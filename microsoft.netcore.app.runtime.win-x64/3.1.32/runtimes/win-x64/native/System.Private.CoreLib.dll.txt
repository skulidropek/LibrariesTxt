public static class Internal.Console : object {
    private static SafeFileHandle _outputHandle;
    private static Console();
    [NullableContextAttribute("1")]
public static void Write(string s);
    [NullableContextAttribute("2")]
public static void WriteLine(string s);
    public static void WriteLine();
}
internal static class Internal.IO.File : object {
    public static bool Exists(string path);
    internal static bool InternalExists(string fullPath);
    internal static int FillAttributeInfo(string path, WIN32_FILE_ATTRIBUTE_DATA& data, bool returnErrorOnNotFound);
}
internal class Internal.PaddingFor32 : ValueType {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Internal.Resources.PRIExceptionInfo : object {
    public string PackageSimpleName;
    public string ResWFile;
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public abstract class Internal.Resources.WindowsRuntimeResourceManagerBase : object {
    [NullableAttribute("2")]
public CultureInfo GlobalResourceContextBestFitCultureInfo { get; }
    public abstract virtual bool Initialize(string libpath, string reswFilename, PRIExceptionInfo& exceptionInfo);
    public abstract virtual string GetString(string stringName, string startingCulture, string neutralResourcesCulture);
    [NullableContextAttribute("2")]
public abstract virtual CultureInfo get_GlobalResourceContextBestFitCultureInfo();
    public abstract virtual bool SetGlobalResourceContextDefaultCulture(CultureInfo ci);
    [NullableContextAttribute("2")]
public static bool IsValidCulture(string cultureName);
}
[NullableAttribute("0")]
[CLSCompliantAttribute("False")]
[NullableContextAttribute("1")]
public static class Internal.Runtime.CompilerServices.Unsafe : object {
    [NullableContextAttribute("0")]
[IntrinsicAttribute]
[NonVersionableAttribute]
public static Void* AsPointer(T& value);
    [NonVersionableAttribute]
[NullableContextAttribute("2")]
[IntrinsicAttribute]
public static int SizeOf();
    [NonVersionableAttribute]
[IntrinsicAttribute]
[NullableContextAttribute("2")]
public static T As(object value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static TTo& As(TFrom& source);
    [NonVersionableAttribute]
[IntrinsicAttribute]
public static T& Add(T& source, int elementOffset);
    [NonVersionableAttribute]
[IntrinsicAttribute]
public static T& Add(T& source, IntPtr elementOffset);
    [NullableContextAttribute("0")]
[IntrinsicAttribute]
[NonVersionableAttribute]
public static Void* Add(Void* source, int elementOffset);
    [IntrinsicAttribute]
[NonVersionableAttribute]
internal static T& AddByteOffset(T& source, ulong byteOffset);
    [NonVersionableAttribute]
[IntrinsicAttribute]
public static bool AreSame(T& left, T& right);
    [NonVersionableAttribute]
[IntrinsicAttribute]
public static bool IsAddressGreaterThan(T& left, T& right);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static bool IsAddressLessThan(T& left, T& right);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static void InitBlockUnaligned(Byte& startAddress, byte value, UInt32 byteCount);
    [NullableContextAttribute("0")]
[IntrinsicAttribute]
[NonVersionableAttribute]
public static T ReadUnaligned(Void* source);
    [NonVersionableAttribute]
[IntrinsicAttribute]
public static T ReadUnaligned(Byte& source);
    [NonVersionableAttribute]
[IntrinsicAttribute]
[NullableContextAttribute("0")]
public static void WriteUnaligned(Void* destination, T value);
    [NonVersionableAttribute]
[IntrinsicAttribute]
public static void WriteUnaligned(Byte& destination, T value);
    [NonVersionableAttribute]
[IntrinsicAttribute]
public static T& AddByteOffset(T& source, IntPtr byteOffset);
    [NonVersionableAttribute]
[NullableContextAttribute("0")]
[IntrinsicAttribute]
public static T Read(Void* source);
    [NonVersionableAttribute]
[IntrinsicAttribute]
public static T Read(Byte& source);
    [IntrinsicAttribute]
[NonVersionableAttribute]
[NullableContextAttribute("0")]
public static void Write(Void* destination, T value);
    [NonVersionableAttribute]
[IntrinsicAttribute]
public static void Write(Byte& destination, T value);
    [IntrinsicAttribute]
[NullableContextAttribute("0")]
[NonVersionableAttribute]
public static T& AsRef(Void* source);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static T& AsRef(T& source);
    [NonVersionableAttribute]
[IntrinsicAttribute]
public static IntPtr ByteOffset(T& origin, T& target);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class Internal.Runtime.InteropServices.ComActivationContext : ValueType {
    public Guid ClassId;
    public Guid InterfaceId;
    public string AssemblyPath;
    public string AssemblyName;
    public string TypeName;
    [CLSCompliantAttribute("False")]
public static ComActivationContext Create(ComActivationContextInternal& cxtInt);
}
[CLSCompliantAttribute("False")]
public class Internal.Runtime.InteropServices.ComActivationContextInternal : ValueType {
    public Guid ClassId;
    public Guid InterfaceId;
    public Char* AssemblyPathBuffer;
    public Char* AssemblyNameBuffer;
    public Char* TypeNameBuffer;
    public IntPtr ClassFactoryDest;
}
public static class Internal.Runtime.InteropServices.ComActivator : object {
    private static Dictionary`2<string, AssemblyLoadContext> s_assemblyLoadContexts;
    private static ComActivator();
    [NullableContextAttribute("1")]
public static object GetClassFactoryForType(ComActivationContext cxt);
    public static void ClassRegistrationScenarioForType(ComActivationContext cxt, bool register);
    [CLSCompliantAttribute("False")]
public static int GetClassFactoryForTypeInternal(ComActivationContextInternal& cxtInt);
    [CLSCompliantAttribute("False")]
public static int RegisterClassForTypeInternal(ComActivationContextInternal& cxtInt);
    [CLSCompliantAttribute("False")]
public static int UnregisterClassForTypeInternal(ComActivationContextInternal& cxtInt);
    private static bool IsLoggingEnabled();
    private static void Log(string fmt, Object[] args);
    private static Type FindClassType(Guid clsid, string assemblyPath, string assemblyName, string typeName);
    private static AssemblyLoadContext GetALC(string assemblyPath);
}
public static class Internal.Runtime.InteropServices.ComponentActivator : object {
    private static Dictionary`2<string, IsolatedComponentLoadContext> s_assemblyLoadContexts;
    private static Dictionary`2<IntPtr, Delegate> s_delegates;
    private static ComponentActivator();
    private static string MarshalToString(IntPtr arg, string argName);
    public static int LoadAssemblyAndGetFunctionPointer(IntPtr assemblyPathNative, IntPtr typeNameNative, IntPtr methodNameNative, IntPtr delegateTypeNative, IntPtr reserved, IntPtr functionHandle);
    private static Delegate CreateDelegate(string assemblyPath, string typeName, string methodName, string delegateTypeName);
    private static IsolatedComponentLoadContext GetIsolatedComponentLoadContext(string assemblyPath);
}
[NullableContextAttribute("2")]
[ComVisibleAttribute("False")]
[InterfaceTypeAttribute("1")]
[GuidAttribute("00000001-0000-0000-C000-000000000046")]
public interface Internal.Runtime.InteropServices.IClassFactory {
    public abstract virtual void CreateInstance(object pUnkOuter, Guid& riid, IntPtr& ppvObject);
    public abstract virtual void LockServer(bool fLock);
}
[GuidAttribute("B196B28F-BAB4-101A-B69C-00AA00341D07")]
[ComVisibleAttribute("False")]
[InterfaceTypeAttribute("1")]
internal interface Internal.Runtime.InteropServices.IClassFactory2 {
    public abstract virtual void CreateInstance(object pUnkOuter, Guid& riid, IntPtr& ppvObject);
    public abstract virtual void LockServer(bool fLock);
    public abstract virtual void GetLicInfo(LICINFO& pLicInfo);
    public abstract virtual void RequestLicKey(int dwReserved, String& pBstrKey);
    public abstract virtual void CreateInstanceLic(object pUnkOuter, object pUnkReserved, Guid& riid, string bstrKey, IntPtr& ppvObject);
}
public static class Internal.Runtime.InteropServices.InMemoryAssemblyLoader : object {
    public static void LoadInMemoryAssembly(IntPtr moduleHandle, IntPtr assemblyPath);
}
internal class Internal.Runtime.InteropServices.IsolatedComponentLoadContext : AssemblyLoadContext {
    private AssemblyDependencyResolver _resolver;
    public IsolatedComponentLoadContext(string componentAssemblyPath);
    protected virtual Assembly Load(AssemblyName assemblyName);
    protected virtual IntPtr LoadUnmanagedDll(string unmanagedDllName);
}
internal class Internal.Runtime.InteropServices.LicenseInteropProxy : object {
    private static Type s_licenseAttrType;
    private static Type s_licenseExceptionType;
    private MethodInfo _createWithContext;
    private MethodInfo _validateTypeAndReturnDetails;
    private MethodInfo _getCurrentContextInfo;
    private MethodInfo _createDesignContext;
    private MethodInfo _createRuntimeContext;
    private MethodInfo _setSavedLicenseKey;
    private Type _licInfoHelper;
    private MethodInfo _licInfoHelperContains;
    private object _licContext;
    private Type _targetRcwType;
    private static LicenseInteropProxy();
    public static object Create();
    public static bool HasLicense(Type type);
    public void GetLicInfo(Type type, Boolean& runtimeKeyAvail, Boolean& licVerified);
    public string RequestLicKey(Type type);
    public object AllocateAndValidateLicense(Type type, string key, bool isDesignTime);
    public void GetCurrentContextInfo(RuntimeTypeHandle rth, Boolean& isDesignTime, IntPtr& bstrKey);
    public void SaveKeyInCurrentContext(IntPtr bstrKey);
}
internal class Internal.Runtime.InteropServices.LICINFO : ValueType {
    public int cbLicInfo;
    public bool fRuntimeKeyAvail;
    public bool fLicVerified;
}
internal static class Internal.Runtime.InteropServices.WindowsRuntime.ActivationFactoryLoader : object {
    private static Dictionary`2<string, AssemblyLoadContext> s_assemblyLoadContexts;
    private static ActivationFactoryLoader();
    private static AssemblyLoadContext GetALC(string assemblyPath);
    public static int GetActivationFactory(Char* componentPath, string typeName, IActivationFactory& activationFactory);
}
[NullableAttribute("0")]
[NullableContextAttribute("2")]
public static class Internal.Runtime.InteropServices.WindowsRuntime.ExceptionSupport : object {
    public static Exception AttachRestrictedErrorInfo(Exception e);
    public static bool ReportUnhandledError(Exception ex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Internal.Threading.Tasks.AsyncCausalitySupport : object {
    public static bool LoggingOn { get; }
    public static void AddToActiveTasks(Task task);
    public static void RemoveFromActiveTasks(Task task);
    public static bool get_LoggingOn();
    public static void TraceOperationCreation(Task task, string operationName);
    public static void TraceOperationCompletedSuccess(Task task);
    public static void TraceOperationCompletedError(Task task);
}
internal static class Internal.Win32.Registry : object {
    public static RegistryKey CurrentUser;
    public static RegistryKey LocalMachine;
    private static Registry();
}
internal class Internal.Win32.RegistryKey : object {
    private SafeRegistryHandle _hkey;
    private RegistryKey(SafeRegistryHandle hkey);
    private sealed virtual override void System.IDisposable.Dispose();
    public void DeleteValue(string name, bool throwOnMissingValue);
    internal static RegistryKey OpenBaseKey(IntPtr hKey);
    public RegistryKey OpenSubKey(string name);
    public RegistryKey OpenSubKey(string name, bool writable);
    public String[] GetSubKeyNames();
    public String[] GetValueNames();
    public object GetValue(string name);
    public object GetValue(string name, object defaultValue);
    internal void SetValue(string name, string value);
    internal void Win32Error(int errorCode, string str);
}
internal class Internal.Win32.SafeHandles.SafeRegistryHandle : SafeHandleZeroOrMinusOneIsInvalid {
    public SafeRegistryHandle(IntPtr preexistingHandle, bool ownsHandle);
    protected virtual bool ReleaseHandle();
}
internal static class Interop : object {
    internal static void GetRandomBytes(Byte* buffer, int length);
    internal static UInt32 GetCurrentProcessId();
}
[EmbeddedAttribute]
[CompilerGeneratedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[ExtensionAttribute]
internal static class Microsoft.Reflection.ReflectionExtensions : object {
    [ExtensionAttribute]
public static bool IsEnum(Type type);
    [ExtensionAttribute]
public static bool IsAbstract(Type type);
    [ExtensionAttribute]
public static bool IsSealed(Type type);
    [ExtensionAttribute]
public static bool IsValueType(Type type);
    [ExtensionAttribute]
public static bool IsGenericType(Type type);
    [ExtensionAttribute]
public static Type BaseType(Type type);
    [ExtensionAttribute]
public static Assembly Assembly(Type type);
    [ExtensionAttribute]
public static TypeCode GetTypeCode(Type type);
    [ExtensionAttribute]
public static bool ReflectionOnly(Assembly assm);
}
internal static class Microsoft.Win32.OAVariantLib : object {
    internal static Type[] ClassTypes;
    private static OAVariantLib();
    internal static Variant ChangeType(Variant source, Type targetClass, short options, CultureInfo culture);
    private static int GetCVTypeFromClass(Type ctype);
    private static void ChangeTypeEx(Variant& result, Variant& source, int lcid, IntPtr typeHandle, int cvType, short flags);
}
public abstract class Microsoft.Win32.SafeHandles.CriticalHandleMinusOneIsInvalid : CriticalHandle {
    public bool IsInvalid { get; }
    public virtual bool get_IsInvalid();
}
public abstract class Microsoft.Win32.SafeHandles.CriticalHandleZeroOrMinusOneIsInvalid : CriticalHandle {
    public bool IsInvalid { get; }
    public virtual bool get_IsInvalid();
}
public class Microsoft.Win32.SafeHandles.SafeFileHandle : SafeHandleZeroOrMinusOneIsInvalid {
    private Nullable`1<bool> _isAsync;
    [CompilerGeneratedAttribute]
private ThreadPoolBoundHandle <ThreadPoolBinding>k__BackingField;
    internal Nullable`1<bool> IsAsync { get; internal set; }
    [NullableAttribute("2")]
internal ThreadPoolBoundHandle ThreadPoolBinding { get; internal set; }
    public SafeFileHandle(IntPtr preexistingHandle, bool ownsHandle);
    internal Nullable`1<bool> get_IsAsync();
    internal void set_IsAsync(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
internal ThreadPoolBoundHandle get_ThreadPoolBinding();
    [CompilerGeneratedAttribute]
internal void set_ThreadPoolBinding(ThreadPoolBoundHandle value);
    protected virtual bool ReleaseHandle();
}
internal class Microsoft.Win32.SafeHandles.SafeFindHandle : SafeHandleZeroOrMinusOneIsInvalid {
    protected virtual bool ReleaseHandle();
}
public abstract class Microsoft.Win32.SafeHandles.SafeHandleMinusOneIsInvalid : SafeHandle {
    public bool IsInvalid { get; }
    protected SafeHandleMinusOneIsInvalid(bool ownsHandle);
    public virtual bool get_IsInvalid();
}
public abstract class Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid : SafeHandle {
    public bool IsInvalid { get; }
    protected SafeHandleZeroOrMinusOneIsInvalid(bool ownsHandle);
    public virtual bool get_IsInvalid();
}
internal class Microsoft.Win32.SafeHandles.SafeLibraryHandle : SafeHandleZeroOrMinusOneIsInvalid {
    protected virtual bool ReleaseHandle();
}
public class Microsoft.Win32.SafeHandles.SafeWaitHandle : SafeHandleZeroOrMinusOneIsInvalid {
    public SafeWaitHandle(IntPtr existingHandle, bool ownsHandle);
    protected virtual bool ReleaseHandle();
}
internal static class Microsoft.Win32.UnsafeNativeMethods : object {
    internal static int RoGetActivationFactory(string activatableClassId, Guid& iid, Object& factory);
}
[ComVisibleAttribute("True")]
[ClassInterfaceAttribute("0")]
internal class System.__Canon : object {
}
internal class System.__ComObject : MarshalByRefObject {
    private Hashtable m_ObjectToDataMap;
    public virtual string ToString();
    internal object GetData(object key);
    internal bool SetData(object key, object data);
    internal void ReleaseAllData();
    internal object GetEventProvider(RuntimeType t);
    internal int ReleaseSelf();
    internal void FinalReleaseSelf();
    private object CreateEventProvider(RuntimeType t);
}
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[IsByRefLikeAttribute]
internal class System.__DTString : ValueType {
    internal ReadOnlySpan`1<char> Value;
    internal int Index;
    internal char m_current;
    private CompareInfo m_info;
    private bool m_checkDigitToken;
    private static Char[] WhiteSpaceChecks;
    internal int Length { get; }
    internal CompareInfo CompareInfo { get; }
    internal __DTString(ReadOnlySpan`1<char> str, DateTimeFormatInfo dtfi, bool checkDigitToken);
    internal __DTString(ReadOnlySpan`1<char> str, DateTimeFormatInfo dtfi);
    private static __DTString();
    internal int get_Length();
    internal CompareInfo get_CompareInfo();
    internal bool GetNext();
    internal bool AtEnd();
    internal bool Advance(int count);
    internal void GetRegularToken(TokenType& tokenType, Int32& tokenValue, DateTimeFormatInfo dtfi);
    internal TokenType GetSeparatorToken(DateTimeFormatInfo dtfi, Int32& indexBeforeSeparator, Char& charBeforeSeparator);
    internal bool MatchSpecifiedWord(string target);
    internal bool MatchSpecifiedWords(string target, bool checkWordBoundary, Int32& matchLength);
    internal bool Match(string str);
    internal bool Match(char ch);
    internal int MatchLongestWords(String[] words, Int32& maxMatchStrLen);
    internal int GetRepeatCount();
    internal bool GetNextDigit();
    internal char GetChar();
    internal int GetDigit();
    internal void SkipWhiteSpaces();
    internal bool SkipWhiteSpaceCurrent();
    internal void TrimTail();
    internal void RemoveTrailingInQuoteSpaces();
    internal void RemoveLeadingInQuoteSpaces();
    internal DTSubString GetSubString();
    internal void ConsumeSubString(DTSubString sub);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableAttribute("0")]
[NullableContextAttribute("2")]
public class System.AccessViolationException : SystemException {
    private IntPtr _ip;
    private IntPtr _target;
    private int _accessType;
    public AccessViolationException(string message);
    public AccessViolationException(string message, Exception innerException);
    [NullableContextAttribute("1")]
protected AccessViolationException(SerializationInfo info, StreamingContext context);
}
public class System.Action : MulticastDelegate {
    public Action(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`1 : MulticastDelegate {
    public Action`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(T obj);
    public virtual IAsyncResult BeginInvoke(T obj, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`2 : MulticastDelegate {
    public Action`2(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(T1 arg1, T2 arg2);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`3 : MulticastDelegate {
    public Action`3(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Action`4 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Action`4(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Action`5 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Action`5(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual void EndInvoke(IAsyncResult result);
}
[NullableAttribute("0")]
[NullableContextAttribute("2")]
public class System.Action`6 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Action`6(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Action`7 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Action`7(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual void EndInvoke(IAsyncResult result);
}
[NullableAttribute("0")]
[NullableContextAttribute("2")]
public class System.Action`8 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Action`8(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Activator : object {
    [DebuggerStepThroughAttribute]
[NullableContextAttribute("2")]
[DebuggerHiddenAttribute]
public static object CreateInstance(Type type, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
[NullableContextAttribute("2")]
public static object CreateInstance(Type type, Object[] args);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
[NullableContextAttribute("2")]
public static object CreateInstance(Type type, Object[] args, Object[] activationAttributes);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public static object CreateInstance(Type type);
    public static ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName);
    public static ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, Object[] activationAttributes);
    [NullableContextAttribute("2")]
public static ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    [NullableContextAttribute("2")]
public static object CreateInstance(Type type, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    public static ObjectHandle CreateInstance(string assemblyName, string typeName);
    [NullableContextAttribute("2")]
public static ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    public static ObjectHandle CreateInstance(string assemblyName, string typeName, Object[] activationAttributes);
    public static object CreateInstance(Type type, bool nonPublic);
    internal static object CreateInstance(Type type, bool nonPublic, bool wrapExceptions);
    private static ObjectHandle CreateInstanceInternal(string assemblyString, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, StackCrawlMark& stackMark);
    public static T CreateInstance();
    private static T CreateDefaultInstance();
}
[DebuggerDisplayAttribute("Count = {InnerExceptionCount}")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.AggregateException : Exception {
    private ReadOnlyCollection`1<Exception> m_innerExceptions;
    public ReadOnlyCollection`1<Exception> InnerExceptions { get; }
    public string Message { get; }
    private int InnerExceptionCount { get; }
    [NullableContextAttribute("2")]
public AggregateException(string message);
    public AggregateException(string message, Exception innerException);
    public AggregateException(IEnumerable`1<Exception> innerExceptions);
    public AggregateException(Exception[] innerExceptions);
    public AggregateException(string message, IEnumerable`1<Exception> innerExceptions);
    public AggregateException(string message, Exception[] innerExceptions);
    private AggregateException(string message, IList`1<Exception> innerExceptions);
    internal AggregateException(IEnumerable`1<ExceptionDispatchInfo> innerExceptionInfos);
    internal AggregateException(string message, IEnumerable`1<ExceptionDispatchInfo> innerExceptionInfos);
    private AggregateException(string message, IList`1<ExceptionDispatchInfo> innerExceptionInfos);
    protected AggregateException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual Exception GetBaseException();
    public ReadOnlyCollection`1<Exception> get_InnerExceptions();
    public void Handle(Func`2<Exception, bool> predicate);
    public AggregateException Flatten();
    public virtual string get_Message();
    public virtual string ToString();
    private int get_InnerExceptionCount();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class System.AppContext : object {
    private static Dictionary`2<string, object> s_dataStore;
    private static Dictionary`2<string, bool> s_switches;
    private static string s_defaultBaseDirectory;
    [CompilerGeneratedAttribute]
private static UnhandledExceptionEventHandler UnhandledException;
    [CompilerGeneratedAttribute]
private static EventHandler`1<FirstChanceExceptionEventArgs> FirstChanceException;
    [CompilerGeneratedAttribute]
private static EventHandler ProcessExit;
    [NullableAttribute("1")]
public static string BaseDirectory { get; }
    public static string TargetFrameworkName { get; }
    private static AppContext();
    internal static void Setup(Char** pNames, Char** pValues, int count);
    private static string GetBaseDirectoryCore();
    [NullableContextAttribute("1")]
public static string get_BaseDirectory();
    public static string get_TargetFrameworkName();
    [NullableContextAttribute("1")]
public static object GetData(string name);
    [NullableContextAttribute("1")]
public static void SetData(string name, object data);
    [CompilerGeneratedAttribute]
public static void add_UnhandledException(UnhandledExceptionEventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_UnhandledException(UnhandledExceptionEventHandler value);
    [CompilerGeneratedAttribute]
public static void add_FirstChanceException(EventHandler`1<FirstChanceExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_FirstChanceException(EventHandler`1<FirstChanceExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public static void add_ProcessExit(EventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_ProcessExit(EventHandler value);
    internal static void OnProcessExit();
    [NullableContextAttribute("1")]
public static bool TryGetSwitch(string switchName, Boolean& isEnabled);
    [NullableContextAttribute("1")]
public static void SetSwitch(string switchName, bool isEnabled);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.AppDomain : MarshalByRefObject {
    private static AppDomain s_domain;
    private object _forLock;
    private IPrincipal _defaultPrincipal;
    private PrincipalPolicy _principalPolicy;
    private Func`1<IPrincipal> s_getWindowsPrincipal;
    private Func`1<IPrincipal> s_getUnauthenticatedPrincipal;
    [CompilerGeneratedAttribute]
private EventHandler DomainUnload;
    [CompilerGeneratedAttribute]
private ResolveEventHandler ReflectionOnlyAssemblyResolve;
    [NullableAttribute("1")]
public static AppDomain CurrentDomain { get; }
    public string BaseDirectory { get; }
    public string RelativeSearchPath { get; }
    [NullableAttribute("1")]
public AppDomainSetup SetupInformation { get; }
    [NullableAttribute("1")]
public PermissionSet PermissionSet { get; }
    public string DynamicDirectory { get; }
    [NullableAttribute("1")]
public string FriendlyName { get; }
    public int Id { get; }
    public bool IsFullyTrusted { get; }
    public bool IsHomogenous { get; }
    public static bool MonitoringIsEnabled { get; public set; }
    public long MonitoringSurvivedMemorySize { get; }
    public static long MonitoringSurvivedProcessMemorySize { get; }
    public long MonitoringTotalAllocatedMemorySize { get; }
    public bool ShadowCopyFiles { get; }
    public TimeSpan MonitoringTotalProcessorTime { get; }
    private static AppDomain();
    [NullableContextAttribute("1")]
public static AppDomain get_CurrentDomain();
    public string get_BaseDirectory();
    public string get_RelativeSearchPath();
    [NullableContextAttribute("1")]
public AppDomainSetup get_SetupInformation();
    [NullableContextAttribute("1")]
public PermissionSet get_PermissionSet();
    public void add_UnhandledException(UnhandledExceptionEventHandler value);
    public void remove_UnhandledException(UnhandledExceptionEventHandler value);
    public string get_DynamicDirectory();
    [ObsoleteAttribute("AppDomain.SetDynamicBase has been deprecated. Please investigate the use of AppDomainSetup.DynamicBase instead. https://go.microsoft.com/fwlink/?linkid=14202")]
public void SetDynamicBase(string path);
    [NullableContextAttribute("1")]
public string get_FriendlyName();
    public int get_Id();
    public bool get_IsFullyTrusted();
    public bool get_IsHomogenous();
    [CompilerGeneratedAttribute]
public void add_DomainUnload(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_DomainUnload(EventHandler value);
    public void add_FirstChanceException(EventHandler`1<FirstChanceExceptionEventArgs> value);
    public void remove_FirstChanceException(EventHandler`1<FirstChanceExceptionEventArgs> value);
    public void add_ProcessExit(EventHandler value);
    public void remove_ProcessExit(EventHandler value);
    [NullableContextAttribute("1")]
public string ApplyPolicy(string assemblyName);
    [NullableContextAttribute("1")]
public static AppDomain CreateDomain(string friendlyName);
    [NullableContextAttribute("1")]
public int ExecuteAssembly(string assemblyFile);
    [NullableContextAttribute("1")]
public int ExecuteAssembly(string assemblyFile, String[] args);
    public int ExecuteAssembly(string assemblyFile, String[] args, Byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm);
    private int ExecuteAssembly(Assembly assembly, String[] args);
    [NullableContextAttribute("1")]
public int ExecuteAssemblyByName(AssemblyName assemblyName, String[] args);
    [NullableContextAttribute("1")]
public int ExecuteAssemblyByName(string assemblyName);
    [NullableContextAttribute("1")]
public int ExecuteAssemblyByName(string assemblyName, String[] args);
    [NullableContextAttribute("1")]
public object GetData(string name);
    [NullableContextAttribute("1")]
public void SetData(string name, object data);
    [NullableContextAttribute("1")]
public Nullable`1<bool> IsCompatibilitySwitchSet(string value);
    public bool IsDefaultAppDomain();
    public bool IsFinalizingForUnload();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public static void Unload(AppDomain domain);
    [NullableContextAttribute("1")]
public Assembly Load(Byte[] rawAssembly);
    [NullableContextAttribute("1")]
public Assembly Load(Byte[] rawAssembly, Byte[] rawSymbolStore);
    [NullableContextAttribute("1")]
public Assembly Load(AssemblyName assemblyRef);
    [NullableContextAttribute("1")]
public Assembly Load(string assemblyString);
    [NullableContextAttribute("1")]
public Assembly[] ReflectionOnlyGetAssemblies();
    public static bool get_MonitoringIsEnabled();
    public static void set_MonitoringIsEnabled(bool value);
    public long get_MonitoringSurvivedMemorySize();
    public static long get_MonitoringSurvivedProcessMemorySize();
    public long get_MonitoringTotalAllocatedMemorySize();
    [ObsoleteAttribute("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.  https://go.microsoft.com/fwlink/?linkid=14202", "False")]
public static int GetCurrentThreadId();
    public bool get_ShadowCopyFiles();
    [ObsoleteAttribute("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. https://go.microsoft.com/fwlink/?linkid=14202")]
public void AppendPrivatePath(string path);
    [ObsoleteAttribute("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. https://go.microsoft.com/fwlink/?linkid=14202")]
public void ClearPrivatePath();
    [ObsoleteAttribute("AppDomain.ClearShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. https://go.microsoft.com/fwlink/?linkid=14202")]
public void ClearShadowCopyPath();
    [ObsoleteAttribute("AppDomain.SetCachePath has been deprecated. Please investigate the use of AppDomainSetup.CachePath instead. https://go.microsoft.com/fwlink/?linkid=14202")]
public void SetCachePath(string path);
    [ObsoleteAttribute("AppDomain.SetShadowCopyFiles has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyFiles instead. https://go.microsoft.com/fwlink/?linkid=14202")]
public void SetShadowCopyFiles();
    [ObsoleteAttribute("AppDomain.SetShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. https://go.microsoft.com/fwlink/?linkid=14202")]
public void SetShadowCopyPath(string path);
    [NullableContextAttribute("1")]
public Assembly[] GetAssemblies();
    public void add_AssemblyLoad(AssemblyLoadEventHandler value);
    public void remove_AssemblyLoad(AssemblyLoadEventHandler value);
    public void add_AssemblyResolve(ResolveEventHandler value);
    public void remove_AssemblyResolve(ResolveEventHandler value);
    [CompilerGeneratedAttribute]
public void add_ReflectionOnlyAssemblyResolve(ResolveEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ReflectionOnlyAssemblyResolve(ResolveEventHandler value);
    public void add_TypeResolve(ResolveEventHandler value);
    public void remove_TypeResolve(ResolveEventHandler value);
    public void add_ResourceResolve(ResolveEventHandler value);
    public void remove_ResourceResolve(ResolveEventHandler value);
    public void SetPrincipalPolicy(PrincipalPolicy policy);
    [NullableContextAttribute("1")]
public void SetThreadPrincipal(IPrincipal principal);
    [NullableContextAttribute("1")]
public ObjectHandle CreateInstance(string assemblyName, string typeName);
    public ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    [NullableContextAttribute("1")]
public ObjectHandle CreateInstance(string assemblyName, string typeName, Object[] activationAttributes);
    [NullableContextAttribute("1")]
public object CreateInstanceAndUnwrap(string assemblyName, string typeName);
    public object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    [NullableContextAttribute("1")]
public object CreateInstanceAndUnwrap(string assemblyName, string typeName, Object[] activationAttributes);
    [NullableContextAttribute("1")]
public ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName);
    public ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    [NullableContextAttribute("1")]
public ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, Object[] activationAttributes);
    [NullableContextAttribute("1")]
public object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName);
    public object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    [NullableContextAttribute("1")]
public object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName, Object[] activationAttributes);
    internal IPrincipal GetThreadPrincipal();
    public TimeSpan get_MonitoringTotalProcessorTime();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.AppDomainSetup : object {
    public string ApplicationBase { get; }
    public string TargetFrameworkName { get; }
    public string get_ApplicationBase();
    public string get_TargetFrameworkName();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ApplicationException : Exception {
    public ApplicationException(string message);
    public ApplicationException(string message, Exception innerException);
    [NullableContextAttribute("1")]
protected ApplicationException(SerializationInfo info, StreamingContext context);
}
internal static class System.ApplicationModel : object {
    internal static bool IsUap;
    private static ApplicationModel();
    private static BOOL IsAppXProcess();
}
[IsByRefLikeAttribute]
public class System.ArgIterator : ValueType {
    private IntPtr ArgCookie;
    private IntPtr sigPtr;
    private IntPtr sigPtrLen;
    private IntPtr ArgPtr;
    private int RemainingArgs;
    private ArgIterator(IntPtr arglist);
    public ArgIterator(RuntimeArgumentHandle arglist);
    private ArgIterator(IntPtr arglist, Void* ptr);
    [CLSCompliantAttribute("False")]
public ArgIterator(RuntimeArgumentHandle arglist, Void* ptr);
    [CLSCompliantAttribute("False")]
public TypedReference GetNextArg();
    private void FCallGetNextArg(Void* result);
    [CLSCompliantAttribute("False")]
public TypedReference GetNextArg(RuntimeTypeHandle rth);
    private void InternalGetNextArg(Void* result, RuntimeType rt);
    public void End();
    public int GetRemainingCount();
    private Void* _GetNextArgType();
    public RuntimeTypeHandle GetNextArgType();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object o);
}
[NullableContextAttribute("2")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableAttribute("0")]
public class System.ArgumentException : SystemException {
    private string _paramName;
    [NullableAttribute("1")]
public string Message { get; }
    public string ParamName { get; }
    public ArgumentException(string message);
    public ArgumentException(string message, Exception innerException);
    public ArgumentException(string message, string paramName, Exception innerException);
    public ArgumentException(string message, string paramName);
    [NullableContextAttribute("1")]
protected ArgumentException(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("1")]
public virtual string get_Message();
    private void SetMessageField();
    public virtual string get_ParamName();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.ArgumentNullException : ArgumentException {
    public ArgumentNullException(string paramName);
    public ArgumentNullException(string message, Exception innerException);
    public ArgumentNullException(string paramName, string message);
    [NullableContextAttribute("1")]
protected ArgumentNullException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableAttribute("0")]
[NullableContextAttribute("2")]
public class System.ArgumentOutOfRangeException : ArgumentException {
    private object _actualValue;
    [NullableAttribute("1")]
public string Message { get; }
    public object ActualValue { get; }
    public ArgumentOutOfRangeException(string paramName);
    public ArgumentOutOfRangeException(string paramName, string message);
    public ArgumentOutOfRangeException(string message, Exception innerException);
    public ArgumentOutOfRangeException(string paramName, object actualValue, string message);
    [NullableContextAttribute("1")]
protected ArgumentOutOfRangeException(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("1")]
public virtual string get_Message();
    public virtual object get_ActualValue();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ArithmeticException : SystemException {
    public ArithmeticException(string message);
    public ArithmeticException(string message, Exception innerException);
    [NullableContextAttribute("1")]
protected ArithmeticException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public abstract class System.Array : object {
    public int Length { get; }
    public long LongLength { get; }
    public int Rank { get; }
    private int System.Collections.ICollection.Count { get; }
    public object SyncRoot { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public bool IsSynchronized { get; }
    [NullableAttribute("2")]
private object System.Collections.IList.Item { get; private set; }
    public static Array CreateInstance(Type elementType, int length);
    public static Array CreateInstance(Type elementType, int length1, int length2);
    public static Array CreateInstance(Type elementType, int length1, int length2, int length3);
    public static Array CreateInstance(Type elementType, Int32[] lengths);
    public static Array CreateInstance(Type elementType, Int32[] lengths, Int32[] lowerBounds);
    private static Array InternalCreate(Void* elementType, int rank, Int32* pLengths, Int32* pLowerBounds);
    public static void Copy(Array sourceArray, Array destinationArray, int length);
    public static void Copy(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);
    internal static void Copy(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length, bool reliable);
    public static void ConstrainedCopy(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);
    public static void Clear(Array array, int index, int length);
    private static Byte& GetRawArrayGeometry(Array array, UInt32& numComponents, UInt32& elementSize, Int32& lowerBound, Boolean& containsGCPointers);
    public object GetValue(Int32[] indices);
    [NullableContextAttribute("2")]
public object GetValue(int index);
    [NullableContextAttribute("2")]
public object GetValue(int index1, int index2);
    [NullableContextAttribute("2")]
public object GetValue(int index1, int index2, int index3);
    [NullableContextAttribute("2")]
public void SetValue(object value, int index);
    [NullableContextAttribute("2")]
public void SetValue(object value, int index1, int index2);
    [NullableContextAttribute("2")]
public void SetValue(object value, int index1, int index2, int index3);
    public void SetValue(object value, Int32[] indices);
    private static void SortImpl(Array keys, Array items, int index, int length, IComparer comparer);
    private void InternalGetReference(Void* elemRef, int rank, Int32* pIndices);
    private static void InternalSetValue(Void* target, object value);
    public int get_Length();
    public long get_LongLength();
    public int GetLength(int dimension);
    public int get_Rank();
    public int GetUpperBound(int dimension);
    public int GetLowerBound(int dimension);
    internal Byte& GetRawArrayData();
    internal int GetElementSize();
    private static bool TrySZBinarySearch(Array sourceArray, int sourceIndex, int count, object value, Int32& retVal);
    private static bool TrySZIndexOf(Array sourceArray, int sourceIndex, int count, object value, Int32& retVal);
    private static bool TrySZLastIndexOf(Array sourceArray, int sourceIndex, int count, object value, Int32& retVal);
    private static bool TrySZReverse(Array array, int index, int count);
    private static bool TrySZSort(Array keys, Array items, int left, int right);
    public void Initialize();
    public static ReadOnlyCollection`1<T> AsReadOnly(T[] array);
    [NullableContextAttribute("2")]
public static void Resize(T[]& array, int newSize);
    public static Array CreateInstance(Type elementType, Int64[] lengths);
    public static void Copy(Array sourceArray, Array destinationArray, long length);
    public static void Copy(Array sourceArray, long sourceIndex, Array destinationArray, long destinationIndex, long length);
    [NullableContextAttribute("2")]
public object GetValue(long index);
    [NullableContextAttribute("2")]
public object GetValue(long index1, long index2);
    [NullableContextAttribute("2")]
public object GetValue(long index1, long index2, long index3);
    public object GetValue(Int64[] indices);
    [NullableContextAttribute("2")]
public void SetValue(object value, long index);
    [NullableContextAttribute("2")]
public void SetValue(object value, long index1, long index2);
    [NullableContextAttribute("2")]
public void SetValue(object value, long index1, long index2, long index3);
    public void SetValue(object value, Int64[] indices);
    private static int GetMedian(int low, int hi);
    public long GetLongLength(int dimension);
    private sealed virtual override int System.Collections.ICollection.get_Count();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsSynchronized();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    public sealed virtual object Clone();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private static int CombineHashCodes(int h1, int h2);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    public static int BinarySearch(Array array, object value);
    public static int BinarySearch(Array array, int index, int length, object value);
    [NullableContextAttribute("2")]
public static int BinarySearch(Array array, object value, IComparer comparer);
    [NullableContextAttribute("2")]
public static int BinarySearch(Array array, int index, int length, object value, IComparer comparer);
    public static int BinarySearch(T[] array, T value);
    public static int BinarySearch(T[] array, T value, IComparer`1<T> comparer);
    public static int BinarySearch(T[] array, int index, int length, T value);
    public static int BinarySearch(T[] array, int index, int length, T value, IComparer`1<T> comparer);
    public static TOutput[] ConvertAll(TInput[] array, Converter`2<TInput, TOutput> converter);
    public sealed virtual void CopyTo(Array array, int index);
    public void CopyTo(Array array, long index);
    public static T[] Empty();
    public static bool Exists(T[] array, Predicate`1<T> match);
    public static void Fill(T[] array, T value);
    public static void Fill(T[] array, T value, int startIndex, int count);
    public static T Find(T[] array, Predicate`1<T> match);
    public static T[] FindAll(T[] array, Predicate`1<T> match);
    public static int FindIndex(T[] array, Predicate`1<T> match);
    public static int FindIndex(T[] array, int startIndex, Predicate`1<T> match);
    public static int FindIndex(T[] array, int startIndex, int count, Predicate`1<T> match);
    public static T FindLast(T[] array, Predicate`1<T> match);
    public static int FindLastIndex(T[] array, Predicate`1<T> match);
    public static int FindLastIndex(T[] array, int startIndex, Predicate`1<T> match);
    public static int FindLastIndex(T[] array, int startIndex, int count, Predicate`1<T> match);
    public static void ForEach(T[] array, Action`1<T> action);
    public static int IndexOf(Array array, object value);
    public static int IndexOf(Array array, object value, int startIndex);
    public static int IndexOf(Array array, object value, int startIndex, int count);
    public static int IndexOf(T[] array, T value);
    public static int IndexOf(T[] array, T value, int startIndex);
    public static int IndexOf(T[] array, T value, int startIndex, int count);
    public static int LastIndexOf(Array array, object value);
    public static int LastIndexOf(Array array, object value, int startIndex);
    public static int LastIndexOf(Array array, object value, int startIndex, int count);
    public static int LastIndexOf(T[] array, T value);
    public static int LastIndexOf(T[] array, T value, int startIndex);
    public static int LastIndexOf(T[] array, T value, int startIndex, int count);
    public static void Reverse(Array array);
    public static void Reverse(Array array, int index, int length);
    public static void Reverse(T[] array);
    public static void Reverse(T[] array, int index, int length);
    public static void Sort(Array array);
    public static void Sort(Array keys, Array items);
    public static void Sort(Array array, int index, int length);
    public static void Sort(Array keys, Array items, int index, int length);
    public static void Sort(Array array, IComparer comparer);
    [NullableContextAttribute("2")]
public static void Sort(Array keys, Array items, IComparer comparer);
    public static void Sort(Array array, int index, int length, IComparer comparer);
    [NullableContextAttribute("2")]
public static void Sort(Array keys, Array items, int index, int length, IComparer comparer);
    public static void Sort(T[] array);
    [NullableContextAttribute("2")]
public static void Sort(TKey[] keys, TValue[] items);
    public static void Sort(T[] array, int index, int length);
    [NullableContextAttribute("2")]
public static void Sort(TKey[] keys, TValue[] items, int index, int length);
    public static void Sort(T[] array, IComparer`1<T> comparer);
    [NullableContextAttribute("2")]
public static void Sort(TKey[] keys, TValue[] items, IComparer`1<TKey> comparer);
    public static void Sort(T[] array, int index, int length, IComparer`1<T> comparer);
    [NullableContextAttribute("2")]
public static void Sort(TKey[] keys, TValue[] items, int index, int length, IComparer`1<TKey> comparer);
    public static void Sort(T[] array, Comparison`1<T> comparison);
    public static bool TrueForAll(T[] array, Predicate`1<T> match);
    public sealed virtual IEnumerator GetEnumerator();
}
internal class System.ArrayEnumerator : object {
    private Array array;
    private int index;
    private int endIndex;
    private int startIndex;
    private Int32[] _indices;
    private bool _complete;
    public object Current { get; }
    internal ArrayEnumerator(Array array, int index, int count);
    private void IncArray();
    public sealed virtual object Clone();
    public sealed virtual bool MoveNext();
    public sealed virtual object get_Current();
    public sealed virtual void Reset();
}
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[IsReadOnlyAttribute]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableContextAttribute("1")]
public class System.ArraySegment`1 : ValueType {
    [CompilerGeneratedAttribute]
private static ArraySegment`1<T> <Empty>k__BackingField;
    private T[] _array;
    private int _offset;
    private int _count;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ArraySegment`1<T> Empty { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public T[] Array { get; }
    public int Offset { get; }
    public int Count { get; }
    public T Item { get; public set; }
    private T System.Collections.Generic.IList<T>.Item { get; private set; }
    private T System.Collections.Generic.IReadOnlyList<T>.Item { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public ArraySegment`1(T[] array);
    public ArraySegment`1(T[] array, int offset, int count);
    private static ArraySegment`1();
    [CompilerGeneratedAttribute]
public static ArraySegment`1<T> get_Empty();
    public T[] get_Array();
    public int get_Offset();
    public sealed virtual int get_Count();
    public T get_Item(int index);
    public void set_Item(int index, T value);
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    public virtual int GetHashCode();
    public void CopyTo(T[] destination);
    public sealed virtual void CopyTo(T[] destination, int destinationIndex);
    public void CopyTo(ArraySegment`1<T> destination);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public bool Equals(ArraySegment`1<T> obj);
    public ArraySegment`1<T> Slice(int index);
    public ArraySegment`1<T> Slice(int index, int count);
    public T[] ToArray();
    public static bool op_Equality(ArraySegment`1<T> a, ArraySegment`1<T> b);
    public static bool op_Inequality(ArraySegment`1<T> a, ArraySegment`1<T> b);
    public static ArraySegment`1<T> op_Implicit(T[] array);
    private sealed virtual override T System.Collections.Generic.IList<T>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.set_Item(int index, T value);
    private sealed virtual override int System.Collections.Generic.IList<T>.IndexOf(T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override T System.Collections.Generic.IReadOnlyList<T>.get_Item(int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Contains(T item);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private void ThrowInvalidOperationIfDefault();
}
[NullableContextAttribute("2")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableAttribute("0")]
public class System.ArrayTypeMismatchException : SystemException {
    public ArrayTypeMismatchException(string message);
    public ArrayTypeMismatchException(string message, Exception innerException);
    [NullableContextAttribute("1")]
protected ArrayTypeMismatchException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.AssemblyLoadEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Assembly <LoadedAssembly>k__BackingField;
    public Assembly LoadedAssembly { get; }
    public AssemblyLoadEventArgs(Assembly loadedAssembly);
    [CompilerGeneratedAttribute]
public Assembly get_LoadedAssembly();
}
public class System.AssemblyLoadEventHandler : MulticastDelegate {
    public AssemblyLoadEventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender, AssemblyLoadEventArgs args);
    public virtual IAsyncResult BeginInvoke(object sender, AssemblyLoadEventArgs args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.AsyncCallback : MulticastDelegate {
    public AsyncCallback(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(IAsyncResult ar);
    public virtual IAsyncResult BeginInvoke(IAsyncResult ar, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[AttributeUsageAttribute("32767")]
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Attribute : object {
    public object TypeId { get; }
    private static Attribute[] InternalGetCustomAttributes(PropertyInfo element, Type type, bool inherit);
    private static bool InternalIsDefined(PropertyInfo element, Type attributeType, bool inherit);
    private static PropertyInfo GetParentDefinition(PropertyInfo property, Type[] propertyParameters);
    private static Attribute[] InternalGetCustomAttributes(EventInfo element, Type type, bool inherit);
    private static EventInfo GetParentDefinition(EventInfo ev);
    private static bool InternalIsDefined(EventInfo element, Type attributeType, bool inherit);
    private static ParameterInfo GetParentDefinition(ParameterInfo param);
    private static Attribute[] InternalParamGetCustomAttributes(ParameterInfo param, Type type, bool inherit);
    private static bool InternalParamIsDefined(ParameterInfo param, Type type, bool inherit);
    private static void CopyToArrayList(List`1<Attribute> attributeList, Attribute[] attributes, Dictionary`2<Type, AttributeUsageAttribute> types);
    private static Type[] GetIndexParameterTypes(PropertyInfo element);
    private static void AddAttributesToList(List`1<Attribute> attributeList, Attribute[] attributes, Dictionary`2<Type, AttributeUsageAttribute> types);
    private static AttributeUsageAttribute InternalGetAttributeUsage(Type type);
    private static Attribute[] CreateAttributeArrayHelper(Type elementType, int elementCount);
    public static Attribute[] GetCustomAttributes(MemberInfo element, Type type);
    public static Attribute[] GetCustomAttributes(MemberInfo element, Type type, bool inherit);
    public static Attribute[] GetCustomAttributes(MemberInfo element);
    public static Attribute[] GetCustomAttributes(MemberInfo element, bool inherit);
    public static bool IsDefined(MemberInfo element, Type attributeType);
    public static bool IsDefined(MemberInfo element, Type attributeType, bool inherit);
    public static Attribute GetCustomAttribute(MemberInfo element, Type attributeType);
    public static Attribute GetCustomAttribute(MemberInfo element, Type attributeType, bool inherit);
    public static Attribute[] GetCustomAttributes(ParameterInfo element);
    public static Attribute[] GetCustomAttributes(ParameterInfo element, Type attributeType);
    public static Attribute[] GetCustomAttributes(ParameterInfo element, Type attributeType, bool inherit);
    public static Attribute[] GetCustomAttributes(ParameterInfo element, bool inherit);
    public static bool IsDefined(ParameterInfo element, Type attributeType);
    public static bool IsDefined(ParameterInfo element, Type attributeType, bool inherit);
    public static Attribute GetCustomAttribute(ParameterInfo element, Type attributeType);
    public static Attribute GetCustomAttribute(ParameterInfo element, Type attributeType, bool inherit);
    public static Attribute[] GetCustomAttributes(Module element, Type attributeType);
    public static Attribute[] GetCustomAttributes(Module element);
    public static Attribute[] GetCustomAttributes(Module element, bool inherit);
    public static Attribute[] GetCustomAttributes(Module element, Type attributeType, bool inherit);
    public static bool IsDefined(Module element, Type attributeType);
    public static bool IsDefined(Module element, Type attributeType, bool inherit);
    public static Attribute GetCustomAttribute(Module element, Type attributeType);
    public static Attribute GetCustomAttribute(Module element, Type attributeType, bool inherit);
    public static Attribute[] GetCustomAttributes(Assembly element, Type attributeType);
    public static Attribute[] GetCustomAttributes(Assembly element, Type attributeType, bool inherit);
    public static Attribute[] GetCustomAttributes(Assembly element);
    public static Attribute[] GetCustomAttributes(Assembly element, bool inherit);
    public static bool IsDefined(Assembly element, Type attributeType);
    public static bool IsDefined(Assembly element, Type attributeType, bool inherit);
    public static Attribute GetCustomAttribute(Assembly element, Type attributeType);
    public static Attribute GetCustomAttribute(Assembly element, Type attributeType, bool inherit);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private static bool AreFieldValuesEqual(object thisValue, object thatValue);
    public virtual object get_TypeId();
    [NullableContextAttribute("2")]
public virtual bool Match(object obj);
    public virtual bool IsDefaultAttribute();
}
[FlagsAttribute]
public enum System.AttributeTargets : Enum {
    public int value__;
    public static AttributeTargets Assembly;
    public static AttributeTargets Module;
    public static AttributeTargets Class;
    public static AttributeTargets Struct;
    public static AttributeTargets Enum;
    public static AttributeTargets Constructor;
    public static AttributeTargets Method;
    public static AttributeTargets Property;
    public static AttributeTargets Field;
    public static AttributeTargets Event;
    public static AttributeTargets Interface;
    public static AttributeTargets Parameter;
    public static AttributeTargets Delegate;
    public static AttributeTargets ReturnValue;
    public static AttributeTargets GenericParameter;
    public static AttributeTargets All;
}
[AttributeUsageAttribute("4")]
public class System.AttributeUsageAttribute : Attribute {
    private AttributeTargets _attributeTarget;
    private bool _allowMultiple;
    private bool _inherited;
    internal static AttributeUsageAttribute Default;
    public AttributeTargets ValidOn { get; }
    public bool AllowMultiple { get; public set; }
    public bool Inherited { get; public set; }
    public AttributeUsageAttribute(AttributeTargets validOn);
    internal AttributeUsageAttribute(AttributeTargets validOn, bool allowMultiple, bool inherited);
    private static AttributeUsageAttribute();
    public AttributeTargets get_ValidOn();
    public bool get_AllowMultiple();
    public void set_AllowMultiple(bool value);
    public bool get_Inherited();
    public void set_Inherited(bool value);
}
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableContextAttribute("2")]
public class System.BadImageFormatException : SystemException {
    private string _fileName;
    private string _fusionLog;
    [NullableAttribute("1")]
public string Message { get; }
    public string FileName { get; }
    public string FusionLog { get; }
    private BadImageFormatException(string fileName, string fusionLog, int hResult);
    public BadImageFormatException(string message);
    public BadImageFormatException(string message, Exception inner);
    public BadImageFormatException(string message, string fileName);
    public BadImageFormatException(string message, string fileName, Exception inner);
    [NullableContextAttribute("1")]
protected BadImageFormatException(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("1")]
public virtual string get_Message();
    private void SetMessageField();
    public string get_FileName();
    [NullableContextAttribute("1")]
public virtual string ToString();
    public string get_FusionLog();
}
[FlagsAttribute]
public enum System.Base64FormattingOptions : Enum {
    public int value__;
    public static Base64FormattingOptions None;
    public static Base64FormattingOptions InsertLineBreaks;
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public static class System.BitConverter : object {
    [IntrinsicAttribute]
public static bool IsLittleEndian;
    private static BitConverter();
    public static Byte[] GetBytes(bool value);
    [NullableContextAttribute("0")]
public static bool TryWriteBytes(Span`1<byte> destination, bool value);
    public static Byte[] GetBytes(char value);
    [NullableContextAttribute("0")]
public static bool TryWriteBytes(Span`1<byte> destination, char value);
    public static Byte[] GetBytes(short value);
    [NullableContextAttribute("0")]
public static bool TryWriteBytes(Span`1<byte> destination, short value);
    public static Byte[] GetBytes(int value);
    [NullableContextAttribute("0")]
public static bool TryWriteBytes(Span`1<byte> destination, int value);
    public static Byte[] GetBytes(long value);
    [NullableContextAttribute("0")]
public static bool TryWriteBytes(Span`1<byte> destination, long value);
    [CLSCompliantAttribute("False")]
public static Byte[] GetBytes(ushort value);
    [CLSCompliantAttribute("False")]
[NullableContextAttribute("0")]
public static bool TryWriteBytes(Span`1<byte> destination, ushort value);
    [CLSCompliantAttribute("False")]
public static Byte[] GetBytes(UInt32 value);
    [CLSCompliantAttribute("False")]
[NullableContextAttribute("0")]
public static bool TryWriteBytes(Span`1<byte> destination, UInt32 value);
    [CLSCompliantAttribute("False")]
public static Byte[] GetBytes(ulong value);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public static bool TryWriteBytes(Span`1<byte> destination, ulong value);
    public static Byte[] GetBytes(float value);
    [NullableContextAttribute("0")]
public static bool TryWriteBytes(Span`1<byte> destination, float value);
    public static Byte[] GetBytes(double value);
    [NullableContextAttribute("0")]
public static bool TryWriteBytes(Span`1<byte> destination, double value);
    public static char ToChar(Byte[] value, int startIndex);
    [NullableContextAttribute("0")]
public static char ToChar(ReadOnlySpan`1<byte> value);
    public static short ToInt16(Byte[] value, int startIndex);
    [NullableContextAttribute("0")]
public static short ToInt16(ReadOnlySpan`1<byte> value);
    public static int ToInt32(Byte[] value, int startIndex);
    [NullableContextAttribute("0")]
public static int ToInt32(ReadOnlySpan`1<byte> value);
    public static long ToInt64(Byte[] value, int startIndex);
    [NullableContextAttribute("0")]
public static long ToInt64(ReadOnlySpan`1<byte> value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(Byte[] value, int startIndex);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public static ushort ToUInt16(ReadOnlySpan`1<byte> value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(Byte[] value, int startIndex);
    [CLSCompliantAttribute("False")]
[NullableContextAttribute("0")]
public static UInt32 ToUInt32(ReadOnlySpan`1<byte> value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(Byte[] value, int startIndex);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public static ulong ToUInt64(ReadOnlySpan`1<byte> value);
    public static float ToSingle(Byte[] value, int startIndex);
    [NullableContextAttribute("0")]
public static float ToSingle(ReadOnlySpan`1<byte> value);
    public static double ToDouble(Byte[] value, int startIndex);
    [NullableContextAttribute("0")]
public static double ToDouble(ReadOnlySpan`1<byte> value);
    public static string ToString(Byte[] value, int startIndex, int length);
    public static string ToString(Byte[] value);
    public static string ToString(Byte[] value, int startIndex);
    public static bool ToBoolean(Byte[] value, int startIndex);
    [NullableContextAttribute("0")]
public static bool ToBoolean(ReadOnlySpan`1<byte> value);
    public static long DoubleToInt64Bits(double value);
    public static double Int64BitsToDouble(long value);
    public static int SingleToInt32Bits(float value);
    public static float Int32BitsToSingle(int value);
}
[IsReadOnlyAttribute]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Boolean : ValueType {
    private bool m_value;
    [NullableAttribute("1")]
public static string TrueString;
    [NullableAttribute("1")]
public static string FalseString;
    private static Boolean();
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public sealed virtual string ToString(IFormatProvider provider);
    public bool TryFormat(Span`1<char> destination, Int32& charsWritten);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(bool obj);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(bool value);
    internal static bool IsTrueStringIgnoreCase(ReadOnlySpan`1<char> value);
    internal static bool IsFalseStringIgnoreCase(ReadOnlySpan`1<char> value);
    [NullableContextAttribute("1")]
public static bool Parse(string value);
    public static bool Parse(ReadOnlySpan`1<char> value);
    [NullableContextAttribute("2")]
public static bool TryParse(string value, Boolean& result);
    public static bool TryParse(ReadOnlySpan`1<char> value, Boolean& result);
    private static ReadOnlySpan`1<char> TrimWhiteSpaceAndNull(ReadOnlySpan`1<char> value);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public static class System.Buffer : object {
    public static void BlockCopy(Array src, int srcOffset, Array dst, int dstOffset, int count);
    private static bool IsPrimitiveTypeArray(Array array);
    private static int _ByteLength(Array array);
    internal static void Memcpy(Byte* dest, Byte* src, int len);
    private static void __Memmove(Byte* dest, Byte* src, ulong len);
    public static int ByteLength(Array array);
    public static byte GetByte(Array array, int index);
    public static void SetByte(Array array, int index, byte value);
    internal static void ZeroMemory(Byte* dest, long len);
    internal static void ZeroMemory(Byte* dest, ulong len);
    [CLSCompliantAttribute("False")]
[NullableContextAttribute("0")]
public static void MemoryCopy(Void* source, Void* destination, long destinationSizeInBytes, long sourceBytesToCopy);
    [CLSCompliantAttribute("False")]
[NullableContextAttribute("0")]
public static void MemoryCopy(Void* source, Void* destination, ulong destinationSizeInBytes, ulong sourceBytesToCopy);
    internal static void Memcpy(Byte[] dest, int destIndex, Byte* src, int srcIndex, int len);
    internal static void Memcpy(Byte* pDest, int destIndex, Byte[] src, int srcIndex, int len);
    internal static void Memmove(Byte* dest, Byte* src, ulong len);
    internal static void Memmove(T& destination, T& source, ulong elementCount);
    private static void Memmove(Byte& dest, Byte& src, ulong len);
    private static void _Memmove(Byte* dest, Byte* src, ulong len);
    private static void _Memmove(Byte& dest, Byte& src, ulong len);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Buffers.ArrayPool`1 : object {
    private static TlsOverPerCoreLockedStacksArrayPool`1<T> s_shared;
    public static ArrayPool`1<T> Shared { get; }
    private static ArrayPool`1();
    public static ArrayPool`1<T> get_Shared();
    public static ArrayPool`1<T> Create();
    public static ArrayPool`1<T> Create(int maxArrayLength, int maxArraysPerBucket);
    public abstract virtual T[] Rent(int minimumLength);
    public abstract virtual void Return(T[] array, bool clearArray);
}
[EventSourceAttribute]
internal class System.Buffers.ArrayPoolEventSource : EventSource {
    internal static ArrayPoolEventSource Log;
    private static ArrayPoolEventSource();
    [EventAttribute("1")]
internal void BufferRented(int bufferId, int bufferSize, int poolId, int bucketId);
    [EventAttribute("2")]
internal void BufferAllocated(int bufferId, int bufferSize, int poolId, int bucketId, BufferAllocatedReason reason);
    [EventAttribute("3")]
internal void BufferReturned(int bufferId, int bufferSize, int poolId);
    [EventAttribute("4")]
internal void BufferTrimmed(int bufferId, int bufferSize, int poolId);
    [EventAttribute("5")]
internal void BufferTrimPoll(int milliseconds, int pressure);
}
public static class System.Buffers.Binary.BinaryPrimitives : object {
    [CLSCompliantAttribute("False")]
public static sbyte ReverseEndianness(sbyte value);
    [IntrinsicAttribute]
public static short ReverseEndianness(short value);
    [IntrinsicAttribute]
public static int ReverseEndianness(int value);
    [IntrinsicAttribute]
public static long ReverseEndianness(long value);
    public static byte ReverseEndianness(byte value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static ushort ReverseEndianness(ushort value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static UInt32 ReverseEndianness(UInt32 value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static ulong ReverseEndianness(ulong value);
    public static short ReadInt16BigEndian(ReadOnlySpan`1<byte> source);
    public static int ReadInt32BigEndian(ReadOnlySpan`1<byte> source);
    public static long ReadInt64BigEndian(ReadOnlySpan`1<byte> source);
    [CLSCompliantAttribute("False")]
public static ushort ReadUInt16BigEndian(ReadOnlySpan`1<byte> source);
    [CLSCompliantAttribute("False")]
public static UInt32 ReadUInt32BigEndian(ReadOnlySpan`1<byte> source);
    [CLSCompliantAttribute("False")]
public static ulong ReadUInt64BigEndian(ReadOnlySpan`1<byte> source);
    public static bool TryReadInt16BigEndian(ReadOnlySpan`1<byte> source, Int16& value);
    public static bool TryReadInt32BigEndian(ReadOnlySpan`1<byte> source, Int32& value);
    public static bool TryReadInt64BigEndian(ReadOnlySpan`1<byte> source, Int64& value);
    [CLSCompliantAttribute("False")]
public static bool TryReadUInt16BigEndian(ReadOnlySpan`1<byte> source, UInt16& value);
    [CLSCompliantAttribute("False")]
public static bool TryReadUInt32BigEndian(ReadOnlySpan`1<byte> source, UInt32& value);
    [CLSCompliantAttribute("False")]
public static bool TryReadUInt64BigEndian(ReadOnlySpan`1<byte> source, UInt64& value);
    public static short ReadInt16LittleEndian(ReadOnlySpan`1<byte> source);
    public static int ReadInt32LittleEndian(ReadOnlySpan`1<byte> source);
    public static long ReadInt64LittleEndian(ReadOnlySpan`1<byte> source);
    [CLSCompliantAttribute("False")]
public static ushort ReadUInt16LittleEndian(ReadOnlySpan`1<byte> source);
    [CLSCompliantAttribute("False")]
public static UInt32 ReadUInt32LittleEndian(ReadOnlySpan`1<byte> source);
    [CLSCompliantAttribute("False")]
public static ulong ReadUInt64LittleEndian(ReadOnlySpan`1<byte> source);
    public static bool TryReadInt16LittleEndian(ReadOnlySpan`1<byte> source, Int16& value);
    public static bool TryReadInt32LittleEndian(ReadOnlySpan`1<byte> source, Int32& value);
    public static bool TryReadInt64LittleEndian(ReadOnlySpan`1<byte> source, Int64& value);
    [CLSCompliantAttribute("False")]
public static bool TryReadUInt16LittleEndian(ReadOnlySpan`1<byte> source, UInt16& value);
    [CLSCompliantAttribute("False")]
public static bool TryReadUInt32LittleEndian(ReadOnlySpan`1<byte> source, UInt32& value);
    [CLSCompliantAttribute("False")]
public static bool TryReadUInt64LittleEndian(ReadOnlySpan`1<byte> source, UInt64& value);
    public static void WriteInt16BigEndian(Span`1<byte> destination, short value);
    public static void WriteInt32BigEndian(Span`1<byte> destination, int value);
    public static void WriteInt64BigEndian(Span`1<byte> destination, long value);
    [CLSCompliantAttribute("False")]
public static void WriteUInt16BigEndian(Span`1<byte> destination, ushort value);
    [CLSCompliantAttribute("False")]
public static void WriteUInt32BigEndian(Span`1<byte> destination, UInt32 value);
    [CLSCompliantAttribute("False")]
public static void WriteUInt64BigEndian(Span`1<byte> destination, ulong value);
    public static bool TryWriteInt16BigEndian(Span`1<byte> destination, short value);
    public static bool TryWriteInt32BigEndian(Span`1<byte> destination, int value);
    public static bool TryWriteInt64BigEndian(Span`1<byte> destination, long value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteUInt16BigEndian(Span`1<byte> destination, ushort value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteUInt32BigEndian(Span`1<byte> destination, UInt32 value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteUInt64BigEndian(Span`1<byte> destination, ulong value);
    public static void WriteInt16LittleEndian(Span`1<byte> destination, short value);
    public static void WriteInt32LittleEndian(Span`1<byte> destination, int value);
    public static void WriteInt64LittleEndian(Span`1<byte> destination, long value);
    [CLSCompliantAttribute("False")]
public static void WriteUInt16LittleEndian(Span`1<byte> destination, ushort value);
    [CLSCompliantAttribute("False")]
public static void WriteUInt32LittleEndian(Span`1<byte> destination, UInt32 value);
    [CLSCompliantAttribute("False")]
public static void WriteUInt64LittleEndian(Span`1<byte> destination, ulong value);
    public static bool TryWriteInt16LittleEndian(Span`1<byte> destination, short value);
    public static bool TryWriteInt32LittleEndian(Span`1<byte> destination, int value);
    public static bool TryWriteInt64LittleEndian(Span`1<byte> destination, long value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteUInt16LittleEndian(Span`1<byte> destination, ushort value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteUInt32LittleEndian(Span`1<byte> destination, UInt32 value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteUInt64LittleEndian(Span`1<byte> destination, ulong value);
}
internal class System.Buffers.ConfigurableArrayPool`1 : ArrayPool`1<T> {
    private Bucket[] _buckets;
    private int Id { get; }
    internal ConfigurableArrayPool`1(int maxArrayLength, int maxArraysPerBucket);
    private int get_Id();
    public virtual T[] Rent(int minimumLength);
    public virtual void Return(T[] array, bool clearArray);
}
public interface System.Buffers.IMemoryOwner`1 {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Memory`1<T> Memory { get; }
    public abstract virtual Memory`1<T> get_Memory();
}
public interface System.Buffers.IPinnable {
    public abstract virtual MemoryHandle Pin(int elementIndex);
    public abstract virtual void Unpin();
}
public class System.Buffers.MemoryHandle : ValueType {
    private Void* _pointer;
    private GCHandle _handle;
    private IPinnable _pinnable;
    [CLSCompliantAttribute("False")]
public Void* Pointer { get; }
    [CLSCompliantAttribute("False")]
public MemoryHandle(Void* pointer, GCHandle handle, IPinnable pinnable);
    public Void* get_Pointer();
    public sealed virtual void Dispose();
}
public abstract class System.Buffers.MemoryManager`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Memory`1<T> Memory { get; }
    public virtual Memory`1<T> get_Memory();
    public abstract virtual Span`1<T> GetSpan();
    public abstract virtual MemoryHandle Pin(int elementIndex);
    public abstract virtual void Unpin();
    protected Memory`1<T> CreateMemory(int length);
    protected Memory`1<T> CreateMemory(int start, int length);
    protected internal virtual bool TryGetArray(ArraySegment`1& segment);
    private sealed virtual override void System.IDisposable.Dispose();
    protected abstract virtual void Dispose(bool disposing);
}
public enum System.Buffers.OperationStatus : Enum {
    public int value__;
    public static OperationStatus Done;
    public static OperationStatus DestinationTooSmall;
    public static OperationStatus NeedMoreData;
    public static OperationStatus InvalidData;
}
public class System.Buffers.ReadOnlySpanAction`2 : MulticastDelegate {
    public ReadOnlySpanAction`2(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(ReadOnlySpan`1<T> span, TArg arg);
    public virtual IAsyncResult BeginInvoke(ReadOnlySpan`1<T> span, TArg arg, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Buffers.SpanAction`2 : MulticastDelegate {
    public SpanAction`2(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(Span`1<T> span, TArg arg);
    public virtual IAsyncResult BeginInvoke(Span`1<T> span, TArg arg, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[IsReadOnlyAttribute]
public class System.Buffers.StandardFormat : ValueType {
    public static byte NoPrecision;
    public static byte MaxPrecision;
    private byte _format;
    private byte _precision;
    public char Symbol { get; }
    public byte Precision { get; }
    public bool HasPrecision { get; }
    public bool IsDefault { get; }
    public StandardFormat(char symbol, byte precision);
    public char get_Symbol();
    public byte get_Precision();
    public bool get_HasPrecision();
    public bool get_IsDefault();
    public static StandardFormat op_Implicit(char symbol);
    public static StandardFormat Parse(ReadOnlySpan`1<char> format);
    [NullableContextAttribute("2")]
public static StandardFormat Parse(string format);
    public static bool TryParse(ReadOnlySpan`1<char> format, StandardFormat& result);
    private static bool ParseHelper(ReadOnlySpan`1<char> format, StandardFormat& standardFormat, bool throws);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(StandardFormat other);
    [NullableContextAttribute("1")]
public virtual string ToString();
    internal int Format(Span`1<char> destination);
    public static bool op_Equality(StandardFormat left, StandardFormat right);
    public static bool op_Inequality(StandardFormat left, StandardFormat right);
}
internal static class System.Buffers.Text.FormattingHelpers : object {
    public static int CountDigits(ulong value);
    public static int CountDigits(UInt32 value);
    public static int CountHexDigits(ulong value);
    public static int CountDecimalTrailingZeros(UInt32 value, UInt32& valueWithoutTrailingZeros);
    public static char GetSymbolOrDefault(StandardFormat& format, char defaultSymbol);
    public static void FillWithAsciiZeros(Span`1<byte> buffer);
    public static void WriteHexByte(byte value, Span`1<byte> buffer, int startingIndex, HexCasing casing);
    public static void WriteDigits(ulong value, Span`1<byte> buffer);
    public static void WriteDigitsWithGroupSeparator(ulong value, Span`1<byte> buffer);
    public static void WriteDigits(UInt32 value, Span`1<byte> buffer);
    public static void WriteFourDecimalDigits(UInt32 value, Span`1<byte> buffer, int startingIndex);
    public static void WriteTwoDecimalDigits(UInt32 value, Span`1<byte> buffer, int startingIndex);
    public static ulong DivMod(ulong numerator, ulong denominator, UInt64& modulo);
    public static UInt32 DivMod(UInt32 numerator, UInt32 denominator, UInt32& modulo);
    public static bool TryFormatThrowFormatException(Int32& bytesWritten);
}
internal static class System.Buffers.Text.ParserHelpers : object {
    public static Byte[] s_hexLookup;
    private static ParserHelpers();
    public static bool IsDigit(int i);
    public static bool TryParseThrowFormatException(Int32& bytesConsumed);
    public static bool TryParseThrowFormatException(T& value, Int32& bytesConsumed);
}
internal static class System.Buffers.Text.Utf8Constants : object {
    public static TimeSpan NullUtcOffset;
    private static Utf8Constants();
}
public static class System.Buffers.Text.Utf8Formatter : object {
    private static UInt32[] s_dayAbbreviations;
    private static UInt32[] s_dayAbbreviationsLowercase;
    private static UInt32[] s_monthAbbreviations;
    private static UInt32[] s_monthAbbreviationsLowercase;
    private static Utf8Formatter();
    public static bool TryFormat(bool value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(DateTimeOffset value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(DateTime value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    private static bool TryFormatDateTimeG(DateTime value, TimeSpan offset, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatDateTimeL(DateTime value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatDateTimeO(DateTime value, TimeSpan offset, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatDateTimeR(DateTime value, Span`1<byte> destination, Int32& bytesWritten);
    public static bool TryFormat(decimal value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    private static bool TryFormatDecimalE(NumberBuffer& number, Span`1<byte> destination, Int32& bytesWritten, byte precision, byte exponentSymbol);
    private static bool TryFormatDecimalF(NumberBuffer& number, Span`1<byte> destination, Int32& bytesWritten, byte precision);
    private static bool TryFormatDecimalG(NumberBuffer& number, Span`1<byte> destination, Int32& bytesWritten);
    public static bool TryFormat(double value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(float value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    private static bool TryFormatFloatingPoint(T value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(Guid value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(byte value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    [CLSCompliantAttribute("False")]
public static bool TryFormat(sbyte value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    [CLSCompliantAttribute("False")]
public static bool TryFormat(ushort value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(short value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    [CLSCompliantAttribute("False")]
public static bool TryFormat(UInt32 value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(int value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    [CLSCompliantAttribute("False")]
public static bool TryFormat(ulong value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(long value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    private static bool TryFormatInt64(long value, ulong mask, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    private static bool TryFormatInt64D(long value, byte precision, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatInt64Default(long value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatInt32MultipleDigits(int value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatInt64MultipleDigits(long value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatInt64MoreThanNegativeBillionMaxUInt(long value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatInt64LessThanNegativeBillionMaxUInt(long value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatInt64N(long value, byte precision, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatUInt64(ulong value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    private static bool TryFormatUInt64D(ulong value, byte precision, Span`1<byte> destination, bool insertNegationSign, Int32& bytesWritten);
    private static bool TryFormatUInt64Default(ulong value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatUInt32SingleDigit(UInt32 value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatUInt32MultipleDigits(UInt32 value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatUInt64MultipleDigits(ulong value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatUInt64LessThanBillionMaxUInt(ulong value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatUInt64MoreThanBillionMaxUInt(ulong value, Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryFormatUInt64N(ulong value, byte precision, Span`1<byte> destination, bool insertNegationSign, Int32& bytesWritten);
    private static bool TryFormatUInt64X(ulong value, byte precision, bool useLower, Span`1<byte> destination, Int32& bytesWritten);
    public static bool TryFormat(TimeSpan value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
}
public static class System.Buffers.Text.Utf8Parser : object {
    private static Int32[] s_daysToMonth365;
    private static Int32[] s_daysToMonth366;
    private static Utf8Parser();
    public static bool TryParse(ReadOnlySpan`1<byte> source, Boolean& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, DateTime& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, DateTimeOffset& value, Int32& bytesConsumed, char standardFormat);
    private static bool TryParseDateTimeOffsetDefault(ReadOnlySpan`1<byte> source, DateTimeOffset& value, Int32& bytesConsumed);
    private static bool TryParseDateTimeG(ReadOnlySpan`1<byte> source, DateTime& value, DateTimeOffset& valueAsOffset, Int32& bytesConsumed);
    private static bool TryCreateDateTimeOffset(DateTime dateTime, bool offsetNegative, int offsetHours, int offsetMinutes, DateTimeOffset& value);
    private static bool TryCreateDateTimeOffset(int year, int month, int day, int hour, int minute, int second, int fraction, bool offsetNegative, int offsetHours, int offsetMinutes, DateTimeOffset& value);
    private static bool TryCreateDateTimeOffsetInterpretingDataAsLocalTime(int year, int month, int day, int hour, int minute, int second, int fraction, DateTimeOffset& value);
    private static bool TryCreateDateTime(int year, int month, int day, int hour, int minute, int second, int fraction, DateTimeKind kind, DateTime& value);
    private static bool TryParseDateTimeOffsetO(ReadOnlySpan`1<byte> source, DateTimeOffset& value, Int32& bytesConsumed, DateTimeKind& kind);
    private static bool TryParseDateTimeOffsetR(ReadOnlySpan`1<byte> source, UInt32 caseFlipXorMask, DateTimeOffset& dateTimeOffset, Int32& bytesConsumed);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Decimal& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Single& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Double& value, Int32& bytesConsumed, char standardFormat);
    private static bool TryParseNormalAsFloatingPoint(ReadOnlySpan`1<byte> source, NumberBuffer& number, Int32& bytesConsumed, char standardFormat);
    private static bool TryParseAsSpecialFloatingPoint(ReadOnlySpan`1<byte> source, T positiveInfinity, T negativeInfinity, T nan, T& value, Int32& bytesConsumed);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Guid& value, Int32& bytesConsumed, char standardFormat);
    private static bool TryParseGuidN(ReadOnlySpan`1<byte> text, Guid& value, Int32& bytesConsumed);
    private static bool TryParseGuidCore(ReadOnlySpan`1<byte> source, bool ends, char begin, char end, Guid& value, Int32& bytesConsumed);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<byte> source, SByte& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Int16& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Int32& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Int64& value, Int32& bytesConsumed, char standardFormat);
    private static bool TryParseSByteD(ReadOnlySpan`1<byte> source, SByte& value, Int32& bytesConsumed);
    private static bool TryParseInt16D(ReadOnlySpan`1<byte> source, Int16& value, Int32& bytesConsumed);
    private static bool TryParseInt32D(ReadOnlySpan`1<byte> source, Int32& value, Int32& bytesConsumed);
    private static bool TryParseInt64D(ReadOnlySpan`1<byte> source, Int64& value, Int32& bytesConsumed);
    private static bool TryParseSByteN(ReadOnlySpan`1<byte> source, SByte& value, Int32& bytesConsumed);
    private static bool TryParseInt16N(ReadOnlySpan`1<byte> source, Int16& value, Int32& bytesConsumed);
    private static bool TryParseInt32N(ReadOnlySpan`1<byte> source, Int32& value, Int32& bytesConsumed);
    private static bool TryParseInt64N(ReadOnlySpan`1<byte> source, Int64& value, Int32& bytesConsumed);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Byte& value, Int32& bytesConsumed, char standardFormat);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<byte> source, UInt16& value, Int32& bytesConsumed, char standardFormat);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<byte> source, UInt32& value, Int32& bytesConsumed, char standardFormat);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<byte> source, UInt64& value, Int32& bytesConsumed, char standardFormat);
    private static bool TryParseByteD(ReadOnlySpan`1<byte> source, Byte& value, Int32& bytesConsumed);
    private static bool TryParseUInt16D(ReadOnlySpan`1<byte> source, UInt16& value, Int32& bytesConsumed);
    private static bool TryParseUInt32D(ReadOnlySpan`1<byte> source, UInt32& value, Int32& bytesConsumed);
    private static bool TryParseUInt64D(ReadOnlySpan`1<byte> source, UInt64& value, Int32& bytesConsumed);
    private static bool TryParseByteN(ReadOnlySpan`1<byte> source, Byte& value, Int32& bytesConsumed);
    private static bool TryParseUInt16N(ReadOnlySpan`1<byte> source, UInt16& value, Int32& bytesConsumed);
    private static bool TryParseUInt32N(ReadOnlySpan`1<byte> source, UInt32& value, Int32& bytesConsumed);
    private static bool TryParseUInt64N(ReadOnlySpan`1<byte> source, UInt64& value, Int32& bytesConsumed);
    private static bool TryParseByteX(ReadOnlySpan`1<byte> source, Byte& value, Int32& bytesConsumed);
    private static bool TryParseUInt16X(ReadOnlySpan`1<byte> source, UInt16& value, Int32& bytesConsumed);
    private static bool TryParseUInt32X(ReadOnlySpan`1<byte> source, UInt32& value, Int32& bytesConsumed);
    private static bool TryParseUInt64X(ReadOnlySpan`1<byte> source, UInt64& value, Int32& bytesConsumed);
    private static bool TryParseNumber(ReadOnlySpan`1<byte> source, NumberBuffer& number, Int32& bytesConsumed, ParseNumberOptions options, Boolean& textUsedExponentNotation);
    private static bool TryParseTimeSpanBigG(ReadOnlySpan`1<byte> source, TimeSpan& value, Int32& bytesConsumed);
    private static bool TryParseTimeSpanC(ReadOnlySpan`1<byte> source, TimeSpan& value, Int32& bytesConsumed);
    public static bool TryParse(ReadOnlySpan`1<byte> source, TimeSpan& value, Int32& bytesConsumed, char standardFormat);
    private static bool TryParseTimeSpanFraction(ReadOnlySpan`1<byte> source, UInt32& value, Int32& bytesConsumed);
    private static bool TryCreateTimeSpan(bool isNegative, UInt32 days, UInt32 hours, UInt32 minutes, UInt32 seconds, UInt32 fraction, TimeSpan& timeSpan);
    private static bool TryParseTimeSpanLittleG(ReadOnlySpan`1<byte> source, TimeSpan& value, Int32& bytesConsumed);
}
internal class System.Buffers.TlsOverPerCoreLockedStacksArrayPool`1 : ArrayPool`1<T> {
    private Int32[] _bucketArraySizes;
    private PerCoreLockedStacks[] _buckets;
    [ThreadStaticAttribute]
private static T[][] t_tlsBuckets;
    private int _callbackCreated;
    private static bool s_trimBuffers;
    private static ConditionalWeakTable`2<T[][], object> s_allTlsBuckets;
    private int Id { get; }
    private static TlsOverPerCoreLockedStacksArrayPool`1();
    private PerCoreLockedStacks<T> CreatePerCoreLockedStacks(int bucketIndex);
    private int get_Id();
    public virtual T[] Rent(int minimumLength);
    public virtual void Return(T[] array, bool clearArray);
    public bool Trim();
    private static bool Gen2GcCallbackFunc(object target);
    private static MemoryPressure<T> GetMemoryPressure();
    private static bool GetTrimBuffers();
}
internal static class System.Buffers.Utilities : object {
    internal static int SelectBucketIndex(int bufferSize);
    internal static int GetMaxSizeForBucket(int binIndex);
}
[IsReadOnlyAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[NonVersionableAttribute]
[IsByRefLikeAttribute]
internal class System.ByReference`1 : ValueType {
    private IntPtr _value;
    public T& Value { get; }
    [IntrinsicAttribute]
public ByReference`1(T& value);
    [IntrinsicAttribute]
public T& get_Value();
}
[IsReadOnlyAttribute]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Byte : ValueType {
    private byte m_value;
    public static byte MaxValue;
    public static byte MinValue;
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(byte value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(byte obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public static byte Parse(string s);
    [NullableContextAttribute("1")]
public static byte Parse(string s, NumberStyles style);
    [NullableContextAttribute("1")]
public static byte Parse(string s, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static byte Parse(string s, NumberStyles style, IFormatProvider provider);
    public static byte Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    private static byte Parse(ReadOnlySpan`1<char> s, NumberStyles style, NumberFormatInfo info);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, Byte& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, Byte& result);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Byte& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Byte& result);
    private static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, NumberFormatInfo info, Byte& result);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("1")]
public sealed virtual string ToString(IFormatProvider provider);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.CannotUnloadAppDomainException : SystemException {
    public CannotUnloadAppDomainException(string message);
    public CannotUnloadAppDomainException(string message, Exception innerException);
    [NullableContextAttribute("1")]
protected CannotUnloadAppDomainException(SerializationInfo info, StreamingContext context);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
[IsReadOnlyAttribute]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Char : ValueType {
    private char m_value;
    public static char MaxValue;
    public static char MinValue;
    [NullableAttribute("0")]
private static ReadOnlySpan`1<byte> CategoryForLatin1 { get; }
    private static ReadOnlySpan`1<byte> get_CategoryForLatin1();
    private static bool IsLatin1(char ch);
    private static bool IsAscii(char ch);
    private static UnicodeCategory GetLatin1UnicodeCategory(char ch);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(char obj);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(char value);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public static string ToString(char c);
    public static char Parse(string s);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, Char& result);
    public static bool IsDigit(char c);
    internal static bool IsInRange(char c, char min, char max);
    private static bool IsInRange(UnicodeCategory c, UnicodeCategory min, UnicodeCategory max);
    internal static bool CheckLetter(UnicodeCategory uc);
    public static bool IsLetter(char c);
    private static bool IsWhiteSpaceLatin1(char c);
    public static bool IsWhiteSpace(char c);
    public static bool IsUpper(char c);
    public static bool IsLower(char c);
    internal static bool CheckPunctuation(UnicodeCategory uc);
    public static bool IsPunctuation(char c);
    internal static bool CheckLetterOrDigit(UnicodeCategory uc);
    public static bool IsLetterOrDigit(char c);
    public static char ToUpper(char c, CultureInfo culture);
    public static char ToUpper(char c);
    public static char ToUpperInvariant(char c);
    public static char ToLower(char c, CultureInfo culture);
    public static char ToLower(char c);
    public static char ToLowerInvariant(char c);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    public static bool IsControl(char c);
    public static bool IsControl(string s, int index);
    public static bool IsDigit(string s, int index);
    public static bool IsLetter(string s, int index);
    public static bool IsLetterOrDigit(string s, int index);
    public static bool IsLower(string s, int index);
    internal static bool CheckNumber(UnicodeCategory uc);
    public static bool IsNumber(char c);
    public static bool IsNumber(string s, int index);
    public static bool IsPunctuation(string s, int index);
    internal static bool CheckSeparator(UnicodeCategory uc);
    private static bool IsSeparatorLatin1(char c);
    public static bool IsSeparator(char c);
    public static bool IsSeparator(string s, int index);
    public static bool IsSurrogate(char c);
    public static bool IsSurrogate(string s, int index);
    internal static bool CheckSymbol(UnicodeCategory uc);
    public static bool IsSymbol(char c);
    public static bool IsSymbol(string s, int index);
    public static bool IsUpper(string s, int index);
    public static bool IsWhiteSpace(string s, int index);
    public static UnicodeCategory GetUnicodeCategory(char c);
    public static UnicodeCategory GetUnicodeCategory(string s, int index);
    public static double GetNumericValue(char c);
    public static double GetNumericValue(string s, int index);
    public static bool IsHighSurrogate(char c);
    public static bool IsHighSurrogate(string s, int index);
    public static bool IsLowSurrogate(char c);
    public static bool IsLowSurrogate(string s, int index);
    public static bool IsSurrogatePair(string s, int index);
    public static bool IsSurrogatePair(char highSurrogate, char lowSurrogate);
    public static string ConvertFromUtf32(int utf32);
    public static int ConvertToUtf32(char highSurrogate, char lowSurrogate);
    [StackTraceHiddenAttribute]
private static void ConvertToUtf32_ThrowInvalidArgs(UInt32 highSurrogateOffset);
    public static int ConvertToUtf32(string s, int index);
}
public class System.CharEnumerator : object {
    private string _str;
    private int _index;
    private char _currentElement;
    [NullableAttribute("2")]
private object System.Collections.IEnumerator.Current { get; }
    public char Current { get; }
    internal CharEnumerator(string str);
    [NullableContextAttribute("1")]
public sealed virtual object Clone();
    public sealed virtual bool MoveNext();
    public sealed virtual void Dispose();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual char get_Current();
    public sealed virtual void Reset();
}
internal class System.CLRConfig : object {
    internal static bool GetBoolValue(string switchName, Boolean& exist);
    internal static bool GetBoolValueWithFallbacks(string switchName, string environmentName, bool defaultValue);
    private static bool GetConfigBoolValue(string configSwitchName, Boolean& exist);
}
[AttributeUsageAttribute("32767")]
public class System.CLSCompliantAttribute : Attribute {
    private bool _compliant;
    public bool IsCompliant { get; }
    public CLSCompliantAttribute(bool isCompliant);
    public bool get_IsCompliant();
}
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableContextAttribute("1")]
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Collections.ArrayList/ArrayListDebugView")]
[DefaultMemberAttribute("Item")]
public class System.Collections.ArrayList : object {
    private Object[] _items;
    private int _size;
    private int _version;
    public int Capacity { get; public set; }
    public int Count { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    [NullableAttribute("2")]
public object Item { get; public set; }
    internal ArrayList(bool trash);
    public ArrayList(int capacity);
    public ArrayList(ICollection c);
    public virtual int get_Capacity();
    public virtual void set_Capacity(int value);
    public virtual int get_Count();
    public virtual bool get_IsFixedSize();
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsSynchronized();
    public virtual object get_SyncRoot();
    [NullableContextAttribute("2")]
public virtual object get_Item(int index);
    [NullableContextAttribute("2")]
public virtual void set_Item(int index, object value);
    public static ArrayList Adapter(IList list);
    [NullableContextAttribute("2")]
public virtual int Add(object value);
    public virtual void AddRange(ICollection c);
    [NullableContextAttribute("2")]
public virtual int BinarySearch(int index, int count, object value, IComparer comparer);
    [NullableContextAttribute("2")]
public virtual int BinarySearch(object value);
    [NullableContextAttribute("2")]
public virtual int BinarySearch(object value, IComparer comparer);
    public virtual void Clear();
    public virtual object Clone();
    [NullableContextAttribute("2")]
public virtual bool Contains(object item);
    public virtual void CopyTo(Array array);
    public virtual void CopyTo(Array array, int arrayIndex);
    public virtual void CopyTo(int index, Array array, int arrayIndex, int count);
    private void EnsureCapacity(int min);
    public static IList FixedSize(IList list);
    public static ArrayList FixedSize(ArrayList list);
    public virtual IEnumerator GetEnumerator();
    public virtual IEnumerator GetEnumerator(int index, int count);
    [NullableContextAttribute("2")]
public virtual int IndexOf(object value);
    [NullableContextAttribute("2")]
public virtual int IndexOf(object value, int startIndex);
    [NullableContextAttribute("2")]
public virtual int IndexOf(object value, int startIndex, int count);
    [NullableContextAttribute("2")]
public virtual void Insert(int index, object value);
    public virtual void InsertRange(int index, ICollection c);
    [NullableContextAttribute("2")]
public virtual int LastIndexOf(object value);
    [NullableContextAttribute("2")]
public virtual int LastIndexOf(object value, int startIndex);
    [NullableContextAttribute("2")]
public virtual int LastIndexOf(object value, int startIndex, int count);
    public static IList ReadOnly(IList list);
    public static ArrayList ReadOnly(ArrayList list);
    [NullableContextAttribute("2")]
public virtual void Remove(object obj);
    public virtual void RemoveAt(int index);
    public virtual void RemoveRange(int index, int count);
    public static ArrayList Repeat(object value, int count);
    public virtual void Reverse();
    public virtual void Reverse(int index, int count);
    public virtual void SetRange(int index, ICollection c);
    public virtual ArrayList GetRange(int index, int count);
    public virtual void Sort();
    [NullableContextAttribute("2")]
public virtual void Sort(IComparer comparer);
    [NullableContextAttribute("2")]
public virtual void Sort(int index, int count, IComparer comparer);
    public static IList Synchronized(IList list);
    public static ArrayList Synchronized(ArrayList list);
    public virtual Object[] ToArray();
    public virtual Array ToArray(Type type);
    public virtual void TrimToSize();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Collections.Comparer : object {
    private CompareInfo _compareInfo;
    public static Comparer Default;
    public static Comparer DefaultInvariant;
    public Comparer(CultureInfo culture);
    private Comparer(SerializationInfo info, StreamingContext context);
    private static Comparer();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("2")]
public sealed virtual int Compare(object a, object b);
}
internal class System.Collections.CompatibleComparer : object {
    private IHashCodeProvider _hcp;
    private IComparer _comparer;
    internal IHashCodeProvider HashCodeProvider { get; }
    internal IComparer Comparer { get; }
    internal CompatibleComparer(IHashCodeProvider hashCodeProvider, IComparer comparer);
    internal IHashCodeProvider get_HashCodeProvider();
    internal IComparer get_Comparer();
    public sealed virtual bool Equals(object a, object b);
    public int Compare(object a, object b);
    public sealed virtual int GetHashCode(object obj);
}
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Collections.Concurrent.IProducerConsumerCollectionDebugView`1")]
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Collections.Concurrent.ConcurrentQueue`1 : object {
    private object _crossSegmentLock;
    private ConcurrentQueueSegment`1 modreq(System.Runtime.CompilerServices.IsVolatile) _tail;
    private ConcurrentQueueSegment`1 modreq(System.Runtime.CompilerServices.IsVolatile) _head;
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public bool IsEmpty { get; }
    public int Count { get; }
    public ConcurrentQueue`1(IEnumerable`1<T> collection);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.Concurrent.IProducerConsumerCollection<T>.TryAdd(T item);
    private sealed virtual override bool System.Collections.Concurrent.IProducerConsumerCollection<T>.TryTake(T& item);
    public bool get_IsEmpty();
    public sealed virtual T[] ToArray();
    public sealed virtual int get_Count();
    private static int GetCount(ConcurrentQueueSegment`1<T> s, int head, int tail);
    private static long GetCount(ConcurrentQueueSegment`1<T> head, int headHead, ConcurrentQueueSegment`1<T> tail, int tailTail);
    public sealed virtual void CopyTo(T[] array, int index);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private void SnapForObservation(ConcurrentQueueSegment`1& head, Int32& headHead, ConcurrentQueueSegment`1& tail, Int32& tailTail);
    private T GetItemWhenAvailable(ConcurrentQueueSegment`1<T> segment, int i);
    [IteratorStateMachineAttribute("System.Collections.Concurrent.ConcurrentQueue`1/<Enumerate>d__26")]
private IEnumerator`1<T> Enumerate(ConcurrentQueueSegment`1<T> head, int headHead, ConcurrentQueueSegment`1<T> tail, int tailTail);
    public void Enqueue(T item);
    private void EnqueueSlow(T item);
    public bool TryDequeue(T& result);
    private bool TryDequeueSlow(T& item);
    public bool TryPeek(T& result);
    private bool TryPeek(T& result, bool resultUsed);
    public void Clear();
}
[DebuggerDisplayAttribute("Capacity = {Capacity}")]
internal class System.Collections.Concurrent.ConcurrentQueueSegment`1 : object {
    internal Slot[] _slots;
    internal int _slotsMask;
    internal PaddedHeadAndTail _headAndTail;
    internal bool _preservedForObservation;
    internal bool _frozenForEnqueues;
    internal ConcurrentQueueSegment`1<T> _nextSegment;
    internal int Capacity { get; }
    internal int FreezeOffset { get; }
    internal ConcurrentQueueSegment`1(int boundedLength);
    internal static int RoundUpToPowerOf2(int i);
    internal int get_Capacity();
    internal int get_FreezeOffset();
    internal void EnsureFrozenForEnqueues();
    public bool TryDequeue(T& item);
    public bool TryPeek(T& result, bool resultUsed);
    public bool TryEnqueue(T item);
}
[NullableContextAttribute("1")]
public interface System.Collections.Concurrent.IProducerConsumerCollection`1 {
    public abstract virtual void CopyTo(T[] array, int index);
    public abstract virtual bool TryAdd(T item);
    public abstract virtual bool TryTake(T& item);
    public abstract virtual T[] ToArray();
}
internal class System.Collections.Concurrent.IProducerConsumerCollectionDebugView`1 : object {
    private IProducerConsumerCollection`1<T> _collection;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public IProducerConsumerCollectionDebugView`1(IProducerConsumerCollection`1<T> collection);
    public T[] get_Items();
}
[DebuggerDisplayAttribute("Head = {Head}, Tail = {Tail}")]
internal class System.Collections.Concurrent.PaddedHeadAndTail : ValueType {
    public int Head;
    public int Tail;
}
[NullableContextAttribute("1")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableAttribute("0")]
public class System.Collections.DictionaryEntry : ValueType {
    private object _key;
    private object _value;
    public object Key { get; public set; }
    [NullableAttribute("2")]
public object Value { get; public set; }
    public DictionaryEntry(object key, object value);
    public object get_Key();
    public void set_Key(object value);
    [NullableContextAttribute("2")]
public object get_Value();
    [NullableContextAttribute("2")]
public void set_Value(object value);
    [EditorBrowsableAttribute("1")]
public void Deconstruct(Object& key, Object& value);
}
[DefaultMemberAttribute("Item")]
internal class System.Collections.EmptyReadOnlyDictionaryInternal : object {
    public int Count { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    public object Item { get; public set; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual ICollection get_Keys();
    public sealed virtual ICollection get_Values();
    public sealed virtual bool Contains(object key);
    public sealed virtual void Add(object key, object value);
    public sealed virtual void Clear();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual IDictionaryEnumerator GetEnumerator();
    public sealed virtual void Remove(object key);
}
[TypeDependencyAttribute("System.Collections.Generic.GenericArraySortHelper`1")]
internal class System.Collections.Generic.ArraySortHelper`1 : object {
    private static IArraySortHelper`1<T> s_defaultArraySortHelper;
    public static IArraySortHelper`1<T> Default { get; }
    private static ArraySortHelper`1();
    public static IArraySortHelper`1<T> get_Default();
    private static IArraySortHelper`1<T> CreateArraySortHelper();
    public sealed virtual void Sort(T[] keys, int index, int length, IComparer`1<T> comparer);
    public sealed virtual int BinarySearch(T[] array, int index, int length, T value, IComparer`1<T> comparer);
    internal static void Sort(T[] keys, int index, int length, Comparison`1<T> comparer);
    internal static int InternalBinarySearch(T[] array, int index, int length, T value, IComparer`1<T> comparer);
    private static void SwapIfGreater(T[] keys, Comparison`1<T> comparer, int a, int b);
    private static void Swap(T[] a, int i, int j);
    internal static void IntrospectiveSort(T[] keys, int left, int length, Comparison`1<T> comparer);
    private static void IntroSort(T[] keys, int lo, int hi, int depthLimit, Comparison`1<T> comparer);
    private static int PickPivotAndPartition(T[] keys, int lo, int hi, Comparison`1<T> comparer);
    private static void Heapsort(T[] keys, int lo, int hi, Comparison`1<T> comparer);
    private static void DownHeap(T[] keys, int i, int n, int lo, Comparison`1<T> comparer);
    private static void InsertionSort(T[] keys, int lo, int hi, Comparison`1<T> comparer);
}
[TypeDependencyAttribute("System.Collections.Generic.GenericArraySortHelper`2")]
internal class System.Collections.Generic.ArraySortHelper`2 : object {
    private static IArraySortHelper`2<TKey, TValue> s_defaultArraySortHelper;
    public static IArraySortHelper`2<TKey, TValue> Default { get; }
    private static ArraySortHelper`2();
    public static IArraySortHelper`2<TKey, TValue> get_Default();
    private static IArraySortHelper`2<TKey, TValue> CreateArraySortHelper();
    public sealed virtual void Sort(TKey[] keys, TValue[] values, int index, int length, IComparer`1<TKey> comparer);
    private static void SwapIfGreaterWithItems(TKey[] keys, TValue[] values, IComparer`1<TKey> comparer, int a, int b);
    private static void Swap(TKey[] keys, TValue[] values, int i, int j);
    internal static void IntrospectiveSort(TKey[] keys, TValue[] values, int left, int length, IComparer`1<TKey> comparer);
    private static void IntroSort(TKey[] keys, TValue[] values, int lo, int hi, int depthLimit, IComparer`1<TKey> comparer);
    private static int PickPivotAndPartition(TKey[] keys, TValue[] values, int lo, int hi, IComparer`1<TKey> comparer);
    private static void Heapsort(TKey[] keys, TValue[] values, int lo, int hi, IComparer`1<TKey> comparer);
    private static void DownHeap(TKey[] keys, TValue[] values, int i, int n, int lo, IComparer`1<TKey> comparer);
    private static void InsertionSort(TKey[] keys, TValue[] values, int lo, int hi, IComparer`1<TKey> comparer);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.Generic.ByteEqualityComparer : EqualityComparer`1<byte> {
    public virtual bool Equals(byte x, byte y);
    public virtual int GetHashCode(byte b);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableContextAttribute("1")]
[TypeDependencyAttribute("System.Collections.Generic.ObjectComparer`1")]
[NullableAttribute("0")]
public abstract class System.Collections.Generic.Comparer`1 : object {
    [CompilerGeneratedAttribute]
private static Comparer`1<T> <Default>k__BackingField;
    public static Comparer`1<T> Default { get; }
    private static Comparer`1();
    [CompilerGeneratedAttribute]
public static Comparer`1<T> get_Default();
    public static Comparer`1<T> Create(Comparison`1<T> comparison);
    public abstract virtual int Compare(T x, T y);
    private sealed virtual override int System.Collections.IComparer.Compare(object x, object y);
}
internal static class System.Collections.Generic.ComparerHelpers : object {
    internal static object CreateDefaultComparer(Type type);
    private static object TryCreateNullableComparer(RuntimeType nullableType);
    private static object TryCreateEnumComparer(RuntimeType enumType);
    internal static object CreateDefaultEqualityComparer(Type type);
    private static object TryCreateNullableEqualityComparer(RuntimeType nullableType);
    private static object TryCreateEnumEqualityComparer(RuntimeType enumType);
}
internal class System.Collections.Generic.ComparisonComparer`1 : Comparer`1<T> {
    private Comparison`1<T> _comparison;
    public ComparisonComparer`1(Comparison`1<T> comparison);
    public virtual int Compare(T x, T y);
}
[DebuggerDisplayAttribute("Count = {Count}")]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.IDictionaryDebugView`2")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Collections.Generic.Dictionary`2 : object {
    private Int32[] _buckets;
    private Entry[] _entries;
    private int _count;
    private int _freeList;
    private int _freeCount;
    private int _version;
    private IEqualityComparer`1<TKey> _comparer;
    private KeyCollection<TKey, TValue> _keys;
    private ValueCollection<TKey, TValue> _values;
    public IEqualityComparer`1<TKey> Comparer { get; }
    public int Count { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public KeyCollection<TKey, TValue> Keys { get; }
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueCollection<TKey, TValue> Values { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    public TValue Item { get; public set; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    [NullableAttribute("2")]
private object System.Collections.IDictionary.Item { get; private set; }
    public Dictionary`2(int capacity);
    public Dictionary`2(IEqualityComparer`1<TKey> comparer);
    public Dictionary`2(int capacity, IEqualityComparer`1<TKey> comparer);
    public Dictionary`2(IDictionary`2<TKey, TValue> dictionary);
    public Dictionary`2(IDictionary`2<TKey, TValue> dictionary, IEqualityComparer`1<TKey> comparer);
    public Dictionary`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection);
    public Dictionary`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection, IEqualityComparer`1<TKey> comparer);
    protected Dictionary`2(SerializationInfo info, StreamingContext context);
    public IEqualityComparer`1<TKey> get_Comparer();
    public sealed virtual int get_Count();
    public KeyCollection<TKey, TValue> get_Keys();
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    public ValueCollection<TKey, TValue> get_Values();
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual void Add(TKey key, TValue value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> keyValuePair);
    public sealed virtual void Clear();
    public sealed virtual bool ContainsKey(TKey key);
    public bool ContainsValue(TValue value);
    private void CopyTo(KeyValuePair`2[] array, int index);
    [NullableContextAttribute("0")]
public Enumerator<TKey, TValue> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    private int FindEntry(TKey key);
    private int Initialize(int capacity);
    private bool TryInsert(TKey key, TValue value, InsertionBehavior behavior);
    [NullableContextAttribute("2")]
public virtual void OnDeserialization(object sender);
    private void Resize();
    private void Resize(int newSize, bool forceNewHashCodes);
    public sealed virtual bool Remove(TKey key);
    public bool Remove(TKey key, TValue& value);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public bool TryAdd(TKey key, TValue value);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public int EnsureCapacity(int capacity);
    public void TrimExcess();
    public void TrimExcess(int capacity);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private static bool IsCompatibleKey(object key);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
}
internal class System.Collections.Generic.DictionaryKeyCollectionDebugView`2 : object {
    private ICollection`1<TKey> _collection;
    [DebuggerBrowsableAttribute("3")]
public TKey[] Items { get; }
    public DictionaryKeyCollectionDebugView`2(ICollection`1<TKey> collection);
    public TKey[] get_Items();
}
internal class System.Collections.Generic.DictionaryValueCollectionDebugView`2 : object {
    private ICollection`1<TValue> _collection;
    [DebuggerBrowsableAttribute("3")]
public TValue[] Items { get; }
    public DictionaryValueCollectionDebugView`2(ICollection`1<TValue> collection);
    public TValue[] get_Items();
}
internal class System.Collections.Generic.EnumComparer`1 : Comparer`1<T> {
    private EnumComparer`1(SerializationInfo info, StreamingContext context);
    public virtual int Compare(T x, T y);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.Generic.EnumEqualityComparer`1 : EqualityComparer`1<T> {
    private EnumEqualityComparer`1(SerializationInfo information, StreamingContext context);
    public virtual bool Equals(T x, T y);
    internal virtual int IndexOf(T[] array, T value, int startIndex, int count);
    internal virtual int LastIndexOf(T[] array, T value, int startIndex, int count);
    [NullableContextAttribute("1")]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual int GetHashCode(T obj);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[TypeDependencyAttribute("System.Collections.Generic.ObjectEqualityComparer`1")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableContextAttribute("1")]
public abstract class System.Collections.Generic.EqualityComparer`1 : object {
    [CompilerGeneratedAttribute]
private static EqualityComparer`1<T> <Default>k__BackingField;
    public static EqualityComparer`1<T> Default { get; }
    private static EqualityComparer`1();
    [CompilerGeneratedAttribute]
[IntrinsicAttribute]
public static EqualityComparer`1<T> get_Default();
    internal virtual int IndexOf(T[] array, T value, int startIndex, int count);
    internal virtual int LastIndexOf(T[] array, T value, int startIndex, int count);
    public abstract virtual bool Equals(T x, T y);
    public abstract virtual int GetHashCode(T obj);
    private sealed virtual override int System.Collections.IEqualityComparer.GetHashCode(object obj);
    private sealed virtual override bool System.Collections.IEqualityComparer.Equals(object x, object y);
}
internal class System.Collections.Generic.GenericArraySortHelper`1 : object {
    public sealed virtual void Sort(T[] keys, int index, int length, IComparer`1<T> comparer);
    public sealed virtual int BinarySearch(T[] array, int index, int length, T value, IComparer`1<T> comparer);
    private static int BinarySearch(T[] array, int index, int length, T value);
    private static void SwapIfGreaterWithItems(T[] keys, int a, int b);
    private static void Swap(T[] a, int i, int j);
    internal static void IntrospectiveSort(T[] keys, int left, int length);
    private static void IntroSort(T[] keys, int lo, int hi, int depthLimit);
    private static int PickPivotAndPartition(T[] keys, int lo, int hi);
    private static void Heapsort(T[] keys, int lo, int hi);
    private static void DownHeap(T[] keys, int i, int n, int lo);
    private static void InsertionSort(T[] keys, int lo, int hi);
}
internal class System.Collections.Generic.GenericArraySortHelper`2 : object {
    public sealed virtual void Sort(TKey[] keys, TValue[] values, int index, int length, IComparer`1<TKey> comparer);
    private static void SwapIfGreaterWithItems(TKey[] keys, TValue[] values, int a, int b);
    private static void Swap(TKey[] keys, TValue[] values, int i, int j);
    internal static void IntrospectiveSort(TKey[] keys, TValue[] values, int left, int length);
    private static void IntroSort(TKey[] keys, TValue[] values, int lo, int hi, int depthLimit);
    private static int PickPivotAndPartition(TKey[] keys, TValue[] values, int lo, int hi);
    private static void Heapsort(TKey[] keys, TValue[] values, int lo, int hi);
    private static void DownHeap(TKey[] keys, TValue[] values, int i, int n, int lo);
    private static void InsertionSort(TKey[] keys, TValue[] values, int lo, int hi);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.Generic.GenericComparer`1 : Comparer`1<T> {
    public virtual int Compare(T x, T y);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class System.Collections.Generic.GenericEqualityComparer`1 : EqualityComparer`1<T> {
    internal virtual int IndexOf(T[] array, T value, int startIndex, int count);
    internal virtual int LastIndexOf(T[] array, T value, int startIndex, int count);
    [NullableContextAttribute("1")]
public virtual bool Equals(T x, T y);
    [NullableContextAttribute("1")]
public virtual int GetHashCode(T obj);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal interface System.Collections.Generic.IArraySortHelper`1 {
    public abstract virtual void Sort(TKey[] keys, int index, int length, IComparer`1<TKey> comparer);
    public abstract virtual int BinarySearch(TKey[] keys, int index, int length, TKey value, IComparer`1<TKey> comparer);
}
internal interface System.Collections.Generic.IArraySortHelper`2 {
    public abstract virtual void Sort(TKey[] keys, TValue[] values, int index, int length, IComparer`1<TKey> comparer);
}
[NullableContextAttribute("1")]
public interface System.Collections.Generic.IAsyncEnumerable`1 {
    public abstract virtual IAsyncEnumerator`1<T> GetAsyncEnumerator(CancellationToken cancellationToken);
}
public interface System.Collections.Generic.IAsyncEnumerator`1 {
    [NullableAttribute("1")]
public T Current { get; }
    public abstract virtual ValueTask`1<bool> MoveNextAsync();
    [NullableContextAttribute("1")]
public abstract virtual T get_Current();
}
[NullableContextAttribute("1")]
public interface System.Collections.Generic.ICollection`1 {
    public int Count { get; }
    public bool IsReadOnly { get; }
    public abstract virtual int get_Count();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual void Add(T item);
    public abstract virtual void Clear();
    public abstract virtual bool Contains(T item);
    public abstract virtual void CopyTo(T[] array, int arrayIndex);
    public abstract virtual bool Remove(T item);
}
internal class System.Collections.Generic.ICollectionDebugView`1 : object {
    private ICollection`1<T> _collection;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public ICollectionDebugView`1(ICollection`1<T> collection);
    public T[] get_Items();
}
[NullableContextAttribute("1")]
public interface System.Collections.Generic.IComparer`1 {
    public abstract virtual int Compare(T x, T y);
}
[DefaultMemberAttribute("Item")]
[NullableContextAttribute("1")]
public interface System.Collections.Generic.IDictionary`2 {
    public TValue Item { get; public set; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public abstract virtual TValue get_Item(TKey key);
    public abstract virtual void set_Item(TKey key, TValue value);
    public abstract virtual ICollection`1<TKey> get_Keys();
    public abstract virtual ICollection`1<TValue> get_Values();
    public abstract virtual bool ContainsKey(TKey key);
    public abstract virtual void Add(TKey key, TValue value);
    public abstract virtual bool Remove(TKey key);
    public abstract virtual bool TryGetValue(TKey key, TValue& value);
}
internal class System.Collections.Generic.IDictionaryDebugView`2 : object {
    private IDictionary`2<K, V> _dict;
    [DebuggerBrowsableAttribute("3")]
public KeyValuePair`2[] Items { get; }
    public IDictionaryDebugView`2(IDictionary`2<K, V> dictionary);
    public KeyValuePair`2[] get_Items();
}
public interface System.Collections.Generic.IEnumerable`1 {
    [NullableContextAttribute("1")]
public abstract virtual IEnumerator`1<T> GetEnumerator();
}
public interface System.Collections.Generic.IEnumerator`1 {
    [NullableAttribute("1")]
public T Current { get; }
    [NullableContextAttribute("1")]
public abstract virtual T get_Current();
}
[NullableContextAttribute("1")]
public interface System.Collections.Generic.IEqualityComparer`1 {
    public abstract virtual bool Equals(T x, T y);
    public abstract virtual int GetHashCode(T obj);
}
[NullableContextAttribute("1")]
[DefaultMemberAttribute("Item")]
public interface System.Collections.Generic.IList`1 {
    public T Item { get; public set; }
    public abstract virtual T get_Item(int index);
    public abstract virtual void set_Item(int index, T value);
    public abstract virtual int IndexOf(T item);
    public abstract virtual void Insert(int index, T item);
    public abstract virtual void RemoveAt(int index);
}
internal enum System.Collections.Generic.InsertionBehavior : Enum {
    public byte value__;
    public static InsertionBehavior None;
    public static InsertionBehavior OverwriteExisting;
    public static InsertionBehavior ThrowOnExisting;
}
internal static class System.Collections.Generic.IntrospectiveSortUtilities : object {
    internal static int FloorLog2PlusOne(int n);
    [DoesNotReturnAttribute]
internal static void ThrowOrIgnoreBadComparer(object comparer);
}
public interface System.Collections.Generic.IReadOnlyCollection`1 {
    public int Count { get; }
    public abstract virtual int get_Count();
}
[DefaultMemberAttribute("Item")]
[NullableContextAttribute("1")]
public interface System.Collections.Generic.IReadOnlyDictionary`2 {
    public TValue Item { get; }
    public IEnumerable`1<TKey> Keys { get; }
    public IEnumerable`1<TValue> Values { get; }
    public abstract virtual bool ContainsKey(TKey key);
    public abstract virtual bool TryGetValue(TKey key, TValue& value);
    public abstract virtual TValue get_Item(TKey key);
    public abstract virtual IEnumerable`1<TKey> get_Keys();
    public abstract virtual IEnumerable`1<TValue> get_Values();
}
[NullableContextAttribute("1")]
[DefaultMemberAttribute("Item")]
public interface System.Collections.Generic.IReadOnlyList`1 {
    public T Item { get; }
    public abstract virtual T get_Item(int index);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.Generic.KeyNotFoundException : SystemException {
    public KeyNotFoundException(string message);
    public KeyNotFoundException(string message, Exception innerException);
    [NullableContextAttribute("1")]
protected KeyNotFoundException(SerializationInfo info, StreamingContext context);
}
public static class System.Collections.Generic.KeyValuePair : object {
    [NullableContextAttribute("1")]
public static KeyValuePair`2<TKey, TValue> Create(TKey key, TValue value);
    internal static string PairToString(object key, object value);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Collections.Generic.KeyValuePair`2 : ValueType {
    private TKey key;
    private TValue value;
    public TKey Key { get; }
    public TValue Value { get; }
    public KeyValuePair`2(TKey key, TValue value);
    public TKey get_Key();
    public TValue get_Value();
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public void Deconstruct(TKey& key, TValue& value);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.ICollectionDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class System.Collections.Generic.List`1 : object {
    private T[] _items;
    private int _size;
    private int _version;
    private static T[] s_emptyArray;
    public int Capacity { get; public set; }
    public int Count { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public T Item { get; public set; }
    [NullableAttribute("2")]
private object System.Collections.IList.Item { get; private set; }
    public List`1(int capacity);
    public List`1(IEnumerable`1<T> collection);
    private static List`1();
    public int get_Capacity();
    public void set_Capacity(int value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    private static bool IsCompatibleObject(object value);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual void Add(T item);
    private void AddWithResize(T item);
    private sealed virtual override int System.Collections.IList.Add(object item);
    public void AddRange(IEnumerable`1<T> collection);
    public ReadOnlyCollection`1<T> AsReadOnly();
    public int BinarySearch(int index, int count, T item, IComparer`1<T> comparer);
    public int BinarySearch(T item);
    public int BinarySearch(T item, IComparer`1<T> comparer);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    private sealed virtual override bool System.Collections.IList.Contains(object item);
    public List`1<TOutput> ConvertAll(Converter`2<T, TOutput> converter);
    public void CopyTo(T[] array);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    public void CopyTo(int index, T[] array, int arrayIndex, int count);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    private void EnsureCapacity(int min);
    public bool Exists(Predicate`1<T> match);
    public T Find(Predicate`1<T> match);
    public List`1<T> FindAll(Predicate`1<T> match);
    public int FindIndex(Predicate`1<T> match);
    public int FindIndex(int startIndex, Predicate`1<T> match);
    public int FindIndex(int startIndex, int count, Predicate`1<T> match);
    public T FindLast(Predicate`1<T> match);
    public int FindLastIndex(Predicate`1<T> match);
    public int FindLastIndex(int startIndex, Predicate`1<T> match);
    public int FindLastIndex(int startIndex, int count, Predicate`1<T> match);
    public void ForEach(Action`1<T> action);
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public List`1<T> GetRange(int index, int count);
    public sealed virtual int IndexOf(T item);
    private sealed virtual override int System.Collections.IList.IndexOf(object item);
    public int IndexOf(T item, int index);
    public int IndexOf(T item, int index, int count);
    public sealed virtual void Insert(int index, T item);
    private sealed virtual override void System.Collections.IList.Insert(int index, object item);
    public void InsertRange(int index, IEnumerable`1<T> collection);
    public int LastIndexOf(T item);
    public int LastIndexOf(T item, int index);
    public int LastIndexOf(T item, int index, int count);
    public sealed virtual bool Remove(T item);
    private sealed virtual override void System.Collections.IList.Remove(object item);
    public int RemoveAll(Predicate`1<T> match);
    public sealed virtual void RemoveAt(int index);
    public void RemoveRange(int index, int count);
    public void Reverse();
    public void Reverse(int index, int count);
    public void Sort();
    public void Sort(IComparer`1<T> comparer);
    public void Sort(int index, int count, IComparer`1<T> comparer);
    public void Sort(Comparison`1<T> comparison);
    public T[] ToArray();
    public void TrimExcess();
    public bool TrueForAll(Predicate`1<T> match);
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableContextAttribute("2")]
public class System.Collections.Generic.NonRandomizedStringEqualityComparer : EqualityComparer`1<string> {
    [CompilerGeneratedAttribute]
private static IEqualityComparer`1<string> <Default>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEqualityComparer`1<string> Default { get; }
    private NonRandomizedStringEqualityComparer(SerializationInfo information, StreamingContext context);
    private static NonRandomizedStringEqualityComparer();
    [CompilerGeneratedAttribute]
internal static IEqualityComparer`1<string> get_Default();
    public sealed virtual bool Equals(string x, string y);
    public sealed virtual int GetHashCode(string obj);
    [NullableContextAttribute("1")]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.Generic.NullableComparer`1 : Comparer`1<Nullable`1<T>> {
    public virtual int Compare(Nullable`1<T> x, Nullable`1<T> y);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.Generic.NullableEqualityComparer`1 : EqualityComparer`1<Nullable`1<T>> {
    internal virtual int IndexOf(Nullable`1[] array, Nullable`1<T> value, int startIndex, int count);
    internal virtual int LastIndexOf(Nullable`1[] array, Nullable`1<T> value, int startIndex, int count);
    public virtual bool Equals(Nullable`1<T> x, Nullable`1<T> y);
    public virtual int GetHashCode(Nullable`1<T> obj);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableContextAttribute("2")]
public class System.Collections.Generic.ObjectComparer`1 : Comparer`1<T> {
    [NullableContextAttribute("1")]
public virtual int Compare(T x, T y);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.Generic.ObjectEqualityComparer`1 : EqualityComparer`1<T> {
    internal virtual int IndexOf(T[] array, T value, int startIndex, int count);
    internal virtual int LastIndexOf(T[] array, T value, int startIndex, int count);
    public virtual bool Equals(T x, T y);
    public virtual int GetHashCode(T obj);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[DefaultMemberAttribute("Item")]
internal class System.Collections.Generic.ValueListBuilder`1 : ValueType {
    private Span`1<T> _span;
    private T[] _arrayFromPool;
    private int _pos;
    public int Length { get; }
    public ValueListBuilder`1(Span`1<T> initialSpan);
    public int get_Length();
    public void Append(T item);
    public ReadOnlySpan`1<T> AsSpan();
    public void Dispose();
    private void Grow();
}
internal static class System.Collections.HashHelpers : object {
    public static Int32[] primes;
    private static ConditionalWeakTable`2<object, SerializationInfo> s_serializationInfoTable;
    public static ConditionalWeakTable`2<object, SerializationInfo> SerializationInfoTable { get; }
    private static HashHelpers();
    public static bool IsPrime(int candidate);
    public static int GetPrime(int min);
    public static int ExpandPrime(int oldSize);
    public static ConditionalWeakTable`2<object, SerializationInfo> get_SerializationInfoTable();
}
[NullableContextAttribute("1")]
[DebuggerTypeProxyAttribute("System.Collections.Hashtable/HashtableDebugView")]
[DebuggerDisplayAttribute("Count = {Count}")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class System.Collections.Hashtable : object {
    private bucket[] _buckets;
    private int _count;
    private int _occupancy;
    private int _loadsize;
    private float _loadFactor;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _version;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _isWriterInProgress;
    private ICollection _keys;
    private ICollection _values;
    private IEqualityComparer _keycomparer;
    [NullableAttribute("2")]
[ObsoleteAttribute("Please use EqualityComparer property.")]
protected IHashCodeProvider hcp { get; protected set; }
    [ObsoleteAttribute("Please use KeyComparer properties.")]
[NullableAttribute("2")]
protected IComparer comparer { get; protected set; }
    [NullableAttribute("2")]
protected IEqualityComparer EqualityComparer { get; }
    [NullableAttribute("2")]
public object Item { get; public set; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public bool IsSynchronized { get; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public object SyncRoot { get; }
    public int Count { get; }
    internal Hashtable(bool trash);
    public Hashtable(int capacity);
    public Hashtable(int capacity, float loadFactor);
    [NullableContextAttribute("2")]
public Hashtable(int capacity, float loadFactor, IEqualityComparer equalityComparer);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Please use Hashtable(IEqualityComparer) instead.")]
public Hashtable(IHashCodeProvider hcp, IComparer comparer);
    [NullableContextAttribute("2")]
public Hashtable(IEqualityComparer equalityComparer);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Please use Hashtable(int, IEqualityComparer) instead.")]
public Hashtable(int capacity, IHashCodeProvider hcp, IComparer comparer);
    [NullableContextAttribute("2")]
public Hashtable(int capacity, IEqualityComparer equalityComparer);
    public Hashtable(IDictionary d);
    public Hashtable(IDictionary d, float loadFactor);
    [ObsoleteAttribute("Please use Hashtable(IDictionary, IEqualityComparer) instead.")]
[NullableContextAttribute("2")]
public Hashtable(IDictionary d, IHashCodeProvider hcp, IComparer comparer);
    public Hashtable(IDictionary d, IEqualityComparer equalityComparer);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Please use Hashtable(int, float, IEqualityComparer) instead.")]
public Hashtable(int capacity, float loadFactor, IHashCodeProvider hcp, IComparer comparer);
    [ObsoleteAttribute("Please use Hashtable(IDictionary, float, IEqualityComparer) instead.")]
[NullableContextAttribute("2")]
public Hashtable(IDictionary d, float loadFactor, IHashCodeProvider hcp, IComparer comparer);
    public Hashtable(IDictionary d, float loadFactor, IEqualityComparer equalityComparer);
    protected Hashtable(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("2")]
protected IHashCodeProvider get_hcp();
    [NullableContextAttribute("2")]
protected void set_hcp(IHashCodeProvider value);
    [NullableContextAttribute("2")]
protected IComparer get_comparer();
    [NullableContextAttribute("2")]
protected void set_comparer(IComparer value);
    [NullableContextAttribute("2")]
protected IEqualityComparer get_EqualityComparer();
    private UInt32 InitHash(object key, int hashsize, UInt32& seed, UInt32& incr);
    public virtual void Add(object key, object value);
    public virtual void Clear();
    public virtual object Clone();
    public virtual bool Contains(object key);
    public virtual bool ContainsKey(object key);
    [NullableContextAttribute("2")]
public virtual bool ContainsValue(object value);
    private void CopyKeys(Array array, int arrayIndex);
    private void CopyEntries(Array array, int arrayIndex);
    public virtual void CopyTo(Array array, int arrayIndex);
    internal virtual KeyValuePairs[] ToKeyValuePairsArray();
    private void CopyValues(Array array, int arrayIndex);
    public virtual object get_Item(object key);
    public virtual void set_Item(object key, object value);
    private void expand();
    private void rehash();
    private void UpdateVersion();
    private void rehash(int newsize);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual IDictionaryEnumerator GetEnumerator();
    protected virtual int GetHash(object key);
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsFixedSize();
    public virtual bool get_IsSynchronized();
    protected virtual bool KeyEquals(object item, object key);
    public virtual ICollection get_Keys();
    public virtual ICollection get_Values();
    private void Insert(object key, object nvalue, bool add);
    private void putEntry(bucket[] newBuckets, object key, object nvalue, int hashcode);
    public virtual void Remove(object key);
    public virtual object get_SyncRoot();
    public virtual int get_Count();
    public static Hashtable Synchronized(Hashtable table);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("2")]
public virtual void OnDeserialization(object sender);
}
[NullableContextAttribute("1")]
public interface System.Collections.ICollection {
    public int Count { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    public abstract virtual void CopyTo(Array array, int index);
    public abstract virtual int get_Count();
    public abstract virtual object get_SyncRoot();
    public abstract virtual bool get_IsSynchronized();
}
[NullableContextAttribute("2")]
public interface System.Collections.IComparer {
    public abstract virtual int Compare(object x, object y);
}
[DefaultMemberAttribute("Item")]
[NullableContextAttribute("1")]
public interface System.Collections.IDictionary {
    [NullableAttribute("2")]
public object Item { get; public set; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public abstract virtual object get_Item(object key);
    public abstract virtual void set_Item(object key, object value);
    public abstract virtual ICollection get_Keys();
    public abstract virtual ICollection get_Values();
    public abstract virtual bool Contains(object key);
    public abstract virtual void Add(object key, object value);
    public abstract virtual void Clear();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual bool get_IsFixedSize();
    public abstract virtual IDictionaryEnumerator GetEnumerator();
    public abstract virtual void Remove(object key);
}
[NullableContextAttribute("1")]
public interface System.Collections.IDictionaryEnumerator {
    public object Key { get; }
    [NullableAttribute("2")]
public object Value { get; }
    public DictionaryEntry Entry { get; }
    public abstract virtual object get_Key();
    [NullableContextAttribute("2")]
public abstract virtual object get_Value();
    public abstract virtual DictionaryEntry get_Entry();
}
[GuidAttribute("496B0ABE-CDEE-11d3-88E8-00902754C43A")]
[NullableContextAttribute("1")]
[ComVisibleAttribute("True")]
public interface System.Collections.IEnumerable {
    public abstract virtual IEnumerator GetEnumerator();
}
[NullableContextAttribute("2")]
public interface System.Collections.IEnumerator {
    public object Current { get; }
    public abstract virtual bool MoveNext();
    public abstract virtual object get_Current();
    public abstract virtual void Reset();
}
[NullableContextAttribute("1")]
public interface System.Collections.IEqualityComparer {
    [NullableContextAttribute("2")]
public abstract virtual bool Equals(object x, object y);
    public abstract virtual int GetHashCode(object obj);
}
[NullableContextAttribute("1")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[ObsoleteAttribute("Please use IEqualityComparer instead.")]
public interface System.Collections.IHashCodeProvider {
    public abstract virtual int GetHashCode(object obj);
}
[NullableContextAttribute("2")]
[DefaultMemberAttribute("Item")]
public interface System.Collections.IList {
    public object Item { get; public set; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public abstract virtual object get_Item(int index);
    public abstract virtual void set_Item(int index, object value);
    public abstract virtual int Add(object value);
    public abstract virtual bool Contains(object value);
    public abstract virtual void Clear();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual bool get_IsFixedSize();
    public abstract virtual int IndexOf(object value);
    public abstract virtual void Insert(int index, object value);
    public abstract virtual void Remove(object value);
    public abstract virtual void RemoveAt(int index);
}
[NullableContextAttribute("1")]
public interface System.Collections.IStructuralComparable {
    public abstract virtual int CompareTo(object other, IComparer comparer);
}
[NullableContextAttribute("1")]
public interface System.Collections.IStructuralEquatable {
    public abstract virtual bool Equals(object other, IEqualityComparer comparer);
    public abstract virtual int GetHashCode(IEqualityComparer comparer);
}
[DebuggerDisplayAttribute("{_value}")]
internal class System.Collections.KeyValuePairs : object {
    [DebuggerBrowsableAttribute("0")]
private object _key;
    [DebuggerBrowsableAttribute("0")]
private object _value;
    public KeyValuePairs(object key, object value);
}
[DefaultMemberAttribute("Item")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableContextAttribute("1")]
public class System.Collections.ListDictionaryInternal : object {
    private DictionaryNode head;
    private int version;
    private int count;
    [NullableAttribute("2")]
public object Item { get; public set; }
    public int Count { get; }
    public ICollection Keys { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public ICollection Values { get; }
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual int get_Count();
    public sealed virtual ICollection get_Keys();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual ICollection get_Values();
    public sealed virtual void Add(object key, object value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(object key);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual IDictionaryEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Remove(object key);
}
[DefaultMemberAttribute("Item")]
[NullableContextAttribute("1")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.ICollectionDebugView`1")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class System.Collections.ObjectModel.Collection`1 : object {
    private IList`1<T> items;
    public int Count { get; }
    protected IList`1<T> Items { get; }
    public T Item { get; public set; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    [NullableAttribute("2")]
private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    public Collection`1(IList`1<T> list);
    public sealed virtual int get_Count();
    protected IList`1<T> get_Items();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual void CopyTo(T[] array, int index);
    public sealed virtual bool Contains(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual bool Remove(T item);
    public sealed virtual void RemoveAt(int index);
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, T item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, T item);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private static bool IsCompatibleObject(object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.ICollectionDebugView`1")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class System.Collections.ObjectModel.ReadOnlyCollection`1 : object {
    private IList`1<T> list;
    public int Count { get; }
    public T Item { get; }
    protected IList`1<T> Items { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private T System.Collections.Generic.IList<T>.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    [NullableAttribute("2")]
private object System.Collections.IList.Item { get; private set; }
    public ReadOnlyCollection`1(IList`1<T> list);
    public sealed virtual int get_Count();
    public sealed virtual T get_Item(int index);
    public sealed virtual bool Contains(T value);
    public sealed virtual void CopyTo(T[] array, int index);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public sealed virtual int IndexOf(T value);
    protected IList`1<T> get_Items();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override T System.Collections.Generic.IList<T>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.set_Item(int index, T value);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T value);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T value);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T value);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private static bool IsCompatibleObject(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
}
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.IDictionaryDebugView`2")]
[DefaultMemberAttribute("Item")]
internal class System.Collections.ObjectModel.ReadOnlyDictionary`2 : object {
    private IDictionary`2<TKey, TValue> m_dictionary;
    private object m_syncRoot;
    private KeyCollection<TKey, TValue> m_keys;
    private ValueCollection<TKey, TValue> m_values;
    public KeyCollection<TKey, TValue> Keys { get; }
    public ValueCollection<TKey, TValue> Values { get; }
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    public TValue Item { get; }
    private TValue System.Collections.Generic.IDictionary<TKey,TValue>.Item { get; private set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    public ReadOnlyDictionary`2(IDictionary`2<TKey, TValue> dictionary);
    public KeyCollection<TKey, TValue> get_Keys();
    public ValueCollection<TKey, TValue> get_Values();
    public sealed virtual bool ContainsKey(TKey key);
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    public sealed virtual TValue get_Item(TKey key);
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.Add(TKey key, TValue value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<TKey,TValue>.Remove(TKey key);
    private sealed virtual override TValue System.Collections.Generic.IDictionary<TKey,TValue>.get_Item(TKey key);
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.set_Item(TKey key, TValue value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private static bool IsCompatibleKey(object key);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override void System.Collections.IDictionary.Clear();
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
}
internal static class System.Collections.ObjectModel.ReadOnlyDictionaryHelpers : object {
    internal static void CopyToNonGenericICollectionHelper(ICollection`1<T> collection, Array array, int index);
}
internal static class System.CommonlyUsedGenericInstantiations : object {
    private static CommonlyUsedGenericInstantiations();
    private static T NullableHelper();
    private static void SZArrayHelper(SZArrayHelper oSZArrayHelper);
    [AsyncStateMachineAttribute("System.CommonlyUsedGenericInstantiations/<AsyncHelper>d__3`1")]
private static void AsyncHelper();
    [AsyncStateMachineAttribute("System.CommonlyUsedGenericInstantiations/<AsyncHelper2>d__4`1")]
private static Task`1<string> AsyncHelper2();
    [AsyncStateMachineAttribute("System.CommonlyUsedGenericInstantiations/<AsyncHelper3>d__5")]
private static Task AsyncHelper3();
    private static void CommonlyUsedWinRTRedirectedInterfaceStubs();
    private static void WinRT_IEnumerable(IterableToEnumerableAdapter iterableToEnumerableAdapter, EnumerableToIterableAdapter enumerableToIterableAdapter, IIterable`1<T> iterable);
    private static void WinRT_IList(VectorToListAdapter vectorToListAdapter, VectorToCollectionAdapter vectorToCollectionAdapter, ListToVectorAdapter listToVectorAdapter, IVector`1<T> vector);
    private static void WinRT_IReadOnlyCollection(VectorViewToReadOnlyCollectionAdapter vectorViewToReadOnlyCollectionAdapter);
    private static void WinRT_IReadOnlyList(IVectorViewToIReadOnlyListAdapter vectorToListAdapter, IReadOnlyListToIVectorViewAdapter listToVectorAdapter, IVectorView`1<T> vectorView);
    private static void WinRT_IDictionary(MapToDictionaryAdapter mapToDictionaryAdapter, MapToCollectionAdapter mapToCollectionAdapter, DictionaryToMapAdapter dictionaryToMapAdapter, IMap`2<K, V> map);
    private static void WinRT_IReadOnlyDictionary(IMapViewToIReadOnlyDictionaryAdapter mapToDictionaryAdapter, IReadOnlyDictionaryToIMapViewAdapter dictionaryToMapAdapter, IMapView`2<K, V> mapView, MapViewToReadOnlyCollectionAdapter mapViewToReadOnlyCollectionAdapter);
    private static void WinRT_Nullable();
}
public class System.Comparison`1 : MulticastDelegate {
    public Comparison`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual int Invoke(T x, T y);
    public virtual IAsyncResult BeginInvoke(T x, T y, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("32767")]
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.ComponentModel.DefaultValueAttribute : Attribute {
    private object _value;
    private static object s_convertFromInvariantString;
    public object Value { get; }
    [NullableContextAttribute("1")]
public DefaultValueAttribute(Type type, string value);
    public DefaultValueAttribute(char value);
    public DefaultValueAttribute(byte value);
    public DefaultValueAttribute(short value);
    public DefaultValueAttribute(int value);
    public DefaultValueAttribute(long value);
    public DefaultValueAttribute(float value);
    public DefaultValueAttribute(double value);
    public DefaultValueAttribute(bool value);
    public DefaultValueAttribute(string value);
    public DefaultValueAttribute(object value);
    [CLSCompliantAttribute("False")]
public DefaultValueAttribute(sbyte value);
    [CLSCompliantAttribute("False")]
public DefaultValueAttribute(ushort value);
    [CLSCompliantAttribute("False")]
public DefaultValueAttribute(UInt32 value);
    [CLSCompliantAttribute("False")]
public DefaultValueAttribute(ulong value);
    public virtual object get_Value();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    protected void SetValue(object value);
    [CompilerGeneratedAttribute]
internal static bool <.ctor>g__TryConvertFromInvariantString|2_0(Type typeToConvert, string stringValue, Object& conversionResult);
}
[AttributeUsageAttribute("6140")]
public class System.ComponentModel.EditorBrowsableAttribute : Attribute {
    [CompilerGeneratedAttribute]
private EditorBrowsableState <State>k__BackingField;
    public EditorBrowsableState State { get; }
    public EditorBrowsableAttribute(EditorBrowsableState state);
    [CompilerGeneratedAttribute]
public EditorBrowsableState get_State();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public enum System.ComponentModel.EditorBrowsableState : Enum {
    public int value__;
    public static EditorBrowsableState Always;
    public static EditorBrowsableState Never;
    public static EditorBrowsableState Advanced;
}
public enum System.Configuration.Assemblies.AssemblyHashAlgorithm : Enum {
    public int value__;
    public static AssemblyHashAlgorithm None;
    public static AssemblyHashAlgorithm MD5;
    public static AssemblyHashAlgorithm SHA1;
    public static AssemblyHashAlgorithm SHA256;
    public static AssemblyHashAlgorithm SHA384;
    public static AssemblyHashAlgorithm SHA512;
}
public enum System.Configuration.Assemblies.AssemblyVersionCompatibility : Enum {
    public int value__;
    public static AssemblyVersionCompatibility SameMachine;
    public static AssemblyVersionCompatibility SameProcess;
    public static AssemblyVersionCompatibility SameDomain;
}
[ExtensionAttribute]
[NullableAttribute("0")]
[NullableContextAttribute("2")]
public static class System.Convert : object {
    internal static Type[] ConvertTypes;
    private static Type EnumType;
    internal static Char[] base64Table;
    [NullableAttribute("1")]
public static object DBNull;
    private static SByte[] s_decodingMap;
    private static Convert();
    public static TypeCode GetTypeCode(object value);
    public static bool IsDBNull(object value);
    public static object ChangeType(object value, TypeCode typeCode);
    public static object ChangeType(object value, TypeCode typeCode, IFormatProvider provider);
    internal static object DefaultToType(IConvertible value, Type targetType, IFormatProvider provider);
    public static object ChangeType(object value, Type conversionType);
    public static object ChangeType(object value, Type conversionType, IFormatProvider provider);
    [DoesNotReturnAttribute]
private static void ThrowCharOverflowException();
    [DoesNotReturnAttribute]
private static void ThrowByteOverflowException();
    [DoesNotReturnAttribute]
private static void ThrowSByteOverflowException();
    [DoesNotReturnAttribute]
private static void ThrowInt16OverflowException();
    [DoesNotReturnAttribute]
private static void ThrowUInt16OverflowException();
    [DoesNotReturnAttribute]
private static void ThrowInt32OverflowException();
    [DoesNotReturnAttribute]
private static void ThrowUInt32OverflowException();
    [DoesNotReturnAttribute]
private static void ThrowInt64OverflowException();
    [DoesNotReturnAttribute]
private static void ThrowUInt64OverflowException();
    public static bool ToBoolean(object value);
    public static bool ToBoolean(object value, IFormatProvider provider);
    public static bool ToBoolean(bool value);
    [CLSCompliantAttribute("False")]
public static bool ToBoolean(sbyte value);
    public static bool ToBoolean(char value);
    public static bool ToBoolean(byte value);
    public static bool ToBoolean(short value);
    [CLSCompliantAttribute("False")]
public static bool ToBoolean(ushort value);
    public static bool ToBoolean(int value);
    [CLSCompliantAttribute("False")]
public static bool ToBoolean(UInt32 value);
    public static bool ToBoolean(long value);
    [CLSCompliantAttribute("False")]
public static bool ToBoolean(ulong value);
    public static bool ToBoolean(string value);
    public static bool ToBoolean(string value, IFormatProvider provider);
    public static bool ToBoolean(float value);
    public static bool ToBoolean(double value);
    public static bool ToBoolean(decimal value);
    public static bool ToBoolean(DateTime value);
    public static char ToChar(object value);
    public static char ToChar(object value, IFormatProvider provider);
    public static char ToChar(bool value);
    public static char ToChar(char value);
    [CLSCompliantAttribute("False")]
public static char ToChar(sbyte value);
    public static char ToChar(byte value);
    public static char ToChar(short value);
    [CLSCompliantAttribute("False")]
public static char ToChar(ushort value);
    public static char ToChar(int value);
    [CLSCompliantAttribute("False")]
public static char ToChar(UInt32 value);
    public static char ToChar(long value);
    [CLSCompliantAttribute("False")]
public static char ToChar(ulong value);
    [NullableContextAttribute("1")]
public static char ToChar(string value);
    [NullableContextAttribute("1")]
public static char ToChar(string value, IFormatProvider provider);
    public static char ToChar(float value);
    public static char ToChar(double value);
    public static char ToChar(decimal value);
    public static char ToChar(DateTime value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(object value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(bool value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(sbyte value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(char value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(byte value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(short value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(ushort value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(int value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(UInt32 value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(long value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(ulong value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(float value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(double value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(decimal value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(string value);
    [CLSCompliantAttribute("False")]
[NullableContextAttribute("1")]
public static sbyte ToSByte(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(DateTime value);
    public static byte ToByte(object value);
    public static byte ToByte(object value, IFormatProvider provider);
    public static byte ToByte(bool value);
    public static byte ToByte(byte value);
    public static byte ToByte(char value);
    [CLSCompliantAttribute("False")]
public static byte ToByte(sbyte value);
    public static byte ToByte(short value);
    [CLSCompliantAttribute("False")]
public static byte ToByte(ushort value);
    public static byte ToByte(int value);
    [CLSCompliantAttribute("False")]
public static byte ToByte(UInt32 value);
    public static byte ToByte(long value);
    [CLSCompliantAttribute("False")]
public static byte ToByte(ulong value);
    public static byte ToByte(float value);
    public static byte ToByte(double value);
    public static byte ToByte(decimal value);
    public static byte ToByte(string value);
    public static byte ToByte(string value, IFormatProvider provider);
    public static byte ToByte(DateTime value);
    public static short ToInt16(object value);
    public static short ToInt16(object value, IFormatProvider provider);
    public static short ToInt16(bool value);
    public static short ToInt16(char value);
    [CLSCompliantAttribute("False")]
public static short ToInt16(sbyte value);
    public static short ToInt16(byte value);
    [CLSCompliantAttribute("False")]
public static short ToInt16(ushort value);
    public static short ToInt16(int value);
    [CLSCompliantAttribute("False")]
public static short ToInt16(UInt32 value);
    public static short ToInt16(short value);
    public static short ToInt16(long value);
    [CLSCompliantAttribute("False")]
public static short ToInt16(ulong value);
    public static short ToInt16(float value);
    public static short ToInt16(double value);
    public static short ToInt16(decimal value);
    public static short ToInt16(string value);
    public static short ToInt16(string value, IFormatProvider provider);
    public static short ToInt16(DateTime value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(object value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(bool value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(char value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(sbyte value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(byte value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(short value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(int value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(ushort value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(UInt32 value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(long value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(ulong value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(float value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(double value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(decimal value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(string value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(DateTime value);
    public static int ToInt32(object value);
    public static int ToInt32(object value, IFormatProvider provider);
    public static int ToInt32(bool value);
    public static int ToInt32(char value);
    [CLSCompliantAttribute("False")]
public static int ToInt32(sbyte value);
    public static int ToInt32(byte value);
    public static int ToInt32(short value);
    [CLSCompliantAttribute("False")]
public static int ToInt32(ushort value);
    [CLSCompliantAttribute("False")]
public static int ToInt32(UInt32 value);
    public static int ToInt32(int value);
    public static int ToInt32(long value);
    [CLSCompliantAttribute("False")]
public static int ToInt32(ulong value);
    public static int ToInt32(float value);
    public static int ToInt32(double value);
    public static int ToInt32(decimal value);
    public static int ToInt32(string value);
    public static int ToInt32(string value, IFormatProvider provider);
    public static int ToInt32(DateTime value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(object value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(bool value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(char value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(sbyte value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(byte value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(short value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(ushort value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(int value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(UInt32 value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(long value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(ulong value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(float value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(double value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(decimal value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(string value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(DateTime value);
    public static long ToInt64(object value);
    public static long ToInt64(object value, IFormatProvider provider);
    public static long ToInt64(bool value);
    public static long ToInt64(char value);
    [CLSCompliantAttribute("False")]
public static long ToInt64(sbyte value);
    public static long ToInt64(byte value);
    public static long ToInt64(short value);
    [CLSCompliantAttribute("False")]
public static long ToInt64(ushort value);
    public static long ToInt64(int value);
    [CLSCompliantAttribute("False")]
public static long ToInt64(UInt32 value);
    [CLSCompliantAttribute("False")]
public static long ToInt64(ulong value);
    public static long ToInt64(long value);
    public static long ToInt64(float value);
    public static long ToInt64(double value);
    public static long ToInt64(decimal value);
    public static long ToInt64(string value);
    public static long ToInt64(string value, IFormatProvider provider);
    public static long ToInt64(DateTime value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(object value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(bool value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(char value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(sbyte value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(byte value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(short value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(ushort value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(int value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(UInt32 value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(long value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(ulong value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(float value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(double value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(decimal value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(string value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(DateTime value);
    public static float ToSingle(object value);
    public static float ToSingle(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static float ToSingle(sbyte value);
    public static float ToSingle(byte value);
    public static float ToSingle(char value);
    public static float ToSingle(short value);
    [CLSCompliantAttribute("False")]
public static float ToSingle(ushort value);
    public static float ToSingle(int value);
    [CLSCompliantAttribute("False")]
public static float ToSingle(UInt32 value);
    public static float ToSingle(long value);
    [CLSCompliantAttribute("False")]
public static float ToSingle(ulong value);
    public static float ToSingle(float value);
    public static float ToSingle(double value);
    public static float ToSingle(decimal value);
    public static float ToSingle(string value);
    public static float ToSingle(string value, IFormatProvider provider);
    public static float ToSingle(bool value);
    public static float ToSingle(DateTime value);
    public static double ToDouble(object value);
    public static double ToDouble(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static double ToDouble(sbyte value);
    public static double ToDouble(byte value);
    public static double ToDouble(short value);
    public static double ToDouble(char value);
    [CLSCompliantAttribute("False")]
public static double ToDouble(ushort value);
    public static double ToDouble(int value);
    [CLSCompliantAttribute("False")]
public static double ToDouble(UInt32 value);
    public static double ToDouble(long value);
    [CLSCompliantAttribute("False")]
public static double ToDouble(ulong value);
    public static double ToDouble(float value);
    public static double ToDouble(double value);
    public static double ToDouble(decimal value);
    public static double ToDouble(string value);
    public static double ToDouble(string value, IFormatProvider provider);
    public static double ToDouble(bool value);
    public static double ToDouble(DateTime value);
    public static decimal ToDecimal(object value);
    public static decimal ToDecimal(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static decimal ToDecimal(sbyte value);
    public static decimal ToDecimal(byte value);
    public static decimal ToDecimal(char value);
    public static decimal ToDecimal(short value);
    [CLSCompliantAttribute("False")]
public static decimal ToDecimal(ushort value);
    public static decimal ToDecimal(int value);
    [CLSCompliantAttribute("False")]
public static decimal ToDecimal(UInt32 value);
    public static decimal ToDecimal(long value);
    [CLSCompliantAttribute("False")]
public static decimal ToDecimal(ulong value);
    public static decimal ToDecimal(float value);
    public static decimal ToDecimal(double value);
    public static decimal ToDecimal(string value);
    public static decimal ToDecimal(string value, IFormatProvider provider);
    public static decimal ToDecimal(decimal value);
    public static decimal ToDecimal(bool value);
    public static decimal ToDecimal(DateTime value);
    public static DateTime ToDateTime(DateTime value);
    public static DateTime ToDateTime(object value);
    public static DateTime ToDateTime(object value, IFormatProvider provider);
    public static DateTime ToDateTime(string value);
    public static DateTime ToDateTime(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static DateTime ToDateTime(sbyte value);
    public static DateTime ToDateTime(byte value);
    public static DateTime ToDateTime(short value);
    [CLSCompliantAttribute("False")]
public static DateTime ToDateTime(ushort value);
    public static DateTime ToDateTime(int value);
    [CLSCompliantAttribute("False")]
public static DateTime ToDateTime(UInt32 value);
    public static DateTime ToDateTime(long value);
    [CLSCompliantAttribute("False")]
public static DateTime ToDateTime(ulong value);
    public static DateTime ToDateTime(bool value);
    public static DateTime ToDateTime(char value);
    public static DateTime ToDateTime(float value);
    public static DateTime ToDateTime(double value);
    public static DateTime ToDateTime(decimal value);
    public static string ToString(object value);
    public static string ToString(object value, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static string ToString(bool value);
    [NullableContextAttribute("1")]
public static string ToString(bool value, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static string ToString(char value);
    [NullableContextAttribute("1")]
public static string ToString(char value, IFormatProvider provider);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public static string ToString(sbyte value);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public static string ToString(sbyte value, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static string ToString(byte value);
    [NullableContextAttribute("1")]
public static string ToString(byte value, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static string ToString(short value);
    [NullableContextAttribute("1")]
public static string ToString(short value, IFormatProvider provider);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public static string ToString(ushort value);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public static string ToString(ushort value, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static string ToString(int value);
    [NullableContextAttribute("1")]
public static string ToString(int value, IFormatProvider provider);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public static string ToString(UInt32 value);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public static string ToString(UInt32 value, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static string ToString(long value);
    [NullableContextAttribute("1")]
public static string ToString(long value, IFormatProvider provider);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public static string ToString(ulong value);
    [CLSCompliantAttribute("False")]
[NullableContextAttribute("1")]
public static string ToString(ulong value, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static string ToString(float value);
    [NullableContextAttribute("1")]
public static string ToString(float value, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static string ToString(double value);
    [NullableContextAttribute("1")]
public static string ToString(double value, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static string ToString(decimal value);
    [NullableContextAttribute("1")]
public static string ToString(decimal value, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static string ToString(DateTime value);
    [NullableContextAttribute("1")]
public static string ToString(DateTime value, IFormatProvider provider);
    public static string ToString(string value);
    public static string ToString(string value, IFormatProvider provider);
    public static byte ToByte(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(string value, int fromBase);
    public static short ToInt16(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(string value, int fromBase);
    public static int ToInt32(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(string value, int fromBase);
    public static long ToInt64(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(string value, int fromBase);
    [NullableContextAttribute("1")]
public static string ToString(byte value, int toBase);
    [NullableContextAttribute("1")]
public static string ToString(short value, int toBase);
    [NullableContextAttribute("1")]
public static string ToString(int value, int toBase);
    [NullableContextAttribute("1")]
public static string ToString(long value, int toBase);
    [NullableContextAttribute("1")]
public static string ToBase64String(Byte[] inArray);
    [NullableContextAttribute("1")]
public static string ToBase64String(Byte[] inArray, Base64FormattingOptions options);
    [NullableContextAttribute("1")]
public static string ToBase64String(Byte[] inArray, int offset, int length);
    [NullableContextAttribute("1")]
public static string ToBase64String(Byte[] inArray, int offset, int length, Base64FormattingOptions options);
    [NullableContextAttribute("0")]
public static string ToBase64String(ReadOnlySpan`1<byte> bytes, Base64FormattingOptions options);
    [NullableContextAttribute("1")]
public static int ToBase64CharArray(Byte[] inArray, int offsetIn, int length, Char[] outArray, int offsetOut);
    [NullableContextAttribute("1")]
public static int ToBase64CharArray(Byte[] inArray, int offsetIn, int length, Char[] outArray, int offsetOut, Base64FormattingOptions options);
    [NullableContextAttribute("0")]
public static bool TryToBase64Chars(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, Int32& charsWritten, Base64FormattingOptions options);
    private static int ConvertToBase64Array(Char* outChars, Byte* inData, int offset, int length, bool insertLineBreaks);
    private static int ToBase64_CalculateAndValidateOutputLength(int inputLength, bool insertLineBreaks);
    [NullableContextAttribute("1")]
public static Byte[] FromBase64String(string s);
    [NullableContextAttribute("0")]
public static bool TryFromBase64String(string s, Span`1<byte> bytes, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public static bool TryFromBase64Chars(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, Int32& bytesWritten);
    private static void CopyToTempBufferWithoutWhiteSpace(ReadOnlySpan`1<char> chars, Span`1<char> tempBuffer, Int32& consumed, Int32& charsWritten);
    [ExtensionAttribute]
private static bool IsSpace(char c);
    [NullableContextAttribute("1")]
public static Byte[] FromBase64CharArray(Char[] inArray, int offset, int length);
    private static Byte[] FromBase64CharPtr(Char* inputPtr, int inputLength);
    private static int FromBase64_ComputeResultLength(Char* inputPtr, int inputLength);
    private static bool TryDecodeFromUtf16(ReadOnlySpan`1<char> utf16, Span`1<byte> bytes, Int32& consumed, Int32& written);
    private static int Decode(Char& encodedChars, SByte& decodingMap);
    private static void WriteThreeLowOrderBytes(Byte& destination, int value);
}
public class System.Converter`2 : MulticastDelegate {
    public Converter`2(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TOutput Invoke(TInput input);
    public virtual IAsyncResult BeginInvoke(TInput input, AsyncCallback callback, object object);
    public virtual TOutput EndInvoke(IAsyncResult result);
}
internal class System.CtorDelegate : MulticastDelegate {
    public CtorDelegate(object object, IntPtr method);
    public virtual void Invoke(object instance);
    public virtual IAsyncResult BeginInvoke(object instance, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.CultureAwareComparer : StringComparer {
    private CompareInfo _compareInfo;
    private CompareOptions _options;
    internal CultureAwareComparer(CultureInfo culture, CompareOptions options);
    internal CultureAwareComparer(CompareInfo compareInfo, CompareOptions options);
    private CultureAwareComparer(SerializationInfo info, StreamingContext context);
    public virtual int Compare(string x, string y);
    public virtual bool Equals(string x, string y);
    [NullableContextAttribute("1")]
public virtual int GetHashCode(string obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class System.Currency : ValueType {
    internal long m_value;
    public Currency(decimal value);
}
[ObsoleteAttribute("System.CurrentSystemTimeZone has been deprecated.  Please investigate the use of System.TimeZoneInfo.Local instead.")]
internal class System.CurrentSystemTimeZone : TimeZone {
    private long m_ticksOffset;
    private string m_standardName;
    private string m_daylightName;
    private Hashtable m_CachedDaylightChanges;
    public string StandardName { get; }
    public string DaylightName { get; }
    public virtual string get_StandardName();
    public virtual string get_DaylightName();
    internal long GetUtcOffsetFromUniversalTime(DateTime time, Boolean& isAmbiguousLocalDst);
    public virtual DateTime ToLocalTime(DateTime time);
    public virtual DaylightTime GetDaylightChanges(int year);
    private static DaylightTime CreateDaylightChanges(int year);
    public virtual TimeSpan GetUtcOffset(DateTime time);
    private DaylightTime GetCachedDaylightChanges(int year);
}
[NullableContextAttribute("2")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableAttribute("0")]
public class System.DataMisalignedException : SystemException {
    public DataMisalignedException(string message);
    public DataMisalignedException(string message, Exception innerException);
    internal DataMisalignedException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.DateTime : ValueType {
    private static Int32[] s_daysToMonth365;
    private static Int32[] s_daysToMonth366;
    public static DateTime MinValue;
    public static DateTime MaxValue;
    public static DateTime UnixEpoch;
    private ulong _dateData;
    internal static bool s_systemSupportsLeapSeconds;
    internal long InternalTicks { get; }
    private ulong InternalKind { get; }
    public DateTime Date { get; }
    public int Day { get; }
    public DayOfWeek DayOfWeek { get; }
    public int DayOfYear { get; }
    public int Hour { get; }
    public DateTimeKind Kind { get; }
    public int Millisecond { get; }
    public int Minute { get; }
    public int Month { get; }
    public static DateTime Now { get; }
    public int Second { get; }
    public long Ticks { get; }
    public TimeSpan TimeOfDay { get; }
    public static DateTime Today { get; }
    public int Year { get; }
    public static DateTime UtcNow { get; }
    public DateTime(long ticks);
    private DateTime(ulong dateData);
    public DateTime(long ticks, DateTimeKind kind);
    internal DateTime(long ticks, DateTimeKind kind, bool isAmbiguousDst);
    public DateTime(int year, int month, int day);
    public DateTime(int year, int month, int day, Calendar calendar);
    public DateTime(int year, int month, int day, int hour, int minute, int second);
    public DateTime(int year, int month, int day, int hour, int minute, int second, DateTimeKind kind);
    public DateTime(int year, int month, int day, int hour, int minute, int second, Calendar calendar);
    public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond);
    public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, DateTimeKind kind);
    public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, Calendar calendar);
    public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, Calendar calendar, DateTimeKind kind);
    private DateTime(SerializationInfo info, StreamingContext context);
    private static DateTime();
    private static bool ValidateSystemTime(SYSTEMTIME* time, bool localTime);
    private static bool FileTimeToSystemTime(long fileTime, FullSystemTime* time);
    private static void GetSystemTimeWithLeapSecondsHandling(FullSystemTime* time);
    private static bool SystemTimeToFileTime(SYSTEMTIME* time, Int64* fileTime);
    private static long GetSystemTimeAsFileTime();
    internal long get_InternalTicks();
    private ulong get_InternalKind();
    public DateTime Add(TimeSpan value);
    private DateTime Add(double value, int scale);
    public DateTime AddDays(double value);
    public DateTime AddHours(double value);
    public DateTime AddMilliseconds(double value);
    public DateTime AddMinutes(double value);
    public DateTime AddMonths(int months);
    public DateTime AddSeconds(double value);
    public DateTime AddTicks(long value);
    internal bool TryAddTicks(long value, DateTime& result);
    public DateTime AddYears(int value);
    public static int Compare(DateTime t1, DateTime t2);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(DateTime value);
    private static long DateToTicks(int year, int month, int day);
    private static long TimeToTicks(int hour, int minute, int second);
    public static int DaysInMonth(int year, int month);
    internal static long DoubleDateToTicks(double value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public sealed virtual bool Equals(DateTime value);
    public static bool Equals(DateTime t1, DateTime t2);
    public static DateTime FromBinary(long dateData);
    internal static DateTime FromBinaryRaw(long dateData);
    public static DateTime FromFileTime(long fileTime);
    public static DateTime FromFileTimeUtc(long fileTime);
    public static DateTime FromOADate(double d);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public bool IsDaylightSavingTime();
    public static DateTime SpecifyKind(DateTime value, DateTimeKind kind);
    public long ToBinary();
    public DateTime get_Date();
    private int GetDatePart(int part);
    internal void GetDatePart(Int32& year, Int32& month, Int32& day);
    public int get_Day();
    public DayOfWeek get_DayOfWeek();
    public int get_DayOfYear();
    public virtual int GetHashCode();
    public int get_Hour();
    internal bool IsAmbiguousDaylightSavingTime();
    public DateTimeKind get_Kind();
    public int get_Millisecond();
    public int get_Minute();
    public int get_Month();
    public static DateTime get_Now();
    public int get_Second();
    public long get_Ticks();
    public TimeSpan get_TimeOfDay();
    public static DateTime get_Today();
    public int get_Year();
    public static bool IsLeapYear(int year);
    public static DateTime Parse(string s);
    public static DateTime Parse(string s, IFormatProvider provider);
    public static DateTime Parse(string s, IFormatProvider provider, DateTimeStyles styles);
    [NullableContextAttribute("0")]
public static DateTime Parse(ReadOnlySpan`1<char> s, IFormatProvider provider, DateTimeStyles styles);
    public static DateTime ParseExact(string s, string format, IFormatProvider provider);
    public static DateTime ParseExact(string s, string format, IFormatProvider provider, DateTimeStyles style);
    [NullableContextAttribute("0")]
public static DateTime ParseExact(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, IFormatProvider provider, DateTimeStyles style);
    public static DateTime ParseExact(string s, String[] formats, IFormatProvider provider, DateTimeStyles style);
    [NullableContextAttribute("0")]
public static DateTime ParseExact(ReadOnlySpan`1<char> s, String[] formats, IFormatProvider provider, DateTimeStyles style);
    public TimeSpan Subtract(DateTime value);
    public DateTime Subtract(TimeSpan value);
    private static double TicksToOADate(long value);
    public double ToOADate();
    public long ToFileTime();
    public long ToFileTimeUtc();
    public DateTime ToLocalTime();
    internal DateTime ToLocalTime(bool throwOnOverflow);
    public string ToLongDateString();
    public string ToLongTimeString();
    public string ToShortDateString();
    public string ToShortTimeString();
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(IFormatProvider provider);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    [NullableContextAttribute("0")]
public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public DateTime ToUniversalTime();
    [NullableContextAttribute("2")]
public static bool TryParse(string s, DateTime& result);
    [NullableContextAttribute("0")]
public static bool TryParse(ReadOnlySpan`1<char> s, DateTime& result);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, IFormatProvider provider, DateTimeStyles styles, DateTime& result);
    [NullableContextAttribute("0")]
public static bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, DateTimeStyles styles, DateTime& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(string s, string format, IFormatProvider provider, DateTimeStyles style, DateTime& result);
    [NullableContextAttribute("0")]
public static bool TryParseExact(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, IFormatProvider provider, DateTimeStyles style, DateTime& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(string s, String[] formats, IFormatProvider provider, DateTimeStyles style, DateTime& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(ReadOnlySpan`1<char> s, String[] formats, IFormatProvider provider, DateTimeStyles style, DateTime& result);
    public static DateTime op_Addition(DateTime d, TimeSpan t);
    public static DateTime op_Subtraction(DateTime d, TimeSpan t);
    public static TimeSpan op_Subtraction(DateTime d1, DateTime d2);
    public static bool op_Equality(DateTime d1, DateTime d2);
    public static bool op_Inequality(DateTime d1, DateTime d2);
    public static bool op_LessThan(DateTime t1, DateTime t2);
    public static bool op_LessThanOrEqual(DateTime t1, DateTime t2);
    public static bool op_GreaterThan(DateTime t1, DateTime t2);
    public static bool op_GreaterThanOrEqual(DateTime t1, DateTime t2);
    public String[] GetDateTimeFormats();
    public String[] GetDateTimeFormats(IFormatProvider provider);
    public String[] GetDateTimeFormats(char format);
    public String[] GetDateTimeFormats(char format, IFormatProvider provider);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    internal static bool TryCreate(int year, int month, int day, int hour, int minute, int second, int millisecond, DateTime& result);
    public static DateTime get_UtcNow();
    internal static bool IsValidTimeWithLeapSeconds(int year, int month, int day, int hour, int minute, int second, DateTimeKind kind);
    private static DateTime FromFileTimeLeapSecondsAware(long fileTime);
    private static long ToFileTimeLeapSecondsAware(long ticks);
    private static DateTime CreateDateTimeFromSystemTime(FullSystemTime& time);
    private static bool SystemSupportsLeapSeconds();
}
internal static class System.DateTimeFormat : object {
    internal static TimeSpan NullOffset;
    internal static Char[] allStandardFormats;
    internal static DateTimeFormatInfo InvariantFormatInfo;
    internal static String[] InvariantAbbreviatedMonthNames;
    internal static String[] InvariantAbbreviatedDayNames;
    internal static String[] fixedNumberFormats;
    private static DateTimeFormat();
    internal static void FormatDigits(StringBuilder outputBuffer, int value, int len);
    internal static void FormatDigits(StringBuilder outputBuffer, int value, int len, bool overrideLengthLimit);
    private static void HebrewFormatDigits(StringBuilder outputBuffer, int digits);
    internal static int ParseRepeatPattern(ReadOnlySpan`1<char> format, int pos, char patternChar);
    private static string FormatDayOfWeek(int dayOfWeek, int repeat, DateTimeFormatInfo dtfi);
    private static string FormatMonth(int month, int repeatCount, DateTimeFormatInfo dtfi);
    private static string FormatHebrewMonthName(DateTime time, int month, int repeatCount, DateTimeFormatInfo dtfi);
    internal static int ParseQuoteString(ReadOnlySpan`1<char> format, int pos, StringBuilder result);
    internal static int ParseNextChar(ReadOnlySpan`1<char> format, int pos);
    private static bool IsUseGenitiveForm(ReadOnlySpan`1<char> format, int index, int tokenLen, char patternToMatch);
    private static StringBuilder FormatCustomized(DateTime dateTime, ReadOnlySpan`1<char> format, DateTimeFormatInfo dtfi, TimeSpan offset, StringBuilder result);
    private static void FormatCustomizedTimeZone(DateTime dateTime, TimeSpan offset, ReadOnlySpan`1<char> format, int tokenLen, bool timeOnly, StringBuilder result);
    private static void FormatCustomizedRoundripTimeZone(DateTime dateTime, TimeSpan offset, StringBuilder result);
    private static void Append2DigitNumber(StringBuilder result, int val);
    internal static string GetRealFormat(ReadOnlySpan`1<char> format, DateTimeFormatInfo dtfi);
    private static string ExpandPredefinedFormat(ReadOnlySpan`1<char> format, DateTime& dateTime, DateTimeFormatInfo& dtfi, TimeSpan& offset);
    internal static string Format(DateTime dateTime, string format, IFormatProvider provider);
    internal static string Format(DateTime dateTime, string format, IFormatProvider provider, TimeSpan offset);
    internal static bool TryFormat(DateTime dateTime, Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    internal static bool TryFormat(DateTime dateTime, Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider, TimeSpan offset);
    private static StringBuilder FormatStringBuilder(DateTime dateTime, ReadOnlySpan`1<char> format, DateTimeFormatInfo dtfi, TimeSpan offset);
    private static bool TryFormatO(DateTime dateTime, TimeSpan offset, Span`1<char> destination, Int32& charsWritten);
    private static bool TryFormatR(DateTime dateTime, TimeSpan offset, Span`1<char> destination, Int32& charsWritten);
    private static void WriteTwoDecimalDigits(UInt32 value, Span`1<char> destination, int offset);
    private static void WriteFourDecimalDigits(UInt32 value, Span`1<char> buffer, int startingIndex);
    private static void WriteDigits(ulong value, Span`1<char> buffer);
    internal static String[] GetAllDateTimes(DateTime dateTime, char format, DateTimeFormatInfo dtfi);
    internal static String[] GetAllDateTimes(DateTime dateTime, DateTimeFormatInfo dtfi);
    internal static void InvalidFormatForLocal(ReadOnlySpan`1<char> format, DateTime dateTime);
}
public enum System.DateTimeKind : Enum {
    public int value__;
    public static DateTimeKind Unspecified;
    public static DateTimeKind Utc;
    public static DateTimeKind Local;
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[IsReadOnlyAttribute]
public class System.DateTimeOffset : ValueType {
    public static DateTimeOffset MinValue;
    public static DateTimeOffset MaxValue;
    public static DateTimeOffset UnixEpoch;
    private DateTime _dateTime;
    private short _offsetMinutes;
    public static DateTimeOffset Now { get; }
    public static DateTimeOffset UtcNow { get; }
    public DateTime DateTime { get; }
    public DateTime UtcDateTime { get; }
    public DateTime LocalDateTime { get; }
    private DateTime ClockDateTime { get; }
    public DateTime Date { get; }
    public int Day { get; }
    public DayOfWeek DayOfWeek { get; }
    public int DayOfYear { get; }
    public int Hour { get; }
    public int Millisecond { get; }
    public int Minute { get; }
    public int Month { get; }
    public TimeSpan Offset { get; }
    public int Second { get; }
    public long Ticks { get; }
    public long UtcTicks { get; }
    public TimeSpan TimeOfDay { get; }
    public int Year { get; }
    public DateTimeOffset(long ticks, TimeSpan offset);
    public DateTimeOffset(DateTime dateTime);
    public DateTimeOffset(DateTime dateTime, TimeSpan offset);
    public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, TimeSpan offset);
    public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, TimeSpan offset);
    [NullableContextAttribute("1")]
public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, Calendar calendar, TimeSpan offset);
    private DateTimeOffset(SerializationInfo info, StreamingContext context);
    private static DateTimeOffset();
    public static DateTimeOffset get_Now();
    public static DateTimeOffset get_UtcNow();
    public DateTime get_DateTime();
    public DateTime get_UtcDateTime();
    public DateTime get_LocalDateTime();
    public DateTimeOffset ToOffset(TimeSpan offset);
    private DateTime get_ClockDateTime();
    public DateTime get_Date();
    public int get_Day();
    public DayOfWeek get_DayOfWeek();
    public int get_DayOfYear();
    public int get_Hour();
    public int get_Millisecond();
    public int get_Minute();
    public int get_Month();
    public TimeSpan get_Offset();
    public int get_Second();
    public long get_Ticks();
    public long get_UtcTicks();
    public TimeSpan get_TimeOfDay();
    public int get_Year();
    public DateTimeOffset Add(TimeSpan timeSpan);
    public DateTimeOffset AddDays(double days);
    public DateTimeOffset AddHours(double hours);
    public DateTimeOffset AddMilliseconds(double milliseconds);
    public DateTimeOffset AddMinutes(double minutes);
    public DateTimeOffset AddMonths(int months);
    public DateTimeOffset AddSeconds(double seconds);
    public DateTimeOffset AddTicks(long ticks);
    public DateTimeOffset AddYears(int years);
    public static int Compare(DateTimeOffset first, DateTimeOffset second);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public sealed virtual int CompareTo(DateTimeOffset other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(DateTimeOffset other);
    public bool EqualsExact(DateTimeOffset other);
    public static bool Equals(DateTimeOffset first, DateTimeOffset second);
    public static DateTimeOffset FromFileTime(long fileTime);
    public static DateTimeOffset FromUnixTimeSeconds(long seconds);
    public static DateTimeOffset FromUnixTimeMilliseconds(long milliseconds);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public static DateTimeOffset Parse(string input);
    [NullableContextAttribute("1")]
public static DateTimeOffset Parse(string input, IFormatProvider formatProvider);
    [NullableContextAttribute("1")]
public static DateTimeOffset Parse(string input, IFormatProvider formatProvider, DateTimeStyles styles);
    public static DateTimeOffset Parse(ReadOnlySpan`1<char> input, IFormatProvider formatProvider, DateTimeStyles styles);
    [NullableContextAttribute("1")]
public static DateTimeOffset ParseExact(string input, string format, IFormatProvider formatProvider);
    [NullableContextAttribute("1")]
public static DateTimeOffset ParseExact(string input, string format, IFormatProvider formatProvider, DateTimeStyles styles);
    public static DateTimeOffset ParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, IFormatProvider formatProvider, DateTimeStyles styles);
    [NullableContextAttribute("1")]
public static DateTimeOffset ParseExact(string input, String[] formats, IFormatProvider formatProvider, DateTimeStyles styles);
    public static DateTimeOffset ParseExact(ReadOnlySpan`1<char> input, String[] formats, IFormatProvider formatProvider, DateTimeStyles styles);
    public TimeSpan Subtract(DateTimeOffset value);
    public DateTimeOffset Subtract(TimeSpan value);
    public long ToFileTime();
    public long ToUnixTimeSeconds();
    public long ToUnixTimeMilliseconds();
    public DateTimeOffset ToLocalTime();
    internal DateTimeOffset ToLocalTime(bool throwOnOverflow);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("1")]
public string ToString(IFormatProvider formatProvider);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider formatProvider);
    public DateTimeOffset ToUniversalTime();
    [NullableContextAttribute("2")]
public static bool TryParse(string input, DateTimeOffset& result);
    public static bool TryParse(ReadOnlySpan`1<char> input, DateTimeOffset& result);
    [NullableContextAttribute("2")]
public static bool TryParse(string input, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
    public static bool TryParse(ReadOnlySpan`1<char> input, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(string input, string format, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(string input, String[] formats, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(ReadOnlySpan`1<char> input, String[] formats, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
    private static short ValidateOffset(TimeSpan offset);
    private static DateTime ValidateDate(DateTime dateTime, TimeSpan offset);
    private static DateTimeStyles ValidateStyles(DateTimeStyles style, string parameterName);
    public static DateTimeOffset op_Implicit(DateTime dateTime);
    public static DateTimeOffset op_Addition(DateTimeOffset dateTimeOffset, TimeSpan timeSpan);
    public static DateTimeOffset op_Subtraction(DateTimeOffset dateTimeOffset, TimeSpan timeSpan);
    public static TimeSpan op_Subtraction(DateTimeOffset left, DateTimeOffset right);
    public static bool op_Equality(DateTimeOffset left, DateTimeOffset right);
    public static bool op_Inequality(DateTimeOffset left, DateTimeOffset right);
    public static bool op_LessThan(DateTimeOffset left, DateTimeOffset right);
    public static bool op_LessThanOrEqual(DateTimeOffset left, DateTimeOffset right);
    public static bool op_GreaterThan(DateTimeOffset left, DateTimeOffset right);
    public static bool op_GreaterThanOrEqual(DateTimeOffset left, DateTimeOffset right);
}
internal static class System.DateTimeParse : object {
    internal static MatchNumberDelegate m_hebrewNumberParser;
    private static DS[][] dateParsingStates;
    private static DateTimeParse();
    internal static DateTime ParseExact(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, DateTimeFormatInfo dtfi, DateTimeStyles style);
    internal static DateTime ParseExact(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, DateTimeFormatInfo dtfi, DateTimeStyles style, TimeSpan& offset);
    internal static bool TryParseExact(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, DateTimeFormatInfo dtfi, DateTimeStyles style, DateTime& result);
    internal static bool TryParseExact(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, DateTimeFormatInfo dtfi, DateTimeStyles style, DateTime& result, TimeSpan& offset);
    internal static bool TryParseExact(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, DateTimeFormatInfo dtfi, DateTimeStyles style, DateTimeResult& result);
    internal static DateTime ParseExactMultiple(ReadOnlySpan`1<char> s, String[] formats, DateTimeFormatInfo dtfi, DateTimeStyles style);
    internal static DateTime ParseExactMultiple(ReadOnlySpan`1<char> s, String[] formats, DateTimeFormatInfo dtfi, DateTimeStyles style, TimeSpan& offset);
    internal static bool TryParseExactMultiple(ReadOnlySpan`1<char> s, String[] formats, DateTimeFormatInfo dtfi, DateTimeStyles style, DateTime& result, TimeSpan& offset);
    internal static bool TryParseExactMultiple(ReadOnlySpan`1<char> s, String[] formats, DateTimeFormatInfo dtfi, DateTimeStyles style, DateTime& result);
    internal static bool TryParseExactMultiple(ReadOnlySpan`1<char> s, String[] formats, DateTimeFormatInfo dtfi, DateTimeStyles style, DateTimeResult& result);
    private static bool MatchWord(__DTString& str, string target);
    private static bool GetTimeZoneName(__DTString& str);
    internal static bool IsDigit(char ch);
    private static bool ParseFraction(__DTString& str, Double& result);
    private static bool ParseTimeZone(__DTString& str, TimeSpan& result);
    private static bool HandleTimeZone(__DTString& str, DateTimeResult& result);
    private static bool Lex(DS dps, __DTString& str, DateTimeToken& dtok, DateTimeRawInfo& raw, DateTimeResult& result, DateTimeFormatInfo& dtfi, DateTimeStyles styles);
    private static bool VerifyValidPunctuation(__DTString& str);
    private static bool GetYearMonthDayOrder(string datePattern, DateTimeFormatInfo dtfi, Int32& order);
    private static bool GetYearMonthOrder(string pattern, DateTimeFormatInfo dtfi, Int32& order);
    private static bool GetMonthDayOrder(string pattern, DateTimeFormatInfo dtfi, Int32& order);
    private static bool TryAdjustYear(DateTimeResult& result, int year, Int32& adjustedYear);
    private static bool SetDateYMD(DateTimeResult& result, int year, int month, int day);
    private static bool SetDateMDY(DateTimeResult& result, int month, int day, int year);
    private static bool SetDateDMY(DateTimeResult& result, int day, int month, int year);
    private static bool SetDateYDM(DateTimeResult& result, int year, int day, int month);
    private static void GetDefaultYear(DateTimeResult& result, DateTimeStyles& styles);
    private static bool GetDayOfNN(DateTimeResult& result, DateTimeStyles& styles, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool GetDayOfNNN(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool GetDayOfMN(DateTimeResult& result, DateTimeStyles& styles, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool GetHebrewDayOfNM(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool GetDayOfNM(DateTimeResult& result, DateTimeStyles& styles, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool GetDayOfMNN(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool GetDayOfYNN(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool GetDayOfNNY(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool GetDayOfYMN(DateTimeResult& result, DateTimeRawInfo& raw);
    private static bool GetDayOfYN(DateTimeResult& result, DateTimeRawInfo& raw);
    private static bool GetDayOfYM(DateTimeResult& result, DateTimeRawInfo& raw);
    private static void AdjustTimeMark(DateTimeFormatInfo dtfi, DateTimeRawInfo& raw);
    private static bool AdjustHour(Int32& hour, TM timeMark);
    private static bool GetTimeOfN(DateTimeResult& result, DateTimeRawInfo& raw);
    private static bool GetTimeOfNN(DateTimeResult& result, DateTimeRawInfo& raw);
    private static bool GetTimeOfNNN(DateTimeResult& result, DateTimeRawInfo& raw);
    private static bool GetDateOfDSN(DateTimeResult& result, DateTimeRawInfo& raw);
    private static bool GetDateOfNDS(DateTimeResult& result, DateTimeRawInfo& raw);
    private static bool GetDateOfNNDS(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool ProcessDateTimeSuffix(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeToken& dtok);
    internal static bool ProcessHebrewTerminalState(DS dps, __DTString& str, DateTimeResult& result, DateTimeStyles& styles, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    internal static bool ProcessTerminalState(DS dps, __DTString& str, DateTimeResult& result, DateTimeStyles& styles, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    internal static DateTime Parse(ReadOnlySpan`1<char> s, DateTimeFormatInfo dtfi, DateTimeStyles styles);
    internal static DateTime Parse(ReadOnlySpan`1<char> s, DateTimeFormatInfo dtfi, DateTimeStyles styles, TimeSpan& offset);
    internal static bool TryParse(ReadOnlySpan`1<char> s, DateTimeFormatInfo dtfi, DateTimeStyles styles, DateTime& result);
    internal static bool TryParse(ReadOnlySpan`1<char> s, DateTimeFormatInfo dtfi, DateTimeStyles styles, DateTime& result, TimeSpan& offset);
    internal static bool TryParse(ReadOnlySpan`1<char> s, DateTimeFormatInfo dtfi, DateTimeStyles styles, DateTimeResult& result);
    private static bool DetermineTimeZoneAdjustments(DateTimeResult& result, DateTimeStyles styles, bool bTimeOnly);
    private static bool DateTimeOffsetTimeZonePostProcessing(DateTimeResult& result, DateTimeStyles styles);
    private static bool AdjustTimeZoneToUniversal(DateTimeResult& result);
    private static bool AdjustTimeZoneToLocal(DateTimeResult& result, bool bTimeOnly);
    private static bool ParseISO8601(DateTimeRawInfo& raw, __DTString& str, DateTimeStyles styles, DateTimeResult& result);
    internal static bool MatchHebrewDigits(__DTString& str, int digitLen, Int32& number);
    internal static bool ParseDigits(__DTString& str, int digitLen, Int32& result);
    internal static bool ParseDigits(__DTString& str, int minDigitLen, int maxDigitLen, Int32& result);
    private static bool ParseFractionExact(__DTString& str, int maxDigitLen, Double& result);
    private static bool ParseSign(__DTString& str, Boolean& result);
    private static bool ParseTimeZoneOffset(__DTString& str, int len, TimeSpan& result);
    private static bool MatchAbbreviatedMonthName(__DTString& str, DateTimeFormatInfo dtfi, Int32& result);
    private static bool MatchMonthName(__DTString& str, DateTimeFormatInfo dtfi, Int32& result);
    private static bool MatchAbbreviatedDayName(__DTString& str, DateTimeFormatInfo dtfi, Int32& result);
    private static bool MatchDayName(__DTString& str, DateTimeFormatInfo dtfi, Int32& result);
    private static bool MatchEraName(__DTString& str, DateTimeFormatInfo dtfi, Int32& result);
    private static bool MatchTimeMark(__DTString& str, DateTimeFormatInfo dtfi, TM& result);
    private static bool MatchAbbreviatedTimeMark(__DTString& str, DateTimeFormatInfo dtfi, TM& result);
    private static bool CheckNewValue(Int32& currentValue, int newValue, char patternChar, DateTimeResult& result);
    private static DateTime GetDateTimeNow(DateTimeResult& result, DateTimeStyles& styles);
    private static bool CheckDefaultDateTime(DateTimeResult& result, Calendar& cal, DateTimeStyles styles);
    private static string ExpandPredefinedFormat(ReadOnlySpan`1<char> format, DateTimeFormatInfo& dtfi, ParsingInfo& parseInfo, DateTimeResult& result);
    private static bool ParseJapaneseEraStart(__DTString& str, DateTimeFormatInfo dtfi);
    private static void ConfigureFormatR(DateTimeFormatInfo& dtfi, ParsingInfo& parseInfo, DateTimeResult& result);
    private static void ConfigureFormatOS(DateTimeFormatInfo& dtfi, ParsingInfo& parseInfo);
    private static bool ParseByFormat(__DTString& str, __DTString& format, ParsingInfo& parseInfo, DateTimeFormatInfo dtfi, DateTimeResult& result);
    internal static bool TryParseQuoteString(ReadOnlySpan`1<char> format, int pos, StringBuilder result, Int32& returnValue);
    private static bool DoStrictParse(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> formatParam, DateTimeStyles styles, DateTimeFormatInfo dtfi, DateTimeResult& result);
    private static bool ParseFormatR(ReadOnlySpan`1<char> source, ParsingInfo& parseInfo, DateTimeResult& result);
    private static bool ParseFormatO(ReadOnlySpan`1<char> source, ParsingInfo& parseInfo, DateTimeResult& result);
    private static Exception GetDateTimeParseException(DateTimeResult& result);
}
internal class System.DateTimeRawInfo : ValueType {
    private Int32* num;
    internal int numCount;
    internal int month;
    internal int year;
    internal int dayOfWeek;
    internal int era;
    internal TM timeMark;
    internal double fraction;
    internal bool hasSameDateAndTimeSeparators;
    internal void Init(Int32* numberBuffer);
    internal void AddNumber(int value);
    internal int GetNumber(int index);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class System.DateTimeResult : ValueType {
    internal int Year;
    internal int Month;
    internal int Day;
    internal int Hour;
    internal int Minute;
    internal int Second;
    internal double fraction;
    internal int era;
    internal ParseFlags flags;
    internal TimeSpan timeZoneOffset;
    internal Calendar calendar;
    internal DateTime parsedDate;
    internal ParseFailureKind failure;
    internal string failureMessageID;
    internal object failureMessageFormatArgument;
    internal string failureArgumentName;
    internal ReadOnlySpan`1<char> originalDateTimeString;
    internal ReadOnlySpan`1<char> failedFormatSpecifier;
    internal void Init(ReadOnlySpan`1<char> originalDateTimeString);
    internal void SetDate(int year, int month, int day);
    internal void SetBadFormatSpecifierFailure();
    internal void SetBadFormatSpecifierFailure(ReadOnlySpan`1<char> failedFormatSpecifier);
    internal void SetBadDateTimeFailure();
    internal void SetFailure(ParseFailureKind failure, string failureMessageID);
    internal void SetFailure(ParseFailureKind failure, string failureMessageID, object failureMessageFormatArgument);
    internal void SetFailure(ParseFailureKind failure, string failureMessageID, object failureMessageFormatArgument, string failureArgumentName);
}
internal class System.DateTimeToken : ValueType {
    internal DTT dtt;
    internal TokenType suffix;
    internal int num;
}
public enum System.DayOfWeek : Enum {
    public int value__;
    public static DayOfWeek Sunday;
    public static DayOfWeek Monday;
    public static DayOfWeek Tuesday;
    public static DayOfWeek Wednesday;
    public static DayOfWeek Thursday;
    public static DayOfWeek Friday;
    public static DayOfWeek Saturday;
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.DBNull : object {
    public static DBNull Value;
    private DBNull(SerializationInfo info, StreamingContext context);
    private static DBNull();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NonVersionableAttribute]
[IsReadOnlyAttribute]
public class System.Decimal : ValueType {
    [DecimalConstantAttribute("0", "0", "0", "0", "0")]
public static decimal Zero;
    [DecimalConstantAttribute("0", "0", "0", "0", "1")]
public static decimal One;
    [DecimalConstantAttribute("0", "128", "0", "0", "1")]
public static decimal MinusOne;
    [DecimalConstantAttribute("0", "0", "4294967295", "4294967295", "4294967295")]
public static decimal MaxValue;
    [DecimalConstantAttribute("0", "128", "4294967295", "4294967295", "4294967295")]
public static decimal MinValue;
    private int flags;
    private int hi;
    private int lo;
    private int mid;
    internal UInt32 High { get; }
    internal UInt32 Low { get; }
    internal UInt32 Mid { get; }
    internal bool IsNegative { get; }
    internal int Scale { get; }
    private ulong Low64 { get; }
    internal Decimal(Currency value);
    public Decimal(int value);
    [CLSCompliantAttribute("False")]
public Decimal(UInt32 value);
    public Decimal(long value);
    [CLSCompliantAttribute("False")]
public Decimal(ulong value);
    public Decimal(float value);
    public Decimal(double value);
    [NullableContextAttribute("1")]
public Decimal(Int32[] bits);
    public Decimal(int lo, int mid, int hi, bool isNegative, byte scale);
    private Decimal(int lo, int mid, int hi, int flags);
    private Decimal(Decimal& d, int flags);
    private static Decimal();
    public static decimal FromOACurrency(long cy);
    public static long ToOACurrency(decimal value);
    private static bool IsValid(int flags);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    internal static decimal Abs(Decimal& d);
    public static decimal Add(decimal d1, decimal d2);
    public static decimal Ceiling(decimal d);
    public static int Compare(decimal d1, decimal d2);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(decimal value);
    public static decimal Divide(decimal d1, decimal d2);
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public sealed virtual bool Equals(decimal value);
    public virtual int GetHashCode();
    public static bool Equals(decimal d1, decimal d2);
    public static decimal Floor(decimal d);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("1")]
public sealed virtual string ToString(IFormatProvider provider);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static decimal Parse(string s);
    [NullableContextAttribute("1")]
public static decimal Parse(string s, NumberStyles style);
    [NullableContextAttribute("1")]
public static decimal Parse(string s, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static decimal Parse(string s, NumberStyles style, IFormatProvider provider);
    public static decimal Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, Decimal& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, Decimal& result);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Decimal& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Decimal& result);
    [NullableContextAttribute("1")]
public static Int32[] GetBits(decimal d);
    internal static void GetBytes(Decimal& d, Byte[] buffer);
    internal static decimal ToDecimal(ReadOnlySpan`1<byte> span);
    internal static Decimal& modreq(System.Runtime.InteropServices.InAttribute) Max(Decimal& d1, Decimal& d2);
    internal static Decimal& modreq(System.Runtime.InteropServices.InAttribute) Min(Decimal& d1, Decimal& d2);
    public static decimal Remainder(decimal d1, decimal d2);
    public static decimal Multiply(decimal d1, decimal d2);
    public static decimal Negate(decimal d);
    public static decimal Round(decimal d);
    public static decimal Round(decimal d, int decimals);
    public static decimal Round(decimal d, MidpointRounding mode);
    public static decimal Round(decimal d, int decimals, MidpointRounding mode);
    private static decimal Round(Decimal& d, int decimals, MidpointRounding mode);
    internal static int Sign(Decimal& d);
    public static decimal Subtract(decimal d1, decimal d2);
    public static byte ToByte(decimal value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(decimal value);
    public static short ToInt16(decimal value);
    public static double ToDouble(decimal d);
    public static int ToInt32(decimal d);
    public static long ToInt64(decimal d);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(decimal value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(decimal d);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(decimal d);
    public static float ToSingle(decimal d);
    public static decimal Truncate(decimal d);
    private static void Truncate(Decimal& d);
    public static decimal op_Implicit(byte value);
    [CLSCompliantAttribute("False")]
public static decimal op_Implicit(sbyte value);
    public static decimal op_Implicit(short value);
    [CLSCompliantAttribute("False")]
public static decimal op_Implicit(ushort value);
    public static decimal op_Implicit(char value);
    public static decimal op_Implicit(int value);
    [CLSCompliantAttribute("False")]
public static decimal op_Implicit(UInt32 value);
    public static decimal op_Implicit(long value);
    [CLSCompliantAttribute("False")]
public static decimal op_Implicit(ulong value);
    public static decimal op_Explicit(float value);
    public static decimal op_Explicit(double value);
    public static byte op_Explicit(decimal value);
    [CLSCompliantAttribute("False")]
public static sbyte op_Explicit(decimal value);
    public static char op_Explicit(decimal value);
    public static short op_Explicit(decimal value);
    [CLSCompliantAttribute("False")]
public static ushort op_Explicit(decimal value);
    public static int op_Explicit(decimal value);
    [CLSCompliantAttribute("False")]
public static UInt32 op_Explicit(decimal value);
    public static long op_Explicit(decimal value);
    [CLSCompliantAttribute("False")]
public static ulong op_Explicit(decimal value);
    public static float op_Explicit(decimal value);
    public static double op_Explicit(decimal value);
    public static decimal op_UnaryPlus(decimal d);
    public static decimal op_UnaryNegation(decimal d);
    public static decimal op_Increment(decimal d);
    public static decimal op_Decrement(decimal d);
    public static decimal op_Addition(decimal d1, decimal d2);
    public static decimal op_Subtraction(decimal d1, decimal d2);
    public static decimal op_Multiply(decimal d1, decimal d2);
    public static decimal op_Division(decimal d1, decimal d2);
    public static decimal op_Modulus(decimal d1, decimal d2);
    public static bool op_Equality(decimal d1, decimal d2);
    public static bool op_Inequality(decimal d1, decimal d2);
    public static bool op_LessThan(decimal d1, decimal d2);
    public static bool op_LessThanOrEqual(decimal d1, decimal d2);
    public static bool op_GreaterThan(decimal d1, decimal d2);
    public static bool op_GreaterThanOrEqual(decimal d1, decimal d2);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    internal UInt32 get_High();
    internal UInt32 get_Low();
    internal UInt32 get_Mid();
    internal bool get_IsNegative();
    internal int get_Scale();
    private ulong get_Low64();
    private static DecCalc& AsMutable(Decimal& d);
    internal static UInt32 DecDivMod1E9(Decimal& value);
}
internal class System.DefaultBinder : Binder {
    private static Primitives[] s_primitiveConversions;
    private static DefaultBinder();
    public sealed virtual MethodBase BindToMethod(BindingFlags bindingAttr, MethodBase[] match, Object[]& args, ParameterModifier[] modifiers, CultureInfo cultureInfo, String[] names, Object& state);
    public sealed virtual FieldInfo BindToField(BindingFlags bindingAttr, FieldInfo[] match, object value, CultureInfo cultureInfo);
    public sealed virtual MethodBase SelectMethod(BindingFlags bindingAttr, MethodBase[] match, Type[] types, ParameterModifier[] modifiers);
    public sealed virtual PropertyInfo SelectProperty(BindingFlags bindingAttr, PropertyInfo[] match, Type returnType, Type[] indexes, ParameterModifier[] modifiers);
    public virtual object ChangeType(object value, Type type, CultureInfo cultureInfo);
    public sealed virtual void ReorderArgumentArray(Object[]& args, object state);
    public static MethodBase ExactBinding(MethodBase[] match, Type[] types, ParameterModifier[] modifiers);
    public static PropertyInfo ExactPropertyBinding(PropertyInfo[] match, Type returnType, Type[] types, ParameterModifier[] modifiers);
    private static int FindMostSpecific(ParameterInfo[] p1, Int32[] paramOrder1, Type paramArrayType1, ParameterInfo[] p2, Int32[] paramOrder2, Type paramArrayType2, Type[] types, Object[] args);
    private static int FindMostSpecificType(Type c1, Type c2, Type t);
    private static int FindMostSpecificMethod(MethodBase m1, Int32[] paramOrder1, Type paramArrayType1, MethodBase m2, Int32[] paramOrder2, Type paramArrayType2, Type[] types, Object[] args);
    private static int FindMostSpecificField(FieldInfo cur1, FieldInfo cur2);
    private static int FindMostSpecificProperty(PropertyInfo cur1, PropertyInfo cur2);
    public static bool CompareMethodSig(MethodBase m1, MethodBase m2);
    private static int GetHierarchyDepth(Type t);
    internal static MethodBase FindMostDerivedNewSlotMeth(MethodBase[] match, int cMatches);
    private static void ReorderParams(Int32[] paramOrder, Object[] vars);
    private static bool CreateParamOrder(Int32[] paramOrder, ParameterInfo[] pars, String[] names);
    internal static bool CanChangePrimitive(Type source, Type target);
}
[ComVisibleAttribute("True")]
[NullableAttribute("0")]
[ClassInterfaceAttribute("0")]
[NullableContextAttribute("1")]
public abstract class System.Delegate : object {
    internal object _target;
    internal object _methodBase;
    internal IntPtr _methodPtr;
    internal IntPtr _methodPtrAux;
    [NullableAttribute("2")]
public object Target { get; }
    public MethodInfo Method { get; }
    protected Delegate(object target, string method);
    protected Delegate(Type target, string method);
    [NullableContextAttribute("2")]
protected virtual object DynamicInvokeImpl(Object[] args);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    protected virtual MethodInfo GetMethodImpl();
    [NullableContextAttribute("2")]
public object get_Target();
    public static Delegate CreateDelegate(Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure);
    public static Delegate CreateDelegate(Type type, Type target, string method, bool ignoreCase, bool throwOnBindFailure);
    public static Delegate CreateDelegate(Type type, MethodInfo method, bool throwOnBindFailure);
    public static Delegate CreateDelegate(Type type, object firstArgument, MethodInfo method, bool throwOnBindFailure);
    internal static Delegate CreateDelegateNoSecurityCheck(Type type, object target, RuntimeMethodHandle method);
    internal static Delegate CreateDelegateInternal(RuntimeType rtType, RuntimeMethodInfo rtMethod, object firstArgument, DelegateBindingFlags flags);
    private bool BindToMethodName(object target, RuntimeType methodType, string method, DelegateBindingFlags flags);
    private bool BindToMethodInfo(object target, IRuntimeMethodInfo method, RuntimeType methodType, DelegateBindingFlags flags);
    private static MulticastDelegate InternalAlloc(RuntimeType type);
    internal static MulticastDelegate InternalAllocLike(Delegate d);
    internal static bool InternalEqualTypes(object a, object b);
    private void DelegateConstruct(object target, IntPtr slot);
    internal IntPtr GetMulticastInvoke();
    internal IntPtr GetInvokeMethod();
    internal IRuntimeMethodInfo FindMethodHandle();
    internal static bool InternalEqualMethodHandles(Delegate left, Delegate right);
    internal IntPtr AdjustTarget(object target, IntPtr methodPtr);
    internal IntPtr GetCallStub(IntPtr methodPtr);
    internal virtual object GetTarget();
    internal static bool CompareUnmanagedFunctionPtrs(Delegate d1, Delegate d2);
    public virtual object Clone();
    [NullableContextAttribute("2")]
public static Delegate Combine(Delegate a, Delegate b);
    [NullableContextAttribute("2")]
public static Delegate Combine(Delegate[] delegates);
    public static Delegate CreateDelegate(Type type, object firstArgument, MethodInfo method);
    public static Delegate CreateDelegate(Type type, MethodInfo method);
    public static Delegate CreateDelegate(Type type, object target, string method);
    public static Delegate CreateDelegate(Type type, object target, string method, bool ignoreCase);
    public static Delegate CreateDelegate(Type type, Type target, string method);
    public static Delegate CreateDelegate(Type type, Type target, string method, bool ignoreCase);
    protected virtual Delegate CombineImpl(Delegate d);
    protected virtual Delegate RemoveImpl(Delegate d);
    public virtual Delegate[] GetInvocationList();
    [NullableContextAttribute("2")]
public object DynamicInvoke(Object[] args);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public MethodInfo get_Method();
    [NullableContextAttribute("2")]
public static Delegate Remove(Delegate source, Delegate value);
    [NullableContextAttribute("2")]
public static Delegate RemoveAll(Delegate source, Delegate value);
    [NullableContextAttribute("2")]
public static bool op_Equality(Delegate d1, Delegate d2);
    [NullableContextAttribute("2")]
public static bool op_Inequality(Delegate d1, Delegate d2);
}
internal enum System.DelegateBindingFlags : Enum {
    public int value__;
    public static DelegateBindingFlags StaticMethodOnly;
    public static DelegateBindingFlags InstanceMethodOnly;
    public static DelegateBindingFlags OpenDelegateOnly;
    public static DelegateBindingFlags ClosedDelegateOnly;
    public static DelegateBindingFlags NeverCloseOverNull;
    public static DelegateBindingFlags CaselessMatching;
    public static DelegateBindingFlags SkipSecurityChecks;
    public static DelegateBindingFlags RelaxedSignature;
}
[AttributeUsageAttribute("2432")]
public class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
public class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
public class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("10624")]
public class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("10368")]
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
public class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableAttribute("0")]
[NullableContextAttribute("2")]
[AttributeUsageAttribute("32767")]
[ConditionalAttribute("CODE_ANALYSIS")]
public class System.Diagnostics.CodeAnalysis.SuppressMessageAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CheckId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Justification>k__BackingField;
    [NullableAttribute("1")]
public string Category { get; }
    [NullableAttribute("1")]
public string CheckId { get; }
    public string Scope { get; public set; }
    public string Target { get; public set; }
    public string MessageId { get; public set; }
    public string Justification { get; public set; }
    [NullableContextAttribute("1")]
public SuppressMessageAttribute(string category, string checkId);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_Category();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_CheckId();
    [CompilerGeneratedAttribute]
public string get_Scope();
    [CompilerGeneratedAttribute]
public void set_Scope(string value);
    [CompilerGeneratedAttribute]
public string get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(string value);
    [CompilerGeneratedAttribute]
public string get_MessageId();
    [CompilerGeneratedAttribute]
public void set_MessageId(string value);
    [CompilerGeneratedAttribute]
public string get_Justification();
    [CompilerGeneratedAttribute]
public void set_Justification(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("68")]
public class System.Diagnostics.ConditionalAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ConditionString>k__BackingField;
    public string ConditionString { get; }
    public ConditionalAttribute(string conditionString);
    [CompilerGeneratedAttribute]
public string get_ConditionString();
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public static class System.Diagnostics.Contracts.Contract : object {
    [ConditionalAttribute("DEBUG")]
[ConditionalAttribute("CONTRACTS_FULL")]
public static void Assume(bool condition);
    [ConditionalAttribute("DEBUG")]
[ConditionalAttribute("CONTRACTS_FULL")]
[NullableContextAttribute("2")]
public static void Assume(bool condition, string userMessage);
    [ConditionalAttribute("DEBUG")]
[ConditionalAttribute("CONTRACTS_FULL")]
public static void Assert(bool condition);
    [NullableContextAttribute("2")]
[ConditionalAttribute("DEBUG")]
[ConditionalAttribute("CONTRACTS_FULL")]
public static void Assert(bool condition, string userMessage);
    [ConditionalAttribute("CONTRACTS_FULL")]
public static void Requires(bool condition);
    [NullableContextAttribute("2")]
[ConditionalAttribute("CONTRACTS_FULL")]
public static void Requires(bool condition, string userMessage);
    [NullableContextAttribute("0")]
public static void Requires(bool condition);
    [NullableContextAttribute("0")]
public static void Requires(bool condition, string userMessage);
    [ConditionalAttribute("CONTRACTS_FULL")]
public static void Ensures(bool condition);
    [ConditionalAttribute("CONTRACTS_FULL")]
[NullableContextAttribute("2")]
public static void Ensures(bool condition, string userMessage);
    [NullableContextAttribute("0")]
[ConditionalAttribute("CONTRACTS_FULL")]
public static void EnsuresOnThrow(bool condition);
    [NullableContextAttribute("0")]
[ConditionalAttribute("CONTRACTS_FULL")]
public static void EnsuresOnThrow(bool condition, string userMessage);
    public static T Result();
    public static T ValueAtReturn(T& value);
    public static T OldValue(T value);
    [ConditionalAttribute("CONTRACTS_FULL")]
public static void Invariant(bool condition);
    [NullableContextAttribute("2")]
[ConditionalAttribute("CONTRACTS_FULL")]
public static void Invariant(bool condition, string userMessage);
    public static bool ForAll(int fromInclusive, int toExclusive, Predicate`1<int> predicate);
    public static bool ForAll(IEnumerable`1<T> collection, Predicate`1<T> predicate);
    public static bool Exists(int fromInclusive, int toExclusive, Predicate`1<int> predicate);
    public static bool Exists(IEnumerable`1<T> collection, Predicate`1<T> predicate);
    [ConditionalAttribute("CONTRACTS_FULL")]
public static void EndContractBlock();
    private static void AssertMustUseRewriter(ContractFailureKind kind, string contractKind);
    [DebuggerNonUserCodeAttribute]
private static void ReportFailure(ContractFailureKind failureKind, string userMessage, string conditionText, Exception innerException);
    public static void add_ContractFailed(EventHandler`1<ContractFailedEventArgs> value);
    public static void remove_ContractFailed(EventHandler`1<ContractFailedEventArgs> value);
}
[ConditionalAttribute("CONTRACTS_FULL")]
[AttributeUsageAttribute("64")]
public class System.Diagnostics.Contracts.ContractAbbreviatorAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
[ConditionalAttribute("CONTRACTS_FULL")]
public class System.Diagnostics.Contracts.ContractArgumentValidatorAttribute : Attribute {
}
[NullableContextAttribute("1")]
[AttributeUsageAttribute("5124")]
[ConditionalAttribute("DEBUG")]
[ConditionalAttribute("CONTRACTS_FULL")]
[NullableAttribute("0")]
public class System.Diagnostics.Contracts.ContractClassAttribute : Attribute {
    private Type _typeWithContracts;
    public Type TypeContainingContracts { get; }
    public ContractClassAttribute(Type typeContainingContracts);
    public Type get_TypeContainingContracts();
}
[AttributeUsageAttribute("4")]
[ConditionalAttribute("CONTRACTS_FULL")]
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Diagnostics.Contracts.ContractClassForAttribute : Attribute {
    private Type _typeIAmAContractFor;
    public Type TypeContractsAreFor { get; }
    public ContractClassForAttribute(Type typeContractsAreFor);
    public Type get_TypeContractsAreFor();
}
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableContextAttribute("2")]
public class System.Diagnostics.Contracts.ContractException : Exception {
    private ContractFailureKind _kind;
    private string _userMessage;
    private string _condition;
    public ContractFailureKind Kind { get; }
    [NullableAttribute("1")]
public string Failure { get; }
    public string UserMessage { get; }
    public string Condition { get; }
    public ContractException(ContractFailureKind kind, string failure, string userMessage, string condition, Exception innerException);
    private ContractException(SerializationInfo info, StreamingContext context);
    public ContractFailureKind get_Kind();
    [NullableContextAttribute("1")]
public string get_Failure();
    public string get_UserMessage();
    public string get_Condition();
    [NullableContextAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[NullableAttribute("0")]
[NullableContextAttribute("2")]
public class System.Diagnostics.Contracts.ContractFailedEventArgs : EventArgs {
    private ContractFailureKind _failureKind;
    private string _message;
    private string _condition;
    private Exception _originalException;
    private bool _handled;
    private bool _unwind;
    internal Exception thrownDuringHandler;
    public string Message { get; }
    public string Condition { get; }
    public ContractFailureKind FailureKind { get; }
    public Exception OriginalException { get; }
    public bool Handled { get; }
    public bool Unwind { get; }
    public ContractFailedEventArgs(ContractFailureKind failureKind, string message, string condition, Exception originalException);
    public string get_Message();
    public string get_Condition();
    public ContractFailureKind get_FailureKind();
    public Exception get_OriginalException();
    public bool get_Handled();
    public void SetHandled();
    public bool get_Unwind();
    public void SetUnwind();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public enum System.Diagnostics.Contracts.ContractFailureKind : Enum {
    public int value__;
    public static ContractFailureKind Precondition;
    public static ContractFailureKind Postcondition;
    public static ContractFailureKind PostconditionOnException;
    public static ContractFailureKind Invariant;
    public static ContractFailureKind Assert;
    public static ContractFailureKind Assume;
}
[AttributeUsageAttribute("64")]
[ConditionalAttribute("CONTRACTS_FULL")]
public class System.Diagnostics.Contracts.ContractInvariantMethodAttribute : Attribute {
}
[NullableContextAttribute("1")]
[AttributeUsageAttribute("32767")]
[ConditionalAttribute("CONTRACTS_FULL")]
[NullableAttribute("0")]
public class System.Diagnostics.Contracts.ContractOptionAttribute : Attribute {
    private string _category;
    private string _setting;
    private bool _enabled;
    private string _value;
    public string Category { get; }
    public string Setting { get; }
    public bool Enabled { get; }
    [NullableAttribute("2")]
public string Value { get; }
    public ContractOptionAttribute(string category, string setting, bool enabled);
    public ContractOptionAttribute(string category, string setting, string value);
    public string get_Category();
    public string get_Setting();
    public bool get_Enabled();
    [NullableContextAttribute("2")]
public string get_Value();
}
[NullableAttribute("0")]
[AttributeUsageAttribute("256")]
[NullableContextAttribute("1")]
[ConditionalAttribute("CONTRACTS_FULL")]
public class System.Diagnostics.Contracts.ContractPublicPropertyNameAttribute : Attribute {
    private string _publicName;
    public string Name { get; }
    public ContractPublicPropertyNameAttribute(string name);
    public string get_Name();
}
[AttributeUsageAttribute("1")]
public class System.Diagnostics.Contracts.ContractReferenceAssemblyAttribute : Attribute {
}
[ConditionalAttribute("CONTRACTS_FULL")]
[AttributeUsageAttribute("192")]
public class System.Diagnostics.Contracts.ContractRuntimeIgnoredAttribute : Attribute {
}
[ConditionalAttribute("CONTRACTS_FULL")]
[AttributeUsageAttribute("237")]
public class System.Diagnostics.Contracts.ContractVerificationAttribute : Attribute {
    private bool _value;
    public bool Value { get; }
    public ContractVerificationAttribute(bool value);
    public bool get_Value();
}
[ConditionalAttribute("CONTRACTS_FULL")]
[AttributeUsageAttribute("6884")]
public class System.Diagnostics.Contracts.PureAttribute : Attribute {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class System.Diagnostics.Debug : object {
    private static DebugProvider modreq(System.Runtime.CompilerServices.IsVolatile) s_provider;
    [ThreadStaticAttribute]
private static int t_indentLevel;
    private static Int32 modreq(System.Runtime.CompilerServices.IsVolatile) s_indentSize;
    public static bool AutoFlush { get; public set; }
    public static int IndentLevel { get; public set; }
    public static int IndentSize { get; public set; }
    private static Debug();
    [NullableContextAttribute("1")]
public static DebugProvider SetProvider(DebugProvider provider);
    public static bool get_AutoFlush();
    public static void set_AutoFlush(bool value);
    public static int get_IndentLevel();
    public static void set_IndentLevel(int value);
    public static int get_IndentSize();
    public static void set_IndentSize(int value);
    [ConditionalAttribute("DEBUG")]
public static void Close();
    [ConditionalAttribute("DEBUG")]
public static void Flush();
    [ConditionalAttribute("DEBUG")]
public static void Indent();
    [ConditionalAttribute("DEBUG")]
public static void Unindent();
    [ConditionalAttribute("DEBUG")]
public static void Print(string message);
    [ConditionalAttribute("DEBUG")]
[NullableContextAttribute("1")]
public static void Print(string format, Object[] args);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool condition);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool condition, string message);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool condition, string message, string detailMessage);
    internal static void ContractFailure(string message, string detailMessage, string failureKindMessage);
    [DoesNotReturnAttribute]
[ConditionalAttribute("DEBUG")]
public static void Fail(string message);
    [ConditionalAttribute("DEBUG")]
[DoesNotReturnAttribute]
public static void Fail(string message, string detailMessage);
    [NullableContextAttribute("1")]
[ConditionalAttribute("DEBUG")]
public static void Assert(bool condition, string message, string detailMessageFormat, Object[] args);
    [ConditionalAttribute("DEBUG")]
public static void WriteLine(string message);
    [ConditionalAttribute("DEBUG")]
public static void Write(string message);
    [ConditionalAttribute("DEBUG")]
public static void WriteLine(object value);
    [ConditionalAttribute("DEBUG")]
public static void WriteLine(object value, string category);
    [NullableContextAttribute("1")]
[ConditionalAttribute("DEBUG")]
public static void WriteLine(string format, Object[] args);
    [ConditionalAttribute("DEBUG")]
public static void WriteLine(string message, string category);
    [ConditionalAttribute("DEBUG")]
public static void Write(object value);
    [ConditionalAttribute("DEBUG")]
public static void Write(string message, string category);
    [ConditionalAttribute("DEBUG")]
public static void Write(object value, string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteIf(bool condition, string message);
    [ConditionalAttribute("DEBUG")]
public static void WriteIf(bool condition, object value);
    [ConditionalAttribute("DEBUG")]
public static void WriteIf(bool condition, string message, string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteIf(bool condition, object value, string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteLineIf(bool condition, object value);
    [ConditionalAttribute("DEBUG")]
public static void WriteLineIf(bool condition, object value, string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteLineIf(bool condition, string message);
    [ConditionalAttribute("DEBUG")]
public static void WriteLineIf(bool condition, string message, string category);
}
[AttributeUsageAttribute("3")]
public class System.Diagnostics.DebuggableAttribute : Attribute {
    [CompilerGeneratedAttribute]
private DebuggingModes <DebuggingFlags>k__BackingField;
    public bool IsJITTrackingEnabled { get; }
    public bool IsJITOptimizerDisabled { get; }
    public DebuggingModes DebuggingFlags { get; }
    public DebuggableAttribute(bool isJITTrackingEnabled, bool isJITOptimizerDisabled);
    public DebuggableAttribute(DebuggingModes modes);
    public bool get_IsJITTrackingEnabled();
    public bool get_IsJITOptimizerDisabled();
    [CompilerGeneratedAttribute]
public DebuggingModes get_DebuggingFlags();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class System.Diagnostics.Debugger : object {
    public static string DefaultCategory;
    public static bool IsAttached { get; }
    private static Debugger();
    public static void Break();
    private static void BreakCanThrow();
    private static void BreakInternal();
    public static bool Launch();
    private static void NotifyOfCrossThreadDependencySlow();
    public static void NotifyOfCrossThreadDependency();
    private static bool LaunchInternal();
    public static bool get_IsAttached();
    public static void Log(int level, string category, string message);
    public static bool IsLogging();
    private static void CustomNotification(ICustomDebuggerNotification data);
}
[AttributeUsageAttribute("384")]
public class System.Diagnostics.DebuggerBrowsableAttribute : Attribute {
    [CompilerGeneratedAttribute]
private DebuggerBrowsableState <State>k__BackingField;
    public DebuggerBrowsableState State { get; }
    public DebuggerBrowsableAttribute(DebuggerBrowsableState state);
    [CompilerGeneratedAttribute]
public DebuggerBrowsableState get_State();
}
public enum System.Diagnostics.DebuggerBrowsableState : Enum {
    public int value__;
    public static DebuggerBrowsableState Never;
    public static DebuggerBrowsableState Collapsed;
    public static DebuggerBrowsableState RootHidden;
}
[NullableAttribute("0")]
[NullableContextAttribute("2")]
[AttributeUsageAttribute("4509")]
public class System.Diagnostics.DebuggerDisplayAttribute : Attribute {
    private Type _target;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetTypeName>k__BackingField;
    [NullableAttribute("1")]
public string Value { get; }
    public string Name { get; public set; }
    public string Type { get; public set; }
    public Type Target { get; public set; }
    public string TargetTypeName { get; public set; }
    public DebuggerDisplayAttribute(string value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    public Type get_Target();
    public void set_Target(Type value);
    [CompilerGeneratedAttribute]
public string get_TargetTypeName();
    [CompilerGeneratedAttribute]
public void set_TargetTypeName(string value);
}
[AttributeUsageAttribute("224")]
public class System.Diagnostics.DebuggerHiddenAttribute : Attribute {
}
[AttributeUsageAttribute("236")]
public class System.Diagnostics.DebuggerNonUserCodeAttribute : Attribute {
}
[AttributeUsageAttribute("96")]
public class System.Diagnostics.DebuggerStepperBoundaryAttribute : Attribute {
}
[AttributeUsageAttribute("108")]
public class System.Diagnostics.DebuggerStepThroughAttribute : Attribute {
}
[NullableAttribute("0")]
[AttributeUsageAttribute("13")]
[NullableContextAttribute("2")]
public class System.Diagnostics.DebuggerTypeProxyAttribute : Attribute {
    private Type _target;
    [CompilerGeneratedAttribute]
private string <ProxyTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetTypeName>k__BackingField;
    [NullableAttribute("1")]
public string ProxyTypeName { get; }
    public Type Target { get; public set; }
    public string TargetTypeName { get; public set; }
    [NullableContextAttribute("1")]
public DebuggerTypeProxyAttribute(Type type);
    [NullableContextAttribute("1")]
public DebuggerTypeProxyAttribute(string typeName);
    [CompilerGeneratedAttribute]
[NullableContextAttribute("1")]
public string get_ProxyTypeName();
    public Type get_Target();
    public void set_Target(Type value);
    [CompilerGeneratedAttribute]
public string get_TargetTypeName();
    [CompilerGeneratedAttribute]
public void set_TargetTypeName(string value);
}
[AttributeUsageAttribute("13")]
[NullableAttribute("0")]
[NullableContextAttribute("2")]
public class System.Diagnostics.DebuggerVisualizerAttribute : Attribute {
    private Type _target;
    [CompilerGeneratedAttribute]
private string <VisualizerObjectSourceTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VisualizerTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetTypeName>k__BackingField;
    public string VisualizerObjectSourceTypeName { get; }
    [NullableAttribute("1")]
public string VisualizerTypeName { get; }
    public string Description { get; public set; }
    public Type Target { get; public set; }
    public string TargetTypeName { get; public set; }
    [NullableContextAttribute("1")]
public DebuggerVisualizerAttribute(string visualizerTypeName);
    [NullableContextAttribute("1")]
public DebuggerVisualizerAttribute(string visualizerTypeName, string visualizerObjectSourceTypeName);
    [NullableContextAttribute("1")]
public DebuggerVisualizerAttribute(string visualizerTypeName, Type visualizerObjectSource);
    [NullableContextAttribute("1")]
public DebuggerVisualizerAttribute(Type visualizer);
    [NullableContextAttribute("1")]
public DebuggerVisualizerAttribute(Type visualizer, Type visualizerObjectSource);
    [NullableContextAttribute("1")]
public DebuggerVisualizerAttribute(Type visualizer, string visualizerObjectSourceTypeName);
    [CompilerGeneratedAttribute]
public string get_VisualizerObjectSourceTypeName();
    [CompilerGeneratedAttribute]
[NullableContextAttribute("1")]
public string get_VisualizerTypeName();
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    public Type get_Target();
    public void set_Target(Type value);
    [CompilerGeneratedAttribute]
public string get_TargetTypeName();
    [CompilerGeneratedAttribute]
public void set_TargetTypeName(string value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Diagnostics.DebugProvider : object {
    private static object s_lock;
    private bool _needIndent;
    private string _indentString;
    internal static Action`4<string, string, string, string> s_FailCore;
    internal static Action`1<string> s_WriteCore;
    private static object s_ForLock;
    private static DebugProvider();
    public virtual void Fail(string message, string detailMessage);
    internal void WriteAssert(string stackTrace, string message, string detailMessage);
    public virtual void Write(string message);
    public virtual void WriteLine(string message);
    public virtual void OnIndentLevelChanged(int indentLevel);
    public virtual void OnIndentSizeChanged(int indentSize);
    private string GetIndentString();
    [NullableContextAttribute("1")]
public static void FailCore(string stackTrace, string message, string detailMessage, string errorSource);
    [NullableContextAttribute("1")]
public static void WriteCore(string message);
    private static void WriteToDebugger(string message);
}
internal class System.Diagnostics.EditAndContinueHelper : object {
    private object _objectReference;
}
internal interface System.Diagnostics.ICustomDebuggerNotification {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Diagnostics.StackFrame : object {
    private MethodBase _method;
    private int _nativeOffset;
    private int _ilOffset;
    private string _fileName;
    private int _lineNumber;
    private int _columnNumber;
    private bool _isLastFrameFromForeignExceptionStackTrace;
    public static int OFFSET_UNKNOWN;
    internal bool IsLastFrameFromForeignExceptionStackTrace { get; }
    internal StackFrame(StackFrameHelper stackFrameHelper, int skipFrames, bool needFileInfo);
    public StackFrame(bool needFileInfo);
    public StackFrame(int skipFrames);
    public StackFrame(int skipFrames, bool needFileInfo);
    public StackFrame(string fileName, int lineNumber);
    public StackFrame(string fileName, int lineNumber, int colNumber);
    private void BuildStackFrame(int skipFrames, bool needFileInfo);
    private bool AppendStackFrameWithoutMethodBase(StringBuilder sb);
    private void InitMembers();
    internal bool get_IsLastFrameFromForeignExceptionStackTrace();
    public virtual MethodBase GetMethod();
    public virtual int GetNativeOffset();
    public virtual int GetILOffset();
    public virtual string GetFileName();
    public virtual int GetFileLineNumber();
    public virtual int GetFileColumnNumber();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
internal class System.Diagnostics.StackFrameHelper : object {
    private Thread targetThread;
    private Int32[] rgiOffset;
    private Int32[] rgiILOffset;
    private object dynamicMethods;
    private IntPtr[] rgMethodHandle;
    private String[] rgAssemblyPath;
    private Assembly[] rgAssembly;
    private IntPtr[] rgLoadedPeAddress;
    private Int32[] rgiLoadedPeSize;
    private IntPtr[] rgInMemoryPdbAddress;
    private Int32[] rgiInMemoryPdbSize;
    private Int32[] rgiMethodToken;
    private String[] rgFilename;
    private Int32[] rgiLineNumber;
    private Int32[] rgiColumnNumber;
    private Boolean[] rgiLastFrameFromForeignExceptionStackTrace;
    private int iFrameCount;
    private static GetSourceLineInfoDelegate s_getSourceLineInfo;
    [ThreadStaticAttribute]
private static int t_reentrancy;
    public StackFrameHelper(Thread target);
    private static StackFrameHelper();
    internal void InitializeSourceInfo(int iSkip, bool fNeedFileInfo, Exception exception);
    public virtual MethodBase GetMethodBase(int i);
    public virtual int GetOffset(int i);
    public virtual int GetILOffset(int i);
    public virtual string GetFilename(int i);
    public virtual int GetLineNumber(int i);
    public virtual int GetColumnNumber(int i);
    public virtual bool IsLastFrameFromForeignExceptionStackTrace(int i);
    public virtual int GetNumberOfFrames();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Diagnostics.StackTrace : object {
    public static int METHODS_TO_SKIP;
    private int _numOfFrames;
    private int _methodsToSkip;
    private StackFrame[] _stackFrames;
    public int FrameCount { get; }
    public StackTrace(bool fNeedFileInfo);
    public StackTrace(int skipFrames);
    public StackTrace(int skipFrames, bool fNeedFileInfo);
    public StackTrace(Exception e);
    public StackTrace(Exception e, bool fNeedFileInfo);
    public StackTrace(Exception e, int skipFrames);
    public StackTrace(Exception e, int skipFrames, bool fNeedFileInfo);
    public StackTrace(StackFrame frame);
    internal static void GetStackFramesInternal(StackFrameHelper sfh, int iSkip, bool fNeedFileInfo, Exception e);
    internal static int CalculateFramesToSkip(StackFrameHelper StackF, int iNumFrames);
    private void InitializeForException(Exception exception, int skipFrames, bool fNeedFileInfo);
    private void InitializeForCurrentThread(int skipFrames, bool fNeedFileInfo);
    private void CaptureStackTrace(int skipFrames, bool fNeedFileInfo, Exception e);
    public virtual int get_FrameCount();
    [NullableContextAttribute("2")]
public virtual StackFrame GetFrame(int index);
    public virtual StackFrame[] GetFrames();
    public virtual string ToString();
    internal string ToString(TraceFormat traceFormat);
    private static bool ShowInStackTrace(MethodBase mb);
    private static bool TryResolveStateMachineMethod(MethodBase& method, Type& declaringType);
}
[AttributeUsageAttribute("108")]
internal class System.Diagnostics.StackTraceHiddenAttribute : Attribute {
}
[NullableContextAttribute("1")]
public interface System.Diagnostics.SymbolStore.ISymbolDocumentWriter {
    public abstract virtual void SetCheckSum(Guid algorithmId, Byte[] checkSum);
    public abstract virtual void SetSource(Byte[] source);
}
internal interface System.Diagnostics.SymbolStore.ISymbolWriter {
    public abstract virtual ISymbolDocumentWriter DefineDocument(string url, Guid language, Guid languageVendor, Guid documentType);
    public abstract virtual void OpenMethod(SymbolToken method);
    public abstract virtual void CloseMethod();
    public abstract virtual void DefineSequencePoints(ISymbolDocumentWriter document, Int32[] offsets, Int32[] lines, Int32[] columns, Int32[] endLines, Int32[] endColumns);
    public abstract virtual int OpenScope(int startOffset);
    public abstract virtual void CloseScope(int endOffset);
    public abstract virtual void DefineLocalVariable(string name, FieldAttributes attributes, Byte[] signature, SymAddressKind addrKind, int addr1, int addr2, int addr3, int startOffset, int endOffset);
    public abstract virtual void SetSymAttribute(SymbolToken parent, string name, Byte[] data);
    public abstract virtual void UsingNamespace(string fullName);
}
internal enum System.Diagnostics.SymbolStore.SymAddressKind : Enum {
    public int value__;
    public static SymAddressKind ILOffset;
    public static SymAddressKind NativeRVA;
    public static SymAddressKind NativeRegister;
    public static SymAddressKind NativeRegisterRelative;
    public static SymAddressKind NativeOffset;
    public static SymAddressKind NativeRegisterRegister;
    public static SymAddressKind NativeRegisterStack;
    public static SymAddressKind NativeStackRegister;
    public static SymAddressKind BitField;
    public static SymAddressKind NativeSectionOffset;
}
internal class System.Diagnostics.SymbolStore.SymbolToken : ValueType {
    internal int m_token;
    public SymbolToken(int val);
    public int GetToken();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(SymbolToken obj);
}
internal class System.Diagnostics.Tracing.ActivityTracker : object {
    private AsyncLocal`1<ActivityInfo> m_current;
    private bool m_checkedForEnable;
    private static ActivityTracker s_activityTrackerInstance;
    private static long m_nextId;
    public static ActivityTracker Instance { get; }
    private static ActivityTracker();
    public void OnStart(string providerName, string activityName, int task, Guid& activityId, Guid& relatedActivityId, EventActivityOptions options);
    public void OnStop(string providerName, string activityName, int task, Guid& activityId);
    public void Enable();
    public static ActivityTracker get_Instance();
    private ActivityInfo FindActiveActivity(string name, ActivityInfo startLocation);
    private string NormalizeActivityName(string providerName, string activityName, int task);
    private void ActivityChanging(AsyncLocalValueChangedArgs`1<ActivityInfo> args);
}
internal class System.Diagnostics.Tracing.ArrayTypeInfo : TraceLoggingTypeInfo {
    private TraceLoggingTypeInfo elementInfo;
    public ArrayTypeInfo(Type type, TraceLoggingTypeInfo elementInfo);
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
    public virtual object GetData(object value);
}
internal class System.Diagnostics.Tracing.ConcurrentSet`2 : ValueType {
    private ItemType[] items;
    public ItemType TryGet(KeyType key);
    public ItemType GetOrAdd(ItemType newItem);
}
internal abstract class System.Diagnostics.Tracing.ConcurrentSetItem`2 : object {
    public abstract virtual int Compare(ItemType other);
    public abstract virtual int Compare(KeyType key);
}
internal enum System.Diagnostics.Tracing.ControllerCommand : Enum {
    public int value__;
    public static ControllerCommand Update;
    public static ControllerCommand SendManifest;
    public static ControllerCommand Enable;
    public static ControllerCommand Disable;
}
internal class System.Diagnostics.Tracing.CounterGroup : object {
    private EventSource _eventSource;
    private List`1<DiagnosticCounter> _counters;
    private static object s_counterGroupLock;
    private static WeakReference`1[] s_counterGroups;
    private DateTime _timeStampSinceCollectionStarted;
    private int _pollingIntervalInMilliseconds;
    private DateTime _nextPollingTimeStamp;
    private static Thread s_pollingThread;
    private static AutoResetEvent s_pollingThreadSleepEvent;
    private static List`1<CounterGroup> s_counterGroupEnabledList;
    internal CounterGroup(EventSource eventSource);
    private static CounterGroup();
    internal void Add(DiagnosticCounter eventCounter);
    internal void Remove(DiagnosticCounter eventCounter);
    private void RegisterCommandCallback();
    private void OnEventSourceCommand(object sender, EventCommandEventArgs e);
    private static void EnsureEventSourceIndexAvailable(int eventSourceIndex);
    internal static CounterGroup GetCounterGroup(EventSource eventSource);
    private void EnableTimer(float pollingIntervalInSeconds);
    private void DisableTimer();
    private void ResetCounters();
    private void OnTimer();
    private static void PollForValues();
}
[EventDataAttribute]
internal class System.Diagnostics.Tracing.CounterPayload : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Mean>k__BackingField;
    [CompilerGeneratedAttribute]
private double <StandardDeviation>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Min>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Max>k__BackingField;
    [CompilerGeneratedAttribute]
private float <IntervalSec>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Series>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CounterType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayUnits>k__BackingField;
    public string Name { get; public set; }
    public string DisplayName { get; public set; }
    public double Mean { get; public set; }
    public double StandardDeviation { get; public set; }
    public int Count { get; public set; }
    public double Min { get; public set; }
    public double Max { get; public set; }
    public float IntervalSec { get; internal set; }
    public string Series { get; public set; }
    public string CounterType { get; public set; }
    public string Metadata { get; public set; }
    public string DisplayUnits { get; public set; }
    private IEnumerable`1<KeyValuePair`2<string, object>> ForEnumeration { get; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    [CompilerGeneratedAttribute]
public void set_DisplayName(string value);
    [CompilerGeneratedAttribute]
public double get_Mean();
    [CompilerGeneratedAttribute]
public void set_Mean(double value);
    [CompilerGeneratedAttribute]
public double get_StandardDeviation();
    [CompilerGeneratedAttribute]
public void set_StandardDeviation(double value);
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
public void set_Count(int value);
    [CompilerGeneratedAttribute]
public double get_Min();
    [CompilerGeneratedAttribute]
public void set_Min(double value);
    [CompilerGeneratedAttribute]
public double get_Max();
    [CompilerGeneratedAttribute]
public void set_Max(double value);
    [CompilerGeneratedAttribute]
public float get_IntervalSec();
    [CompilerGeneratedAttribute]
internal void set_IntervalSec(float value);
    [CompilerGeneratedAttribute]
public string get_Series();
    [CompilerGeneratedAttribute]
public void set_Series(string value);
    [CompilerGeneratedAttribute]
public string get_CounterType();
    [CompilerGeneratedAttribute]
public void set_CounterType(string value);
    [CompilerGeneratedAttribute]
public string get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(string value);
    [CompilerGeneratedAttribute]
public string get_DisplayUnits();
    [CompilerGeneratedAttribute]
public void set_DisplayUnits(string value);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [IteratorStateMachineAttribute("System.Diagnostics.Tracing.CounterPayload/<get_ForEnumeration>d__51")]
private IEnumerable`1<KeyValuePair`2<string, object>> get_ForEnumeration();
}
[EventDataAttribute]
internal class System.Diagnostics.Tracing.CounterPayloadType : object {
    [CompilerGeneratedAttribute]
private CounterPayload <Payload>k__BackingField;
    public CounterPayload Payload { get; public set; }
    public CounterPayloadType(CounterPayload payload);
    [CompilerGeneratedAttribute]
public CounterPayload get_Payload();
    [CompilerGeneratedAttribute]
public void set_Payload(CounterPayload value);
}
internal class System.Diagnostics.Tracing.DataCollector : ValueType {
    [ThreadStaticAttribute]
internal static DataCollector ThreadInstance;
    private Byte* scratchEnd;
    private EventData* datasEnd;
    private GCHandle* pinsEnd;
    private EventData* datasStart;
    private Byte* scratch;
    private EventData* datas;
    private GCHandle* pins;
    private Byte[] buffer;
    private int bufferPos;
    private int bufferNesting;
    private bool writingScalars;
    internal void Enable(Byte* scratch, int scratchSize, EventData* datas, int dataCount, GCHandle* pins, int pinCount);
    internal void Disable();
    internal EventData* Finish();
    internal void AddScalar(Void* value, int size);
    internal void AddNullTerminatedString(string value);
    internal void AddArray(Array value, int length, int itemSize);
    internal int BeginBufferedArray();
    internal void EndBufferedArray(int bookmark, int count);
    internal void BeginBuffered();
    internal void EndBuffered();
    private void EnsureBuffer();
    private void EnsureBuffer(int additionalSize);
    private void GrowBuffer(int required);
    private void PinArray(object value, int size);
    private void ScalarsBegin();
    private void ScalarsEnd();
}
internal class System.Diagnostics.Tracing.DateTimeOffsetTypeInfo : TraceLoggingTypeInfo {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
}
internal class System.Diagnostics.Tracing.DateTimeTypeInfo : TraceLoggingTypeInfo {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
}
internal class System.Diagnostics.Tracing.DecimalTypeInfo : TraceLoggingTypeInfo {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public abstract class System.Diagnostics.Tracing.DiagnosticCounter : object {
    private string _displayName;
    private string _displayUnits;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private EventSource <EventSource>k__BackingField;
    private CounterGroup _group;
    private Dictionary`2<string, string> _metadata;
    public string DisplayName { get; public set; }
    public string DisplayUnits { get; public set; }
    public string Name { get; }
    public EventSource EventSource { get; }
    internal DiagnosticCounter(string name, EventSource eventSource);
    public sealed virtual void Dispose();
    public void AddMetadata(string key, string value);
    public void set_DisplayName(string value);
    public string get_DisplayName();
    public void set_DisplayUnits(string value);
    public string get_DisplayUnits();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public EventSource get_EventSource();
    internal abstract virtual void WritePayload(float intervalSec, int pollingIntervalMillisec);
    internal void ReportOutOfBandMessage(string message);
    internal string GetMetadataString();
}
internal class System.Diagnostics.Tracing.EmptyStruct : ValueType {
}
internal class System.Diagnostics.Tracing.EnumerableTypeInfo : TraceLoggingTypeInfo {
    private TraceLoggingTypeInfo elementInfo;
    public EnumerableTypeInfo(Type type, TraceLoggingTypeInfo elementInfo);
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
    public virtual object GetData(object value);
}
internal class System.Diagnostics.Tracing.EtwEventProvider : object {
    private sealed virtual override UInt32 System.Diagnostics.Tracing.IEventProvider.EventRegister(EventSource eventSource, EtwEnableCallback enableCallback, Void* callbackContext, Int64& registrationHandle);
    private sealed virtual override UInt32 System.Diagnostics.Tracing.IEventProvider.EventUnregister(long registrationHandle);
    private sealed virtual override WriteEventErrorCode System.Diagnostics.Tracing.IEventProvider.EventWriteTransfer(long registrationHandle, EventDescriptor& modreq(System.Runtime.InteropServices.InAttribute) eventDescriptor, IntPtr eventHandle, Guid* activityId, Guid* relatedActivityId, int userDataCount, EventData* userData);
    private sealed virtual override int System.Diagnostics.Tracing.IEventProvider.EventActivityIdControl(ActivityControl ControlCode, Guid& ActivityId);
    private sealed virtual override IntPtr System.Diagnostics.Tracing.IEventProvider.DefineEventHandle(UInt32 eventID, string eventName, long keywords, UInt32 eventVersion, UInt32 level, Byte* pMetadata, UInt32 metadataLength);
}
[FlagsAttribute]
public enum System.Diagnostics.Tracing.EventActivityOptions : Enum {
    public int value__;
    public static EventActivityOptions None;
    public static EventActivityOptions Disable;
    public static EventActivityOptions Recursive;
    public static EventActivityOptions Detachable;
}
[AttributeUsageAttribute("64")]
[NullableAttribute("0")]
[NullableContextAttribute("2")]
public class System.Diagnostics.Tracing.EventAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <EventId>k__BackingField;
    [CompilerGeneratedAttribute]
private EventLevel <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private EventKeywords <Keywords>k__BackingField;
    [CompilerGeneratedAttribute]
private EventTask <Task>k__BackingField;
    [CompilerGeneratedAttribute]
private EventChannel <Channel>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private EventTags <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private EventActivityOptions <ActivityOptions>k__BackingField;
    private EventOpcode m_opcode;
    private bool m_opcodeSet;
    public int EventId { get; private set; }
    public EventLevel Level { get; public set; }
    public EventKeywords Keywords { get; public set; }
    public EventOpcode Opcode { get; public set; }
    internal bool IsOpcodeSet { get; }
    public EventTask Task { get; public set; }
    public EventChannel Channel { get; public set; }
    public byte Version { get; public set; }
    public string Message { get; public set; }
    public EventTags Tags { get; public set; }
    public EventActivityOptions ActivityOptions { get; public set; }
    public EventAttribute(int eventId);
    [CompilerGeneratedAttribute]
public int get_EventId();
    [CompilerGeneratedAttribute]
private void set_EventId(int value);
    [CompilerGeneratedAttribute]
public EventLevel get_Level();
    [CompilerGeneratedAttribute]
public void set_Level(EventLevel value);
    [CompilerGeneratedAttribute]
public EventKeywords get_Keywords();
    [CompilerGeneratedAttribute]
public void set_Keywords(EventKeywords value);
    public EventOpcode get_Opcode();
    public void set_Opcode(EventOpcode value);
    internal bool get_IsOpcodeSet();
    [CompilerGeneratedAttribute]
public EventTask get_Task();
    [CompilerGeneratedAttribute]
public void set_Task(EventTask value);
    [CompilerGeneratedAttribute]
public EventChannel get_Channel();
    [CompilerGeneratedAttribute]
public void set_Channel(EventChannel value);
    [CompilerGeneratedAttribute]
public byte get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(byte value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public EventTags get_Tags();
    [CompilerGeneratedAttribute]
public void set_Tags(EventTags value);
    [CompilerGeneratedAttribute]
public EventActivityOptions get_ActivityOptions();
    [CompilerGeneratedAttribute]
public void set_ActivityOptions(EventActivityOptions value);
}
public enum System.Diagnostics.Tracing.EventChannel : Enum {
    public byte value__;
    public static EventChannel None;
    public static EventChannel Admin;
    public static EventChannel Operational;
    public static EventChannel Analytic;
    public static EventChannel Debug;
}
[AttributeUsageAttribute("256")]
internal class System.Diagnostics.Tracing.EventChannelAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <Enabled>k__BackingField;
    [CompilerGeneratedAttribute]
private EventChannelType <EventChannelType>k__BackingField;
    public bool Enabled { get; public set; }
    public EventChannelType EventChannelType { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Enabled();
    [CompilerGeneratedAttribute]
public void set_Enabled(bool value);
    [CompilerGeneratedAttribute]
public EventChannelType get_EventChannelType();
    [CompilerGeneratedAttribute]
public void set_EventChannelType(EventChannelType value);
}
internal enum System.Diagnostics.Tracing.EventChannelType : Enum {
    public int value__;
    public static EventChannelType Admin;
    public static EventChannelType Operational;
    public static EventChannelType Analytic;
    public static EventChannelType Debug;
}
public enum System.Diagnostics.Tracing.EventCommand : Enum {
    public int value__;
    public static EventCommand Update;
    public static EventCommand SendManifest;
    public static EventCommand Enable;
    public static EventCommand Disable;
}
public class System.Diagnostics.Tracing.EventCommandEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private EventCommand <Command>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Arguments>k__BackingField;
    internal EventSource eventSource;
    internal EventDispatcher dispatcher;
    internal EventProviderType eventProviderType;
    internal EventListener listener;
    internal int perEventSourceSessionId;
    internal int etwSessionId;
    internal bool enable;
    internal EventLevel level;
    internal EventKeywords matchAnyKeyword;
    internal EventCommandEventArgs nextCommand;
    public EventCommand Command { get; internal set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IDictionary`2<string, string> Arguments { get; internal set; }
    internal EventCommandEventArgs(EventCommand command, IDictionary`2<string, string> arguments, EventSource eventSource, EventListener listener, EventProviderType eventProviderType, int perEventSourceSessionId, int etwSessionId, bool enable, EventLevel level, EventKeywords matchAnyKeyword);
    [CompilerGeneratedAttribute]
public EventCommand get_Command();
    [CompilerGeneratedAttribute]
internal void set_Command(EventCommand value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Arguments();
    [CompilerGeneratedAttribute]
internal void set_Arguments(IDictionary`2<string, string> value);
    public bool EnableEvent(int eventId);
    public bool DisableEvent(int eventId);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Diagnostics.Tracing.EventCounter : DiagnosticCounter {
    private int _count;
    private double _sum;
    private double _sumSquared;
    private double _min;
    private double _max;
    private Double[] modreq(System.Runtime.CompilerServices.IsVolatile) _bufferedValues;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _bufferedValuesIndex;
    public EventCounter(string name, EventSource eventSource);
    public void WriteMetric(float value);
    public void WriteMetric(double value);
    public virtual string ToString();
    internal void OnMetricWritten(double value);
    internal virtual void WritePayload(float intervalSec, int pollingIntervalMillisec);
    internal void ResetStatistics();
    private void InitializeBuffer();
    private void Enqueue(double value);
    protected void Flush();
}
[NullableAttribute("0")]
[NullableContextAttribute("2")]
[AttributeUsageAttribute("12")]
public class System.Diagnostics.Tracing.EventDataAttribute : Attribute {
    private EventLevel level;
    private EventOpcode opcode;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private EventKeywords <Keywords>k__BackingField;
    [CompilerGeneratedAttribute]
private EventTags <Tags>k__BackingField;
    public string Name { get; public set; }
    internal EventLevel Level { get; }
    internal EventOpcode Opcode { get; }
    internal EventKeywords Keywords { get; }
    internal EventTags Tags { get; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    internal EventLevel get_Level();
    internal EventOpcode get_Opcode();
    [CompilerGeneratedAttribute]
internal EventKeywords get_Keywords();
    [CompilerGeneratedAttribute]
internal EventTags get_Tags();
}
internal class System.Diagnostics.Tracing.EventDescriptor : ValueType {
    private int m_traceloggingId;
    private ushort m_id;
    private byte m_version;
    private byte m_channel;
    private byte m_level;
    private byte m_opcode;
    private ushort m_task;
    private long m_keywords;
    public int EventId { get; }
    public byte Version { get; }
    public byte Channel { get; }
    public byte Level { get; }
    public byte Opcode { get; }
    public int Task { get; }
    public long Keywords { get; }
    public EventDescriptor(int traceloggingId, byte level, byte opcode, long keywords);
    public EventDescriptor(int id, byte version, byte channel, byte level, byte opcode, int task, long keywords);
    public int get_EventId();
    public byte get_Version();
    public byte get_Channel();
    public byte get_Level();
    public byte get_Opcode();
    public int get_Task();
    public long get_Keywords();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public bool Equals(EventDescriptor other);
}
internal class System.Diagnostics.Tracing.EventDispatcher : object {
    internal EventListener m_Listener;
    internal Boolean[] m_EventEnabled;
    internal EventDispatcher m_Next;
    internal EventDispatcher(EventDispatcher next, Boolean[] eventEnabled, EventListener listener);
}
[AttributeUsageAttribute("128")]
public class System.Diagnostics.Tracing.EventFieldAttribute : Attribute {
    [CompilerGeneratedAttribute]
private EventFieldTags <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private EventFieldFormat <Format>k__BackingField;
    public EventFieldTags Tags { get; public set; }
    [NullableAttribute("2")]
internal string Name { get; }
    public EventFieldFormat Format { get; public set; }
    [CompilerGeneratedAttribute]
public EventFieldTags get_Tags();
    [CompilerGeneratedAttribute]
public void set_Tags(EventFieldTags value);
    [CompilerGeneratedAttribute]
internal string get_Name();
    [CompilerGeneratedAttribute]
public EventFieldFormat get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(EventFieldFormat value);
}
public enum System.Diagnostics.Tracing.EventFieldFormat : Enum {
    public int value__;
    public static EventFieldFormat Default;
    public static EventFieldFormat String;
    public static EventFieldFormat Boolean;
    public static EventFieldFormat Hexadecimal;
    public static EventFieldFormat Xml;
    public static EventFieldFormat Json;
    public static EventFieldFormat HResult;
}
[FlagsAttribute]
public enum System.Diagnostics.Tracing.EventFieldTags : Enum {
    public int value__;
    public static EventFieldTags None;
}
[AttributeUsageAttribute("128")]
public class System.Diagnostics.Tracing.EventIgnoreAttribute : Attribute {
}
[FlagsAttribute]
public enum System.Diagnostics.Tracing.EventKeywords : Enum {
    public long value__;
    public static EventKeywords None;
    public static EventKeywords All;
    public static EventKeywords MicrosoftTelemetry;
    public static EventKeywords WdiContext;
    public static EventKeywords WdiDiagnostic;
    public static EventKeywords Sqm;
    public static EventKeywords AuditFailure;
    public static EventKeywords AuditSuccess;
    public static EventKeywords CorrelationHint;
    public static EventKeywords EventLogClassic;
}
public enum System.Diagnostics.Tracing.EventLevel : Enum {
    public int value__;
    public static EventLevel LogAlways;
    public static EventLevel Critical;
    public static EventLevel Error;
    public static EventLevel Warning;
    public static EventLevel Informational;
    public static EventLevel Verbose;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Diagnostics.Tracing.EventListener : object {
    [CompilerGeneratedAttribute]
private EventHandler`1<EventSourceCreatedEventArgs> _EventSourceCreated;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventWrittenEventArgs> EventWritten;
    internal EventListener modreq(System.Runtime.CompilerServices.IsVolatile) m_Next;
    internal static EventListener s_Listeners;
    internal static List`1<WeakReference> s_EventSources;
    private static bool s_CreatingListener;
    private static bool s_EventSourceShutdownRegistered;
    internal static object EventListenersLock { get; }
    private static EventListener();
    public void add_EventSourceCreated(EventHandler`1<EventSourceCreatedEventArgs> value);
    public void remove_EventSourceCreated(EventHandler`1<EventSourceCreatedEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_EventWritten(EventHandler`1<EventWrittenEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_EventWritten(EventHandler`1<EventWrittenEventArgs> value);
    public virtual void Dispose();
    public void EnableEvents(EventSource eventSource, EventLevel level);
    public void EnableEvents(EventSource eventSource, EventLevel level, EventKeywords matchAnyKeyword);
    public void EnableEvents(EventSource eventSource, EventLevel level, EventKeywords matchAnyKeyword, IDictionary`2<string, string> arguments);
    public void DisableEvents(EventSource eventSource);
    public static int EventSourceIndex(EventSource eventSource);
    protected internal virtual void OnEventSourceCreated(EventSource eventSource);
    protected internal virtual void OnEventWritten(EventWrittenEventArgs eventData);
    internal static void AddEventSource(EventSource newEventSource);
    private static void DisposeOnShutdown(object sender, EventArgs e);
    private static void RemoveReferencesToListenerInEventSources(EventListener listenerToRemove);
    internal static object get_EventListenersLock();
    private void CallBackForExistingEventSources(bool addToListenersList, EventHandler`1<EventSourceCreatedEventArgs> callback);
}
[FlagsAttribute]
public enum System.Diagnostics.Tracing.EventManifestOptions : Enum {
    public int value__;
    public static EventManifestOptions None;
    public static EventManifestOptions Strict;
    public static EventManifestOptions AllCultures;
    public static EventManifestOptions OnlyIfNeededForRegistration;
    public static EventManifestOptions AllowEventSourceOverride;
}
public enum System.Diagnostics.Tracing.EventOpcode : Enum {
    public int value__;
    public static EventOpcode Info;
    public static EventOpcode Start;
    public static EventOpcode Stop;
    public static EventOpcode DataCollectionStart;
    public static EventOpcode DataCollectionStop;
    public static EventOpcode Extension;
    public static EventOpcode Reply;
    public static EventOpcode Resume;
    public static EventOpcode Suspend;
    public static EventOpcode Send;
    public static EventOpcode Receive;
}
internal class System.Diagnostics.Tracing.EventParameterInfo : ValueType {
    internal string ParameterName;
    internal Type ParameterType;
    internal TraceLoggingTypeInfo TypeInfo;
    internal void SetInfo(string name, Type type, TraceLoggingTypeInfo typeInfo);
    internal bool GenerateMetadata(Byte* pMetadataBlob, UInt32& offset, UInt32 blobSize);
    private static bool GenerateMetadataForProperty(PropertyAnalysis property, Byte* pMetadataBlob, UInt32& offset, UInt32 blobSize);
    internal int GetMetadataLength();
    private static UInt32 GetMetadataLengthForProperty(PropertyAnalysis property);
    private static TypeCode GetTypeCodeExtended(Type parameterType);
}
[DefaultMemberAttribute("Item")]
internal class System.Diagnostics.Tracing.EventPayload : object {
    private List`1<string> m_names;
    private List`1<object> m_values;
    public ICollection`1<string> Keys { get; }
    public ICollection`1<object> Values { get; }
    public object Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    internal EventPayload(List`1<string> payloadNames, List`1<object> payloadValues);
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual ICollection`1<object> get_Values();
    public sealed virtual object get_Item(string key);
    public sealed virtual void set_Item(string key, object value);
    public sealed virtual void Add(string key, object value);
    public sealed virtual void Add(KeyValuePair`2<string, object> payloadEntry);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<string, object> entry);
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    [IteratorStateMachineAttribute("System.Diagnostics.Tracing.EventPayload/<GetEnumerator>d__17")]
public sealed virtual IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void CopyTo(KeyValuePair`2[] payloadEntries, int count);
    public sealed virtual bool Remove(string key);
    public sealed virtual bool Remove(KeyValuePair`2<string, object> entry);
    public sealed virtual bool TryGetValue(string key, Object& value);
}
internal static class System.Diagnostics.Tracing.EventPipe : object {
    private static ulong s_sessionID;
    private static EventPipe();
    internal static void Enable(EventPipeConfiguration configuration);
    internal static void Disable();
}
internal class System.Diagnostics.Tracing.EventPipeConfiguration : object {
    private string m_outputFile;
    private EventPipeSerializationFormat m_format;
    private UInt32 m_circularBufferSizeInMB;
    private List`1<EventPipeProviderConfiguration> m_providers;
    private TimeSpan m_minTimeBetweenSamples;
    internal string OutputFile { get; }
    internal EventPipeSerializationFormat Format { get; }
    internal UInt32 CircularBufferSizeInMB { get; }
    internal EventPipeProviderConfiguration[] Providers { get; }
    internal EventPipeConfiguration(string outputFile, EventPipeSerializationFormat format, UInt32 circularBufferSizeInMB);
    internal string get_OutputFile();
    internal EventPipeSerializationFormat get_Format();
    internal UInt32 get_CircularBufferSizeInMB();
    internal EventPipeProviderConfiguration[] get_Providers();
    internal void EnableProvider(string providerName, ulong keywords, UInt32 loggingLevel);
    internal void EnableProviderWithFilter(string providerName, ulong keywords, UInt32 loggingLevel, string filterData);
    private void EnableProviderConfiguration(EventPipeProviderConfiguration providerConfig);
    internal void EnableProviderRange(EventPipeProviderConfiguration[] providerConfigs);
    internal void SetProfilerSamplingRate(TimeSpan minTimeBetweenSamples);
}
internal static class System.Diagnostics.Tracing.EventPipeController : object {
    private static string DefaultAppName;
    private static string NetPerfFileExtension;
    private static string NetTraceFileExtension;
    private static UInt32 DefaultCircularBufferMB;
    private static char ProviderConfigDelimiter;
    private static char ConfigComponentDelimiter;
    [CompilerGeneratedAttribute]
private static bool <IsControllerInitialized>k__BackingField;
    private static EventPipeProviderConfiguration[] DefaultProviderConfiguration { get; }
    private static bool IsControllerInitialized { get; private set; }
    private static int Config_EnableEventPipe { get; }
    private static int Config_NetTraceFormat { get; }
    private static string Config_EventPipeConfig { get; }
    private static UInt32 Config_EventPipeCircularMB { get; }
    private static string Config_EventPipeOutputPath { get; }
    private static EventPipeController();
    private static EventPipeProviderConfiguration[] get_DefaultProviderConfiguration();
    [CompilerGeneratedAttribute]
private static bool get_IsControllerInitialized();
    [CompilerGeneratedAttribute]
private static void set_IsControllerInitialized(bool value);
    internal static void Initialize();
    private static EventPipeConfiguration BuildConfigFromEnvironment();
    private static string BuildTraceFileName();
    private static string GetAppName();
    private static void SetProviderConfiguration(string strConfig, EventPipeConfiguration config);
    private static int get_Config_EnableEventPipe();
    private static int get_Config_NetTraceFormat();
    private static string get_Config_EventPipeConfig();
    private static UInt32 get_Config_EventPipeCircularMB();
    private static string get_Config_EventPipeOutputPath();
}
internal class System.Diagnostics.Tracing.EventPipeEventDispatcher : object {
    internal static EventPipeEventDispatcher Instance;
    private IntPtr m_RuntimeProviderID;
    private ulong m_sessionID;
    private DateTime m_syncTimeUtc;
    private long m_syncTimeQPC;
    private long m_timeQPCFrequency;
    private bool m_stopDispatchTask;
    private EventPipeWaitHandle m_dispatchTaskWaitHandle;
    private Task m_dispatchTask;
    private object m_dispatchControlLock;
    private Dictionary`2<EventListener, EventListenerSubscription> m_subscriptions;
    private static UInt32 DefaultEventListenerCircularMBSize;
    private static EventPipeEventDispatcher();
    internal void SendCommand(EventListener eventListener, EventCommand command, bool enable, EventLevel level, EventKeywords matchAnyKeywords);
    internal void RemoveEventListener(EventListener listener);
    private void CommitDispatchConfiguration();
    private void StartDispatchTask();
    private void StopDispatchTask();
    private void DispatchEventsToEventListeners();
    private DateTime TimeStampToDateTime(long timeStamp);
}
internal class System.Diagnostics.Tracing.EventPipeEventInstanceData : ValueType {
    internal IntPtr ProviderID;
    internal UInt32 EventID;
    internal UInt32 ThreadID;
    internal long TimeStamp;
    internal Guid ActivityId;
    internal Guid ChildActivityId;
    internal IntPtr Payload;
    internal UInt32 PayloadLength;
}
internal class System.Diagnostics.Tracing.EventPipeEventProvider : object {
    private IntPtr m_provHandle;
    private sealed virtual override UInt32 System.Diagnostics.Tracing.IEventProvider.EventRegister(EventSource eventSource, EtwEnableCallback enableCallback, Void* callbackContext, Int64& registrationHandle);
    private sealed virtual override UInt32 System.Diagnostics.Tracing.IEventProvider.EventUnregister(long registrationHandle);
    private sealed virtual override WriteEventErrorCode System.Diagnostics.Tracing.IEventProvider.EventWriteTransfer(long registrationHandle, EventDescriptor& modreq(System.Runtime.InteropServices.InAttribute) eventDescriptor, IntPtr eventHandle, Guid* activityId, Guid* relatedActivityId, int userDataCount, EventData* userData);
    private sealed virtual override int System.Diagnostics.Tracing.IEventProvider.EventActivityIdControl(ActivityControl ControlCode, Guid& ActivityId);
    private sealed virtual override IntPtr System.Diagnostics.Tracing.IEventProvider.DefineEventHandle(UInt32 eventID, string eventName, long keywords, UInt32 eventVersion, UInt32 level, Byte* pMetadata, UInt32 metadataLength);
}
internal static class System.Diagnostics.Tracing.EventPipeInternal : object {
    internal static ulong Enable(string outputFile, EventPipeSerializationFormat format, UInt32 circularBufferSizeInMB, EventPipeProviderConfiguration[] providers, UInt32 numProviders);
    internal static void Disable(ulong sessionID);
    internal static IntPtr CreateProvider(string providerName, EtwEnableCallback callbackFunc);
    internal static IntPtr DefineEvent(IntPtr provHandle, UInt32 eventID, long keywords, UInt32 eventVersion, UInt32 level, Void* pMetadata, UInt32 metadataLength);
    internal static IntPtr GetProvider(string providerName);
    internal static void DeleteProvider(IntPtr provHandle);
    internal static int EventActivityIdControl(UInt32 controlCode, Guid& activityId);
    internal static void WriteEvent(IntPtr eventHandle, UInt32 eventID, Void* pData, UInt32 length, Guid* activityId, Guid* relatedActivityId);
    internal static void WriteEventData(IntPtr eventHandle, UInt32 eventID, EventData* pEventData, UInt32 dataCount, Guid* activityId, Guid* relatedActivityId);
    internal static bool GetSessionInfo(ulong sessionID, EventPipeSessionInfo* pSessionInfo);
    internal static bool GetNextEvent(ulong sessionID, EventPipeEventInstanceData* pInstance);
    internal static IntPtr GetWaitHandle(ulong sessionID);
}
internal class System.Diagnostics.Tracing.EventPipeMetadataGenerator : object {
    public static EventPipeMetadataGenerator Instance;
    private static EventPipeMetadataGenerator();
    public Byte[] GenerateEventMetadata(EventMetadata eventMetadata);
    public Byte[] GenerateEventMetadata(int eventId, string eventName, EventKeywords keywords, EventLevel level, UInt32 version, TraceLoggingEventTypes eventTypes);
    private Byte[] GenerateMetadata(int eventId, string eventName, long keywords, UInt32 level, UInt32 version, EventParameterInfo[] parameters);
    internal static void WriteToBuffer(Byte* buffer, UInt32 bufferLength, UInt32& offset, Byte* src, UInt32 srcLength);
    internal static void WriteToBuffer(Byte* buffer, UInt32 bufferLength, UInt32& offset, UInt32 value);
    internal static void WriteToBuffer(Byte* buffer, UInt32 bufferLength, UInt32& offset, long value);
    internal static void WriteToBuffer(Byte* buffer, UInt32 bufferLength, UInt32& offset, char value);
}
internal static class System.Diagnostics.Tracing.EventPipePayloadDecoder : object {
    internal static Object[] DecodePayload(EventMetadata& metadata, ReadOnlySpan`1<byte> payload);
}
internal class System.Diagnostics.Tracing.EventPipeProviderConfiguration : ValueType {
    private string m_providerName;
    private ulong m_keywords;
    private UInt32 m_loggingLevel;
    private string m_filterData;
    internal string ProviderName { get; }
    internal ulong Keywords { get; }
    internal UInt32 LoggingLevel { get; }
    internal string FilterData { get; }
    internal EventPipeProviderConfiguration(string providerName, ulong keywords, UInt32 loggingLevel, string filterData);
    internal string get_ProviderName();
    internal ulong get_Keywords();
    internal UInt32 get_LoggingLevel();
    internal string get_FilterData();
}
internal enum System.Diagnostics.Tracing.EventPipeSerializationFormat : Enum {
    public int value__;
    public static EventPipeSerializationFormat NetPerf;
    public static EventPipeSerializationFormat NetTrace;
}
internal class System.Diagnostics.Tracing.EventPipeSessionInfo : ValueType {
    internal long StartTimeAsUTCFileTime;
    internal long StartTimeStamp;
    internal long TimeStampFrequency;
}
internal class System.Diagnostics.Tracing.EventPipeWaitHandle : WaitHandle {
}
internal class System.Diagnostics.Tracing.EventProvider : object {
    internal IEventProvider m_eventProvider;
    private EtwEnableCallback m_etwCallback;
    private long m_regHandle;
    private byte m_level;
    private long m_anyKeywordMask;
    private long m_allKeywordMask;
    private List`1<SessionInfo> m_liveSessions;
    private bool m_enabled;
    private string m_providerName;
    private Guid m_providerId;
    internal bool m_disposed;
    [ThreadStaticAttribute]
private static WriteEventErrorCode s_returnCode;
    private static bool m_setInformationMissing;
    protected EventLevel Level { get; }
    protected EventKeywords MatchAnyKeyword { get; }
    internal EventProvider(EventProviderType providerType);
    internal void Register(EventSource eventSource);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    private void EtwEnableCallBack(Guid& sourceId, int controlCode, byte setLevel, long anyKeyword, long allKeyword, EVENT_FILTER_DESCRIPTOR* filterData, Void* callbackContext);
    protected virtual void OnControllerCommand(ControllerCommand command, IDictionary`2<string, string> arguments, int sessionId, int etwSessionId);
    protected EventLevel get_Level();
    protected EventKeywords get_MatchAnyKeyword();
    private static int FindNull(Byte[] buffer, int idx);
    private List`1<Tuple`2<SessionInfo, bool>> GetSessions();
    private static void GetSessionInfoCallback(int etwSessionId, long matchAllKeywords, List`1& sessionList);
    private void GetSessionInfo(SessionInfoCallback action, List`1& sessionList);
    private static int IndexOfSessionInList(List`1<SessionInfo> sessions, int etwSessionId);
    private bool GetDataFromController(int etwSessionId, EVENT_FILTER_DESCRIPTOR* filterData, ControllerCommand& command, Byte[]& data, Int32& dataStart);
    public bool IsEnabled();
    public bool IsEnabled(byte level, long keywords);
    public static WriteEventErrorCode GetLastWriteEventError();
    private static void SetLastError(WriteEventErrorCode error);
    private static object EncodeObject(Object& data, EventData*& dataDescriptor, Byte*& dataBuffer, UInt32& totalEventSize);
    internal bool WriteEvent(EventDescriptor& eventDescriptor, IntPtr eventHandle, Guid* activityID, Guid* childActivityID, Object[] eventPayload);
    protected internal bool WriteEvent(EventDescriptor& eventDescriptor, IntPtr eventHandle, Guid* activityID, Guid* childActivityID, int dataCount, IntPtr data);
    internal bool WriteEventRaw(EventDescriptor& eventDescriptor, IntPtr eventHandle, Guid* activityID, Guid* relatedActivityID, int dataCount, IntPtr data);
    private UInt32 EventRegister(EventSource eventSource, EtwEnableCallback enableCallback);
    private UInt32 EventUnregister(long registrationHandle);
    internal int SetInformation(EVENT_INFO_CLASS eventInfoClass, IntPtr data, UInt32 dataSize);
}
internal enum System.Diagnostics.Tracing.EventProviderType : Enum {
    public int value__;
    public static EventProviderType None;
    public static EventProviderType ETW;
    public static EventProviderType EventPipe;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Diagnostics.Tracing.EventSource : object {
    private static bool m_EventSourcePreventRecursion;
    private string m_name;
    internal int m_id;
    private Guid m_guid;
    internal EventMetadata[] modreq(System.Runtime.CompilerServices.IsVolatile) m_eventData;
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) m_rawManifest;
    private EventHandler`1<EventCommandEventArgs> m_eventCommandExecuted;
    private EventSourceSettings m_config;
    private bool m_eventSourceDisposed;
    private bool m_eventSourceEnabled;
    internal EventLevel m_level;
    internal EventKeywords m_matchAnyKeyword;
    internal EventDispatcher modreq(System.Runtime.CompilerServices.IsVolatile) m_Dispatchers;
    private OverideEventProvider modreq(System.Runtime.CompilerServices.IsVolatile) m_etwProvider;
    private OverideEventProvider modreq(System.Runtime.CompilerServices.IsVolatile) m_eventPipeProvider;
    private bool m_completelyInited;
    private Exception m_constructionException;
    private byte m_outOfBandMessageCount;
    private EventCommandEventArgs m_deferredCommands;
    private String[] m_traits;
    internal static UInt32 s_currentPid;
    [ThreadStaticAttribute]
private static byte m_EventSourceExceptionRecurenceCount;
    [ThreadStaticAttribute]
private static bool m_EventSourceInDecodeObject;
    internal UInt64[] modreq(System.Runtime.CompilerServices.IsVolatile) m_channelData;
    private ActivityTracker m_activityTracker;
    private static bool AllowDuplicateSourceNames;
    private static Byte[] namespaceBytes;
    private Byte[] providerMetadata;
    private TraceLoggingEventHandleTable m_eventHandleTable;
    [NullableAttribute("1")]
public string Name { get; }
    public Guid Guid { get; }
    public EventSourceSettings Settings { get; }
    public Exception ConstructionException { get; }
    public static Guid CurrentThreadActivityId { get; }
    private bool IsDisposed { get; }
    private bool ThrowOnEventWriteErrors { get; }
    private bool SelfDescribingEvents { get; }
    protected EventSource(bool throwOnEventWriteErrors);
    protected EventSource(EventSourceSettings settings);
    protected EventSource(EventSourceSettings settings, String[] traits);
    internal EventSource(Guid eventSourceGuid, string eventSourceName);
    internal EventSource(Guid eventSourceGuid, string eventSourceName, EventSourceSettings settings, String[] traits);
    [NullableContextAttribute("1")]
public EventSource(string eventSourceName);
    [NullableContextAttribute("1")]
public EventSource(string eventSourceName, EventSourceSettings config);
    [NullableContextAttribute("1")]
public EventSource(string eventSourceName, EventSourceSettings config, String[] traits);
    private static EventSource();
    [NullableContextAttribute("1")]
public string get_Name();
    public Guid get_Guid();
    public bool IsEnabled();
    public bool IsEnabled(EventLevel level, EventKeywords keywords);
    public bool IsEnabled(EventLevel level, EventKeywords keywords, EventChannel channel);
    public EventSourceSettings get_Settings();
    [NullableContextAttribute("1")]
public static Guid GetGuid(Type eventSourceType);
    [NullableContextAttribute("1")]
public static string GetName(Type eventSourceType);
    public static string GenerateManifest(Type eventSourceType, string assemblyPathToIncludeInManifest);
    public static string GenerateManifest(Type eventSourceType, string assemblyPathToIncludeInManifest, EventManifestOptions flags);
    [NullableContextAttribute("1")]
public static IEnumerable`1<EventSource> GetSources();
    [NullableContextAttribute("1")]
public static void SendCommand(EventSource eventSource, EventCommand command, IDictionary`2<string, string> commandArguments);
    public Exception get_ConstructionException();
    [NullableContextAttribute("1")]
public string GetTrait(string key);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public void add_EventCommandExecuted(EventHandler`1<EventCommandEventArgs> value);
    public void remove_EventCommandExecuted(EventHandler`1<EventCommandEventArgs> value);
    public static void SetCurrentThreadActivityId(Guid activityId);
    public static Guid get_CurrentThreadActivityId();
    public static void SetCurrentThreadActivityId(Guid activityId, Guid& oldActivityThatWillContinue);
    private void DefineEventPipeEvents();
    internal virtual void GetMetadata(Guid& eventSourceGuid, String& eventSourceName, EventMetadata[]& eventData, Byte[]& manifestBytes);
    [NullableContextAttribute("1")]
protected virtual void OnEventCommand(EventCommandEventArgs command);
    protected void WriteEvent(int eventId);
    protected void WriteEvent(int eventId, int arg1);
    protected void WriteEvent(int eventId, int arg1, int arg2);
    protected void WriteEvent(int eventId, int arg1, int arg2, int arg3);
    protected void WriteEvent(int eventId, long arg1);
    protected void WriteEvent(int eventId, long arg1, long arg2);
    protected void WriteEvent(int eventId, long arg1, long arg2, long arg3);
    protected void WriteEvent(int eventId, string arg1);
    protected void WriteEvent(int eventId, string arg1, string arg2);
    protected void WriteEvent(int eventId, string arg1, string arg2, string arg3);
    protected void WriteEvent(int eventId, string arg1, int arg2);
    protected void WriteEvent(int eventId, string arg1, int arg2, int arg3);
    protected void WriteEvent(int eventId, string arg1, long arg2);
    protected void WriteEvent(int eventId, long arg1, string arg2);
    protected void WriteEvent(int eventId, int arg1, string arg2);
    protected void WriteEvent(int eventId, Byte[] arg1);
    protected void WriteEvent(int eventId, long arg1, Byte[] arg2);
    [CLSCompliantAttribute("False")]
[NullableContextAttribute("0")]
protected void WriteEventCore(int eventId, int eventDataCount, EventData* data);
    [CLSCompliantAttribute("False")]
[NullableContextAttribute("0")]
protected void WriteEventWithRelatedActivityIdCore(int eventId, Guid* relatedActivityId, int eventDataCount, EventData* data);
    protected void WriteEvent(int eventId, Object[] args);
    protected void WriteEventWithRelatedActivityId(int eventId, Guid relatedActivityId, Object[] args);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    private void WriteEventRaw(string eventName, EventDescriptor& eventDescriptor, IntPtr eventHandle, Guid* activityID, Guid* relatedActivityID, int dataCount, IntPtr data);
    private void Initialize(Guid eventSourceGuid, string eventSourceName, String[] traits);
    private static string GetName(Type eventSourceType, EventManifestOptions flags);
    private static Guid GenerateGuidFromName(string name);
    private object DecodeObject(int eventId, int parameterId, EventData*& data);
    private EventDispatcher GetDispatcher(EventListener listener);
    private void WriteEventVarargs(int eventId, Guid* childActivityID, Object[] args);
    private Object[] SerializeEventArgs(int eventId, Object[] args);
    private void LogEventArgsMismatches(ParameterInfo[] infos, Object[] args);
    private void WriteToAllListeners(int eventId, Guid* activityID, Guid* childActivityID, int eventDataCount, EventData* data);
    internal void WriteToAllListeners(int eventId, UInt32* osThreadId, DateTime* timeStamp, Guid* activityID, Guid* childActivityID, Object[] args);
    private void DispatchToAllListeners(int eventId, Guid* childActivityID, EventWrittenEventArgs eventCallbackArgs);
    private void WriteEventString(EventLevel level, long keywords, string msgString);
    private void WriteStringToAllListeners(string eventName, string msg);
    private bool IsEnabledByDefault(int eventNum, bool enable, EventLevel currentLevel, EventKeywords currentMatchAnyKeyword);
    private bool IsEnabledCommon(bool enabled, EventLevel currentLevel, EventKeywords currentMatchAnyKeyword, EventLevel eventLevel, EventKeywords eventKeywords, EventChannel eventChannel);
    private void ThrowEventSourceException(string eventName, Exception innerEx);
    private void ValidateEventOpcodeForTransfer(EventMetadata& eventData, string eventName);
    internal static EventOpcode GetOpcodeWithDefault(EventOpcode opcode, string eventName);
    private int GetParameterCount(EventMetadata eventData);
    private Type GetDataType(EventMetadata eventData, int parameterId);
    internal void SendCommand(EventListener listener, EventProviderType eventProviderType, int perEventSourceSessionId, int etwSessionId, EventCommand command, bool enable, EventLevel level, EventKeywords matchAnyKeyword, IDictionary`2<string, string> commandArguments);
    internal void DoCommand(EventCommandEventArgs commandArgs);
    internal bool EnableEventForDispatcher(EventDispatcher dispatcher, EventProviderType eventProviderType, int eventId, bool value);
    private bool AnyEventEnabled();
    private bool get_IsDisposed();
    private void EnsureDescriptorsInitialized();
    private bool SendManifest(Byte[] rawManifest);
    internal static Attribute GetCustomAttributeHelper(MemberInfo member, Type attributeType, EventManifestOptions flags);
    private static bool AttributeTypeNamesMatch(Type attributeType, Type reflectedAttributeType);
    private static Type GetEventSourceBaseType(Type eventSourceType, bool allowEventSourceOverride, bool reflectionOnly);
    private static Byte[] CreateManifestAndDescriptors(Type eventSourceType, string eventSourceDllName, EventSource source, EventManifestOptions flags);
    private static bool RemoveFirstArgIfRelatedActivityId(ParameterInfo[]& args);
    private static void AddProviderEnumKind(ManifestBuilder manifest, FieldInfo staticField, string providerEnumKind);
    private static void AddEventDescriptor(EventMetadata[]& eventData, string eventName, EventAttribute eventAttribute, ParameterInfo[] eventParameters, bool hasRelatedActivityID);
    private static void TrimEventDescriptors(EventMetadata[]& eventData);
    internal void AddListener(EventListener listener);
    private static void DebugCheckEvent(Dictionary`2& eventsByName, EventMetadata[] eventData, MethodInfo method, EventAttribute eventAttribute, ManifestBuilder manifest, EventManifestOptions options);
    private static int GetHelperCallFirstArg(MethodInfo method);
    internal void ReportOutOfBandMessage(string msg, bool flush);
    private EventSourceSettings ValidateSettings(EventSourceSettings settings);
    private bool get_ThrowOnEventWriteErrors();
    private bool get_SelfDescribingEvents();
    public void Write(string eventName);
    public void Write(string eventName, EventSourceOptions options);
    public void Write(string eventName, T data);
    public void Write(string eventName, EventSourceOptions options, T data);
    public void Write(string eventName, EventSourceOptions& options, T& data);
    public void Write(string eventName, EventSourceOptions& options, Guid& activityId, Guid& relatedActivityId, T& data);
    private void WriteMultiMerge(string eventName, EventSourceOptions& options, TraceLoggingEventTypes eventTypes, Guid* activityID, Guid* childActivityID, Object[] values);
    private void WriteMultiMergeInner(string eventName, EventSourceOptions& options, TraceLoggingEventTypes eventTypes, Guid* activityID, Guid* childActivityID, Object[] values);
    internal void WriteMultiMerge(string eventName, EventSourceOptions& options, TraceLoggingEventTypes eventTypes, Guid* activityID, Guid* childActivityID, EventData* data);
    private void WriteImpl(string eventName, EventSourceOptions& options, object data, Guid* pActivityId, Guid* pRelatedActivityId, TraceLoggingEventTypes eventTypes);
    private void WriteToAllListeners(string eventName, EventDescriptor& eventDescriptor, EventTags tags, Guid* pActivityId, Guid* pChildActivityId, EventPayload payload);
    [ReliabilityContractAttribute("3", "2")]
[NonEventAttribute]
private void WriteCleanup(GCHandle* pPins, int cPins);
    private void InitializeProviderMetadata();
    private static int AddValueToMetaData(List`1<byte> metaData, string value);
    private static int HexDigit(char c);
    private NameInfo UpdateDescriptor(string name, TraceLoggingEventTypes eventInfo, EventSourceOptions& options, EventDescriptor& descriptor);
}
[AttributeUsageAttribute("4")]
[NullableAttribute("0")]
[NullableContextAttribute("2")]
public class System.Diagnostics.Tracing.EventSourceAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Guid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocalizationResources>k__BackingField;
    public string Name { get; public set; }
    public string Guid { get; public set; }
    public string LocalizationResources { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Guid();
    [CompilerGeneratedAttribute]
public void set_Guid(string value);
    [CompilerGeneratedAttribute]
public string get_LocalizationResources();
    [CompilerGeneratedAttribute]
public void set_LocalizationResources(string value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Diagnostics.Tracing.EventSourceCreatedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private EventSource <EventSource>k__BackingField;
    public EventSource EventSource { get; internal set; }
    [CompilerGeneratedAttribute]
public EventSource get_EventSource();
    [CompilerGeneratedAttribute]
internal void set_EventSource(EventSource value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Diagnostics.Tracing.EventSourceException : Exception {
    public EventSourceException(string message);
    public EventSourceException(string message, Exception innerException);
    [NullableContextAttribute("1")]
protected EventSourceException(SerializationInfo info, StreamingContext context);
    internal EventSourceException(Exception innerException);
}
public class System.Diagnostics.Tracing.EventSourceOptions : ValueType {
    internal EventKeywords keywords;
    internal EventTags tags;
    internal EventActivityOptions activityOptions;
    internal byte level;
    internal byte opcode;
    internal byte valuesSet;
    public EventLevel Level { get; public set; }
    public EventOpcode Opcode { get; public set; }
    internal bool IsOpcodeSet { get; }
    public EventKeywords Keywords { get; public set; }
    public EventTags Tags { get; public set; }
    public EventActivityOptions ActivityOptions { get; public set; }
    public EventLevel get_Level();
    public void set_Level(EventLevel value);
    public EventOpcode get_Opcode();
    public void set_Opcode(EventOpcode value);
    internal bool get_IsOpcodeSet();
    public EventKeywords get_Keywords();
    public void set_Keywords(EventKeywords value);
    public EventTags get_Tags();
    public void set_Tags(EventTags value);
    public EventActivityOptions get_ActivityOptions();
    public void set_ActivityOptions(EventActivityOptions value);
}
[FlagsAttribute]
public enum System.Diagnostics.Tracing.EventSourceSettings : Enum {
    public int value__;
    public static EventSourceSettings Default;
    public static EventSourceSettings ThrowOnEventWriteErrors;
    public static EventSourceSettings EtwManifestEventFormat;
    public static EventSourceSettings EtwSelfDescribingEventFormat;
}
[FlagsAttribute]
public enum System.Diagnostics.Tracing.EventTags : Enum {
    public int value__;
    public static EventTags None;
}
public enum System.Diagnostics.Tracing.EventTask : Enum {
    public int value__;
    public static EventTask None;
}
[NullableAttribute("0")]
[NullableContextAttribute("2")]
public class System.Diagnostics.Tracing.EventWrittenEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private int <EventId>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <RelatedActivityId>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<object> <Payload>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <TimeStamp>k__BackingField;
    private string m_message;
    private string m_eventName;
    private EventSource m_eventSource;
    private ReadOnlyCollection`1<string> m_payloadNames;
    private Guid m_activityId;
    private Nullable`1<long> m_osThreadId;
    internal EventTags m_tags;
    internal EventOpcode m_opcode;
    internal EventLevel m_level;
    internal EventKeywords m_keywords;
    public string EventName { get; internal set; }
    public int EventId { get; internal set; }
    public Guid ActivityId { get; internal set; }
    public Guid RelatedActivityId { get; internal set; }
    public ReadOnlyCollection`1<object> Payload { get; internal set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlyCollection`1<string> PayloadNames { get; internal set; }
    [NullableAttribute("1")]
public EventSource EventSource { get; }
    public EventKeywords Keywords { get; }
    public EventOpcode Opcode { get; }
    public EventTask Task { get; }
    public EventTags Tags { get; }
    public string Message { get; internal set; }
    public EventChannel Channel { get; }
    public byte Version { get; }
    public EventLevel Level { get; }
    public long OSThreadId { get; internal set; }
    public DateTime TimeStamp { get; internal set; }
    internal EventWrittenEventArgs(EventSource eventSource);
    public string get_EventName();
    internal void set_EventName(string value);
    [CompilerGeneratedAttribute]
public int get_EventId();
    [CompilerGeneratedAttribute]
internal void set_EventId(int value);
    public Guid get_ActivityId();
    internal void set_ActivityId(Guid value);
    [CompilerGeneratedAttribute]
public Guid get_RelatedActivityId();
    [CompilerGeneratedAttribute]
internal void set_RelatedActivityId(Guid value);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<object> get_Payload();
    [CompilerGeneratedAttribute]
internal void set_Payload(ReadOnlyCollection`1<object> value);
    public ReadOnlyCollection`1<string> get_PayloadNames();
    internal void set_PayloadNames(ReadOnlyCollection`1<string> value);
    [NullableContextAttribute("1")]
public EventSource get_EventSource();
    public EventKeywords get_Keywords();
    public EventOpcode get_Opcode();
    public EventTask get_Task();
    public EventTags get_Tags();
    public string get_Message();
    internal void set_Message(string value);
    public EventChannel get_Channel();
    public byte get_Version();
    public EventLevel get_Level();
    public long get_OSThreadId();
    internal void set_OSThreadId(long value);
    [CompilerGeneratedAttribute]
public DateTime get_TimeStamp();
    [CompilerGeneratedAttribute]
internal void set_TimeStamp(DateTime value);
}
internal class System.Diagnostics.Tracing.FieldMetadata : object {
    private string name;
    private int nameSize;
    private EventFieldTags tags;
    private Byte[] custom;
    private ushort fixedCount;
    private byte inType;
    private byte outType;
    public FieldMetadata(string name, TraceLoggingDataType type, EventFieldTags tags, bool variableCount);
    private FieldMetadata(string name, TraceLoggingDataType dataType, EventFieldTags tags, byte countFlags, ushort fixedCount, Byte[] custom);
    public void IncrementStructFieldCount();
    public void Encode(Int32& pos, Byte[] metadata);
}
[EventSourceAttribute]
internal class System.Diagnostics.Tracing.FrameworkEventSource : EventSource {
    public static FrameworkEventSource Log;
    private static FrameworkEventSource();
    [NonEventAttribute]
private void WriteEvent(int eventId, long arg1, int arg2, string arg3, bool arg4, int arg5, int arg6);
    [NonEventAttribute]
private void WriteEvent(int eventId, long arg1, int arg2, string arg3);
    [EventAttribute("30")]
public void ThreadPoolEnqueueWork(long workID);
    [NonEventAttribute]
public void ThreadPoolEnqueueWorkObject(object workID);
    [EventAttribute("31")]
public void ThreadPoolDequeueWork(long workID);
    [NonEventAttribute]
public void ThreadPoolDequeueWorkObject(object workID);
    [EventAttribute("150")]
public void ThreadTransferSend(long id, int kind, string info, bool multiDequeues, int intInfo1, int intInfo2);
    [NonEventAttribute]
public void ThreadTransferSendObj(object id, int kind, string info, bool multiDequeues, int intInfo1, int intInfo2);
    [EventAttribute("151")]
public void ThreadTransferReceive(long id, int kind, string info);
    [NonEventAttribute]
public void ThreadTransferReceiveObj(object id, int kind, string info);
}
internal interface System.Diagnostics.Tracing.IEventProvider {
    public abstract virtual UInt32 EventRegister(EventSource eventSource, EtwEnableCallback enableCallback, Void* callbackContext, Int64& registrationHandle);
    public abstract virtual UInt32 EventUnregister(long registrationHandle);
    public abstract virtual WriteEventErrorCode EventWriteTransfer(long registrationHandle, EventDescriptor& modreq(System.Runtime.InteropServices.InAttribute) eventDescriptor, IntPtr eventHandle, Guid* activityId, Guid* relatedActivityId, int userDataCount, EventData* userData);
    public abstract virtual int EventActivityIdControl(ActivityControl ControlCode, Guid& ActivityId);
    public abstract virtual IntPtr DefineEventHandle(UInt32 eventID, string eventName, long keywords, UInt32 eventVersion, UInt32 level, Byte* pMetadata, UInt32 metadataLength);
}
[EventDataAttribute]
internal class System.Diagnostics.Tracing.IncrementingCounterPayload : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayRateTimeScale>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Increment>k__BackingField;
    [CompilerGeneratedAttribute]
private float <IntervalSec>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Series>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CounterType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayUnits>k__BackingField;
    public string Name { get; public set; }
    public string DisplayName { get; public set; }
    public string DisplayRateTimeScale { get; public set; }
    public double Increment { get; public set; }
    public float IntervalSec { get; internal set; }
    public string Metadata { get; public set; }
    public string Series { get; public set; }
    public string CounterType { get; public set; }
    public string DisplayUnits { get; public set; }
    private IEnumerable`1<KeyValuePair`2<string, object>> ForEnumeration { get; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    [CompilerGeneratedAttribute]
public void set_DisplayName(string value);
    [CompilerGeneratedAttribute]
public string get_DisplayRateTimeScale();
    [CompilerGeneratedAttribute]
public void set_DisplayRateTimeScale(string value);
    [CompilerGeneratedAttribute]
public double get_Increment();
    [CompilerGeneratedAttribute]
public void set_Increment(double value);
    [CompilerGeneratedAttribute]
public float get_IntervalSec();
    [CompilerGeneratedAttribute]
internal void set_IntervalSec(float value);
    [CompilerGeneratedAttribute]
public string get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(string value);
    [CompilerGeneratedAttribute]
public string get_Series();
    [CompilerGeneratedAttribute]
public void set_Series(string value);
    [CompilerGeneratedAttribute]
public string get_CounterType();
    [CompilerGeneratedAttribute]
public void set_CounterType(string value);
    [CompilerGeneratedAttribute]
public string get_DisplayUnits();
    [CompilerGeneratedAttribute]
public void set_DisplayUnits(string value);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [IteratorStateMachineAttribute("System.Diagnostics.Tracing.IncrementingCounterPayload/<get_ForEnumeration>d__39")]
private IEnumerable`1<KeyValuePair`2<string, object>> get_ForEnumeration();
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Diagnostics.Tracing.IncrementingEventCounter : DiagnosticCounter {
    [CompilerGeneratedAttribute]
private TimeSpan <DisplayRateTimeScale>k__BackingField;
    private double _increment;
    private double _prevIncrement;
    public TimeSpan DisplayRateTimeScale { get; public set; }
    public IncrementingEventCounter(string name, EventSource eventSource);
    public void Increment(double increment);
    [CompilerGeneratedAttribute]
public TimeSpan get_DisplayRateTimeScale();
    [CompilerGeneratedAttribute]
public void set_DisplayRateTimeScale(TimeSpan value);
    public virtual string ToString();
    internal virtual void WritePayload(float intervalSec, int pollingIntervalMillisec);
    internal void UpdateMetric();
}
[EventDataAttribute]
internal class System.Diagnostics.Tracing.IncrementingEventCounterPayloadType : object {
    [CompilerGeneratedAttribute]
private IncrementingCounterPayload <Payload>k__BackingField;
    public IncrementingCounterPayload Payload { get; public set; }
    public IncrementingEventCounterPayloadType(IncrementingCounterPayload payload);
    [CompilerGeneratedAttribute]
public IncrementingCounterPayload get_Payload();
    [CompilerGeneratedAttribute]
public void set_Payload(IncrementingCounterPayload value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Diagnostics.Tracing.IncrementingPollingCounter : DiagnosticCounter {
    [CompilerGeneratedAttribute]
private TimeSpan <DisplayRateTimeScale>k__BackingField;
    private double _increment;
    private double _prevIncrement;
    private Func`1<double> _totalValueProvider;
    public TimeSpan DisplayRateTimeScale { get; public set; }
    public IncrementingPollingCounter(string name, EventSource eventSource, Func`1<double> totalValueProvider);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public TimeSpan get_DisplayRateTimeScale();
    [CompilerGeneratedAttribute]
public void set_DisplayRateTimeScale(TimeSpan value);
    internal void UpdateMetric();
    internal virtual void WritePayload(float intervalSec, int pollingIntervalMillisec);
}
[EventDataAttribute]
internal class System.Diagnostics.Tracing.IncrementingPollingCounterPayloadType : object {
    [CompilerGeneratedAttribute]
private IncrementingCounterPayload <Payload>k__BackingField;
    public IncrementingCounterPayload Payload { get; public set; }
    public IncrementingPollingCounterPayloadType(IncrementingCounterPayload payload);
    [CompilerGeneratedAttribute]
public IncrementingCounterPayload get_Payload();
    [CompilerGeneratedAttribute]
public void set_Payload(IncrementingCounterPayload value);
}
internal class System.Diagnostics.Tracing.InvokeTypeInfo : TraceLoggingTypeInfo {
    internal PropertyAnalysis[] properties;
    public InvokeTypeInfo(Type type, TypeAnalysis typeAnalysis);
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
    public virtual object GetData(object value);
}
internal class System.Diagnostics.Tracing.ManifestBuilder : object {
    private static String[] s_escapes;
    private Dictionary`2<int, string> opcodeTab;
    private Dictionary`2<int, string> taskTab;
    private Dictionary`2<int, ChannelInfo> channelTab;
    private Dictionary`2<ulong, string> keywordTab;
    private Dictionary`2<string, Type> mapsTab;
    private Dictionary`2<string, string> stringTab;
    private ulong nextChannelKeywordBit;
    private StringBuilder sb;
    private StringBuilder events;
    private StringBuilder templates;
    private string providerName;
    private ResourceManager resources;
    private EventManifestOptions flags;
    private IList`1<string> errors;
    private Dictionary`2<string, List`1<int>> perEventByteArrayArgIndices;
    private string eventName;
    private int numParams;
    private List`1<int> byteArrArgIndices;
    public IList`1<string> Errors { get; }
    public ManifestBuilder(string providerName, Guid providerGuid, string dllName, ResourceManager resources, EventManifestOptions flags);
    private static ManifestBuilder();
    public void AddOpcode(string name, int value);
    public void AddTask(string name, int value);
    public void AddKeyword(string name, ulong value);
    public void AddChannel(string name, int value, EventChannelAttribute channelAttribute);
    private EventChannelType EventChannelToChannelType(EventChannel channel);
    private EventChannelAttribute GetDefaultChannelAttribute(EventChannel channel);
    public UInt64[] GetChannelData();
    public void StartEvent(string eventName, EventAttribute eventAttribute);
    public void AddEventParameter(Type type, string name);
    public void EndEvent();
    public ulong GetChannelKeyword(EventChannel channel, ulong channelKeyword);
    public Byte[] CreateManifest();
    public IList`1<string> get_Errors();
    public void ManifestError(string msg, bool runtimeCritical);
    private string CreateManifestString();
    private void WriteNameAndMessageAttribs(StringBuilder stringBuilder, string elementName, string name);
    private void WriteMessageAttrib(StringBuilder stringBuilder, string elementName, string name, string value);
    internal string GetLocalizedMessage(string key, CultureInfo ci, bool etwFormat);
    private static List`1<CultureInfo> GetSupportedCultures(ResourceManager resources);
    private static string GetLevelName(EventLevel level);
    private string GetChannelName(EventChannel channel, string eventName, string eventMessage);
    private string GetTaskName(EventTask task, string eventName);
    private string GetOpcodeName(EventOpcode opcode, string eventName);
    private string GetKeywords(ulong keywords, string eventName);
    private string GetTypeName(Type type);
    private static void UpdateStringBuilder(StringBuilder& stringBuilder, string eventMessage, int startIndex, int count);
    private string TranslateToManifestConvention(string eventMessage, string evtName);
    private int TranslateIndexToManifestConvention(int idx, string evtName);
}
internal class System.Diagnostics.Tracing.ManifestEnvelope : ValueType {
    public ManifestFormats Format;
    public byte MajorVersion;
    public byte MinorVersion;
    public byte Magic;
    public ushort TotalChunks;
    public ushort ChunkNumber;
}
internal class System.Diagnostics.Tracing.NameInfo : ConcurrentSetItem`2<KeyValuePair`2<string, EventTags>, NameInfo> {
    private static int lastIdentity;
    internal string name;
    internal EventTags tags;
    internal int identity;
    internal Byte[] nameMetadata;
    public NameInfo(string name, EventTags tags, int typeMetadataSize);
    private static NameInfo();
    internal static void ReserveEventIDsBelow(int eventId);
    public virtual int Compare(NameInfo other);
    public virtual int Compare(KeyValuePair`2<string, EventTags> key);
    private int Compare(string otherName, EventTags otherTags);
    public IntPtr GetOrCreateEventHandle(EventProvider provider, TraceLoggingEventHandleTable eventHandleTable, EventDescriptor descriptor, TraceLoggingEventTypes eventTypes);
}
[EventSourceAttribute]
internal class System.Diagnostics.Tracing.NativeRuntimeEventSource : EventSource {
    internal static string EventSourceName;
    internal static NativeRuntimeEventSource Log;
    private static NativeRuntimeEventSource();
    [NonEventAttribute]
internal void ProcessEvent(UInt32 eventID, UInt32 osThreadID, DateTime timeStamp, Guid activityId, Guid childActivityId, ReadOnlySpan`1<byte> payload);
    [EventAttribute("1")]
private void GCStart_V2(UInt32 Count, UInt32 Depth, UInt32 Reason, UInt32 Type, ushort ClrInstanceID, ulong ClientSequenceNumber);
    [EventAttribute("2")]
private void GCEnd_V1(UInt32 Count, UInt32 Depth, ushort ClrInstanceID);
    [EventAttribute("3")]
private void GCRestartEEEnd_V1(ushort ClrInstanceID);
    [EventAttribute("4")]
private void GCHeapStats_V1(ulong GenerationSize0, ulong TotalPromotedSize0, ulong GenerationSize1, ulong TotalPromotedSize1, ulong GenerationSize2, ulong TotalPromotedSize2, ulong GenerationSize3, ulong TotalPromotedSize3, ulong FinalizationPromotedSize, ulong FinalizationPromotedCount, UInt32 PinnedObjectCount, UInt32 SinkBlockCount, UInt32 GCHandleCount, ushort ClrInstanceID);
    [EventAttribute("5")]
private void GCCreateSegment_V1(ulong Address, ulong Size, UInt32 Type, ushort ClrInstanceID);
    [EventAttribute("6")]
private void GCFreeSegment_V1(ulong Address, ushort ClrInstanceID);
    [EventAttribute("7")]
private void GCRestartEEBegin_V1(ushort ClrInstanceID);
    [EventAttribute("8")]
private void GCSuspendEEEnd_V1(ushort ClrInstanceID);
    [EventAttribute("9")]
private void GCSuspendEEBegin_V1(UInt32 Reason, UInt32 Count, ushort ClrInstanceID);
    [EventAttribute("10")]
private void GCAllocationTick_V3(UInt32 AllocationAmount, UInt32 AllocationKind, ushort ClrInstanceID, ulong AllocationAmount64, IntPtr TypeID, string TypeName, UInt32 HeapIndex, IntPtr Address);
    [EventAttribute("11")]
private void GCCreateConcurrentThread_V1(ushort ClrInstanceID);
    [EventAttribute("12")]
private void GCTerminateConcurrentThread_V1(ushort ClrInstanceID);
    [EventAttribute("13")]
private void GCFinalizersEnd_V1(UInt32 Count, ushort ClrInstanceID);
    [EventAttribute("14")]
private void GCFinalizersBegin_V1(ushort ClrInstanceID);
    [EventAttribute("15")]
private void BulkType(UInt32 Count, ushort ClrInstanceID);
    [EventAttribute("16")]
private void GCBulkRootEdge(UInt32 Index, UInt32 Count, ushort ClrInstanceID);
    [EventAttribute("17")]
private void GCBulkRootConditionalWeakTableElementEdge(UInt32 Index, UInt32 Count, ushort ClrInstanceID);
    [EventAttribute("18")]
private void GCBulkNode(UInt32 Index, UInt32 Count, ushort ClrInstanceID);
    [EventAttribute("19")]
private void GCBulkEdge(UInt32 Index, UInt32 Count, ushort ClrInstanceID);
    [EventAttribute("20")]
private void GCSampledObjectAllocationHigh(IntPtr Address, IntPtr TypeID, UInt32 ObjectCountForTypeSample, ulong TotalSizeForTypeSample, ushort ClrInstanceID);
    [EventAttribute("21")]
private void GCBulkSurvivingObjectRanges(UInt32 Index, UInt32 Count, ushort ClrInstanceID);
    [EventAttribute("22")]
private void GCBulkMovedObjectRanges(UInt32 Index, UInt32 Count, ushort ClrInstanceID);
    [EventAttribute("23")]
private void GCGenerationRange(byte Generation, IntPtr RangeStart, ulong RangeUsedLength, ulong RangeReservedLength, ushort ClrInstanceID);
    [EventAttribute("25")]
private void GCMarkStackRoots(UInt32 HeapNum, ushort ClrInstanceID);
    [EventAttribute("26")]
private void GCMarkFinalizeQueueRoots(UInt32 HeapNum, ushort ClrInstanceID);
    [EventAttribute("27")]
private void GCMarkHandles(UInt32 HeapNum, ushort ClrInstanceID);
    [EventAttribute("28")]
private void GCMarkOlderGenerationRoots(UInt32 HeapNum, ushort ClrInstanceID);
    [EventAttribute("29")]
private void FinalizeObject(IntPtr TypeID, IntPtr ObjectID, ushort ClrInstanceID);
    [EventAttribute("30")]
private void SetGCHandle(IntPtr HandleID, IntPtr ObjectID, UInt32 Kind, UInt32 Generation, ulong AppDomainID, ushort ClrInstanceID);
    [EventAttribute("31")]
private void DestroyGCHandle(IntPtr HandleID, ushort ClrInstanceID);
    [EventAttribute("32")]
private void GCSampledObjectAllocationLow(IntPtr Address, IntPtr TypeID, UInt32 ObjectCountForTypeSample, ulong TotalSizeForTypeSample, ushort ClrInstanceID);
    [EventAttribute("33")]
private void PinObjectAtGCTime(IntPtr HandleID, IntPtr ObjectID, ulong ObjectSize, string TypeName, ushort ClrInstanceID);
    [EventAttribute("35")]
private void GCTriggered(UInt32 Reason, ushort ClrInstanceID);
    [EventAttribute("36")]
private void GCBulkRootCCW(UInt32 Count, ushort ClrInstanceID);
    [EventAttribute("37")]
private void GCBulkRCW(UInt32 Count, ushort ClrInstanceID);
    [EventAttribute("38")]
private void GCBulkRootStaticVar(UInt32 Count, ulong AppDomainID, ushort ClrInstanceID);
    [EventAttribute("39")]
private void GCDynamicEvent(string Name, UInt32 DataSize);
    [EventAttribute("40")]
private void WorkerThreadCreate(UInt32 WorkerThreadCount, UInt32 RetiredWorkerThreads);
    [EventAttribute("41")]
private void WorkerThreadTerminate(UInt32 WorkerThreadCount, UInt32 RetiredWorkerThreads);
    [EventAttribute("42")]
private void WorkerThreadRetire(UInt32 WorkerThreadCount, UInt32 RetiredWorkerThreads);
    [EventAttribute("43")]
private void WorkerThreadUnretire(UInt32 WorkerThreadCount, UInt32 RetiredWorkerThreads);
    [EventAttribute("44")]
private void IOThreadCreate_V1(UInt32 IOThreadCount, UInt32 RetiredIOThreads, ushort ClrInstanceID);
    [EventAttribute("45")]
private void IOThreadTerminate_V1(UInt32 IOThreadCount, UInt32 RetiredIOThreads, ushort ClrInstanceID);
    [EventAttribute("46")]
private void IOThreadRetire_V1(UInt32 IOThreadCount, UInt32 RetiredIOThreads, ushort ClrInstanceID);
    [EventAttribute("47")]
private void IOThreadUnretire_V1(UInt32 IOThreadCount, UInt32 RetiredIOThreads, ushort ClrInstanceID);
    [EventAttribute("48")]
private void ThreadpoolSuspensionSuspendThread(UInt32 ClrThreadID, UInt32 CpuUtilization);
    [EventAttribute("49")]
private void ThreadpoolSuspensionResumeThread(UInt32 ClrThreadID, UInt32 CpuUtilization);
    [EventAttribute("50")]
private void ThreadPoolWorkerThreadStart(UInt32 ActiveWorkerThreadCount, UInt32 RetiredWorkerThreadCount, ushort ClrInstanceID);
    [EventAttribute("51")]
private void ThreadPoolWorkerThreadStop(UInt32 ActiveWorkerThreadCount, UInt32 RetiredWorkerThreadCount, ushort ClrInstanceID);
    [EventAttribute("52")]
private void ThreadPoolWorkerThreadRetirementStart(UInt32 ActiveWorkerThreadCount, UInt32 RetiredWorkerThreadCount, ushort ClrInstanceID);
    [EventAttribute("53")]
private void ThreadPoolWorkerThreadRetirementStop(UInt32 ActiveWorkerThreadCount, UInt32 RetiredWorkerThreadCount, ushort ClrInstanceID);
    [EventAttribute("54")]
private void ThreadPoolWorkerThreadAdjustmentSample(double Throughput, ushort ClrInstanceID);
    [EventAttribute("55")]
private void ThreadPoolWorkerThreadAdjustmentAdjustment(double AverageThroughput, UInt32 NewWorkerThreadCount, UInt32 Reason, ushort ClrInstanceID);
    [EventAttribute("56")]
private void ThreadPoolWorkerThreadAdjustmentStats(double Duration, double Throughput, double ThreadWave, double ThroughputWave, double ThroughputErrorEstimate, double AverageThroughputErrorEstimate, double ThroughputRatio, double Confidence, double NewControlSetting, ushort NewThreadWaveMagnitude, ushort ClrInstanceID);
    [EventAttribute("57")]
private void ThreadPoolWorkerThreadWait(UInt32 ActiveWorkerThreadCount, UInt32 RetiredWorkerThreadCount, ushort ClrInstanceID);
    [EventAttribute("60")]
private void ThreadPoolWorkingThreadCount(UInt32 Count, ushort ClrInstanceID);
    [EventAttribute("61")]
private void ThreadPoolEnqueue(IntPtr WorkID, ushort ClrInstanceID);
    [EventAttribute("62")]
private void ThreadPoolDequeue(IntPtr WorkID, ushort ClrInstanceID);
    [EventAttribute("63")]
private void ThreadPoolIOEnqueue(IntPtr NativeOverlapped, IntPtr Overlapped, bool MultiDequeues, ushort ClrInstanceID);
    [EventAttribute("64")]
private void ThreadPoolIODequeue(IntPtr NativeOverlapped, IntPtr Overlapped, ushort ClrInstanceID);
    [EventAttribute("65")]
private void ThreadPoolIOPack(IntPtr NativeOverlapped, IntPtr Overlapped, ushort ClrInstanceID);
    [EventAttribute("70")]
private void ThreadCreating(IntPtr ID, ushort ClrInstanceID);
    [EventAttribute("71")]
private void ThreadRunning(IntPtr ID, ushort ClrInstanceID);
    [EventAttribute("80")]
private void ExceptionThrown_V1(string ExceptionType, string ExceptionMessage, IntPtr ExceptionEIP, UInt32 ExceptionHRESULT, ushort ExceptionFlags, ushort ClrInstanceID);
    [EventAttribute("250")]
private void ExceptionCatchStart(ulong EntryEIP, ulong MethodID, string MethodName, ushort ClrInstanceID);
    [EventAttribute("251")]
private void ExceptionCatchStop();
    [EventAttribute("252")]
private void ExceptionFinallyStart(ulong EntryEIP, ulong MethodID, string MethodName, ushort ClrInstanceID);
    [EventAttribute("253")]
private void ExceptionFinallyStop();
    [EventAttribute("254")]
private void ExceptionFilterStart(ulong EntryEIP, ulong MethodID, string MethodName, ushort ClrInstanceID);
    [EventAttribute("255")]
private void ExceptionFilterStop();
    [EventAttribute("256")]
private void ExceptionThrownStop();
    [EventAttribute("81")]
private void ContentionStart_V1(byte ContentionFlags, ushort ClrInstanceID);
    [EventAttribute("91")]
private void ContentionStop_V1(byte ContentionFlags, ushort ClrInstanceID, double DurationNs);
    [EventAttribute("82")]
private void CLRStackWalk(ushort ClrInstanceID, byte Reserved1, byte Reserved2, UInt32 FrameCount);
    [EventAttribute("83")]
private void AppDomainMemAllocated(ulong AppDomainID, ulong Allocated, ushort ClrInstanceID);
    [EventAttribute("84")]
private void AppDomainMemSurvived(ulong AppDomainID, ulong Survived, ulong ProcessSurvived, ushort ClrInstanceID);
    [EventAttribute("85")]
private void ThreadCreated(ulong ManagedThreadID, ulong AppDomainID, UInt32 Flags, UInt32 ManagedThreadIndex, UInt32 OSThreadID, ushort ClrInstanceID);
    [EventAttribute("86")]
private void ThreadTerminated(ulong ManagedThreadID, ulong AppDomainID, ushort ClrInstanceID);
    [EventAttribute("87")]
private void ThreadDomainEnter(ulong ManagedThreadID, ulong AppDomainID, ushort ClrInstanceID);
    [EventAttribute("88")]
private void ILStubGenerated(ushort ClrInstanceID, ulong ModuleID, ulong StubMethodID, UInt32 StubFlags, UInt32 ManagedInteropMethodToken, string ManagedInteropMethodNamespace, string ManagedInteropMethodName, string ManagedInteropMethodSignature, string NativeMethodSignature, string StubMethodSignature, string StubMethodILCode);
    [EventAttribute("89")]
private void ILStubCacheHit(ushort ClrInstanceID, ulong ModuleID, ulong StubMethodID, UInt32 ManagedInteropMethodToken, string ManagedInteropMethodNamespace, string ManagedInteropMethodName, string ManagedInteropMethodSignature);
    [EventAttribute("135")]
private void DCStartCompleteV2();
    [EventAttribute("136")]
private void DCEndCompleteV2();
    [EventAttribute("137")]
private void MethodDCStartV2(ulong MethodID, ulong ModuleID, ulong MethodStartAddress, UInt32 MethodSize, UInt32 MethodToken, UInt32 MethodFlags);
    [EventAttribute("138")]
private void MethodDCEndV2(ulong MethodID, ulong ModuleID, ulong MethodStartAddress, UInt32 MethodSize, UInt32 MethodToken, UInt32 MethodFlags);
    [EventAttribute("139")]
private void MethodDCStartVerboseV2(ulong MethodID, ulong ModuleID, ulong MethodStartAddress, UInt32 MethodSize, UInt32 MethodToken, UInt32 MethodFlags, string MethodNamespace, string MethodName, string MethodSignature);
    [EventAttribute("140")]
private void MethodDCEndVerboseV2(ulong MethodID, ulong ModuleID, ulong MethodStartAddress, UInt32 MethodSize, UInt32 MethodToken, UInt32 MethodFlags, string MethodNamespace, string MethodName, string MethodSignature);
    [EventAttribute("141")]
private void MethodLoad_V2(ulong MethodID, ulong ModuleID, ulong MethodStartAddress, UInt32 MethodSize, UInt32 MethodToken, UInt32 MethodFlags, ushort ClrInstanceID, ulong ReJITID);
    [EventAttribute("159")]
private void R2RGetEntryPoint(ulong MethodID, string MethodNamespace, string MethodName, string MethodSignature, ulong EntryPoint, ushort ClrInstanceID);
    [EventAttribute("142")]
private void MethodUnload_V2(ulong MethodID, ulong ModuleID, ulong MethodStartAddress, UInt32 MethodSize, UInt32 MethodToken, UInt32 MethodFlags, ushort ClrInstanceID, ulong ReJITID);
    [EventAttribute("143")]
private void MethodLoadVerbose_V2(ulong MethodID, ulong ModuleID, ulong MethodStartAddress, UInt32 MethodSize, UInt32 MethodToken, UInt32 MethodFlags, string MethodNamespace, string MethodName, string MethodSignature, ushort ClrInstanceID, ulong ReJITID);
    [EventAttribute("144")]
private void MethodUnloadVerbose_V2(ulong MethodID, ulong ModuleID, ulong MethodStartAddress, UInt32 MethodSize, UInt32 MethodToken, UInt32 MethodFlags, string MethodNamespace, string MethodName, string MethodSignature, ushort ClrInstanceID, ulong ReJITID);
    [EventAttribute("145")]
private void MethodJittingStarted_V1(ulong MethodID, ulong ModuleID, UInt32 MethodToken, UInt32 MethodILSize, string MethodNamespace, string MethodName, string MethodSignature, ushort ClrInstanceID);
    [EventAttribute("185")]
private void MethodJitInliningSucceeded(string MethodBeingCompiledNamespace, string MethodBeingCompiledName, string MethodBeingCompiledNameSignature, string InlinerNamespace, string InlinerName, string InlinerNameSignature, string InlineeNamespace, string InlineeName, string InlineeNameSignature, ushort ClrInstanceID);
    [EventAttribute("186")]
private void MethodJitInliningFailedAnsi(string MethodBeingCompiledNamespace, string MethodBeingCompiledName, string MethodBeingCompiledNameSignature, string InlinerNamespace, string InlinerName, string InlinerNameSignature, string InlineeNamespace, string InlineeName, string InlineeNameSignature, bool FailAlways);
    [EventAttribute("188")]
private void MethodJitTailCallSucceeded(string MethodBeingCompiledNamespace, string MethodBeingCompiledName, string MethodBeingCompiledNameSignature, string CallerNamespace, string CallerName, string CallerNameSignature, string CalleeNamespace, string CalleeName, string CalleeNameSignature, bool TailPrefix, UInt32 TailCallType, ushort ClrInstanceID);
    [EventAttribute("189")]
private void MethodJitTailCallFailedAnsi(string MethodBeingCompiledNamespace, string MethodBeingCompiledName, string MethodBeingCompiledNameSignature, string CallerNamespace, string CallerName, string CallerNameSignature, string CalleeNamespace, string CalleeName, string CalleeNameSignature, bool TailPrefix);
    [EventAttribute("190")]
private void MethodILToNativeMap(ulong MethodID, ulong ReJITID, byte MethodExtent, ushort CountOfMapEntries);
    [EventAttribute("191")]
private void MethodJitTailCallFailed(string MethodBeingCompiledNamespace, string MethodBeingCompiledName, string MethodBeingCompiledNameSignature, string CallerNamespace, string CallerName, string CallerNameSignature, string CalleeNamespace, string CalleeName, string CalleeNameSignature, bool TailPrefix, string FailReason, ushort ClrInstanceID);
    [EventAttribute("192")]
private void MethodJitInliningFailed(string MethodBeingCompiledNamespace, string MethodBeingCompiledName, string MethodBeingCompiledNameSignature, string InlinerNamespace, string InlinerName, string InlinerNameSignature, string InlineeNamespace, string InlineeName, string InlineeNameSignature, bool FailAlways, string FailReason, ushort ClrInstanceID);
    [EventAttribute("149")]
private void ModuleDCStartV2(ulong ModuleID, ulong AssemblyID, UInt32 ModuleFlags, UInt32 Reserved1, string ModuleILPath, string ModuleNativePath);
    [EventAttribute("150")]
private void ModuleDCEndV2(ulong ModuleID, ulong AssemblyID, UInt32 ModuleFlags, UInt32 Reserved1, string ModuleILPath, string ModuleNativePath);
    [EventAttribute("151")]
private void DomainModuleLoad_V1(ulong ModuleID, ulong AssemblyID, ulong AppDomainID, UInt32 ModuleFlags, UInt32 Reserved1, string ModuleILPath, string ModuleNativePath, ushort ClrInstanceID);
    [EventAttribute("152")]
private void ModuleLoad_V2(ulong ModuleID, ulong AssemblyID, UInt32 ModuleFlags, UInt32 Reserved1, string ModuleILPath, string ModuleNativePath, ushort ClrInstanceID, Guid ManagedPdbSignature, UInt32 ManagedPdbAge, string ManagedPdbBuildPath, Guid NativePdbSignature, UInt32 NativePdbAge, string NativePdbBuildPath);
    [EventAttribute("153")]
private void ModuleUnload_V2(ulong ModuleID, ulong AssemblyID, UInt32 ModuleFlags, UInt32 Reserved1, string ModuleILPath, string ModuleNativePath, ushort ClrInstanceID, Guid ManagedPdbSignature, UInt32 ManagedPdbAge, string ManagedPdbBuildPath, Guid NativePdbSignature, UInt32 NativePdbAge, string NativePdbBuildPath);
    [EventAttribute("154")]
private void AssemblyLoad_V1(ulong AssemblyID, ulong AppDomainID, ulong BindingID, UInt32 AssemblyFlags, string FullyQualifiedAssemblyName, ushort ClrInstanceID);
    [EventAttribute("155")]
private void AssemblyUnload_V1(ulong AssemblyID, ulong AppDomainID, ulong BindingID, UInt32 AssemblyFlags, string FullyQualifiedAssemblyName, ushort ClrInstanceID);
    [EventAttribute("156")]
private void AppDomainLoad_V1(ulong AppDomainID, UInt32 AppDomainFlags, string AppDomainName, UInt32 AppDomainIndex, ushort ClrInstanceID);
    [EventAttribute("157")]
private void AppDomainUnload_V1(ulong AppDomainID, UInt32 AppDomainFlags, string AppDomainName, UInt32 AppDomainIndex, ushort ClrInstanceID);
    [EventAttribute("158")]
private void ModuleRangeLoad(ushort ClrInstanceID, ulong ModuleID, UInt32 RangeBegin, UInt32 RangeSize, byte RangeType);
    [EventAttribute("181")]
private void StrongNameVerificationStart_V1(UInt32 VerificationFlags, UInt32 ErrorCode, string FullyQualifiedAssemblyName, ushort ClrInstanceID);
    [EventAttribute("182")]
private void StrongNameVerificationStop_V1(UInt32 VerificationFlags, UInt32 ErrorCode, string FullyQualifiedAssemblyName, ushort ClrInstanceID);
    [EventAttribute("183")]
private void AuthenticodeVerificationStart_V1(UInt32 VerificationFlags, UInt32 ErrorCode, string ModulePath, ushort ClrInstanceID);
    [EventAttribute("184")]
private void AuthenticodeVerificationStop_V1(UInt32 VerificationFlags, UInt32 ErrorCode, string ModulePath, ushort ClrInstanceID);
    [EventAttribute("187")]
private void RuntimeInformationStart(ushort ClrInstanceID, ushort Sku, ushort BclMajorVersion, ushort BclMinorVersion, ushort BclBuildNumber, ushort BclQfeNumber, ushort VMMajorVersion, ushort VMMinorVersion, ushort VMBuildNumber, ushort VMQfeNumber, UInt32 StartupFlags, byte StartupMode, string CommandLine, Guid ComObjectGuid, string RuntimeDllPath);
    [EventAttribute("200")]
private void IncreaseMemoryPressure(ulong BytesAllocated, ushort ClrInstanceID);
    [EventAttribute("201")]
private void DecreaseMemoryPressure(ulong BytesFreed, ushort ClrInstanceID);
    [EventAttribute("202")]
private void GCMarkWithType(UInt32 HeapNum, ushort ClrInstanceID, UInt32 Type, ulong Bytes);
    [EventAttribute("203")]
private void GCJoin_V2(UInt32 Heap, UInt32 JoinTime, UInt32 JoinType, ushort ClrInstanceID, UInt32 JoinID);
    [EventAttribute("204")]
private void GCPerHeapHistory_V3(ushort ClrInstanceID, IntPtr FreeListAllocated, IntPtr FreeListRejected, IntPtr EndOfSegAllocated, IntPtr CondemnedAllocated, IntPtr PinnedAllocated, IntPtr PinnedAllocatedAdvance, UInt32 RunningFreeListEfficiency, UInt32 CondemnReasons0, UInt32 CondemnReasons1, UInt32 CompactMechanisms, UInt32 ExpandMechanisms, UInt32 HeapIndex, IntPtr ExtraGen0Commit, UInt32 Count);
    [EventAttribute("205")]
private void GCGlobalHeapHistory_V2(ulong FinalYoungestDesired, int NumHeaps, UInt32 CondemnedGeneration, UInt32 Gen0ReductionCount, UInt32 Reason, UInt32 GlobalMechanisms, ushort ClrInstanceID, UInt32 PauseMode, UInt32 MemoryPressure);
    [EventAttribute("240")]
private void DebugIPCEventStart();
    [EventAttribute("241")]
private void DebugIPCEventEnd();
    [EventAttribute("242")]
private void DebugExceptionProcessingStart();
    [EventAttribute("243")]
private void DebugExceptionProcessingEnd();
    [EventAttribute("260")]
private void CodeSymbols(ulong ModuleId, ushort TotalChunks, ushort ChunkNumber, UInt32 ChunkLength);
    [EventAttribute("270")]
private void EventSource(int EventID, string EventName, string EventSourceName, string Payload);
    [EventAttribute("280")]
private void TieredCompilationSettings(ushort ClrInstanceID, UInt32 Flags);
    [EventAttribute("281")]
private void TieredCompilationPause(ushort ClrInstanceID);
    [EventAttribute("282")]
private void TieredCompilationResume(ushort ClrInstanceID, UInt32 NewMethodCount);
    [EventAttribute("283")]
private void TieredCompilationBackgroundJitStart(ushort ClrInstanceID, UInt32 PendingMethodCount);
    [EventAttribute("284")]
private void TieredCompilationBackgroundJitStop(ushort ClrInstanceID, UInt32 PendingMethodCount, UInt32 JittedMethodCount);
}
[AttributeUsageAttribute("64")]
public class System.Diagnostics.Tracing.NonEventAttribute : Attribute {
}
internal class System.Diagnostics.Tracing.NoOpEventProvider : object {
    private sealed virtual override UInt32 System.Diagnostics.Tracing.IEventProvider.EventRegister(EventSource eventSource, EtwEnableCallback enableCallback, Void* callbackContext, Int64& registrationHandle);
    private sealed virtual override UInt32 System.Diagnostics.Tracing.IEventProvider.EventUnregister(long registrationHandle);
    private sealed virtual override WriteEventErrorCode System.Diagnostics.Tracing.IEventProvider.EventWriteTransfer(long registrationHandle, EventDescriptor& modreq(System.Runtime.InteropServices.InAttribute) eventDescriptor, IntPtr eventHandle, Guid* activityId, Guid* relatedActivityId, int userDataCount, EventData* userData);
    private sealed virtual override int System.Diagnostics.Tracing.IEventProvider.EventActivityIdControl(ActivityControl ControlCode, Guid& ActivityId);
    private sealed virtual override IntPtr System.Diagnostics.Tracing.IEventProvider.DefineEventHandle(UInt32 eventID, string eventName, long keywords, UInt32 eventVersion, UInt32 level, Byte* pMetadata, UInt32 metadataLength);
}
internal class System.Diagnostics.Tracing.NullableTypeInfo : TraceLoggingTypeInfo {
    private TraceLoggingTypeInfo valueInfo;
    private Func`2<PropertyValue, PropertyValue> valueGetter;
    public NullableTypeInfo(Type type, List`1<Type> recursionCheck);
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
}
internal class System.Diagnostics.Tracing.NullTypeInfo : TraceLoggingTypeInfo {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
    public virtual object GetData(object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Diagnostics.Tracing.PollingCounter : DiagnosticCounter {
    private Func`1<double> _metricProvider;
    private double _lastVal;
    public PollingCounter(string name, EventSource eventSource, Func`1<double> metricProvider);
    public virtual string ToString();
    internal virtual void WritePayload(float intervalSec, int pollingIntervalMillisec);
}
[EventDataAttribute]
internal class System.Diagnostics.Tracing.PollingPayloadType : object {
    [CompilerGeneratedAttribute]
private CounterPayload <Payload>k__BackingField;
    public CounterPayload Payload { get; public set; }
    public PollingPayloadType(CounterPayload payload);
    [CompilerGeneratedAttribute]
public CounterPayload get_Payload();
    [CompilerGeneratedAttribute]
public void set_Payload(CounterPayload value);
}
internal class System.Diagnostics.Tracing.PropertyAnalysis : object {
    internal string name;
    internal PropertyInfo propertyInfo;
    internal Func`2<PropertyValue, PropertyValue> getter;
    internal TraceLoggingTypeInfo typeInfo;
    internal EventFieldAttribute fieldAttribute;
    public PropertyAnalysis(string name, PropertyInfo propertyInfo, TraceLoggingTypeInfo typeInfo, EventFieldAttribute fieldAttribute);
}
[IsReadOnlyAttribute]
internal class System.Diagnostics.Tracing.PropertyValue : ValueType {
    private object _reference;
    private Scalar _scalar;
    private int _scalarLength;
    public object ReferenceValue { get; }
    public Scalar ScalarValue { get; }
    public int ScalarLength { get; }
    private PropertyValue(object value);
    private PropertyValue(Scalar scalar, int scalarLength);
    private PropertyValue(bool value);
    private PropertyValue(byte value);
    private PropertyValue(sbyte value);
    private PropertyValue(char value);
    private PropertyValue(short value);
    private PropertyValue(ushort value);
    private PropertyValue(int value);
    private PropertyValue(UInt32 value);
    private PropertyValue(long value);
    private PropertyValue(ulong value);
    private PropertyValue(IntPtr value);
    private PropertyValue(UIntPtr value);
    private PropertyValue(float value);
    private PropertyValue(double value);
    private PropertyValue(Guid value);
    private PropertyValue(DateTime value);
    private PropertyValue(DateTimeOffset value);
    private PropertyValue(TimeSpan value);
    private PropertyValue(decimal value);
    public static Func`2<object, PropertyValue> GetFactory(Type type);
    public object get_ReferenceValue();
    public Scalar get_ScalarValue();
    public int get_ScalarLength();
    public static Func`2<PropertyValue, PropertyValue> GetPropertyGetter(PropertyInfo property);
    private static Func`2<PropertyValue, PropertyValue> GetBoxedValueTypePropertyGetter(PropertyInfo property);
    private static Func`2<PropertyValue, PropertyValue> GetReferenceTypePropertyGetter(PropertyInfo property);
}
[EventSourceAttribute]
internal class System.Diagnostics.Tracing.RuntimeEventSource : EventSource {
    private static RuntimeEventSource s_RuntimeEventSource;
    private PollingCounter _gcHeapSizeCounter;
    private IncrementingPollingCounter _gen0GCCounter;
    private IncrementingPollingCounter _gen1GCCounter;
    private IncrementingPollingCounter _gen2GCCounter;
    private IncrementingPollingCounter _exceptionCounter;
    private PollingCounter _cpuTimeCounter;
    private PollingCounter _workingSetCounter;
    private PollingCounter _threadPoolThreadCounter;
    private IncrementingPollingCounter _monitorContentionCounter;
    private PollingCounter _threadPoolQueueCounter;
    private IncrementingPollingCounter _completedItemsCounter;
    private PollingCounter _gcTimeCounter;
    private PollingCounter _gen0SizeCounter;
    private PollingCounter _gen1SizeCounter;
    private PollingCounter _gen2SizeCounter;
    private PollingCounter _lohSizeCounter;
    private IncrementingPollingCounter _allocRateCounter;
    private PollingCounter _assemblyCounter;
    private PollingCounter _timerCounter;
    private static int EnabledPollingIntervalMilliseconds;
    public static void Initialize();
    protected virtual void OnEventCommand(EventCommandEventArgs command);
}
internal class System.Diagnostics.Tracing.RuntimeEventSourceHelper : object {
    private static long prevProcUserTime;
    private static long prevProcKernelTime;
    private static long prevSystemUserTime;
    private static long prevSystemKernelTime;
    private static RuntimeEventSourceHelper();
    internal static int GetCpuUsage();
}
internal class System.Diagnostics.Tracing.ScalarArrayTypeInfo : TraceLoggingTypeInfo {
    private Func`3<EventFieldFormat, TraceLoggingDataType, TraceLoggingDataType> formatFunc;
    private TraceLoggingDataType nativeFormat;
    private int elementSize;
    private ScalarArrayTypeInfo(Type type, Func`3<EventFieldFormat, TraceLoggingDataType, TraceLoggingDataType> formatFunc, TraceLoggingDataType nativeFormat, int elementSize);
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
    public static TraceLoggingTypeInfo Boolean();
    public static TraceLoggingTypeInfo Byte();
    public static TraceLoggingTypeInfo SByte();
    public static TraceLoggingTypeInfo Char();
    public static TraceLoggingTypeInfo Int16();
    public static TraceLoggingTypeInfo UInt16();
    public static TraceLoggingTypeInfo Int32();
    public static TraceLoggingTypeInfo UInt32();
    public static TraceLoggingTypeInfo Int64();
    public static TraceLoggingTypeInfo UInt64();
    public static TraceLoggingTypeInfo IntPtr();
    public static TraceLoggingTypeInfo UIntPtr();
    public static TraceLoggingTypeInfo Single();
    public static TraceLoggingTypeInfo Double();
    public static TraceLoggingTypeInfo Guid();
}
internal class System.Diagnostics.Tracing.ScalarTypeInfo : TraceLoggingTypeInfo {
    private Func`3<EventFieldFormat, TraceLoggingDataType, TraceLoggingDataType> formatFunc;
    private TraceLoggingDataType nativeFormat;
    private ScalarTypeInfo(Type type, Func`3<EventFieldFormat, TraceLoggingDataType, TraceLoggingDataType> formatFunc, TraceLoggingDataType nativeFormat);
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
    public static TraceLoggingTypeInfo Boolean();
    public static TraceLoggingTypeInfo Byte();
    public static TraceLoggingTypeInfo SByte();
    public static TraceLoggingTypeInfo Char();
    public static TraceLoggingTypeInfo Int16();
    public static TraceLoggingTypeInfo UInt16();
    public static TraceLoggingTypeInfo Int32();
    public static TraceLoggingTypeInfo UInt32();
    public static TraceLoggingTypeInfo Int64();
    public static TraceLoggingTypeInfo UInt64();
    public static TraceLoggingTypeInfo IntPtr();
    public static TraceLoggingTypeInfo UIntPtr();
    public static TraceLoggingTypeInfo Single();
    public static TraceLoggingTypeInfo Double();
    public static TraceLoggingTypeInfo Guid();
}
[DefaultMemberAttribute("Item")]
internal class System.Diagnostics.Tracing.SessionMask : ValueType {
    private UInt32 m_mask;
    public static SessionMask All { get; }
    public SessionMask(UInt32 mask);
    public static SessionMask get_All();
    public ulong ToEventKeywords();
    public static SessionMask FromEventKeywords(ulong m);
    public static UInt32 op_Explicit(SessionMask m);
}
internal static class System.Diagnostics.Tracing.SimpleEventTypes`1 : object {
    private static TraceLoggingEventTypes instance;
    public static TraceLoggingEventTypes Instance { get; }
    public static TraceLoggingEventTypes get_Instance();
    private static TraceLoggingEventTypes InitInstance();
}
internal static class System.Diagnostics.Tracing.Statics : object {
    public static TraceLoggingDataType IntPtrType;
    public static TraceLoggingDataType UIntPtrType;
    public static TraceLoggingDataType HexIntPtrType;
    private static Statics();
    public static Byte[] MetadataForString(string name, int prefixSize, int suffixSize, int additionalSize);
    public static void EncodeTags(int tags, Int32& pos, Byte[] metadata);
    public static byte Combine(int settingValue, byte defaultValue);
    public static int Combine(int settingValue1, int settingValue2);
    public static void CheckName(string name);
    public static bool ShouldOverrideFieldName(string fieldName);
    public static TraceLoggingDataType MakeDataType(TraceLoggingDataType baseType, EventFieldFormat format);
    public static TraceLoggingDataType Format8(EventFieldFormat format, TraceLoggingDataType native);
    public static TraceLoggingDataType Format16(EventFieldFormat format, TraceLoggingDataType native);
    public static TraceLoggingDataType Format32(EventFieldFormat format, TraceLoggingDataType native);
    public static TraceLoggingDataType Format64(EventFieldFormat format, TraceLoggingDataType native);
    public static TraceLoggingDataType FormatPtr(EventFieldFormat format, TraceLoggingDataType native);
    public static bool IsValueType(Type type);
    public static bool IsEnum(Type type);
    public static IEnumerable`1<PropertyInfo> GetProperties(Type type);
    public static MethodInfo GetGetMethod(PropertyInfo propInfo);
    public static bool HasCustomAttribute(PropertyInfo propInfo, Type attributeType);
    public static AttributeType GetCustomAttribute(PropertyInfo propInfo);
    public static AttributeType GetCustomAttribute(Type type);
    public static Type[] GetGenericArguments(Type type);
    public static Type FindEnumerableElementType(Type type);
    public static bool IsGenericMatch(Type type, object openType);
    public static TraceLoggingTypeInfo CreateDefaultTypeInfo(Type dataType, List`1<Type> recursionCheck);
}
internal class System.Diagnostics.Tracing.StringTypeInfo : TraceLoggingTypeInfo {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
    public virtual object GetData(object value);
}
internal class System.Diagnostics.Tracing.TimeSpanTypeInfo : TraceLoggingTypeInfo {
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
}
internal class System.Diagnostics.Tracing.TraceLoggingDataCollector : object {
    internal static TraceLoggingDataCollector Instance;
    private static TraceLoggingDataCollector();
    public int BeginBufferedArray();
    public void EndBufferedArray(int bookmark, int count);
    public void AddScalar(PropertyValue value);
    public void AddScalar(long value);
    public void AddScalar(double value);
    public void AddScalar(bool value);
    public void AddNullTerminatedString(string value);
    public void AddArray(PropertyValue value, int elementSize);
}
internal enum System.Diagnostics.Tracing.TraceLoggingDataType : Enum {
    public int value__;
    public static TraceLoggingDataType Nil;
    public static TraceLoggingDataType Utf16String;
    public static TraceLoggingDataType MbcsString;
    public static TraceLoggingDataType Int8;
    public static TraceLoggingDataType UInt8;
    public static TraceLoggingDataType Int16;
    public static TraceLoggingDataType UInt16;
    public static TraceLoggingDataType Int32;
    public static TraceLoggingDataType UInt32;
    public static TraceLoggingDataType Int64;
    public static TraceLoggingDataType UInt64;
    public static TraceLoggingDataType Float;
    public static TraceLoggingDataType Double;
    public static TraceLoggingDataType Boolean32;
    public static TraceLoggingDataType Binary;
    public static TraceLoggingDataType Guid;
    public static TraceLoggingDataType FileTime;
    public static TraceLoggingDataType SystemTime;
    public static TraceLoggingDataType HexInt32;
    public static TraceLoggingDataType HexInt64;
    public static TraceLoggingDataType CountedUtf16String;
    public static TraceLoggingDataType CountedMbcsString;
    public static TraceLoggingDataType Struct;
    public static TraceLoggingDataType Char16;
    public static TraceLoggingDataType Char8;
    public static TraceLoggingDataType Boolean8;
    public static TraceLoggingDataType HexInt8;
    public static TraceLoggingDataType HexInt16;
    public static TraceLoggingDataType Utf16Xml;
    public static TraceLoggingDataType MbcsXml;
    public static TraceLoggingDataType CountedUtf16Xml;
    public static TraceLoggingDataType CountedMbcsXml;
    public static TraceLoggingDataType Utf16Json;
    public static TraceLoggingDataType MbcsJson;
    public static TraceLoggingDataType CountedUtf16Json;
    public static TraceLoggingDataType CountedMbcsJson;
    public static TraceLoggingDataType HResult;
}
[DefaultMemberAttribute("Item")]
internal class System.Diagnostics.Tracing.TraceLoggingEventHandleTable : object {
    private IntPtr[] m_innerTable;
    internal IntPtr Item { get; }
    internal IntPtr get_Item(int eventID);
    internal void SetEventHandle(int eventID, IntPtr eventHandle);
}
public class System.Diagnostics.Tracing.TraceLoggingEventTypes : object {
    internal TraceLoggingTypeInfo[] typeInfos;
    internal String[] paramNames;
    internal string name;
    internal EventTags tags;
    internal byte level;
    internal byte opcode;
    internal EventKeywords keywords;
    internal Byte[] typeMetadata;
    internal int scratchSize;
    internal int dataCount;
    internal int pinCount;
    private ConcurrentSet`2<KeyValuePair`2<string, EventTags>, NameInfo> nameInfos;
    [NullableAttribute("1")]
internal string Name { get; }
    internal EventTags Tags { get; }
    internal TraceLoggingEventTypes(string name, EventTags tags, Type[] types);
    internal TraceLoggingEventTypes(string name, EventTags tags, TraceLoggingTypeInfo[] typeInfos);
    internal TraceLoggingEventTypes(string name, EventTags tags, ParameterInfo[] paramInfos);
    private TraceLoggingEventTypes(EventTags tags, string defaultName, TraceLoggingTypeInfo[] typeInfos);
    internal string get_Name();
    internal EventTags get_Tags();
    internal NameInfo GetNameInfo(string name, EventTags tags);
    private TraceLoggingTypeInfo[] MakeArray(ParameterInfo[] paramInfos);
    private static TraceLoggingTypeInfo[] MakeArray(Type[] types);
    private static TraceLoggingTypeInfo[] MakeArray(TraceLoggingTypeInfo[] typeInfos);
    private static String[] MakeParamNameArray(ParameterInfo[] paramInfos);
}
internal class System.Diagnostics.Tracing.TraceLoggingMetadataCollector : object {
    private Impl impl;
    private FieldMetadata currentGroup;
    private int bufferedArrayFieldCount;
    [CompilerGeneratedAttribute]
private EventFieldTags <Tags>k__BackingField;
    internal EventFieldTags Tags { get; internal set; }
    internal int ScratchSize { get; }
    internal int DataCount { get; }
    internal int PinCount { get; }
    private bool BeginningBufferedArray { get; }
    private TraceLoggingMetadataCollector(TraceLoggingMetadataCollector other, FieldMetadata group);
    [CompilerGeneratedAttribute]
internal EventFieldTags get_Tags();
    [CompilerGeneratedAttribute]
internal void set_Tags(EventFieldTags value);
    internal int get_ScratchSize();
    internal int get_DataCount();
    internal int get_PinCount();
    private bool get_BeginningBufferedArray();
    public TraceLoggingMetadataCollector AddGroup(string name);
    public void AddScalar(string name, TraceLoggingDataType type);
    public void AddNullTerminatedString(string name, TraceLoggingDataType type);
    public void AddArray(string name, TraceLoggingDataType type);
    public void BeginBufferedArray();
    public void EndBufferedArray();
    internal Byte[] GetMetadata();
    private void AddField(FieldMetadata fieldMetadata);
}
internal abstract class System.Diagnostics.Tracing.TraceLoggingTypeInfo : object {
    private string name;
    private EventKeywords keywords;
    private EventLevel level;
    private EventOpcode opcode;
    private EventTags tags;
    private Type dataType;
    private Func`2<object, PropertyValue> propertyValueFactory;
    [ThreadStaticAttribute]
private static Dictionary`2<Type, TraceLoggingTypeInfo> threadCache;
    public string Name { get; }
    public EventLevel Level { get; }
    public EventOpcode Opcode { get; }
    public EventKeywords Keywords { get; }
    public EventTags Tags { get; }
    internal Type DataType { get; }
    internal Func`2<object, PropertyValue> PropertyValueFactory { get; }
    internal TraceLoggingTypeInfo(Type dataType);
    internal TraceLoggingTypeInfo(Type dataType, string name, EventLevel level, EventOpcode opcode, EventKeywords keywords, EventTags tags);
    public string get_Name();
    public EventLevel get_Level();
    public EventOpcode get_Opcode();
    public EventKeywords get_Keywords();
    public EventTags get_Tags();
    internal Type get_DataType();
    internal Func`2<object, PropertyValue> get_PropertyValueFactory();
    public abstract virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public abstract virtual void WriteData(TraceLoggingDataCollector collector, PropertyValue value);
    public virtual object GetData(object value);
    public static TraceLoggingTypeInfo GetInstance(Type type, List`1<Type> recursionCheck);
}
internal class System.Diagnostics.Tracing.TypeAnalysis : object {
    internal PropertyAnalysis[] properties;
    internal string name;
    internal EventKeywords keywords;
    internal EventLevel level;
    internal EventOpcode opcode;
    internal EventTags tags;
    public TypeAnalysis(Type dataType, EventDataAttribute eventAttrib, List`1<Type> recursionCheck);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.DivideByZeroException : ArithmeticException {
    public DivideByZeroException(string message);
    public DivideByZeroException(string message, Exception innerException);
    [NullableContextAttribute("1")]
protected DivideByZeroException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableAttribute("0")]
[NullableContextAttribute("2")]
public class System.DllNotFoundException : TypeLoadException {
    public DllNotFoundException(string message);
    public DllNotFoundException(string message, Exception inner);
    [NullableContextAttribute("1")]
protected DllNotFoundException(SerializationInfo info, StreamingContext context);
}
[IsReadOnlyAttribute]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Double : ValueType {
    private double m_value;
    public static double MinValue;
    public static double MaxValue;
    public static double Epsilon;
    public static double NegativeInfinity;
    public static double PositiveInfinity;
    public static double NaN;
    [NonVersionableAttribute]
public static bool IsFinite(double d);
    [NonVersionableAttribute]
public static bool IsInfinity(double d);
    [NonVersionableAttribute]
public static bool IsNaN(double d);
    [NonVersionableAttribute]
public static bool IsNegative(double d);
    [NonVersionableAttribute]
public static bool IsNegativeInfinity(double d);
    [NonVersionableAttribute]
public static bool IsNormal(double d);
    [NonVersionableAttribute]
public static bool IsPositiveInfinity(double d);
    [NonVersionableAttribute]
public static bool IsSubnormal(double d);
    internal static int ExtractExponentFromBits(ulong bits);
    internal static ulong ExtractSignificandFromBits(ulong bits);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(double value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public static bool op_Equality(double left, double right);
    [NonVersionableAttribute]
public static bool op_Inequality(double left, double right);
    [NonVersionableAttribute]
public static bool op_LessThan(double left, double right);
    [NonVersionableAttribute]
public static bool op_GreaterThan(double left, double right);
    [NonVersionableAttribute]
public static bool op_LessThanOrEqual(double left, double right);
    [NonVersionableAttribute]
public static bool op_GreaterThanOrEqual(double left, double right);
    public sealed virtual bool Equals(double obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("1")]
public sealed virtual string ToString(IFormatProvider provider);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static double Parse(string s);
    [NullableContextAttribute("1")]
public static double Parse(string s, NumberStyles style);
    [NullableContextAttribute("1")]
public static double Parse(string s, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static double Parse(string s, NumberStyles style, IFormatProvider provider);
    public static double Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, Double& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, Double& result);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Double& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Double& result);
    private static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, NumberFormatInfo info, Double& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[IsByRefLikeAttribute]
[DefaultMemberAttribute("Item")]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class System.DTSubString : ValueType {
    internal ReadOnlySpan`1<char> s;
    internal int index;
    internal int length;
    internal DTSubStringType type;
    internal int value;
    internal char Item { get; }
    internal char get_Item(int relativeIndex);
}
internal enum System.DTSubStringType : Enum {
    public int value__;
    public static DTSubStringType Unknown;
    public static DTSubStringType Invalid;
    public static DTSubStringType Number;
    public static DTSubStringType End;
    public static DTSubStringType Other;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.DuplicateWaitObjectException : ArgumentException {
    public DuplicateWaitObjectException(string parameterName);
    public DuplicateWaitObjectException(string parameterName, string message);
    public DuplicateWaitObjectException(string message, Exception innerException);
    [NullableContextAttribute("1")]
protected DuplicateWaitObjectException(SerializationInfo info, StreamingContext context);
}
internal class System.Empty : object {
    public static Empty Value;
    private static Empty();
    public virtual string ToString();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.EntryPointNotFoundException : TypeLoadException {
    public EntryPointNotFoundException(string message);
    public EntryPointNotFoundException(string message, Exception inner);
    [NullableContextAttribute("1")]
protected EntryPointNotFoundException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public abstract class System.Enum : ValueType {
    private static void GetEnumValuesAndNames(QCallTypeHandle enumType, ObjectHandleOnStack values, ObjectHandleOnStack names, BOOL getNames);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    private static object InternalBoxEnum(RuntimeType enumType, long value);
    private static int InternalCompareTo(object thisRef, object target);
    private CorElementType InternalGetCorElementType();
    internal static RuntimeType InternalGetUnderlyingType(RuntimeType enumType);
    private bool InternalHasFlag(Enum flags);
    private static EnumInfo GetEnumInfo(RuntimeType enumType, bool getNames);
    internal static UInt64[] InternalGetValues(RuntimeType enumType);
    internal static String[] InternalGetNames(RuntimeType enumType);
    [IntrinsicAttribute]
public bool HasFlag(Enum flag);
    public static string GetName(Type enumType, object value);
    public static String[] GetNames(Type enumType);
    public static Type GetUnderlyingType(Type enumType);
    public static Array GetValues(Type enumType);
    public static bool IsDefined(Type enumType, object value);
    private static RuntimeType ValidateRuntimeType(Type enumType);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object target);
    private string ValueToString();
    private string ValueToHexString();
    private static string ValueToHexString(object value);
    internal static string GetEnumName(RuntimeType enumType, ulong ulValue);
    private static string GetEnumName(EnumInfo enumInfo, ulong ulValue);
    private static string InternalFormat(RuntimeType enumType, ulong value);
    private static string InternalFlagsFormat(RuntimeType enumType, ulong result);
    private static string InternalFlagsFormat(RuntimeType enumType, EnumInfo enumInfo, ulong resultValue);
    internal static ulong ToUInt64(object value);
    public static object Parse(Type enumType, string value);
    public static object Parse(Type enumType, string value, bool ignoreCase);
    [NullableContextAttribute("0")]
public static TEnum Parse(string value);
    [NullableContextAttribute("0")]
public static TEnum Parse(string value, bool ignoreCase);
    [NullableContextAttribute("2")]
public static bool TryParse(Type enumType, string value, Object& result);
    [NullableContextAttribute("2")]
public static bool TryParse(Type enumType, string value, bool ignoreCase, Object& result);
    private static bool TryParse(Type enumType, string value, bool ignoreCase, bool throwOnFailure, Object& result);
    [NullableContextAttribute("0")]
public static bool TryParse(string value, TEnum& result);
    [NullableContextAttribute("0")]
public static bool TryParse(string value, bool ignoreCase, TEnum& result);
    private static bool TryParse(string value, bool ignoreCase, bool throwOnFailure, TEnum& result);
    private static bool TryParseInt32Enum(RuntimeType enumType, string originalValueString, ReadOnlySpan`1<char> value, int minInclusive, int maxInclusive, bool ignoreCase, bool throwOnFailure, TypeCode type, Int32& result);
    private static bool TryParseUInt32Enum(RuntimeType enumType, string originalValueString, ReadOnlySpan`1<char> value, UInt32 maxInclusive, bool ignoreCase, bool throwOnFailure, TypeCode type, UInt32& result);
    private static bool TryParseInt64Enum(RuntimeType enumType, string originalValueString, ReadOnlySpan`1<char> value, bool ignoreCase, bool throwOnFailure, Int64& result);
    private static bool TryParseUInt64Enum(RuntimeType enumType, string originalValueString, ReadOnlySpan`1<char> value, bool ignoreCase, bool throwOnFailure, UInt64& result);
    private static bool TryParseRareEnum(RuntimeType enumType, string originalValueString, ReadOnlySpan`1<char> value, bool ignoreCase, bool throwOnFailure, Object& result);
    private static bool TryParseByName(RuntimeType enumType, string originalValueString, ReadOnlySpan`1<char> value, bool ignoreCase, bool throwOnFailure, UInt64& result);
    private static bool StartsNumber(char c);
    public static object ToObject(Type enumType, object value);
    public static string Format(Type enumType, object value, string format);
    internal object GetValue();
    private ulong ToUInt64();
    public virtual int GetHashCode();
    public virtual string ToString();
    [NullableContextAttribute("2")]
[ObsoleteAttribute("The provider argument is not used. Please use ToString(String).")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public string ToString(string format);
    [ObsoleteAttribute("The provider argument is not used. Please use ToString().")]
public sealed virtual string ToString(IFormatProvider provider);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static object ToObject(Type enumType, sbyte value);
    public static object ToObject(Type enumType, short value);
    public static object ToObject(Type enumType, int value);
    public static object ToObject(Type enumType, byte value);
    [CLSCompliantAttribute("False")]
public static object ToObject(Type enumType, ushort value);
    [CLSCompliantAttribute("False")]
public static object ToObject(Type enumType, UInt32 value);
    public static object ToObject(Type enumType, long value);
    [CLSCompliantAttribute("False")]
public static object ToObject(Type enumType, ulong value);
    private static object ToObject(Type enumType, char value);
    private static object ToObject(Type enumType, bool value);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public static class System.Environment : object {
    private static String[] s_commandLineArgs;
    private static OperatingSystem s_osVersion;
    public static int CurrentManagedThreadId { get; }
    public static int ExitCode { get; public set; }
    public static bool HasShutdownStarted { get; }
    public static int ProcessorCount { get; }
    public static string StackTrace { get; }
    public static int TickCount { get; }
    public static long TickCount64 { get; }
    internal static bool IsWinRTSupported { get; }
    public static string CommandLine { get; }
    public static string CurrentDirectory { get; public set; }
    public static bool Is64BitProcess { get; }
    public static bool Is64BitOperatingSystem { get; }
    public static OperatingSystem OSVersion { get; }
    public static bool UserInteractive { get; }
    public static Version Version { get; }
    private static string CurrentDirectoryCore { get; private set; }
    public static string NewLine { get; }
    public static int SystemPageSize { get; }
    private static bool Is64BitOperatingSystemWhen32BitProcess { get; }
    public static string MachineName { get; }
    public static string SystemDirectory { get; }
    public static long WorkingSet { get; }
    internal static bool IsWindows8OrAbove { get; }
    public static string UserName { get; }
    public static string UserDomainName { get; }
    public static int get_CurrentManagedThreadId();
    private static void _Exit(int exitCode);
    [DoesNotReturnAttribute]
public static void Exit(int exitCode);
    public static int get_ExitCode();
    public static void set_ExitCode(int value);
    [DoesNotReturnAttribute]
[NullableContextAttribute("2")]
public static void FailFast(string message);
    [DoesNotReturnAttribute]
[NullableContextAttribute("2")]
public static void FailFast(string message, Exception exception);
    [DoesNotReturnAttribute]
[NullableContextAttribute("2")]
public static void FailFast(string message, Exception exception, string errorMessage);
    private static String[] GetCommandLineArgsNative();
    public static String[] GetCommandLineArgs();
    public static bool get_HasShutdownStarted();
    public static int get_ProcessorCount();
    private static int GetProcessorCount();
    internal static string GetResourceStringLocal(string key);
    public static string get_StackTrace();
    public static int get_TickCount();
    public static long get_TickCount64();
    internal static bool get_IsWinRTSupported();
    private static BOOL WinRTSupported();
    public static string GetEnvironmentVariable(string variable);
    public static string GetEnvironmentVariable(string variable, EnvironmentVariableTarget target);
    public static IDictionary GetEnvironmentVariables(EnvironmentVariableTarget target);
    public static void SetEnvironmentVariable(string variable, string value);
    public static void SetEnvironmentVariable(string variable, string value, EnvironmentVariableTarget target);
    public static string get_CommandLine();
    public static string get_CurrentDirectory();
    public static void set_CurrentDirectory(string value);
    public static string ExpandEnvironmentVariables(string name);
    internal static void SetCommandLineArgs(String[] cmdLineArgs);
    public static string GetFolderPath(SpecialFolder folder);
    public static string GetFolderPath(SpecialFolder folder, SpecialFolderOption option);
    public static bool get_Is64BitProcess();
    public static bool get_Is64BitOperatingSystem();
    public static OperatingSystem get_OSVersion();
    public static bool get_UserInteractive();
    public static Version get_Version();
    private static bool ValidateAndConvertRegistryTarget(EnvironmentVariableTarget target);
    private static void ValidateVariableAndValue(string variable, String& value);
    private static string get_CurrentDirectoryCore();
    private static void set_CurrentDirectoryCore(string value);
    public static String[] GetLogicalDrives();
    public static string get_NewLine();
    public static int get_SystemPageSize();
    private static string ExpandEnvironmentVariablesCore(string name);
    private static bool get_Is64BitOperatingSystemWhen32BitProcess();
    public static string get_MachineName();
    private static OperatingSystem GetOSVersion();
    public static string get_SystemDirectory();
    public static long get_WorkingSet();
    internal static bool get_IsWindows8OrAbove();
    private static string GetEnvironmentVariableFromRegistry(string variable, bool fromMachine);
    private static void SetEnvironmentVariableFromRegistry(string variable, string value, bool fromMachine);
    private static IDictionary GetEnvironmentVariablesFromRegistry(bool fromMachine);
    private static RegistryKey OpenEnvironmentKeyIfExists(bool fromMachine, bool writable);
    public static string get_UserName();
    private static void GetUserName(ValueStringBuilder& builder);
    public static string get_UserDomainName();
    private static string GetFolderPathCore(SpecialFolder folder, SpecialFolderOption option);
    private static string GetKnownFolderPath(string folderGuid, SpecialFolderOption option);
    private static string GetEnvironmentVariableCore(string variable);
    private static void SetEnvironmentVariableCore(string variable, string value);
    public static IDictionary GetEnvironmentVariables();
}
public enum System.EnvironmentVariableTarget : Enum {
    public int value__;
    public static EnvironmentVariableTarget Process;
    public static EnvironmentVariableTarget User;
    public static EnvironmentVariableTarget Machine;
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.EventArgs : object {
    [NullableAttribute("1")]
public static EventArgs Empty;
    private static EventArgs();
}
public class System.EventHandler : MulticastDelegate {
    public EventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender, EventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, EventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.EventHandler`1 : MulticastDelegate {
    public EventHandler`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender, TEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, TEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableAttribute("0")]
public class System.Exception : object {
    private static object s_DispatchStateLock;
    private MethodBase _exceptionMethod;
    internal string _message;
    private IDictionary _data;
    private Exception _innerException;
    private string _helpURL;
    private object _stackTrace;
    private object _watsonBuckets;
    private string _stackTraceString;
    private string _remoteStackTraceString;
    private object _dynamicMethods;
    private string _source;
    private UIntPtr _ipForWatsonBuckets;
    private IntPtr _xptrs;
    private int _xcode;
    private int _HResult;
    private static int _COMPlusExceptionCode;
    private protected static string InnerExceptionPrefix;
    public MethodBase TargetSite { get; }
    public string StackTrace { get; }
    private string SerializationRemoteStackTraceString { get; }
    private object SerializationWatsonBuckets { get; }
    private string SerializationStackTraceString { get; }
    [NullableAttribute("1")]
public string Message { get; }
    [NullableAttribute("1")]
public IDictionary Data { get; }
    public Exception InnerException { get; }
    public string HelpLink { get; public set; }
    public string Source { get; public set; }
    public int HResult { get; public set; }
    public Exception(string message);
    public Exception(string message, Exception innerException);
    [NullableContextAttribute("1")]
protected Exception(SerializationInfo info, StreamingContext context);
    private static Exception();
    private IDictionary CreateDataContainer();
    private static bool IsImmutableAgileException(Exception e);
    internal void AddExceptionDataForRestrictedErrorInfo(string restrictedError, string restrictedErrorReference, string restrictedCapabilitySid, object restrictedErrorObject, bool hasrestrictedLanguageErrorObject);
    internal bool TryGetRestrictedLanguageErrorObject(Object& restrictedErrorObject);
    private static IRuntimeMethodInfo GetMethodFromStackTrace(object stackTrace);
    private MethodBase GetExceptionMethodFromStackTrace();
    public MethodBase get_TargetSite();
    public virtual string get_StackTrace();
    private static string GetStackTrace(Exception e);
    private string CreateSourceName();
    [OnDeserializedAttribute]
private void OnDeserialized(StreamingContext context);
    internal void InternalPreserveStackTrace();
    private static void PrepareForForeignExceptionRaise();
    private static void GetStackTracesDeepCopy(Exception exception, Object& currentStackTrace, Object& dynamicMethodArray);
    internal static void SaveStackTracesFromDeepCopy(Exception exception, object currentStackTrace, object dynamicMethodArray);
    private static object CopyStackTrace(object currentStackTrace);
    private static object CopyDynamicMethods(object currentDynamicMethods);
    internal static UInt32 GetExceptionCount();
    internal object DeepCopyStackTrace(object currentStackTrace);
    internal object DeepCopyDynamicMethods(object currentDynamicMethods);
    internal void RestoreDispatchState(DispatchState& dispatchState);
    private string get_SerializationRemoteStackTraceString();
    private object get_SerializationWatsonBuckets();
    private string get_SerializationStackTraceString();
    internal static string GetMessageFromNativeResources(ExceptionMessageKind kind);
    private static void GetMessageFromNativeResources(ExceptionMessageKind kind, StringHandleOnStack retMesg);
    internal DispatchState CaptureDispatchState();
    [NullableContextAttribute("1")]
public virtual string get_Message();
    [NullableContextAttribute("1")]
public virtual IDictionary get_Data();
    private string GetClassName();
    [NullableContextAttribute("1")]
public virtual Exception GetBaseException();
    public Exception get_InnerException();
    public virtual string get_HelpLink();
    public virtual void set_HelpLink(string value);
    public virtual string get_Source();
    public virtual void set_Source(string value);
    [NullableContextAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("1")]
public virtual string ToString();
    protected void add_SerializeObjectState(EventHandler`1<SafeSerializationEventArgs> value);
    protected void remove_SerializeObjectState(EventHandler`1<SafeSerializationEventArgs> value);
    public int get_HResult();
    public void set_HResult(int value);
    [NullableContextAttribute("1")]
public Type GetType();
    private void RestoreRemoteStackTrace(SerializationInfo info, StreamingContext context);
}
internal enum System.ExceptionArgument : Enum {
    public int value__;
    public static ExceptionArgument obj;
    public static ExceptionArgument dictionary;
    public static ExceptionArgument array;
    public static ExceptionArgument info;
    public static ExceptionArgument key;
    public static ExceptionArgument text;
    public static ExceptionArgument values;
    public static ExceptionArgument value;
    public static ExceptionArgument startIndex;
    public static ExceptionArgument task;
    public static ExceptionArgument bytes;
    public static ExceptionArgument byteIndex;
    public static ExceptionArgument byteCount;
    public static ExceptionArgument ch;
    public static ExceptionArgument chars;
    public static ExceptionArgument charIndex;
    public static ExceptionArgument charCount;
    public static ExceptionArgument s;
    public static ExceptionArgument input;
    public static ExceptionArgument ownedMemory;
    public static ExceptionArgument list;
    public static ExceptionArgument index;
    public static ExceptionArgument capacity;
    public static ExceptionArgument collection;
    public static ExceptionArgument item;
    public static ExceptionArgument converter;
    public static ExceptionArgument match;
    public static ExceptionArgument count;
    public static ExceptionArgument action;
    public static ExceptionArgument comparison;
    public static ExceptionArgument exceptions;
    public static ExceptionArgument exception;
    public static ExceptionArgument pointer;
    public static ExceptionArgument start;
    public static ExceptionArgument format;
    public static ExceptionArgument culture;
    public static ExceptionArgument comparer;
    public static ExceptionArgument comparable;
    public static ExceptionArgument source;
    public static ExceptionArgument state;
    public static ExceptionArgument length;
    public static ExceptionArgument comparisonType;
    public static ExceptionArgument manager;
    public static ExceptionArgument sourceBytesToCopy;
    public static ExceptionArgument callBack;
    public static ExceptionArgument creationOptions;
    public static ExceptionArgument function;
    public static ExceptionArgument scheduler;
    public static ExceptionArgument continuationAction;
    public static ExceptionArgument continuationFunction;
    public static ExceptionArgument tasks;
    public static ExceptionArgument asyncResult;
    public static ExceptionArgument beginMethod;
    public static ExceptionArgument endMethod;
    public static ExceptionArgument endFunction;
    public static ExceptionArgument cancellationToken;
    public static ExceptionArgument continuationOptions;
    public static ExceptionArgument delay;
    public static ExceptionArgument millisecondsDelay;
    public static ExceptionArgument millisecondsTimeout;
    public static ExceptionArgument stateMachine;
    public static ExceptionArgument timeout;
    public static ExceptionArgument type;
    public static ExceptionArgument sourceIndex;
    public static ExceptionArgument sourceArray;
    public static ExceptionArgument destinationIndex;
    public static ExceptionArgument destinationArray;
    public static ExceptionArgument pHandle;
    public static ExceptionArgument other;
    public static ExceptionArgument newSize;
    public static ExceptionArgument lowerBounds;
    public static ExceptionArgument lengths;
    public static ExceptionArgument len;
    public static ExceptionArgument keys;
    public static ExceptionArgument indices;
    public static ExceptionArgument index1;
    public static ExceptionArgument index2;
    public static ExceptionArgument index3;
    public static ExceptionArgument length1;
    public static ExceptionArgument length2;
    public static ExceptionArgument length3;
    public static ExceptionArgument endIndex;
    public static ExceptionArgument elementType;
    public static ExceptionArgument arrayIndex;
}
internal enum System.ExceptionResource : Enum {
    public int value__;
    public static ExceptionResource ArgumentOutOfRange_Index;
    public static ExceptionResource ArgumentOutOfRange_IndexCount;
    public static ExceptionResource ArgumentOutOfRange_IndexCountBuffer;
    public static ExceptionResource ArgumentOutOfRange_Count;
    public static ExceptionResource Arg_ArrayPlusOffTooSmall;
    public static ExceptionResource NotSupported_ReadOnlyCollection;
    public static ExceptionResource Arg_RankMultiDimNotSupported;
    public static ExceptionResource Arg_NonZeroLowerBound;
    public static ExceptionResource ArgumentOutOfRange_ListInsert;
    public static ExceptionResource ArgumentOutOfRange_NeedNonNegNum;
    public static ExceptionResource ArgumentOutOfRange_SmallCapacity;
    public static ExceptionResource Argument_InvalidOffLen;
    public static ExceptionResource Argument_CannotExtractScalar;
    public static ExceptionResource ArgumentOutOfRange_BiggerThanCollection;
    public static ExceptionResource Serialization_MissingKeys;
    public static ExceptionResource Serialization_NullKey;
    public static ExceptionResource NotSupported_KeyCollectionSet;
    public static ExceptionResource NotSupported_ValueCollectionSet;
    public static ExceptionResource InvalidOperation_NullArray;
    public static ExceptionResource TaskT_TransitionToFinal_AlreadyCompleted;
    public static ExceptionResource TaskCompletionSourceT_TrySetException_NullException;
    public static ExceptionResource TaskCompletionSourceT_TrySetException_NoExceptions;
    public static ExceptionResource NotSupported_StringComparison;
    public static ExceptionResource ConcurrentCollection_SyncRoot_NotSupported;
    public static ExceptionResource Task_MultiTaskContinuation_NullTask;
    public static ExceptionResource InvalidOperation_WrongAsyncResultOrEndCalledMultiple;
    public static ExceptionResource Task_MultiTaskContinuation_EmptyTaskList;
    public static ExceptionResource Task_Start_TaskCompleted;
    public static ExceptionResource Task_Start_Promise;
    public static ExceptionResource Task_Start_ContinuationTask;
    public static ExceptionResource Task_Start_AlreadyStarted;
    public static ExceptionResource Task_RunSynchronously_Continuation;
    public static ExceptionResource Task_RunSynchronously_Promise;
    public static ExceptionResource Task_RunSynchronously_TaskCompleted;
    public static ExceptionResource Task_RunSynchronously_AlreadyStarted;
    public static ExceptionResource AsyncMethodBuilder_InstanceNotInitialized;
    public static ExceptionResource Task_ContinueWith_ESandLR;
    public static ExceptionResource Task_ContinueWith_NotOnAnything;
    public static ExceptionResource Task_Delay_InvalidDelay;
    public static ExceptionResource Task_Delay_InvalidMillisecondsDelay;
    public static ExceptionResource Task_Dispose_NotCompleted;
    public static ExceptionResource Task_ThrowIfDisposed;
    public static ExceptionResource Task_WaitMulti_NullTask;
    public static ExceptionResource ArgumentException_OtherNotArrayOfCorrectLength;
    public static ExceptionResource ArgumentNull_Array;
    public static ExceptionResource ArgumentNull_SafeHandle;
    public static ExceptionResource ArgumentOutOfRange_EndIndexStartIndex;
    public static ExceptionResource ArgumentOutOfRange_Enum;
    public static ExceptionResource ArgumentOutOfRange_HugeArrayNotSupported;
    public static ExceptionResource Argument_AddingDuplicate;
    public static ExceptionResource Argument_InvalidArgumentForComparison;
    public static ExceptionResource Arg_LowerBoundsMustMatch;
    public static ExceptionResource Arg_MustBeType;
    public static ExceptionResource Arg_Need1DArray;
    public static ExceptionResource Arg_Need2DArray;
    public static ExceptionResource Arg_Need3DArray;
    public static ExceptionResource Arg_NeedAtLeast1Rank;
    public static ExceptionResource Arg_RankIndices;
    public static ExceptionResource Arg_RanksAndBounds;
    public static ExceptionResource InvalidOperation_IComparerFailed;
    public static ExceptionResource NotSupported_FixedSizeCollection;
    public static ExceptionResource Rank_MultiDimNotSupported;
    public static ExceptionResource Arg_TypeNotSupported;
}
[NullableContextAttribute("2")]
[ObsoleteAttribute("This type previously indicated an unspecified fatal error in the runtime. The runtime no longer raises this exception so this type is obsolete.")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableAttribute("0")]
public class System.ExecutionEngineException : SystemException {
    public ExecutionEngineException(string message);
    public ExecutionEngineException(string message, Exception innerException);
    internal ExecutionEngineException(SerializationInfo info, StreamingContext context);
}
[NullableAttribute("0")]
[NullableContextAttribute("2")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.FieldAccessException : MemberAccessException {
    public FieldAccessException(string message);
    public FieldAccessException(string message, Exception inner);
    [NullableContextAttribute("1")]
protected FieldAccessException(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("16")]
public class System.FlagsAttribute : Attribute {
}
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableContextAttribute("2")]
public class System.FormatException : SystemException {
    public FormatException(string message);
    public FormatException(string message, Exception innerException);
    [NullableContextAttribute("1")]
protected FormatException(SerializationInfo info, StreamingContext context);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public abstract class System.FormattableString : object {
    public string Format { get; }
    public int ArgumentCount { get; }
    public abstract virtual string get_Format();
    public abstract virtual Object[] GetArguments();
    public abstract virtual int get_ArgumentCount();
    [NullableContextAttribute("2")]
public abstract virtual object GetArgument(int index);
    public abstract virtual string ToString(IFormatProvider formatProvider);
    private sealed virtual override string System.IFormattable.ToString(string ignored, IFormatProvider formatProvider);
    public static string Invariant(FormattableString formattable);
    public static string CurrentCulture(FormattableString formattable);
    public virtual string ToString();
}
public class System.Func`1 : MulticastDelegate {
    public Func`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TResult Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`2 : MulticastDelegate {
    public Func`2(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TResult Invoke(T arg);
    public virtual IAsyncResult BeginInvoke(T arg, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`3 : MulticastDelegate {
    public Func`3(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TResult Invoke(T1 arg1, T2 arg2);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`4 : MulticastDelegate {
    public Func`4(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Func`5 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Func`5(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual TResult EndInvoke(IAsyncResult result);
}
[NullableAttribute("0")]
[NullableContextAttribute("2")]
public class System.Func`6 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Func`6(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual TResult EndInvoke(IAsyncResult result);
}
[NullableAttribute("0")]
[NullableContextAttribute("2")]
public class System.Func`7 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Func`7(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual TResult EndInvoke(IAsyncResult result);
}
[NullableAttribute("0")]
[NullableContextAttribute("2")]
public class System.Func`8 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Func`8(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual TResult EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Func`9 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Func`9(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual TResult EndInvoke(IAsyncResult result);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public static class System.GC : object {
    private static List`1<MemoryLoadChangeNotification> s_notifications;
    private static float s_previousMemoryLoad;
    public static int MaxGeneration { get; }
    private static GC();
    internal static void GetMemoryInfo(UInt64& highMemLoadThresholdBytes, UInt64& totalAvailableMemoryBytes, UInt64& lastRecordedMemLoadBytes, UInt32& lastRecordedMemLoadPct, UIntPtr& lastRecordedHeapSizeBytes, UIntPtr& lastRecordedFragmentationBytes);
    public static GCMemoryInfo GetGCMemoryInfo();
    internal static int _StartNoGCRegion(long totalSize, bool lohSizeKnown, long lohSize, bool disallowFullBlockingGC);
    internal static int _EndNoGCRegion();
    internal static Array AllocateNewArray(IntPtr typeHandle, int length, bool zeroingOptional);
    private static int GetGenerationWR(IntPtr handle);
    private static long GetTotalMemory();
    private static void _Collect(int generation, int mode);
    private static int GetMaxGeneration();
    private static int _CollectionCount(int generation, int getSpecialGCCount);
    internal static ulong GetSegmentSize();
    internal static int GetLastGCPercentTimeInGC();
    internal static ulong GetGenerationSize(int gen);
    private static void _AddMemoryPressure(ulong bytesAllocated);
    private static void _RemoveMemoryPressure(ulong bytesAllocated);
    public static void AddMemoryPressure(long bytesAllocated);
    public static void RemoveMemoryPressure(long bytesAllocated);
    public static int GetGeneration(object obj);
    public static void Collect(int generation);
    public static void Collect();
    public static void Collect(int generation, GCCollectionMode mode);
    public static void Collect(int generation, GCCollectionMode mode, bool blocking);
    public static void Collect(int generation, GCCollectionMode mode, bool blocking, bool compacting);
    public static int CollectionCount(int generation);
    [NullableContextAttribute("2")]
public static void KeepAlive(object obj);
    public static int GetGeneration(WeakReference wo);
    public static int get_MaxGeneration();
    private static void _WaitForPendingFinalizers();
    public static void WaitForPendingFinalizers();
    private static void _SuppressFinalize(object o);
    public static void SuppressFinalize(object obj);
    private static void _ReRegisterForFinalize(object o);
    public static void ReRegisterForFinalize(object obj);
    public static long GetTotalMemory(bool forceFullCollection);
    private static IntPtr _RegisterFrozenSegment(IntPtr sectionAddress, IntPtr sectionSize);
    private static void _UnregisterFrozenSegment(IntPtr segmentHandle);
    public static long GetAllocatedBytesForCurrentThread();
    public static long GetTotalAllocatedBytes(bool precise);
    private static bool _RegisterForFullGCNotification(int maxGenerationPercentage, int largeObjectHeapPercentage);
    private static bool _CancelFullGCNotification();
    private static int _WaitForFullGCApproach(int millisecondsTimeout);
    private static int _WaitForFullGCComplete(int millisecondsTimeout);
    public static void RegisterForFullGCNotification(int maxGenerationThreshold, int largeObjectHeapThreshold);
    public static void CancelFullGCNotification();
    public static GCNotificationStatus WaitForFullGCApproach();
    public static GCNotificationStatus WaitForFullGCApproach(int millisecondsTimeout);
    public static GCNotificationStatus WaitForFullGCComplete();
    public static GCNotificationStatus WaitForFullGCComplete(int millisecondsTimeout);
    private static bool StartNoGCRegionWorker(long totalSize, bool hasLohSize, long lohSize, bool disallowFullBlockingGC);
    public static bool TryStartNoGCRegion(long totalSize);
    public static bool TryStartNoGCRegion(long totalSize, long lohSize);
    public static bool TryStartNoGCRegion(long totalSize, bool disallowFullBlockingGC);
    public static bool TryStartNoGCRegion(long totalSize, long lohSize, bool disallowFullBlockingGC);
    private static EndNoGCRegionStatus EndNoGCRegionWorker();
    public static void EndNoGCRegion();
    internal static T[] AllocateUninitializedArray(int length);
}
public enum System.GCCollectionMode : Enum {
    public int value__;
    public static GCCollectionMode Default;
    public static GCCollectionMode Forced;
    public static GCCollectionMode Optimized;
}
[IsReadOnlyAttribute]
public class System.GCMemoryInfo : ValueType {
    [CompilerGeneratedAttribute]
private long <HighMemoryLoadThresholdBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MemoryLoadBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalAvailableMemoryBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <HeapSizeBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <FragmentedBytes>k__BackingField;
    public long HighMemoryLoadThresholdBytes { get; }
    public long MemoryLoadBytes { get; }
    public long TotalAvailableMemoryBytes { get; }
    public long HeapSizeBytes { get; }
    public long FragmentedBytes { get; }
    internal GCMemoryInfo(long highMemoryLoadThresholdBytes, long memoryLoadBytes, long totalAvailableMemoryBytes, long heapSizeBytes, long fragmentedBytes);
    [CompilerGeneratedAttribute]
public long get_HighMemoryLoadThresholdBytes();
    [CompilerGeneratedAttribute]
public long get_MemoryLoadBytes();
    [CompilerGeneratedAttribute]
public long get_TotalAvailableMemoryBytes();
    [CompilerGeneratedAttribute]
public long get_HeapSizeBytes();
    [CompilerGeneratedAttribute]
public long get_FragmentedBytes();
}
public enum System.GCNotificationStatus : Enum {
    public int value__;
    public static GCNotificationStatus Succeeded;
    public static GCNotificationStatus Failed;
    public static GCNotificationStatus Canceled;
    public static GCNotificationStatus Timeout;
    public static GCNotificationStatus NotApplicable;
}
internal class System.Gen2GcCallback : CriticalFinalizerObject {
    private Func`1<bool> _callback0;
    private Func`2<object, bool> _callback1;
    private GCHandle _weakTargetObj;
    private Gen2GcCallback(Func`2<object, bool> callback, object targetObj);
    public static void Register(Func`2<object, bool> callback, object targetObj);
    protected virtual override void Finalize();
}
internal enum System.Globalization.BidiCategory : Enum {
    public int value__;
    public static BidiCategory LeftToRight;
    public static BidiCategory LeftToRightEmbedding;
    public static BidiCategory LeftToRightOverride;
    public static BidiCategory RightToLeft;
    public static BidiCategory RightToLeftArabic;
    public static BidiCategory RightToLeftEmbedding;
    public static BidiCategory RightToLeftOverride;
    public static BidiCategory PopDirectionalFormat;
    public static BidiCategory EuropeanNumber;
    public static BidiCategory EuropeanNumberSeparator;
    public static BidiCategory EuropeanNumberTerminator;
    public static BidiCategory ArabicNumber;
    public static BidiCategory CommonNumberSeparator;
    public static BidiCategory NonSpacingMark;
    public static BidiCategory BoundaryNeutral;
    public static BidiCategory ParagraphSeparator;
    public static BidiCategory SegmentSeparator;
    public static BidiCategory Whitespace;
    public static BidiCategory OtherNeutrals;
    public static BidiCategory LeftToRightIsolate;
    public static BidiCategory RightToLeftIsolate;
    public static BidiCategory FirstStrongIsolate;
    public static BidiCategory PopDirectionIsolate;
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public abstract class System.Globalization.Calendar : object {
    private int _currentEraValue;
    private bool _isReadOnly;
    public static int CurrentEra;
    internal int _twoDigitYearMax;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal CalendarId ID { get; }
    internal CalendarId BaseCalendarID { get; }
    public bool IsReadOnly { get; }
    internal int CurrentEraValue { get; }
    public Int32[] Eras { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    public int TwoDigitYearMax { get; public set; }
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual CalendarId get_ID();
    internal virtual CalendarId get_BaseCalendarID();
    public bool get_IsReadOnly();
    public virtual object Clone();
    public static Calendar ReadOnly(Calendar calendar);
    internal void VerifyWritable();
    internal void SetReadOnlyState(bool readOnly);
    internal virtual int get_CurrentEraValue();
    internal static void CheckAddResult(long ticks, DateTime minValue, DateTime maxValue);
    internal DateTime Add(DateTime time, double value, int scale);
    public virtual DateTime AddMilliseconds(DateTime time, double milliseconds);
    public virtual DateTime AddDays(DateTime time, int days);
    public virtual DateTime AddHours(DateTime time, int hours);
    public virtual DateTime AddMinutes(DateTime time, int minutes);
    public abstract virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddSeconds(DateTime time, int seconds);
    public virtual DateTime AddWeeks(DateTime time, int weeks);
    public abstract virtual DateTime AddYears(DateTime time, int years);
    public abstract virtual int GetDayOfMonth(DateTime time);
    public abstract virtual DayOfWeek GetDayOfWeek(DateTime time);
    public abstract virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month);
    public abstract virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year);
    public abstract virtual int GetDaysInYear(int year, int era);
    public abstract virtual int GetEra(DateTime time);
    public abstract virtual Int32[] get_Eras();
    public virtual int GetHour(DateTime time);
    public virtual double GetMilliseconds(DateTime time);
    public virtual int GetMinute(DateTime time);
    public abstract virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year);
    public abstract virtual int GetMonthsInYear(int year, int era);
    public virtual int GetSecond(DateTime time);
    internal int GetFirstDayWeekOfYear(DateTime time, int firstDayOfWeek);
    private int GetWeekOfYearFullDays(DateTime time, int firstDayOfWeek, int fullDays);
    private int GetWeekOfYearOfMinSupportedDateTime(int firstDayOfWeek, int minimumDaysInFirstWeek);
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public abstract virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day);
    public abstract virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapMonth(int year, int month);
    public abstract virtual bool IsLeapMonth(int year, int month, int era);
    public virtual int GetLeapMonth(int year);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapYear(int year);
    public abstract virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond);
    public abstract virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    internal virtual bool TryToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era, DateTime& result);
    internal virtual bool IsValidYear(int year, int era);
    internal virtual bool IsValidMonth(int year, int month, int era);
    internal virtual bool IsValidDay(int year, int month, int day, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
    internal static long TimeToTicks(int hour, int minute, int second, int millisecond);
    internal static int GetSystemTwoDigitYearSetting(CalendarId CalID, int defaultYearValue);
}
public enum System.Globalization.CalendarAlgorithmType : Enum {
    public int value__;
    public static CalendarAlgorithmType Unknown;
    public static CalendarAlgorithmType SolarCalendar;
    public static CalendarAlgorithmType LunarCalendar;
    public static CalendarAlgorithmType LunisolarCalendar;
}
internal class System.Globalization.CalendarData : object {
    internal string sNativeName;
    internal String[] saShortDates;
    internal String[] saYearMonths;
    internal String[] saLongDates;
    internal string sMonthDay;
    internal String[] saEraNames;
    internal String[] saAbbrevEraNames;
    internal String[] saAbbrevEnglishEraNames;
    internal String[] saDayNames;
    internal String[] saAbbrevDayNames;
    internal String[] saSuperShortDayNames;
    internal String[] saMonthNames;
    internal String[] saAbbrevMonthNames;
    internal String[] saMonthGenitiveNames;
    internal String[] saAbbrevMonthGenitiveNames;
    internal String[] saLeapYearMonthNames;
    internal int iTwoDigitYearMax;
    internal int iCurrentEra;
    internal bool bUseUserOverrides;
    internal static CalendarData Invariant;
    internal CalendarData(string localeName, CalendarId calendarId, bool bUseUserOverrides);
    private static CalendarData();
    private static CalendarData CreateInvariant();
    private void InitializeEraNames(string localeName, CalendarId calendarId);
    private void InitializeAbbreviatedEraNames(string localeName, CalendarId calendarId);
    internal static CalendarData GetCalendarData(CalendarId calendarId);
    private static string CalendarIdToCultureName(CalendarId calendarId);
    private bool LoadCalendarDataFromSystem(string localeName, CalendarId calendarId);
    internal static int GetTwoDigitYearMax(CalendarId calendarId);
    internal static int GetCalendars(string localeName, bool useUserOverride, CalendarId[] calendars);
    private static bool SystemSupportsTaiwaneseCalendar();
    private static void CheckSpecialCalendar(CalendarId& calendar, String& localeName);
    private static bool CallGetCalendarInfoEx(string localeName, CalendarId calendar, UInt32 calType, Int32& data);
    private static bool CallGetCalendarInfoEx(string localeName, CalendarId calendar, UInt32 calType, String& data);
    private static BOOL EnumCalendarInfoCallback(Char* lpCalendarInfoString, UInt32 calendar, IntPtr pReserved, Void* lParam);
    private static bool CallEnumCalendarInfo(string localeName, CalendarId calendar, UInt32 calType, UInt32 lcType, String[]& data);
    private static bool GetCalendarDayInfo(string localeName, CalendarId calendar, UInt32 calType, String[]& outputStrings);
    private static bool GetCalendarMonthInfo(string localeName, CalendarId calendar, UInt32 calType, String[]& outputStrings);
    private static BOOL EnumCalendarsCallback(Char* lpCalendarInfoString, UInt32 calendar, IntPtr reserved, Void* lParam);
    private static string GetUserDefaultLocaleName();
}
internal enum System.Globalization.CalendarId : Enum {
    public ushort value__;
    public static CalendarId UNINITIALIZED_VALUE;
    public static CalendarId GREGORIAN;
    public static CalendarId GREGORIAN_US;
    public static CalendarId JAPAN;
    public static CalendarId TAIWAN;
    public static CalendarId KOREA;
    public static CalendarId HIJRI;
    public static CalendarId THAI;
    public static CalendarId HEBREW;
    public static CalendarId GREGORIAN_ME_FRENCH;
    public static CalendarId GREGORIAN_ARABIC;
    public static CalendarId GREGORIAN_XLIT_ENGLISH;
    public static CalendarId GREGORIAN_XLIT_FRENCH;
    public static CalendarId JULIAN;
    public static CalendarId JAPANESELUNISOLAR;
    public static CalendarId CHINESELUNISOLAR;
    public static CalendarId SAKA;
    public static CalendarId LUNAR_ETO_CHN;
    public static CalendarId LUNAR_ETO_KOR;
    public static CalendarId LUNAR_ETO_ROKUYOU;
    public static CalendarId KOREANLUNISOLAR;
    public static CalendarId TAIWANLUNISOLAR;
    public static CalendarId PERSIAN;
    public static CalendarId UMALQURA;
    public static CalendarId LAST_CALENDAR;
}
public enum System.Globalization.CalendarWeekRule : Enum {
    public int value__;
    public static CalendarWeekRule FirstDay;
    public static CalendarWeekRule FirstFullWeek;
    public static CalendarWeekRule FirstFourDayWeek;
}
internal class System.Globalization.CalendricalCalculationsHelper : object {
    private static long s_startOf1810;
    private static long s_startOf1900Century;
    private static Double[] s_coefficients1900to1987;
    private static Double[] s_coefficients1800to1899;
    private static Double[] s_coefficients1700to1799;
    private static Double[] s_coefficients1620to1699;
    private static Double[] s_lambdaCoefficients;
    private static Double[] s_anomalyCoefficients;
    private static Double[] s_eccentricityCoefficients;
    private static Double[] s_coefficients;
    private static Double[] s_coefficientsA;
    private static Double[] s_coefficientsB;
    private static EphemerisCorrectionAlgorithmMap[] s_ephemerisCorrectionTable;
    private static CalendricalCalculationsHelper();
    private static double RadiansFromDegrees(double degree);
    private static double SinOfDegree(double degree);
    private static double CosOfDegree(double degree);
    private static double TanOfDegree(double degree);
    public static double Angle(int degrees, int minutes, double seconds);
    private static double Obliquity(double julianCenturies);
    internal static long GetNumberOfDays(DateTime date);
    private static int GetGregorianYear(double numberOfDays);
    private static double Reminder(double divisor, double dividend);
    private static double NormalizeLongitude(double longitude);
    public static double AsDayFraction(double longitude);
    private static double PolynomialSum(Double[] coefficients, double indeterminate);
    private static double CenturiesFrom1900(int gregorianYear);
    private static double DefaultEphemerisCorrection(int gregorianYear);
    private static double EphemerisCorrection1988to2019(int gregorianYear);
    private static double EphemerisCorrection1900to1987(int gregorianYear);
    private static double EphemerisCorrection1800to1899(int gregorianYear);
    private static double EphemerisCorrection1700to1799(int gregorianYear);
    private static double EphemerisCorrection1620to1699(int gregorianYear);
    private static double EphemerisCorrection(double time);
    public static double JulianCenturies(double moment);
    private static bool IsNegative(double value);
    private static double CopySign(double value, double sign);
    private static double EquationOfTime(double time);
    private static double AsLocalTime(double apparentMidday, double longitude);
    public static double Midday(double date, double longitude);
    private static double InitLongitude(double longitude);
    public static double MiddayAtPersianObservationSite(double date);
    private static double PeriodicTerm(double julianCenturies, int x, double y, double z);
    private static double SumLongSequenceOfPeriodicTerms(double julianCenturies);
    private static double Aberration(double julianCenturies);
    private static double Nutation(double julianCenturies);
    public static double Compute(double time);
    public static double AsSeason(double longitude);
    private static double EstimatePrior(double longitude, double time);
    internal static long PersianNewYearOnOrBefore(long numberOfDays);
}
public static class System.Globalization.CharUnicodeInfo : object {
    private static ReadOnlySpan`1<byte> CategoryLevel1Index { get; }
    private static ReadOnlySpan`1<byte> CategoryLevel2Index { get; }
    private static ReadOnlySpan`1<byte> CategoryLevel3Index { get; }
    private static ReadOnlySpan`1<byte> CategoriesValue { get; }
    private static ReadOnlySpan`1<byte> NumericLevel1Index { get; }
    private static ReadOnlySpan`1<byte> NumericLevel2Index { get; }
    private static ReadOnlySpan`1<byte> NumericLevel3Index { get; }
    private static ReadOnlySpan`1<byte> NumericValues { get; }
    private static ReadOnlySpan`1<byte> DigitValues { get; }
    private static ReadOnlySpan`1<byte> get_CategoryLevel1Index();
    private static ReadOnlySpan`1<byte> get_CategoryLevel2Index();
    private static ReadOnlySpan`1<byte> get_CategoryLevel3Index();
    private static ReadOnlySpan`1<byte> get_CategoriesValue();
    private static ReadOnlySpan`1<byte> get_NumericLevel1Index();
    private static ReadOnlySpan`1<byte> get_NumericLevel2Index();
    private static ReadOnlySpan`1<byte> get_NumericLevel3Index();
    private static ReadOnlySpan`1<byte> get_NumericValues();
    private static ReadOnlySpan`1<byte> get_DigitValues();
    internal static int InternalConvertToUtf32(string s, int index);
    internal static int InternalConvertToUtf32(StringBuilder s, int index);
    internal static int InternalConvertToUtf32(string s, int index, Int32& charLength);
    internal static double InternalGetNumericValue(int ch);
    internal static byte InternalGetDigitValues(int ch, int offset);
    public static double GetNumericValue(char ch);
    [NullableContextAttribute("1")]
public static double GetNumericValue(string s, int index);
    public static int GetDecimalDigitValue(char ch);
    [NullableContextAttribute("1")]
public static int GetDecimalDigitValue(string s, int index);
    public static int GetDigitValue(char ch);
    [NullableContextAttribute("1")]
public static int GetDigitValue(string s, int index);
    public static UnicodeCategory GetUnicodeCategory(char ch);
    [NullableContextAttribute("1")]
public static UnicodeCategory GetUnicodeCategory(string s, int index);
    public static UnicodeCategory GetUnicodeCategory(int codePoint);
    internal static byte InternalGetCategoryValue(int ch, int offset);
    internal static UnicodeCategory InternalGetUnicodeCategory(string value, int index);
    internal static BidiCategory GetBidiCategory(string s, int index);
    internal static BidiCategory GetBidiCategory(StringBuilder s, int index);
    internal static UnicodeCategory InternalGetUnicodeCategory(string str, int index, Int32& charLength);
    internal static bool IsCombiningCategory(UnicodeCategory uc);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Globalization.ChineseLunisolarCalendar : EastAsianLunisolarCalendar {
    public static int ChineseEra;
    private static DateTime s_minDate;
    private static DateTime s_maxDate;
    private static Int32[0...,0...] s_yinfo;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    internal int MinCalendarYear { get; }
    internal int MaxCalendarYear { get; }
    internal DateTime MinDate { get; }
    internal DateTime MaxDate { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal EraInfo[] CalEraInfo { get; }
    internal CalendarId ID { get; }
    internal CalendarId BaseCalendarID { get; }
    public Int32[] Eras { get; }
    private static ChineseLunisolarCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    internal virtual int get_MinCalendarYear();
    internal virtual int get_MaxCalendarYear();
    internal virtual DateTime get_MinDate();
    internal virtual DateTime get_MaxDate();
    internal virtual EraInfo[] get_CalEraInfo();
    internal virtual int GetYearInfo(int lunarYear, int index);
    internal virtual int GetYear(int year, DateTime time);
    internal virtual int GetGregorianYear(int year, int era);
    public virtual int GetEra(DateTime time);
    internal virtual CalendarId get_ID();
    internal virtual CalendarId get_BaseCalendarID();
    public virtual Int32[] get_Eras();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Globalization.CompareInfo : object {
    internal static CompareInfo Invariant;
    [OptionalFieldAttribute]
private string m_name;
    private string _sortName;
    [OptionalFieldAttribute]
private SortVersion m_SortVersion;
    private int culture;
    private IntPtr _sortHandle;
    public string Name { get; }
    public SortVersion Version { get; }
    public int LCID { get; }
    internal CompareInfo(CultureInfo culture);
    private static CompareInfo();
    public static CompareInfo GetCompareInfo(int culture, Assembly assembly);
    public static CompareInfo GetCompareInfo(string name, Assembly assembly);
    public static CompareInfo GetCompareInfo(int culture);
    public static CompareInfo GetCompareInfo(string name);
    public static bool IsSortable(char ch);
    public static bool IsSortable(string text);
    [OnDeserializingAttribute]
private void OnDeserializing(StreamingContext ctx);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    [OnDeserializedAttribute]
private void OnDeserialized(StreamingContext ctx);
    private void OnDeserialized();
    [OnSerializingAttribute]
private void OnSerializing(StreamingContext ctx);
    public virtual string get_Name();
    [NullableContextAttribute("2")]
public virtual int Compare(string string1, string string2);
    [NullableContextAttribute("2")]
public virtual int Compare(string string1, string string2, CompareOptions options);
    internal int Compare(ReadOnlySpan`1<char> string1, string string2, CompareOptions options);
    internal int CompareOptionNone(ReadOnlySpan`1<char> string1, ReadOnlySpan`1<char> string2);
    internal int CompareOptionIgnoreCase(ReadOnlySpan`1<char> string1, ReadOnlySpan`1<char> string2);
    [NullableContextAttribute("2")]
public virtual int Compare(string string1, int offset1, int length1, string string2, int offset2, int length2);
    [NullableContextAttribute("2")]
public virtual int Compare(string string1, int offset1, string string2, int offset2, CompareOptions options);
    [NullableContextAttribute("2")]
public virtual int Compare(string string1, int offset1, string string2, int offset2);
    [NullableContextAttribute("2")]
public virtual int Compare(string string1, int offset1, int length1, string string2, int offset2, int length2, CompareOptions options);
    internal static int CompareOrdinalIgnoreCase(string strA, int indexA, int lengthA, string strB, int indexB, int lengthB);
    internal static int CompareOrdinalIgnoreCase(ReadOnlySpan`1<char> strA, ReadOnlySpan`1<char> strB);
    internal static int CompareOrdinalIgnoreCase(string strA, string strB);
    internal static int CompareOrdinalIgnoreCase(Char& strA, int lengthA, Char& strB, int lengthB);
    internal static bool EqualsOrdinalIgnoreCase(Char& charA, Char& charB, int length);
    private static bool EqualsOrdinalIgnoreCaseNonAscii(Char& charA, Char& charB, int length);
    public virtual bool IsPrefix(string source, string prefix, CompareOptions options);
    internal bool IsPrefix(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> prefix, CompareOptions options);
    public virtual bool IsPrefix(string source, string prefix);
    public virtual bool IsSuffix(string source, string suffix, CompareOptions options);
    internal bool IsSuffix(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> suffix, CompareOptions options);
    public virtual bool IsSuffix(string source, string suffix);
    public virtual int IndexOf(string source, char value);
    public virtual int IndexOf(string source, string value);
    public virtual int IndexOf(string source, char value, CompareOptions options);
    public virtual int IndexOf(string source, string value, CompareOptions options);
    public virtual int IndexOf(string source, char value, int startIndex);
    public virtual int IndexOf(string source, string value, int startIndex);
    public virtual int IndexOf(string source, char value, int startIndex, CompareOptions options);
    public virtual int IndexOf(string source, string value, int startIndex, CompareOptions options);
    public virtual int IndexOf(string source, char value, int startIndex, int count);
    public virtual int IndexOf(string source, string value, int startIndex, int count);
    public virtual int IndexOf(string source, char value, int startIndex, int count, CompareOptions options);
    public virtual int IndexOf(string source, string value, int startIndex, int count, CompareOptions options);
    internal int IndexOfOrdinalIgnoreCase(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> value);
    internal int LastIndexOfOrdinal(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> value, bool ignoreCase);
    internal int IndexOf(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> value, CompareOptions options);
    internal int LastIndexOf(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> value, CompareOptions options);
    internal int IndexOf(string source, string value, int startIndex, int count, CompareOptions options, Int32* matchLengthPtr);
    internal int IndexOfOrdinal(string source, string value, int startIndex, int count, bool ignoreCase);
    public virtual int LastIndexOf(string source, char value);
    public virtual int LastIndexOf(string source, string value);
    public virtual int LastIndexOf(string source, char value, CompareOptions options);
    public virtual int LastIndexOf(string source, string value, CompareOptions options);
    public virtual int LastIndexOf(string source, char value, int startIndex);
    public virtual int LastIndexOf(string source, string value, int startIndex);
    public virtual int LastIndexOf(string source, char value, int startIndex, CompareOptions options);
    public virtual int LastIndexOf(string source, string value, int startIndex, CompareOptions options);
    public virtual int LastIndexOf(string source, char value, int startIndex, int count);
    public virtual int LastIndexOf(string source, string value, int startIndex, int count);
    public virtual int LastIndexOf(string source, char value, int startIndex, int count, CompareOptions options);
    public virtual int LastIndexOf(string source, string value, int startIndex, int count, CompareOptions options);
    internal int LastIndexOfOrdinal(string source, string value, int startIndex, int count, bool ignoreCase);
    public virtual SortKey GetSortKey(string source, CompareOptions options);
    public virtual SortKey GetSortKey(string source);
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public virtual int GetHashCode();
    internal int GetHashCodeOfString(string source, CompareOptions options);
    public virtual int GetHashCode(string source, CompareOptions options);
    [NullableContextAttribute("0")]
public int GetHashCode(ReadOnlySpan`1<char> source, CompareOptions options);
    public virtual string ToString();
    public SortVersion get_Version();
    public int get_LCID();
    internal static int InvariantIndexOf(string source, string value, int startIndex, int count, bool ignoreCase);
    internal static int InvariantIndexOf(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> value, bool ignoreCase, bool fromBeginning);
    internal static int InvariantLastIndexOf(string source, string value, int startIndex, int count, bool ignoreCase);
    private static int InvariantFindString(Char* source, int sourceCount, Char* value, int valueCount, bool ignoreCase, bool fromBeginning);
    private static char InvariantToUpper(char c);
    private SortKey InvariantCreateSortKey(string source, CompareOptions options);
    internal static IntPtr GetSortHandle(string cultureName);
    private void InitSort(CultureInfo culture);
    private static int FindStringOrdinal(UInt32 dwFindStringOrdinalFlags, string stringSource, int offset, int cchSource, string value, int cchValue, bool bIgnoreCase);
    private static int FindStringOrdinal(UInt32 dwFindStringOrdinalFlags, ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> value, bool bIgnoreCase);
    internal static int IndexOfOrdinalCore(string source, string value, int startIndex, int count, bool ignoreCase);
    internal static int IndexOfOrdinalCore(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> value, bool ignoreCase, bool fromBeginning);
    internal static int LastIndexOfOrdinalCore(string source, string value, int startIndex, int count, bool ignoreCase);
    private int GetHashCodeOfStringCore(ReadOnlySpan`1<char> source, CompareOptions options);
    private static int CompareStringOrdinalIgnoreCase(Char& string1, int count1, Char& string2, int count2);
    private int CompareString(ReadOnlySpan`1<char> string1, string string2, CompareOptions options);
    private int CompareString(ReadOnlySpan`1<char> string1, ReadOnlySpan`1<char> string2, CompareOptions options);
    private int FindString(UInt32 dwFindNLSStringFlags, ReadOnlySpan`1<char> lpStringSource, ReadOnlySpan`1<char> lpStringValue, Int32* pcchFound);
    private int FindString(UInt32 dwFindNLSStringFlags, string lpStringSource, int startSource, int cchSource, string lpStringValue, int startValue, int cchValue, Int32* pcchFound);
    internal int IndexOfCore(string source, string target, int startIndex, int count, CompareOptions options, Int32* matchLengthPtr);
    internal int IndexOfCore(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> target, CompareOptions options, Int32* matchLengthPtr, bool fromBeginning);
    private int LastIndexOfCore(string source, string target, int startIndex, int count, CompareOptions options);
    private bool StartsWith(string source, string prefix, CompareOptions options);
    private bool StartsWith(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> prefix, CompareOptions options);
    private bool EndsWith(string source, string suffix, CompareOptions options);
    private bool EndsWith(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> suffix, CompareOptions options);
    private static int FastLastIndexOfString(string source, string target, int startIndex, int sourceCount, int targetCount);
    private SortKey CreateSortKey(string source, CompareOptions options);
    private static bool IsSortable(Char* text, int length);
    private static int GetNativeCompareFlags(CompareOptions options);
    private SortVersion GetSortVersion();
}
[FlagsAttribute]
public enum System.Globalization.CompareOptions : Enum {
    public int value__;
    public static CompareOptions None;
    public static CompareOptions IgnoreCase;
    public static CompareOptions IgnoreNonSpace;
    public static CompareOptions IgnoreSymbols;
    public static CompareOptions IgnoreKanaType;
    public static CompareOptions IgnoreWidth;
    public static CompareOptions OrdinalIgnoreCase;
    public static CompareOptions StringSort;
    public static CompareOptions Ordinal;
}
internal class System.Globalization.CultureData : object {
    private string _sRealName;
    private string _sWindowsName;
    private string _sName;
    private string _sParent;
    private string _sLocalizedDisplayName;
    private string _sEnglishDisplayName;
    private string _sNativeDisplayName;
    private string _sSpecificCulture;
    private string _sISO639Language;
    private string _sISO639Language2;
    private string _sLocalizedLanguage;
    private string _sEnglishLanguage;
    private string _sNativeLanguage;
    private string _sAbbrevLang;
    private string _sConsoleFallbackName;
    private int _iInputLanguageHandle;
    private string _sRegionName;
    private string _sLocalizedCountry;
    private string _sEnglishCountry;
    private string _sNativeCountry;
    private string _sISO3166CountryName;
    private string _sISO3166CountryName2;
    private int _iGeoId;
    private string _sPositiveSign;
    private string _sNegativeSign;
    private int _iDigits;
    private int _iNegativeNumber;
    private Int32[] _waGrouping;
    private string _sDecimalSeparator;
    private string _sThousandSeparator;
    private string _sNaN;
    private string _sPositiveInfinity;
    private string _sNegativeInfinity;
    private int _iNegativePercent;
    private int _iPositivePercent;
    private string _sPercent;
    private string _sPerMille;
    private string _sCurrency;
    private string _sIntlMonetarySymbol;
    private string _sEnglishCurrency;
    private string _sNativeCurrency;
    private int _iCurrencyDigits;
    private int _iCurrency;
    private int _iNegativeCurrency;
    private Int32[] _waMonetaryGrouping;
    private string _sMonetaryDecimal;
    private string _sMonetaryThousand;
    private int _iMeasure;
    private string _sListSeparator;
    private string _sAM1159;
    private string _sPM2359;
    private string _sTimeSeparator;
    private String[] modreq(System.Runtime.CompilerServices.IsVolatile) _saLongTimes;
    private String[] modreq(System.Runtime.CompilerServices.IsVolatile) _saShortTimes;
    private String[] modreq(System.Runtime.CompilerServices.IsVolatile) _saDurationFormats;
    private int _iFirstDayOfWeek;
    private int _iFirstWeekOfYear;
    private CalendarId[] modreq(System.Runtime.CompilerServices.IsVolatile) _waCalendars;
    private CalendarData[] _calendars;
    private int _iReadingLayout;
    private int _iDefaultAnsiCodePage;
    private int _iDefaultOemCodePage;
    private int _iDefaultMacCodePage;
    private int _iDefaultEbcdicCodePage;
    private int _iLanguage;
    private bool _bUseOverrides;
    private bool _bNeutral;
    private static Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_cachedRegions;
    private static Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_regionNames;
    private static CultureData modreq(System.Runtime.CompilerServices.IsVolatile) s_Invariant;
    private static Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_cachedCultures;
    private static object s_lock;
    private static Dictionary`2<string, string> RegionNames { get; }
    internal static CultureData Invariant { get; }
    internal string CultureName { get; }
    internal bool UseUserOverride { get; }
    internal string Name { get; }
    internal string ParentName { get; }
    internal string DisplayName { get; }
    internal string EnglishName { get; }
    internal string NativeName { get; }
    internal string SpecificCultureName { get; }
    internal string TwoLetterISOLanguageName { get; }
    internal string ThreeLetterISOLanguageName { get; }
    internal string ThreeLetterWindowsLanguageName { get; }
    private string LocalizedLanguageName { get; }
    private string EnglishLanguageName { get; }
    private string NativeLanguageName { get; }
    internal string RegionName { get; }
    internal int GeoId { get; }
    internal string LocalizedCountryName { get; }
    internal string EnglishCountryName { get; }
    internal string NativeCountryName { get; }
    internal string TwoLetterISOCountryName { get; }
    internal string ThreeLetterISOCountryName { get; }
    internal int KeyboardLayoutId { get; }
    internal string SCONSOLEFALLBACKNAME { get; }
    internal Int32[] NumberGroupSizes { get; }
    private string NaNSymbol { get; }
    private string PositiveInfinitySymbol { get; }
    private string NegativeInfinitySymbol { get; }
    private int PercentNegativePattern { get; }
    private int PercentPositivePattern { get; }
    private string PercentSymbol { get; }
    private string PerMilleSymbol { get; }
    internal string CurrencySymbol { get; }
    internal string ISOCurrencySymbol { get; }
    internal string CurrencyEnglishName { get; }
    internal string CurrencyNativeName { get; }
    internal Int32[] CurrencyGroupSizes { get; }
    internal int MeasurementSystem { get; }
    internal string ListSeparator { get; }
    internal string AMDesignator { get; }
    internal string PMDesignator { get; }
    internal String[] LongTimes { get; }
    internal String[] ShortTimes { get; }
    internal int FirstDayOfWeek { get; }
    internal int CalendarWeekRule { get; }
    internal CalendarId[] CalendarIds { get; }
    internal bool IsRightToLeft { get; }
    private int ReadingLayout { get; }
    internal string TextInfoName { get; }
    internal string SortName { get; }
    internal bool IsSupplementalCustomCulture { get; }
    internal int ANSICodePage { get; }
    internal int OEMCodePage { get; }
    internal int MacCodePage { get; }
    internal int EBCDICCodePage { get; }
    internal int LCID { get; }
    internal bool IsNeutralCulture { get; }
    internal bool IsInvariantCulture { get; }
    internal Calendar DefaultCalendar { get; }
    internal string TimeSeparator { get; }
    internal bool IsFramework { get; }
    internal bool IsWin32Installed { get; }
    internal bool IsReplacementCulture { get; }
    private static CultureData();
    private static Dictionary`2<string, string> get_RegionNames();
    internal static CultureData GetCultureDataForRegion(string cultureName, bool useUserOverride);
    internal static void ClearCachedData();
    internal static CultureInfo[] GetCultures(CultureTypes types);
    private static CultureData CreateCultureWithInvariantData();
    internal static CultureData get_Invariant();
    internal static CultureData GetCultureData(string cultureName, bool useUserOverride);
    private static string NormalizeCultureName(string name, Boolean& isNeutralName);
    private static CultureData CreateCultureData(string cultureName, bool useUserOverride);
    private bool InitCompatibilityCultureData();
    internal static CultureData GetCultureData(int culture, bool bUseUserOverride);
    internal string get_CultureName();
    internal bool get_UseUserOverride();
    internal string get_Name();
    internal string get_ParentName();
    internal string get_DisplayName();
    internal string get_EnglishName();
    internal string get_NativeName();
    internal string get_SpecificCultureName();
    internal string get_TwoLetterISOLanguageName();
    internal string get_ThreeLetterISOLanguageName();
    internal string get_ThreeLetterWindowsLanguageName();
    private string get_LocalizedLanguageName();
    private string get_EnglishLanguageName();
    private string get_NativeLanguageName();
    internal string get_RegionName();
    internal int get_GeoId();
    internal string get_LocalizedCountryName();
    internal string get_EnglishCountryName();
    internal string get_NativeCountryName();
    internal string get_TwoLetterISOCountryName();
    internal string get_ThreeLetterISOCountryName();
    internal int get_KeyboardLayoutId();
    internal string get_SCONSOLEFALLBACKNAME();
    internal Int32[] get_NumberGroupSizes();
    private string get_NaNSymbol();
    private string get_PositiveInfinitySymbol();
    private string get_NegativeInfinitySymbol();
    private int get_PercentNegativePattern();
    private int get_PercentPositivePattern();
    private string get_PercentSymbol();
    private string get_PerMilleSymbol();
    internal string get_CurrencySymbol();
    internal string get_ISOCurrencySymbol();
    internal string get_CurrencyEnglishName();
    internal string get_CurrencyNativeName();
    internal Int32[] get_CurrencyGroupSizes();
    internal int get_MeasurementSystem();
    internal string get_ListSeparator();
    internal string get_AMDesignator();
    internal string get_PMDesignator();
    internal String[] get_LongTimes();
    internal String[] get_ShortTimes();
    private String[] AdjustShortTimesForMac(String[] shortTimes);
    private String[] DeriveShortTimesFromLong();
    private static string StripSecondsFromPattern(string time);
    private static int GetIndexOfNextTokenAfterSeconds(string time, int index, Boolean& containsSpace);
    internal int get_FirstDayOfWeek();
    internal int get_CalendarWeekRule();
    internal String[] ShortDates(CalendarId calendarId);
    internal String[] LongDates(CalendarId calendarId);
    internal String[] YearMonths(CalendarId calendarId);
    internal String[] DayNames(CalendarId calendarId);
    internal String[] AbbreviatedDayNames(CalendarId calendarId);
    internal String[] SuperShortDayNames(CalendarId calendarId);
    internal String[] MonthNames(CalendarId calendarId);
    internal String[] GenitiveMonthNames(CalendarId calendarId);
    internal String[] AbbreviatedMonthNames(CalendarId calendarId);
    internal String[] AbbreviatedGenitiveMonthNames(CalendarId calendarId);
    internal String[] LeapYearMonthNames(CalendarId calendarId);
    internal string MonthDay(CalendarId calendarId);
    internal CalendarId[] get_CalendarIds();
    internal string CalendarName(CalendarId calendarId);
    internal CalendarData GetCalendar(CalendarId calendarId);
    internal bool get_IsRightToLeft();
    private int get_ReadingLayout();
    internal string get_TextInfoName();
    internal string get_SortName();
    internal bool get_IsSupplementalCustomCulture();
    internal int get_ANSICodePage();
    internal int get_OEMCodePage();
    internal int get_MacCodePage();
    internal int get_EBCDICCodePage();
    internal int get_LCID();
    internal bool get_IsNeutralCulture();
    internal bool get_IsInvariantCulture();
    internal Calendar get_DefaultCalendar();
    internal String[] EraNames(CalendarId calendarId);
    internal String[] AbbrevEraNames(CalendarId calendarId);
    internal String[] AbbreviatedEnglishEraNames(CalendarId calendarId);
    internal string get_TimeSeparator();
    internal string DateSeparator(CalendarId calendarId);
    private static string UnescapeNlsString(string str, int start, int end);
    private static string GetTimeSeparator(string format);
    private static string GetDateSeparator(string format);
    private static string GetSeparator(string format, string timeParts);
    private static int IndexOfTimePart(string format, int startIndex, string timeParts);
    internal static bool IsCustomCultureId(int cultureId);
    internal void GetNFIValues(NumberFormatInfo nfi);
    internal static string AnsiToLower(string testString);
    private bool InitCultureData();
    internal static string GetLocaleInfoEx(string localeName, UInt32 field);
    internal static int GetLocaleInfoExInt(string localeName, UInt32 field);
    internal static int GetLocaleInfoEx(string lpLocaleName, UInt32 lcType, Char* lpLCData, int cchData);
    private string GetLocaleInfo(LocaleStringData type);
    private string GetLocaleInfo(string localeName, LocaleStringData type);
    private int GetLocaleInfo(LocaleNumberData type);
    private Int32[] GetLocaleInfo(LocaleGroupingData type);
    private string GetTimeFormatString();
    private int GetFirstDayOfWeek();
    private String[] GetTimeFormats();
    private String[] GetShortTimeFormats();
    private static CultureData GetCultureDataFromRegionName(string regionName);
    private string GetLanguageDisplayName(string cultureName);
    private string GetRegionDisplayName(string isoCountryCode);
    private static CultureInfo GetUserDefaultCulture();
    private static string GetLocaleInfoFromLCType(string localeName, UInt32 lctype, bool useUserOveride);
    internal static string ReescapeWin32String(string str);
    internal static String[] ReescapeWin32Strings(String[] array);
    private static Int32[] ConvertWin32GroupString(string win32Str);
    private static int ConvertFirstDayOfWeekMonToSun(int iTemp);
    private static BOOL EnumSystemLocalesProc(Char* lpLocaleString, UInt32 flags, Void* contextHandle);
    private static BOOL EnumAllSystemLocalesProc(Char* lpLocaleString, UInt32 flags, Void* contextHandle);
    private static BOOL EnumTimeCallback(Char* lpTimeFormatString, Void* lParam);
    private static String[] nativeEnumTimeFormats(string localeName, UInt32 dwFlags, bool useUserOverride);
    private static int LocaleNameToLCID(string cultureName);
    private static string LCIDToLocaleName(int culture);
    private int GetAnsiCodePage(string cultureName);
    private int GetOemCodePage(string cultureName);
    private int GetMacCodePage(string cultureName);
    private int GetEbcdicCodePage(string cultureName);
    private int GetGeoId(string cultureName);
    private int GetDigitSubstitution(string cultureName);
    private string GetThreeLetterWindowsLanguageName(string cultureName);
    private static CultureInfo[] EnumCultures(CultureTypes types);
    private string GetConsoleFallbackName(string cultureName);
    internal bool get_IsFramework();
    internal bool get_IsWin32Installed();
    internal bool get_IsReplacementCulture();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Globalization.CultureInfo : object {
    private bool _isReadOnly;
    private CompareInfo _compareInfo;
    private TextInfo _textInfo;
    internal NumberFormatInfo _numInfo;
    internal DateTimeFormatInfo _dateTimeInfo;
    private Calendar _calendar;
    internal CultureData _cultureData;
    internal bool _isInherited;
    private CultureInfo _consoleFallbackCulture;
    internal string _name;
    private string _nonSortName;
    private string _sortName;
    private static CultureInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_userDefaultCulture;
    private static CultureInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_userDefaultUICulture;
    private static CultureInfo s_InvariantCultureInfo;
    private static CultureInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_DefaultThreadCurrentUICulture;
    private static CultureInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_DefaultThreadCurrentCulture;
    [ThreadStaticAttribute]
private static CultureInfo s_currentThreadCulture;
    [ThreadStaticAttribute]
private static CultureInfo s_currentThreadUICulture;
    private static AsyncLocal`1<CultureInfo> s_asyncLocalCurrentCulture;
    private static AsyncLocal`1<CultureInfo> s_asyncLocalCurrentUICulture;
    private static object _lock;
    private static Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_NameCachedCultures;
    private static Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_LcidCachedCultures;
    private CultureInfo _parent;
    internal static int LOCALE_NEUTRAL;
    private static int LOCALE_USER_DEFAULT;
    private static int LOCALE_SYSTEM_DEFAULT;
    internal static int LOCALE_CUSTOM_UNSPECIFIED;
    internal static int LOCALE_CUSTOM_DEFAULT;
    internal static int LOCALE_INVARIANT;
    private static WindowsRuntimeResourceManagerBase modreq(System.Runtime.CompilerServices.IsVolatile) s_WindowsRuntimeResourceManager;
    [ThreadStaticAttribute]
private static bool ts_IsDoingAppXCultureInfoLookup;
    public static CultureInfo CurrentCulture { get; public set; }
    public static CultureInfo CurrentUICulture { get; public set; }
    internal static CultureInfo UserDefaultUICulture { get; }
    public static CultureInfo InstalledUICulture { get; }
    [NullableAttribute("2")]
public static CultureInfo DefaultThreadCurrentCulture { get; public set; }
    [NullableAttribute("2")]
public static CultureInfo DefaultThreadCurrentUICulture { get; public set; }
    public static CultureInfo InvariantCulture { get; }
    public CultureInfo Parent { get; }
    public int LCID { get; }
    public int KeyboardLayoutId { get; }
    public string Name { get; }
    internal string SortName { get; }
    public string IetfLanguageTag { get; }
    public string DisplayName { get; }
    public string NativeName { get; }
    public string EnglishName { get; }
    public string TwoLetterISOLanguageName { get; }
    public string ThreeLetterISOLanguageName { get; }
    public string ThreeLetterWindowsLanguageName { get; }
    public CompareInfo CompareInfo { get; }
    public TextInfo TextInfo { get; }
    public bool IsNeutralCulture { get; }
    public CultureTypes CultureTypes { get; }
    public NumberFormatInfo NumberFormat { get; public set; }
    public DateTimeFormatInfo DateTimeFormat { get; public set; }
    public Calendar Calendar { get; }
    public Calendar[] OptionalCalendars { get; }
    public bool UseUserOverride { get; }
    public bool IsReadOnly { get; }
    internal bool HasInvariantCultureName { get; }
    public CultureInfo(string name);
    public CultureInfo(string name, bool useUserOverride);
    private CultureInfo(CultureData cultureData, bool isReadOnly);
    public CultureInfo(int culture);
    public CultureInfo(int culture, bool useUserOverride);
    internal CultureInfo(string cultureName, string textAndCompareCultureName);
    private static CultureInfo();
    private static void AsyncLocalSetCurrentCulture(AsyncLocalValueChangedArgs`1<CultureInfo> args);
    private static void AsyncLocalSetCurrentUICulture(AsyncLocalValueChangedArgs`1<CultureInfo> args);
    private static CultureInfo InitializeUserDefaultCulture();
    private static CultureInfo InitializeUserDefaultUICulture();
    private static CultureInfo CreateCultureInfoNoThrow(string name, bool useUserOverride);
    private static CultureInfo GetCultureByName(string name);
    public static CultureInfo CreateSpecificCulture(string name);
    internal static bool VerifyCultureName(string cultureName, bool throwException);
    internal static bool VerifyCultureName(CultureInfo culture, bool throwException);
    public static CultureInfo get_CurrentCulture();
    public static void set_CurrentCulture(CultureInfo value);
    public static CultureInfo get_CurrentUICulture();
    public static void set_CurrentUICulture(CultureInfo value);
    internal static CultureInfo get_UserDefaultUICulture();
    public static CultureInfo get_InstalledUICulture();
    [NullableContextAttribute("2")]
public static CultureInfo get_DefaultThreadCurrentCulture();
    [NullableContextAttribute("2")]
public static void set_DefaultThreadCurrentCulture(CultureInfo value);
    [NullableContextAttribute("2")]
public static CultureInfo get_DefaultThreadCurrentUICulture();
    [NullableContextAttribute("2")]
public static void set_DefaultThreadCurrentUICulture(CultureInfo value);
    public static CultureInfo get_InvariantCulture();
    public virtual CultureInfo get_Parent();
    public virtual int get_LCID();
    public virtual int get_KeyboardLayoutId();
    public static CultureInfo[] GetCultures(CultureTypes types);
    public virtual string get_Name();
    internal string get_SortName();
    public string get_IetfLanguageTag();
    public virtual string get_DisplayName();
    public virtual string get_NativeName();
    public virtual string get_EnglishName();
    public virtual string get_TwoLetterISOLanguageName();
    public virtual string get_ThreeLetterISOLanguageName();
    public virtual string get_ThreeLetterWindowsLanguageName();
    public virtual CompareInfo get_CompareInfo();
    public virtual TextInfo get_TextInfo();
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual object GetFormat(Type formatType);
    public virtual bool get_IsNeutralCulture();
    public CultureTypes get_CultureTypes();
    public virtual NumberFormatInfo get_NumberFormat();
    public virtual void set_NumberFormat(NumberFormatInfo value);
    public virtual DateTimeFormatInfo get_DateTimeFormat();
    public virtual void set_DateTimeFormat(DateTimeFormatInfo value);
    public void ClearCachedData();
    internal static Calendar GetCalendarInstance(CalendarId calType);
    internal static Calendar GetCalendarInstanceRare(CalendarId calType);
    public virtual Calendar get_Calendar();
    public virtual Calendar[] get_OptionalCalendars();
    public bool get_UseUserOverride();
    public CultureInfo GetConsoleFallbackUICulture();
    public virtual object Clone();
    public static CultureInfo ReadOnly(CultureInfo ci);
    public bool get_IsReadOnly();
    private void VerifyWritable();
    internal bool get_HasInvariantCultureName();
    internal static CultureInfo GetCultureInfoHelper(int lcid, string name, string altName);
    public static CultureInfo GetCultureInfo(int culture);
    public static CultureInfo GetCultureInfo(string name);
    public static CultureInfo GetCultureInfo(string name, string altName);
    public static CultureInfo GetCultureInfoByIetfLanguageTag(string name);
    internal static CultureInfo GetUserDefaultCulture();
    private static CultureInfo GetUserDefaultUICulture();
    internal static CultureInfo GetCultureInfoForUserPreferredLanguageInAppX();
    internal static bool SetCultureInfoForUserPreferredLanguageInAppX(CultureInfo ci);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Globalization.CultureNotFoundException : ArgumentException {
    private string _invalidCultureName;
    private Nullable`1<int> _invalidCultureId;
    public Nullable`1<int> InvalidCultureId { get; }
    public string InvalidCultureName { get; }
    [NullableAttribute("1")]
private static string DefaultMessage { get; }
    private string FormattedInvalidCultureId { get; }
    [NullableAttribute("1")]
public string Message { get; }
    public CultureNotFoundException(string message);
    public CultureNotFoundException(string paramName, string message);
    public CultureNotFoundException(string message, Exception innerException);
    public CultureNotFoundException(string paramName, string invalidCultureName, string message);
    public CultureNotFoundException(string message, string invalidCultureName, Exception innerException);
    public CultureNotFoundException(string message, int invalidCultureId, Exception innerException);
    public CultureNotFoundException(string paramName, int invalidCultureId, string message);
    [NullableContextAttribute("1")]
protected CultureNotFoundException(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual Nullable`1<int> get_InvalidCultureId();
    public virtual string get_InvalidCultureName();
    private static string get_DefaultMessage();
    private string get_FormattedInvalidCultureId();
    [NullableContextAttribute("1")]
public virtual string get_Message();
}
[FlagsAttribute]
public enum System.Globalization.CultureTypes : Enum {
    public int value__;
    public static CultureTypes NeutralCultures;
    public static CultureTypes SpecificCultures;
    public static CultureTypes InstalledWin32Cultures;
    public static CultureTypes AllCultures;
    public static CultureTypes UserCustomCulture;
    public static CultureTypes ReplacementCultures;
    [ObsoleteAttribute("This value has been deprecated.  Please use other values in CultureTypes.")]
public static CultureTypes WindowsOnlyCultures;
    [ObsoleteAttribute("This value has been deprecated.  Please use other values in CultureTypes.")]
public static CultureTypes FrameworkCultures;
}
[FlagsAttribute]
internal enum System.Globalization.DateTimeFormatFlags : Enum {
    public int value__;
    public static DateTimeFormatFlags None;
    public static DateTimeFormatFlags UseGenitiveMonth;
    public static DateTimeFormatFlags UseLeapYearMonth;
    public static DateTimeFormatFlags UseSpacesInMonthNames;
    public static DateTimeFormatFlags UseHebrewRule;
    public static DateTimeFormatFlags UseSpacesInDayNames;
    public static DateTimeFormatFlags UseDigitPrefixInTokens;
    public static DateTimeFormatFlags NotInitialized;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Globalization.DateTimeFormatInfo : object {
    private static DateTimeFormatInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_invariantInfo;
    private CultureData _cultureData;
    private string _name;
    private string _langName;
    private CompareInfo _compareInfo;
    private CultureInfo _cultureInfo;
    private string amDesignator;
    private string pmDesignator;
    private string dateSeparator;
    private string generalShortTimePattern;
    private string generalLongTimePattern;
    private string timeSeparator;
    private string monthDayPattern;
    private string dateTimeOffsetPattern;
    private Calendar calendar;
    private int firstDayOfWeek;
    private int calendarWeekRule;
    private string fullDateTimePattern;
    private String[] abbreviatedDayNames;
    private String[] m_superShortDayNames;
    private String[] dayNames;
    private String[] abbreviatedMonthNames;
    private String[] monthNames;
    private String[] genitiveMonthNames;
    private String[] m_genitiveAbbreviatedMonthNames;
    private String[] leapYearMonthNames;
    private string longDatePattern;
    private string shortDatePattern;
    private string yearMonthPattern;
    private string longTimePattern;
    private string shortTimePattern;
    private String[] allYearMonthPatterns;
    private String[] allShortDatePatterns;
    private String[] allLongDatePatterns;
    private String[] allShortTimePatterns;
    private String[] allLongTimePatterns;
    private String[] m_eraNames;
    private String[] m_abbrevEraNames;
    private String[] m_abbrevEnglishEraNames;
    private CalendarId[] optionalCalendars;
    internal bool _isReadOnly;
    private DateTimeFormatFlags formatFlags;
    private static Char[] s_monthSpaces;
    private string _decimalSeparator;
    private string _fullTimeSpanPositivePattern;
    private string _fullTimeSpanNegativePattern;
    private TokenHashValue[] _dtfiTokenHash;
    private static DateTimeFormatInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_jajpDTFI;
    private static DateTimeFormatInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_zhtwDTFI;
    private string CultureName { get; }
    private CultureInfo Culture { get; }
    private string LanguageName { get; }
    public static DateTimeFormatInfo InvariantInfo { get; }
    public static DateTimeFormatInfo CurrentInfo { get; }
    public string AMDesignator { get; public set; }
    public Calendar Calendar { get; public set; }
    private CalendarId[] OptionalCalendars { get; }
    internal String[] EraNames { get; }
    internal String[] AbbreviatedEraNames { get; }
    internal String[] AbbreviatedEnglishEraNames { get; }
    public string DateSeparator { get; public set; }
    public DayOfWeek FirstDayOfWeek { get; public set; }
    public CalendarWeekRule CalendarWeekRule { get; public set; }
    public string FullDateTimePattern { get; public set; }
    public string LongDatePattern { get; public set; }
    public string LongTimePattern { get; public set; }
    public string MonthDayPattern { get; public set; }
    public string PMDesignator { get; public set; }
    public string RFC1123Pattern { get; }
    public string ShortDatePattern { get; public set; }
    public string ShortTimePattern { get; public set; }
    public string SortableDateTimePattern { get; }
    internal string GeneralShortTimePattern { get; }
    internal string GeneralLongTimePattern { get; }
    internal string DateTimeOffsetPattern { get; }
    public string TimeSeparator { get; public set; }
    public string UniversalSortableDateTimePattern { get; }
    public string YearMonthPattern { get; public set; }
    public String[] AbbreviatedDayNames { get; public set; }
    public String[] ShortestDayNames { get; public set; }
    public String[] DayNames { get; public set; }
    public String[] AbbreviatedMonthNames { get; public set; }
    public String[] MonthNames { get; public set; }
    internal bool HasSpacesInMonthNames { get; }
    internal bool HasSpacesInDayNames { get; }
    private String[] AllYearMonthPatterns { get; }
    private String[] AllShortDatePatterns { get; }
    private String[] AllShortTimePatterns { get; }
    private String[] AllLongDatePatterns { get; }
    private String[] AllLongTimePatterns { get; }
    private String[] UnclonedYearMonthPatterns { get; }
    private String[] UnclonedShortDatePatterns { get; }
    private String[] UnclonedLongDatePatterns { get; }
    private String[] UnclonedShortTimePatterns { get; }
    private String[] UnclonedLongTimePatterns { get; }
    public bool IsReadOnly { get; }
    public string NativeCalendarName { get; }
    public String[] AbbreviatedMonthGenitiveNames { get; public set; }
    public String[] MonthGenitiveNames { get; public set; }
    internal string DecimalSeparator { get; }
    internal string FullTimeSpanPositivePattern { get; }
    internal string FullTimeSpanNegativePattern { get; }
    internal CompareInfo CompareInfo { get; }
    internal DateTimeFormatFlags FormatFlags { get; }
    internal bool HasForceTwoDigitYears { get; }
    internal bool HasYearMonthAdjustment { get; }
    internal DateTimeFormatInfo(CultureData cultureData, Calendar cal);
    private static DateTimeFormatInfo();
    private string get_CultureName();
    private CultureInfo get_Culture();
    private string get_LanguageName();
    private String[] InternalGetAbbreviatedDayOfWeekNames();
    private String[] InternalGetAbbreviatedDayOfWeekNamesCore();
    private String[] InternalGetSuperShortDayNames();
    private String[] InternalGetSuperShortDayNamesCore();
    private String[] InternalGetDayOfWeekNames();
    private String[] InternalGetDayOfWeekNamesCore();
    private String[] InternalGetAbbreviatedMonthNames();
    private String[] InternalGetAbbreviatedMonthNamesCore();
    private String[] InternalGetMonthNames();
    private String[] internalGetMonthNamesCore();
    private void InitializeOverridableProperties(CultureData cultureData, CalendarId calendarId);
    public static DateTimeFormatInfo get_InvariantInfo();
    public static DateTimeFormatInfo get_CurrentInfo();
    public static DateTimeFormatInfo GetInstance(IFormatProvider provider);
    [NullableContextAttribute("2")]
public sealed virtual object GetFormat(Type formatType);
    public sealed virtual object Clone();
    public string get_AMDesignator();
    public void set_AMDesignator(string value);
    public Calendar get_Calendar();
    public void set_Calendar(Calendar value);
    private CalendarId[] get_OptionalCalendars();
    public int GetEra(string eraName);
    internal String[] get_EraNames();
    public string GetEraName(int era);
    internal String[] get_AbbreviatedEraNames();
    public string GetAbbreviatedEraName(int era);
    internal String[] get_AbbreviatedEnglishEraNames();
    public string get_DateSeparator();
    public void set_DateSeparator(string value);
    public DayOfWeek get_FirstDayOfWeek();
    public void set_FirstDayOfWeek(DayOfWeek value);
    public CalendarWeekRule get_CalendarWeekRule();
    public void set_CalendarWeekRule(CalendarWeekRule value);
    public string get_FullDateTimePattern();
    public void set_FullDateTimePattern(string value);
    public string get_LongDatePattern();
    public void set_LongDatePattern(string value);
    public string get_LongTimePattern();
    public void set_LongTimePattern(string value);
    public string get_MonthDayPattern();
    public void set_MonthDayPattern(string value);
    public string get_PMDesignator();
    public void set_PMDesignator(string value);
    public string get_RFC1123Pattern();
    public string get_ShortDatePattern();
    public void set_ShortDatePattern(string value);
    public string get_ShortTimePattern();
    public void set_ShortTimePattern(string value);
    public string get_SortableDateTimePattern();
    internal string get_GeneralShortTimePattern();
    internal string get_GeneralLongTimePattern();
    internal string get_DateTimeOffsetPattern();
    public string get_TimeSeparator();
    public void set_TimeSeparator(string value);
    public string get_UniversalSortableDateTimePattern();
    public string get_YearMonthPattern();
    public void set_YearMonthPattern(string value);
    private static void CheckNullValue(String[] values, int length);
    public String[] get_AbbreviatedDayNames();
    public void set_AbbreviatedDayNames(String[] value);
    public String[] get_ShortestDayNames();
    public void set_ShortestDayNames(String[] value);
    public String[] get_DayNames();
    public void set_DayNames(String[] value);
    public String[] get_AbbreviatedMonthNames();
    public void set_AbbreviatedMonthNames(String[] value);
    public String[] get_MonthNames();
    public void set_MonthNames(String[] value);
    internal bool get_HasSpacesInMonthNames();
    internal bool get_HasSpacesInDayNames();
    internal string InternalGetMonthName(int month, MonthNameStyles style, bool abbreviated);
    private String[] InternalGetGenitiveMonthNames(bool abbreviated);
    internal String[] InternalGetLeapYearMonthNames();
    public string GetAbbreviatedDayName(DayOfWeek dayofweek);
    public string GetShortestDayName(DayOfWeek dayOfWeek);
    private static String[] GetCombinedPatterns(String[] patterns1, String[] patterns2, string connectString);
    public String[] GetAllDateTimePatterns();
    public String[] GetAllDateTimePatterns(char format);
    public string GetDayName(DayOfWeek dayofweek);
    public string GetAbbreviatedMonthName(int month);
    public string GetMonthName(int month);
    private static String[] GetMergedPatterns(String[] patterns, string defaultPattern);
    private String[] get_AllYearMonthPatterns();
    private String[] get_AllShortDatePatterns();
    private String[] get_AllShortTimePatterns();
    private String[] get_AllLongDatePatterns();
    private String[] get_AllLongTimePatterns();
    private String[] get_UnclonedYearMonthPatterns();
    private String[] get_UnclonedShortDatePatterns();
    private String[] get_UnclonedLongDatePatterns();
    private String[] get_UnclonedShortTimePatterns();
    private String[] get_UnclonedLongTimePatterns();
    public static DateTimeFormatInfo ReadOnly(DateTimeFormatInfo dtfi);
    public bool get_IsReadOnly();
    public string get_NativeCalendarName();
    public void SetAllDateTimePatterns(String[] patterns, char format);
    public String[] get_AbbreviatedMonthGenitiveNames();
    public void set_AbbreviatedMonthGenitiveNames(String[] value);
    public String[] get_MonthGenitiveNames();
    public void set_MonthGenitiveNames(String[] value);
    internal string get_DecimalSeparator();
    internal string get_FullTimeSpanPositivePattern();
    internal string get_FullTimeSpanNegativePattern();
    internal CompareInfo get_CompareInfo();
    internal static void ValidateStyles(DateTimeStyles style, string parameterName);
    internal DateTimeFormatFlags get_FormatFlags();
    private DateTimeFormatFlags InitializeFormatFlags();
    internal bool get_HasForceTwoDigitYears();
    internal bool get_HasYearMonthAdjustment();
    internal bool YearMonthAdjustment(Int32& year, Int32& month, bool parsedMonthName);
    internal static DateTimeFormatInfo GetJapaneseCalendarDTFI();
    internal static DateTimeFormatInfo GetTaiwanCalendarDTFI();
    private void ClearTokenHashTable();
    internal TokenHashValue[] CreateTokenHashTable();
    private void AddMonthNames(TokenHashValue[] temp, ReadOnlySpan`1<char> monthPostfix);
    private static bool TryParseHebrewNumber(__DTString& str, Boolean& badFormat, Int32& number);
    private static bool IsHebrewChar(char ch);
    private bool IsAllowedJapaneseTokenFollowedByNonSpaceLetter(string tokenString, char nextCh);
    internal bool Tokenize(TokenType TokenMask, TokenType& tokenType, Int32& tokenValue, __DTString& str);
    private void InsertAtCurrentHashNode(TokenHashValue[] hashTable, string str, char ch, TokenType tokenType, int tokenValue, int pos, int hashcode, int hashProbe);
    private void InsertHash(TokenHashValue[] hashTable, string str, TokenType tokenType, int tokenValue);
    private bool CompareStringIgnoreCaseOptimized(string string1, int offset1, int length1, string string2, int offset2, int length2);
}
internal class System.Globalization.DateTimeFormatInfoScanner : object {
    internal List`1<string> m_dateWords;
    private static Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_knownWords;
    private FoundDatePattern _ymdFlags;
    private static Dictionary`2<string, string> KnownWords { get; }
    private static Dictionary`2<string, string> get_KnownWords();
    internal static int SkipWhiteSpacesAndNonLetter(string pattern, int currentIndex);
    internal void AddDateWordOrPostfix(string formatPostfix, string str);
    internal int AddDateWords(string pattern, int index, string formatPostfix);
    internal static int ScanRepeatChar(string pattern, char ch, int index, Int32& count);
    internal void AddIgnorableSymbols(string text);
    internal void ScanDateWord(string pattern);
    internal String[] GetDateWordsOfDTFI(DateTimeFormatInfo dtfi);
    internal static FORMATFLAGS GetFormatFlagGenitiveMonth(String[] monthNames, String[] genitveMonthNames, String[] abbrevMonthNames, String[] genetiveAbbrevMonthNames);
    internal static FORMATFLAGS GetFormatFlagUseSpaceInMonthNames(String[] monthNames, String[] genitveMonthNames, String[] abbrevMonthNames, String[] genetiveAbbrevMonthNames);
    internal static FORMATFLAGS GetFormatFlagUseSpaceInDayNames(String[] dayNames, String[] abbrevDayNames);
    internal static FORMATFLAGS GetFormatFlagUseHebrewCalendar(int calID);
    private static bool EqualStringArrays(String[] array1, String[] array2);
    private static bool ArrayElementsHaveSpace(String[] array);
    private static bool ArrayElementsBeginWithDigit(String[] array);
}
[FlagsAttribute]
public enum System.Globalization.DateTimeStyles : Enum {
    public int value__;
    public static DateTimeStyles None;
    public static DateTimeStyles AllowLeadingWhite;
    public static DateTimeStyles AllowTrailingWhite;
    public static DateTimeStyles AllowInnerWhite;
    public static DateTimeStyles AllowWhiteSpaces;
    public static DateTimeStyles NoCurrentDateDefault;
    public static DateTimeStyles AdjustToUniversal;
    public static DateTimeStyles AssumeLocal;
    public static DateTimeStyles AssumeUniversal;
    public static DateTimeStyles RoundtripKind;
}
public class System.Globalization.DaylightTime : object {
    private DateTime _start;
    private DateTime _end;
    private TimeSpan _delta;
    public DateTime Start { get; }
    public DateTime End { get; }
    public TimeSpan Delta { get; }
    public DaylightTime(DateTime start, DateTime end, TimeSpan delta);
    public DateTime get_Start();
    public DateTime get_End();
    public TimeSpan get_Delta();
}
[IsReadOnlyAttribute]
internal class System.Globalization.DaylightTimeStruct : ValueType {
    public DateTime Start;
    public DateTime End;
    public TimeSpan Delta;
    public DaylightTimeStruct(DateTime start, DateTime end, TimeSpan delta);
}
public enum System.Globalization.DigitShapes : Enum {
    public int value__;
    public static DigitShapes Context;
    public static DigitShapes None;
    public static DigitShapes NativeNational;
}
public abstract class System.Globalization.EastAsianLunisolarCalendar : Calendar {
    private static Int32[] s_daysToMonth365;
    private static Int32[] s_daysToMonth366;
    public CalendarAlgorithmType AlgorithmType { get; }
    internal int MinCalendarYear { get; }
    internal int MaxCalendarYear { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal EraInfo[] CalEraInfo { get; }
    internal DateTime MinDate { get; }
    internal DateTime MaxDate { get; }
    public int TwoDigitYearMax { get; public set; }
    private static EastAsianLunisolarCalendar();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    public virtual int GetSexagenaryYear(DateTime time);
    public int GetCelestialStem(int sexagenaryYear);
    public int GetTerrestrialBranch(int sexagenaryYear);
    internal abstract virtual int GetYearInfo(int LunarYear, int Index);
    internal abstract virtual int GetYear(int year, DateTime time);
    internal abstract virtual int GetGregorianYear(int year, int era);
    internal abstract virtual int get_MinCalendarYear();
    internal abstract virtual int get_MaxCalendarYear();
    internal abstract virtual EraInfo[] get_CalEraInfo();
    internal abstract virtual DateTime get_MinDate();
    internal abstract virtual DateTime get_MaxDate();
    internal int MinEraCalendarYear(int era);
    internal int MaxEraCalendarYear(int era);
    internal void CheckTicksRange(long ticks);
    internal void CheckEraRange(int era);
    internal int CheckYearRange(int year, int era);
    internal int CheckYearMonthRange(int year, int month, int era);
    internal int InternalGetDaysInMonth(int year, int month);
    public virtual int GetDaysInMonth(int year, int month, int era);
    private static bool GregorianIsLeapYear(int y);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    private void GregorianToLunar(int solarYear, int solarMonth, int solarDate, Int32& lunarYear, Int32& lunarMonth, Int32& lunarDate);
    private bool LunarToGregorian(int lunarYear, int lunarMonth, int lunarDate, Int32& solarYear, Int32& solarMonth, Int32& solarDay);
    private DateTime LunarToTime(DateTime time, int year, int month, int day);
    private void TimeToLunar(DateTime time, Int32& year, Int32& month, Int32& day);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetMonth(DateTime time);
    public virtual int GetYear(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual int GetLeapMonth(int year, int era);
    internal bool InternalIsLeapYear(int year);
    public virtual bool IsLeapYear(int year, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
internal class System.Globalization.EraInfo : object {
    internal int era;
    internal long ticks;
    internal int yearOffset;
    internal int minEraYear;
    internal int maxEraYear;
    internal string eraName;
    internal string abbrevEraName;
    internal string englishEraName;
    internal EraInfo(int era, int startYear, int startMonth, int startDay, int yearOffset, int minEraYear, int maxEraYear);
    internal EraInfo(int era, int startYear, int startMonth, int startDay, int yearOffset, int minEraYear, int maxEraYear, string eraName, string abbrevEraName, string englishEraName);
}
internal enum System.Globalization.FORMATFLAGS : Enum {
    public int value__;
    public static FORMATFLAGS None;
    public static FORMATFLAGS UseGenitiveMonth;
    public static FORMATFLAGS UseLeapYearMonth;
    public static FORMATFLAGS UseSpacesInMonthNames;
    public static FORMATFLAGS UseHebrewParsing;
    public static FORMATFLAGS UseSpacesInDayNames;
    public static FORMATFLAGS UseDigitPrefixInTokens;
}
[ExtensionAttribute]
public static class System.Globalization.GlobalizationExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static StringComparer GetStringComparer(CompareInfo compareInfo, CompareOptions options);
}
internal class System.Globalization.GlobalizationMode : object {
    [CompilerGeneratedAttribute]
private static bool <Invariant>k__BackingField;
    internal static bool Invariant { get; }
    private static GlobalizationMode();
    [CompilerGeneratedAttribute]
internal static bool get_Invariant();
    internal static bool GetInvariantSwitchValue();
    private static bool GetGlobalizationInvariantMode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Globalization.GregorianCalendar : Calendar {
    public static int ADEra;
    private GregorianCalendarTypes _type;
    private static Int32[] DaysToMonth365;
    private static Int32[] DaysToMonth366;
    private static Calendar modreq(System.Runtime.CompilerServices.IsVolatile) s_defaultInstance;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    public GregorianCalendarTypes CalendarType { get; public set; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    public GregorianCalendar(GregorianCalendarTypes type);
    private static GregorianCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal static Calendar GetDefaultInstance();
    public virtual GregorianCalendarTypes get_CalendarType();
    public virtual void set_CalendarType(GregorianCalendarTypes value);
    internal virtual CalendarId get_ID();
    internal static long GetAbsoluteDate(int year, int month, int day);
    internal virtual long DateToTicks(int year, int month, int day);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual Int32[] get_Eras();
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    internal virtual bool IsValidYear(int year, int era);
    internal virtual bool IsValidDay(int year, int month, int day, int era);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    internal virtual bool TryToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era, DateTime& result);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
internal class System.Globalization.GregorianCalendarHelper : object {
    internal static Int32[] DaysToMonth365;
    internal static Int32[] DaysToMonth366;
    internal int m_maxYear;
    internal int m_minYear;
    internal Calendar m_Cal;
    internal EraInfo[] m_EraInfo;
    internal Int32[] m_eras;
    internal int MaxYear { get; }
    public Int32[] Eras { get; }
    internal GregorianCalendarHelper(Calendar cal, EraInfo[] eraInfo);
    private static GregorianCalendarHelper();
    internal int get_MaxYear();
    private int GetYearOffset(int year, int era, bool throwOnError);
    internal int GetGregorianYear(int year, int era);
    internal bool IsValidYear(int year, int era);
    internal virtual int GetDatePart(long ticks, int part);
    internal static long GetAbsoluteDate(int year, int month, int day);
    internal static long DateToTicks(int year, int month, int day);
    internal static long TimeToTicks(int hour, int minute, int second, int millisecond);
    internal void CheckTicksRange(long ticks);
    public DateTime AddMonths(DateTime time, int months);
    public DateTime AddYears(DateTime time, int years);
    public int GetDayOfMonth(DateTime time);
    public DayOfWeek GetDayOfWeek(DateTime time);
    public int GetDayOfYear(DateTime time);
    public int GetDaysInMonth(int year, int month, int era);
    public int GetDaysInYear(int year, int era);
    public int GetEra(DateTime time);
    public Int32[] get_Eras();
    public int GetMonth(DateTime time);
    public int GetMonthsInYear(int year, int era);
    public int GetYear(DateTime time);
    public int GetYear(int year, DateTime time);
    public bool IsLeapDay(int year, int month, int day, int era);
    public int GetLeapMonth(int year, int era);
    public bool IsLeapMonth(int year, int month, int era);
    public bool IsLeapYear(int year, int era);
    public DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public int ToFourDigitYear(int year, int twoDigitYearMax);
}
public enum System.Globalization.GregorianCalendarTypes : Enum {
    public int value__;
    public static GregorianCalendarTypes Localized;
    public static GregorianCalendarTypes USEnglish;
    public static GregorianCalendarTypes MiddleEastFrench;
    public static GregorianCalendarTypes Arabic;
    public static GregorianCalendarTypes TransliteratedEnglish;
    public static GregorianCalendarTypes TransliteratedFrench;
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Globalization.HebrewCalendar : Calendar {
    public static int HebrewEra;
    private static Byte[] s_hebrewTable;
    private static Byte[] s_lunarMonthLen;
    private static DateTime s_calendarMinValue;
    private static DateTime s_calendarMaxValue;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static HebrewCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual CalendarId get_ID();
    private static void CheckHebrewYearValue(int y, int era, string varName);
    private void CheckHebrewMonthValue(int year, int month, int era);
    private void CheckHebrewDayValue(int year, int month, int day, int era);
    private static void CheckEraRange(int era);
    private static void CheckTicksRange(long ticks);
    private static int GetResult(DateBuffer result, int part);
    internal static int GetLunarMonthDay(int gregorianYear, DateBuffer lunarDate);
    internal virtual int GetDatePart(long ticks, int part);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    internal static int GetHebrewYearType(int year, int era);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual Int32[] get_Eras();
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    private static int GetDayDifference(int lunarYearType, int month1, int day1, int month2, int day2);
    private static DateTime HebrewToGregorian(int hebrewYear, int hebrewMonth, int hebrewDay, int hour, int minute, int second, int millisecond);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
internal static class System.Globalization.HebrewNumber : object {
    private static HebrewValue[] s_hebrewValues;
    private static char s_maxHebrewNumberCh;
    private static HS[] s_numberPasingState;
    private static HebrewNumber();
    internal static void Append(StringBuilder outputBuffer, int Number);
    internal static HebrewNumberParsingState ParseByChar(char ch, HebrewNumberParsingContext& context);
    internal static bool IsDigit(char ch);
}
internal class System.Globalization.HebrewNumberParsingContext : ValueType {
    internal HS state;
    internal int result;
    public HebrewNumberParsingContext(int result);
}
internal enum System.Globalization.HebrewNumberParsingState : Enum {
    public int value__;
    public static HebrewNumberParsingState InvalidHebrewNumber;
    public static HebrewNumberParsingState NotHebrewDigit;
    public static HebrewNumberParsingState FoundEndOfHebrewNumber;
    public static HebrewNumberParsingState ContinueParsing;
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Globalization.HijriCalendar : Calendar {
    public static int HijriEra;
    private static Int32[] s_hijriMonthDays;
    private int _hijriAdvance;
    private static DateTime s_calendarMinValue;
    private static DateTime s_calendarMaxValue;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal CalendarId ID { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    public int HijriAdjustment { get; public set; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static HijriCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual CalendarId get_ID();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    private long GetAbsoluteDateHijri(int y, int m, int d);
    private long DaysUpToHijriYear(int HijriYear);
    public int get_HijriAdjustment();
    public void set_HijriAdjustment(int value);
    internal static void CheckTicksRange(long ticks);
    internal static void CheckEraRange(int era);
    internal static void CheckYearRange(int year, int era);
    internal static void CheckYearMonthRange(int year, int month, int era);
    internal virtual int GetDatePart(long ticks, int part);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual Int32[] get_Eras();
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
    private int GetHijriDateAdjustment();
    private static int GetAdvanceHijriDate();
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Globalization.IdnMapping : object {
    private bool _allowUnassigned;
    private bool _useStd3AsciiRules;
    private static Char[] c_Dots;
    public bool AllowUnassigned { get; public set; }
    public bool UseStd3AsciiRules { get; public set; }
    private UInt32 Flags { get; }
    private static IdnMapping();
    public bool get_AllowUnassigned();
    public void set_AllowUnassigned(bool value);
    public bool get_UseStd3AsciiRules();
    public void set_UseStd3AsciiRules(bool value);
    public string GetAscii(string unicode);
    public string GetAscii(string unicode, int index);
    public string GetAscii(string unicode, int index, int count);
    public string GetUnicode(string ascii);
    public string GetUnicode(string ascii, int index);
    public string GetUnicode(string ascii, int index, int count);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private static string GetStringForOutput(string originalString, Char* input, int inputLength, Char* output, int outputLength);
    private string GetAsciiInvariant(string unicode, int index, int count);
    private static bool ValidateStd3AndAscii(string unicode, bool bUseStd3, bool bCheckAscii);
    private static string PunycodeEncode(string unicode);
    private static bool IsDot(char c);
    private static bool IsSupplementary(int cTest);
    private static bool Basic(UInt32 cp);
    private static void ValidateStd3(char c, bool bNextToDot);
    private string GetUnicodeInvariant(string ascii, int index, int count);
    private static string PunycodeDecode(string ascii);
    private static int DecodeDigit(char cp);
    private static int Adapt(int delta, int numpoints, bool firsttime);
    private static char EncodeBasic(char bcp);
    private static bool HasUpperCaseFlag(char punychar);
    private static char EncodeDigit(int d);
    private string GetAsciiCore(string unicodeString, Char* unicode, int count);
    private string GetAsciiCore(string unicodeString, Char* unicode, int count, UInt32 flags, Char* output, int outputLength);
    private string GetUnicodeCore(string asciiString, Char* ascii, int count);
    private string GetUnicodeCore(string asciiString, Char* ascii, int count, UInt32 flags, Char* output, int outputLength);
    private UInt32 get_Flags();
    [DoesNotReturnAttribute]
private static void ThrowForZeroLength(bool unicode);
}
internal class System.Globalization.InternalGlobalizationHelper : object {
    internal static long TimeToTicks(int hour, int minute, int second);
}
public static class System.Globalization.ISOWeek : object {
    public static int GetWeekOfYear(DateTime date);
    public static int GetYear(DateTime date);
    public static DateTime GetYearStart(int year);
    public static DateTime GetYearEnd(int year);
    public static int GetWeeksInYear(int year);
    public static DateTime ToDateTime(int year, int week, DayOfWeek dayOfWeek);
    private static int GetWeekNumber(DateTime date);
    private static int GetWeekday(DayOfWeek dayOfWeek);
    [CompilerGeneratedAttribute]
internal static int <GetWeeksInYear>g__P|8_0(int y);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Globalization.JapaneseCalendar : Calendar {
    private static DateTime s_calendarMinValue;
    private static EraInfo[] modreq(System.Runtime.CompilerServices.IsVolatile) s_japaneseEraInfo;
    internal static Calendar modreq(System.Runtime.CompilerServices.IsVolatile) s_defaultInstance;
    internal GregorianCalendarHelper _helper;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static JapaneseCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal static EraInfo[] GetEraInfo();
    internal static Calendar GetDefaultInstance();
    internal virtual CalendarId get_ID();
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public virtual int GetEra(DateTime time);
    public virtual int GetMonth(DateTime time);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int ToFourDigitYear(int year);
    public virtual Int32[] get_Eras();
    internal static String[] EraNames();
    internal static String[] AbbrevEraNames();
    internal static String[] EnglishEraNames();
    internal virtual bool IsValidYear(int year, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    private static EraInfo[] GetJapaneseEras();
    private static int CompareEraRanges(EraInfo a, EraInfo b);
    private static EraInfo GetEraFromValue(string value, string data);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Globalization.JapaneseLunisolarCalendar : EastAsianLunisolarCalendar {
    public static int JapaneseEra;
    private GregorianCalendarHelper _helper;
    private static DateTime s_minDate;
    private static DateTime s_maxDate;
    private static Int32[0...,0...] s_yinfo;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    internal int MinCalendarYear { get; }
    internal int MaxCalendarYear { get; }
    internal DateTime MinDate { get; }
    internal DateTime MaxDate { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal EraInfo[] CalEraInfo { get; }
    internal CalendarId BaseCalendarID { get; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    private static JapaneseLunisolarCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    internal virtual int get_MinCalendarYear();
    internal virtual int get_MaxCalendarYear();
    internal virtual DateTime get_MinDate();
    internal virtual DateTime get_MaxDate();
    internal virtual EraInfo[] get_CalEraInfo();
    internal virtual int GetYearInfo(int lunarYear, int index);
    internal virtual int GetYear(int year, DateTime time);
    internal virtual int GetGregorianYear(int year, int era);
    private static EraInfo[] TrimEras(EraInfo[] baseEras);
    public virtual int GetEra(DateTime time);
    internal virtual CalendarId get_BaseCalendarID();
    internal virtual CalendarId get_ID();
    public virtual Int32[] get_Eras();
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Globalization.JulianCalendar : Calendar {
    public static int JulianEra;
    private static Int32[] s_daysToMonth365;
    private static Int32[] s_daysToMonth366;
    internal int MaxYear;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static JulianCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual CalendarId get_ID();
    internal static void CheckEraRange(int era);
    internal void CheckYearEraRange(int year, int era);
    internal static void CheckMonthRange(int month);
    internal static void CheckDayRange(int year, int month, int day);
    internal static int GetDatePart(long ticks, int part);
    internal static long DateToTicks(int year, int month, int day);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual int GetMonth(DateTime time);
    public virtual Int32[] get_Eras();
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Globalization.KoreanCalendar : Calendar {
    public static int KoreanEra;
    private static EraInfo[] s_koreanEraInfo;
    private GregorianCalendarHelper _helper;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static KoreanCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual CalendarId get_ID();
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public virtual int GetEra(DateTime time);
    public virtual int GetMonth(DateTime time);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual Int32[] get_Eras();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Globalization.KoreanLunisolarCalendar : EastAsianLunisolarCalendar {
    public static int GregorianEra;
    private static DateTime s_minDate;
    private static DateTime s_maxDate;
    private static Int32[0...,0...] s_yinfo;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    internal int MinCalendarYear { get; }
    internal int MaxCalendarYear { get; }
    internal DateTime MinDate { get; }
    internal DateTime MaxDate { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal EraInfo[] CalEraInfo { get; }
    internal CalendarId BaseCalendarID { get; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    private static KoreanLunisolarCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    internal virtual int get_MinCalendarYear();
    internal virtual int get_MaxCalendarYear();
    internal virtual DateTime get_MinDate();
    internal virtual DateTime get_MaxDate();
    internal virtual EraInfo[] get_CalEraInfo();
    internal virtual int GetYearInfo(int lunarYear, int index);
    internal virtual int GetYear(int year, DateTime time);
    internal virtual int GetGregorianYear(int year, int era);
    public virtual int GetEra(DateTime time);
    internal virtual CalendarId get_BaseCalendarID();
    internal virtual CalendarId get_ID();
    public virtual Int32[] get_Eras();
}
[FlagsAttribute]
internal enum System.Globalization.MonthNameStyles : Enum {
    public int value__;
    public static MonthNameStyles Regular;
    public static MonthNameStyles Genitive;
    public static MonthNameStyles LeapYear;
}
internal static class System.Globalization.Normalization : object {
    internal static bool IsNormalized(string strInput, NormalizationForm normalizationForm);
    internal static string Normalize(string strInput, NormalizationForm normalizationForm);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Globalization.NumberFormatInfo : object {
    private static NumberFormatInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_invariantInfo;
    internal Int32[] _numberGroupSizes;
    internal Int32[] _currencyGroupSizes;
    internal Int32[] _percentGroupSizes;
    internal string _positiveSign;
    internal string _negativeSign;
    internal string _numberDecimalSeparator;
    internal string _numberGroupSeparator;
    internal string _currencyGroupSeparator;
    internal string _currencyDecimalSeparator;
    internal string _currencySymbol;
    internal string _nanSymbol;
    internal string _positiveInfinitySymbol;
    internal string _negativeInfinitySymbol;
    internal string _percentDecimalSeparator;
    internal string _percentGroupSeparator;
    internal string _percentSymbol;
    internal string _perMilleSymbol;
    internal String[] _nativeDigits;
    internal int _numberDecimalDigits;
    internal int _currencyDecimalDigits;
    internal int _currencyPositivePattern;
    internal int _currencyNegativePattern;
    internal int _numberNegativePattern;
    internal int _percentPositivePattern;
    internal int _percentNegativePattern;
    internal int _percentDecimalDigits;
    internal int _digitSubstitution;
    internal bool _isReadOnly;
    private bool _hasInvariantNumberSigns;
    internal bool HasInvariantNumberSigns { get; }
    public static NumberFormatInfo InvariantInfo { get; }
    public int CurrencyDecimalDigits { get; public set; }
    public string CurrencyDecimalSeparator { get; public set; }
    public bool IsReadOnly { get; }
    public Int32[] CurrencyGroupSizes { get; public set; }
    public Int32[] NumberGroupSizes { get; public set; }
    public Int32[] PercentGroupSizes { get; public set; }
    public string CurrencyGroupSeparator { get; public set; }
    public string CurrencySymbol { get; public set; }
    public static NumberFormatInfo CurrentInfo { get; }
    public string NaNSymbol { get; public set; }
    public int CurrencyNegativePattern { get; public set; }
    public int NumberNegativePattern { get; public set; }
    public int PercentPositivePattern { get; public set; }
    public int PercentNegativePattern { get; public set; }
    public string NegativeInfinitySymbol { get; public set; }
    public string NegativeSign { get; public set; }
    public int NumberDecimalDigits { get; public set; }
    public string NumberDecimalSeparator { get; public set; }
    public string NumberGroupSeparator { get; public set; }
    public int CurrencyPositivePattern { get; public set; }
    public string PositiveInfinitySymbol { get; public set; }
    public string PositiveSign { get; public set; }
    public int PercentDecimalDigits { get; public set; }
    public string PercentDecimalSeparator { get; public set; }
    public string PercentGroupSeparator { get; public set; }
    public string PercentSymbol { get; public set; }
    public string PerMilleSymbol { get; public set; }
    public String[] NativeDigits { get; public set; }
    public DigitShapes DigitSubstitution { get; public set; }
    internal NumberFormatInfo(CultureData cultureData);
    private static void VerifyDecimalSeparator(string decSep, string propertyName);
    private static void VerifyGroupSeparator(string groupSep, string propertyName);
    private static void VerifyNativeDigits(String[] nativeDig, string propertyName);
    private static void VerifyDigitSubstitution(DigitShapes digitSub, string propertyName);
    internal bool get_HasInvariantNumberSigns();
    private void UpdateHasInvariantNumberSigns();
    private void VerifyWritable();
    public static NumberFormatInfo get_InvariantInfo();
    public static NumberFormatInfo GetInstance(IFormatProvider formatProvider);
    public sealed virtual object Clone();
    public int get_CurrencyDecimalDigits();
    public void set_CurrencyDecimalDigits(int value);
    public string get_CurrencyDecimalSeparator();
    public void set_CurrencyDecimalSeparator(string value);
    public bool get_IsReadOnly();
    internal static void CheckGroupSize(string propName, Int32[] groupSize);
    public Int32[] get_CurrencyGroupSizes();
    public void set_CurrencyGroupSizes(Int32[] value);
    public Int32[] get_NumberGroupSizes();
    public void set_NumberGroupSizes(Int32[] value);
    public Int32[] get_PercentGroupSizes();
    public void set_PercentGroupSizes(Int32[] value);
    public string get_CurrencyGroupSeparator();
    public void set_CurrencyGroupSeparator(string value);
    public string get_CurrencySymbol();
    public void set_CurrencySymbol(string value);
    public static NumberFormatInfo get_CurrentInfo();
    public string get_NaNSymbol();
    public void set_NaNSymbol(string value);
    public int get_CurrencyNegativePattern();
    public void set_CurrencyNegativePattern(int value);
    public int get_NumberNegativePattern();
    public void set_NumberNegativePattern(int value);
    public int get_PercentPositivePattern();
    public void set_PercentPositivePattern(int value);
    public int get_PercentNegativePattern();
    public void set_PercentNegativePattern(int value);
    public string get_NegativeInfinitySymbol();
    public void set_NegativeInfinitySymbol(string value);
    public string get_NegativeSign();
    public void set_NegativeSign(string value);
    public int get_NumberDecimalDigits();
    public void set_NumberDecimalDigits(int value);
    public string get_NumberDecimalSeparator();
    public void set_NumberDecimalSeparator(string value);
    public string get_NumberGroupSeparator();
    public void set_NumberGroupSeparator(string value);
    public int get_CurrencyPositivePattern();
    public void set_CurrencyPositivePattern(int value);
    public string get_PositiveInfinitySymbol();
    public void set_PositiveInfinitySymbol(string value);
    public string get_PositiveSign();
    public void set_PositiveSign(string value);
    public int get_PercentDecimalDigits();
    public void set_PercentDecimalDigits(int value);
    public string get_PercentDecimalSeparator();
    public void set_PercentDecimalSeparator(string value);
    public string get_PercentGroupSeparator();
    public void set_PercentGroupSeparator(string value);
    public string get_PercentSymbol();
    public void set_PercentSymbol(string value);
    public string get_PerMilleSymbol();
    public void set_PerMilleSymbol(string value);
    public String[] get_NativeDigits();
    public void set_NativeDigits(String[] value);
    public DigitShapes get_DigitSubstitution();
    public void set_DigitSubstitution(DigitShapes value);
    [NullableContextAttribute("2")]
public sealed virtual object GetFormat(Type formatType);
    public static NumberFormatInfo ReadOnly(NumberFormatInfo nfi);
    internal static void ValidateParseStyleInteger(NumberStyles style);
    internal static void ValidateParseStyleFloatingPoint(NumberStyles style);
    [CompilerGeneratedAttribute]
internal static NumberFormatInfo <GetInstance>g__GetProviderNonNull|42_0(IFormatProvider provider);
    [CompilerGeneratedAttribute]
internal static void <ValidateParseStyleInteger>g__throwInvalid|133_0(NumberStyles value);
    [CompilerGeneratedAttribute]
internal static void <ValidateParseStyleFloatingPoint>g__throwInvalid|134_0(NumberStyles value);
}
[FlagsAttribute]
public enum System.Globalization.NumberStyles : Enum {
    public int value__;
    public static NumberStyles None;
    public static NumberStyles AllowLeadingWhite;
    public static NumberStyles AllowTrailingWhite;
    public static NumberStyles AllowLeadingSign;
    public static NumberStyles AllowTrailingSign;
    public static NumberStyles AllowParentheses;
    public static NumberStyles AllowDecimalPoint;
    public static NumberStyles AllowThousands;
    public static NumberStyles AllowExponent;
    public static NumberStyles AllowCurrencySymbol;
    public static NumberStyles AllowHexSpecifier;
    public static NumberStyles Integer;
    public static NumberStyles HexNumber;
    public static NumberStyles Number;
    public static NumberStyles Float;
    public static NumberStyles Currency;
    public static NumberStyles Any;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Globalization.PersianCalendar : Calendar {
    public static int PersianEra;
    private static long s_persianEpoch;
    private static Int32[] s_daysToMonth;
    private static DateTime s_minDate;
    private static DateTime s_maxDate;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal CalendarId BaseCalendarID { get; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static PersianCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual CalendarId get_BaseCalendarID();
    internal virtual CalendarId get_ID();
    private long GetAbsoluteDatePersian(int year, int month, int day);
    internal static void CheckTicksRange(long ticks);
    internal static void CheckEraRange(int era);
    internal static void CheckYearRange(int year, int era);
    internal static void CheckYearMonthRange(int year, int month, int era);
    private static int MonthFromOrdinalDay(int ordinalDay);
    private static int DaysInPreviousMonths(int month);
    internal int GetDatePart(long ticks, int part);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual Int32[] get_Eras();
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Globalization.RegionInfo : object {
    private string _name;
    private CultureData _cultureData;
    internal static RegionInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_currentRegionInfo;
    public static RegionInfo CurrentRegion { get; }
    public string Name { get; }
    public string EnglishName { get; }
    public string DisplayName { get; }
    public string NativeName { get; }
    public string TwoLetterISORegionName { get; }
    public string ThreeLetterISORegionName { get; }
    public string ThreeLetterWindowsRegionName { get; }
    public bool IsMetric { get; }
    public int GeoId { get; }
    public string CurrencyEnglishName { get; }
    public string CurrencyNativeName { get; }
    public string CurrencySymbol { get; }
    public string ISOCurrencySymbol { get; }
    public RegionInfo(string name);
    public RegionInfo(int culture);
    internal RegionInfo(CultureData cultureData);
    public static RegionInfo get_CurrentRegion();
    public virtual string get_Name();
    public virtual string get_EnglishName();
    public virtual string get_DisplayName();
    public virtual string get_NativeName();
    public virtual string get_TwoLetterISORegionName();
    public virtual string get_ThreeLetterISORegionName();
    public virtual string get_ThreeLetterWindowsRegionName();
    public virtual bool get_IsMetric();
    public virtual int get_GeoId();
    public virtual string get_CurrencyEnglishName();
    public virtual string get_CurrencyNativeName();
    public virtual string get_CurrencySymbol();
    public virtual string get_ISOCurrencySymbol();
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Globalization.SortKey : object {
    private string _localeName;
    private CompareOptions _options;
    private string _string;
    private Byte[] _keyData;
    public string OriginalString { get; }
    public Byte[] KeyData { get; }
    internal SortKey(string localeName, string str, CompareOptions options, Byte[] keyData);
    public virtual string get_OriginalString();
    public virtual Byte[] get_KeyData();
    public static int Compare(SortKey sortkey1, SortKey sortkey2);
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NullableAttribute("0")]
[NullableContextAttribute("2")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Globalization.SortVersion : object {
    private int m_NlsVersion;
    private Guid m_SortId;
    public int FullVersion { get; }
    public Guid SortId { get; }
    public SortVersion(int fullVersion, Guid sortId);
    internal SortVersion(int nlsVersion, int effectiveId, Guid customVersion);
    public int get_FullVersion();
    public Guid get_SortId();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SortVersion other);
    public virtual int GetHashCode();
    public static bool op_Equality(SortVersion left, SortVersion right);
    public static bool op_Inequality(SortVersion left, SortVersion right);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Globalization.StringInfo : object {
    private string _str;
    private Int32[] _indexes;
    [NullableAttribute("2")]
private Int32[] Indexes { get; }
    public string String { get; public set; }
    public int LengthInTextElements { get; }
    public StringInfo(string value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public virtual int GetHashCode();
    private Int32[] get_Indexes();
    public string get_String();
    public void set_String(string value);
    public int get_LengthInTextElements();
    public string SubstringByTextElements(int startingTextElement);
    public string SubstringByTextElements(int startingTextElement, int lengthInTextElements);
    public static string GetNextTextElement(string str);
    internal static int GetCurrentTextElementLen(string str, int index, int len, UnicodeCategory& ucCurrent, Int32& currentCharCount);
    public static string GetNextTextElement(string str, int index);
    public static TextElementEnumerator GetTextElementEnumerator(string str);
    public static TextElementEnumerator GetTextElementEnumerator(string str, int index);
    public static Int32[] ParseCombiningCharacters(string str);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Globalization.TaiwanCalendar : Calendar {
    private static EraInfo[] s_taiwanEraInfo;
    private static Calendar modreq(System.Runtime.CompilerServices.IsVolatile) s_defaultInstance;
    private GregorianCalendarHelper _helper;
    private static DateTime s_calendarMinValue;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static TaiwanCalendar();
    internal static Calendar GetDefaultInstance();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual CalendarId get_ID();
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public virtual int GetEra(DateTime time);
    public virtual int GetMonth(DateTime time);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual Int32[] get_Eras();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Globalization.TaiwanLunisolarCalendar : EastAsianLunisolarCalendar {
    private static EraInfo[] s_taiwanLunisolarEraInfo;
    private GregorianCalendarHelper _helper;
    private static DateTime s_minDate;
    private static DateTime s_maxDate;
    private static Int32[0...,0...] s_yinfo;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    internal int MinCalendarYear { get; }
    internal int MaxCalendarYear { get; }
    internal DateTime MinDate { get; }
    internal DateTime MaxDate { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal EraInfo[] CalEraInfo { get; }
    internal CalendarId BaseCalendarID { get; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    private static TaiwanLunisolarCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    internal virtual int get_MinCalendarYear();
    internal virtual int get_MaxCalendarYear();
    internal virtual DateTime get_MinDate();
    internal virtual DateTime get_MaxDate();
    internal virtual EraInfo[] get_CalEraInfo();
    internal virtual int GetYearInfo(int lunarYear, int index);
    internal virtual int GetYear(int year, DateTime time);
    internal virtual int GetGregorianYear(int year, int era);
    public virtual int GetEra(DateTime time);
    internal virtual CalendarId get_BaseCalendarID();
    internal virtual CalendarId get_ID();
    public virtual Int32[] get_Eras();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Globalization.TextElementEnumerator : object {
    private string _str;
    private int _index;
    private int _startIndex;
    private int _strLen;
    private int _currTextElementLen;
    private UnicodeCategory _uc;
    private int _charLen;
    public object Current { get; }
    public int ElementIndex { get; }
    internal TextElementEnumerator(string str, int startIndex, int strLen);
    public sealed virtual bool MoveNext();
    public sealed virtual object get_Current();
    public string GetTextElement();
    public int get_ElementIndex();
    public sealed virtual void Reset();
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Globalization.TextInfo : object {
    private string _listSeparator;
    private bool _isReadOnly;
    private string _cultureName;
    private CultureData _cultureData;
    private string _textInfoName;
    private Tristate _isAsciiCasingSameAsInvariant;
    private static TextInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_invariant;
    private IntPtr _sortHandle;
    internal static TextInfo Invariant { get; }
    public int ANSICodePage { get; }
    public int OEMCodePage { get; }
    public int MacCodePage { get; }
    public int EBCDICCodePage { get; }
    public int LCID { get; }
    public string CultureName { get; }
    public bool IsReadOnly { get; }
    public string ListSeparator { get; public set; }
    private bool IsAsciiCasingSameAsInvariant { get; }
    public bool IsRightToLeft { get; }
    internal TextInfo(CultureData cultureData);
    internal static TextInfo get_Invariant();
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    public virtual int get_ANSICodePage();
    public virtual int get_OEMCodePage();
    public virtual int get_MacCodePage();
    public virtual int get_EBCDICCodePage();
    public int get_LCID();
    public string get_CultureName();
    public bool get_IsReadOnly();
    public virtual object Clone();
    public static TextInfo ReadOnly(TextInfo textInfo);
    private void VerifyWritable();
    internal void SetReadOnlyState(bool readOnly);
    public virtual string get_ListSeparator();
    public virtual void set_ListSeparator(string value);
    public virtual char ToLower(char c);
    public virtual string ToLower(string str);
    private char ChangeCase(char c, bool toUpper);
    internal void ChangeCaseToLower(ReadOnlySpan`1<char> source, Span`1<char> destination);
    internal void ChangeCaseToUpper(ReadOnlySpan`1<char> source, Span`1<char> destination);
    private void ChangeCaseCommon(ReadOnlySpan`1<char> source, Span`1<char> destination);
    private void ChangeCaseCommon(Char& source, Char& destination, int charCount);
    private string ChangeCaseCommon(string source);
    internal static string ToLowerAsciiInvariant(string s);
    internal static void ToLowerAsciiInvariant(ReadOnlySpan`1<char> source, Span`1<char> destination);
    private static string ToUpperAsciiInvariant(string s);
    internal static void ToUpperAsciiInvariant(ReadOnlySpan`1<char> source, Span`1<char> destination);
    private static char ToLowerAsciiInvariant(char c);
    public virtual char ToUpper(char c);
    public virtual string ToUpper(string str);
    internal static char ToUpperAsciiInvariant(char c);
    private static bool IsAscii(char c);
    private bool get_IsAsciiCasingSameAsInvariant();
    private void PopulateIsAsciiCasingSameAsInvariant();
    public bool get_IsRightToLeft();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToTitleCase(string str);
    private static int AddNonLetter(StringBuilder& result, String& input, int inputIndex, int charLen);
    private int AddTitlecaseLetter(StringBuilder& result, String& input, int inputIndex, int charLen);
    private static bool IsWordSeparator(UnicodeCategory category);
    private static bool IsLetterCategory(UnicodeCategory uc);
    private void FinishInitialization();
    private void ChangeCase(Char* pSource, int pSourceLen, Char* pResult, int pResultLen, bool toUpper);
    private static bool IsInvariantLocale(string localeName);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Globalization.ThaiBuddhistCalendar : Calendar {
    private static EraInfo[] s_thaiBuddhistEraInfo;
    public static int ThaiBuddhistEra;
    private GregorianCalendarHelper _helper;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static ThaiBuddhistCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual CalendarId get_ID();
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public virtual int GetEra(DateTime time);
    public virtual int GetMonth(DateTime time);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual Int32[] get_Eras();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
internal static class System.Globalization.TimeSpanFormat : object {
    internal static FormatLiterals PositiveInvariantFormatLiterals;
    internal static FormatLiterals NegativeInvariantFormatLiterals;
    private static TimeSpanFormat();
    internal static string Format(TimeSpan value, string format, IFormatProvider formatProvider);
    internal static bool TryFormat(TimeSpan value, Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider formatProvider);
    internal static string FormatC(TimeSpan value);
    private static string FormatG(TimeSpan value, DateTimeFormatInfo dtfi, StandardFormat format);
    private static bool TryFormatStandard(TimeSpan value, StandardFormat format, string decimalSeparator, Span`1<char> destination, Int32& charsWritten);
    private static void WriteTwoDigits(UInt32 value, Span`1<char> buffer);
    private static void WriteDigits(UInt32 value, Span`1<char> buffer);
    private static StringBuilder FormatCustomized(TimeSpan value, ReadOnlySpan`1<char> format, DateTimeFormatInfo dtfi, StringBuilder result);
}
internal static class System.Globalization.TimeSpanParse : object {
    internal static long Pow10(int pow);
    private static bool TryTimeToTicks(bool positive, TimeSpanToken days, TimeSpanToken hours, TimeSpanToken minutes, TimeSpanToken seconds, TimeSpanToken fraction, Int64& result);
    internal static TimeSpan Parse(ReadOnlySpan`1<char> input, IFormatProvider formatProvider);
    internal static bool TryParse(ReadOnlySpan`1<char> input, IFormatProvider formatProvider, TimeSpan& result);
    internal static TimeSpan ParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, IFormatProvider formatProvider, TimeSpanStyles styles);
    internal static bool TryParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result);
    internal static TimeSpan ParseExactMultiple(ReadOnlySpan`1<char> input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles);
    internal static bool TryParseExactMultiple(ReadOnlySpan`1<char> input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result);
    private static bool TryParseTimeSpan(ReadOnlySpan`1<char> input, TimeSpanStandardStyles style, IFormatProvider formatProvider, TimeSpanResult& result);
    private static bool ProcessTerminalState(TimeSpanRawInfo& raw, TimeSpanStandardStyles style, TimeSpanResult& result);
    private static bool ProcessTerminal_DHMSF(TimeSpanRawInfo& raw, TimeSpanStandardStyles style, TimeSpanResult& result);
    private static bool ProcessTerminal_HMS_F_D(TimeSpanRawInfo& raw, TimeSpanStandardStyles style, TimeSpanResult& result);
    private static bool ProcessTerminal_HM_S_D(TimeSpanRawInfo& raw, TimeSpanStandardStyles style, TimeSpanResult& result);
    private static bool ProcessTerminal_HM(TimeSpanRawInfo& raw, TimeSpanStandardStyles style, TimeSpanResult& result);
    private static bool ProcessTerminal_D(TimeSpanRawInfo& raw, TimeSpanStandardStyles style, TimeSpanResult& result);
    private static bool TryParseExactTimeSpan(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpanResult& result);
    private static bool TryParseByFormat(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, TimeSpanStyles styles, TimeSpanResult& result);
    private static bool ParseExactDigits(TimeSpanTokenizer& tokenizer, int minDigitLength, Int32& result);
    private static bool ParseExactDigits(TimeSpanTokenizer& tokenizer, int minDigitLength, int maxDigitLength, Int32& zeroes, Int32& result);
    private static bool ParseExactLiteral(TimeSpanTokenizer& tokenizer, StringBuilder enquotedString);
    private static bool TryParseTimeSpanConstant(ReadOnlySpan`1<char> input, TimeSpanResult& result);
    private static bool TryParseExactMultipleTimeSpan(ReadOnlySpan`1<char> input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpanResult& result);
}
[FlagsAttribute]
public enum System.Globalization.TimeSpanStyles : Enum {
    public int value__;
    public static TimeSpanStyles None;
    public static TimeSpanStyles AssumeNegative;
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Globalization.UmAlQuraCalendar : Calendar {
    private static DateMapping[] s_hijriYearInfo;
    public static int UmAlQuraEra;
    private static DateTime s_minDate;
    private static DateTime s_maxDate;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal CalendarId BaseCalendarID { get; }
    internal CalendarId ID { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static UmAlQuraCalendar();
    private static DateMapping[] InitDateMapping();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual CalendarId get_BaseCalendarID();
    internal virtual CalendarId get_ID();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    private static void ConvertHijriToGregorian(int HijriYear, int HijriMonth, int HijriDay, Int32& yg, Int32& mg, Int32& dg);
    private static long GetAbsoluteDateUmAlQura(int year, int month, int day);
    internal static void CheckTicksRange(long ticks);
    internal static void CheckEraRange(int era);
    internal static void CheckYearRange(int year, int era);
    internal static void CheckYearMonthRange(int year, int month, int era);
    private static void ConvertGregorianToHijri(DateTime time, Int32& HijriYear, Int32& HijriMonth, Int32& HijriDay);
    private int GetDatePart(DateTime time, int part);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    internal static int RealGetDaysInYear(int year);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual Int32[] get_Eras();
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
public enum System.Globalization.UnicodeCategory : Enum {
    public int value__;
    public static UnicodeCategory UppercaseLetter;
    public static UnicodeCategory LowercaseLetter;
    public static UnicodeCategory TitlecaseLetter;
    public static UnicodeCategory ModifierLetter;
    public static UnicodeCategory OtherLetter;
    public static UnicodeCategory NonSpacingMark;
    public static UnicodeCategory SpacingCombiningMark;
    public static UnicodeCategory EnclosingMark;
    public static UnicodeCategory DecimalDigitNumber;
    public static UnicodeCategory LetterNumber;
    public static UnicodeCategory OtherNumber;
    public static UnicodeCategory SpaceSeparator;
    public static UnicodeCategory LineSeparator;
    public static UnicodeCategory ParagraphSeparator;
    public static UnicodeCategory Control;
    public static UnicodeCategory Format;
    public static UnicodeCategory Surrogate;
    public static UnicodeCategory PrivateUse;
    public static UnicodeCategory ConnectorPunctuation;
    public static UnicodeCategory DashPunctuation;
    public static UnicodeCategory OpenPunctuation;
    public static UnicodeCategory ClosePunctuation;
    public static UnicodeCategory InitialQuotePunctuation;
    public static UnicodeCategory FinalQuotePunctuation;
    public static UnicodeCategory OtherPunctuation;
    public static UnicodeCategory MathSymbol;
    public static UnicodeCategory CurrencySymbol;
    public static UnicodeCategory ModifierSymbol;
    public static UnicodeCategory OtherSymbol;
    public static UnicodeCategory OtherNotAssigned;
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NonVersionableAttribute]
public class System.Guid : ValueType {
    public static Guid Empty;
    private int _a;
    private short _b;
    private short _c;
    private byte _d;
    private byte _e;
    private byte _f;
    private byte _g;
    private byte _h;
    private byte _i;
    private byte _j;
    private byte _k;
    [NullableContextAttribute("1")]
public Guid(Byte[] b);
    public Guid(ReadOnlySpan`1<byte> b);
    [CLSCompliantAttribute("False")]
public Guid(UInt32 a, ushort b, ushort c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k);
    [NullableContextAttribute("1")]
public Guid(int a, short b, short c, Byte[] d);
    public Guid(int a, short b, short c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k);
    [NullableContextAttribute("1")]
public Guid(string g);
    private static Guid();
    [NullableContextAttribute("1")]
public static Guid Parse(string input);
    public static Guid Parse(ReadOnlySpan`1<char> input);
    [NullableContextAttribute("2")]
public static bool TryParse(string input, Guid& result);
    public static bool TryParse(ReadOnlySpan`1<char> input, Guid& result);
    [NullableContextAttribute("1")]
public static Guid ParseExact(string input, string format);
    public static Guid ParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format);
    [NullableContextAttribute("2")]
public static bool TryParseExact(string input, string format, Guid& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, Guid& result);
    private static bool TryParseGuid(ReadOnlySpan`1<char> guidString, GuidResult& result);
    private static bool TryParseExactB(ReadOnlySpan`1<char> guidString, GuidResult& result);
    private static bool TryParseExactD(ReadOnlySpan`1<char> guidString, GuidResult& result);
    private static bool TryParseExactN(ReadOnlySpan`1<char> guidString, GuidResult& result);
    private static bool TryParseExactP(ReadOnlySpan`1<char> guidString, GuidResult& result);
    private static bool TryParseExactX(ReadOnlySpan`1<char> guidString, GuidResult& result);
    private static bool TryParseHex(ReadOnlySpan`1<char> guidString, Int16& result, Boolean& overflow);
    private static bool TryParseHex(ReadOnlySpan`1<char> guidString, UInt32& result);
    private static bool TryParseHex(ReadOnlySpan`1<char> guidString, UInt32& result, Boolean& overflow);
    private static ReadOnlySpan`1<char> EatAllWhitespace(ReadOnlySpan`1<char> str);
    private static bool IsHexPrefix(ReadOnlySpan`1<char> str, int i);
    [NullableContextAttribute("1")]
public Byte[] ToByteArray();
    public bool TryWriteBytes(Span`1<byte> destination);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object o);
    public sealed virtual bool Equals(Guid g);
    private int GetResult(UInt32 me, UInt32 them);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(Guid value);
    public static bool op_Equality(Guid a, Guid b);
    public static bool op_Inequality(Guid a, Guid b);
    [NullableContextAttribute("1")]
public string ToString(string format);
    private static char HexToChar(int a);
    private static int HexsToChars(Char* guidChars, int a, int b);
    private static int HexsToCharsHexOutput(Char* guidChars, int a, int b);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format);
    private sealed virtual override bool System.ISpanFormattable.TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static Guid NewGuid();
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.HashCode : ValueType {
    private static UInt32 s_seed;
    private UInt32 _v1;
    private UInt32 _v2;
    private UInt32 _v3;
    private UInt32 _v4;
    private UInt32 _queue1;
    private UInt32 _queue2;
    private UInt32 _queue3;
    private UInt32 _length;
    private static HashCode();
    private static UInt32 GenerateGlobalSeed();
    public static int Combine(T1 value1);
    public static int Combine(T1 value1, T2 value2);
    public static int Combine(T1 value1, T2 value2, T3 value3);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7, T8 value8);
    private static void Initialize(UInt32& v1, UInt32& v2, UInt32& v3, UInt32& v4);
    private static UInt32 Round(UInt32 hash, UInt32 input);
    private static UInt32 QueueRound(UInt32 hash, UInt32 queuedValue);
    private static UInt32 MixState(UInt32 v1, UInt32 v2, UInt32 v3, UInt32 v4);
    private static UInt32 MixEmptyState();
    private static UInt32 MixFinal(UInt32 hash);
    public void Add(T value);
    public void Add(T value, IEqualityComparer`1<T> comparer);
    private void Add(int value);
    public int ToHashCode();
    [ObsoleteAttribute("HashCode is a mutable struct and should not be compared with other HashCodes. Use ToHashCode to retrieve the computed hash code.", "True")]
[EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    [ObsoleteAttribute("HashCode is a mutable struct and should not be compared with other HashCodes.", "True")]
[NullableContextAttribute("2")]
[EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
}
public interface System.IAsyncDisposable {
    public abstract virtual ValueTask DisposeAsync();
}
[NullableContextAttribute("1")]
public interface System.IAsyncResult {
    public bool IsCompleted { get; }
    public WaitHandle AsyncWaitHandle { get; }
    [NullableAttribute("2")]
public object AsyncState { get; }
    public bool CompletedSynchronously { get; }
    public abstract virtual bool get_IsCompleted();
    public abstract virtual WaitHandle get_AsyncWaitHandle();
    [NullableContextAttribute("2")]
public abstract virtual object get_AsyncState();
    public abstract virtual bool get_CompletedSynchronously();
}
[NullableContextAttribute("1")]
public interface System.ICloneable {
    public abstract virtual object Clone();
}
[NullableContextAttribute("2")]
public interface System.IComparable {
    public abstract virtual int CompareTo(object obj);
}
[NullableContextAttribute("1")]
public interface System.IComparable`1 {
    public abstract virtual int CompareTo(T other);
}
[CLSCompliantAttribute("False")]
[NullableContextAttribute("2")]
public interface System.IConvertible {
    public abstract virtual TypeCode GetTypeCode();
    public abstract virtual bool ToBoolean(IFormatProvider provider);
    public abstract virtual char ToChar(IFormatProvider provider);
    public abstract virtual sbyte ToSByte(IFormatProvider provider);
    public abstract virtual byte ToByte(IFormatProvider provider);
    public abstract virtual short ToInt16(IFormatProvider provider);
    public abstract virtual ushort ToUInt16(IFormatProvider provider);
    public abstract virtual int ToInt32(IFormatProvider provider);
    public abstract virtual UInt32 ToUInt32(IFormatProvider provider);
    public abstract virtual long ToInt64(IFormatProvider provider);
    public abstract virtual ulong ToUInt64(IFormatProvider provider);
    public abstract virtual float ToSingle(IFormatProvider provider);
    public abstract virtual double ToDouble(IFormatProvider provider);
    public abstract virtual decimal ToDecimal(IFormatProvider provider);
    public abstract virtual DateTime ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("1")]
public abstract virtual string ToString(IFormatProvider provider);
    [NullableContextAttribute("1")]
public abstract virtual object ToType(Type conversionType, IFormatProvider provider);
}
[NullableContextAttribute("2")]
public interface System.ICustomFormatter {
    public abstract virtual string Format(string format, object arg, IFormatProvider formatProvider);
}
public interface System.IDisposable {
    public abstract virtual void Dispose();
}
[NullableContextAttribute("1")]
public interface System.IEquatable`1 {
    public abstract virtual bool Equals(T other);
}
[NullableContextAttribute("2")]
public interface System.IFormatProvider {
    public abstract virtual object GetFormat(Type formatType);
}
[NullableContextAttribute("2")]
public interface System.IFormattable {
    public abstract virtual string ToString(string format, IFormatProvider formatProvider);
}
[IsReadOnlyAttribute]
public class System.Index : ValueType {
    private int _value;
    public static Index Start { get; }
    public static Index End { get; }
    public int Value { get; }
    public bool IsFromEnd { get; }
    public Index(int value, bool fromEnd);
    private Index(int value);
    public static Index get_Start();
    public static Index get_End();
    public static Index FromStart(int value);
    public static Index FromEnd(int value);
    public int get_Value();
    public bool get_IsFromEnd();
    public int GetOffset(int length);
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public sealed virtual bool Equals(Index other);
    public virtual int GetHashCode();
    public static Index op_Implicit(int value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    private string ToStringFromEnd();
}
[NullableAttribute("0")]
[NullableContextAttribute("2")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.IndexOutOfRangeException : SystemException {
    public IndexOutOfRangeException(string message);
    public IndexOutOfRangeException(string message, Exception innerException);
    internal IndexOutOfRangeException(SerializationInfo info, StreamingContext context);
}
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableContextAttribute("2")]
public class System.InsufficientExecutionStackException : SystemException {
    public InsufficientExecutionStackException(string message);
    public InsufficientExecutionStackException(string message, Exception innerException);
    internal InsufficientExecutionStackException(SerializationInfo info, StreamingContext context);
}
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableContextAttribute("2")]
public class System.InsufficientMemoryException : OutOfMemoryException {
    public InsufficientMemoryException(string message);
    public InsufficientMemoryException(string message, Exception innerException);
    private InsufficientMemoryException(SerializationInfo info, StreamingContext context);
}
[IsReadOnlyAttribute]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Int16 : ValueType {
    private short m_value;
    public static short MaxValue;
    public static short MinValue;
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(short value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(short obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public sealed virtual string ToString(IFormatProvider provider);
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static short Parse(string s);
    [NullableContextAttribute("1")]
public static short Parse(string s, NumberStyles style);
    [NullableContextAttribute("1")]
public static short Parse(string s, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static short Parse(string s, NumberStyles style, IFormatProvider provider);
    public static short Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    private static short Parse(ReadOnlySpan`1<char> s, NumberStyles style, NumberFormatInfo info);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, Int16& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, Int16& result);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Int16& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Int16& result);
    private static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, NumberFormatInfo info, Int16& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[IsReadOnlyAttribute]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Int32 : ValueType {
    private int m_value;
    public static int MaxValue;
    public static int MinValue;
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(int value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(int obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("1")]
public sealed virtual string ToString(IFormatProvider provider);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static int Parse(string s);
    [NullableContextAttribute("1")]
public static int Parse(string s, NumberStyles style);
    [NullableContextAttribute("1")]
public static int Parse(string s, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static int Parse(string s, NumberStyles style, IFormatProvider provider);
    public static int Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, Int32& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, Int32& result);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Int32& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Int32& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[IsReadOnlyAttribute]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Int64 : ValueType {
    private long m_value;
    public static long MaxValue;
    public static long MinValue;
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(long value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(long obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public sealed virtual string ToString(IFormatProvider provider);
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static long Parse(string s);
    [NullableContextAttribute("1")]
public static long Parse(string s, NumberStyles style);
    [NullableContextAttribute("1")]
public static long Parse(string s, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static long Parse(string s, NumberStyles style, IFormatProvider provider);
    public static long Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, Int64& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, Int64& result);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Int64& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Int64& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[IsReadOnlyAttribute]
public class System.IntPtr : ValueType {
    private Void* _value;
    [IntrinsicAttribute]
public static IntPtr Zero;
    public static int Size { get; }
    [NonVersionableAttribute]
[IntrinsicAttribute]
public IntPtr(int value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public IntPtr(long value);
    [NonVersionableAttribute]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public IntPtr(Void* value);
    private IntPtr(SerializationInfo info, StreamingContext context);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    private sealed virtual override bool System.IEquatable<System.IntPtr>.Equals(IntPtr other);
    public virtual int GetHashCode();
    [NonVersionableAttribute]
[IntrinsicAttribute]
public int ToInt32();
    [IntrinsicAttribute]
[NonVersionableAttribute]
public long ToInt64();
    [NonVersionableAttribute]
[IntrinsicAttribute]
public static IntPtr op_Explicit(int value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static IntPtr op_Explicit(long value);
    [NonVersionableAttribute]
[CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static IntPtr op_Explicit(Void* value);
    [NonVersionableAttribute]
[CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static Void* op_Explicit(IntPtr value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static int op_Explicit(IntPtr value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static long op_Explicit(IntPtr value);
    [NonVersionableAttribute]
[IntrinsicAttribute]
public static bool op_Equality(IntPtr value1, IntPtr value2);
    [NonVersionableAttribute]
[IntrinsicAttribute]
public static bool op_Inequality(IntPtr value1, IntPtr value2);
    [NonVersionableAttribute]
public static IntPtr Add(IntPtr pointer, int offset);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static IntPtr op_Addition(IntPtr pointer, int offset);
    [NonVersionableAttribute]
public static IntPtr Subtract(IntPtr pointer, int offset);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static IntPtr op_Subtraction(IntPtr pointer, int offset);
    [NonVersionableAttribute]
[IntrinsicAttribute]
public static int get_Size();
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
[IntrinsicAttribute]
public Void* ToPointer();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(string format);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableAttribute("0")]
[NullableContextAttribute("2")]
public class System.InvalidCastException : SystemException {
    public InvalidCastException(string message);
    public InvalidCastException(string message, Exception innerException);
    public InvalidCastException(string message, int errorCode);
    [NullableContextAttribute("1")]
protected InvalidCastException(SerializationInfo info, StreamingContext context);
}
[NullableAttribute("0")]
[NullableContextAttribute("2")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.InvalidOperationException : SystemException {
    public InvalidOperationException(string message);
    public InvalidOperationException(string message, Exception innerException);
    [NullableContextAttribute("1")]
protected InvalidOperationException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableAttribute("0")]
[NullableContextAttribute("2")]
public class System.InvalidProgramException : SystemException {
    public InvalidProgramException(string message);
    public InvalidProgramException(string message, Exception inner);
    internal InvalidProgramException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("System.Core, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.InvalidTimeZoneException : Exception {
    public InvalidTimeZoneException(string message);
    public InvalidTimeZoneException(string message, Exception innerException);
    [NullableContextAttribute("1")]
protected InvalidTimeZoneException(SerializationInfo info, StreamingContext context);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.IO.BinaryReader : object {
    private Stream _stream;
    private Byte[] _buffer;
    private Decoder _decoder;
    private Byte[] _charBytes;
    private Char[] _charBuffer;
    private int _maxCharsSize;
    private bool _2BytesPerChar;
    private bool _isMemoryStream;
    private bool _leaveOpen;
    private bool _disposed;
    public Stream BaseStream { get; }
    public BinaryReader(Stream input);
    public BinaryReader(Stream input, Encoding encoding);
    public BinaryReader(Stream input, Encoding encoding, bool leaveOpen);
    public virtual Stream get_BaseStream();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    public virtual void Close();
    private void ThrowIfDisposed();
    public virtual int PeekChar();
    public virtual int Read();
    public virtual byte ReadByte();
    private byte InternalReadByte();
    [CLSCompliantAttribute("False")]
public virtual sbyte ReadSByte();
    public virtual bool ReadBoolean();
    public virtual char ReadChar();
    public virtual short ReadInt16();
    [CLSCompliantAttribute("False")]
public virtual ushort ReadUInt16();
    public virtual int ReadInt32();
    [CLSCompliantAttribute("False")]
public virtual UInt32 ReadUInt32();
    public virtual long ReadInt64();
    [CLSCompliantAttribute("False")]
public virtual ulong ReadUInt64();
    public virtual float ReadSingle();
    public virtual double ReadDouble();
    public virtual decimal ReadDecimal();
    public virtual string ReadString();
    public virtual int Read(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual int Read(Span`1<char> buffer);
    private int InternalReadChars(Span`1<char> buffer);
    public virtual Char[] ReadChars(int count);
    public virtual int Read(Byte[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual int Read(Span`1<byte> buffer);
    public virtual Byte[] ReadBytes(int count);
    private ReadOnlySpan`1<byte> InternalRead(int numBytes);
    protected virtual void FillBuffer(int numBytes);
    protected internal int Read7BitEncodedInt();
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.IO.BinaryWriter : object {
    public static BinaryWriter Null;
    protected Stream OutStream;
    private Byte[] _buffer;
    private Encoding _encoding;
    private Encoder _encoder;
    private bool _leaveOpen;
    private Byte[] _largeByteBuffer;
    private int _maxChars;
    public Stream BaseStream { get; }
    public BinaryWriter(Stream output);
    public BinaryWriter(Stream output, Encoding encoding);
    public BinaryWriter(Stream output, Encoding encoding, bool leaveOpen);
    private static BinaryWriter();
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    public virtual ValueTask DisposeAsync();
    public virtual Stream get_BaseStream();
    public virtual void Flush();
    public virtual long Seek(int offset, SeekOrigin origin);
    public virtual void Write(bool value);
    public virtual void Write(byte value);
    [CLSCompliantAttribute("False")]
public virtual void Write(sbyte value);
    public virtual void Write(Byte[] buffer);
    public virtual void Write(Byte[] buffer, int index, int count);
    public virtual void Write(char ch);
    public virtual void Write(Char[] chars);
    public virtual void Write(Char[] chars, int index, int count);
    public virtual void Write(double value);
    public virtual void Write(decimal value);
    public virtual void Write(short value);
    [CLSCompliantAttribute("False")]
public virtual void Write(ushort value);
    public virtual void Write(int value);
    [CLSCompliantAttribute("False")]
public virtual void Write(UInt32 value);
    public virtual void Write(long value);
    [CLSCompliantAttribute("False")]
public virtual void Write(ulong value);
    public virtual void Write(float value);
    public virtual void Write(string value);
    [NullableContextAttribute("0")]
public virtual void Write(ReadOnlySpan`1<byte> buffer);
    [NullableContextAttribute("0")]
public virtual void Write(ReadOnlySpan`1<char> chars);
    protected void Write7BitEncodedInt(int value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.IO.DirectoryNotFoundException : IOException {
    public DirectoryNotFoundException(string message);
    public DirectoryNotFoundException(string message, Exception innerException);
    [NullableContextAttribute("1")]
protected DirectoryNotFoundException(SerializationInfo info, StreamingContext context);
}
internal class System.IO.DisableMediaInsertionPrompt : ValueType {
    private bool _disableSuccess;
    private UInt32 _oldMode;
    public static DisableMediaInsertionPrompt Create();
    public sealed virtual void Dispose();
}
internal static class System.IO.DriveInfoInternal : object {
    public static String[] GetLogicalDrives();
}
internal static class System.IO.EncodingCache : object {
    internal static Encoding UTF8NoBOM;
    private static EncodingCache();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.IO.EndOfStreamException : IOException {
    public EndOfStreamException(string message);
    public EndOfStreamException(string message, Exception innerException);
    [NullableContextAttribute("1")]
protected EndOfStreamException(SerializationInfo info, StreamingContext context);
}
internal static class System.IO.Error : object {
    internal static Exception GetStreamIsClosed();
    internal static Exception GetEndOfFile();
    internal static Exception GetFileNotOpen();
    internal static Exception GetReadNotSupported();
    internal static Exception GetSeekNotSupported();
    internal static Exception GetWriteNotSupported();
}
[FlagsAttribute]
public enum System.IO.FileAccess : Enum {
    public int value__;
    public static FileAccess Read;
    public static FileAccess Write;
    public static FileAccess ReadWrite;
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableAttribute("0")]
[NullableContextAttribute("2")]
public class System.IO.FileLoadException : IOException {
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FusionLog>k__BackingField;
    [NullableAttribute("1")]
public string Message { get; }
    public string FileName { get; }
    public string FusionLog { get; }
    private FileLoadException(string fileName, string fusionLog, int hResult);
    public FileLoadException(string message);
    public FileLoadException(string message, Exception inner);
    public FileLoadException(string message, string fileName);
    public FileLoadException(string message, string fileName, Exception inner);
    [NullableContextAttribute("1")]
protected FileLoadException(SerializationInfo info, StreamingContext context);
    internal static string FormatFileLoadExceptionMessage(string fileName, int hResult);
    private static void GetFileLoadExceptionMessage(int hResult, StringHandleOnStack retString);
    private static void GetMessageForHR(int hresult, StringHandleOnStack retString);
    [NullableContextAttribute("1")]
public virtual string get_Message();
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public string get_FusionLog();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public enum System.IO.FileMode : Enum {
    public int value__;
    public static FileMode CreateNew;
    public static FileMode Create;
    public static FileMode Open;
    public static FileMode OpenOrCreate;
    public static FileMode Truncate;
    public static FileMode Append;
}
[NullableAttribute("0")]
[NullableContextAttribute("2")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.IO.FileNotFoundException : IOException {
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FusionLog>k__BackingField;
    [NullableAttribute("1")]
public string Message { get; }
    public string FileName { get; }
    public string FusionLog { get; }
    private FileNotFoundException(string fileName, string fusionLog, int hResult);
    public FileNotFoundException(string message);
    public FileNotFoundException(string message, Exception innerException);
    public FileNotFoundException(string message, string fileName);
    public FileNotFoundException(string message, string fileName, Exception innerException);
    [NullableContextAttribute("1")]
protected FileNotFoundException(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("1")]
public virtual string get_Message();
    private void SetMessageField();
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public string get_FusionLog();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[FlagsAttribute]
public enum System.IO.FileOptions : Enum {
    public int value__;
    public static FileOptions None;
    public static FileOptions WriteThrough;
    public static FileOptions Asynchronous;
    public static FileOptions RandomAccess;
    public static FileOptions DeleteOnClose;
    public static FileOptions SequentialScan;
    public static FileOptions Encrypted;
}
[FlagsAttribute]
public enum System.IO.FileShare : Enum {
    public int value__;
    public static FileShare None;
    public static FileShare Read;
    public static FileShare Write;
    public static FileShare ReadWrite;
    public static FileShare Delete;
    public static FileShare Inheritable;
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.IO.FileStream : Stream {
    private Byte[] _buffer;
    private int _bufferLength;
    private SafeFileHandle _fileHandle;
    private FileAccess _access;
    private string _path;
    private int _readPos;
    private int _readLength;
    private int _writePos;
    private bool _useAsyncIO;
    private Task`1<int> _lastSynchronouslyCompletedTask;
    private long _filePosition;
    private bool _exposedHandle;
    private static int s_cachedSerializationSwitch;
    private bool _canSeek;
    private bool _isPipe;
    private long _appendStart;
    private static IOCompletionCallback s_ioCallback;
    private Task _activeBufferOperation;
    private PreAllocatedOverlapped _preallocatedOverlapped;
    private FileStreamCompletionSource _currentOverlappedOwner;
    [ObsoleteAttribute("This property has been deprecated.  Please use FileStream's SafeFileHandle property instead.  https://go.microsoft.com/fwlink/?linkid=14202")]
public IntPtr Handle { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public SafeFileHandle SafeFileHandle { get; }
    public string Name { get; }
    public bool IsAsync { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal bool IsClosed { get; }
    private bool HasActiveBufferOperation { get; }
    public bool CanSeek { get; }
    [ObsoleteAttribute("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead.  https://go.microsoft.com/fwlink/?linkid=14202")]
public FileStream(IntPtr handle, FileAccess access);
    [ObsoleteAttribute("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  https://go.microsoft.com/fwlink/?linkid=14202")]
public FileStream(IntPtr handle, FileAccess access, bool ownsHandle);
    [ObsoleteAttribute("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  https://go.microsoft.com/fwlink/?linkid=14202")]
public FileStream(IntPtr handle, FileAccess access, bool ownsHandle, int bufferSize);
    [ObsoleteAttribute("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  https://go.microsoft.com/fwlink/?linkid=14202")]
public FileStream(IntPtr handle, FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);
    public FileStream(SafeFileHandle handle, FileAccess access);
    public FileStream(SafeFileHandle handle, FileAccess access, int bufferSize);
    public FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync);
    public FileStream(string path, FileMode mode);
    public FileStream(string path, FileMode mode, FileAccess access);
    public FileStream(string path, FileMode mode, FileAccess access, FileShare share);
    public FileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize);
    public FileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, bool useAsync);
    public FileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, FileOptions options);
    private static FileStream();
    private void ValidateAndInitFromHandle(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync);
    public virtual IntPtr get_Handle();
    public virtual void Lock(long position, long length);
    public virtual void Unlock(long position, long length);
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] array, int offset, int count);
    [NullableContextAttribute("0")]
public virtual int Read(Span`1<byte> buffer);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    private Task`1<int> ReadAsyncTask(Byte[] array, int offset, int count, CancellationToken cancellationToken);
    public virtual void Write(Byte[] array, int offset, int count);
    [NullableContextAttribute("0")]
public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual void Flush();
    public virtual void Flush(bool flushToDisk);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    private void ValidateReadWriteArgs(Byte[] array, int offset, int count);
    public virtual void SetLength(long value);
    public virtual SafeFileHandle get_SafeFileHandle();
    public virtual string get_Name();
    public virtual bool get_IsAsync();
    public virtual long get_Length();
    private void VerifyOSHandlePosition();
    private void PrepareForReading();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    internal virtual bool get_IsClosed();
    private static bool IsIoRelatedException(Exception e);
    private Byte[] GetBuffer();
    private void OnBufferAllocated();
    private void FlushInternalBuffer();
    private void FlushReadBuffer();
    public virtual int ReadByte();
    public virtual void WriteByte(byte value);
    private void PrepareForWriting();
    protected virtual override void Finalize();
    public virtual IAsyncResult BeginRead(Byte[] array, int offset, int numBytes, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] array, int offset, int numBytes, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    private void Init(FileMode mode, FileShare share, string originalPath);
    private void InitFromHandle(SafeFileHandle handle, FileAccess access, bool useAsyncIO);
    private void InitFromHandleImpl(SafeFileHandle handle, FileAccess access, bool useAsyncIO);
    private static SECURITY_ATTRIBUTES GetSecAttrs(FileShare share);
    private bool get_HasActiveBufferOperation();
    public virtual bool get_CanSeek();
    private long GetLengthInternal();
    protected virtual void Dispose(bool disposing);
    public virtual ValueTask DisposeAsync();
    [AsyncStateMachineAttribute("System.IO.FileStream/<DisposeAsyncCore>d__99")]
private ValueTask DisposeAsyncCore();
    private void FlushOSBuffer();
    private Task FlushWriteAsync(CancellationToken cancellationToken);
    private void FlushWriteBufferForWriteByte();
    private void FlushWriteBuffer(bool calledFromFinalizer);
    private void SetLengthInternal(long value);
    private void SetLengthCore(long value);
    private FileStreamCompletionSource CompareExchangeCurrentOverlappedOwner(FileStreamCompletionSource newSource, FileStreamCompletionSource existingSource);
    private int ReadSpan(Span`1<byte> destination);
    private int FillReadBufferForReadByte();
    private int ReadNative(Span`1<byte> buffer);
    public virtual long Seek(long offset, SeekOrigin origin);
    private long SeekCore(SafeFileHandle fileHandle, long offset, SeekOrigin origin, bool closeInvalidHandle);
    private void WriteSpan(ReadOnlySpan`1<byte> source);
    private void WriteCore(ReadOnlySpan`1<byte> source);
    private Task`1<int> ReadAsyncInternal(Memory`1<byte> destination, CancellationToken cancellationToken, Int32& synchronousResult);
    private Task`1<int> ReadNativeAsync(Memory`1<byte> destination, int numBufferedBytesRead, CancellationToken cancellationToken);
    private ValueTask WriteAsyncInternal(ReadOnlyMemory`1<byte> source, CancellationToken cancellationToken);
    private Task WriteAsyncInternalCore(ReadOnlyMemory`1<byte> source, CancellationToken cancellationToken);
    private int ReadFileNative(SafeFileHandle handle, Span`1<byte> bytes, NativeOverlapped* overlapped, Int32& errorCode);
    private int WriteFileNative(SafeFileHandle handle, ReadOnlySpan`1<byte> buffer, NativeOverlapped* overlapped, Int32& errorCode);
    private int GetLastWin32ErrorAndDisposeHandleIfInvalid();
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.FileStream/<AsyncModeCopyToAsync>d__136")]
private Task AsyncModeCopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    private Task FlushAsyncInternal(CancellationToken cancellationToken);
    private void LockInternal(long position, long length);
    private void UnlockInternal(long position, long length);
    private SafeFileHandle ValidateFileHandle(SafeFileHandle fileHandle);
    private SafeFileHandle OpenHandle(FileMode mode, FileShare share, FileOptions options);
    private SafeFileHandle CreateFileOpenHandle(FileMode mode, FileShare share, FileOptions options);
    private static bool GetDefaultIsAsync(SafeFileHandle handle);
    private static Nullable`1<bool> IsHandleSynchronous(SafeFileHandle fileHandle, bool ignoreInvalid);
    private static void VerifyHandleIsSync(SafeFileHandle handle, int fileType, FileAccess access);
}
[NullableContextAttribute("2")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableAttribute("0")]
public class System.IO.IOException : SystemException {
    public IOException(string message);
    public IOException(string message, int hresult);
    public IOException(string message, Exception innerException);
    [NullableContextAttribute("1")]
protected IOException(SerializationInfo info, StreamingContext context);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.IO.MemoryStream : Stream {
    private Byte[] _buffer;
    private int _origin;
    private int _position;
    private int _length;
    private int _capacity;
    private bool _expandable;
    private bool _writable;
    private bool _exposable;
    private bool _isOpen;
    private Task`1<int> _lastReadTask;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public int Capacity { get; public set; }
    public long Length { get; }
    public long Position { get; public set; }
    public MemoryStream(int capacity);
    public MemoryStream(Byte[] buffer);
    public MemoryStream(Byte[] buffer, bool writable);
    public MemoryStream(Byte[] buffer, int index, int count);
    public MemoryStream(Byte[] buffer, int index, int count, bool writable);
    public MemoryStream(Byte[] buffer, int index, int count, bool writable, bool publiclyVisible);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    private void EnsureNotClosed();
    private void EnsureWriteable();
    protected virtual void Dispose(bool disposing);
    private bool EnsureCapacity(int value);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual Byte[] GetBuffer();
    [NullableContextAttribute("0")]
public virtual bool TryGetBuffer(ArraySegment`1& buffer);
    internal Byte[] InternalGetBuffer();
    internal int InternalGetPosition();
    internal ReadOnlySpan`1<byte> InternalReadSpan(int count);
    internal int InternalEmulateRead(int count);
    public virtual int get_Capacity();
    public virtual void set_Capacity(int value);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    [NullableContextAttribute("0")]
public virtual int Read(Span`1<byte> buffer);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual void CopyTo(Stream destination, int bufferSize);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin loc);
    public virtual void SetLength(long value);
    public virtual Byte[] ToArray();
    public virtual void Write(Byte[] buffer, int offset, int count);
    [NullableContextAttribute("0")]
public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
    public virtual void WriteTo(Stream stream);
}
public static class System.IO.Path : object {
    public static char DirectorySeparatorChar;
    public static char AltDirectorySeparatorChar;
    public static char VolumeSeparatorChar;
    public static char PathSeparator;
    [NullableAttribute("1")]
[ObsoleteAttribute("Please use GetInvalidPathChars or GetInvalidFileNameChars instead.")]
public static Char[] InvalidPathChars;
    private static ReadOnlySpan`1<byte> Base32Char { get; }
    internal static StringComparison StringComparison { get; }
    internal static bool IsCaseSensitive { get; }
    private static Path();
    [NullableContextAttribute("2")]
public static string ChangeExtension(string path, string extension);
    [NullableContextAttribute("2")]
public static string GetDirectoryName(string path);
    public static ReadOnlySpan`1<char> GetDirectoryName(ReadOnlySpan`1<char> path);
    private static int GetDirectoryNameOffset(ReadOnlySpan`1<char> path);
    [NullableContextAttribute("2")]
public static string GetExtension(string path);
    public static ReadOnlySpan`1<char> GetExtension(ReadOnlySpan`1<char> path);
    [NullableContextAttribute("2")]
public static string GetFileName(string path);
    public static ReadOnlySpan`1<char> GetFileName(ReadOnlySpan`1<char> path);
    [NullableContextAttribute("2")]
public static string GetFileNameWithoutExtension(string path);
    public static ReadOnlySpan`1<char> GetFileNameWithoutExtension(ReadOnlySpan`1<char> path);
    [NullableContextAttribute("1")]
public static string GetRandomFileName();
    [NullableContextAttribute("1")]
public static bool IsPathFullyQualified(string path);
    public static bool IsPathFullyQualified(ReadOnlySpan`1<char> path);
    [NullableContextAttribute("2")]
public static bool HasExtension(string path);
    public static bool HasExtension(ReadOnlySpan`1<char> path);
    [NullableContextAttribute("1")]
public static string Combine(string path1, string path2);
    [NullableContextAttribute("1")]
public static string Combine(string path1, string path2, string path3);
    [NullableContextAttribute("1")]
public static string Combine(string path1, string path2, string path3, string path4);
    [NullableContextAttribute("1")]
public static string Combine(String[] paths);
    public static string Join(ReadOnlySpan`1<char> path1, ReadOnlySpan`1<char> path2);
    public static string Join(ReadOnlySpan`1<char> path1, ReadOnlySpan`1<char> path2, ReadOnlySpan`1<char> path3);
    public static string Join(ReadOnlySpan`1<char> path1, ReadOnlySpan`1<char> path2, ReadOnlySpan`1<char> path3, ReadOnlySpan`1<char> path4);
    [NullableContextAttribute("2")]
public static string Join(string path1, string path2);
    [NullableContextAttribute("2")]
public static string Join(string path1, string path2, string path3);
    [NullableContextAttribute("2")]
public static string Join(string path1, string path2, string path3, string path4);
    [NullableContextAttribute("1")]
public static string Join(String[] paths);
    public static bool TryJoin(ReadOnlySpan`1<char> path1, ReadOnlySpan`1<char> path2, Span`1<char> destination, Int32& charsWritten);
    public static bool TryJoin(ReadOnlySpan`1<char> path1, ReadOnlySpan`1<char> path2, ReadOnlySpan`1<char> path3, Span`1<char> destination, Int32& charsWritten);
    private static string CombineInternal(string first, string second);
    private static string CombineInternal(string first, string second, string third);
    private static string CombineInternal(string first, string second, string third, string fourth);
    private static string JoinInternal(ReadOnlySpan`1<char> first, ReadOnlySpan`1<char> second);
    private static string JoinInternal(ReadOnlySpan`1<char> first, ReadOnlySpan`1<char> second, ReadOnlySpan`1<char> third);
    private static string JoinInternal(ReadOnlySpan`1<char> first, ReadOnlySpan`1<char> second, ReadOnlySpan`1<char> third, ReadOnlySpan`1<char> fourth);
    private static ReadOnlySpan`1<byte> get_Base32Char();
    private static void Populate83FileNameFromRandomBytes(Byte* bytes, int byteCount, Span`1<char> chars);
    [NullableContextAttribute("1")]
public static string GetRelativePath(string relativeTo, string path);
    private static string GetRelativePath(string relativeTo, string path, StringComparison comparisonType);
    internal static StringComparison get_StringComparison();
    [NullableContextAttribute("1")]
public static string TrimEndingDirectorySeparator(string path);
    public static ReadOnlySpan`1<char> TrimEndingDirectorySeparator(ReadOnlySpan`1<char> path);
    public static bool EndsInDirectorySeparator(ReadOnlySpan`1<char> path);
    [NullableContextAttribute("1")]
public static bool EndsInDirectorySeparator(string path);
    [NullableContextAttribute("1")]
public static Char[] GetInvalidFileNameChars();
    [NullableContextAttribute("1")]
public static Char[] GetInvalidPathChars();
    [NullableContextAttribute("1")]
public static string GetFullPath(string path);
    [NullableContextAttribute("1")]
public static string GetFullPath(string path, string basePath);
    [NullableContextAttribute("1")]
public static string GetTempPath();
    private static void GetTempPath(ValueStringBuilder& builder);
    [NullableContextAttribute("1")]
public static string GetTempFileName();
    [NullableContextAttribute("2")]
public static bool IsPathRooted(string path);
    public static bool IsPathRooted(ReadOnlySpan`1<char> path);
    [NullableContextAttribute("2")]
public static string GetPathRoot(string path);
    public static ReadOnlySpan`1<char> GetPathRoot(ReadOnlySpan`1<char> path);
    internal static bool get_IsCaseSensitive();
    internal static ReadOnlySpan`1<char> GetVolumeName(ReadOnlySpan`1<char> path);
    internal static int GetUncRootLength(ReadOnlySpan`1<char> path);
}
internal class System.IO.PathHelper : object {
    internal static string Normalize(string path);
    internal static string Normalize(ValueStringBuilder& path);
    private static void GetFullPathName(ReadOnlySpan`1<char> path, ValueStringBuilder& builder);
    internal static int PrependDevicePathChars(ValueStringBuilder& content, bool isDosUnc, ValueStringBuilder& buffer);
    internal static string TryExpandShortFileName(ValueStringBuilder& outputBuilder, string originalPath);
}
internal static class System.IO.PathInternal : object {
    internal static bool StartsWithDirectorySeparator(ReadOnlySpan`1<char> path);
    internal static bool IsRoot(ReadOnlySpan`1<char> path);
    internal static int GetCommonPathLength(string first, string second, bool ignoreCase);
    internal static int EqualStartingCharacterCount(string first, string second, bool ignoreCase);
    internal static bool AreRootsEqual(string first, string second, StringComparison comparisonType);
    internal static string RemoveRelativeSegments(string path, int rootLength);
    internal static bool RemoveRelativeSegments(ReadOnlySpan`1<char> path, int rootLength, ValueStringBuilder& sb);
    internal static bool IsValidDriveChar(char value);
    internal static bool EndsWithPeriodOrSpace(string path);
    internal static string EnsureExtendedPrefixIfNeeded(string path);
    internal static string EnsureExtendedPrefix(string path);
    internal static bool IsDevice(ReadOnlySpan`1<char> path);
    internal static bool IsDeviceUNC(ReadOnlySpan`1<char> path);
    internal static bool IsExtended(ReadOnlySpan`1<char> path);
    internal static int GetRootLength(ReadOnlySpan`1<char> path);
    internal static bool IsPartiallyQualified(ReadOnlySpan`1<char> path);
    internal static bool IsDirectorySeparator(char c);
    internal static string NormalizeDirectorySeparators(string path);
    internal static bool IsEffectivelyEmpty(ReadOnlySpan`1<char> path);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.IO.PathTooLongException : IOException {
    public PathTooLongException(string message);
    public PathTooLongException(string message, Exception innerException);
    [NullableContextAttribute("1")]
protected PathTooLongException(SerializationInfo info, StreamingContext context);
}
internal class System.IO.PinnedBufferMemoryStream : UnmanagedMemoryStream {
    private Byte[] _array;
    private GCHandle _pinningHandle;
    internal PinnedBufferMemoryStream(Byte[] array);
    public virtual int Read(Span`1<byte> buffer);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    protected virtual override void Finalize();
    protected virtual void Dispose(bool disposing);
}
public enum System.IO.SeekOrigin : Enum {
    public int value__;
    public static SeekOrigin Begin;
    public static SeekOrigin Current;
    public static SeekOrigin End;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.IO.Stream : MarshalByRefObject {
    public static Stream Null;
    private ReadWriteTask _activeReadWriteTask;
    private SemaphoreSlim _asyncActiveSemaphore;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    private static Stream();
    private bool HasOverriddenBeginEndRead();
    private bool HasOverriddenBeginEndWrite();
    internal SemaphoreSlim EnsureAsyncActiveSemaphoreInitialized();
    public abstract virtual bool get_CanRead();
    public abstract virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public abstract virtual bool get_CanWrite();
    public abstract virtual long get_Length();
    public abstract virtual long get_Position();
    public abstract virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public Task CopyToAsync(Stream destination);
    public Task CopyToAsync(Stream destination, int bufferSize);
    public Task CopyToAsync(Stream destination, CancellationToken cancellationToken);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.Stream/<CopyToAsyncInternal>d__30")]
private Task CopyToAsyncInternal(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public void CopyTo(Stream destination);
    public virtual void CopyTo(Stream destination, int bufferSize);
    private int GetCopyBufferSize();
    public virtual void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual ValueTask DisposeAsync();
    public abstract virtual void Flush();
    public Task FlushAsync();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    [ObsoleteAttribute("CreateWaitHandle will be removed eventually.  Please use "new ManualResetEvent(false)" instead.")]
protected virtual WaitHandle CreateWaitHandle();
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    internal IAsyncResult BeginReadInternal(Byte[] buffer, int offset, int count, AsyncCallback callback, object state, bool serializeAsynchronously, bool apm);
    public virtual int EndRead(IAsyncResult asyncResult);
    public Task`1<int> ReadAsync(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    private Task`1<int> BeginEndReadAsync(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    internal IAsyncResult BeginWriteInternal(Byte[] buffer, int offset, int count, AsyncCallback callback, object state, bool serializeAsynchronously, bool apm);
    private void RunReadWriteTaskWhenReady(Task asyncWaiter, ReadWriteTask readWriteTask);
    private void RunReadWriteTask(ReadWriteTask readWriteTask);
    private void FinishTrackingAsyncOperation();
    public virtual void EndWrite(IAsyncResult asyncResult);
    public Task WriteAsync(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.Stream/<FinishWriteAsync>d__60")]
private Task FinishWriteAsync(Task writeTask, Byte[] localBuffer);
    private Task BeginEndWriteAsync(Byte[] buffer, int offset, int count);
    public abstract virtual long Seek(long offset, SeekOrigin origin);
    public abstract virtual void SetLength(long value);
    public abstract virtual int Read(Byte[] buffer, int offset, int count);
    [NullableContextAttribute("0")]
public virtual int Read(Span`1<byte> buffer);
    public virtual int ReadByte();
    public abstract virtual void Write(Byte[] buffer, int offset, int count);
    [NullableContextAttribute("0")]
public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual void WriteByte(byte value);
    public static Stream Synchronized(Stream stream);
    [ObsoleteAttribute("Do not call or override this method.")]
protected virtual void ObjectInvariant();
    internal IAsyncResult BlockingBeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    internal static int BlockingEndRead(IAsyncResult asyncResult);
    internal IAsyncResult BlockingBeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    internal static void BlockingEndWrite(IAsyncResult asyncResult);
    [AsyncStateMachineAttribute("System.IO.Stream/<<ReadAsync>g__FinishReadAsync|47_0>d")]
[CompilerGeneratedAttribute]
internal static ValueTask`1<int> <ReadAsync>g__FinishReadAsync|47_0(Task`1<int> readTask, Byte[] localBuffer, Memory`1<byte> localDestination);
}
internal static class System.IO.StreamHelpers : object {
    public static void ValidateCopyToArgs(Stream source, Stream destination, int bufferSize);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.IO.StreamReader : TextReader {
    public static StreamReader Null;
    private Stream _stream;
    private Encoding _encoding;
    private Decoder _decoder;
    private Byte[] _byteBuffer;
    private Char[] _charBuffer;
    private int _charPos;
    private int _charLen;
    private int _byteLen;
    private int _bytePos;
    private int _maxCharsPerBuffer;
    private bool _disposed;
    private bool _detectEncoding;
    private bool _checkPreamble;
    private bool _isBlocked;
    private bool _closable;
    private Task _asyncReadTask;
    public Encoding CurrentEncoding { get; }
    public Stream BaseStream { get; }
    public bool EndOfStream { get; }
    public StreamReader(Stream stream);
    public StreamReader(Stream stream, bool detectEncodingFromByteOrderMarks);
    public StreamReader(Stream stream, Encoding encoding);
    public StreamReader(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks);
    public StreamReader(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);
    public StreamReader(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize, bool leaveOpen);
    public StreamReader(string path);
    public StreamReader(string path, bool detectEncodingFromByteOrderMarks);
    public StreamReader(string path, Encoding encoding);
    public StreamReader(string path, Encoding encoding, bool detectEncodingFromByteOrderMarks);
    public StreamReader(string path, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);
    private static StreamReader();
    private void CheckAsyncTaskInProgress();
    [DoesNotReturnAttribute]
private static void ThrowAsyncIOInProgress();
    private static Stream ValidateArgsAndOpenPath(string path, Encoding encoding, int bufferSize);
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public virtual Encoding get_CurrentEncoding();
    public virtual Stream get_BaseStream();
    public void DiscardBufferedData();
    public bool get_EndOfStream();
    public virtual int Peek();
    public virtual int Read();
    public virtual int Read(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual int Read(Span`1<char> buffer);
    private int ReadSpan(Span`1<char> buffer);
    public virtual string ReadToEnd();
    public virtual int ReadBlock(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual int ReadBlock(Span`1<char> buffer);
    private void CompressBuffer(int n);
    private void DetectEncoding();
    private bool IsPreamble();
    internal virtual int ReadBuffer();
    private int ReadBuffer(Span`1<char> userBuffer, Boolean& readToUserBuffer);
    [NullableContextAttribute("2")]
public virtual string ReadLine();
    public virtual Task`1<string> ReadLineAsync();
    [AsyncStateMachineAttribute("System.IO.StreamReader/<ReadLineAsyncInternal>d__59")]
private Task`1<string> ReadLineAsyncInternal();
    public virtual Task`1<string> ReadToEndAsync();
    [AsyncStateMachineAttribute("System.IO.StreamReader/<ReadToEndAsyncInternal>d__61")]
private Task`1<string> ReadToEndAsyncInternal();
    public virtual Task`1<int> ReadAsync(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual ValueTask`1<int> ReadAsync(Memory`1<char> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.StreamReader/<ReadAsyncInternal>d__64")]
internal virtual ValueTask`1<int> ReadAsyncInternal(Memory`1<char> buffer, CancellationToken cancellationToken);
    public virtual Task`1<int> ReadBlockAsync(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual ValueTask`1<int> ReadBlockAsync(Memory`1<char> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.StreamReader/<ReadBufferAsync>d__67")]
private ValueTask`1<int> ReadBufferAsync(CancellationToken cancellationToken);
    private void ThrowIfDisposed();
    [CompilerGeneratedAttribute]
private void <ThrowIfDisposed>g__ThrowObjectDisposedException|68_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.IO.StreamWriter : TextWriter {
    public static StreamWriter Null;
    private Stream _stream;
    private Encoding _encoding;
    private Encoder _encoder;
    private Byte[] _byteBuffer;
    private Char[] _charBuffer;
    private int _charPos;
    private int _charLen;
    private bool _autoFlush;
    private bool _haveWrittenPreamble;
    private bool _closable;
    private bool _disposed;
    private Task _asyncWriteTask;
    private static Encoding UTF8NoBOM { get; }
    public bool AutoFlush { get; public set; }
    public Stream BaseStream { get; }
    public Encoding Encoding { get; }
    public StreamWriter(Stream stream);
    public StreamWriter(Stream stream, Encoding encoding);
    public StreamWriter(Stream stream, Encoding encoding, int bufferSize);
    public StreamWriter(Stream stream, Encoding encoding, int bufferSize, bool leaveOpen);
    public StreamWriter(string path);
    public StreamWriter(string path, bool append);
    public StreamWriter(string path, bool append, Encoding encoding);
    public StreamWriter(string path, bool append, Encoding encoding, int bufferSize);
    private static StreamWriter();
    private void CheckAsyncTaskInProgress();
    [DoesNotReturnAttribute]
private static void ThrowAsyncIOInProgress();
    private static Encoding get_UTF8NoBOM();
    private static Stream ValidateArgsAndOpenPath(string path, bool append, Encoding encoding, int bufferSize);
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    private void CloseStreamFromDispose(bool disposing);
    public virtual ValueTask DisposeAsync();
    [AsyncStateMachineAttribute("System.IO.StreamWriter/<DisposeAsyncCore>d__33")]
private ValueTask DisposeAsyncCore();
    public virtual void Flush();
    private void Flush(bool flushStream, bool flushEncoder);
    public virtual bool get_AutoFlush();
    public virtual void set_AutoFlush(bool value);
    public virtual Stream get_BaseStream();
    public virtual Encoding get_Encoding();
    public virtual void Write(char value);
    [NullableContextAttribute("2")]
public virtual void Write(Char[] buffer);
    public virtual void Write(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual void Write(ReadOnlySpan`1<char> buffer);
    private void WriteSpan(ReadOnlySpan`1<char> buffer, bool appendNewLine);
    [NullableContextAttribute("2")]
public virtual void Write(string value);
    [NullableContextAttribute("2")]
public virtual void WriteLine(string value);
    [NullableContextAttribute("0")]
public virtual void WriteLine(ReadOnlySpan`1<char> value);
    private void WriteFormatHelper(string format, ParamsArray args, bool appendNewLine);
    public virtual void Write(string format, object arg0);
    [NullableContextAttribute("2")]
public virtual void Write(string format, object arg0, object arg1);
    [NullableContextAttribute("2")]
public virtual void Write(string format, object arg0, object arg1, object arg2);
    public virtual void Write(string format, Object[] arg);
    public virtual void WriteLine(string format, object arg0);
    [NullableContextAttribute("2")]
public virtual void WriteLine(string format, object arg0, object arg1);
    [NullableContextAttribute("2")]
public virtual void WriteLine(string format, object arg0, object arg1, object arg2);
    public virtual void WriteLine(string format, Object[] arg);
    public virtual Task WriteAsync(char value);
    [AsyncStateMachineAttribute("System.IO.StreamWriter/<WriteAsyncInternal>d__61")]
private static Task WriteAsyncInternal(StreamWriter _this, char value, Char[] charBuffer, int charPos, int charLen, Char[] coreNewLine, bool autoFlush, bool appendNewLine);
    public virtual Task WriteAsync(string value);
    [AsyncStateMachineAttribute("System.IO.StreamWriter/<WriteAsyncInternal>d__63")]
private static Task WriteAsyncInternal(StreamWriter _this, string value, Char[] charBuffer, int charPos, int charLen, Char[] coreNewLine, bool autoFlush, bool appendNewLine);
    public virtual Task WriteAsync(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual Task WriteAsync(ReadOnlyMemory`1<char> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.StreamWriter/<WriteAsyncInternal>d__66")]
private static Task WriteAsyncInternal(StreamWriter _this, ReadOnlyMemory`1<char> source, Char[] charBuffer, int charPos, int charLen, Char[] coreNewLine, bool autoFlush, bool appendNewLine, CancellationToken cancellationToken);
    public virtual Task WriteLineAsync();
    public virtual Task WriteLineAsync(char value);
    public virtual Task WriteLineAsync(string value);
    public virtual Task WriteLineAsync(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual Task WriteLineAsync(ReadOnlyMemory`1<char> buffer, CancellationToken cancellationToken);
    public virtual Task FlushAsync();
    private Task FlushAsyncInternal(bool flushStream, bool flushEncoder, Char[] sCharBuffer, int sCharPos, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.StreamWriter/<FlushAsyncInternal>d__74")]
private static Task FlushAsyncInternal(StreamWriter _this, bool flushStream, bool flushEncoder, Char[] charBuffer, int charPos, bool haveWrittenPreamble, Encoding encoding, Encoder encoder, Byte[] byteBuffer, Stream stream, CancellationToken cancellationToken);
    private void ThrowIfDisposed();
    [CompilerGeneratedAttribute]
private void <ThrowIfDisposed>g__ThrowObjectDisposedException|75_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.IO.TextReader : MarshalByRefObject {
    public static TextReader Null;
    private static TextReader();
    public virtual void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual int Peek();
    public virtual int Read();
    public virtual int Read(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual int Read(Span`1<char> buffer);
    public virtual string ReadToEnd();
    public virtual int ReadBlock(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual int ReadBlock(Span`1<char> buffer);
    [NullableContextAttribute("2")]
public virtual string ReadLine();
    public virtual Task`1<string> ReadLineAsync();
    [AsyncStateMachineAttribute("System.IO.TextReader/<ReadToEndAsync>d__14")]
public virtual Task`1<string> ReadToEndAsync();
    public virtual Task`1<int> ReadAsync(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual ValueTask`1<int> ReadAsync(Memory`1<char> buffer, CancellationToken cancellationToken);
    internal virtual ValueTask`1<int> ReadAsyncInternal(Memory`1<char> buffer, CancellationToken cancellationToken);
    public virtual Task`1<int> ReadBlockAsync(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual ValueTask`1<int> ReadBlockAsync(Memory`1<char> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.TextReader/<ReadBlockAsyncInternal>d__20")]
internal ValueTask`1<int> ReadBlockAsyncInternal(Memory`1<char> buffer, CancellationToken cancellationToken);
    public static TextReader Synchronized(TextReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.IO.TextWriter : MarshalByRefObject {
    public static TextWriter Null;
    private static Char[] s_coreNewLine;
    protected Char[] CoreNewLine;
    private string CoreNewLineStr;
    private IFormatProvider _internalFormatProvider;
    public IFormatProvider FormatProvider { get; }
    public Encoding Encoding { get; }
    public string NewLine { get; public set; }
    [NullableContextAttribute("2")]
protected TextWriter(IFormatProvider formatProvider);
    private static TextWriter();
    public virtual IFormatProvider get_FormatProvider();
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    public virtual ValueTask DisposeAsync();
    public virtual void Flush();
    public abstract virtual Encoding get_Encoding();
    public virtual string get_NewLine();
    public virtual void set_NewLine(string value);
    public virtual void Write(char value);
    [NullableContextAttribute("2")]
public virtual void Write(Char[] buffer);
    public virtual void Write(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual void Write(ReadOnlySpan`1<char> buffer);
    public virtual void Write(bool value);
    public virtual void Write(int value);
    [CLSCompliantAttribute("False")]
public virtual void Write(UInt32 value);
    public virtual void Write(long value);
    [CLSCompliantAttribute("False")]
public virtual void Write(ulong value);
    public virtual void Write(float value);
    public virtual void Write(double value);
    public virtual void Write(decimal value);
    [NullableContextAttribute("2")]
public virtual void Write(string value);
    [NullableContextAttribute("2")]
public virtual void Write(object value);
    [NullableContextAttribute("2")]
public virtual void Write(StringBuilder value);
    public virtual void Write(string format, object arg0);
    [NullableContextAttribute("2")]
public virtual void Write(string format, object arg0, object arg1);
    [NullableContextAttribute("2")]
public virtual void Write(string format, object arg0, object arg1, object arg2);
    public virtual void Write(string format, Object[] arg);
    public virtual void WriteLine();
    public virtual void WriteLine(char value);
    [NullableContextAttribute("2")]
public virtual void WriteLine(Char[] buffer);
    public virtual void WriteLine(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual void WriteLine(ReadOnlySpan`1<char> buffer);
    public virtual void WriteLine(bool value);
    public virtual void WriteLine(int value);
    [CLSCompliantAttribute("False")]
public virtual void WriteLine(UInt32 value);
    public virtual void WriteLine(long value);
    [CLSCompliantAttribute("False")]
public virtual void WriteLine(ulong value);
    public virtual void WriteLine(float value);
    public virtual void WriteLine(double value);
    public virtual void WriteLine(decimal value);
    [NullableContextAttribute("2")]
public virtual void WriteLine(string value);
    [NullableContextAttribute("2")]
public virtual void WriteLine(StringBuilder value);
    [NullableContextAttribute("2")]
public virtual void WriteLine(object value);
    public virtual void WriteLine(string format, object arg0);
    [NullableContextAttribute("2")]
public virtual void WriteLine(string format, object arg0, object arg1);
    [NullableContextAttribute("2")]
public virtual void WriteLine(string format, object arg0, object arg1, object arg2);
    public virtual void WriteLine(string format, Object[] arg);
    public virtual Task WriteAsync(char value);
    public virtual Task WriteAsync(string value);
    public virtual Task WriteAsync(StringBuilder value, CancellationToken cancellationToken);
    public Task WriteAsync(Char[] buffer);
    public virtual Task WriteAsync(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual Task WriteAsync(ReadOnlyMemory`1<char> buffer, CancellationToken cancellationToken);
    public virtual Task WriteLineAsync(char value);
    public virtual Task WriteLineAsync(string value);
    public virtual Task WriteLineAsync(StringBuilder value, CancellationToken cancellationToken);
    public Task WriteLineAsync(Char[] buffer);
    public virtual Task WriteLineAsync(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual Task WriteLineAsync(ReadOnlyMemory`1<char> buffer, CancellationToken cancellationToken);
    public virtual Task WriteLineAsync();
    public virtual Task FlushAsync();
    public static TextWriter Synchronized(TextWriter writer);
    [AsyncStateMachineAttribute("System.IO.TextWriter/<<WriteAsync>g__WriteAsyncCore|60_0>d")]
[CompilerGeneratedAttribute]
private Task <WriteAsync>g__WriteAsyncCore|60_0(StringBuilder sb, CancellationToken ct);
    [CompilerGeneratedAttribute]
[AsyncStateMachineAttribute("System.IO.TextWriter/<<WriteLineAsync>g__WriteLineAsyncCore|66_0>d")]
private Task <WriteLineAsync>g__WriteLineAsyncCore|66_0(StringBuilder sb, CancellationToken ct);
}
public class System.IO.UnmanagedMemoryAccessor : object {
    private SafeBuffer _buffer;
    private long _offset;
    private long _capacity;
    private FileAccess _access;
    private bool _isOpen;
    private bool _canRead;
    private bool _canWrite;
    public long Capacity { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    protected bool IsOpen { get; }
    [NullableContextAttribute("1")]
public UnmanagedMemoryAccessor(SafeBuffer buffer, long offset, long capacity);
    [NullableContextAttribute("1")]
public UnmanagedMemoryAccessor(SafeBuffer buffer, long offset, long capacity, FileAccess access);
    [NullableContextAttribute("1")]
protected void Initialize(SafeBuffer buffer, long offset, long capacity, FileAccess access);
    public long get_Capacity();
    public bool get_CanRead();
    public bool get_CanWrite();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    protected bool get_IsOpen();
    public bool ReadBoolean(long position);
    public byte ReadByte(long position);
    public char ReadChar(long position);
    public short ReadInt16(long position);
    public int ReadInt32(long position);
    public long ReadInt64(long position);
    public decimal ReadDecimal(long position);
    public float ReadSingle(long position);
    public double ReadDouble(long position);
    [CLSCompliantAttribute("False")]
public sbyte ReadSByte(long position);
    [CLSCompliantAttribute("False")]
public ushort ReadUInt16(long position);
    [CLSCompliantAttribute("False")]
public UInt32 ReadUInt32(long position);
    [CLSCompliantAttribute("False")]
public ulong ReadUInt64(long position);
    public void Read(long position, T& structure);
    public int ReadArray(long position, T[] array, int offset, int count);
    public void Write(long position, bool value);
    public void Write(long position, byte value);
    public void Write(long position, char value);
    public void Write(long position, short value);
    public void Write(long position, int value);
    public void Write(long position, long value);
    public void Write(long position, decimal value);
    public void Write(long position, float value);
    public void Write(long position, double value);
    [CLSCompliantAttribute("False")]
public void Write(long position, sbyte value);
    [CLSCompliantAttribute("False")]
public void Write(long position, ushort value);
    [CLSCompliantAttribute("False")]
public void Write(long position, UInt32 value);
    [CLSCompliantAttribute("False")]
public void Write(long position, ulong value);
    public void Write(long position, T& structure);
    public void WriteArray(long position, T[] array, int offset, int count);
    private void EnsureSafeToRead(long position, int sizeOfType);
    private void EnsureSafeToWrite(long position, int sizeOfType);
}
public class System.IO.UnmanagedMemoryStream : Stream {
    private SafeBuffer _buffer;
    private Byte* _mem;
    private long _length;
    private long _capacity;
    private long _position;
    private long _offset;
    private FileAccess _access;
    private bool _isOpen;
    private Task`1<int> _lastReadTask;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Capacity { get; }
    public long Position { get; public set; }
    [CLSCompliantAttribute("False")]
public Byte* PositionPointer { get; public set; }
    [NullableContextAttribute("1")]
public UnmanagedMemoryStream(SafeBuffer buffer, long offset, long length);
    [NullableContextAttribute("1")]
public UnmanagedMemoryStream(SafeBuffer buffer, long offset, long length, FileAccess access);
    [CLSCompliantAttribute("False")]
public UnmanagedMemoryStream(Byte* pointer, long length);
    [CLSCompliantAttribute("False")]
public UnmanagedMemoryStream(Byte* pointer, long length, long capacity, FileAccess access);
    [NullableContextAttribute("1")]
protected void Initialize(SafeBuffer buffer, long offset, long length, FileAccess access);
    [CLSCompliantAttribute("False")]
protected void Initialize(Byte* pointer, long length, long capacity, FileAccess access);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    protected virtual void Dispose(bool disposing);
    private void EnsureNotClosed();
    private void EnsureReadable();
    private void EnsureWriteable();
    public virtual void Flush();
    [NullableContextAttribute("1")]
public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual long get_Length();
    public long get_Capacity();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public Byte* get_PositionPointer();
    public void set_PositionPointer(Byte* value);
    [NullableContextAttribute("1")]
public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int Read(Span`1<byte> buffer);
    internal int ReadCore(Span`1<byte> buffer);
    [NullableContextAttribute("1")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin loc);
    public virtual void SetLength(long value);
    [NullableContextAttribute("1")]
public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    internal void WriteCore(ReadOnlySpan`1<byte> buffer);
    [NullableContextAttribute("1")]
public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
}
internal class System.IO.UnmanagedMemoryStreamWrapper : MemoryStream {
    private UnmanagedMemoryStream _unmanagedStream;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public int Capacity { get; public set; }
    public long Length { get; }
    public long Position { get; public set; }
    internal UnmanagedMemoryStreamWrapper(UnmanagedMemoryStream stream);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    public virtual Byte[] GetBuffer();
    public virtual bool TryGetBuffer(ArraySegment`1& buffer);
    public virtual int get_Capacity();
    public virtual void set_Capacity(int value);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int Read(Span`1<byte> buffer);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin loc);
    public virtual Byte[] ToArray();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual void WriteByte(byte value);
    public virtual void WriteTo(Stream stream);
    public virtual void SetLength(long value);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
}
internal static class System.IO.Win32Marshal : object {
    internal static Exception GetExceptionForLastWin32Error(string path);
    internal static Exception GetExceptionForWin32Error(int errorCode, string path);
    internal static int MakeHRFromErrorCode(int errorCode);
    internal static string GetMessage(int errorCode);
}
[NullableContextAttribute("1")]
public interface System.IObservable`1 {
    public abstract virtual IDisposable Subscribe(IObserver`1<T> observer);
}
[NullableContextAttribute("1")]
public interface System.IObserver`1 {
    public abstract virtual void OnNext(T value);
    public abstract virtual void OnError(Exception error);
    public abstract virtual void OnCompleted();
}
[NullableContextAttribute("1")]
public interface System.IProgress`1 {
    public abstract virtual void Report(T value);
}
internal interface System.IRuntimeFieldInfo {
    public RuntimeFieldHandleInternal Value { get; }
    public abstract virtual RuntimeFieldHandleInternal get_Value();
}
internal interface System.IRuntimeMethodInfo {
    public RuntimeMethodHandleInternal Value { get; }
    public abstract virtual RuntimeMethodHandleInternal get_Value();
}
internal interface System.ISpanFormattable {
    public abstract virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
}
internal interface System.ITupleInternal {
    public abstract virtual string ToString(StringBuilder sb);
    public abstract virtual int GetHashCode(IEqualityComparer comparer);
}
internal interface System.IValueTupleInternal {
    public abstract virtual int GetHashCode(IEqualityComparer comparer);
    public abstract virtual string ToStringEnd();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerTypeProxyAttribute("System.LazyDebugView`1")]
[DebuggerDisplayAttribute("ThreadSafetyMode={Mode}, IsValueCreated={IsValueCreated}, IsValueFaulted={IsValueFaulted}, Value={ValueForDebugDisplay}")]
public class System.Lazy`1 : object {
    private LazyHelper modreq(System.Runtime.CompilerServices.IsVolatile) _state;
    private Func`1<T> _factory;
    private T _value;
    internal T ValueForDebugDisplay { get; }
    internal Nullable`1<LazyThreadSafetyMode> Mode { get; }
    internal bool IsValueFaulted { get; }
    public bool IsValueCreated { get; }
    [DebuggerBrowsableAttribute("0")]
public T Value { get; }
    public Lazy`1(T value);
    public Lazy`1(Func`1<T> valueFactory);
    public Lazy`1(bool isThreadSafe);
    public Lazy`1(LazyThreadSafetyMode mode);
    public Lazy`1(Func`1<T> valueFactory, bool isThreadSafe);
    public Lazy`1(Func`1<T> valueFactory, LazyThreadSafetyMode mode);
    private Lazy`1(Func`1<T> valueFactory, LazyThreadSafetyMode mode, bool useDefaultConstructor);
    private static T CreateViaDefaultConstructor();
    private void ViaConstructor();
    private void ViaFactory(LazyThreadSafetyMode mode);
    private void ExecutionAndPublication(LazyHelper executionAndPublication, bool useDefaultConstructor);
    private void PublicationOnly(LazyHelper publicationOnly, T possibleValue);
    private void PublicationOnlyViaConstructor(LazyHelper initializer);
    private void PublicationOnlyViaFactory(LazyHelper initializer);
    private void PublicationOnlyWaitForOtherThreadToPublish();
    private T CreateValue();
    [NullableContextAttribute("2")]
public virtual string ToString();
    internal T get_ValueForDebugDisplay();
    internal Nullable`1<LazyThreadSafetyMode> get_Mode();
    internal bool get_IsValueFaulted();
    public bool get_IsValueCreated();
    public T get_Value();
}
internal class System.LazyDebugView`1 : object {
    private Lazy`1<T> _lazy;
    public bool IsValueCreated { get; }
    public T Value { get; }
    public Nullable`1<LazyThreadSafetyMode> Mode { get; }
    public bool IsValueFaulted { get; }
    public LazyDebugView`1(Lazy`1<T> lazy);
    public bool get_IsValueCreated();
    public T get_Value();
    public Nullable`1<LazyThreadSafetyMode> get_Mode();
    public bool get_IsValueFaulted();
}
internal class System.LazyHelper : object {
    internal static LazyHelper NoneViaConstructor;
    internal static LazyHelper NoneViaFactory;
    internal static LazyHelper PublicationOnlyViaConstructor;
    internal static LazyHelper PublicationOnlyViaFactory;
    internal static LazyHelper PublicationOnlyWaitForOtherThreadToPublish;
    [CompilerGeneratedAttribute]
private LazyState <State>k__BackingField;
    private ExceptionDispatchInfo _exceptionDispatch;
    internal LazyState State { get; }
    internal LazyHelper(LazyState state);
    internal LazyHelper(LazyThreadSafetyMode mode, Exception exception);
    private static LazyHelper();
    [CompilerGeneratedAttribute]
internal LazyState get_State();
    [DoesNotReturnAttribute]
internal void ThrowException();
    private LazyThreadSafetyMode GetMode();
    internal static Nullable`1<LazyThreadSafetyMode> GetMode(LazyHelper state);
    internal static bool GetIsValueFaulted(LazyHelper state);
    internal static LazyHelper Create(LazyThreadSafetyMode mode, bool useDefaultConstructor);
    internal static T CreateViaDefaultConstructor();
    internal static LazyThreadSafetyMode GetModeFromIsThreadSafe(bool isThreadSafe);
}
internal enum System.LazyState : Enum {
    public int value__;
    public static LazyState NoneViaConstructor;
    public static LazyState NoneViaFactory;
    public static LazyState NoneException;
    public static LazyState PublicationOnlyViaConstructor;
    public static LazyState PublicationOnlyViaFactory;
    public static LazyState PublicationOnlyWait;
    public static LazyState PublicationOnlyException;
    public static LazyState ExecutionAndPublicationViaConstructor;
    public static LazyState ExecutionAndPublicationViaFactory;
    public static LazyState ExecutionAndPublicationException;
}
internal static class System.LocalAppContextSwitches : object {
    private static int s_enforceJapaneseEraYearRanges;
    private static int s_formatJapaneseFirstYearAsANumber;
    private static int s_enforceLegacyJapaneseDateParsing;
    private static int s_preserveEventListnerObjectIdentity;
    private static int s_serializationGuard;
    public static bool EnforceJapaneseEraYearRanges { get; }
    public static bool FormatJapaneseFirstYearAsANumber { get; }
    public static bool EnforceLegacyJapaneseDateParsing { get; }
    public static bool PreserveEventListnerObjectIdentity { get; }
    public static bool SerializationGuard { get; }
    public static bool get_EnforceJapaneseEraYearRanges();
    public static bool get_FormatJapaneseFirstYearAsANumber();
    public static bool get_EnforceLegacyJapaneseDateParsing();
    public static bool get_PreserveEventListnerObjectIdentity();
    public static bool get_SerializationGuard();
    internal static bool GetCachedSwitchValue(string switchName, Int32& cachedSwitchValue);
    private static bool GetCachedSwitchValueInternal(string switchName, Int32& cachedSwitchValue);
    private static bool GetSwitchDefaultValue(string switchName);
}
public class System.LocalDataStoreSlot : object {
    [CompilerGeneratedAttribute]
private ThreadLocal`1<object> <Data>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal ThreadLocal`1<object> Data { get; private set; }
    internal LocalDataStoreSlot(ThreadLocal`1<object> data);
    [CompilerGeneratedAttribute]
internal ThreadLocal`1<object> get_Data();
    [CompilerGeneratedAttribute]
private void set_Data(ThreadLocal`1<object> value);
    protected virtual override void Finalize();
}
[ComVisibleAttribute("True")]
[ClassInterfaceAttribute("1")]
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.MarshalByRefObject : object {
    public object GetLifetimeService();
    public virtual object InitializeLifetimeService();
    protected MarshalByRefObject MemberwiseClone(bool cloneIdentity);
}
internal static class System.Marvin : object {
    [CompilerGeneratedAttribute]
private static ulong <DefaultSeed>k__BackingField;
    public static ulong DefaultSeed { get; }
    private static Marvin();
    public static int ComputeHash32(ReadOnlySpan`1<byte> data, ulong seed);
    public static int ComputeHash32(Byte& data, UInt32 count, UInt32 p0, UInt32 p1);
    private static void Block(UInt32& rp0, UInt32& rp1);
    [CompilerGeneratedAttribute]
public static ulong get_DefaultSeed();
    private static ulong GenerateSeed();
    public static int ComputeHash32OrdinalIgnoreCase(Char& data, int count, UInt32 p0, UInt32 p1);
    private static int ComputeHash32OrdinalIgnoreCaseSlow(Char& data, int count, UInt32 p0, UInt32 p1);
}
public static class System.Math : object {
    public static double E;
    public static double PI;
    private static Double[] roundPower10Double;
    private static Math();
    public static double Abs(double value);
    public static float Abs(float value);
    public static double Acos(double d);
    public static double Acosh(double d);
    public static double Asin(double d);
    public static double Asinh(double d);
    public static double Atan(double d);
    public static double Atan2(double y, double x);
    public static double Atanh(double d);
    public static double Cbrt(double d);
    public static double Ceiling(double a);
    public static double Cos(double d);
    public static double Cosh(double value);
    public static double Exp(double d);
    public static double Floor(double d);
    [IntrinsicAttribute]
public static double FusedMultiplyAdd(double x, double y, double z);
    public static int ILogB(double x);
    public static double Log(double d);
    public static double Log2(double x);
    public static double Log10(double d);
    public static double Pow(double x, double y);
    public static double ScaleB(double x, int n);
    public static double Sin(double a);
    public static double Sinh(double value);
    public static double Sqrt(double d);
    public static double Tan(double a);
    public static double Tanh(double value);
    private static double ModF(double x, Double* intptr);
    public static short Abs(short value);
    public static int Abs(int value);
    public static long Abs(long value);
    [CLSCompliantAttribute("False")]
public static sbyte Abs(sbyte value);
    public static decimal Abs(decimal value);
    [DoesNotReturnAttribute]
[StackTraceHiddenAttribute]
private static void ThrowAbsOverflow();
    public static long BigMul(int a, int b);
    public static double BitDecrement(double x);
    public static double BitIncrement(double x);
    public static double CopySign(double x, double y);
    public static int DivRem(int a, int b, Int32& result);
    public static long DivRem(long a, long b, Int64& result);
    internal static UInt32 DivRem(UInt32 a, UInt32 b, UInt32& result);
    internal static ulong DivRem(ulong a, ulong b, UInt64& result);
    public static decimal Ceiling(decimal d);
    public static byte Clamp(byte value, byte min, byte max);
    public static decimal Clamp(decimal value, decimal min, decimal max);
    public static double Clamp(double value, double min, double max);
    public static short Clamp(short value, short min, short max);
    public static int Clamp(int value, int min, int max);
    public static long Clamp(long value, long min, long max);
    [CLSCompliantAttribute("False")]
public static sbyte Clamp(sbyte value, sbyte min, sbyte max);
    public static float Clamp(float value, float min, float max);
    [CLSCompliantAttribute("False")]
public static ushort Clamp(ushort value, ushort min, ushort max);
    [CLSCompliantAttribute("False")]
public static UInt32 Clamp(UInt32 value, UInt32 min, UInt32 max);
    [CLSCompliantAttribute("False")]
public static ulong Clamp(ulong value, ulong min, ulong max);
    public static decimal Floor(decimal d);
    public static double IEEERemainder(double x, double y);
    public static double Log(double a, double newBase);
    [NonVersionableAttribute]
public static byte Max(byte val1, byte val2);
    public static decimal Max(decimal val1, decimal val2);
    public static double Max(double val1, double val2);
    [NonVersionableAttribute]
public static short Max(short val1, short val2);
    [NonVersionableAttribute]
public static int Max(int val1, int val2);
    [NonVersionableAttribute]
public static long Max(long val1, long val2);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static sbyte Max(sbyte val1, sbyte val2);
    public static float Max(float val1, float val2);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static ushort Max(ushort val1, ushort val2);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static UInt32 Max(UInt32 val1, UInt32 val2);
    [NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static ulong Max(ulong val1, ulong val2);
    public static double MaxMagnitude(double x, double y);
    [NonVersionableAttribute]
public static byte Min(byte val1, byte val2);
    public static decimal Min(decimal val1, decimal val2);
    public static double Min(double val1, double val2);
    [NonVersionableAttribute]
public static short Min(short val1, short val2);
    [NonVersionableAttribute]
public static int Min(int val1, int val2);
    [NonVersionableAttribute]
public static long Min(long val1, long val2);
    [NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static sbyte Min(sbyte val1, sbyte val2);
    public static float Min(float val1, float val2);
    [NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static ushort Min(ushort val1, ushort val2);
    [NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static UInt32 Min(UInt32 val1, UInt32 val2);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static ulong Min(ulong val1, ulong val2);
    public static double MinMagnitude(double x, double y);
    public static decimal Round(decimal d);
    public static decimal Round(decimal d, int decimals);
    public static decimal Round(decimal d, MidpointRounding mode);
    public static decimal Round(decimal d, int decimals, MidpointRounding mode);
    [IntrinsicAttribute]
public static double Round(double a);
    public static double Round(double value, int digits);
    public static double Round(double value, MidpointRounding mode);
    public static double Round(double value, int digits, MidpointRounding mode);
    public static int Sign(decimal value);
    public static int Sign(double value);
    public static int Sign(short value);
    public static int Sign(int value);
    public static int Sign(long value);
    [CLSCompliantAttribute("False")]
public static int Sign(sbyte value);
    public static int Sign(float value);
    public static decimal Truncate(decimal d);
    public static double Truncate(double d);
    [DoesNotReturnAttribute]
private static void ThrowMinMaxException(T min, T max);
}
public static class System.MathF : object {
    public static float E;
    public static float PI;
    private static Single[] roundPower10Single;
    private static MathF();
    public static float Acos(float x);
    public static float Acosh(float x);
    public static float Asin(float x);
    public static float Asinh(float x);
    public static float Atan(float x);
    public static float Atan2(float y, float x);
    public static float Atanh(float x);
    public static float Cbrt(float x);
    public static float Ceiling(float x);
    public static float Cos(float x);
    public static float Cosh(float x);
    public static float Exp(float x);
    public static float Floor(float x);
    [IntrinsicAttribute]
public static float FusedMultiplyAdd(float x, float y, float z);
    public static int ILogB(float x);
    public static float Log(float x);
    public static float Log2(float x);
    public static float Log10(float x);
    public static float Pow(float x, float y);
    public static float ScaleB(float x, int n);
    public static float Sin(float x);
    public static float Sinh(float x);
    public static float Sqrt(float x);
    public static float Tan(float x);
    public static float Tanh(float x);
    private static float ModF(float x, Single* intptr);
    public static float Abs(float x);
    public static float BitDecrement(float x);
    public static float BitIncrement(float x);
    public static float CopySign(float x, float y);
    public static float IEEERemainder(float x, float y);
    public static float Log(float x, float y);
    public static float Max(float x, float y);
    public static float MaxMagnitude(float x, float y);
    public static float Min(float x, float y);
    public static float MinMagnitude(float x, float y);
    [IntrinsicAttribute]
public static float Round(float x);
    public static float Round(float x, int digits);
    public static float Round(float x, MidpointRounding mode);
    public static float Round(float x, int digits, MidpointRounding mode);
    public static int Sign(float x);
    public static float Truncate(float x);
}
[IsReadOnlyAttribute]
internal class System.MdUtf8String : ValueType {
    private Byte* m_pStringHeap;
    private int m_StringHeapByteLength;
    internal MdUtf8String(Void* pStringHeap);
    internal MdUtf8String(Byte* pUtf8String, int cUtf8String);
    private static bool EqualsCaseInsensitive(Void* szLhs, Void* szRhs, int cSz);
    private static UInt32 HashCaseInsensitive(Void* sz, int cSz);
    internal bool Equals(MdUtf8String s);
    internal bool EqualsCaseInsensitive(MdUtf8String s);
    internal UInt32 HashCaseInsensitive();
    public virtual string ToString();
}
[NullableAttribute("0")]
[NullableContextAttribute("2")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.MemberAccessException : SystemException {
    public MemberAccessException(string message);
    public MemberAccessException(string message, Exception inner);
    [NullableContextAttribute("1")]
protected MemberAccessException(SerializationInfo info, StreamingContext context);
}
[DebuggerTypeProxyAttribute("System.MemoryDebugView`1")]
[DebuggerDisplayAttribute("{ToString(),raw}")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public class System.Memory`1 : ValueType {
    private object _object;
    private int _index;
    private int _length;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Memory`1<T> Empty { get; }
    public int Length { get; }
    public bool IsEmpty { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Span`1<T> Span { get; }
    public Memory`1(T[] array);
    internal Memory`1(T[] array, int start);
    public Memory`1(T[] array, int start, int length);
    internal Memory`1(MemoryManager`1<T> manager, int length);
    internal Memory`1(MemoryManager`1<T> manager, int start, int length);
    internal Memory`1(object obj, int start, int length);
    public static Memory`1<T> op_Implicit(T[] array);
    public static Memory`1<T> op_Implicit(ArraySegment`1<T> segment);
    public static ReadOnlyMemory`1<T> op_Implicit(Memory`1<T> memory);
    public static Memory`1<T> get_Empty();
    public int get_Length();
    public bool get_IsEmpty();
    public virtual string ToString();
    public Memory`1<T> Slice(int start);
    public Memory`1<T> Slice(int start, int length);
    public Span`1<T> get_Span();
    public void CopyTo(Memory`1<T> destination);
    public bool TryCopyTo(Memory`1<T> destination);
    public MemoryHandle Pin();
    public T[] ToArray();
    [NullableContextAttribute("2")]
[EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Memory`1<T> other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
}
internal class System.MemoryDebugView`1 : object {
    private ReadOnlyMemory`1<T> _memory;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public MemoryDebugView`1(Memory`1<T> memory);
    public MemoryDebugView`1(ReadOnlyMemory`1<T> memory);
    public T[] get_Items();
}
[ExtensionAttribute]
public static class System.MemoryExtensions : object {
    [ExtensionAttribute]
public static bool IsWhiteSpace(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
public static bool Contains(Span`1<T> span, T value);
    [ExtensionAttribute]
public static bool Contains(ReadOnlySpan`1<T> span, T value);
    [ExtensionAttribute]
public static int IndexOf(Span`1<T> span, T value);
    [ExtensionAttribute]
public static int IndexOf(Span`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static int LastIndexOf(Span`1<T> span, T value);
    [ExtensionAttribute]
public static int LastIndexOf(Span`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static bool SequenceEqual(Span`1<T> span, ReadOnlySpan`1<T> other);
    [ExtensionAttribute]
public static int SequenceCompareTo(Span`1<T> span, ReadOnlySpan`1<T> other);
    [ExtensionAttribute]
public static int IndexOf(ReadOnlySpan`1<T> span, T value);
    [ExtensionAttribute]
public static int IndexOf(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static int LastIndexOf(ReadOnlySpan`1<T> span, T value);
    [ExtensionAttribute]
public static int LastIndexOf(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static int IndexOfAny(Span`1<T> span, T value0, T value1);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int IndexOfAny(Span`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
public static int IndexOfAny(Span`1<T> span, ReadOnlySpan`1<T> values);
    [ExtensionAttribute]
public static int IndexOfAny(ReadOnlySpan`1<T> span, T value0, T value1);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int IndexOfAny(ReadOnlySpan`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
public static int IndexOfAny(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> values);
    [ExtensionAttribute]
public static int LastIndexOfAny(Span`1<T> span, T value0, T value1);
    [ExtensionAttribute]
[NullableContextAttribute("1")]
public static int LastIndexOfAny(Span`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
public static int LastIndexOfAny(Span`1<T> span, ReadOnlySpan`1<T> values);
    [ExtensionAttribute]
public static int LastIndexOfAny(ReadOnlySpan`1<T> span, T value0, T value1);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int LastIndexOfAny(ReadOnlySpan`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
public static int LastIndexOfAny(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> values);
    [ExtensionAttribute]
public static bool SequenceEqual(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other);
    [ExtensionAttribute]
public static int SequenceCompareTo(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other);
    [ExtensionAttribute]
public static bool StartsWith(Span`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static bool StartsWith(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static bool EndsWith(Span`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static bool EndsWith(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static SpanRuneEnumerator EnumerateRunes(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
public static SpanRuneEnumerator EnumerateRunes(Span`1<char> span);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static void Reverse(Span`1<T> span);
    [ExtensionAttribute]
[NullableContextAttribute("2")]
public static Span`1<T> AsSpan(T[] array);
    [ExtensionAttribute]
[NullableContextAttribute("2")]
public static Span`1<T> AsSpan(T[] array, int start, int length);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Span`1<T> AsSpan(ArraySegment`1<T> segment);
    [ExtensionAttribute]
[NullableContextAttribute("2")]
public static Span`1<T> AsSpan(ArraySegment`1<T> segment, int start);
    [ExtensionAttribute]
[NullableContextAttribute("2")]
public static Span`1<T> AsSpan(ArraySegment`1<T> segment, Index startIndex);
    [ExtensionAttribute]
[NullableContextAttribute("2")]
public static Span`1<T> AsSpan(ArraySegment`1<T> segment, int start, int length);
    [ExtensionAttribute]
[NullableContextAttribute("2")]
public static Span`1<T> AsSpan(ArraySegment`1<T> segment, Range range);
    [ExtensionAttribute]
[NullableContextAttribute("2")]
public static Memory`1<T> AsMemory(T[] array);
    [ExtensionAttribute]
[NullableContextAttribute("2")]
public static Memory`1<T> AsMemory(T[] array, int start);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Memory`1<T> AsMemory(T[] array, Index startIndex);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Memory`1<T> AsMemory(T[] array, int start, int length);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Memory`1<T> AsMemory(T[] array, Range range);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Memory`1<T> AsMemory(ArraySegment`1<T> segment);
    [ExtensionAttribute]
[NullableContextAttribute("2")]
public static Memory`1<T> AsMemory(ArraySegment`1<T> segment, int start);
    [ExtensionAttribute]
[NullableContextAttribute("2")]
public static Memory`1<T> AsMemory(ArraySegment`1<T> segment, int start, int length);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static void CopyTo(T[] source, Span`1<T> destination);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static void CopyTo(T[] source, Memory`1<T> destination);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool Overlaps(Span`1<T> span, ReadOnlySpan`1<T> other);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool Overlaps(Span`1<T> span, ReadOnlySpan`1<T> other, Int32& elementOffset);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool Overlaps(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool Overlaps(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other, Int32& elementOffset);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int BinarySearch(Span`1<T> span, IComparable`1<T> comparable);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int BinarySearch(Span`1<T> span, TComparable comparable);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int BinarySearch(Span`1<T> span, T value, TComparer comparer);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int BinarySearch(ReadOnlySpan`1<T> span, IComparable`1<T> comparable);
    [ExtensionAttribute]
[NullableContextAttribute("1")]
public static int BinarySearch(ReadOnlySpan`1<T> span, TComparable comparable);
    [ExtensionAttribute]
[NullableContextAttribute("1")]
public static int BinarySearch(ReadOnlySpan`1<T> span, T value, TComparer comparer);
    [ExtensionAttribute]
public static bool Contains(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType);
    [ExtensionAttribute]
public static bool Equals(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> other, StringComparison comparisonType);
    [ExtensionAttribute]
internal static bool EqualsOrdinal(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value);
    [ExtensionAttribute]
internal static bool EqualsOrdinalIgnoreCase(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value);
    [ExtensionAttribute]
public static int CompareTo(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> other, StringComparison comparisonType);
    [ExtensionAttribute]
public static int IndexOf(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType);
    [ExtensionAttribute]
public static int LastIndexOf(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType);
    [ExtensionAttribute]
public static int ToLower(ReadOnlySpan`1<char> source, Span`1<char> destination, CultureInfo culture);
    [ExtensionAttribute]
public static int ToLowerInvariant(ReadOnlySpan`1<char> source, Span`1<char> destination);
    [ExtensionAttribute]
public static int ToUpper(ReadOnlySpan`1<char> source, Span`1<char> destination, CultureInfo culture);
    [ExtensionAttribute]
public static int ToUpperInvariant(ReadOnlySpan`1<char> source, Span`1<char> destination);
    [ExtensionAttribute]
public static bool EndsWith(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType);
    [ExtensionAttribute]
public static bool StartsWith(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType);
    [ExtensionAttribute]
[NullableContextAttribute("2")]
public static Span`1<T> AsSpan(T[] array, int start);
    [ExtensionAttribute]
[NullableContextAttribute("2")]
public static Span`1<T> AsSpan(T[] array, Index startIndex);
    [ExtensionAttribute]
[NullableContextAttribute("2")]
public static Span`1<T> AsSpan(T[] array, Range range);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> AsSpan(string text);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> AsSpan(string text, int start);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> AsSpan(string text, int start, int length);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> AsMemory(string text);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> AsMemory(string text, int start);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> AsMemory(string text, Index startIndex);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> AsMemory(string text, int start, int length);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> AsMemory(string text, Range range);
    [ExtensionAttribute]
public static Memory`1<T> Trim(Memory`1<T> memory, T trimElement);
    [ExtensionAttribute]
public static Memory`1<T> TrimStart(Memory`1<T> memory, T trimElement);
    [ExtensionAttribute]
public static Memory`1<T> TrimEnd(Memory`1<T> memory, T trimElement);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<T> Trim(ReadOnlyMemory`1<T> memory, T trimElement);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<T> TrimStart(ReadOnlyMemory`1<T> memory, T trimElement);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<T> TrimEnd(ReadOnlyMemory`1<T> memory, T trimElement);
    [ExtensionAttribute]
public static Span`1<T> Trim(Span`1<T> span, T trimElement);
    [ExtensionAttribute]
public static Span`1<T> TrimStart(Span`1<T> span, T trimElement);
    [ExtensionAttribute]
public static Span`1<T> TrimEnd(Span`1<T> span, T trimElement);
    [ExtensionAttribute]
public static ReadOnlySpan`1<T> Trim(ReadOnlySpan`1<T> span, T trimElement);
    [ExtensionAttribute]
public static ReadOnlySpan`1<T> TrimStart(ReadOnlySpan`1<T> span, T trimElement);
    [ExtensionAttribute]
public static ReadOnlySpan`1<T> TrimEnd(ReadOnlySpan`1<T> span, T trimElement);
    private static int ClampStart(ReadOnlySpan`1<T> span, T trimElement);
    private static int ClampEnd(ReadOnlySpan`1<T> span, int start, T trimElement);
    [ExtensionAttribute]
public static Memory`1<T> Trim(Memory`1<T> memory, ReadOnlySpan`1<T> trimElements);
    [ExtensionAttribute]
public static Memory`1<T> TrimStart(Memory`1<T> memory, ReadOnlySpan`1<T> trimElements);
    [ExtensionAttribute]
public static Memory`1<T> TrimEnd(Memory`1<T> memory, ReadOnlySpan`1<T> trimElements);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<T> Trim(ReadOnlyMemory`1<T> memory, ReadOnlySpan`1<T> trimElements);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<T> TrimStart(ReadOnlyMemory`1<T> memory, ReadOnlySpan`1<T> trimElements);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<T> TrimEnd(ReadOnlyMemory`1<T> memory, ReadOnlySpan`1<T> trimElements);
    [ExtensionAttribute]
public static Span`1<T> Trim(Span`1<T> span, ReadOnlySpan`1<T> trimElements);
    [ExtensionAttribute]
public static Span`1<T> TrimStart(Span`1<T> span, ReadOnlySpan`1<T> trimElements);
    [ExtensionAttribute]
public static Span`1<T> TrimEnd(Span`1<T> span, ReadOnlySpan`1<T> trimElements);
    [ExtensionAttribute]
public static ReadOnlySpan`1<T> Trim(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> trimElements);
    [ExtensionAttribute]
public static ReadOnlySpan`1<T> TrimStart(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> trimElements);
    [ExtensionAttribute]
public static ReadOnlySpan`1<T> TrimEnd(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> trimElements);
    private static int ClampStart(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> trimElements);
    private static int ClampEnd(ReadOnlySpan`1<T> span, int start, ReadOnlySpan`1<T> trimElements);
    [ExtensionAttribute]
public static Memory`1<char> Trim(Memory`1<char> memory);
    [ExtensionAttribute]
public static Memory`1<char> TrimStart(Memory`1<char> memory);
    [ExtensionAttribute]
public static Memory`1<char> TrimEnd(Memory`1<char> memory);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> Trim(ReadOnlyMemory`1<char> memory);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> TrimStart(ReadOnlyMemory`1<char> memory);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> TrimEnd(ReadOnlyMemory`1<char> memory);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> Trim(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimStart(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimEnd(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> Trim(ReadOnlySpan`1<char> span, char trimChar);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimStart(ReadOnlySpan`1<char> span, char trimChar);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimEnd(ReadOnlySpan`1<char> span, char trimChar);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> Trim(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> trimChars);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimStart(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> trimChars);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimEnd(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> trimChars);
    [ExtensionAttribute]
public static Span`1<char> Trim(Span`1<char> span);
    [ExtensionAttribute]
public static Span`1<char> TrimStart(Span`1<char> span);
    [ExtensionAttribute]
public static Span`1<char> TrimEnd(Span`1<char> span);
    private static int ClampStart(ReadOnlySpan`1<char> span);
    private static int ClampEnd(ReadOnlySpan`1<char> span, int start);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.MethodAccessException : MemberAccessException {
    public MethodAccessException(string message);
    public MethodAccessException(string message, Exception inner);
    [NullableContextAttribute("1")]
protected MethodAccessException(SerializationInfo info, StreamingContext context);
}
public enum System.MidpointRounding : Enum {
    public int value__;
    public static MidpointRounding ToEven;
    public static MidpointRounding AwayFromZero;
    public static MidpointRounding ToZero;
    public static MidpointRounding ToNegativeInfinity;
    public static MidpointRounding ToPositiveInfinity;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.MissingFieldException : MissingMemberException {
    public string Message { get; }
    [NullableContextAttribute("2")]
public MissingFieldException(string message);
    [NullableContextAttribute("2")]
public MissingFieldException(string message, Exception inner);
    [NullableContextAttribute("2")]
public MissingFieldException(string className, string fieldName);
    protected MissingFieldException(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
}
[NullableAttribute("0")]
[NullableContextAttribute("2")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.MissingMemberException : MemberAccessException {
    protected string ClassName;
    protected string MemberName;
    protected Byte[] Signature;
    [NullableAttribute("1")]
public string Message { get; }
    public MissingMemberException(string message);
    public MissingMemberException(string message, Exception inner);
    public MissingMemberException(string className, string memberName);
    [NullableContextAttribute("1")]
protected MissingMemberException(SerializationInfo info, StreamingContext context);
    internal static string FormatSignature(Byte[] signature);
    [NullableContextAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("1")]
public virtual string get_Message();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.MissingMethodException : MissingMemberException {
    public string Message { get; }
    [NullableContextAttribute("2")]
public MissingMethodException(string message);
    [NullableContextAttribute("2")]
public MissingMethodException(string message, Exception inner);
    [NullableContextAttribute("2")]
public MissingMethodException(string className, string methodName);
    protected MissingMethodException(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
}
[NullableAttribute("0")]
[NullableContextAttribute("2")]
public class System.ModuleHandle : ValueType {
    public static ModuleHandle EmptyHandle;
    private RuntimeModule m_ptr;
    public int MDStreamVersion { get; }
    internal ModuleHandle(RuntimeModule module);
    private static ModuleHandle();
    private static ModuleHandle GetEmptyMH();
    internal RuntimeModule GetRuntimeModule();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(ModuleHandle handle);
    public static bool op_Equality(ModuleHandle left, ModuleHandle right);
    public static bool op_Inequality(ModuleHandle left, ModuleHandle right);
    internal static IRuntimeMethodInfo GetDynamicMethod(DynamicMethod method, RuntimeModule module, string name, Byte[] sig, Resolver resolver);
    internal static int GetToken(RuntimeModule module);
    private static void ValidateModulePointer(RuntimeModule module);
    public RuntimeTypeHandle GetRuntimeTypeHandleFromMetadataToken(int typeToken);
    public RuntimeTypeHandle ResolveTypeHandle(int typeToken);
    public RuntimeTypeHandle ResolveTypeHandle(int typeToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext);
    internal static RuntimeType ResolveTypeHandleInternal(RuntimeModule module, int typeToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext);
    private static void ResolveType(QCallModule module, int typeToken, IntPtr* typeInstArgs, int typeInstCount, IntPtr* methodInstArgs, int methodInstCount, ObjectHandleOnStack type);
    public RuntimeMethodHandle GetRuntimeMethodHandleFromMetadataToken(int methodToken);
    public RuntimeMethodHandle ResolveMethodHandle(int methodToken);
    internal static IRuntimeMethodInfo ResolveMethodHandleInternal(RuntimeModule module, int methodToken);
    public RuntimeMethodHandle ResolveMethodHandle(int methodToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext);
    internal static IRuntimeMethodInfo ResolveMethodHandleInternal(RuntimeModule module, int methodToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext);
    internal static RuntimeMethodHandleInternal ResolveMethodHandleInternalCore(RuntimeModule module, int methodToken, IntPtr[] typeInstantiationContext, int typeInstCount, IntPtr[] methodInstantiationContext, int methodInstCount);
    private static RuntimeMethodHandleInternal ResolveMethod(QCallModule module, int methodToken, IntPtr* typeInstArgs, int typeInstCount, IntPtr* methodInstArgs, int methodInstCount);
    public RuntimeFieldHandle GetRuntimeFieldHandleFromMetadataToken(int fieldToken);
    public RuntimeFieldHandle ResolveFieldHandle(int fieldToken);
    public RuntimeFieldHandle ResolveFieldHandle(int fieldToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext);
    internal static IRuntimeFieldInfo ResolveFieldHandleInternal(RuntimeModule module, int fieldToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext);
    private static void ResolveField(QCallModule module, int fieldToken, IntPtr* typeInstArgs, int typeInstCount, IntPtr* methodInstArgs, int methodInstCount, ObjectHandleOnStack retField);
    private static BOOL _ContainsPropertyMatchingHash(QCallModule module, int propertyToken, UInt32 hash);
    internal static bool ContainsPropertyMatchingHash(RuntimeModule module, int propertyToken, UInt32 hash);
    internal static void GetModuleType(QCallModule handle, ObjectHandleOnStack type);
    internal static RuntimeType GetModuleType(RuntimeModule module);
    private static void GetPEKind(QCallModule handle, Int32* peKind, Int32* machine);
    internal static void GetPEKind(RuntimeModule module, PortableExecutableKinds& peKind, ImageFileMachine& machine);
    internal static int GetMDStreamVersion(RuntimeModule module);
    public int get_MDStreamVersion();
    private static IntPtr _GetMetadataImport(RuntimeModule module);
    internal static MetadataImport GetMetadataImport(RuntimeModule module);
}
[AttributeUsageAttribute("64")]
public class System.MTAThreadAttribute : Attribute {
}
[ComVisibleAttribute("True")]
[NullableAttribute("0")]
[NullableContextAttribute("1")]
[ClassInterfaceAttribute("0")]
public abstract class System.MulticastDelegate : Delegate {
    private object _invocationList;
    private IntPtr _invocationCount;
    protected MulticastDelegate(object target, string method);
    protected MulticastDelegate(Type target, string method);
    internal bool IsUnmanagedFunctionPtr();
    internal bool InvocationListLogicallyNull();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(object obj);
    private bool InvocationListEquals(MulticastDelegate d);
    private bool TrySetSlot(Object[] a, int index, object o);
    private MulticastDelegate NewMulticastDelegate(Object[] invocationList, int invocationCount, bool thisIsMultiCastAlready);
    internal MulticastDelegate NewMulticastDelegate(Object[] invocationList, int invocationCount);
    internal void StoreDynamicMethod(MethodInfo dynamicMethod);
    protected sealed virtual Delegate CombineImpl(Delegate follow);
    private Object[] DeleteFromInvocationList(Object[] invocationList, int invocationCount, int deleteIndex, int deleteCount);
    private bool EqualInvocationLists(Object[] a, Object[] b, int start, int count);
    protected sealed virtual Delegate RemoveImpl(Delegate value);
    public sealed virtual Delegate[] GetInvocationList();
    [NullableContextAttribute("2")]
public static bool op_Equality(MulticastDelegate d1, MulticastDelegate d2);
    [NullableContextAttribute("2")]
public static bool op_Inequality(MulticastDelegate d1, MulticastDelegate d2);
    public sealed virtual int GetHashCode();
    internal virtual object GetTarget();
    protected virtual MethodInfo GetMethodImpl();
    [DebuggerNonUserCodeAttribute]
[DoesNotReturnAttribute]
private void ThrowNullThisInDelegateToInstance();
    [DebuggerNonUserCodeAttribute]
private void CtorClosed(object target, IntPtr methodPtr);
    [DebuggerNonUserCodeAttribute]
private void CtorClosedStatic(object target, IntPtr methodPtr);
    [DebuggerNonUserCodeAttribute]
private void CtorRTClosed(object target, IntPtr methodPtr);
    [DebuggerNonUserCodeAttribute]
private void CtorOpened(object target, IntPtr methodPtr, IntPtr shuffleThunk);
    [DebuggerNonUserCodeAttribute]
private void CtorVirtualDispatch(object target, IntPtr methodPtr, IntPtr shuffleThunk);
    [DebuggerNonUserCodeAttribute]
private void CtorCollectibleClosedStatic(object target, IntPtr methodPtr, IntPtr gchandle);
    [DebuggerNonUserCodeAttribute]
private void CtorCollectibleOpened(object target, IntPtr methodPtr, IntPtr shuffleThunk, IntPtr gchandle);
    [DebuggerNonUserCodeAttribute]
private void CtorCollectibleVirtualDispatch(object target, IntPtr methodPtr, IntPtr shuffleThunk, IntPtr gchandle);
}
[NullableAttribute("0")]
[NullableContextAttribute("2")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.MulticastNotSupportedException : SystemException {
    public MulticastNotSupportedException(string message);
    public MulticastNotSupportedException(string message, Exception inner);
    internal MulticastNotSupportedException(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("256")]
public class System.NonSerializedAttribute : Attribute {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.NotFiniteNumberException : ArithmeticException {
    private double _offendingNumber;
    public double OffendingNumber { get; }
    public NotFiniteNumberException(double offendingNumber);
    public NotFiniteNumberException(string message);
    public NotFiniteNumberException(string message, double offendingNumber);
    public NotFiniteNumberException(string message, Exception innerException);
    public NotFiniteNumberException(string message, double offendingNumber, Exception innerException);
    [NullableContextAttribute("1")]
protected NotFiniteNumberException(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public double get_OffendingNumber();
}
internal static class System.NotImplemented : object {
    internal static Exception ByDesign { get; }
    internal static Exception get_ByDesign();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.NotImplementedException : SystemException {
    public NotImplementedException(string message);
    public NotImplementedException(string message, Exception inner);
    [NullableContextAttribute("1")]
protected NotImplementedException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.NotSupportedException : SystemException {
    public NotSupportedException(string message);
    public NotSupportedException(string message, Exception innerException);
    [NullableContextAttribute("1")]
protected NotSupportedException(SerializationInfo info, StreamingContext context);
}
public static class System.Nullable : object {
    public static int Compare(Nullable`1<T> n1, Nullable`1<T> n2);
    public static bool Equals(Nullable`1<T> n1, Nullable`1<T> n2);
    [NullableContextAttribute("1")]
public static Type GetUnderlyingType(Type nullableType);
}
[NonVersionableAttribute]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Nullable`1 : ValueType {
    private bool hasValue;
    internal T value;
    public bool HasValue { get; }
    public T Value { get; }
    [NonVersionableAttribute]
public Nullable`1(T value);
    [NonVersionableAttribute]
public bool get_HasValue();
    public T get_Value();
    [NonVersionableAttribute]
public T GetValueOrDefault();
    [NonVersionableAttribute]
public T GetValueOrDefault(T defaultValue);
    [NullableContextAttribute("2")]
public virtual bool Equals(object other);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual string ToString();
    [NonVersionableAttribute]
public static Nullable`1<T> op_Implicit(T value);
    [NonVersionableAttribute]
public static T op_Explicit(Nullable`1<T> value);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.NullReferenceException : SystemException {
    public NullReferenceException(string message);
    public NullReferenceException(string message, Exception innerException);
    [NullableContextAttribute("1")]
protected NullReferenceException(SerializationInfo info, StreamingContext context);
}
internal static class System.Number : object {
    private static String[] s_singleDigitStringCache;
    private static String[] s_posCurrencyFormats;
    private static String[] s_negCurrencyFormats;
    private static String[] s_posPercentFormats;
    private static String[] s_negPercentFormats;
    private static String[] s_negNumberFormats;
    private static Single[] s_Pow10SingleTable;
    private static Double[] s_Pow10DoubleTable;
    internal static ReadOnlySpan`1<byte> CharToHexLookup { get; }
    private static Number();
    public static void Dragon4Double(double value, int cutoffNumber, bool isSignificantDigits, NumberBuffer& number);
    public static void Dragon4Single(float value, int cutoffNumber, bool isSignificantDigits, NumberBuffer& number);
    private static UInt32 Dragon4(ulong mantissa, int exponent, UInt32 mantissaHighBitIdx, bool hasUnequalMargins, int cutoffNumber, bool isSignificantDigits, Span`1<byte> buffer, Int32& decimalExponent);
    public static string FormatDecimal(decimal value, ReadOnlySpan`1<char> format, NumberFormatInfo info);
    public static bool TryFormatDecimal(decimal value, ReadOnlySpan`1<char> format, NumberFormatInfo info, Span`1<char> destination, Int32& charsWritten);
    internal static void DecimalToNumber(Decimal& d, NumberBuffer& number);
    public static string FormatDouble(double value, string format, NumberFormatInfo info);
    public static bool TryFormatDouble(double value, ReadOnlySpan`1<char> format, NumberFormatInfo info, Span`1<char> destination, Int32& charsWritten);
    private static int GetFloatingPointMaxDigitsAndPrecision(char fmt, Int32& precision, NumberFormatInfo info, Boolean& isSignificantDigits);
    private static string FormatDouble(ValueStringBuilder& sb, double value, ReadOnlySpan`1<char> format, NumberFormatInfo info);
    public static string FormatSingle(float value, string format, NumberFormatInfo info);
    public static bool TryFormatSingle(float value, ReadOnlySpan`1<char> format, NumberFormatInfo info, Span`1<char> destination, Int32& charsWritten);
    private static string FormatSingle(ValueStringBuilder& sb, float value, ReadOnlySpan`1<char> format, NumberFormatInfo info);
    private static bool TryCopyTo(string source, Span`1<char> destination, Int32& charsWritten);
    public static string FormatInt32(int value, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static bool TryFormatInt32(int value, ReadOnlySpan`1<char> format, IFormatProvider provider, Span`1<char> destination, Int32& charsWritten);
    public static string FormatUInt32(UInt32 value, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static bool TryFormatUInt32(UInt32 value, ReadOnlySpan`1<char> format, IFormatProvider provider, Span`1<char> destination, Int32& charsWritten);
    public static string FormatInt64(long value, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static bool TryFormatInt64(long value, ReadOnlySpan`1<char> format, IFormatProvider provider, Span`1<char> destination, Int32& charsWritten);
    public static string FormatUInt64(ulong value, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static bool TryFormatUInt64(ulong value, ReadOnlySpan`1<char> format, IFormatProvider provider, Span`1<char> destination, Int32& charsWritten);
    private static void Int32ToNumber(int value, NumberBuffer& number);
    private static string NegativeInt32ToDecStr(int value, int digits, string sNegative);
    private static bool TryNegativeInt32ToDecStr(int value, int digits, string sNegative, Span`1<char> destination, Int32& charsWritten);
    private static string Int32ToHexStr(int value, char hexBase, int digits);
    private static bool TryInt32ToHexStr(int value, char hexBase, int digits, Span`1<char> destination, Int32& charsWritten);
    private static Char* Int32ToHexChars(Char* buffer, UInt32 value, int hexBase, int digits);
    private static void UInt32ToNumber(UInt32 value, NumberBuffer& number);
    internal static Byte* UInt32ToDecChars(Byte* bufferEnd, UInt32 value, int digits);
    internal static Char* UInt32ToDecChars(Char* bufferEnd, UInt32 value, int digits);
    private static string UInt32ToDecStr(UInt32 value, int digits);
    private static bool TryUInt32ToDecStr(UInt32 value, int digits, Span`1<char> destination, Int32& charsWritten);
    private static void Int64ToNumber(long input, NumberBuffer& number);
    private static string NegativeInt64ToDecStr(long input, int digits, string sNegative);
    private static bool TryNegativeInt64ToDecStr(long input, int digits, string sNegative, Span`1<char> destination, Int32& charsWritten);
    private static string Int64ToHexStr(long value, char hexBase, int digits);
    private static bool TryInt64ToHexStr(long value, char hexBase, int digits, Span`1<char> destination, Int32& charsWritten);
    private static void UInt64ToNumber(ulong value, NumberBuffer& number);
    private static string UInt64ToDecStr(ulong value, int digits);
    private static bool TryUInt64ToDecStr(ulong value, int digits, Span`1<char> destination, Int32& charsWritten);
    internal static char ParseFormatSpecifier(ReadOnlySpan`1<char> format, Int32& digits);
    internal static void NumberToString(ValueStringBuilder& sb, NumberBuffer& number, char format, int nMaxDigits, NumberFormatInfo info);
    internal static void NumberToStringFormat(ValueStringBuilder& sb, NumberBuffer& number, ReadOnlySpan`1<char> format, NumberFormatInfo info);
    private static void FormatCurrency(ValueStringBuilder& sb, NumberBuffer& number, int nMaxDigits, NumberFormatInfo info);
    private static void FormatFixed(ValueStringBuilder& sb, NumberBuffer& number, int nMaxDigits, NumberFormatInfo info, Int32[] groupDigits, string sDecimal, string sGroup);
    private static void FormatNumber(ValueStringBuilder& sb, NumberBuffer& number, int nMaxDigits, NumberFormatInfo info);
    private static void FormatScientific(ValueStringBuilder& sb, NumberBuffer& number, int nMaxDigits, NumberFormatInfo info, char expChar);
    private static void FormatExponent(ValueStringBuilder& sb, NumberFormatInfo info, int value, char expChar, int minDigits, bool positiveSign);
    private static void FormatGeneral(ValueStringBuilder& sb, NumberBuffer& number, int nMaxDigits, NumberFormatInfo info, char expChar, bool bSuppressScientific);
    private static void FormatPercent(ValueStringBuilder& sb, NumberBuffer& number, int nMaxDigits, NumberFormatInfo info);
    internal static void RoundNumber(NumberBuffer& number, int pos, bool isCorrectlyRounded);
    private static int FindSection(ReadOnlySpan`1<char> format, int section);
    private static UInt32 Low32(ulong value);
    private static UInt32 High32(ulong value);
    private static UInt32 Int64DivMod1E9(UInt64& value);
    private static ulong ExtractFractionAndBiasedExponent(double value, Int32& exponent);
    private static UInt32 ExtractFractionAndBiasedExponent(float value, Int32& exponent);
    private static void AccumulateDecimalDigitsIntoBigInteger(NumberBuffer& number, UInt32 firstIndex, UInt32 lastIndex, BigInteger& result);
    private static ulong AssembleFloatingPointBits(FloatingPointInfo& info, ulong initialMantissa, int initialExponent, bool hasZeroTail);
    private static ulong ConvertBigIntegerToFloatingPointBits(BigInteger& value, FloatingPointInfo& info, UInt32 integerBitsOfPrecision, bool hasNonZeroFractionalPart);
    private static UInt32 DigitsToUInt32(Byte* p, int count);
    private static ulong DigitsToUInt64(Byte* p, int count);
    private static ulong NumberToFloatingPointBits(NumberBuffer& number, FloatingPointInfo& info);
    private static ulong NumberToFloatingPointBitsSlow(NumberBuffer& number, FloatingPointInfo& info, UInt32 positiveExponent, UInt32 integerDigitsPresent, UInt32 fractionalDigitsPresent);
    private static ulong RightShiftWithRounding(ulong value, int shift, bool hasZeroTail);
    private static bool ShouldRoundUp(bool lsbBit, bool roundBit, bool hasTailBits);
    internal static ReadOnlySpan`1<byte> get_CharToHexLookup();
    private static bool TryNumberToInt32(NumberBuffer& number, Int32& value);
    private static bool TryNumberToInt64(NumberBuffer& number, Int64& value);
    private static bool TryNumberToUInt32(NumberBuffer& number, UInt32& value);
    private static bool TryNumberToUInt64(NumberBuffer& number, UInt64& value);
    internal static int ParseInt32(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info);
    internal static long ParseInt64(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info);
    internal static UInt32 ParseUInt32(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info);
    internal static ulong ParseUInt64(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info);
    private static bool TryParseNumber(Char*& str, Char* strEnd, NumberStyles styles, NumberBuffer& number, NumberFormatInfo info);
    internal static ParsingStatus TryParseInt32(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info, Int32& result);
    private static ParsingStatus TryParseInt32Number(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info, Int32& result);
    internal static ParsingStatus TryParseInt32IntegerStyle(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info, Int32& result);
    internal static ParsingStatus TryParseInt64IntegerStyle(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info, Int64& result);
    internal static ParsingStatus TryParseInt64(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info, Int64& result);
    private static ParsingStatus TryParseInt64Number(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info, Int64& result);
    internal static ParsingStatus TryParseUInt32(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info, UInt32& result);
    private static ParsingStatus TryParseUInt32Number(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info, UInt32& result);
    internal static ParsingStatus TryParseUInt32IntegerStyle(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info, UInt32& result);
    private static ParsingStatus TryParseUInt32HexNumberStyle(ReadOnlySpan`1<char> value, NumberStyles styles, UInt32& result);
    internal static ParsingStatus TryParseUInt64(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info, UInt64& result);
    private static ParsingStatus TryParseUInt64Number(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info, UInt64& result);
    internal static ParsingStatus TryParseUInt64IntegerStyle(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info, UInt64& result);
    private static ParsingStatus TryParseUInt64HexNumberStyle(ReadOnlySpan`1<char> value, NumberStyles styles, UInt64& result);
    internal static decimal ParseDecimal(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info);
    internal static bool TryNumberToDecimal(NumberBuffer& number, Decimal& value);
    internal static double ParseDouble(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info);
    internal static float ParseSingle(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info);
    internal static ParsingStatus TryParseDecimal(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info, Decimal& result);
    internal static bool TryParseDouble(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info, Double& result);
    internal static bool TryParseSingle(ReadOnlySpan`1<char> value, NumberStyles styles, NumberFormatInfo info, Single& result);
    internal static bool TryStringToNumber(ReadOnlySpan`1<char> value, NumberStyles styles, NumberBuffer& number, NumberFormatInfo info);
    private static bool TrailingZeros(ReadOnlySpan`1<char> value, int index);
    private static bool IsSpaceReplacingChar(char c);
    private static Char* MatchChars(Char* p, Char* pEnd, string value);
    private static bool IsWhite(int ch);
    private static bool IsDigit(int ch);
    [DoesNotReturnAttribute]
internal static void ThrowOverflowOrFormatException(ParsingStatus status, TypeCode type);
    [DoesNotReturnAttribute]
internal static void ThrowOverflowException(TypeCode type);
    private static Exception GetException(ParsingStatus status, TypeCode type);
    internal static double NumberToDouble(NumberBuffer& number);
    internal static float NumberToSingle(NumberBuffer& number);
    [CompilerGeneratedAttribute]
internal static bool <RoundNumber>g__ShouldRoundUp|71_0(Byte* dig, int i, NumberBufferKind numberKind, bool isCorrectlyRounded);
}
public static class System.Numerics.BitOperations : object {
    private static ReadOnlySpan`1<byte> s_TrailingZeroCountDeBruijn { get; }
    private static ReadOnlySpan`1<byte> s_Log2DeBruijn { get; }
    private static ReadOnlySpan`1<byte> get_s_TrailingZeroCountDeBruijn();
    private static ReadOnlySpan`1<byte> get_s_Log2DeBruijn();
    [CLSCompliantAttribute("False")]
public static int LeadingZeroCount(UInt32 value);
    [CLSCompliantAttribute("False")]
public static int LeadingZeroCount(ulong value);
    [CLSCompliantAttribute("False")]
public static int Log2(UInt32 value);
    [CLSCompliantAttribute("False")]
public static int Log2(ulong value);
    private static int Log2SoftwareFallback(UInt32 value);
    [CLSCompliantAttribute("False")]
public static int PopCount(UInt32 value);
    [CLSCompliantAttribute("False")]
public static int PopCount(ulong value);
    public static int TrailingZeroCount(int value);
    [CLSCompliantAttribute("False")]
public static int TrailingZeroCount(UInt32 value);
    public static int TrailingZeroCount(long value);
    [CLSCompliantAttribute("False")]
public static int TrailingZeroCount(ulong value);
    [CLSCompliantAttribute("False")]
public static UInt32 RotateLeft(UInt32 value, int offset);
    [CLSCompliantAttribute("False")]
public static ulong RotateLeft(ulong value, int offset);
    [CLSCompliantAttribute("False")]
public static UInt32 RotateRight(UInt32 value, int offset);
    [CLSCompliantAttribute("False")]
public static ulong RotateRight(ulong value, int offset);
    [CompilerGeneratedAttribute]
internal static int <PopCount>g__SoftwareFallback|9_0(UInt32 value);
    [CompilerGeneratedAttribute]
internal static int <PopCount>g__SoftwareFallback|10_0(ulong value);
}
internal class System.Numerics.ConstantHelper : object {
    public static byte GetByteWithAllBitsSet();
    public static sbyte GetSByteWithAllBitsSet();
    public static ushort GetUInt16WithAllBitsSet();
    public static short GetInt16WithAllBitsSet();
    public static UInt32 GetUInt32WithAllBitsSet();
    public static int GetInt32WithAllBitsSet();
    public static ulong GetUInt64WithAllBitsSet();
    public static long GetInt64WithAllBitsSet();
    public static float GetSingleWithAllBitsSet();
    public static double GetDoubleWithAllBitsSet();
}
internal static class System.Numerics.Hashing.HashHelpers : object {
    public static int RandomSeed;
    private static HashHelpers();
    public static int Combine(int h1, int h2);
}
internal class System.Numerics.Register : ValueType {
    internal byte byte_0;
    internal byte byte_1;
    internal byte byte_2;
    internal byte byte_3;
    internal byte byte_4;
    internal byte byte_5;
    internal byte byte_6;
    internal byte byte_7;
    internal byte byte_8;
    internal byte byte_9;
    internal byte byte_10;
    internal byte byte_11;
    internal byte byte_12;
    internal byte byte_13;
    internal byte byte_14;
    internal byte byte_15;
    internal sbyte sbyte_0;
    internal sbyte sbyte_1;
    internal sbyte sbyte_2;
    internal sbyte sbyte_3;
    internal sbyte sbyte_4;
    internal sbyte sbyte_5;
    internal sbyte sbyte_6;
    internal sbyte sbyte_7;
    internal sbyte sbyte_8;
    internal sbyte sbyte_9;
    internal sbyte sbyte_10;
    internal sbyte sbyte_11;
    internal sbyte sbyte_12;
    internal sbyte sbyte_13;
    internal sbyte sbyte_14;
    internal sbyte sbyte_15;
    internal ushort uint16_0;
    internal ushort uint16_1;
    internal ushort uint16_2;
    internal ushort uint16_3;
    internal ushort uint16_4;
    internal ushort uint16_5;
    internal ushort uint16_6;
    internal ushort uint16_7;
    internal short int16_0;
    internal short int16_1;
    internal short int16_2;
    internal short int16_3;
    internal short int16_4;
    internal short int16_5;
    internal short int16_6;
    internal short int16_7;
    internal UInt32 uint32_0;
    internal UInt32 uint32_1;
    internal UInt32 uint32_2;
    internal UInt32 uint32_3;
    internal int int32_0;
    internal int int32_1;
    internal int int32_2;
    internal int int32_3;
    internal ulong uint64_0;
    internal ulong uint64_1;
    internal long int64_0;
    internal long int64_1;
    internal float single_0;
    internal float single_1;
    internal float single_2;
    internal float single_3;
    internal double double_0;
    internal double double_1;
}
[IntrinsicAttribute]
public static class System.Numerics.Vector : object {
    public static bool IsHardwareAccelerated { get; }
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static void Widen(Vector`1<byte> source, Vector`1& low, Vector`1& high);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static void Widen(Vector`1<ushort> source, Vector`1& low, Vector`1& high);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static void Widen(Vector`1<UInt32> source, Vector`1& low, Vector`1& high);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static void Widen(Vector`1<sbyte> source, Vector`1& low, Vector`1& high);
    [IntrinsicAttribute]
public static void Widen(Vector`1<short> source, Vector`1& low, Vector`1& high);
    [IntrinsicAttribute]
public static void Widen(Vector`1<int> source, Vector`1& low, Vector`1& high);
    [IntrinsicAttribute]
public static void Widen(Vector`1<float> source, Vector`1& low, Vector`1& high);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<byte> Narrow(Vector`1<ushort> low, Vector`1<ushort> high);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<ushort> Narrow(Vector`1<UInt32> low, Vector`1<UInt32> high);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<UInt32> Narrow(Vector`1<ulong> low, Vector`1<ulong> high);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<sbyte> Narrow(Vector`1<short> low, Vector`1<short> high);
    [IntrinsicAttribute]
public static Vector`1<short> Narrow(Vector`1<int> low, Vector`1<int> high);
    [IntrinsicAttribute]
public static Vector`1<int> Narrow(Vector`1<long> low, Vector`1<long> high);
    [IntrinsicAttribute]
public static Vector`1<float> Narrow(Vector`1<double> low, Vector`1<double> high);
    [IntrinsicAttribute]
public static Vector`1<float> ConvertToSingle(Vector`1<int> value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<float> ConvertToSingle(Vector`1<UInt32> value);
    [IntrinsicAttribute]
public static Vector`1<double> ConvertToDouble(Vector`1<long> value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<double> ConvertToDouble(Vector`1<ulong> value);
    [IntrinsicAttribute]
public static Vector`1<int> ConvertToInt32(Vector`1<float> value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static Vector`1<UInt32> ConvertToUInt32(Vector`1<float> value);
    [IntrinsicAttribute]
public static Vector`1<long> ConvertToInt64(Vector`1<double> value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<ulong> ConvertToUInt64(Vector`1<double> value);
    [DoesNotReturnAttribute]
internal static void ThrowInsufficientNumberOfElementsException(int requiredElementCount);
    [IntrinsicAttribute]
public static Vector`1<float> ConditionalSelect(Vector`1<int> condition, Vector`1<float> left, Vector`1<float> right);
    [IntrinsicAttribute]
public static Vector`1<double> ConditionalSelect(Vector`1<long> condition, Vector`1<double> left, Vector`1<double> right);
    [IntrinsicAttribute]
public static Vector`1<T> ConditionalSelect(Vector`1<T> condition, Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static Vector`1<T> Equals(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static Vector`1<int> Equals(Vector`1<float> left, Vector`1<float> right);
    [IntrinsicAttribute]
public static Vector`1<int> Equals(Vector`1<int> left, Vector`1<int> right);
    [IntrinsicAttribute]
public static Vector`1<long> Equals(Vector`1<double> left, Vector`1<double> right);
    [IntrinsicAttribute]
public static Vector`1<long> Equals(Vector`1<long> left, Vector`1<long> right);
    public static bool EqualsAll(Vector`1<T> left, Vector`1<T> right);
    public static bool EqualsAny(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static Vector`1<T> LessThan(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static Vector`1<int> LessThan(Vector`1<float> left, Vector`1<float> right);
    [IntrinsicAttribute]
public static Vector`1<int> LessThan(Vector`1<int> left, Vector`1<int> right);
    [IntrinsicAttribute]
public static Vector`1<long> LessThan(Vector`1<double> left, Vector`1<double> right);
    [IntrinsicAttribute]
public static Vector`1<long> LessThan(Vector`1<long> left, Vector`1<long> right);
    public static bool LessThanAll(Vector`1<T> left, Vector`1<T> right);
    public static bool LessThanAny(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static Vector`1<T> LessThanOrEqual(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static Vector`1<int> LessThanOrEqual(Vector`1<float> left, Vector`1<float> right);
    [IntrinsicAttribute]
public static Vector`1<int> LessThanOrEqual(Vector`1<int> left, Vector`1<int> right);
    [IntrinsicAttribute]
public static Vector`1<long> LessThanOrEqual(Vector`1<long> left, Vector`1<long> right);
    [IntrinsicAttribute]
public static Vector`1<long> LessThanOrEqual(Vector`1<double> left, Vector`1<double> right);
    public static bool LessThanOrEqualAll(Vector`1<T> left, Vector`1<T> right);
    public static bool LessThanOrEqualAny(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static Vector`1<T> GreaterThan(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static Vector`1<int> GreaterThan(Vector`1<float> left, Vector`1<float> right);
    [IntrinsicAttribute]
public static Vector`1<int> GreaterThan(Vector`1<int> left, Vector`1<int> right);
    [IntrinsicAttribute]
public static Vector`1<long> GreaterThan(Vector`1<double> left, Vector`1<double> right);
    [IntrinsicAttribute]
public static Vector`1<long> GreaterThan(Vector`1<long> left, Vector`1<long> right);
    public static bool GreaterThanAll(Vector`1<T> left, Vector`1<T> right);
    public static bool GreaterThanAny(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static Vector`1<T> GreaterThanOrEqual(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static Vector`1<int> GreaterThanOrEqual(Vector`1<float> left, Vector`1<float> right);
    [IntrinsicAttribute]
public static Vector`1<int> GreaterThanOrEqual(Vector`1<int> left, Vector`1<int> right);
    [IntrinsicAttribute]
public static Vector`1<long> GreaterThanOrEqual(Vector`1<long> left, Vector`1<long> right);
    [IntrinsicAttribute]
public static Vector`1<long> GreaterThanOrEqual(Vector`1<double> left, Vector`1<double> right);
    public static bool GreaterThanOrEqualAll(Vector`1<T> left, Vector`1<T> right);
    public static bool GreaterThanOrEqualAny(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static bool get_IsHardwareAccelerated();
    [IntrinsicAttribute]
public static Vector`1<T> Abs(Vector`1<T> value);
    [IntrinsicAttribute]
public static Vector`1<T> Min(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static Vector`1<T> Max(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static T Dot(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static Vector`1<T> SquareRoot(Vector`1<T> value);
    public static Vector`1<T> Add(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> Subtract(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> Multiply(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> Multiply(Vector`1<T> left, T right);
    public static Vector`1<T> Multiply(T left, Vector`1<T> right);
    public static Vector`1<T> Divide(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> Negate(Vector`1<T> value);
    public static Vector`1<T> BitwiseAnd(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> BitwiseOr(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> OnesComplement(Vector`1<T> value);
    public static Vector`1<T> Xor(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static Vector`1<T> AndNot(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<byte> AsVectorByte(Vector`1<T> value);
    [CLSCompliantAttribute("False")]
public static Vector`1<sbyte> AsVectorSByte(Vector`1<T> value);
    [CLSCompliantAttribute("False")]
public static Vector`1<ushort> AsVectorUInt16(Vector`1<T> value);
    public static Vector`1<short> AsVectorInt16(Vector`1<T> value);
    [CLSCompliantAttribute("False")]
public static Vector`1<UInt32> AsVectorUInt32(Vector`1<T> value);
    public static Vector`1<int> AsVectorInt32(Vector`1<T> value);
    [CLSCompliantAttribute("False")]
public static Vector`1<ulong> AsVectorUInt64(Vector`1<T> value);
    public static Vector`1<long> AsVectorInt64(Vector`1<T> value);
    public static Vector`1<float> AsVectorSingle(Vector`1<T> value);
    public static Vector`1<double> AsVectorDouble(Vector`1<T> value);
}
[DefaultMemberAttribute("Item")]
[IntrinsicAttribute]
public class System.Numerics.Vector`1 : ValueType {
    private Register register;
    private static Vector`1<T> s_zero;
    private static Vector`1<T> s_one;
    private static Vector`1<T> s_allOnes;
    public static int Count { get; }
    public static Vector`1<T> Zero { get; }
    public static Vector`1<T> One { get; }
    internal static Vector`1<T> AllOnes { get; }
    public T Item { get; }
    [IntrinsicAttribute]
public Vector`1(T value);
    [IntrinsicAttribute]
public Vector`1(T[] values);
    [IntrinsicAttribute]
public Vector`1(T[] values, int index);
    internal Vector`1(Void* dataPointer);
    internal Vector`1(Void* dataPointer, int offset);
    private Vector`1(Register& existingRegister);
    public Vector`1(ReadOnlySpan`1<byte> values);
    public Vector`1(ReadOnlySpan`1<T> values);
    public Vector`1(Span`1<T> values);
    private static Vector`1();
    [IntrinsicAttribute]
public static int get_Count();
    [IntrinsicAttribute]
public static Vector`1<T> get_Zero();
    [IntrinsicAttribute]
public static Vector`1<T> get_One();
    [IntrinsicAttribute]
internal static Vector`1<T> get_AllOnes();
    [IsReadOnlyAttribute]
public void CopyTo(Span`1<byte> destination);
    [IsReadOnlyAttribute]
public void CopyTo(Span`1<T> destination);
    [IntrinsicAttribute]
[IsReadOnlyAttribute]
public void CopyTo(T[] destination);
    [IsReadOnlyAttribute]
[IntrinsicAttribute]
public void CopyTo(T[] destination, int startIndex);
    [IsReadOnlyAttribute]
[IntrinsicAttribute]
public T get_Item(int index);
    [NullableContextAttribute("2")]
[IsReadOnlyAttribute]
public virtual bool Equals(object obj);
    [IntrinsicAttribute]
[IsReadOnlyAttribute]
public sealed virtual bool Equals(Vector`1<T> other);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("1")]
[IsReadOnlyAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[IsReadOnlyAttribute]
public string ToString(string format);
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    [IsReadOnlyAttribute]
public bool TryCopyTo(Span`1<byte> destination);
    [IsReadOnlyAttribute]
public bool TryCopyTo(Span`1<T> destination);
    [IntrinsicAttribute]
public static Vector`1<T> op_Addition(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static Vector`1<T> op_Subtraction(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static Vector`1<T> op_Multiply(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> op_Multiply(Vector`1<T> value, T factor);
    public static Vector`1<T> op_Multiply(T factor, Vector`1<T> value);
    [IntrinsicAttribute]
public static Vector`1<T> op_Division(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> op_UnaryNegation(Vector`1<T> value);
    [IntrinsicAttribute]
public static Vector`1<T> op_BitwiseAnd(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static Vector`1<T> op_BitwiseOr(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static Vector`1<T> op_ExclusiveOr(Vector`1<T> left, Vector`1<T> right);
    public static Vector`1<T> op_OnesComplement(Vector`1<T> value);
    [IntrinsicAttribute]
public static bool op_Equality(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static bool op_Inequality(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static Vector`1<byte> op_Explicit(Vector`1<T> value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<sbyte> op_Explicit(Vector`1<T> value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static Vector`1<ushort> op_Explicit(Vector`1<T> value);
    [IntrinsicAttribute]
public static Vector`1<short> op_Explicit(Vector`1<T> value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static Vector`1<UInt32> op_Explicit(Vector`1<T> value);
    [IntrinsicAttribute]
public static Vector`1<int> op_Explicit(Vector`1<T> value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static Vector`1<ulong> op_Explicit(Vector`1<T> value);
    [IntrinsicAttribute]
public static Vector`1<long> op_Explicit(Vector`1<T> value);
    [IntrinsicAttribute]
public static Vector`1<float> op_Explicit(Vector`1<T> value);
    [IntrinsicAttribute]
public static Vector`1<double> op_Explicit(Vector`1<T> value);
    [IntrinsicAttribute]
internal static Vector`1<T> Equals(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
internal static Vector`1<T> LessThan(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
internal static Vector`1<T> GreaterThan(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
internal static Vector`1<T> GreaterThanOrEqual(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
internal static Vector`1<T> LessThanOrEqual(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
internal static Vector`1<T> ConditionalSelect(Vector`1<T> condition, Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
internal static Vector`1<T> Abs(Vector`1<T> value);
    [IntrinsicAttribute]
internal static Vector`1<T> Min(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
internal static Vector`1<T> Max(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
internal static T Dot(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
internal static Vector`1<T> SquareRoot(Vector`1<T> value);
    private static bool ScalarEquals(T left, T right);
    private static bool ScalarLessThan(T left, T right);
    private static bool ScalarGreaterThan(T left, T right);
    private static T ScalarAdd(T left, T right);
    private static T ScalarSubtract(T left, T right);
    private static T ScalarMultiply(T left, T right);
    private static T ScalarDivide(T left, T right);
    private static T GetOneValue();
    private static T GetAllBitsSetValue();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[ComVisibleAttribute("True")]
[ClassInterfaceAttribute("1")]
[NullableContextAttribute("2")]
public class System.Object {
    [NullableContextAttribute("1")]
public Type GetType();
    [NullableContextAttribute("1")]
protected object MemberwiseClone();
    [NonVersionableAttribute]
protected virtual void Finalize();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public static bool Equals(object objA, object objB);
    [NonVersionableAttribute]
public static bool ReferenceEquals(object objA, object objB);
    public virtual int GetHashCode();
}
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableContextAttribute("1")]
public class System.ObjectDisposedException : InvalidOperationException {
    private string _objectName;
    public string Message { get; }
    public string ObjectName { get; }
    [NullableContextAttribute("2")]
public ObjectDisposedException(string objectName);
    [NullableContextAttribute("2")]
public ObjectDisposedException(string objectName, string message);
    [NullableContextAttribute("2")]
public ObjectDisposedException(string message, Exception innerException);
    protected ObjectDisposedException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
    public string get_ObjectName();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("6140")]
public class System.ObsoleteAttribute : Attribute {
    private string _message;
    private bool _error;
    public string Message { get; }
    public bool IsError { get; }
    public ObsoleteAttribute(string message);
    public ObsoleteAttribute(string message, bool error);
    public string get_Message();
    public bool get_IsError();
}
internal class System.OleAutBinder : DefaultBinder {
    public virtual object ChangeType(object value, Type type, CultureInfo cultureInfo);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.OperatingSystem : object {
    private Version _version;
    private PlatformID _platform;
    private string _servicePack;
    private string _versionString;
    public PlatformID Platform { get; }
    public string ServicePack { get; }
    public Version Version { get; }
    public string VersionString { get; }
    public OperatingSystem(PlatformID platform, Version version);
    internal OperatingSystem(PlatformID platform, Version version, string servicePack);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public PlatformID get_Platform();
    public string get_ServicePack();
    public Version get_Version();
    public sealed virtual object Clone();
    public virtual string ToString();
    public string get_VersionString();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.OperationCanceledException : SystemException {
    private CancellationToken _cancellationToken;
    public CancellationToken CancellationToken { get; private set; }
    public OperationCanceledException(string message);
    public OperationCanceledException(string message, Exception innerException);
    public OperationCanceledException(CancellationToken token);
    public OperationCanceledException(string message, CancellationToken token);
    public OperationCanceledException(string message, Exception innerException, CancellationToken token);
    [NullableContextAttribute("1")]
protected OperationCanceledException(SerializationInfo info, StreamingContext context);
    public CancellationToken get_CancellationToken();
    private void set_CancellationToken(CancellationToken value);
}
internal class System.OrdinalCaseSensitiveComparer : OrdinalComparer {
    public virtual int Compare(string x, string y);
    public virtual bool Equals(string x, string y);
    public virtual int GetHashCode(string obj);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[NullableAttribute("0")]
[NullableContextAttribute("2")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.OrdinalComparer : StringComparer {
    private bool _ignoreCase;
    internal OrdinalComparer(bool ignoreCase);
    public virtual int Compare(string x, string y);
    public virtual bool Equals(string x, string y);
    [NullableContextAttribute("1")]
public virtual int GetHashCode(string obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class System.OrdinalIgnoreCaseComparer : OrdinalComparer {
    public virtual int Compare(string x, string y);
    public virtual bool Equals(string x, string y);
    public virtual int GetHashCode(string obj);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.OutOfMemoryException : SystemException {
    public OutOfMemoryException(string message);
    public OutOfMemoryException(string message, Exception innerException);
    [NullableContextAttribute("1")]
protected OutOfMemoryException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableAttribute("0")]
[NullableContextAttribute("2")]
public class System.OverflowException : ArithmeticException {
    public OverflowException(string message);
    public OverflowException(string message, Exception innerException);
    [NullableContextAttribute("1")]
protected OverflowException(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("2048")]
public class System.ParamArrayAttribute : Attribute {
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class System.ParamsArray : ValueType {
    private static Object[] s_oneArgArray;
    private static Object[] s_twoArgArray;
    private static Object[] s_threeArgArray;
    private object _arg0;
    private object _arg1;
    private object _arg2;
    private Object[] _args;
    public int Length { get; }
    public object Item { get; }
    public ParamsArray(object arg0);
    public ParamsArray(object arg0, object arg1);
    public ParamsArray(object arg0, object arg1, object arg2);
    public ParamsArray(Object[] args);
    private static ParamsArray();
    public int get_Length();
    public object get_Item(int index);
    private object GetAtSlow(int index);
}
internal enum System.ParseFailureKind : Enum {
    public int value__;
    public static ParseFailureKind None;
    public static ParseFailureKind ArgumentNull;
    public static ParseFailureKind Format;
    public static ParseFailureKind FormatWithParameter;
    public static ParseFailureKind FormatWithOriginalDateTime;
    public static ParseFailureKind FormatWithFormatSpecifier;
    public static ParseFailureKind FormatWithOriginalDateTimeAndParameter;
    public static ParseFailureKind FormatBadDateTimeCalendar;
}
[FlagsAttribute]
internal enum System.ParseFlags : Enum {
    public int value__;
    public static ParseFlags HaveYear;
    public static ParseFlags HaveMonth;
    public static ParseFlags HaveDay;
    public static ParseFlags HaveHour;
    public static ParseFlags HaveMinute;
    public static ParseFlags HaveSecond;
    public static ParseFlags HaveTime;
    public static ParseFlags HaveDate;
    public static ParseFlags TimeZoneUsed;
    public static ParseFlags TimeZoneUtc;
    public static ParseFlags ParsedMonthName;
    public static ParseFlags CaptureOffset;
    public static ParseFlags YearDefault;
    public static ParseFlags Rfc1123Pattern;
    public static ParseFlags UtcSortPattern;
}
internal static class System.ParseNumbers : object {
    public static long StringToLong(ReadOnlySpan`1<char> s, int radix, int flags);
    public static long StringToLong(ReadOnlySpan`1<char> s, int radix, int flags, Int32& currPos);
    public static int StringToInt(ReadOnlySpan`1<char> s, int radix, int flags);
    public static int StringToInt(ReadOnlySpan`1<char> s, int radix, int flags, Int32& currPos);
    public static string IntToString(int n, int radix, int width, char paddingChar, int flags);
    public static string LongToString(long n, int radix, int width, char paddingChar, int flags);
    private static void EatWhiteSpace(ReadOnlySpan`1<char> s, Int32& i);
    private static long GrabLongs(int radix, ReadOnlySpan`1<char> s, Int32& i, bool isUnsigned);
    private static int GrabInts(int radix, ReadOnlySpan`1<char> s, Int32& i, bool isUnsigned);
    private static bool IsDigit(char c, int radix, Int32& result);
}
internal class System.ParsingInfo : ValueType {
    internal Calendar calendar;
    internal int dayOfWeek;
    internal TM timeMark;
    internal bool fUseHour12;
    internal bool fUseTwoDigitYear;
    internal bool fAllowInnerWhite;
    internal bool fAllowTrailingWhite;
    internal bool fCustomNumberParser;
    internal MatchNumberDelegate parseNumberDelegate;
    internal void Init();
}
internal static class System.PasteArguments : object {
    internal static void AppendArgument(StringBuilder stringBuilder, string argument);
    private static bool ContainsNoWhitespaceOrQuotes(string s);
    internal static string Paste(IEnumerable`1<string> arguments, bool pasteFirstArgumentUsingArgV0Rules);
}
public enum System.PlatformID : Enum {
    public int value__;
    [EditorBrowsableAttribute("1")]
public static PlatformID Win32S;
    [EditorBrowsableAttribute("1")]
public static PlatformID Win32Windows;
    public static PlatformID Win32NT;
    [EditorBrowsableAttribute("1")]
public static PlatformID WinCE;
    public static PlatformID Unix;
    [EditorBrowsableAttribute("1")]
public static PlatformID Xbox;
    [EditorBrowsableAttribute("1")]
public static PlatformID MacOSX;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.PlatformNotSupportedException : NotSupportedException {
    public PlatformNotSupportedException(string message);
    public PlatformNotSupportedException(string message, Exception inner);
    [NullableContextAttribute("1")]
protected PlatformNotSupportedException(SerializationInfo info, StreamingContext context);
}
public class System.Predicate`1 : MulticastDelegate {
    public Predicate`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual bool Invoke(T obj);
    public virtual IAsyncResult BeginInvoke(T obj, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal static class System.Private.CoreLib.Resources.Strings : object {
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Progress`1 : object {
    private SynchronizationContext _synchronizationContext;
    private Action`1<T> _handler;
    private SendOrPostCallback _invokeHandlers;
    [CompilerGeneratedAttribute]
private EventHandler`1<T> ProgressChanged;
    public Progress`1(Action`1<T> handler);
    [CompilerGeneratedAttribute]
public void add_ProgressChanged(EventHandler`1<T> value);
    [CompilerGeneratedAttribute]
public void remove_ProgressChanged(EventHandler`1<T> value);
    protected virtual void OnReport(T value);
    private sealed virtual override void System.IProgress<T>.Report(T value);
    private void InvokeHandlers(object state);
}
internal static class System.ProgressStatics : object {
    internal static SynchronizationContext DefaultContext;
    private static ProgressStatics();
}
public class System.Random : object {
    private int _inext;
    private int _inextp;
    private Int32[] _seedArray;
    [ThreadStaticAttribute]
private static Random t_threadRandom;
    private static Random s_globalRandom;
    public Random(int Seed);
    private static Random();
    protected virtual double Sample();
    private int InternalSample();
    private static int GenerateSeed();
    private static int GenerateGlobalSeed();
    public virtual int Next();
    private double GetSampleForLargeRange();
    public virtual int Next(int minValue, int maxValue);
    public virtual int Next(int maxValue);
    public virtual double NextDouble();
    [NullableContextAttribute("1")]
public virtual void NextBytes(Byte[] buffer);
    public virtual void NextBytes(Span`1<byte> buffer);
}
[IsReadOnlyAttribute]
public class System.Range : ValueType {
    [CompilerGeneratedAttribute]
private Index <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private Index <End>k__BackingField;
    public Index Start { get; }
    public Index End { get; }
    public static Range All { get; }
    public Range(Index start, Index end);
    [CompilerGeneratedAttribute]
public Index get_Start();
    [CompilerGeneratedAttribute]
public Index get_End();
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public sealed virtual bool Equals(Range other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    public static Range StartAt(Index start);
    public static Range EndAt(Index end);
    public static Range get_All();
    public ValueTuple`2<int, int> GetOffsetAndLength(int length);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableAttribute("0")]
[NullableContextAttribute("2")]
public class System.RankException : SystemException {
    public RankException(string message);
    public RankException(string message, Exception innerException);
    [NullableContextAttribute("1")]
protected RankException(SerializationInfo info, StreamingContext context);
}
[DebuggerDisplayAttribute("{ToString(),raw}")]
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerTypeProxyAttribute("System.MemoryDebugView`1")]
public class System.ReadOnlyMemory`1 : ValueType {
    private object _object;
    private int _index;
    private int _length;
    internal static int RemoveFlagsBitMask;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ReadOnlyMemory`1<T> Empty { get; }
    public int Length { get; }
    public bool IsEmpty { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlySpan`1<T> Span { get; }
    public ReadOnlyMemory`1(T[] array);
    public ReadOnlyMemory`1(T[] array, int start, int length);
    internal ReadOnlyMemory`1(object obj, int start, int length);
    public static ReadOnlyMemory`1<T> op_Implicit(T[] array);
    public static ReadOnlyMemory`1<T> op_Implicit(ArraySegment`1<T> segment);
    public static ReadOnlyMemory`1<T> get_Empty();
    public int get_Length();
    public bool get_IsEmpty();
    public virtual string ToString();
    public ReadOnlyMemory`1<T> Slice(int start);
    public ReadOnlyMemory`1<T> Slice(int start, int length);
    public ReadOnlySpan`1<T> get_Span();
    public void CopyTo(Memory`1<T> destination);
    public bool TryCopyTo(Memory`1<T> destination);
    public MemoryHandle Pin();
    public T[] ToArray();
    [NullableContextAttribute("2")]
[EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ReadOnlyMemory`1<T> other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    internal object GetObjectStartLength(Int32& start, Int32& length);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.SpanDebugView`1")]
[DebuggerDisplayAttribute("{ToString(),raw}")]
[NonVersionableAttribute]
public class System.ReadOnlySpan`1 : ValueType {
    internal ByReference`1<T> _pointer;
    private int _length;
    public int Length { get; }
    public bool IsEmpty { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ReadOnlySpan`1<T> Empty { get; }
    [IsReadOnlyAttribute]
public T& modreq(System.Runtime.InteropServices.InAttribute) Item { get; }
    public ReadOnlySpan`1(T[] array);
    public ReadOnlySpan`1(T[] array, int start, int length);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public ReadOnlySpan`1(Void* pointer, int length);
    internal ReadOnlySpan`1(T& ptr, int length);
    [NonVersionableAttribute]
public int get_Length();
    [NonVersionableAttribute]
public bool get_IsEmpty();
    public static bool op_Inequality(ReadOnlySpan`1<T> left, ReadOnlySpan`1<T> right);
    [ObsoleteAttribute("Equals() on ReadOnlySpan will always throw an exception. Use == instead.")]
[EditorBrowsableAttribute("1")]
[NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("GetHashCode() on ReadOnlySpan will always throw an exception.")]
public virtual int GetHashCode();
    public static ReadOnlySpan`1<T> op_Implicit(T[] array);
    public static ReadOnlySpan`1<T> op_Implicit(ArraySegment`1<T> segment);
    public static ReadOnlySpan`1<T> get_Empty();
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    [IntrinsicAttribute]
[NonVersionableAttribute]
public T& modreq(System.Runtime.InteropServices.InAttribute) get_Item(int index);
    [EditorBrowsableAttribute("1")]
public T& modreq(System.Runtime.InteropServices.InAttribute) GetPinnableReference();
    public void CopyTo(Span`1<T> destination);
    public bool TryCopyTo(Span`1<T> destination);
    public static bool op_Equality(ReadOnlySpan`1<T> left, ReadOnlySpan`1<T> right);
    public virtual string ToString();
    public ReadOnlySpan`1<T> Slice(int start);
    public ReadOnlySpan`1<T> Slice(int start, int length);
    public T[] ToArray();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Reflection.AmbiguousMatchException : SystemException {
    public AmbiguousMatchException(string message);
    public AmbiguousMatchException(string message, Exception inner);
    internal AmbiguousMatchException(SerializationInfo info, StreamingContext context);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public abstract class System.Reflection.Assembly : object {
    private static bool s_forceNullEntryPoint;
    private static Dictionary`2<string, Assembly> s_loadfile;
    private static List`1<string> s_loadFromAssemblyList;
    private static bool s_loadFromHandlerSet;
    private static int s_cachedSerializationSwitch;
    public IEnumerable`1<TypeInfo> DefinedTypes { get; }
    public IEnumerable`1<Type> ExportedTypes { get; }
    [NullableAttribute("2")]
public string CodeBase { get; }
    [NullableAttribute("2")]
public MethodInfo EntryPoint { get; }
    [NullableAttribute("2")]
public string FullName { get; }
    public string ImageRuntimeVersion { get; }
    public bool IsDynamic { get; }
    public string Location { get; }
    public bool ReflectionOnly { get; }
    public bool IsCollectible { get; }
    public bool IsFullyTrusted { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public string EscapedCodeBase { get; }
    public Module ManifestModule { get; }
    public IEnumerable`1<Module> Modules { get; }
    public bool GlobalAssemblyCache { get; }
    public long HostContext { get; }
    public SecurityRuleSet SecurityRuleSet { get; }
    private static Assembly();
    public static Assembly Load(string assemblyString);
    [ObsoleteAttribute("This method has been deprecated. Please use Assembly.Load() instead. https://go.microsoft.com/fwlink/?linkid=14202")]
public static Assembly LoadWithPartialName(string partialName);
    public static Assembly Load(AssemblyName assemblyRef);
    internal static Assembly Load(AssemblyName assemblyRef, StackCrawlMark& stackMark, AssemblyLoadContext assemblyLoadContext);
    private static void GetExecutingAssemblyNative(StackCrawlMarkHandle stackMark, ObjectHandleOnStack retAssembly);
    internal static RuntimeAssembly GetExecutingAssembly(StackCrawlMark& stackMark);
    public static Assembly GetExecutingAssembly();
    public static Assembly GetCallingAssembly();
    private static void GetEntryAssemblyNative(ObjectHandleOnStack retAssembly);
    [NullableContextAttribute("2")]
public static Assembly GetEntryAssembly();
    internal bool IsRuntimeImplemented();
    internal static UInt32 GetAssemblyCount();
    public virtual IEnumerable`1<TypeInfo> get_DefinedTypes();
    public virtual Type[] GetTypes();
    public virtual IEnumerable`1<Type> get_ExportedTypes();
    public virtual Type[] GetExportedTypes();
    public virtual Type[] GetForwardedTypes();
    [NullableContextAttribute("2")]
public virtual string get_CodeBase();
    [NullableContextAttribute("2")]
public virtual MethodInfo get_EntryPoint();
    [NullableContextAttribute("2")]
public virtual string get_FullName();
    public virtual string get_ImageRuntimeVersion();
    public virtual bool get_IsDynamic();
    public virtual string get_Location();
    public virtual bool get_ReflectionOnly();
    public virtual bool get_IsCollectible();
    public virtual ManifestResourceInfo GetManifestResourceInfo(string resourceName);
    public virtual String[] GetManifestResourceNames();
    public virtual Stream GetManifestResourceStream(string name);
    public virtual Stream GetManifestResourceStream(Type type, string name);
    public bool get_IsFullyTrusted();
    public virtual AssemblyName GetName();
    public virtual AssemblyName GetName(bool copiedName);
    public virtual Type GetType(string name);
    public virtual Type GetType(string name, bool throwOnError);
    public virtual Type GetType(string name, bool throwOnError, bool ignoreCase);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual string get_EscapedCodeBase();
    public object CreateInstance(string typeName);
    public object CreateInstance(string typeName, bool ignoreCase);
    [NullableContextAttribute("2")]
public virtual object CreateInstance(string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    [NullableContextAttribute("2")]
public virtual void add_ModuleResolve(ModuleResolveEventHandler value);
    [NullableContextAttribute("2")]
public virtual void remove_ModuleResolve(ModuleResolveEventHandler value);
    public virtual Module get_ManifestModule();
    public virtual Module GetModule(string name);
    public Module[] GetModules();
    public virtual Module[] GetModules(bool getResourceModules);
    public virtual IEnumerable`1<Module> get_Modules();
    public Module[] GetLoadedModules();
    public virtual Module[] GetLoadedModules(bool getResourceModules);
    public virtual AssemblyName[] GetReferencedAssemblies();
    public virtual Assembly GetSatelliteAssembly(CultureInfo culture);
    public virtual Assembly GetSatelliteAssembly(CultureInfo culture, Version version);
    public virtual FileStream GetFile(string name);
    public virtual FileStream[] GetFiles();
    public virtual FileStream[] GetFiles(bool getResourceModules);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
    public virtual bool get_GlobalAssemblyCache();
    public virtual long get_HostContext();
    [NullableContextAttribute("2")]
public virtual bool Equals(object o);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public static bool op_Equality(Assembly left, Assembly right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(Assembly left, Assembly right);
    [NullableContextAttribute("2")]
public static string CreateQualifiedName(string assemblyName, string typeName);
    public static Assembly GetAssembly(Type type);
    public static Assembly Load(Byte[] rawAssembly);
    public static Assembly Load(Byte[] rawAssembly, Byte[] rawSymbolStore);
    public static Assembly LoadFile(string path);
    private static Assembly LoadFromResolveHandler(object sender, ResolveEventArgs args);
    public static Assembly LoadFrom(string assemblyFile);
    public static Assembly LoadFrom(string assemblyFile, Byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm);
    public static Assembly UnsafeLoadFrom(string assemblyFile);
    public Module LoadModule(string moduleName, Byte[] rawModule);
    public virtual Module LoadModule(string moduleName, Byte[] rawModule, Byte[] rawSymbolStore);
    public static Assembly ReflectionOnlyLoad(Byte[] rawAssembly);
    public static Assembly ReflectionOnlyLoad(string assemblyString);
    public static Assembly ReflectionOnlyLoadFrom(string assemblyFile);
    public virtual SecurityRuleSet get_SecurityRuleSet();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyAlgorithmIdAttribute : Attribute {
    [CompilerGeneratedAttribute]
private UInt32 <AlgorithmId>k__BackingField;
    [CLSCompliantAttribute("False")]
public UInt32 AlgorithmId { get; }
    public AssemblyAlgorithmIdAttribute(AssemblyHashAlgorithm algorithmId);
    [CLSCompliantAttribute("False")]
public AssemblyAlgorithmIdAttribute(UInt32 algorithmId);
    [CompilerGeneratedAttribute]
public UInt32 get_AlgorithmId();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyCompanyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Company>k__BackingField;
    public string Company { get; }
    public AssemblyCompanyAttribute(string company);
    [CompilerGeneratedAttribute]
public string get_Company();
}
[NullableContextAttribute("1")]
[AttributeUsageAttribute("1")]
[NullableAttribute("0")]
public class System.Reflection.AssemblyConfigurationAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Configuration>k__BackingField;
    public string Configuration { get; }
    public AssemblyConfigurationAttribute(string configuration);
    [CompilerGeneratedAttribute]
public string get_Configuration();
}
public enum System.Reflection.AssemblyContentType : Enum {
    public int value__;
    public static AssemblyContentType Default;
    public static AssemblyContentType WindowsRuntime;
}
[AttributeUsageAttribute("1")]
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Reflection.AssemblyCopyrightAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Copyright>k__BackingField;
    public string Copyright { get; }
    public AssemblyCopyrightAttribute(string copyright);
    [CompilerGeneratedAttribute]
public string get_Copyright();
}
[AttributeUsageAttribute("1")]
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Reflection.AssemblyCultureAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Culture>k__BackingField;
    public string Culture { get; }
    public AssemblyCultureAttribute(string culture);
    [CompilerGeneratedAttribute]
public string get_Culture();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyDefaultAliasAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <DefaultAlias>k__BackingField;
    public string DefaultAlias { get; }
    public AssemblyDefaultAliasAttribute(string defaultAlias);
    [CompilerGeneratedAttribute]
public string get_DefaultAlias();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyDelaySignAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <DelaySign>k__BackingField;
    public bool DelaySign { get; }
    public AssemblyDelaySignAttribute(bool delaySign);
    [CompilerGeneratedAttribute]
public bool get_DelaySign();
}
[AttributeUsageAttribute("1")]
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Reflection.AssemblyDescriptionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public string Description { get; }
    public AssemblyDescriptionAttribute(string description);
    [CompilerGeneratedAttribute]
public string get_Description();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyFileVersionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    public string Version { get; }
    public AssemblyFileVersionAttribute(string version);
    [CompilerGeneratedAttribute]
public string get_Version();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyFlagsAttribute : Attribute {
    private AssemblyNameFlags _flags;
    [ObsoleteAttribute("This property has been deprecated. Please use AssemblyFlags instead. https://go.microsoft.com/fwlink/?linkid=14202")]
[CLSCompliantAttribute("False")]
public UInt32 Flags { get; }
    public int AssemblyFlags { get; }
    [ObsoleteAttribute("This constructor has been deprecated. Please use AssemblyFlagsAttribute(AssemblyNameFlags) instead. https://go.microsoft.com/fwlink/?linkid=14202")]
[CLSCompliantAttribute("False")]
public AssemblyFlagsAttribute(UInt32 flags);
    [ObsoleteAttribute("This constructor has been deprecated. Please use AssemblyFlagsAttribute(AssemblyNameFlags) instead. https://go.microsoft.com/fwlink/?linkid=14202")]
public AssemblyFlagsAttribute(int assemblyFlags);
    public AssemblyFlagsAttribute(AssemblyNameFlags assemblyFlags);
    public UInt32 get_Flags();
    public int get_AssemblyFlags();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyInformationalVersionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <InformationalVersion>k__BackingField;
    public string InformationalVersion { get; }
    public AssemblyInformationalVersionAttribute(string informationalVersion);
    [CompilerGeneratedAttribute]
public string get_InformationalVersion();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyKeyFileAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <KeyFile>k__BackingField;
    public string KeyFile { get; }
    public AssemblyKeyFileAttribute(string keyFile);
    [CompilerGeneratedAttribute]
public string get_KeyFile();
}
[AttributeUsageAttribute("1")]
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Reflection.AssemblyKeyNameAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <KeyName>k__BackingField;
    public string KeyName { get; }
    public AssemblyKeyNameAttribute(string keyName);
    [CompilerGeneratedAttribute]
public string get_KeyName();
}
[AttributeUsageAttribute("1")]
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Reflection.AssemblyMetadataAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Key { get; }
    [NullableAttribute("2")]
public string Value { get; }
    public AssemblyMetadataAttribute(string key, string value);
    [CompilerGeneratedAttribute]
public string get_Key();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Value();
}
[NullableAttribute("0")]
[NullableContextAttribute("2")]
public class System.Reflection.AssemblyName : object {
    private string _name;
    private Byte[] _publicKey;
    private Byte[] _publicKeyToken;
    private CultureInfo _cultureInfo;
    private string _codeBase;
    private Version _version;
    private StrongNameKeyPair _strongNameKeyPair;
    private AssemblyHashAlgorithm _hashAlgorithm;
    private AssemblyVersionCompatibility _versionCompatibility;
    private AssemblyNameFlags _flags;
    private static Char[] s_hexUpperChars;
    internal static char c_DummyChar;
    private static short c_MaxAsciiCharsReallocate;
    private static short c_MaxUnicodeCharsReallocate;
    private static short c_MaxUTF_8BytesPerUnicodeChar;
    private static short c_EncodedCharsPerByte;
    private static string RFC3986ReservedMarks;
    private static string RFC3986UnreservedMarks;
    public string Name { get; public set; }
    public Version Version { get; public set; }
    public CultureInfo CultureInfo { get; public set; }
    public string CultureName { get; public set; }
    public string CodeBase { get; public set; }
    public string EscapedCodeBase { get; }
    public ProcessorArchitecture ProcessorArchitecture { get; public set; }
    public AssemblyContentType ContentType { get; public set; }
    public AssemblyNameFlags Flags { get; public set; }
    public AssemblyHashAlgorithm HashAlgorithm { get; public set; }
    public AssemblyVersionCompatibility VersionCompatibility { get; public set; }
    public StrongNameKeyPair KeyPair { get; public set; }
    [NullableAttribute("1")]
public string FullName { get; }
    [NullableContextAttribute("1")]
public AssemblyName(string assemblyName);
    internal AssemblyName(string name, Byte[] publicKey, Byte[] publicKeyToken, Version version, CultureInfo cultureInfo, AssemblyHashAlgorithm hashAlgorithm, AssemblyVersionCompatibility versionCompatibility, string codeBase, AssemblyNameFlags flags, StrongNameKeyPair keyPair);
    private static AssemblyName();
    internal void nInit();
    internal static AssemblyName nGetFileInformation(string s);
    internal static AssemblyName GetFileInformationCore(string assemblyFile);
    private Byte[] ComputePublicKeyToken();
    internal void SetProcArchIndex(PortableExecutableKinds pek, ImageFileMachine ifm);
    internal static ProcessorArchitecture CalculateProcArchIndex(PortableExecutableKinds pek, ImageFileMachine ifm, AssemblyNameFlags flags);
    public string get_Name();
    public void set_Name(string value);
    public Version get_Version();
    public void set_Version(Version value);
    public CultureInfo get_CultureInfo();
    public void set_CultureInfo(CultureInfo value);
    public string get_CultureName();
    public void set_CultureName(string value);
    public string get_CodeBase();
    public void set_CodeBase(string value);
    public string get_EscapedCodeBase();
    public ProcessorArchitecture get_ProcessorArchitecture();
    public void set_ProcessorArchitecture(ProcessorArchitecture value);
    public AssemblyContentType get_ContentType();
    public void set_ContentType(AssemblyContentType value);
    [NullableContextAttribute("1")]
public sealed virtual object Clone();
    [NullableContextAttribute("1")]
public static AssemblyName GetAssemblyName(string assemblyFile);
    public Byte[] GetPublicKey();
    public void SetPublicKey(Byte[] publicKey);
    public Byte[] GetPublicKeyToken();
    public void SetPublicKeyToken(Byte[] publicKeyToken);
    public AssemblyNameFlags get_Flags();
    public void set_Flags(AssemblyNameFlags value);
    public AssemblyHashAlgorithm get_HashAlgorithm();
    public void set_HashAlgorithm(AssemblyHashAlgorithm value);
    public AssemblyVersionCompatibility get_VersionCompatibility();
    public void set_VersionCompatibility(AssemblyVersionCompatibility value);
    public StrongNameKeyPair get_KeyPair();
    public void set_KeyPair(StrongNameKeyPair value);
    [NullableContextAttribute("1")]
public string get_FullName();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public sealed virtual void OnDeserialization(object sender);
    public static bool ReferenceMatchesDefinition(AssemblyName reference, AssemblyName definition);
    internal static string EscapeCodeBase(string codebase);
    internal static Char[] EscapeString(string input, int start, int end, Char[] dest, Int32& destPos, bool isUriString, char force1, char force2, char rsvd);
    private static Char[] EnsureDestinationSize(Char* pStr, Char[] dest, int currentInputPos, short charsToAdd, short minReallocateChars, Int32& destPos, int prevInputPos);
    internal static void EscapeAsciiChar(char ch, Char[] to, Int32& pos);
    internal static char EscapedAscii(char digit, char next);
    private static bool IsReservedUnreservedOrHash(char c);
    internal static bool IsUnreserved(char c);
    internal static bool IsAsciiLetter(char character);
    internal static bool IsAsciiLetterOrDigit(char character);
}
[FlagsAttribute]
public enum System.Reflection.AssemblyNameFlags : Enum {
    public int value__;
    public static AssemblyNameFlags None;
    public static AssemblyNameFlags PublicKey;
    public static AssemblyNameFlags EnableJITcompileOptimizer;
    public static AssemblyNameFlags EnableJITcompileTracking;
    public static AssemblyNameFlags Retargetable;
}
[ExtensionAttribute]
internal static class System.Reflection.AssemblyNameFormatter : object {
    public static KeyValuePair`2[] EscapeSequences;
    private static AssemblyNameFormatter();
    public static string ComputeDisplayName(string name, Version version, string cultureName, Byte[] pkt, AssemblyNameFlags flags, AssemblyContentType contentType);
    [ExtensionAttribute]
private static void AppendQuoted(StringBuilder sb, string s);
    [ExtensionAttribute]
private static Version CanonicalizeVersion(Version version);
}
[AttributeUsageAttribute("1")]
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Reflection.AssemblyProductAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Product>k__BackingField;
    public string Product { get; }
    public AssemblyProductAttribute(string product);
    [CompilerGeneratedAttribute]
public string get_Product();
}
[AttributeUsageAttribute("1")]
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Reflection.AssemblySignatureKeyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <PublicKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Countersignature>k__BackingField;
    public string PublicKey { get; }
    public string Countersignature { get; }
    public AssemblySignatureKeyAttribute(string publicKey, string countersignature);
    [CompilerGeneratedAttribute]
public string get_PublicKey();
    [CompilerGeneratedAttribute]
public string get_Countersignature();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyTitleAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    public string Title { get; }
    public AssemblyTitleAttribute(string title);
    [CompilerGeneratedAttribute]
public string get_Title();
}
[AttributeUsageAttribute("1")]
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Reflection.AssemblyTrademarkAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Trademark>k__BackingField;
    public string Trademark { get; }
    public AssemblyTrademarkAttribute(string trademark);
    [CompilerGeneratedAttribute]
public string get_Trademark();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyVersionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    public string Version { get; }
    public AssemblyVersionAttribute(string version);
    [CompilerGeneratedAttribute]
public string get_Version();
}
internal static class System.Reflection.Associates : object {
    internal static bool IncludeAccessor(MethodInfo associate, bool nonPublic);
    private static RuntimeMethodInfo AssignAssociates(int tkMethod, RuntimeType declaredType, RuntimeType reflectedType);
    internal static void AssignAssociates(MetadataImport scope, int mdPropEvent, RuntimeType declaringType, RuntimeType reflectedType, RuntimeMethodInfo& addOn, RuntimeMethodInfo& removeOn, RuntimeMethodInfo& fireOn, RuntimeMethodInfo& getter, RuntimeMethodInfo& setter, MethodInfo[]& other, Boolean& composedOfAllPrivateMethods, BindingFlags& bindingFlags);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Reflection.Binder : object {
    public abstract virtual FieldInfo BindToField(BindingFlags bindingAttr, FieldInfo[] match, object value, CultureInfo culture);
    [NullableContextAttribute("2")]
public abstract virtual MethodBase BindToMethod(BindingFlags bindingAttr, MethodBase[] match, Object[]& args, ParameterModifier[] modifiers, CultureInfo culture, String[] names, Object& state);
    public abstract virtual object ChangeType(object value, Type type, CultureInfo culture);
    public abstract virtual void ReorderArgumentArray(Object[]& args, object state);
    public abstract virtual MethodBase SelectMethod(BindingFlags bindingAttr, MethodBase[] match, Type[] types, ParameterModifier[] modifiers);
    [NullableContextAttribute("2")]
public abstract virtual PropertyInfo SelectProperty(BindingFlags bindingAttr, PropertyInfo[] match, Type returnType, Type[] indexes, ParameterModifier[] modifiers);
}
[FlagsAttribute]
public enum System.Reflection.BindingFlags : Enum {
    public int value__;
    public static BindingFlags Default;
    public static BindingFlags IgnoreCase;
    public static BindingFlags DeclaredOnly;
    public static BindingFlags Instance;
    public static BindingFlags Static;
    public static BindingFlags Public;
    public static BindingFlags NonPublic;
    public static BindingFlags FlattenHierarchy;
    public static BindingFlags InvokeMethod;
    public static BindingFlags CreateInstance;
    public static BindingFlags GetField;
    public static BindingFlags SetField;
    public static BindingFlags GetProperty;
    public static BindingFlags SetProperty;
    public static BindingFlags PutDispProperty;
    public static BindingFlags PutRefDispProperty;
    public static BindingFlags ExactBinding;
    public static BindingFlags SuppressChangeType;
    public static BindingFlags OptionalParamBinding;
    public static BindingFlags IgnoreReturn;
    public static BindingFlags DoNotWrapExceptions;
}
[FlagsAttribute]
public enum System.Reflection.CallingConventions : Enum {
    public int value__;
    public static CallingConventions Standard;
    public static CallingConventions VarArgs;
    public static CallingConventions Any;
    public static CallingConventions HasThis;
    public static CallingConventions ExplicitThis;
}
[DefaultMemberAttribute("Item")]
internal class System.Reflection.CerHashtable`2 : ValueType {
    private Table<K, V> m_Table;
    internal V Item { get; internal set; }
    private static int GetHashCodeHelper(K key);
    private void Rehash(int newSize);
    internal void set_Item(K key, V value);
    internal V get_Item(K key);
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class System.Reflection.ConstArray : ValueType {
    internal int m_length;
    internal IntPtr m_constArray;
    public IntPtr Signature { get; }
    public int Length { get; }
    public byte Item { get; }
    public IntPtr get_Signature();
    public int get_Length();
    public byte get_Item(int index);
}
[NullableAttribute("0")]
[NullableContextAttribute("2")]
public abstract class System.Reflection.ConstructorInfo : MethodBase {
    [NullableAttribute("1")]
public static string ConstructorName;
    [NullableAttribute("1")]
public static string TypeConstructorName;
    public MemberTypes MemberType { get; }
    private static ConstructorInfo();
    internal virtual Type GetReturnType();
    public virtual MemberTypes get_MemberType();
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
[NullableContextAttribute("1")]
public object Invoke(Object[] parameters);
    public abstract virtual object Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ConstructorInfo left, ConstructorInfo right);
    public static bool op_Inequality(ConstructorInfo left, ConstructorInfo right);
}
internal enum System.Reflection.CorElementType : Enum {
    public byte value__;
    public static CorElementType ELEMENT_TYPE_END;
    public static CorElementType ELEMENT_TYPE_VOID;
    public static CorElementType ELEMENT_TYPE_BOOLEAN;
    public static CorElementType ELEMENT_TYPE_CHAR;
    public static CorElementType ELEMENT_TYPE_I1;
    public static CorElementType ELEMENT_TYPE_U1;
    public static CorElementType ELEMENT_TYPE_I2;
    public static CorElementType ELEMENT_TYPE_U2;
    public static CorElementType ELEMENT_TYPE_I4;
    public static CorElementType ELEMENT_TYPE_U4;
    public static CorElementType ELEMENT_TYPE_I8;
    public static CorElementType ELEMENT_TYPE_U8;
    public static CorElementType ELEMENT_TYPE_R4;
    public static CorElementType ELEMENT_TYPE_R8;
    public static CorElementType ELEMENT_TYPE_STRING;
    public static CorElementType ELEMENT_TYPE_PTR;
    public static CorElementType ELEMENT_TYPE_BYREF;
    public static CorElementType ELEMENT_TYPE_VALUETYPE;
    public static CorElementType ELEMENT_TYPE_CLASS;
    public static CorElementType ELEMENT_TYPE_VAR;
    public static CorElementType ELEMENT_TYPE_ARRAY;
    public static CorElementType ELEMENT_TYPE_GENERICINST;
    public static CorElementType ELEMENT_TYPE_TYPEDBYREF;
    public static CorElementType ELEMENT_TYPE_I;
    public static CorElementType ELEMENT_TYPE_U;
    public static CorElementType ELEMENT_TYPE_FNPTR;
    public static CorElementType ELEMENT_TYPE_OBJECT;
    public static CorElementType ELEMENT_TYPE_SZARRAY;
    public static CorElementType ELEMENT_TYPE_MVAR;
    public static CorElementType ELEMENT_TYPE_CMOD_REQD;
    public static CorElementType ELEMENT_TYPE_CMOD_OPT;
    public static CorElementType ELEMENT_TYPE_INTERNAL;
    public static CorElementType ELEMENT_TYPE_MAX;
    public static CorElementType ELEMENT_TYPE_MODIFIER;
    public static CorElementType ELEMENT_TYPE_SENTINEL;
    public static CorElementType ELEMENT_TYPE_PINNED;
}
internal static class System.Reflection.CustomAttribute : object {
    private static RuntimeType Type_RuntimeType;
    private static RuntimeType Type_Type;
    private static CustomAttribute();
    internal static bool IsDefined(RuntimeType type, RuntimeType caType, bool inherit);
    internal static bool IsDefined(RuntimeMethodInfo method, RuntimeType caType, bool inherit);
    internal static bool IsDefined(RuntimeConstructorInfo ctor, RuntimeType caType);
    internal static bool IsDefined(RuntimePropertyInfo property, RuntimeType caType);
    internal static bool IsDefined(RuntimeEventInfo e, RuntimeType caType);
    internal static bool IsDefined(RuntimeFieldInfo field, RuntimeType caType);
    internal static bool IsDefined(RuntimeParameterInfo parameter, RuntimeType caType);
    internal static bool IsDefined(RuntimeAssembly assembly, RuntimeType caType);
    internal static bool IsDefined(RuntimeModule module, RuntimeType caType);
    internal static Object[] GetCustomAttributes(RuntimeType type, RuntimeType caType, bool inherit);
    internal static Object[] GetCustomAttributes(RuntimeMethodInfo method, RuntimeType caType, bool inherit);
    internal static Object[] GetCustomAttributes(RuntimeConstructorInfo ctor, RuntimeType caType);
    internal static Object[] GetCustomAttributes(RuntimePropertyInfo property, RuntimeType caType);
    internal static Object[] GetCustomAttributes(RuntimeEventInfo e, RuntimeType caType);
    internal static Object[] GetCustomAttributes(RuntimeFieldInfo field, RuntimeType caType);
    internal static Object[] GetCustomAttributes(RuntimeParameterInfo parameter, RuntimeType caType);
    internal static Object[] GetCustomAttributes(RuntimeAssembly assembly, RuntimeType caType);
    internal static Object[] GetCustomAttributes(RuntimeModule module, RuntimeType caType);
    private static bool IsCustomAttributeDefined(RuntimeModule decoratedModule, int decoratedMetadataToken, RuntimeType attributeFilterType);
    private static bool IsCustomAttributeDefined(RuntimeModule decoratedModule, int decoratedMetadataToken, RuntimeType attributeFilterType, int attributeCtorToken, bool mustBeInheritable);
    private static Object[] GetCustomAttributes(RuntimeModule decoratedModule, int decoratedMetadataToken, int pcaCount, RuntimeType attributeFilterType);
    private static void AddCustomAttributes(ListBuilder`1& attributes, RuntimeModule decoratedModule, int decoratedMetadataToken, RuntimeType attributeFilterType, bool mustBeInheritable, ListBuilder`1<object> derivedAttributes);
    private static bool FilterCustomAttributeRecord(MetadataToken caCtorToken, MetadataImport& scope, RuntimeModule decoratedModule, MetadataToken decoratedToken, RuntimeType attributeFilterType, bool mustBeInheritable, ListBuilder`1& derivedAttributes, RuntimeType& attributeType, IRuntimeMethodInfo& ctor, Boolean& ctorHasParameters, Boolean& isVarArg);
    private static bool AttributeUsageCheck(RuntimeType attributeType, bool mustBeInheritable, ListBuilder`1& derivedAttributes);
    internal static AttributeUsageAttribute GetAttributeUsage(RuntimeType decoratedAttribute);
    private static void _ParseAttributeUsageAttribute(IntPtr pCa, int cCa, Int32& targets, Boolean& inherited, Boolean& allowMultiple);
    private static void ParseAttributeUsageAttribute(ConstArray ca, AttributeTargets& targets, Boolean& inherited, Boolean& allowMultiple);
    private static object _CreateCaObject(RuntimeModule pModule, RuntimeType type, IRuntimeMethodInfo pCtor, Byte** ppBlob, Byte* pEndBlob, Int32* pcNamedArgs);
    private static object CreateCaObject(RuntimeModule module, RuntimeType type, IRuntimeMethodInfo ctor, IntPtr& blob, IntPtr blobEnd, Int32& namedArgs);
    private static void _GetPropertyOrFieldData(RuntimeModule pModule, Byte** ppBlobStart, Byte* pBlobEnd, String& name, Boolean& bIsProperty, RuntimeType& type, Object& value);
    private static void GetPropertyOrFieldData(RuntimeModule module, IntPtr& blobStart, IntPtr blobEnd, String& name, Boolean& isProperty, RuntimeType& type, Object& value);
    private static Object[] CreateAttributeArrayHelper(RuntimeType elementType, int elementCount);
}
[IsReadOnlyAttribute]
internal class System.Reflection.CustomAttributeCtorParameter : ValueType {
    private CustomAttributeType m_type;
    private CustomAttributeEncodedArgument m_encodedArgument;
    public CustomAttributeEncodedArgument CustomAttributeEncodedArgument { get; }
    public CustomAttributeCtorParameter(CustomAttributeType type);
    public CustomAttributeEncodedArgument get_CustomAttributeEncodedArgument();
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Reflection.CustomAttributeData : object {
    private ConstructorInfo m_ctor;
    private RuntimeModule m_scope;
    private MemberInfo[] m_members;
    private CustomAttributeCtorParameter[] m_ctorParams;
    private CustomAttributeNamedParameter[] m_namedParams;
    private IList`1<CustomAttributeTypedArgument> m_typedCtorArgs;
    private IList`1<CustomAttributeNamedArgument> m_namedArgs;
    public Type AttributeType { get; }
    public ConstructorInfo Constructor { get; }
    public IList`1<CustomAttributeTypedArgument> ConstructorArguments { get; }
    public IList`1<CustomAttributeNamedArgument> NamedArguments { get; }
    private CustomAttributeData(RuntimeModule scope, MetadataToken caCtorToken, ConstArray& blob);
    internal CustomAttributeData(Attribute attribute);
    public static IList`1<CustomAttributeData> GetCustomAttributes(MemberInfo target);
    public static IList`1<CustomAttributeData> GetCustomAttributes(Module target);
    public static IList`1<CustomAttributeData> GetCustomAttributes(Assembly target);
    public static IList`1<CustomAttributeData> GetCustomAttributes(ParameterInfo target);
    internal static IList`1<CustomAttributeData> GetCustomAttributesInternal(RuntimeType target);
    internal static IList`1<CustomAttributeData> GetCustomAttributesInternal(RuntimeFieldInfo target);
    internal static IList`1<CustomAttributeData> GetCustomAttributesInternal(RuntimeMethodInfo target);
    internal static IList`1<CustomAttributeData> GetCustomAttributesInternal(RuntimeConstructorInfo target);
    internal static IList`1<CustomAttributeData> GetCustomAttributesInternal(RuntimeEventInfo target);
    internal static IList`1<CustomAttributeData> GetCustomAttributesInternal(RuntimePropertyInfo target);
    internal static IList`1<CustomAttributeData> GetCustomAttributesInternal(RuntimeModule target);
    internal static IList`1<CustomAttributeData> GetCustomAttributesInternal(RuntimeAssembly target);
    internal static IList`1<CustomAttributeData> GetCustomAttributesInternal(RuntimeParameterInfo target);
    private static IList`1<CustomAttributeData> GetCombinedList(IList`1<CustomAttributeData> customAttributes, ListBuilder`1& pseudoAttributes);
    private static CustomAttributeEncoding TypeToCustomAttributeEncoding(RuntimeType type);
    private static CustomAttributeType InitCustomAttributeType(RuntimeType parameterType);
    private static IList`1<CustomAttributeData> GetCustomAttributes(RuntimeModule module, int tkTarget);
    internal static CustomAttributeRecord[] GetCustomAttributeRecords(RuntimeModule module, int targetToken);
    internal static CustomAttributeTypedArgument Filter(IList`1<CustomAttributeData> attrs, Type caType, int parameter);
    private void Init(DllImportAttribute dllImport);
    private void Init(FieldOffsetAttribute fieldOffset);
    private void Init(MarshalAsAttribute marshalAs);
    private void Init(TypeForwardedToAttribute forwardedTo);
    private void Init(object pca);
    public virtual string ToString();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual Type get_AttributeType();
    public virtual ConstructorInfo get_Constructor();
    public virtual IList`1<CustomAttributeTypedArgument> get_ConstructorArguments();
    public virtual IList`1<CustomAttributeNamedArgument> get_NamedArguments();
}
[IsReadOnlyAttribute]
internal class System.Reflection.CustomAttributeEncodedArgument : ValueType {
    private long m_primitiveValue;
    private CustomAttributeEncodedArgument[] m_arrayValue;
    private string m_stringValue;
    private CustomAttributeType m_type;
    public CustomAttributeType CustomAttributeType { get; }
    public long PrimitiveValue { get; }
    public CustomAttributeEncodedArgument[] ArrayValue { get; }
    public string StringValue { get; }
    private static void ParseAttributeArguments(IntPtr pCa, int cCa, CustomAttributeCtorParameter[]& CustomAttributeCtorParameters, CustomAttributeNamedParameter[]& CustomAttributeTypedArgument, RuntimeAssembly assembly);
    internal static void ParseAttributeArguments(ConstArray attributeBlob, CustomAttributeCtorParameter[]& customAttributeCtorParameters, CustomAttributeNamedParameter[]& customAttributeNamedParameters, RuntimeModule customAttributeModule);
    public CustomAttributeType get_CustomAttributeType();
    public long get_PrimitiveValue();
    public CustomAttributeEncodedArgument[] get_ArrayValue();
    public string get_StringValue();
}
internal enum System.Reflection.CustomAttributeEncoding : Enum {
    public int value__;
    public static CustomAttributeEncoding Undefined;
    public static CustomAttributeEncoding Boolean;
    public static CustomAttributeEncoding Char;
    public static CustomAttributeEncoding SByte;
    public static CustomAttributeEncoding Byte;
    public static CustomAttributeEncoding Int16;
    public static CustomAttributeEncoding UInt16;
    public static CustomAttributeEncoding Int32;
    public static CustomAttributeEncoding UInt32;
    public static CustomAttributeEncoding Int64;
    public static CustomAttributeEncoding UInt64;
    public static CustomAttributeEncoding Float;
    public static CustomAttributeEncoding Double;
    public static CustomAttributeEncoding String;
    public static CustomAttributeEncoding Array;
    public static CustomAttributeEncoding Type;
    public static CustomAttributeEncoding Object;
    public static CustomAttributeEncoding Field;
    public static CustomAttributeEncoding Property;
    public static CustomAttributeEncoding Enum;
}
[NullableContextAttribute("1")]
[ExtensionAttribute]
[NullableAttribute("0")]
public static class System.Reflection.CustomAttributeExtensions : object {
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(Assembly element, Type attributeType);
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(Module element, Type attributeType);
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(MemberInfo element, Type attributeType);
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(ParameterInfo element, Type attributeType);
    [ExtensionAttribute]
public static T GetCustomAttribute(Assembly element);
    [ExtensionAttribute]
public static T GetCustomAttribute(Module element);
    [ExtensionAttribute]
public static T GetCustomAttribute(MemberInfo element);
    [ExtensionAttribute]
public static T GetCustomAttribute(ParameterInfo element);
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(MemberInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(ParameterInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static T GetCustomAttribute(MemberInfo element, bool inherit);
    [ExtensionAttribute]
public static T GetCustomAttribute(ParameterInfo element, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(Assembly element);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(Module element);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(MemberInfo element);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(ParameterInfo element);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(MemberInfo element, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(ParameterInfo element, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(Assembly element, Type attributeType);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(Module element, Type attributeType);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(MemberInfo element, Type attributeType);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(ParameterInfo element, Type attributeType);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(Assembly element);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(Module element);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(MemberInfo element);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(ParameterInfo element);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(MemberInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(ParameterInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(MemberInfo element, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(ParameterInfo element, bool inherit);
    [ExtensionAttribute]
public static bool IsDefined(Assembly element, Type attributeType);
    [ExtensionAttribute]
public static bool IsDefined(Module element, Type attributeType);
    [ExtensionAttribute]
public static bool IsDefined(MemberInfo element, Type attributeType);
    [ExtensionAttribute]
public static bool IsDefined(ParameterInfo element, Type attributeType);
    [ExtensionAttribute]
public static bool IsDefined(MemberInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static bool IsDefined(ParameterInfo element, Type attributeType, bool inherit);
}
[NullableAttribute("0")]
[NullableContextAttribute("2")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Reflection.CustomAttributeFormatException : FormatException {
    public CustomAttributeFormatException(string message);
    public CustomAttributeFormatException(string message, Exception inner);
    [NullableContextAttribute("1")]
protected CustomAttributeFormatException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[IsReadOnlyAttribute]
[NullableAttribute("0")]
public class System.Reflection.CustomAttributeNamedArgument : ValueType {
    private MemberInfo m_memberInfo;
    private CustomAttributeTypedArgument m_value;
    internal Type ArgumentType { get; }
    public MemberInfo MemberInfo { get; }
    public CustomAttributeTypedArgument TypedValue { get; }
    public string MemberName { get; }
    public bool IsField { get; }
    public CustomAttributeNamedArgument(MemberInfo memberInfo, object value);
    public CustomAttributeNamedArgument(MemberInfo memberInfo, CustomAttributeTypedArgument typedArgument);
    public static bool op_Equality(CustomAttributeNamedArgument left, CustomAttributeNamedArgument right);
    public static bool op_Inequality(CustomAttributeNamedArgument left, CustomAttributeNamedArgument right);
    public virtual string ToString();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    internal Type get_ArgumentType();
    public MemberInfo get_MemberInfo();
    public CustomAttributeTypedArgument get_TypedValue();
    public string get_MemberName();
    public bool get_IsField();
}
[IsReadOnlyAttribute]
internal class System.Reflection.CustomAttributeNamedParameter : ValueType {
    private string m_argumentName;
    private CustomAttributeEncoding m_fieldOrProperty;
    private CustomAttributeEncoding m_padding;
    private CustomAttributeType m_type;
    private CustomAttributeEncodedArgument m_encodedArgument;
    public CustomAttributeEncodedArgument EncodedArgument { get; }
    public CustomAttributeNamedParameter(string argumentName, CustomAttributeEncoding fieldOrProperty, CustomAttributeType type);
    public CustomAttributeEncodedArgument get_EncodedArgument();
}
internal class System.Reflection.CustomAttributeRecord : ValueType {
    internal ConstArray blob;
    internal MetadataToken tkCtor;
}
[IsReadOnlyAttribute]
internal class System.Reflection.CustomAttributeType : ValueType {
    private string m_enumName;
    private CustomAttributeEncoding m_encodedType;
    private CustomAttributeEncoding m_encodedEnumType;
    private CustomAttributeEncoding m_encodedArrayType;
    private CustomAttributeEncoding m_padding;
    public CustomAttributeEncoding EncodedType { get; }
    public CustomAttributeEncoding EncodedEnumType { get; }
    public CustomAttributeEncoding EncodedArrayType { get; }
    public string EnumName { get; }
    public CustomAttributeType(CustomAttributeEncoding encodedType, CustomAttributeEncoding encodedArrayType, CustomAttributeEncoding encodedEnumType, string enumName);
    public CustomAttributeEncoding get_EncodedType();
    public CustomAttributeEncoding get_EncodedEnumType();
    public CustomAttributeEncoding get_EncodedArrayType();
    public string get_EnumName();
}
[IsReadOnlyAttribute]
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Reflection.CustomAttributeTypedArgument : ValueType {
    private object m_value;
    private Type m_argumentType;
    public Type ArgumentType { get; }
    [NullableAttribute("2")]
public object Value { get; }
    internal CustomAttributeTypedArgument(RuntimeModule scope, CustomAttributeEncodedArgument encodedArg);
    public CustomAttributeTypedArgument(Type argumentType, object value);
    public CustomAttributeTypedArgument(object value);
    private static Type CustomAttributeEncodingToType(CustomAttributeEncoding encodedType);
    private static object EncodedValueToRawValue(long val, CustomAttributeEncoding encodedType);
    private static RuntimeType ResolveType(RuntimeModule scope, string typeName);
    private static object CanonicalizeValue(object value);
    public static bool op_Equality(CustomAttributeTypedArgument left, CustomAttributeTypedArgument right);
    public static bool op_Inequality(CustomAttributeTypedArgument left, CustomAttributeTypedArgument right);
    public virtual string ToString();
    internal string ToString(bool typed);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public Type get_ArgumentType();
    [NullableContextAttribute("2")]
public object get_Value();
}
[AttributeUsageAttribute("1036")]
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Reflection.DefaultMemberAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <MemberName>k__BackingField;
    public string MemberName { get; }
    public DefaultMemberAttribute(string memberName);
    [CompilerGeneratedAttribute]
public string get_MemberName();
}
internal class System.Reflection.Emit.__ExceptionInfo : object {
    internal int m_startAddr;
    internal Int32[] m_filterAddr;
    internal Int32[] m_catchAddr;
    internal Int32[] m_catchEndAddr;
    internal Int32[] m_type;
    internal Type[] m_catchClass;
    internal Label m_endLabel;
    internal Label m_finallyEndLabel;
    internal int m_endAddr;
    internal int m_endFinally;
    internal int m_currentCatch;
    private int m_currentState;
    internal __ExceptionInfo(int startAddr, Label endLabel);
    private void MarkHelper(int catchorfilterAddr, int catchEndAddr, Type catchClass, int type);
    internal void MarkFilterAddr(int filterAddr);
    internal void MarkFaultAddr(int faultAddr);
    internal void MarkCatchAddr(int catchAddr, Type catchException);
    internal void MarkFinallyAddr(int finallyAddr, int endCatchAddr);
    internal void Done(int endAddr);
    internal int GetStartAddress();
    internal int GetEndAddress();
    internal int GetFinallyEndAddress();
    internal Label GetEndLabel();
    internal Int32[] GetFilterAddresses();
    internal Int32[] GetCatchAddresses();
    internal Int32[] GetCatchEndAddresses();
    internal Type[] GetCatchClass();
    internal int GetNumberOfCatches();
    internal Int32[] GetExceptionTypes();
    internal void SetFinallyEndLabel(Label lbl);
    internal bool IsInner(__ExceptionInfo exc);
    internal int GetCurrentState();
}
internal class System.Reflection.Emit.__FixupData : ValueType {
    internal Label m_fixupLabel;
    internal int m_fixupPos;
    internal int m_fixupInstSize;
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Reflection.Emit.AssemblyBuilder : Assembly {
    internal AssemblyBuilderData _assemblyData;
    private InternalAssemblyBuilder _internalAssemblyBuilder;
    private ModuleBuilder _manifestModuleBuilder;
    private bool _isManifestModuleUsedAsDefinedModule;
    private static object s_assemblyBuilderLock;
    internal object SyncRoot { get; }
    internal InternalAssemblyBuilder InternalAssembly { get; }
    public string Location { get; }
    public string ImageRuntimeVersion { get; }
    [NullableAttribute("2")]
public string CodeBase { get; }
    [NullableAttribute("2")]
public MethodInfo EntryPoint { get; }
    [NullableAttribute("2")]
public string FullName { get; }
    public Module ManifestModule { get; }
    public bool ReflectionOnly { get; }
    public bool GlobalAssemblyCache { get; }
    public long HostContext { get; }
    public bool IsDynamic { get; }
    public bool IsCollectible { get; }
    internal AssemblyBuilder(AssemblyName name, AssemblyBuilderAccess access, StackCrawlMark& stackMark, IEnumerable`1<CustomAttributeBuilder> unsafeAssemblyAttributes);
    private static AssemblyBuilder();
    private static RuntimeModule GetInMemoryAssemblyModule(RuntimeAssembly assembly);
    internal ModuleBuilder GetModuleBuilder(InternalModuleBuilder module);
    internal object get_SyncRoot();
    internal InternalAssemblyBuilder get_InternalAssembly();
    internal RuntimeAssembly GetNativeHandle();
    private void InitManifestModule();
    public static AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access);
    public static AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, IEnumerable`1<CustomAttributeBuilder> assemblyAttributes);
    private static Assembly nCreateDynamicAssembly(AssemblyName name, StackCrawlMark& stackMark, AssemblyBuilderAccess access);
    internal static AssemblyBuilder InternalDefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, StackCrawlMark& stackMark, IEnumerable`1<CustomAttributeBuilder> unsafeAssemblyAttributes);
    public ModuleBuilder DefineDynamicModule(string name);
    public ModuleBuilder DefineDynamicModule(string name, bool emitSymbolInfo);
    private ModuleBuilder DefineDynamicModuleInternal(string name, bool emitSymbolInfo, StackCrawlMark& stackMark);
    private ModuleBuilder DefineDynamicModuleInternalNoLock(string name, bool emitSymbolInfo, StackCrawlMark& stackMark);
    internal void CheckContext(Type[][] typess);
    internal void CheckContext(Type[] types);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual String[] GetManifestResourceNames();
    public virtual FileStream GetFile(string name);
    public virtual FileStream[] GetFiles(bool getResourceModules);
    public virtual Stream GetManifestResourceStream(Type type, string name);
    public virtual Stream GetManifestResourceStream(string name);
    public virtual ManifestResourceInfo GetManifestResourceInfo(string resourceName);
    public virtual string get_Location();
    public virtual string get_ImageRuntimeVersion();
    [NullableContextAttribute("2")]
public virtual string get_CodeBase();
    [NullableContextAttribute("2")]
public virtual MethodInfo get_EntryPoint();
    public virtual Type[] GetExportedTypes();
    public virtual AssemblyName GetName(bool copiedName);
    [NullableContextAttribute("2")]
public virtual string get_FullName();
    public virtual Type GetType(string name, bool throwOnError, bool ignoreCase);
    public virtual Module get_ManifestModule();
    public virtual bool get_ReflectionOnly();
    public virtual Module GetModule(string name);
    public virtual AssemblyName[] GetReferencedAssemblies();
    public virtual bool get_GlobalAssemblyCache();
    public virtual long get_HostContext();
    public virtual Module[] GetModules(bool getResourceModules);
    public virtual Module[] GetLoadedModules(bool getResourceModules);
    public virtual Assembly GetSatelliteAssembly(CultureInfo culture);
    public virtual Assembly GetSatelliteAssembly(CultureInfo culture, Version version);
    public virtual bool get_IsDynamic();
    public virtual bool get_IsCollectible();
    public ModuleBuilder GetDynamicModule(string name);
    private ModuleBuilder GetDynamicModuleNoLock(string name);
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    private void SetCustomAttributeNoLock(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    private void SetCustomAttributeNoLock(CustomAttributeBuilder customBuilder);
}
[FlagsAttribute]
public enum System.Reflection.Emit.AssemblyBuilderAccess : Enum {
    public int value__;
    public static AssemblyBuilderAccess Run;
    public static AssemblyBuilderAccess RunAndCollect;
}
internal class System.Reflection.Emit.AssemblyBuilderData : object {
    public List`1<ModuleBuilder> _moduleBuilderList;
    public AssemblyBuilderAccess _access;
    public MethodInfo _entryPointMethod;
    private InternalAssemblyBuilder _assembly;
    internal AssemblyBuilderData(InternalAssemblyBuilder assembly, AssemblyBuilderAccess access);
    public void CheckTypeNameConflict(string strTypeName, TypeBuilder enclosingType);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Reflection.Emit.ConstructorBuilder : ConstructorInfo {
    private MethodBuilder m_methodBuilder;
    internal bool m_isDefaultConstructor;
    internal int MetadataTokenInternal { get; }
    public Module Module { get; }
    [NullableAttribute("2")]
public Type ReflectedType { get; }
    [NullableAttribute("2")]
public Type DeclaringType { get; }
    public string Name { get; }
    public MethodAttributes Attributes { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public CallingConventions CallingConvention { get; }
    public string Signature { get; }
    public bool InitLocals { get; public set; }
    internal ConstructorBuilder(string name, MethodAttributes attributes, CallingConventions callingConvention, Type[] parameterTypes, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers, ModuleBuilder mod, TypeBuilder type);
    internal ConstructorBuilder(string name, MethodAttributes attributes, CallingConventions callingConvention, Type[] parameterTypes, ModuleBuilder mod, TypeBuilder type);
    internal virtual Type[] GetParameterTypes();
    private TypeBuilder GetTypeBuilder();
    public virtual string ToString();
    internal int get_MetadataTokenInternal();
    public virtual Module get_Module();
    [NullableContextAttribute("2")]
public virtual Type get_ReflectedType();
    [NullableContextAttribute("2")]
public virtual Type get_DeclaringType();
    public virtual string get_Name();
    [NullableContextAttribute("2")]
public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual ParameterInfo[] GetParameters();
    public virtual MethodAttributes get_Attributes();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual RuntimeMethodHandle get_MethodHandle();
    [NullableContextAttribute("2")]
public virtual object Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public MethodToken GetToken();
    public ParameterBuilder DefineParameter(int iSequence, ParameterAttributes attributes, string strParamName);
    public ILGenerator GetILGenerator();
    public ILGenerator GetILGenerator(int streamSize);
    public virtual CallingConventions get_CallingConvention();
    public Module GetModule();
    internal virtual Type GetReturnType();
    public string get_Signature();
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    public void SetImplementationFlags(MethodImplAttributes attributes);
    public bool get_InitLocals();
    public void set_InitLocals(bool value);
}
internal class System.Reflection.Emit.ConstructorOnTypeBuilderInstantiation : ConstructorInfo {
    internal ConstructorInfo m_ctor;
    private TypeBuilderInstantiation m_type;
    public MemberTypes MemberType { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    internal int MetadataTokenInternal { get; }
    public Module Module { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public bool IsGenericMethodDefinition { get; }
    public bool ContainsGenericParameters { get; }
    public bool IsGenericMethod { get; }
    internal ConstructorOnTypeBuilderInstantiation(ConstructorInfo constructor, TypeBuilderInstantiation type);
    internal static ConstructorInfo GetConstructor(ConstructorInfo Constructor, TypeBuilderInstantiation type);
    internal virtual Type[] GetParameterTypes();
    internal virtual Type GetReturnType();
    public virtual MemberTypes get_MemberType();
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    internal int get_MetadataTokenInternal();
    public virtual Module get_Module();
    public virtual ParameterInfo[] GetParameters();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual MethodAttributes get_Attributes();
    public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual CallingConventions get_CallingConvention();
    public virtual Type[] GetGenericArguments();
    public virtual bool get_IsGenericMethodDefinition();
    public virtual bool get_ContainsGenericParameters();
    public virtual bool get_IsGenericMethod();
    public virtual object Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Reflection.Emit.CustomAttributeBuilder : object {
    internal ConstructorInfo m_con;
    internal Object[] m_constructorArgs;
    internal Byte[] m_blob;
    public CustomAttributeBuilder(ConstructorInfo con, Object[] constructorArgs);
    public CustomAttributeBuilder(ConstructorInfo con, Object[] constructorArgs, PropertyInfo[] namedProperties, Object[] propertyValues);
    public CustomAttributeBuilder(ConstructorInfo con, Object[] constructorArgs, FieldInfo[] namedFields, Object[] fieldValues);
    public CustomAttributeBuilder(ConstructorInfo con, Object[] constructorArgs, PropertyInfo[] namedProperties, Object[] propertyValues, FieldInfo[] namedFields, Object[] fieldValues);
    private bool ValidateType(Type t);
    internal void InitCustomAttributeBuilder(ConstructorInfo con, Object[] constructorArgs, PropertyInfo[] namedProperties, Object[] propertyValues, FieldInfo[] namedFields, Object[] fieldValues);
    private static void VerifyTypeAndPassedObjectType(Type type, Type passedType, string paramName);
    private static void EmitType(BinaryWriter writer, Type type);
    private static void EmitString(BinaryWriter writer, string str);
    private static void EmitValue(BinaryWriter writer, Type type, object value);
    internal void CreateCustomAttribute(ModuleBuilder mod, int tkOwner);
    internal void CreateCustomAttribute(ModuleBuilder mod, int tkOwner, int tkAttrib, bool toDisk);
}
internal class System.Reflection.Emit.DynamicILGenerator : ILGenerator {
    internal DynamicScope m_scope;
    private int m_methodSigToken;
    internal DynamicILGenerator(DynamicMethod method, Byte[] methodSignature, int size);
    internal void GetCallableMethod(RuntimeModule module, DynamicMethod dm);
    public virtual LocalBuilder DeclareLocal(Type localType, bool pinned);
    public virtual void Emit(OpCode opcode, MethodInfo meth);
    public virtual void Emit(OpCode opcode, ConstructorInfo con);
    public virtual void Emit(OpCode opcode, Type type);
    public virtual void Emit(OpCode opcode, FieldInfo field);
    public virtual void Emit(OpCode opcode, string str);
    public virtual void EmitCalli(OpCode opcode, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes);
    public virtual void EmitCalli(OpCode opcode, CallingConvention unmanagedCallConv, Type returnType, Type[] parameterTypes);
    public virtual void EmitCall(OpCode opcode, MethodInfo methodInfo, Type[] optionalParameterTypes);
    public virtual void Emit(OpCode opcode, SignatureHelper signature);
    public virtual void BeginExceptFilterBlock();
    public virtual void BeginCatchBlock(Type exceptionType);
    public virtual void UsingNamespace(string ns);
    public virtual void MarkSequencePoint(ISymbolDocumentWriter document, int startLine, int startColumn, int endLine, int endColumn);
    public virtual void BeginScope();
    public virtual void EndScope();
    private int GetMemberRefToken(MethodBase methodInfo, Type[] optionalParameterTypes);
    internal virtual SignatureHelper GetMemberRefSignature(CallingConventions call, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes);
    internal virtual void RecordTokenFixup();
    private int GetTokenFor(RuntimeType rtType);
    private int GetTokenFor(RuntimeFieldInfo runtimeField);
    private int GetTokenFor(RuntimeFieldInfo runtimeField, RuntimeType rtType);
    private int GetTokenFor(RuntimeConstructorInfo rtMeth);
    private int GetTokenFor(RuntimeConstructorInfo rtMeth, RuntimeType rtType);
    private int GetTokenFor(RuntimeMethodInfo rtMeth);
    private int GetTokenFor(RuntimeMethodInfo rtMeth, RuntimeType rtType);
    private int GetTokenFor(DynamicMethod dm);
    private int GetTokenForVarArgMethod(RuntimeMethodInfo rtMeth, SignatureHelper sig);
    private int GetTokenForVarArgMethod(DynamicMethod dm, SignatureHelper sig);
    private int GetTokenForString(string s);
    private int GetTokenForSig(Byte[] sig);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Reflection.Emit.DynamicILInfo : object {
    private DynamicMethod m_method;
    private DynamicScope m_scope;
    private Byte[] m_exceptions;
    private Byte[] m_code;
    private Byte[] m_localSignature;
    private int m_maxStackSize;
    private int m_methodSignature;
    internal Byte[] LocalSignature { get; }
    internal Byte[] Exceptions { get; }
    internal Byte[] Code { get; }
    internal int MaxStackSize { get; }
    public DynamicMethod DynamicMethod { get; }
    internal DynamicScope DynamicScope { get; }
    internal DynamicILInfo(DynamicMethod method, Byte[] methodSignature);
    internal void GetCallableMethod(RuntimeModule module, DynamicMethod dm);
    internal Byte[] get_LocalSignature();
    internal Byte[] get_Exceptions();
    internal Byte[] get_Code();
    internal int get_MaxStackSize();
    public DynamicMethod get_DynamicMethod();
    internal DynamicScope get_DynamicScope();
    [NullableContextAttribute("2")]
public void SetCode(Byte[] code, int maxStackSize);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public void SetCode(Byte* code, int codeSize, int maxStackSize);
    [NullableContextAttribute("2")]
public void SetExceptions(Byte[] exceptions);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public void SetExceptions(Byte* exceptions, int exceptionsSize);
    [NullableContextAttribute("2")]
public void SetLocalSignature(Byte[] localSignature);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public void SetLocalSignature(Byte* localSignature, int signatureSize);
    public int GetTokenFor(RuntimeMethodHandle method);
    public int GetTokenFor(DynamicMethod method);
    public int GetTokenFor(RuntimeMethodHandle method, RuntimeTypeHandle contextType);
    public int GetTokenFor(RuntimeFieldHandle field);
    public int GetTokenFor(RuntimeFieldHandle field, RuntimeTypeHandle contextType);
    public int GetTokenFor(RuntimeTypeHandle type);
    public int GetTokenFor(string literal);
    public int GetTokenFor(Byte[] signature);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Reflection.Emit.DynamicMethod : MethodInfo {
    private RuntimeType[] m_parameterTypes;
    internal IRuntimeMethodInfo m_methodHandle;
    private RuntimeType m_returnType;
    private DynamicILGenerator m_ilGenerator;
    private DynamicILInfo m_DynamicILInfo;
    private bool m_fInitLocals;
    private RuntimeModule m_module;
    internal bool m_skipVisibility;
    internal RuntimeType m_typeOwner;
    private RTDynamicMethod m_dynMethod;
    internal DynamicResolver m_resolver;
    internal bool m_restrictedSkipVisibility;
    private static InternalModuleBuilder modreq(System.Runtime.CompilerServices.IsVolatile) s_anonymouslyHostedDynamicMethodsModule;
    private static object s_anonymouslyHostedDynamicMethodsModuleLock;
    public string Name { get; }
    [NullableAttribute("2")]
public Type DeclaringType { get; }
    [NullableAttribute("2")]
public Type ReflectedType { get; }
    public Module Module { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public Type ReturnType { get; }
    public ParameterInfo ReturnParameter { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    public bool InitLocals { get; public set; }
    public DynamicMethod(string name, Type returnType, Type[] parameterTypes);
    public DynamicMethod(string name, Type returnType, Type[] parameterTypes, bool restrictedSkipVisibility);
    public DynamicMethod(string name, Type returnType, Type[] parameterTypes, Module m);
    public DynamicMethod(string name, Type returnType, Type[] parameterTypes, Module m, bool skipVisibility);
    public DynamicMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Module m, bool skipVisibility);
    public DynamicMethod(string name, Type returnType, Type[] parameterTypes, Type owner);
    public DynamicMethod(string name, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);
    public DynamicMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);
    private static DynamicMethod();
    private static void CheckConsistency(MethodAttributes attributes, CallingConventions callingConvention);
    private static RuntimeModule GetDynamicMethodsModule();
    private void Init(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] signature, Type owner, Module m, bool skipVisibility, bool transparentMethod);
    public sealed virtual Delegate CreateDelegate(Type delegateType);
    public sealed virtual Delegate CreateDelegate(Type delegateType, object target);
    internal RuntimeMethodHandle GetMethodDescriptor();
    public virtual string ToString();
    public virtual string get_Name();
    [NullableContextAttribute("2")]
public virtual Type get_DeclaringType();
    [NullableContextAttribute("2")]
public virtual Type get_ReflectedType();
    public virtual Module get_Module();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual MethodAttributes get_Attributes();
    public virtual CallingConventions get_CallingConvention();
    public virtual MethodInfo GetBaseDefinition();
    public virtual ParameterInfo[] GetParameters();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    [NullableContextAttribute("2")]
public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Type get_ReturnType();
    public virtual ParameterInfo get_ReturnParameter();
    public virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    [NullableContextAttribute("2")]
public ParameterBuilder DefineParameter(int position, ParameterAttributes attributes, string parameterName);
    public DynamicILInfo GetDynamicILInfo();
    public ILGenerator GetILGenerator();
    public ILGenerator GetILGenerator(int streamSize);
    public bool get_InitLocals();
    public void set_InitLocals(bool value);
    internal MethodInfo GetMethodInfo();
}
internal class System.Reflection.Emit.DynamicResolver : Resolver {
    private __ExceptionInfo[] m_exceptions;
    private Byte[] m_exceptionHeader;
    private DynamicMethod m_method;
    private Byte[] m_code;
    private Byte[] m_localSignature;
    private int m_stackSize;
    private DynamicScope m_scope;
    internal DynamicResolver(DynamicILGenerator ilGenerator);
    internal DynamicResolver(DynamicILInfo dynamicILInfo);
    protected virtual override void Finalize();
    internal virtual RuntimeType GetJitContext(Int32& securityControlFlags);
    private static int CalculateNumberOfExceptions(__ExceptionInfo[] excp);
    internal virtual Byte[] GetCodeInfo(Int32& stackSize, Int32& initLocals, Int32& EHCount);
    internal virtual Byte[] GetLocalsSignature();
    internal virtual Byte[] GetRawEHInfo();
    internal virtual void GetEHInfo(int excNumber, Void* exc);
    internal virtual string GetStringLiteral(int token);
    internal virtual void ResolveToken(int token, IntPtr& typeHandle, IntPtr& methodHandle, IntPtr& fieldHandle);
    internal virtual Byte[] ResolveSignature(int token, int fromMethod);
    internal virtual MethodInfo GetDynamicMethod();
}
[DefaultMemberAttribute("Item")]
internal class System.Reflection.Emit.DynamicScope : object {
    internal List`1<object> m_tokens;
    internal object Item { get; }
    internal object get_Item(int token);
    internal int GetTokenFor(VarArgMethod varArgMethod);
    internal string GetString(int token);
    internal Byte[] ResolveSignature(int token, int fromMethod);
    public int GetTokenFor(RuntimeMethodHandle method);
    public int GetTokenFor(RuntimeMethodHandle method, RuntimeTypeHandle typeContext);
    public int GetTokenFor(DynamicMethod method);
    public int GetTokenFor(RuntimeFieldHandle field);
    public int GetTokenFor(RuntimeFieldHandle field, RuntimeTypeHandle typeContext);
    public int GetTokenFor(RuntimeTypeHandle type);
    public int GetTokenFor(string literal);
    public int GetTokenFor(Byte[] signature);
}
internal class System.Reflection.Emit.EmptyCAHolder : object {
    private sealed virtual override Object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(Type attributeType, bool inherit);
    private sealed virtual override Object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit);
    private sealed virtual override bool System.Reflection.ICustomAttributeProvider.IsDefined(Type attributeType, bool inherit);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Reflection.Emit.EnumBuilder : TypeInfo {
    internal TypeBuilder m_typeBuilder;
    private FieldBuilder m_underlyingField;
    public TypeToken TypeToken { get; }
    public FieldBuilder UnderlyingField { get; }
    public string Name { get; }
    public Guid GUID { get; }
    public Module Module { get; }
    public Assembly Assembly { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    [NullableAttribute("2")]
public string FullName { get; }
    [NullableAttribute("2")]
public string AssemblyQualifiedName { get; }
    [NullableAttribute("2")]
public string Namespace { get; }
    [NullableAttribute("2")]
public Type BaseType { get; }
    public bool IsTypeDefinition { get; }
    public bool IsSZArray { get; }
    public bool IsConstructedGenericType { get; }
    public Type UnderlyingSystemType { get; }
    [NullableAttribute("2")]
public Type DeclaringType { get; }
    [NullableAttribute("2")]
public Type ReflectedType { get; }
    internal EnumBuilder(string name, Type underlyingType, TypeAttributes visibility, ModuleBuilder module);
    [NullableContextAttribute("2")]
public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    public FieldBuilder DefineLiteral(string literalName, object literalValue);
    [NullableContextAttribute("2")]
public TypeInfo CreateTypeInfo();
    [NullableContextAttribute("2")]
public Type CreateType();
    public TypeToken get_TypeToken();
    public FieldBuilder get_UnderlyingField();
    public virtual string get_Name();
    public virtual Guid get_GUID();
    [NullableContextAttribute("2")]
public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public virtual Module get_Module();
    public virtual Assembly get_Assembly();
    public virtual RuntimeTypeHandle get_TypeHandle();
    [NullableContextAttribute("2")]
public virtual string get_FullName();
    [NullableContextAttribute("2")]
public virtual string get_AssemblyQualifiedName();
    [NullableContextAttribute("2")]
public virtual string get_Namespace();
    [NullableContextAttribute("2")]
public virtual Type get_BaseType();
    [NullableContextAttribute("2")]
protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    [NullableContextAttribute("2")]
protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public virtual Type GetInterface(string name, bool ignoreCase);
    public virtual Type[] GetInterfaces();
    public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents();
    [NullableContextAttribute("2")]
protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    public virtual bool get_IsTypeDefinition();
    public virtual bool get_IsSZArray();
    protected virtual bool IsArrayImpl();
    protected virtual bool IsPrimitiveImpl();
    protected virtual bool IsValueTypeImpl();
    protected virtual bool IsByRefImpl();
    protected virtual bool IsPointerImpl();
    protected virtual bool IsCOMObjectImpl();
    public virtual bool get_IsConstructedGenericType();
    [NullableContextAttribute("2")]
public virtual Type GetElementType();
    protected virtual bool HasElementTypeImpl();
    public virtual Type GetEnumUnderlyingType();
    public virtual Type get_UnderlyingSystemType();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    [NullableContextAttribute("2")]
public virtual Type get_DeclaringType();
    [NullableContextAttribute("2")]
public virtual Type get_ReflectedType();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Type MakePointerType();
    public virtual Type MakeByRefType();
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Reflection.Emit.EventBuilder : object {
    private string m_name;
    private EventToken m_evToken;
    private ModuleBuilder m_module;
    private EventAttributes m_attributes;
    private TypeBuilder m_type;
    internal EventBuilder(ModuleBuilder mod, string name, EventAttributes attr, TypeBuilder type, EventToken evToken);
    public EventToken GetEventToken();
    private void SetMethodSemantics(MethodBuilder mdBuilder, MethodSemanticsAttributes semantics);
    public void SetAddOnMethod(MethodBuilder mdBuilder);
    public void SetRemoveOnMethod(MethodBuilder mdBuilder);
    public void SetRaiseMethod(MethodBuilder mdBuilder);
    public void AddOtherMethod(MethodBuilder mdBuilder);
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
}
public class System.Reflection.Emit.EventToken : ValueType {
    public static EventToken Empty;
    [CompilerGeneratedAttribute]
private int <Token>k__BackingField;
    public int Token { get; }
    internal EventToken(int eventToken);
    private static EventToken();
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public int get_Token();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public bool Equals(EventToken obj);
    public static bool op_Equality(EventToken a, EventToken b);
    public static bool op_Inequality(EventToken a, EventToken b);
}
[IsReadOnlyAttribute]
internal class System.Reflection.Emit.ExceptionHandler : ValueType {
    internal int m_exceptionClass;
    internal int m_tryStartOffset;
    internal int m_tryEndOffset;
    internal int m_filterOffset;
    internal int m_handlerStartOffset;
    internal int m_handlerEndOffset;
    internal ExceptionHandlingClauseOptions m_kind;
    internal ExceptionHandler(int tryStartOffset, int tryEndOffset, int filterOffset, int handlerStartOffset, int handlerEndOffset, int kind, int exceptionTypeToken);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ExceptionHandler other);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Reflection.Emit.FieldBuilder : FieldInfo {
    private int m_fieldTok;
    private FieldToken m_tkField;
    private TypeBuilder m_typeBuilder;
    private string m_fieldName;
    private FieldAttributes m_Attributes;
    private Type m_fieldType;
    internal int MetadataTokenInternal { get; }
    public Module Module { get; }
    public string Name { get; }
    [NullableAttribute("2")]
public Type DeclaringType { get; }
    [NullableAttribute("2")]
public Type ReflectedType { get; }
    public Type FieldType { get; }
    public RuntimeFieldHandle FieldHandle { get; }
    public FieldAttributes Attributes { get; }
    internal FieldBuilder(TypeBuilder typeBuilder, string fieldName, Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers, FieldAttributes attributes);
    internal void SetData(Byte[] data, int size);
    internal int get_MetadataTokenInternal();
    public virtual Module get_Module();
    public virtual string get_Name();
    [NullableContextAttribute("2")]
public virtual Type get_DeclaringType();
    [NullableContextAttribute("2")]
public virtual Type get_ReflectedType();
    public virtual Type get_FieldType();
    [NullableContextAttribute("2")]
public virtual object GetValue(object obj);
    [NullableContextAttribute("2")]
public virtual void SetValue(object obj, object val, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
    public virtual RuntimeFieldHandle get_FieldHandle();
    public virtual FieldAttributes get_Attributes();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public FieldToken GetToken();
    public void SetOffset(int iOffset);
    [NullableContextAttribute("2")]
public void SetConstant(object defaultValue);
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
}
internal class System.Reflection.Emit.FieldOnTypeBuilderInstantiation : FieldInfo {
    private FieldInfo m_field;
    private TypeBuilderInstantiation m_type;
    internal FieldInfo FieldInfo { get; }
    public MemberTypes MemberType { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    internal int MetadataTokenInternal { get; }
    public Module Module { get; }
    public RuntimeFieldHandle FieldHandle { get; }
    public Type FieldType { get; }
    public FieldAttributes Attributes { get; }
    internal FieldOnTypeBuilderInstantiation(FieldInfo field, TypeBuilderInstantiation type);
    internal static FieldInfo GetField(FieldInfo Field, TypeBuilderInstantiation type);
    internal FieldInfo get_FieldInfo();
    public virtual MemberTypes get_MemberType();
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    internal int get_MetadataTokenInternal();
    public virtual Module get_Module();
    public virtual Type[] GetRequiredCustomModifiers();
    public virtual Type[] GetOptionalCustomModifiers();
    public virtual void SetValueDirect(TypedReference obj, object value);
    public virtual object GetValueDirect(TypedReference obj);
    public virtual RuntimeFieldHandle get_FieldHandle();
    public virtual Type get_FieldType();
    public virtual object GetValue(object obj);
    public virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
    public virtual FieldAttributes get_Attributes();
}
public class System.Reflection.Emit.FieldToken : ValueType {
    public static FieldToken Empty;
    private object _class;
    [CompilerGeneratedAttribute]
private int <Token>k__BackingField;
    public int Token { get; }
    internal FieldToken(int fieldToken, Type fieldClass);
    private static FieldToken();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Token();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public bool Equals(FieldToken obj);
    public static bool op_Equality(FieldToken a, FieldToken b);
    public static bool op_Inequality(FieldToken a, FieldToken b);
}
public enum System.Reflection.Emit.FlowControl : Enum {
    public int value__;
    public static FlowControl Branch;
    public static FlowControl Break;
    public static FlowControl Call;
    public static FlowControl Cond_Branch;
    public static FlowControl Meta;
    public static FlowControl Next;
    [ObsoleteAttribute("This API has been deprecated. https://go.microsoft.com/fwlink/?linkid=14202")]
public static FlowControl Phi;
    public static FlowControl Return;
    public static FlowControl Throw;
}
internal class System.Reflection.Emit.GenericFieldInfo : object {
    internal RuntimeFieldHandle m_fieldHandle;
    internal RuntimeTypeHandle m_context;
    internal GenericFieldInfo(RuntimeFieldHandle fieldHandle, RuntimeTypeHandle context);
}
internal class System.Reflection.Emit.GenericMethodInfo : object {
    internal RuntimeMethodHandle m_methodHandle;
    internal RuntimeTypeHandle m_context;
    internal GenericMethodInfo(RuntimeMethodHandle methodHandle, RuntimeTypeHandle context);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Reflection.Emit.GenericTypeParameterBuilder : TypeInfo {
    internal TypeBuilder m_type;
    [NullableAttribute("2")]
public Type DeclaringType { get; }
    [NullableAttribute("2")]
public Type ReflectedType { get; }
    public string Name { get; }
    public Module Module { get; }
    internal int MetadataTokenInternal { get; }
    public Guid GUID { get; }
    public Assembly Assembly { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    [NullableAttribute("2")]
public string FullName { get; }
    [NullableAttribute("2")]
public string Namespace { get; }
    [NullableAttribute("2")]
public string AssemblyQualifiedName { get; }
    [NullableAttribute("2")]
public Type BaseType { get; }
    public bool IsTypeDefinition { get; }
    public bool IsSZArray { get; }
    public Type UnderlyingSystemType { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsGenericType { get; }
    public bool IsGenericParameter { get; }
    public bool IsConstructedGenericType { get; }
    public int GenericParameterPosition { get; }
    public bool ContainsGenericParameters { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    [NullableAttribute("2")]
public MethodBase DeclaringMethod { get; }
    internal GenericTypeParameterBuilder(TypeBuilder type);
    [NullableContextAttribute("2")]
public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object o);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual Type get_DeclaringType();
    [NullableContextAttribute("2")]
public virtual Type get_ReflectedType();
    public virtual string get_Name();
    public virtual Module get_Module();
    internal int get_MetadataTokenInternal();
    public virtual Type MakePointerType();
    public virtual Type MakeByRefType();
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
    public virtual Guid get_GUID();
    [NullableContextAttribute("2")]
public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public virtual Assembly get_Assembly();
    public virtual RuntimeTypeHandle get_TypeHandle();
    [NullableContextAttribute("2")]
public virtual string get_FullName();
    [NullableContextAttribute("2")]
public virtual string get_Namespace();
    [NullableContextAttribute("2")]
public virtual string get_AssemblyQualifiedName();
    [NullableContextAttribute("2")]
public virtual Type get_BaseType();
    protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public virtual Type GetInterface(string name, bool ignoreCase);
    public virtual Type[] GetInterfaces();
    public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents();
    [NullableContextAttribute("2")]
protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    public virtual bool get_IsTypeDefinition();
    public virtual bool get_IsSZArray();
    protected virtual bool IsArrayImpl();
    protected virtual bool IsByRefImpl();
    protected virtual bool IsPointerImpl();
    protected virtual bool IsPrimitiveImpl();
    protected virtual bool IsCOMObjectImpl();
    public virtual Type GetElementType();
    protected virtual bool HasElementTypeImpl();
    public virtual Type get_UnderlyingSystemType();
    public virtual Type[] GetGenericArguments();
    public virtual bool get_IsGenericTypeDefinition();
    public virtual bool get_IsGenericType();
    public virtual bool get_IsGenericParameter();
    public virtual bool get_IsConstructedGenericType();
    public virtual int get_GenericParameterPosition();
    public virtual bool get_ContainsGenericParameters();
    public virtual GenericParameterAttributes get_GenericParameterAttributes();
    [NullableContextAttribute("2")]
public virtual MethodBase get_DeclaringMethod();
    public virtual Type GetGenericTypeDefinition();
    public virtual Type MakeGenericType(Type[] typeArguments);
    protected virtual bool IsValueTypeImpl();
    [NullableContextAttribute("2")]
public virtual bool IsAssignableFrom(Type c);
    public virtual bool IsSubclassOf(Type c);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    [NullableContextAttribute("2")]
public void SetBaseTypeConstraint(Type baseTypeConstraint);
    public void SetInterfaceConstraints(Type[] interfaceConstraints);
    public void SetGenericParameterAttributes(GenericParameterAttributes genericParameterAttributes);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Reflection.Emit.ILGenerator : object {
    private int m_length;
    private Byte[] m_ILStream;
    private Int32[] m_labelList;
    private int m_labelCount;
    private __FixupData[] m_fixupData;
    private int m_fixupCount;
    private Int32[] m_RelocFixupList;
    private int m_RelocFixupCount;
    private int m_exceptionCount;
    private int m_currExcStackCount;
    private __ExceptionInfo[] m_exceptions;
    private __ExceptionInfo[] m_currExcStack;
    internal ScopeTree m_ScopeTree;
    internal LineNumberInfo m_LineNumberInfo;
    internal MethodInfo m_methodBuilder;
    internal int m_localCount;
    internal SignatureHelper m_localSignature;
    private int m_maxStackSize;
    private int m_maxMidStack;
    private int m_maxMidStackCur;
    internal int CurrExcStackCount { get; }
    internal __ExceptionInfo[] CurrExcStack { get; }
    public int ILOffset { get; }
    internal ILGenerator(MethodInfo methodBuilder);
    internal ILGenerator(MethodInfo methodBuilder, int size);
    internal static T[] EnlargeArray(T[] incoming);
    internal static T[] EnlargeArray(T[] incoming, int requiredSize);
    internal int get_CurrExcStackCount();
    internal __ExceptionInfo[] get_CurrExcStack();
    internal virtual void RecordTokenFixup();
    internal void InternalEmit(OpCode opcode);
    internal void UpdateStackSize(OpCode opcode, int stackchange);
    private int GetMethodToken(MethodBase method, Type[] optionalParameterTypes, bool useMethodDef);
    internal virtual SignatureHelper GetMemberRefSignature(CallingConventions call, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes);
    private SignatureHelper GetMemberRefSignature(CallingConventions call, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes, int cGenericParameters);
    internal Byte[] BakeByteArray();
    internal __ExceptionInfo[] GetExceptions();
    internal void EnsureCapacity(int size);
    private void IncreaseCapacity(int size);
    internal void PutInteger4(int value);
    private int GetLabelPos(Label lbl);
    private void AddFixup(Label lbl, int pos, int instSize);
    internal int GetMaxStackSize();
    private static void SortExceptions(__ExceptionInfo[] exceptions);
    internal Int32[] GetTokenFixups();
    public virtual void Emit(OpCode opcode);
    public virtual void Emit(OpCode opcode, byte arg);
    [CLSCompliantAttribute("False")]
public void Emit(OpCode opcode, sbyte arg);
    public virtual void Emit(OpCode opcode, short arg);
    public virtual void Emit(OpCode opcode, int arg);
    public virtual void Emit(OpCode opcode, MethodInfo meth);
    [NullableContextAttribute("2")]
public virtual void EmitCalli(OpCode opcode, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes);
    [NullableContextAttribute("2")]
public virtual void EmitCalli(OpCode opcode, CallingConvention unmanagedCallConv, Type returnType, Type[] parameterTypes);
    public virtual void EmitCall(OpCode opcode, MethodInfo methodInfo, Type[] optionalParameterTypes);
    public virtual void Emit(OpCode opcode, SignatureHelper signature);
    public virtual void Emit(OpCode opcode, ConstructorInfo con);
    public virtual void Emit(OpCode opcode, Type cls);
    public virtual void Emit(OpCode opcode, long arg);
    public virtual void Emit(OpCode opcode, float arg);
    public virtual void Emit(OpCode opcode, double arg);
    public virtual void Emit(OpCode opcode, Label label);
    public virtual void Emit(OpCode opcode, Label[] labels);
    public virtual void Emit(OpCode opcode, FieldInfo field);
    public virtual void Emit(OpCode opcode, string str);
    public virtual void Emit(OpCode opcode, LocalBuilder local);
    public virtual Label BeginExceptionBlock();
    public virtual void EndExceptionBlock();
    public virtual void BeginExceptFilterBlock();
    public virtual void BeginCatchBlock(Type exceptionType);
    public virtual void BeginFaultBlock();
    public virtual void BeginFinallyBlock();
    public virtual Label DefineLabel();
    public virtual void MarkLabel(Label loc);
    public virtual void ThrowException(Type excType);
    private static Type GetConsoleType();
    public virtual void EmitWriteLine(string value);
    public virtual void EmitWriteLine(LocalBuilder localBuilder);
    public virtual void EmitWriteLine(FieldInfo fld);
    public virtual LocalBuilder DeclareLocal(Type localType);
    public virtual LocalBuilder DeclareLocal(Type localType, bool pinned);
    public virtual void UsingNamespace(string usingNamespace);
    public virtual void MarkSequencePoint(ISymbolDocumentWriter document, int startLine, int startColumn, int endLine, int endColumn);
    public virtual void BeginScope();
    public virtual void EndScope();
    public virtual int get_ILOffset();
}
internal class System.Reflection.Emit.InternalAssemblyBuilder : RuntimeAssembly {
    public string Location { get; }
    public string CodeBase { get; }
    public string ImageRuntimeVersion { get; }
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual String[] GetManifestResourceNames();
    public virtual FileStream GetFile(string name);
    public virtual FileStream[] GetFiles(bool getResourceModules);
    public virtual Stream GetManifestResourceStream(Type type, string name);
    public virtual Stream GetManifestResourceStream(string name);
    public virtual ManifestResourceInfo GetManifestResourceInfo(string resourceName);
    public virtual string get_Location();
    public virtual string get_CodeBase();
    public virtual Type[] GetExportedTypes();
    public virtual string get_ImageRuntimeVersion();
}
internal class System.Reflection.Emit.InternalModuleBuilder : RuntimeModule {
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[IsReadOnlyAttribute]
public class System.Reflection.Emit.Label : ValueType {
    internal int m_label;
    internal Label(int label);
    internal int GetLabelValue();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Label obj);
    public static bool op_Equality(Label a, Label b);
    public static bool op_Inequality(Label a, Label b);
}
internal class System.Reflection.Emit.LineNumberInfo : object {
    private int m_DocumentCount;
    private REDocument[] m_Documents;
    private int m_iLastFound;
    internal void AddLineNumberInfo(ISymbolDocumentWriter document, int iOffset, int iStartLine, int iStartColumn, int iEndLine, int iEndColumn);
    private int FindDocument(ISymbolDocumentWriter document);
    private void EnsureCapacity();
    internal void EmitLineNumberInfo(ISymbolWriter symWriter);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Reflection.Emit.LocalBuilder : LocalVariableInfo {
    private int m_localIndex;
    private Type m_localType;
    private MethodInfo m_methodBuilder;
    private bool m_isPinned;
    public bool IsPinned { get; }
    public Type LocalType { get; }
    public int LocalIndex { get; }
    internal LocalBuilder(int localIndex, Type localType, MethodInfo methodBuilder);
    internal LocalBuilder(int localIndex, Type localType, MethodInfo methodBuilder, bool isPinned);
    internal int GetLocalIndex();
    internal MethodInfo GetMethodBuilder();
    public virtual bool get_IsPinned();
    public virtual Type get_LocalType();
    public virtual int get_LocalIndex();
    public void SetLocalSymInfo(string name);
    public void SetLocalSymInfo(string name, int startOffset, int endOffset);
}
internal class System.Reflection.Emit.LocalSymInfo : object {
    internal String[] m_strName;
    internal Byte[][] m_ubSignature;
    internal Int32[] m_iLocalSlot;
    internal Int32[] m_iStartOffset;
    internal Int32[] m_iEndOffset;
    internal int m_iLocalSymCount;
    internal String[] m_namespace;
    internal int m_iNameSpaceCount;
    private void EnsureCapacityNamespace();
    private void EnsureCapacity();
    internal void AddLocalSymInfo(string strName, Byte[] signature, int slot, int startOffset, int endOffset);
    internal void AddUsingNamespace(string strNamespace);
    internal virtual void EmitLocalSymInfo(ISymbolWriter symWriter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Reflection.Emit.MethodBuilder : MethodInfo {
    internal string m_strName;
    private MethodToken m_tkMethod;
    private ModuleBuilder m_module;
    internal TypeBuilder m_containingType;
    private Int32[] m_mdMethodFixups;
    private Byte[] m_localSignature;
    internal LocalSymInfo m_localSymInfo;
    internal ILGenerator m_ilGenerator;
    private Byte[] m_ubBody;
    private ExceptionHandler[] m_exceptions;
    private int m_maxStack;
    internal bool m_bIsBaked;
    private bool m_bIsGlobalMethod;
    private bool m_fInitLocals;
    private MethodAttributes m_iAttributes;
    private CallingConventions m_callingConvention;
    private MethodImplAttributes m_dwMethodImplFlags;
    private SignatureHelper m_signature;
    internal Type[] m_parameterTypes;
    private Type m_returnType;
    private Type[] m_returnTypeRequiredCustomModifiers;
    private Type[] m_returnTypeOptionalCustomModifiers;
    private Type[][] m_parameterTypeRequiredCustomModifiers;
    private Type[][] m_parameterTypeOptionalCustomModifiers;
    private GenericTypeParameterBuilder[] m_inst;
    private bool m_bIsGenMethDef;
    private List`1<SymCustomAttr> m_symCustomAttrs;
    internal bool m_canBeRuntimeImpl;
    internal bool m_isDllImport;
    internal int ExceptionHandlerCount { get; }
    public string Name { get; }
    internal int MetadataTokenInternal { get; }
    public Module Module { get; }
    [NullableAttribute("2")]
public Type DeclaringType { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    [NullableAttribute("2")]
public Type ReflectedType { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public Type ReturnType { get; }
    public ParameterInfo ReturnParameter { get; }
    public bool IsGenericMethodDefinition { get; }
    public bool ContainsGenericParameters { get; }
    public bool IsGenericMethod { get; }
    public bool InitLocals { get; public set; }
    public string Signature { get; }
    internal MethodBuilder(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers, ModuleBuilder mod, TypeBuilder type, bool bIsGlobalMethod);
    internal void CheckContext(Type[][] typess);
    internal void CheckContext(Type[] types);
    internal void CreateMethodBodyHelper(ILGenerator il);
    internal void ReleaseBakedStructures();
    internal virtual Type[] GetParameterTypes();
    internal static Type GetMethodBaseReturnType(MethodBase method);
    internal void SetToken(MethodToken token);
    internal Byte[] GetBody();
    internal Int32[] GetTokenFixups();
    internal SignatureHelper GetMethodSignature();
    internal Byte[] GetLocalSignature(Int32& signatureLength);
    internal int GetMaxStack();
    internal ExceptionHandler[] GetExceptionHandlers();
    internal int get_ExceptionHandlerCount();
    internal int CalculateNumberOfExceptions(__ExceptionInfo[] excp);
    internal bool IsTypeCreated();
    internal TypeBuilder GetTypeBuilder();
    internal ModuleBuilder GetModuleBuilder();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual string get_Name();
    internal int get_MetadataTokenInternal();
    public virtual Module get_Module();
    [NullableContextAttribute("2")]
public virtual Type get_DeclaringType();
    public virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    [NullableContextAttribute("2")]
public virtual Type get_ReflectedType();
    [NullableContextAttribute("2")]
public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual MethodAttributes get_Attributes();
    public virtual CallingConventions get_CallingConvention();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    public virtual MethodInfo GetBaseDefinition();
    public virtual Type get_ReturnType();
    public virtual ParameterInfo[] GetParameters();
    public virtual ParameterInfo get_ReturnParameter();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual bool get_IsGenericMethodDefinition();
    public virtual bool get_ContainsGenericParameters();
    public virtual MethodInfo GetGenericMethodDefinition();
    public virtual bool get_IsGenericMethod();
    public virtual Type[] GetGenericArguments();
    public virtual MethodInfo MakeGenericMethod(Type[] typeArguments);
    public GenericTypeParameterBuilder[] DefineGenericParameters(String[] names);
    internal void ThrowIfGeneric();
    public MethodToken GetToken();
    private MethodToken GetTokenNoLock();
    public void SetParameters(Type[] parameterTypes);
    [NullableContextAttribute("2")]
public void SetReturnType(Type returnType);
    [NullableContextAttribute("2")]
public void SetSignature(Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
    public ParameterBuilder DefineParameter(int position, ParameterAttributes attributes, string strParamName);
    public void SetImplementationFlags(MethodImplAttributes attributes);
    public ILGenerator GetILGenerator();
    public ILGenerator GetILGenerator(int size);
    private void ThrowIfShouldNotHaveBody();
    public bool get_InitLocals();
    public void set_InitLocals(bool value);
    public Module GetModule();
    public string get_Signature();
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    private bool IsKnownCA(ConstructorInfo con);
    private void ParseCA(ConstructorInfo con, Byte[] blob);
}
internal class System.Reflection.Emit.MethodBuilderInstantiation : MethodInfo {
    internal MethodInfo m_method;
    private Type[] m_inst;
    public MemberTypes MemberType { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public Module Module { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public bool IsGenericMethodDefinition { get; }
    public bool ContainsGenericParameters { get; }
    public bool IsGenericMethod { get; }
    public Type ReturnType { get; }
    public ParameterInfo ReturnParameter { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    internal MethodBuilderInstantiation(MethodInfo method, Type[] inst);
    internal static MethodInfo MakeGenericMethod(MethodInfo method, Type[] inst);
    internal virtual Type[] GetParameterTypes();
    public virtual MemberTypes get_MemberType();
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Module get_Module();
    public virtual ParameterInfo[] GetParameters();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual MethodAttributes get_Attributes();
    public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual CallingConventions get_CallingConvention();
    public virtual Type[] GetGenericArguments();
    public virtual MethodInfo GetGenericMethodDefinition();
    public virtual bool get_IsGenericMethodDefinition();
    public virtual bool get_ContainsGenericParameters();
    public virtual MethodInfo MakeGenericMethod(Type[] arguments);
    public virtual bool get_IsGenericMethod();
    public virtual Type get_ReturnType();
    public virtual ParameterInfo get_ReturnParameter();
    public virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public virtual MethodInfo GetBaseDefinition();
}
internal class System.Reflection.Emit.MethodOnTypeBuilderInstantiation : MethodInfo {
    internal MethodInfo m_method;
    private TypeBuilderInstantiation m_type;
    public MemberTypes MemberType { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public Module Module { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public bool IsGenericMethodDefinition { get; }
    public bool ContainsGenericParameters { get; }
    public bool IsGenericMethod { get; }
    public Type ReturnType { get; }
    public ParameterInfo ReturnParameter { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    internal MethodOnTypeBuilderInstantiation(MethodInfo method, TypeBuilderInstantiation type);
    internal static MethodInfo GetMethod(MethodInfo method, TypeBuilderInstantiation type);
    internal virtual Type[] GetParameterTypes();
    public virtual MemberTypes get_MemberType();
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Module get_Module();
    public virtual ParameterInfo[] GetParameters();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual MethodAttributes get_Attributes();
    public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual CallingConventions get_CallingConvention();
    public virtual Type[] GetGenericArguments();
    public virtual MethodInfo GetGenericMethodDefinition();
    public virtual bool get_IsGenericMethodDefinition();
    public virtual bool get_ContainsGenericParameters();
    public virtual MethodInfo MakeGenericMethod(Type[] typeArgs);
    public virtual bool get_IsGenericMethod();
    public virtual Type get_ReturnType();
    public virtual ParameterInfo get_ReturnParameter();
    public virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public virtual MethodInfo GetBaseDefinition();
}
public class System.Reflection.Emit.MethodToken : ValueType {
    public static MethodToken Empty;
    [CompilerGeneratedAttribute]
private int <Token>k__BackingField;
    public int Token { get; }
    internal MethodToken(int methodToken);
    private static MethodToken();
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public int get_Token();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public bool Equals(MethodToken obj);
    public static bool op_Equality(MethodToken a, MethodToken b);
    public static bool op_Inequality(MethodToken a, MethodToken b);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Reflection.Emit.ModuleBuilder : Module {
    private Dictionary`2<string, Type> _typeBuilderDict;
    private ISymbolWriter _iSymWriter;
    internal ModuleBuilderData _moduleData;
    internal InternalModuleBuilder _internalModuleBuilder;
    private AssemblyBuilder _assemblyBuilder;
    internal AssemblyBuilder ContainingAssemblyBuilder { get; }
    internal object SyncRoot { get; }
    internal InternalModuleBuilder InternalModule { get; }
    public string FullyQualifiedName { get; }
    public int MDStreamVersion { get; }
    public Guid ModuleVersionId { get; }
    public int MetadataToken { get; }
    public string ScopeName { get; }
    public string Name { get; }
    public Assembly Assembly { get; }
    internal ModuleBuilder(AssemblyBuilder assemblyBuilder, InternalModuleBuilder internalModuleBuilder);
    internal static IntPtr nCreateISymWriterForDynamicModule(Module module, string filename);
    internal static string UnmangleTypeName(string typeName);
    internal AssemblyBuilder get_ContainingAssemblyBuilder();
    internal void AddType(string name, Type type);
    internal void CheckTypeNameConflict(string strTypeName, Type enclosingType);
    private Type GetType(string strFormat, Type baseType);
    internal void CheckContext(Type[][] typess);
    internal void CheckContext(Type[] types);
    private static int GetTypeRef(QCallModule module, string strFullName, QCallModule refedModule, string strRefedModuleFileName, int tkResolution);
    private static int GetMemberRef(QCallModule module, QCallModule refedModule, int tr, int defToken);
    private int GetMemberRef(Module refedModule, int tr, int defToken);
    private static int GetMemberRefFromSignature(QCallModule module, int tr, string methodName, Byte[] signature, int length);
    private int GetMemberRefFromSignature(int tr, string methodName, Byte[] signature, int length);
    private static int GetMemberRefOfMethodInfo(QCallModule module, int tr, RuntimeMethodHandleInternal method);
    private int GetMemberRefOfMethodInfo(int tr, RuntimeMethodInfo method);
    private int GetMemberRefOfMethodInfo(int tr, RuntimeConstructorInfo method);
    private static int GetMemberRefOfFieldInfo(QCallModule module, int tkType, QCallTypeHandle declaringType, int tkField);
    private int GetMemberRefOfFieldInfo(int tkType, RuntimeTypeHandle declaringType, RuntimeFieldInfo runtimeField);
    private static int GetTokenFromTypeSpec(QCallModule pModule, Byte[] signature, int length);
    private int GetTokenFromTypeSpec(Byte[] signature, int length);
    private static int GetArrayMethodToken(QCallModule module, int tkTypeSpec, string methodName, Byte[] signature, int sigLength);
    private static int GetStringConstant(QCallModule module, string str, int length);
    internal static void SetFieldRVAContent(QCallModule module, int fdToken, Byte[] data, int length);
    internal virtual Type FindTypeBuilderWithName(string strTypeName, bool ignoreCase);
    private int GetTypeRefNested(Type type, Module refedModule, string strRefedModuleFileName);
    internal MethodToken InternalGetConstructorToken(ConstructorInfo con, bool usingRef);
    internal void Init(string strModuleName);
    internal void SetSymWriter(ISymbolWriter writer);
    internal object get_SyncRoot();
    internal InternalModuleBuilder get_InternalModule();
    protected virtual ModuleHandle GetModuleHandleImpl();
    internal RuntimeModule GetNativeHandle();
    private static RuntimeModule GetRuntimeModuleFromModule(Module m);
    private int GetMemberRefToken(MethodBase method, IEnumerable`1<Type> optionalParameterTypes);
    internal SignatureHelper GetMemberRefSignature(CallingConventions call, Type returnType, Type[] parameterTypes, IEnumerable`1<Type> optionalParameterTypes, int cGenericParameters);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual Type[] GetTypes();
    internal Type[] GetTypesNoLock();
    public virtual Type GetType(string className);
    public virtual Type GetType(string className, bool ignoreCase);
    public virtual Type GetType(string className, bool throwOnError, bool ignoreCase);
    private Type GetTypeNoLock(string className, bool throwOnError, bool ignoreCase);
    public virtual string get_FullyQualifiedName();
    public virtual Byte[] ResolveSignature(int metadataToken);
    [NullableContextAttribute("2")]
public virtual MethodBase ResolveMethod(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    [NullableContextAttribute("2")]
public virtual FieldInfo ResolveField(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual Type ResolveType(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    [NullableContextAttribute("2")]
public virtual MemberInfo ResolveMember(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual string ResolveString(int metadataToken);
    public virtual void GetPEKind(PortableExecutableKinds& peKind, ImageFileMachine& machine);
    public virtual int get_MDStreamVersion();
    public virtual Guid get_ModuleVersionId();
    public virtual int get_MetadataToken();
    public virtual bool IsResource();
    public virtual FieldInfo[] GetFields(BindingFlags bindingFlags);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingFlags);
    [NullableContextAttribute("2")]
protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual string get_ScopeName();
    public virtual string get_Name();
    public virtual Assembly get_Assembly();
    public TypeBuilder DefineType(string name);
    public TypeBuilder DefineType(string name, TypeAttributes attr);
    public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent);
    public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, int typesize);
    public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, PackingSize packingSize, int typesize);
    public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, Type[] interfaces);
    private TypeBuilder DefineTypeNoLock(string name, TypeAttributes attr, Type parent, Type[] interfaces, PackingSize packingSize, int typesize);
    public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, PackingSize packsize);
    private TypeBuilder DefineTypeNoLock(string name, TypeAttributes attr, Type parent, PackingSize packsize);
    public EnumBuilder DefineEnum(string name, TypeAttributes visibility, Type underlyingType);
    private EnumBuilder DefineEnumNoLock(string name, TypeAttributes visibility, Type underlyingType);
    public MethodBuilder DefinePInvokeMethod(string name, string dllName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, CallingConvention nativeCallConv, CharSet nativeCharSet);
    public MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, CallingConvention nativeCallConv, CharSet nativeCharSet);
    public MethodBuilder DefineGlobalMethod(string name, MethodAttributes attributes, Type returnType, Type[] parameterTypes);
    public MethodBuilder DefineGlobalMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    public MethodBuilder DefineGlobalMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers);
    private MethodBuilder DefineGlobalMethodNoLock(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers);
    public void CreateGlobalFunctions();
    private void CreateGlobalFunctionsNoLock();
    public FieldBuilder DefineInitializedData(string name, Byte[] data, FieldAttributes attributes);
    private FieldBuilder DefineInitializedDataNoLock(string name, Byte[] data, FieldAttributes attributes);
    public FieldBuilder DefineUninitializedData(string name, int size, FieldAttributes attributes);
    private FieldBuilder DefineUninitializedDataNoLock(string name, int size, FieldAttributes attributes);
    internal TypeToken GetTypeTokenInternal(Type type);
    private TypeToken GetTypeTokenInternal(Type type, bool getGenericDefinition);
    public TypeToken GetTypeToken(Type type);
    private TypeToken GetTypeTokenWorkerNoLock(Type type, bool getGenericDefinition);
    public TypeToken GetTypeToken(string name);
    public MethodToken GetMethodToken(MethodInfo method);
    internal MethodToken GetMethodTokenInternal(MethodInfo method);
    private MethodToken GetMethodTokenNoLock(MethodInfo method, bool getGenericTypeDefinition);
    internal int GetMethodTokenInternal(MethodBase method, IEnumerable`1<Type> optionalParameterTypes, bool useMethodDef);
    public MethodToken GetArrayMethodToken(Type arrayClass, string methodName, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    private MethodToken GetArrayMethodTokenNoLock(Type arrayClass, string methodName, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    public MethodInfo GetArrayMethod(Type arrayClass, string methodName, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    public MethodToken GetConstructorToken(ConstructorInfo con);
    public FieldToken GetFieldToken(FieldInfo field);
    private FieldToken GetFieldTokenNoLock(FieldInfo field);
    public StringToken GetStringConstant(string str);
    public SignatureToken GetSignatureToken(SignatureHelper sigHelper);
    public SignatureToken GetSignatureToken(Byte[] sigBytes, int sigLength);
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    internal ISymbolWriter GetSymWriter();
    public ISymbolDocumentWriter DefineDocument(string url, Guid language, Guid languageVendor, Guid documentType);
    private ISymbolDocumentWriter DefineDocumentNoLock(string url, Guid language, Guid languageVendor, Guid documentType);
    public bool IsTransient();
}
internal class System.Reflection.Emit.ModuleBuilderData : object {
    public TypeBuilder _globalTypeBuilder;
    public string _moduleName;
    public bool _hasGlobalBeenCreated;
    internal ModuleBuilderData(ModuleBuilder module, string moduleName);
}
[IsReadOnlyAttribute]
[NullableAttribute("0")]
[NullableContextAttribute("2")]
public class System.Reflection.Emit.OpCode : ValueType {
    private OpCodeValues m_value;
    private int m_flags;
    private static String[] modreq(System.Runtime.CompilerServices.IsVolatile) g_nameCache;
    public OperandType OperandType { get; }
    public FlowControl FlowControl { get; }
    public OpCodeType OpCodeType { get; }
    public StackBehaviour StackBehaviourPop { get; }
    public StackBehaviour StackBehaviourPush { get; }
    public int Size { get; }
    public short Value { get; }
    public string Name { get; }
    internal OpCode(OpCodeValues value, int flags);
    internal bool EndsUncondJmpBlk();
    internal int StackChange();
    public OperandType get_OperandType();
    public FlowControl get_FlowControl();
    public OpCodeType get_OpCodeType();
    public StackBehaviour get_StackBehaviourPop();
    public StackBehaviour get_StackBehaviourPush();
    public int get_Size();
    public short get_Value();
    public string get_Name();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(OpCode obj);
    public static bool op_Equality(OpCode a, OpCode b);
    public static bool op_Inequality(OpCode a, OpCode b);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class System.Reflection.Emit.OpCodes : object {
    public static OpCode Nop;
    public static OpCode Break;
    public static OpCode Ldarg_0;
    public static OpCode Ldarg_1;
    public static OpCode Ldarg_2;
    public static OpCode Ldarg_3;
    public static OpCode Ldloc_0;
    public static OpCode Ldloc_1;
    public static OpCode Ldloc_2;
    public static OpCode Ldloc_3;
    public static OpCode Stloc_0;
    public static OpCode Stloc_1;
    public static OpCode Stloc_2;
    public static OpCode Stloc_3;
    public static OpCode Ldarg_S;
    public static OpCode Ldarga_S;
    public static OpCode Starg_S;
    public static OpCode Ldloc_S;
    public static OpCode Ldloca_S;
    public static OpCode Stloc_S;
    public static OpCode Ldnull;
    public static OpCode Ldc_I4_M1;
    public static OpCode Ldc_I4_0;
    public static OpCode Ldc_I4_1;
    public static OpCode Ldc_I4_2;
    public static OpCode Ldc_I4_3;
    public static OpCode Ldc_I4_4;
    public static OpCode Ldc_I4_5;
    public static OpCode Ldc_I4_6;
    public static OpCode Ldc_I4_7;
    public static OpCode Ldc_I4_8;
    public static OpCode Ldc_I4_S;
    public static OpCode Ldc_I4;
    public static OpCode Ldc_I8;
    public static OpCode Ldc_R4;
    public static OpCode Ldc_R8;
    public static OpCode Dup;
    public static OpCode Pop;
    public static OpCode Jmp;
    public static OpCode Call;
    public static OpCode Calli;
    public static OpCode Ret;
    public static OpCode Br_S;
    public static OpCode Brfalse_S;
    public static OpCode Brtrue_S;
    public static OpCode Beq_S;
    public static OpCode Bge_S;
    public static OpCode Bgt_S;
    public static OpCode Ble_S;
    public static OpCode Blt_S;
    public static OpCode Bne_Un_S;
    public static OpCode Bge_Un_S;
    public static OpCode Bgt_Un_S;
    public static OpCode Ble_Un_S;
    public static OpCode Blt_Un_S;
    public static OpCode Br;
    public static OpCode Brfalse;
    public static OpCode Brtrue;
    public static OpCode Beq;
    public static OpCode Bge;
    public static OpCode Bgt;
    public static OpCode Ble;
    public static OpCode Blt;
    public static OpCode Bne_Un;
    public static OpCode Bge_Un;
    public static OpCode Bgt_Un;
    public static OpCode Ble_Un;
    public static OpCode Blt_Un;
    public static OpCode Switch;
    public static OpCode Ldind_I1;
    public static OpCode Ldind_U1;
    public static OpCode Ldind_I2;
    public static OpCode Ldind_U2;
    public static OpCode Ldind_I4;
    public static OpCode Ldind_U4;
    public static OpCode Ldind_I8;
    public static OpCode Ldind_I;
    public static OpCode Ldind_R4;
    public static OpCode Ldind_R8;
    public static OpCode Ldind_Ref;
    public static OpCode Stind_Ref;
    public static OpCode Stind_I1;
    public static OpCode Stind_I2;
    public static OpCode Stind_I4;
    public static OpCode Stind_I8;
    public static OpCode Stind_R4;
    public static OpCode Stind_R8;
    public static OpCode Add;
    public static OpCode Sub;
    public static OpCode Mul;
    public static OpCode Div;
    public static OpCode Div_Un;
    public static OpCode Rem;
    public static OpCode Rem_Un;
    public static OpCode And;
    public static OpCode Or;
    public static OpCode Xor;
    public static OpCode Shl;
    public static OpCode Shr;
    public static OpCode Shr_Un;
    public static OpCode Neg;
    public static OpCode Not;
    public static OpCode Conv_I1;
    public static OpCode Conv_I2;
    public static OpCode Conv_I4;
    public static OpCode Conv_I8;
    public static OpCode Conv_R4;
    public static OpCode Conv_R8;
    public static OpCode Conv_U4;
    public static OpCode Conv_U8;
    public static OpCode Callvirt;
    public static OpCode Cpobj;
    public static OpCode Ldobj;
    public static OpCode Ldstr;
    public static OpCode Newobj;
    public static OpCode Castclass;
    public static OpCode Isinst;
    public static OpCode Conv_R_Un;
    public static OpCode Unbox;
    public static OpCode Throw;
    public static OpCode Ldfld;
    public static OpCode Ldflda;
    public static OpCode Stfld;
    public static OpCode Ldsfld;
    public static OpCode Ldsflda;
    public static OpCode Stsfld;
    public static OpCode Stobj;
    public static OpCode Conv_Ovf_I1_Un;
    public static OpCode Conv_Ovf_I2_Un;
    public static OpCode Conv_Ovf_I4_Un;
    public static OpCode Conv_Ovf_I8_Un;
    public static OpCode Conv_Ovf_U1_Un;
    public static OpCode Conv_Ovf_U2_Un;
    public static OpCode Conv_Ovf_U4_Un;
    public static OpCode Conv_Ovf_U8_Un;
    public static OpCode Conv_Ovf_I_Un;
    public static OpCode Conv_Ovf_U_Un;
    public static OpCode Box;
    public static OpCode Newarr;
    public static OpCode Ldlen;
    public static OpCode Ldelema;
    public static OpCode Ldelem_I1;
    public static OpCode Ldelem_U1;
    public static OpCode Ldelem_I2;
    public static OpCode Ldelem_U2;
    public static OpCode Ldelem_I4;
    public static OpCode Ldelem_U4;
    public static OpCode Ldelem_I8;
    public static OpCode Ldelem_I;
    public static OpCode Ldelem_R4;
    public static OpCode Ldelem_R8;
    public static OpCode Ldelem_Ref;
    public static OpCode Stelem_I;
    public static OpCode Stelem_I1;
    public static OpCode Stelem_I2;
    public static OpCode Stelem_I4;
    public static OpCode Stelem_I8;
    public static OpCode Stelem_R4;
    public static OpCode Stelem_R8;
    public static OpCode Stelem_Ref;
    public static OpCode Ldelem;
    public static OpCode Stelem;
    public static OpCode Unbox_Any;
    public static OpCode Conv_Ovf_I1;
    public static OpCode Conv_Ovf_U1;
    public static OpCode Conv_Ovf_I2;
    public static OpCode Conv_Ovf_U2;
    public static OpCode Conv_Ovf_I4;
    public static OpCode Conv_Ovf_U4;
    public static OpCode Conv_Ovf_I8;
    public static OpCode Conv_Ovf_U8;
    public static OpCode Refanyval;
    public static OpCode Ckfinite;
    public static OpCode Mkrefany;
    public static OpCode Ldtoken;
    public static OpCode Conv_U2;
    public static OpCode Conv_U1;
    public static OpCode Conv_I;
    public static OpCode Conv_Ovf_I;
    public static OpCode Conv_Ovf_U;
    public static OpCode Add_Ovf;
    public static OpCode Add_Ovf_Un;
    public static OpCode Mul_Ovf;
    public static OpCode Mul_Ovf_Un;
    public static OpCode Sub_Ovf;
    public static OpCode Sub_Ovf_Un;
    public static OpCode Endfinally;
    public static OpCode Leave;
    public static OpCode Leave_S;
    public static OpCode Stind_I;
    public static OpCode Conv_U;
    public static OpCode Prefix7;
    public static OpCode Prefix6;
    public static OpCode Prefix5;
    public static OpCode Prefix4;
    public static OpCode Prefix3;
    public static OpCode Prefix2;
    public static OpCode Prefix1;
    public static OpCode Prefixref;
    public static OpCode Arglist;
    public static OpCode Ceq;
    public static OpCode Cgt;
    public static OpCode Cgt_Un;
    public static OpCode Clt;
    public static OpCode Clt_Un;
    public static OpCode Ldftn;
    public static OpCode Ldvirtftn;
    public static OpCode Ldarg;
    public static OpCode Ldarga;
    public static OpCode Starg;
    public static OpCode Ldloc;
    public static OpCode Ldloca;
    public static OpCode Stloc;
    public static OpCode Localloc;
    public static OpCode Endfilter;
    public static OpCode Unaligned;
    public static OpCode Volatile;
    public static OpCode Tailcall;
    public static OpCode Initobj;
    public static OpCode Constrained;
    public static OpCode Cpblk;
    public static OpCode Initblk;
    public static OpCode Rethrow;
    public static OpCode Sizeof;
    public static OpCode Refanytype;
    public static OpCode Readonly;
    private static OpCodes();
    public static bool TakesSingleByteArgument(OpCode inst);
}
public enum System.Reflection.Emit.OpCodeType : Enum {
    public int value__;
    [ObsoleteAttribute("This API has been deprecated. https://go.microsoft.com/fwlink/?linkid=14202")]
public static OpCodeType Annotation;
    public static OpCodeType Macro;
    public static OpCodeType Nternal;
    public static OpCodeType Objmodel;
    public static OpCodeType Prefix;
    public static OpCodeType Primitive;
}
internal enum System.Reflection.Emit.OpCodeValues : Enum {
    public int value__;
    public static OpCodeValues Nop;
    public static OpCodeValues Break;
    public static OpCodeValues Ldarg_0;
    public static OpCodeValues Ldarg_1;
    public static OpCodeValues Ldarg_2;
    public static OpCodeValues Ldarg_3;
    public static OpCodeValues Ldloc_0;
    public static OpCodeValues Ldloc_1;
    public static OpCodeValues Ldloc_2;
    public static OpCodeValues Ldloc_3;
    public static OpCodeValues Stloc_0;
    public static OpCodeValues Stloc_1;
    public static OpCodeValues Stloc_2;
    public static OpCodeValues Stloc_3;
    public static OpCodeValues Ldarg_S;
    public static OpCodeValues Ldarga_S;
    public static OpCodeValues Starg_S;
    public static OpCodeValues Ldloc_S;
    public static OpCodeValues Ldloca_S;
    public static OpCodeValues Stloc_S;
    public static OpCodeValues Ldnull;
    public static OpCodeValues Ldc_I4_M1;
    public static OpCodeValues Ldc_I4_0;
    public static OpCodeValues Ldc_I4_1;
    public static OpCodeValues Ldc_I4_2;
    public static OpCodeValues Ldc_I4_3;
    public static OpCodeValues Ldc_I4_4;
    public static OpCodeValues Ldc_I4_5;
    public static OpCodeValues Ldc_I4_6;
    public static OpCodeValues Ldc_I4_7;
    public static OpCodeValues Ldc_I4_8;
    public static OpCodeValues Ldc_I4_S;
    public static OpCodeValues Ldc_I4;
    public static OpCodeValues Ldc_I8;
    public static OpCodeValues Ldc_R4;
    public static OpCodeValues Ldc_R8;
    public static OpCodeValues Dup;
    public static OpCodeValues Pop;
    public static OpCodeValues Jmp;
    public static OpCodeValues Call;
    public static OpCodeValues Calli;
    public static OpCodeValues Ret;
    public static OpCodeValues Br_S;
    public static OpCodeValues Brfalse_S;
    public static OpCodeValues Brtrue_S;
    public static OpCodeValues Beq_S;
    public static OpCodeValues Bge_S;
    public static OpCodeValues Bgt_S;
    public static OpCodeValues Ble_S;
    public static OpCodeValues Blt_S;
    public static OpCodeValues Bne_Un_S;
    public static OpCodeValues Bge_Un_S;
    public static OpCodeValues Bgt_Un_S;
    public static OpCodeValues Ble_Un_S;
    public static OpCodeValues Blt_Un_S;
    public static OpCodeValues Br;
    public static OpCodeValues Brfalse;
    public static OpCodeValues Brtrue;
    public static OpCodeValues Beq;
    public static OpCodeValues Bge;
    public static OpCodeValues Bgt;
    public static OpCodeValues Ble;
    public static OpCodeValues Blt;
    public static OpCodeValues Bne_Un;
    public static OpCodeValues Bge_Un;
    public static OpCodeValues Bgt_Un;
    public static OpCodeValues Ble_Un;
    public static OpCodeValues Blt_Un;
    public static OpCodeValues Switch;
    public static OpCodeValues Ldind_I1;
    public static OpCodeValues Ldind_U1;
    public static OpCodeValues Ldind_I2;
    public static OpCodeValues Ldind_U2;
    public static OpCodeValues Ldind_I4;
    public static OpCodeValues Ldind_U4;
    public static OpCodeValues Ldind_I8;
    public static OpCodeValues Ldind_I;
    public static OpCodeValues Ldind_R4;
    public static OpCodeValues Ldind_R8;
    public static OpCodeValues Ldind_Ref;
    public static OpCodeValues Stind_Ref;
    public static OpCodeValues Stind_I1;
    public static OpCodeValues Stind_I2;
    public static OpCodeValues Stind_I4;
    public static OpCodeValues Stind_I8;
    public static OpCodeValues Stind_R4;
    public static OpCodeValues Stind_R8;
    public static OpCodeValues Add;
    public static OpCodeValues Sub;
    public static OpCodeValues Mul;
    public static OpCodeValues Div;
    public static OpCodeValues Div_Un;
    public static OpCodeValues Rem;
    public static OpCodeValues Rem_Un;
    public static OpCodeValues And;
    public static OpCodeValues Or;
    public static OpCodeValues Xor;
    public static OpCodeValues Shl;
    public static OpCodeValues Shr;
    public static OpCodeValues Shr_Un;
    public static OpCodeValues Neg;
    public static OpCodeValues Not;
    public static OpCodeValues Conv_I1;
    public static OpCodeValues Conv_I2;
    public static OpCodeValues Conv_I4;
    public static OpCodeValues Conv_I8;
    public static OpCodeValues Conv_R4;
    public static OpCodeValues Conv_R8;
    public static OpCodeValues Conv_U4;
    public static OpCodeValues Conv_U8;
    public static OpCodeValues Callvirt;
    public static OpCodeValues Cpobj;
    public static OpCodeValues Ldobj;
    public static OpCodeValues Ldstr;
    public static OpCodeValues Newobj;
    public static OpCodeValues Castclass;
    public static OpCodeValues Isinst;
    public static OpCodeValues Conv_R_Un;
    public static OpCodeValues Unbox;
    public static OpCodeValues Throw;
    public static OpCodeValues Ldfld;
    public static OpCodeValues Ldflda;
    public static OpCodeValues Stfld;
    public static OpCodeValues Ldsfld;
    public static OpCodeValues Ldsflda;
    public static OpCodeValues Stsfld;
    public static OpCodeValues Stobj;
    public static OpCodeValues Conv_Ovf_I1_Un;
    public static OpCodeValues Conv_Ovf_I2_Un;
    public static OpCodeValues Conv_Ovf_I4_Un;
    public static OpCodeValues Conv_Ovf_I8_Un;
    public static OpCodeValues Conv_Ovf_U1_Un;
    public static OpCodeValues Conv_Ovf_U2_Un;
    public static OpCodeValues Conv_Ovf_U4_Un;
    public static OpCodeValues Conv_Ovf_U8_Un;
    public static OpCodeValues Conv_Ovf_I_Un;
    public static OpCodeValues Conv_Ovf_U_Un;
    public static OpCodeValues Box;
    public static OpCodeValues Newarr;
    public static OpCodeValues Ldlen;
    public static OpCodeValues Ldelema;
    public static OpCodeValues Ldelem_I1;
    public static OpCodeValues Ldelem_U1;
    public static OpCodeValues Ldelem_I2;
    public static OpCodeValues Ldelem_U2;
    public static OpCodeValues Ldelem_I4;
    public static OpCodeValues Ldelem_U4;
    public static OpCodeValues Ldelem_I8;
    public static OpCodeValues Ldelem_I;
    public static OpCodeValues Ldelem_R4;
    public static OpCodeValues Ldelem_R8;
    public static OpCodeValues Ldelem_Ref;
    public static OpCodeValues Stelem_I;
    public static OpCodeValues Stelem_I1;
    public static OpCodeValues Stelem_I2;
    public static OpCodeValues Stelem_I4;
    public static OpCodeValues Stelem_I8;
    public static OpCodeValues Stelem_R4;
    public static OpCodeValues Stelem_R8;
    public static OpCodeValues Stelem_Ref;
    public static OpCodeValues Ldelem;
    public static OpCodeValues Stelem;
    public static OpCodeValues Unbox_Any;
    public static OpCodeValues Conv_Ovf_I1;
    public static OpCodeValues Conv_Ovf_U1;
    public static OpCodeValues Conv_Ovf_I2;
    public static OpCodeValues Conv_Ovf_U2;
    public static OpCodeValues Conv_Ovf_I4;
    public static OpCodeValues Conv_Ovf_U4;
    public static OpCodeValues Conv_Ovf_I8;
    public static OpCodeValues Conv_Ovf_U8;
    public static OpCodeValues Refanyval;
    public static OpCodeValues Ckfinite;
    public static OpCodeValues Mkrefany;
    public static OpCodeValues Ldtoken;
    public static OpCodeValues Conv_U2;
    public static OpCodeValues Conv_U1;
    public static OpCodeValues Conv_I;
    public static OpCodeValues Conv_Ovf_I;
    public static OpCodeValues Conv_Ovf_U;
    public static OpCodeValues Add_Ovf;
    public static OpCodeValues Add_Ovf_Un;
    public static OpCodeValues Mul_Ovf;
    public static OpCodeValues Mul_Ovf_Un;
    public static OpCodeValues Sub_Ovf;
    public static OpCodeValues Sub_Ovf_Un;
    public static OpCodeValues Endfinally;
    public static OpCodeValues Leave;
    public static OpCodeValues Leave_S;
    public static OpCodeValues Stind_I;
    public static OpCodeValues Conv_U;
    public static OpCodeValues Prefix7;
    public static OpCodeValues Prefix6;
    public static OpCodeValues Prefix5;
    public static OpCodeValues Prefix4;
    public static OpCodeValues Prefix3;
    public static OpCodeValues Prefix2;
    public static OpCodeValues Prefix1;
    public static OpCodeValues Prefixref;
    public static OpCodeValues Arglist;
    public static OpCodeValues Ceq;
    public static OpCodeValues Cgt;
    public static OpCodeValues Cgt_Un;
    public static OpCodeValues Clt;
    public static OpCodeValues Clt_Un;
    public static OpCodeValues Ldftn;
    public static OpCodeValues Ldvirtftn;
    public static OpCodeValues Ldarg;
    public static OpCodeValues Ldarga;
    public static OpCodeValues Starg;
    public static OpCodeValues Ldloc;
    public static OpCodeValues Ldloca;
    public static OpCodeValues Stloc;
    public static OpCodeValues Localloc;
    public static OpCodeValues Endfilter;
    public static OpCodeValues Unaligned_;
    public static OpCodeValues Volatile_;
    public static OpCodeValues Tail_;
    public static OpCodeValues Initobj;
    public static OpCodeValues Constrained_;
    public static OpCodeValues Cpblk;
    public static OpCodeValues Initblk;
    public static OpCodeValues Rethrow;
    public static OpCodeValues Sizeof;
    public static OpCodeValues Refanytype;
    public static OpCodeValues Readonly_;
}
public enum System.Reflection.Emit.OperandType : Enum {
    public int value__;
    public static OperandType InlineBrTarget;
    public static OperandType InlineField;
    public static OperandType InlineI;
    public static OperandType InlineI8;
    public static OperandType InlineMethod;
    public static OperandType InlineNone;
    [ObsoleteAttribute("This API has been deprecated. https://go.microsoft.com/fwlink/?linkid=14202")]
public static OperandType InlinePhi;
    public static OperandType InlineR;
    public static OperandType InlineSig;
    public static OperandType InlineString;
    public static OperandType InlineSwitch;
    public static OperandType InlineTok;
    public static OperandType InlineType;
    public static OperandType InlineVar;
    public static OperandType ShortInlineBrTarget;
    public static OperandType ShortInlineI;
    public static OperandType ShortInlineR;
    public static OperandType ShortInlineVar;
}
public enum System.Reflection.Emit.PackingSize : Enum {
    public int value__;
    public static PackingSize Unspecified;
    public static PackingSize Size1;
    public static PackingSize Size2;
    public static PackingSize Size4;
    public static PackingSize Size8;
    public static PackingSize Size16;
    public static PackingSize Size32;
    public static PackingSize Size64;
    public static PackingSize Size128;
}
[NullableAttribute("0")]
[NullableContextAttribute("2")]
public class System.Reflection.Emit.ParameterBuilder : object {
    private string _name;
    private int _position;
    private ParameterAttributes _attributes;
    private MethodBuilder _methodBuilder;
    private ParameterToken _token;
    public string Name { get; }
    public int Position { get; }
    public int Attributes { get; }
    public bool IsIn { get; }
    public bool IsOut { get; }
    public bool IsOptional { get; }
    internal ParameterBuilder(MethodBuilder methodBuilder, int sequence, ParameterAttributes attributes, string paramName);
    public virtual void SetConstant(object defaultValue);
    [NullableContextAttribute("1")]
public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    [NullableContextAttribute("1")]
public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    public virtual ParameterToken GetToken();
    public virtual string get_Name();
    public virtual int get_Position();
    public virtual int get_Attributes();
    public bool get_IsIn();
    public bool get_IsOut();
    public bool get_IsOptional();
}
public class System.Reflection.Emit.ParameterToken : ValueType {
    public static ParameterToken Empty;
    [CompilerGeneratedAttribute]
private int <Token>k__BackingField;
    public int Token { get; }
    internal ParameterToken(int parameterToken);
    private static ParameterToken();
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public int get_Token();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public bool Equals(ParameterToken obj);
    public static bool op_Equality(ParameterToken a, ParameterToken b);
    public static bool op_Inequality(ParameterToken a, ParameterToken b);
}
public enum System.Reflection.Emit.PEFileKinds : Enum {
    public int value__;
    public static PEFileKinds Dll;
    public static PEFileKinds ConsoleApplication;
    public static PEFileKinds WindowApplication;
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Reflection.Emit.PropertyBuilder : PropertyInfo {
    private string m_name;
    private PropertyToken m_prToken;
    private int m_tkProperty;
    private ModuleBuilder m_moduleBuilder;
    private SignatureHelper m_signature;
    private PropertyAttributes m_attributes;
    private Type m_returnType;
    private MethodInfo m_getMethod;
    private MethodInfo m_setMethod;
    private TypeBuilder m_containingType;
    public PropertyToken PropertyToken { get; }
    public Module Module { get; }
    public Type PropertyType { get; }
    public PropertyAttributes Attributes { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public string Name { get; }
    [NullableAttribute("2")]
public Type DeclaringType { get; }
    [NullableAttribute("2")]
public Type ReflectedType { get; }
    internal PropertyBuilder(ModuleBuilder mod, string name, SignatureHelper sig, PropertyAttributes attr, Type returnType, PropertyToken prToken, TypeBuilder containingType);
    [NullableContextAttribute("2")]
public void SetConstant(object defaultValue);
    public PropertyToken get_PropertyToken();
    public virtual Module get_Module();
    private void SetMethodSemantics(MethodBuilder mdBuilder, MethodSemanticsAttributes semantics);
    public void SetGetMethod(MethodBuilder mdBuilder);
    public void SetSetMethod(MethodBuilder mdBuilder);
    public void AddOtherMethod(MethodBuilder mdBuilder);
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    [NullableContextAttribute("2")]
public virtual object GetValue(object obj, Object[] index);
    [NullableContextAttribute("2")]
public virtual object GetValue(object obj, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    [NullableContextAttribute("2")]
public virtual void SetValue(object obj, object value, Object[] index);
    [NullableContextAttribute("2")]
public virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public virtual MethodInfo[] GetAccessors(bool nonPublic);
    [NullableContextAttribute("2")]
public virtual MethodInfo GetGetMethod(bool nonPublic);
    [NullableContextAttribute("2")]
public virtual MethodInfo GetSetMethod(bool nonPublic);
    public virtual ParameterInfo[] GetIndexParameters();
    public virtual Type get_PropertyType();
    public virtual PropertyAttributes get_Attributes();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual string get_Name();
    [NullableContextAttribute("2")]
public virtual Type get_DeclaringType();
    [NullableContextAttribute("2")]
public virtual Type get_ReflectedType();
}
public class System.Reflection.Emit.PropertyToken : ValueType {
    public static PropertyToken Empty;
    [CompilerGeneratedAttribute]
private int <Token>k__BackingField;
    public int Token { get; }
    internal PropertyToken(int propertyToken);
    private static PropertyToken();
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public int get_Token();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public bool Equals(PropertyToken obj);
    public static bool op_Equality(PropertyToken a, PropertyToken b);
    public static bool op_Inequality(PropertyToken a, PropertyToken b);
}
internal class System.Reflection.Emit.PunkSafeHandle : SafeHandle {
    private static DRelease m_Release;
    public bool IsInvalid { get; }
    private static PunkSafeHandle();
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
    private static IntPtr nGetDReleaseTarget();
}
internal class System.Reflection.Emit.REDocument : object {
    private Int32[] m_iOffsets;
    private Int32[] m_iLines;
    private Int32[] m_iColumns;
    private Int32[] m_iEndLines;
    private Int32[] m_iEndColumns;
    internal ISymbolDocumentWriter m_document;
    private int m_iLineNumberCount;
    internal REDocument(ISymbolDocumentWriter document);
    internal void AddLineNumberInfo(ISymbolDocumentWriter document, int iOffset, int iStartLine, int iStartColumn, int iEndLine, int iEndColumn);
    private void EnsureCapacity();
    internal void EmitLineNumberInfo(ISymbolWriter symWriter);
}
internal enum System.Reflection.Emit.ScopeAction : Enum {
    public sbyte value__;
    public static ScopeAction Open;
    public static ScopeAction Close;
}
internal class System.Reflection.Emit.ScopeTree : object {
    internal Int32[] m_iOffsets;
    internal ScopeAction[] m_ScopeActions;
    internal int m_iCount;
    internal int m_iOpenScopeCount;
    internal LocalSymInfo[] m_localSymInfos;
    internal int GetCurrentActiveScopeIndex();
    internal void AddLocalSymInfoToCurrentScope(string strName, Byte[] signature, int slot, int startOffset, int endOffset);
    internal void AddUsingNamespaceToCurrentScope(string strNamespace);
    internal void AddScopeInfo(ScopeAction sa, int iOffset);
    internal void EnsureCapacity();
    internal void EmitScopeTree(ISymbolWriter symWriter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Reflection.Emit.SignatureHelper : object {
    private Byte[] m_signature;
    private int m_currSig;
    private int m_sizeLoc;
    private ModuleBuilder m_module;
    private bool m_sigDone;
    private int m_argCount;
    internal int ArgumentCount { get; }
    private SignatureHelper(Module mod, MdSigCallingConvention callingConvention);
    private SignatureHelper(Module mod, MdSigCallingConvention callingConvention, int cGenericParameters, Type returnType, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers);
    private SignatureHelper(Module mod, MdSigCallingConvention callingConvention, Type returnType, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers);
    private SignatureHelper(Module mod, Type type);
    [NullableContextAttribute("2")]
public static SignatureHelper GetMethodSigHelper(Module mod, Type returnType, Type[] parameterTypes);
    internal static SignatureHelper GetMethodSigHelper(Module mod, CallingConventions callingConvention, Type returnType, int cGenericParam);
    [NullableContextAttribute("2")]
public static SignatureHelper GetMethodSigHelper(Module mod, CallingConventions callingConvention, Type returnType);
    internal static SignatureHelper GetMethodSpecSigHelper(Module scope, Type[] inst);
    internal static SignatureHelper GetMethodSigHelper(Module scope, CallingConventions callingConvention, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers);
    internal static SignatureHelper GetMethodSigHelper(Module scope, CallingConventions callingConvention, int cGenericParam, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers);
    [NullableContextAttribute("2")]
public static SignatureHelper GetMethodSigHelper(Module mod, CallingConvention unmanagedCallConv, Type returnType);
    public static SignatureHelper GetLocalVarSigHelper();
    public static SignatureHelper GetMethodSigHelper(CallingConventions callingConvention, Type returnType);
    public static SignatureHelper GetMethodSigHelper(CallingConvention unmanagedCallingConvention, Type returnType);
    public static SignatureHelper GetLocalVarSigHelper(Module mod);
    public static SignatureHelper GetFieldSigHelper(Module mod);
    [NullableContextAttribute("2")]
public static SignatureHelper GetPropertySigHelper(Module mod, Type returnType, Type[] parameterTypes);
    [NullableContextAttribute("2")]
public static SignatureHelper GetPropertySigHelper(Module mod, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers);
    [NullableContextAttribute("2")]
public static SignatureHelper GetPropertySigHelper(Module mod, CallingConventions callingConvention, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers);
    internal static SignatureHelper GetTypeSigToken(Module module, Type type);
    private void Init(Module mod);
    private void Init(Module mod, MdSigCallingConvention callingConvention);
    private void Init(Module mod, MdSigCallingConvention callingConvention, int cGenericParam);
    private void AddOneArgTypeHelper(Type argument, bool pinned);
    private void AddOneArgTypeHelper(Type clsArgument, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers);
    private void AddOneArgTypeHelper(Type clsArgument);
    private void AddOneArgTypeHelperWorker(Type clsArgument, bool lastWasGenericInst);
    private void AddData(int data);
    private void AddElementType(CorElementType cvt);
    private void AddToken(int token);
    private void InternalAddTypeToken(TypeToken clsToken, CorElementType CorType);
    private void InternalAddRuntimeType(Type type);
    private Byte[] ExpandArray(Byte[] inArray);
    private Byte[] ExpandArray(Byte[] inArray, int requiredLength);
    private void IncrementArgCounts();
    private void SetNumberOfSignatureElements(bool forceCopy);
    internal int get_ArgumentCount();
    internal static bool IsSimpleType(CorElementType type);
    internal Byte[] InternalGetSignature(Int32& length);
    internal Byte[] InternalGetSignatureArray();
    public void AddArgument(Type clsArgument);
    public void AddArgument(Type argument, bool pinned);
    public void AddArguments(Type[] arguments, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers);
    public void AddArgument(Type argument, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers);
    public void AddSentinel();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public Byte[] GetSignature();
    internal Byte[] GetSignature(bool appendEndOfSig);
    public virtual string ToString();
}
public class System.Reflection.Emit.SignatureToken : ValueType {
    public static SignatureToken Empty;
    [CompilerGeneratedAttribute]
private int <Token>k__BackingField;
    public int Token { get; }
    internal SignatureToken(int signatureToken);
    private static SignatureToken();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Token();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public bool Equals(SignatureToken obj);
    public static bool op_Equality(SignatureToken a, SignatureToken b);
    public static bool op_Inequality(SignatureToken a, SignatureToken b);
}
public enum System.Reflection.Emit.StackBehaviour : Enum {
    public int value__;
    public static StackBehaviour Pop0;
    public static StackBehaviour Pop1;
    public static StackBehaviour Pop1_pop1;
    public static StackBehaviour Popi;
    public static StackBehaviour Popi_pop1;
    public static StackBehaviour Popi_popi;
    public static StackBehaviour Popi_popi8;
    public static StackBehaviour Popi_popi_popi;
    public static StackBehaviour Popi_popr4;
    public static StackBehaviour Popi_popr8;
    public static StackBehaviour Popref;
    public static StackBehaviour Popref_pop1;
    public static StackBehaviour Popref_popi;
    public static StackBehaviour Popref_popi_popi;
    public static StackBehaviour Popref_popi_popi8;
    public static StackBehaviour Popref_popi_popr4;
    public static StackBehaviour Popref_popi_popr8;
    public static StackBehaviour Popref_popi_popref;
    public static StackBehaviour Push0;
    public static StackBehaviour Push1;
    public static StackBehaviour Push1_push1;
    public static StackBehaviour Pushi;
    public static StackBehaviour Pushi8;
    public static StackBehaviour Pushr4;
    public static StackBehaviour Pushr8;
    public static StackBehaviour Pushref;
    public static StackBehaviour Varpop;
    public static StackBehaviour Varpush;
    public static StackBehaviour Popref_popi_pop1;
}
public class System.Reflection.Emit.StringToken : ValueType {
    [CompilerGeneratedAttribute]
private int <Token>k__BackingField;
    public int Token { get; }
    internal StringToken(int str);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public int get_Token();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public bool Equals(StringToken obj);
    public static bool op_Equality(StringToken a, StringToken b);
    public static bool op_Inequality(StringToken a, StringToken b);
}
internal class System.Reflection.Emit.SymbolMethod : MethodInfo {
    private ModuleBuilder m_module;
    private Type m_containingType;
    private string m_name;
    private CallingConventions m_callingConvention;
    private Type m_returnType;
    private MethodToken m_mdMethod;
    private Type[] m_parameterTypes;
    private SignatureHelper m_signature;
    public Module Module { get; }
    public Type ReflectedType { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public Type ReturnType { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    internal SymbolMethod(ModuleBuilder mod, MethodToken token, Type arrayClass, string methodName, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    internal virtual Type[] GetParameterTypes();
    internal MethodToken GetToken(ModuleBuilder mod);
    public virtual Module get_Module();
    public virtual Type get_ReflectedType();
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual ParameterInfo[] GetParameters();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual MethodAttributes get_Attributes();
    public virtual CallingConventions get_CallingConvention();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual Type get_ReturnType();
    public virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual MethodInfo GetBaseDefinition();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public Module GetModule();
    public MethodToken GetToken();
}
internal class System.Reflection.Emit.SymbolType : TypeInfo {
    internal TypeKind m_typeKind;
    internal Type m_baseType;
    internal int m_cRank;
    internal Int32[] m_iaLowerBound;
    internal Int32[] m_iaUpperBound;
    private string m_format;
    private bool m_isSzArray;
    public bool IsTypeDefinition { get; }
    public bool IsSZArray { get; }
    public Guid GUID { get; }
    public Module Module { get; }
    public Assembly Assembly { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public string Name { get; }
    public string FullName { get; }
    public string AssemblyQualifiedName { get; }
    public string Namespace { get; }
    public Type BaseType { get; }
    public bool IsConstructedGenericType { get; }
    public Type UnderlyingSystemType { get; }
    internal SymbolType(TypeKind typeKind);
    public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    internal static Type FormCompoundType(string format, Type baseType, int curIndex);
    internal void SetElementType(Type baseType);
    private void SetBounds(int lower, int upper);
    internal void SetFormat(string format, int curIndex, int length);
    public virtual bool get_IsTypeDefinition();
    public virtual bool get_IsSZArray();
    public virtual Type MakePointerType();
    public virtual Type MakeByRefType();
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
    public virtual int GetArrayRank();
    public virtual Guid get_GUID();
    public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public virtual Module get_Module();
    public virtual Assembly get_Assembly();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public virtual string get_Name();
    public virtual string get_FullName();
    public virtual string get_AssemblyQualifiedName();
    public virtual string ToString();
    public virtual string get_Namespace();
    public virtual Type get_BaseType();
    protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public virtual Type GetInterface(string name, bool ignoreCase);
    public virtual Type[] GetInterfaces();
    public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents();
    protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    protected virtual bool IsArrayImpl();
    protected virtual bool IsPointerImpl();
    protected virtual bool IsByRefImpl();
    protected virtual bool IsPrimitiveImpl();
    protected virtual bool IsValueTypeImpl();
    protected virtual bool IsCOMObjectImpl();
    public virtual bool get_IsConstructedGenericType();
    public virtual Type GetElementType();
    protected virtual bool HasElementTypeImpl();
    public virtual Type get_UnderlyingSystemType();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
}
internal class System.Reflection.Emit.SymWrapperCore : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Reflection.Emit.TypeBuilder : TypeInfo {
    public static int UnspecifiedTypeSize;
    private List`1<CustAttr> m_ca;
    private TypeToken m_tdType;
    private ModuleBuilder m_module;
    private string m_strName;
    private string m_strNameSpace;
    private string m_strFullQualName;
    private Type m_typeParent;
    private List`1<Type> m_typeInterfaces;
    private TypeAttributes m_iAttr;
    private GenericParameterAttributes m_genParamAttributes;
    internal List`1<MethodBuilder> m_listMethods;
    internal int m_lastTokenizedMethod;
    private int m_constructorCount;
    private int m_iTypeSize;
    private PackingSize m_iPackingSize;
    private TypeBuilder m_DeclaringType;
    private Type m_enumUnderlyingType;
    internal bool m_isHiddenGlobalType;
    private bool m_hasBeenCreated;
    private RuntimeType m_bakedRuntimeType;
    private int m_genParamPos;
    private GenericTypeParameterBuilder[] m_inst;
    private bool m_bIsGenParam;
    private MethodBuilder m_declMeth;
    private TypeBuilder m_genTypeDef;
    internal object SyncRoot { get; }
    internal RuntimeType BakedRuntimeType { get; }
    [NullableAttribute("2")]
public Type DeclaringType { get; }
    [NullableAttribute("2")]
public Type ReflectedType { get; }
    public string Name { get; }
    public Module Module { get; }
    internal int MetadataTokenInternal { get; }
    public Guid GUID { get; }
    public Assembly Assembly { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    [NullableAttribute("2")]
public string FullName { get; }
    [NullableAttribute("2")]
public string Namespace { get; }
    [NullableAttribute("2")]
public string AssemblyQualifiedName { get; }
    [NullableAttribute("2")]
public Type BaseType { get; }
    public bool IsTypeDefinition { get; }
    public bool IsSZArray { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public Type UnderlyingSystemType { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsGenericType { get; }
    public bool IsGenericParameter { get; }
    public bool IsConstructedGenericType { get; }
    public int GenericParameterPosition { get; }
    [NullableAttribute("2")]
public MethodBase DeclaringMethod { get; }
    public int Size { get; }
    public PackingSize PackingSize { get; }
    public TypeToken TypeToken { get; }
    internal TypeBuilder(ModuleBuilder module);
    internal TypeBuilder(string szName, int genParamPos, MethodBuilder declMeth);
    private TypeBuilder(string szName, int genParamPos, TypeBuilder declType);
    internal TypeBuilder(string fullname, TypeAttributes attr, Type parent, Type[] interfaces, ModuleBuilder module, PackingSize iPackingSize, int iTypeSize, TypeBuilder enclosingType);
    [NullableContextAttribute("2")]
public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    public static MethodInfo GetMethod(Type type, MethodInfo method);
    public static ConstructorInfo GetConstructor(Type type, ConstructorInfo constructor);
    public static FieldInfo GetField(Type type, FieldInfo field);
    private static void SetParentType(QCallModule module, int tdTypeDef, int tkParent);
    private static void AddInterfaceImpl(QCallModule module, int tdTypeDef, int tkInterface);
    internal static int DefineMethod(QCallModule module, int tkParent, string name, Byte[] signature, int sigLength, MethodAttributes attributes);
    internal static int DefineMethodSpec(QCallModule module, int tkParent, Byte[] signature, int sigLength);
    internal static int DefineField(QCallModule module, int tkParent, string name, Byte[] signature, int sigLength, FieldAttributes attributes);
    private static void SetMethodIL(QCallModule module, int tk, bool isInitLocals, Byte[] body, int bodyLength, Byte[] LocalSig, int sigLength, int maxStackSize, ExceptionHandler[] exceptions, int numExceptions, Int32[] tokenFixups, int numTokenFixups);
    private static void DefineCustomAttribute(QCallModule module, int tkAssociate, int tkConstructor, Byte[] attr, int attrLength, bool toDisk, bool updateCompilerFlags);
    internal static void DefineCustomAttribute(ModuleBuilder module, int tkAssociate, int tkConstructor, Byte[] attr, bool toDisk, bool updateCompilerFlags);
    internal static int DefineProperty(QCallModule module, int tkParent, string name, PropertyAttributes attributes, Byte[] signature, int sigLength);
    internal static int DefineEvent(QCallModule module, int tkParent, string name, EventAttributes attributes, int tkEventType);
    internal static void DefineMethodSemantics(QCallModule module, int tkAssociation, MethodSemanticsAttributes semantics, int tkMethod);
    internal static void DefineMethodImpl(QCallModule module, int tkType, int tkBody, int tkDecl);
    internal static void SetMethodImpl(QCallModule module, int tkMethod, MethodImplAttributes MethodImplAttributes);
    internal static int SetParamInfo(QCallModule module, int tkMethod, int iSequence, ParameterAttributes iParamAttributes, string strParamName);
    internal static int GetTokenFromSig(QCallModule module, Byte[] signature, int sigLength);
    internal static void SetFieldLayoutOffset(QCallModule module, int fdToken, int iOffset);
    internal static void SetClassLayout(QCallModule module, int tk, PackingSize iPackingSize, int iTypeSize);
    private static void SetConstantValue(QCallModule module, int tk, int corType, Void* pValue);
    private static void SetPInvokeData(QCallModule module, string DllName, string name, int token, int linkFlags);
    internal static bool IsTypeEqual(Type t1, Type t2);
    internal static void SetConstantValue(ModuleBuilder module, int tk, Type destType, object value);
    private void InitAsGenericParam(string szName, int genParamPos);
    private FieldBuilder DefineDataHelper(string name, Byte[] data, int size, FieldAttributes attributes);
    private void VerifyTypeAttributes(TypeAttributes attr);
    public bool IsCreated();
    private static int DefineType(QCallModule module, string fullname, int tkParent, TypeAttributes attributes, int tkEnclosingType, Int32[] interfaceTokens);
    private static int DefineGenericParam(QCallModule module, string name, int tkParent, GenericParameterAttributes attributes, int position, Int32[] constraints);
    private static void TermCreateClass(QCallModule module, int tk, ObjectHandleOnStack type);
    internal void ThrowIfCreated();
    internal object get_SyncRoot();
    internal ModuleBuilder GetModuleBuilder();
    internal RuntimeType get_BakedRuntimeType();
    internal void SetGenParamAttributes(GenericParameterAttributes genericParameterAttributes);
    internal void SetGenParamCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    internal void SetGenParamCustomAttribute(CustomAttributeBuilder customBuilder);
    private void SetGenParamCustomAttributeNoLock(CustAttr ca);
    public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual Type get_DeclaringType();
    [NullableContextAttribute("2")]
public virtual Type get_ReflectedType();
    public virtual string get_Name();
    public virtual Module get_Module();
    internal int get_MetadataTokenInternal();
    public virtual Guid get_GUID();
    [NullableContextAttribute("2")]
public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public virtual Assembly get_Assembly();
    public virtual RuntimeTypeHandle get_TypeHandle();
    [NullableContextAttribute("2")]
public virtual string get_FullName();
    [NullableContextAttribute("2")]
public virtual string get_Namespace();
    [NullableContextAttribute("2")]
public virtual string get_AssemblyQualifiedName();
    [NullableContextAttribute("2")]
public virtual Type get_BaseType();
    [NullableContextAttribute("2")]
protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    [NullableContextAttribute("2")]
protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public virtual Type GetInterface(string name, bool ignoreCase);
    public virtual Type[] GetInterfaces();
    public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents();
    [NullableContextAttribute("2")]
protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    [NullableContextAttribute("2")]
public virtual bool IsAssignableFrom(Type c);
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    public virtual bool get_IsTypeDefinition();
    public virtual bool get_IsSZArray();
    protected virtual bool IsArrayImpl();
    protected virtual bool IsByRefImpl();
    protected virtual bool IsPointerImpl();
    protected virtual bool IsPrimitiveImpl();
    protected virtual bool IsCOMObjectImpl();
    public virtual Type GetElementType();
    protected virtual bool HasElementTypeImpl();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    public virtual bool IsSubclassOf(Type c);
    public virtual Type get_UnderlyingSystemType();
    public virtual Type MakePointerType();
    public virtual Type MakeByRefType();
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual GenericParameterAttributes get_GenericParameterAttributes();
    internal void SetInterfaces(Type[] interfaces);
    public GenericTypeParameterBuilder[] DefineGenericParameters(String[] names);
    public virtual Type MakeGenericType(Type[] typeArguments);
    public virtual Type[] GetGenericArguments();
    public virtual bool get_IsGenericTypeDefinition();
    public virtual bool get_IsGenericType();
    public virtual bool get_IsGenericParameter();
    public virtual bool get_IsConstructedGenericType();
    public virtual int get_GenericParameterPosition();
    [NullableContextAttribute("2")]
public virtual MethodBase get_DeclaringMethod();
    public virtual Type GetGenericTypeDefinition();
    public void DefineMethodOverride(MethodInfo methodInfoBody, MethodInfo methodInfoDeclaration);
    private void DefineMethodOverrideNoLock(MethodInfo methodInfoBody, MethodInfo methodInfoDeclaration);
    public MethodBuilder DefineMethod(string name, MethodAttributes attributes, Type returnType, Type[] parameterTypes);
    public MethodBuilder DefineMethod(string name, MethodAttributes attributes);
    public MethodBuilder DefineMethod(string name, MethodAttributes attributes, CallingConventions callingConvention);
    public MethodBuilder DefineMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    public MethodBuilder DefineMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
    private MethodBuilder DefineMethodNoLock(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
    public MethodBuilder DefinePInvokeMethod(string name, string dllName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, CallingConvention nativeCallConv, CharSet nativeCharSet);
    public MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, CallingConvention nativeCallConv, CharSet nativeCharSet);
    public MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers, CallingConvention nativeCallConv, CharSet nativeCharSet);
    private MethodBuilder DefinePInvokeMethodHelper(string name, string dllName, string importName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers, CallingConvention nativeCallConv, CharSet nativeCharSet);
    public ConstructorBuilder DefineTypeInitializer();
    private ConstructorBuilder DefineTypeInitializerNoLock();
    public ConstructorBuilder DefineDefaultConstructor(MethodAttributes attributes);
    private ConstructorBuilder DefineDefaultConstructorNoLock(MethodAttributes attributes);
    public ConstructorBuilder DefineConstructor(MethodAttributes attributes, CallingConventions callingConvention, Type[] parameterTypes);
    public ConstructorBuilder DefineConstructor(MethodAttributes attributes, CallingConventions callingConvention, Type[] parameterTypes, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers);
    private ConstructorBuilder DefineConstructorNoLock(MethodAttributes attributes, CallingConventions callingConvention, Type[] parameterTypes, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers);
    public TypeBuilder DefineNestedType(string name);
    public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, Type[] interfaces);
    public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent);
    public TypeBuilder DefineNestedType(string name, TypeAttributes attr);
    public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, int typeSize);
    public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, PackingSize packSize);
    public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, PackingSize packSize, int typeSize);
    private TypeBuilder DefineNestedTypeNoLock(string name, TypeAttributes attr, Type parent, Type[] interfaces, PackingSize packSize, int typeSize);
    public FieldBuilder DefineField(string fieldName, Type type, FieldAttributes attributes);
    public FieldBuilder DefineField(string fieldName, Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers, FieldAttributes attributes);
    private FieldBuilder DefineFieldNoLock(string fieldName, Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers, FieldAttributes attributes);
    public FieldBuilder DefineInitializedData(string name, Byte[] data, FieldAttributes attributes);
    private FieldBuilder DefineInitializedDataNoLock(string name, Byte[] data, FieldAttributes attributes);
    public FieldBuilder DefineUninitializedData(string name, int size, FieldAttributes attributes);
    private FieldBuilder DefineUninitializedDataNoLock(string name, int size, FieldAttributes attributes);
    public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, Type returnType, Type[] parameterTypes);
    public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
    public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
    private PropertyBuilder DefinePropertyNoLock(string name, PropertyAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
    public EventBuilder DefineEvent(string name, EventAttributes attributes, Type eventtype);
    private EventBuilder DefineEventNoLock(string name, EventAttributes attributes, Type eventtype);
    [NullableContextAttribute("2")]
public TypeInfo CreateTypeInfo();
    [NullableContextAttribute("2")]
public Type CreateType();
    internal void CheckContext(Type[][] typess);
    internal void CheckContext(Type[] types);
    private TypeInfo CreateTypeNoLock();
    public int get_Size();
    public PackingSize get_PackingSize();
    [NullableContextAttribute("2")]
public void SetParent(Type parent);
    public void AddInterfaceImplementation(Type interfaceType);
    public TypeToken get_TypeToken();
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
}
internal class System.Reflection.Emit.TypeBuilderInstantiation : TypeInfo {
    private Type m_type;
    private Type[] m_inst;
    private string m_strFullQualName;
    internal Hashtable m_hashtable;
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public string Name { get; }
    public Module Module { get; }
    public Guid GUID { get; }
    public Assembly Assembly { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public string FullName { get; }
    public string Namespace { get; }
    public string AssemblyQualifiedName { get; }
    public Type BaseType { get; }
    public bool IsTypeDefinition { get; }
    public bool IsSZArray { get; }
    public Type UnderlyingSystemType { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsGenericType { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsGenericParameter { get; }
    public int GenericParameterPosition { get; }
    public bool ContainsGenericParameters { get; }
    public MethodBase DeclaringMethod { get; }
    private TypeBuilderInstantiation(Type type, Type[] inst);
    public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    internal static Type MakeGenericType(Type type, Type[] typeArguments);
    public virtual string ToString();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual string get_Name();
    public virtual Module get_Module();
    public virtual Type MakePointerType();
    public virtual Type MakeByRefType();
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
    public virtual Guid get_GUID();
    public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public virtual Assembly get_Assembly();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public virtual string get_FullName();
    public virtual string get_Namespace();
    public virtual string get_AssemblyQualifiedName();
    private Type Substitute(Type[] substitutes);
    public virtual Type get_BaseType();
    protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public virtual Type GetInterface(string name, bool ignoreCase);
    public virtual Type[] GetInterfaces();
    public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents();
    protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    public virtual bool get_IsTypeDefinition();
    public virtual bool get_IsSZArray();
    protected virtual bool IsArrayImpl();
    protected virtual bool IsByRefImpl();
    protected virtual bool IsPointerImpl();
    protected virtual bool IsPrimitiveImpl();
    protected virtual bool IsCOMObjectImpl();
    public virtual Type GetElementType();
    protected virtual bool HasElementTypeImpl();
    public virtual Type get_UnderlyingSystemType();
    public virtual Type[] GetGenericArguments();
    public virtual bool get_IsGenericTypeDefinition();
    public virtual bool get_IsGenericType();
    public virtual bool get_IsConstructedGenericType();
    public virtual bool get_IsGenericParameter();
    public virtual int get_GenericParameterPosition();
    protected virtual bool IsValueTypeImpl();
    public virtual bool get_ContainsGenericParameters();
    public virtual MethodBase get_DeclaringMethod();
    public virtual Type GetGenericTypeDefinition();
    public virtual Type MakeGenericType(Type[] inst);
    public virtual bool IsAssignableFrom(Type c);
    public virtual bool IsSubclassOf(Type c);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
}
internal enum System.Reflection.Emit.TypeKind : Enum {
    public int value__;
    public static TypeKind IsArray;
    public static TypeKind IsPointer;
    public static TypeKind IsByRef;
}
internal class System.Reflection.Emit.TypeNameBuilder : object {
    private IntPtr m_typeNameBuilder;
    private TypeNameBuilder(IntPtr typeNameBuilder);
    private static IntPtr CreateTypeNameBuilder();
    private static void ReleaseTypeNameBuilder(IntPtr pAQN);
    private static void OpenGenericArguments(IntPtr tnb);
    private static void CloseGenericArguments(IntPtr tnb);
    private static void OpenGenericArgument(IntPtr tnb);
    private static void CloseGenericArgument(IntPtr tnb);
    private static void AddName(IntPtr tnb, string name);
    private static void AddPointer(IntPtr tnb);
    private static void AddByRef(IntPtr tnb);
    private static void AddSzArray(IntPtr tnb);
    private static void AddArray(IntPtr tnb, int rank);
    private static void AddAssemblySpec(IntPtr tnb, string assemblySpec);
    private static void ToString(IntPtr tnb, StringHandleOnStack retString);
    private static void Clear(IntPtr tnb);
    internal static string ToString(Type type, Format format);
    internal void Dispose();
    private void AddElementType(Type elementType);
    private void ConstructAssemblyQualifiedNameWorker(Type type, Format format);
    private void OpenGenericArguments();
    private void CloseGenericArguments();
    private void OpenGenericArgument();
    private void CloseGenericArgument();
    private void AddName(string name);
    private void AddPointer();
    private void AddByRef();
    private void AddSzArray();
    private void AddArray(int rank);
    private void AddAssemblySpec(string assemblySpec);
    public virtual string ToString();
    private void Clear();
}
public class System.Reflection.Emit.TypeToken : ValueType {
    public static TypeToken Empty;
    [CompilerGeneratedAttribute]
private int <Token>k__BackingField;
    public int Token { get; }
    internal TypeToken(int typeToken);
    private static TypeToken();
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public int get_Token();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public bool Equals(TypeToken obj);
    public static bool op_Equality(TypeToken a, TypeToken b);
    public static bool op_Inequality(TypeToken a, TypeToken b);
}
internal class System.Reflection.Emit.VarArgMethod : object {
    internal RuntimeMethodInfo m_method;
    internal DynamicMethod m_dynamicMethod;
    internal SignatureHelper m_signature;
    internal VarArgMethod(DynamicMethod dm, SignatureHelper signature);
    internal VarArgMethod(RuntimeMethodInfo method, SignatureHelper signature);
}
[FlagsAttribute]
public enum System.Reflection.EventAttributes : Enum {
    public int value__;
    public static EventAttributes None;
    public static EventAttributes SpecialName;
    public static EventAttributes RTSpecialName;
    public static EventAttributes ReservedMask;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class System.Reflection.EventInfo : MemberInfo {
    public MemberTypes MemberType { get; }
    public EventAttributes Attributes { get; }
    public bool IsSpecialName { get; }
    public MethodInfo AddMethod { get; }
    public MethodInfo RemoveMethod { get; }
    public MethodInfo RaiseMethod { get; }
    public bool IsMulticast { get; }
    public Type EventHandlerType { get; }
    public virtual MemberTypes get_MemberType();
    public abstract virtual EventAttributes get_Attributes();
    public bool get_IsSpecialName();
    [NullableContextAttribute("1")]
public MethodInfo[] GetOtherMethods();
    [NullableContextAttribute("1")]
public virtual MethodInfo[] GetOtherMethods(bool nonPublic);
    public virtual MethodInfo get_AddMethod();
    public virtual MethodInfo get_RemoveMethod();
    public virtual MethodInfo get_RaiseMethod();
    public MethodInfo GetAddMethod();
    public MethodInfo GetRemoveMethod();
    public MethodInfo GetRaiseMethod();
    public abstract virtual MethodInfo GetAddMethod(bool nonPublic);
    public abstract virtual MethodInfo GetRemoveMethod(bool nonPublic);
    public abstract virtual MethodInfo GetRaiseMethod(bool nonPublic);
    public virtual bool get_IsMulticast();
    public virtual Type get_EventHandlerType();
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public virtual void AddEventHandler(object target, Delegate handler);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public virtual void RemoveEventHandler(object target, Delegate handler);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(EventInfo left, EventInfo right);
    public static bool op_Inequality(EventInfo left, EventInfo right);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Reflection.ExceptionHandlingClause : object {
    public ExceptionHandlingClauseOptions Flags { get; }
    public int TryOffset { get; }
    public int TryLength { get; }
    public int HandlerOffset { get; }
    public int HandlerLength { get; }
    public int FilterOffset { get; }
    public Type CatchType { get; }
    public virtual ExceptionHandlingClauseOptions get_Flags();
    public virtual int get_TryOffset();
    public virtual int get_TryLength();
    public virtual int get_HandlerOffset();
    public virtual int get_HandlerLength();
    public virtual int get_FilterOffset();
    public virtual Type get_CatchType();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[FlagsAttribute]
public enum System.Reflection.ExceptionHandlingClauseOptions : Enum {
    public int value__;
    public static ExceptionHandlingClauseOptions Clause;
    public static ExceptionHandlingClauseOptions Filter;
    public static ExceptionHandlingClauseOptions Finally;
    public static ExceptionHandlingClauseOptions Fault;
}
[FlagsAttribute]
public enum System.Reflection.FieldAttributes : Enum {
    public int value__;
    public static FieldAttributes FieldAccessMask;
    public static FieldAttributes PrivateScope;
    public static FieldAttributes Private;
    public static FieldAttributes FamANDAssem;
    public static FieldAttributes Assembly;
    public static FieldAttributes Family;
    public static FieldAttributes FamORAssem;
    public static FieldAttributes Public;
    public static FieldAttributes Static;
    public static FieldAttributes InitOnly;
    public static FieldAttributes Literal;
    public static FieldAttributes NotSerialized;
    public static FieldAttributes SpecialName;
    public static FieldAttributes PinvokeImpl;
    public static FieldAttributes RTSpecialName;
    public static FieldAttributes HasFieldMarshal;
    public static FieldAttributes HasDefault;
    public static FieldAttributes HasFieldRVA;
    public static FieldAttributes ReservedMask;
}
[NullableAttribute("0")]
[NullableContextAttribute("2")]
public abstract class System.Reflection.FieldInfo : MemberInfo {
    public MemberTypes MemberType { get; }
    public FieldAttributes Attributes { get; }
    [NullableAttribute("1")]
public Type FieldType { get; }
    public bool IsInitOnly { get; }
    public bool IsLiteral { get; }
    public bool IsNotSerialized { get; }
    public bool IsPinvokeImpl { get; }
    public bool IsSpecialName { get; }
    public bool IsStatic { get; }
    public bool IsAssembly { get; }
    public bool IsFamily { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsPrivate { get; }
    public bool IsPublic { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public RuntimeFieldHandle FieldHandle { get; }
    [NullableContextAttribute("1")]
public static FieldInfo GetFieldFromHandle(RuntimeFieldHandle handle);
    [NullableContextAttribute("1")]
public static FieldInfo GetFieldFromHandle(RuntimeFieldHandle handle, RuntimeTypeHandle declaringType);
    public virtual MemberTypes get_MemberType();
    public abstract virtual FieldAttributes get_Attributes();
    [NullableContextAttribute("1")]
public abstract virtual Type get_FieldType();
    public bool get_IsInitOnly();
    public bool get_IsLiteral();
    public bool get_IsNotSerialized();
    public bool get_IsPinvokeImpl();
    public bool get_IsSpecialName();
    public bool get_IsStatic();
    public bool get_IsAssembly();
    public bool get_IsFamily();
    public bool get_IsFamilyAndAssembly();
    public bool get_IsFamilyOrAssembly();
    public bool get_IsPrivate();
    public bool get_IsPublic();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    public abstract virtual RuntimeFieldHandle get_FieldHandle();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(FieldInfo left, FieldInfo right);
    public static bool op_Inequality(FieldInfo left, FieldInfo right);
    public abstract virtual object GetValue(object obj);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public void SetValue(object obj, object value);
    public abstract virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public virtual void SetValueDirect(TypedReference obj, object value);
    [CLSCompliantAttribute("False")]
public virtual object GetValueDirect(TypedReference obj);
    public virtual object GetRawConstantValue();
    [NullableContextAttribute("1")]
public virtual Type[] GetOptionalCustomModifiers();
    [NullableContextAttribute("1")]
public virtual Type[] GetRequiredCustomModifiers();
}
[FlagsAttribute]
public enum System.Reflection.GenericParameterAttributes : Enum {
    public int value__;
    public static GenericParameterAttributes None;
    public static GenericParameterAttributes VarianceMask;
    public static GenericParameterAttributes Covariant;
    public static GenericParameterAttributes Contravariant;
    public static GenericParameterAttributes SpecialConstraintMask;
    public static GenericParameterAttributes ReferenceTypeConstraint;
    public static GenericParameterAttributes NotNullableValueTypeConstraint;
    public static GenericParameterAttributes DefaultConstructorConstraint;
}
[NullableContextAttribute("1")]
public interface System.Reflection.ICustomAttributeProvider {
    public abstract virtual Object[] GetCustomAttributes(bool inherit);
    public abstract virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public abstract virtual bool IsDefined(Type attributeType, bool inherit);
}
public enum System.Reflection.ImageFileMachine : Enum {
    public int value__;
    public static ImageFileMachine I386;
    public static ImageFileMachine IA64;
    public static ImageFileMachine AMD64;
    public static ImageFileMachine ARM;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Reflection.InterfaceMapping : ValueType {
    public Type TargetType;
    public Type InterfaceType;
    public MethodInfo[] TargetMethods;
    public MethodInfo[] InterfaceMethods;
}
[ExtensionAttribute]
public static class System.Reflection.IntrospectionExtensions : object {
    [ExtensionAttribute]
[NullableContextAttribute("1")]
public static TypeInfo GetTypeInfo(Type type);
}
[NullableContextAttribute("2")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableAttribute("0")]
public class System.Reflection.InvalidFilterCriteriaException : ApplicationException {
    public InvalidFilterCriteriaException(string message);
    public InvalidFilterCriteriaException(string message, Exception inner);
    [NullableContextAttribute("1")]
protected InvalidFilterCriteriaException(SerializationInfo info, StreamingContext context);
}
[FlagsAttribute]
internal enum System.Reflection.INVOCATION_FLAGS : Enum {
    public UInt32 value__;
    public static INVOCATION_FLAGS INVOCATION_FLAGS_UNKNOWN;
    public static INVOCATION_FLAGS INVOCATION_FLAGS_INITIALIZED;
    public static INVOCATION_FLAGS INVOCATION_FLAGS_NO_INVOKE;
    public static INVOCATION_FLAGS INVOCATION_FLAGS_NO_CTOR_INVOKE;
    public static INVOCATION_FLAGS INVOCATION_FLAGS_IS_CTOR;
    public static INVOCATION_FLAGS INVOCATION_FLAGS_IS_DELEGATE_CTOR;
    public static INVOCATION_FLAGS INVOCATION_FLAGS_CONTAINS_STACK_POINTERS;
    public static INVOCATION_FLAGS INVOCATION_FLAGS_SPECIAL_FIELD;
    public static INVOCATION_FLAGS INVOCATION_FLAGS_FIELD_SPECIAL_CAST;
    public static INVOCATION_FLAGS INVOCATION_FLAGS_CONSTRUCTOR_INVOKE;
}
[NullableContextAttribute("1")]
public interface System.Reflection.IReflect {
    public Type UnderlyingSystemType { get; }
    [NullableContextAttribute("2")]
public abstract virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
    public abstract virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr);
    public abstract virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public abstract virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public abstract virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public abstract virtual PropertyInfo GetProperty(string name, BindingFlags bindingAttr);
    [NullableContextAttribute("2")]
public abstract virtual PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public abstract virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public abstract virtual MemberInfo[] GetMember(string name, BindingFlags bindingAttr);
    public abstract virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    [NullableContextAttribute("2")]
public abstract virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public abstract virtual Type get_UnderlyingSystemType();
}
[NullableContextAttribute("1")]
public interface System.Reflection.IReflectableType {
    public abstract virtual TypeInfo GetTypeInfo();
}
internal class System.Reflection.LoaderAllocator : object {
    private LoaderAllocatorScout m_scout;
    private Object[] m_slots;
    internal CerHashtable`2<RuntimeMethodInfo, RuntimeMethodInfo> m_methodInstantiations;
    private int m_slotsUsed;
}
internal class System.Reflection.LoaderAllocatorScout : object {
    internal IntPtr m_nativeLoaderAllocator;
    private static bool Destroy(IntPtr nativeLoaderAllocator);
    protected virtual override void Finalize();
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Reflection.LocalVariableInfo : object {
    public Type LocalType { get; }
    public int LocalIndex { get; }
    public bool IsPinned { get; }
    public virtual Type get_LocalType();
    public virtual int get_LocalIndex();
    public virtual bool get_IsPinned();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Reflection.ManifestResourceInfo : object {
    [CompilerGeneratedAttribute]
private Assembly <ReferencedAssembly>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private ResourceLocation <ResourceLocation>k__BackingField;
    public Assembly ReferencedAssembly { get; }
    public string FileName { get; }
    public ResourceLocation ResourceLocation { get; }
    public ManifestResourceInfo(Assembly containingAssembly, string containingFileName, ResourceLocation resourceLocation);
    [CompilerGeneratedAttribute]
public virtual Assembly get_ReferencedAssembly();
    [CompilerGeneratedAttribute]
public virtual string get_FileName();
    [CompilerGeneratedAttribute]
public virtual ResourceLocation get_ResourceLocation();
}
internal static class System.Reflection.MdConstant : object {
    public static object GetValue(MetadataImport scope, int token, RuntimeTypeHandle fieldTypeHandle, bool raw);
}
internal class System.Reflection.MdFieldInfo : RuntimeFieldInfo {
    private int m_tkField;
    private string m_name;
    private RuntimeType m_fieldType;
    private FieldAttributes m_fieldAttributes;
    public string Name { get; }
    public int MetadataToken { get; }
    public RuntimeFieldHandle FieldHandle { get; }
    public FieldAttributes Attributes { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public Type FieldType { get; }
    internal MdFieldInfo(int tkField, FieldAttributes fieldAttributes, RuntimeTypeHandle declaringTypeHandle, RuntimeTypeCache reflectedTypeCache, BindingFlags bindingFlags);
    internal virtual bool CacheEquals(object o);
    public virtual string get_Name();
    public virtual int get_MetadataToken();
    internal virtual RuntimeModule GetRuntimeModule();
    public virtual RuntimeFieldHandle get_FieldHandle();
    public virtual FieldAttributes get_Attributes();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public virtual object GetValueDirect(TypedReference obj);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public virtual void SetValueDirect(TypedReference obj, object value);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public virtual object GetValue(object obj);
    public virtual object GetRawConstantValue();
    private object GetValue(bool raw);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
    public virtual Type get_FieldType();
    public virtual Type[] GetRequiredCustomModifiers();
    public virtual Type[] GetOptionalCustomModifiers();
}
[FlagsAttribute]
internal enum System.Reflection.MdSigCallingConvention : Enum {
    public byte value__;
    public static MdSigCallingConvention CallConvMask;
    public static MdSigCallingConvention Default;
    public static MdSigCallingConvention C;
    public static MdSigCallingConvention StdCall;
    public static MdSigCallingConvention ThisCall;
    public static MdSigCallingConvention FastCall;
    public static MdSigCallingConvention Vararg;
    public static MdSigCallingConvention Field;
    public static MdSigCallingConvention LocalSig;
    public static MdSigCallingConvention Property;
    public static MdSigCallingConvention Unmgd;
    public static MdSigCallingConvention GenericInst;
    public static MdSigCallingConvention Generic;
    public static MdSigCallingConvention HasThis;
    public static MdSigCallingConvention ExplicitThis;
}
public class System.Reflection.MemberFilter : MulticastDelegate {
    public MemberFilter(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual bool Invoke(MemberInfo m, object filterCriteria);
    public virtual IAsyncResult BeginInvoke(MemberInfo m, object filterCriteria, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Reflection.MemberInfo : object {
    public MemberTypes MemberType { get; }
    public string Name { get; }
    [NullableAttribute("2")]
public Type DeclaringType { get; }
    [NullableAttribute("2")]
public Type ReflectedType { get; }
    public Module Module { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public bool IsCollectible { get; }
    public int MetadataToken { get; }
    internal virtual bool CacheEquals(object o);
    internal bool HasSameMetadataDefinitionAsCore(MemberInfo other);
    public abstract virtual MemberTypes get_MemberType();
    public abstract virtual string get_Name();
    [NullableContextAttribute("2")]
public abstract virtual Type get_DeclaringType();
    [NullableContextAttribute("2")]
public abstract virtual Type get_ReflectedType();
    public virtual Module get_Module();
    public virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public abstract virtual bool IsDefined(Type attributeType, bool inherit);
    public abstract virtual Object[] GetCustomAttributes(bool inherit);
    public abstract virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual bool get_IsCollectible();
    public virtual int get_MetadataToken();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public static bool op_Equality(MemberInfo left, MemberInfo right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(MemberInfo left, MemberInfo right);
}
[FlagsAttribute]
public enum System.Reflection.MemberTypes : Enum {
    public int value__;
    public static MemberTypes Constructor;
    public static MemberTypes Event;
    public static MemberTypes Field;
    public static MemberTypes Method;
    public static MemberTypes Property;
    public static MemberTypes TypeInfo;
    public static MemberTypes Custom;
    public static MemberTypes NestedType;
    public static MemberTypes All;
}
[ExtensionAttribute]
public static class System.Reflection.Metadata.AssemblyExtensions : object {
    private static bool InternalTryGetRawMetadata(QCallAssembly assembly, Byte*& blob, Int32& length);
    [CLSCompliantAttribute("False")]
[ExtensionAttribute]
public static bool TryGetRawMetadata(Assembly assembly, Byte*& blob, Int32& length);
}
[DefaultMemberAttribute("Item")]
internal class System.Reflection.MetadataEnumResult : ValueType {
    private Int32[] largeResult;
    private int length;
    [FixedBufferAttribute("System.Int32", "16")]
private <smallResult>e__FixedBuffer smallResult;
    public int Length { get; }
    public int Item { get; }
    public int get_Length();
    public int get_Item(int index);
}
internal class System.Reflection.MetadataException : Exception {
    private int m_hr;
    internal MetadataException(int hr);
    public virtual string ToString();
}
[IsReadOnlyAttribute]
internal class System.Reflection.MetadataImport : ValueType {
    private IntPtr m_metadataImport2;
    private object m_keepalive;
    internal static MetadataImport EmptyImport;
    internal MetadataImport(IntPtr metadataImport2, object keepalive);
    private static MetadataImport();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    private bool Equals(MetadataImport import);
    private static void _GetMarshalAs(IntPtr pNativeType, int cNativeType, Int32& unmanagedType, Int32& safeArraySubType, String& safeArrayUserDefinedSubType, Int32& arraySubType, Int32& sizeParamIndex, Int32& sizeConst, String& marshalType, String& marshalCookie, Int32& iidParamIndex);
    internal static void GetMarshalAs(ConstArray nativeType, UnmanagedType& unmanagedType, VarEnum& safeArraySubType, String& safeArrayUserDefinedSubType, UnmanagedType& arraySubType, Int32& sizeParamIndex, Int32& sizeConst, String& marshalType, String& marshalCookie, Int32& iidParamIndex);
    internal static void ThrowError(int hResult);
    private static void _Enum(IntPtr scope, int type, int parent, MetadataEnumResult& result);
    public void Enum(MetadataTokenType type, int parent, MetadataEnumResult& result);
    public void EnumNestedTypes(int mdTypeDef, MetadataEnumResult& result);
    public void EnumCustomAttributes(int mdToken, MetadataEnumResult& result);
    public void EnumParams(int mdMethodDef, MetadataEnumResult& result);
    public void EnumFields(int mdTypeDef, MetadataEnumResult& result);
    public void EnumProperties(int mdTypeDef, MetadataEnumResult& result);
    public void EnumEvents(int mdTypeDef, MetadataEnumResult& result);
    private static string _GetDefaultValue(IntPtr scope, int mdToken, Int64& value, Int32& length, Int32& corElementType);
    public string GetDefaultValue(int mdToken, Int64& value, Int32& length, CorElementType& corElementType);
    private static void _GetUserString(IntPtr scope, int mdToken, Void** name, Int32& length);
    public string GetUserString(int mdToken);
    private static void _GetName(IntPtr scope, int mdToken, Void** name);
    public MdUtf8String GetName(int mdToken);
    private static void _GetNamespace(IntPtr scope, int mdToken, Void** namesp);
    public MdUtf8String GetNamespace(int mdToken);
    private static void _GetEventProps(IntPtr scope, int mdToken, Void** name, Int32& eventAttributes);
    public void GetEventProps(int mdToken, Void*& name, EventAttributes& eventAttributes);
    private static void _GetFieldDefProps(IntPtr scope, int mdToken, Int32& fieldAttributes);
    public void GetFieldDefProps(int mdToken, FieldAttributes& fieldAttributes);
    private static void _GetPropertyProps(IntPtr scope, int mdToken, Void** name, Int32& propertyAttributes, ConstArray& signature);
    public void GetPropertyProps(int mdToken, Void*& name, PropertyAttributes& propertyAttributes, ConstArray& signature);
    private static void _GetParentToken(IntPtr scope, int mdToken, Int32& tkParent);
    public int GetParentToken(int tkToken);
    private static void _GetParamDefProps(IntPtr scope, int parameterToken, Int32& sequence, Int32& attributes);
    public void GetParamDefProps(int parameterToken, Int32& sequence, ParameterAttributes& attributes);
    private static void _GetGenericParamProps(IntPtr scope, int genericParameter, Int32& flags);
    public void GetGenericParamProps(int genericParameter, GenericParameterAttributes& attributes);
    private static void _GetScopeProps(IntPtr scope, Guid& mvid);
    public void GetScopeProps(Guid& mvid);
    public ConstArray GetMethodSignature(MetadataToken token);
    private static void _GetSigOfMethodDef(IntPtr scope, int methodToken, ConstArray& signature);
    public ConstArray GetSigOfMethodDef(int methodToken);
    private static void _GetSignatureFromToken(IntPtr scope, int methodToken, ConstArray& signature);
    public ConstArray GetSignatureFromToken(int token);
    private static void _GetMemberRefProps(IntPtr scope, int memberTokenRef, ConstArray& signature);
    public ConstArray GetMemberRefProps(int memberTokenRef);
    private static void _GetCustomAttributeProps(IntPtr scope, int customAttributeToken, Int32& constructorToken, ConstArray& signature);
    public void GetCustomAttributeProps(int customAttributeToken, Int32& constructorToken, ConstArray& signature);
    private static void _GetClassLayout(IntPtr scope, int typeTokenDef, Int32& packSize, Int32& classSize);
    public void GetClassLayout(int typeTokenDef, Int32& packSize, Int32& classSize);
    private static bool _GetFieldOffset(IntPtr scope, int typeTokenDef, int fieldTokenDef, Int32& offset);
    public bool GetFieldOffset(int typeTokenDef, int fieldTokenDef, Int32& offset);
    private static void _GetSigOfFieldDef(IntPtr scope, int fieldToken, ConstArray& fieldMarshal);
    public ConstArray GetSigOfFieldDef(int fieldToken);
    private static void _GetFieldMarshal(IntPtr scope, int fieldToken, ConstArray& fieldMarshal);
    public ConstArray GetFieldMarshal(int fieldToken);
    private static void _GetPInvokeMap(IntPtr scope, int token, Int32& attributes, Void** importName, Void** importDll);
    public void GetPInvokeMap(int token, PInvokeAttributes& attributes, String& importName, String& importDll);
    private static bool _IsValidToken(IntPtr scope, int token);
    public bool IsValidToken(int token);
}
internal class System.Reflection.MetadataToken : ValueType {
    public int Value;
    public bool IsGlobalTypeDefToken { get; }
    public MetadataTokenType TokenType { get; }
    public bool IsTypeRef { get; }
    public bool IsTypeDef { get; }
    public bool IsFieldDef { get; }
    public bool IsMethodDef { get; }
    public bool IsMemberRef { get; }
    public bool IsEvent { get; }
    public bool IsProperty { get; }
    public bool IsParamDef { get; }
    public bool IsTypeSpec { get; }
    public bool IsMethodSpec { get; }
    public bool IsString { get; }
    public bool IsSignature { get; }
    public bool IsGenericPar { get; }
    public MetadataToken(int token);
    public static int op_Implicit(MetadataToken token);
    public static MetadataToken op_Implicit(int token);
    public static bool IsNullToken(int token);
    public bool get_IsGlobalTypeDefToken();
    public MetadataTokenType get_TokenType();
    public bool get_IsTypeRef();
    public bool get_IsTypeDef();
    public bool get_IsFieldDef();
    public bool get_IsMethodDef();
    public bool get_IsMemberRef();
    public bool get_IsEvent();
    public bool get_IsProperty();
    public bool get_IsParamDef();
    public bool get_IsTypeSpec();
    public bool get_IsMethodSpec();
    public bool get_IsString();
    public bool get_IsSignature();
    public bool get_IsGenericPar();
    public virtual string ToString();
}
internal enum System.Reflection.MetadataTokenType : Enum {
    public int value__;
    public static MetadataTokenType Module;
    public static MetadataTokenType TypeRef;
    public static MetadataTokenType TypeDef;
    public static MetadataTokenType FieldDef;
    public static MetadataTokenType MethodDef;
    public static MetadataTokenType ParamDef;
    public static MetadataTokenType InterfaceImpl;
    public static MetadataTokenType MemberRef;
    public static MetadataTokenType CustomAttribute;
    public static MetadataTokenType Permission;
    public static MetadataTokenType Signature;
    public static MetadataTokenType Event;
    public static MetadataTokenType Property;
    public static MetadataTokenType ModuleRef;
    public static MetadataTokenType TypeSpec;
    public static MetadataTokenType Assembly;
    public static MetadataTokenType AssemblyRef;
    public static MetadataTokenType File;
    public static MetadataTokenType ExportedType;
    public static MetadataTokenType ManifestResource;
    public static MetadataTokenType GenericPar;
    public static MetadataTokenType MethodSpec;
    public static MetadataTokenType String;
    public static MetadataTokenType Name;
    public static MetadataTokenType BaseType;
    public static MetadataTokenType Invalid;
}
[FlagsAttribute]
public enum System.Reflection.MethodAttributes : Enum {
    public int value__;
    public static MethodAttributes MemberAccessMask;
    public static MethodAttributes PrivateScope;
    public static MethodAttributes Private;
    public static MethodAttributes FamANDAssem;
    public static MethodAttributes Assembly;
    public static MethodAttributes Family;
    public static MethodAttributes FamORAssem;
    public static MethodAttributes Public;
    public static MethodAttributes Static;
    public static MethodAttributes Final;
    public static MethodAttributes Virtual;
    public static MethodAttributes HideBySig;
    public static MethodAttributes CheckAccessOnOverride;
    public static MethodAttributes VtableLayoutMask;
    public static MethodAttributes ReuseSlot;
    public static MethodAttributes NewSlot;
    public static MethodAttributes Abstract;
    public static MethodAttributes SpecialName;
    public static MethodAttributes PinvokeImpl;
    public static MethodAttributes UnmanagedExport;
    public static MethodAttributes RTSpecialName;
    public static MethodAttributes HasSecurity;
    public static MethodAttributes RequireSecObject;
    public static MethodAttributes ReservedMask;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class System.Reflection.MethodBase : MemberInfo {
    public MethodAttributes Attributes { get; }
    public MethodImplAttributes MethodImplementationFlags { get; }
    public CallingConventions CallingConvention { get; }
    public bool IsAbstract { get; }
    public bool IsConstructor { get; }
    public bool IsFinal { get; }
    public bool IsHideBySig { get; }
    public bool IsSpecialName { get; }
    public bool IsStatic { get; }
    public bool IsVirtual { get; }
    public bool IsAssembly { get; }
    public bool IsFamily { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsPrivate { get; }
    public bool IsPublic { get; }
    public bool IsConstructedGenericMethod { get; }
    public bool IsGenericMethod { get; }
    public bool IsGenericMethodDefinition { get; }
    public bool ContainsGenericParameters { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public static MethodBase GetMethodFromHandle(RuntimeMethodHandle handle);
    public static MethodBase GetMethodFromHandle(RuntimeMethodHandle handle, RuntimeTypeHandle declaringType);
    public static MethodBase GetCurrentMethod();
    private IntPtr GetMethodDesc();
    internal virtual ParameterInfo[] GetParametersNoCopy();
    internal static void AppendParameters(ValueStringBuilder& sbParamList, Type[] parameterTypes, CallingConventions callingConvention);
    internal virtual Type[] GetParameterTypes();
    internal Object[] CheckArguments(Object[] parameters, Binder binder, BindingFlags invokeAttr, CultureInfo culture, Signature sig);
    [NullableContextAttribute("1")]
public abstract virtual ParameterInfo[] GetParameters();
    public abstract virtual MethodAttributes get_Attributes();
    public virtual MethodImplAttributes get_MethodImplementationFlags();
    public abstract virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual MethodBody GetMethodBody();
    public virtual CallingConventions get_CallingConvention();
    public bool get_IsAbstract();
    public bool get_IsConstructor();
    public bool get_IsFinal();
    public bool get_IsHideBySig();
    public bool get_IsSpecialName();
    public bool get_IsStatic();
    public bool get_IsVirtual();
    public bool get_IsAssembly();
    public bool get_IsFamily();
    public bool get_IsFamilyAndAssembly();
    public bool get_IsFamilyOrAssembly();
    public bool get_IsPrivate();
    public bool get_IsPublic();
    public virtual bool get_IsConstructedGenericMethod();
    public virtual bool get_IsGenericMethod();
    public virtual bool get_IsGenericMethodDefinition();
    [NullableContextAttribute("1")]
public virtual Type[] GetGenericArguments();
    public virtual bool get_ContainsGenericParameters();
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public object Invoke(object obj, Object[] parameters);
    public abstract virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public abstract virtual RuntimeMethodHandle get_MethodHandle();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(MethodBase left, MethodBase right);
    public static bool op_Inequality(MethodBase left, MethodBase right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Reflection.MethodBody : object {
    public int LocalSignatureMetadataToken { get; }
    public IList`1<LocalVariableInfo> LocalVariables { get; }
    public int MaxStackSize { get; }
    public bool InitLocals { get; }
    public IList`1<ExceptionHandlingClause> ExceptionHandlingClauses { get; }
    public virtual int get_LocalSignatureMetadataToken();
    public virtual IList`1<LocalVariableInfo> get_LocalVariables();
    public virtual int get_MaxStackSize();
    public virtual bool get_InitLocals();
    [NullableContextAttribute("2")]
public virtual Byte[] GetILAsByteArray();
    public virtual IList`1<ExceptionHandlingClause> get_ExceptionHandlingClauses();
}
public enum System.Reflection.MethodImplAttributes : Enum {
    public int value__;
    public static MethodImplAttributes CodeTypeMask;
    public static MethodImplAttributes IL;
    public static MethodImplAttributes Native;
    public static MethodImplAttributes OPTIL;
    public static MethodImplAttributes Runtime;
    public static MethodImplAttributes ManagedMask;
    public static MethodImplAttributes Unmanaged;
    public static MethodImplAttributes Managed;
    public static MethodImplAttributes ForwardRef;
    public static MethodImplAttributes PreserveSig;
    public static MethodImplAttributes InternalCall;
    public static MethodImplAttributes Synchronized;
    public static MethodImplAttributes NoInlining;
    public static MethodImplAttributes AggressiveInlining;
    public static MethodImplAttributes NoOptimization;
    public static MethodImplAttributes AggressiveOptimization;
    public static MethodImplAttributes MaxMethodImplVal;
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public abstract class System.Reflection.MethodInfo : MethodBase {
    public MemberTypes MemberType { get; }
    public ParameterInfo ReturnParameter { get; }
    public Type ReturnType { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    internal int GenericParameterCount { get; }
    public virtual MemberTypes get_MemberType();
    public virtual ParameterInfo get_ReturnParameter();
    public virtual Type get_ReturnType();
    public virtual Type[] GetGenericArguments();
    public virtual MethodInfo GetGenericMethodDefinition();
    public virtual MethodInfo MakeGenericMethod(Type[] typeArguments);
    public abstract virtual MethodInfo GetBaseDefinition();
    public abstract virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public virtual Delegate CreateDelegate(Type delegateType);
    public virtual Delegate CreateDelegate(Type delegateType, object target);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public static bool op_Equality(MethodInfo left, MethodInfo right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(MethodInfo left, MethodInfo right);
    internal virtual int get_GenericParameterCount();
}
[FlagsAttribute]
internal enum System.Reflection.MethodSemanticsAttributes : Enum {
    public int value__;
    public static MethodSemanticsAttributes Setter;
    public static MethodSemanticsAttributes Getter;
    public static MethodSemanticsAttributes Other;
    public static MethodSemanticsAttributes AddOn;
    public static MethodSemanticsAttributes RemoveOn;
    public static MethodSemanticsAttributes Fire;
}
public class System.Reflection.Missing : object {
    [NullableAttribute("1")]
public static Missing Value;
    private static Missing();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public abstract class System.Reflection.Module : object {
    public static TypeFilter FilterTypeName;
    public static TypeFilter FilterTypeNameIgnoreCase;
    public Assembly Assembly { get; }
    public string FullyQualifiedName { get; }
    public string Name { get; }
    public int MDStreamVersion { get; }
    public Guid ModuleVersionId { get; }
    public string ScopeName { get; }
    public ModuleHandle ModuleHandle { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public int MetadataToken { get; }
    private static Module();
    public virtual Assembly get_Assembly();
    public virtual string get_FullyQualifiedName();
    public virtual string get_Name();
    public virtual int get_MDStreamVersion();
    public virtual Guid get_ModuleVersionId();
    public virtual string get_ScopeName();
    public ModuleHandle get_ModuleHandle();
    protected virtual ModuleHandle GetModuleHandleImpl();
    public virtual void GetPEKind(PortableExecutableKinds& peKind, ImageFileMachine& machine);
    public virtual bool IsResource();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public MethodInfo GetMethod(string name);
    public MethodInfo GetMethod(string name, Type[] types);
    [NullableContextAttribute("2")]
public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [NullableContextAttribute("2")]
protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public MethodInfo[] GetMethods();
    public virtual MethodInfo[] GetMethods(BindingFlags bindingFlags);
    public FieldInfo GetField(string name);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public FieldInfo[] GetFields();
    public virtual FieldInfo[] GetFields(BindingFlags bindingFlags);
    public virtual Type[] GetTypes();
    public virtual Type GetType(string className);
    public virtual Type GetType(string className, bool ignoreCase);
    public virtual Type GetType(string className, bool throwOnError, bool ignoreCase);
    [NullableContextAttribute("2")]
public virtual Type[] FindTypes(TypeFilter filter, object filterCriteria);
    public virtual int get_MetadataToken();
    [NullableContextAttribute("2")]
public FieldInfo ResolveField(int metadataToken);
    [NullableContextAttribute("2")]
public virtual FieldInfo ResolveField(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    [NullableContextAttribute("2")]
public MemberInfo ResolveMember(int metadataToken);
    [NullableContextAttribute("2")]
public virtual MemberInfo ResolveMember(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    [NullableContextAttribute("2")]
public MethodBase ResolveMethod(int metadataToken);
    [NullableContextAttribute("2")]
public virtual MethodBase ResolveMethod(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual Byte[] ResolveSignature(int metadataToken);
    public virtual string ResolveString(int metadataToken);
    public Type ResolveType(int metadataToken);
    public virtual Type ResolveType(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("2")]
public virtual bool Equals(object o);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public static bool op_Equality(Module left, Module right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(Module left, Module right);
    public virtual string ToString();
    private static bool FilterTypeNameImpl(Type cls, object filterCriteria, StringComparison comparison);
}
public class System.Reflection.ModuleResolveEventHandler : MulticastDelegate {
    public ModuleResolveEventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual Module Invoke(object sender, ResolveEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ResolveEventArgs e, AsyncCallback callback, object object);
    public virtual Module EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("1")]
public class System.Reflection.ObfuscateAssemblyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <AssemblyIsPrivate>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StripAfterObfuscation>k__BackingField;
    public bool AssemblyIsPrivate { get; }
    public bool StripAfterObfuscation { get; public set; }
    public ObfuscateAssemblyAttribute(bool assemblyIsPrivate);
    [CompilerGeneratedAttribute]
public bool get_AssemblyIsPrivate();
    [CompilerGeneratedAttribute]
public bool get_StripAfterObfuscation();
    [CompilerGeneratedAttribute]
public void set_StripAfterObfuscation(bool value);
}
[NullableAttribute("0")]
[AttributeUsageAttribute("8157")]
[NullableContextAttribute("2")]
public class System.Reflection.ObfuscationAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <StripAfterObfuscation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Exclude>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ApplyToMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Feature>k__BackingField;
    public bool StripAfterObfuscation { get; public set; }
    public bool Exclude { get; public set; }
    public bool ApplyToMembers { get; public set; }
    public string Feature { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_StripAfterObfuscation();
    [CompilerGeneratedAttribute]
public void set_StripAfterObfuscation(bool value);
    [CompilerGeneratedAttribute]
public bool get_Exclude();
    [CompilerGeneratedAttribute]
public void set_Exclude(bool value);
    [CompilerGeneratedAttribute]
public bool get_ApplyToMembers();
    [CompilerGeneratedAttribute]
public void set_ApplyToMembers(bool value);
    [CompilerGeneratedAttribute]
public string get_Feature();
    [CompilerGeneratedAttribute]
public void set_Feature(string value);
}
[FlagsAttribute]
public enum System.Reflection.ParameterAttributes : Enum {
    public int value__;
    public static ParameterAttributes None;
    public static ParameterAttributes In;
    public static ParameterAttributes Out;
    public static ParameterAttributes Lcid;
    public static ParameterAttributes Retval;
    public static ParameterAttributes Optional;
    public static ParameterAttributes HasDefault;
    public static ParameterAttributes HasFieldMarshal;
    public static ParameterAttributes Reserved3;
    public static ParameterAttributes Reserved4;
    public static ParameterAttributes ReservedMask;
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Reflection.ParameterInfo : object {
    protected ParameterAttributes AttrsImpl;
    [NullableAttribute("2")]
protected Type ClassImpl;
    [NullableAttribute("2")]
protected object DefaultValueImpl;
    protected MemberInfo MemberImpl;
    [NullableAttribute("2")]
protected string NameImpl;
    protected int PositionImpl;
    public ParameterAttributes Attributes { get; }
    public MemberInfo Member { get; }
    [NullableAttribute("2")]
public string Name { get; }
    public Type ParameterType { get; }
    public int Position { get; }
    public bool IsIn { get; }
    public bool IsLcid { get; }
    public bool IsOptional { get; }
    public bool IsOut { get; }
    public bool IsRetval { get; }
    [NullableAttribute("2")]
public object DefaultValue { get; }
    [NullableAttribute("2")]
public object RawDefaultValue { get; }
    public bool HasDefaultValue { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public int MetadataToken { get; }
    public virtual ParameterAttributes get_Attributes();
    public virtual MemberInfo get_Member();
    [NullableContextAttribute("2")]
public virtual string get_Name();
    public virtual Type get_ParameterType();
    public virtual int get_Position();
    public bool get_IsIn();
    public bool get_IsLcid();
    public bool get_IsOptional();
    public bool get_IsOut();
    public bool get_IsRetval();
    [NullableContextAttribute("2")]
public virtual object get_DefaultValue();
    [NullableContextAttribute("2")]
public virtual object get_RawDefaultValue();
    public virtual bool get_HasDefaultValue();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual Type[] GetOptionalCustomModifiers();
    public virtual Type[] GetRequiredCustomModifiers();
    public virtual int get_MetadataToken();
    public sealed virtual object GetRealObject(StreamingContext context);
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
[IsReadOnlyAttribute]
public class System.Reflection.ParameterModifier : ValueType {
    private Boolean[] _byRef;
    public bool Item { get; public set; }
    [NullableAttribute("1")]
internal Boolean[] IsByRefArray { get; }
    public ParameterModifier(int parameterCount);
    public bool get_Item(int index);
    public void set_Item(int index, bool value);
    internal Boolean[] get_IsByRefArray();
}
[FlagsAttribute]
internal enum System.Reflection.PInvokeAttributes : Enum {
    public int value__;
    public static PInvokeAttributes NoMangle;
    public static PInvokeAttributes CharSetMask;
    public static PInvokeAttributes CharSetNotSpec;
    public static PInvokeAttributes CharSetAnsi;
    public static PInvokeAttributes CharSetUnicode;
    public static PInvokeAttributes CharSetAuto;
    public static PInvokeAttributes BestFitUseAssem;
    public static PInvokeAttributes BestFitEnabled;
    public static PInvokeAttributes BestFitDisabled;
    public static PInvokeAttributes BestFitMask;
    public static PInvokeAttributes ThrowOnUnmappableCharUseAssem;
    public static PInvokeAttributes ThrowOnUnmappableCharEnabled;
    public static PInvokeAttributes ThrowOnUnmappableCharDisabled;
    public static PInvokeAttributes ThrowOnUnmappableCharMask;
    public static PInvokeAttributes SupportsLastError;
    public static PInvokeAttributes CallConvMask;
    public static PInvokeAttributes CallConvWinapi;
    public static PInvokeAttributes CallConvCdecl;
    public static PInvokeAttributes CallConvStdcall;
    public static PInvokeAttributes CallConvThiscall;
    public static PInvokeAttributes CallConvFastcall;
    public static PInvokeAttributes MaxValue;
}
[CLSCompliantAttribute("False")]
public class System.Reflection.Pointer : object {
    private Void* _ptr;
    private Type _ptrType;
    private Pointer(Void* ptr, Type ptrType);
    [NullableContextAttribute("1")]
public static object Box(Void* ptr, Type type);
    public static Void* Unbox(object ptr);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    internal Type GetPointerType();
    internal IntPtr GetPointerValue();
}
[FlagsAttribute]
public enum System.Reflection.PortableExecutableKinds : Enum {
    public int value__;
    public static PortableExecutableKinds NotAPortableExecutableImage;
    public static PortableExecutableKinds ILOnly;
    public static PortableExecutableKinds Required32Bit;
    public static PortableExecutableKinds PE32Plus;
    public static PortableExecutableKinds Unmanaged32Bit;
    public static PortableExecutableKinds Preferred32Bit;
}
public enum System.Reflection.ProcessorArchitecture : Enum {
    public int value__;
    public static ProcessorArchitecture None;
    public static ProcessorArchitecture MSIL;
    public static ProcessorArchitecture X86;
    public static ProcessorArchitecture IA64;
    public static ProcessorArchitecture Amd64;
    public static ProcessorArchitecture Arm;
}
[FlagsAttribute]
public enum System.Reflection.PropertyAttributes : Enum {
    public int value__;
    public static PropertyAttributes None;
    public static PropertyAttributes SpecialName;
    public static PropertyAttributes RTSpecialName;
    public static PropertyAttributes HasDefault;
    public static PropertyAttributes Reserved2;
    public static PropertyAttributes Reserved3;
    public static PropertyAttributes Reserved4;
    public static PropertyAttributes ReservedMask;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class System.Reflection.PropertyInfo : MemberInfo {
    public MemberTypes MemberType { get; }
    [NullableAttribute("1")]
public Type PropertyType { get; }
    public PropertyAttributes Attributes { get; }
    public bool IsSpecialName { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public MethodInfo GetMethod { get; }
    public MethodInfo SetMethod { get; }
    public virtual MemberTypes get_MemberType();
    [NullableContextAttribute("1")]
public abstract virtual Type get_PropertyType();
    [NullableContextAttribute("1")]
public abstract virtual ParameterInfo[] GetIndexParameters();
    public abstract virtual PropertyAttributes get_Attributes();
    public bool get_IsSpecialName();
    public abstract virtual bool get_CanRead();
    public abstract virtual bool get_CanWrite();
    [NullableContextAttribute("1")]
public MethodInfo[] GetAccessors();
    [NullableContextAttribute("1")]
public abstract virtual MethodInfo[] GetAccessors(bool nonPublic);
    public virtual MethodInfo get_GetMethod();
    public MethodInfo GetGetMethod();
    public abstract virtual MethodInfo GetGetMethod(bool nonPublic);
    public virtual MethodInfo get_SetMethod();
    public MethodInfo GetSetMethod();
    public abstract virtual MethodInfo GetSetMethod(bool nonPublic);
    [NullableContextAttribute("1")]
public virtual Type[] GetOptionalCustomModifiers();
    [NullableContextAttribute("1")]
public virtual Type[] GetRequiredCustomModifiers();
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public object GetValue(object obj);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public virtual object GetValue(object obj, Object[] index);
    public abstract virtual object GetValue(object obj, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public virtual object GetConstantValue();
    public virtual object GetRawConstantValue();
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public void SetValue(object obj, object value);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public virtual void SetValue(object obj, object value, Object[] index);
    public abstract virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(PropertyInfo left, PropertyInfo right);
    public static bool op_Inequality(PropertyInfo left, PropertyInfo right);
}
internal static class System.Reflection.PseudoCustomAttribute : object {
    private static Dictionary`2<RuntimeType, RuntimeType> s_pca;
    private static PseudoCustomAttribute();
    private static Dictionary`2<RuntimeType, RuntimeType> CreatePseudoCustomAttributeDictionary();
    internal static void GetCustomAttributes(RuntimeType type, RuntimeType caType, ListBuilder`1& pcas);
    internal static bool IsDefined(RuntimeType type, RuntimeType caType);
    internal static void GetCustomAttributes(RuntimeMethodInfo method, RuntimeType caType, ListBuilder`1& pcas);
    internal static bool IsDefined(RuntimeMethodInfo method, RuntimeType caType);
    internal static void GetCustomAttributes(RuntimeParameterInfo parameter, RuntimeType caType, ListBuilder`1& pcas);
    internal static bool IsDefined(RuntimeParameterInfo parameter, RuntimeType caType);
    internal static void GetCustomAttributes(RuntimeFieldInfo field, RuntimeType caType, ListBuilder`1& pcas);
    internal static bool IsDefined(RuntimeFieldInfo field, RuntimeType caType);
    private static DllImportAttribute GetDllImportCustomAttribute(RuntimeMethodInfo method);
    private static MarshalAsAttribute GetMarshalAsCustomAttribute(RuntimeParameterInfo parameter);
    private static MarshalAsAttribute GetMarshalAsCustomAttribute(RuntimeFieldInfo field);
    private static MarshalAsAttribute GetMarshalAsCustomAttribute(int token, RuntimeModule scope);
    private static FieldOffsetAttribute GetFieldOffsetCustomAttribute(RuntimeFieldInfo field);
    internal static StructLayoutAttribute GetStructLayoutCustomAttribute(RuntimeType type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Reflection.ReflectionContext : object {
    public abstract virtual Assembly MapAssembly(Assembly assembly);
    public abstract virtual TypeInfo MapType(TypeInfo type);
    public virtual TypeInfo GetTypeForObject(object value);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Reflection.ReflectionTypeLoadException : SystemException {
    [CompilerGeneratedAttribute]
private Type[] <Types>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception[] <LoaderExceptions>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Type[] Types { get; }
    [NullableAttribute("2")]
public Exception[] LoaderExceptions { get; }
    public string Message { get; }
    [NullableContextAttribute("2")]
public ReflectionTypeLoadException(Type[] classes, Exception[] exceptions);
    [NullableContextAttribute("2")]
public ReflectionTypeLoadException(Type[] classes, Exception[] exceptions, string message);
    private ReflectionTypeLoadException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public Type[] get_Types();
    [CompilerGeneratedAttribute]
[NullableContextAttribute("2")]
public Exception[] get_LoaderExceptions();
    public virtual string get_Message();
    public virtual string ToString();
    private string CreateString(bool isMessage);
}
[FlagsAttribute]
public enum System.Reflection.ResourceAttributes : Enum {
    public int value__;
    public static ResourceAttributes Public;
    public static ResourceAttributes Private;
}
[FlagsAttribute]
public enum System.Reflection.ResourceLocation : Enum {
    public int value__;
    public static ResourceLocation ContainedInAnotherAssembly;
    public static ResourceLocation ContainedInManifestFile;
    public static ResourceLocation Embedded;
}
internal class System.Reflection.RtFieldInfo : RuntimeFieldInfo {
    private IntPtr m_fieldHandle;
    private FieldAttributes m_fieldAttributes;
    private string m_name;
    private RuntimeType m_fieldType;
    private INVOCATION_FLAGS m_invocationFlags;
    internal INVOCATION_FLAGS InvocationFlags { get; }
    private RuntimeFieldHandleInternal System.IRuntimeFieldInfo.Value { get; }
    public string Name { get; }
    public int MetadataToken { get; }
    public RuntimeFieldHandle FieldHandle { get; }
    public FieldAttributes Attributes { get; }
    public Type FieldType { get; }
    internal RtFieldInfo(RuntimeFieldHandleInternal handle, RuntimeType declaringType, RuntimeTypeCache reflectedTypeCache, BindingFlags bindingFlags);
    internal INVOCATION_FLAGS get_InvocationFlags();
    private INVOCATION_FLAGS InitializeInvocationFlags();
    private sealed virtual override RuntimeFieldHandleInternal System.IRuntimeFieldInfo.get_Value();
    internal void CheckConsistency(object target);
    internal virtual bool CacheEquals(object o);
    public virtual string get_Name();
    public virtual int get_MetadataToken();
    internal virtual RuntimeModule GetRuntimeModule();
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public virtual object GetValue(object obj);
    public virtual object GetRawConstantValue();
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public virtual object GetValueDirect(TypedReference obj);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public virtual void SetValueDirect(TypedReference obj, object value);
    public virtual RuntimeFieldHandle get_FieldHandle();
    internal IntPtr GetFieldHandle();
    public virtual FieldAttributes get_Attributes();
    public virtual Type get_FieldType();
    private RuntimeType InitializeFieldType();
    public virtual Type[] GetRequiredCustomModifiers();
    public virtual Type[] GetOptionalCustomModifiers();
}
internal class System.Reflection.RuntimeAssembly : Assembly {
    [CompilerGeneratedAttribute]
private ModuleResolveEventHandler _ModuleResolve;
    private string m_fullname;
    private object m_syncRoot;
    private IntPtr m_assembly;
    private static string s_localFilePrefix;
    internal object SyncRoot { get; }
    public string CodeBase { get; }
    public string FullName { get; }
    public MethodInfo EntryPoint { get; }
    public IEnumerable`1<TypeInfo> DefinedTypes { get; }
    public bool IsCollectible { get; }
    public Module ManifestModule { get; }
    public bool ReflectionOnly { get; }
    public string Location { get; }
    public string ImageRuntimeVersion { get; }
    public bool GlobalAssemblyCache { get; }
    public long HostContext { get; }
    public bool IsDynamic { get; }
    [CompilerGeneratedAttribute]
private void add__ModuleResolve(ModuleResolveEventHandler value);
    [CompilerGeneratedAttribute]
private void remove__ModuleResolve(ModuleResolveEventHandler value);
    internal IntPtr GetUnderlyingNativeHandle();
    internal object get_SyncRoot();
    public virtual void add_ModuleResolve(ModuleResolveEventHandler value);
    public virtual void remove_ModuleResolve(ModuleResolveEventHandler value);
    private static void GetCodeBase(QCallAssembly assembly, bool copiedName, StringHandleOnStack retString);
    internal string GetCodeBase(bool copiedName);
    public virtual string get_CodeBase();
    internal RuntimeAssembly GetNativeHandle();
    public virtual AssemblyName GetName(bool copiedName);
    private static void GetFullName(QCallAssembly assembly, StringHandleOnStack retString);
    public virtual string get_FullName();
    private static void GetEntryPoint(QCallAssembly assembly, ObjectHandleOnStack retMethod);
    public virtual MethodInfo get_EntryPoint();
    private static void GetType(QCallAssembly assembly, string name, bool throwOnError, bool ignoreCase, ObjectHandleOnStack type, ObjectHandleOnStack keepAlive, ObjectHandleOnStack assemblyLoadContext);
    public virtual Type GetType(string name, bool throwOnError, bool ignoreCase);
    private static void GetExportedTypes(QCallAssembly assembly, ObjectHandleOnStack retTypes);
    public virtual Type[] GetExportedTypes();
    public virtual IEnumerable`1<TypeInfo> get_DefinedTypes();
    internal static BOOL GetIsCollectible(QCallAssembly assembly);
    public virtual bool get_IsCollectible();
    private static Byte* GetResource(QCallAssembly assembly, string resourceName, UInt32& length);
    public virtual Stream GetManifestResourceStream(Type type, string name);
    public virtual Stream GetManifestResourceStream(string name);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual Module get_ManifestModule();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    internal static RuntimeAssembly InternalLoad(string assemblyString, StackCrawlMark& stackMark, AssemblyLoadContext assemblyLoadContext);
    internal static RuntimeAssembly InternalLoadAssemblyName(AssemblyName assemblyRef, StackCrawlMark& stackMark, AssemblyLoadContext assemblyLoadContext);
    private static RuntimeAssembly nLoad(AssemblyName fileName, string codeBase, RuntimeAssembly assemblyContext, StackCrawlMark& stackMark, bool throwOnFileNotFound, AssemblyLoadContext assemblyLoadContext);
    public virtual bool get_ReflectionOnly();
    private static void GetModule(QCallAssembly assembly, string name, ObjectHandleOnStack retModule);
    public virtual Module GetModule(string name);
    public virtual FileStream GetFile(string name);
    public virtual FileStream[] GetFiles(bool getResourceModules);
    private static String[] GetManifestResourceNames(RuntimeAssembly assembly);
    public virtual String[] GetManifestResourceNames();
    private static AssemblyName[] GetReferencedAssemblies(RuntimeAssembly assembly);
    public virtual AssemblyName[] GetReferencedAssemblies();
    private static int GetManifestResourceInfo(QCallAssembly assembly, string resourceName, ObjectHandleOnStack assemblyRef, StringHandleOnStack retFileName);
    public virtual ManifestResourceInfo GetManifestResourceInfo(string resourceName);
    private static void GetLocation(QCallAssembly assembly, StringHandleOnStack retString);
    public virtual string get_Location();
    private static void GetImageRuntimeVersion(QCallAssembly assembly, StringHandleOnStack retString);
    public virtual string get_ImageRuntimeVersion();
    public virtual bool get_GlobalAssemblyCache();
    public virtual long get_HostContext();
    private static string VerifyCodeBase(string codebase);
    private static void GetVersion(QCallAssembly assembly, Int32& majVer, Int32& minVer, Int32& buildNum, Int32& revNum);
    internal Version GetVersion();
    private static void GetLocale(QCallAssembly assembly, StringHandleOnStack retString);
    internal CultureInfo GetLocale();
    private static bool FCallIsDynamic(RuntimeAssembly assembly);
    public virtual bool get_IsDynamic();
    private static void GetSimpleName(QCallAssembly assembly, StringHandleOnStack retSimpleName);
    internal string GetSimpleName();
    private static AssemblyHashAlgorithm GetHashAlgorithm(QCallAssembly assembly);
    private AssemblyHashAlgorithm GetHashAlgorithm();
    private static AssemblyNameFlags GetFlags(QCallAssembly assembly);
    private AssemblyNameFlags GetFlags();
    private static void GetPublicKey(QCallAssembly assembly, ObjectHandleOnStack retPublicKey);
    internal Byte[] GetPublicKey();
    private RuntimeModule OnModuleResolveEvent(string moduleName);
    public virtual Assembly GetSatelliteAssembly(CultureInfo culture);
    public virtual Assembly GetSatelliteAssembly(CultureInfo culture, Version version);
    internal Assembly InternalGetSatelliteAssembly(CultureInfo culture, Version version, bool throwOnFileNotFound);
    private static void GetModules(QCallAssembly assembly, bool loadIfNotFound, bool getResourceModules, ObjectHandleOnStack retModuleHandles);
    private RuntimeModule[] GetModulesInternal(bool loadIfNotFound, bool getResourceModules);
    public virtual Module[] GetModules(bool getResourceModules);
    public virtual Module[] GetLoadedModules(bool getResourceModules);
    internal static RuntimeModule GetManifestModule(RuntimeAssembly assembly);
    internal static int GetToken(RuntimeAssembly assembly);
    public sealed virtual Type[] GetForwardedTypes();
    private static void AddPublicNestedTypes(Type type, List`1<Type> types, List`1<Exception> exceptions);
    private static void GetForwardedType(QCallAssembly assembly, MetadataToken mdtExternalType, ObjectHandleOnStack type);
}
internal class System.Reflection.RuntimeConstructorInfo : ConstructorInfo {
    private RuntimeType modreq(System.Runtime.CompilerServices.IsVolatile) m_declaringType;
    private RuntimeTypeCache m_reflectedTypeCache;
    private string m_toString;
    private ParameterInfo[] m_parameters;
    private object _empty1;
    private object _empty2;
    private object _empty3;
    private IntPtr m_handle;
    private MethodAttributes m_methodAttributes;
    private BindingFlags m_bindingFlags;
    private Signature modreq(System.Runtime.CompilerServices.IsVolatile) m_signature;
    private INVOCATION_FLAGS m_invocationFlags;
    internal INVOCATION_FLAGS InvocationFlags { get; }
    private RuntimeMethodHandleInternal System.IRuntimeMethodInfo.Value { get; }
    private Signature Signature { get; }
    private RuntimeType ReflectedTypeInternal { get; }
    internal BindingFlags BindingFlags { get; }
    public string Name { get; }
    public MemberTypes MemberType { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public int MetadataToken { get; }
    public Module Module { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public bool ContainsGenericParameters { get; }
    internal RuntimeConstructorInfo(RuntimeMethodHandleInternal handle, RuntimeType declaringType, RuntimeTypeCache reflectedTypeCache, MethodAttributes methodAttributes, BindingFlags bindingFlags);
    internal INVOCATION_FLAGS get_InvocationFlags();
    private sealed virtual override RuntimeMethodHandleInternal System.IRuntimeMethodInfo.get_Value();
    internal virtual bool CacheEquals(object o);
    private Signature get_Signature();
    private RuntimeType get_ReflectedTypeInternal();
    private void CheckConsistency(object target);
    internal BindingFlags get_BindingFlags();
    public virtual string ToString();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual string get_Name();
    public virtual MemberTypes get_MemberType();
    public virtual Type get_DeclaringType();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public virtual Type get_ReflectedType();
    public virtual int get_MetadataToken();
    public virtual Module get_Module();
    internal RuntimeType GetRuntimeType();
    internal RuntimeModule GetRuntimeModule();
    internal virtual Type GetReturnType();
    internal virtual ParameterInfo[] GetParametersNoCopy();
    public virtual ParameterInfo[] GetParameters();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual MethodAttributes get_Attributes();
    public virtual CallingConventions get_CallingConvention();
    internal static void CheckCanCreateInstance(Type declaringType, bool isVarArg);
    [DoesNotReturnAttribute]
internal void ThrowNoInvokeException();
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual MethodBody GetMethodBody();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    public virtual bool get_ContainsGenericParameters();
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public virtual object Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
}
internal class System.Reflection.RuntimeEventInfo : EventInfo {
    private int m_token;
    private EventAttributes m_flags;
    private string m_name;
    private Void* m_utf8name;
    private RuntimeTypeCache m_reflectedTypeCache;
    private RuntimeMethodInfo m_addMethod;
    private RuntimeMethodInfo m_removeMethod;
    private RuntimeMethodInfo m_raiseMethod;
    private MethodInfo[] m_otherMethod;
    private RuntimeType m_declaringType;
    private BindingFlags m_bindingFlags;
    internal BindingFlags BindingFlags { get; }
    public MemberTypes MemberType { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    private RuntimeType ReflectedTypeInternal { get; }
    public int MetadataToken { get; }
    public Module Module { get; }
    public EventAttributes Attributes { get; }
    internal RuntimeEventInfo(int tkEvent, RuntimeType declaredType, RuntimeTypeCache reflectedTypeCache, Boolean& isPrivate);
    internal virtual bool CacheEquals(object o);
    internal BindingFlags get_BindingFlags();
    public virtual string ToString();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual MemberTypes get_MemberType();
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public virtual Type get_ReflectedType();
    private RuntimeType get_ReflectedTypeInternal();
    public virtual int get_MetadataToken();
    public virtual Module get_Module();
    internal RuntimeModule GetRuntimeModule();
    public virtual MethodInfo[] GetOtherMethods(bool nonPublic);
    public virtual MethodInfo GetAddMethod(bool nonPublic);
    public virtual MethodInfo GetRemoveMethod(bool nonPublic);
    public virtual MethodInfo GetRaiseMethod(bool nonPublic);
    public virtual EventAttributes get_Attributes();
}
internal class System.Reflection.RuntimeExceptionHandlingClause : ExceptionHandlingClause {
    private RuntimeMethodBody _methodBody;
    private ExceptionHandlingClauseOptions _flags;
    private int _tryOffset;
    private int _tryLength;
    private int _handlerOffset;
    private int _handlerLength;
    private int _catchMetadataToken;
    private int _filterOffset;
    public ExceptionHandlingClauseOptions Flags { get; }
    public int TryOffset { get; }
    public int TryLength { get; }
    public int HandlerOffset { get; }
    public int HandlerLength { get; }
    public int FilterOffset { get; }
    public Type CatchType { get; }
    public virtual ExceptionHandlingClauseOptions get_Flags();
    public virtual int get_TryOffset();
    public virtual int get_TryLength();
    public virtual int get_HandlerOffset();
    public virtual int get_HandlerLength();
    public virtual int get_FilterOffset();
    public virtual Type get_CatchType();
    public virtual string ToString();
}
internal abstract class System.Reflection.RuntimeFieldInfo : FieldInfo {
    private BindingFlags m_bindingFlags;
    protected RuntimeTypeCache m_reflectedTypeCache;
    protected RuntimeType m_declaringType;
    internal BindingFlags BindingFlags { get; }
    private RuntimeType ReflectedTypeInternal { get; }
    public MemberTypes MemberType { get; }
    public Type ReflectedType { get; }
    public Type DeclaringType { get; }
    public Module Module { get; }
    public bool IsCollectible { get; }
    protected RuntimeFieldInfo(RuntimeTypeCache reflectedTypeCache, RuntimeType declaringType, BindingFlags bindingFlags);
    internal BindingFlags get_BindingFlags();
    private RuntimeType get_ReflectedTypeInternal();
    internal RuntimeType GetDeclaringTypeInternal();
    internal RuntimeType GetRuntimeType();
    internal abstract virtual RuntimeModule GetRuntimeModule();
    public virtual MemberTypes get_MemberType();
    public virtual Type get_ReflectedType();
    public virtual Type get_DeclaringType();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public virtual Module get_Module();
    public virtual bool get_IsCollectible();
    public virtual string ToString();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
}
internal class System.Reflection.RuntimeLocalVariableInfo : LocalVariableInfo {
    private RuntimeType _type;
    private int _localIndex;
    private bool _isPinned;
    public Type LocalType { get; }
    public int LocalIndex { get; }
    public bool IsPinned { get; }
    public virtual Type get_LocalType();
    public virtual int get_LocalIndex();
    public virtual bool get_IsPinned();
}
internal class System.Reflection.RuntimeMethodBody : MethodBody {
    private Byte[] _IL;
    private ExceptionHandlingClause[] _exceptionHandlingClauses;
    private LocalVariableInfo[] _localVariables;
    internal MethodBase _methodBase;
    private int _localSignatureMetadataToken;
    private int _maxStackSize;
    private bool _initLocals;
    public int LocalSignatureMetadataToken { get; }
    public IList`1<LocalVariableInfo> LocalVariables { get; }
    public int MaxStackSize { get; }
    public bool InitLocals { get; }
    public IList`1<ExceptionHandlingClause> ExceptionHandlingClauses { get; }
    public virtual int get_LocalSignatureMetadataToken();
    public virtual IList`1<LocalVariableInfo> get_LocalVariables();
    public virtual int get_MaxStackSize();
    public virtual bool get_InitLocals();
    public virtual Byte[] GetILAsByteArray();
    public virtual IList`1<ExceptionHandlingClause> get_ExceptionHandlingClauses();
}
internal class System.Reflection.RuntimeMethodInfo : MethodInfo {
    private IntPtr m_handle;
    private RuntimeTypeCache m_reflectedTypeCache;
    private string m_name;
    private string m_toString;
    private ParameterInfo[] m_parameters;
    private ParameterInfo m_returnParameter;
    private BindingFlags m_bindingFlags;
    private MethodAttributes m_methodAttributes;
    private Signature m_signature;
    private RuntimeType m_declaringType;
    private object m_keepalive;
    private INVOCATION_FLAGS m_invocationFlags;
    internal INVOCATION_FLAGS InvocationFlags { get; }
    private RuntimeMethodHandleInternal System.IRuntimeMethodInfo.Value { get; }
    private RuntimeType ReflectedTypeInternal { get; }
    internal Signature Signature { get; }
    internal BindingFlags BindingFlags { get; }
    internal int GenericParameterCount { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public MemberTypes MemberType { get; }
    public int MetadataToken { get; }
    public Module Module { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public Type ReturnType { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    public ParameterInfo ReturnParameter { get; }
    public bool IsCollectible { get; }
    public bool IsGenericMethod { get; }
    public bool IsGenericMethodDefinition { get; }
    public bool ContainsGenericParameters { get; }
    internal RuntimeMethodInfo(RuntimeMethodHandleInternal handle, RuntimeType declaringType, RuntimeTypeCache reflectedTypeCache, MethodAttributes methodAttributes, BindingFlags bindingFlags, object keepalive);
    internal INVOCATION_FLAGS get_InvocationFlags();
    private bool IsDisallowedByRefType(Type type);
    private sealed virtual override RuntimeMethodHandleInternal System.IRuntimeMethodInfo.get_Value();
    private RuntimeType get_ReflectedTypeInternal();
    private ParameterInfo[] FetchNonReturnParameters();
    private ParameterInfo FetchReturnParameter();
    internal virtual bool CacheEquals(object o);
    internal Signature get_Signature();
    internal BindingFlags get_BindingFlags();
    internal RuntimeMethodInfo GetParentDefinition();
    internal RuntimeType GetDeclaringTypeInternal();
    internal sealed virtual int get_GenericParameterCount();
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public virtual Type get_ReflectedType();
    public virtual MemberTypes get_MemberType();
    public virtual int get_MetadataToken();
    public virtual Module get_Module();
    internal RuntimeType GetRuntimeType();
    internal RuntimeModule GetRuntimeModule();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    internal virtual ParameterInfo[] GetParametersNoCopy();
    public virtual ParameterInfo[] GetParameters();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual MethodAttributes get_Attributes();
    public virtual CallingConventions get_CallingConvention();
    public virtual MethodBody GetMethodBody();
    private void CheckConsistency(object target);
    [DoesNotReturnAttribute]
private void ThrowNoInvokeException();
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
private Object[] InvokeArgumentsCheck(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual Type get_ReturnType();
    public virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public virtual ParameterInfo get_ReturnParameter();
    public virtual bool get_IsCollectible();
    public virtual MethodInfo GetBaseDefinition();
    public virtual Delegate CreateDelegate(Type delegateType);
    public virtual Delegate CreateDelegate(Type delegateType, object target);
    private Delegate CreateDelegateInternal(Type delegateType, object firstArgument, DelegateBindingFlags bindingFlags);
    public virtual MethodInfo MakeGenericMethod(Type[] methodInstantiation);
    internal RuntimeType[] GetGenericArgumentsInternal();
    public virtual Type[] GetGenericArguments();
    public virtual MethodInfo GetGenericMethodDefinition();
    public virtual bool get_IsGenericMethod();
    public virtual bool get_IsGenericMethodDefinition();
    public virtual bool get_ContainsGenericParameters();
    internal static MethodBase InternalGetCurrentMethod(StackCrawlMark& stackMark);
}
internal class System.Reflection.RuntimeModule : Module {
    private RuntimeType m_runtimeType;
    private RuntimeAssembly m_runtimeAssembly;
    private IntPtr m_pRefClass;
    private IntPtr m_pData;
    private IntPtr m_pGlobals;
    private IntPtr m_pFields;
    public int MDStreamVersion { get; }
    internal RuntimeType RuntimeType { get; }
    internal MetadataImport MetadataImport { get; }
    public string FullyQualifiedName { get; }
    public Guid ModuleVersionId { get; }
    public int MetadataToken { get; }
    public string ScopeName { get; }
    public string Name { get; }
    public Assembly Assembly { get; }
    private static void GetType(QCallModule module, string className, bool throwOnError, bool ignoreCase, ObjectHandleOnStack type, ObjectHandleOnStack keepAlive);
    private static bool nIsTransientInternal(QCallModule module);
    private static void GetScopeName(QCallModule module, StringHandleOnStack retString);
    private static void GetFullyQualifiedName(QCallModule module, StringHandleOnStack retString);
    private static RuntimeType[] GetTypes(RuntimeModule module);
    internal RuntimeType[] GetDefinedTypes();
    private static bool IsResource(RuntimeModule module);
    private static RuntimeTypeHandle[] ConvertToTypeHandleArray(Type[] genericArguments);
    public virtual Byte[] ResolveSignature(int metadataToken);
    public virtual MethodBase ResolveMethod(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    private FieldInfo ResolveLiteralField(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual FieldInfo ResolveField(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual Type ResolveType(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual MemberInfo ResolveMember(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual string ResolveString(int metadataToken);
    public virtual void GetPEKind(PortableExecutableKinds& peKind, ImageFileMachine& machine);
    public virtual int get_MDStreamVersion();
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    internal MethodInfo GetMethodInternal(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    internal RuntimeType get_RuntimeType();
    internal bool IsTransientInternal();
    internal MetadataImport get_MetadataImport();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual Type GetType(string className, bool throwOnError, bool ignoreCase);
    internal string GetFullyQualifiedName();
    public virtual string get_FullyQualifiedName();
    public virtual Type[] GetTypes();
    public virtual Guid get_ModuleVersionId();
    public virtual int get_MetadataToken();
    public virtual bool IsResource();
    public virtual FieldInfo[] GetFields(BindingFlags bindingFlags);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingFlags);
    public virtual string get_ScopeName();
    public virtual string get_Name();
    public virtual Assembly get_Assembly();
    internal RuntimeAssembly GetRuntimeAssembly();
    protected virtual ModuleHandle GetModuleHandleImpl();
    internal RuntimeModule GetNativeHandle();
    internal IntPtr GetUnderlyingNativeHandle();
}
internal class System.Reflection.RuntimeParameterInfo : ParameterInfo {
    private static Type s_DecimalConstantAttributeType;
    private static Type s_CustomConstantAttributeType;
    private int m_tkParamDef;
    private MetadataImport m_scope;
    private Signature m_signature;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_nameIsCached;
    private bool m_noMetadata;
    private bool m_noDefaultValue;
    private MethodBase m_originalMember;
    public Type ParameterType { get; }
    public string Name { get; }
    public bool HasDefaultValue { get; }
    public object DefaultValue { get; }
    public object RawDefaultValue { get; }
    public int MetadataToken { get; }
    internal RuntimeParameterInfo(RuntimeParameterInfo accessor, RuntimePropertyInfo property);
    private RuntimeParameterInfo(RuntimeParameterInfo accessor, MemberInfo member);
    private RuntimeParameterInfo(Signature signature, MetadataImport scope, int tkParamDef, int position, ParameterAttributes attributes, MemberInfo member);
    internal RuntimeParameterInfo(MethodInfo owner, string name, Type parameterType, int position);
    private static RuntimeParameterInfo();
    internal static ParameterInfo[] GetParameters(IRuntimeMethodInfo method, MemberInfo member, Signature sig);
    internal static ParameterInfo GetReturnParameter(IRuntimeMethodInfo method, MemberInfo member, Signature sig);
    internal static ParameterInfo[] GetParameters(IRuntimeMethodInfo methodHandle, MemberInfo member, Signature sig, ParameterInfo& returnParameter, bool fetchReturnParameter);
    internal void SetName(string name);
    internal void SetAttributes(ParameterAttributes attributes);
    public virtual Type get_ParameterType();
    public virtual string get_Name();
    public virtual bool get_HasDefaultValue();
    public virtual object get_DefaultValue();
    public virtual object get_RawDefaultValue();
    private object GetDefaultValue(bool raw);
    private object GetDefaultValueInternal(bool raw);
    private static decimal GetRawDecimalConstant(CustomAttributeData attr);
    private static DateTime GetRawDateTimeConstant(CustomAttributeData attr);
    private static object GetRawConstant(CustomAttributeData attr);
    internal RuntimeModule GetRuntimeModule();
    public virtual int get_MetadataToken();
    public virtual Type[] GetRequiredCustomModifiers();
    public virtual Type[] GetOptionalCustomModifiers();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
}
internal class System.Reflection.RuntimePropertyInfo : PropertyInfo {
    private int m_token;
    private string m_name;
    private Void* m_utf8name;
    private PropertyAttributes m_flags;
    private RuntimeTypeCache m_reflectedTypeCache;
    private RuntimeMethodInfo m_getterMethod;
    private RuntimeMethodInfo m_setterMethod;
    private MethodInfo[] m_otherMethod;
    private RuntimeType m_declaringType;
    private BindingFlags m_bindingFlags;
    private Signature m_signature;
    private ParameterInfo[] m_parameters;
    internal Signature Signature { get; }
    internal BindingFlags BindingFlags { get; }
    public MemberTypes MemberType { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    private RuntimeType ReflectedTypeInternal { get; }
    public int MetadataToken { get; }
    public Module Module { get; }
    public bool IsCollectible { get; }
    public Type PropertyType { get; }
    public PropertyAttributes Attributes { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    internal RuntimePropertyInfo(int tkProperty, RuntimeType declaredType, RuntimeTypeCache reflectedTypeCache, Boolean& isPrivate);
    internal virtual bool CacheEquals(object o);
    internal Signature get_Signature();
    internal bool EqualsSig(RuntimePropertyInfo target);
    internal BindingFlags get_BindingFlags();
    public virtual string ToString();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual MemberTypes get_MemberType();
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public virtual Type get_ReflectedType();
    private RuntimeType get_ReflectedTypeInternal();
    public virtual int get_MetadataToken();
    public virtual Module get_Module();
    internal RuntimeModule GetRuntimeModule();
    public virtual bool get_IsCollectible();
    public virtual Type[] GetRequiredCustomModifiers();
    public virtual Type[] GetOptionalCustomModifiers();
    internal object GetConstantValue(bool raw);
    public virtual object GetConstantValue();
    public virtual object GetRawConstantValue();
    public virtual MethodInfo[] GetAccessors(bool nonPublic);
    public virtual Type get_PropertyType();
    public virtual MethodInfo GetGetMethod(bool nonPublic);
    public virtual MethodInfo GetSetMethod(bool nonPublic);
    public virtual ParameterInfo[] GetIndexParameters();
    internal ParameterInfo[] GetIndexParametersNoCopy();
    public virtual PropertyAttributes get_Attributes();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public virtual object GetValue(object obj, Object[] index);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public virtual object GetValue(object obj, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public virtual void SetValue(object obj, object value, Object[] index);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
}
internal class System.Reflection.SignatureArrayType : SignatureHasElementType {
    private int _rank;
    private bool _isMultiDim;
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    protected string Suffix { get; }
    internal SignatureArrayType(SignatureType elementType, int rank, bool isMultiDim);
    protected sealed virtual bool IsArrayImpl();
    protected sealed virtual bool IsByRefImpl();
    protected sealed virtual bool IsPointerImpl();
    public sealed virtual bool get_IsSZArray();
    public sealed virtual bool get_IsVariableBoundArray();
    public sealed virtual int GetArrayRank();
    protected sealed virtual string get_Suffix();
}
internal class System.Reflection.SignatureByRefType : SignatureHasElementType {
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    protected string Suffix { get; }
    internal SignatureByRefType(SignatureType elementType);
    protected sealed virtual bool IsArrayImpl();
    protected sealed virtual bool IsByRefImpl();
    protected sealed virtual bool IsPointerImpl();
    public sealed virtual bool get_IsSZArray();
    public sealed virtual bool get_IsVariableBoundArray();
    public sealed virtual int GetArrayRank();
    protected sealed virtual string get_Suffix();
}
internal class System.Reflection.SignatureConstructedGenericType : SignatureType {
    private Type _genericTypeDefinition;
    private Type[] _genericTypeArguments;
    public bool IsTypeDefinition { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsByRefLike { get; }
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericTypeParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public bool ContainsGenericParameters { get; }
    internal SignatureType ElementType { get; }
    public Type[] GenericTypeArguments { get; }
    public int GenericParameterPosition { get; }
    public string Name { get; }
    public string Namespace { get; }
    internal SignatureConstructedGenericType(Type genericTypeDefinition, Type[] typeArguments);
    public sealed virtual bool get_IsTypeDefinition();
    public sealed virtual bool get_IsGenericTypeDefinition();
    protected sealed virtual bool HasElementTypeImpl();
    protected sealed virtual bool IsArrayImpl();
    protected sealed virtual bool IsByRefImpl();
    public sealed virtual bool get_IsByRefLike();
    protected sealed virtual bool IsPointerImpl();
    public sealed virtual bool get_IsSZArray();
    public sealed virtual bool get_IsVariableBoundArray();
    public sealed virtual bool get_IsConstructedGenericType();
    public sealed virtual bool get_IsGenericParameter();
    public sealed virtual bool get_IsGenericTypeParameter();
    public sealed virtual bool get_IsGenericMethodParameter();
    public sealed virtual bool get_ContainsGenericParameters();
    internal sealed virtual SignatureType get_ElementType();
    public sealed virtual int GetArrayRank();
    public sealed virtual Type GetGenericTypeDefinition();
    public sealed virtual Type[] GetGenericArguments();
    public sealed virtual Type[] get_GenericTypeArguments();
    public sealed virtual int get_GenericParameterPosition();
    public sealed virtual string get_Name();
    public sealed virtual string get_Namespace();
    public sealed virtual string ToString();
}
internal class System.Reflection.SignatureGenericMethodParameterType : SignatureGenericParameterType {
    public bool IsGenericTypeParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public string Name { get; }
    internal SignatureGenericMethodParameterType(int position);
    public sealed virtual bool get_IsGenericTypeParameter();
    public sealed virtual bool get_IsGenericMethodParameter();
    public sealed virtual string get_Name();
}
internal abstract class System.Reflection.SignatureGenericParameterType : SignatureType {
    private int _position;
    public bool IsTypeDefinition { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsByRefLike { get; }
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public bool ContainsGenericParameters { get; }
    internal SignatureType ElementType { get; }
    public Type[] GenericTypeArguments { get; }
    public int GenericParameterPosition { get; }
    public string Name { get; }
    public string Namespace { get; }
    protected SignatureGenericParameterType(int position);
    public sealed virtual bool get_IsTypeDefinition();
    public sealed virtual bool get_IsGenericTypeDefinition();
    protected sealed virtual bool HasElementTypeImpl();
    protected sealed virtual bool IsArrayImpl();
    protected sealed virtual bool IsByRefImpl();
    public sealed virtual bool get_IsByRefLike();
    protected sealed virtual bool IsPointerImpl();
    public sealed virtual bool get_IsSZArray();
    public sealed virtual bool get_IsVariableBoundArray();
    public sealed virtual bool get_IsConstructedGenericType();
    public sealed virtual bool get_IsGenericParameter();
    public abstract virtual bool get_IsGenericMethodParameter();
    public sealed virtual bool get_ContainsGenericParameters();
    internal sealed virtual SignatureType get_ElementType();
    public sealed virtual int GetArrayRank();
    public sealed virtual Type GetGenericTypeDefinition();
    public sealed virtual Type[] GetGenericArguments();
    public sealed virtual Type[] get_GenericTypeArguments();
    public sealed virtual int get_GenericParameterPosition();
    public abstract virtual string get_Name();
    public sealed virtual string get_Namespace();
    public sealed virtual string ToString();
}
internal abstract class System.Reflection.SignatureHasElementType : SignatureType {
    private SignatureType _elementType;
    public bool IsTypeDefinition { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsByRefLike { get; }
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericTypeParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public bool ContainsGenericParameters { get; }
    internal SignatureType ElementType { get; }
    public Type[] GenericTypeArguments { get; }
    public int GenericParameterPosition { get; }
    public string Name { get; }
    public string Namespace { get; }
    protected string Suffix { get; }
    protected SignatureHasElementType(SignatureType elementType);
    public sealed virtual bool get_IsTypeDefinition();
    public sealed virtual bool get_IsGenericTypeDefinition();
    protected sealed virtual bool HasElementTypeImpl();
    protected abstract virtual bool IsArrayImpl();
    protected abstract virtual bool IsByRefImpl();
    public sealed virtual bool get_IsByRefLike();
    protected abstract virtual bool IsPointerImpl();
    public abstract virtual bool get_IsSZArray();
    public abstract virtual bool get_IsVariableBoundArray();
    public sealed virtual bool get_IsConstructedGenericType();
    public sealed virtual bool get_IsGenericParameter();
    public sealed virtual bool get_IsGenericTypeParameter();
    public sealed virtual bool get_IsGenericMethodParameter();
    public sealed virtual bool get_ContainsGenericParameters();
    internal sealed virtual SignatureType get_ElementType();
    public abstract virtual int GetArrayRank();
    public sealed virtual Type GetGenericTypeDefinition();
    public sealed virtual Type[] GetGenericArguments();
    public sealed virtual Type[] get_GenericTypeArguments();
    public sealed virtual int get_GenericParameterPosition();
    public sealed virtual string get_Name();
    public sealed virtual string get_Namespace();
    public sealed virtual string ToString();
    protected abstract virtual string get_Suffix();
}
internal class System.Reflection.SignaturePointerType : SignatureHasElementType {
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    protected string Suffix { get; }
    internal SignaturePointerType(SignatureType elementType);
    protected sealed virtual bool IsArrayImpl();
    protected sealed virtual bool IsByRefImpl();
    protected sealed virtual bool IsPointerImpl();
    public sealed virtual bool get_IsSZArray();
    public sealed virtual bool get_IsVariableBoundArray();
    public sealed virtual int GetArrayRank();
    protected sealed virtual string get_Suffix();
}
internal abstract class System.Reflection.SignatureType : Type {
    public bool IsSignatureType { get; }
    public bool IsTypeDefinition { get; }
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    public bool IsByRefLike { get; }
    public bool IsGenericType { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericTypeParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public bool ContainsGenericParameters { get; }
    public MemberTypes MemberType { get; }
    public Type[] GenericTypeArguments { get; }
    public int GenericParameterPosition { get; }
    internal SignatureType ElementType { get; }
    public Type UnderlyingSystemType { get; }
    public string Name { get; }
    public string Namespace { get; }
    public string FullName { get; }
    public string AssemblyQualifiedName { get; }
    public Assembly Assembly { get; }
    public Module Module { get; }
    public Type ReflectedType { get; }
    public Type BaseType { get; }
    public int MetadataToken { get; }
    public Type DeclaringType { get; }
    public MethodBase DeclaringMethod { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public Guid GUID { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public bool IsEnum { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public bool IsSerializable { get; }
    public StructLayoutAttribute StructLayoutAttribute { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public sealed virtual bool get_IsSignatureType();
    public abstract virtual bool get_IsTypeDefinition();
    protected abstract virtual bool HasElementTypeImpl();
    protected abstract virtual bool IsArrayImpl();
    public abstract virtual bool get_IsSZArray();
    public abstract virtual bool get_IsVariableBoundArray();
    protected abstract virtual bool IsByRefImpl();
    public abstract virtual bool get_IsByRefLike();
    protected abstract virtual bool IsPointerImpl();
    public sealed virtual bool get_IsGenericType();
    public abstract virtual bool get_IsGenericTypeDefinition();
    public abstract virtual bool get_IsConstructedGenericType();
    public abstract virtual bool get_IsGenericParameter();
    public abstract virtual bool get_IsGenericTypeParameter();
    public abstract virtual bool get_IsGenericMethodParameter();
    public abstract virtual bool get_ContainsGenericParameters();
    public sealed virtual MemberTypes get_MemberType();
    public sealed virtual Type MakeArrayType();
    public sealed virtual Type MakeArrayType(int rank);
    public sealed virtual Type MakeByRefType();
    public sealed virtual Type MakePointerType();
    public sealed virtual Type MakeGenericType(Type[] typeArguments);
    public sealed virtual Type GetElementType();
    public abstract virtual int GetArrayRank();
    public abstract virtual Type GetGenericTypeDefinition();
    public abstract virtual Type[] get_GenericTypeArguments();
    public abstract virtual Type[] GetGenericArguments();
    public abstract virtual int get_GenericParameterPosition();
    internal abstract virtual SignatureType get_ElementType();
    public sealed virtual Type get_UnderlyingSystemType();
    public abstract virtual string get_Name();
    public abstract virtual string get_Namespace();
    public sealed virtual string get_FullName();
    public sealed virtual string get_AssemblyQualifiedName();
    public abstract virtual string ToString();
    public sealed virtual Assembly get_Assembly();
    public sealed virtual Module get_Module();
    public sealed virtual Type get_ReflectedType();
    public sealed virtual Type get_BaseType();
    public sealed virtual Type[] GetInterfaces();
    public sealed virtual bool IsAssignableFrom(Type c);
    public sealed virtual int get_MetadataToken();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public sealed virtual Type get_DeclaringType();
    public sealed virtual MethodBase get_DeclaringMethod();
    public sealed virtual Type[] GetGenericParameterConstraints();
    public sealed virtual GenericParameterAttributes get_GenericParameterAttributes();
    public sealed virtual bool IsEnumDefined(object value);
    public sealed virtual string GetEnumName(object value);
    public sealed virtual String[] GetEnumNames();
    public sealed virtual Type GetEnumUnderlyingType();
    public sealed virtual Array GetEnumValues();
    public sealed virtual Guid get_GUID();
    protected sealed virtual TypeCode GetTypeCodeImpl();
    protected sealed virtual TypeAttributes GetAttributeFlagsImpl();
    public sealed virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    public sealed virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public sealed virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public sealed virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public sealed virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public sealed virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    public sealed virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public sealed virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public sealed virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public sealed virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public sealed virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    protected sealed virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    protected sealed virtual MethodInfo GetMethodImpl(string name, int genericParameterCount, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    protected sealed virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public sealed virtual MemberInfo[] FindMembers(MemberTypes memberType, BindingFlags bindingAttr, MemberFilter filter, object filterCriteria);
    public sealed virtual MemberInfo[] GetMember(string name, BindingFlags bindingAttr);
    public sealed virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public sealed virtual MemberInfo[] GetDefaultMembers();
    public sealed virtual EventInfo[] GetEvents();
    public sealed virtual Object[] GetCustomAttributes(bool inherit);
    public sealed virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public sealed virtual bool IsDefined(Type attributeType, bool inherit);
    public sealed virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public sealed virtual Type GetInterface(string name, bool ignoreCase);
    protected sealed virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    protected sealed virtual bool IsCOMObjectImpl();
    protected sealed virtual bool IsPrimitiveImpl();
    public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public sealed virtual Type[] FindInterfaces(TypeFilter filter, object filterCriteria);
    public sealed virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    protected sealed virtual bool IsContextfulImpl();
    public sealed virtual bool get_IsEnum();
    public sealed virtual bool IsEquivalentTo(Type other);
    public sealed virtual bool IsInstanceOfType(object o);
    protected sealed virtual bool IsMarshalByRefImpl();
    public sealed virtual bool get_IsSecurityCritical();
    public sealed virtual bool get_IsSecuritySafeCritical();
    public sealed virtual bool get_IsSecurityTransparent();
    public sealed virtual bool get_IsSerializable();
    public sealed virtual bool IsSubclassOf(Type c);
    protected sealed virtual bool IsValueTypeImpl();
    public sealed virtual StructLayoutAttribute get_StructLayoutAttribute();
    public sealed virtual RuntimeTypeHandle get_TypeHandle();
}
[ExtensionAttribute]
internal static class System.Reflection.SignatureTypeExtensions : object {
    [ExtensionAttribute]
public static bool MatchesParameterTypeExactly(Type pattern, ParameterInfo parameter);
    [ExtensionAttribute]
internal static bool MatchesExactly(SignatureType pattern, Type actual);
    [ExtensionAttribute]
internal static Type TryResolveAgainstGenericMethod(SignatureType signatureType, MethodInfo genericMethod);
    [ExtensionAttribute]
private static Type TryResolve(SignatureType signatureType, Type[] genericMethodParameters);
    [ExtensionAttribute]
private static Type TryMakeArrayType(Type type);
    [ExtensionAttribute]
private static Type TryMakeArrayType(Type type, int rank);
    [ExtensionAttribute]
private static Type TryMakeByRefType(Type type);
    [ExtensionAttribute]
private static Type TryMakePointerType(Type type);
    [ExtensionAttribute]
private static Type TryMakeGenericType(Type type, Type[] instantiation);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Reflection.StrongNameKeyPair : object {
    public Byte[] PublicKey { get; }
    public StrongNameKeyPair(FileStream keyPairFile);
    public StrongNameKeyPair(Byte[] keyPairArray);
    protected StrongNameKeyPair(SerializationInfo info, StreamingContext context);
    public StrongNameKeyPair(string keyPairContainer);
    public Byte[] get_PublicKey();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Reflection.TargetException : ApplicationException {
    public TargetException(string message);
    public TargetException(string message, Exception inner);
    [NullableContextAttribute("1")]
protected TargetException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Reflection.TargetInvocationException : ApplicationException {
    public TargetInvocationException(Exception inner);
    public TargetInvocationException(string message, Exception inner);
    internal TargetInvocationException(SerializationInfo info, StreamingContext context);
}
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableContextAttribute("2")]
public class System.Reflection.TargetParameterCountException : ApplicationException {
    public TargetParameterCountException(string message);
    public TargetParameterCountException(string message, Exception inner);
    internal TargetParameterCountException(SerializationInfo info, StreamingContext context);
}
[FlagsAttribute]
public enum System.Reflection.TypeAttributes : Enum {
    public int value__;
    public static TypeAttributes VisibilityMask;
    public static TypeAttributes NotPublic;
    public static TypeAttributes Public;
    public static TypeAttributes NestedPublic;
    public static TypeAttributes NestedPrivate;
    public static TypeAttributes NestedFamily;
    public static TypeAttributes NestedAssembly;
    public static TypeAttributes NestedFamANDAssem;
    public static TypeAttributes NestedFamORAssem;
    public static TypeAttributes LayoutMask;
    public static TypeAttributes AutoLayout;
    public static TypeAttributes SequentialLayout;
    public static TypeAttributes ExplicitLayout;
    public static TypeAttributes ClassSemanticsMask;
    public static TypeAttributes Class;
    public static TypeAttributes Interface;
    public static TypeAttributes Abstract;
    public static TypeAttributes Sealed;
    public static TypeAttributes SpecialName;
    public static TypeAttributes Import;
    public static TypeAttributes Serializable;
    public static TypeAttributes WindowsRuntime;
    public static TypeAttributes StringFormatMask;
    public static TypeAttributes AnsiClass;
    public static TypeAttributes UnicodeClass;
    public static TypeAttributes AutoClass;
    public static TypeAttributes CustomFormatClass;
    public static TypeAttributes CustomFormatMask;
    public static TypeAttributes BeforeFieldInit;
    public static TypeAttributes RTSpecialName;
    public static TypeAttributes HasSecurity;
    public static TypeAttributes ReservedMask;
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Reflection.TypeDelegator : TypeInfo {
    protected Type typeImpl;
    public Guid GUID { get; }
    public int MetadataToken { get; }
    public Module Module { get; }
    public Assembly Assembly { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public string Name { get; }
    [NullableAttribute("2")]
public string FullName { get; }
    [NullableAttribute("2")]
public string Namespace { get; }
    [NullableAttribute("2")]
public string AssemblyQualifiedName { get; }
    [NullableAttribute("2")]
public Type BaseType { get; }
    public bool IsTypeDefinition { get; }
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    public bool IsGenericTypeParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public bool IsByRefLike { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsCollectible { get; }
    public Type UnderlyingSystemType { get; }
    public TypeDelegator(Type delegatingType);
    [NullableContextAttribute("2")]
public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    public virtual Guid get_GUID();
    public virtual int get_MetadataToken();
    [NullableContextAttribute("2")]
public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public virtual Module get_Module();
    public virtual Assembly get_Assembly();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public virtual string get_Name();
    [NullableContextAttribute("2")]
public virtual string get_FullName();
    [NullableContextAttribute("2")]
public virtual string get_Namespace();
    [NullableContextAttribute("2")]
public virtual string get_AssemblyQualifiedName();
    [NullableContextAttribute("2")]
public virtual Type get_BaseType();
    [NullableContextAttribute("2")]
protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    [NullableContextAttribute("2")]
protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public virtual Type GetInterface(string name, bool ignoreCase);
    public virtual Type[] GetInterfaces();
    public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents();
    [NullableContextAttribute("2")]
protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    public virtual bool get_IsTypeDefinition();
    public virtual bool get_IsSZArray();
    public virtual bool get_IsVariableBoundArray();
    protected virtual bool IsArrayImpl();
    protected virtual bool IsPrimitiveImpl();
    protected virtual bool IsByRefImpl();
    public virtual bool get_IsGenericTypeParameter();
    public virtual bool get_IsGenericMethodParameter();
    protected virtual bool IsPointerImpl();
    protected virtual bool IsValueTypeImpl();
    protected virtual bool IsCOMObjectImpl();
    public virtual bool get_IsByRefLike();
    public virtual bool get_IsConstructedGenericType();
    public virtual bool get_IsCollectible();
    [NullableContextAttribute("2")]
public virtual Type GetElementType();
    protected virtual bool HasElementTypeImpl();
    public virtual Type get_UnderlyingSystemType();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
}
public class System.Reflection.TypeFilter : MulticastDelegate {
    public TypeFilter(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual bool Invoke(Type m, object filterCriteria);
    public virtual IAsyncResult BeginInvoke(Type m, object filterCriteria, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public abstract class System.Reflection.TypeInfo : Type {
    public Type[] GenericTypeParameters { get; }
    public IEnumerable`1<ConstructorInfo> DeclaredConstructors { get; }
    public IEnumerable`1<EventInfo> DeclaredEvents { get; }
    public IEnumerable`1<FieldInfo> DeclaredFields { get; }
    public IEnumerable`1<MemberInfo> DeclaredMembers { get; }
    public IEnumerable`1<MethodInfo> DeclaredMethods { get; }
    public IEnumerable`1<TypeInfo> DeclaredNestedTypes { get; }
    public IEnumerable`1<PropertyInfo> DeclaredProperties { get; }
    public IEnumerable`1<Type> ImplementedInterfaces { get; }
    private sealed virtual override TypeInfo System.Reflection.IReflectableType.GetTypeInfo();
    public virtual Type AsType();
    public virtual Type[] get_GenericTypeParameters();
    public virtual EventInfo GetDeclaredEvent(string name);
    public virtual FieldInfo GetDeclaredField(string name);
    public virtual MethodInfo GetDeclaredMethod(string name);
    public virtual TypeInfo GetDeclaredNestedType(string name);
    public virtual PropertyInfo GetDeclaredProperty(string name);
    [IteratorStateMachineAttribute("System.Reflection.TypeInfo/<GetDeclaredMethods>d__10")]
public virtual IEnumerable`1<MethodInfo> GetDeclaredMethods(string name);
    public virtual IEnumerable`1<ConstructorInfo> get_DeclaredConstructors();
    public virtual IEnumerable`1<EventInfo> get_DeclaredEvents();
    public virtual IEnumerable`1<FieldInfo> get_DeclaredFields();
    public virtual IEnumerable`1<MemberInfo> get_DeclaredMembers();
    public virtual IEnumerable`1<MethodInfo> get_DeclaredMethods();
    [IteratorStateMachineAttribute("System.Reflection.TypeInfo/<get_DeclaredNestedTypes>d__22")]
public virtual IEnumerable`1<TypeInfo> get_DeclaredNestedTypes();
    public virtual IEnumerable`1<PropertyInfo> get_DeclaredProperties();
    public virtual IEnumerable`1<Type> get_ImplementedInterfaces();
    [NullableContextAttribute("2")]
public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    internal static string GetRankString(int rank);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.ResolveEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Assembly <RequestingAssembly>k__BackingField;
    public string Name { get; }
    public Assembly RequestingAssembly { get; }
    public ResolveEventArgs(string name);
    public ResolveEventArgs(string name, Assembly requestingAssembly);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Assembly get_RequestingAssembly();
}
public class System.ResolveEventHandler : MulticastDelegate {
    public ResolveEventHandler(object object, IntPtr method);
    [NullableContextAttribute("2")]
public virtual Assembly Invoke(object sender, ResolveEventArgs args);
    public virtual IAsyncResult BeginInvoke(object sender, ResolveEventArgs args, AsyncCallback callback, object object);
    public virtual Assembly EndInvoke(IAsyncResult result);
}
internal abstract class System.Resolver : object {
    internal abstract virtual RuntimeType GetJitContext(Int32& securityControlFlags);
    internal abstract virtual Byte[] GetCodeInfo(Int32& stackSize, Int32& initLocals, Int32& EHCount);
    internal abstract virtual Byte[] GetLocalsSignature();
    internal abstract virtual void GetEHInfo(int EHNumber, Void* exception);
    internal abstract virtual Byte[] GetRawEHInfo();
    internal abstract virtual string GetStringLiteral(int token);
    internal abstract virtual void ResolveToken(int token, IntPtr& typeHandle, IntPtr& methodHandle, IntPtr& fieldHandle);
    internal abstract virtual Byte[] ResolveSignature(int token, int fromMethod);
    internal abstract virtual MethodInfo GetDynamicMethod();
}
internal class System.Resources.FastResourceComparer : object {
    internal static FastResourceComparer Default;
    private static FastResourceComparer();
    public sealed virtual int GetHashCode(object key);
    public sealed virtual int GetHashCode(string key);
    internal static int HashFunction(string key);
    public sealed virtual int Compare(object a, object b);
    public sealed virtual int Compare(string a, string b);
    public sealed virtual bool Equals(string a, string b);
    public sealed virtual bool Equals(object a, object b);
    public static int CompareOrdinal(string a, Byte[] bytes, int bCharLength);
    public static int CompareOrdinal(Byte[] bytes, int aCharLength, string b);
    internal static int CompareOrdinal(Byte* a, int byteLen, string b);
}
internal class System.Resources.FileBasedResourceGroveler : object {
    private ResourceManagerMediator _mediator;
    public FileBasedResourceGroveler(ResourceManagerMediator mediator);
    public sealed virtual ResourceSet GrovelForResourceSet(CultureInfo culture, Dictionary`2<string, ResourceSet> localResourceSets, bool tryParents, bool createIfNotExists);
    private string FindResourceFile(CultureInfo culture, string fileName);
    private ResourceSet CreateResourceSet(string file);
}
internal interface System.Resources.IResourceGroveler {
    public abstract virtual ResourceSet GrovelForResourceSet(CultureInfo culture, Dictionary`2<string, ResourceSet> localResourceSets, bool tryParents, bool createIfNotExists);
}
public interface System.Resources.IResourceReader {
    public abstract virtual void Close();
    [NullableContextAttribute("1")]
public abstract virtual IDictionaryEnumerator GetEnumerator();
}
internal class System.Resources.ManifestBasedResourceGroveler : object {
    private ResourceManagerMediator _mediator;
    public ManifestBasedResourceGroveler(ResourceManagerMediator mediator);
    private static Assembly InternalGetSatelliteAssembly(Assembly mainAssembly, CultureInfo culture, Version version);
    public sealed virtual ResourceSet GrovelForResourceSet(CultureInfo culture, Dictionary`2<string, ResourceSet> localResourceSets, bool tryParents, bool createIfNotExists);
    private CultureInfo UltimateFallbackFixup(CultureInfo lookForCulture);
    internal static CultureInfo GetNeutralResourcesLanguage(Assembly a, UltimateResourceFallbackLocation& fallbackLocation);
    internal ResourceSet CreateResourceSet(Stream store, Assembly assembly);
    private Stream GetManifestResourceStream(Assembly satellite, string fileName);
    private Stream CaseInsensitiveManifestResourceStreamLookup(Assembly satellite, string name);
    private Assembly GetSatelliteAssembly(CultureInfo lookForCulture);
    private bool CanUseDefaultResourceClasses(string readerTypeName, string resSetTypeName);
    private void HandleSatelliteMissing();
    private static string GetManifestResourceNamesList(Assembly assembly);
    private void HandleResourceStreamMissing(string fileName);
}
[NullableAttribute("0")]
[NullableContextAttribute("2")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Resources.MissingManifestResourceException : SystemException {
    public MissingManifestResourceException(string message);
    public MissingManifestResourceException(string message, Exception inner);
    [NullableContextAttribute("1")]
protected MissingManifestResourceException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableAttribute("0")]
[NullableContextAttribute("2")]
public class System.Resources.MissingSatelliteAssemblyException : SystemException {
    private string _cultureName;
    public string CultureName { get; }
    public MissingSatelliteAssemblyException(string message);
    public MissingSatelliteAssemblyException(string message, string cultureName);
    public MissingSatelliteAssemblyException(string message, Exception inner);
    [NullableContextAttribute("1")]
protected MissingSatelliteAssemblyException(SerializationInfo info, StreamingContext context);
    public string get_CultureName();
}
[AttributeUsageAttribute("1")]
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Resources.NeutralResourcesLanguageAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <CultureName>k__BackingField;
    [CompilerGeneratedAttribute]
private UltimateResourceFallbackLocation <Location>k__BackingField;
    public string CultureName { get; }
    public UltimateResourceFallbackLocation Location { get; }
    public NeutralResourcesLanguageAttribute(string cultureName);
    public NeutralResourcesLanguageAttribute(string cultureName, UltimateResourceFallbackLocation location);
    [CompilerGeneratedAttribute]
public string get_CultureName();
    [CompilerGeneratedAttribute]
public UltimateResourceFallbackLocation get_Location();
}
internal class System.Resources.ResourceFallbackManager : object {
    private CultureInfo m_startingCulture;
    private CultureInfo m_neutralResourcesCulture;
    private bool m_useParents;
    internal ResourceFallbackManager(CultureInfo startingCulture, CultureInfo neutralResourcesCulture, bool useParents);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [IteratorStateMachineAttribute("System.Resources.ResourceFallbackManager/<GetEnumerator>d__5")]
public sealed virtual IEnumerator`1<CultureInfo> GetEnumerator();
}
internal class System.Resources.ResourceLocator : ValueType {
    internal object _value;
    internal int _dataPos;
    internal int DataPosition { get; }
    internal object Value { get; internal set; }
    internal ResourceLocator(int dataPos, object value);
    internal int get_DataPosition();
    internal object get_Value();
    internal void set_Value(object value);
    internal static bool CanCache(ResourceTypeCode value);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Resources.ResourceManager : object {
    protected string BaseNameField;
    [NullableAttribute("2")]
protected Assembly MainAssembly;
    private Dictionary`2<string, ResourceSet> _resourceSets;
    private string _moduleDir;
    private Type _locationInfo;
    private Type _userResourceSet;
    private CultureInfo _neutralResourcesCulture;
    private CultureNameResourceSetPair _lastUsedResourceCache;
    private bool _ignoreCase;
    private bool _useManifest;
    private UltimateResourceFallbackLocation _fallbackLoc;
    private Version _satelliteContractVersion;
    private bool _lookedForSatelliteContractVersion;
    private IResourceGroveler _resourceGroveler;
    public static int MagicNumber;
    public static int HeaderVersionNumber;
    private static Type s_minResourceSet;
    private WindowsRuntimeResourceManagerBase _WinRTResourceManager;
    private PRIExceptionInfo _PRIExceptionInfo;
    private bool _PRIInitialized;
    private bool _useUapResourceManagement;
    public string BaseName { get; }
    public bool IgnoreCase { get; public set; }
    public Type ResourceSetType { get; }
    protected UltimateResourceFallbackLocation FallbackLocation { get; protected set; }
    private ResourceManager(string baseName, string resourceDir, Type userResourceSet);
    public ResourceManager(string baseName, Assembly assembly);
    public ResourceManager(string baseName, Assembly assembly, Type usingResourceSet);
    public ResourceManager(Type resourceSource);
    private static ResourceManager();
    private void CommonAssemblyInit();
    public virtual string get_BaseName();
    public virtual bool get_IgnoreCase();
    public virtual void set_IgnoreCase(bool value);
    public virtual Type get_ResourceSetType();
    protected UltimateResourceFallbackLocation get_FallbackLocation();
    protected void set_FallbackLocation(UltimateResourceFallbackLocation value);
    public virtual void ReleaseAllResources();
    public static ResourceManager CreateFileBasedResourceManager(string baseName, string resourceDir, Type usingResourceSet);
    protected virtual string GetResourceFileName(CultureInfo culture);
    internal ResourceSet GetFirstResourceSet(CultureInfo culture);
    public virtual ResourceSet GetResourceSet(CultureInfo culture, bool createIfNotExists, bool tryParents);
    protected virtual ResourceSet InternalGetResourceSet(CultureInfo culture, bool createIfNotExists, bool tryParents);
    private static void AddResourceSet(Dictionary`2<string, ResourceSet> localResourceSets, string cultureName, ResourceSet& rs);
    protected static Version GetSatelliteContractVersion(Assembly a);
    protected static CultureInfo GetNeutralResourcesLanguage(Assembly a);
    internal static bool IsDefaultType(string asmTypeName, string typeName);
    public virtual string GetString(string name);
    [NullableContextAttribute("2")]
public virtual string GetString(string name, CultureInfo culture);
    public virtual object GetObject(string name);
    [NullableContextAttribute("2")]
public virtual object GetObject(string name, CultureInfo culture);
    private object GetObject(string name, CultureInfo culture, bool wrapUnmanagedMemStream);
    public UnmanagedMemoryStream GetStream(string name);
    [NullableContextAttribute("2")]
public UnmanagedMemoryStream GetStream(string name, CultureInfo culture);
    private string GetStringFromPRI(string stringName, CultureInfo culture, string neutralResourcesCulture);
    internal static WindowsRuntimeResourceManagerBase GetWinRTResourceManager();
    private static bool ShouldUseUapResourceManagement(Assembly resourcesAssembly);
    private void SetUapConfiguration();
}
public class System.Resources.ResourceReader : object {
    private BinaryReader _store;
    internal Dictionary`2<string, ResourceLocator> _resCache;
    private long _nameSectionOffset;
    private long _dataSectionOffset;
    private Int32[] _nameHashes;
    private Int32* _nameHashesPtr;
    private Int32[] _namePositions;
    private Int32* _namePositionsPtr;
    private Type[] _typeTable;
    private Int32[] _typeNamePositions;
    private int _numResources;
    private UnmanagedMemoryStream _ums;
    private int _version;
    private bool _permitDeserialization;
    private object _binaryFormatter;
    private static Type s_binaryFormatterType;
    private static Func`3<object, Stream, object> s_deserializeMethod;
    [NullableContextAttribute("1")]
public ResourceReader(string fileName);
    [NullableContextAttribute("1")]
public ResourceReader(Stream stream);
    internal ResourceReader(Stream stream, Dictionary`2<string, ResourceLocator> resCache, bool permitDeserialization);
    public sealed virtual void Close();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    internal static int ReadUnalignedI4(Int32* p);
    private void SkipString();
    private int GetNameHash(int index);
    private int GetNamePosition(int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [NullableContextAttribute("1")]
public sealed virtual IDictionaryEnumerator GetEnumerator();
    internal ResourceEnumerator GetEnumeratorInternal();
    internal int FindPosForResource(string name);
    private bool CompareStringEqualsName(string name);
    private string AllocateStringForNameIndex(int index, Int32& dataOffset);
    private object GetValueForNameIndex(int index);
    internal string LoadString(int pos);
    internal object LoadObject(int pos);
    internal object LoadObject(int pos, ResourceTypeCode& typeCode);
    internal object LoadObjectV1(int pos);
    private object _LoadObjectV1(int pos);
    internal object LoadObjectV2(int pos, ResourceTypeCode& typeCode);
    private object _LoadObjectV2(int pos, ResourceTypeCode& typeCode);
    private void ReadResources();
    private void _ReadResources();
    private Type FindType(int typeIndex);
    private string TypeNameFromTypeCode(ResourceTypeCode typeCode);
    private object DeserializeObject(int typeIndex);
    private void InitializeBinaryFormatter();
    private static Func`3<object, Stream, object> CreateUntypedDelegate(MethodInfo method);
    private bool ValidateReaderType(string readerType);
    [NullableContextAttribute("1")]
public void GetResourceData(string resourceName, String& resourceType, Byte[]& resourceData);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Resources.ResourceSet : object {
    protected IResourceReader Reader;
    internal Hashtable Table;
    private Hashtable _caseInsensitiveTable;
    internal ResourceSet(bool junk);
    public ResourceSet(string fileName);
    public ResourceSet(Stream stream);
    public ResourceSet(IResourceReader reader);
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    public virtual Type GetDefaultReader();
    public virtual Type GetDefaultWriter();
    public virtual IDictionaryEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private IDictionaryEnumerator GetEnumeratorHelper();
    public virtual string GetString(string name);
    public virtual string GetString(string name, bool ignoreCase);
    public virtual object GetObject(string name);
    public virtual object GetObject(string name, bool ignoreCase);
    protected virtual void ReadResources();
    private object GetObjectInternal(string name);
    private object GetCaseInsensitiveObjectInternal(string name);
}
internal enum System.Resources.ResourceTypeCode : Enum {
    public int value__;
    public static ResourceTypeCode Null;
    public static ResourceTypeCode String;
    public static ResourceTypeCode Boolean;
    public static ResourceTypeCode Char;
    public static ResourceTypeCode Byte;
    public static ResourceTypeCode SByte;
    public static ResourceTypeCode Int16;
    public static ResourceTypeCode UInt16;
    public static ResourceTypeCode Int32;
    public static ResourceTypeCode UInt32;
    public static ResourceTypeCode Int64;
    public static ResourceTypeCode UInt64;
    public static ResourceTypeCode Single;
    public static ResourceTypeCode Double;
    public static ResourceTypeCode Decimal;
    public static ResourceTypeCode DateTime;
    public static ResourceTypeCode TimeSpan;
    public static ResourceTypeCode LastPrimitive;
    public static ResourceTypeCode ByteArray;
    public static ResourceTypeCode Stream;
    public static ResourceTypeCode StartOfUserTypes;
}
internal class System.Resources.RuntimeResourceSet : ResourceSet {
    private Dictionary`2<string, ResourceLocator> _resCache;
    private ResourceReader _defaultReader;
    private Dictionary`2<string, ResourceLocator> _caseInsensitiveTable;
    private bool _haveReadFromReader;
    internal RuntimeResourceSet(string fileName);
    internal RuntimeResourceSet(Stream stream, bool permitDeserialization);
    protected virtual void Dispose(bool disposing);
    public virtual IDictionaryEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private IDictionaryEnumerator GetEnumeratorHelper();
    public virtual string GetString(string key);
    public virtual string GetString(string key, bool ignoreCase);
    public virtual object GetObject(string key);
    public virtual object GetObject(string key, bool ignoreCase);
    private object GetObject(string key, bool ignoreCase, bool isString);
    private object ResolveResourceLocator(ResourceLocator resLocation, string key, Dictionary`2<string, ResourceLocator> copyOfCache, bool keyInWrongCase);
}
[AttributeUsageAttribute("1")]
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Resources.SatelliteContractVersionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    public string Version { get; }
    public SatelliteContractVersionAttribute(string version);
    [CompilerGeneratedAttribute]
public string get_Version();
}
public enum System.Resources.UltimateResourceFallbackLocation : Enum {
    public int value__;
    public static UltimateResourceFallbackLocation MainAssembly;
    public static UltimateResourceFallbackLocation Satellite;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("System.Runtime, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class System.Runtime.AmbiguousImplementationException : Exception {
    public AmbiguousImplementationException(string message);
    public AmbiguousImplementationException(string message, Exception innerException);
    private AmbiguousImplementationException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("256")]
public class System.Runtime.CompilerServices.AccessedThroughPropertyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    public string PropertyName { get; }
    public AccessedThroughPropertyAttribute(string propertyName);
    [CompilerGeneratedAttribute]
public string get_PropertyName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Runtime.CompilerServices.AsyncIteratorMethodBuilder : ValueType {
    private AsyncTaskMethodBuilder _methodBuilder;
    internal object ObjectIdForDebugger { get; }
    public static AsyncIteratorMethodBuilder Create();
    public void MoveNext(TStateMachine& stateMachine);
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void Complete();
    internal object get_ObjectIdForDebugger();
}
[AttributeUsageAttribute("64")]
public class System.Runtime.CompilerServices.AsyncIteratorStateMachineAttribute : StateMachineAttribute {
    [NullableContextAttribute("1")]
public AsyncIteratorStateMachineAttribute(Type stateMachineType);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
[AttributeUsageAttribute("5148")]
public class System.Runtime.CompilerServices.AsyncMethodBuilderAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <BuilderType>k__BackingField;
    public Type BuilderType { get; }
    public AsyncMethodBuilderAttribute(Type builderType);
    [CompilerGeneratedAttribute]
public Type get_BuilderType();
}
internal static class System.Runtime.CompilerServices.AsyncMethodBuilderCore : object {
    internal static bool TrackAsyncMethodCompletion { get; }
    [DebuggerStepThroughAttribute]
public static void Start(TStateMachine& stateMachine);
    public static void SetStateMachine(IAsyncStateMachine stateMachine, Task task);
    internal static bool get_TrackAsyncMethodCompletion();
    internal static string GetAsyncStateMachineDescription(IAsyncStateMachine stateMachine);
    internal static Action CreateContinuationWrapper(Action continuation, Action`2<Action, Task> invokeAction, Task innerTask);
    internal static Action TryGetStateMachineForDebugger(Action action);
    internal static Task TryGetContinuationTask(Action continuation);
}
[AttributeUsageAttribute("64")]
public class System.Runtime.CompilerServices.AsyncStateMachineAttribute : StateMachineAttribute {
    [NullableContextAttribute("1")]
public AsyncStateMachineAttribute(Type stateMachineType);
}
internal static class System.Runtime.CompilerServices.AsyncTaskCache : object {
    internal static Task`1<bool> TrueTask;
    internal static Task`1<bool> FalseTask;
    internal static Task`1[] Int32Tasks;
    private static AsyncTaskCache();
    private static Task`1[] CreateInt32Tasks();
    internal static Task`1<TResult> CreateCacheableTask(TResult result);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Runtime.CompilerServices.AsyncTaskMethodBuilder : ValueType {
    private static Task`1<VoidTaskResult> s_cachedCompleted;
    private AsyncTaskMethodBuilder`1<VoidTaskResult> m_builder;
    public Task Task { get; }
    internal object ObjectIdForDebugger { get; }
    private static AsyncTaskMethodBuilder();
    public static AsyncTaskMethodBuilder Create();
    [DebuggerStepThroughAttribute]
public void Start(TStateMachine& stateMachine);
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public Task get_Task();
    public void SetResult();
    public void SetException(Exception exception);
    internal void SetNotificationForWaitCompletion(bool enabled);
    internal object get_ObjectIdForDebugger();
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1 : ValueType {
    internal static Task`1<TResult> s_defaultResultTask;
    private Task`1<TResult> m_task;
    public Task`1<TResult> Task { get; }
    internal object ObjectIdForDebugger { get; }
    private static AsyncTaskMethodBuilder`1();
    public static AsyncTaskMethodBuilder`1<TResult> Create();
    [DebuggerStepThroughAttribute]
public void Start(TStateMachine& stateMachine);
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    private IAsyncStateMachineBox GetStateMachineBox(TStateMachine& stateMachine);
    private static AsyncStateMachineBox`1<TResult, TStateMachine> CreateDebugFinalizableAsyncStateMachineBox();
    public Task`1<TResult> get_Task();
    private Task`1<TResult> InitializeTaskAsPromise();
    private Task`1<TResult> InitializeTaskAsStateMachineBox();
    public void SetResult(TResult result);
    private void SetExistingTaskResult(TResult result);
    internal void SetResult(Task`1<TResult> completedTask);
    public void SetException(Exception exception);
    internal void SetNotificationForWaitCompletion(bool enabled);
    internal object get_ObjectIdForDebugger();
    internal static Task`1<TResult> GetTaskForResult(TResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder : ValueType {
    private AsyncTaskMethodBuilder _methodBuilder;
    private bool _haveResult;
    private bool _useBuilder;
    public ValueTask Task { get; }
    public static AsyncValueTaskMethodBuilder Create();
    public void Start(TStateMachine& stateMachine);
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    public void SetResult();
    public void SetException(Exception exception);
    public ValueTask get_Task();
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder`1 : ValueType {
    private AsyncTaskMethodBuilder`1<TResult> _methodBuilder;
    private TResult _result;
    private bool _haveResult;
    private bool _useBuilder;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueTask`1<TResult> Task { get; }
    public static AsyncValueTaskMethodBuilder`1<TResult> Create();
    public void Start(TStateMachine& stateMachine);
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    public void SetResult(TResult result);
    public void SetException(Exception exception);
    public ValueTask`1<TResult> get_Task();
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Runtime.CompilerServices.AsyncVoidMethodBuilder : ValueType {
    private SynchronizationContext _synchronizationContext;
    private AsyncTaskMethodBuilder _builder;
    private Task Task { get; }
    internal object ObjectIdForDebugger { get; }
    public static AsyncVoidMethodBuilder Create();
    [DebuggerStepThroughAttribute]
public void Start(TStateMachine& stateMachine);
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void SetResult();
    public void SetException(Exception exception);
    private void NotifySynchronizationContextOfCompletion();
    private Task get_Task();
    internal object get_ObjectIdForDebugger();
}
[AttributeUsageAttribute("2048")]
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Runtime.CompilerServices.CallerArgumentExpressionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public CallerArgumentExpressionAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.CompilerServices.CallerFilePathAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.CompilerServices.CallerLineNumberAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.CompilerServices.CallerMemberNameAttribute : Attribute {
}
[FlagsAttribute]
public enum System.Runtime.CompilerServices.CompilationRelaxations : Enum {
    public int value__;
    public static CompilationRelaxations NoStringInterning;
}
[AttributeUsageAttribute("71")]
public class System.Runtime.CompilerServices.CompilationRelaxationsAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <CompilationRelaxations>k__BackingField;
    public int CompilationRelaxations { get; }
    public CompilationRelaxationsAttribute(int relaxations);
    public CompilationRelaxationsAttribute(CompilationRelaxations relaxations);
    [CompilerGeneratedAttribute]
public int get_CompilationRelaxations();
}
[AttributeUsageAttribute("32767")]
public class System.Runtime.CompilerServices.CompilerGeneratedAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
public class System.Runtime.CompilerServices.CompilerGlobalScopeAttribute : Attribute {
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Runtime.CompilerServices.ConditionalWeakTable`2 : object {
    private object _lock;
    private Container modreq(System.Runtime.CompilerServices.IsVolatile) _container;
    private int _activeEnumeratorRefCount;
    public bool TryGetValue(TKey key, TValue& value);
    public void Add(TKey key, TValue value);
    public void AddOrUpdate(TKey key, TValue value);
    public bool Remove(TKey key);
    public void Clear();
    public TValue GetValue(TKey key, CreateValueCallback<TKey, TValue> createValueCallback);
    private TValue GetValueLocked(TKey key, CreateValueCallback<TKey, TValue> createValueCallback);
    public TValue GetOrCreateValue(TKey key);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private void CreateEntry(TKey key, TValue value);
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ConfiguredAsyncDisposable : ValueType {
    private IAsyncDisposable _source;
    private bool _continueOnCapturedContext;
    internal ConfiguredAsyncDisposable(IAsyncDisposable source, bool continueOnCapturedContext);
    public ConfiguredValueTaskAwaitable DisposeAsync();
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ConfiguredCancelableAsyncEnumerable`1 : ValueType {
    private IAsyncEnumerable`1<T> _enumerable;
    private CancellationToken _cancellationToken;
    private bool _continueOnCapturedContext;
    internal ConfiguredCancelableAsyncEnumerable`1(IAsyncEnumerable`1<T> enumerable, bool continueOnCapturedContext, CancellationToken cancellationToken);
    public ConfiguredCancelableAsyncEnumerable`1<T> ConfigureAwait(bool continueOnCapturedContext);
    public ConfiguredCancelableAsyncEnumerable`1<T> WithCancellation(CancellationToken cancellationToken);
    public Enumerator<T> GetAsyncEnumerator();
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ConfiguredTaskAwaitable : ValueType {
    private ConfiguredTaskAwaiter m_configuredTaskAwaiter;
    internal ConfiguredTaskAwaitable(Task task, bool continueOnCapturedContext);
    public ConfiguredTaskAwaiter GetAwaiter();
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1 : ValueType {
    private ConfiguredTaskAwaiter<TResult> m_configuredTaskAwaiter;
    internal ConfiguredTaskAwaitable`1(Task`1<TResult> task, bool continueOnCapturedContext);
    public ConfiguredTaskAwaiter<TResult> GetAwaiter();
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable : ValueType {
    private ValueTask _value;
    internal ConfiguredValueTaskAwaitable(ValueTask& value);
    public ConfiguredValueTaskAwaiter GetAwaiter();
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable`1 : ValueType {
    private ValueTask`1<TResult> _value;
    internal ConfiguredValueTaskAwaitable`1(ValueTask`1& value);
    public ConfiguredValueTaskAwaiter<TResult> GetAwaiter();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class System.Runtime.CompilerServices.ContractHelper : object {
    [CompilerGeneratedAttribute]
private static EventHandler`1<ContractFailedEventArgs> InternalContractFailed;
    [CompilerGeneratedAttribute]
internal static void add_InternalContractFailed(EventHandler`1<ContractFailedEventArgs> value);
    [CompilerGeneratedAttribute]
internal static void remove_InternalContractFailed(EventHandler`1<ContractFailedEventArgs> value);
    [DebuggerNonUserCodeAttribute]
public static string RaiseContractFailedEvent(ContractFailureKind failureKind, string userMessage, string conditionText, Exception innerException);
    [DebuggerNonUserCodeAttribute]
public static void TriggerFailure(ContractFailureKind kind, string displayMessage, string userMessage, string conditionText, Exception innerException);
    private static string GetFailureMessage(ContractFailureKind failureKind, string conditionText);
    private static string GetDisplayMessage(ContractFailureKind failureKind, string userMessage, string conditionText);
}
[AttributeUsageAttribute("2304")]
[NullableAttribute("0")]
[NullableContextAttribute("2")]
public abstract class System.Runtime.CompilerServices.CustomConstantAttribute : Attribute {
    public object Value { get; }
    public abstract virtual object get_Value();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2304")]
public class System.Runtime.CompilerServices.DateTimeConstantAttribute : CustomConstantAttribute {
    private DateTime _date;
    public object Value { get; }
    public DateTimeConstantAttribute(long ticks);
    public virtual object get_Value();
}
[AttributeUsageAttribute("2304")]
public class System.Runtime.CompilerServices.DecimalConstantAttribute : Attribute {
    private decimal _dec;
    public decimal Value { get; }
    [CLSCompliantAttribute("False")]
public DecimalConstantAttribute(byte scale, byte sign, UInt32 hi, UInt32 mid, UInt32 low);
    public DecimalConstantAttribute(byte scale, byte sign, int hi, int mid, int low);
    public decimal get_Value();
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.DefaultDependencyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private LoadHint <LoadHint>k__BackingField;
    public LoadHint LoadHint { get; }
    public DefaultDependencyAttribute(LoadHint loadHintArgument);
    [CompilerGeneratedAttribute]
public LoadHint get_LoadHint();
}
[AttributeUsageAttribute("1")]
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Runtime.CompilerServices.DependencyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <DependentAssembly>k__BackingField;
    [CompilerGeneratedAttribute]
private LoadHint <LoadHint>k__BackingField;
    public string DependentAssembly { get; }
    public LoadHint LoadHint { get; }
    public DependencyAttribute(string dependentAssemblyArgument, LoadHint loadHintArgument);
    [CompilerGeneratedAttribute]
public string get_DependentAssembly();
    [CompilerGeneratedAttribute]
public LoadHint get_LoadHint();
}
internal class System.Runtime.CompilerServices.DependentHandle : ValueType {
    private IntPtr _handle;
    public bool IsAllocated { get; }
    public DependentHandle(object primary, object secondary);
    public bool get_IsAllocated();
    public object GetPrimary();
    public object GetPrimaryAndSecondary(Object& secondary);
    public void SetPrimary(object primary);
    public void SetSecondary(object secondary);
    public void Free();
    private static IntPtr nInitialize(object primary, object secondary);
    private static object nGetPrimary(IntPtr dependentHandle);
    private static object nGetPrimaryAndSecondary(IntPtr dependentHandle, Object& secondary);
    private static void nSetPrimary(IntPtr dependentHandle, object primary);
    private static void nSetSecondary(IntPtr dependentHandle, object secondary);
    private static void nFree(IntPtr dependentHandle);
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.DisablePrivateReflectionAttribute : Attribute {
}
public class System.Runtime.CompilerServices.DiscardableAttribute : Attribute {
}
[AttributeUsageAttribute("69")]
public class System.Runtime.CompilerServices.ExtensionAttribute : Attribute {
}
[AttributeUsageAttribute("256")]
public class System.Runtime.CompilerServices.FixedAddressValueTypeAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("256")]
public class System.Runtime.CompilerServices.FixedBufferAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <ElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    public Type ElementType { get; }
    public int Length { get; }
    public FixedBufferAttribute(Type elementType, int length);
    [CompilerGeneratedAttribute]
public Type get_ElementType();
    [CompilerGeneratedAttribute]
public int get_Length();
}
public static class System.Runtime.CompilerServices.FormattableStringFactory : object {
    [NullableContextAttribute("1")]
public static FormattableString Create(string format, Object[] arguments);
}
internal class System.Runtime.CompilerServices.GCHeapHash : object {
    private Array _data;
    private int _count;
    private int _deletedCount;
}
[NullableContextAttribute("1")]
public interface System.Runtime.CompilerServices.IAsyncStateMachine {
    public abstract virtual void MoveNext();
    public abstract virtual void SetStateMachine(IAsyncStateMachine stateMachine);
}
internal interface System.Runtime.CompilerServices.IAsyncStateMachineBox {
    public Action MoveNextAction { get; }
    public abstract virtual void MoveNext();
    public abstract virtual Action get_MoveNextAction();
    public abstract virtual IAsyncStateMachine GetStateMachineObject();
}
[NullableContextAttribute("2")]
public interface System.Runtime.CompilerServices.ICastable {
    public abstract virtual bool IsInstanceOfInterface(RuntimeTypeHandle interfaceType, Exception& castError);
    public abstract virtual RuntimeTypeHandle GetImplType(RuntimeTypeHandle interfaceType);
}
internal class System.Runtime.CompilerServices.ICastableHelpers : object {
    internal static bool IsInstanceOfInterface(ICastable castable, RuntimeType type, Exception& castError);
    internal static RuntimeType GetImplType(ICastable castable, RuntimeType interfaceType);
}
internal interface System.Runtime.CompilerServices.IConfiguredTaskAwaiter {
}
public interface System.Runtime.CompilerServices.ICriticalNotifyCompletion {
    [NullableContextAttribute("1")]
public abstract virtual void UnsafeOnCompleted(Action continuation);
}
[AttributeUsageAttribute("128")]
public class System.Runtime.CompilerServices.IndexerNameAttribute : Attribute {
    [NullableContextAttribute("1")]
public IndexerNameAttribute(string indexerName);
}
[NullableContextAttribute("1")]
public interface System.Runtime.CompilerServices.INotifyCompletion {
    public abstract virtual void OnCompleted(Action continuation);
}
[AttributeUsageAttribute("1")]
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Runtime.CompilerServices.InternalsVisibleToAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllInternalsVisible>k__BackingField;
    public string AssemblyName { get; }
    public bool AllInternalsVisible { get; public set; }
    public InternalsVisibleToAttribute(string assemblyName);
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public bool get_AllInternalsVisible();
    [CompilerGeneratedAttribute]
public void set_AllInternalsVisible(bool value);
}
[AttributeUsageAttribute("364")]
internal class System.Runtime.CompilerServices.IntrinsicAttribute : Attribute {
}
[AttributeUsageAttribute("8")]
[EditorBrowsableAttribute("1")]
public class System.Runtime.CompilerServices.IsByRefLikeAttribute : Attribute {
}
public static class System.Runtime.CompilerServices.IsConst : object {
}
[EditorBrowsableAttribute("1")]
[AttributeUsageAttribute("32767")]
public class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
internal interface System.Runtime.CompilerServices.IStateMachineBoxAwareAwaiter {
    public abstract virtual void AwaitUnsafeOnCompleted(IAsyncStateMachineBox box);
}
[NullableContextAttribute("2")]
public interface System.Runtime.CompilerServices.IStrongBox {
    public object Value { get; public set; }
    public abstract virtual object get_Value();
    public abstract virtual void set_Value(object value);
}
public static class System.Runtime.CompilerServices.IsVolatile : object {
}
internal interface System.Runtime.CompilerServices.ITaskAwaiter {
}
[AttributeUsageAttribute("64")]
public class System.Runtime.CompilerServices.IteratorStateMachineAttribute : StateMachineAttribute {
    [NullableContextAttribute("1")]
public IteratorStateMachineAttribute(Type stateMachineType);
}
[NullableContextAttribute("2")]
[DefaultMemberAttribute("Item")]
public interface System.Runtime.CompilerServices.ITuple {
    public int Length { get; }
    public object Item { get; }
    public abstract virtual int get_Length();
    public abstract virtual object get_Item(int index);
}
[ExtensionAttribute]
internal static class System.Runtime.CompilerServices.JitHelpers : object {
    internal static StringHandleOnStack GetStringHandleOnStack(String& s);
    internal static ObjectHandleOnStack GetObjectHandleOnStack(T& o);
    internal static QCallModule GetQCallModuleOnStack(RuntimeModule& module);
    internal static QCallModule GetQCallModuleOnStack(ModuleBuilder& module);
    internal static QCallAssembly GetQCallAssemblyOnStack(RuntimeAssembly& assembly);
    internal static QCallTypeHandle GetQCallTypeHandleOnStack(RuntimeTypeHandle& rth);
    internal static QCallTypeHandle GetQCallTypeHandleOnStack(RuntimeType& type);
    internal static StackCrawlMarkHandle GetStackCrawlMarkHandle(StackCrawlMark& stackMark);
    internal static bool EnumEquals(T x, T y);
    internal static int EnumCompareTo(T x, T y);
    [ExtensionAttribute]
internal static Byte& GetRawData(object obj);
    [ExtensionAttribute]
internal static Byte& GetRawSzArrayData(Array array);
}
internal class System.Runtime.CompilerServices.LAHashDependentHashTracker : object {
    private GCHandle _dependentHandle;
    private IntPtr _loaderAllocator;
    protected virtual override void Finalize();
}
internal class System.Runtime.CompilerServices.LAHashKeyToTrackers : object {
    private object _trackerOrTrackerSet;
    private object _laLocalKeyValueStore;
}
public enum System.Runtime.CompilerServices.LoadHint : Enum {
    public int value__;
    public static LoadHint Default;
    public static LoadHint Always;
    public static LoadHint Sometimes;
}
public enum System.Runtime.CompilerServices.MethodCodeType : Enum {
    public int value__;
    public static MethodCodeType IL;
    public static MethodCodeType Native;
    public static MethodCodeType OPTIL;
    public static MethodCodeType Runtime;
}
[AttributeUsageAttribute("96")]
public class System.Runtime.CompilerServices.MethodImplAttribute : Attribute {
    public MethodCodeType MethodCodeType;
    [CompilerGeneratedAttribute]
private MethodImplOptions <Value>k__BackingField;
    public MethodImplOptions Value { get; }
    public MethodImplAttribute(MethodImplOptions methodImplOptions);
    public MethodImplAttribute(short value);
    [CompilerGeneratedAttribute]
public MethodImplOptions get_Value();
}
[FlagsAttribute]
public enum System.Runtime.CompilerServices.MethodImplOptions : Enum {
    public int value__;
    public static MethodImplOptions Unmanaged;
    public static MethodImplOptions NoInlining;
    public static MethodImplOptions ForwardRef;
    public static MethodImplOptions Synchronized;
    public static MethodImplOptions NoOptimization;
    public static MethodImplOptions PreserveSig;
    public static MethodImplOptions AggressiveInlining;
    public static MethodImplOptions AggressiveOptimization;
    public static MethodImplOptions InternalCall;
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5198")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[AttributeUsageAttribute("2")]
[EmbeddedAttribute]
[CompilerGeneratedAttribute]
internal class System.Runtime.CompilerServices.NullablePublicOnlyAttribute : Attribute {
    public bool IncludesInternals;
    public NullablePublicOnlyAttribute(bool );
}
internal class System.Runtime.CompilerServices.ObjectHandleOnStack : ValueType {
    private IntPtr m_ptr;
    internal ObjectHandleOnStack(IntPtr pObject);
}
internal class System.Runtime.CompilerServices.QCallAssembly : ValueType {
    private IntPtr m_ptr;
    private IntPtr m_assembly;
    internal QCallAssembly(IntPtr pObject, RuntimeAssembly assembly);
}
internal class System.Runtime.CompilerServices.QCallModule : ValueType {
    private IntPtr m_ptr;
    private IntPtr m_module;
    internal QCallModule(IntPtr pObject, RuntimeModule module);
    internal QCallModule(IntPtr pObject, ModuleBuilder module);
}
internal class System.Runtime.CompilerServices.QCallTypeHandle : ValueType {
    private IntPtr m_ptr;
    private IntPtr m_handle;
    internal QCallTypeHandle(IntPtr pObject, RuntimeType type);
}
internal class System.Runtime.CompilerServices.RawData : object {
    public byte Data;
}
internal class System.Runtime.CompilerServices.RawSzArrayData : object {
    public IntPtr Count;
    public byte Data;
}
[NullableAttribute("0")]
[NullableContextAttribute("2")]
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.ReferenceAssemblyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public string Description { get; }
    public ReferenceAssemblyAttribute(string description);
    [CompilerGeneratedAttribute]
public string get_Description();
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.RuntimeCompatibilityAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <WrapNonExceptionThrows>k__BackingField;
    public bool WrapNonExceptionThrows { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_WrapNonExceptionThrows();
    [CompilerGeneratedAttribute]
public void set_WrapNonExceptionThrows(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Runtime.CompilerServices.RuntimeFeature : object {
    public static string PortablePdb;
    public static string DefaultImplementationsOfInterfaces;
    public static bool IsDynamicCodeSupported { get; }
    public static bool IsDynamicCodeCompiled { get; }
    public static bool get_IsDynamicCodeSupported();
    public static bool get_IsDynamicCodeCompiled();
    public static bool IsSupported(string feature);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Runtime.CompilerServices.RuntimeHelpers : object {
    public static int OffsetToStringData { get; }
    public static void InitializeArray(Array array, RuntimeFieldHandle fldHandle);
    [NullableContextAttribute("2")]
public static object GetObjectValue(object obj);
    private static void _RunClassConstructor(RuntimeType type);
    public static void RunClassConstructor(RuntimeTypeHandle type);
    private static void _RunModuleConstructor(RuntimeModule module);
    public static void RunModuleConstructor(ModuleHandle module);
    internal static void _CompileMethod(RuntimeMethodHandleInternal method);
    private static void _PrepareMethod(IRuntimeMethodInfo method, IntPtr* pInstantiation, int cInstantiation);
    public static void PrepareMethod(RuntimeMethodHandle method);
    [NullableContextAttribute("2")]
public static void PrepareMethod(RuntimeMethodHandle method, RuntimeTypeHandle[] instantiation);
    public static void PrepareDelegate(Delegate d);
    public static int GetHashCode(object o);
    [NullableContextAttribute("2")]
public static bool Equals(object o1, object o2);
    [NonVersionableAttribute]
public static int get_OffsetToStringData();
    public static void EnsureSufficientExecutionStack();
    public static bool TryEnsureSufficientExecutionStack();
    public static void ExecuteCodeWithGuaranteedCleanup(TryCode code, CleanupCode backoutCode, object userData);
    internal static void ExecuteBackoutCodeHelper(object backoutCode, object userData, bool exceptionThrown);
    [NullableContextAttribute("2")]
public static bool IsReferenceOrContainsReferences();
    internal static bool IsBitwiseEquatable();
    internal static bool ObjectHasComponentSize(object obj);
    private static IntPtr GetObjectMethodTablePointer(object obj);
    private static object GetUninitializedObjectInternal(Type type);
    public static T[] GetSubArray(T[] array, Range range);
    public static object GetUninitializedObject(Type type);
    public static void PrepareContractedDelegate(Delegate d);
    public static void ProbeForSufficientStack();
    public static void PrepareConstrainedRegions();
    public static void PrepareConstrainedRegionsNoOP();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Runtime.CompilerServices.RuntimeWrappedException : Exception {
    private object _wrappedException;
    public object WrappedException { get; }
    public RuntimeWrappedException(object thrownObject);
    private RuntimeWrappedException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public object get_WrappedException();
}
[AttributeUsageAttribute("972")]
public class System.Runtime.CompilerServices.SpecialNameAttribute : Attribute {
}
internal class System.Runtime.CompilerServices.StackCrawlMarkHandle : ValueType {
    private IntPtr m_ptr;
    internal StackCrawlMarkHandle(IntPtr stackMark);
}
[NullableAttribute("0")]
[AttributeUsageAttribute("64")]
[NullableContextAttribute("1")]
public class System.Runtime.CompilerServices.StateMachineAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <StateMachineType>k__BackingField;
    public Type StateMachineType { get; }
    public StateMachineAttribute(Type stateMachineType);
    [CompilerGeneratedAttribute]
public Type get_StateMachineType();
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.StringFreezingAttribute : Attribute {
}
internal class System.Runtime.CompilerServices.StringHandleOnStack : ValueType {
    private IntPtr m_ptr;
    internal StringHandleOnStack(IntPtr pString);
}
public class System.Runtime.CompilerServices.StrongBox`1 : object {
    [NullableAttribute("1")]
[MaybeNullAttribute]
public T Value;
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.IStrongBox.Value { get; private set; }
    [NullableContextAttribute("1")]
public StrongBox`1(T value);
    private sealed virtual override object System.Runtime.CompilerServices.IStrongBox.get_Value();
    private sealed virtual override void System.Runtime.CompilerServices.IStrongBox.set_Value(object value);
}
[AttributeUsageAttribute("3")]
public class System.Runtime.CompilerServices.SuppressIldasmAttribute : Attribute {
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.TaskAwaiter : ValueType {
    internal Task m_task;
    public bool IsCompleted { get; }
    internal TaskAwaiter(Task task);
    public bool get_IsCompleted();
    [NullableContextAttribute("1")]
public sealed virtual void OnCompleted(Action continuation);
    [NullableContextAttribute("1")]
public sealed virtual void UnsafeOnCompleted(Action continuation);
    [StackTraceHiddenAttribute]
public void GetResult();
    [StackTraceHiddenAttribute]
internal static void ValidateEnd(Task task);
    [StackTraceHiddenAttribute]
private static void HandleNonSuccessAndDebuggerNotification(Task task);
    [StackTraceHiddenAttribute]
private static void ThrowForNonSuccess(Task task);
    internal static void OnCompletedInternal(Task task, Action continuation, bool continueOnCapturedContext, bool flowExecutionContext);
    internal static void UnsafeOnCompletedInternal(Task task, IAsyncStateMachineBox stateMachineBox, bool continueOnCapturedContext);
    private static Action OutputWaitEtwEvents(Task task, Action continuation);
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.TaskAwaiter`1 : ValueType {
    private Task`1<TResult> m_task;
    public bool IsCompleted { get; }
    internal TaskAwaiter`1(Task`1<TResult> task);
    public bool get_IsCompleted();
    [NullableContextAttribute("1")]
public sealed virtual void OnCompleted(Action continuation);
    [NullableContextAttribute("1")]
public sealed virtual void UnsafeOnCompleted(Action continuation);
    [NullableContextAttribute("1")]
[StackTraceHiddenAttribute]
public TResult GetResult();
}
[AttributeUsageAttribute("11148")]
[CLSCompliantAttribute("False")]
public class System.Runtime.CompilerServices.TupleElementNamesAttribute : Attribute {
    private String[] _transformNames;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IList`1<string> TransformNames { get; }
    public TupleElementNamesAttribute(String[] transformNames);
    public IList`1<string> get_TransformNames();
}
[AttributeUsageAttribute("1036")]
internal class System.Runtime.CompilerServices.TypeDependencyAttribute : Attribute {
    private string typeName;
    public TypeDependencyAttribute(string typeName);
}
[NullableAttribute("0")]
[AttributeUsageAttribute("5148")]
[NullableContextAttribute("1")]
public class System.Runtime.CompilerServices.TypeForwardedFromAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <AssemblyFullName>k__BackingField;
    public string AssemblyFullName { get; }
    public TypeForwardedFromAttribute(string assemblyFullName);
    [CompilerGeneratedAttribute]
public string get_AssemblyFullName();
}
[AttributeUsageAttribute("1")]
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Runtime.CompilerServices.TypeForwardedToAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <Destination>k__BackingField;
    public Type Destination { get; }
    public TypeForwardedToAttribute(Type destination);
    [CompilerGeneratedAttribute]
public Type get_Destination();
}
[AttributeUsageAttribute("8")]
public class System.Runtime.CompilerServices.UnsafeValueTypeAttribute : Attribute {
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ValueTaskAwaiter : ValueType {
    internal static Action`1<object> s_invokeActionDelegate;
    private ValueTask _value;
    public bool IsCompleted { get; }
    internal ValueTaskAwaiter(ValueTask& value);
    private static ValueTaskAwaiter();
    public bool get_IsCompleted();
    public void GetResult();
    [NullableContextAttribute("1")]
public sealed virtual void OnCompleted(Action continuation);
    [NullableContextAttribute("1")]
public sealed virtual void UnsafeOnCompleted(Action continuation);
    private sealed virtual override void System.Runtime.CompilerServices.IStateMachineBoxAwareAwaiter.AwaitUnsafeOnCompleted(IAsyncStateMachineBox box);
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ValueTaskAwaiter`1 : ValueType {
    private ValueTask`1<TResult> _value;
    public bool IsCompleted { get; }
    internal ValueTaskAwaiter`1(ValueTask`1& value);
    public bool get_IsCompleted();
    [NullableContextAttribute("1")]
public TResult GetResult();
    [NullableContextAttribute("1")]
public sealed virtual void OnCompleted(Action continuation);
    [NullableContextAttribute("1")]
public sealed virtual void UnsafeOnCompleted(Action continuation);
    private sealed virtual override void System.Runtime.CompilerServices.IStateMachineBoxAwareAwaiter.AwaitUnsafeOnCompleted(IAsyncStateMachineBox box);
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.YieldAwaitable : ValueType {
    public YieldAwaiter GetAwaiter();
}
public enum System.Runtime.ConstrainedExecution.Cer : Enum {
    public int value__;
    public static Cer None;
    public static Cer MayFail;
    public static Cer Success;
}
public enum System.Runtime.ConstrainedExecution.Consistency : Enum {
    public int value__;
    public static Consistency MayCorruptProcess;
    public static Consistency MayCorruptAppDomain;
    public static Consistency MayCorruptInstance;
    public static Consistency WillNotCorruptState;
}
public abstract class System.Runtime.ConstrainedExecution.CriticalFinalizerObject : object {
    protected virtual override void Finalize();
}
[AttributeUsageAttribute("1133")]
public class System.Runtime.ConstrainedExecution.ReliabilityContractAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Consistency <ConsistencyGuarantee>k__BackingField;
    [CompilerGeneratedAttribute]
private Cer <Cer>k__BackingField;
    public Consistency ConsistencyGuarantee { get; }
    public Cer Cer { get; }
    public ReliabilityContractAttribute(Consistency consistencyGuarantee, Cer cer);
    [CompilerGeneratedAttribute]
public Consistency get_ConsistencyGuarantee();
    [CompilerGeneratedAttribute]
public Cer get_Cer();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Runtime.ExceptionServices.ExceptionDispatchInfo : object {
    private Exception _exception;
    private DispatchState _dispatchState;
    public Exception SourceException { get; }
    private ExceptionDispatchInfo(Exception exception);
    public static ExceptionDispatchInfo Capture(Exception source);
    public Exception get_SourceException();
    [DoesNotReturnAttribute]
[StackTraceHiddenAttribute]
public void Throw();
    [DoesNotReturnAttribute]
public static void Throw(Exception source);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public Exception Exception { get; }
    public FirstChanceExceptionEventArgs(Exception exception);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
}
[AttributeUsageAttribute("64")]
public class System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute : Attribute {
}
public enum System.Runtime.GCLargeObjectHeapCompactionMode : Enum {
    public int value__;
    public static GCLargeObjectHeapCompactionMode Default;
    public static GCLargeObjectHeapCompactionMode CompactOnce;
}
public enum System.Runtime.GCLatencyMode : Enum {
    public int value__;
    public static GCLatencyMode Batch;
    public static GCLatencyMode Interactive;
    public static GCLatencyMode LowLatency;
    public static GCLatencyMode SustainedLowLatency;
    public static GCLatencyMode NoGCRegion;
}
public static class System.Runtime.GCSettings : object {
    public static bool IsServerGC { get; }
    public static GCLatencyMode LatencyMode { get; public set; }
    public static GCLargeObjectHeapCompactionMode LargeObjectHeapCompactionMode { get; public set; }
    public static bool get_IsServerGC();
    private static GCLatencyMode GetGCLatencyMode();
    private static SetLatencyModeStatus SetGCLatencyMode(GCLatencyMode newLatencyMode);
    private static GCLargeObjectHeapCompactionMode GetLOHCompactionMode();
    private static void SetLOHCompactionMode(GCLargeObjectHeapCompactionMode newLOHCompactionMode);
    public static GCLatencyMode get_LatencyMode();
    public static void set_LatencyMode(GCLatencyMode value);
    public static GCLargeObjectHeapCompactionMode get_LargeObjectHeapCompactionMode();
    public static void set_LargeObjectHeapCompactionMode(GCLargeObjectHeapCompactionMode value);
}
[AttributeUsageAttribute("64")]
public class System.Runtime.InteropServices.AllowReversePInvokeCallsAttribute : Attribute {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Runtime.InteropServices.ArrayWithOffset : ValueType {
    private object m_array;
    private int m_offset;
    private int m_count;
    public ArrayWithOffset(object array, int offset);
    public object GetArray();
    public int GetOffset();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(ArrayWithOffset obj);
    public static bool op_Equality(ArrayWithOffset a, ArrayWithOffset b);
    public static bool op_Inequality(ArrayWithOffset a, ArrayWithOffset b);
}
[AttributeUsageAttribute("1037")]
public class System.Runtime.InteropServices.BestFitMappingAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <BestFitMapping>k__BackingField;
    public bool ThrowOnUnmappableChar;
    public bool BestFitMapping { get; }
    public BestFitMappingAttribute(bool BestFitMapping);
    [CompilerGeneratedAttribute]
public bool get_BestFitMapping();
}
[NullableAttribute("0")]
[NullableContextAttribute("2")]
public class System.Runtime.InteropServices.BStrWrapper : object {
    [CompilerGeneratedAttribute]
private string <WrappedObject>k__BackingField;
    public string WrappedObject { get; }
    public BStrWrapper(string value);
    public BStrWrapper(object value);
    [CompilerGeneratedAttribute]
public string get_WrappedObject();
}
public enum System.Runtime.InteropServices.CallingConvention : Enum {
    public int value__;
    public static CallingConvention Winapi;
    public static CallingConvention Cdecl;
    public static CallingConvention StdCall;
    public static CallingConvention ThisCall;
    public static CallingConvention FastCall;
}
public enum System.Runtime.InteropServices.CharSet : Enum {
    public int value__;
    public static CharSet None;
    public static CharSet Ansi;
    public static CharSet Unicode;
    public static CharSet Auto;
}
[AttributeUsageAttribute("5")]
public class System.Runtime.InteropServices.ClassInterfaceAttribute : Attribute {
    [CompilerGeneratedAttribute]
private ClassInterfaceType <Value>k__BackingField;
    public ClassInterfaceType Value { get; }
    public ClassInterfaceAttribute(ClassInterfaceType classInterfaceType);
    public ClassInterfaceAttribute(short classInterfaceType);
    [CompilerGeneratedAttribute]
public ClassInterfaceType get_Value();
}
public enum System.Runtime.InteropServices.ClassInterfaceType : Enum {
    public int value__;
    public static ClassInterfaceType None;
    public static ClassInterfaceType AutoDispatch;
    public static ClassInterfaceType AutoDual;
}
[NullableAttribute("0")]
[AttributeUsageAttribute("1024")]
[NullableContextAttribute("1")]
public class System.Runtime.InteropServices.CoClassAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <CoClass>k__BackingField;
    public Type CoClass { get; }
    public CoClassAttribute(Type coClass);
    [CompilerGeneratedAttribute]
public Type get_CoClass();
}
[AttributeUsageAttribute("4")]
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Runtime.InteropServices.ComDefaultInterfaceAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <Value>k__BackingField;
    public Type Value { get; }
    public ComDefaultInterfaceAttribute(Type defaultInterface);
    [CompilerGeneratedAttribute]
public Type get_Value();
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
[AttributeUsageAttribute("1024")]
public class System.Runtime.InteropServices.ComEventInterfaceAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <SourceInterface>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <EventProvider>k__BackingField;
    public Type SourceInterface { get; }
    public Type EventProvider { get; }
    public ComEventInterfaceAttribute(Type SourceInterface, Type EventProvider);
    [CompilerGeneratedAttribute]
public Type get_SourceInterface();
    [CompilerGeneratedAttribute]
public Type get_EventProvider();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Runtime.InteropServices.ComEventsHelper : object {
    public static void Combine(object rcw, Guid iid, int dispid, Delegate d);
    public static Delegate Remove(object rcw, Guid iid, int dispid, Delegate d);
}
internal class System.Runtime.InteropServices.ComEventsInfo : object {
    private ComEventsSink _sinks;
    private object _rcw;
    private ComEventsInfo(object rcw);
    protected virtual override void Finalize();
    public static ComEventsInfo Find(object rcw);
    public static ComEventsInfo FromObject(object rcw);
    public ComEventsSink FindSink(Guid& iid);
    public ComEventsSink AddSink(Guid& iid);
    internal ComEventsSink RemoveSink(ComEventsSink sink);
}
internal class System.Runtime.InteropServices.ComEventsMethod : object {
    private List`1<DelegateWrapper> _delegateWrappers;
    private int _dispid;
    private ComEventsMethod _next;
    public bool Empty { get; }
    public ComEventsMethod(int dispid);
    public static ComEventsMethod Find(ComEventsMethod methods, int dispid);
    public static ComEventsMethod Add(ComEventsMethod methods, ComEventsMethod method);
    public static ComEventsMethod Remove(ComEventsMethod methods, ComEventsMethod method);
    public bool get_Empty();
    public void AddDelegate(Delegate d);
    public void RemoveDelegate(Delegate d);
    public object Invoke(Object[] args);
}
internal class System.Runtime.InteropServices.ComEventsSink : object {
    private Guid _iidSourceItf;
    private IConnectionPoint _connectionPoint;
    private int _cookie;
    private ComEventsMethod _methods;
    private ComEventsSink _next;
    public ComEventsSink(object rcw, Guid iid);
    public static ComEventsSink Find(ComEventsSink sinks, Guid& iid);
    public static ComEventsSink Add(ComEventsSink sinks, ComEventsSink sink);
    public static ComEventsSink RemoveAll(ComEventsSink sinks);
    public static ComEventsSink Remove(ComEventsSink sinks, ComEventsSink sink);
    public ComEventsMethod RemoveMethod(ComEventsMethod method);
    public ComEventsMethod FindMethod(int dispid);
    public ComEventsMethod AddMethod(int dispid);
    private sealed virtual override int System.Runtime.InteropServices.IDispatch.GetTypeInfoCount();
    private sealed virtual override ITypeInfo System.Runtime.InteropServices.IDispatch.GetTypeInfo(int iTInfo, int lcid);
    private sealed virtual override void System.Runtime.InteropServices.IDispatch.GetIDsOfNames(Guid& iid, String[] names, int cNames, int lcid, Int32[] rgDispId);
    private static Variant& GetVariant(Variant& pSrc);
    private sealed virtual override void System.Runtime.InteropServices.IDispatch.Invoke(int dispid, Guid& riid, int lcid, InvokeFlags wFlags, DISPPARAMS& pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    private sealed virtual override CustomQueryInterfaceResult System.Runtime.InteropServices.ICustomQueryInterface.GetInterface(Guid& iid, IntPtr& ppv);
    private void Advise(object rcw);
    private void Unadvise();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Runtime.InteropServices.COMException : ExternalException {
    public COMException(string message);
    public COMException(string message, Exception inner);
    public COMException(string message, int errorCode);
    [NullableContextAttribute("1")]
protected COMException(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[AttributeUsageAttribute("1028")]
public class System.Runtime.InteropServices.ComImportAttribute : Attribute {
}
public enum System.Runtime.InteropServices.ComInterfaceType : Enum {
    public int value__;
    public static ComInterfaceType InterfaceIsDual;
    public static ComInterfaceType InterfaceIsIUnknown;
    public static ComInterfaceType InterfaceIsIDispatch;
    public static ComInterfaceType InterfaceIsIInspectable;
}
public enum System.Runtime.InteropServices.ComMemberType : Enum {
    public int value__;
    public static ComMemberType Method;
    public static ComMemberType PropGet;
    public static ComMemberType PropSet;
}
[AttributeUsageAttribute("4")]
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Runtime.InteropServices.ComSourceInterfacesAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; }
    public ComSourceInterfacesAttribute(string sourceInterfaces);
    public ComSourceInterfacesAttribute(Type sourceInterface);
    public ComSourceInterfacesAttribute(Type sourceInterface1, Type sourceInterface2);
    public ComSourceInterfacesAttribute(Type sourceInterface1, Type sourceInterface2, Type sourceInterface3);
    public ComSourceInterfacesAttribute(Type sourceInterface1, Type sourceInterface2, Type sourceInterface3, Type sourceInterface4);
    [CompilerGeneratedAttribute]
public string get_Value();
}
public class System.Runtime.InteropServices.ComTypes.BIND_OPTS : ValueType {
    public int cbStruct;
    public int grfFlags;
    public int grfMode;
    public int dwTickCountDeadline;
}
public class System.Runtime.InteropServices.ComTypes.BINDPTR : ValueType {
    public IntPtr lpfuncdesc;
    public IntPtr lpvardesc;
    public IntPtr lptcomp;
}
public enum System.Runtime.InteropServices.ComTypes.CALLCONV : Enum {
    public int value__;
    public static CALLCONV CC_CDECL;
    public static CALLCONV CC_MSCPASCAL;
    public static CALLCONV CC_PASCAL;
    public static CALLCONV CC_MACPASCAL;
    public static CALLCONV CC_STDCALL;
    public static CALLCONV CC_RESERVED;
    public static CALLCONV CC_SYSCALL;
    public static CALLCONV CC_MPWCDECL;
    public static CALLCONV CC_MPWPASCAL;
    public static CALLCONV CC_MAX;
}
public class System.Runtime.InteropServices.ComTypes.CONNECTDATA : ValueType {
    [NullableAttribute("1")]
public object pUnk;
    public int dwCookie;
}
public enum System.Runtime.InteropServices.ComTypes.DESCKIND : Enum {
    public int value__;
    public static DESCKIND DESCKIND_NONE;
    public static DESCKIND DESCKIND_FUNCDESC;
    public static DESCKIND DESCKIND_VARDESC;
    public static DESCKIND DESCKIND_TYPECOMP;
    public static DESCKIND DESCKIND_IMPLICITAPPOBJ;
    public static DESCKIND DESCKIND_MAX;
}
public class System.Runtime.InteropServices.ComTypes.DISPPARAMS : ValueType {
    public IntPtr rgvarg;
    public IntPtr rgdispidNamedArgs;
    public int cArgs;
    public int cNamedArgs;
}
public class System.Runtime.InteropServices.ComTypes.ELEMDESC : ValueType {
    public TYPEDESC tdesc;
    public DESCUNION desc;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Runtime.InteropServices.ComTypes.EXCEPINFO : ValueType {
    public short wCode;
    public short wReserved;
    public string bstrSource;
    public string bstrDescription;
    public string bstrHelpFile;
    public int dwHelpContext;
    public IntPtr pvReserved;
    public IntPtr pfnDeferredFillIn;
    public int scode;
}
public class System.Runtime.InteropServices.ComTypes.FILETIME : ValueType {
    public int dwLowDateTime;
    public int dwHighDateTime;
}
public class System.Runtime.InteropServices.ComTypes.FUNCDESC : ValueType {
    public int memid;
    public IntPtr lprgscode;
    public IntPtr lprgelemdescParam;
    public FUNCKIND funckind;
    public INVOKEKIND invkind;
    public CALLCONV callconv;
    public short cParams;
    public short cParamsOpt;
    public short oVft;
    public short cScodes;
    public ELEMDESC elemdescFunc;
    public short wFuncFlags;
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.FUNCFLAGS : Enum {
    public short value__;
    public static FUNCFLAGS FUNCFLAG_FRESTRICTED;
    public static FUNCFLAGS FUNCFLAG_FSOURCE;
    public static FUNCFLAGS FUNCFLAG_FBINDABLE;
    public static FUNCFLAGS FUNCFLAG_FREQUESTEDIT;
    public static FUNCFLAGS FUNCFLAG_FDISPLAYBIND;
    public static FUNCFLAGS FUNCFLAG_FDEFAULTBIND;
    public static FUNCFLAGS FUNCFLAG_FHIDDEN;
    public static FUNCFLAGS FUNCFLAG_FUSESGETLASTERROR;
    public static FUNCFLAGS FUNCFLAG_FDEFAULTCOLLELEM;
    public static FUNCFLAGS FUNCFLAG_FUIDEFAULT;
    public static FUNCFLAGS FUNCFLAG_FNONBROWSABLE;
    public static FUNCFLAGS FUNCFLAG_FREPLACEABLE;
    public static FUNCFLAGS FUNCFLAG_FIMMEDIATEBIND;
}
public enum System.Runtime.InteropServices.ComTypes.FUNCKIND : Enum {
    public int value__;
    public static FUNCKIND FUNC_VIRTUAL;
    public static FUNCKIND FUNC_PUREVIRTUAL;
    public static FUNCKIND FUNC_NONVIRTUAL;
    public static FUNCKIND FUNC_STATIC;
    public static FUNCKIND FUNC_DISPATCH;
}
[NullableContextAttribute("1")]
[GuidAttribute("0000000e-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IBindCtx {
    public abstract virtual void RegisterObjectBound(object punk);
    public abstract virtual void RevokeObjectBound(object punk);
    public abstract virtual void ReleaseBoundObjects();
    public abstract virtual void SetBindOptions(BIND_OPTS& pbindopts);
    public abstract virtual void GetBindOptions(BIND_OPTS& pbindopts);
    [NullableContextAttribute("2")]
public abstract virtual void GetRunningObjectTable(IRunningObjectTable& pprot);
    public abstract virtual void RegisterObjectParam(string pszKey, object punk);
    public abstract virtual void GetObjectParam(string pszKey, Object& ppunk);
    [NullableContextAttribute("2")]
public abstract virtual void EnumObjectParam(IEnumString& ppenum);
    public abstract virtual int RevokeObjectParam(string pszKey);
}
[NullableContextAttribute("1")]
[GuidAttribute("B196B286-BAB4-101A-B69C-00AA00341D07")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IConnectionPoint {
    public abstract virtual void GetConnectionInterface(Guid& pIID);
    public abstract virtual void GetConnectionPointContainer(IConnectionPointContainer& ppCPC);
    public abstract virtual void Advise(object pUnkSink, Int32& pdwCookie);
    public abstract virtual void Unadvise(int dwCookie);
    public abstract virtual void EnumConnections(IEnumConnections& ppEnum);
}
[NullableContextAttribute("1")]
[GuidAttribute("B196B284-BAB4-101A-B69C-00AA00341D07")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IConnectionPointContainer {
    public abstract virtual void EnumConnectionPoints(IEnumConnectionPoints& ppEnum);
    [NullableContextAttribute("2")]
public abstract virtual void FindConnectionPoint(Guid& riid, IConnectionPoint& ppCP);
}
public class System.Runtime.InteropServices.ComTypes.IDLDESC : ValueType {
    public IntPtr dwReserved;
    public IDLFLAG wIDLFlags;
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.IDLFLAG : Enum {
    public short value__;
    public static IDLFLAG IDLFLAG_NONE;
    public static IDLFLAG IDLFLAG_FIN;
    public static IDLFLAG IDLFLAG_FOUT;
    public static IDLFLAG IDLFLAG_FLCID;
    public static IDLFLAG IDLFLAG_FRETVAL;
}
[GuidAttribute("B196B285-BAB4-101A-B69C-00AA00341D07")]
[NullableContextAttribute("1")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IEnumConnectionPoints {
    public abstract virtual int Next(int celt, IConnectionPoint[] rgelt, IntPtr pceltFetched);
    public abstract virtual int Skip(int celt);
    public abstract virtual void Reset();
    public abstract virtual void Clone(IEnumConnectionPoints& ppenum);
}
[NullableContextAttribute("1")]
[GuidAttribute("B196B287-BAB4-101A-B69C-00AA00341D07")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IEnumConnections {
    public abstract virtual int Next(int celt, CONNECTDATA[] rgelt, IntPtr pceltFetched);
    public abstract virtual int Skip(int celt);
    public abstract virtual void Reset();
    public abstract virtual void Clone(IEnumConnections& ppenum);
}
[GuidAttribute("496B0ABE-CDEE-11d3-88E8-00902754C43A")]
internal interface System.Runtime.InteropServices.ComTypes.IEnumerable {
    [DispIdAttribute("-4")]
public abstract virtual IEnumerator GetEnumerator();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("00000102-0000-0000-C000-000000000046")]
[NullableContextAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IEnumMoniker {
    public abstract virtual int Next(int celt, IMoniker[] rgelt, IntPtr pceltFetched);
    public abstract virtual int Skip(int celt);
    public abstract virtual void Reset();
    public abstract virtual void Clone(IEnumMoniker& ppenum);
}
[InterfaceTypeAttribute("1")]
[NullableContextAttribute("1")]
[GuidAttribute("00000101-0000-0000-C000-000000000046")]
public interface System.Runtime.InteropServices.ComTypes.IEnumString {
    public abstract virtual int Next(int celt, String[] rgelt, IntPtr pceltFetched);
    public abstract virtual int Skip(int celt);
    public abstract virtual void Reset();
    public abstract virtual void Clone(IEnumString& ppenum);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("00020404-0000-0000-C000-000000000046")]
[NullableContextAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IEnumVARIANT {
    public abstract virtual int Next(int celt, Object[] rgVar, IntPtr pceltFetched);
    public abstract virtual int Skip(int celt);
    public abstract virtual int Reset();
    public abstract virtual IEnumVARIANT Clone();
}
[GuidAttribute("0000000f-0000-0000-C000-000000000046")]
[NullableContextAttribute("1")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IMoniker {
    public abstract virtual void GetClassID(Guid& pClassID);
    public abstract virtual int IsDirty();
    public abstract virtual void Load(IStream pStm);
    public abstract virtual void Save(IStream pStm, bool fClearDirty);
    public abstract virtual void GetSizeMax(Int64& pcbSize);
    public abstract virtual void BindToObject(IBindCtx pbc, IMoniker pmkToLeft, Guid& riidResult, Object& ppvResult);
    public abstract virtual void BindToStorage(IBindCtx pbc, IMoniker pmkToLeft, Guid& riid, Object& ppvObj);
    [NullableContextAttribute("2")]
public abstract virtual void Reduce(IBindCtx pbc, int dwReduceHowFar, IMoniker& ppmkToLeft, IMoniker& ppmkReduced);
    public abstract virtual void ComposeWith(IMoniker pmkRight, bool fOnlyIfNotGeneric, IMoniker& ppmkComposite);
    [NullableContextAttribute("2")]
public abstract virtual void Enum(bool fForward, IEnumMoniker& ppenumMoniker);
    public abstract virtual int IsEqual(IMoniker pmkOtherMoniker);
    public abstract virtual void Hash(Int32& pdwHash);
    [NullableContextAttribute("2")]
public abstract virtual int IsRunning(IBindCtx pbc, IMoniker pmkToLeft, IMoniker pmkNewlyRunning);
    public abstract virtual void GetTimeOfLastChange(IBindCtx pbc, IMoniker pmkToLeft, FILETIME& pFileTime);
    public abstract virtual void Inverse(IMoniker& ppmk);
    public abstract virtual void CommonPrefixWith(IMoniker pmkOther, IMoniker& ppmkPrefix);
    public abstract virtual void RelativePathTo(IMoniker pmkOther, IMoniker& ppmkRelPath);
    public abstract virtual void GetDisplayName(IBindCtx pbc, IMoniker pmkToLeft, String& ppszDisplayName);
    public abstract virtual void ParseDisplayName(IBindCtx pbc, IMoniker pmkToLeft, string pszDisplayName, Int32& pchEaten, IMoniker& ppmkOut);
    public abstract virtual int IsSystemMoniker(Int32& pdwMksys);
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.IMPLTYPEFLAGS : Enum {
    public int value__;
    public static IMPLTYPEFLAGS IMPLTYPEFLAG_FDEFAULT;
    public static IMPLTYPEFLAGS IMPLTYPEFLAG_FSOURCE;
    public static IMPLTYPEFLAGS IMPLTYPEFLAG_FRESTRICTED;
    public static IMPLTYPEFLAGS IMPLTYPEFLAG_FDEFAULTVTABLE;
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.INVOKEKIND : Enum {
    public int value__;
    public static INVOKEKIND INVOKE_FUNC;
    public static INVOKEKIND INVOKE_PROPERTYGET;
    public static INVOKEKIND INVOKE_PROPERTYPUT;
    public static INVOKEKIND INVOKE_PROPERTYPUTREF;
}
[InterfaceTypeAttribute("1")]
[NullableContextAttribute("1")]
[GuidAttribute("0000010b-0000-0000-C000-000000000046")]
public interface System.Runtime.InteropServices.ComTypes.IPersistFile {
    public abstract virtual void GetClassID(Guid& pClassID);
    public abstract virtual int IsDirty();
    public abstract virtual void Load(string pszFileName, int dwMode);
    [NullableContextAttribute("2")]
public abstract virtual void Save(string pszFileName, bool fRemember);
    public abstract virtual void SaveCompleted(string pszFileName);
    public abstract virtual void GetCurFile(String& ppszFileName);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("00000010-0000-0000-C000-000000000046")]
[NullableContextAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IRunningObjectTable {
    public abstract virtual int Register(int grfFlags, object punkObject, IMoniker pmkObjectName);
    public abstract virtual void Revoke(int dwRegister);
    public abstract virtual int IsRunning(IMoniker pmkObjectName);
    public abstract virtual int GetObject(IMoniker pmkObjectName, Object& ppunkObject);
    public abstract virtual void NoteChangeTime(int dwRegister, FILETIME& pfiletime);
    public abstract virtual int GetTimeOfLastChange(IMoniker pmkObjectName, FILETIME& pfiletime);
    public abstract virtual void EnumRunning(IEnumMoniker& ppenumMoniker);
}
[InterfaceTypeAttribute("1")]
[NullableContextAttribute("1")]
[GuidAttribute("0000000c-0000-0000-C000-000000000046")]
public interface System.Runtime.InteropServices.ComTypes.IStream {
    public abstract virtual void Read(Byte[] pv, int cb, IntPtr pcbRead);
    public abstract virtual void Write(Byte[] pv, int cb, IntPtr pcbWritten);
    public abstract virtual void Seek(long dlibMove, int dwOrigin, IntPtr plibNewPosition);
    public abstract virtual void SetSize(long libNewSize);
    public abstract virtual void CopyTo(IStream pstm, long cb, IntPtr pcbRead, IntPtr pcbWritten);
    public abstract virtual void Commit(int grfCommitFlags);
    public abstract virtual void Revert();
    public abstract virtual void LockRegion(long libOffset, long cb, int dwLockType);
    public abstract virtual void UnlockRegion(long libOffset, long cb, int dwLockType);
    public abstract virtual void Stat(STATSTG& pstatstg, int grfStatFlag);
    public abstract virtual void Clone(IStream& ppstm);
}
[InterfaceTypeAttribute("1")]
[NullableContextAttribute("1")]
[GuidAttribute("00020403-0000-0000-C000-000000000046")]
public interface System.Runtime.InteropServices.ComTypes.ITypeComp {
    public abstract virtual void Bind(string szName, int lHashVal, short wFlags, ITypeInfo& ppTInfo, DESCKIND& pDescKind, BINDPTR& pBindPtr);
    public abstract virtual void BindType(string szName, int lHashVal, ITypeInfo& ppTInfo, ITypeComp& ppTComp);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("00020401-0000-0000-C000-000000000046")]
[NullableContextAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.ITypeInfo {
    public abstract virtual void GetTypeAttr(IntPtr& ppTypeAttr);
    public abstract virtual void GetTypeComp(ITypeComp& ppTComp);
    public abstract virtual void GetFuncDesc(int index, IntPtr& ppFuncDesc);
    public abstract virtual void GetVarDesc(int index, IntPtr& ppVarDesc);
    public abstract virtual void GetNames(int memid, String[] rgBstrNames, int cMaxNames, Int32& pcNames);
    public abstract virtual void GetRefTypeOfImplType(int index, Int32& href);
    public abstract virtual void GetImplTypeFlags(int index, IMPLTYPEFLAGS& pImplTypeFlags);
    public abstract virtual void GetIDsOfNames(String[] rgszNames, int cNames, Int32[] pMemId);
    public abstract virtual void Invoke(object pvInstance, int memid, short wFlags, DISPPARAMS& pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, Int32& puArgErr);
    public abstract virtual void GetDocumentation(int index, String& strName, String& strDocString, Int32& dwHelpContext, String& strHelpFile);
    public abstract virtual void GetDllEntry(int memid, INVOKEKIND invKind, IntPtr pBstrDllName, IntPtr pBstrName, IntPtr pwOrdinal);
    public abstract virtual void GetRefTypeInfo(int hRef, ITypeInfo& ppTI);
    public abstract virtual void AddressOfMember(int memid, INVOKEKIND invKind, IntPtr& ppv);
    public abstract virtual void CreateInstance(object pUnkOuter, Guid& riid, Object& ppvObj);
    [NullableContextAttribute("2")]
public abstract virtual void GetMops(int memid, String& pBstrMops);
    public abstract virtual void GetContainingTypeLib(ITypeLib& ppTLB, Int32& pIndex);
    public abstract virtual void ReleaseTypeAttr(IntPtr pTypeAttr);
    public abstract virtual void ReleaseFuncDesc(IntPtr pFuncDesc);
    public abstract virtual void ReleaseVarDesc(IntPtr pVarDesc);
}
[GuidAttribute("00020412-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
[NullableContextAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.ITypeInfo2 {
    public abstract virtual void GetTypeAttr(IntPtr& ppTypeAttr);
    public abstract virtual void GetTypeComp(ITypeComp& ppTComp);
    public abstract virtual void GetFuncDesc(int index, IntPtr& ppFuncDesc);
    public abstract virtual void GetVarDesc(int index, IntPtr& ppVarDesc);
    public abstract virtual void GetNames(int memid, String[] rgBstrNames, int cMaxNames, Int32& pcNames);
    public abstract virtual void GetRefTypeOfImplType(int index, Int32& href);
    public abstract virtual void GetImplTypeFlags(int index, IMPLTYPEFLAGS& pImplTypeFlags);
    public abstract virtual void GetIDsOfNames(String[] rgszNames, int cNames, Int32[] pMemId);
    public abstract virtual void Invoke(object pvInstance, int memid, short wFlags, DISPPARAMS& pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, Int32& puArgErr);
    public abstract virtual void GetDocumentation(int index, String& strName, String& strDocString, Int32& dwHelpContext, String& strHelpFile);
    public abstract virtual void GetDllEntry(int memid, INVOKEKIND invKind, IntPtr pBstrDllName, IntPtr pBstrName, IntPtr pwOrdinal);
    public abstract virtual void GetRefTypeInfo(int hRef, ITypeInfo& ppTI);
    public abstract virtual void AddressOfMember(int memid, INVOKEKIND invKind, IntPtr& ppv);
    public abstract virtual void CreateInstance(object pUnkOuter, Guid& riid, Object& ppvObj);
    [NullableContextAttribute("2")]
public abstract virtual void GetMops(int memid, String& pBstrMops);
    public abstract virtual void GetContainingTypeLib(ITypeLib& ppTLB, Int32& pIndex);
    public abstract virtual void ReleaseTypeAttr(IntPtr pTypeAttr);
    public abstract virtual void ReleaseFuncDesc(IntPtr pFuncDesc);
    public abstract virtual void ReleaseVarDesc(IntPtr pVarDesc);
    public abstract virtual void GetTypeKind(TYPEKIND& pTypeKind);
    public abstract virtual void GetTypeFlags(Int32& pTypeFlags);
    public abstract virtual void GetFuncIndexOfMemId(int memid, INVOKEKIND invKind, Int32& pFuncIndex);
    public abstract virtual void GetVarIndexOfMemId(int memid, Int32& pVarIndex);
    public abstract virtual void GetCustData(Guid& guid, Object& pVarVal);
    public abstract virtual void GetFuncCustData(int index, Guid& guid, Object& pVarVal);
    public abstract virtual void GetParamCustData(int indexFunc, int indexParam, Guid& guid, Object& pVarVal);
    public abstract virtual void GetVarCustData(int index, Guid& guid, Object& pVarVal);
    public abstract virtual void GetImplTypeCustData(int index, Guid& guid, Object& pVarVal);
    [LCIDConversionAttribute("1")]
public abstract virtual void GetDocumentation2(int memid, String& pbstrHelpString, Int32& pdwHelpStringContext, String& pbstrHelpStringDll);
    public abstract virtual void GetAllCustData(IntPtr pCustData);
    public abstract virtual void GetAllFuncCustData(int index, IntPtr pCustData);
    public abstract virtual void GetAllParamCustData(int indexFunc, int indexParam, IntPtr pCustData);
    public abstract virtual void GetAllVarCustData(int index, IntPtr pCustData);
    public abstract virtual void GetAllImplTypeCustData(int index, IntPtr pCustData);
}
[GuidAttribute("00020402-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
[NullableContextAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.ITypeLib {
    public abstract virtual int GetTypeInfoCount();
    public abstract virtual void GetTypeInfo(int index, ITypeInfo& ppTI);
    public abstract virtual void GetTypeInfoType(int index, TYPEKIND& pTKind);
    public abstract virtual void GetTypeInfoOfGuid(Guid& guid, ITypeInfo& ppTInfo);
    public abstract virtual void GetLibAttr(IntPtr& ppTLibAttr);
    public abstract virtual void GetTypeComp(ITypeComp& ppTComp);
    public abstract virtual void GetDocumentation(int index, String& strName, String& strDocString, Int32& dwHelpContext, String& strHelpFile);
    public abstract virtual bool IsName(string szNameBuf, int lHashVal);
    public abstract virtual void FindName(string szNameBuf, int lHashVal, ITypeInfo[] ppTInfo, Int32[] rgMemId, Int16& pcFound);
    public abstract virtual void ReleaseTLibAttr(IntPtr pTLibAttr);
}
[GuidAttribute("00020411-0000-0000-C000-000000000046")]
[NullableContextAttribute("1")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.ITypeLib2 {
    public abstract virtual int GetTypeInfoCount();
    public abstract virtual void GetTypeInfo(int index, ITypeInfo& ppTI);
    public abstract virtual void GetTypeInfoType(int index, TYPEKIND& pTKind);
    public abstract virtual void GetTypeInfoOfGuid(Guid& guid, ITypeInfo& ppTInfo);
    public abstract virtual void GetLibAttr(IntPtr& ppTLibAttr);
    public abstract virtual void GetTypeComp(ITypeComp& ppTComp);
    public abstract virtual void GetDocumentation(int index, String& strName, String& strDocString, Int32& dwHelpContext, String& strHelpFile);
    public abstract virtual bool IsName(string szNameBuf, int lHashVal);
    public abstract virtual void FindName(string szNameBuf, int lHashVal, ITypeInfo[] ppTInfo, Int32[] rgMemId, Int16& pcFound);
    public abstract virtual void ReleaseTLibAttr(IntPtr pTLibAttr);
    public abstract virtual void GetCustData(Guid& guid, Object& pVarVal);
    [LCIDConversionAttribute("1")]
public abstract virtual void GetDocumentation2(int index, String& pbstrHelpString, Int32& pdwHelpStringContext, String& pbstrHelpStringDll);
    public abstract virtual void GetLibStatistics(IntPtr pcUniqueNames, Int32& pcchUniqueNames);
    public abstract virtual void GetAllCustData(IntPtr pCustData);
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.LIBFLAGS : Enum {
    public short value__;
    public static LIBFLAGS LIBFLAG_FRESTRICTED;
    public static LIBFLAGS LIBFLAG_FCONTROL;
    public static LIBFLAGS LIBFLAG_FHIDDEN;
    public static LIBFLAGS LIBFLAG_FHASDISKIMAGE;
}
public class System.Runtime.InteropServices.ComTypes.PARAMDESC : ValueType {
    public IntPtr lpVarValue;
    public PARAMFLAG wParamFlags;
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.PARAMFLAG : Enum {
    public short value__;
    public static PARAMFLAG PARAMFLAG_NONE;
    public static PARAMFLAG PARAMFLAG_FIN;
    public static PARAMFLAG PARAMFLAG_FOUT;
    public static PARAMFLAG PARAMFLAG_FLCID;
    public static PARAMFLAG PARAMFLAG_FRETVAL;
    public static PARAMFLAG PARAMFLAG_FOPT;
    public static PARAMFLAG PARAMFLAG_FHASDEFAULT;
    public static PARAMFLAG PARAMFLAG_FHASCUSTDATA;
}
public class System.Runtime.InteropServices.ComTypes.STATSTG : ValueType {
    [NullableAttribute("1")]
public string pwcsName;
    public int type;
    public long cbSize;
    public FILETIME mtime;
    public FILETIME ctime;
    public FILETIME atime;
    public int grfMode;
    public int grfLocksSupported;
    public Guid clsid;
    public int grfStateBits;
    public int reserved;
}
public enum System.Runtime.InteropServices.ComTypes.SYSKIND : Enum {
    public int value__;
    public static SYSKIND SYS_WIN16;
    public static SYSKIND SYS_WIN32;
    public static SYSKIND SYS_MAC;
    public static SYSKIND SYS_WIN64;
}
public class System.Runtime.InteropServices.ComTypes.TYPEATTR : ValueType {
    public static int MEMBER_ID_NIL;
    public Guid guid;
    public int lcid;
    public int dwReserved;
    public int memidConstructor;
    public int memidDestructor;
    public IntPtr lpstrSchema;
    public int cbSizeInstance;
    public TYPEKIND typekind;
    public short cFuncs;
    public short cVars;
    public short cImplTypes;
    public short cbSizeVft;
    public short cbAlignment;
    public TYPEFLAGS wTypeFlags;
    public short wMajorVerNum;
    public short wMinorVerNum;
    public TYPEDESC tdescAlias;
    public IDLDESC idldescType;
}
public class System.Runtime.InteropServices.ComTypes.TYPEDESC : ValueType {
    public IntPtr lpValue;
    public short vt;
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.TYPEFLAGS : Enum {
    public short value__;
    public static TYPEFLAGS TYPEFLAG_FAPPOBJECT;
    public static TYPEFLAGS TYPEFLAG_FCANCREATE;
    public static TYPEFLAGS TYPEFLAG_FLICENSED;
    public static TYPEFLAGS TYPEFLAG_FPREDECLID;
    public static TYPEFLAGS TYPEFLAG_FHIDDEN;
    public static TYPEFLAGS TYPEFLAG_FCONTROL;
    public static TYPEFLAGS TYPEFLAG_FDUAL;
    public static TYPEFLAGS TYPEFLAG_FNONEXTENSIBLE;
    public static TYPEFLAGS TYPEFLAG_FOLEAUTOMATION;
    public static TYPEFLAGS TYPEFLAG_FRESTRICTED;
    public static TYPEFLAGS TYPEFLAG_FAGGREGATABLE;
    public static TYPEFLAGS TYPEFLAG_FREPLACEABLE;
    public static TYPEFLAGS TYPEFLAG_FDISPATCHABLE;
    public static TYPEFLAGS TYPEFLAG_FREVERSEBIND;
    public static TYPEFLAGS TYPEFLAG_FPROXY;
}
public enum System.Runtime.InteropServices.ComTypes.TYPEKIND : Enum {
    public int value__;
    public static TYPEKIND TKIND_ENUM;
    public static TYPEKIND TKIND_RECORD;
    public static TYPEKIND TKIND_MODULE;
    public static TYPEKIND TKIND_INTERFACE;
    public static TYPEKIND TKIND_DISPATCH;
    public static TYPEKIND TKIND_COCLASS;
    public static TYPEKIND TKIND_ALIAS;
    public static TYPEKIND TKIND_UNION;
    public static TYPEKIND TKIND_MAX;
}
public class System.Runtime.InteropServices.ComTypes.TYPELIBATTR : ValueType {
    public Guid guid;
    public int lcid;
    public SYSKIND syskind;
    public short wMajorVerNum;
    public short wMinorVerNum;
    public LIBFLAGS wLibFlags;
}
public class System.Runtime.InteropServices.ComTypes.VARDESC : ValueType {
    public int memid;
    [NullableAttribute("1")]
public string lpstrSchema;
    public DESCUNION desc;
    public ELEMDESC elemdescVar;
    public short wVarFlags;
    public VARKIND varkind;
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.VARFLAGS : Enum {
    public short value__;
    public static VARFLAGS VARFLAG_FREADONLY;
    public static VARFLAGS VARFLAG_FSOURCE;
    public static VARFLAGS VARFLAG_FBINDABLE;
    public static VARFLAGS VARFLAG_FREQUESTEDIT;
    public static VARFLAGS VARFLAG_FDISPLAYBIND;
    public static VARFLAGS VARFLAG_FDEFAULTBIND;
    public static VARFLAGS VARFLAG_FHIDDEN;
    public static VARFLAGS VARFLAG_FRESTRICTED;
    public static VARFLAGS VARFLAG_FDEFAULTCOLLELEM;
    public static VARFLAGS VARFLAG_FUIDEFAULT;
    public static VARFLAGS VARFLAG_FNONBROWSABLE;
    public static VARFLAGS VARFLAG_FREPLACEABLE;
    public static VARFLAGS VARFLAG_FIMMEDIATEBIND;
}
public enum System.Runtime.InteropServices.ComTypes.VARKIND : Enum {
    public int value__;
    public static VARKIND VAR_PERINSTANCE;
    public static VARKIND VAR_STATIC;
    public static VARKIND VAR_CONST;
    public static VARKIND VAR_DISPATCH;
}
[AttributeUsageAttribute("5597")]
public class System.Runtime.InteropServices.ComVisibleAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <Value>k__BackingField;
    public bool Value { get; }
    public ComVisibleAttribute(bool visibility);
    [CompilerGeneratedAttribute]
public bool get_Value();
}
public abstract class System.Runtime.InteropServices.CriticalHandle : CriticalFinalizerObject {
    protected IntPtr handle;
    private bool _isClosed;
    public bool IsClosed { get; }
    public bool IsInvalid { get; }
    protected CriticalHandle(IntPtr invalidHandleValue);
    private void ReleaseHandleFailed();
    protected virtual override void Finalize();
    private void Cleanup();
    protected void SetHandle(IntPtr handle);
    public bool get_IsClosed();
    public abstract virtual bool get_IsInvalid();
    public void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public void SetHandleAsInvalid();
    protected abstract virtual bool ReleaseHandle();
}
public class System.Runtime.InteropServices.CurrencyWrapper : object {
    [CompilerGeneratedAttribute]
private decimal <WrappedObject>k__BackingField;
    public decimal WrappedObject { get; }
    public CurrencyWrapper(decimal obj);
    [NullableContextAttribute("1")]
public CurrencyWrapper(object obj);
    [CompilerGeneratedAttribute]
public decimal get_WrappedObject();
}
internal static class System.Runtime.InteropServices.CustomMarshalers.ComDataHelpers : object {
    public static TView GetOrCreateManagedViewFromComData(object comObject, Func`2<T, TView> createCallback);
}
internal class System.Runtime.InteropServices.CustomMarshalers.EnumerableToDispatchMarshaler : object {
    private static EnumerableToDispatchMarshaler s_enumerableToDispatchMarshaler;
    private static EnumerableToDispatchMarshaler();
    public static ICustomMarshaler GetInstance(string cookie);
    public sealed virtual void CleanUpManagedData(object ManagedObj);
    public sealed virtual void CleanUpNativeData(IntPtr pNativeData);
    public sealed virtual int GetNativeDataSize();
    public sealed virtual IntPtr MarshalManagedToNative(object ManagedObj);
    public sealed virtual object MarshalNativeToManaged(IntPtr pNativeData);
}
internal class System.Runtime.InteropServices.CustomMarshalers.EnumerableViewOfDispatch : object {
    private static int DISPID_NEWENUM;
    private static int LCID_DEFAULT;
    private object _dispatch;
    private IDispatch Dispatch { get; }
    public EnumerableViewOfDispatch(object dispatch);
    private IDispatch get_Dispatch();
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual object GetUnderlyingObject();
}
internal class System.Runtime.InteropServices.CustomMarshalers.EnumeratorToEnumVariantMarshaler : object {
    private static EnumeratorToEnumVariantMarshaler s_enumeratorToEnumVariantMarshaler;
    private static EnumeratorToEnumVariantMarshaler();
    public static ICustomMarshaler GetInstance(string cookie);
    public sealed virtual void CleanUpManagedData(object ManagedObj);
    public sealed virtual void CleanUpNativeData(IntPtr pNativeData);
    public sealed virtual int GetNativeDataSize();
    public sealed virtual IntPtr MarshalManagedToNative(object ManagedObj);
    public sealed virtual object MarshalNativeToManaged(IntPtr pNativeData);
}
internal class System.Runtime.InteropServices.CustomMarshalers.EnumeratorViewOfEnumVariant : object {
    private IEnumVARIANT _enumVariantObject;
    private bool _fetchedLastObject;
    private Object[] _nextArray;
    private object _current;
    public object Current { get; }
    public EnumeratorViewOfEnumVariant(IEnumVARIANT enumVariantObject);
    public sealed virtual object get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual object GetUnderlyingObject();
}
internal class System.Runtime.InteropServices.CustomMarshalers.EnumVariantViewOfEnumerator : object {
    [CompilerGeneratedAttribute]
private IEnumerator <Enumerator>k__BackingField;
    public IEnumerator Enumerator { get; }
    public EnumVariantViewOfEnumerator(IEnumerator enumerator);
    [CompilerGeneratedAttribute]
public IEnumerator get_Enumerator();
    public sealed virtual IEnumVARIANT Clone();
    public sealed virtual int Next(int celt, Object[] rgVar, IntPtr pceltFetched);
    public sealed virtual int Reset();
    public sealed virtual int Skip(int celt);
    public sealed virtual object GetUnderlyingObject();
}
internal class System.Runtime.InteropServices.CustomMarshalers.ExpandoToDispatchExMarshaler : object {
    private static ExpandoToDispatchExMarshaler s_ExpandoToDispatchExMarshaler;
    private static ExpandoToDispatchExMarshaler();
    public static ICustomMarshaler GetInstance(string cookie);
    public sealed virtual void CleanUpManagedData(object ManagedObj);
    public sealed virtual void CleanUpNativeData(IntPtr pNativeData);
    public sealed virtual int GetNativeDataSize();
    public sealed virtual IntPtr MarshalManagedToNative(object ManagedObj);
    public sealed virtual object MarshalNativeToManaged(IntPtr pNativeData);
}
internal class System.Runtime.InteropServices.CustomMarshalers.TypeToTypeInfoMarshaler : object {
    private static TypeToTypeInfoMarshaler s_typeToTypeInfoMarshaler;
    private static TypeToTypeInfoMarshaler();
    public static ICustomMarshaler GetInstance(string cookie);
    public sealed virtual void CleanUpManagedData(object ManagedObj);
    public sealed virtual void CleanUpNativeData(IntPtr pNativeData);
    public sealed virtual int GetNativeDataSize();
    public sealed virtual IntPtr MarshalManagedToNative(object ManagedObj);
    public sealed virtual object MarshalNativeToManaged(IntPtr pNativeData);
}
public enum System.Runtime.InteropServices.CustomQueryInterfaceMode : Enum {
    public int value__;
    public static CustomQueryInterfaceMode Ignore;
    public static CustomQueryInterfaceMode Allow;
}
public enum System.Runtime.InteropServices.CustomQueryInterfaceResult : Enum {
    public int value__;
    public static CustomQueryInterfaceResult Handled;
    public static CustomQueryInterfaceResult NotHandled;
    public static CustomQueryInterfaceResult Failed;
}
[AttributeUsageAttribute("2")]
public class System.Runtime.InteropServices.DefaultCharSetAttribute : Attribute {
    [CompilerGeneratedAttribute]
private CharSet <CharSet>k__BackingField;
    public CharSet CharSet { get; }
    public DefaultCharSetAttribute(CharSet charSet);
    [CompilerGeneratedAttribute]
public CharSet get_CharSet();
}
[AttributeUsageAttribute("65")]
public class System.Runtime.InteropServices.DefaultDllImportSearchPathsAttribute : Attribute {
    [CompilerGeneratedAttribute]
private DllImportSearchPath <Paths>k__BackingField;
    public DllImportSearchPath Paths { get; }
    public DefaultDllImportSearchPathsAttribute(DllImportSearchPath paths);
    [CompilerGeneratedAttribute]
public DllImportSearchPath get_Paths();
}
[NullableContextAttribute("2")]
[AttributeUsageAttribute("2048")]
[NullableAttribute("0")]
public class System.Runtime.InteropServices.DefaultParameterValueAttribute : Attribute {
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public object Value { get; }
    public DefaultParameterValueAttribute(object value);
    [CompilerGeneratedAttribute]
public object get_Value();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Runtime.InteropServices.DispatchWrapper : object {
    [CompilerGeneratedAttribute]
private object <WrappedObject>k__BackingField;
    public object WrappedObject { get; }
    public DispatchWrapper(object obj);
    [CompilerGeneratedAttribute]
public object get_WrappedObject();
}
[AttributeUsageAttribute("960")]
public class System.Runtime.InteropServices.DispIdAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <Value>k__BackingField;
    public int Value { get; }
    public DispIdAttribute(int dispId);
    [CompilerGeneratedAttribute]
public int get_Value();
}
[AttributeUsageAttribute("64")]
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Runtime.InteropServices.DllImportAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [NullableAttribute("2")]
public string EntryPoint;
    public CharSet CharSet;
    public bool SetLastError;
    public bool ExactSpelling;
    public CallingConvention CallingConvention;
    public bool BestFitMapping;
    public bool PreserveSig;
    public bool ThrowOnUnmappableChar;
    public string Value { get; }
    public DllImportAttribute(string dllName);
    [CompilerGeneratedAttribute]
public string get_Value();
}
public class System.Runtime.InteropServices.DllImportResolver : MulticastDelegate {
    public DllImportResolver(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual IntPtr Invoke(string libraryName, Assembly assembly, Nullable`1<DllImportSearchPath> searchPath);
    public virtual IAsyncResult BeginInvoke(string libraryName, Assembly assembly, Nullable`1<DllImportSearchPath> searchPath, AsyncCallback callback, object object);
    public virtual IntPtr EndInvoke(IAsyncResult result);
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.DllImportSearchPath : Enum {
    public int value__;
    public static DllImportSearchPath UseDllDirectoryForDependencies;
    public static DllImportSearchPath ApplicationDirectory;
    public static DllImportSearchPath UserDirectories;
    public static DllImportSearchPath System32;
    public static DllImportSearchPath SafeDirectories;
    public static DllImportSearchPath AssemblyDirectory;
    public static DllImportSearchPath LegacyBehavior;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Runtime.InteropServices.ErrorWrapper : object {
    [CompilerGeneratedAttribute]
private int <ErrorCode>k__BackingField;
    public int ErrorCode { get; }
    public ErrorWrapper(int errorCode);
    public ErrorWrapper(object errorCode);
    public ErrorWrapper(Exception e);
    [CompilerGeneratedAttribute]
public int get_ErrorCode();
}
[GuidAttribute("AFBF15E6-C37C-11d2-B88E-00A0C9B471B8")]
internal interface System.Runtime.InteropServices.Expando.IExpando {
    public abstract virtual FieldInfo AddField(string name);
    public abstract virtual void RemoveMember(MemberInfo m);
}
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableContextAttribute("2")]
public class System.Runtime.InteropServices.ExternalException : SystemException {
    public int ErrorCode { get; }
    public ExternalException(string message);
    public ExternalException(string message, Exception inner);
    public ExternalException(string message, int errorCode);
    [NullableContextAttribute("1")]
protected ExternalException(SerializationInfo info, StreamingContext context);
    public virtual int get_ErrorCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[AttributeUsageAttribute("256")]
public class System.Runtime.InteropServices.FieldOffsetAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <Value>k__BackingField;
    public int Value { get; }
    public FieldOffsetAttribute(int offset);
    [CompilerGeneratedAttribute]
public int get_Value();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Runtime.InteropServices.GCHandle : ValueType {
    private IntPtr _handle;
    public object Target { get; public set; }
    public bool IsAllocated { get; }
    private GCHandle(object value, GCHandleType type);
    private GCHandle(IntPtr handle);
    private static IntPtr InternalAlloc(object value, GCHandleType type);
    internal static void InternalFree(IntPtr handle);
    internal static object InternalGet(IntPtr handle);
    private static void InternalSet(IntPtr handle, object value);
    internal static object InternalCompareExchange(IntPtr handle, object value, object oldValue);
    public static GCHandle Alloc(object value);
    public static GCHandle Alloc(object value, GCHandleType type);
    public void Free();
    public object get_Target();
    public void set_Target(object value);
    public IntPtr AddrOfPinnedObject();
    public bool get_IsAllocated();
    public static GCHandle op_Explicit(IntPtr value);
    public static GCHandle FromIntPtr(IntPtr value);
    public static IntPtr op_Explicit(GCHandle value);
    public static IntPtr ToIntPtr(GCHandle value);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public static bool op_Equality(GCHandle a, GCHandle b);
    public static bool op_Inequality(GCHandle a, GCHandle b);
    private static IntPtr GetHandleValue(IntPtr handle);
    private static bool IsPinned(IntPtr handle);
    private static void ThrowIfInvalid(IntPtr handle);
}
public enum System.Runtime.InteropServices.GCHandleType : Enum {
    public int value__;
    public static GCHandleType Weak;
    public static GCHandleType WeakTrackResurrection;
    public static GCHandleType Normal;
    public static GCHandleType Pinned;
}
[AttributeUsageAttribute("5149")]
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Runtime.InteropServices.GuidAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; }
    public GuidAttribute(string guid);
    [CompilerGeneratedAttribute]
public string get_Value();
}
[IsReadOnlyAttribute]
[NullableAttribute("0")]
[NullableContextAttribute("2")]
public class System.Runtime.InteropServices.HandleRef : ValueType {
    private object _wrapper;
    private IntPtr _handle;
    public object Wrapper { get; }
    public IntPtr Handle { get; }
    public HandleRef(object wrapper, IntPtr handle);
    public object get_Wrapper();
    public IntPtr get_Handle();
    public static IntPtr op_Explicit(HandleRef value);
    public static IntPtr ToIntPtr(HandleRef value);
}
[NullableContextAttribute("1")]
public interface System.Runtime.InteropServices.ICustomAdapter {
    public abstract virtual object GetUnderlyingObject();
}
[NullableContextAttribute("1")]
public interface System.Runtime.InteropServices.ICustomFactory {
    public abstract virtual MarshalByRefObject CreateInstance(Type serverType);
}
[NullableContextAttribute("1")]
public interface System.Runtime.InteropServices.ICustomMarshaler {
    public abstract virtual object MarshalNativeToManaged(IntPtr pNativeData);
    public abstract virtual IntPtr MarshalManagedToNative(object ManagedObj);
    public abstract virtual void CleanUpNativeData(IntPtr pNativeData);
    public abstract virtual void CleanUpManagedData(object ManagedObj);
    public abstract virtual int GetNativeDataSize();
}
public interface System.Runtime.InteropServices.ICustomQueryInterface {
    public abstract virtual CustomQueryInterfaceResult GetInterface(Guid& iid, IntPtr& ppv);
}
[GuidAttribute("00020400-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
internal interface System.Runtime.InteropServices.IDispatch {
    public abstract virtual int GetTypeInfoCount();
    public abstract virtual ITypeInfo GetTypeInfo(int iTInfo, int lcid);
    public abstract virtual void GetIDsOfNames(Guid& riid, String[] rgszNames, int cNames, int lcid, Int32[] rgDispId);
    public abstract virtual void Invoke(int dispIdMember, Guid& riid, int lcid, InvokeFlags wFlags, DISPPARAMS& pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.InteropServices.InAttribute : Attribute {
}
[AttributeUsageAttribute("1024")]
public class System.Runtime.InteropServices.InterfaceTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private ComInterfaceType <Value>k__BackingField;
    public ComInterfaceType Value { get; }
    public InterfaceTypeAttribute(ComInterfaceType interfaceType);
    public InterfaceTypeAttribute(short interfaceType);
    [CompilerGeneratedAttribute]
public ComInterfaceType get_Value();
}
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableContextAttribute("2")]
public class System.Runtime.InteropServices.InvalidComObjectException : SystemException {
    public InvalidComObjectException(string message);
    public InvalidComObjectException(string message, Exception inner);
    [NullableContextAttribute("1")]
protected InvalidComObjectException(SerializationInfo info, StreamingContext context);
}
[NullableAttribute("0")]
[NullableContextAttribute("2")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Runtime.InteropServices.InvalidOleVariantTypeException : SystemException {
    public InvalidOleVariantTypeException(string message);
    public InvalidOleVariantTypeException(string message, Exception inner);
    [NullableContextAttribute("1")]
protected InvalidOleVariantTypeException(SerializationInfo info, StreamingContext context);
}
[FlagsAttribute]
internal enum System.Runtime.InteropServices.InvokeFlags : Enum {
    public short value__;
    public static InvokeFlags DISPATCH_METHOD;
    public static InvokeFlags DISPATCH_PROPERTYGET;
    public static InvokeFlags DISPATCH_PROPERTYPUT;
    public static InvokeFlags DISPATCH_PROPERTYPUTREF;
}
public enum System.Runtime.InteropServices.LayoutKind : Enum {
    public int value__;
    public static LayoutKind Sequential;
    public static LayoutKind Explicit;
    public static LayoutKind Auto;
}
[AttributeUsageAttribute("64")]
public class System.Runtime.InteropServices.LCIDConversionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <Value>k__BackingField;
    public int Value { get; }
    public LCIDConversionAttribute(int lcid);
    [CompilerGeneratedAttribute]
public int get_Value();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Runtime.InteropServices.Marshal : object {
    internal static Guid IID_IUnknown;
    public static int SystemDefaultCharSize;
    public static int SystemMaxDBCSCharSize;
    private static Marshal();
    internal static int SizeOfHelper(Type t, bool throwIfNotMarshalable);
    public static IntPtr OffsetOf(Type t, string fieldName);
    private static IntPtr OffsetOfHelper(IRuntimeFieldInfo f);
    public static byte ReadByte(object ptr, int ofs);
    public static short ReadInt16(object ptr, int ofs);
    public static int ReadInt32(object ptr, int ofs);
    public static long ReadInt64(object ptr, int ofs);
    private static T ReadValueSlow(object ptr, int ofs, Func`3<IntPtr, int, T> readValueHelper);
    public static void WriteByte(object ptr, int ofs, byte val);
    public static void WriteInt16(object ptr, int ofs, short val);
    public static void WriteInt32(object ptr, int ofs, int val);
    public static void WriteInt64(object ptr, int ofs, long val);
    private static void WriteValueSlow(object ptr, int ofs, T val, Action`3<IntPtr, int, T> writeValueHelper);
    public static int GetLastWin32Error();
    internal static void SetLastWin32Error(int error);
    private static void PrelinkCore(MethodInfo m);
    private static void InternalPrelink(RuntimeMethodHandleInternal m);
    public static IntPtr GetExceptionPointers();
    public static int GetExceptionCode();
    [ReliabilityContractAttribute("3", "1")]
public static void StructureToPtr(object structure, IntPtr ptr, bool fDeleteOld);
    private static object PtrToStructureHelper(IntPtr ptr, Type structureType);
    private static void PtrToStructureHelper(IntPtr ptr, object structure, bool allowValueClasses);
    public static void DestroyStructure(IntPtr ptr, Type structuretype);
    internal static bool IsPinnable(object obj);
    public static IntPtr GetHINSTANCE(Module m);
    private static IntPtr GetHINSTANCE(QCallModule m);
    internal static Exception GetExceptionForHRInternal(int errorCode, IntPtr errorInfo);
    public static IntPtr AllocHGlobal(IntPtr cb);
    public static void FreeHGlobal(IntPtr hglobal);
    public static IntPtr ReAllocHGlobal(IntPtr pv, IntPtr cb);
    [NullableContextAttribute("2")]
public static int GetHRForException(Exception e);
    public static string GetTypeInfoName(ITypeInfo typeInfo);
    [NullableContextAttribute("2")]
public static Type GetTypeFromCLSID(Guid clsid);
    public static IntPtr GetIUnknownForObject(object o);
    private static IntPtr GetIUnknownForObjectNative(object o, bool onlyInContext);
    internal static IntPtr GetRawIUnknownForComObjectNoAddRef(object o);
    public static IntPtr GetComInterfaceForObject(object o, Type T);
    [NullableContextAttribute("2")]
public static IntPtr GetComInterfaceForObject(T o);
    public static IntPtr GetComInterfaceForObject(object o, Type T, CustomQueryInterfaceMode mode);
    private static IntPtr GetComInterfaceForObjectNative(object o, Type t, bool onlyInContext, bool fEnalbeCustomizedQueryInterface);
    public static object GetObjectForIUnknown(IntPtr pUnk);
    public static object GetUniqueObjectForIUnknown(IntPtr unknown);
    public static object GetTypedObjectForIUnknown(IntPtr pUnk, Type t);
    public static IntPtr CreateAggregatedObject(IntPtr pOuter, object o);
    public static IntPtr CreateAggregatedObject(IntPtr pOuter, T o);
    public static void CleanupUnusedObjectsInCurrentContext();
    public static bool AreComObjectsAvailableForCleanup();
    public static bool IsComObject(object o);
    public static IntPtr AllocCoTaskMem(int cb);
    public static void FreeCoTaskMem(IntPtr ptr);
    public static IntPtr ReAllocCoTaskMem(IntPtr pv, int cb);
    internal static IntPtr AllocBSTR(int length);
    public static void FreeBSTR(IntPtr ptr);
    [NullableContextAttribute("2")]
public static IntPtr StringToBSTR(string s);
    public static string PtrToStringBSTR(IntPtr ptr);
    public static int ReleaseComObject(object o);
    internal static int InternalReleaseComObject(object o);
    public static int FinalReleaseComObject(object o);
    internal static void InternalFinalReleaseComObject(object o);
    public static object GetComObjectData(object obj, object key);
    public static bool SetComObjectData(object obj, object key, object data);
    [NullableContextAttribute("2")]
public static object CreateWrapperOfType(object o, Type t);
    public static TWrapper CreateWrapperOfType(T o);
    private static object InternalCreateWrapperOfType(object o, Type t);
    public static bool IsTypeVisibleFromCom(Type t);
    public static int QueryInterface(IntPtr pUnk, Guid& iid, IntPtr& ppv);
    public static int AddRef(IntPtr pUnk);
    public static int Release(IntPtr pUnk);
    [NullableContextAttribute("2")]
public static void GetNativeVariantForObject(object obj, IntPtr pDstNativeVariant);
    public static void GetNativeVariantForObject(T obj, IntPtr pDstNativeVariant);
    [NullableContextAttribute("2")]
public static object GetObjectForNativeVariant(IntPtr pSrcNativeVariant);
    public static T GetObjectForNativeVariant(IntPtr pSrcNativeVariant);
    public static Object[] GetObjectsForNativeVariants(IntPtr aSrcNativeVariant, int cVars);
    public static T[] GetObjectsForNativeVariants(IntPtr aSrcNativeVariant, int cVars);
    public static int GetStartComSlot(Type t);
    public static int GetEndComSlot(Type t);
    public static object BindToMoniker(string monikerName);
    private static void CreateBindCtx(UInt32 reserved, IBindCtx& ppbc);
    private static void MkParseDisplayName(IBindCtx pbc, string szUserName, UInt32& pchEaten, IMoniker& ppmk);
    private static void BindMoniker(IMoniker pmk, UInt32 grfOpt, Guid& iidResult, Object& ppvResult);
    public static void ChangeWrapperHandleStrength(object otp, bool fIsWeak);
    internal static Delegate GetDelegateForFunctionPointerInternal(IntPtr ptr, Type t);
    internal static IntPtr GetFunctionPointerForDelegateInternal(Delegate d);
    public static IntPtr AllocHGlobal(int cb);
    [NullableContextAttribute("2")]
public static string PtrToStringAnsi(IntPtr ptr);
    public static string PtrToStringAnsi(IntPtr ptr, int len);
    [NullableContextAttribute("2")]
public static string PtrToStringUni(IntPtr ptr);
    public static string PtrToStringUni(IntPtr ptr, int len);
    [NullableContextAttribute("2")]
public static string PtrToStringUTF8(IntPtr ptr);
    public static string PtrToStringUTF8(IntPtr ptr, int byteLen);
    public static int SizeOf(object structure);
    public static int SizeOf(T structure);
    public static int SizeOf(Type t);
    [NullableContextAttribute("2")]
public static int SizeOf();
    public static IntPtr UnsafeAddrOfPinnedArrayElement(Array arr, int index);
    public static IntPtr UnsafeAddrOfPinnedArrayElement(T[] arr, int index);
    public static IntPtr OffsetOf(string fieldName);
    public static void Copy(Int32[] source, int startIndex, IntPtr destination, int length);
    public static void Copy(Char[] source, int startIndex, IntPtr destination, int length);
    public static void Copy(Int16[] source, int startIndex, IntPtr destination, int length);
    public static void Copy(Int64[] source, int startIndex, IntPtr destination, int length);
    public static void Copy(Single[] source, int startIndex, IntPtr destination, int length);
    public static void Copy(Double[] source, int startIndex, IntPtr destination, int length);
    public static void Copy(Byte[] source, int startIndex, IntPtr destination, int length);
    public static void Copy(IntPtr[] source, int startIndex, IntPtr destination, int length);
    private static void CopyToNative(T[] source, int startIndex, IntPtr destination, int length);
    public static void Copy(IntPtr source, Int32[] destination, int startIndex, int length);
    public static void Copy(IntPtr source, Char[] destination, int startIndex, int length);
    public static void Copy(IntPtr source, Int16[] destination, int startIndex, int length);
    public static void Copy(IntPtr source, Int64[] destination, int startIndex, int length);
    public static void Copy(IntPtr source, Single[] destination, int startIndex, int length);
    public static void Copy(IntPtr source, Double[] destination, int startIndex, int length);
    public static void Copy(IntPtr source, Byte[] destination, int startIndex, int length);
    public static void Copy(IntPtr source, IntPtr[] destination, int startIndex, int length);
    private static void CopyToManaged(IntPtr source, T[] destination, int startIndex, int length);
    public static byte ReadByte(IntPtr ptr, int ofs);
    public static byte ReadByte(IntPtr ptr);
    public static short ReadInt16(IntPtr ptr, int ofs);
    public static short ReadInt16(IntPtr ptr);
    public static int ReadInt32(IntPtr ptr, int ofs);
    public static int ReadInt32(IntPtr ptr);
    public static IntPtr ReadIntPtr(object ptr, int ofs);
    public static IntPtr ReadIntPtr(IntPtr ptr, int ofs);
    public static IntPtr ReadIntPtr(IntPtr ptr);
    public static long ReadInt64(IntPtr ptr, int ofs);
    public static long ReadInt64(IntPtr ptr);
    public static void WriteByte(IntPtr ptr, int ofs, byte val);
    public static void WriteByte(IntPtr ptr, byte val);
    public static void WriteInt16(IntPtr ptr, int ofs, short val);
    public static void WriteInt16(IntPtr ptr, short val);
    public static void WriteInt16(IntPtr ptr, int ofs, char val);
    public static void WriteInt16(object ptr, int ofs, char val);
    public static void WriteInt16(IntPtr ptr, char val);
    public static void WriteInt32(IntPtr ptr, int ofs, int val);
    public static void WriteInt32(IntPtr ptr, int val);
    public static void WriteIntPtr(IntPtr ptr, int ofs, IntPtr val);
    public static void WriteIntPtr(object ptr, int ofs, IntPtr val);
    public static void WriteIntPtr(IntPtr ptr, IntPtr val);
    public static void WriteInt64(IntPtr ptr, int ofs, long val);
    public static void WriteInt64(IntPtr ptr, long val);
    public static void Prelink(MethodInfo m);
    public static void PrelinkAll(Type c);
    public static void StructureToPtr(T structure, IntPtr ptr, bool fDeleteOld);
    public static object PtrToStructure(IntPtr ptr, Type structureType);
    public static void PtrToStructure(IntPtr ptr, object structure);
    public static void PtrToStructure(IntPtr ptr, T structure);
    public static T PtrToStructure(IntPtr ptr);
    [NullableContextAttribute("2")]
public static void DestroyStructure(IntPtr ptr);
    [NullableContextAttribute("2")]
public static Exception GetExceptionForHR(int errorCode);
    [NullableContextAttribute("2")]
public static Exception GetExceptionForHR(int errorCode, IntPtr errorInfo);
    public static void ThrowExceptionForHR(int errorCode);
    public static void ThrowExceptionForHR(int errorCode, IntPtr errorInfo);
    public static IntPtr SecureStringToBSTR(SecureString s);
    public static IntPtr SecureStringToCoTaskMemAnsi(SecureString s);
    public static IntPtr SecureStringToCoTaskMemUnicode(SecureString s);
    public static IntPtr SecureStringToGlobalAllocAnsi(SecureString s);
    public static IntPtr SecureStringToGlobalAllocUnicode(SecureString s);
    [NullableContextAttribute("2")]
public static IntPtr StringToHGlobalAnsi(string s);
    [NullableContextAttribute("2")]
public static IntPtr StringToHGlobalUni(string s);
    [NullableContextAttribute("2")]
public static IntPtr StringToCoTaskMemUni(string s);
    [NullableContextAttribute("2")]
public static IntPtr StringToCoTaskMemUTF8(string s);
    [NullableContextAttribute("2")]
public static IntPtr StringToCoTaskMemAnsi(string s);
    public static Guid GenerateGuidForType(Type type);
    public static string GenerateProgIdForType(Type type);
    public static Delegate GetDelegateForFunctionPointer(IntPtr ptr, Type t);
    public static TDelegate GetDelegateForFunctionPointer(IntPtr ptr);
    public static IntPtr GetFunctionPointerForDelegate(Delegate d);
    public static IntPtr GetFunctionPointerForDelegate(TDelegate d);
    public static int GetHRForLastWin32Error();
    public static IntPtr GetIDispatchForObject(object o);
    public static void ZeroFreeBSTR(IntPtr s);
    public static void ZeroFreeCoTaskMemAnsi(IntPtr s);
    public static void ZeroFreeCoTaskMemUnicode(IntPtr s);
    public static void ZeroFreeCoTaskMemUTF8(IntPtr s);
    public static void ZeroFreeGlobalAllocAnsi(IntPtr s);
    public static void ZeroFreeGlobalAllocUnicode(IntPtr s);
    internal static UInt32 SysStringByteLen(IntPtr s);
    [NullableContextAttribute("2")]
public static string PtrToStringAuto(IntPtr ptr, int len);
    [NullableContextAttribute("2")]
public static string PtrToStringAuto(IntPtr ptr);
    [NullableContextAttribute("2")]
public static IntPtr StringToHGlobalAuto(string s);
    [NullableContextAttribute("2")]
public static IntPtr StringToCoTaskMemAuto(string s);
    private static int GetSystemMaxDBCSCharSize();
    private static bool IsWin32Atom(IntPtr ptr);
    internal static int StringToAnsiString(string s, Byte* buffer, int bufferLength, bool bestFit, bool throwOnUnmappableChar);
}
[NullableAttribute("0")]
[NullableContextAttribute("2")]
[AttributeUsageAttribute("10496")]
public class System.Runtime.InteropServices.MarshalAsAttribute : Attribute {
    [CompilerGeneratedAttribute]
private UnmanagedType <Value>k__BackingField;
    public VarEnum SafeArraySubType;
    public Type SafeArrayUserDefinedSubType;
    public int IidParameterIndex;
    public UnmanagedType ArraySubType;
    public short SizeParamIndex;
    public int SizeConst;
    public string MarshalType;
    public Type MarshalTypeRef;
    public string MarshalCookie;
    public UnmanagedType Value { get; }
    public MarshalAsAttribute(UnmanagedType unmanagedType);
    public MarshalAsAttribute(short unmanagedType);
    [CompilerGeneratedAttribute]
public UnmanagedType get_Value();
}
[NullableAttribute("0")]
[NullableContextAttribute("2")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Runtime.InteropServices.MarshalDirectiveException : SystemException {
    public MarshalDirectiveException(string message);
    public MarshalDirectiveException(string message, Exception inner);
    [NullableContextAttribute("1")]
protected MarshalDirectiveException(SerializationInfo info, StreamingContext context);
}
public static class System.Runtime.InteropServices.MemoryMarshal : object {
    [NullableContextAttribute("2")]
public static bool TryGetArray(ReadOnlyMemory`1<T> memory, ArraySegment`1& segment);
    [NullableContextAttribute("2")]
public static bool TryGetMemoryManager(ReadOnlyMemory`1<T> memory, TManager& manager);
    [NullableContextAttribute("2")]
public static bool TryGetMemoryManager(ReadOnlyMemory`1<T> memory, TManager& manager, Int32& start, Int32& length);
    [IteratorStateMachineAttribute("System.Runtime.InteropServices.MemoryMarshal/<ToEnumerable>d__3`1")]
[NullableContextAttribute("1")]
public static IEnumerable`1<T> ToEnumerable(ReadOnlyMemory`1<T> memory);
    public static bool TryGetString(ReadOnlyMemory`1<char> memory, String& text, Int32& start, Int32& length);
    public static T Read(ReadOnlySpan`1<byte> source);
    public static bool TryRead(ReadOnlySpan`1<byte> source, T& value);
    public static void Write(Span`1<byte> destination, T& value);
    public static bool TryWrite(Span`1<byte> destination, T& value);
    public static T& AsRef(Span`1<byte> span);
    public static T& modreq(System.Runtime.InteropServices.InAttribute) AsRef(ReadOnlySpan`1<byte> span);
    [NullableContextAttribute("2")]
public static Memory`1<T> CreateFromPinnedArray(T[] array, int start, int length);
    public static Span`1<byte> AsBytes(Span`1<T> span);
    public static ReadOnlySpan`1<byte> AsBytes(ReadOnlySpan`1<T> span);
    [NullableContextAttribute("2")]
public static Memory`1<T> AsMemory(ReadOnlyMemory`1<T> memory);
    [NullableContextAttribute("1")]
public static T& GetReference(Span`1<T> span);
    [NullableContextAttribute("1")]
public static T& GetReference(ReadOnlySpan`1<T> span);
    internal static T& GetNonNullPinnableReference(Span`1<T> span);
    internal static T& GetNonNullPinnableReference(ReadOnlySpan`1<T> span);
    public static Span`1<TTo> Cast(Span`1<TFrom> span);
    public static ReadOnlySpan`1<TTo> Cast(ReadOnlySpan`1<TFrom> span);
    [NullableContextAttribute("1")]
public static Span`1<T> CreateSpan(T& reference, int length);
    [NullableContextAttribute("1")]
public static ReadOnlySpan`1<T> CreateReadOnlySpan(T& reference, int length);
}
[AttributeUsageAttribute("64")]
public class System.Runtime.InteropServices.NativeCallableAttribute : Attribute {
    public CallingConvention CallingConvention;
    [NullableAttribute("2")]
public string EntryPoint;
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public static class System.Runtime.InteropServices.NativeLibrary : object {
    private static ConditionalWeakTable`2<Assembly, DllImportResolver> s_nativeDllResolveMap;
    internal static IntPtr LoadLibraryByName(string libraryName, Assembly assembly, Nullable`1<DllImportSearchPath> searchPath, bool throwOnError);
    internal static IntPtr LoadFromPath(string libraryName, bool throwOnError);
    internal static IntPtr LoadByName(string libraryName, QCallAssembly callingAssembly, bool hasDllImportSearchPathFlag, UInt32 dllImportSearchPathFlag, bool throwOnError);
    internal static void FreeLib(IntPtr handle);
    internal static IntPtr GetSymbol(IntPtr handle, string symbolName, bool throwOnError);
    public static IntPtr Load(string libraryPath);
    public static bool TryLoad(string libraryPath, IntPtr& handle);
    public static IntPtr Load(string libraryName, Assembly assembly, Nullable`1<DllImportSearchPath> searchPath);
    public static bool TryLoad(string libraryName, Assembly assembly, Nullable`1<DllImportSearchPath> searchPath, IntPtr& handle);
    public static void Free(IntPtr handle);
    public static IntPtr GetExport(IntPtr handle, string name);
    public static bool TryGetExport(IntPtr handle, string name, IntPtr& address);
    public static void SetDllImportResolver(Assembly assembly, DllImportResolver resolver);
    internal static IntPtr LoadLibraryCallbackStub(string libraryName, Assembly assembly, bool hasDllImportSearchPathFlags, UInt32 dllImportSearchPathFlags);
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.InteropServices.OptionalAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.InteropServices.OutAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class System.Runtime.InteropServices.PreserveSigAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Runtime.InteropServices.ProgIdAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; }
    public ProgIdAttribute(string progId);
    [CompilerGeneratedAttribute]
public string get_Value();
}
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableContextAttribute("2")]
public class System.Runtime.InteropServices.SafeArrayRankMismatchException : SystemException {
    public SafeArrayRankMismatchException(string message);
    public SafeArrayRankMismatchException(string message, Exception inner);
    [NullableContextAttribute("1")]
protected SafeArrayRankMismatchException(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Runtime.InteropServices.SafeArrayTypeMismatchException : SystemException {
    public SafeArrayTypeMismatchException(string message);
    public SafeArrayTypeMismatchException(string message, Exception inner);
    [NullableContextAttribute("1")]
protected SafeArrayTypeMismatchException(SerializationInfo info, StreamingContext context);
}
public abstract class System.Runtime.InteropServices.SafeBuffer : SafeHandleZeroOrMinusOneIsInvalid {
    private static UIntPtr Uninitialized;
    private UIntPtr _numBytes;
    [CLSCompliantAttribute("False")]
public ulong ByteLength { get; }
    protected SafeBuffer(bool ownsHandle);
    private static SafeBuffer();
    [CLSCompliantAttribute("False")]
public void Initialize(ulong numBytes);
    [CLSCompliantAttribute("False")]
public void Initialize(UInt32 numElements, UInt32 sizeOfEachElement);
    [CLSCompliantAttribute("False")]
public void Initialize(UInt32 numElements);
    [CLSCompliantAttribute("False")]
public void AcquirePointer(Byte*& pointer);
    public void ReleasePointer();
    [CLSCompliantAttribute("False")]
public T Read(ulong byteOffset);
    [CLSCompliantAttribute("False")]
public void ReadArray(ulong byteOffset, T[] array, int index, int count);
    [CLSCompliantAttribute("False")]
public void Write(ulong byteOffset, T value);
    [CLSCompliantAttribute("False")]
public void WriteArray(ulong byteOffset, T[] array, int index, int count);
    public ulong get_ByteLength();
    private void SpaceCheck(Byte* ptr, ulong sizeInBytes);
    private static void NotEnoughRoom();
    private static InvalidOperationException NotInitialized();
    internal static UInt32 AlignedSizeOf();
    internal static UInt32 SizeOf();
}
public abstract class System.Runtime.InteropServices.SafeHandle : CriticalFinalizerObject {
    protected IntPtr handle;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _state;
    private bool _ownsHandle;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _fullyInitialized;
    public bool IsClosed { get; }
    public bool IsInvalid { get; }
    protected SafeHandle(IntPtr invalidHandleValue, bool ownsHandle);
    protected virtual override void Finalize();
    protected void SetHandle(IntPtr handle);
    public IntPtr DangerousGetHandle();
    public bool get_IsClosed();
    public abstract virtual bool get_IsInvalid();
    public void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public void SetHandleAsInvalid();
    protected abstract virtual bool ReleaseHandle();
    public void DangerousAddRef(Boolean& success);
    public void DangerousRelease();
    private void InternalRelease(bool disposeOrFinalizeOperation);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Runtime.InteropServices.SEHException : ExternalException {
    public SEHException(string message);
    public SEHException(string message, Exception inner);
    [NullableContextAttribute("1")]
protected SEHException(SerializationInfo info, StreamingContext context);
    public virtual bool CanResume();
}
[AttributeUsageAttribute("12")]
public class System.Runtime.InteropServices.StructLayoutAttribute : Attribute {
    [CompilerGeneratedAttribute]
private LayoutKind <Value>k__BackingField;
    public int Pack;
    public int Size;
    public CharSet CharSet;
    public LayoutKind Value { get; }
    public StructLayoutAttribute(LayoutKind layoutKind);
    public StructLayoutAttribute(short layoutKind);
    [CompilerGeneratedAttribute]
public LayoutKind get_Value();
}
[AttributeUsageAttribute("5144")]
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Runtime.InteropServices.TypeIdentifierAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    public string Scope { get; }
    public string Identifier { get; }
    public TypeIdentifierAttribute(string scope, string identifier);
    [CompilerGeneratedAttribute]
public string get_Scope();
    [CompilerGeneratedAttribute]
public string get_Identifier();
}
[NullableAttribute("0")]
[NullableContextAttribute("2")]
public class System.Runtime.InteropServices.UnknownWrapper : object {
    [CompilerGeneratedAttribute]
private object <WrappedObject>k__BackingField;
    public object WrappedObject { get; }
    public UnknownWrapper(object obj);
    [CompilerGeneratedAttribute]
public object get_WrappedObject();
}
[AttributeUsageAttribute("4096")]
public class System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute : Attribute {
    [CompilerGeneratedAttribute]
private CallingConvention <CallingConvention>k__BackingField;
    public bool BestFitMapping;
    public bool SetLastError;
    public bool ThrowOnUnmappableChar;
    public CharSet CharSet;
    public CallingConvention CallingConvention { get; }
    public UnmanagedFunctionPointerAttribute(CallingConvention callingConvention);
    [CompilerGeneratedAttribute]
public CallingConvention get_CallingConvention();
}
public enum System.Runtime.InteropServices.UnmanagedType : Enum {
    public int value__;
    public static UnmanagedType Bool;
    public static UnmanagedType I1;
    public static UnmanagedType U1;
    public static UnmanagedType I2;
    public static UnmanagedType U2;
    public static UnmanagedType I4;
    public static UnmanagedType U4;
    public static UnmanagedType I8;
    public static UnmanagedType U8;
    public static UnmanagedType R4;
    public static UnmanagedType R8;
    public static UnmanagedType Currency;
    public static UnmanagedType BStr;
    public static UnmanagedType LPStr;
    public static UnmanagedType LPWStr;
    public static UnmanagedType LPTStr;
    public static UnmanagedType ByValTStr;
    public static UnmanagedType IUnknown;
    public static UnmanagedType IDispatch;
    public static UnmanagedType Struct;
    public static UnmanagedType Interface;
    public static UnmanagedType SafeArray;
    public static UnmanagedType ByValArray;
    public static UnmanagedType SysInt;
    public static UnmanagedType SysUInt;
    public static UnmanagedType VBByRefStr;
    public static UnmanagedType AnsiBStr;
    public static UnmanagedType TBStr;
    public static UnmanagedType VariantBool;
    public static UnmanagedType FunctionPtr;
    public static UnmanagedType AsAny;
    public static UnmanagedType LPArray;
    public static UnmanagedType LPStruct;
    public static UnmanagedType CustomMarshaler;
    public static UnmanagedType Error;
    public static UnmanagedType IInspectable;
    public static UnmanagedType HString;
    public static UnmanagedType LPUTF8Str;
}
public enum System.Runtime.InteropServices.VarEnum : Enum {
    public int value__;
    public static VarEnum VT_EMPTY;
    public static VarEnum VT_NULL;
    public static VarEnum VT_I2;
    public static VarEnum VT_I4;
    public static VarEnum VT_R4;
    public static VarEnum VT_R8;
    public static VarEnum VT_CY;
    public static VarEnum VT_DATE;
    public static VarEnum VT_BSTR;
    public static VarEnum VT_DISPATCH;
    public static VarEnum VT_ERROR;
    public static VarEnum VT_BOOL;
    public static VarEnum VT_VARIANT;
    public static VarEnum VT_UNKNOWN;
    public static VarEnum VT_DECIMAL;
    public static VarEnum VT_I1;
    public static VarEnum VT_UI1;
    public static VarEnum VT_UI2;
    public static VarEnum VT_UI4;
    public static VarEnum VT_I8;
    public static VarEnum VT_UI8;
    public static VarEnum VT_INT;
    public static VarEnum VT_UINT;
    public static VarEnum VT_VOID;
    public static VarEnum VT_HRESULT;
    public static VarEnum VT_PTR;
    public static VarEnum VT_SAFEARRAY;
    public static VarEnum VT_CARRAY;
    public static VarEnum VT_USERDEFINED;
    public static VarEnum VT_LPSTR;
    public static VarEnum VT_LPWSTR;
    public static VarEnum VT_RECORD;
    public static VarEnum VT_FILETIME;
    public static VarEnum VT_BLOB;
    public static VarEnum VT_STREAM;
    public static VarEnum VT_STORAGE;
    public static VarEnum VT_STREAMED_OBJECT;
    public static VarEnum VT_STORED_OBJECT;
    public static VarEnum VT_BLOB_OBJECT;
    public static VarEnum VT_CF;
    public static VarEnum VT_CLSID;
    public static VarEnum VT_VECTOR;
    public static VarEnum VT_ARRAY;
    public static VarEnum VT_BYREF;
}
internal class System.Runtime.InteropServices.Variant : ValueType {
    private TypeUnion _typeUnion;
    private decimal _decimal;
    public VarEnum VariantType { get; }
    public bool IsEmpty { get; }
    public bool IsByRef { get; }
    public sbyte AsI1 { get; }
    public short AsI2 { get; }
    public int AsI4 { get; }
    public long AsI8 { get; }
    public byte AsUi1 { get; }
    public ushort AsUi2 { get; }
    public UInt32 AsUi4 { get; }
    public ulong AsUi8 { get; }
    public int AsInt { get; }
    public UInt32 AsUint { get; }
    public bool AsBool { get; }
    public int AsError { get; }
    public float AsR4 { get; }
    public double AsR8 { get; }
    public decimal AsDecimal { get; }
    public decimal AsCy { get; }
    public DateTime AsDate { get; }
    public string AsBstr { get; }
    public object AsUnknown { get; }
    public object AsDispatch { get; }
    public IntPtr AsByRefVariant { get; }
    public void CopyFromIndirect(object value);
    public object ToObject();
    public VarEnum get_VariantType();
    public bool get_IsEmpty();
    public bool get_IsByRef();
    public sbyte get_AsI1();
    public short get_AsI2();
    public int get_AsI4();
    public long get_AsI8();
    public byte get_AsUi1();
    public ushort get_AsUi2();
    public UInt32 get_AsUi4();
    public ulong get_AsUi8();
    public int get_AsInt();
    public UInt32 get_AsUint();
    public bool get_AsBool();
    public int get_AsError();
    public float get_AsR4();
    public double get_AsR8();
    public decimal get_AsDecimal();
    public decimal get_AsCy();
    public DateTime get_AsDate();
    public string get_AsBstr();
    public object get_AsUnknown();
    public object get_AsDispatch();
    public IntPtr get_AsByRefVariant();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Runtime.InteropServices.VariantWrapper : object {
    [CompilerGeneratedAttribute]
private object <WrappedObject>k__BackingField;
    public object WrappedObject { get; }
    public VariantWrapper(object obj);
    [CompilerGeneratedAttribute]
public object get_WrappedObject();
}
internal class System.Runtime.InteropServices.WindowsRuntime.BindableIterableToEnumerableAdapter : object {
    internal IEnumerator GetEnumerator_Stub();
}
internal class System.Runtime.InteropServices.WindowsRuntime.BindableVectorToCollectionAdapter : object {
    internal int Count();
    internal bool IsSynchronized();
    internal object SyncRoot();
    internal void CopyTo(Array array, int arrayIndex);
}
internal class System.Runtime.InteropServices.WindowsRuntime.BindableVectorToListAdapter : object {
    internal object Indexer_Get(int index);
    internal void Indexer_Set(int index, object value);
    internal int Add(object value);
    internal bool Contains(object item);
    internal void Clear();
    internal bool IsFixedSize();
    internal bool IsReadOnly();
    internal int IndexOf(object item);
    internal void Insert(int index, object item);
    internal void Remove(object item);
    internal void RemoveAt(int index);
    private static object GetAt(IBindableVector _this, UInt32 index);
    private static void SetAt(IBindableVector _this, UInt32 index, object value);
    private static void InsertAtHelper(IBindableVector _this, UInt32 index, object item);
    private static void RemoveAtHelper(IBindableVector _this, UInt32 index);
}
internal class System.Runtime.InteropServices.WindowsRuntime.CLRIKeyValuePairImpl`2 : object {
    private KeyValuePair`2<K, V> _pair;
    public K Key { get; }
    public V Value { get; }
    public CLRIKeyValuePairImpl`2(KeyValuePair`2& pair);
    public sealed virtual K get_Key();
    public sealed virtual V get_Value();
    internal static object BoxHelper(object pair);
    internal static object UnboxHelper(object wrapper);
    public virtual string ToString();
    private sealed virtual override object System.Runtime.InteropServices.WindowsRuntime.IGetProxyTarget.GetTarget();
}
internal class System.Runtime.InteropServices.WindowsRuntime.CLRIPropertyValueImpl : object {
    private PropertyType _type;
    private object _data;
    private static Tuple`2[] modreq(System.Runtime.CompilerServices.IsVolatile) s_numericScalarTypes;
    private static Tuple`2[] NumericScalarTypes { get; }
    public PropertyType Type { get; }
    public bool IsNumericScalar { get; }
    internal CLRIPropertyValueImpl(PropertyType type, object data);
    private static Tuple`2[] get_NumericScalarTypes();
    public sealed virtual PropertyType get_Type();
    public sealed virtual bool get_IsNumericScalar();
    public virtual string ToString();
    public sealed virtual byte GetUInt8();
    public sealed virtual short GetInt16();
    public sealed virtual ushort GetUInt16();
    public sealed virtual int GetInt32();
    public sealed virtual UInt32 GetUInt32();
    public sealed virtual long GetInt64();
    public sealed virtual ulong GetUInt64();
    public sealed virtual float GetSingle();
    public sealed virtual double GetDouble();
    public sealed virtual char GetChar16();
    public sealed virtual bool GetBoolean();
    public sealed virtual string GetString();
    public sealed virtual Guid GetGuid();
    public sealed virtual DateTimeOffset GetDateTime();
    public sealed virtual TimeSpan GetTimeSpan();
    public sealed virtual Point GetPoint();
    public sealed virtual Size GetSize();
    public sealed virtual Rect GetRect();
    public sealed virtual Byte[] GetUInt8Array();
    public sealed virtual Int16[] GetInt16Array();
    public sealed virtual UInt16[] GetUInt16Array();
    public sealed virtual Int32[] GetInt32Array();
    public sealed virtual UInt32[] GetUInt32Array();
    public sealed virtual Int64[] GetInt64Array();
    public sealed virtual UInt64[] GetUInt64Array();
    public sealed virtual Single[] GetSingleArray();
    public sealed virtual Double[] GetDoubleArray();
    public sealed virtual Char[] GetChar16Array();
    public sealed virtual Boolean[] GetBooleanArray();
    public sealed virtual String[] GetStringArray();
    public sealed virtual Object[] GetInspectableArray();
    public sealed virtual Guid[] GetGuidArray();
    public sealed virtual DateTimeOffset[] GetDateTimeArray();
    public sealed virtual TimeSpan[] GetTimeSpanArray();
    public sealed virtual Point[] GetPointArray();
    public sealed virtual Size[] GetSizeArray();
    public sealed virtual Rect[] GetRectArray();
    private T[] CoerceArrayValue(PropertyType unboxType);
    private T CoerceScalarValue(PropertyType unboxType);
    private static T CoerceScalarValue(PropertyType type, object value);
    private static bool IsCoercable(PropertyType type, object data);
    private static bool IsNumericScalarImpl(PropertyType type, object data);
    private T Unbox(Type expectedBoxedType);
    private T[] UnboxArray(Type expectedArrayElementType);
}
internal class System.Runtime.InteropServices.WindowsRuntime.CLRIReferenceArrayImpl`1 : CLRIPropertyValueImpl {
    private T[] _value;
    private IList _list;
    public T[] Value { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private int System.Collections.ICollection.Count { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    public CLRIReferenceArrayImpl`1(PropertyType type, T[] obj);
    public sealed virtual T[] get_Value();
    public virtual string ToString();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Runtime.InteropServices.WindowsRuntime.IGetProxyTarget.GetTarget();
    internal static object UnboxHelper(object wrapper);
}
internal class System.Runtime.InteropServices.WindowsRuntime.CLRIReferenceImpl`1 : CLRIPropertyValueImpl {
    private T _value;
    public T Value { get; }
    public CLRIReferenceImpl`1(PropertyType type, T obj);
    public sealed virtual T get_Value();
    public virtual string ToString();
    private sealed virtual override object System.Runtime.InteropServices.WindowsRuntime.IGetProxyTarget.GetTarget();
    internal static object UnboxHelper(object wrapper);
}
[DebuggerDisplayAttribute("Count = {Count}")]
internal class System.Runtime.InteropServices.WindowsRuntime.ConstantSplittableMap`2 : object {
    private static KeyValuePairComparator<TKey, TValue> keyValuePairComparator;
    private KeyValuePair`2[] items;
    private int firstItemIndex;
    private int lastItemIndex;
    public int Count { get; }
    public UInt32 Size { get; }
    internal ConstantSplittableMap`2(IReadOnlyDictionary`2<TKey, TValue> data);
    private ConstantSplittableMap`2(KeyValuePair`2[] items, int firstItemIndex, int lastItemIndex);
    private static ConstantSplittableMap`2();
    private KeyValuePair`2[] CreateKeyValueArray(int count, IEnumerator`1<KeyValuePair`2<TKey, TValue>> data);
    public int get_Count();
    public sealed virtual UInt32 get_Size();
    public sealed virtual TValue Lookup(TKey key);
    public sealed virtual bool HasKey(TKey key);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IIterator`1<IKeyValuePair`2<TKey, TValue>> First();
    public sealed virtual IEnumerator`1<IKeyValuePair`2<TKey, TValue>> GetEnumerator();
    public sealed virtual void Split(IMapView`2& firstPartition, IMapView`2& secondPartition);
    public bool TryGetValue(TKey key, TValue& value);
}
internal class System.Runtime.InteropServices.WindowsRuntime.CustomPropertyImpl : object {
    private PropertyInfo m_property;
    public string Name { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public Type Type { get; }
    public CustomPropertyImpl(PropertyInfo propertyInfo);
    public sealed virtual string get_Name();
    public sealed virtual bool get_CanRead();
    public sealed virtual bool get_CanWrite();
    public sealed virtual object GetValue(object target);
    public sealed virtual object GetValue(object target, object indexValue);
    public sealed virtual void SetValue(object target, object value);
    public sealed virtual void SetValue(object target, object value, object indexValue);
    private object InvokeInternal(object target, Object[] args, bool getValue);
    public sealed virtual Type get_Type();
}
[NullableContextAttribute("1")]
[AttributeUsageAttribute("1028")]
[NullableAttribute("0")]
public class System.Runtime.InteropServices.WindowsRuntime.DefaultInterfaceAttribute : Attribute {
    private Type m_defaultInterface;
    public Type DefaultInterface { get; }
    public DefaultInterfaceAttribute(Type defaultInterface);
    public Type get_DefaultInterface();
}
internal class System.Runtime.InteropServices.WindowsRuntime.DesignerNamespaceResolveEventArgs : EventArgs {
    private string _NamespaceName;
    private Collection`1<string> _ResolvedAssemblyFiles;
    public Collection`1<string> ResolvedAssemblyFiles { get; }
    public DesignerNamespaceResolveEventArgs(string namespaceName);
    public Collection`1<string> get_ResolvedAssemblyFiles();
}
[DebuggerDisplayAttribute("Count = {Count}")]
internal class System.Runtime.InteropServices.WindowsRuntime.DictionaryKeyCollection`2 : object {
    private IDictionary`2<TKey, TValue> dictionary;
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<TKey>.IsReadOnly { get; }
    public DictionaryKeyCollection`2(IDictionary`2<TKey, TValue> dictionary);
    public sealed virtual void CopyTo(TKey[] array, int index);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<TKey>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<TKey>.Add(TKey item);
    private sealed virtual override void System.Collections.Generic.ICollection<TKey>.Clear();
    public sealed virtual bool Contains(TKey item);
    private sealed virtual override bool System.Collections.Generic.ICollection<TKey>.Remove(TKey item);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<TKey> GetEnumerator();
}
internal class System.Runtime.InteropServices.WindowsRuntime.DictionaryKeyEnumerator`2 : object {
    private IDictionary`2<TKey, TValue> dictionary;
    private IEnumerator`1<KeyValuePair`2<TKey, TValue>> enumeration;
    private object System.Collections.IEnumerator.Current { get; }
    public TKey Current { get; }
    public DictionaryKeyEnumerator`2(IDictionary`2<TKey, TValue> dictionary);
    private sealed virtual override void System.IDisposable.Dispose();
    public sealed virtual bool MoveNext();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual TKey get_Current();
    public sealed virtual void Reset();
}
internal class System.Runtime.InteropServices.WindowsRuntime.DictionaryToMapAdapter : object {
    internal V Lookup(K key);
    internal UInt32 Size();
    internal bool HasKey(K key);
    internal IReadOnlyDictionary`2<K, V> GetView();
    internal bool Insert(K key, V value);
    internal void Remove(K key);
    internal void Clear();
}
[DebuggerDisplayAttribute("Count = {Count}")]
internal class System.Runtime.InteropServices.WindowsRuntime.DictionaryValueCollection`2 : object {
    private IDictionary`2<TKey, TValue> dictionary;
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<TValue>.IsReadOnly { get; }
    public DictionaryValueCollection`2(IDictionary`2<TKey, TValue> dictionary);
    public sealed virtual void CopyTo(TValue[] array, int index);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<TValue>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<TValue>.Add(TValue item);
    private sealed virtual override void System.Collections.Generic.ICollection<TValue>.Clear();
    public sealed virtual bool Contains(TValue item);
    private sealed virtual override bool System.Collections.Generic.ICollection<TValue>.Remove(TValue item);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<TValue> GetEnumerator();
}
internal class System.Runtime.InteropServices.WindowsRuntime.DictionaryValueEnumerator`2 : object {
    private IDictionary`2<TKey, TValue> dictionary;
    private IEnumerator`1<KeyValuePair`2<TKey, TValue>> enumeration;
    private object System.Collections.IEnumerator.Current { get; }
    public TValue Current { get; }
    public DictionaryValueEnumerator`2(IDictionary`2<TKey, TValue> dictionary);
    private sealed virtual override void System.IDisposable.Dispose();
    public sealed virtual bool MoveNext();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual TValue get_Current();
    public sealed virtual void Reset();
}
internal class System.Runtime.InteropServices.WindowsRuntime.EnumerableToBindableIterableAdapter : object {
    internal IBindableIterator First_Stub();
}
internal class System.Runtime.InteropServices.WindowsRuntime.EnumerableToIterableAdapter : object {
    internal IIterator`1<T> First_Stub();
}
internal class System.Runtime.InteropServices.WindowsRuntime.EnumeratorToIteratorAdapter`1 : object {
    private IEnumerator`1<T> m_enumerator;
    private bool m_firstItem;
    private bool m_hasCurrent;
    public T Current { get; }
    private object System.Runtime.InteropServices.WindowsRuntime.IBindableIterator.Current { get; }
    public bool HasCurrent { get; }
    internal EnumeratorToIteratorAdapter`1(IEnumerator`1<T> enumerator);
    public sealed virtual T get_Current();
    private sealed virtual override object System.Runtime.InteropServices.WindowsRuntime.IBindableIterator.get_Current();
    public sealed virtual bool get_HasCurrent();
    public sealed virtual bool MoveNext();
    public sealed virtual int GetMany(T[] items);
}
public class System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken : ValueType {
    private ulong _value;
    [CLSCompliantAttribute("False")]
public ulong Value { get; }
    [CLSCompliantAttribute("False")]
public EventRegistrationToken(ulong value);
    public ulong get_Value();
    public static bool op_Equality(EventRegistrationToken left, EventRegistrationToken right);
    public static bool op_Inequality(EventRegistrationToken left, EventRegistrationToken right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(EventRegistrationToken other);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Runtime.InteropServices.WindowsRuntime.EventRegistrationTokenTable`1 : object {
    private Dictionary`2<EventRegistrationToken, T> m_tokens;
    private T modreq(System.Runtime.CompilerServices.IsVolatile) m_invokeList;
    public T InvocationList { get; public set; }
    public T get_InvocationList();
    public void set_InvocationList(T value);
    public EventRegistrationToken AddEventHandler(T handler);
    private EventRegistrationToken AddEventHandlerNoLock(T handler);
    private static EventRegistrationToken GetPreferredToken(T handler);
    public bool RemoveEventHandler(EventRegistrationToken token, T& handler);
    public void RemoveEventHandler(EventRegistrationToken token);
    public void RemoveEventHandler(T handler);
    private void RemoveEventHandlerNoLock(EventRegistrationToken token);
    [NullableContextAttribute("1")]
public static EventRegistrationTokenTable`1<T> GetOrCreateEventRegistrationTokenTable(EventRegistrationTokenTable`1& refEventTable);
}
internal class System.Runtime.InteropServices.WindowsRuntime.GetEnumerator_Delegate`1 : MulticastDelegate {
    public GetEnumerator_Delegate`1(object object, IntPtr method);
    public virtual IEnumerator`1<T> Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual IEnumerator`1<T> EndInvoke(IAsyncResult result);
}
internal class System.Runtime.InteropServices.WindowsRuntime.HSTRING_HEADER : ValueType {
}
[GuidAttribute("00000035-0000-0000-C000-000000000046")]
[NullableContextAttribute("1")]
public interface System.Runtime.InteropServices.WindowsRuntime.IActivationFactory {
    public abstract virtual object ActivateInstance();
}
[GuidAttribute("036d2c08-df29-41af-8aa2-d774be62ba6f")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IBindableIterable {
    public abstract virtual IBindableIterator First();
}
[GuidAttribute("6a1d6c07-076d-49f2-8314-f52c9c9a8331")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IBindableIterator {
    public object Current { get; }
    public bool HasCurrent { get; }
    public abstract virtual object get_Current();
    public abstract virtual bool get_HasCurrent();
    public abstract virtual bool MoveNext();
}
[GuidAttribute("393de7de-6fd0-4c0d-bb71-47244a113e93")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IBindableVector {
    public UInt32 Size { get; }
    public abstract virtual object GetAt(UInt32 index);
    public abstract virtual UInt32 get_Size();
    public abstract virtual IBindableVectorView GetView();
    public abstract virtual bool IndexOf(object value, UInt32& index);
    public abstract virtual void SetAt(UInt32 index, object value);
    public abstract virtual void InsertAt(UInt32 index, object value);
    public abstract virtual void RemoveAt(UInt32 index);
    public abstract virtual void Append(object value);
    public abstract virtual void RemoveAtEnd();
    public abstract virtual void Clear();
}
[GuidAttribute("346dd6e7-976e-4bc3-815d-ece243bc0f33")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IBindableVectorView {
    public UInt32 Size { get; }
    public abstract virtual object GetAt(UInt32 index);
    public abstract virtual UInt32 get_Size();
    public abstract virtual bool IndexOf(object value, UInt32& index);
}
[GuidAttribute("30d5a829-7fa4-4026-83bb-d75bae4ea99e")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IClosable {
    public abstract virtual void Close();
}
internal class System.Runtime.InteropServices.WindowsRuntime.IClosableToIDisposableAdapter : object {
    private void Dispose();
}
[GuidAttribute("30DA92C0-23E8-42A0-AE7C-734A0E5D2782")]
internal interface System.Runtime.InteropServices.WindowsRuntime.ICustomProperty {
    public Type Type { get; }
    public string Name { get; }
    public bool CanWrite { get; }
    public bool CanRead { get; }
    public abstract virtual Type get_Type();
    public abstract virtual string get_Name();
    public abstract virtual object GetValue(object target);
    public abstract virtual void SetValue(object target, object value);
    public abstract virtual object GetValue(object target, object indexValue);
    public abstract virtual void SetValue(object target, object value, object indexValue);
    public abstract virtual bool get_CanWrite();
    public abstract virtual bool get_CanRead();
}
internal static class System.Runtime.InteropServices.WindowsRuntime.ICustomPropertyProviderImpl : object {
    internal static ICustomProperty CreateProperty(object target, string propertyName);
    internal static ICustomProperty CreateIndexedProperty(object target, string propertyName, TypeNameNative* pIndexedParamType);
    internal static ICustomProperty CreateIndexedProperty(object target, string propertyName, Type indexedParamType);
    internal static void GetType(object target, TypeNameNative* pIndexedParamType);
}
internal class System.Runtime.InteropServices.WindowsRuntime.ICustomPropertyProviderProxy`2 : object {
    private object _target;
    private InterfaceForwardingSupport _flags;
    private UInt32 System.Runtime.InteropServices.WindowsRuntime.IBindableVector.Size { get; }
    private UInt32 System.Runtime.InteropServices.WindowsRuntime.IBindableVectorView.Size { get; }
    internal ICustomPropertyProviderProxy`2(object target, InterfaceForwardingSupport flags);
    internal static object CreateInstance(object target);
    public virtual string ToString();
    private sealed virtual override object System.Runtime.InteropServices.WindowsRuntime.IGetProxyTarget.GetTarget();
    public sealed virtual CustomQueryInterfaceResult GetInterface(Guid& iid, IntPtr& ppv);
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override object System.Runtime.InteropServices.WindowsRuntime.IBindableVector.GetAt(UInt32 index);
    private sealed virtual override UInt32 System.Runtime.InteropServices.WindowsRuntime.IBindableVector.get_Size();
    private sealed virtual override IBindableVectorView System.Runtime.InteropServices.WindowsRuntime.IBindableVector.GetView();
    private sealed virtual override bool System.Runtime.InteropServices.WindowsRuntime.IBindableVector.IndexOf(object value, UInt32& index);
    private sealed virtual override void System.Runtime.InteropServices.WindowsRuntime.IBindableVector.SetAt(UInt32 index, object value);
    private sealed virtual override void System.Runtime.InteropServices.WindowsRuntime.IBindableVector.InsertAt(UInt32 index, object value);
    private sealed virtual override void System.Runtime.InteropServices.WindowsRuntime.IBindableVector.RemoveAt(UInt32 index);
    private sealed virtual override void System.Runtime.InteropServices.WindowsRuntime.IBindableVector.Append(object value);
    private sealed virtual override void System.Runtime.InteropServices.WindowsRuntime.IBindableVector.RemoveAtEnd();
    private sealed virtual override void System.Runtime.InteropServices.WindowsRuntime.IBindableVector.Clear();
    private IBindableVector GetIBindableVectorNoThrow();
    private IVector_Raw`1<T1> GetVectorOfT();
    private sealed virtual override object System.Runtime.InteropServices.WindowsRuntime.IBindableVectorView.GetAt(UInt32 index);
    private sealed virtual override UInt32 System.Runtime.InteropServices.WindowsRuntime.IBindableVectorView.get_Size();
    private sealed virtual override bool System.Runtime.InteropServices.WindowsRuntime.IBindableVectorView.IndexOf(object value, UInt32& index);
    private sealed virtual override IBindableIterator System.Runtime.InteropServices.WindowsRuntime.IBindableIterable.First();
    private IBindableVectorView GetIBindableVectorViewNoThrow();
    private IVectorView`1<T2> GetVectorViewOfT();
    private static T ConvertTo(object value);
}
internal class System.Runtime.InteropServices.WindowsRuntime.IDisposableToIClosableAdapter : object {
    public void Close();
}
internal interface System.Runtime.InteropServices.WindowsRuntime.IGetProxyTarget {
    public abstract virtual object GetTarget();
}
[GuidAttribute("faa585ea-6214-4217-afda-7f46de5869b3")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IIterable`1 {
    public abstract virtual IIterator`1<T> First();
}
[GuidAttribute("6a79e863-4300-459a-9966-cbb660963ee1")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IIterator`1 {
    public T Current { get; }
    public bool HasCurrent { get; }
    public abstract virtual T get_Current();
    public abstract virtual bool get_HasCurrent();
    public abstract virtual bool MoveNext();
    public abstract virtual int GetMany(T[] items);
}
[GuidAttribute("02b51929-c1c4-4a7e-8940-0312b5c18500")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IKeyValuePair`2 {
    public K Key { get; }
    public V Value { get; }
    public abstract virtual K get_Key();
    public abstract virtual V get_Value();
}
[GuidAttribute("60D27C8D-5F61-4CCE-B751-690FAE66AA53")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IManagedActivationFactory {
    public abstract virtual void RunClassConstructor();
}
[GuidAttribute("3c2925fe-8519-45c1-aa79-197b6718c1c1")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IMap`2 {
    public UInt32 Size { get; }
    public abstract virtual V Lookup(K key);
    public abstract virtual UInt32 get_Size();
    public abstract virtual bool HasKey(K key);
    public abstract virtual IReadOnlyDictionary`2<K, V> GetView();
    public abstract virtual bool Insert(K key, V value);
    public abstract virtual void Remove(K key);
    public abstract virtual void Clear();
}
[GuidAttribute("e480ce40-a338-4ada-adcf-272272e48cb9")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IMapView`2 {
    public UInt32 Size { get; }
    public abstract virtual V Lookup(K key);
    public abstract virtual UInt32 get_Size();
    public abstract virtual bool HasKey(K key);
    public abstract virtual void Split(IMapView`2& first, IMapView`2& second);
}
[DebuggerDisplayAttribute("Count = {Count}")]
internal class System.Runtime.InteropServices.WindowsRuntime.IMapViewToIReadOnlyDictionaryAdapter : object {
    internal V Indexer_Get(K key);
    internal IEnumerable`1<K> Keys();
    internal IEnumerable`1<V> Values();
    internal bool ContainsKey(K key);
    internal bool TryGetValue(K key, V& value);
    private static V Lookup(IMapView`2<K, V> _this, K key);
}
internal class System.Runtime.InteropServices.WindowsRuntime.Indexer_Get_Delegate`1 : MulticastDelegate {
    public Indexer_Get_Delegate`1(object object, IntPtr method);
    public virtual T Invoke(int index);
    public virtual IAsyncResult BeginInvoke(int index, AsyncCallback callback, object object);
    public virtual T EndInvoke(IAsyncResult result);
}
[FlagsAttribute]
internal enum System.Runtime.InteropServices.WindowsRuntime.InterfaceForwardingSupport : Enum {
    public int value__;
    public static InterfaceForwardingSupport None;
    public static InterfaceForwardingSupport IBindableVector;
    public static InterfaceForwardingSupport IVector;
    public static InterfaceForwardingSupport IBindableVectorView;
    public static InterfaceForwardingSupport IVectorView;
    public static InterfaceForwardingSupport IBindableIterableOrIIterable;
}
[NullableContextAttribute("1")]
[AttributeUsageAttribute("1028")]
[NullableAttribute("0")]
public class System.Runtime.InteropServices.WindowsRuntime.InterfaceImplementedInVersionAttribute : Attribute {
    private Type m_interfaceType;
    private byte m_majorVersion;
    private byte m_minorVersion;
    private byte m_buildVersion;
    private byte m_revisionVersion;
    public Type InterfaceType { get; }
    public byte MajorVersion { get; }
    public byte MinorVersion { get; }
    public byte BuildVersion { get; }
    public byte RevisionVersion { get; }
    public InterfaceImplementedInVersionAttribute(Type interfaceType, byte majorVersion, byte minorVersion, byte buildVersion, byte revisionVersion);
    public Type get_InterfaceType();
    public byte get_MajorVersion();
    public byte get_MinorVersion();
    public byte get_BuildVersion();
    public byte get_RevisionVersion();
}
[GuidAttribute("4bd682dd-7554-40e9-9a9b-82654ede7e62")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IPropertyValue {
    public PropertyType Type { get; }
    public bool IsNumericScalar { get; }
    public abstract virtual PropertyType get_Type();
    public abstract virtual bool get_IsNumericScalar();
    public abstract virtual byte GetUInt8();
    public abstract virtual short GetInt16();
    public abstract virtual ushort GetUInt16();
    public abstract virtual int GetInt32();
    public abstract virtual UInt32 GetUInt32();
    public abstract virtual long GetInt64();
    public abstract virtual ulong GetUInt64();
    public abstract virtual float GetSingle();
    public abstract virtual double GetDouble();
    public abstract virtual char GetChar16();
    public abstract virtual bool GetBoolean();
    public abstract virtual string GetString();
    public abstract virtual Guid GetGuid();
    public abstract virtual DateTimeOffset GetDateTime();
    public abstract virtual TimeSpan GetTimeSpan();
    public abstract virtual Point GetPoint();
    public abstract virtual Size GetSize();
    public abstract virtual Rect GetRect();
    public abstract virtual Byte[] GetUInt8Array();
    public abstract virtual Int16[] GetInt16Array();
    public abstract virtual UInt16[] GetUInt16Array();
    public abstract virtual Int32[] GetInt32Array();
    public abstract virtual UInt32[] GetUInt32Array();
    public abstract virtual Int64[] GetInt64Array();
    public abstract virtual UInt64[] GetUInt64Array();
    public abstract virtual Single[] GetSingleArray();
    public abstract virtual Double[] GetDoubleArray();
    public abstract virtual Char[] GetChar16Array();
    public abstract virtual Boolean[] GetBooleanArray();
    public abstract virtual String[] GetStringArray();
    public abstract virtual Object[] GetInspectableArray();
    public abstract virtual Guid[] GetGuidArray();
    public abstract virtual DateTimeOffset[] GetDateTimeArray();
    public abstract virtual TimeSpan[] GetTimeSpanArray();
    public abstract virtual Point[] GetPointArray();
    public abstract virtual Size[] GetSizeArray();
    public abstract virtual Rect[] GetRectArray();
}
[DebuggerDisplayAttribute("Size = {Size}")]
internal class System.Runtime.InteropServices.WindowsRuntime.IReadOnlyDictionaryToIMapViewAdapter : object {
    internal V Lookup(K key);
    internal UInt32 Size();
    internal bool HasKey(K key);
    internal void Split(IMapView`2& first, IMapView`2& second);
}
[DebuggerDisplayAttribute("Size = {Size}")]
internal class System.Runtime.InteropServices.WindowsRuntime.IReadOnlyListToIVectorViewAdapter : object {
    internal T GetAt(UInt32 index);
    internal UInt32 Size();
    internal bool IndexOf(T value, UInt32& index);
    internal UInt32 GetMany(UInt32 startIndex, T[] items);
    private static void EnsureIndexInt32(UInt32 index, int listCapacity);
}
[GuidAttribute("61c17706-2d65-11e0-9ae8-d48564015472")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IReference`1 {
    public T Value { get; }
    public abstract virtual T get_Value();
}
[GuidAttribute("61c17707-2d65-11e0-9ae8-d48564015472")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IReferenceArray`1 {
    public T[] Value { get; }
    public abstract virtual T[] get_Value();
}
internal static class System.Runtime.InteropServices.WindowsRuntime.IReferenceFactory : object {
    internal static Type s_pointType;
    internal static Type s_rectType;
    internal static Type s_sizeType;
    private static IReferenceFactory();
    internal static object CreateIReference(object obj);
    internal static object CreateIReferenceArray(Array obj);
}
[GuidAttribute("82BA7092-4C88-427D-A7BC-16DD93FEB67E")]
[InterfaceTypeAttribute("1")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IRestrictedErrorInfo {
    public abstract virtual void GetErrorDetails(String& description, Int32& error, String& restrictedDescription, String& capabilitySid);
    public abstract virtual void GetReference(String& reference);
}
[GuidAttribute("96369f54-8eb6-48f0-abce-c1b211e627c3")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IStringable {
    public abstract virtual string ToString();
}
internal class System.Runtime.InteropServices.WindowsRuntime.IStringableHelper : object {
    internal static string ToString(object obj);
}
internal class System.Runtime.InteropServices.WindowsRuntime.IterableToEnumerableAdapter : object {
    internal IEnumerator`1<T> GetEnumerator_Stub();
    internal IEnumerator`1<T> GetEnumerator_Variance_Stub();
}
internal class System.Runtime.InteropServices.WindowsRuntime.IteratorToEnumeratorAdapter`1 : object {
    private IIterator`1<T> m_iterator;
    private bool m_hadCurrent;
    private T m_current;
    private bool m_isInitialized;
    public T Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal IteratorToEnumeratorAdapter`1(IIterator`1<T> iterator);
    public sealed virtual T get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual void Dispose();
}
[GuidAttribute("913337e9-11a1-4345-a3a2-4e7f956e222d")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IVector_Raw`1 {
    public UInt32 Size { get; }
    public abstract virtual T GetAt(UInt32 index);
    public abstract virtual UInt32 get_Size();
    public abstract virtual IVectorView`1<T> GetView();
    public abstract virtual bool IndexOf(T value, UInt32& index);
    public abstract virtual void SetAt(UInt32 index, T value);
    public abstract virtual void InsertAt(UInt32 index, T value);
    public abstract virtual void RemoveAt(UInt32 index);
    public abstract virtual void Append(T value);
    public abstract virtual void RemoveAtEnd();
    public abstract virtual void Clear();
}
[GuidAttribute("913337e9-11a1-4345-a3a2-4e7f956e222d")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IVector`1 {
    public UInt32 Size { get; }
    public abstract virtual T GetAt(UInt32 index);
    public abstract virtual UInt32 get_Size();
    public abstract virtual IReadOnlyList`1<T> GetView();
    public abstract virtual bool IndexOf(T value, UInt32& index);
    public abstract virtual void SetAt(UInt32 index, T value);
    public abstract virtual void InsertAt(UInt32 index, T value);
    public abstract virtual void RemoveAt(UInt32 index);
    public abstract virtual void Append(T value);
    public abstract virtual void RemoveAtEnd();
    public abstract virtual void Clear();
    public abstract virtual UInt32 GetMany(UInt32 startIndex, T[] items);
    public abstract virtual void ReplaceAll(T[] items);
}
[GuidAttribute("bbe1fa4c-b0e3-4583-baef-1f1b2e483e56")]
internal interface System.Runtime.InteropServices.WindowsRuntime.IVectorView`1 {
    public UInt32 Size { get; }
    public abstract virtual T GetAt(UInt32 index);
    public abstract virtual UInt32 get_Size();
    public abstract virtual bool IndexOf(T value, UInt32& index);
    public abstract virtual UInt32 GetMany(UInt32 startIndex, T[] items);
}
[DebuggerDisplayAttribute("Count = {Count}")]
internal class System.Runtime.InteropServices.WindowsRuntime.IVectorViewToIReadOnlyListAdapter : object {
    internal T Indexer_Get(int index);
    internal T Indexer_Get_Variance(int index);
}
internal class System.Runtime.InteropServices.WindowsRuntime.ListToBindableVectorAdapter : object {
    internal object GetAt(UInt32 index);
    internal UInt32 Size();
    internal IBindableVectorView GetView();
    internal bool IndexOf(object value, UInt32& index);
    internal void SetAt(UInt32 index, object value);
    internal void InsertAt(UInt32 index, object value);
    internal void RemoveAt(UInt32 index);
    internal void Append(object value);
    internal void RemoveAtEnd();
    internal void Clear();
    private static void EnsureIndexInt32(UInt32 index, int listCapacity);
}
internal class System.Runtime.InteropServices.WindowsRuntime.ListToBindableVectorViewAdapter : object {
    private IList list;
    public UInt32 Size { get; }
    internal ListToBindableVectorViewAdapter(IList list);
    private static void EnsureIndexInt32(UInt32 index, int listCapacity);
    public sealed virtual IBindableIterator First();
    public sealed virtual object GetAt(UInt32 index);
    public sealed virtual UInt32 get_Size();
    public sealed virtual bool IndexOf(object value, UInt32& index);
}
internal class System.Runtime.InteropServices.WindowsRuntime.ListToVectorAdapter : object {
    internal T GetAt(UInt32 index);
    internal UInt32 Size();
    internal IReadOnlyList`1<T> GetView();
    internal bool IndexOf(T value, UInt32& index);
    internal void SetAt(UInt32 index, T value);
    internal void InsertAt(UInt32 index, T value);
    internal void RemoveAt(UInt32 index);
    internal void Append(T value);
    internal void RemoveAtEnd();
    internal void Clear();
    internal UInt32 GetMany(UInt32 startIndex, T[] items);
    internal void ReplaceAll(T[] items);
    private static void EnsureIndexInt32(UInt32 index, int listCapacity);
    private static UInt32 GetManyHelper(IList`1<T> sourceList, UInt32 startIndex, T[] items);
}
[ComVisibleAttribute("True")]
[ClassInterfaceAttribute("0")]
internal class System.Runtime.InteropServices.WindowsRuntime.ManagedActivationFactory : object {
    private Type m_type;
    internal ManagedActivationFactory(Type type);
    public sealed virtual object ActivateInstance();
    private sealed virtual override void System.Runtime.InteropServices.WindowsRuntime.IManagedActivationFactory.RunClassConstructor();
}
internal class System.Runtime.InteropServices.WindowsRuntime.MapToCollectionAdapter : object {
    internal int Count();
    internal bool IsReadOnly();
    internal void Add(KeyValuePair`2<K, V> item);
    internal void Clear();
    internal bool Contains(KeyValuePair`2<K, V> item);
    internal void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    internal bool Remove(KeyValuePair`2<K, V> item);
}
internal class System.Runtime.InteropServices.WindowsRuntime.MapToDictionaryAdapter : object {
    internal V Indexer_Get(K key);
    internal void Indexer_Set(K key, V value);
    internal ICollection`1<K> Keys();
    internal ICollection`1<V> Values();
    internal bool ContainsKey(K key);
    internal void Add(K key, V value);
    internal bool Remove(K key);
    internal bool TryGetValue(K key, V& value);
    private static V Lookup(IMap`2<K, V> _this, K key);
    private static bool Insert(IMap`2<K, V> _this, K key, V value);
}
internal class System.Runtime.InteropServices.WindowsRuntime.MapViewToReadOnlyCollectionAdapter : object {
    internal int Count();
}
internal class System.Runtime.InteropServices.WindowsRuntime.Point : ValueType {
}
internal enum System.Runtime.InteropServices.WindowsRuntime.PropertyType : Enum {
    public int value__;
    public static PropertyType Empty;
    public static PropertyType UInt8;
    public static PropertyType Int16;
    public static PropertyType UInt16;
    public static PropertyType Int32;
    public static PropertyType UInt32;
    public static PropertyType Int64;
    public static PropertyType UInt64;
    public static PropertyType Single;
    public static PropertyType Double;
    public static PropertyType Char16;
    public static PropertyType Boolean;
    public static PropertyType String;
    public static PropertyType Inspectable;
    public static PropertyType DateTime;
    public static PropertyType TimeSpan;
    public static PropertyType Guid;
    public static PropertyType Point;
    public static PropertyType Size;
    public static PropertyType Rect;
    public static PropertyType Other;
    public static PropertyType UInt8Array;
    public static PropertyType Int16Array;
    public static PropertyType UInt16Array;
    public static PropertyType Int32Array;
    public static PropertyType UInt32Array;
    public static PropertyType Int64Array;
    public static PropertyType UInt64Array;
    public static PropertyType SingleArray;
    public static PropertyType DoubleArray;
    public static PropertyType Char16Array;
    public static PropertyType BooleanArray;
    public static PropertyType StringArray;
    public static PropertyType InspectableArray;
    public static PropertyType DateTimeArray;
    public static PropertyType TimeSpanArray;
    public static PropertyType GuidArray;
    public static PropertyType PointArray;
    public static PropertyType SizeArray;
    public static PropertyType RectArray;
    public static PropertyType OtherArray;
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.InteropServices.WindowsRuntime.ReadOnlyArrayAttribute : Attribute {
}
[DebuggerDisplayAttribute("Count = {Count}")]
internal class System.Runtime.InteropServices.WindowsRuntime.ReadOnlyDictionaryKeyCollection`2 : object {
    private IReadOnlyDictionary`2<TKey, TValue> dictionary;
    public ReadOnlyDictionaryKeyCollection`2(IReadOnlyDictionary`2<TKey, TValue> dictionary);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<TKey> GetEnumerator();
}
internal class System.Runtime.InteropServices.WindowsRuntime.ReadOnlyDictionaryKeyEnumerator`2 : object {
    private IReadOnlyDictionary`2<TKey, TValue> dictionary;
    private IEnumerator`1<KeyValuePair`2<TKey, TValue>> enumeration;
    private object System.Collections.IEnumerator.Current { get; }
    public TKey Current { get; }
    public ReadOnlyDictionaryKeyEnumerator`2(IReadOnlyDictionary`2<TKey, TValue> dictionary);
    private sealed virtual override void System.IDisposable.Dispose();
    public sealed virtual bool MoveNext();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual TKey get_Current();
    public sealed virtual void Reset();
}
[DebuggerDisplayAttribute("Count = {Count}")]
internal class System.Runtime.InteropServices.WindowsRuntime.ReadOnlyDictionaryValueCollection`2 : object {
    private IReadOnlyDictionary`2<TKey, TValue> dictionary;
    public ReadOnlyDictionaryValueCollection`2(IReadOnlyDictionary`2<TKey, TValue> dictionary);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<TValue> GetEnumerator();
}
internal class System.Runtime.InteropServices.WindowsRuntime.ReadOnlyDictionaryValueEnumerator`2 : object {
    private IReadOnlyDictionary`2<TKey, TValue> dictionary;
    private IEnumerator`1<KeyValuePair`2<TKey, TValue>> enumeration;
    private object System.Collections.IEnumerator.Current { get; }
    public TValue Current { get; }
    public ReadOnlyDictionaryValueEnumerator`2(IReadOnlyDictionary`2<TKey, TValue> dictionary);
    private sealed virtual override void System.IDisposable.Dispose();
    public sealed virtual bool MoveNext();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual TValue get_Current();
    public sealed virtual void Reset();
}
internal class System.Runtime.InteropServices.WindowsRuntime.Rect : ValueType {
}
[NullableContextAttribute("1")]
[AttributeUsageAttribute("12288")]
[NullableAttribute("0")]
public class System.Runtime.InteropServices.WindowsRuntime.ReturnValueNameAttribute : Attribute {
    private string m_Name;
    public string Name { get; }
    public ReturnValueNameAttribute(string name);
    public string get_Name();
}
internal abstract class System.Runtime.InteropServices.WindowsRuntime.RuntimeClass : __ComObject {
    internal IntPtr GetRedirectedGetHashCodeMD();
    internal int RedirectGetHashCode(IntPtr pMD);
    public virtual int GetHashCode();
    internal IntPtr GetRedirectedToStringMD();
    internal string RedirectToString(IntPtr pMD);
    public virtual string ToString();
    internal IntPtr GetRedirectedEqualsMD();
    internal bool RedirectEquals(object obj, IntPtr pMD);
    public virtual bool Equals(object obj);
}
internal class System.Runtime.InteropServices.WindowsRuntime.Size : ValueType {
}
internal static class System.Runtime.InteropServices.WindowsRuntime.UnsafeNativeMethods : object {
    internal static IRestrictedErrorInfo GetRestrictedErrorInfo();
    internal static bool RoOriginateLanguageException(int error, string message, IntPtr languageException);
    internal static void RoReportUnhandledError(IRestrictedErrorInfo error);
    internal static int WindowsCreateString(string sourceString, int length, IntPtr* hstring);
    internal static int WindowsCreateStringReference(Char* sourceString, int length, HSTRING_HEADER* hstringHeader, IntPtr* hstring);
    internal static int WindowsDeleteString(IntPtr hstring);
    internal static Char* WindowsGetStringRawBuffer(IntPtr hstring, UInt32* length);
}
internal class System.Runtime.InteropServices.WindowsRuntime.VectorToCollectionAdapter : object {
    internal int Count();
    internal bool IsReadOnly();
    internal void Add(T item);
    internal void Clear();
    internal bool Contains(T item);
    internal void CopyTo(T[] array, int arrayIndex);
    internal bool Remove(T item);
}
internal class System.Runtime.InteropServices.WindowsRuntime.VectorToListAdapter : object {
    internal T Indexer_Get(int index);
    internal void Indexer_Set(int index, T value);
    internal int IndexOf(T item);
    internal void Insert(int index, T item);
    internal void RemoveAt(int index);
    internal static T GetAt(IVector`1<T> _this, UInt32 index);
    private static void SetAt(IVector`1<T> _this, UInt32 index, T value);
    private static void InsertAtHelper(IVector`1<T> _this, UInt32 index, T item);
    internal static void RemoveAtHelper(IVector`1<T> _this, UInt32 index);
}
internal class System.Runtime.InteropServices.WindowsRuntime.VectorViewToReadOnlyCollectionAdapter : object {
    internal int Count();
}
[GuidAttribute("9de1c535-6ae1-11e0-84e1-18a905bcc53f")]
internal class System.Runtime.InteropServices.WindowsRuntime.WindowsFoundationEventHandler`1 : MulticastDelegate {
    public WindowsFoundationEventHandler`1(object object, IntPtr method);
    public virtual void Invoke(object sender, T args);
    public virtual IAsyncResult BeginInvoke(object sender, T args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeMarshal : object {
    private static bool s_haveBlueErrorApis;
    private static Guid s_iidIErrorInfo;
    private static WindowsRuntimeMarshal();
    public static void AddEventHandler(Func`2<T, EventRegistrationToken> addMethod, Action`1<EventRegistrationToken> removeMethod, T handler);
    public static void RemoveEventHandler(Action`1<EventRegistrationToken> removeMethod, T handler);
    public static void RemoveAllEventHandlers(Action`1<EventRegistrationToken> removeMethod);
    internal static int GetRegistrationTokenCacheSize();
    internal static void CallRemoveMethods(Action`1<EventRegistrationToken> removeMethod, List`1<EventRegistrationToken> tokensToRemove);
    internal static string HStringToString(IntPtr hstring);
    internal static Exception GetExceptionForHR(int hresult, Exception innerException, string messageResource);
    internal static Exception GetExceptionForHR(int hresult, Exception innerException);
    private static bool RoOriginateLanguageException(int error, string message, IntPtr languageException);
    private static void RoReportUnhandledError(IRestrictedErrorInfo error);
    internal static bool ReportUnhandledError(Exception e);
    internal static IntPtr GetActivationFactoryForType(Type type);
    internal static ManagedActivationFactory GetManagedActivationFactory(Type type);
    public static IActivationFactory GetActivationFactory(Type type);
    public static IntPtr StringToHString(string s);
    public static string PtrToStringHString(IntPtr ptr);
    public static void FreeHString(IntPtr ptr);
    public static object GetUniqueObjectForIUnknownWithoutUnboxing(IntPtr unknown);
    internal static void InitializeWrapper(object o, IntPtr& pUnk);
    internal static int GetHRForException(Exception e);
    internal static void InitializeManagedWinRTFactoryObject(object o, RuntimeType runtimeClassType);
    internal static object GetNativeActivationFactory(Type type);
    [ConditionalAttribute("_LOGGING")]
private static void Log(string s);
}
internal static class System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeMetadata : object {
    private static EventHandler`1<DesignerNamespaceResolveEventArgs> DesignerNamespaceResolve;
    internal static String[] OnDesignerNamespaceResolve(string namespaceName);
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.InteropServices.WindowsRuntime.WriteOnlyArrayAttribute : Attribute {
}
[CLSCompliantAttribute("False")]
public static class System.Runtime.Intrinsics.Arm.Arm64.Aes : object {
    public static bool IsSupported { get; }
    [IntrinsicAttribute]
public static bool get_IsSupported();
    public static Vector128`1<byte> Decrypt(Vector128`1<byte> value, Vector128`1<byte> roundKey);
    public static Vector128`1<byte> Encrypt(Vector128`1<byte> value, Vector128`1<byte> roundKey);
    public static Vector128`1<byte> MixColumns(Vector128`1<byte> value);
    public static Vector128`1<byte> InverseMixColumns(Vector128`1<byte> value);
}
[CLSCompliantAttribute("False")]
public static class System.Runtime.Intrinsics.Arm.Arm64.Base : object {
    public static bool IsSupported { get; }
    [IntrinsicAttribute]
public static bool get_IsSupported();
    public static int LeadingSignCount(int value);
    public static int LeadingSignCount(long value);
    public static int LeadingZeroCount(int value);
    public static int LeadingZeroCount(UInt32 value);
    public static int LeadingZeroCount(long value);
    public static int LeadingZeroCount(ulong value);
}
[CLSCompliantAttribute("False")]
public static class System.Runtime.Intrinsics.Arm.Arm64.Sha1 : object {
    public static bool IsSupported { get; }
    [IntrinsicAttribute]
public static bool get_IsSupported();
    public static Vector128`1<UInt32> HashChoose(Vector128`1<UInt32> hash_abcd, UInt32 hash_e, Vector128`1<UInt32> wk);
    public static Vector128`1<UInt32> HashMajority(Vector128`1<UInt32> hash_abcd, UInt32 hash_e, Vector128`1<UInt32> wk);
    public static Vector128`1<UInt32> HashParity(Vector128`1<UInt32> hash_abcd, UInt32 hash_e, Vector128`1<UInt32> wk);
    public static UInt32 FixedRotate(UInt32 hash_e);
    public static Vector128`1<UInt32> SchedulePart1(Vector128`1<UInt32> w0_3, Vector128`1<UInt32> w4_7, Vector128`1<UInt32> w8_11);
    public static Vector128`1<UInt32> SchedulePart2(Vector128`1<UInt32> tw0_3, Vector128`1<UInt32> w12_15);
}
[CLSCompliantAttribute("False")]
public static class System.Runtime.Intrinsics.Arm.Arm64.Sha256 : object {
    public static bool IsSupported { get; }
    [IntrinsicAttribute]
public static bool get_IsSupported();
    public static Vector128`1<UInt32> HashLower(Vector128`1<UInt32> hash_abcd, Vector128`1<UInt32> hash_efgh, Vector128`1<UInt32> wk);
    public static Vector128`1<UInt32> HashUpper(Vector128`1<UInt32> hash_efgh, Vector128`1<UInt32> hash_abcd, Vector128`1<UInt32> wk);
    public static Vector128`1<UInt32> SchedulePart1(Vector128`1<UInt32> w0_3, Vector128`1<UInt32> w4_7);
    public static Vector128`1<UInt32> SchedulePart2(Vector128`1<UInt32> w0_3, Vector128`1<UInt32> w8_11, Vector128`1<UInt32> w12_15);
}
[CLSCompliantAttribute("False")]
public static class System.Runtime.Intrinsics.Arm.Arm64.Simd : object {
    public static bool IsSupported { get; }
    [IntrinsicAttribute]
public static bool get_IsSupported();
    public static Vector64`1<byte> Abs(Vector64`1<sbyte> value);
    public static Vector64`1<ushort> Abs(Vector64`1<short> value);
    public static Vector64`1<UInt32> Abs(Vector64`1<int> value);
    public static Vector64`1<float> Abs(Vector64`1<float> value);
    public static Vector128`1<byte> Abs(Vector128`1<sbyte> value);
    public static Vector128`1<ushort> Abs(Vector128`1<short> value);
    public static Vector128`1<UInt32> Abs(Vector128`1<int> value);
    public static Vector128`1<ulong> Abs(Vector128`1<long> value);
    public static Vector128`1<float> Abs(Vector128`1<float> value);
    public static Vector128`1<double> Abs(Vector128`1<double> value);
    public static Vector64`1<T> Add(Vector64`1<T> left, Vector64`1<T> right);
    public static Vector128`1<T> Add(Vector128`1<T> left, Vector128`1<T> right);
    public static Vector64`1<T> And(Vector64`1<T> left, Vector64`1<T> right);
    public static Vector128`1<T> And(Vector128`1<T> left, Vector128`1<T> right);
    public static Vector64`1<T> AndNot(Vector64`1<T> left, Vector64`1<T> right);
    public static Vector128`1<T> AndNot(Vector128`1<T> left, Vector128`1<T> right);
    public static Vector64`1<T> BitwiseSelect(Vector64`1<T> sel, Vector64`1<T> left, Vector64`1<T> right);
    public static Vector128`1<T> BitwiseSelect(Vector128`1<T> sel, Vector128`1<T> left, Vector128`1<T> right);
    public static Vector64`1<T> CompareEqual(Vector64`1<T> left, Vector64`1<T> right);
    public static Vector128`1<T> CompareEqual(Vector128`1<T> left, Vector128`1<T> right);
    public static Vector64`1<T> CompareEqualZero(Vector64`1<T> value);
    public static Vector128`1<T> CompareEqualZero(Vector128`1<T> value);
    public static Vector64`1<T> CompareGreaterThan(Vector64`1<T> left, Vector64`1<T> right);
    public static Vector128`1<T> CompareGreaterThan(Vector128`1<T> left, Vector128`1<T> right);
    public static Vector64`1<T> CompareGreaterThanZero(Vector64`1<T> value);
    public static Vector128`1<T> CompareGreaterThanZero(Vector128`1<T> value);
    public static Vector64`1<T> CompareGreaterThanOrEqual(Vector64`1<T> left, Vector64`1<T> right);
    public static Vector128`1<T> CompareGreaterThanOrEqual(Vector128`1<T> left, Vector128`1<T> right);
    public static Vector64`1<T> CompareGreaterThanOrEqualZero(Vector64`1<T> value);
    public static Vector128`1<T> CompareGreaterThanOrEqualZero(Vector128`1<T> value);
    public static Vector64`1<T> CompareLessThanZero(Vector64`1<T> value);
    public static Vector128`1<T> CompareLessThanZero(Vector128`1<T> value);
    public static Vector64`1<T> CompareLessThanOrEqualZero(Vector64`1<T> value);
    public static Vector128`1<T> CompareLessThanOrEqualZero(Vector128`1<T> value);
    public static Vector64`1<T> CompareTest(Vector64`1<T> left, Vector64`1<T> right);
    public static Vector128`1<T> CompareTest(Vector128`1<T> left, Vector128`1<T> right);
    public static Vector64`1<float> Divide(Vector64`1<float> left, Vector64`1<float> right);
    public static Vector128`1<float> Divide(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<double> Divide(Vector128`1<double> left, Vector128`1<double> right);
    public static T Extract(Vector64`1<T> vector, byte index);
    public static T Extract(Vector128`1<T> vector, byte index);
    public static Vector64`1<T> Insert(Vector64`1<T> vector, byte index, T data);
    public static Vector128`1<T> Insert(Vector128`1<T> vector, byte index, T data);
    public static Vector64`1<sbyte> LeadingSignCount(Vector64`1<sbyte> value);
    public static Vector64`1<short> LeadingSignCount(Vector64`1<short> value);
    public static Vector64`1<int> LeadingSignCount(Vector64`1<int> value);
    public static Vector128`1<sbyte> LeadingSignCount(Vector128`1<sbyte> value);
    public static Vector128`1<short> LeadingSignCount(Vector128`1<short> value);
    public static Vector128`1<int> LeadingSignCount(Vector128`1<int> value);
    public static Vector64`1<byte> LeadingZeroCount(Vector64`1<byte> value);
    public static Vector64`1<sbyte> LeadingZeroCount(Vector64`1<sbyte> value);
    public static Vector64`1<ushort> LeadingZeroCount(Vector64`1<ushort> value);
    public static Vector64`1<short> LeadingZeroCount(Vector64`1<short> value);
    public static Vector64`1<UInt32> LeadingZeroCount(Vector64`1<UInt32> value);
    public static Vector64`1<int> LeadingZeroCount(Vector64`1<int> value);
    public static Vector128`1<byte> LeadingZeroCount(Vector128`1<byte> value);
    public static Vector128`1<sbyte> LeadingZeroCount(Vector128`1<sbyte> value);
    public static Vector128`1<ushort> LeadingZeroCount(Vector128`1<ushort> value);
    public static Vector128`1<short> LeadingZeroCount(Vector128`1<short> value);
    public static Vector128`1<UInt32> LeadingZeroCount(Vector128`1<UInt32> value);
    public static Vector128`1<int> LeadingZeroCount(Vector128`1<int> value);
    public static Vector64`1<byte> Max(Vector64`1<byte> left, Vector64`1<byte> right);
    public static Vector64`1<sbyte> Max(Vector64`1<sbyte> left, Vector64`1<sbyte> right);
    public static Vector64`1<ushort> Max(Vector64`1<ushort> left, Vector64`1<ushort> right);
    public static Vector64`1<short> Max(Vector64`1<short> left, Vector64`1<short> right);
    public static Vector64`1<UInt32> Max(Vector64`1<UInt32> left, Vector64`1<UInt32> right);
    public static Vector64`1<int> Max(Vector64`1<int> left, Vector64`1<int> right);
    public static Vector64`1<float> Max(Vector64`1<float> left, Vector64`1<float> right);
    public static Vector128`1<byte> Max(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<sbyte> Max(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<ushort> Max(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<short> Max(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<UInt32> Max(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<int> Max(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<float> Max(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<double> Max(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector64`1<byte> Min(Vector64`1<byte> left, Vector64`1<byte> right);
    public static Vector64`1<sbyte> Min(Vector64`1<sbyte> left, Vector64`1<sbyte> right);
    public static Vector64`1<ushort> Min(Vector64`1<ushort> left, Vector64`1<ushort> right);
    public static Vector64`1<short> Min(Vector64`1<short> left, Vector64`1<short> right);
    public static Vector64`1<UInt32> Min(Vector64`1<UInt32> left, Vector64`1<UInt32> right);
    public static Vector64`1<int> Min(Vector64`1<int> left, Vector64`1<int> right);
    public static Vector64`1<float> Min(Vector64`1<float> left, Vector64`1<float> right);
    public static Vector128`1<byte> Min(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<sbyte> Min(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<ushort> Min(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<short> Min(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<UInt32> Min(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<int> Min(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<float> Min(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<double> Min(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector64`1<byte> Multiply(Vector64`1<byte> left, Vector64`1<byte> right);
    public static Vector64`1<sbyte> Multiply(Vector64`1<sbyte> left, Vector64`1<sbyte> right);
    public static Vector64`1<ushort> Multiply(Vector64`1<ushort> left, Vector64`1<ushort> right);
    public static Vector64`1<short> Multiply(Vector64`1<short> left, Vector64`1<short> right);
    public static Vector64`1<UInt32> Multiply(Vector64`1<UInt32> left, Vector64`1<UInt32> right);
    public static Vector64`1<int> Multiply(Vector64`1<int> left, Vector64`1<int> right);
    public static Vector64`1<float> Multiply(Vector64`1<float> left, Vector64`1<float> right);
    public static Vector128`1<byte> Multiply(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<sbyte> Multiply(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<ushort> Multiply(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<short> Multiply(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<UInt32> Multiply(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<int> Multiply(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<float> Multiply(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<double> Multiply(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector64`1<sbyte> Negate(Vector64`1<sbyte> value);
    public static Vector64`1<short> Negate(Vector64`1<short> value);
    public static Vector64`1<int> Negate(Vector64`1<int> value);
    public static Vector64`1<float> Negate(Vector64`1<float> value);
    public static Vector128`1<sbyte> Negate(Vector128`1<sbyte> value);
    public static Vector128`1<short> Negate(Vector128`1<short> value);
    public static Vector128`1<int> Negate(Vector128`1<int> value);
    public static Vector128`1<long> Negate(Vector128`1<long> value);
    public static Vector128`1<float> Negate(Vector128`1<float> value);
    public static Vector128`1<double> Negate(Vector128`1<double> value);
    public static Vector64`1<T> Not(Vector64`1<T> value);
    public static Vector128`1<T> Not(Vector128`1<T> value);
    public static Vector64`1<T> Or(Vector64`1<T> left, Vector64`1<T> right);
    public static Vector128`1<T> Or(Vector128`1<T> left, Vector128`1<T> right);
    public static Vector64`1<T> OrNot(Vector64`1<T> left, Vector64`1<T> right);
    public static Vector128`1<T> OrNot(Vector128`1<T> left, Vector128`1<T> right);
    public static Vector64`1<byte> PopCount(Vector64`1<byte> value);
    public static Vector64`1<sbyte> PopCount(Vector64`1<sbyte> value);
    public static Vector128`1<byte> PopCount(Vector128`1<byte> value);
    public static Vector128`1<sbyte> PopCount(Vector128`1<sbyte> value);
    public static Vector64`1<T> SetAllVector64(T value);
    public static Vector128`1<T> SetAllVector128(T value);
    public static Vector64`1<float> Sqrt(Vector64`1<float> value);
    public static Vector128`1<float> Sqrt(Vector128`1<float> value);
    public static Vector128`1<double> Sqrt(Vector128`1<double> value);
    public static Vector64`1<T> Subtract(Vector64`1<T> left, Vector64`1<T> right);
    public static Vector128`1<T> Subtract(Vector128`1<T> left, Vector128`1<T> right);
    public static Vector64`1<T> Xor(Vector64`1<T> left, Vector64`1<T> right);
    public static Vector128`1<T> Xor(Vector128`1<T> left, Vector128`1<T> right);
}
[ExtensionAttribute]
public static class System.Runtime.Intrinsics.Vector128 : object {
    [ExtensionAttribute]
[IntrinsicAttribute]
public static Vector128`1<U> As(Vector128`1<T> vector);
    [IntrinsicAttribute]
[ExtensionAttribute]
public static Vector128`1<byte> AsByte(Vector128`1<T> vector);
    [IntrinsicAttribute]
[ExtensionAttribute]
public static Vector128`1<double> AsDouble(Vector128`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static Vector128`1<short> AsInt16(Vector128`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static Vector128`1<int> AsInt32(Vector128`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static Vector128`1<long> AsInt64(Vector128`1<T> vector);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
[ExtensionAttribute]
public static Vector128`1<sbyte> AsSByte(Vector128`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static Vector128`1<float> AsSingle(Vector128`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<ushort> AsUInt16(Vector128`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<UInt32> AsUInt32(Vector128`1<T> vector);
    [CLSCompliantAttribute("False")]
[ExtensionAttribute]
[IntrinsicAttribute]
public static Vector128`1<ulong> AsUInt64(Vector128`1<T> vector);
    public static Vector128`1<byte> Create(byte value);
    public static Vector128`1<double> Create(double value);
    public static Vector128`1<short> Create(short value);
    public static Vector128`1<int> Create(int value);
    public static Vector128`1<long> Create(long value);
    [CLSCompliantAttribute("False")]
public static Vector128`1<sbyte> Create(sbyte value);
    public static Vector128`1<float> Create(float value);
    [CLSCompliantAttribute("False")]
public static Vector128`1<ushort> Create(ushort value);
    [CLSCompliantAttribute("False")]
public static Vector128`1<UInt32> Create(UInt32 value);
    [CLSCompliantAttribute("False")]
public static Vector128`1<ulong> Create(ulong value);
    public static Vector128`1<byte> Create(byte e0, byte e1, byte e2, byte e3, byte e4, byte e5, byte e6, byte e7, byte e8, byte e9, byte e10, byte e11, byte e12, byte e13, byte e14, byte e15);
    public static Vector128`1<double> Create(double e0, double e1);
    public static Vector128`1<short> Create(short e0, short e1, short e2, short e3, short e4, short e5, short e6, short e7);
    public static Vector128`1<int> Create(int e0, int e1, int e2, int e3);
    public static Vector128`1<long> Create(long e0, long e1);
    [CLSCompliantAttribute("False")]
public static Vector128`1<sbyte> Create(sbyte e0, sbyte e1, sbyte e2, sbyte e3, sbyte e4, sbyte e5, sbyte e6, sbyte e7, sbyte e8, sbyte e9, sbyte e10, sbyte e11, sbyte e12, sbyte e13, sbyte e14, sbyte e15);
    public static Vector128`1<float> Create(float e0, float e1, float e2, float e3);
    [CLSCompliantAttribute("False")]
public static Vector128`1<ushort> Create(ushort e0, ushort e1, ushort e2, ushort e3, ushort e4, ushort e5, ushort e6, ushort e7);
    [CLSCompliantAttribute("False")]
public static Vector128`1<UInt32> Create(UInt32 e0, UInt32 e1, UInt32 e2, UInt32 e3);
    [CLSCompliantAttribute("False")]
public static Vector128`1<ulong> Create(ulong e0, ulong e1);
    public static Vector128`1<byte> Create(Vector64`1<byte> lower, Vector64`1<byte> upper);
    public static Vector128`1<double> Create(Vector64`1<double> lower, Vector64`1<double> upper);
    public static Vector128`1<short> Create(Vector64`1<short> lower, Vector64`1<short> upper);
    public static Vector128`1<int> Create(Vector64`1<int> lower, Vector64`1<int> upper);
    public static Vector128`1<long> Create(Vector64`1<long> lower, Vector64`1<long> upper);
    [CLSCompliantAttribute("False")]
public static Vector128`1<sbyte> Create(Vector64`1<sbyte> lower, Vector64`1<sbyte> upper);
    public static Vector128`1<float> Create(Vector64`1<float> lower, Vector64`1<float> upper);
    [CLSCompliantAttribute("False")]
public static Vector128`1<ushort> Create(Vector64`1<ushort> lower, Vector64`1<ushort> upper);
    [CLSCompliantAttribute("False")]
public static Vector128`1<UInt32> Create(Vector64`1<UInt32> lower, Vector64`1<UInt32> upper);
    [CLSCompliantAttribute("False")]
public static Vector128`1<ulong> Create(Vector64`1<ulong> lower, Vector64`1<ulong> upper);
    public static Vector128`1<byte> CreateScalar(byte value);
    public static Vector128`1<double> CreateScalar(double value);
    public static Vector128`1<short> CreateScalar(short value);
    public static Vector128`1<int> CreateScalar(int value);
    public static Vector128`1<long> CreateScalar(long value);
    [CLSCompliantAttribute("False")]
public static Vector128`1<sbyte> CreateScalar(sbyte value);
    public static Vector128`1<float> CreateScalar(float value);
    [CLSCompliantAttribute("False")]
public static Vector128`1<ushort> CreateScalar(ushort value);
    [CLSCompliantAttribute("False")]
public static Vector128`1<UInt32> CreateScalar(UInt32 value);
    [CLSCompliantAttribute("False")]
public static Vector128`1<ulong> CreateScalar(ulong value);
    [IntrinsicAttribute]
public static Vector128`1<byte> CreateScalarUnsafe(byte value);
    [IntrinsicAttribute]
public static Vector128`1<double> CreateScalarUnsafe(double value);
    [IntrinsicAttribute]
public static Vector128`1<short> CreateScalarUnsafe(short value);
    [IntrinsicAttribute]
public static Vector128`1<int> CreateScalarUnsafe(int value);
    [IntrinsicAttribute]
public static Vector128`1<long> CreateScalarUnsafe(long value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<sbyte> CreateScalarUnsafe(sbyte value);
    [IntrinsicAttribute]
public static Vector128`1<float> CreateScalarUnsafe(float value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static Vector128`1<ushort> CreateScalarUnsafe(ushort value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static Vector128`1<UInt32> CreateScalarUnsafe(UInt32 value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static Vector128`1<ulong> CreateScalarUnsafe(ulong value);
    [IntrinsicAttribute]
[ExtensionAttribute]
public static T GetElement(Vector128`1<T> vector, int index);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static Vector128`1<T> WithElement(Vector128`1<T> vector, int index, T value);
    [ExtensionAttribute]
public static Vector64`1<T> GetLower(Vector128`1<T> vector);
    [ExtensionAttribute]
public static Vector128`1<T> WithLower(Vector128`1<T> vector, Vector64`1<T> value);
    [ExtensionAttribute]
public static Vector64`1<T> GetUpper(Vector128`1<T> vector);
    [ExtensionAttribute]
public static Vector128`1<T> WithUpper(Vector128`1<T> vector, Vector64`1<T> value);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static T ToScalar(Vector128`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static Vector256`1<T> ToVector256(Vector128`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static Vector256`1<T> ToVector256Unsafe(Vector128`1<T> vector);
    [CompilerGeneratedAttribute]
internal static Vector128`1<byte> <Create>g__SoftwareFallback|12_0(byte value);
    [CompilerGeneratedAttribute]
internal static Vector128`1<double> <Create>g__SoftwareFallback|13_0(double value);
    [CompilerGeneratedAttribute]
internal static Vector128`1<short> <Create>g__SoftwareFallback|14_0(short value);
    [CompilerGeneratedAttribute]
internal static Vector128`1<int> <Create>g__SoftwareFallback|15_0(int value);
    [CompilerGeneratedAttribute]
internal static Vector128`1<long> <Create>g__SoftwareFallback|16_0(long value);
    [CompilerGeneratedAttribute]
internal static Vector128`1<sbyte> <Create>g__SoftwareFallback|17_0(sbyte value);
    [CompilerGeneratedAttribute]
internal static Vector128`1<float> <Create>g__SoftwareFallback|18_0(float value);
    [CompilerGeneratedAttribute]
internal static Vector128`1<ushort> <Create>g__SoftwareFallback|19_0(ushort value);
    [CompilerGeneratedAttribute]
internal static Vector128`1<UInt32> <Create>g__SoftwareFallback|20_0(UInt32 value);
    [CompilerGeneratedAttribute]
internal static Vector128`1<ulong> <Create>g__SoftwareFallback|21_0(ulong value);
    [CompilerGeneratedAttribute]
internal static Vector128`1<byte> <Create>g__SoftwareFallback|22_0(byte e0, byte e1, byte e2, byte e3, byte e4, byte e5, byte e6, byte e7, byte e8, byte e9, byte e10, byte e11, byte e12, byte e13, byte e14, byte e15);
    [CompilerGeneratedAttribute]
internal static Vector128`1<double> <Create>g__SoftwareFallback|23_0(double e0, double e1);
    [CompilerGeneratedAttribute]
internal static Vector128`1<short> <Create>g__SoftwareFallback|24_0(short e0, short e1, short e2, short e3, short e4, short e5, short e6, short e7);
    [CompilerGeneratedAttribute]
internal static Vector128`1<int> <Create>g__SoftwareFallback|25_0(int e0, int e1, int e2, int e3);
    [CompilerGeneratedAttribute]
internal static Vector128`1<long> <Create>g__SoftwareFallback|26_0(long e0, long e1);
    [CompilerGeneratedAttribute]
internal static Vector128`1<sbyte> <Create>g__SoftwareFallback|27_0(sbyte e0, sbyte e1, sbyte e2, sbyte e3, sbyte e4, sbyte e5, sbyte e6, sbyte e7, sbyte e8, sbyte e9, sbyte e10, sbyte e11, sbyte e12, sbyte e13, sbyte e14, sbyte e15);
    [CompilerGeneratedAttribute]
internal static Vector128`1<float> <Create>g__SoftwareFallback|28_0(float e0, float e1, float e2, float e3);
    [CompilerGeneratedAttribute]
internal static Vector128`1<ushort> <Create>g__SoftwareFallback|29_0(ushort e0, ushort e1, ushort e2, ushort e3, ushort e4, ushort e5, ushort e6, ushort e7);
    [CompilerGeneratedAttribute]
internal static Vector128`1<UInt32> <Create>g__SoftwareFallback|30_0(UInt32 e0, UInt32 e1, UInt32 e2, UInt32 e3);
    [CompilerGeneratedAttribute]
internal static Vector128`1<ulong> <Create>g__SoftwareFallback|31_0(ulong e0, ulong e1);
    [CompilerGeneratedAttribute]
internal static Vector128`1<byte> <CreateScalar>g__SoftwareFallback|42_0(byte value);
    [CompilerGeneratedAttribute]
internal static Vector128`1<double> <CreateScalar>g__SoftwareFallback|43_0(double value);
    [CompilerGeneratedAttribute]
internal static Vector128`1<short> <CreateScalar>g__SoftwareFallback|44_0(short value);
    [CompilerGeneratedAttribute]
internal static Vector128`1<int> <CreateScalar>g__SoftwareFallback|45_0(int value);
    [CompilerGeneratedAttribute]
internal static Vector128`1<long> <CreateScalar>g__SoftwareFallback|46_0(long value);
    [CompilerGeneratedAttribute]
internal static Vector128`1<sbyte> <CreateScalar>g__SoftwareFallback|47_0(sbyte value);
    [CompilerGeneratedAttribute]
internal static Vector128`1<float> <CreateScalar>g__SoftwareFallback|48_0(float value);
    [CompilerGeneratedAttribute]
internal static Vector128`1<ushort> <CreateScalar>g__SoftwareFallback|49_0(ushort value);
    [CompilerGeneratedAttribute]
internal static Vector128`1<UInt32> <CreateScalar>g__SoftwareFallback|50_0(UInt32 value);
    [CompilerGeneratedAttribute]
internal static Vector128`1<ulong> <CreateScalar>g__SoftwareFallback|51_0(ulong value);
}
[DebuggerTypeProxyAttribute("System.Runtime.Intrinsics.Vector128DebugView`1")]
[IsReadOnlyAttribute]
[IntrinsicAttribute]
[DebuggerDisplayAttribute("{DisplayString,nq}")]
public class System.Runtime.Intrinsics.Vector128`1 : ValueType {
    private ulong _00;
    private ulong _01;
    public static int Count { get; }
    public static Vector128`1<T> Zero { get; }
    [NullableAttribute("1")]
internal string DisplayString { get; }
    internal static bool IsSupported { get; }
    [IntrinsicAttribute]
public static int get_Count();
    [IntrinsicAttribute]
public static Vector128`1<T> get_Zero();
    internal string get_DisplayString();
    internal static bool get_IsSupported();
    public sealed virtual bool Equals(Vector128`1<T> other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [CompilerGeneratedAttribute]
internal static bool <Equals>g__SoftwareFallback|10_0(Vector128`1& vector, Vector128`1<T> other);
}
[IsReadOnlyAttribute]
internal class System.Runtime.Intrinsics.Vector128DebugView`1 : ValueType {
    private Vector128`1<T> _value;
    public Byte[] ByteView { get; }
    public Double[] DoubleView { get; }
    public Int16[] Int16View { get; }
    public Int32[] Int32View { get; }
    public Int64[] Int64View { get; }
    public SByte[] SByteView { get; }
    public Single[] SingleView { get; }
    public UInt16[] UInt16View { get; }
    public UInt32[] UInt32View { get; }
    public UInt64[] UInt64View { get; }
    public Vector128DebugView`1(Vector128`1<T> value);
    public Byte[] get_ByteView();
    public Double[] get_DoubleView();
    public Int16[] get_Int16View();
    public Int32[] get_Int32View();
    public Int64[] get_Int64View();
    public SByte[] get_SByteView();
    public Single[] get_SingleView();
    public UInt16[] get_UInt16View();
    public UInt32[] get_UInt32View();
    public UInt64[] get_UInt64View();
}
[ExtensionAttribute]
public static class System.Runtime.Intrinsics.Vector256 : object {
    [ExtensionAttribute]
[IntrinsicAttribute]
public static Vector256`1<U> As(Vector256`1<T> vector);
    [IntrinsicAttribute]
[ExtensionAttribute]
public static Vector256`1<byte> AsByte(Vector256`1<T> vector);
    [IntrinsicAttribute]
[ExtensionAttribute]
public static Vector256`1<double> AsDouble(Vector256`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static Vector256`1<short> AsInt16(Vector256`1<T> vector);
    [IntrinsicAttribute]
[ExtensionAttribute]
public static Vector256`1<int> AsInt32(Vector256`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static Vector256`1<long> AsInt64(Vector256`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<sbyte> AsSByte(Vector256`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static Vector256`1<float> AsSingle(Vector256`1<T> vector);
    [IntrinsicAttribute]
[ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<ushort> AsUInt16(Vector256`1<T> vector);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
[ExtensionAttribute]
public static Vector256`1<UInt32> AsUInt32(Vector256`1<T> vector);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
[ExtensionAttribute]
public static Vector256`1<ulong> AsUInt64(Vector256`1<T> vector);
    public static Vector256`1<byte> Create(byte value);
    public static Vector256`1<double> Create(double value);
    public static Vector256`1<short> Create(short value);
    public static Vector256`1<int> Create(int value);
    public static Vector256`1<long> Create(long value);
    [CLSCompliantAttribute("False")]
public static Vector256`1<sbyte> Create(sbyte value);
    public static Vector256`1<float> Create(float value);
    [CLSCompliantAttribute("False")]
public static Vector256`1<ushort> Create(ushort value);
    [CLSCompliantAttribute("False")]
public static Vector256`1<UInt32> Create(UInt32 value);
    [CLSCompliantAttribute("False")]
public static Vector256`1<ulong> Create(ulong value);
    public static Vector256`1<byte> Create(byte e0, byte e1, byte e2, byte e3, byte e4, byte e5, byte e6, byte e7, byte e8, byte e9, byte e10, byte e11, byte e12, byte e13, byte e14, byte e15, byte e16, byte e17, byte e18, byte e19, byte e20, byte e21, byte e22, byte e23, byte e24, byte e25, byte e26, byte e27, byte e28, byte e29, byte e30, byte e31);
    public static Vector256`1<double> Create(double e0, double e1, double e2, double e3);
    public static Vector256`1<short> Create(short e0, short e1, short e2, short e3, short e4, short e5, short e6, short e7, short e8, short e9, short e10, short e11, short e12, short e13, short e14, short e15);
    public static Vector256`1<int> Create(int e0, int e1, int e2, int e3, int e4, int e5, int e6, int e7);
    public static Vector256`1<long> Create(long e0, long e1, long e2, long e3);
    [CLSCompliantAttribute("False")]
public static Vector256`1<sbyte> Create(sbyte e0, sbyte e1, sbyte e2, sbyte e3, sbyte e4, sbyte e5, sbyte e6, sbyte e7, sbyte e8, sbyte e9, sbyte e10, sbyte e11, sbyte e12, sbyte e13, sbyte e14, sbyte e15, sbyte e16, sbyte e17, sbyte e18, sbyte e19, sbyte e20, sbyte e21, sbyte e22, sbyte e23, sbyte e24, sbyte e25, sbyte e26, sbyte e27, sbyte e28, sbyte e29, sbyte e30, sbyte e31);
    public static Vector256`1<float> Create(float e0, float e1, float e2, float e3, float e4, float e5, float e6, float e7);
    [CLSCompliantAttribute("False")]
public static Vector256`1<ushort> Create(ushort e0, ushort e1, ushort e2, ushort e3, ushort e4, ushort e5, ushort e6, ushort e7, ushort e8, ushort e9, ushort e10, ushort e11, ushort e12, ushort e13, ushort e14, ushort e15);
    [CLSCompliantAttribute("False")]
public static Vector256`1<UInt32> Create(UInt32 e0, UInt32 e1, UInt32 e2, UInt32 e3, UInt32 e4, UInt32 e5, UInt32 e6, UInt32 e7);
    [CLSCompliantAttribute("False")]
public static Vector256`1<ulong> Create(ulong e0, ulong e1, ulong e2, ulong e3);
    public static Vector256`1<byte> Create(Vector128`1<byte> lower, Vector128`1<byte> upper);
    public static Vector256`1<double> Create(Vector128`1<double> lower, Vector128`1<double> upper);
    public static Vector256`1<short> Create(Vector128`1<short> lower, Vector128`1<short> upper);
    public static Vector256`1<int> Create(Vector128`1<int> lower, Vector128`1<int> upper);
    public static Vector256`1<long> Create(Vector128`1<long> lower, Vector128`1<long> upper);
    [CLSCompliantAttribute("False")]
public static Vector256`1<sbyte> Create(Vector128`1<sbyte> lower, Vector128`1<sbyte> upper);
    public static Vector256`1<float> Create(Vector128`1<float> lower, Vector128`1<float> upper);
    [CLSCompliantAttribute("False")]
public static Vector256`1<ushort> Create(Vector128`1<ushort> lower, Vector128`1<ushort> upper);
    [CLSCompliantAttribute("False")]
public static Vector256`1<UInt32> Create(Vector128`1<UInt32> lower, Vector128`1<UInt32> upper);
    [CLSCompliantAttribute("False")]
public static Vector256`1<ulong> Create(Vector128`1<ulong> lower, Vector128`1<ulong> upper);
    public static Vector256`1<byte> CreateScalar(byte value);
    public static Vector256`1<double> CreateScalar(double value);
    public static Vector256`1<short> CreateScalar(short value);
    public static Vector256`1<int> CreateScalar(int value);
    public static Vector256`1<long> CreateScalar(long value);
    [CLSCompliantAttribute("False")]
public static Vector256`1<sbyte> CreateScalar(sbyte value);
    public static Vector256`1<float> CreateScalar(float value);
    [CLSCompliantAttribute("False")]
public static Vector256`1<ushort> CreateScalar(ushort value);
    [CLSCompliantAttribute("False")]
public static Vector256`1<UInt32> CreateScalar(UInt32 value);
    [CLSCompliantAttribute("False")]
public static Vector256`1<ulong> CreateScalar(ulong value);
    [IntrinsicAttribute]
public static Vector256`1<byte> CreateScalarUnsafe(byte value);
    [IntrinsicAttribute]
public static Vector256`1<double> CreateScalarUnsafe(double value);
    [IntrinsicAttribute]
public static Vector256`1<short> CreateScalarUnsafe(short value);
    [IntrinsicAttribute]
public static Vector256`1<int> CreateScalarUnsafe(int value);
    [IntrinsicAttribute]
public static Vector256`1<long> CreateScalarUnsafe(long value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static Vector256`1<sbyte> CreateScalarUnsafe(sbyte value);
    [IntrinsicAttribute]
public static Vector256`1<float> CreateScalarUnsafe(float value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static Vector256`1<ushort> CreateScalarUnsafe(ushort value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<UInt32> CreateScalarUnsafe(UInt32 value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<ulong> CreateScalarUnsafe(ulong value);
    [IntrinsicAttribute]
[ExtensionAttribute]
public static T GetElement(Vector256`1<T> vector, int index);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static Vector256`1<T> WithElement(Vector256`1<T> vector, int index, T value);
    [IntrinsicAttribute]
[ExtensionAttribute]
public static Vector128`1<T> GetLower(Vector256`1<T> vector);
    [ExtensionAttribute]
public static Vector256`1<T> WithLower(Vector256`1<T> vector, Vector128`1<T> value);
    [ExtensionAttribute]
public static Vector128`1<T> GetUpper(Vector256`1<T> vector);
    [ExtensionAttribute]
public static Vector256`1<T> WithUpper(Vector256`1<T> vector, Vector128`1<T> value);
    [IntrinsicAttribute]
[ExtensionAttribute]
public static T ToScalar(Vector256`1<T> vector);
    [CompilerGeneratedAttribute]
internal static Vector256`1<byte> <Create>g__SoftwareFallback|12_0(byte value);
    [CompilerGeneratedAttribute]
internal static Vector256`1<double> <Create>g__SoftwareFallback|13_0(double value);
    [CompilerGeneratedAttribute]
internal static Vector256`1<short> <Create>g__SoftwareFallback|14_0(short value);
    [CompilerGeneratedAttribute]
internal static Vector256`1<int> <Create>g__SoftwareFallback|15_0(int value);
    [CompilerGeneratedAttribute]
internal static Vector256`1<long> <Create>g__SoftwareFallback|16_0(long value);
    [CompilerGeneratedAttribute]
internal static Vector256`1<sbyte> <Create>g__SoftwareFallback|17_0(sbyte value);
    [CompilerGeneratedAttribute]
internal static Vector256`1<float> <Create>g__SoftwareFallback|18_0(float value);
    [CompilerGeneratedAttribute]
internal static Vector256`1<ushort> <Create>g__SoftwareFallback|19_0(ushort value);
    [CompilerGeneratedAttribute]
internal static Vector256`1<UInt32> <Create>g__SoftwareFallback|20_0(UInt32 value);
    [CompilerGeneratedAttribute]
internal static Vector256`1<ulong> <Create>g__SoftwareFallback|21_0(ulong value);
    [CompilerGeneratedAttribute]
internal static Vector256`1<byte> <Create>g__SoftwareFallback|22_0(byte e0, byte e1, byte e2, byte e3, byte e4, byte e5, byte e6, byte e7, byte e8, byte e9, byte e10, byte e11, byte e12, byte e13, byte e14, byte e15, byte e16, byte e17, byte e18, byte e19, byte e20, byte e21, byte e22, byte e23, byte e24, byte e25, byte e26, byte e27, byte e28, byte e29, byte e30, byte e31);
    [CompilerGeneratedAttribute]
internal static Vector256`1<double> <Create>g__SoftwareFallback|23_0(double e0, double e1, double e2, double e3);
    [CompilerGeneratedAttribute]
internal static Vector256`1<short> <Create>g__SoftwareFallback|24_0(short e0, short e1, short e2, short e3, short e4, short e5, short e6, short e7, short e8, short e9, short e10, short e11, short e12, short e13, short e14, short e15);
    [CompilerGeneratedAttribute]
internal static Vector256`1<int> <Create>g__SoftwareFallback|25_0(int e0, int e1, int e2, int e3, int e4, int e5, int e6, int e7);
    [CompilerGeneratedAttribute]
internal static Vector256`1<long> <Create>g__SoftwareFallback|26_0(long e0, long e1, long e2, long e3);
    [CompilerGeneratedAttribute]
internal static Vector256`1<sbyte> <Create>g__SoftwareFallback|27_0(sbyte e0, sbyte e1, sbyte e2, sbyte e3, sbyte e4, sbyte e5, sbyte e6, sbyte e7, sbyte e8, sbyte e9, sbyte e10, sbyte e11, sbyte e12, sbyte e13, sbyte e14, sbyte e15, sbyte e16, sbyte e17, sbyte e18, sbyte e19, sbyte e20, sbyte e21, sbyte e22, sbyte e23, sbyte e24, sbyte e25, sbyte e26, sbyte e27, sbyte e28, sbyte e29, sbyte e30, sbyte e31);
    [CompilerGeneratedAttribute]
internal static Vector256`1<float> <Create>g__SoftwareFallback|28_0(float e0, float e1, float e2, float e3, float e4, float e5, float e6, float e7);
    [CompilerGeneratedAttribute]
internal static Vector256`1<ushort> <Create>g__SoftwareFallback|29_0(ushort e0, ushort e1, ushort e2, ushort e3, ushort e4, ushort e5, ushort e6, ushort e7, ushort e8, ushort e9, ushort e10, ushort e11, ushort e12, ushort e13, ushort e14, ushort e15);
    [CompilerGeneratedAttribute]
internal static Vector256`1<UInt32> <Create>g__SoftwareFallback|30_0(UInt32 e0, UInt32 e1, UInt32 e2, UInt32 e3, UInt32 e4, UInt32 e5, UInt32 e6, UInt32 e7);
    [CompilerGeneratedAttribute]
internal static Vector256`1<ulong> <Create>g__SoftwareFallback|31_0(ulong e0, ulong e1, ulong e2, ulong e3);
    [CompilerGeneratedAttribute]
internal static Vector256`1<byte> <Create>g__SoftwareFallback|32_0(Vector128`1<byte> lower, Vector128`1<byte> upper);
    [CompilerGeneratedAttribute]
internal static Vector256`1<double> <Create>g__SoftwareFallback|33_0(Vector128`1<double> lower, Vector128`1<double> upper);
    [CompilerGeneratedAttribute]
internal static Vector256`1<short> <Create>g__SoftwareFallback|34_0(Vector128`1<short> lower, Vector128`1<short> upper);
    [CompilerGeneratedAttribute]
internal static Vector256`1<int> <Create>g__SoftwareFallback|35_0(Vector128`1<int> lower, Vector128`1<int> upper);
    [CompilerGeneratedAttribute]
internal static Vector256`1<long> <Create>g__SoftwareFallback|36_0(Vector128`1<long> lower, Vector128`1<long> upper);
    [CompilerGeneratedAttribute]
internal static Vector256`1<sbyte> <Create>g__SoftwareFallback|37_0(Vector128`1<sbyte> lower, Vector128`1<sbyte> upper);
    [CompilerGeneratedAttribute]
internal static Vector256`1<float> <Create>g__SoftwareFallback|38_0(Vector128`1<float> lower, Vector128`1<float> upper);
    [CompilerGeneratedAttribute]
internal static Vector256`1<ushort> <Create>g__SoftwareFallback|39_0(Vector128`1<ushort> lower, Vector128`1<ushort> upper);
    [CompilerGeneratedAttribute]
internal static Vector256`1<UInt32> <Create>g__SoftwareFallback|40_0(Vector128`1<UInt32> lower, Vector128`1<UInt32> upper);
    [CompilerGeneratedAttribute]
internal static Vector256`1<ulong> <Create>g__SoftwareFallback|41_0(Vector128`1<ulong> lower, Vector128`1<ulong> upper);
    [CompilerGeneratedAttribute]
internal static Vector256`1<byte> <CreateScalar>g__SoftwareFallback|42_0(byte value);
    [CompilerGeneratedAttribute]
internal static Vector256`1<double> <CreateScalar>g__SoftwareFallback|43_0(double value);
    [CompilerGeneratedAttribute]
internal static Vector256`1<short> <CreateScalar>g__SoftwareFallback|44_0(short value);
    [CompilerGeneratedAttribute]
internal static Vector256`1<int> <CreateScalar>g__SoftwareFallback|45_0(int value);
    [CompilerGeneratedAttribute]
internal static Vector256`1<long> <CreateScalar>g__SoftwareFallback|46_0(long value);
    [CompilerGeneratedAttribute]
internal static Vector256`1<sbyte> <CreateScalar>g__SoftwareFallback|47_0(sbyte value);
    [CompilerGeneratedAttribute]
internal static Vector256`1<float> <CreateScalar>g__SoftwareFallback|48_0(float value);
    [CompilerGeneratedAttribute]
internal static Vector256`1<ushort> <CreateScalar>g__SoftwareFallback|49_0(ushort value);
    [CompilerGeneratedAttribute]
internal static Vector256`1<UInt32> <CreateScalar>g__SoftwareFallback|50_0(UInt32 value);
    [CompilerGeneratedAttribute]
internal static Vector256`1<ulong> <CreateScalar>g__SoftwareFallback|51_0(ulong value);
    [CompilerGeneratedAttribute]
internal static Vector256`1<T> <WithLower>g__SoftwareFallback|65_0(Vector256`1<T> vector, Vector128`1<T> value);
    [CompilerGeneratedAttribute]
internal static Vector128`1<T> <GetUpper>g__SoftwareFallback|66_0(Vector256`1<T> vector);
    [CompilerGeneratedAttribute]
internal static Vector256`1<T> <WithUpper>g__SoftwareFallback|67_0(Vector256`1<T> vector, Vector128`1<T> value);
}
[DebuggerDisplayAttribute("{DisplayString,nq}")]
[IntrinsicAttribute]
[IsReadOnlyAttribute]
[DebuggerTypeProxyAttribute("System.Runtime.Intrinsics.Vector256DebugView`1")]
public class System.Runtime.Intrinsics.Vector256`1 : ValueType {
    private ulong _00;
    private ulong _01;
    private ulong _02;
    private ulong _03;
    public static int Count { get; }
    public static Vector256`1<T> Zero { get; }
    [NullableAttribute("1")]
internal string DisplayString { get; }
    internal static bool IsSupported { get; }
    [IntrinsicAttribute]
public static int get_Count();
    [IntrinsicAttribute]
public static Vector256`1<T> get_Zero();
    internal string get_DisplayString();
    internal static bool get_IsSupported();
    public sealed virtual bool Equals(Vector256`1<T> other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [CompilerGeneratedAttribute]
internal static bool <Equals>g__SoftwareFallback|12_0(Vector256`1& vector, Vector256`1<T> other);
}
[IsReadOnlyAttribute]
internal class System.Runtime.Intrinsics.Vector256DebugView`1 : ValueType {
    private Vector256`1<T> _value;
    public Byte[] ByteView { get; }
    public Double[] DoubleView { get; }
    public Int16[] Int16View { get; }
    public Int32[] Int32View { get; }
    public Int64[] Int64View { get; }
    public SByte[] SByteView { get; }
    public Single[] SingleView { get; }
    public UInt16[] UInt16View { get; }
    public UInt32[] UInt32View { get; }
    public UInt64[] UInt64View { get; }
    public Vector256DebugView`1(Vector256`1<T> value);
    public Byte[] get_ByteView();
    public Double[] get_DoubleView();
    public Int16[] get_Int16View();
    public Int32[] get_Int32View();
    public Int64[] get_Int64View();
    public SByte[] get_SByteView();
    public Single[] get_SingleView();
    public UInt16[] get_UInt16View();
    public UInt32[] get_UInt32View();
    public UInt64[] get_UInt64View();
}
[ExtensionAttribute]
public static class System.Runtime.Intrinsics.Vector64 : object {
    [ExtensionAttribute]
[IntrinsicAttribute]
public static Vector64`1<U> As(Vector64`1<T> vector);
    [IntrinsicAttribute]
[ExtensionAttribute]
public static Vector64`1<byte> AsByte(Vector64`1<T> vector);
    [IntrinsicAttribute]
[ExtensionAttribute]
public static Vector64`1<double> AsDouble(Vector64`1<T> vector);
    [IntrinsicAttribute]
[ExtensionAttribute]
public static Vector64`1<short> AsInt16(Vector64`1<T> vector);
    [IntrinsicAttribute]
[ExtensionAttribute]
public static Vector64`1<int> AsInt32(Vector64`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static Vector64`1<long> AsInt64(Vector64`1<T> vector);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
[ExtensionAttribute]
public static Vector64`1<sbyte> AsSByte(Vector64`1<T> vector);
    [IntrinsicAttribute]
[ExtensionAttribute]
public static Vector64`1<float> AsSingle(Vector64`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<ushort> AsUInt16(Vector64`1<T> vector);
    [IntrinsicAttribute]
[ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<UInt32> AsUInt32(Vector64`1<T> vector);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
[ExtensionAttribute]
public static Vector64`1<ulong> AsUInt64(Vector64`1<T> vector);
    public static Vector64`1<byte> Create(byte value);
    public static Vector64`1<double> Create(double value);
    public static Vector64`1<short> Create(short value);
    public static Vector64`1<int> Create(int value);
    public static Vector64`1<long> Create(long value);
    [CLSCompliantAttribute("False")]
public static Vector64`1<sbyte> Create(sbyte value);
    public static Vector64`1<float> Create(float value);
    [CLSCompliantAttribute("False")]
public static Vector64`1<ushort> Create(ushort value);
    [CLSCompliantAttribute("False")]
public static Vector64`1<UInt32> Create(UInt32 value);
    [CLSCompliantAttribute("False")]
public static Vector64`1<ulong> Create(ulong value);
    public static Vector64`1<byte> Create(byte e0, byte e1, byte e2, byte e3, byte e4, byte e5, byte e6, byte e7);
    public static Vector64`1<short> Create(short e0, short e1, short e2, short e3);
    public static Vector64`1<int> Create(int e0, int e1);
    [CLSCompliantAttribute("False")]
public static Vector64`1<sbyte> Create(sbyte e0, sbyte e1, sbyte e2, sbyte e3, sbyte e4, sbyte e5, sbyte e6, sbyte e7);
    public static Vector64`1<float> Create(float e0, float e1);
    [CLSCompliantAttribute("False")]
public static Vector64`1<ushort> Create(ushort e0, ushort e1, ushort e2, ushort e3);
    [CLSCompliantAttribute("False")]
public static Vector64`1<UInt32> Create(UInt32 e0, UInt32 e1);
    public static Vector64`1<byte> CreateScalar(byte value);
    public static Vector64`1<short> CreateScalar(short value);
    public static Vector64`1<int> CreateScalar(int value);
    [CLSCompliantAttribute("False")]
public static Vector64`1<sbyte> CreateScalar(sbyte value);
    public static Vector64`1<float> CreateScalar(float value);
    [CLSCompliantAttribute("False")]
public static Vector64`1<ushort> CreateScalar(ushort value);
    [CLSCompliantAttribute("False")]
public static Vector64`1<UInt32> CreateScalar(UInt32 value);
    public static Vector64`1<byte> CreateScalarUnsafe(byte value);
    public static Vector64`1<short> CreateScalarUnsafe(short value);
    public static Vector64`1<int> CreateScalarUnsafe(int value);
    [CLSCompliantAttribute("False")]
public static Vector64`1<sbyte> CreateScalarUnsafe(sbyte value);
    public static Vector64`1<float> CreateScalarUnsafe(float value);
    [CLSCompliantAttribute("False")]
public static Vector64`1<ushort> CreateScalarUnsafe(ushort value);
    [CLSCompliantAttribute("False")]
public static Vector64`1<UInt32> CreateScalarUnsafe(UInt32 value);
    [ExtensionAttribute]
public static T GetElement(Vector64`1<T> vector, int index);
    [ExtensionAttribute]
public static Vector64`1<T> WithElement(Vector64`1<T> vector, int index, T value);
    [ExtensionAttribute]
public static T ToScalar(Vector64`1<T> vector);
    [ExtensionAttribute]
public static Vector128`1<T> ToVector128(Vector64`1<T> vector);
    [ExtensionAttribute]
public static Vector128`1<T> ToVector128Unsafe(Vector64`1<T> vector);
}
[IntrinsicAttribute]
[DebuggerDisplayAttribute("{DisplayString,nq}")]
[IsReadOnlyAttribute]
[DebuggerTypeProxyAttribute("System.Runtime.Intrinsics.Vector64DebugView`1")]
public class System.Runtime.Intrinsics.Vector64`1 : ValueType {
    private ulong _00;
    public static int Count { get; }
    public static Vector64`1<T> Zero { get; }
    [NullableAttribute("1")]
internal string DisplayString { get; }
    internal static bool IsSupported { get; }
    public static int get_Count();
    public static Vector64`1<T> get_Zero();
    internal string get_DisplayString();
    internal static bool get_IsSupported();
    public sealed virtual bool Equals(Vector64`1<T> other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[IsReadOnlyAttribute]
internal class System.Runtime.Intrinsics.Vector64DebugView`1 : ValueType {
    private Vector64`1<T> _value;
    public Byte[] ByteView { get; }
    public Double[] DoubleView { get; }
    public Int16[] Int16View { get; }
    public Int32[] Int32View { get; }
    public Int64[] Int64View { get; }
    public SByte[] SByteView { get; }
    public Single[] SingleView { get; }
    public UInt16[] UInt16View { get; }
    public UInt32[] UInt32View { get; }
    public UInt64[] UInt64View { get; }
    public Vector64DebugView`1(Vector64`1<T> value);
    public Byte[] get_ByteView();
    public Double[] get_DoubleView();
    public Int16[] get_Int16View();
    public Int32[] get_Int32View();
    public Int64[] get_Int64View();
    public SByte[] get_SByteView();
    public Single[] get_SingleView();
    public UInt16[] get_UInt16View();
    public UInt32[] get_UInt32View();
    public UInt64[] get_UInt64View();
}
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public abstract class System.Runtime.Intrinsics.X86.Aes : Sse2 {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static Vector128`1<byte> Decrypt(Vector128`1<byte> value, Vector128`1<byte> roundKey);
    public static Vector128`1<byte> DecryptLast(Vector128`1<byte> value, Vector128`1<byte> roundKey);
    public static Vector128`1<byte> Encrypt(Vector128`1<byte> value, Vector128`1<byte> roundKey);
    public static Vector128`1<byte> EncryptLast(Vector128`1<byte> value, Vector128`1<byte> roundKey);
    public static Vector128`1<byte> InverseMixColumns(Vector128`1<byte> value);
    public static Vector128`1<byte> KeygenAssist(Vector128`1<byte> value, byte control);
}
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public abstract class System.Runtime.Intrinsics.X86.Avx : Sse42 {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static Vector256`1<float> Add(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> Add(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<float> AddSubtract(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> AddSubtract(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<float> And(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> And(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<float> AndNot(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> AndNot(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<float> Blend(Vector256`1<float> left, Vector256`1<float> right, byte control);
    public static Vector256`1<double> Blend(Vector256`1<double> left, Vector256`1<double> right, byte control);
    public static Vector256`1<float> BlendVariable(Vector256`1<float> left, Vector256`1<float> right, Vector256`1<float> mask);
    public static Vector256`1<double> BlendVariable(Vector256`1<double> left, Vector256`1<double> right, Vector256`1<double> mask);
    public static Vector128`1<float> BroadcastScalarToVector128(Single* source);
    public static Vector256`1<float> BroadcastScalarToVector256(Single* source);
    public static Vector256`1<double> BroadcastScalarToVector256(Double* source);
    public static Vector256`1<float> BroadcastVector128ToVector256(Single* address);
    public static Vector256`1<double> BroadcastVector128ToVector256(Double* address);
    public static Vector256`1<float> Ceiling(Vector256`1<float> value);
    public static Vector256`1<double> Ceiling(Vector256`1<double> value);
    public static Vector128`1<float> Compare(Vector128`1<float> left, Vector128`1<float> right, FloatComparisonMode mode);
    public static Vector128`1<double> Compare(Vector128`1<double> left, Vector128`1<double> right, FloatComparisonMode mode);
    public static Vector256`1<float> Compare(Vector256`1<float> left, Vector256`1<float> right, FloatComparisonMode mode);
    public static Vector256`1<double> Compare(Vector256`1<double> left, Vector256`1<double> right, FloatComparisonMode mode);
    public static Vector128`1<double> CompareScalar(Vector128`1<double> left, Vector128`1<double> right, FloatComparisonMode mode);
    public static Vector128`1<float> CompareScalar(Vector128`1<float> left, Vector128`1<float> right, FloatComparisonMode mode);
    public static Vector128`1<int> ConvertToVector128Int32(Vector256`1<double> value);
    public static Vector128`1<float> ConvertToVector128Single(Vector256`1<double> value);
    public static Vector256`1<int> ConvertToVector256Int32(Vector256`1<float> value);
    public static Vector256`1<float> ConvertToVector256Single(Vector256`1<int> value);
    public static Vector256`1<double> ConvertToVector256Double(Vector128`1<float> value);
    public static Vector256`1<double> ConvertToVector256Double(Vector128`1<int> value);
    public static Vector128`1<int> ConvertToVector128Int32WithTruncation(Vector256`1<double> value);
    public static Vector256`1<int> ConvertToVector256Int32WithTruncation(Vector256`1<float> value);
    public static Vector256`1<float> Divide(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> Divide(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<float> DotProduct(Vector256`1<float> left, Vector256`1<float> right, byte control);
    public static Vector256`1<float> DuplicateEvenIndexed(Vector256`1<float> value);
    public static Vector256`1<double> DuplicateEvenIndexed(Vector256`1<double> value);
    public static Vector256`1<float> DuplicateOddIndexed(Vector256`1<float> value);
    public static Vector128`1<byte> ExtractVector128(Vector256`1<byte> value, byte index);
    public static Vector128`1<sbyte> ExtractVector128(Vector256`1<sbyte> value, byte index);
    public static Vector128`1<short> ExtractVector128(Vector256`1<short> value, byte index);
    public static Vector128`1<ushort> ExtractVector128(Vector256`1<ushort> value, byte index);
    public static Vector128`1<int> ExtractVector128(Vector256`1<int> value, byte index);
    public static Vector128`1<UInt32> ExtractVector128(Vector256`1<UInt32> value, byte index);
    public static Vector128`1<long> ExtractVector128(Vector256`1<long> value, byte index);
    public static Vector128`1<ulong> ExtractVector128(Vector256`1<ulong> value, byte index);
    public static Vector128`1<float> ExtractVector128(Vector256`1<float> value, byte index);
    public static Vector128`1<double> ExtractVector128(Vector256`1<double> value, byte index);
    public static Vector256`1<float> Floor(Vector256`1<float> value);
    public static Vector256`1<double> Floor(Vector256`1<double> value);
    public static Vector256`1<float> HorizontalAdd(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> HorizontalAdd(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<float> HorizontalSubtract(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> HorizontalSubtract(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<byte> InsertVector128(Vector256`1<byte> value, Vector128`1<byte> data, byte index);
    public static Vector256`1<sbyte> InsertVector128(Vector256`1<sbyte> value, Vector128`1<sbyte> data, byte index);
    public static Vector256`1<short> InsertVector128(Vector256`1<short> value, Vector128`1<short> data, byte index);
    public static Vector256`1<ushort> InsertVector128(Vector256`1<ushort> value, Vector128`1<ushort> data, byte index);
    public static Vector256`1<int> InsertVector128(Vector256`1<int> value, Vector128`1<int> data, byte index);
    public static Vector256`1<UInt32> InsertVector128(Vector256`1<UInt32> value, Vector128`1<UInt32> data, byte index);
    public static Vector256`1<long> InsertVector128(Vector256`1<long> value, Vector128`1<long> data, byte index);
    public static Vector256`1<ulong> InsertVector128(Vector256`1<ulong> value, Vector128`1<ulong> data, byte index);
    public static Vector256`1<float> InsertVector128(Vector256`1<float> value, Vector128`1<float> data, byte index);
    public static Vector256`1<double> InsertVector128(Vector256`1<double> value, Vector128`1<double> data, byte index);
    public static Vector256`1<sbyte> LoadVector256(SByte* address);
    public static Vector256`1<byte> LoadVector256(Byte* address);
    public static Vector256`1<short> LoadVector256(Int16* address);
    public static Vector256`1<ushort> LoadVector256(UInt16* address);
    public static Vector256`1<int> LoadVector256(Int32* address);
    public static Vector256`1<UInt32> LoadVector256(UInt32* address);
    public static Vector256`1<long> LoadVector256(Int64* address);
    public static Vector256`1<ulong> LoadVector256(UInt64* address);
    public static Vector256`1<float> LoadVector256(Single* address);
    public static Vector256`1<double> LoadVector256(Double* address);
    public static Vector256`1<sbyte> LoadAlignedVector256(SByte* address);
    public static Vector256`1<byte> LoadAlignedVector256(Byte* address);
    public static Vector256`1<short> LoadAlignedVector256(Int16* address);
    public static Vector256`1<ushort> LoadAlignedVector256(UInt16* address);
    public static Vector256`1<int> LoadAlignedVector256(Int32* address);
    public static Vector256`1<UInt32> LoadAlignedVector256(UInt32* address);
    public static Vector256`1<long> LoadAlignedVector256(Int64* address);
    public static Vector256`1<ulong> LoadAlignedVector256(UInt64* address);
    public static Vector256`1<float> LoadAlignedVector256(Single* address);
    public static Vector256`1<double> LoadAlignedVector256(Double* address);
    public static Vector256`1<sbyte> LoadDquVector256(SByte* address);
    public static Vector256`1<byte> LoadDquVector256(Byte* address);
    public static Vector256`1<short> LoadDquVector256(Int16* address);
    public static Vector256`1<ushort> LoadDquVector256(UInt16* address);
    public static Vector256`1<int> LoadDquVector256(Int32* address);
    public static Vector256`1<UInt32> LoadDquVector256(UInt32* address);
    public static Vector256`1<long> LoadDquVector256(Int64* address);
    public static Vector256`1<ulong> LoadDquVector256(UInt64* address);
    public static Vector128`1<float> MaskLoad(Single* address, Vector128`1<float> mask);
    public static Vector128`1<double> MaskLoad(Double* address, Vector128`1<double> mask);
    public static Vector256`1<float> MaskLoad(Single* address, Vector256`1<float> mask);
    public static Vector256`1<double> MaskLoad(Double* address, Vector256`1<double> mask);
    public static void MaskStore(Single* address, Vector128`1<float> mask, Vector128`1<float> source);
    public static void MaskStore(Double* address, Vector128`1<double> mask, Vector128`1<double> source);
    public static void MaskStore(Single* address, Vector256`1<float> mask, Vector256`1<float> source);
    public static void MaskStore(Double* address, Vector256`1<double> mask, Vector256`1<double> source);
    public static Vector256`1<float> Max(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> Max(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<float> Min(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> Min(Vector256`1<double> left, Vector256`1<double> right);
    public static int MoveMask(Vector256`1<float> value);
    public static int MoveMask(Vector256`1<double> value);
    public static Vector256`1<float> Multiply(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> Multiply(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<float> Or(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> Or(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector128`1<float> Permute(Vector128`1<float> value, byte control);
    public static Vector128`1<double> Permute(Vector128`1<double> value, byte control);
    public static Vector256`1<float> Permute(Vector256`1<float> value, byte control);
    public static Vector256`1<double> Permute(Vector256`1<double> value, byte control);
    public static Vector256`1<byte> Permute2x128(Vector256`1<byte> left, Vector256`1<byte> right, byte control);
    public static Vector256`1<sbyte> Permute2x128(Vector256`1<sbyte> left, Vector256`1<sbyte> right, byte control);
    public static Vector256`1<short> Permute2x128(Vector256`1<short> left, Vector256`1<short> right, byte control);
    public static Vector256`1<ushort> Permute2x128(Vector256`1<ushort> left, Vector256`1<ushort> right, byte control);
    public static Vector256`1<int> Permute2x128(Vector256`1<int> left, Vector256`1<int> right, byte control);
    public static Vector256`1<UInt32> Permute2x128(Vector256`1<UInt32> left, Vector256`1<UInt32> right, byte control);
    public static Vector256`1<long> Permute2x128(Vector256`1<long> left, Vector256`1<long> right, byte control);
    public static Vector256`1<ulong> Permute2x128(Vector256`1<ulong> left, Vector256`1<ulong> right, byte control);
    public static Vector256`1<float> Permute2x128(Vector256`1<float> left, Vector256`1<float> right, byte control);
    public static Vector256`1<double> Permute2x128(Vector256`1<double> left, Vector256`1<double> right, byte control);
    public static Vector128`1<float> PermuteVar(Vector128`1<float> left, Vector128`1<int> control);
    public static Vector128`1<double> PermuteVar(Vector128`1<double> left, Vector128`1<long> control);
    public static Vector256`1<float> PermuteVar(Vector256`1<float> left, Vector256`1<int> control);
    public static Vector256`1<double> PermuteVar(Vector256`1<double> left, Vector256`1<long> control);
    public static Vector256`1<float> Reciprocal(Vector256`1<float> value);
    public static Vector256`1<float> ReciprocalSqrt(Vector256`1<float> value);
    public static Vector256`1<float> RoundToNearestInteger(Vector256`1<float> value);
    public static Vector256`1<float> RoundToNegativeInfinity(Vector256`1<float> value);
    public static Vector256`1<float> RoundToPositiveInfinity(Vector256`1<float> value);
    public static Vector256`1<float> RoundToZero(Vector256`1<float> value);
    public static Vector256`1<float> RoundCurrentDirection(Vector256`1<float> value);
    public static Vector256`1<double> RoundToNearestInteger(Vector256`1<double> value);
    public static Vector256`1<double> RoundToNegativeInfinity(Vector256`1<double> value);
    public static Vector256`1<double> RoundToPositiveInfinity(Vector256`1<double> value);
    public static Vector256`1<double> RoundToZero(Vector256`1<double> value);
    public static Vector256`1<double> RoundCurrentDirection(Vector256`1<double> value);
    public static Vector256`1<float> Shuffle(Vector256`1<float> value, Vector256`1<float> right, byte control);
    public static Vector256`1<double> Shuffle(Vector256`1<double> value, Vector256`1<double> right, byte control);
    public static Vector256`1<float> Sqrt(Vector256`1<float> value);
    public static Vector256`1<double> Sqrt(Vector256`1<double> value);
    public static void StoreAligned(SByte* address, Vector256`1<sbyte> source);
    public static void StoreAligned(Byte* address, Vector256`1<byte> source);
    public static void StoreAligned(Int16* address, Vector256`1<short> source);
    public static void StoreAligned(UInt16* address, Vector256`1<ushort> source);
    public static void StoreAligned(Int32* address, Vector256`1<int> source);
    public static void StoreAligned(UInt32* address, Vector256`1<UInt32> source);
    public static void StoreAligned(Int64* address, Vector256`1<long> source);
    public static void StoreAligned(UInt64* address, Vector256`1<ulong> source);
    public static void StoreAligned(Single* address, Vector256`1<float> source);
    public static void StoreAligned(Double* address, Vector256`1<double> source);
    public static void StoreAlignedNonTemporal(SByte* address, Vector256`1<sbyte> source);
    public static void StoreAlignedNonTemporal(Byte* address, Vector256`1<byte> source);
    public static void StoreAlignedNonTemporal(Int16* address, Vector256`1<short> source);
    public static void StoreAlignedNonTemporal(UInt16* address, Vector256`1<ushort> source);
    public static void StoreAlignedNonTemporal(Int32* address, Vector256`1<int> source);
    public static void StoreAlignedNonTemporal(UInt32* address, Vector256`1<UInt32> source);
    public static void StoreAlignedNonTemporal(Int64* address, Vector256`1<long> source);
    public static void StoreAlignedNonTemporal(UInt64* address, Vector256`1<ulong> source);
    public static void StoreAlignedNonTemporal(Single* address, Vector256`1<float> source);
    public static void StoreAlignedNonTemporal(Double* address, Vector256`1<double> source);
    public static void Store(SByte* address, Vector256`1<sbyte> source);
    public static void Store(Byte* address, Vector256`1<byte> source);
    public static void Store(Int16* address, Vector256`1<short> source);
    public static void Store(UInt16* address, Vector256`1<ushort> source);
    public static void Store(Int32* address, Vector256`1<int> source);
    public static void Store(UInt32* address, Vector256`1<UInt32> source);
    public static void Store(Int64* address, Vector256`1<long> source);
    public static void Store(UInt64* address, Vector256`1<ulong> source);
    public static void Store(Single* address, Vector256`1<float> source);
    public static void Store(Double* address, Vector256`1<double> source);
    public static Vector256`1<float> Subtract(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> Subtract(Vector256`1<double> left, Vector256`1<double> right);
    public static bool TestC(Vector128`1<float> left, Vector128`1<float> right);
    public static bool TestC(Vector128`1<double> left, Vector128`1<double> right);
    public static bool TestC(Vector256`1<byte> left, Vector256`1<byte> right);
    public static bool TestC(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static bool TestC(Vector256`1<short> left, Vector256`1<short> right);
    public static bool TestC(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static bool TestC(Vector256`1<int> left, Vector256`1<int> right);
    public static bool TestC(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static bool TestC(Vector256`1<long> left, Vector256`1<long> right);
    public static bool TestC(Vector256`1<ulong> left, Vector256`1<ulong> right);
    public static bool TestC(Vector256`1<float> left, Vector256`1<float> right);
    public static bool TestC(Vector256`1<double> left, Vector256`1<double> right);
    public static bool TestNotZAndNotC(Vector128`1<float> left, Vector128`1<float> right);
    public static bool TestNotZAndNotC(Vector128`1<double> left, Vector128`1<double> right);
    public static bool TestNotZAndNotC(Vector256`1<byte> left, Vector256`1<byte> right);
    public static bool TestNotZAndNotC(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static bool TestNotZAndNotC(Vector256`1<short> left, Vector256`1<short> right);
    public static bool TestNotZAndNotC(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static bool TestNotZAndNotC(Vector256`1<int> left, Vector256`1<int> right);
    public static bool TestNotZAndNotC(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static bool TestNotZAndNotC(Vector256`1<long> left, Vector256`1<long> right);
    public static bool TestNotZAndNotC(Vector256`1<ulong> left, Vector256`1<ulong> right);
    public static bool TestNotZAndNotC(Vector256`1<float> left, Vector256`1<float> right);
    public static bool TestNotZAndNotC(Vector256`1<double> left, Vector256`1<double> right);
    public static bool TestZ(Vector128`1<float> left, Vector128`1<float> right);
    public static bool TestZ(Vector128`1<double> left, Vector128`1<double> right);
    public static bool TestZ(Vector256`1<byte> left, Vector256`1<byte> right);
    public static bool TestZ(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static bool TestZ(Vector256`1<short> left, Vector256`1<short> right);
    public static bool TestZ(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static bool TestZ(Vector256`1<int> left, Vector256`1<int> right);
    public static bool TestZ(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static bool TestZ(Vector256`1<long> left, Vector256`1<long> right);
    public static bool TestZ(Vector256`1<ulong> left, Vector256`1<ulong> right);
    public static bool TestZ(Vector256`1<float> left, Vector256`1<float> right);
    public static bool TestZ(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<float> UnpackHigh(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> UnpackHigh(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<float> UnpackLow(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> UnpackLow(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<float> Xor(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> Xor(Vector256`1<double> left, Vector256`1<double> right);
}
[CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public abstract class System.Runtime.Intrinsics.X86.Avx2 : Avx {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static Vector256`1<byte> Abs(Vector256`1<sbyte> value);
    public static Vector256`1<ushort> Abs(Vector256`1<short> value);
    public static Vector256`1<UInt32> Abs(Vector256`1<int> value);
    public static Vector256`1<sbyte> Add(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<byte> Add(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<short> Add(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> Add(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<int> Add(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<UInt32> Add(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static Vector256`1<long> Add(Vector256`1<long> left, Vector256`1<long> right);
    public static Vector256`1<ulong> Add(Vector256`1<ulong> left, Vector256`1<ulong> right);
    public static Vector256`1<sbyte> AddSaturate(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<byte> AddSaturate(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<short> AddSaturate(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> AddSaturate(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<sbyte> AlignRight(Vector256`1<sbyte> left, Vector256`1<sbyte> right, byte mask);
    public static Vector256`1<byte> AlignRight(Vector256`1<byte> left, Vector256`1<byte> right, byte mask);
    public static Vector256`1<short> AlignRight(Vector256`1<short> left, Vector256`1<short> right, byte mask);
    public static Vector256`1<ushort> AlignRight(Vector256`1<ushort> left, Vector256`1<ushort> right, byte mask);
    public static Vector256`1<int> AlignRight(Vector256`1<int> left, Vector256`1<int> right, byte mask);
    public static Vector256`1<UInt32> AlignRight(Vector256`1<UInt32> left, Vector256`1<UInt32> right, byte mask);
    public static Vector256`1<long> AlignRight(Vector256`1<long> left, Vector256`1<long> right, byte mask);
    public static Vector256`1<ulong> AlignRight(Vector256`1<ulong> left, Vector256`1<ulong> right, byte mask);
    public static Vector256`1<sbyte> And(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<byte> And(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<short> And(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> And(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<int> And(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<UInt32> And(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static Vector256`1<long> And(Vector256`1<long> left, Vector256`1<long> right);
    public static Vector256`1<ulong> And(Vector256`1<ulong> left, Vector256`1<ulong> right);
    public static Vector256`1<sbyte> AndNot(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<byte> AndNot(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<short> AndNot(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> AndNot(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<int> AndNot(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<UInt32> AndNot(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static Vector256`1<long> AndNot(Vector256`1<long> left, Vector256`1<long> right);
    public static Vector256`1<ulong> AndNot(Vector256`1<ulong> left, Vector256`1<ulong> right);
    public static Vector256`1<byte> Average(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<ushort> Average(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector128`1<int> Blend(Vector128`1<int> left, Vector128`1<int> right, byte control);
    public static Vector128`1<UInt32> Blend(Vector128`1<UInt32> left, Vector128`1<UInt32> right, byte control);
    public static Vector256`1<short> Blend(Vector256`1<short> left, Vector256`1<short> right, byte control);
    public static Vector256`1<ushort> Blend(Vector256`1<ushort> left, Vector256`1<ushort> right, byte control);
    public static Vector256`1<int> Blend(Vector256`1<int> left, Vector256`1<int> right, byte control);
    public static Vector256`1<UInt32> Blend(Vector256`1<UInt32> left, Vector256`1<UInt32> right, byte control);
    public static Vector256`1<sbyte> BlendVariable(Vector256`1<sbyte> left, Vector256`1<sbyte> right, Vector256`1<sbyte> mask);
    public static Vector256`1<byte> BlendVariable(Vector256`1<byte> left, Vector256`1<byte> right, Vector256`1<byte> mask);
    public static Vector256`1<short> BlendVariable(Vector256`1<short> left, Vector256`1<short> right, Vector256`1<short> mask);
    public static Vector256`1<ushort> BlendVariable(Vector256`1<ushort> left, Vector256`1<ushort> right, Vector256`1<ushort> mask);
    public static Vector256`1<int> BlendVariable(Vector256`1<int> left, Vector256`1<int> right, Vector256`1<int> mask);
    public static Vector256`1<UInt32> BlendVariable(Vector256`1<UInt32> left, Vector256`1<UInt32> right, Vector256`1<UInt32> mask);
    public static Vector256`1<long> BlendVariable(Vector256`1<long> left, Vector256`1<long> right, Vector256`1<long> mask);
    public static Vector256`1<ulong> BlendVariable(Vector256`1<ulong> left, Vector256`1<ulong> right, Vector256`1<ulong> mask);
    public static Vector128`1<byte> BroadcastScalarToVector128(Vector128`1<byte> value);
    public static Vector128`1<sbyte> BroadcastScalarToVector128(Vector128`1<sbyte> value);
    public static Vector128`1<short> BroadcastScalarToVector128(Vector128`1<short> value);
    public static Vector128`1<ushort> BroadcastScalarToVector128(Vector128`1<ushort> value);
    public static Vector128`1<int> BroadcastScalarToVector128(Vector128`1<int> value);
    public static Vector128`1<UInt32> BroadcastScalarToVector128(Vector128`1<UInt32> value);
    public static Vector128`1<long> BroadcastScalarToVector128(Vector128`1<long> value);
    public static Vector128`1<ulong> BroadcastScalarToVector128(Vector128`1<ulong> value);
    public static Vector128`1<float> BroadcastScalarToVector128(Vector128`1<float> value);
    public static Vector128`1<double> BroadcastScalarToVector128(Vector128`1<double> value);
    public static Vector128`1<byte> BroadcastScalarToVector128(Byte* source);
    public static Vector128`1<sbyte> BroadcastScalarToVector128(SByte* source);
    public static Vector128`1<short> BroadcastScalarToVector128(Int16* source);
    public static Vector128`1<ushort> BroadcastScalarToVector128(UInt16* source);
    public static Vector128`1<int> BroadcastScalarToVector128(Int32* source);
    public static Vector128`1<UInt32> BroadcastScalarToVector128(UInt32* source);
    public static Vector128`1<long> BroadcastScalarToVector128(Int64* source);
    public static Vector128`1<ulong> BroadcastScalarToVector128(UInt64* source);
    public static Vector256`1<byte> BroadcastScalarToVector256(Vector128`1<byte> value);
    public static Vector256`1<sbyte> BroadcastScalarToVector256(Vector128`1<sbyte> value);
    public static Vector256`1<short> BroadcastScalarToVector256(Vector128`1<short> value);
    public static Vector256`1<ushort> BroadcastScalarToVector256(Vector128`1<ushort> value);
    public static Vector256`1<int> BroadcastScalarToVector256(Vector128`1<int> value);
    public static Vector256`1<UInt32> BroadcastScalarToVector256(Vector128`1<UInt32> value);
    public static Vector256`1<long> BroadcastScalarToVector256(Vector128`1<long> value);
    public static Vector256`1<ulong> BroadcastScalarToVector256(Vector128`1<ulong> value);
    public static Vector256`1<float> BroadcastScalarToVector256(Vector128`1<float> value);
    public static Vector256`1<double> BroadcastScalarToVector256(Vector128`1<double> value);
    public static Vector256`1<byte> BroadcastScalarToVector256(Byte* source);
    public static Vector256`1<sbyte> BroadcastScalarToVector256(SByte* source);
    public static Vector256`1<short> BroadcastScalarToVector256(Int16* source);
    public static Vector256`1<ushort> BroadcastScalarToVector256(UInt16* source);
    public static Vector256`1<int> BroadcastScalarToVector256(Int32* source);
    public static Vector256`1<UInt32> BroadcastScalarToVector256(UInt32* source);
    public static Vector256`1<long> BroadcastScalarToVector256(Int64* source);
    public static Vector256`1<ulong> BroadcastScalarToVector256(UInt64* source);
    public static Vector256`1<sbyte> BroadcastVector128ToVector256(SByte* address);
    public static Vector256`1<byte> BroadcastVector128ToVector256(Byte* address);
    public static Vector256`1<short> BroadcastVector128ToVector256(Int16* address);
    public static Vector256`1<ushort> BroadcastVector128ToVector256(UInt16* address);
    public static Vector256`1<int> BroadcastVector128ToVector256(Int32* address);
    public static Vector256`1<UInt32> BroadcastVector128ToVector256(UInt32* address);
    public static Vector256`1<long> BroadcastVector128ToVector256(Int64* address);
    public static Vector256`1<ulong> BroadcastVector128ToVector256(UInt64* address);
    public static Vector256`1<sbyte> CompareEqual(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<byte> CompareEqual(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<short> CompareEqual(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> CompareEqual(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<int> CompareEqual(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<UInt32> CompareEqual(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static Vector256`1<long> CompareEqual(Vector256`1<long> left, Vector256`1<long> right);
    public static Vector256`1<ulong> CompareEqual(Vector256`1<ulong> left, Vector256`1<ulong> right);
    public static Vector256`1<sbyte> CompareGreaterThan(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<short> CompareGreaterThan(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<int> CompareGreaterThan(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<long> CompareGreaterThan(Vector256`1<long> left, Vector256`1<long> right);
    public static int ConvertToInt32(Vector256`1<int> value);
    public static UInt32 ConvertToUInt32(Vector256`1<UInt32> value);
    public static Vector256`1<short> ConvertToVector256Int16(Vector128`1<sbyte> value);
    public static Vector256`1<short> ConvertToVector256Int16(Vector128`1<byte> value);
    public static Vector256`1<int> ConvertToVector256Int32(Vector128`1<sbyte> value);
    public static Vector256`1<int> ConvertToVector256Int32(Vector128`1<byte> value);
    public static Vector256`1<int> ConvertToVector256Int32(Vector128`1<short> value);
    public static Vector256`1<int> ConvertToVector256Int32(Vector128`1<ushort> value);
    public static Vector256`1<long> ConvertToVector256Int64(Vector128`1<sbyte> value);
    public static Vector256`1<long> ConvertToVector256Int64(Vector128`1<byte> value);
    public static Vector256`1<long> ConvertToVector256Int64(Vector128`1<short> value);
    public static Vector256`1<long> ConvertToVector256Int64(Vector128`1<ushort> value);
    public static Vector256`1<long> ConvertToVector256Int64(Vector128`1<int> value);
    public static Vector256`1<long> ConvertToVector256Int64(Vector128`1<UInt32> value);
    public static Vector256`1<short> ConvertToVector256Int16(SByte* address);
    public static Vector256`1<short> ConvertToVector256Int16(Byte* address);
    public static Vector256`1<int> ConvertToVector256Int32(SByte* address);
    public static Vector256`1<int> ConvertToVector256Int32(Byte* address);
    public static Vector256`1<int> ConvertToVector256Int32(Int16* address);
    public static Vector256`1<int> ConvertToVector256Int32(UInt16* address);
    public static Vector256`1<long> ConvertToVector256Int64(SByte* address);
    public static Vector256`1<long> ConvertToVector256Int64(Byte* address);
    public static Vector256`1<long> ConvertToVector256Int64(Int16* address);
    public static Vector256`1<long> ConvertToVector256Int64(UInt16* address);
    public static Vector256`1<long> ConvertToVector256Int64(Int32* address);
    public static Vector256`1<long> ConvertToVector256Int64(UInt32* address);
    public static Vector128`1<sbyte> ExtractVector128(Vector256`1<sbyte> value, byte index);
    public static Vector128`1<byte> ExtractVector128(Vector256`1<byte> value, byte index);
    public static Vector128`1<short> ExtractVector128(Vector256`1<short> value, byte index);
    public static Vector128`1<ushort> ExtractVector128(Vector256`1<ushort> value, byte index);
    public static Vector128`1<int> ExtractVector128(Vector256`1<int> value, byte index);
    public static Vector128`1<UInt32> ExtractVector128(Vector256`1<UInt32> value, byte index);
    public static Vector128`1<long> ExtractVector128(Vector256`1<long> value, byte index);
    public static Vector128`1<ulong> ExtractVector128(Vector256`1<ulong> value, byte index);
    public static Vector128`1<int> GatherVector128(Int32* baseAddress, Vector128`1<int> index, byte scale);
    public static Vector128`1<UInt32> GatherVector128(UInt32* baseAddress, Vector128`1<int> index, byte scale);
    public static Vector128`1<long> GatherVector128(Int64* baseAddress, Vector128`1<int> index, byte scale);
    public static Vector128`1<ulong> GatherVector128(UInt64* baseAddress, Vector128`1<int> index, byte scale);
    public static Vector128`1<float> GatherVector128(Single* baseAddress, Vector128`1<int> index, byte scale);
    public static Vector128`1<double> GatherVector128(Double* baseAddress, Vector128`1<int> index, byte scale);
    public static Vector128`1<int> GatherVector128(Int32* baseAddress, Vector128`1<long> index, byte scale);
    public static Vector128`1<UInt32> GatherVector128(UInt32* baseAddress, Vector128`1<long> index, byte scale);
    public static Vector128`1<long> GatherVector128(Int64* baseAddress, Vector128`1<long> index, byte scale);
    public static Vector128`1<ulong> GatherVector128(UInt64* baseAddress, Vector128`1<long> index, byte scale);
    public static Vector128`1<float> GatherVector128(Single* baseAddress, Vector128`1<long> index, byte scale);
    public static Vector128`1<double> GatherVector128(Double* baseAddress, Vector128`1<long> index, byte scale);
    public static Vector256`1<int> GatherVector256(Int32* baseAddress, Vector256`1<int> index, byte scale);
    public static Vector256`1<UInt32> GatherVector256(UInt32* baseAddress, Vector256`1<int> index, byte scale);
    public static Vector256`1<long> GatherVector256(Int64* baseAddress, Vector128`1<int> index, byte scale);
    public static Vector256`1<ulong> GatherVector256(UInt64* baseAddress, Vector128`1<int> index, byte scale);
    public static Vector256`1<float> GatherVector256(Single* baseAddress, Vector256`1<int> index, byte scale);
    public static Vector256`1<double> GatherVector256(Double* baseAddress, Vector128`1<int> index, byte scale);
    public static Vector128`1<int> GatherVector128(Int32* baseAddress, Vector256`1<long> index, byte scale);
    public static Vector128`1<UInt32> GatherVector128(UInt32* baseAddress, Vector256`1<long> index, byte scale);
    public static Vector256`1<long> GatherVector256(Int64* baseAddress, Vector256`1<long> index, byte scale);
    public static Vector256`1<ulong> GatherVector256(UInt64* baseAddress, Vector256`1<long> index, byte scale);
    public static Vector128`1<float> GatherVector128(Single* baseAddress, Vector256`1<long> index, byte scale);
    public static Vector256`1<double> GatherVector256(Double* baseAddress, Vector256`1<long> index, byte scale);
    public static Vector128`1<int> GatherMaskVector128(Vector128`1<int> source, Int32* baseAddress, Vector128`1<int> index, Vector128`1<int> mask, byte scale);
    public static Vector128`1<UInt32> GatherMaskVector128(Vector128`1<UInt32> source, UInt32* baseAddress, Vector128`1<int> index, Vector128`1<UInt32> mask, byte scale);
    public static Vector128`1<long> GatherMaskVector128(Vector128`1<long> source, Int64* baseAddress, Vector128`1<int> index, Vector128`1<long> mask, byte scale);
    public static Vector128`1<ulong> GatherMaskVector128(Vector128`1<ulong> source, UInt64* baseAddress, Vector128`1<int> index, Vector128`1<ulong> mask, byte scale);
    public static Vector128`1<float> GatherMaskVector128(Vector128`1<float> source, Single* baseAddress, Vector128`1<int> index, Vector128`1<float> mask, byte scale);
    public static Vector128`1<double> GatherMaskVector128(Vector128`1<double> source, Double* baseAddress, Vector128`1<int> index, Vector128`1<double> mask, byte scale);
    public static Vector128`1<int> GatherMaskVector128(Vector128`1<int> source, Int32* baseAddress, Vector128`1<long> index, Vector128`1<int> mask, byte scale);
    public static Vector128`1<UInt32> GatherMaskVector128(Vector128`1<UInt32> source, UInt32* baseAddress, Vector128`1<long> index, Vector128`1<UInt32> mask, byte scale);
    public static Vector128`1<long> GatherMaskVector128(Vector128`1<long> source, Int64* baseAddress, Vector128`1<long> index, Vector128`1<long> mask, byte scale);
    public static Vector128`1<ulong> GatherMaskVector128(Vector128`1<ulong> source, UInt64* baseAddress, Vector128`1<long> index, Vector128`1<ulong> mask, byte scale);
    public static Vector128`1<float> GatherMaskVector128(Vector128`1<float> source, Single* baseAddress, Vector128`1<long> index, Vector128`1<float> mask, byte scale);
    public static Vector128`1<double> GatherMaskVector128(Vector128`1<double> source, Double* baseAddress, Vector128`1<long> index, Vector128`1<double> mask, byte scale);
    public static Vector256`1<int> GatherMaskVector256(Vector256`1<int> source, Int32* baseAddress, Vector256`1<int> index, Vector256`1<int> mask, byte scale);
    public static Vector256`1<UInt32> GatherMaskVector256(Vector256`1<UInt32> source, UInt32* baseAddress, Vector256`1<int> index, Vector256`1<UInt32> mask, byte scale);
    public static Vector256`1<long> GatherMaskVector256(Vector256`1<long> source, Int64* baseAddress, Vector128`1<int> index, Vector256`1<long> mask, byte scale);
    public static Vector256`1<ulong> GatherMaskVector256(Vector256`1<ulong> source, UInt64* baseAddress, Vector128`1<int> index, Vector256`1<ulong> mask, byte scale);
    public static Vector256`1<float> GatherMaskVector256(Vector256`1<float> source, Single* baseAddress, Vector256`1<int> index, Vector256`1<float> mask, byte scale);
    public static Vector256`1<double> GatherMaskVector256(Vector256`1<double> source, Double* baseAddress, Vector128`1<int> index, Vector256`1<double> mask, byte scale);
    public static Vector128`1<int> GatherMaskVector128(Vector128`1<int> source, Int32* baseAddress, Vector256`1<long> index, Vector128`1<int> mask, byte scale);
    public static Vector128`1<UInt32> GatherMaskVector128(Vector128`1<UInt32> source, UInt32* baseAddress, Vector256`1<long> index, Vector128`1<UInt32> mask, byte scale);
    public static Vector256`1<long> GatherMaskVector256(Vector256`1<long> source, Int64* baseAddress, Vector256`1<long> index, Vector256`1<long> mask, byte scale);
    public static Vector256`1<ulong> GatherMaskVector256(Vector256`1<ulong> source, UInt64* baseAddress, Vector256`1<long> index, Vector256`1<ulong> mask, byte scale);
    public static Vector128`1<float> GatherMaskVector128(Vector128`1<float> source, Single* baseAddress, Vector256`1<long> index, Vector128`1<float> mask, byte scale);
    public static Vector256`1<double> GatherMaskVector256(Vector256`1<double> source, Double* baseAddress, Vector256`1<long> index, Vector256`1<double> mask, byte scale);
    public static Vector256`1<short> HorizontalAdd(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<int> HorizontalAdd(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<short> HorizontalAddSaturate(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<short> HorizontalSubtract(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<int> HorizontalSubtract(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<short> HorizontalSubtractSaturate(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<sbyte> InsertVector128(Vector256`1<sbyte> value, Vector128`1<sbyte> data, byte index);
    public static Vector256`1<byte> InsertVector128(Vector256`1<byte> value, Vector128`1<byte> data, byte index);
    public static Vector256`1<short> InsertVector128(Vector256`1<short> value, Vector128`1<short> data, byte index);
    public static Vector256`1<ushort> InsertVector128(Vector256`1<ushort> value, Vector128`1<ushort> data, byte index);
    public static Vector256`1<int> InsertVector128(Vector256`1<int> value, Vector128`1<int> data, byte index);
    public static Vector256`1<UInt32> InsertVector128(Vector256`1<UInt32> value, Vector128`1<UInt32> data, byte index);
    public static Vector256`1<long> InsertVector128(Vector256`1<long> value, Vector128`1<long> data, byte index);
    public static Vector256`1<ulong> InsertVector128(Vector256`1<ulong> value, Vector128`1<ulong> data, byte index);
    public static Vector256`1<sbyte> LoadAlignedVector256NonTemporal(SByte* address);
    public static Vector256`1<byte> LoadAlignedVector256NonTemporal(Byte* address);
    public static Vector256`1<short> LoadAlignedVector256NonTemporal(Int16* address);
    public static Vector256`1<ushort> LoadAlignedVector256NonTemporal(UInt16* address);
    public static Vector256`1<int> LoadAlignedVector256NonTemporal(Int32* address);
    public static Vector256`1<UInt32> LoadAlignedVector256NonTemporal(UInt32* address);
    public static Vector256`1<long> LoadAlignedVector256NonTemporal(Int64* address);
    public static Vector256`1<ulong> LoadAlignedVector256NonTemporal(UInt64* address);
    public static Vector128`1<int> MaskLoad(Int32* address, Vector128`1<int> mask);
    public static Vector128`1<UInt32> MaskLoad(UInt32* address, Vector128`1<UInt32> mask);
    public static Vector128`1<long> MaskLoad(Int64* address, Vector128`1<long> mask);
    public static Vector128`1<ulong> MaskLoad(UInt64* address, Vector128`1<ulong> mask);
    public static Vector256`1<int> MaskLoad(Int32* address, Vector256`1<int> mask);
    public static Vector256`1<UInt32> MaskLoad(UInt32* address, Vector256`1<UInt32> mask);
    public static Vector256`1<long> MaskLoad(Int64* address, Vector256`1<long> mask);
    public static Vector256`1<ulong> MaskLoad(UInt64* address, Vector256`1<ulong> mask);
    public static void MaskStore(Int32* address, Vector128`1<int> mask, Vector128`1<int> source);
    public static void MaskStore(UInt32* address, Vector128`1<UInt32> mask, Vector128`1<UInt32> source);
    public static void MaskStore(Int64* address, Vector128`1<long> mask, Vector128`1<long> source);
    public static void MaskStore(UInt64* address, Vector128`1<ulong> mask, Vector128`1<ulong> source);
    public static void MaskStore(Int32* address, Vector256`1<int> mask, Vector256`1<int> source);
    public static void MaskStore(UInt32* address, Vector256`1<UInt32> mask, Vector256`1<UInt32> source);
    public static void MaskStore(Int64* address, Vector256`1<long> mask, Vector256`1<long> source);
    public static void MaskStore(UInt64* address, Vector256`1<ulong> mask, Vector256`1<ulong> source);
    public static Vector256`1<int> MultiplyAddAdjacent(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<short> MultiplyAddAdjacent(Vector256`1<byte> left, Vector256`1<sbyte> right);
    public static Vector256`1<sbyte> Max(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<byte> Max(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<short> Max(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> Max(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<int> Max(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<UInt32> Max(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static Vector256`1<sbyte> Min(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<byte> Min(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<short> Min(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> Min(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<int> Min(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<UInt32> Min(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static int MoveMask(Vector256`1<sbyte> value);
    public static int MoveMask(Vector256`1<byte> value);
    public static Vector256`1<ushort> MultipleSumAbsoluteDifferences(Vector256`1<byte> left, Vector256`1<byte> right, byte mask);
    public static Vector256`1<long> Multiply(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<ulong> Multiply(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static Vector256`1<short> MultiplyHigh(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> MultiplyHigh(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<short> MultiplyHighRoundScale(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<short> MultiplyLow(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> MultiplyLow(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<int> MultiplyLow(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<UInt32> MultiplyLow(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static Vector256`1<sbyte> Or(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<byte> Or(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<short> Or(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> Or(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<int> Or(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<UInt32> Or(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static Vector256`1<long> Or(Vector256`1<long> left, Vector256`1<long> right);
    public static Vector256`1<ulong> Or(Vector256`1<ulong> left, Vector256`1<ulong> right);
    public static Vector256`1<sbyte> PackSignedSaturate(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<short> PackSignedSaturate(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<byte> PackUnsignedSaturate(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> PackUnsignedSaturate(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<sbyte> Permute2x128(Vector256`1<sbyte> left, Vector256`1<sbyte> right, byte control);
    public static Vector256`1<byte> Permute2x128(Vector256`1<byte> left, Vector256`1<byte> right, byte control);
    public static Vector256`1<short> Permute2x128(Vector256`1<short> left, Vector256`1<short> right, byte control);
    public static Vector256`1<ushort> Permute2x128(Vector256`1<ushort> left, Vector256`1<ushort> right, byte control);
    public static Vector256`1<int> Permute2x128(Vector256`1<int> left, Vector256`1<int> right, byte control);
    public static Vector256`1<UInt32> Permute2x128(Vector256`1<UInt32> left, Vector256`1<UInt32> right, byte control);
    public static Vector256`1<long> Permute2x128(Vector256`1<long> left, Vector256`1<long> right, byte control);
    public static Vector256`1<ulong> Permute2x128(Vector256`1<ulong> left, Vector256`1<ulong> right, byte control);
    public static Vector256`1<long> Permute4x64(Vector256`1<long> value, byte control);
    public static Vector256`1<ulong> Permute4x64(Vector256`1<ulong> value, byte control);
    public static Vector256`1<double> Permute4x64(Vector256`1<double> value, byte control);
    public static Vector256`1<int> PermuteVar8x32(Vector256`1<int> left, Vector256`1<int> control);
    public static Vector256`1<UInt32> PermuteVar8x32(Vector256`1<UInt32> left, Vector256`1<UInt32> control);
    public static Vector256`1<float> PermuteVar8x32(Vector256`1<float> left, Vector256`1<int> control);
    public static Vector256`1<short> ShiftLeftLogical(Vector256`1<short> value, Vector128`1<short> count);
    public static Vector256`1<ushort> ShiftLeftLogical(Vector256`1<ushort> value, Vector128`1<ushort> count);
    public static Vector256`1<int> ShiftLeftLogical(Vector256`1<int> value, Vector128`1<int> count);
    public static Vector256`1<UInt32> ShiftLeftLogical(Vector256`1<UInt32> value, Vector128`1<UInt32> count);
    public static Vector256`1<long> ShiftLeftLogical(Vector256`1<long> value, Vector128`1<long> count);
    public static Vector256`1<ulong> ShiftLeftLogical(Vector256`1<ulong> value, Vector128`1<ulong> count);
    public static Vector256`1<short> ShiftLeftLogical(Vector256`1<short> value, byte count);
    public static Vector256`1<ushort> ShiftLeftLogical(Vector256`1<ushort> value, byte count);
    public static Vector256`1<int> ShiftLeftLogical(Vector256`1<int> value, byte count);
    public static Vector256`1<UInt32> ShiftLeftLogical(Vector256`1<UInt32> value, byte count);
    public static Vector256`1<long> ShiftLeftLogical(Vector256`1<long> value, byte count);
    public static Vector256`1<ulong> ShiftLeftLogical(Vector256`1<ulong> value, byte count);
    public static Vector256`1<sbyte> ShiftLeftLogical128BitLane(Vector256`1<sbyte> value, byte numBytes);
    public static Vector256`1<byte> ShiftLeftLogical128BitLane(Vector256`1<byte> value, byte numBytes);
    public static Vector256`1<short> ShiftLeftLogical128BitLane(Vector256`1<short> value, byte numBytes);
    public static Vector256`1<ushort> ShiftLeftLogical128BitLane(Vector256`1<ushort> value, byte numBytes);
    public static Vector256`1<int> ShiftLeftLogical128BitLane(Vector256`1<int> value, byte numBytes);
    public static Vector256`1<UInt32> ShiftLeftLogical128BitLane(Vector256`1<UInt32> value, byte numBytes);
    public static Vector256`1<long> ShiftLeftLogical128BitLane(Vector256`1<long> value, byte numBytes);
    public static Vector256`1<ulong> ShiftLeftLogical128BitLane(Vector256`1<ulong> value, byte numBytes);
    public static Vector256`1<int> ShiftLeftLogicalVariable(Vector256`1<int> value, Vector256`1<UInt32> count);
    public static Vector256`1<UInt32> ShiftLeftLogicalVariable(Vector256`1<UInt32> value, Vector256`1<UInt32> count);
    public static Vector256`1<long> ShiftLeftLogicalVariable(Vector256`1<long> value, Vector256`1<ulong> count);
    public static Vector256`1<ulong> ShiftLeftLogicalVariable(Vector256`1<ulong> value, Vector256`1<ulong> count);
    public static Vector128`1<int> ShiftLeftLogicalVariable(Vector128`1<int> value, Vector128`1<UInt32> count);
    public static Vector128`1<UInt32> ShiftLeftLogicalVariable(Vector128`1<UInt32> value, Vector128`1<UInt32> count);
    public static Vector128`1<long> ShiftLeftLogicalVariable(Vector128`1<long> value, Vector128`1<ulong> count);
    public static Vector128`1<ulong> ShiftLeftLogicalVariable(Vector128`1<ulong> value, Vector128`1<ulong> count);
    public static Vector256`1<short> ShiftRightArithmetic(Vector256`1<short> value, Vector128`1<short> count);
    public static Vector256`1<int> ShiftRightArithmetic(Vector256`1<int> value, Vector128`1<int> count);
    public static Vector256`1<short> ShiftRightArithmetic(Vector256`1<short> value, byte count);
    public static Vector256`1<int> ShiftRightArithmetic(Vector256`1<int> value, byte count);
    public static Vector256`1<int> ShiftRightArithmeticVariable(Vector256`1<int> value, Vector256`1<UInt32> count);
    public static Vector128`1<int> ShiftRightArithmeticVariable(Vector128`1<int> value, Vector128`1<UInt32> count);
    public static Vector256`1<short> ShiftRightLogical(Vector256`1<short> value, Vector128`1<short> count);
    public static Vector256`1<ushort> ShiftRightLogical(Vector256`1<ushort> value, Vector128`1<ushort> count);
    public static Vector256`1<int> ShiftRightLogical(Vector256`1<int> value, Vector128`1<int> count);
    public static Vector256`1<UInt32> ShiftRightLogical(Vector256`1<UInt32> value, Vector128`1<UInt32> count);
    public static Vector256`1<long> ShiftRightLogical(Vector256`1<long> value, Vector128`1<long> count);
    public static Vector256`1<ulong> ShiftRightLogical(Vector256`1<ulong> value, Vector128`1<ulong> count);
    public static Vector256`1<short> ShiftRightLogical(Vector256`1<short> value, byte count);
    public static Vector256`1<ushort> ShiftRightLogical(Vector256`1<ushort> value, byte count);
    public static Vector256`1<int> ShiftRightLogical(Vector256`1<int> value, byte count);
    public static Vector256`1<UInt32> ShiftRightLogical(Vector256`1<UInt32> value, byte count);
    public static Vector256`1<long> ShiftRightLogical(Vector256`1<long> value, byte count);
    public static Vector256`1<ulong> ShiftRightLogical(Vector256`1<ulong> value, byte count);
    public static Vector256`1<sbyte> ShiftRightLogical128BitLane(Vector256`1<sbyte> value, byte numBytes);
    public static Vector256`1<byte> ShiftRightLogical128BitLane(Vector256`1<byte> value, byte numBytes);
    public static Vector256`1<short> ShiftRightLogical128BitLane(Vector256`1<short> value, byte numBytes);
    public static Vector256`1<ushort> ShiftRightLogical128BitLane(Vector256`1<ushort> value, byte numBytes);
    public static Vector256`1<int> ShiftRightLogical128BitLane(Vector256`1<int> value, byte numBytes);
    public static Vector256`1<UInt32> ShiftRightLogical128BitLane(Vector256`1<UInt32> value, byte numBytes);
    public static Vector256`1<long> ShiftRightLogical128BitLane(Vector256`1<long> value, byte numBytes);
    public static Vector256`1<ulong> ShiftRightLogical128BitLane(Vector256`1<ulong> value, byte numBytes);
    public static Vector256`1<int> ShiftRightLogicalVariable(Vector256`1<int> value, Vector256`1<UInt32> count);
    public static Vector256`1<UInt32> ShiftRightLogicalVariable(Vector256`1<UInt32> value, Vector256`1<UInt32> count);
    public static Vector256`1<long> ShiftRightLogicalVariable(Vector256`1<long> value, Vector256`1<ulong> count);
    public static Vector256`1<ulong> ShiftRightLogicalVariable(Vector256`1<ulong> value, Vector256`1<ulong> count);
    public static Vector128`1<int> ShiftRightLogicalVariable(Vector128`1<int> value, Vector128`1<UInt32> count);
    public static Vector128`1<UInt32> ShiftRightLogicalVariable(Vector128`1<UInt32> value, Vector128`1<UInt32> count);
    public static Vector128`1<long> ShiftRightLogicalVariable(Vector128`1<long> value, Vector128`1<ulong> count);
    public static Vector128`1<ulong> ShiftRightLogicalVariable(Vector128`1<ulong> value, Vector128`1<ulong> count);
    public static Vector256`1<sbyte> Shuffle(Vector256`1<sbyte> value, Vector256`1<sbyte> mask);
    public static Vector256`1<byte> Shuffle(Vector256`1<byte> value, Vector256`1<byte> mask);
    public static Vector256`1<int> Shuffle(Vector256`1<int> value, byte control);
    public static Vector256`1<UInt32> Shuffle(Vector256`1<UInt32> value, byte control);
    public static Vector256`1<short> ShuffleHigh(Vector256`1<short> value, byte control);
    public static Vector256`1<ushort> ShuffleHigh(Vector256`1<ushort> value, byte control);
    public static Vector256`1<short> ShuffleLow(Vector256`1<short> value, byte control);
    public static Vector256`1<ushort> ShuffleLow(Vector256`1<ushort> value, byte control);
    public static Vector256`1<sbyte> Sign(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<short> Sign(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<int> Sign(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<sbyte> Subtract(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<byte> Subtract(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<short> Subtract(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> Subtract(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<int> Subtract(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<UInt32> Subtract(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static Vector256`1<long> Subtract(Vector256`1<long> left, Vector256`1<long> right);
    public static Vector256`1<ulong> Subtract(Vector256`1<ulong> left, Vector256`1<ulong> right);
    public static Vector256`1<sbyte> SubtractSaturate(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<short> SubtractSaturate(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<byte> SubtractSaturate(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<ushort> SubtractSaturate(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<ushort> SumAbsoluteDifferences(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<sbyte> UnpackHigh(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<byte> UnpackHigh(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<short> UnpackHigh(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> UnpackHigh(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<int> UnpackHigh(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<UInt32> UnpackHigh(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static Vector256`1<long> UnpackHigh(Vector256`1<long> left, Vector256`1<long> right);
    public static Vector256`1<ulong> UnpackHigh(Vector256`1<ulong> left, Vector256`1<ulong> right);
    public static Vector256`1<sbyte> UnpackLow(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<byte> UnpackLow(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<short> UnpackLow(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> UnpackLow(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<int> UnpackLow(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<UInt32> UnpackLow(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static Vector256`1<long> UnpackLow(Vector256`1<long> left, Vector256`1<long> right);
    public static Vector256`1<ulong> UnpackLow(Vector256`1<ulong> left, Vector256`1<ulong> right);
    public static Vector256`1<sbyte> Xor(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<byte> Xor(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<short> Xor(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> Xor(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<int> Xor(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<UInt32> Xor(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static Vector256`1<long> Xor(Vector256`1<long> left, Vector256`1<long> right);
    public static Vector256`1<ulong> Xor(Vector256`1<ulong> left, Vector256`1<ulong> right);
}
[CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public abstract class System.Runtime.Intrinsics.X86.Bmi1 : object {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static UInt32 AndNot(UInt32 left, UInt32 right);
    public static UInt32 BitFieldExtract(UInt32 value, byte start, byte length);
    public static UInt32 BitFieldExtract(UInt32 value, ushort control);
    public static UInt32 ExtractLowestSetBit(UInt32 value);
    public static UInt32 GetMaskUpToLowestSetBit(UInt32 value);
    public static UInt32 ResetLowestSetBit(UInt32 value);
    public static UInt32 TrailingZeroCount(UInt32 value);
}
[CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public abstract class System.Runtime.Intrinsics.X86.Bmi2 : object {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static UInt32 ZeroHighBits(UInt32 value, UInt32 index);
    public static UInt32 MultiplyNoFlags(UInt32 left, UInt32 right);
    public static UInt32 MultiplyNoFlags(UInt32 left, UInt32 right, UInt32* low);
    public static UInt32 ParallelBitDeposit(UInt32 value, UInt32 mask);
    public static UInt32 ParallelBitExtract(UInt32 value, UInt32 mask);
}
public enum System.Runtime.Intrinsics.X86.FloatComparisonMode : Enum {
    public byte value__;
    public static FloatComparisonMode OrderedEqualNonSignaling;
    public static FloatComparisonMode OrderedLessThanSignaling;
    public static FloatComparisonMode OrderedLessThanOrEqualSignaling;
    public static FloatComparisonMode UnorderedNonSignaling;
    public static FloatComparisonMode UnorderedNotEqualNonSignaling;
    public static FloatComparisonMode UnorderedNotLessThanSignaling;
    public static FloatComparisonMode UnorderedNotLessThanOrEqualSignaling;
    public static FloatComparisonMode OrderedNonSignaling;
    public static FloatComparisonMode UnorderedEqualNonSignaling;
    public static FloatComparisonMode UnorderedNotGreaterThanOrEqualSignaling;
    public static FloatComparisonMode UnorderedNotGreaterThanSignaling;
    public static FloatComparisonMode OrderedFalseNonSignaling;
    public static FloatComparisonMode OrderedNotEqualNonSignaling;
    public static FloatComparisonMode OrderedGreaterThanOrEqualSignaling;
    public static FloatComparisonMode OrderedGreaterThanSignaling;
    public static FloatComparisonMode UnorderedTrueNonSignaling;
    public static FloatComparisonMode OrderedEqualSignaling;
    public static FloatComparisonMode OrderedLessThanNonSignaling;
    public static FloatComparisonMode OrderedLessThanOrEqualNonSignaling;
    public static FloatComparisonMode UnorderedSignaling;
    public static FloatComparisonMode UnorderedNotEqualSignaling;
    public static FloatComparisonMode UnorderedNotLessThanNonSignaling;
    public static FloatComparisonMode UnorderedNotLessThanOrEqualNonSignaling;
    public static FloatComparisonMode OrderedSignaling;
    public static FloatComparisonMode UnorderedEqualSignaling;
    public static FloatComparisonMode UnorderedNotGreaterThanOrEqualNonSignaling;
    public static FloatComparisonMode UnorderedNotGreaterThanNonSignaling;
    public static FloatComparisonMode OrderedFalseSignaling;
    public static FloatComparisonMode OrderedNotEqualSignaling;
    public static FloatComparisonMode OrderedGreaterThanOrEqualNonSignaling;
    public static FloatComparisonMode OrderedGreaterThanNonSignaling;
    public static FloatComparisonMode UnorderedTrueSignaling;
}
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public abstract class System.Runtime.Intrinsics.X86.Fma : Avx {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static Vector128`1<float> MultiplyAdd(Vector128`1<float> a, Vector128`1<float> b, Vector128`1<float> c);
    public static Vector128`1<double> MultiplyAdd(Vector128`1<double> a, Vector128`1<double> b, Vector128`1<double> c);
    public static Vector256`1<float> MultiplyAdd(Vector256`1<float> a, Vector256`1<float> b, Vector256`1<float> c);
    public static Vector256`1<double> MultiplyAdd(Vector256`1<double> a, Vector256`1<double> b, Vector256`1<double> c);
    public static Vector128`1<float> MultiplyAddScalar(Vector128`1<float> a, Vector128`1<float> b, Vector128`1<float> c);
    public static Vector128`1<double> MultiplyAddScalar(Vector128`1<double> a, Vector128`1<double> b, Vector128`1<double> c);
    public static Vector128`1<float> MultiplyAddSubtract(Vector128`1<float> a, Vector128`1<float> b, Vector128`1<float> c);
    public static Vector128`1<double> MultiplyAddSubtract(Vector128`1<double> a, Vector128`1<double> b, Vector128`1<double> c);
    public static Vector256`1<float> MultiplyAddSubtract(Vector256`1<float> a, Vector256`1<float> b, Vector256`1<float> c);
    public static Vector256`1<double> MultiplyAddSubtract(Vector256`1<double> a, Vector256`1<double> b, Vector256`1<double> c);
    public static Vector128`1<float> MultiplySubtract(Vector128`1<float> a, Vector128`1<float> b, Vector128`1<float> c);
    public static Vector128`1<double> MultiplySubtract(Vector128`1<double> a, Vector128`1<double> b, Vector128`1<double> c);
    public static Vector256`1<float> MultiplySubtract(Vector256`1<float> a, Vector256`1<float> b, Vector256`1<float> c);
    public static Vector256`1<double> MultiplySubtract(Vector256`1<double> a, Vector256`1<double> b, Vector256`1<double> c);
    public static Vector128`1<float> MultiplySubtractScalar(Vector128`1<float> a, Vector128`1<float> b, Vector128`1<float> c);
    public static Vector128`1<double> MultiplySubtractScalar(Vector128`1<double> a, Vector128`1<double> b, Vector128`1<double> c);
    public static Vector128`1<float> MultiplySubtractAdd(Vector128`1<float> a, Vector128`1<float> b, Vector128`1<float> c);
    public static Vector128`1<double> MultiplySubtractAdd(Vector128`1<double> a, Vector128`1<double> b, Vector128`1<double> c);
    public static Vector256`1<float> MultiplySubtractAdd(Vector256`1<float> a, Vector256`1<float> b, Vector256`1<float> c);
    public static Vector256`1<double> MultiplySubtractAdd(Vector256`1<double> a, Vector256`1<double> b, Vector256`1<double> c);
    public static Vector128`1<float> MultiplyAddNegated(Vector128`1<float> a, Vector128`1<float> b, Vector128`1<float> c);
    public static Vector128`1<double> MultiplyAddNegated(Vector128`1<double> a, Vector128`1<double> b, Vector128`1<double> c);
    public static Vector256`1<float> MultiplyAddNegated(Vector256`1<float> a, Vector256`1<float> b, Vector256`1<float> c);
    public static Vector256`1<double> MultiplyAddNegated(Vector256`1<double> a, Vector256`1<double> b, Vector256`1<double> c);
    public static Vector128`1<float> MultiplyAddNegatedScalar(Vector128`1<float> a, Vector128`1<float> b, Vector128`1<float> c);
    public static Vector128`1<double> MultiplyAddNegatedScalar(Vector128`1<double> a, Vector128`1<double> b, Vector128`1<double> c);
    public static Vector128`1<float> MultiplySubtractNegated(Vector128`1<float> a, Vector128`1<float> b, Vector128`1<float> c);
    public static Vector128`1<double> MultiplySubtractNegated(Vector128`1<double> a, Vector128`1<double> b, Vector128`1<double> c);
    public static Vector256`1<float> MultiplySubtractNegated(Vector256`1<float> a, Vector256`1<float> b, Vector256`1<float> c);
    public static Vector256`1<double> MultiplySubtractNegated(Vector256`1<double> a, Vector256`1<double> b, Vector256`1<double> c);
    public static Vector128`1<float> MultiplySubtractNegatedScalar(Vector128`1<float> a, Vector128`1<float> b, Vector128`1<float> c);
    public static Vector128`1<double> MultiplySubtractNegatedScalar(Vector128`1<double> a, Vector128`1<double> b, Vector128`1<double> c);
}
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public abstract class System.Runtime.Intrinsics.X86.Lzcnt : object {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static UInt32 LeadingZeroCount(UInt32 value);
}
[CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public abstract class System.Runtime.Intrinsics.X86.Pclmulqdq : Sse2 {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static Vector128`1<long> CarrylessMultiply(Vector128`1<long> left, Vector128`1<long> right, byte control);
    public static Vector128`1<ulong> CarrylessMultiply(Vector128`1<ulong> left, Vector128`1<ulong> right, byte control);
}
[CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public abstract class System.Runtime.Intrinsics.X86.Popcnt : Sse42 {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static UInt32 PopCount(UInt32 value);
}
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public abstract class System.Runtime.Intrinsics.X86.Sse : object {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static Vector128`1<float> Add(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> AddScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> And(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> AndNot(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static bool CompareScalarOrderedEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static bool CompareScalarUnorderedEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareScalarEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareGreaterThan(Vector128`1<float> left, Vector128`1<float> right);
    public static bool CompareScalarOrderedGreaterThan(Vector128`1<float> left, Vector128`1<float> right);
    public static bool CompareScalarUnorderedGreaterThan(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareScalarGreaterThan(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareGreaterThanOrEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static bool CompareScalarOrderedGreaterThanOrEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static bool CompareScalarUnorderedGreaterThanOrEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareScalarGreaterThanOrEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareLessThan(Vector128`1<float> left, Vector128`1<float> right);
    public static bool CompareScalarOrderedLessThan(Vector128`1<float> left, Vector128`1<float> right);
    public static bool CompareScalarUnorderedLessThan(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareScalarLessThan(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareLessThanOrEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static bool CompareScalarOrderedLessThanOrEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static bool CompareScalarUnorderedLessThanOrEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareScalarLessThanOrEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareNotEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static bool CompareScalarOrderedNotEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static bool CompareScalarUnorderedNotEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareScalarNotEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareNotGreaterThan(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareScalarNotGreaterThan(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareNotGreaterThanOrEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareScalarNotGreaterThanOrEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareNotLessThan(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareScalarNotLessThan(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareNotLessThanOrEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareScalarNotLessThanOrEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareOrdered(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareScalarOrdered(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareUnordered(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareScalarUnordered(Vector128`1<float> left, Vector128`1<float> right);
    public static int ConvertToInt32(Vector128`1<float> value);
    public static Vector128`1<float> ConvertScalarToVector128Single(Vector128`1<float> upper, int value);
    public static int ConvertToInt32WithTruncation(Vector128`1<float> value);
    public static Vector128`1<float> Divide(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> DivideScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> LoadVector128(Single* address);
    public static Vector128`1<float> LoadScalarVector128(Single* address);
    public static Vector128`1<float> LoadAlignedVector128(Single* address);
    public static Vector128`1<float> LoadHigh(Vector128`1<float> lower, Single* address);
    public static Vector128`1<float> LoadLow(Vector128`1<float> upper, Single* address);
    public static Vector128`1<float> Max(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> MaxScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> Min(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> MinScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> MoveScalar(Vector128`1<float> upper, Vector128`1<float> value);
    public static Vector128`1<float> MoveHighToLow(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> MoveLowToHigh(Vector128`1<float> left, Vector128`1<float> right);
    public static int MoveMask(Vector128`1<float> value);
    public static Vector128`1<float> Multiply(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> MultiplyScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> Or(Vector128`1<float> left, Vector128`1<float> right);
    public static void Prefetch0(Void* address);
    public static void Prefetch1(Void* address);
    public static void Prefetch2(Void* address);
    public static void PrefetchNonTemporal(Void* address);
    public static Vector128`1<float> Reciprocal(Vector128`1<float> value);
    public static Vector128`1<float> ReciprocalScalar(Vector128`1<float> value);
    public static Vector128`1<float> ReciprocalScalar(Vector128`1<float> upper, Vector128`1<float> value);
    public static Vector128`1<float> ReciprocalSqrt(Vector128`1<float> value);
    public static Vector128`1<float> ReciprocalSqrtScalar(Vector128`1<float> value);
    public static Vector128`1<float> ReciprocalSqrtScalar(Vector128`1<float> upper, Vector128`1<float> value);
    public static Vector128`1<float> Shuffle(Vector128`1<float> left, Vector128`1<float> right, byte control);
    public static Vector128`1<float> Sqrt(Vector128`1<float> value);
    public static Vector128`1<float> SqrtScalar(Vector128`1<float> value);
    public static Vector128`1<float> SqrtScalar(Vector128`1<float> upper, Vector128`1<float> value);
    public static void StoreAligned(Single* address, Vector128`1<float> source);
    public static void StoreAlignedNonTemporal(Single* address, Vector128`1<float> source);
    public static void Store(Single* address, Vector128`1<float> source);
    public static void StoreFence();
    public static void StoreScalar(Single* address, Vector128`1<float> source);
    public static void StoreHigh(Single* address, Vector128`1<float> source);
    public static void StoreLow(Single* address, Vector128`1<float> source);
    public static Vector128`1<float> Subtract(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> SubtractScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> UnpackHigh(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> UnpackLow(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> Xor(Vector128`1<float> left, Vector128`1<float> right);
}
[CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public abstract class System.Runtime.Intrinsics.X86.Sse2 : Sse {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static Vector128`1<byte> Add(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<sbyte> Add(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> Add(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> Add(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> Add(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> Add(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<long> Add(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<ulong> Add(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<double> Add(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> AddScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<sbyte> AddSaturate(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<byte> AddSaturate(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> AddSaturate(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> AddSaturate(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<byte> And(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<sbyte> And(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> And(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> And(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> And(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> And(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<long> And(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<ulong> And(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<double> And(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<byte> AndNot(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<sbyte> AndNot(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> AndNot(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> AndNot(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> AndNot(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> AndNot(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<long> AndNot(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<ulong> AndNot(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<double> AndNot(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<byte> Average(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<ushort> Average(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<sbyte> CompareEqual(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<byte> CompareEqual(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> CompareEqual(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> CompareEqual(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> CompareEqual(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> CompareEqual(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<double> CompareEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static bool CompareScalarOrderedEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static bool CompareScalarUnorderedEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareScalarEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<sbyte> CompareGreaterThan(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> CompareGreaterThan(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<int> CompareGreaterThan(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<double> CompareGreaterThan(Vector128`1<double> left, Vector128`1<double> right);
    public static bool CompareScalarOrderedGreaterThan(Vector128`1<double> left, Vector128`1<double> right);
    public static bool CompareScalarUnorderedGreaterThan(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareScalarGreaterThan(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareGreaterThanOrEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static bool CompareScalarOrderedGreaterThanOrEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static bool CompareScalarUnorderedGreaterThanOrEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareScalarGreaterThanOrEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<sbyte> CompareLessThan(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> CompareLessThan(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<int> CompareLessThan(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<double> CompareLessThan(Vector128`1<double> left, Vector128`1<double> right);
    public static bool CompareScalarOrderedLessThan(Vector128`1<double> left, Vector128`1<double> right);
    public static bool CompareScalarUnorderedLessThan(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareScalarLessThan(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareLessThanOrEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static bool CompareScalarOrderedLessThanOrEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static bool CompareScalarUnorderedLessThanOrEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareScalarLessThanOrEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareNotEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static bool CompareScalarOrderedNotEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static bool CompareScalarUnorderedNotEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareScalarNotEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareNotGreaterThan(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareScalarNotGreaterThan(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareNotGreaterThanOrEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareScalarNotGreaterThanOrEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareNotLessThan(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareScalarNotLessThan(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareNotLessThanOrEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareScalarNotLessThanOrEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareOrdered(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareScalarOrdered(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareUnordered(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareScalarUnordered(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<int> ConvertToVector128Int32(Vector128`1<float> value);
    public static Vector128`1<int> ConvertToVector128Int32(Vector128`1<double> value);
    public static Vector128`1<float> ConvertToVector128Single(Vector128`1<int> value);
    public static Vector128`1<float> ConvertToVector128Single(Vector128`1<double> value);
    public static Vector128`1<double> ConvertToVector128Double(Vector128`1<int> value);
    public static Vector128`1<double> ConvertToVector128Double(Vector128`1<float> value);
    public static int ConvertToInt32(Vector128`1<double> value);
    public static int ConvertToInt32(Vector128`1<int> value);
    public static UInt32 ConvertToUInt32(Vector128`1<UInt32> value);
    public static Vector128`1<double> ConvertScalarToVector128Double(Vector128`1<double> upper, int value);
    public static Vector128`1<double> ConvertScalarToVector128Double(Vector128`1<double> upper, Vector128`1<float> value);
    public static Vector128`1<int> ConvertScalarToVector128Int32(int value);
    public static Vector128`1<float> ConvertScalarToVector128Single(Vector128`1<float> upper, Vector128`1<double> value);
    public static Vector128`1<UInt32> ConvertScalarToVector128UInt32(UInt32 value);
    public static Vector128`1<int> ConvertToVector128Int32WithTruncation(Vector128`1<float> value);
    public static Vector128`1<int> ConvertToVector128Int32WithTruncation(Vector128`1<double> value);
    public static int ConvertToInt32WithTruncation(Vector128`1<double> value);
    public static Vector128`1<double> Divide(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> DivideScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static ushort Extract(Vector128`1<ushort> value, byte index);
    public static Vector128`1<short> Insert(Vector128`1<short> value, short data, byte index);
    public static Vector128`1<ushort> Insert(Vector128`1<ushort> value, ushort data, byte index);
    public static Vector128`1<sbyte> LoadVector128(SByte* address);
    public static Vector128`1<byte> LoadVector128(Byte* address);
    public static Vector128`1<short> LoadVector128(Int16* address);
    public static Vector128`1<ushort> LoadVector128(UInt16* address);
    public static Vector128`1<int> LoadVector128(Int32* address);
    public static Vector128`1<UInt32> LoadVector128(UInt32* address);
    public static Vector128`1<long> LoadVector128(Int64* address);
    public static Vector128`1<ulong> LoadVector128(UInt64* address);
    public static Vector128`1<double> LoadVector128(Double* address);
    public static Vector128`1<double> LoadScalarVector128(Double* address);
    public static Vector128`1<sbyte> LoadAlignedVector128(SByte* address);
    public static Vector128`1<byte> LoadAlignedVector128(Byte* address);
    public static Vector128`1<short> LoadAlignedVector128(Int16* address);
    public static Vector128`1<ushort> LoadAlignedVector128(UInt16* address);
    public static Vector128`1<int> LoadAlignedVector128(Int32* address);
    public static Vector128`1<UInt32> LoadAlignedVector128(UInt32* address);
    public static Vector128`1<long> LoadAlignedVector128(Int64* address);
    public static Vector128`1<ulong> LoadAlignedVector128(UInt64* address);
    public static Vector128`1<double> LoadAlignedVector128(Double* address);
    public static void LoadFence();
    public static Vector128`1<double> LoadHigh(Vector128`1<double> lower, Double* address);
    public static Vector128`1<double> LoadLow(Vector128`1<double> upper, Double* address);
    public static Vector128`1<int> LoadScalarVector128(Int32* address);
    public static Vector128`1<UInt32> LoadScalarVector128(UInt32* address);
    public static Vector128`1<long> LoadScalarVector128(Int64* address);
    public static Vector128`1<ulong> LoadScalarVector128(UInt64* address);
    public static void MaskMove(Vector128`1<sbyte> source, Vector128`1<sbyte> mask, SByte* address);
    public static void MaskMove(Vector128`1<byte> source, Vector128`1<byte> mask, Byte* address);
    public static Vector128`1<byte> Max(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> Max(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<double> Max(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> MaxScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static void MemoryFence();
    public static Vector128`1<byte> Min(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> Min(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<double> Min(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> MinScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> MoveScalar(Vector128`1<double> upper, Vector128`1<double> value);
    public static int MoveMask(Vector128`1<sbyte> value);
    public static int MoveMask(Vector128`1<byte> value);
    public static int MoveMask(Vector128`1<double> value);
    public static Vector128`1<long> MoveScalar(Vector128`1<long> value);
    public static Vector128`1<ulong> MoveScalar(Vector128`1<ulong> value);
    public static Vector128`1<ulong> Multiply(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<double> Multiply(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> MultiplyScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<short> MultiplyHigh(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> MultiplyHigh(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> MultiplyAddAdjacent(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<short> MultiplyLow(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> MultiplyLow(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<byte> Or(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<sbyte> Or(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> Or(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> Or(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> Or(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> Or(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<long> Or(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<ulong> Or(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<double> Or(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<sbyte> PackSignedSaturate(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<short> PackSignedSaturate(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<byte> PackUnsignedSaturate(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> SumAbsoluteDifferences(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<int> Shuffle(Vector128`1<int> value, byte control);
    public static Vector128`1<UInt32> Shuffle(Vector128`1<UInt32> value, byte control);
    public static Vector128`1<double> Shuffle(Vector128`1<double> left, Vector128`1<double> right, byte control);
    public static Vector128`1<short> ShuffleHigh(Vector128`1<short> value, byte control);
    public static Vector128`1<ushort> ShuffleHigh(Vector128`1<ushort> value, byte control);
    public static Vector128`1<short> ShuffleLow(Vector128`1<short> value, byte control);
    public static Vector128`1<ushort> ShuffleLow(Vector128`1<ushort> value, byte control);
    public static Vector128`1<short> ShiftLeftLogical(Vector128`1<short> value, Vector128`1<short> count);
    public static Vector128`1<ushort> ShiftLeftLogical(Vector128`1<ushort> value, Vector128`1<ushort> count);
    public static Vector128`1<int> ShiftLeftLogical(Vector128`1<int> value, Vector128`1<int> count);
    public static Vector128`1<UInt32> ShiftLeftLogical(Vector128`1<UInt32> value, Vector128`1<UInt32> count);
    public static Vector128`1<long> ShiftLeftLogical(Vector128`1<long> value, Vector128`1<long> count);
    public static Vector128`1<ulong> ShiftLeftLogical(Vector128`1<ulong> value, Vector128`1<ulong> count);
    public static Vector128`1<short> ShiftLeftLogical(Vector128`1<short> value, byte count);
    public static Vector128`1<ushort> ShiftLeftLogical(Vector128`1<ushort> value, byte count);
    public static Vector128`1<int> ShiftLeftLogical(Vector128`1<int> value, byte count);
    public static Vector128`1<UInt32> ShiftLeftLogical(Vector128`1<UInt32> value, byte count);
    public static Vector128`1<long> ShiftLeftLogical(Vector128`1<long> value, byte count);
    public static Vector128`1<ulong> ShiftLeftLogical(Vector128`1<ulong> value, byte count);
    public static Vector128`1<sbyte> ShiftLeftLogical128BitLane(Vector128`1<sbyte> value, byte numBytes);
    public static Vector128`1<byte> ShiftLeftLogical128BitLane(Vector128`1<byte> value, byte numBytes);
    public static Vector128`1<short> ShiftLeftLogical128BitLane(Vector128`1<short> value, byte numBytes);
    public static Vector128`1<ushort> ShiftLeftLogical128BitLane(Vector128`1<ushort> value, byte numBytes);
    public static Vector128`1<int> ShiftLeftLogical128BitLane(Vector128`1<int> value, byte numBytes);
    public static Vector128`1<UInt32> ShiftLeftLogical128BitLane(Vector128`1<UInt32> value, byte numBytes);
    public static Vector128`1<long> ShiftLeftLogical128BitLane(Vector128`1<long> value, byte numBytes);
    public static Vector128`1<ulong> ShiftLeftLogical128BitLane(Vector128`1<ulong> value, byte numBytes);
    public static Vector128`1<short> ShiftRightArithmetic(Vector128`1<short> value, Vector128`1<short> count);
    public static Vector128`1<int> ShiftRightArithmetic(Vector128`1<int> value, Vector128`1<int> count);
    public static Vector128`1<short> ShiftRightArithmetic(Vector128`1<short> value, byte count);
    public static Vector128`1<int> ShiftRightArithmetic(Vector128`1<int> value, byte count);
    public static Vector128`1<short> ShiftRightLogical(Vector128`1<short> value, Vector128`1<short> count);
    public static Vector128`1<ushort> ShiftRightLogical(Vector128`1<ushort> value, Vector128`1<ushort> count);
    public static Vector128`1<int> ShiftRightLogical(Vector128`1<int> value, Vector128`1<int> count);
    public static Vector128`1<UInt32> ShiftRightLogical(Vector128`1<UInt32> value, Vector128`1<UInt32> count);
    public static Vector128`1<long> ShiftRightLogical(Vector128`1<long> value, Vector128`1<long> count);
    public static Vector128`1<ulong> ShiftRightLogical(Vector128`1<ulong> value, Vector128`1<ulong> count);
    public static Vector128`1<short> ShiftRightLogical(Vector128`1<short> value, byte count);
    public static Vector128`1<ushort> ShiftRightLogical(Vector128`1<ushort> value, byte count);
    public static Vector128`1<int> ShiftRightLogical(Vector128`1<int> value, byte count);
    public static Vector128`1<UInt32> ShiftRightLogical(Vector128`1<UInt32> value, byte count);
    public static Vector128`1<long> ShiftRightLogical(Vector128`1<long> value, byte count);
    public static Vector128`1<ulong> ShiftRightLogical(Vector128`1<ulong> value, byte count);
    public static Vector128`1<sbyte> ShiftRightLogical128BitLane(Vector128`1<sbyte> value, byte numBytes);
    public static Vector128`1<byte> ShiftRightLogical128BitLane(Vector128`1<byte> value, byte numBytes);
    public static Vector128`1<short> ShiftRightLogical128BitLane(Vector128`1<short> value, byte numBytes);
    public static Vector128`1<ushort> ShiftRightLogical128BitLane(Vector128`1<ushort> value, byte numBytes);
    public static Vector128`1<int> ShiftRightLogical128BitLane(Vector128`1<int> value, byte numBytes);
    public static Vector128`1<UInt32> ShiftRightLogical128BitLane(Vector128`1<UInt32> value, byte numBytes);
    public static Vector128`1<long> ShiftRightLogical128BitLane(Vector128`1<long> value, byte numBytes);
    public static Vector128`1<ulong> ShiftRightLogical128BitLane(Vector128`1<ulong> value, byte numBytes);
    public static Vector128`1<double> Sqrt(Vector128`1<double> value);
    public static Vector128`1<double> SqrtScalar(Vector128`1<double> value);
    public static Vector128`1<double> SqrtScalar(Vector128`1<double> upper, Vector128`1<double> value);
    public static void StoreScalar(Double* address, Vector128`1<double> source);
    public static void StoreScalar(Int64* address, Vector128`1<long> source);
    public static void StoreScalar(UInt64* address, Vector128`1<ulong> source);
    public static void StoreAligned(SByte* address, Vector128`1<sbyte> source);
    public static void StoreAligned(Byte* address, Vector128`1<byte> source);
    public static void StoreAligned(Int16* address, Vector128`1<short> source);
    public static void StoreAligned(UInt16* address, Vector128`1<ushort> source);
    public static void StoreAligned(Int32* address, Vector128`1<int> source);
    public static void StoreAligned(UInt32* address, Vector128`1<UInt32> source);
    public static void StoreAligned(Int64* address, Vector128`1<long> source);
    public static void StoreAligned(UInt64* address, Vector128`1<ulong> source);
    public static void StoreAligned(Double* address, Vector128`1<double> source);
    public static void StoreAlignedNonTemporal(SByte* address, Vector128`1<sbyte> source);
    public static void StoreAlignedNonTemporal(Byte* address, Vector128`1<byte> source);
    public static void StoreAlignedNonTemporal(Int16* address, Vector128`1<short> source);
    public static void StoreAlignedNonTemporal(UInt16* address, Vector128`1<ushort> source);
    public static void StoreAlignedNonTemporal(Int32* address, Vector128`1<int> source);
    public static void StoreAlignedNonTemporal(UInt32* address, Vector128`1<UInt32> source);
    public static void StoreAlignedNonTemporal(Int64* address, Vector128`1<long> source);
    public static void StoreAlignedNonTemporal(UInt64* address, Vector128`1<ulong> source);
    public static void StoreAlignedNonTemporal(Double* address, Vector128`1<double> source);
    public static void Store(SByte* address, Vector128`1<sbyte> source);
    public static void Store(Byte* address, Vector128`1<byte> source);
    public static void Store(Int16* address, Vector128`1<short> source);
    public static void Store(UInt16* address, Vector128`1<ushort> source);
    public static void Store(Int32* address, Vector128`1<int> source);
    public static void Store(UInt32* address, Vector128`1<UInt32> source);
    public static void Store(Int64* address, Vector128`1<long> source);
    public static void Store(UInt64* address, Vector128`1<ulong> source);
    public static void Store(Double* address, Vector128`1<double> source);
    public static void StoreHigh(Double* address, Vector128`1<double> source);
    public static void StoreLow(Double* address, Vector128`1<double> source);
    public static void StoreNonTemporal(Int32* address, int value);
    public static void StoreNonTemporal(UInt32* address, UInt32 value);
    public static Vector128`1<byte> Subtract(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<sbyte> Subtract(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> Subtract(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> Subtract(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> Subtract(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> Subtract(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<long> Subtract(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<ulong> Subtract(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<double> Subtract(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> SubtractScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<sbyte> SubtractSaturate(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> SubtractSaturate(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<byte> SubtractSaturate(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<ushort> SubtractSaturate(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<byte> UnpackHigh(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<sbyte> UnpackHigh(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> UnpackHigh(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> UnpackHigh(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> UnpackHigh(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> UnpackHigh(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<long> UnpackHigh(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<ulong> UnpackHigh(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<double> UnpackHigh(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<byte> UnpackLow(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<sbyte> UnpackLow(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> UnpackLow(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> UnpackLow(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> UnpackLow(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> UnpackLow(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<long> UnpackLow(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<ulong> UnpackLow(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<double> UnpackLow(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<byte> Xor(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<sbyte> Xor(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> Xor(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> Xor(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> Xor(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> Xor(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<long> Xor(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<ulong> Xor(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<double> Xor(Vector128`1<double> left, Vector128`1<double> right);
}
[CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public abstract class System.Runtime.Intrinsics.X86.Sse3 : Sse2 {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static Vector128`1<float> AddSubtract(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<double> AddSubtract(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<float> HorizontalAdd(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<double> HorizontalAdd(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<float> HorizontalSubtract(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<double> HorizontalSubtract(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> LoadAndDuplicateToVector128(Double* address);
    public static Vector128`1<sbyte> LoadDquVector128(SByte* address);
    public static Vector128`1<byte> LoadDquVector128(Byte* address);
    public static Vector128`1<short> LoadDquVector128(Int16* address);
    public static Vector128`1<ushort> LoadDquVector128(UInt16* address);
    public static Vector128`1<int> LoadDquVector128(Int32* address);
    public static Vector128`1<UInt32> LoadDquVector128(UInt32* address);
    public static Vector128`1<long> LoadDquVector128(Int64* address);
    public static Vector128`1<ulong> LoadDquVector128(UInt64* address);
    public static Vector128`1<double> MoveAndDuplicate(Vector128`1<double> source);
    public static Vector128`1<float> MoveHighAndDuplicate(Vector128`1<float> source);
    public static Vector128`1<float> MoveLowAndDuplicate(Vector128`1<float> source);
}
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public abstract class System.Runtime.Intrinsics.X86.Sse41 : Ssse3 {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static Vector128`1<short> Blend(Vector128`1<short> left, Vector128`1<short> right, byte control);
    public static Vector128`1<ushort> Blend(Vector128`1<ushort> left, Vector128`1<ushort> right, byte control);
    public static Vector128`1<float> Blend(Vector128`1<float> left, Vector128`1<float> right, byte control);
    public static Vector128`1<double> Blend(Vector128`1<double> left, Vector128`1<double> right, byte control);
    public static Vector128`1<sbyte> BlendVariable(Vector128`1<sbyte> left, Vector128`1<sbyte> right, Vector128`1<sbyte> mask);
    public static Vector128`1<byte> BlendVariable(Vector128`1<byte> left, Vector128`1<byte> right, Vector128`1<byte> mask);
    public static Vector128`1<short> BlendVariable(Vector128`1<short> left, Vector128`1<short> right, Vector128`1<short> mask);
    public static Vector128`1<ushort> BlendVariable(Vector128`1<ushort> left, Vector128`1<ushort> right, Vector128`1<ushort> mask);
    public static Vector128`1<int> BlendVariable(Vector128`1<int> left, Vector128`1<int> right, Vector128`1<int> mask);
    public static Vector128`1<UInt32> BlendVariable(Vector128`1<UInt32> left, Vector128`1<UInt32> right, Vector128`1<UInt32> mask);
    public static Vector128`1<long> BlendVariable(Vector128`1<long> left, Vector128`1<long> right, Vector128`1<long> mask);
    public static Vector128`1<ulong> BlendVariable(Vector128`1<ulong> left, Vector128`1<ulong> right, Vector128`1<ulong> mask);
    public static Vector128`1<float> BlendVariable(Vector128`1<float> left, Vector128`1<float> right, Vector128`1<float> mask);
    public static Vector128`1<double> BlendVariable(Vector128`1<double> left, Vector128`1<double> right, Vector128`1<double> mask);
    public static Vector128`1<float> Ceiling(Vector128`1<float> value);
    public static Vector128`1<double> Ceiling(Vector128`1<double> value);
    public static Vector128`1<double> CeilingScalar(Vector128`1<double> value);
    public static Vector128`1<float> CeilingScalar(Vector128`1<float> value);
    public static Vector128`1<double> CeilingScalar(Vector128`1<double> upper, Vector128`1<double> value);
    public static Vector128`1<float> CeilingScalar(Vector128`1<float> upper, Vector128`1<float> value);
    public static Vector128`1<long> CompareEqual(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<ulong> CompareEqual(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<short> ConvertToVector128Int16(Vector128`1<sbyte> value);
    public static Vector128`1<short> ConvertToVector128Int16(Vector128`1<byte> value);
    public static Vector128`1<int> ConvertToVector128Int32(Vector128`1<sbyte> value);
    public static Vector128`1<int> ConvertToVector128Int32(Vector128`1<byte> value);
    public static Vector128`1<int> ConvertToVector128Int32(Vector128`1<short> value);
    public static Vector128`1<int> ConvertToVector128Int32(Vector128`1<ushort> value);
    public static Vector128`1<long> ConvertToVector128Int64(Vector128`1<sbyte> value);
    public static Vector128`1<long> ConvertToVector128Int64(Vector128`1<byte> value);
    public static Vector128`1<long> ConvertToVector128Int64(Vector128`1<short> value);
    public static Vector128`1<long> ConvertToVector128Int64(Vector128`1<ushort> value);
    public static Vector128`1<long> ConvertToVector128Int64(Vector128`1<int> value);
    public static Vector128`1<long> ConvertToVector128Int64(Vector128`1<UInt32> value);
    public static Vector128`1<short> ConvertToVector128Int16(SByte* address);
    public static Vector128`1<short> ConvertToVector128Int16(Byte* address);
    public static Vector128`1<int> ConvertToVector128Int32(SByte* address);
    public static Vector128`1<int> ConvertToVector128Int32(Byte* address);
    public static Vector128`1<int> ConvertToVector128Int32(Int16* address);
    public static Vector128`1<int> ConvertToVector128Int32(UInt16* address);
    public static Vector128`1<long> ConvertToVector128Int64(SByte* address);
    public static Vector128`1<long> ConvertToVector128Int64(Byte* address);
    public static Vector128`1<long> ConvertToVector128Int64(Int16* address);
    public static Vector128`1<long> ConvertToVector128Int64(UInt16* address);
    public static Vector128`1<long> ConvertToVector128Int64(Int32* address);
    public static Vector128`1<long> ConvertToVector128Int64(UInt32* address);
    public static Vector128`1<float> DotProduct(Vector128`1<float> left, Vector128`1<float> right, byte control);
    public static Vector128`1<double> DotProduct(Vector128`1<double> left, Vector128`1<double> right, byte control);
    public static byte Extract(Vector128`1<byte> value, byte index);
    public static int Extract(Vector128`1<int> value, byte index);
    public static UInt32 Extract(Vector128`1<UInt32> value, byte index);
    public static float Extract(Vector128`1<float> value, byte index);
    public static Vector128`1<float> Floor(Vector128`1<float> value);
    public static Vector128`1<double> Floor(Vector128`1<double> value);
    public static Vector128`1<double> FloorScalar(Vector128`1<double> value);
    public static Vector128`1<float> FloorScalar(Vector128`1<float> value);
    public static Vector128`1<double> FloorScalar(Vector128`1<double> upper, Vector128`1<double> value);
    public static Vector128`1<float> FloorScalar(Vector128`1<float> upper, Vector128`1<float> value);
    public static Vector128`1<sbyte> Insert(Vector128`1<sbyte> value, sbyte data, byte index);
    public static Vector128`1<byte> Insert(Vector128`1<byte> value, byte data, byte index);
    public static Vector128`1<int> Insert(Vector128`1<int> value, int data, byte index);
    public static Vector128`1<UInt32> Insert(Vector128`1<UInt32> value, UInt32 data, byte index);
    public static Vector128`1<float> Insert(Vector128`1<float> value, Vector128`1<float> data, byte index);
    public static Vector128`1<sbyte> Max(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<ushort> Max(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> Max(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> Max(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<sbyte> Min(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<ushort> Min(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> Min(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> Min(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<ushort> MinHorizontal(Vector128`1<ushort> value);
    public static Vector128`1<ushort> MultipleSumAbsoluteDifferences(Vector128`1<byte> left, Vector128`1<byte> right, byte mask);
    public static Vector128`1<long> Multiply(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<int> MultiplyLow(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> MultiplyLow(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<ushort> PackUnsignedSaturate(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<float> RoundToNearestInteger(Vector128`1<float> value);
    public static Vector128`1<float> RoundToNegativeInfinity(Vector128`1<float> value);
    public static Vector128`1<float> RoundToPositiveInfinity(Vector128`1<float> value);
    public static Vector128`1<float> RoundToZero(Vector128`1<float> value);
    public static Vector128`1<float> RoundCurrentDirection(Vector128`1<float> value);
    public static Vector128`1<double> RoundToNearestInteger(Vector128`1<double> value);
    public static Vector128`1<double> RoundToNegativeInfinity(Vector128`1<double> value);
    public static Vector128`1<double> RoundToPositiveInfinity(Vector128`1<double> value);
    public static Vector128`1<double> RoundToZero(Vector128`1<double> value);
    public static Vector128`1<double> RoundCurrentDirection(Vector128`1<double> value);
    public static Vector128`1<double> RoundCurrentDirectionScalar(Vector128`1<double> value);
    public static Vector128`1<double> RoundToNearestIntegerScalar(Vector128`1<double> value);
    public static Vector128`1<double> RoundToNegativeInfinityScalar(Vector128`1<double> value);
    public static Vector128`1<double> RoundToPositiveInfinityScalar(Vector128`1<double> value);
    public static Vector128`1<double> RoundToZeroScalar(Vector128`1<double> value);
    public static Vector128`1<double> RoundCurrentDirectionScalar(Vector128`1<double> upper, Vector128`1<double> value);
    public static Vector128`1<double> RoundToNearestIntegerScalar(Vector128`1<double> upper, Vector128`1<double> value);
    public static Vector128`1<double> RoundToNegativeInfinityScalar(Vector128`1<double> upper, Vector128`1<double> value);
    public static Vector128`1<double> RoundToPositiveInfinityScalar(Vector128`1<double> upper, Vector128`1<double> value);
    public static Vector128`1<double> RoundToZeroScalar(Vector128`1<double> upper, Vector128`1<double> value);
    public static Vector128`1<float> RoundCurrentDirectionScalar(Vector128`1<float> value);
    public static Vector128`1<float> RoundToNearestIntegerScalar(Vector128`1<float> value);
    public static Vector128`1<float> RoundToNegativeInfinityScalar(Vector128`1<float> value);
    public static Vector128`1<float> RoundToPositiveInfinityScalar(Vector128`1<float> value);
    public static Vector128`1<float> RoundToZeroScalar(Vector128`1<float> value);
    public static Vector128`1<float> RoundCurrentDirectionScalar(Vector128`1<float> upper, Vector128`1<float> value);
    public static Vector128`1<float> RoundToNearestIntegerScalar(Vector128`1<float> upper, Vector128`1<float> value);
    public static Vector128`1<float> RoundToNegativeInfinityScalar(Vector128`1<float> upper, Vector128`1<float> value);
    public static Vector128`1<float> RoundToPositiveInfinityScalar(Vector128`1<float> upper, Vector128`1<float> value);
    public static Vector128`1<float> RoundToZeroScalar(Vector128`1<float> upper, Vector128`1<float> value);
    public static Vector128`1<sbyte> LoadAlignedVector128NonTemporal(SByte* address);
    public static Vector128`1<byte> LoadAlignedVector128NonTemporal(Byte* address);
    public static Vector128`1<short> LoadAlignedVector128NonTemporal(Int16* address);
    public static Vector128`1<ushort> LoadAlignedVector128NonTemporal(UInt16* address);
    public static Vector128`1<int> LoadAlignedVector128NonTemporal(Int32* address);
    public static Vector128`1<UInt32> LoadAlignedVector128NonTemporal(UInt32* address);
    public static Vector128`1<long> LoadAlignedVector128NonTemporal(Int64* address);
    public static Vector128`1<ulong> LoadAlignedVector128NonTemporal(UInt64* address);
    public static bool TestC(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static bool TestC(Vector128`1<byte> left, Vector128`1<byte> right);
    public static bool TestC(Vector128`1<short> left, Vector128`1<short> right);
    public static bool TestC(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static bool TestC(Vector128`1<int> left, Vector128`1<int> right);
    public static bool TestC(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static bool TestC(Vector128`1<long> left, Vector128`1<long> right);
    public static bool TestC(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static bool TestNotZAndNotC(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static bool TestNotZAndNotC(Vector128`1<byte> left, Vector128`1<byte> right);
    public static bool TestNotZAndNotC(Vector128`1<short> left, Vector128`1<short> right);
    public static bool TestNotZAndNotC(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static bool TestNotZAndNotC(Vector128`1<int> left, Vector128`1<int> right);
    public static bool TestNotZAndNotC(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static bool TestNotZAndNotC(Vector128`1<long> left, Vector128`1<long> right);
    public static bool TestNotZAndNotC(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static bool TestZ(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static bool TestZ(Vector128`1<byte> left, Vector128`1<byte> right);
    public static bool TestZ(Vector128`1<short> left, Vector128`1<short> right);
    public static bool TestZ(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static bool TestZ(Vector128`1<int> left, Vector128`1<int> right);
    public static bool TestZ(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static bool TestZ(Vector128`1<long> left, Vector128`1<long> right);
    public static bool TestZ(Vector128`1<ulong> left, Vector128`1<ulong> right);
}
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public abstract class System.Runtime.Intrinsics.X86.Sse42 : Sse41 {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static Vector128`1<long> CompareGreaterThan(Vector128`1<long> left, Vector128`1<long> right);
    public static UInt32 Crc32(UInt32 crc, byte data);
    public static UInt32 Crc32(UInt32 crc, ushort data);
    public static UInt32 Crc32(UInt32 crc, UInt32 data);
}
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public abstract class System.Runtime.Intrinsics.X86.Ssse3 : Sse3 {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static Vector128`1<byte> Abs(Vector128`1<sbyte> value);
    public static Vector128`1<ushort> Abs(Vector128`1<short> value);
    public static Vector128`1<UInt32> Abs(Vector128`1<int> value);
    public static Vector128`1<sbyte> AlignRight(Vector128`1<sbyte> left, Vector128`1<sbyte> right, byte mask);
    public static Vector128`1<byte> AlignRight(Vector128`1<byte> left, Vector128`1<byte> right, byte mask);
    public static Vector128`1<short> AlignRight(Vector128`1<short> left, Vector128`1<short> right, byte mask);
    public static Vector128`1<ushort> AlignRight(Vector128`1<ushort> left, Vector128`1<ushort> right, byte mask);
    public static Vector128`1<int> AlignRight(Vector128`1<int> left, Vector128`1<int> right, byte mask);
    public static Vector128`1<UInt32> AlignRight(Vector128`1<UInt32> left, Vector128`1<UInt32> right, byte mask);
    public static Vector128`1<long> AlignRight(Vector128`1<long> left, Vector128`1<long> right, byte mask);
    public static Vector128`1<ulong> AlignRight(Vector128`1<ulong> left, Vector128`1<ulong> right, byte mask);
    public static Vector128`1<short> HorizontalAdd(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<int> HorizontalAdd(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<short> HorizontalAddSaturate(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<short> HorizontalSubtract(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<int> HorizontalSubtract(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<short> HorizontalSubtractSaturate(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<short> MultiplyAddAdjacent(Vector128`1<byte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> MultiplyHighRoundScale(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<sbyte> Shuffle(Vector128`1<sbyte> value, Vector128`1<sbyte> mask);
    public static Vector128`1<byte> Shuffle(Vector128`1<byte> value, Vector128`1<byte> mask);
    public static Vector128`1<sbyte> Sign(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> Sign(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<int> Sign(Vector128`1<int> left, Vector128`1<int> right);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Runtime.Loader.AssemblyDependencyResolver : object {
    private Dictionary`2<string, string> _assemblyPaths;
    private String[] _nativeSearchPaths;
    private String[] _resourceSearchPaths;
    private String[] _assemblyDirectorySearchPaths;
    public AssemblyDependencyResolver(string componentAssemblyPath);
    public string ResolveAssemblyToPath(AssemblyName assemblyName);
    public string ResolveUnmanagedDllToPath(string unmanagedDllName);
    private static String[] SplitPathsList(string pathsList);
    private static int corehost_resolve_component_dependencies(string component_main_assembly_path, corehost_resolve_component_dependencies_result_fn result);
    private static IntPtr corehost_set_error_writer(IntPtr error_writer);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Runtime.Loader.AssemblyLoadContext : object {
    private static Dictionary`2<long, WeakReference`1<AssemblyLoadContext>> s_allContexts;
    private static long s_nextId;
    private object _unloadLock;
    [CompilerGeneratedAttribute]
private Func`3<Assembly, string, IntPtr> _resolvingUnmanagedDll;
    [CompilerGeneratedAttribute]
private Func`3<AssemblyLoadContext, AssemblyName, Assembly> _resolving;
    [CompilerGeneratedAttribute]
private Action`1<AssemblyLoadContext> _unloading;
    private string _name;
    private IntPtr _nativeAssemblyLoadContext;
    private long _id;
    private InternalState _state;
    private bool _isCollectible;
    [CompilerGeneratedAttribute]
private static AssemblyLoadEventHandler AssemblyLoad;
    [CompilerGeneratedAttribute]
private static ResolveEventHandler TypeResolve;
    [CompilerGeneratedAttribute]
private static ResolveEventHandler ResourceResolve;
    [CompilerGeneratedAttribute]
private static ResolveEventHandler AssemblyResolve;
    private static AsyncLocal`1<AssemblyLoadContext> s_asyncLocalCurrent;
    public IEnumerable`1<Assembly> Assemblies { get; }
    public static AssemblyLoadContext Default { get; }
    public bool IsCollectible { get; }
    [NullableAttribute("2")]
public string Name { get; }
    public static IEnumerable`1<AssemblyLoadContext> All { get; }
    [NullableAttribute("2")]
public static AssemblyLoadContext CurrentContextualReflectionContext { get; }
    protected AssemblyLoadContext(bool isCollectible);
    [NullableContextAttribute("2")]
public AssemblyLoadContext(string name, bool isCollectible);
    private protected AssemblyLoadContext(bool representsTPALoadContext, bool isCollectible, string name);
    private static AssemblyLoadContext();
    private static IntPtr InitializeAssemblyLoadContext(IntPtr ptrAssemblyLoadContext, bool fRepresentsTPALoadContext, bool isCollectible);
    private static void PrepareForAssemblyLoadContextRelease(IntPtr ptrNativeAssemblyLoadContext, IntPtr ptrAssemblyLoadContextStrong);
    private static IntPtr LoadFromStream(IntPtr ptrNativeAssemblyLoadContext, IntPtr ptrAssemblyArray, int iAssemblyArrayLen, IntPtr ptrSymbols, int iSymbolArrayLen, ObjectHandleOnStack retAssembly);
    internal static void InternalSetProfileRoot(string directoryPath);
    internal static void InternalStartProfile(string profile, IntPtr ptrNativeAssemblyLoadContext);
    private static void LoadFromPath(IntPtr ptrNativeAssemblyLoadContext, string ilPath, string niPath, ObjectHandleOnStack retAssembly);
    internal static Assembly[] GetLoadedAssemblies();
    private Assembly InternalLoadFromPath(string assemblyPath, string nativeImagePath);
    internal Assembly InternalLoad(ReadOnlySpan`1<byte> arrAssembly, ReadOnlySpan`1<byte> arrSymbols);
    private static IntPtr LoadFromInMemoryModuleInternal(IntPtr ptrNativeAssemblyLoadContext, IntPtr hModule, ObjectHandleOnStack retAssembly);
    internal Assembly LoadFromInMemoryModule(IntPtr moduleHandle);
    private static Assembly Resolve(IntPtr gchManagedAssemblyLoadContext, AssemblyName assemblyName);
    private static Assembly ResolveUsingResolvingEvent(IntPtr gchManagedAssemblyLoadContext, AssemblyName assemblyName);
    private static Assembly ResolveSatelliteAssembly(IntPtr gchManagedAssemblyLoadContext, AssemblyName assemblyName);
    private Assembly GetFirstResolvedAssembly(AssemblyName assemblyName);
    private Assembly ValidateAssemblyNameWithSimpleName(Assembly assembly, string requestedSimpleName);
    private Assembly ResolveUsingLoad(AssemblyName assemblyName);
    private Assembly ResolveUsingEvent(AssemblyName assemblyName);
    private static IntPtr InternalLoadUnmanagedDllFromPath(string unmanagedDllPath);
    private static IntPtr ResolveUnmanagedDll(string unmanagedDllName, IntPtr gchManagedAssemblyLoadContext);
    private static IntPtr ResolveUnmanagedDllUsingEvent(string unmanagedDllName, Assembly assembly, IntPtr gchManagedAssemblyLoadContext);
    private IntPtr GetResolvedUnmanagedDll(Assembly assembly, string unmanagedDllName);
    private static void LoadTypeForWinRTTypeNameInContextInternal(IntPtr ptrNativeAssemblyLoadContext, string typeName, ObjectHandleOnStack loadedType);
    internal Type LoadTypeForWinRTTypeNameInContext(string typeName);
    private static IntPtr GetLoadContextForAssembly(QCallAssembly assembly);
    public static AssemblyLoadContext GetLoadContext(Assembly assembly);
    public void SetProfileOptimizationRoot(string directoryPath);
    public void StartProfileOptimization(string profile);
    private static void OnAssemblyLoad(RuntimeAssembly assembly);
    private static RuntimeAssembly OnResourceResolve(RuntimeAssembly assembly, string resourceName);
    private static RuntimeAssembly OnTypeResolve(RuntimeAssembly assembly, string typeName);
    private static RuntimeAssembly OnAssemblyResolve(RuntimeAssembly assembly, string assemblyFullName);
    private static RuntimeAssembly InvokeResolveEvent(ResolveEventHandler eventHandler, RuntimeAssembly assembly, string name);
    private static RuntimeAssembly GetRuntimeAssembly(Assembly asm);
    [CompilerGeneratedAttribute]
private void add__resolvingUnmanagedDll(Func`3<Assembly, string, IntPtr> value);
    [CompilerGeneratedAttribute]
private void remove__resolvingUnmanagedDll(Func`3<Assembly, string, IntPtr> value);
    [CompilerGeneratedAttribute]
private void add__resolving(Func`3<AssemblyLoadContext, AssemblyName, Assembly> value);
    [CompilerGeneratedAttribute]
private void remove__resolving(Func`3<AssemblyLoadContext, AssemblyName, Assembly> value);
    [CompilerGeneratedAttribute]
private void add__unloading(Action`1<AssemblyLoadContext> value);
    [CompilerGeneratedAttribute]
private void remove__unloading(Action`1<AssemblyLoadContext> value);
    protected virtual override void Finalize();
    private void RaiseUnloadEvent();
    private void InitiateUnload();
    [IteratorStateMachineAttribute("System.Runtime.Loader.AssemblyLoadContext/<get_Assemblies>d__60")]
public IEnumerable`1<Assembly> get_Assemblies();
    public void add_ResolvingUnmanagedDll(Func`3<Assembly, string, IntPtr> value);
    public void remove_ResolvingUnmanagedDll(Func`3<Assembly, string, IntPtr> value);
    public void add_Resolving(Func`3<AssemblyLoadContext, AssemblyName, Assembly> value);
    public void remove_Resolving(Func`3<AssemblyLoadContext, AssemblyName, Assembly> value);
    public void add_Unloading(Action`1<AssemblyLoadContext> value);
    public void remove_Unloading(Action`1<AssemblyLoadContext> value);
    [CompilerGeneratedAttribute]
internal static void add_AssemblyLoad(AssemblyLoadEventHandler value);
    [CompilerGeneratedAttribute]
internal static void remove_AssemblyLoad(AssemblyLoadEventHandler value);
    [CompilerGeneratedAttribute]
internal static void add_TypeResolve(ResolveEventHandler value);
    [CompilerGeneratedAttribute]
internal static void remove_TypeResolve(ResolveEventHandler value);
    [CompilerGeneratedAttribute]
internal static void add_ResourceResolve(ResolveEventHandler value);
    [CompilerGeneratedAttribute]
internal static void remove_ResourceResolve(ResolveEventHandler value);
    [CompilerGeneratedAttribute]
internal static void add_AssemblyResolve(ResolveEventHandler value);
    [CompilerGeneratedAttribute]
internal static void remove_AssemblyResolve(ResolveEventHandler value);
    public static AssemblyLoadContext get_Default();
    public bool get_IsCollectible();
    [NullableContextAttribute("2")]
public string get_Name();
    public virtual string ToString();
    [IteratorStateMachineAttribute("System.Runtime.Loader.AssemblyLoadContext/<get_All>d__90")]
public static IEnumerable`1<AssemblyLoadContext> get_All();
    public static AssemblyName GetAssemblyName(string assemblyPath);
    protected virtual Assembly Load(AssemblyName assemblyName);
    public Assembly LoadFromAssemblyName(AssemblyName assemblyName);
    public Assembly LoadFromAssemblyPath(string assemblyPath);
    public Assembly LoadFromNativeImagePath(string nativeImagePath, string assemblyPath);
    public Assembly LoadFromStream(Stream assembly);
    public Assembly LoadFromStream(Stream assembly, Stream assemblySymbols);
    protected IntPtr LoadUnmanagedDllFromPath(string unmanagedDllPath);
    protected virtual IntPtr LoadUnmanagedDll(string unmanagedDllName);
    public void Unload();
    internal static void OnProcessExit();
    private void VerifyIsAlive();
    [NullableContextAttribute("2")]
public static AssemblyLoadContext get_CurrentContextualReflectionContext();
    private static void SetCurrentContextualReflectionContext(AssemblyLoadContext value);
    public ContextualReflectionScope EnterContextualReflection();
    [NullableContextAttribute("2")]
public static ContextualReflectionScope EnterContextualReflection(Assembly activating);
    private Assembly ResolveSatelliteAssembly(AssemblyName assemblyName);
}
internal class System.Runtime.Loader.DefaultAssemblyLoadContext : AssemblyLoadContext {
    internal static AssemblyLoadContext s_loadContext;
    private static DefaultAssemblyLoadContext();
}
internal class System.Runtime.Loader.IndividualAssemblyLoadContext : AssemblyLoadContext {
    internal IndividualAssemblyLoadContext(string name);
}
internal class System.Runtime.Loader.LibraryNameVariation : ValueType {
    public string Prefix;
    public string Suffix;
    public LibraryNameVariation(string prefix, string suffix);
    [IteratorStateMachineAttribute("System.Runtime.Loader.LibraryNameVariation/<DetermineLibraryNameVariations>d__4")]
internal static IEnumerable`1<LibraryNameVariation> DetermineLibraryNameVariations(string libName, bool isRelativePath);
}
public class System.Runtime.MemoryFailPoint : CriticalFinalizerObject {
    private static ulong s_topOfMemory;
    private static long s_hiddenLastKnownFreeAddressSpace;
    private static long s_hiddenLastTimeCheckingAddressSpace;
    private static ulong s_GCSegmentSize;
    private static long s_failPointReservedMemory;
    private ulong _reservedMemory;
    private bool _mustSubtractReservation;
    private static long LastKnownFreeAddressSpace { get; private set; }
    private static long LastTimeCheckingAddressSpace { get; private set; }
    internal static ulong MemoryFailPointReservedMemory { get; }
    public MemoryFailPoint(int sizeInMegabytes);
    private static MemoryFailPoint();
    private static long get_LastKnownFreeAddressSpace();
    private static void set_LastKnownFreeAddressSpace(long value);
    private static long AddToLastKnownFreeAddressSpace(long addend);
    private static long get_LastTimeCheckingAddressSpace();
    private static void set_LastTimeCheckingAddressSpace(long value);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    internal static long AddMemoryFailPointReservation(long size);
    internal static ulong get_MemoryFailPointReservedMemory();
    private static ulong GetTopOfMemory();
    private static bool CheckForAvailableMemory(UInt64& availPageFile, UInt64& totalAddressSpaceFree);
    private static bool CheckForFreeAddressSpace(ulong size, bool shouldThrow);
    private static ulong MemFreeAfterAddress(Void* address, ulong size);
    private static void GrowPageFileIfNecessaryAndPossible(UIntPtr numBytes);
}
[NullableAttribute("0")]
[NullableContextAttribute("2")]
public class System.Runtime.Remoting.ObjectHandle : MarshalByRefObject {
    private object _wrappedObject;
    public ObjectHandle(object o);
    public object Unwrap();
}
public class System.Runtime.RuntimeImports : object {
    internal static void RhZeroMemory(Byte& b, ulong byteLength);
    internal static void RhZeroMemory(IntPtr p, UIntPtr byteLength);
    private static void RhZeroMemory(Void* b, ulong byteLength);
    internal static void RhBulkMoveWithWriteBarrier(Byte& destination, Byte& source, ulong byteCount);
}
[IsReadOnlyAttribute]
public class System.Runtime.Serialization.DeserializationToken : ValueType {
    private DeserializationTracker _tracker;
    internal DeserializationToken(DeserializationTracker tracker);
    public sealed virtual void Dispose();
}
internal class System.Runtime.Serialization.DeserializationTracker : object {
    [CompilerGeneratedAttribute]
private bool <DeserializationInProgress>k__BackingField;
    internal bool DeserializationInProgress { get; internal set; }
    [CompilerGeneratedAttribute]
internal bool get_DeserializationInProgress();
    [CompilerGeneratedAttribute]
internal void set_DeserializationInProgress(bool value);
}
[NullableContextAttribute("2")]
public interface System.Runtime.Serialization.IDeserializationCallback {
    public abstract virtual void OnDeserialization(object sender);
}
[CLSCompliantAttribute("False")]
[NullableContextAttribute("1")]
public interface System.Runtime.Serialization.IFormatterConverter {
    public abstract virtual object Convert(object value, Type type);
    public abstract virtual object Convert(object value, TypeCode typeCode);
    public abstract virtual bool ToBoolean(object value);
    public abstract virtual char ToChar(object value);
    public abstract virtual sbyte ToSByte(object value);
    public abstract virtual byte ToByte(object value);
    public abstract virtual short ToInt16(object value);
    public abstract virtual ushort ToUInt16(object value);
    public abstract virtual int ToInt32(object value);
    public abstract virtual UInt32 ToUInt32(object value);
    public abstract virtual long ToInt64(object value);
    public abstract virtual ulong ToUInt64(object value);
    public abstract virtual float ToSingle(object value);
    public abstract virtual double ToDouble(object value);
    public abstract virtual decimal ToDecimal(object value);
    public abstract virtual DateTime ToDateTime(object value);
    public abstract virtual string ToString(object value);
}
[NullableContextAttribute("1")]
public interface System.Runtime.Serialization.IObjectReference {
    public abstract virtual object GetRealObject(StreamingContext context);
}
[NullableContextAttribute("1")]
public interface System.Runtime.Serialization.ISafeSerializationData {
    public abstract virtual void CompleteDeserialization(object deserialized);
}
[NullableContextAttribute("1")]
public interface System.Runtime.Serialization.ISerializable {
    public abstract virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("64")]
public class System.Runtime.Serialization.OnDeserializedAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class System.Runtime.Serialization.OnDeserializingAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class System.Runtime.Serialization.OnSerializedAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class System.Runtime.Serialization.OnSerializingAttribute : Attribute {
}
[AttributeUsageAttribute("256")]
public class System.Runtime.Serialization.OptionalFieldAttribute : Attribute {
    private int _versionAdded;
    public int VersionAdded { get; public set; }
    public int get_VersionAdded();
    public void set_VersionAdded(int value);
}
public class System.Runtime.Serialization.SafeSerializationEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private StreamingContext <StreamingContext>k__BackingField;
    public StreamingContext StreamingContext { get; }
    [NullableContextAttribute("1")]
public void AddSerializedState(ISafeSerializationData serializedState);
    [CompilerGeneratedAttribute]
public StreamingContext get_StreamingContext();
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
[IsReadOnlyAttribute]
public class System.Runtime.Serialization.SerializationEntry : ValueType {
    private string _name;
    private object _value;
    private Type _type;
    [NullableAttribute("2")]
public object Value { get; }
    public string Name { get; }
    public Type ObjectType { get; }
    internal SerializationEntry(string entryName, object entryValue, Type entryType);
    [NullableContextAttribute("2")]
public object get_Value();
    public string get_Name();
    public Type get_ObjectType();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Runtime.Serialization.SerializationException : SystemException {
    public SerializationException(string message);
    public SerializationException(string message, Exception innerException);
    [NullableContextAttribute("1")]
protected SerializationException(SerializationInfo info, StreamingContext context);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Runtime.Serialization.SerializationInfo : object {
    private String[] _names;
    private Object[] _values;
    private Type[] _types;
    private int _count;
    private Dictionary`2<string, int> _nameToIndex;
    private IFormatterConverter _converter;
    private string _rootTypeName;
    private string _rootTypeAssemblyName;
    private Type _rootType;
    [CompilerGeneratedAttribute]
private static AsyncLocal`1<bool> <AsyncDeserializationInProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFullTypeNameSetExplicit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAssemblyNameSetExplicit>k__BackingField;
    internal static AsyncLocal`1<bool> AsyncDeserializationInProgress { get; }
    public static bool DeserializationInProgress { get; }
    public string FullTypeName { get; public set; }
    public string AssemblyName { get; public set; }
    public bool IsFullTypeNameSetExplicit { get; private set; }
    public bool IsAssemblyNameSetExplicit { get; private set; }
    public int MemberCount { get; }
    public Type ObjectType { get; }
    [CLSCompliantAttribute("False")]
public SerializationInfo(Type type, IFormatterConverter converter);
    [CLSCompliantAttribute("False")]
public SerializationInfo(Type type, IFormatterConverter converter, bool requireSameTokenInPartialTrust);
    private static SerializationInfo();
    [CompilerGeneratedAttribute]
internal static AsyncLocal`1<bool> get_AsyncDeserializationInProgress();
    public static bool get_DeserializationInProgress();
    public static void ThrowIfDeserializationInProgress();
    public static void ThrowIfDeserializationInProgress(string switchSuffix, Int32& cachedValue);
    public static DeserializationToken StartDeserialization();
    public string get_FullTypeName();
    public void set_FullTypeName(string value);
    public string get_AssemblyName();
    public void set_AssemblyName(string value);
    [CompilerGeneratedAttribute]
public bool get_IsFullTypeNameSetExplicit();
    [CompilerGeneratedAttribute]
private void set_IsFullTypeNameSetExplicit(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsAssemblyNameSetExplicit();
    [CompilerGeneratedAttribute]
private void set_IsAssemblyNameSetExplicit(bool value);
    public void SetType(Type type);
    public int get_MemberCount();
    public Type get_ObjectType();
    public SerializationInfoEnumerator GetEnumerator();
    private void ExpandArrays();
    public void AddValue(string name, object value, Type type);
    public void AddValue(string name, object value);
    public void AddValue(string name, bool value);
    public void AddValue(string name, char value);
    [CLSCompliantAttribute("False")]
public void AddValue(string name, sbyte value);
    public void AddValue(string name, byte value);
    public void AddValue(string name, short value);
    [CLSCompliantAttribute("False")]
public void AddValue(string name, ushort value);
    public void AddValue(string name, int value);
    [CLSCompliantAttribute("False")]
public void AddValue(string name, UInt32 value);
    public void AddValue(string name, long value);
    [CLSCompliantAttribute("False")]
public void AddValue(string name, ulong value);
    public void AddValue(string name, float value);
    public void AddValue(string name, double value);
    public void AddValue(string name, decimal value);
    public void AddValue(string name, DateTime value);
    internal void AddValueInternal(string name, object value, Type type);
    public void UpdateValue(string name, object value, Type type);
    private int FindElement(string name);
    private object GetElement(string name, Type& foundType);
    private object GetElementNoThrow(string name, Type& foundType);
    public object GetValue(string name, Type type);
    internal object GetValueNoThrow(string name, Type type);
    public bool GetBoolean(string name);
    public char GetChar(string name);
    [CLSCompliantAttribute("False")]
public sbyte GetSByte(string name);
    public byte GetByte(string name);
    public short GetInt16(string name);
    [CLSCompliantAttribute("False")]
public ushort GetUInt16(string name);
    public int GetInt32(string name);
    [CLSCompliantAttribute("False")]
public UInt32 GetUInt32(string name);
    public long GetInt64(string name);
    [CLSCompliantAttribute("False")]
public ulong GetUInt64(string name);
    public float GetSingle(string name);
    public double GetDouble(string name);
    public decimal GetDecimal(string name);
    public DateTime GetDateTime(string name);
    public string GetString(string name);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Runtime.Serialization.SerializationInfoEnumerator : object {
    private String[] _members;
    private Object[] _data;
    private Type[] _types;
    private int _numItems;
    private int _currItem;
    private bool _current;
    [NullableAttribute("2")]
private object System.Collections.IEnumerator.Current { get; }
    public SerializationEntry Current { get; }
    public string Name { get; }
    [NullableAttribute("2")]
public object Value { get; }
    public Type ObjectType { get; }
    internal SerializationInfoEnumerator(String[] members, Object[] info, Type[] types, int numItems);
    public sealed virtual bool MoveNext();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public SerializationEntry get_Current();
    public sealed virtual void Reset();
    public string get_Name();
    [NullableContextAttribute("2")]
public object get_Value();
    public Type get_ObjectType();
}
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[NullableContextAttribute("2")]
public class System.Runtime.Serialization.StreamingContext : ValueType {
    private object _additionalContext;
    private StreamingContextStates _state;
    public StreamingContextStates State { get; }
    public object Context { get; }
    public StreamingContext(StreamingContextStates state);
    public StreamingContext(StreamingContextStates state, object additional);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public StreamingContextStates get_State();
    public object get_Context();
}
[FlagsAttribute]
public enum System.Runtime.Serialization.StreamingContextStates : Enum {
    public int value__;
    public static StreamingContextStates CrossProcess;
    public static StreamingContextStates CrossMachine;
    public static StreamingContextStates File;
    public static StreamingContextStates Persistence;
    public static StreamingContextStates Remoting;
    public static StreamingContextStates Other;
    public static StreamingContextStates Clone;
    public static StreamingContextStates CrossAppDomain;
    public static StreamingContextStates All;
}
internal static class System.Runtime.Versioning.CompatibilitySwitch : object {
    internal static string GetValueInternal(string compatibilitySwitchName);
    private static string GetValueInternalCall(string compatibilitySwitchName, bool onlyDB);
}
[AttributeUsageAttribute("108")]
internal class System.Runtime.Versioning.NonVersionableAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Runtime.Versioning.TargetFrameworkAttribute : Attribute {
    private string _frameworkName;
    private string _frameworkDisplayName;
    public string FrameworkName { get; }
    [NullableAttribute("2")]
public string FrameworkDisplayName { get; public set; }
    public TargetFrameworkAttribute(string frameworkName);
    public string get_FrameworkName();
    [NullableContextAttribute("2")]
public string get_FrameworkDisplayName();
    [NullableContextAttribute("2")]
public void set_FrameworkDisplayName(string value);
}
[IsByRefLikeAttribute]
public class System.RuntimeArgumentHandle : ValueType {
    private IntPtr m_ptr;
    internal IntPtr Value { get; }
    internal IntPtr get_Value();
}
public class System.RuntimeFieldHandle : ValueType {
    private IRuntimeFieldInfo m_ptr;
    public IntPtr Value { get; }
    internal RuntimeFieldHandle(IRuntimeFieldInfo fieldInfo);
    internal IRuntimeFieldInfo GetRuntimeFieldInfo();
    public IntPtr get_Value();
    internal bool IsNullHandle();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public bool Equals(RuntimeFieldHandle handle);
    public static bool op_Equality(RuntimeFieldHandle left, RuntimeFieldHandle right);
    public static bool op_Inequality(RuntimeFieldHandle left, RuntimeFieldHandle right);
    internal static string GetName(RtFieldInfo field);
    private static Void* _GetUtf8Name(RuntimeFieldHandleInternal field);
    internal static MdUtf8String GetUtf8Name(RuntimeFieldHandleInternal field);
    internal static bool MatchesNameHash(RuntimeFieldHandleInternal handle, UInt32 hash);
    internal static FieldAttributes GetAttributes(RuntimeFieldHandleInternal field);
    internal static RuntimeType GetApproxDeclaringType(RuntimeFieldHandleInternal field);
    internal static RuntimeType GetApproxDeclaringType(IRuntimeFieldInfo field);
    internal static int GetToken(RtFieldInfo field);
    internal static object GetValue(RtFieldInfo field, object instance, RuntimeType fieldType, RuntimeType declaringType, Boolean& domainInitialized);
    internal static object GetValueDirect(RtFieldInfo field, RuntimeType fieldType, Void* pTypedRef, RuntimeType contextType);
    internal static void SetValue(RtFieldInfo field, object obj, object value, RuntimeType fieldType, FieldAttributes fieldAttr, RuntimeType declaringType, Boolean& domainInitialized);
    internal static void SetValueDirect(RtFieldInfo field, RuntimeType fieldType, Void* pTypedRef, object value, RuntimeType contextType);
    internal static RuntimeFieldHandleInternal GetStaticFieldForGenericType(RuntimeFieldHandleInternal field, RuntimeType declaringType);
    internal static bool AcquiresContextFromThis(RuntimeFieldHandleInternal field);
    [NullableContextAttribute("1")]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class System.RuntimeFieldHandleInternal : ValueType {
    internal IntPtr m_handle;
    internal IntPtr Value { get; }
    internal RuntimeFieldHandleInternal(IntPtr value);
    internal IntPtr get_Value();
}
internal class System.RuntimeFieldInfoStub : object {
    private object m_keepalive;
    private object m_c;
    private object m_d;
    private int m_b;
    private object m_e;
    private RuntimeFieldHandleInternal m_fieldHandle;
    private RuntimeFieldHandleInternal System.IRuntimeFieldInfo.Value { get; }
    private sealed virtual override RuntimeFieldHandleInternal System.IRuntimeFieldInfo.get_Value();
}
public class System.RuntimeMethodHandle : ValueType {
    private IRuntimeMethodInfo m_value;
    public IntPtr Value { get; }
    internal RuntimeMethodHandle(IRuntimeMethodInfo method);
    internal static IRuntimeMethodInfo EnsureNonNullMethodInfo(IRuntimeMethodInfo method);
    internal IRuntimeMethodInfo GetMethodInfo();
    private static IntPtr GetValueInternal(RuntimeMethodHandle rmh);
    [NullableContextAttribute("1")]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public IntPtr get_Value();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public static bool op_Equality(RuntimeMethodHandle left, RuntimeMethodHandle right);
    public static bool op_Inequality(RuntimeMethodHandle left, RuntimeMethodHandle right);
    public bool Equals(RuntimeMethodHandle handle);
    internal bool IsNullHandle();
    internal static IntPtr GetFunctionPointer(RuntimeMethodHandleInternal handle);
    public IntPtr GetFunctionPointer();
    internal static BOOL GetIsCollectible(RuntimeMethodHandleInternal handle);
    internal static BOOL IsCAVisibleFromDecoratedType(QCallTypeHandle attrTypeHandle, RuntimeMethodHandleInternal attrCtor, QCallTypeHandle sourceTypeHandle, QCallModule sourceModule);
    private static IRuntimeMethodInfo _GetCurrentMethod(StackCrawlMark& stackMark);
    internal static IRuntimeMethodInfo GetCurrentMethod(StackCrawlMark& stackMark);
    internal static MethodAttributes GetAttributes(RuntimeMethodHandleInternal method);
    internal static MethodAttributes GetAttributes(IRuntimeMethodInfo method);
    internal static MethodImplAttributes GetImplAttributes(IRuntimeMethodInfo method);
    private static void ConstructInstantiation(RuntimeMethodHandleInternal method, TypeNameFormatFlags format, StringHandleOnStack retString);
    internal static string ConstructInstantiation(IRuntimeMethodInfo method, TypeNameFormatFlags format);
    internal static RuntimeType GetDeclaringType(RuntimeMethodHandleInternal method);
    internal static RuntimeType GetDeclaringType(IRuntimeMethodInfo method);
    internal static int GetSlot(RuntimeMethodHandleInternal method);
    internal static int GetSlot(IRuntimeMethodInfo method);
    internal static int GetMethodDef(IRuntimeMethodInfo method);
    internal static string GetName(RuntimeMethodHandleInternal method);
    internal static string GetName(IRuntimeMethodInfo method);
    private static Void* _GetUtf8Name(RuntimeMethodHandleInternal method);
    internal static MdUtf8String GetUtf8Name(RuntimeMethodHandleInternal method);
    internal static bool MatchesNameHash(RuntimeMethodHandleInternal method, UInt32 hash);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
internal static object InvokeMethod(object target, Object[] arguments, Signature sig, bool constructor, bool wrapExceptions);
    private static void GetMethodInstantiation(RuntimeMethodHandleInternal method, ObjectHandleOnStack types, BOOL fAsRuntimeTypeArray);
    internal static RuntimeType[] GetMethodInstantiationInternal(IRuntimeMethodInfo method);
    internal static RuntimeType[] GetMethodInstantiationInternal(RuntimeMethodHandleInternal method);
    internal static Type[] GetMethodInstantiationPublic(IRuntimeMethodInfo method);
    internal static bool HasMethodInstantiation(RuntimeMethodHandleInternal method);
    internal static bool HasMethodInstantiation(IRuntimeMethodInfo method);
    internal static RuntimeMethodHandleInternal GetStubIfNeeded(RuntimeMethodHandleInternal method, RuntimeType declaringType, RuntimeType[] methodInstantiation);
    internal static RuntimeMethodHandleInternal GetMethodFromCanonical(RuntimeMethodHandleInternal method, RuntimeType declaringType);
    internal static bool IsGenericMethodDefinition(RuntimeMethodHandleInternal method);
    internal static bool IsGenericMethodDefinition(IRuntimeMethodInfo method);
    internal static bool IsTypicalMethodDefinition(IRuntimeMethodInfo method);
    private static void GetTypicalMethodDefinition(RuntimeMethodHandleInternal method, ObjectHandleOnStack outMethod);
    internal static IRuntimeMethodInfo GetTypicalMethodDefinition(IRuntimeMethodInfo method);
    private static int GetGenericParameterCount(RuntimeMethodHandleInternal method);
    internal static int GetGenericParameterCount(IRuntimeMethodInfo method);
    private static void StripMethodInstantiation(RuntimeMethodHandleInternal method, ObjectHandleOnStack outMethod);
    internal static IRuntimeMethodInfo StripMethodInstantiation(IRuntimeMethodInfo method);
    internal static bool IsDynamicMethod(RuntimeMethodHandleInternal method);
    internal static void Destroy(RuntimeMethodHandleInternal method);
    internal static Resolver GetResolver(RuntimeMethodHandleInternal method);
    internal static RuntimeMethodBody GetMethodBody(IRuntimeMethodInfo method, RuntimeType declaringType);
    internal static bool IsConstructor(RuntimeMethodHandleInternal method);
    internal static LoaderAllocator GetLoaderAllocator(RuntimeMethodHandleInternal method);
}
internal class System.RuntimeMethodHandleInternal : ValueType {
    internal IntPtr m_handle;
    internal static RuntimeMethodHandleInternal EmptyHandle { get; }
    internal IntPtr Value { get; }
    internal RuntimeMethodHandleInternal(IntPtr value);
    internal static RuntimeMethodHandleInternal get_EmptyHandle();
    internal bool IsNullHandle();
    internal IntPtr get_Value();
}
internal class System.RuntimeMethodInfoStub : object {
    private object m_keepalive;
    private object m_a;
    private object m_b;
    private object m_c;
    private object m_d;
    private object m_e;
    private object m_f;
    private object m_g;
    public RuntimeMethodHandleInternal m_value;
    private RuntimeMethodHandleInternal System.IRuntimeMethodInfo.Value { get; }
    public RuntimeMethodInfoStub(RuntimeMethodHandleInternal methodHandleValue, object keepalive);
    public RuntimeMethodInfoStub(IntPtr methodHandleValue, object keepalive);
    private sealed virtual override RuntimeMethodHandleInternal System.IRuntimeMethodInfo.get_Value();
}
internal class System.RuntimeType : TypeInfo {
    private object m_keepalive;
    private IntPtr m_cache;
    internal IntPtr m_handle;
    internal static RuntimeType ValueType;
    private static RuntimeType ObjectType;
    private static RuntimeType StringType;
    private static int GenericParameterCountAny;
    private static BindingFlags MemberBindingMask;
    private static BindingFlags InvocationMask;
    private static BindingFlags BinderNonCreateInstance;
    private static BindingFlags BinderGetSetProperty;
    private static BindingFlags BinderGetSetField;
    private static BindingFlags BinderNonFieldGetSet;
    private static BindingFlags ClassicBindingMask;
    private static RuntimeType s_typedRef;
    private static OleAutBinder s_ForwardCallBinder;
    internal object GenericCache { get; internal set; }
    internal bool DomainInitialized { get; internal set; }
    private RuntimeTypeCache CacheIfExists { get; }
    private RuntimeTypeCache Cache { get; }
    public bool IsCollectible { get; }
    public MethodBase DeclaringMethod { get; }
    public string FullName { get; }
    public string AssemblyQualifiedName { get; }
    public string Namespace { get; }
    public Guid GUID { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public bool IsSZArray { get; }
    public int GenericParameterPosition { get; }
    public bool ContainsGenericParameters { get; }
    public StructLayoutAttribute StructLayoutAttribute { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    private OleAutBinder ForwardCallBinder { get; }
    public Assembly Assembly { get; }
    public Type BaseType { get; }
    public bool IsByRefLike { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsGenericType { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsGenericParameter { get; }
    public bool IsTypeDefinition { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public MemberTypes MemberType { get; }
    public int MetadataToken { get; }
    public Module Module { get; }
    public Type ReflectedType { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public Type UnderlyingSystemType { get; }
    private static RuntimeType();
    internal static RuntimeType GetType(string typeName, bool throwOnError, bool ignoreCase, StackCrawlMark& stackMark);
    internal static MethodBase GetMethodBase(RuntimeModule scope, int typeMetadataToken);
    internal static MethodBase GetMethodBase(IRuntimeMethodInfo methodHandle);
    internal static MethodBase GetMethodBase(RuntimeType reflectedType, IRuntimeMethodInfo methodHandle);
    internal static MethodBase GetMethodBase(RuntimeType reflectedType, RuntimeMethodHandleInternal methodHandle);
    internal object get_GenericCache();
    internal void set_GenericCache(object value);
    internal bool get_DomainInitialized();
    internal void set_DomainInitialized(bool value);
    internal static FieldInfo GetFieldInfo(IRuntimeFieldInfo fieldHandle);
    internal static FieldInfo GetFieldInfo(RuntimeType reflectedType, IRuntimeFieldInfo field);
    private static PropertyInfo GetPropertyInfo(RuntimeType reflectedType, int tkProperty);
    private static void ThrowIfTypeNeverValidGenericArgument(RuntimeType type);
    internal static void SanityCheckGenericArguments(RuntimeType[] genericArguments, RuntimeType[] genericParamters);
    internal static void ValidateGenericArguments(MemberInfo definition, RuntimeType[] genericArguments, Exception e);
    private static void SplitName(string fullname, String& name, String& ns);
    internal static BindingFlags FilterPreCalculate(bool isPublic, bool isInherited, bool isStatic);
    private static void FilterHelper(BindingFlags bindingFlags, String& name, bool allowPrefixLookup, Boolean& prefixLookup, Boolean& ignoreCase, MemberListType& listType);
    private static void FilterHelper(BindingFlags bindingFlags, String& name, Boolean& ignoreCase, MemberListType& listType);
    private static bool FilterApplyPrefixLookup(MemberInfo memberInfo, string name, bool ignoreCase);
    private static bool FilterApplyBase(MemberInfo memberInfo, BindingFlags bindingFlags, bool isPublic, bool isNonProtectedInternal, bool isStatic, string name, bool prefixLookup);
    private static bool FilterApplyType(Type type, BindingFlags bindingFlags, string name, bool prefixLookup, string ns);
    private static bool FilterApplyMethodInfo(RuntimeMethodInfo method, BindingFlags bindingFlags, CallingConventions callConv, Type[] argumentTypes);
    private static bool FilterApplyConstructorInfo(RuntimeConstructorInfo constructor, BindingFlags bindingFlags, CallingConventions callConv, Type[] argumentTypes);
    private static bool FilterApplyMethodBase(MethodBase methodBase, BindingFlags methodFlags, BindingFlags bindingFlags, CallingConventions callConv, Type[] argumentTypes);
    internal virtual bool CacheEquals(object o);
    private RuntimeTypeCache get_CacheIfExists();
    private RuntimeTypeCache get_Cache();
    private RuntimeTypeCache InitializeCache();
    private string GetDefaultMemberName();
    private ListBuilder`1<MethodInfo> GetMethodCandidates(string name, int genericParameterCount, BindingFlags bindingAttr, CallingConventions callConv, Type[] types, bool allowPrefixLookup);
    private ListBuilder`1<ConstructorInfo> GetConstructorCandidates(string name, BindingFlags bindingAttr, CallingConventions callConv, Type[] types, bool allowPrefixLookup);
    private ListBuilder`1<PropertyInfo> GetPropertyCandidates(string name, BindingFlags bindingAttr, Type[] types, bool allowPrefixLookup);
    private ListBuilder`1<EventInfo> GetEventCandidates(string name, BindingFlags bindingAttr, bool allowPrefixLookup);
    private ListBuilder`1<FieldInfo> GetFieldCandidates(string name, BindingFlags bindingAttr, bool allowPrefixLookup);
    private ListBuilder`1<Type> GetNestedTypeCandidates(string fullname, BindingFlags bindingAttr, bool allowPrefixLookup);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public virtual Type[] GetInterfaces();
    public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    public virtual InterfaceMapping GetInterfaceMap(Type ifaceType);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConv, Type[] types, ParameterModifier[] modifiers);
    protected virtual MethodInfo GetMethodImpl(string name, int genericParameterCount, BindingFlags bindingAttr, Binder binder, CallingConventions callConv, Type[] types, ParameterModifier[] modifiers);
    private MethodInfo GetMethodImplCommon(string name, int genericParameterCount, BindingFlags bindingAttr, Binder binder, CallingConventions callConv, Type[] types, ParameterModifier[] modifiers);
    protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual Type GetInterface(string fullname, bool ignoreCase);
    public virtual Type GetNestedType(string fullname, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public sealed virtual bool get_IsCollectible();
    public virtual MethodBase get_DeclaringMethod();
    public virtual bool IsSubclassOf(Type type);
    public virtual bool IsEquivalentTo(Type other);
    public virtual string get_FullName();
    public virtual string get_AssemblyQualifiedName();
    public virtual string get_Namespace();
    public virtual Guid get_GUID();
    private void GetGUID(Guid& result);
    internal virtual bool IsWindowsRuntimeObjectImpl();
    private static bool IsWindowsRuntimeObjectType(RuntimeType type);
    internal virtual bool IsExportedToWindowsRuntimeImpl();
    private static bool IsTypeExportedToWindowsRuntime(RuntimeType type);
    internal bool IsDelegate();
    public virtual GenericParameterAttributes get_GenericParameterAttributes();
    public sealed virtual bool get_IsSZArray();
    internal Object[] GetEmptyArray();
    internal RuntimeType[] GetGenericArgumentsInternal();
    public virtual Type[] GetGenericArguments();
    public virtual Type MakeGenericType(Type[] instantiation);
    public virtual int get_GenericParameterPosition();
    public virtual bool get_ContainsGenericParameters();
    public virtual Type[] GetGenericParameterConstraints();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public virtual Type MakePointerType();
    public virtual Type MakeByRefType();
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
    public virtual StructLayoutAttribute get_StructLayoutAttribute();
    private static bool CanValueSpecialCast(RuntimeType valueType, RuntimeType targetType);
    private static object AllocateValueType(RuntimeType type, object value, bool fForceTypeChange);
    internal object CheckValue(object value, Binder binder, CultureInfo culture, BindingFlags invokeAttr);
    private object TryChangeType(object value, Binder binder, CultureInfo culture, bool needsSpecialCast);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public virtual object InvokeMember(string name, BindingFlags bindingFlags, Binder binder, object target, Object[] providedArgs, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParams);
    public virtual string ToString();
    public virtual string get_Name();
    internal virtual string FormatTypeName();
    private string GetCachedName(TypeNameKind kind);
    public virtual Type get_DeclaringType();
    private void CreateInstanceCheckThis();
    internal object CreateInstanceImpl(BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture);
    private object CreateInstanceDefaultCtorSlow(bool publicOnly, bool wrapExceptions, bool fillCache);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
internal object CreateInstanceDefaultCtor(bool publicOnly, bool skipCheckThis, bool fillCache, bool wrapExceptions);
    internal void InvalidateCachedNestedType();
    internal bool IsGenericCOMObjectImpl();
    private static object _CreateEnum(RuntimeType enumType, long value);
    internal static object CreateEnum(RuntimeType enumType, long value);
    private object InvokeDispMethod(string name, BindingFlags invokeAttr, object target, Object[] args, Boolean[] byrefModifiers, int culture, String[] namedParameters);
    internal static Type GetTypeFromProgIDImpl(string progID, string server, bool throwOnError);
    internal static Type GetTypeFromCLSIDImpl(Guid clsid, string server, bool throwOnError);
    private object ForwardCallToInvokeMember(string memberName, BindingFlags flags, object target, Object[] aArgs, Boolean[] aArgsIsByRef, Int32[] aArgsWrapperTypes, Type[] aArgsTypes, Type retType);
    private void WrapArgsForInvokeCall(Object[] aArgs, Int32[] aArgsWrapperTypes);
    private OleAutBinder get_ForwardCallBinder();
    public virtual Assembly get_Assembly();
    public virtual Type get_BaseType();
    public virtual bool get_IsByRefLike();
    public virtual bool get_IsConstructedGenericType();
    public virtual bool get_IsGenericType();
    public virtual bool get_IsGenericTypeDefinition();
    public virtual bool get_IsGenericParameter();
    public virtual bool get_IsTypeDefinition();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    public virtual MemberTypes get_MemberType();
    public virtual int get_MetadataToken();
    public virtual Module get_Module();
    public virtual Type get_ReflectedType();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public virtual Type get_UnderlyingSystemType();
    public sealed virtual object Clone();
    public virtual bool Equals(object obj);
    public virtual int GetArrayRank();
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual MemberInfo[] GetDefaultMembers();
    public virtual Type GetElementType();
    public virtual string GetEnumName(object value);
    public virtual String[] GetEnumNames();
    public virtual Array GetEnumValues();
    public virtual Type GetEnumUnderlyingType();
    public virtual Type GetGenericTypeDefinition();
    public virtual int GetHashCode();
    internal RuntimeModule GetRuntimeModule();
    protected virtual TypeCode GetTypeCodeImpl();
    protected virtual bool HasElementTypeImpl();
    protected virtual bool IsArrayImpl();
    protected virtual bool IsContextfulImpl();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual bool IsEnumDefined(object value);
    protected virtual bool IsValueTypeImpl();
    protected virtual bool IsByRefImpl();
    protected virtual bool IsPrimitiveImpl();
    protected virtual bool IsPointerImpl();
    protected virtual bool IsCOMObjectImpl();
    public virtual bool IsInstanceOfType(object o);
    public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    public virtual bool IsAssignableFrom(Type c);
    private RuntimeType GetBaseType();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.RuntimeTypeHandle : ValueType {
    internal RuntimeType m_type;
    public IntPtr Value { get; }
    internal RuntimeTypeHandle(RuntimeType type);
    internal RuntimeTypeHandle GetNativeHandle();
    internal RuntimeType GetTypeChecked();
    internal static bool IsInstanceOfType(RuntimeType type, object o);
    internal static Type GetTypeHelper(Type typeStart, Type[] genericArgs, IntPtr pModifiers, int cModifiers);
    public static bool op_Equality(RuntimeTypeHandle left, object right);
    public static bool op_Equality(object left, RuntimeTypeHandle right);
    public static bool op_Inequality(RuntimeTypeHandle left, object right);
    public static bool op_Inequality(object left, RuntimeTypeHandle right);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(RuntimeTypeHandle handle);
    public IntPtr get_Value();
    internal static IntPtr GetValueInternal(RuntimeTypeHandle handle);
    internal static bool IsTypeDefinition(RuntimeType type);
    internal static bool IsPrimitive(RuntimeType type);
    internal static bool IsByRef(RuntimeType type);
    internal static bool IsPointer(RuntimeType type);
    internal static bool IsArray(RuntimeType type);
    internal static bool IsSZArray(RuntimeType type);
    internal static bool HasElementType(RuntimeType type);
    internal static IntPtr[] CopyRuntimeTypeHandles(RuntimeTypeHandle[] inHandles, Int32& length);
    internal static IntPtr[] CopyRuntimeTypeHandles(Type[] inHandles, Int32& length);
    internal static object CreateInstance(RuntimeType type, bool publicOnly, bool wrapExceptions, Boolean& canBeCached, RuntimeMethodHandleInternal& ctor, Boolean& hasNoDefaultCtor);
    internal static object CreateCaInstance(RuntimeType type, IRuntimeMethodInfo ctor);
    internal static object Allocate(RuntimeType type);
    internal static object CreateInstanceForAnotherGenericParameter(RuntimeType type, RuntimeType genericParameter);
    internal RuntimeType GetRuntimeType();
    internal static CorElementType GetCorElementType(RuntimeType type);
    internal static RuntimeAssembly GetAssembly(RuntimeType type);
    internal static RuntimeModule GetModule(RuntimeType type);
    public ModuleHandle GetModuleHandle();
    internal static RuntimeType GetBaseType(RuntimeType type);
    internal static TypeAttributes GetAttributes(RuntimeType type);
    internal static RuntimeType GetElementType(RuntimeType type);
    internal static bool CompareCanonicalHandles(RuntimeType left, RuntimeType right);
    internal static int GetArrayRank(RuntimeType type);
    internal static int GetToken(RuntimeType type);
    internal static RuntimeMethodHandleInternal GetMethodAt(RuntimeType type, int slot);
    internal static IntroducedMethodEnumerator GetIntroducedMethods(RuntimeType type);
    private static RuntimeMethodHandleInternal GetFirstIntroducedMethod(RuntimeType type);
    private static void GetNextIntroducedMethod(RuntimeMethodHandleInternal& method);
    internal static bool GetFields(RuntimeType type, IntPtr* result, Int32* count);
    internal static Type[] GetInterfaces(RuntimeType type);
    private static void GetConstraints(QCallTypeHandle handle, ObjectHandleOnStack types);
    internal Type[] GetConstraints();
    private static IntPtr GetGCHandle(QCallTypeHandle handle, GCHandleType type);
    internal IntPtr GetGCHandle(GCHandleType type);
    private static IntPtr FreeGCHandle(QCallTypeHandle typeHandle, IntPtr objHandle);
    internal IntPtr FreeGCHandle(IntPtr objHandle);
    internal static int GetNumVirtuals(RuntimeType type);
    private static void VerifyInterfaceIsImplemented(QCallTypeHandle handle, QCallTypeHandle interfaceHandle);
    internal void VerifyInterfaceIsImplemented(RuntimeTypeHandle interfaceHandle);
    private static RuntimeMethodHandleInternal GetInterfaceMethodImplementation(QCallTypeHandle handle, QCallTypeHandle interfaceHandle, RuntimeMethodHandleInternal interfaceMethodHandle);
    internal RuntimeMethodHandleInternal GetInterfaceMethodImplementation(RuntimeTypeHandle interfaceHandle, RuntimeMethodHandleInternal interfaceMethodHandle);
    internal static bool IsComObject(RuntimeType type, bool isGenericCOM);
    internal static bool IsInterface(RuntimeType type);
    internal static bool IsByRefLike(RuntimeType type);
    private static bool _IsVisible(QCallTypeHandle typeHandle);
    internal static bool IsVisible(RuntimeType type);
    internal static bool IsValueType(RuntimeType type);
    private static void ConstructName(QCallTypeHandle handle, TypeNameFormatFlags formatFlags, StringHandleOnStack retString);
    internal string ConstructName(TypeNameFormatFlags formatFlags);
    private static Void* _GetUtf8Name(RuntimeType type);
    internal static MdUtf8String GetUtf8Name(RuntimeType type);
    internal static bool CanCastTo(RuntimeType type, RuntimeType target);
    internal static RuntimeType GetDeclaringType(RuntimeType type);
    internal static IRuntimeMethodInfo GetDeclaringMethod(RuntimeType type);
    private static void GetDefaultConstructor(QCallTypeHandle handle, ObjectHandleOnStack method);
    internal IRuntimeMethodInfo GetDefaultConstructor();
    private static void GetTypeByName(string name, bool throwOnError, bool ignoreCase, StackCrawlMarkHandle stackMark, ObjectHandleOnStack assemblyLoadContext, bool loadTypeFromPartialName, ObjectHandleOnStack type, ObjectHandleOnStack keepalive);
    internal static RuntimeType GetTypeByName(string name, bool throwOnError, bool ignoreCase, StackCrawlMark& stackMark, bool loadTypeFromPartialName);
    internal static RuntimeType GetTypeByName(string name, bool throwOnError, bool ignoreCase, StackCrawlMark& stackMark, AssemblyLoadContext assemblyLoadContext, bool loadTypeFromPartialName);
    private static void GetTypeByNameUsingCARules(string name, QCallModule scope, ObjectHandleOnStack type);
    internal static RuntimeType GetTypeByNameUsingCARules(string name, RuntimeModule scope);
    internal static void GetInstantiation(QCallTypeHandle type, ObjectHandleOnStack types, BOOL fAsRuntimeTypeArray);
    internal RuntimeType[] GetInstantiationInternal();
    internal Type[] GetInstantiationPublic();
    private static void Instantiate(QCallTypeHandle handle, IntPtr* pInst, int numGenericArgs, ObjectHandleOnStack type);
    internal RuntimeType Instantiate(Type[] inst);
    private static void MakeArray(QCallTypeHandle handle, int rank, ObjectHandleOnStack type);
    internal RuntimeType MakeArray(int rank);
    private static void MakeSZArray(QCallTypeHandle handle, ObjectHandleOnStack type);
    internal RuntimeType MakeSZArray();
    private static void MakeByRef(QCallTypeHandle handle, ObjectHandleOnStack type);
    internal RuntimeType MakeByRef();
    private static void MakePointer(QCallTypeHandle handle, ObjectHandleOnStack type);
    internal RuntimeType MakePointer();
    internal static BOOL IsCollectible(QCallTypeHandle handle);
    internal static bool HasInstantiation(RuntimeType type);
    private static void GetGenericTypeDefinition(QCallTypeHandle type, ObjectHandleOnStack retType);
    internal static RuntimeType GetGenericTypeDefinition(RuntimeType type);
    internal static bool IsGenericTypeDefinition(RuntimeType type);
    internal static bool IsGenericVariable(RuntimeType type);
    private static int GetGenericVariableIndex(RuntimeType type);
    internal int GetGenericVariableIndex();
    internal static bool ContainsGenericVariables(RuntimeType handle);
    internal bool ContainsGenericVariables();
    private static bool SatisfiesConstraints(RuntimeType paramType, IntPtr* pTypeContext, int typeContextLength, IntPtr* pMethodContext, int methodContextLength, RuntimeType toType);
    internal static bool SatisfiesConstraints(RuntimeType paramType, RuntimeType[] typeContext, RuntimeType[] methodContext, RuntimeType toType);
    private static IntPtr _GetMetadataImport(RuntimeType type);
    internal static MetadataImport GetMetadataImport(RuntimeType type);
    [NullableContextAttribute("1")]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal static bool IsEquivalentTo(RuntimeType rtType1, RuntimeType rtType2);
}
internal class System.SafeTypeNameParserHandle : SafeHandleZeroOrMinusOneIsInvalid {
    private static void _ReleaseTypeNameParser(IntPtr pTypeNameParser);
    protected virtual bool ReleaseHandle();
}
[CLSCompliantAttribute("False")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[IsReadOnlyAttribute]
public class System.SByte : ValueType {
    private sbyte m_value;
    public static sbyte MaxValue;
    public static sbyte MinValue;
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(sbyte value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(sbyte obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public sealed virtual string ToString(IFormatProvider provider);
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public static sbyte Parse(string s);
    [CLSCompliantAttribute("False")]
[NullableContextAttribute("1")]
public static sbyte Parse(string s, NumberStyles style);
    [CLSCompliantAttribute("False")]
[NullableContextAttribute("1")]
public static sbyte Parse(string s, IFormatProvider provider);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public static sbyte Parse(string s, NumberStyles style, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static sbyte Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    private static sbyte Parse(ReadOnlySpan`1<char> s, NumberStyles style, NumberFormatInfo info);
    [CLSCompliantAttribute("False")]
[NullableContextAttribute("2")]
public static bool TryParse(string s, SByte& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<char> s, SByte& result);
    [CLSCompliantAttribute("False")]
[NullableContextAttribute("2")]
public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, SByte& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, SByte& result);
    private static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, NumberFormatInfo info, SByte& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[AttributeUsageAttribute("1")]
public class System.Security.AllowPartiallyTrustedCallersAttribute : Attribute {
    [CompilerGeneratedAttribute]
private PartialTrustVisibilityLevel <PartialTrustVisibilityLevel>k__BackingField;
    public PartialTrustVisibilityLevel PartialTrustVisibilityLevel { get; public set; }
    [CompilerGeneratedAttribute]
public PartialTrustVisibilityLevel get_PartialTrustVisibilityLevel();
    [CompilerGeneratedAttribute]
public void set_PartialTrustVisibilityLevel(PartialTrustVisibilityLevel value);
}
[NullableContextAttribute("1")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableAttribute("0")]
public class System.Security.Cryptography.CryptographicException : SystemException {
    public CryptographicException(int hr);
    [NullableContextAttribute("2")]
public CryptographicException(string message);
    [NullableContextAttribute("2")]
public CryptographicException(string message, Exception inner);
    public CryptographicException(string format, string insert);
    protected CryptographicException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("2")]
public interface System.Security.IPermission {
    [NullableContextAttribute("1")]
public abstract virtual IPermission Copy();
    public abstract virtual void Demand();
    public abstract virtual IPermission Intersect(IPermission target);
    public abstract virtual bool IsSubsetOf(IPermission target);
    public abstract virtual IPermission Union(IPermission target);
}
internal interface System.Security.ISecurityElementFactory {
    public abstract virtual SecurityElement CreateSecurityElement();
}
[NullableContextAttribute("1")]
public interface System.Security.ISecurityEncodable {
    public abstract virtual void FromXml(SecurityElement e);
    [NullableContextAttribute("2")]
public abstract virtual SecurityElement ToXml();
}
public interface System.Security.IStackWalk {
    public abstract virtual void Assert();
    public abstract virtual void Demand();
    public abstract virtual void Deny();
    public abstract virtual void PermitOnly();
}
public enum System.Security.PartialTrustVisibilityLevel : Enum {
    public int value__;
    public static PartialTrustVisibilityLevel VisibleToAllHosts;
    public static PartialTrustVisibilityLevel NotVisibleByDefault;
}
public enum System.Security.Permissions.PermissionState : Enum {
    public int value__;
    public static PermissionState None;
    public static PermissionState Unrestricted;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Security.PermissionSet : object {
    public int Count { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    [NullableAttribute("1")]
public object SyncRoot { get; }
    public PermissionSet(PermissionState state);
    public PermissionSet(PermissionSet permSet);
    public virtual int get_Count();
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsSynchronized();
    [NullableContextAttribute("1")]
public virtual object get_SyncRoot();
    public IPermission AddPermission(IPermission perm);
    protected virtual IPermission AddPermissionImpl(IPermission perm);
    public sealed virtual void Assert();
    public bool ContainsNonCodeAccessPermissions();
    [NullableContextAttribute("1")]
[ObsoleteAttribute]
public static Byte[] ConvertPermissionSet(string inFormat, Byte[] inData, string outFormat);
    [NullableContextAttribute("1")]
public virtual PermissionSet Copy();
    [NullableContextAttribute("1")]
public virtual void CopyTo(Array array, int index);
    public sealed virtual void Demand();
    [ObsoleteAttribute]
public sealed virtual void Deny();
    public virtual bool Equals(object o);
    [NullableContextAttribute("1")]
public virtual void FromXml(SecurityElement et);
    [NullableContextAttribute("1")]
public sealed virtual IEnumerator GetEnumerator();
    [NullableContextAttribute("1")]
protected virtual IEnumerator GetEnumeratorImpl();
    public virtual int GetHashCode();
    public IPermission GetPermission(Type permClass);
    protected virtual IPermission GetPermissionImpl(Type permClass);
    public PermissionSet Intersect(PermissionSet other);
    public bool IsEmpty();
    public bool IsSubsetOf(PermissionSet target);
    public bool IsUnrestricted();
    public sealed virtual void PermitOnly();
    public IPermission RemovePermission(Type permClass);
    protected virtual IPermission RemovePermissionImpl(Type permClass);
    public static void RevertAssert();
    public IPermission SetPermission(IPermission perm);
    protected virtual IPermission SetPermissionImpl(IPermission perm);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public virtual SecurityElement ToXml();
    public PermissionSet Union(PermissionSet other);
}
[NullableContextAttribute("2")]
public interface System.Security.Principal.IIdentity {
    public string Name { get; }
    public string AuthenticationType { get; }
    public bool IsAuthenticated { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_AuthenticationType();
    public abstract virtual bool get_IsAuthenticated();
}
[NullableContextAttribute("2")]
public interface System.Security.Principal.IPrincipal {
    public IIdentity Identity { get; }
    public abstract virtual IIdentity get_Identity();
    [NullableContextAttribute("1")]
public abstract virtual bool IsInRole(string role);
}
public enum System.Security.Principal.PrincipalPolicy : Enum {
    public int value__;
    public static PrincipalPolicy UnauthenticatedPrincipal;
    public static PrincipalPolicy NoPrincipal;
    public static PrincipalPolicy WindowsPrincipal;
}
internal class System.Security.SafeBSTRHandle : SafeBuffer {
    internal UInt32 Length { get; }
    internal static SafeBSTRHandle Allocate(UInt32 lenInChars);
    protected virtual bool ReleaseHandle();
    internal void ClearBuffer();
    internal UInt32 get_Length();
    internal static void Copy(SafeBSTRHandle source, SafeBSTRHandle target, UInt32 bytesToCopy);
}
public class System.Security.SecureString : object {
    private object _methodLock;
    private bool _readOnly;
    private int _decryptedLength;
    private SafeBSTRHandle _buffer;
    private bool _encrypted;
    public int Length { get; }
    [CLSCompliantAttribute("False")]
public SecureString(Char* value, int length);
    internal SecureString(SecureString str);
    public int get_Length();
    public void AppendChar(char c);
    public void Clear();
    [NullableContextAttribute("1")]
public SecureString Copy();
    public sealed virtual void Dispose();
    public void InsertAt(int index, char c);
    public bool IsReadOnly();
    public void MakeReadOnly();
    public void RemoveAt(int index);
    public void SetAt(int index, char c);
    private void EnsureNotReadOnly();
    private void EnsureNotDisposed();
    internal IntPtr MarshalToBSTR();
    internal IntPtr MarshalToString(bool globalAlloc, bool unicode);
    private static void MarshalFree(IntPtr ptr, bool globalAlloc);
    private void InitializeSecureString(Char* value, int length);
    private void AppendCharCore(char c);
    private void ClearCore();
    private void DisposeCore();
    private void InsertAtCore(int index, char c);
    private void RemoveAtCore(int index);
    private void SetAtCore(int index, char c);
    internal IntPtr MarshalToBSTRCore();
    internal IntPtr MarshalToStringCore(bool globalAlloc, bool unicode);
    private void AllocateBuffer(UInt32 size);
    private static UInt32 GetAlignedSize(UInt32 size);
    private void EnsureCapacity(int capacity);
    private void ProtectMemory();
    private void UnprotectMemory();
}
[AttributeUsageAttribute("5501")]
public class System.Security.SecurityCriticalAttribute : Attribute {
    [CompilerGeneratedAttribute]
private SecurityCriticalScope <Scope>k__BackingField;
    [ObsoleteAttribute("SecurityCriticalScope is only used for .NET 2.0 transparency compatibility.")]
public SecurityCriticalScope Scope { get; }
    public SecurityCriticalAttribute(SecurityCriticalScope scope);
    [CompilerGeneratedAttribute]
public SecurityCriticalScope get_Scope();
}
[ObsoleteAttribute("SecurityCriticalScope is only used for .NET 2.0 transparency compatibility.")]
public enum System.Security.SecurityCriticalScope : Enum {
    public int value__;
    public static SecurityCriticalScope Explicit;
    public static SecurityCriticalScope Everything;
}
[NullableAttribute("0")]
[NullableContextAttribute("2")]
public class System.Security.SecurityElement : object {
    internal string _tag;
    internal string _text;
    private ArrayList _children;
    internal ArrayList _attributes;
    private static Char[] s_tagIllegalCharacters;
    private static Char[] s_textIllegalCharacters;
    private static Char[] s_valueIllegalCharacters;
    private static Char[] s_escapeChars;
    private static String[] s_escapeStringPairs;
    [NullableAttribute("1")]
public string Tag { get; public set; }
    public Hashtable Attributes { get; public set; }
    public string Text { get; public set; }
    public ArrayList Children { get; public set; }
    [NullableContextAttribute("1")]
public SecurityElement(string tag);
    [NullableContextAttribute("1")]
public SecurityElement(string tag, string text);
    private static SecurityElement();
    [NullableContextAttribute("1")]
public string get_Tag();
    [NullableContextAttribute("1")]
public void set_Tag(string value);
    public Hashtable get_Attributes();
    public void set_Attributes(Hashtable value);
    public string get_Text();
    public void set_Text(string value);
    public ArrayList get_Children();
    public void set_Children(ArrayList value);
    internal void ConvertSecurityElementFactories();
    internal void AddAttributeSafe(string name, string value);
    [NullableContextAttribute("1")]
public void AddAttribute(string name, string value);
    [NullableContextAttribute("1")]
public void AddChild(SecurityElement child);
    public bool Equal(SecurityElement other);
    [NullableContextAttribute("1")]
public SecurityElement Copy();
    public static bool IsValidTag(string tag);
    public static bool IsValidText(string text);
    public static bool IsValidAttributeName(string name);
    public static bool IsValidAttributeValue(string value);
    private static string GetEscapeSequence(char c);
    public static string Escape(string str);
    private static string GetUnescapeSequence(string str, int index, Int32& newIndex);
    private static string Unescape(string str);
    [NullableContextAttribute("1")]
public virtual string ToString();
    private void ToString(string indent, object obj, Action`2<object, string> write);
    [NullableContextAttribute("1")]
public string Attribute(string name);
    [NullableContextAttribute("1")]
public SecurityElement SearchForChildByTag(string tag);
    [NullableContextAttribute("1")]
public string SearchForTextOfTag(string tag);
    [NullableContextAttribute("1")]
public static SecurityElement FromString(string xml);
    private sealed virtual override SecurityElement System.Security.ISecurityElementFactory.CreateSecurityElement();
}
[NullableAttribute("0")]
[NullableContextAttribute("2")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Security.SecurityException : SystemException {
    [CompilerGeneratedAttribute]
private object <Demanded>k__BackingField;
    [CompilerGeneratedAttribute]
private object <DenySetInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private AssemblyName <FailedAssemblyInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GrantedSet>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PermissionState>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <PermissionType>k__BackingField;
    [CompilerGeneratedAttribute]
private object <PermitOnlySetInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RefusedSet>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public object Demanded { get; public set; }
    public object DenySetInstance { get; public set; }
    public AssemblyName FailedAssemblyInfo { get; public set; }
    public string GrantedSet { get; public set; }
    public MethodInfo Method { get; public set; }
    public string PermissionState { get; public set; }
    public Type PermissionType { get; public set; }
    public object PermitOnlySetInstance { get; public set; }
    public string RefusedSet { get; public set; }
    public string Url { get; public set; }
    public SecurityException(string message);
    public SecurityException(string message, Exception inner);
    public SecurityException(string message, Type type);
    public SecurityException(string message, Type type, string state);
    [NullableContextAttribute("1")]
protected SecurityException(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public object get_Demanded();
    [CompilerGeneratedAttribute]
public void set_Demanded(object value);
    [CompilerGeneratedAttribute]
public object get_DenySetInstance();
    [CompilerGeneratedAttribute]
public void set_DenySetInstance(object value);
    [CompilerGeneratedAttribute]
public AssemblyName get_FailedAssemblyInfo();
    [CompilerGeneratedAttribute]
public void set_FailedAssemblyInfo(AssemblyName value);
    [CompilerGeneratedAttribute]
public string get_GrantedSet();
    [CompilerGeneratedAttribute]
public void set_GrantedSet(string value);
    [CompilerGeneratedAttribute]
public MethodInfo get_Method();
    [CompilerGeneratedAttribute]
public void set_Method(MethodInfo value);
    [CompilerGeneratedAttribute]
public string get_PermissionState();
    [CompilerGeneratedAttribute]
public void set_PermissionState(string value);
    [CompilerGeneratedAttribute]
public Type get_PermissionType();
    [CompilerGeneratedAttribute]
public void set_PermissionType(Type value);
    [CompilerGeneratedAttribute]
public object get_PermitOnlySetInstance();
    [CompilerGeneratedAttribute]
public void set_PermitOnlySetInstance(object value);
    [CompilerGeneratedAttribute]
public string get_RefusedSet();
    [CompilerGeneratedAttribute]
public void set_RefusedSet(string value);
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
}
[AttributeUsageAttribute("1")]
public class System.Security.SecurityRulesAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <SkipVerificationInFullTrust>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityRuleSet <RuleSet>k__BackingField;
    public bool SkipVerificationInFullTrust { get; public set; }
    public SecurityRuleSet RuleSet { get; }
    public SecurityRulesAttribute(SecurityRuleSet ruleSet);
    [CompilerGeneratedAttribute]
public bool get_SkipVerificationInFullTrust();
    [CompilerGeneratedAttribute]
public void set_SkipVerificationInFullTrust(bool value);
    [CompilerGeneratedAttribute]
public SecurityRuleSet get_RuleSet();
}
public enum System.Security.SecurityRuleSet : Enum {
    public byte value__;
    public static SecurityRuleSet None;
    public static SecurityRuleSet Level1;
    public static SecurityRuleSet Level2;
}
[AttributeUsageAttribute("5500")]
public class System.Security.SecuritySafeCriticalAttribute : Attribute {
}
[AttributeUsageAttribute("1")]
public class System.Security.SecurityTransparentAttribute : Attribute {
}
[AttributeUsageAttribute("5501")]
[ObsoleteAttribute("SecurityTreatAsSafe is only used for .NET 2.0 transparency compatibility.  Please use the SecuritySafeCriticalAttribute instead.")]
public class System.Security.SecurityTreatAsSafeAttribute : Attribute {
}
[AttributeUsageAttribute("5188")]
public class System.Security.SuppressUnmanagedCodeSecurityAttribute : Attribute {
}
[AttributeUsageAttribute("2")]
public class System.Security.UnverifiableCodeAttribute : Attribute {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Security.VerificationException : SystemException {
    public VerificationException(string message);
    public VerificationException(string message, Exception innerException);
    [NullableContextAttribute("1")]
protected VerificationException(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("4124")]
public class System.SerializableAttribute : Attribute {
}
internal class System.Signature : object {
    internal RuntimeType[] m_arguments;
    internal RuntimeType m_declaringType;
    internal RuntimeType m_returnTypeORfieldType;
    internal object m_keepalive;
    internal Void* m_sig;
    internal int m_managedCallingConventionAndArgIteratorFlags;
    internal int m_nSizeOfArgStack;
    internal int m_csig;
    internal RuntimeMethodHandleInternal m_pMethod;
    internal CallingConventions CallingConvention { get; }
    internal RuntimeType[] Arguments { get; }
    internal RuntimeType ReturnType { get; }
    internal RuntimeType FieldType { get; }
    public Signature(IRuntimeMethodInfo method, RuntimeType[] arguments, RuntimeType returnType, CallingConventions callingConvention);
    public Signature(IRuntimeMethodInfo methodHandle, RuntimeType declaringType);
    public Signature(IRuntimeFieldInfo fieldHandle, RuntimeType declaringType);
    public Signature(Void* pCorSig, int cCorSig, RuntimeType declaringType);
    private void GetSignature(Void* pCorSig, int cCorSig, RuntimeFieldHandleInternal fieldHandle, IRuntimeMethodInfo methodHandle, RuntimeType declaringType);
    internal CallingConventions get_CallingConvention();
    internal RuntimeType[] get_Arguments();
    internal RuntimeType get_ReturnType();
    internal RuntimeType get_FieldType();
    internal static bool CompareSig(Signature sig1, Signature sig2);
    internal Type[] GetCustomModifiers(int position, bool required);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[IsReadOnlyAttribute]
public class System.Single : ValueType {
    private float m_value;
    public static float MinValue;
    public static float Epsilon;
    public static float MaxValue;
    public static float PositiveInfinity;
    public static float NegativeInfinity;
    public static float NaN;
    [NonVersionableAttribute]
public static bool IsFinite(float f);
    [NonVersionableAttribute]
public static bool IsInfinity(float f);
    [NonVersionableAttribute]
public static bool IsNaN(float f);
    [NonVersionableAttribute]
public static bool IsNegative(float f);
    [NonVersionableAttribute]
public static bool IsNegativeInfinity(float f);
    [NonVersionableAttribute]
public static bool IsNormal(float f);
    [NonVersionableAttribute]
public static bool IsPositiveInfinity(float f);
    [NonVersionableAttribute]
public static bool IsSubnormal(float f);
    internal static int ExtractExponentFromBits(UInt32 bits);
    internal static UInt32 ExtractSignificandFromBits(UInt32 bits);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(float value);
    [NonVersionableAttribute]
public static bool op_Equality(float left, float right);
    [NonVersionableAttribute]
public static bool op_Inequality(float left, float right);
    [NonVersionableAttribute]
public static bool op_LessThan(float left, float right);
    [NonVersionableAttribute]
public static bool op_GreaterThan(float left, float right);
    [NonVersionableAttribute]
public static bool op_LessThanOrEqual(float left, float right);
    [NonVersionableAttribute]
public static bool op_GreaterThanOrEqual(float left, float right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(float obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public sealed virtual string ToString(IFormatProvider provider);
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static float Parse(string s);
    [NullableContextAttribute("1")]
public static float Parse(string s, NumberStyles style);
    [NullableContextAttribute("1")]
public static float Parse(string s, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static float Parse(string s, NumberStyles style, IFormatProvider provider);
    public static float Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, Single& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, Single& result);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Single& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Single& result);
    private static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, NumberFormatInfo info, Single& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[NullableContextAttribute("1")]
[DebuggerDisplayAttribute("{ToString(),raw}")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[NullableAttribute("0")]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[IsByRefLikeAttribute]
[DebuggerTypeProxyAttribute("System.SpanDebugView`1")]
[NonVersionableAttribute]
public class System.Span`1 : ValueType {
    internal ByReference`1<T> _pointer;
    private int _length;
    public int Length { get; }
    public bool IsEmpty { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Span`1<T> Empty { get; }
    public T& Item { get; }
    public Span`1(T[] array);
    public Span`1(T[] array, int start, int length);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public Span`1(Void* pointer, int length);
    internal Span`1(T& ptr, int length);
    [NonVersionableAttribute]
public int get_Length();
    [NonVersionableAttribute]
public bool get_IsEmpty();
    public static bool op_Inequality(Span`1<T> left, Span`1<T> right);
    [ObsoleteAttribute("Equals() on Span will always throw an exception. Use == instead.")]
[NullableContextAttribute("2")]
[EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("GetHashCode() on Span will always throw an exception.")]
[EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    public static Span`1<T> op_Implicit(T[] array);
    public static Span`1<T> op_Implicit(ArraySegment`1<T> segment);
    public static Span`1<T> get_Empty();
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    [IntrinsicAttribute]
[NonVersionableAttribute]
public T& get_Item(int index);
    [EditorBrowsableAttribute("1")]
public T& GetPinnableReference();
    public void Clear();
    public void Fill(T value);
    public void CopyTo(Span`1<T> destination);
    public bool TryCopyTo(Span`1<T> destination);
    public static bool op_Equality(Span`1<T> left, Span`1<T> right);
    public static ReadOnlySpan`1<T> op_Implicit(Span`1<T> span);
    public virtual string ToString();
    public Span`1<T> Slice(int start);
    public Span`1<T> Slice(int start, int length);
    public T[] ToArray();
}
internal class System.SpanDebugView`1 : object {
    private T[] _array;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public SpanDebugView`1(Span`1<T> span);
    public SpanDebugView`1(ReadOnlySpan`1<T> span);
    public T[] get_Items();
}
[ExtensionAttribute]
internal static class System.SpanHelpers : object {
    public static void ClearWithoutReferences(Byte& b, ulong byteLength);
    public static void ClearWithReferences(IntPtr& ip, ulong pointerSizeLength);
    [ExtensionAttribute]
public static int BinarySearch(ReadOnlySpan`1<T> span, TComparable comparable);
    public static int BinarySearch(T& spanStart, int length, TComparable comparable);
    public static int IndexOf(Byte& searchSpace, int searchSpaceLength, Byte& value, int valueLength);
    public static int IndexOfAny(Byte& searchSpace, int searchSpaceLength, Byte& value, int valueLength);
    public static int LastIndexOfAny(Byte& searchSpace, int searchSpaceLength, Byte& value, int valueLength);
    public static bool Contains(Byte& searchSpace, byte value, int length);
    public static int IndexOf(Byte& searchSpace, byte value, int length);
    public static int LastIndexOf(Byte& searchSpace, int searchSpaceLength, Byte& value, int valueLength);
    public static int LastIndexOf(Byte& searchSpace, byte value, int length);
    public static int IndexOfAny(Byte& searchSpace, byte value0, byte value1, int length);
    public static int IndexOfAny(Byte& searchSpace, byte value0, byte value1, byte value2, int length);
    public static int LastIndexOfAny(Byte& searchSpace, byte value0, byte value1, int length);
    public static int LastIndexOfAny(Byte& searchSpace, byte value0, byte value1, byte value2, int length);
    public static bool SequenceEqual(Byte& first, Byte& second, ulong length);
    private static int LocateFirstFoundByte(Vector`1<byte> match);
    public static int SequenceCompareTo(Byte& first, int firstLength, Byte& second, int secondLength);
    private static int LocateLastFoundByte(Vector`1<byte> match);
    private static int LocateFirstFoundByte(ulong match);
    private static int LocateLastFoundByte(ulong match);
    private static UIntPtr LoadUIntPtr(Byte& start, IntPtr offset);
    private static Vector`1<byte> LoadVector(Byte& start, IntPtr offset);
    private static Vector128`1<byte> LoadVector128(Byte& start, IntPtr offset);
    private static Vector256`1<byte> LoadVector256(Byte& start, IntPtr offset);
    private static IntPtr GetByteVectorSpanLength(IntPtr offset, int length);
    private static IntPtr GetByteVector128SpanLength(IntPtr offset, int length);
    private static IntPtr GetByteVector256SpanLength(IntPtr offset, int length);
    private static IntPtr UnalignedCountVector(Byte& searchSpace);
    private static IntPtr UnalignedCountVector128(Byte& searchSpace);
    private static IntPtr UnalignedCountVectorFromEnd(Byte& searchSpace, int length);
    public static int IndexOf(Char& searchSpace, int searchSpaceLength, Char& value, int valueLength);
    public static int SequenceCompareTo(Char& first, int firstLength, Char& second, int secondLength);
    public static bool Contains(Char& searchSpace, char value, int length);
    public static int IndexOf(Char& searchSpace, char value, int length);
    public static int IndexOfAny(Char& searchSpace, char value0, char value1, int length);
    public static int IndexOfAny(Char& searchSpace, char value0, char value1, char value2, int length);
    public static int IndexOfAny(Char& searchSpace, char value0, char value1, char value2, char value3, int length);
    public static int IndexOfAny(Char& searchSpace, char value0, char value1, char value2, char value3, char value4, int length);
    public static int LastIndexOf(Char& searchSpace, char value, int length);
    private static int LocateFirstFoundChar(Vector`1<ushort> match);
    private static int LocateFirstFoundChar(ulong match);
    private static int LocateLastFoundChar(Vector`1<ushort> match);
    private static int LocateLastFoundChar(ulong match);
    public static Char& Add(Char& source, long elementOffset);
    private static Vector`1<ushort> LoadVector(Char& start, long offset);
    private static Vector128`1<ushort> LoadVector128(Char& start, long offset);
    private static Vector256`1<ushort> LoadVector256(Char& start, long offset);
    private static long GetCharVectorSpanLength(long offset, long length);
    private static long GetCharVector128SpanLength(long offset, long length);
    private static long GetCharVector256SpanLength(long offset, long length);
    private static long UnalignedCountVector(Char& searchSpace);
    private static long UnalignedCountVector128(Char& searchSpace);
    public static int IndexOf(T& searchSpace, int searchSpaceLength, T& value, int valueLength);
    public static bool Contains(T& searchSpace, T value, int length);
    public static int IndexOf(T& searchSpace, T value, int length);
    public static int IndexOfAny(T& searchSpace, T value0, T value1, int length);
    public static int IndexOfAny(T& searchSpace, T value0, T value1, T value2, int length);
    public static int IndexOfAny(T& searchSpace, int searchSpaceLength, T& value, int valueLength);
    public static int LastIndexOf(T& searchSpace, int searchSpaceLength, T& value, int valueLength);
    public static int LastIndexOf(T& searchSpace, T value, int length);
    public static int LastIndexOfAny(T& searchSpace, T value0, T value1, int length);
    public static int LastIndexOfAny(T& searchSpace, T value0, T value1, T value2, int length);
    public static int LastIndexOfAny(T& searchSpace, int searchSpaceLength, T& value, int valueLength);
    public static bool SequenceEqual(T& first, T& second, int length);
    public static int SequenceCompareTo(T& first, int firstLength, T& second, int secondLength);
}
internal static class System.SR : object {
    private static object _lock;
    private static List`1<string> _currentlyLoading;
    private static int _infinitelyRecursingCount;
    private static bool _resourceManagerInited;
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string Acc_CreateAbstEx { get; }
    internal static string Acc_CreateArgIterator { get; }
    internal static string Acc_CreateGenericEx { get; }
    internal static string Acc_CreateInterfaceEx { get; }
    internal static string Acc_CreateVoid { get; }
    internal static string Acc_NotClassInit { get; }
    internal static string Acc_ReadOnly { get; }
    internal static string Access_Void { get; }
    internal static string AggregateException_ctor_DefaultMessage { get; }
    internal static string AggregateException_ctor_InnerExceptionNull { get; }
    internal static string AggregateException_DeserializationFailure { get; }
    internal static string AggregateException_InnerException { get; }
    internal static string AppDomain_Name { get; }
    internal static string AppDomain_NoContextPolicies { get; }
    internal static string AppDomain_Policy_PrincipalTwice { get; }
    internal static string AmbiguousImplementationException_NullMessage { get; }
    internal static string Arg_AccessException { get; }
    internal static string Arg_AccessViolationException { get; }
    internal static string Arg_AmbiguousMatchException { get; }
    internal static string Arg_ApplicationException { get; }
    internal static string Arg_ArgumentException { get; }
    internal static string Arg_ArgumentOutOfRangeException { get; }
    internal static string Arg_ArithmeticException { get; }
    internal static string Arg_ArrayLengthsDiffer { get; }
    internal static string Arg_ArrayPlusOffTooSmall { get; }
    internal static string Arg_ArrayTypeMismatchException { get; }
    internal static string Arg_ArrayZeroError { get; }
    internal static string Arg_BadDecimal { get; }
    internal static string Arg_BadImageFormatException { get; }
    internal static string Arg_BadLiteralFormat { get; }
    internal static string Arg_BogusIComparer { get; }
    internal static string Arg_BufferTooSmall { get; }
    internal static string Arg_CannotBeNaN { get; }
    internal static string Arg_CannotHaveNegativeValue { get; }
    internal static string Arg_CannotMixComparisonInfrastructure { get; }
    internal static string Arg_CannotUnloadAppDomainException { get; }
    internal static string Arg_CATypeResolutionFailed { get; }
    internal static string Arg_COMAccess { get; }
    internal static string Arg_COMException { get; }
    internal static string Arg_COMPropSetPut { get; }
    internal static string Arg_CreatInstAccess { get; }
    internal static string Arg_CryptographyException { get; }
    internal static string Arg_CustomAttributeFormatException { get; }
    internal static string Arg_DataMisalignedException { get; }
    internal static string Arg_DateTimeRange { get; }
    internal static string Arg_DecBitCtor { get; }
    internal static string Arg_DirectoryNotFoundException { get; }
    internal static string Arg_DivideByZero { get; }
    internal static string Arg_DlgtNullInst { get; }
    internal static string Arg_DlgtTargMeth { get; }
    internal static string Arg_DlgtTypeMis { get; }
    internal static string Arg_DllNotFoundException { get; }
    internal static string Arg_DuplicateWaitObjectException { get; }
    internal static string Arg_EHClauseNotClause { get; }
    internal static string Arg_EHClauseNotFilter { get; }
    internal static string Arg_EmptyArray { get; }
    internal static string Arg_EmptyOrNullString { get; }
    internal static string Arg_EndOfStreamException { get; }
    internal static string Arg_EntryPointNotFoundException { get; }
    internal static string Arg_EnumAndObjectMustBeSameType { get; }
    internal static string Arg_EnumFormatUnderlyingTypeAndObjectMustBeSameType { get; }
    internal static string Arg_EnumIllegalVal { get; }
    internal static string Arg_EnumLitValueNotFound { get; }
    internal static string Arg_EnumUnderlyingTypeAndObjectMustBeSameType { get; }
    internal static string Arg_EnumValueNotFound { get; }
    internal static string Arg_ExecutionEngineException { get; }
    internal static string Arg_ExternalException { get; }
    internal static string Arg_FieldAccessException { get; }
    internal static string Arg_FieldDeclTarget { get; }
    internal static string Arg_FldGetArgErr { get; }
    internal static string Arg_FldGetPropSet { get; }
    internal static string Arg_FldSetArgErr { get; }
    internal static string Arg_FldSetGet { get; }
    internal static string Arg_FldSetInvoke { get; }
    internal static string Arg_FldSetPropGet { get; }
    internal static string Arg_FormatException { get; }
    internal static string Arg_GenericParameter { get; }
    internal static string Arg_GetMethNotFnd { get; }
    internal static string Arg_GuidArrayCtor { get; }
    internal static string Arg_HandleNotAsync { get; }
    internal static string Arg_HandleNotSync { get; }
    internal static string Arg_HexStyleNotSupported { get; }
    internal static string Arg_HTCapacityOverflow { get; }
    internal static string Arg_IndexMustBeInt { get; }
    internal static string Arg_IndexOutOfRangeException { get; }
    internal static string Arg_InsufficientExecutionStackException { get; }
    internal static string Arg_InvalidANSIString { get; }
    internal static string Arg_InvalidBase { get; }
    internal static string Arg_InvalidCastException { get; }
    internal static string Arg_InvalidComObjectException { get; }
    internal static string Arg_InvalidFilterCriteriaException { get; }
    internal static string Arg_InvalidHandle { get; }
    internal static string Arg_InvalidHexStyle { get; }
    internal static string Arg_InvalidNeutralResourcesLanguage_Asm_Culture { get; }
    internal static string Arg_InvalidNeutralResourcesLanguage_FallbackLoc { get; }
    internal static string Arg_InvalidSatelliteContract_Asm_Ver { get; }
    internal static string Arg_InvalidOleVariantTypeException { get; }
    internal static string Arg_InvalidOperationException { get; }
    internal static string Arg_InvalidTypeInRetType { get; }
    internal static string Arg_InvalidTypeInSignature { get; }
    internal static string Arg_IOException { get; }
    internal static string Arg_KeyNotFound { get; }
    internal static string Arg_KeyNotFoundWithKey { get; }
    internal static string Arg_LongerThanSrcString { get; }
    internal static string Arg_LowerBoundsMustMatch { get; }
    internal static string Arg_MarshalAsAnyRestriction { get; }
    internal static string Arg_MarshalDirectiveException { get; }
    internal static string Arg_MethodAccessException { get; }
    internal static string Arg_MethodAccessException_WithMethodName { get; }
    internal static string Arg_MissingFieldException { get; }
    internal static string Arg_MissingManifestResourceException { get; }
    internal static string Arg_MissingMemberException { get; }
    internal static string Arg_MissingMethodException { get; }
    internal static string Arg_MulticastNotSupportedException { get; }
    internal static string Arg_MustBeBoolean { get; }
    internal static string Arg_MustBeByte { get; }
    internal static string Arg_MustBeChar { get; }
    internal static string Arg_MustBeDateTime { get; }
    internal static string Arg_MustBeDateTimeOffset { get; }
    internal static string Arg_MustBeDecimal { get; }
    internal static string Arg_MustBeDelegate { get; }
    internal static string Arg_MustBeDouble { get; }
    internal static string Arg_MustBeEnum { get; }
    internal static string Arg_MustBeEnumBaseTypeOrEnum { get; }
    internal static string Arg_MustBeGuid { get; }
    internal static string Arg_MustBeInt16 { get; }
    internal static string Arg_MustBeInt32 { get; }
    internal static string Arg_MustBeInt64 { get; }
    internal static string Arg_MustBePointer { get; }
    internal static string Arg_MustBePrimArray { get; }
    internal static string Arg_MustBeRuntimeAssembly { get; }
    internal static string Arg_MustBeSByte { get; }
    internal static string Arg_MustBeSingle { get; }
    internal static string Arg_MustBeString { get; }
    internal static string Arg_MustBeTimeSpan { get; }
    internal static string Arg_MustBeType { get; }
    internal static string Arg_MustBeTrue { get; }
    internal static string Arg_MustBeUInt16 { get; }
    internal static string Arg_MustBeUInt32 { get; }
    internal static string Arg_MustBeUInt64 { get; }
    internal static string Arg_MustBeVersion { get; }
    internal static string Arg_MustContainEnumInfo { get; }
    internal static string Arg_NamedParamNull { get; }
    internal static string Arg_NamedParamTooBig { get; }
    internal static string Arg_NDirectBadObject { get; }
    internal static string Arg_Need1DArray { get; }
    internal static string Arg_Need2DArray { get; }
    internal static string Arg_Need3DArray { get; }
    internal static string Arg_NeedAtLeast1Rank { get; }
    internal static string Arg_NegativeArgCount { get; }
    internal static string Arg_NoAccessSpec { get; }
    internal static string Arg_NoDefCTor { get; }
    internal static string Arg_NonZeroLowerBound { get; }
    internal static string Arg_NoStaticVirtual { get; }
    internal static string Arg_NotFiniteNumberException { get; }
    internal static string Arg_NotGenericMethodDefinition { get; }
    internal static string Arg_NotGenericParameter { get; }
    internal static string Arg_NotGenericTypeDefinition { get; }
    internal static string Arg_NotImplementedException { get; }
    internal static string Arg_NotSupportedException { get; }
    internal static string Arg_NullReferenceException { get; }
    internal static string Arg_ObjObjEx { get; }
    internal static string Arg_OleAutDateInvalid { get; }
    internal static string Arg_OleAutDateScale { get; }
    internal static string Arg_OverflowException { get; }
    internal static string Arg_ParamName_Name { get; }
    internal static string Arg_ParmArraySize { get; }
    internal static string Arg_ParmCnt { get; }
    internal static string Arg_PathEmpty { get; }
    internal static string Arg_PlatformNotSupported { get; }
    internal static string Arg_PropSetGet { get; }
    internal static string Arg_PropSetInvoke { get; }
    internal static string Arg_RankException { get; }
    internal static string Arg_RankIndices { get; }
    internal static string Arg_RankMultiDimNotSupported { get; }
    internal static string Arg_RanksAndBounds { get; }
    internal static string Arg_RegGetOverflowBug { get; }
    internal static string Arg_RegKeyNotFound { get; }
    internal static string Arg_RegSubKeyValueAbsent { get; }
    internal static string Arg_RegValStrLenBug { get; }
    internal static string Arg_ResMgrNotResSet { get; }
    internal static string Arg_ResourceFileUnsupportedVersion { get; }
    internal static string Arg_ResourceNameNotExist { get; }
    internal static string Arg_SafeArrayRankMismatchException { get; }
    internal static string Arg_SafeArrayTypeMismatchException { get; }
    internal static string Arg_SecurityException { get; }
    internal static string SerializationException { get; }
    internal static string Arg_SetMethNotFnd { get; }
    internal static string Arg_StackOverflowException { get; }
    internal static string Arg_SurrogatesNotAllowedAsSingleChar { get; }
    internal static string Arg_SynchronizationLockException { get; }
    internal static string Arg_SystemException { get; }
    internal static string Arg_TargetInvocationException { get; }
    internal static string Arg_TargetParameterCountException { get; }
    internal static string Arg_ThreadStartException { get; }
    internal static string Arg_ThreadStateException { get; }
    internal static string Arg_TimeoutException { get; }
    internal static string Arg_TypeAccessException { get; }
    internal static string Arg_TypedReference_Null { get; }
    internal static string Arg_TypeLoadException { get; }
    internal static string Arg_TypeLoadNullStr { get; }
    internal static string Arg_TypeRefPrimitve { get; }
    internal static string Arg_TypeUnloadedException { get; }
    internal static string Arg_UnauthorizedAccessException { get; }
    internal static string Arg_UnboundGenField { get; }
    internal static string Arg_UnboundGenParam { get; }
    internal static string Arg_UnknownTypeCode { get; }
    internal static string Arg_VarMissNull { get; }
    internal static string Arg_VersionString { get; }
    internal static string Arg_WrongAsyncResult { get; }
    internal static string Arg_WrongType { get; }
    internal static string Argument_AbsolutePathRequired { get; }
    internal static string Argument_AddingDuplicate { get; }
    internal static string Argument_AddingDuplicate__ { get; }
    internal static string Argument_AddingDuplicateWithKey { get; }
    internal static string Argument_AdjustmentRulesNoNulls { get; }
    internal static string Argument_AdjustmentRulesOutOfOrder { get; }
    internal static string Argument_AlreadyBoundOrSyncHandle { get; }
    internal static string Argument_ArrayGetInterfaceMap { get; }
    internal static string Argument_ArraysInvalid { get; }
    internal static string Argument_AttributeNamesMustBeUnique { get; }
    internal static string Argument_BadConstructor { get; }
    internal static string Argument_BadConstructorCallConv { get; }
    internal static string Argument_BadExceptionCodeGen { get; }
    internal static string Argument_BadFieldForConstructorBuilder { get; }
    internal static string Argument_BadFieldSig { get; }
    internal static string Argument_BadFieldType { get; }
    internal static string Argument_BadFormatSpecifier { get; }
    internal static string Argument_BadImageFormatExceptionResolve { get; }
    internal static string Argument_BadLabel { get; }
    internal static string Argument_BadLabelContent { get; }
    internal static string Argument_BadNestedTypeFlags { get; }
    internal static string Argument_BadParameterCountsForConstructor { get; }
    internal static string Argument_BadParameterTypeForCAB { get; }
    internal static string Argument_BadPropertyForConstructorBuilder { get; }
    internal static string Argument_BadSigFormat { get; }
    internal static string Argument_BadSizeForData { get; }
    internal static string Argument_BadTypeAttrInvalidLayout { get; }
    internal static string Argument_BadTypeAttrNestedVisibilityOnNonNestedType { get; }
    internal static string Argument_BadTypeAttrNonNestedVisibilityNestedType { get; }
    internal static string Argument_BadTypeAttrReservedBitsSet { get; }
    internal static string Argument_BadTypeInCustomAttribute { get; }
    internal static string Argument_CannotGetTypeTokenForByRef { get; }
    internal static string Argument_CannotSetParentToInterface { get; }
    internal static string Argument_CodepageNotSupported { get; }
    internal static string Argument_CompareOptionOrdinal { get; }
    internal static string Argument_ConflictingDateTimeRoundtripStyles { get; }
    internal static string Argument_ConflictingDateTimeStyles { get; }
    internal static string Argument_ConstantDoesntMatch { get; }
    internal static string Argument_ConstantNotSupported { get; }
    internal static string Argument_ConstantNull { get; }
    internal static string Argument_ConstructorNeedGenericDeclaringType { get; }
    internal static string Argument_ConversionOverflow { get; }
    internal static string Argument_ConvertMismatch { get; }
    internal static string Argument_CultureIetfNotSupported { get; }
    internal static string Argument_CultureInvalidIdentifier { get; }
    internal static string Argument_CultureIsNeutral { get; }
    internal static string Argument_CultureNotSupported { get; }
    internal static string Argument_CustomAssemblyLoadContextRequestedNameMismatch { get; }
    internal static string Argument_CustomCultureCannotBePassedByNumber { get; }
    internal static string Argument_DateTimeBadBinaryData { get; }
    internal static string Argument_DateTimeHasTicks { get; }
    internal static string Argument_DateTimeHasTimeOfDay { get; }
    internal static string Argument_DateTimeIsInvalid { get; }
    internal static string Argument_DateTimeIsNotAmbiguous { get; }
    internal static string Argument_DateTimeKindMustBeUnspecified { get; }
    internal static string Argument_DateTimeKindMustBeUnspecifiedOrUtc { get; }
    internal static string Argument_DateTimeOffsetInvalidDateTimeStyles { get; }
    internal static string Argument_DateTimeOffsetIsNotAmbiguous { get; }
    internal static string Argument_DestinationTooShort { get; }
    internal static string Argument_DuplicateTypeName { get; }
    internal static string Argument_EmitWriteLineType { get; }
    internal static string Argument_EmptyDecString { get; }
    internal static string Argument_EmptyName { get; }
    internal static string Argument_EmptyPath { get; }
    internal static string Argument_EmptyWaithandleArray { get; }
    internal static string Argument_EncoderFallbackNotEmpty { get; }
    internal static string Argument_EncodingConversionOverflowBytes { get; }
    internal static string Argument_EncodingConversionOverflowChars { get; }
    internal static string Argument_EncodingNotSupported { get; }
    internal static string Argument_EnumTypeDoesNotMatch { get; }
    internal static string Argument_FallbackBufferNotEmpty { get; }
    internal static string Argument_FieldDeclaringTypeGeneric { get; }
    internal static string Argument_FieldNeedGenericDeclaringType { get; }
    internal static string Argument_GenConstraintViolation { get; }
    internal static string Argument_GenericArgsCount { get; }
    internal static string Argument_GenericsInvalid { get; }
    internal static string Argument_GlobalFunctionHasToBeStatic { get; }
    internal static string Argument_HasToBeArrayClass { get; }
    internal static string Argument_IdnBadBidi { get; }
    internal static string Argument_IdnBadLabelSize { get; }
    internal static string Argument_IdnBadNameSize { get; }
    internal static string Argument_IdnBadPunycode { get; }
    internal static string Argument_IdnBadStd3 { get; }
    internal static string Argument_IdnIllegalName { get; }
    internal static string Argument_IllegalEnvVarName { get; }
    internal static string Argument_IllegalName { get; }
    internal static string Argument_ImplementIComparable { get; }
    internal static string Argument_IndexOutOfArrayBounds { get; }
    internal static string Argument_InsufficientSpaceToCopyCollection { get; }
    internal static string Argument_InvalidAppendMode { get; }
    internal static string Argument_InvalidArgumentForComparison { get; }
    internal static string Argument_InvalidArrayLength { get; }
    internal static string Argument_InvalidArrayType { get; }
    internal static string Argument_InvalidCalendar { get; }
    internal static string Argument_InvalidCharSequence { get; }
    internal static string Argument_InvalidCharSequenceNoIndex { get; }
    internal static string Argument_InvalidCodePageBytesIndex { get; }
    internal static string Argument_InvalidCodePageConversionIndex { get; }
    internal static string Argument_InvalidConstructorDeclaringType { get; }
    internal static string Argument_InvalidConstructorInfo { get; }
    internal static string Argument_InvalidCultureName { get; }
    internal static string Argument_InvalidDateTimeKind { get; }
    internal static string Argument_InvalidDateTimeStyles { get; }
    internal static string Argument_InvalidDigitSubstitution { get; }
    internal static string Argument_InvalidElementName { get; }
    internal static string Argument_InvalidElementTag { get; }
    internal static string Argument_InvalidElementText { get; }
    internal static string Argument_InvalidElementValue { get; }
    internal static string Argument_InvalidEnum { get; }
    internal static string Argument_InvalidEnumValue { get; }
    internal static string Argument_InvalidFieldDeclaringType { get; }
    internal static string Argument_InvalidFileModeAndAccessCombo { get; }
    internal static string Argument_InvalidFlag { get; }
    internal static string Argument_InvalidGenericInstArray { get; }
    internal static string Argument_InvalidGroupSize { get; }
    internal static string Argument_InvalidHandle { get; }
    internal static string Argument_InvalidHighSurrogate { get; }
    internal static string Argument_InvalidId { get; }
    internal static string Argument_InvalidKindOfTypeForCA { get; }
    internal static string Argument_InvalidLabel { get; }
    internal static string Argument_InvalidLowSurrogate { get; }
    internal static string Argument_InvalidMemberForNamedArgument { get; }
    internal static string Argument_InvalidMethodDeclaringType { get; }
    internal static string Argument_InvalidName { get; }
    internal static string Argument_InvalidNativeDigitCount { get; }
    internal static string Argument_InvalidNativeDigitValue { get; }
    internal static string Argument_InvalidNeutralRegionName { get; }
    internal static string Argument_InvalidNormalizationForm { get; }
    internal static string Argument_InvalidNumberStyles { get; }
    internal static string Argument_InvalidOffLen { get; }
    internal static string Argument_InvalidOpCodeOnDynamicMethod { get; }
    internal static string Argument_InvalidParameterInfo { get; }
    internal static string Argument_InvalidParamInfo { get; }
    internal static string Argument_InvalidPathChars { get; }
    internal static string Argument_InvalidResourceCultureName { get; }
    internal static string Argument_InvalidSafeBufferOffLen { get; }
    internal static string Argument_InvalidSeekOrigin { get; }
    internal static string Argument_InvalidSerializedString { get; }
    internal static string Argument_InvalidStartupHookSignature { get; }
    internal static string Argument_InvalidTimeSpanStyles { get; }
    internal static string Argument_InvalidToken { get; }
    internal static string Argument_InvalidTypeForCA { get; }
    internal static string Argument_InvalidTypeForDynamicMethod { get; }
    internal static string Argument_InvalidTypeName { get; }
    internal static string Argument_InvalidTypeWithPointersNotSupported { get; }
    internal static string Argument_InvalidUnity { get; }
    internal static string Argument_LargeInteger { get; }
    internal static string Argument_LongEnvVarValue { get; }
    internal static string Argument_MethodDeclaringTypeGeneric { get; }
    internal static string Argument_MethodDeclaringTypeGenericLcg { get; }
    internal static string Argument_MethodNeedGenericDeclaringType { get; }
    internal static string Argument_MinMaxValue { get; }
    internal static string Argument_MismatchedArrays { get; }
    internal static string Argument_MissingDefaultConstructor { get; }
    internal static string Argument_MustBeFalse { get; }
    internal static string Argument_MustBeRuntimeAssembly { get; }
    internal static string Argument_MustBeRuntimeFieldInfo { get; }
    internal static string Argument_MustBeRuntimeMethodInfo { get; }
    internal static string Argument_MustBeRuntimeReflectionObject { get; }
    internal static string Argument_MustBeRuntimeType { get; }
    internal static string Argument_MustBeTypeBuilder { get; }
    internal static string Argument_MustHaveAttributeBaseClass { get; }
    internal static string Argument_NativeOverlappedAlreadyFree { get; }
    internal static string Argument_NativeOverlappedWrongBoundHandle { get; }
    internal static string Argument_NeedGenericMethodDefinition { get; }
    internal static string Argument_NeedNonGenericType { get; }
    internal static string Argument_NeedStructWithNoRefs { get; }
    internal static string Argument_NeverValidGenericArgument { get; }
    internal static string Argument_NoEra { get; }
    internal static string Argument_NoRegionInvariantCulture { get; }
    internal static string Argument_NotAWritableProperty { get; }
    internal static string Argument_NotEnoughBytesToRead { get; }
    internal static string Argument_NotEnoughBytesToWrite { get; }
    internal static string Argument_NotEnoughGenArguments { get; }
    internal static string Argument_NotExceptionType { get; }
    internal static string Argument_NotInExceptionBlock { get; }
    internal static string Argument_NotMethodCallOpcode { get; }
    internal static string Argument_NotSerializable { get; }
    internal static string Argument_ObjIsWinRTObject { get; }
    internal static string Argument_ObjNotComObject { get; }
    internal static string Argument_OffsetAndCapacityOutOfBounds { get; }
    internal static string Argument_OffsetLocalMismatch { get; }
    internal static string Argument_OffsetOfFieldNotFound { get; }
    internal static string Argument_OffsetOutOfRange { get; }
    internal static string Argument_OffsetPrecision { get; }
    internal static string Argument_OffsetUtcMismatch { get; }
    internal static string Argument_OneOfCulturesNotSupported { get; }
    internal static string Argument_OnlyMscorlib { get; }
    internal static string Argument_OutOfOrderDateTimes { get; }
    internal static string Argument_PathEmpty { get; }
    internal static string Argument_PreAllocatedAlreadyAllocated { get; }
    internal static string Argument_RecursiveFallback { get; }
    internal static string Argument_RecursiveFallbackBytes { get; }
    internal static string Argument_RedefinedLabel { get; }
    internal static string Argument_ResolveField { get; }
    internal static string Argument_ResolveFieldHandle { get; }
    internal static string Argument_ResolveMember { get; }
    internal static string Argument_ResolveMethod { get; }
    internal static string Argument_ResolveMethodHandle { get; }
    internal static string Argument_ResolveModuleType { get; }
    internal static string Argument_ResolveString { get; }
    internal static string Argument_ResolveType { get; }
    internal static string Argument_ResultCalendarRange { get; }
    internal static string Argument_SemaphoreInitialMaximum { get; }
    internal static string Argument_ShouldNotSpecifyExceptionType { get; }
    internal static string Argument_ShouldOnlySetVisibilityFlags { get; }
    internal static string Argument_SigIsFinalized { get; }
    internal static string Argument_StreamNotReadable { get; }
    internal static string Argument_StreamNotWritable { get; }
    internal static string Argument_StringFirstCharIsZero { get; }
    internal static string Argument_StringZeroLength { get; }
    internal static string Argument_TimeSpanHasSeconds { get; }
    internal static string Argument_ToExclusiveLessThanFromExclusive { get; }
    internal static string Argument_TooManyFinallyClause { get; }
    internal static string Argument_TransitionTimesAreIdentical { get; }
    internal static string Argument_TypedReferenceInvalidField { get; }
    internal static string Argument_TypeIsWinRTType { get; }
    internal static string Argument_TypeMustNotBeComImport { get; }
    internal static string Argument_TypeNameTooLong { get; }
    internal static string Argument_TypeNotActivatableViaWindowsRuntime { get; }
    internal static string Argument_TypeNotComObject { get; }
    internal static string Argument_TypeNotValid { get; }
    internal static string Argument_UnclosedExceptionBlock { get; }
    internal static string Argument_Unexpected_TypeSource { get; }
    internal static string Argument_UnknownUnmanagedCallConv { get; }
    internal static string Argument_UnmanagedMemAccessorWrapAround { get; }
    internal static string Argument_UnmatchedMethodForLocal { get; }
    internal static string Argument_UnmatchingSymScope { get; }
    internal static string Argument_UTCOutOfRange { get; }
    internal static string Argument_WinRTSystemRuntimeType { get; }
    internal static string ArgumentException_BadMethodImplBody { get; }
    internal static string ArgumentException_BufferNotFromPool { get; }
    internal static string ArgumentException_OtherNotArrayOfCorrectLength { get; }
    internal static string ArgumentException_NotIsomorphic { get; }
    internal static string ArgumentException_TupleIncorrectType { get; }
    internal static string ArgumentException_TupleLastArgumentNotATuple { get; }
    internal static string ArgumentException_ValueTupleIncorrectType { get; }
    internal static string ArgumentException_ValueTupleLastArgumentNotAValueTuple { get; }
    internal static string ArgumentNull_Array { get; }
    internal static string ArgumentNull_ArrayElement { get; }
    internal static string ArgumentNull_ArrayValue { get; }
    internal static string ArgumentNull_Assembly { get; }
    internal static string ArgumentNull_AssemblyNameName { get; }
    internal static string ArgumentNull_Buffer { get; }
    internal static string ArgumentNull_Child { get; }
    internal static string ArgumentNull_Collection { get; }
    internal static string ArgumentNull_Dictionary { get; }
    internal static string ArgumentNull_Generic { get; }
    internal static string ArgumentNull_Key { get; }
    internal static string ArgumentNull_Path { get; }
    internal static string ArgumentNull_SafeHandle { get; }
    internal static string ArgumentNull_Stream { get; }
    internal static string ArgumentNull_String { get; }
    internal static string ArgumentNull_Type { get; }
    internal static string ArgumentNull_Waithandles { get; }
    internal static string ArgumentOutOfRange_ActualValue { get; }
    internal static string ArgumentOutOfRange_AddressSpace { get; }
    internal static string ArgumentOutOfRange_AddValue { get; }
    internal static string ArgumentOutOfRange_BadHourMinuteSecond { get; }
    internal static string ArgumentOutOfRange_BadYearMonthDay { get; }
    internal static string ArgumentOutOfRange_BiggerThanCollection { get; }
    internal static string ArgumentOutOfRange_BinaryReaderFillBuffer { get; }
    internal static string ArgumentOutOfRange_Bounds_Lower_Upper { get; }
    internal static string ArgumentOutOfRange_CalendarRange { get; }
    internal static string ArgumentOutOfRange_Capacity { get; }
    internal static string ArgumentOutOfRange_Count { get; }
    internal static string ArgumentOutOfRange_DateArithmetic { get; }
    internal static string ArgumentOutOfRange_DateTimeBadMonths { get; }
    internal static string ArgumentOutOfRange_DateTimeBadTicks { get; }
    internal static string ArgumentOutOfRange_DateTimeBadYears { get; }
    internal static string ArgumentOutOfRange_Day { get; }
    internal static string ArgumentOutOfRange_DayOfWeek { get; }
    internal static string ArgumentOutOfRange_DayParam { get; }
    internal static string ArgumentOutOfRange_DecimalRound { get; }
    internal static string ArgumentOutOfRange_DecimalScale { get; }
    internal static string ArgumentOutOfRange_EndIndexStartIndex { get; }
    internal static string ArgumentOutOfRange_Enum { get; }
    internal static string ArgumentOutOfRange_Era { get; }
    internal static string ArgumentOutOfRange_FileLengthTooBig { get; }
    internal static string ArgumentOutOfRange_FileTimeInvalid { get; }
    internal static string ArgumentOutOfRange_GenericPositive { get; }
    internal static string ArgumentOutOfRange_GetByteCountOverflow { get; }
    internal static string ArgumentOutOfRange_GetCharCountOverflow { get; }
    internal static string ArgumentOutOfRange_HashtableLoadFactor { get; }
    internal static string ArgumentOutOfRange_HugeArrayNotSupported { get; }
    internal static string ArgumentOutOfRange_Index { get; }
    internal static string ArgumentOutOfRange_IndexCount { get; }
    internal static string ArgumentOutOfRange_IndexCountBuffer { get; }
    internal static string ArgumentOutOfRange_IndexLargerThanMaxValue { get; }
    internal static string ArgumentOutOfRange_IndexLength { get; }
    internal static string ArgumentOutOfRange_IndexString { get; }
    internal static string ArgumentOutOfRange_InvalidEraValue { get; }
    internal static string ArgumentOutOfRange_InvalidHighSurrogate { get; }
    internal static string ArgumentOutOfRange_InvalidLowSurrogate { get; }
    internal static string ArgumentOutOfRange_InvalidUTF32 { get; }
    internal static string ArgumentOutOfRange_Length { get; }
    internal static string ArgumentOutOfRange_LengthGreaterThanCapacity { get; }
    internal static string ArgumentOutOfRange_LengthTooLarge { get; }
    internal static string ArgumentOutOfRange_LessEqualToIntegerMaxVal { get; }
    internal static string ArgumentOutOfRange_ListInsert { get; }
    internal static string ArgumentOutOfRange_Month { get; }
    internal static string ArgumentOutOfRange_MonthParam { get; }
    internal static string ArgumentOutOfRange_MustBeNonNegInt32 { get; }
    internal static string ArgumentOutOfRange_MustBeNonNegNum { get; }
    internal static string ArgumentOutOfRange_MustBePositive { get; }
    internal static string ArgumentOutOfRange_NeedNonNegNum { get; }
    internal static string ArgumentOutOfRange_NeedNonNegOrNegative1 { get; }
    internal static string ArgumentOutOfRange_NeedPosNum { get; }
    internal static string ArgumentOutOfRange_NeedValidId { get; }
    internal static string ArgumentOutOfRange_NegativeCapacity { get; }
    internal static string ArgumentOutOfRange_NegativeCount { get; }
    internal static string ArgumentOutOfRange_NegativeLength { get; }
    internal static string ArgumentOutOfRange_OffsetLength { get; }
    internal static string ArgumentOutOfRange_OffsetOut { get; }
    internal static string ArgumentOutOfRange_ParamSequence { get; }
    internal static string ArgumentOutOfRange_PartialWCHAR { get; }
    internal static string ArgumentOutOfRange_PeriodTooLarge { get; }
    internal static string ArgumentOutOfRange_PositionLessThanCapacityRequired { get; }
    internal static string ArgumentOutOfRange_Range { get; }
    internal static string ArgumentOutOfRange_RoundingDigits { get; }
    internal static string ArgumentOutOfRange_SmallCapacity { get; }
    internal static string ArgumentOutOfRange_SmallMaxCapacity { get; }
    internal static string ArgumentOutOfRange_StartIndex { get; }
    internal static string ArgumentOutOfRange_StartIndexLargerThanLength { get; }
    internal static string ArgumentOutOfRange_StartIndexLessThanLength { get; }
    internal static string ArgumentOutOfRange_StreamLength { get; }
    internal static string ArgumentOutOfRange_TimeoutTooLarge { get; }
    internal static string ArgumentOutOfRange_UIntPtrMax { get; }
    internal static string ArgumentOutOfRange_UnmanagedMemStreamLength { get; }
    internal static string ArgumentOutOfRange_UnmanagedMemStreamWrapAround { get; }
    internal static string ArgumentOutOfRange_UtcOffset { get; }
    internal static string ArgumentOutOfRange_UtcOffsetAndDaylightDelta { get; }
    internal static string ArgumentOutOfRange_Version { get; }
    internal static string ArgumentOutOfRange_Week { get; }
    internal static string ArgumentOutOfRange_Year { get; }
    internal static string Arithmetic_NaN { get; }
    internal static string AssemblyLoadContext_Unload_CannotUnloadIfNotCollectible { get; }
    internal static string AssemblyLoadContext_Verify_NotUnloading { get; }
    internal static string AssertionFailed { get; }
    internal static string AssertionFailed_Cnd { get; }
    internal static string AssumptionFailed { get; }
    internal static string AssumptionFailed_Cnd { get; }
    internal static string AsyncMethodBuilder_InstanceNotInitialized { get; }
    internal static string BadImageFormat_BadILFormat { get; }
    internal static string BadImageFormat_InvalidType { get; }
    internal static string BadImageFormat_NegativeStringLength { get; }
    internal static string BadImageFormat_ParameterSignatureMismatch { get; }
    internal static string BadImageFormat_ResType_SerBlobMismatch { get; }
    internal static string BadImageFormat_ResourceDataLengthInvalid { get; }
    internal static string BadImageFormat_ResourceNameCorrupted { get; }
    internal static string BadImageFormat_ResourceNameCorrupted_NameIndex { get; }
    internal static string BadImageFormat_ResourcesDataInvalidOffset { get; }
    internal static string BadImageFormat_ResourcesHeaderCorrupted { get; }
    internal static string BadImageFormat_ResourcesIndexTooLong { get; }
    internal static string BadImageFormat_ResourcesNameInvalidOffset { get; }
    internal static string BadImageFormat_ResourcesNameTooLong { get; }
    internal static string BadImageFormat_TypeMismatch { get; }
    internal static string CancellationToken_CreateLinkedToken_TokensIsEmpty { get; }
    internal static string CancellationTokenSource_Disposed { get; }
    internal static string ConcurrentCollection_SyncRoot_NotSupported { get; }
    internal static string EventSource_AbstractMustNotDeclareEventMethods { get; }
    internal static string EventSource_AbstractMustNotDeclareKTOC { get; }
    internal static string EventSource_AddScalarOutOfRange { get; }
    internal static string EventSource_BadHexDigit { get; }
    internal static string EventSource_ChannelTypeDoesNotMatchEventChannelValue { get; }
    internal static string EventSource_DataDescriptorsOutOfRange { get; }
    internal static string EventSource_DuplicateStringKey { get; }
    internal static string EventSource_EnumKindMismatch { get; }
    internal static string EventSource_EvenHexDigits { get; }
    internal static string EventSource_EventChannelOutOfRange { get; }
    internal static string EventSource_EventIdReused { get; }
    internal static string EventSource_EventMustHaveTaskIfNonDefaultOpcode { get; }
    internal static string EventSource_EventMustNotBeExplicitImplementation { get; }
    internal static string EventSource_EventNameReused { get; }
    internal static string EventSource_EventParametersMismatch { get; }
    internal static string EventSource_EventSourceGuidInUse { get; }
    internal static string EventSource_EventTooBig { get; }
    internal static string EventSource_EventWithAdminChannelMustHaveMessage { get; }
    internal static string EventSource_IllegalKeywordsValue { get; }
    internal static string EventSource_IllegalOpcodeValue { get; }
    internal static string EventSource_IllegalTaskValue { get; }
    internal static string EventSource_IllegalValue { get; }
    internal static string EventSource_IncorrentlyAuthoredTypeInfo { get; }
    internal static string EventSource_InvalidCommand { get; }
    internal static string EventSource_InvalidEventFormat { get; }
    internal static string EventSource_KeywordCollision { get; }
    internal static string EventSource_KeywordNeedPowerOfTwo { get; }
    internal static string EventSource_ListenerCreatedInsideCallback { get; }
    internal static string EventSource_ListenerNotFound { get; }
    internal static string EventSource_ListenerWriteFailure { get; }
    internal static string EventSource_MaxChannelExceeded { get; }
    internal static string EventSource_MismatchIdToWriteEvent { get; }
    internal static string EventSource_NeedGuid { get; }
    internal static string EventSource_NeedName { get; }
    internal static string EventSource_NeedPositiveId { get; }
    internal static string EventSource_NoFreeBuffers { get; }
    internal static string EventSource_NonCompliantTypeError { get; }
    internal static string EventSource_NoRelatedActivityId { get; }
    internal static string EventSource_NotSupportedArrayOfBinary { get; }
    internal static string EventSource_NotSupportedArrayOfNil { get; }
    internal static string EventSource_NotSupportedArrayOfNullTerminatedString { get; }
    internal static string EventSource_NotSupportedNestedArraysEnums { get; }
    internal static string EventSource_NullInput { get; }
    internal static string EventSource_OpcodeCollision { get; }
    internal static string EventSource_PinArrayOutOfRange { get; }
    internal static string EventSource_RecursiveTypeDefinition { get; }
    internal static string EventSource_StopsFollowStarts { get; }
    internal static string EventSource_TaskCollision { get; }
    internal static string EventSource_TaskOpcodePairReused { get; }
    internal static string EventSource_TooManyArgs { get; }
    internal static string EventSource_TooManyFields { get; }
    internal static string EventSource_ToString { get; }
    internal static string EventSource_TraitEven { get; }
    internal static string EventSource_TypeMustBeSealedOrAbstract { get; }
    internal static string EventSource_TypeMustDeriveFromEventSource { get; }
    internal static string EventSource_UndefinedChannel { get; }
    internal static string EventSource_UndefinedKeyword { get; }
    internal static string EventSource_UndefinedOpcode { get; }
    internal static string EventSource_UnknownEtwTrait { get; }
    internal static string EventSource_UnsupportedEventTypeInManifest { get; }
    internal static string EventSource_UnsupportedMessageProperty { get; }
    internal static string EventSource_VarArgsParameterMismatch { get; }
    internal static string Exception_EndOfInnerExceptionStack { get; }
    internal static string Exception_EndStackTraceFromPreviousThrow { get; }
    internal static string Exception_WasThrown { get; }
    internal static string ExecutionContext_ExceptionInAsyncLocalNotification { get; }
    internal static string FileNotFound_ResolveAssembly { get; }
    internal static string Format_AttributeUsage { get; }
    internal static string Format_Bad7BitInt32 { get; }
    internal static string Format_BadBase64Char { get; }
    internal static string Format_BadBoolean { get; }
    internal static string Format_BadFormatSpecifier { get; }
    internal static string Format_NoFormatSpecifier { get; }
    internal static string Format_BadQuote { get; }
    internal static string Format_BadTimeSpan { get; }
    internal static string Format_EmptyInputString { get; }
    internal static string Format_ExtraJunkAtEnd { get; }
    internal static string Format_GuidUnrecognized { get; }
    internal static string Format_IndexOutOfRange { get; }
    internal static string Format_InvalidEnumFormatSpecification { get; }
    internal static string Format_InvalidGuidFormatSpecification { get; }
    internal static string Format_InvalidString { get; }
    internal static string Format_NeedSingleChar { get; }
    internal static string Format_NoParsibleDigits { get; }
    internal static string Format_StringZeroLength { get; }
    internal static string IndexOutOfRange_UMSPosition { get; }
    internal static string InsufficientMemory_MemFailPoint { get; }
    internal static string InsufficientMemory_MemFailPoint_TooBig { get; }
    internal static string InsufficientMemory_MemFailPoint_VAFrag { get; }
    internal static string Interop_COM_TypeMismatch { get; }
    internal static string Interop_Marshal_Unmappable_Char { get; }
    internal static string InvalidCast_CannotCastNullToValueType { get; }
    internal static string InvalidCast_CannotCoerceByRefVariant { get; }
    internal static string InvalidCast_DBNull { get; }
    internal static string InvalidCast_Empty { get; }
    internal static string InvalidCast_FromDBNull { get; }
    internal static string InvalidCast_FromTo { get; }
    internal static string InvalidCast_IConvertible { get; }
    internal static string InvalidCast_WinRTIPropertyValueArrayCoersion { get; }
    internal static string InvalidCast_WinRTIPropertyValueCoersion { get; }
    internal static string InvalidCast_WinRTIPropertyValueElement { get; }
    internal static string InvalidOperation_AsyncFlowCtrlCtxMismatch { get; }
    internal static string InvalidOperation_AsyncIOInProgress { get; }
    internal static string InvalidOperation_BadEmptyMethodBody { get; }
    internal static string InvalidOperation_BadILGeneratorUsage { get; }
    internal static string InvalidOperation_BadInstructionOrIndexOutOfBound { get; }
    internal static string InvalidOperation_BadInterfaceNotAbstract { get; }
    internal static string InvalidOperation_BadMethodBody { get; }
    internal static string InvalidOperation_BadTypeAttributesNotAbstract { get; }
    internal static string InvalidOperation_CalledTwice { get; }
    internal static string InvalidOperation_CannotImportGlobalFromDifferentModule { get; }
    internal static string InvalidOperation_CannotRegisterSecondResolver { get; }
    internal static string InvalidOperation_CannotRemoveLastFromEmptyCollection { get; }
    internal static string InvalidOperation_CannotRestoreUnsupressedFlow { get; }
    internal static string InvalidOperation_CannotSupressFlowMultipleTimes { get; }
    internal static string InvalidOperation_CannotUseAFCMultiple { get; }
    internal static string InvalidOperation_CannotUseAFCOtherThread { get; }
    internal static string InvalidOperation_CollectionBackingDictionaryTooLarge { get; }
    internal static string InvalidOperation_CollectionBackingListTooLarge { get; }
    internal static string InvalidOperation_CollectionCorrupted { get; }
    internal static string InvalidOperation_ComputerName { get; }
    internal static string InvalidOperation_ConcurrentOperationsNotSupported { get; }
    internal static string InvalidOperation_ConstructorNotAllowedOnInterface { get; }
    internal static string InvalidOperation_DateTimeParsing { get; }
    internal static string InvalidOperation_DefaultConstructorILGen { get; }
    internal static string InvalidOperation_EndReadCalledMultiple { get; }
    internal static string InvalidOperation_EndWriteCalledMultiple { get; }
    internal static string InvalidOperation_EnumEnded { get; }
    internal static string InvalidOperation_EnumFailedVersion { get; }
    internal static string InvalidOperation_EnumNotStarted { get; }
    internal static string InvalidOperation_EnumOpCantHappen { get; }
    internal static string InvalidOperation_EventInfoNotAvailable { get; }
    internal static string InvalidOperation_EventTokenTableRequiresDelegate { get; }
    internal static string InvalidOperation_GenericParametersAlreadySet { get; }
    internal static string InvalidOperation_GetVersion { get; }
    internal static string InvalidOperation_GlobalsHaveBeenCreated { get; }
    internal static string InvalidOperation_HandleIsNotInitialized { get; }
    internal static string InvalidOperation_HandleIsNotPinned { get; }
    internal static string InvalidOperation_HashInsertFailed { get; }
    internal static string InvalidOperation_IComparerFailed { get; }
    internal static string InvalidOperation_MethodBaked { get; }
    internal static string InvalidOperation_MethodBuilderBaked { get; }
    internal static string InvalidOperation_MethodHasBody { get; }
    internal static string InvalidOperation_MustCallInitialize { get; }
    internal static string InvalidOperation_NativeOverlappedReused { get; }
    internal static string InvalidOperation_NoMultiModuleAssembly { get; }
    internal static string InvalidOperation_NoPublicAddMethod { get; }
    internal static string InvalidOperation_NoPublicRemoveMethod { get; }
    internal static string InvalidOperation_NotADebugModule { get; }
    internal static string InvalidOperation_NotAllowedInDynamicMethod { get; }
    internal static string InvalidOperation_NotAVarArgCallingConvention { get; }
    internal static string InvalidOperation_NotGenericType { get; }
    internal static string InvalidOperation_NotSupportedOnWinRTEvent { get; }
    internal static string InvalidOperation_NotWithConcurrentGC { get; }
    internal static string InvalidOperation_NoUnderlyingTypeOnEnum { get; }
    internal static string InvalidOperation_NoValue { get; }
    internal static string InvalidOperation_NullArray { get; }
    internal static string InvalidOperation_NullContext { get; }
    internal static string InvalidOperation_NullModuleHandle { get; }
    internal static string InvalidOperation_OpenLocalVariableScope { get; }
    internal static string InvalidOperation_Overlapped_Pack { get; }
    internal static string InvalidOperation_PropertyInfoNotAvailable { get; }
    internal static string InvalidOperation_ReadOnly { get; }
    internal static string InvalidOperation_ResMgrBadResSet_Type { get; }
    internal static string InvalidOperation_ResourceNotStream_Name { get; }
    internal static string InvalidOperation_ResourceNotString_Name { get; }
    internal static string InvalidOperation_ResourceNotString_Type { get; }
    internal static string InvalidOperation_SetLatencyModeNoGC { get; }
    internal static string InvalidOperation_ShouldNotHaveMethodBody { get; }
    internal static string InvalidOperation_ThreadWrongThreadStart { get; }
    internal static string InvalidOperation_TimeoutsNotSupported { get; }
    internal static string InvalidOperation_TimerAlreadyClosed { get; }
    internal static string InvalidOperation_TypeHasBeenCreated { get; }
    internal static string InvalidOperation_TypeNotCreated { get; }
    internal static string InvalidOperation_UnderlyingArrayListChanged { get; }
    internal static string InvalidOperation_UnknownEnumType { get; }
    internal static string InvalidOperation_WriteOnce { get; }
    internal static string InvalidOperation_WrongAsyncResultOrEndCalledMultiple { get; }
    internal static string InvalidOperation_WrongAsyncResultOrEndReadCalledMultiple { get; }
    internal static string InvalidOperation_WrongAsyncResultOrEndWriteCalledMultiple { get; }
    internal static string InvalidProgram_Default { get; }
    internal static string InvalidTimeZone_InvalidRegistryData { get; }
    internal static string InvariantFailed { get; }
    internal static string InvariantFailed_Cnd { get; }
    internal static string IO_EOF_ReadBeyondEOF { get; }
    internal static string IO_FileLoad { get; }
    internal static string IO_FileName_Name { get; }
    internal static string IO_FileNotFound { get; }
    internal static string IO_FileNotFound_FileName { get; }
    internal static string IO_AlreadyExists_Name { get; }
    internal static string IO_BindHandleFailed { get; }
    internal static string IO_FileExists_Name { get; }
    internal static string IO_FileStreamHandlePosition { get; }
    internal static string IO_FileTooLongOrHandleNotSync { get; }
    internal static string IO_FixedCapacity { get; }
    internal static string IO_InvalidStringLen_Len { get; }
    internal static string IO_SeekAppendOverwrite { get; }
    internal static string IO_SeekBeforeBegin { get; }
    internal static string IO_SetLengthAppendTruncate { get; }
    internal static string IO_SharingViolation_File { get; }
    internal static string IO_SharingViolation_NoFileName { get; }
    internal static string IO_StreamTooLong { get; }
    internal static string IO_PathNotFound_NoPathName { get; }
    internal static string IO_PathNotFound_Path { get; }
    internal static string IO_PathTooLong { get; }
    internal static string IO_PathTooLong_Path { get; }
    internal static string IO_UnknownFileName { get; }
    internal static string Lazy_CreateValue_NoParameterlessCtorForT { get; }
    internal static string Lazy_ctor_ModeInvalid { get; }
    internal static string Lazy_StaticInit_InvalidOperation { get; }
    internal static string Lazy_ToString_ValueNotCreated { get; }
    internal static string Lazy_Value_RecursiveCallsToValue { get; }
    internal static string ManualResetEventSlim_ctor_SpinCountOutOfRange { get; }
    internal static string ManualResetEventSlim_ctor_TooManyWaiters { get; }
    internal static string ManualResetEventSlim_Disposed { get; }
    internal static string Marshaler_StringTooLong { get; }
    internal static string MissingConstructor_Name { get; }
    internal static string MissingField { get; }
    internal static string MissingField_Name { get; }
    internal static string MissingManifestResource_MultipleBlobs { get; }
    internal static string MissingManifestResource_NoNeutralAsm { get; }
    internal static string MissingManifestResource_NoNeutralDisk { get; }
    internal static string MissingManifestResource_NoPRIresources { get; }
    internal static string MissingManifestResource_ResWFileNotLoaded { get; }
    internal static string MissingMember { get; }
    internal static string MissingMember_Name { get; }
    internal static string MissingMemberNestErr { get; }
    internal static string MissingMemberTypeRef { get; }
    internal static string MissingMethod_Name { get; }
    internal static string MissingSatelliteAssembly_Culture_Name { get; }
    internal static string MissingSatelliteAssembly_Default { get; }
    internal static string Multicast_Combine { get; }
    internal static string MustUseCCRewrite { get; }
    internal static string NotSupported_AbstractNonCLS { get; }
    internal static string NotSupported_ActivAttr { get; }
    internal static string NotSupported_AppX { get; }
    internal static string NotSupported_AssemblyLoadFromHash { get; }
    internal static string NotSupported_ByRefToByRefLikeReturn { get; }
    internal static string NotSupported_ByRefToVoidReturn { get; }
    internal static string NotSupported_CallToVarArg { get; }
    internal static string NotSupported_CannotCallEqualsOnSpan { get; }
    internal static string NotSupported_CannotCallGetHashCodeOnSpan { get; }
    internal static string NotSupported_ChangeType { get; }
    internal static string NotSupported_CreateInstanceWithTypeBuilder { get; }
    internal static string NotSupported_DBNullSerial { get; }
    internal static string NotSupported_DynamicAssembly { get; }
    internal static string NotSupported_DynamicMethodFlags { get; }
    internal static string NotSupported_DynamicModule { get; }
    internal static string NotSupported_FileStreamOnNonFiles { get; }
    internal static string NotSupported_FixedSizeCollection { get; }
    internal static string InvalidOperation_SpanOverlappedOperation { get; }
    internal static string NotSupported_IllegalOneByteBranch { get; }
    internal static string NotSupported_KeyCollectionSet { get; }
    internal static string NotSupported_MaxWaitHandles { get; }
    internal static string NotSupported_MemStreamNotExpandable { get; }
    internal static string NotSupported_MustBeModuleBuilder { get; }
    internal static string NotSupported_NoCodepageData { get; }
    internal static string NotSupported_NonReflectedType { get; }
    internal static string NotSupported_NoParentDefaultConstructor { get; }
    internal static string NotSupported_NoTypeInfo { get; }
    internal static string NotSupported_NYI { get; }
    internal static string NotSupported_ObsoleteResourcesFile { get; }
    internal static string NotSupported_OutputStreamUsingTypeBuilder { get; }
    internal static string NotSupported_RangeCollection { get; }
    internal static string NotSupported_Reading { get; }
    internal static string NotSupported_ReadOnlyCollection { get; }
    internal static string NotSupported_ResourceObjectSerialization { get; }
    internal static string NotSupported_StringComparison { get; }
    internal static string NotSupported_SubclassOverride { get; }
    internal static string NotSupported_SymbolMethod { get; }
    internal static string NotSupported_Type { get; }
    internal static string NotSupported_TypeNotYetCreated { get; }
    internal static string NotSupported_UmsSafeBuffer { get; }
    internal static string NotSupported_UnitySerHolder { get; }
    internal static string NotSupported_UnknownTypeCode { get; }
    internal static string NotSupported_UnreadableStream { get; }
    internal static string NotSupported_UnseekableStream { get; }
    internal static string NotSupported_UnwritableStream { get; }
    internal static string NotSupported_ValueCollectionSet { get; }
    internal static string NotSupported_Writing { get; }
    internal static string NotSupported_WrongResourceReader_Type { get; }
    internal static string ObjectDisposed_FileClosed { get; }
    internal static string ObjectDisposed_Generic { get; }
    internal static string ObjectDisposed_ObjectName_Name { get; }
    internal static string ObjectDisposed_WriterClosed { get; }
    internal static string ObjectDisposed_ReaderClosed { get; }
    internal static string ObjectDisposed_ResourceSet { get; }
    internal static string ObjectDisposed_StreamClosed { get; }
    internal static string ObjectDisposed_ViewAccessorClosed { get; }
    internal static string ObjectDisposed_SafeHandleClosed { get; }
    internal static string OperationCanceled { get; }
    internal static string Overflow_Byte { get; }
    internal static string Overflow_Char { get; }
    internal static string Overflow_Currency { get; }
    internal static string Overflow_Decimal { get; }
    internal static string Overflow_Duration { get; }
    internal static string Overflow_Int16 { get; }
    internal static string Overflow_Int32 { get; }
    internal static string Overflow_Int64 { get; }
    internal static string Overflow_NegateTwosCompNum { get; }
    internal static string Overflow_NegativeUnsigned { get; }
    internal static string Overflow_SByte { get; }
    internal static string Overflow_TimeSpanElementTooLarge { get; }
    internal static string Overflow_TimeSpanTooLong { get; }
    internal static string Overflow_UInt16 { get; }
    internal static string Overflow_UInt32 { get; }
    internal static string Overflow_UInt64 { get; }
    internal static string PlatformNotSupported_ReflectionOnly { get; }
    internal static string PlatformNotSupported_Remoting { get; }
    internal static string PlatformNotSupported_SecureBinarySerialization { get; }
    internal static string PlatformNotSupported_StrongNameSigning { get; }
    internal static string PlatformNotSupported_WinRT { get; }
    internal static string PlatformNotSupported_ITypeInfo { get; }
    internal static string PlatformNotSupported_IExpando { get; }
    internal static string PlatformNotSupported_AppDomains { get; }
    internal static string PlatformNotSupported_CAS { get; }
    internal static string PlatformNotSupported_Principal { get; }
    internal static string PlatformNotSupported_ThreadAbort { get; }
    internal static string PlatformNotSupported_ThreadSuspend { get; }
    internal static string PostconditionFailed { get; }
    internal static string PostconditionFailed_Cnd { get; }
    internal static string PostconditionOnExceptionFailed { get; }
    internal static string PostconditionOnExceptionFailed_Cnd { get; }
    internal static string PreconditionFailed { get; }
    internal static string PreconditionFailed_Cnd { get; }
    internal static string Rank_MultiDimNotSupported { get; }
    internal static string ResourceReaderIsClosed { get; }
    internal static string Resources_StreamNotValid { get; }
    internal static string RFLCT_AmbigCust { get; }
    internal static string RFLCT_Ambiguous { get; }
    internal static string InvalidFilterCriteriaException_CritInt { get; }
    internal static string InvalidFilterCriteriaException_CritString { get; }
    internal static string RFLCT_InvalidFieldFail { get; }
    internal static string RFLCT_InvalidPropFail { get; }
    internal static string RFLCT_Targ_ITargMismatch { get; }
    internal static string RFLCT_Targ_StatFldReqTarg { get; }
    internal static string RFLCT_Targ_StatMethReqTarg { get; }
    internal static string RuntimeWrappedException { get; }
    internal static string Security_CannotReadRegistryData { get; }
    internal static string Security_RegistryPermission { get; }
    internal static string SemaphoreSlim_ctor_InitialCountWrong { get; }
    internal static string SemaphoreSlim_ctor_MaxCountWrong { get; }
    internal static string SemaphoreSlim_Disposed { get; }
    internal static string SemaphoreSlim_Release_CountWrong { get; }
    internal static string SemaphoreSlim_Wait_TimeoutWrong { get; }
    internal static string Serialization_BadParameterInfo { get; }
    internal static string Serialization_CorruptField { get; }
    internal static string Serialization_DateTimeTicksOutOfRange { get; }
    internal static string Serialization_DelegatesNotSupported { get; }
    internal static string Serialization_InsufficientState { get; }
    internal static string Serialization_InvalidData { get; }
    internal static string Serialization_InvalidEscapeSequence { get; }
    internal static string Serialization_InvalidOnDeser { get; }
    internal static string Serialization_InvalidPtrValue { get; }
    internal static string Serialization_InvalidType { get; }
    internal static string Serialization_KeyValueDifferentSizes { get; }
    internal static string Serialization_MissingDateTimeData { get; }
    internal static string Serialization_MissingKeys { get; }
    internal static string Serialization_MissingValues { get; }
    internal static string Serialization_NoParameterInfo { get; }
    internal static string Serialization_NotFound { get; }
    internal static string Serialization_NullKey { get; }
    internal static string Serialization_OptionalFieldVersionValue { get; }
    internal static string Serialization_SameNameTwice { get; }
    internal static string Serialization_StringBuilderCapacity { get; }
    internal static string Serialization_StringBuilderMaxCapacity { get; }
    internal static string SpinLock_Exit_SynchronizationLockException { get; }
    internal static string SpinLock_IsHeldByCurrentThread { get; }
    internal static string SpinLock_TryEnter_ArgumentOutOfRange { get; }
    internal static string SpinLock_TryEnter_LockRecursionException { get; }
    internal static string SpinLock_TryReliableEnter_ArgumentException { get; }
    internal static string SpinWait_SpinUntil_ArgumentNull { get; }
    internal static string SpinWait_SpinUntil_TimeoutWrong { get; }
    internal static string StackTrace_InFileLineNumber { get; }
    internal static string Task_ContinueWith_ESandLR { get; }
    internal static string Task_ContinueWith_NotOnAnything { get; }
    internal static string Task_Delay_InvalidDelay { get; }
    internal static string Task_Delay_InvalidMillisecondsDelay { get; }
    internal static string Task_Dispose_NotCompleted { get; }
    internal static string Task_FromAsync_LongRunning { get; }
    internal static string Task_FromAsync_PreferFairness { get; }
    internal static string Task_MultiTaskContinuation_EmptyTaskList { get; }
    internal static string Task_MultiTaskContinuation_FireOptions { get; }
    internal static string Task_MultiTaskContinuation_NullTask { get; }
    internal static string Task_RunSynchronously_AlreadyStarted { get; }
    internal static string Task_RunSynchronously_Continuation { get; }
    internal static string Task_RunSynchronously_Promise { get; }
    internal static string Task_RunSynchronously_TaskCompleted { get; }
    internal static string Task_Start_AlreadyStarted { get; }
    internal static string Task_Start_ContinuationTask { get; }
    internal static string Task_Start_Promise { get; }
    internal static string Task_Start_TaskCompleted { get; }
    internal static string Task_ThrowIfDisposed { get; }
    internal static string Task_WaitMulti_NullTask { get; }
    internal static string TaskCanceledException_ctor_DefaultMessage { get; }
    internal static string TaskCompletionSourceT_TrySetException_NoExceptions { get; }
    internal static string TaskCompletionSourceT_TrySetException_NullException { get; }
    internal static string TaskExceptionHolder_UnhandledException { get; }
    internal static string TaskExceptionHolder_UnknownExceptionType { get; }
    internal static string TaskScheduler_ExecuteTask_WrongTaskScheduler { get; }
    internal static string TaskScheduler_FromCurrentSynchronizationContext_NoCurrent { get; }
    internal static string TaskScheduler_InconsistentStateAfterTryExecuteTaskInline { get; }
    internal static string TaskSchedulerException_ctor_DefaultMessage { get; }
    internal static string TaskT_DebuggerNoResult { get; }
    internal static string TaskT_TransitionToFinal_AlreadyCompleted { get; }
    internal static string Thread_ApartmentState_ChangeFailed { get; }
    internal static string Thread_GetSetCompressedStack_NotSupported { get; }
    internal static string Thread_Operation_RequiresCurrentThread { get; }
    internal static string Threading_AbandonedMutexException { get; }
    internal static string Threading_WaitHandleCannotBeOpenedException { get; }
    internal static string Threading_WaitHandleCannotBeOpenedException_InvalidHandle { get; }
    internal static string Threading_WaitHandleTooManyPosts { get; }
    internal static string Threading_SemaphoreFullException { get; }
    internal static string ThreadLocal_Disposed { get; }
    internal static string ThreadLocal_Value_RecursiveCallsToValue { get; }
    internal static string ThreadLocal_ValuesNotAvailable { get; }
    internal static string TimeZoneNotFound_MissingData { get; }
    internal static string TypeInitialization_Default { get; }
    internal static string TypeInitialization_Type { get; }
    internal static string TypeLoad_ResolveNestedType { get; }
    internal static string TypeLoad_ResolveType { get; }
    internal static string TypeLoad_ResolveTypeFromAssembly { get; }
    internal static string UnauthorizedAccess_IODenied_NoPathName { get; }
    internal static string UnauthorizedAccess_IODenied_Path { get; }
    internal static string UnauthorizedAccess_MemStreamBuffer { get; }
    internal static string UnauthorizedAccess_RegistryKeyGeneric_Key { get; }
    internal static string UnknownError_Num { get; }
    internal static string Verification_Exception { get; }
    internal static string Word_At { get; }
    internal static string DebugAssertBanner { get; }
    internal static string DebugAssertLongMessage { get; }
    internal static string DebugAssertShortMessage { get; }
    internal static string LockRecursionException_ReadAfterWriteNotAllowed { get; }
    internal static string LockRecursionException_RecursiveReadNotAllowed { get; }
    internal static string LockRecursionException_RecursiveWriteNotAllowed { get; }
    internal static string LockRecursionException_RecursiveUpgradeNotAllowed { get; }
    internal static string LockRecursionException_WriteAfterReadNotAllowed { get; }
    internal static string SynchronizationLockException_MisMatchedUpgrade { get; }
    internal static string SynchronizationLockException_MisMatchedRead { get; }
    internal static string SynchronizationLockException_IncorrectDispose { get; }
    internal static string LockRecursionException_UpgradeAfterReadNotAllowed { get; }
    internal static string LockRecursionException_UpgradeAfterWriteNotAllowed { get; }
    internal static string SynchronizationLockException_MisMatchedWrite { get; }
    internal static string NotSupported_SignatureType { get; }
    internal static string HashCode_HashCodeNotSupported { get; }
    internal static string HashCode_EqualityNotSupported { get; }
    internal static string Arg_TypeNotSupported { get; }
    internal static string IO_InvalidReadLength { get; }
    internal static string Arg_BasePathNotFullyQualified { get; }
    internal static string Arg_ElementsInSourceIsGreaterThanDestination { get; }
    internal static string Arg_NullArgumentNullRef { get; }
    internal static string Argument_OverlapAlignmentMismatch { get; }
    internal static string Arg_InsufficientNumberOfElements { get; }
    internal static string Arg_MustBeNullTerminatedString { get; }
    internal static string ArgumentOutOfRange_Week_ISO { get; }
    internal static string Argument_BadPInvokeMethod { get; }
    internal static string Argument_BadPInvokeOnInterface { get; }
    internal static string Argument_MethodRedefined { get; }
    internal static string Argument_CannotExtractScalar { get; }
    internal static string Argument_CannotParsePrecision { get; }
    internal static string Argument_GWithPrecisionNotSupported { get; }
    internal static string Argument_PrecisionTooLarge { get; }
    internal static string AssemblyDependencyResolver_FailedToLoadHostpolicy { get; }
    internal static string AssemblyDependencyResolver_FailedToResolveDependencies { get; }
    internal static string Arg_EnumNotCloneable { get; }
    internal static string InvalidOp_InvalidNewEnumVariant { get; }
    internal static string Argument_StructArrayTooLarge { get; }
    internal static string IndexOutOfRange_ArrayWithOffset { get; }
    internal static string Serialization_DangerousDeserialization { get; }
    internal static string Serialization_DangerousDeserialization_Switch { get; }
    internal static string Argument_InvalidStartupHookSimpleAssemblyName { get; }
    internal static string Argument_StartupHookAssemblyLoadFailed { get; }
    internal static string InvalidOperation_NonStaticComRegFunction { get; }
    internal static string InvalidOperation_NonStaticComUnRegFunction { get; }
    internal static string InvalidOperation_InvalidComRegFunctionSig { get; }
    internal static string InvalidOperation_InvalidComUnRegFunctionSig { get; }
    internal static string InvalidOperation_MultipleComRegFunctions { get; }
    internal static string InvalidOperation_MultipleComUnRegFunctions { get; }
    private static SR();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey);
    internal static string GetResourceString(string resourceKey, string defaultString);
    private static string InternalGetResourceString(string key);
    internal static string Format(IFormatProvider provider, string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static ResourceManager get_ResourceManager();
    internal static string get_Acc_CreateAbstEx();
    internal static string get_Acc_CreateArgIterator();
    internal static string get_Acc_CreateGenericEx();
    internal static string get_Acc_CreateInterfaceEx();
    internal static string get_Acc_CreateVoid();
    internal static string get_Acc_NotClassInit();
    internal static string get_Acc_ReadOnly();
    internal static string get_Access_Void();
    internal static string get_AggregateException_ctor_DefaultMessage();
    internal static string get_AggregateException_ctor_InnerExceptionNull();
    internal static string get_AggregateException_DeserializationFailure();
    internal static string get_AggregateException_InnerException();
    internal static string get_AppDomain_Name();
    internal static string get_AppDomain_NoContextPolicies();
    internal static string get_AppDomain_Policy_PrincipalTwice();
    internal static string get_AmbiguousImplementationException_NullMessage();
    internal static string get_Arg_AccessException();
    internal static string get_Arg_AccessViolationException();
    internal static string get_Arg_AmbiguousMatchException();
    internal static string get_Arg_ApplicationException();
    internal static string get_Arg_ArgumentException();
    internal static string get_Arg_ArgumentOutOfRangeException();
    internal static string get_Arg_ArithmeticException();
    internal static string get_Arg_ArrayLengthsDiffer();
    internal static string get_Arg_ArrayPlusOffTooSmall();
    internal static string get_Arg_ArrayTypeMismatchException();
    internal static string get_Arg_ArrayZeroError();
    internal static string get_Arg_BadDecimal();
    internal static string get_Arg_BadImageFormatException();
    internal static string get_Arg_BadLiteralFormat();
    internal static string get_Arg_BogusIComparer();
    internal static string get_Arg_BufferTooSmall();
    internal static string get_Arg_CannotBeNaN();
    internal static string get_Arg_CannotHaveNegativeValue();
    internal static string get_Arg_CannotMixComparisonInfrastructure();
    internal static string get_Arg_CannotUnloadAppDomainException();
    internal static string get_Arg_CATypeResolutionFailed();
    internal static string get_Arg_COMAccess();
    internal static string get_Arg_COMException();
    internal static string get_Arg_COMPropSetPut();
    internal static string get_Arg_CreatInstAccess();
    internal static string get_Arg_CryptographyException();
    internal static string get_Arg_CustomAttributeFormatException();
    internal static string get_Arg_DataMisalignedException();
    internal static string get_Arg_DateTimeRange();
    internal static string get_Arg_DecBitCtor();
    internal static string get_Arg_DirectoryNotFoundException();
    internal static string get_Arg_DivideByZero();
    internal static string get_Arg_DlgtNullInst();
    internal static string get_Arg_DlgtTargMeth();
    internal static string get_Arg_DlgtTypeMis();
    internal static string get_Arg_DllNotFoundException();
    internal static string get_Arg_DuplicateWaitObjectException();
    internal static string get_Arg_EHClauseNotClause();
    internal static string get_Arg_EHClauseNotFilter();
    internal static string get_Arg_EmptyArray();
    internal static string get_Arg_EmptyOrNullString();
    internal static string get_Arg_EndOfStreamException();
    internal static string get_Arg_EntryPointNotFoundException();
    internal static string get_Arg_EnumAndObjectMustBeSameType();
    internal static string get_Arg_EnumFormatUnderlyingTypeAndObjectMustBeSameType();
    internal static string get_Arg_EnumIllegalVal();
    internal static string get_Arg_EnumLitValueNotFound();
    internal static string get_Arg_EnumUnderlyingTypeAndObjectMustBeSameType();
    internal static string get_Arg_EnumValueNotFound();
    internal static string get_Arg_ExecutionEngineException();
    internal static string get_Arg_ExternalException();
    internal static string get_Arg_FieldAccessException();
    internal static string get_Arg_FieldDeclTarget();
    internal static string get_Arg_FldGetArgErr();
    internal static string get_Arg_FldGetPropSet();
    internal static string get_Arg_FldSetArgErr();
    internal static string get_Arg_FldSetGet();
    internal static string get_Arg_FldSetInvoke();
    internal static string get_Arg_FldSetPropGet();
    internal static string get_Arg_FormatException();
    internal static string get_Arg_GenericParameter();
    internal static string get_Arg_GetMethNotFnd();
    internal static string get_Arg_GuidArrayCtor();
    internal static string get_Arg_HandleNotAsync();
    internal static string get_Arg_HandleNotSync();
    internal static string get_Arg_HexStyleNotSupported();
    internal static string get_Arg_HTCapacityOverflow();
    internal static string get_Arg_IndexMustBeInt();
    internal static string get_Arg_IndexOutOfRangeException();
    internal static string get_Arg_InsufficientExecutionStackException();
    internal static string get_Arg_InvalidANSIString();
    internal static string get_Arg_InvalidBase();
    internal static string get_Arg_InvalidCastException();
    internal static string get_Arg_InvalidComObjectException();
    internal static string get_Arg_InvalidFilterCriteriaException();
    internal static string get_Arg_InvalidHandle();
    internal static string get_Arg_InvalidHexStyle();
    internal static string get_Arg_InvalidNeutralResourcesLanguage_Asm_Culture();
    internal static string get_Arg_InvalidNeutralResourcesLanguage_FallbackLoc();
    internal static string get_Arg_InvalidSatelliteContract_Asm_Ver();
    internal static string get_Arg_InvalidOleVariantTypeException();
    internal static string get_Arg_InvalidOperationException();
    internal static string get_Arg_InvalidTypeInRetType();
    internal static string get_Arg_InvalidTypeInSignature();
    internal static string get_Arg_IOException();
    internal static string get_Arg_KeyNotFound();
    internal static string get_Arg_KeyNotFoundWithKey();
    internal static string get_Arg_LongerThanSrcString();
    internal static string get_Arg_LowerBoundsMustMatch();
    internal static string get_Arg_MarshalAsAnyRestriction();
    internal static string get_Arg_MarshalDirectiveException();
    internal static string get_Arg_MethodAccessException();
    internal static string get_Arg_MethodAccessException_WithMethodName();
    internal static string get_Arg_MissingFieldException();
    internal static string get_Arg_MissingManifestResourceException();
    internal static string get_Arg_MissingMemberException();
    internal static string get_Arg_MissingMethodException();
    internal static string get_Arg_MulticastNotSupportedException();
    internal static string get_Arg_MustBeBoolean();
    internal static string get_Arg_MustBeByte();
    internal static string get_Arg_MustBeChar();
    internal static string get_Arg_MustBeDateTime();
    internal static string get_Arg_MustBeDateTimeOffset();
    internal static string get_Arg_MustBeDecimal();
    internal static string get_Arg_MustBeDelegate();
    internal static string get_Arg_MustBeDouble();
    internal static string get_Arg_MustBeEnum();
    internal static string get_Arg_MustBeEnumBaseTypeOrEnum();
    internal static string get_Arg_MustBeGuid();
    internal static string get_Arg_MustBeInt16();
    internal static string get_Arg_MustBeInt32();
    internal static string get_Arg_MustBeInt64();
    internal static string get_Arg_MustBePointer();
    internal static string get_Arg_MustBePrimArray();
    internal static string get_Arg_MustBeRuntimeAssembly();
    internal static string get_Arg_MustBeSByte();
    internal static string get_Arg_MustBeSingle();
    internal static string get_Arg_MustBeString();
    internal static string get_Arg_MustBeTimeSpan();
    internal static string get_Arg_MustBeType();
    internal static string get_Arg_MustBeTrue();
    internal static string get_Arg_MustBeUInt16();
    internal static string get_Arg_MustBeUInt32();
    internal static string get_Arg_MustBeUInt64();
    internal static string get_Arg_MustBeVersion();
    internal static string get_Arg_MustContainEnumInfo();
    internal static string get_Arg_NamedParamNull();
    internal static string get_Arg_NamedParamTooBig();
    internal static string get_Arg_NDirectBadObject();
    internal static string get_Arg_Need1DArray();
    internal static string get_Arg_Need2DArray();
    internal static string get_Arg_Need3DArray();
    internal static string get_Arg_NeedAtLeast1Rank();
    internal static string get_Arg_NegativeArgCount();
    internal static string get_Arg_NoAccessSpec();
    internal static string get_Arg_NoDefCTor();
    internal static string get_Arg_NonZeroLowerBound();
    internal static string get_Arg_NoStaticVirtual();
    internal static string get_Arg_NotFiniteNumberException();
    internal static string get_Arg_NotGenericMethodDefinition();
    internal static string get_Arg_NotGenericParameter();
    internal static string get_Arg_NotGenericTypeDefinition();
    internal static string get_Arg_NotImplementedException();
    internal static string get_Arg_NotSupportedException();
    internal static string get_Arg_NullReferenceException();
    internal static string get_Arg_ObjObjEx();
    internal static string get_Arg_OleAutDateInvalid();
    internal static string get_Arg_OleAutDateScale();
    internal static string get_Arg_OverflowException();
    internal static string get_Arg_ParamName_Name();
    internal static string get_Arg_ParmArraySize();
    internal static string get_Arg_ParmCnt();
    internal static string get_Arg_PathEmpty();
    internal static string get_Arg_PlatformNotSupported();
    internal static string get_Arg_PropSetGet();
    internal static string get_Arg_PropSetInvoke();
    internal static string get_Arg_RankException();
    internal static string get_Arg_RankIndices();
    internal static string get_Arg_RankMultiDimNotSupported();
    internal static string get_Arg_RanksAndBounds();
    internal static string get_Arg_RegGetOverflowBug();
    internal static string get_Arg_RegKeyNotFound();
    internal static string get_Arg_RegSubKeyValueAbsent();
    internal static string get_Arg_RegValStrLenBug();
    internal static string get_Arg_ResMgrNotResSet();
    internal static string get_Arg_ResourceFileUnsupportedVersion();
    internal static string get_Arg_ResourceNameNotExist();
    internal static string get_Arg_SafeArrayRankMismatchException();
    internal static string get_Arg_SafeArrayTypeMismatchException();
    internal static string get_Arg_SecurityException();
    internal static string get_SerializationException();
    internal static string get_Arg_SetMethNotFnd();
    internal static string get_Arg_StackOverflowException();
    internal static string get_Arg_SurrogatesNotAllowedAsSingleChar();
    internal static string get_Arg_SynchronizationLockException();
    internal static string get_Arg_SystemException();
    internal static string get_Arg_TargetInvocationException();
    internal static string get_Arg_TargetParameterCountException();
    internal static string get_Arg_ThreadStartException();
    internal static string get_Arg_ThreadStateException();
    internal static string get_Arg_TimeoutException();
    internal static string get_Arg_TypeAccessException();
    internal static string get_Arg_TypedReference_Null();
    internal static string get_Arg_TypeLoadException();
    internal static string get_Arg_TypeLoadNullStr();
    internal static string get_Arg_TypeRefPrimitve();
    internal static string get_Arg_TypeUnloadedException();
    internal static string get_Arg_UnauthorizedAccessException();
    internal static string get_Arg_UnboundGenField();
    internal static string get_Arg_UnboundGenParam();
    internal static string get_Arg_UnknownTypeCode();
    internal static string get_Arg_VarMissNull();
    internal static string get_Arg_VersionString();
    internal static string get_Arg_WrongAsyncResult();
    internal static string get_Arg_WrongType();
    internal static string get_Argument_AbsolutePathRequired();
    internal static string get_Argument_AddingDuplicate();
    internal static string get_Argument_AddingDuplicate__();
    internal static string get_Argument_AddingDuplicateWithKey();
    internal static string get_Argument_AdjustmentRulesNoNulls();
    internal static string get_Argument_AdjustmentRulesOutOfOrder();
    internal static string get_Argument_AlreadyBoundOrSyncHandle();
    internal static string get_Argument_ArrayGetInterfaceMap();
    internal static string get_Argument_ArraysInvalid();
    internal static string get_Argument_AttributeNamesMustBeUnique();
    internal static string get_Argument_BadConstructor();
    internal static string get_Argument_BadConstructorCallConv();
    internal static string get_Argument_BadExceptionCodeGen();
    internal static string get_Argument_BadFieldForConstructorBuilder();
    internal static string get_Argument_BadFieldSig();
    internal static string get_Argument_BadFieldType();
    internal static string get_Argument_BadFormatSpecifier();
    internal static string get_Argument_BadImageFormatExceptionResolve();
    internal static string get_Argument_BadLabel();
    internal static string get_Argument_BadLabelContent();
    internal static string get_Argument_BadNestedTypeFlags();
    internal static string get_Argument_BadParameterCountsForConstructor();
    internal static string get_Argument_BadParameterTypeForCAB();
    internal static string get_Argument_BadPropertyForConstructorBuilder();
    internal static string get_Argument_BadSigFormat();
    internal static string get_Argument_BadSizeForData();
    internal static string get_Argument_BadTypeAttrInvalidLayout();
    internal static string get_Argument_BadTypeAttrNestedVisibilityOnNonNestedType();
    internal static string get_Argument_BadTypeAttrNonNestedVisibilityNestedType();
    internal static string get_Argument_BadTypeAttrReservedBitsSet();
    internal static string get_Argument_BadTypeInCustomAttribute();
    internal static string get_Argument_CannotGetTypeTokenForByRef();
    internal static string get_Argument_CannotSetParentToInterface();
    internal static string get_Argument_CodepageNotSupported();
    internal static string get_Argument_CompareOptionOrdinal();
    internal static string get_Argument_ConflictingDateTimeRoundtripStyles();
    internal static string get_Argument_ConflictingDateTimeStyles();
    internal static string get_Argument_ConstantDoesntMatch();
    internal static string get_Argument_ConstantNotSupported();
    internal static string get_Argument_ConstantNull();
    internal static string get_Argument_ConstructorNeedGenericDeclaringType();
    internal static string get_Argument_ConversionOverflow();
    internal static string get_Argument_ConvertMismatch();
    internal static string get_Argument_CultureIetfNotSupported();
    internal static string get_Argument_CultureInvalidIdentifier();
    internal static string get_Argument_CultureIsNeutral();
    internal static string get_Argument_CultureNotSupported();
    internal static string get_Argument_CustomAssemblyLoadContextRequestedNameMismatch();
    internal static string get_Argument_CustomCultureCannotBePassedByNumber();
    internal static string get_Argument_DateTimeBadBinaryData();
    internal static string get_Argument_DateTimeHasTicks();
    internal static string get_Argument_DateTimeHasTimeOfDay();
    internal static string get_Argument_DateTimeIsInvalid();
    internal static string get_Argument_DateTimeIsNotAmbiguous();
    internal static string get_Argument_DateTimeKindMustBeUnspecified();
    internal static string get_Argument_DateTimeKindMustBeUnspecifiedOrUtc();
    internal static string get_Argument_DateTimeOffsetInvalidDateTimeStyles();
    internal static string get_Argument_DateTimeOffsetIsNotAmbiguous();
    internal static string get_Argument_DestinationTooShort();
    internal static string get_Argument_DuplicateTypeName();
    internal static string get_Argument_EmitWriteLineType();
    internal static string get_Argument_EmptyDecString();
    internal static string get_Argument_EmptyName();
    internal static string get_Argument_EmptyPath();
    internal static string get_Argument_EmptyWaithandleArray();
    internal static string get_Argument_EncoderFallbackNotEmpty();
    internal static string get_Argument_EncodingConversionOverflowBytes();
    internal static string get_Argument_EncodingConversionOverflowChars();
    internal static string get_Argument_EncodingNotSupported();
    internal static string get_Argument_EnumTypeDoesNotMatch();
    internal static string get_Argument_FallbackBufferNotEmpty();
    internal static string get_Argument_FieldDeclaringTypeGeneric();
    internal static string get_Argument_FieldNeedGenericDeclaringType();
    internal static string get_Argument_GenConstraintViolation();
    internal static string get_Argument_GenericArgsCount();
    internal static string get_Argument_GenericsInvalid();
    internal static string get_Argument_GlobalFunctionHasToBeStatic();
    internal static string get_Argument_HasToBeArrayClass();
    internal static string get_Argument_IdnBadBidi();
    internal static string get_Argument_IdnBadLabelSize();
    internal static string get_Argument_IdnBadNameSize();
    internal static string get_Argument_IdnBadPunycode();
    internal static string get_Argument_IdnBadStd3();
    internal static string get_Argument_IdnIllegalName();
    internal static string get_Argument_IllegalEnvVarName();
    internal static string get_Argument_IllegalName();
    internal static string get_Argument_ImplementIComparable();
    internal static string get_Argument_IndexOutOfArrayBounds();
    internal static string get_Argument_InsufficientSpaceToCopyCollection();
    internal static string get_Argument_InvalidAppendMode();
    internal static string get_Argument_InvalidArgumentForComparison();
    internal static string get_Argument_InvalidArrayLength();
    internal static string get_Argument_InvalidArrayType();
    internal static string get_Argument_InvalidCalendar();
    internal static string get_Argument_InvalidCharSequence();
    internal static string get_Argument_InvalidCharSequenceNoIndex();
    internal static string get_Argument_InvalidCodePageBytesIndex();
    internal static string get_Argument_InvalidCodePageConversionIndex();
    internal static string get_Argument_InvalidConstructorDeclaringType();
    internal static string get_Argument_InvalidConstructorInfo();
    internal static string get_Argument_InvalidCultureName();
    internal static string get_Argument_InvalidDateTimeKind();
    internal static string get_Argument_InvalidDateTimeStyles();
    internal static string get_Argument_InvalidDigitSubstitution();
    internal static string get_Argument_InvalidElementName();
    internal static string get_Argument_InvalidElementTag();
    internal static string get_Argument_InvalidElementText();
    internal static string get_Argument_InvalidElementValue();
    internal static string get_Argument_InvalidEnum();
    internal static string get_Argument_InvalidEnumValue();
    internal static string get_Argument_InvalidFieldDeclaringType();
    internal static string get_Argument_InvalidFileModeAndAccessCombo();
    internal static string get_Argument_InvalidFlag();
    internal static string get_Argument_InvalidGenericInstArray();
    internal static string get_Argument_InvalidGroupSize();
    internal static string get_Argument_InvalidHandle();
    internal static string get_Argument_InvalidHighSurrogate();
    internal static string get_Argument_InvalidId();
    internal static string get_Argument_InvalidKindOfTypeForCA();
    internal static string get_Argument_InvalidLabel();
    internal static string get_Argument_InvalidLowSurrogate();
    internal static string get_Argument_InvalidMemberForNamedArgument();
    internal static string get_Argument_InvalidMethodDeclaringType();
    internal static string get_Argument_InvalidName();
    internal static string get_Argument_InvalidNativeDigitCount();
    internal static string get_Argument_InvalidNativeDigitValue();
    internal static string get_Argument_InvalidNeutralRegionName();
    internal static string get_Argument_InvalidNormalizationForm();
    internal static string get_Argument_InvalidNumberStyles();
    internal static string get_Argument_InvalidOffLen();
    internal static string get_Argument_InvalidOpCodeOnDynamicMethod();
    internal static string get_Argument_InvalidParameterInfo();
    internal static string get_Argument_InvalidParamInfo();
    internal static string get_Argument_InvalidPathChars();
    internal static string get_Argument_InvalidResourceCultureName();
    internal static string get_Argument_InvalidSafeBufferOffLen();
    internal static string get_Argument_InvalidSeekOrigin();
    internal static string get_Argument_InvalidSerializedString();
    internal static string get_Argument_InvalidStartupHookSignature();
    internal static string get_Argument_InvalidTimeSpanStyles();
    internal static string get_Argument_InvalidToken();
    internal static string get_Argument_InvalidTypeForCA();
    internal static string get_Argument_InvalidTypeForDynamicMethod();
    internal static string get_Argument_InvalidTypeName();
    internal static string get_Argument_InvalidTypeWithPointersNotSupported();
    internal static string get_Argument_InvalidUnity();
    internal static string get_Argument_LargeInteger();
    internal static string get_Argument_LongEnvVarValue();
    internal static string get_Argument_MethodDeclaringTypeGeneric();
    internal static string get_Argument_MethodDeclaringTypeGenericLcg();
    internal static string get_Argument_MethodNeedGenericDeclaringType();
    internal static string get_Argument_MinMaxValue();
    internal static string get_Argument_MismatchedArrays();
    internal static string get_Argument_MissingDefaultConstructor();
    internal static string get_Argument_MustBeFalse();
    internal static string get_Argument_MustBeRuntimeAssembly();
    internal static string get_Argument_MustBeRuntimeFieldInfo();
    internal static string get_Argument_MustBeRuntimeMethodInfo();
    internal static string get_Argument_MustBeRuntimeReflectionObject();
    internal static string get_Argument_MustBeRuntimeType();
    internal static string get_Argument_MustBeTypeBuilder();
    internal static string get_Argument_MustHaveAttributeBaseClass();
    internal static string get_Argument_NativeOverlappedAlreadyFree();
    internal static string get_Argument_NativeOverlappedWrongBoundHandle();
    internal static string get_Argument_NeedGenericMethodDefinition();
    internal static string get_Argument_NeedNonGenericType();
    internal static string get_Argument_NeedStructWithNoRefs();
    internal static string get_Argument_NeverValidGenericArgument();
    internal static string get_Argument_NoEra();
    internal static string get_Argument_NoRegionInvariantCulture();
    internal static string get_Argument_NotAWritableProperty();
    internal static string get_Argument_NotEnoughBytesToRead();
    internal static string get_Argument_NotEnoughBytesToWrite();
    internal static string get_Argument_NotEnoughGenArguments();
    internal static string get_Argument_NotExceptionType();
    internal static string get_Argument_NotInExceptionBlock();
    internal static string get_Argument_NotMethodCallOpcode();
    internal static string get_Argument_NotSerializable();
    internal static string get_Argument_ObjIsWinRTObject();
    internal static string get_Argument_ObjNotComObject();
    internal static string get_Argument_OffsetAndCapacityOutOfBounds();
    internal static string get_Argument_OffsetLocalMismatch();
    internal static string get_Argument_OffsetOfFieldNotFound();
    internal static string get_Argument_OffsetOutOfRange();
    internal static string get_Argument_OffsetPrecision();
    internal static string get_Argument_OffsetUtcMismatch();
    internal static string get_Argument_OneOfCulturesNotSupported();
    internal static string get_Argument_OnlyMscorlib();
    internal static string get_Argument_OutOfOrderDateTimes();
    internal static string get_Argument_PathEmpty();
    internal static string get_Argument_PreAllocatedAlreadyAllocated();
    internal static string get_Argument_RecursiveFallback();
    internal static string get_Argument_RecursiveFallbackBytes();
    internal static string get_Argument_RedefinedLabel();
    internal static string get_Argument_ResolveField();
    internal static string get_Argument_ResolveFieldHandle();
    internal static string get_Argument_ResolveMember();
    internal static string get_Argument_ResolveMethod();
    internal static string get_Argument_ResolveMethodHandle();
    internal static string get_Argument_ResolveModuleType();
    internal static string get_Argument_ResolveString();
    internal static string get_Argument_ResolveType();
    internal static string get_Argument_ResultCalendarRange();
    internal static string get_Argument_SemaphoreInitialMaximum();
    internal static string get_Argument_ShouldNotSpecifyExceptionType();
    internal static string get_Argument_ShouldOnlySetVisibilityFlags();
    internal static string get_Argument_SigIsFinalized();
    internal static string get_Argument_StreamNotReadable();
    internal static string get_Argument_StreamNotWritable();
    internal static string get_Argument_StringFirstCharIsZero();
    internal static string get_Argument_StringZeroLength();
    internal static string get_Argument_TimeSpanHasSeconds();
    internal static string get_Argument_ToExclusiveLessThanFromExclusive();
    internal static string get_Argument_TooManyFinallyClause();
    internal static string get_Argument_TransitionTimesAreIdentical();
    internal static string get_Argument_TypedReferenceInvalidField();
    internal static string get_Argument_TypeIsWinRTType();
    internal static string get_Argument_TypeMustNotBeComImport();
    internal static string get_Argument_TypeNameTooLong();
    internal static string get_Argument_TypeNotActivatableViaWindowsRuntime();
    internal static string get_Argument_TypeNotComObject();
    internal static string get_Argument_TypeNotValid();
    internal static string get_Argument_UnclosedExceptionBlock();
    internal static string get_Argument_Unexpected_TypeSource();
    internal static string get_Argument_UnknownUnmanagedCallConv();
    internal static string get_Argument_UnmanagedMemAccessorWrapAround();
    internal static string get_Argument_UnmatchedMethodForLocal();
    internal static string get_Argument_UnmatchingSymScope();
    internal static string get_Argument_UTCOutOfRange();
    internal static string get_Argument_WinRTSystemRuntimeType();
    internal static string get_ArgumentException_BadMethodImplBody();
    internal static string get_ArgumentException_BufferNotFromPool();
    internal static string get_ArgumentException_OtherNotArrayOfCorrectLength();
    internal static string get_ArgumentException_NotIsomorphic();
    internal static string get_ArgumentException_TupleIncorrectType();
    internal static string get_ArgumentException_TupleLastArgumentNotATuple();
    internal static string get_ArgumentException_ValueTupleIncorrectType();
    internal static string get_ArgumentException_ValueTupleLastArgumentNotAValueTuple();
    internal static string get_ArgumentNull_Array();
    internal static string get_ArgumentNull_ArrayElement();
    internal static string get_ArgumentNull_ArrayValue();
    internal static string get_ArgumentNull_Assembly();
    internal static string get_ArgumentNull_AssemblyNameName();
    internal static string get_ArgumentNull_Buffer();
    internal static string get_ArgumentNull_Child();
    internal static string get_ArgumentNull_Collection();
    internal static string get_ArgumentNull_Dictionary();
    internal static string get_ArgumentNull_Generic();
    internal static string get_ArgumentNull_Key();
    internal static string get_ArgumentNull_Path();
    internal static string get_ArgumentNull_SafeHandle();
    internal static string get_ArgumentNull_Stream();
    internal static string get_ArgumentNull_String();
    internal static string get_ArgumentNull_Type();
    internal static string get_ArgumentNull_Waithandles();
    internal static string get_ArgumentOutOfRange_ActualValue();
    internal static string get_ArgumentOutOfRange_AddressSpace();
    internal static string get_ArgumentOutOfRange_AddValue();
    internal static string get_ArgumentOutOfRange_BadHourMinuteSecond();
    internal static string get_ArgumentOutOfRange_BadYearMonthDay();
    internal static string get_ArgumentOutOfRange_BiggerThanCollection();
    internal static string get_ArgumentOutOfRange_BinaryReaderFillBuffer();
    internal static string get_ArgumentOutOfRange_Bounds_Lower_Upper();
    internal static string get_ArgumentOutOfRange_CalendarRange();
    internal static string get_ArgumentOutOfRange_Capacity();
    internal static string get_ArgumentOutOfRange_Count();
    internal static string get_ArgumentOutOfRange_DateArithmetic();
    internal static string get_ArgumentOutOfRange_DateTimeBadMonths();
    internal static string get_ArgumentOutOfRange_DateTimeBadTicks();
    internal static string get_ArgumentOutOfRange_DateTimeBadYears();
    internal static string get_ArgumentOutOfRange_Day();
    internal static string get_ArgumentOutOfRange_DayOfWeek();
    internal static string get_ArgumentOutOfRange_DayParam();
    internal static string get_ArgumentOutOfRange_DecimalRound();
    internal static string get_ArgumentOutOfRange_DecimalScale();
    internal static string get_ArgumentOutOfRange_EndIndexStartIndex();
    internal static string get_ArgumentOutOfRange_Enum();
    internal static string get_ArgumentOutOfRange_Era();
    internal static string get_ArgumentOutOfRange_FileLengthTooBig();
    internal static string get_ArgumentOutOfRange_FileTimeInvalid();
    internal static string get_ArgumentOutOfRange_GenericPositive();
    internal static string get_ArgumentOutOfRange_GetByteCountOverflow();
    internal static string get_ArgumentOutOfRange_GetCharCountOverflow();
    internal static string get_ArgumentOutOfRange_HashtableLoadFactor();
    internal static string get_ArgumentOutOfRange_HugeArrayNotSupported();
    internal static string get_ArgumentOutOfRange_Index();
    internal static string get_ArgumentOutOfRange_IndexCount();
    internal static string get_ArgumentOutOfRange_IndexCountBuffer();
    internal static string get_ArgumentOutOfRange_IndexLargerThanMaxValue();
    internal static string get_ArgumentOutOfRange_IndexLength();
    internal static string get_ArgumentOutOfRange_IndexString();
    internal static string get_ArgumentOutOfRange_InvalidEraValue();
    internal static string get_ArgumentOutOfRange_InvalidHighSurrogate();
    internal static string get_ArgumentOutOfRange_InvalidLowSurrogate();
    internal static string get_ArgumentOutOfRange_InvalidUTF32();
    internal static string get_ArgumentOutOfRange_Length();
    internal static string get_ArgumentOutOfRange_LengthGreaterThanCapacity();
    internal static string get_ArgumentOutOfRange_LengthTooLarge();
    internal static string get_ArgumentOutOfRange_LessEqualToIntegerMaxVal();
    internal static string get_ArgumentOutOfRange_ListInsert();
    internal static string get_ArgumentOutOfRange_Month();
    internal static string get_ArgumentOutOfRange_MonthParam();
    internal static string get_ArgumentOutOfRange_MustBeNonNegInt32();
    internal static string get_ArgumentOutOfRange_MustBeNonNegNum();
    internal static string get_ArgumentOutOfRange_MustBePositive();
    internal static string get_ArgumentOutOfRange_NeedNonNegNum();
    internal static string get_ArgumentOutOfRange_NeedNonNegOrNegative1();
    internal static string get_ArgumentOutOfRange_NeedPosNum();
    internal static string get_ArgumentOutOfRange_NeedValidId();
    internal static string get_ArgumentOutOfRange_NegativeCapacity();
    internal static string get_ArgumentOutOfRange_NegativeCount();
    internal static string get_ArgumentOutOfRange_NegativeLength();
    internal static string get_ArgumentOutOfRange_OffsetLength();
    internal static string get_ArgumentOutOfRange_OffsetOut();
    internal static string get_ArgumentOutOfRange_ParamSequence();
    internal static string get_ArgumentOutOfRange_PartialWCHAR();
    internal static string get_ArgumentOutOfRange_PeriodTooLarge();
    internal static string get_ArgumentOutOfRange_PositionLessThanCapacityRequired();
    internal static string get_ArgumentOutOfRange_Range();
    internal static string get_ArgumentOutOfRange_RoundingDigits();
    internal static string get_ArgumentOutOfRange_SmallCapacity();
    internal static string get_ArgumentOutOfRange_SmallMaxCapacity();
    internal static string get_ArgumentOutOfRange_StartIndex();
    internal static string get_ArgumentOutOfRange_StartIndexLargerThanLength();
    internal static string get_ArgumentOutOfRange_StartIndexLessThanLength();
    internal static string get_ArgumentOutOfRange_StreamLength();
    internal static string get_ArgumentOutOfRange_TimeoutTooLarge();
    internal static string get_ArgumentOutOfRange_UIntPtrMax();
    internal static string get_ArgumentOutOfRange_UnmanagedMemStreamLength();
    internal static string get_ArgumentOutOfRange_UnmanagedMemStreamWrapAround();
    internal static string get_ArgumentOutOfRange_UtcOffset();
    internal static string get_ArgumentOutOfRange_UtcOffsetAndDaylightDelta();
    internal static string get_ArgumentOutOfRange_Version();
    internal static string get_ArgumentOutOfRange_Week();
    internal static string get_ArgumentOutOfRange_Year();
    internal static string get_Arithmetic_NaN();
    internal static string get_AssemblyLoadContext_Unload_CannotUnloadIfNotCollectible();
    internal static string get_AssemblyLoadContext_Verify_NotUnloading();
    internal static string get_AssertionFailed();
    internal static string get_AssertionFailed_Cnd();
    internal static string get_AssumptionFailed();
    internal static string get_AssumptionFailed_Cnd();
    internal static string get_AsyncMethodBuilder_InstanceNotInitialized();
    internal static string get_BadImageFormat_BadILFormat();
    internal static string get_BadImageFormat_InvalidType();
    internal static string get_BadImageFormat_NegativeStringLength();
    internal static string get_BadImageFormat_ParameterSignatureMismatch();
    internal static string get_BadImageFormat_ResType_SerBlobMismatch();
    internal static string get_BadImageFormat_ResourceDataLengthInvalid();
    internal static string get_BadImageFormat_ResourceNameCorrupted();
    internal static string get_BadImageFormat_ResourceNameCorrupted_NameIndex();
    internal static string get_BadImageFormat_ResourcesDataInvalidOffset();
    internal static string get_BadImageFormat_ResourcesHeaderCorrupted();
    internal static string get_BadImageFormat_ResourcesIndexTooLong();
    internal static string get_BadImageFormat_ResourcesNameInvalidOffset();
    internal static string get_BadImageFormat_ResourcesNameTooLong();
    internal static string get_BadImageFormat_TypeMismatch();
    internal static string get_CancellationToken_CreateLinkedToken_TokensIsEmpty();
    internal static string get_CancellationTokenSource_Disposed();
    internal static string get_ConcurrentCollection_SyncRoot_NotSupported();
    internal static string get_EventSource_AbstractMustNotDeclareEventMethods();
    internal static string get_EventSource_AbstractMustNotDeclareKTOC();
    internal static string get_EventSource_AddScalarOutOfRange();
    internal static string get_EventSource_BadHexDigit();
    internal static string get_EventSource_ChannelTypeDoesNotMatchEventChannelValue();
    internal static string get_EventSource_DataDescriptorsOutOfRange();
    internal static string get_EventSource_DuplicateStringKey();
    internal static string get_EventSource_EnumKindMismatch();
    internal static string get_EventSource_EvenHexDigits();
    internal static string get_EventSource_EventChannelOutOfRange();
    internal static string get_EventSource_EventIdReused();
    internal static string get_EventSource_EventMustHaveTaskIfNonDefaultOpcode();
    internal static string get_EventSource_EventMustNotBeExplicitImplementation();
    internal static string get_EventSource_EventNameReused();
    internal static string get_EventSource_EventParametersMismatch();
    internal static string get_EventSource_EventSourceGuidInUse();
    internal static string get_EventSource_EventTooBig();
    internal static string get_EventSource_EventWithAdminChannelMustHaveMessage();
    internal static string get_EventSource_IllegalKeywordsValue();
    internal static string get_EventSource_IllegalOpcodeValue();
    internal static string get_EventSource_IllegalTaskValue();
    internal static string get_EventSource_IllegalValue();
    internal static string get_EventSource_IncorrentlyAuthoredTypeInfo();
    internal static string get_EventSource_InvalidCommand();
    internal static string get_EventSource_InvalidEventFormat();
    internal static string get_EventSource_KeywordCollision();
    internal static string get_EventSource_KeywordNeedPowerOfTwo();
    internal static string get_EventSource_ListenerCreatedInsideCallback();
    internal static string get_EventSource_ListenerNotFound();
    internal static string get_EventSource_ListenerWriteFailure();
    internal static string get_EventSource_MaxChannelExceeded();
    internal static string get_EventSource_MismatchIdToWriteEvent();
    internal static string get_EventSource_NeedGuid();
    internal static string get_EventSource_NeedName();
    internal static string get_EventSource_NeedPositiveId();
    internal static string get_EventSource_NoFreeBuffers();
    internal static string get_EventSource_NonCompliantTypeError();
    internal static string get_EventSource_NoRelatedActivityId();
    internal static string get_EventSource_NotSupportedArrayOfBinary();
    internal static string get_EventSource_NotSupportedArrayOfNil();
    internal static string get_EventSource_NotSupportedArrayOfNullTerminatedString();
    internal static string get_EventSource_NotSupportedNestedArraysEnums();
    internal static string get_EventSource_NullInput();
    internal static string get_EventSource_OpcodeCollision();
    internal static string get_EventSource_PinArrayOutOfRange();
    internal static string get_EventSource_RecursiveTypeDefinition();
    internal static string get_EventSource_StopsFollowStarts();
    internal static string get_EventSource_TaskCollision();
    internal static string get_EventSource_TaskOpcodePairReused();
    internal static string get_EventSource_TooManyArgs();
    internal static string get_EventSource_TooManyFields();
    internal static string get_EventSource_ToString();
    internal static string get_EventSource_TraitEven();
    internal static string get_EventSource_TypeMustBeSealedOrAbstract();
    internal static string get_EventSource_TypeMustDeriveFromEventSource();
    internal static string get_EventSource_UndefinedChannel();
    internal static string get_EventSource_UndefinedKeyword();
    internal static string get_EventSource_UndefinedOpcode();
    internal static string get_EventSource_UnknownEtwTrait();
    internal static string get_EventSource_UnsupportedEventTypeInManifest();
    internal static string get_EventSource_UnsupportedMessageProperty();
    internal static string get_EventSource_VarArgsParameterMismatch();
    internal static string get_Exception_EndOfInnerExceptionStack();
    internal static string get_Exception_EndStackTraceFromPreviousThrow();
    internal static string get_Exception_WasThrown();
    internal static string get_ExecutionContext_ExceptionInAsyncLocalNotification();
    internal static string get_FileNotFound_ResolveAssembly();
    internal static string get_Format_AttributeUsage();
    internal static string get_Format_Bad7BitInt32();
    internal static string get_Format_BadBase64Char();
    internal static string get_Format_BadBoolean();
    internal static string get_Format_BadFormatSpecifier();
    internal static string get_Format_NoFormatSpecifier();
    internal static string get_Format_BadQuote();
    internal static string get_Format_BadTimeSpan();
    internal static string get_Format_EmptyInputString();
    internal static string get_Format_ExtraJunkAtEnd();
    internal static string get_Format_GuidUnrecognized();
    internal static string get_Format_IndexOutOfRange();
    internal static string get_Format_InvalidEnumFormatSpecification();
    internal static string get_Format_InvalidGuidFormatSpecification();
    internal static string get_Format_InvalidString();
    internal static string get_Format_NeedSingleChar();
    internal static string get_Format_NoParsibleDigits();
    internal static string get_Format_StringZeroLength();
    internal static string get_IndexOutOfRange_UMSPosition();
    internal static string get_InsufficientMemory_MemFailPoint();
    internal static string get_InsufficientMemory_MemFailPoint_TooBig();
    internal static string get_InsufficientMemory_MemFailPoint_VAFrag();
    internal static string get_Interop_COM_TypeMismatch();
    internal static string get_Interop_Marshal_Unmappable_Char();
    internal static string get_InvalidCast_CannotCastNullToValueType();
    internal static string get_InvalidCast_CannotCoerceByRefVariant();
    internal static string get_InvalidCast_DBNull();
    internal static string get_InvalidCast_Empty();
    internal static string get_InvalidCast_FromDBNull();
    internal static string get_InvalidCast_FromTo();
    internal static string get_InvalidCast_IConvertible();
    internal static string get_InvalidCast_WinRTIPropertyValueArrayCoersion();
    internal static string get_InvalidCast_WinRTIPropertyValueCoersion();
    internal static string get_InvalidCast_WinRTIPropertyValueElement();
    internal static string get_InvalidOperation_AsyncFlowCtrlCtxMismatch();
    internal static string get_InvalidOperation_AsyncIOInProgress();
    internal static string get_InvalidOperation_BadEmptyMethodBody();
    internal static string get_InvalidOperation_BadILGeneratorUsage();
    internal static string get_InvalidOperation_BadInstructionOrIndexOutOfBound();
    internal static string get_InvalidOperation_BadInterfaceNotAbstract();
    internal static string get_InvalidOperation_BadMethodBody();
    internal static string get_InvalidOperation_BadTypeAttributesNotAbstract();
    internal static string get_InvalidOperation_CalledTwice();
    internal static string get_InvalidOperation_CannotImportGlobalFromDifferentModule();
    internal static string get_InvalidOperation_CannotRegisterSecondResolver();
    internal static string get_InvalidOperation_CannotRemoveLastFromEmptyCollection();
    internal static string get_InvalidOperation_CannotRestoreUnsupressedFlow();
    internal static string get_InvalidOperation_CannotSupressFlowMultipleTimes();
    internal static string get_InvalidOperation_CannotUseAFCMultiple();
    internal static string get_InvalidOperation_CannotUseAFCOtherThread();
    internal static string get_InvalidOperation_CollectionBackingDictionaryTooLarge();
    internal static string get_InvalidOperation_CollectionBackingListTooLarge();
    internal static string get_InvalidOperation_CollectionCorrupted();
    internal static string get_InvalidOperation_ComputerName();
    internal static string get_InvalidOperation_ConcurrentOperationsNotSupported();
    internal static string get_InvalidOperation_ConstructorNotAllowedOnInterface();
    internal static string get_InvalidOperation_DateTimeParsing();
    internal static string get_InvalidOperation_DefaultConstructorILGen();
    internal static string get_InvalidOperation_EndReadCalledMultiple();
    internal static string get_InvalidOperation_EndWriteCalledMultiple();
    internal static string get_InvalidOperation_EnumEnded();
    internal static string get_InvalidOperation_EnumFailedVersion();
    internal static string get_InvalidOperation_EnumNotStarted();
    internal static string get_InvalidOperation_EnumOpCantHappen();
    internal static string get_InvalidOperation_EventInfoNotAvailable();
    internal static string get_InvalidOperation_EventTokenTableRequiresDelegate();
    internal static string get_InvalidOperation_GenericParametersAlreadySet();
    internal static string get_InvalidOperation_GetVersion();
    internal static string get_InvalidOperation_GlobalsHaveBeenCreated();
    internal static string get_InvalidOperation_HandleIsNotInitialized();
    internal static string get_InvalidOperation_HandleIsNotPinned();
    internal static string get_InvalidOperation_HashInsertFailed();
    internal static string get_InvalidOperation_IComparerFailed();
    internal static string get_InvalidOperation_MethodBaked();
    internal static string get_InvalidOperation_MethodBuilderBaked();
    internal static string get_InvalidOperation_MethodHasBody();
    internal static string get_InvalidOperation_MustCallInitialize();
    internal static string get_InvalidOperation_NativeOverlappedReused();
    internal static string get_InvalidOperation_NoMultiModuleAssembly();
    internal static string get_InvalidOperation_NoPublicAddMethod();
    internal static string get_InvalidOperation_NoPublicRemoveMethod();
    internal static string get_InvalidOperation_NotADebugModule();
    internal static string get_InvalidOperation_NotAllowedInDynamicMethod();
    internal static string get_InvalidOperation_NotAVarArgCallingConvention();
    internal static string get_InvalidOperation_NotGenericType();
    internal static string get_InvalidOperation_NotSupportedOnWinRTEvent();
    internal static string get_InvalidOperation_NotWithConcurrentGC();
    internal static string get_InvalidOperation_NoUnderlyingTypeOnEnum();
    internal static string get_InvalidOperation_NoValue();
    internal static string get_InvalidOperation_NullArray();
    internal static string get_InvalidOperation_NullContext();
    internal static string get_InvalidOperation_NullModuleHandle();
    internal static string get_InvalidOperation_OpenLocalVariableScope();
    internal static string get_InvalidOperation_Overlapped_Pack();
    internal static string get_InvalidOperation_PropertyInfoNotAvailable();
    internal static string get_InvalidOperation_ReadOnly();
    internal static string get_InvalidOperation_ResMgrBadResSet_Type();
    internal static string get_InvalidOperation_ResourceNotStream_Name();
    internal static string get_InvalidOperation_ResourceNotString_Name();
    internal static string get_InvalidOperation_ResourceNotString_Type();
    internal static string get_InvalidOperation_SetLatencyModeNoGC();
    internal static string get_InvalidOperation_ShouldNotHaveMethodBody();
    internal static string get_InvalidOperation_ThreadWrongThreadStart();
    internal static string get_InvalidOperation_TimeoutsNotSupported();
    internal static string get_InvalidOperation_TimerAlreadyClosed();
    internal static string get_InvalidOperation_TypeHasBeenCreated();
    internal static string get_InvalidOperation_TypeNotCreated();
    internal static string get_InvalidOperation_UnderlyingArrayListChanged();
    internal static string get_InvalidOperation_UnknownEnumType();
    internal static string get_InvalidOperation_WriteOnce();
    internal static string get_InvalidOperation_WrongAsyncResultOrEndCalledMultiple();
    internal static string get_InvalidOperation_WrongAsyncResultOrEndReadCalledMultiple();
    internal static string get_InvalidOperation_WrongAsyncResultOrEndWriteCalledMultiple();
    internal static string get_InvalidProgram_Default();
    internal static string get_InvalidTimeZone_InvalidRegistryData();
    internal static string get_InvariantFailed();
    internal static string get_InvariantFailed_Cnd();
    internal static string get_IO_EOF_ReadBeyondEOF();
    internal static string get_IO_FileLoad();
    internal static string get_IO_FileName_Name();
    internal static string get_IO_FileNotFound();
    internal static string get_IO_FileNotFound_FileName();
    internal static string get_IO_AlreadyExists_Name();
    internal static string get_IO_BindHandleFailed();
    internal static string get_IO_FileExists_Name();
    internal static string get_IO_FileStreamHandlePosition();
    internal static string get_IO_FileTooLongOrHandleNotSync();
    internal static string get_IO_FixedCapacity();
    internal static string get_IO_InvalidStringLen_Len();
    internal static string get_IO_SeekAppendOverwrite();
    internal static string get_IO_SeekBeforeBegin();
    internal static string get_IO_SetLengthAppendTruncate();
    internal static string get_IO_SharingViolation_File();
    internal static string get_IO_SharingViolation_NoFileName();
    internal static string get_IO_StreamTooLong();
    internal static string get_IO_PathNotFound_NoPathName();
    internal static string get_IO_PathNotFound_Path();
    internal static string get_IO_PathTooLong();
    internal static string get_IO_PathTooLong_Path();
    internal static string get_IO_UnknownFileName();
    internal static string get_Lazy_CreateValue_NoParameterlessCtorForT();
    internal static string get_Lazy_ctor_ModeInvalid();
    internal static string get_Lazy_StaticInit_InvalidOperation();
    internal static string get_Lazy_ToString_ValueNotCreated();
    internal static string get_Lazy_Value_RecursiveCallsToValue();
    internal static string get_ManualResetEventSlim_ctor_SpinCountOutOfRange();
    internal static string get_ManualResetEventSlim_ctor_TooManyWaiters();
    internal static string get_ManualResetEventSlim_Disposed();
    internal static string get_Marshaler_StringTooLong();
    internal static string get_MissingConstructor_Name();
    internal static string get_MissingField();
    internal static string get_MissingField_Name();
    internal static string get_MissingManifestResource_MultipleBlobs();
    internal static string get_MissingManifestResource_NoNeutralAsm();
    internal static string get_MissingManifestResource_NoNeutralDisk();
    internal static string get_MissingManifestResource_NoPRIresources();
    internal static string get_MissingManifestResource_ResWFileNotLoaded();
    internal static string get_MissingMember();
    internal static string get_MissingMember_Name();
    internal static string get_MissingMemberNestErr();
    internal static string get_MissingMemberTypeRef();
    internal static string get_MissingMethod_Name();
    internal static string get_MissingSatelliteAssembly_Culture_Name();
    internal static string get_MissingSatelliteAssembly_Default();
    internal static string get_Multicast_Combine();
    internal static string get_MustUseCCRewrite();
    internal static string get_NotSupported_AbstractNonCLS();
    internal static string get_NotSupported_ActivAttr();
    internal static string get_NotSupported_AppX();
    internal static string get_NotSupported_AssemblyLoadFromHash();
    internal static string get_NotSupported_ByRefToByRefLikeReturn();
    internal static string get_NotSupported_ByRefToVoidReturn();
    internal static string get_NotSupported_CallToVarArg();
    internal static string get_NotSupported_CannotCallEqualsOnSpan();
    internal static string get_NotSupported_CannotCallGetHashCodeOnSpan();
    internal static string get_NotSupported_ChangeType();
    internal static string get_NotSupported_CreateInstanceWithTypeBuilder();
    internal static string get_NotSupported_DBNullSerial();
    internal static string get_NotSupported_DynamicAssembly();
    internal static string get_NotSupported_DynamicMethodFlags();
    internal static string get_NotSupported_DynamicModule();
    internal static string get_NotSupported_FileStreamOnNonFiles();
    internal static string get_NotSupported_FixedSizeCollection();
    internal static string get_InvalidOperation_SpanOverlappedOperation();
    internal static string get_NotSupported_IllegalOneByteBranch();
    internal static string get_NotSupported_KeyCollectionSet();
    internal static string get_NotSupported_MaxWaitHandles();
    internal static string get_NotSupported_MemStreamNotExpandable();
    internal static string get_NotSupported_MustBeModuleBuilder();
    internal static string get_NotSupported_NoCodepageData();
    internal static string get_NotSupported_NonReflectedType();
    internal static string get_NotSupported_NoParentDefaultConstructor();
    internal static string get_NotSupported_NoTypeInfo();
    internal static string get_NotSupported_NYI();
    internal static string get_NotSupported_ObsoleteResourcesFile();
    internal static string get_NotSupported_OutputStreamUsingTypeBuilder();
    internal static string get_NotSupported_RangeCollection();
    internal static string get_NotSupported_Reading();
    internal static string get_NotSupported_ReadOnlyCollection();
    internal static string get_NotSupported_ResourceObjectSerialization();
    internal static string get_NotSupported_StringComparison();
    internal static string get_NotSupported_SubclassOverride();
    internal static string get_NotSupported_SymbolMethod();
    internal static string get_NotSupported_Type();
    internal static string get_NotSupported_TypeNotYetCreated();
    internal static string get_NotSupported_UmsSafeBuffer();
    internal static string get_NotSupported_UnitySerHolder();
    internal static string get_NotSupported_UnknownTypeCode();
    internal static string get_NotSupported_UnreadableStream();
    internal static string get_NotSupported_UnseekableStream();
    internal static string get_NotSupported_UnwritableStream();
    internal static string get_NotSupported_ValueCollectionSet();
    internal static string get_NotSupported_Writing();
    internal static string get_NotSupported_WrongResourceReader_Type();
    internal static string get_ObjectDisposed_FileClosed();
    internal static string get_ObjectDisposed_Generic();
    internal static string get_ObjectDisposed_ObjectName_Name();
    internal static string get_ObjectDisposed_WriterClosed();
    internal static string get_ObjectDisposed_ReaderClosed();
    internal static string get_ObjectDisposed_ResourceSet();
    internal static string get_ObjectDisposed_StreamClosed();
    internal static string get_ObjectDisposed_ViewAccessorClosed();
    internal static string get_ObjectDisposed_SafeHandleClosed();
    internal static string get_OperationCanceled();
    internal static string get_Overflow_Byte();
    internal static string get_Overflow_Char();
    internal static string get_Overflow_Currency();
    internal static string get_Overflow_Decimal();
    internal static string get_Overflow_Duration();
    internal static string get_Overflow_Int16();
    internal static string get_Overflow_Int32();
    internal static string get_Overflow_Int64();
    internal static string get_Overflow_NegateTwosCompNum();
    internal static string get_Overflow_NegativeUnsigned();
    internal static string get_Overflow_SByte();
    internal static string get_Overflow_TimeSpanElementTooLarge();
    internal static string get_Overflow_TimeSpanTooLong();
    internal static string get_Overflow_UInt16();
    internal static string get_Overflow_UInt32();
    internal static string get_Overflow_UInt64();
    internal static string get_PlatformNotSupported_ReflectionOnly();
    internal static string get_PlatformNotSupported_Remoting();
    internal static string get_PlatformNotSupported_SecureBinarySerialization();
    internal static string get_PlatformNotSupported_StrongNameSigning();
    internal static string get_PlatformNotSupported_WinRT();
    internal static string get_PlatformNotSupported_ITypeInfo();
    internal static string get_PlatformNotSupported_IExpando();
    internal static string get_PlatformNotSupported_AppDomains();
    internal static string get_PlatformNotSupported_CAS();
    internal static string get_PlatformNotSupported_Principal();
    internal static string get_PlatformNotSupported_ThreadAbort();
    internal static string get_PlatformNotSupported_ThreadSuspend();
    internal static string get_PostconditionFailed();
    internal static string get_PostconditionFailed_Cnd();
    internal static string get_PostconditionOnExceptionFailed();
    internal static string get_PostconditionOnExceptionFailed_Cnd();
    internal static string get_PreconditionFailed();
    internal static string get_PreconditionFailed_Cnd();
    internal static string get_Rank_MultiDimNotSupported();
    internal static string get_ResourceReaderIsClosed();
    internal static string get_Resources_StreamNotValid();
    internal static string get_RFLCT_AmbigCust();
    internal static string get_RFLCT_Ambiguous();
    internal static string get_InvalidFilterCriteriaException_CritInt();
    internal static string get_InvalidFilterCriteriaException_CritString();
    internal static string get_RFLCT_InvalidFieldFail();
    internal static string get_RFLCT_InvalidPropFail();
    internal static string get_RFLCT_Targ_ITargMismatch();
    internal static string get_RFLCT_Targ_StatFldReqTarg();
    internal static string get_RFLCT_Targ_StatMethReqTarg();
    internal static string get_RuntimeWrappedException();
    internal static string get_Security_CannotReadRegistryData();
    internal static string get_Security_RegistryPermission();
    internal static string get_SemaphoreSlim_ctor_InitialCountWrong();
    internal static string get_SemaphoreSlim_ctor_MaxCountWrong();
    internal static string get_SemaphoreSlim_Disposed();
    internal static string get_SemaphoreSlim_Release_CountWrong();
    internal static string get_SemaphoreSlim_Wait_TimeoutWrong();
    internal static string get_Serialization_BadParameterInfo();
    internal static string get_Serialization_CorruptField();
    internal static string get_Serialization_DateTimeTicksOutOfRange();
    internal static string get_Serialization_DelegatesNotSupported();
    internal static string get_Serialization_InsufficientState();
    internal static string get_Serialization_InvalidData();
    internal static string get_Serialization_InvalidEscapeSequence();
    internal static string get_Serialization_InvalidOnDeser();
    internal static string get_Serialization_InvalidPtrValue();
    internal static string get_Serialization_InvalidType();
    internal static string get_Serialization_KeyValueDifferentSizes();
    internal static string get_Serialization_MissingDateTimeData();
    internal static string get_Serialization_MissingKeys();
    internal static string get_Serialization_MissingValues();
    internal static string get_Serialization_NoParameterInfo();
    internal static string get_Serialization_NotFound();
    internal static string get_Serialization_NullKey();
    internal static string get_Serialization_OptionalFieldVersionValue();
    internal static string get_Serialization_SameNameTwice();
    internal static string get_Serialization_StringBuilderCapacity();
    internal static string get_Serialization_StringBuilderMaxCapacity();
    internal static string get_SpinLock_Exit_SynchronizationLockException();
    internal static string get_SpinLock_IsHeldByCurrentThread();
    internal static string get_SpinLock_TryEnter_ArgumentOutOfRange();
    internal static string get_SpinLock_TryEnter_LockRecursionException();
    internal static string get_SpinLock_TryReliableEnter_ArgumentException();
    internal static string get_SpinWait_SpinUntil_ArgumentNull();
    internal static string get_SpinWait_SpinUntil_TimeoutWrong();
    internal static string get_StackTrace_InFileLineNumber();
    internal static string get_Task_ContinueWith_ESandLR();
    internal static string get_Task_ContinueWith_NotOnAnything();
    internal static string get_Task_Delay_InvalidDelay();
    internal static string get_Task_Delay_InvalidMillisecondsDelay();
    internal static string get_Task_Dispose_NotCompleted();
    internal static string get_Task_FromAsync_LongRunning();
    internal static string get_Task_FromAsync_PreferFairness();
    internal static string get_Task_MultiTaskContinuation_EmptyTaskList();
    internal static string get_Task_MultiTaskContinuation_FireOptions();
    internal static string get_Task_MultiTaskContinuation_NullTask();
    internal static string get_Task_RunSynchronously_AlreadyStarted();
    internal static string get_Task_RunSynchronously_Continuation();
    internal static string get_Task_RunSynchronously_Promise();
    internal static string get_Task_RunSynchronously_TaskCompleted();
    internal static string get_Task_Start_AlreadyStarted();
    internal static string get_Task_Start_ContinuationTask();
    internal static string get_Task_Start_Promise();
    internal static string get_Task_Start_TaskCompleted();
    internal static string get_Task_ThrowIfDisposed();
    internal static string get_Task_WaitMulti_NullTask();
    internal static string get_TaskCanceledException_ctor_DefaultMessage();
    internal static string get_TaskCompletionSourceT_TrySetException_NoExceptions();
    internal static string get_TaskCompletionSourceT_TrySetException_NullException();
    internal static string get_TaskExceptionHolder_UnhandledException();
    internal static string get_TaskExceptionHolder_UnknownExceptionType();
    internal static string get_TaskScheduler_ExecuteTask_WrongTaskScheduler();
    internal static string get_TaskScheduler_FromCurrentSynchronizationContext_NoCurrent();
    internal static string get_TaskScheduler_InconsistentStateAfterTryExecuteTaskInline();
    internal static string get_TaskSchedulerException_ctor_DefaultMessage();
    internal static string get_TaskT_DebuggerNoResult();
    internal static string get_TaskT_TransitionToFinal_AlreadyCompleted();
    internal static string get_Thread_ApartmentState_ChangeFailed();
    internal static string get_Thread_GetSetCompressedStack_NotSupported();
    internal static string get_Thread_Operation_RequiresCurrentThread();
    internal static string get_Threading_AbandonedMutexException();
    internal static string get_Threading_WaitHandleCannotBeOpenedException();
    internal static string get_Threading_WaitHandleCannotBeOpenedException_InvalidHandle();
    internal static string get_Threading_WaitHandleTooManyPosts();
    internal static string get_Threading_SemaphoreFullException();
    internal static string get_ThreadLocal_Disposed();
    internal static string get_ThreadLocal_Value_RecursiveCallsToValue();
    internal static string get_ThreadLocal_ValuesNotAvailable();
    internal static string get_TimeZoneNotFound_MissingData();
    internal static string get_TypeInitialization_Default();
    internal static string get_TypeInitialization_Type();
    internal static string get_TypeLoad_ResolveNestedType();
    internal static string get_TypeLoad_ResolveType();
    internal static string get_TypeLoad_ResolveTypeFromAssembly();
    internal static string get_UnauthorizedAccess_IODenied_NoPathName();
    internal static string get_UnauthorizedAccess_IODenied_Path();
    internal static string get_UnauthorizedAccess_MemStreamBuffer();
    internal static string get_UnauthorizedAccess_RegistryKeyGeneric_Key();
    internal static string get_UnknownError_Num();
    internal static string get_Verification_Exception();
    internal static string get_Word_At();
    internal static string get_DebugAssertBanner();
    internal static string get_DebugAssertLongMessage();
    internal static string get_DebugAssertShortMessage();
    internal static string get_LockRecursionException_ReadAfterWriteNotAllowed();
    internal static string get_LockRecursionException_RecursiveReadNotAllowed();
    internal static string get_LockRecursionException_RecursiveWriteNotAllowed();
    internal static string get_LockRecursionException_RecursiveUpgradeNotAllowed();
    internal static string get_LockRecursionException_WriteAfterReadNotAllowed();
    internal static string get_SynchronizationLockException_MisMatchedUpgrade();
    internal static string get_SynchronizationLockException_MisMatchedRead();
    internal static string get_SynchronizationLockException_IncorrectDispose();
    internal static string get_LockRecursionException_UpgradeAfterReadNotAllowed();
    internal static string get_LockRecursionException_UpgradeAfterWriteNotAllowed();
    internal static string get_SynchronizationLockException_MisMatchedWrite();
    internal static string get_NotSupported_SignatureType();
    internal static string get_HashCode_HashCodeNotSupported();
    internal static string get_HashCode_EqualityNotSupported();
    internal static string get_Arg_TypeNotSupported();
    internal static string get_IO_InvalidReadLength();
    internal static string get_Arg_BasePathNotFullyQualified();
    internal static string get_Arg_ElementsInSourceIsGreaterThanDestination();
    internal static string get_Arg_NullArgumentNullRef();
    internal static string get_Argument_OverlapAlignmentMismatch();
    internal static string get_Arg_InsufficientNumberOfElements();
    internal static string get_Arg_MustBeNullTerminatedString();
    internal static string get_ArgumentOutOfRange_Week_ISO();
    internal static string get_Argument_BadPInvokeMethod();
    internal static string get_Argument_BadPInvokeOnInterface();
    internal static string get_Argument_MethodRedefined();
    internal static string get_Argument_CannotExtractScalar();
    internal static string get_Argument_CannotParsePrecision();
    internal static string get_Argument_GWithPrecisionNotSupported();
    internal static string get_Argument_PrecisionTooLarge();
    internal static string get_AssemblyDependencyResolver_FailedToLoadHostpolicy();
    internal static string get_AssemblyDependencyResolver_FailedToResolveDependencies();
    internal static string get_Arg_EnumNotCloneable();
    internal static string get_InvalidOp_InvalidNewEnumVariant();
    internal static string get_Argument_StructArrayTooLarge();
    internal static string get_IndexOutOfRange_ArrayWithOffset();
    internal static string get_Serialization_DangerousDeserialization();
    internal static string get_Serialization_DangerousDeserialization_Switch();
    internal static string get_Argument_InvalidStartupHookSimpleAssemblyName();
    internal static string get_Argument_StartupHookAssemblyLoadFailed();
    internal static string get_InvalidOperation_NonStaticComRegFunction();
    internal static string get_InvalidOperation_NonStaticComUnRegFunction();
    internal static string get_InvalidOperation_InvalidComRegFunctionSig();
    internal static string get_InvalidOperation_InvalidComUnRegFunctionSig();
    internal static string get_InvalidOperation_MultipleComRegFunctions();
    internal static string get_InvalidOperation_MultipleComUnRegFunctions();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.StackOverflowException : SystemException {
    public StackOverflowException(string message);
    public StackOverflowException(string message, Exception innerException);
    internal StackOverflowException(SerializationInfo info, StreamingContext context);
}
internal static class System.StartupHookProvider : object {
    private static void ProcessStartupHooks();
    private static void CallStartupHook(StartupHookNameOrPath startupHook);
}
[AttributeUsageAttribute("64")]
public class System.STAThreadAttribute : Attribute {
}
[DefaultMemberAttribute("Chars")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.String : object {
    private int _stringLength;
    private char _firstChar;
    [IntrinsicAttribute]
public static string Empty;
    public char Chars { get; }
    public int Length { get; }
    public String(Char[] value);
    public String(Char[] value, int startIndex, int length);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public String(Char* value);
    [CLSCompliantAttribute("False")]
[NullableContextAttribute("0")]
public String(Char* value, int startIndex, int length);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public String(SByte* value);
    [CLSCompliantAttribute("False")]
[NullableContextAttribute("0")]
public String(SByte* value, int startIndex, int length);
    [CLSCompliantAttribute("False")]
[NullableContextAttribute("0")]
public String(SByte* value, int startIndex, int length, Encoding enc);
    public String(char c, int count);
    [NullableContextAttribute("0")]
public String(ReadOnlySpan`1<char> value);
    public char get_Chars(int index);
    public int get_Length();
    internal static string FastAllocateString(int length);
    internal void SetTrailByte(byte data);
    internal bool TryGetTrailByte(Byte& data);
    private string Intern();
    private string IsInterned();
    public static string Intern(string str);
    public static string IsInterned(string str);
    internal static void InternalCopy(string src, IntPtr dest, int len);
    internal int GetBytesFromEncoding(Byte* pbNativeBuffer, int cbNativeBuffer, Encoding encoding);
    private string Ctor(Char[] value);
    private string Ctor(Char[] value, int startIndex, int length);
    private string Ctor(Char* ptr);
    private string Ctor(Char* ptr, int startIndex, int length);
    private string Ctor(SByte* value);
    private string Ctor(SByte* value, int startIndex, int length);
    private static string CreateStringForSByteConstructor(Byte* pb, int numBytes);
    private string Ctor(SByte* value, int startIndex, int length, Encoding enc);
    private string Ctor(char c, int count);
    private string Ctor(ReadOnlySpan`1<char> value);
    public static string Create(int length, TState state, SpanAction`2<char, TState> action);
    [NullableContextAttribute("0")]
public static ReadOnlySpan`1<char> op_Implicit(string value);
    public sealed virtual object Clone();
    public static string Copy(string str);
    public void CopyTo(int sourceIndex, Char[] destination, int destinationIndex, int count);
    public Char[] ToCharArray();
    public Char[] ToCharArray(int startIndex, int length);
    [NonVersionableAttribute]
[NullableContextAttribute("2")]
public static bool IsNullOrEmpty(string value);
    [NullableContextAttribute("2")]
public static bool IsNullOrWhiteSpace(string value);
    [NonVersionableAttribute]
[EditorBrowsableAttribute("1")]
public Char& modreq(System.Runtime.InteropServices.InAttribute) GetPinnableReference();
    internal Char& GetRawStringData();
    internal static string CreateStringFromEncoding(Byte* bytes, int byteLength, Encoding encoding);
    internal static string CreateFromChar(char c);
    internal static string CreateFromChar(char c1, char c2);
    internal static void wstrcpy(Char* dmem, Char* smem, int charCount);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public CharEnumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<char> System.Collections.Generic.IEnumerable<System.Char>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public StringRuneEnumerator EnumerateRunes();
    internal static int wcslen(Char* ptr);
    internal static int strlen(Byte* ptr);
    [DoesNotReturnAttribute]
private static void ThrowMustBeNullTerminatedString();
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    public bool IsNormalized();
    public bool IsNormalized(NormalizationForm normalizationForm);
    public string Normalize();
    public string Normalize(NormalizationForm normalizationForm);
    private bool IsAscii();
    private static bool EqualsHelper(string strA, string strB);
    private static int CompareOrdinalHelper(string strA, int indexA, int countA, string strB, int indexB, int countB);
    private static bool EqualsOrdinalIgnoreCase(string strA, string strB);
    private static int CompareOrdinalHelper(string strA, string strB);
    [NullableContextAttribute("2")]
public static int Compare(string strA, string strB);
    [NullableContextAttribute("2")]
public static int Compare(string strA, string strB, bool ignoreCase);
    [NullableContextAttribute("2")]
public static int Compare(string strA, string strB, StringComparison comparisonType);
    [NullableContextAttribute("2")]
public static int Compare(string strA, string strB, CultureInfo culture, CompareOptions options);
    [NullableContextAttribute("2")]
public static int Compare(string strA, string strB, bool ignoreCase, CultureInfo culture);
    [NullableContextAttribute("2")]
public static int Compare(string strA, int indexA, string strB, int indexB, int length);
    [NullableContextAttribute("2")]
public static int Compare(string strA, int indexA, string strB, int indexB, int length, bool ignoreCase);
    [NullableContextAttribute("2")]
public static int Compare(string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, CultureInfo culture);
    [NullableContextAttribute("2")]
public static int Compare(string strA, int indexA, string strB, int indexB, int length, CultureInfo culture, CompareOptions options);
    [NullableContextAttribute("2")]
public static int Compare(string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType);
    [NullableContextAttribute("2")]
public static int CompareOrdinal(string strA, string strB);
    internal static int CompareOrdinal(ReadOnlySpan`1<char> strA, ReadOnlySpan`1<char> strB);
    [NullableContextAttribute("2")]
public static int CompareOrdinal(string strA, int indexA, string strB, int indexB, int length);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(string strB);
    public bool EndsWith(string value);
    public bool EndsWith(string value, StringComparison comparisonType);
    public bool EndsWith(string value, bool ignoreCase, CultureInfo culture);
    public bool EndsWith(char value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(string value);
    [NullableContextAttribute("2")]
public bool Equals(string value, StringComparison comparisonType);
    [NullableContextAttribute("2")]
public static bool Equals(string a, string b);
    [NullableContextAttribute("2")]
public static bool Equals(string a, string b, StringComparison comparisonType);
    [NullableContextAttribute("2")]
public static bool op_Equality(string a, string b);
    [NullableContextAttribute("2")]
public static bool op_Inequality(string a, string b);
    public virtual int GetHashCode();
    public int GetHashCode(StringComparison comparisonType);
    internal int GetHashCodeOrdinalIgnoreCase();
    [NullableContextAttribute("0")]
public static int GetHashCode(ReadOnlySpan`1<char> value);
    [NullableContextAttribute("0")]
public static int GetHashCode(ReadOnlySpan`1<char> value, StringComparison comparisonType);
    internal static int GetHashCodeOrdinalIgnoreCase(ReadOnlySpan`1<char> value);
    internal int GetNonRandomizedHashCode();
    public bool StartsWith(string value);
    public bool StartsWith(string value, StringComparison comparisonType);
    public bool StartsWith(string value, bool ignoreCase, CultureInfo culture);
    public bool StartsWith(char value);
    internal static void CheckStringComparison(StringComparison comparisonType);
    internal static CompareOptions GetCaseCompareOfComparisonCulture(StringComparison comparisonType);
    private static void FillStringChecked(string dest, int destPos, string src);
    public static string Concat(object arg0);
    [NullableContextAttribute("2")]
public static string Concat(object arg0, object arg1);
    [NullableContextAttribute("2")]
public static string Concat(object arg0, object arg1, object arg2);
    public static string Concat(Object[] args);
    public static string Concat(IEnumerable`1<T> values);
    public static string Concat(IEnumerable`1<string> values);
    [NullableContextAttribute("2")]
public static string Concat(string str0, string str1);
    [NullableContextAttribute("2")]
public static string Concat(string str0, string str1, string str2);
    [NullableContextAttribute("2")]
public static string Concat(string str0, string str1, string str2, string str3);
    [NullableContextAttribute("0")]
public static string Concat(ReadOnlySpan`1<char> str0, ReadOnlySpan`1<char> str1);
    [NullableContextAttribute("0")]
public static string Concat(ReadOnlySpan`1<char> str0, ReadOnlySpan`1<char> str1, ReadOnlySpan`1<char> str2);
    [NullableContextAttribute("0")]
public static string Concat(ReadOnlySpan`1<char> str0, ReadOnlySpan`1<char> str1, ReadOnlySpan`1<char> str2, ReadOnlySpan`1<char> str3);
    public static string Concat(String[] values);
    public static string Format(string format, object arg0);
    public static string Format(string format, object arg0, object arg1);
    [NullableContextAttribute("2")]
public static string Format(string format, object arg0, object arg1, object arg2);
    public static string Format(string format, Object[] args);
    public static string Format(IFormatProvider provider, string format, object arg0);
    [NullableContextAttribute("2")]
public static string Format(IFormatProvider provider, string format, object arg0, object arg1);
    [NullableContextAttribute("2")]
public static string Format(IFormatProvider provider, string format, object arg0, object arg1, object arg2);
    public static string Format(IFormatProvider provider, string format, Object[] args);
    private static string FormatHelper(IFormatProvider provider, string format, ParamsArray args);
    public string Insert(int startIndex, string value);
    public static string Join(char separator, String[] value);
    public static string Join(char separator, Object[] values);
    public static string Join(char separator, IEnumerable`1<T> values);
    public static string Join(char separator, String[] value, int startIndex, int count);
    public static string Join(string separator, String[] value);
    public static string Join(string separator, Object[] values);
    public static string Join(string separator, IEnumerable`1<T> values);
    public static string Join(string separator, IEnumerable`1<string> values);
    public static string Join(string separator, String[] value, int startIndex, int count);
    private static string JoinCore(Char* separator, int separatorLength, Object[] values);
    private static string JoinCore(Char* separator, int separatorLength, IEnumerable`1<T> values);
    private static string JoinCore(Char* separator, int separatorLength, String[] value, int startIndex, int count);
    public string PadLeft(int totalWidth);
    public string PadLeft(int totalWidth, char paddingChar);
    public string PadRight(int totalWidth);
    public string PadRight(int totalWidth, char paddingChar);
    public string Remove(int startIndex, int count);
    public string Remove(int startIndex);
    public string Replace(string oldValue, string newValue, bool ignoreCase, CultureInfo culture);
    public string Replace(string oldValue, string newValue, StringComparison comparisonType);
    private string ReplaceCore(string oldValue, string newValue, CultureInfo culture, CompareOptions options);
    public string Replace(char oldChar, char newChar);
    public string Replace(string oldValue, string newValue);
    private string ReplaceHelper(int oldValueLength, string newValue, ReadOnlySpan`1<int> indices);
    public String[] Split(char separator, StringSplitOptions options);
    public String[] Split(char separator, int count, StringSplitOptions options);
    public String[] Split(Char[] separator);
    public String[] Split(Char[] separator, int count);
    public String[] Split(Char[] separator, StringSplitOptions options);
    public String[] Split(Char[] separator, int count, StringSplitOptions options);
    private String[] SplitInternal(ReadOnlySpan`1<char> separators, int count, StringSplitOptions options);
    public String[] Split(string separator, StringSplitOptions options);
    public String[] Split(string separator, int count, StringSplitOptions options);
    public String[] Split(String[] separator, StringSplitOptions options);
    public String[] Split(String[] separator, int count, StringSplitOptions options);
    private String[] SplitInternal(string separator, String[] separators, int count, StringSplitOptions options);
    private String[] SplitInternal(string separator, int count, StringSplitOptions options);
    private String[] SplitKeepEmptyEntries(ReadOnlySpan`1<int> sepList, ReadOnlySpan`1<int> lengthList, int defaultLength, int count);
    private String[] SplitOmitEmptyEntries(ReadOnlySpan`1<int> sepList, ReadOnlySpan`1<int> lengthList, int defaultLength, int count);
    private void MakeSeparatorList(ReadOnlySpan`1<char> separators, ValueListBuilder`1& sepListBuilder);
    private void MakeSeparatorList(string separator, ValueListBuilder`1& sepListBuilder);
    private void MakeSeparatorList(String[] separators, ValueListBuilder`1& sepListBuilder, ValueListBuilder`1& lengthListBuilder);
    public string Substring(int startIndex);
    public string Substring(int startIndex, int length);
    private string InternalSubString(int startIndex, int length);
    public string ToLower();
    public string ToLower(CultureInfo culture);
    public string ToLowerInvariant();
    public string ToUpper();
    public string ToUpper(CultureInfo culture);
    public string ToUpperInvariant();
    public string Trim();
    public string Trim(char trimChar);
    public string Trim(Char[] trimChars);
    public string TrimStart();
    public string TrimStart(char trimChar);
    public string TrimStart(Char[] trimChars);
    public string TrimEnd();
    public string TrimEnd(char trimChar);
    public string TrimEnd(Char[] trimChars);
    private string TrimWhiteSpaceHelper(TrimType trimType);
    private string TrimHelper(Char* trimChars, int trimCharsLength, TrimType trimType);
    private string CreateTrimmedString(int start, int end);
    public bool Contains(string value);
    public bool Contains(string value, StringComparison comparisonType);
    public bool Contains(char value);
    public bool Contains(char value, StringComparison comparisonType);
    public int IndexOf(char value);
    public int IndexOf(char value, int startIndex);
    public int IndexOf(char value, StringComparison comparisonType);
    public int IndexOf(char value, int startIndex, int count);
    public int IndexOfAny(Char[] anyOf);
    public int IndexOfAny(Char[] anyOf, int startIndex);
    public int IndexOfAny(Char[] anyOf, int startIndex, int count);
    private int IndexOfCharArray(Char[] anyOf, int startIndex, int count);
    private static void InitializeProbabilisticMap(UInt32* charMap, ReadOnlySpan`1<char> anyOf);
    private static bool ArrayContains(char searchChar, Char[] anyOf);
    private static bool IsCharBitSet(UInt32* charMap, byte value);
    private static void SetCharBit(UInt32* charMap, byte value);
    public int IndexOf(string value);
    public int IndexOf(string value, int startIndex);
    public int IndexOf(string value, int startIndex, int count);
    public int IndexOf(string value, StringComparison comparisonType);
    public int IndexOf(string value, int startIndex, StringComparison comparisonType);
    public int IndexOf(string value, int startIndex, int count, StringComparison comparisonType);
    public int LastIndexOf(char value);
    public int LastIndexOf(char value, int startIndex);
    public int LastIndexOf(char value, int startIndex, int count);
    public int LastIndexOfAny(Char[] anyOf);
    public int LastIndexOfAny(Char[] anyOf, int startIndex);
    public int LastIndexOfAny(Char[] anyOf, int startIndex, int count);
    private int LastIndexOfCharArray(Char[] anyOf, int startIndex, int count);
    public int LastIndexOf(string value);
    public int LastIndexOf(string value, int startIndex);
    public int LastIndexOf(string value, int startIndex, int count);
    public int LastIndexOf(string value, StringComparison comparisonType);
    public int LastIndexOf(string value, int startIndex, StringComparison comparisonType);
    public int LastIndexOf(string value, int startIndex, int count, StringComparison comparisonType);
}
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableContextAttribute("1")]
public abstract class System.StringComparer : object {
    private static CultureAwareComparer s_invariantCulture;
    private static CultureAwareComparer s_invariantCultureIgnoreCase;
    private static OrdinalCaseSensitiveComparer s_ordinal;
    private static OrdinalIgnoreCaseComparer s_ordinalIgnoreCase;
    public static StringComparer InvariantCulture { get; }
    public static StringComparer InvariantCultureIgnoreCase { get; }
    public static StringComparer CurrentCulture { get; }
    public static StringComparer CurrentCultureIgnoreCase { get; }
    public static StringComparer Ordinal { get; }
    public static StringComparer OrdinalIgnoreCase { get; }
    private static StringComparer();
    public static StringComparer get_InvariantCulture();
    public static StringComparer get_InvariantCultureIgnoreCase();
    public static StringComparer get_CurrentCulture();
    public static StringComparer get_CurrentCultureIgnoreCase();
    public static StringComparer get_Ordinal();
    public static StringComparer get_OrdinalIgnoreCase();
    public static StringComparer FromComparison(StringComparison comparisonType);
    public static StringComparer Create(CultureInfo culture, bool ignoreCase);
    public static StringComparer Create(CultureInfo culture, CompareOptions options);
    [NullableContextAttribute("2")]
public sealed virtual int Compare(object x, object y);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(object x, object y);
    public sealed virtual int GetHashCode(object obj);
    [NullableContextAttribute("2")]
public abstract virtual int Compare(string x, string y);
    [NullableContextAttribute("2")]
public abstract virtual bool Equals(string x, string y);
    public abstract virtual int GetHashCode(string obj);
}
public enum System.StringComparison : Enum {
    public int value__;
    public static StringComparison CurrentCulture;
    public static StringComparison CurrentCultureIgnoreCase;
    public static StringComparison InvariantCulture;
    public static StringComparison InvariantCultureIgnoreCase;
    public static StringComparison Ordinal;
    public static StringComparison OrdinalIgnoreCase;
}
[FlagsAttribute]
public enum System.StringSplitOptions : Enum {
    public int value__;
    public static StringSplitOptions None;
    public static StringSplitOptions RemoveEmptyEntries;
}
internal static class System.StubHelpers.AnsiBSTRMarshaler : object {
    internal static IntPtr ConvertToNative(int flags, string strManaged);
    internal static string ConvertToManaged(IntPtr bstr);
    internal static void ClearNative(IntPtr pNative);
}
internal static class System.StubHelpers.AnsiCharMarshaler : object {
    internal static Byte[] DoAnsiConversion(string str, bool fBestFit, bool fThrowOnUnmappableChar, Int32& cbLength);
    internal static byte ConvertToNative(char managedChar, bool fBestFit, bool fThrowOnUnmappableChar);
    internal static char ConvertToManaged(byte nativeChar);
}
internal class System.StubHelpers.AsAnyMarshaler : ValueType {
    private IntPtr pvArrayMarshaler;
    private BackPropAction backPropAction;
    private Type layoutType;
    private CleanupWorkListElement cleanupWorkList;
    internal AsAnyMarshaler(IntPtr pvArrayMarshaler);
    private static bool IsIn(int dwFlags);
    private static bool IsOut(int dwFlags);
    private static bool IsAnsi(int dwFlags);
    private static bool IsThrowOn(int dwFlags);
    private static bool IsBestFit(int dwFlags);
    private IntPtr ConvertArrayToNative(object pManagedHome, int dwFlags);
    private static IntPtr ConvertStringToNative(string pManagedHome, int dwFlags);
    private IntPtr ConvertStringBuilderToNative(StringBuilder pManagedHome, int dwFlags);
    private IntPtr ConvertLayoutToNative(object pManagedHome, int dwFlags);
    internal IntPtr ConvertToNative(object pManagedHome, int dwFlags);
    internal void ConvertToManaged(object pManagedHome, IntPtr pNativeHome);
    internal void ClearNative(IntPtr pNativeHome);
}
internal static class System.StubHelpers.BSTRMarshaler : object {
    internal static IntPtr ConvertToNative(string strManaged, IntPtr pNativeBuffer);
    internal static string ConvertToManaged(IntPtr bstr);
    internal static void ClearNative(IntPtr pNative);
}
internal abstract class System.StubHelpers.CleanupWorkListElement : object {
    private CleanupWorkListElement m_Next;
    protected abstract virtual void DestroyCore();
    public void Destroy();
    public static void AddToCleanupList(CleanupWorkListElement& list, CleanupWorkListElement newElement);
}
internal static class System.StubHelpers.CSTRMarshaler : object {
    internal static IntPtr ConvertToNative(int flags, string strManaged, IntPtr pNativeBuffer);
    internal static string ConvertToManaged(IntPtr cstr);
    internal static void ClearNative(IntPtr pNative);
}
internal static class System.StubHelpers.DateMarshaler : object {
    internal static double ConvertToNative(DateTime managedDate);
    internal static long ConvertToManaged(double nativeDate);
}
internal class System.StubHelpers.DateTimeNative : ValueType {
    public long UniversalTime;
}
internal static class System.StubHelpers.DateTimeOffsetMarshaler : object {
    internal static void ConvertToNative(DateTimeOffset& managedDTO, DateTimeNative& dateTime);
    internal static void ConvertToManaged(DateTimeOffset& managedLocalDTO, DateTimeNative& nativeTicks);
}
internal class System.StubHelpers.DelegateCleanupWorkListElement : CleanupWorkListElement {
    private Delegate m_del;
    public DelegateCleanupWorkListElement(Delegate del);
    protected virtual void DestroyCore();
}
internal static class System.StubHelpers.HResultExceptionMarshaler : object {
    internal static int ConvertToNative(Exception ex);
    internal static Exception ConvertToManaged(int hr);
}
internal static class System.StubHelpers.HStringMarshaler : object {
    internal static IntPtr ConvertToNative(string managed);
    internal static IntPtr ConvertToNativeReference(string managed, HSTRING_HEADER* hstringHeader);
    internal static string ConvertToManaged(IntPtr hstring);
    internal static void ClearNative(IntPtr hstring);
}
internal static class System.StubHelpers.InterfaceMarshaler : object {
    internal static IntPtr ConvertToNative(object objSrc, IntPtr itfMT, IntPtr classMT, int flags);
    internal static object ConvertToManaged(IntPtr pUnk, IntPtr itfMT, IntPtr classMT, int flags);
    internal static void ClearNative(IntPtr pUnk);
    internal static object ConvertToManagedWithoutUnboxing(IntPtr pNative);
}
internal static class System.StubHelpers.KeyValuePairMarshaler : object {
    internal static IntPtr ConvertToNative(KeyValuePair`2& pair);
    internal static KeyValuePair`2<K, V> ConvertToManaged(IntPtr pInsp);
    internal static object ConvertToManagedBox(IntPtr pInsp);
}
internal static class System.StubHelpers.MngdHiddenLengthArrayMarshaler : object {
    internal static void CreateMarshaler(IntPtr pMarshalState, IntPtr pMT, IntPtr cbElementSize, ushort vt);
    internal static void ConvertSpaceToNative(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome);
    internal static void ConvertContentsToNative(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome);
    internal static void ConvertContentsToNative_DateTime(DateTimeOffset[]& managedArray, IntPtr pNativeHome);
    internal static void ConvertContentsToNative_Type(Type[]& managedArray, IntPtr pNativeHome);
    internal static void ConvertContentsToNative_Exception(Exception[]& managedArray, IntPtr pNativeHome);
    internal static void ConvertContentsToNative_Nullable(Nullable`1[]& managedArray, IntPtr pNativeHome);
    internal static void ConvertContentsToNative_KeyValuePair(KeyValuePair`2[]& managedArray, IntPtr pNativeHome);
    internal static void ConvertSpaceToManaged(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome, int elementCount);
    internal static void ConvertContentsToManaged(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome);
    internal static void ConvertContentsToManaged_DateTime(DateTimeOffset[]& managedArray, IntPtr pNativeHome);
    internal static void ConvertContentsToManaged_Type(Type[]& managedArray, IntPtr pNativeHome);
    internal static void ConvertContentsToManaged_Exception(Exception[]& managedArray, IntPtr pNativeHome);
    internal static void ConvertContentsToManaged_Nullable(Nullable`1[]& managedArray, IntPtr pNativeHome);
    internal static void ConvertContentsToManaged_KeyValuePair(KeyValuePair`2[]& managedArray, IntPtr pNativeHome);
    internal static void ClearNativeContents(IntPtr pMarshalState, IntPtr pNativeHome, int cElements);
    internal static void ClearNativeContents_Type(IntPtr pNativeHome, int cElements);
}
internal static class System.StubHelpers.MngdNativeArrayMarshaler : object {
    internal static void CreateMarshaler(IntPtr pMarshalState, IntPtr pMT, int dwFlags);
    internal static void ConvertSpaceToNative(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome);
    internal static void ConvertContentsToNative(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome);
    internal static void ConvertSpaceToManaged(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome, int cElements);
    internal static void ConvertContentsToManaged(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome);
    internal static void ClearNative(IntPtr pMarshalState, IntPtr pNativeHome, int cElements);
    internal static void ClearNativeContents(IntPtr pMarshalState, IntPtr pNativeHome, int cElements);
}
internal static class System.StubHelpers.MngdRefCustomMarshaler : object {
    internal static void CreateMarshaler(IntPtr pMarshalState, IntPtr pCMHelper);
    internal static void ConvertContentsToNative(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome);
    internal static void ConvertContentsToManaged(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome);
    internal static void ClearNative(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome);
    internal static void ClearManaged(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome);
}
internal static class System.StubHelpers.MngdSafeArrayMarshaler : object {
    internal static void CreateMarshaler(IntPtr pMarshalState, IntPtr pMT, int iRank, int dwFlags);
    internal static void ConvertSpaceToNative(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome);
    internal static void ConvertContentsToNative(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome, object pOriginalManaged);
    internal static void ConvertSpaceToManaged(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome);
    internal static void ConvertContentsToManaged(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome);
    internal static void ClearNative(IntPtr pMarshalState, Object& pManagedHome, IntPtr pNativeHome);
}
internal class System.StubHelpers.NativeVariant : ValueType {
    private ushort vt;
    private ushort wReserved1;
    private ushort wReserved2;
    private ushort wReserved3;
    private IntPtr data1;
    private IntPtr data2;
}
internal static class System.StubHelpers.NullableMarshaler : object {
    internal static IntPtr ConvertToNative(Nullable`1& pManaged);
    internal static void ConvertToManagedRetVoid(IntPtr pNative, Nullable`1& retObj);
    internal static Nullable`1<T> ConvertToManaged(IntPtr pNative);
}
internal static class System.StubHelpers.ObjectMarshaler : object {
    internal static void ConvertToNative(object objSrc, IntPtr pDstVariant);
    internal static object ConvertToManaged(IntPtr pSrcVariant);
    internal static void ClearNative(IntPtr pVariant);
}
internal class System.StubHelpers.SafeHandleCleanupWorkListElement : CleanupWorkListElement {
    private SafeHandle m_handle;
    private bool m_owned;
    public SafeHandleCleanupWorkListElement(SafeHandle handle);
    protected virtual void DestroyCore();
    public IntPtr AddRef();
}
internal static class System.StubHelpers.StubHelpers : object {
    internal static bool IsQCall(IntPtr pMD);
    internal static void InitDeclaringType(IntPtr pMD);
    internal static IntPtr GetNDirectTarget(IntPtr pMD);
    internal static IntPtr GetDelegateTarget(Delegate pThis, IntPtr& pStubArg);
    internal static void ClearLastError();
    internal static void SetLastError();
    internal static void ThrowInteropParamException(int resID, int paramIdx);
    internal static IntPtr AddToCleanupList(CleanupWorkListElement& pCleanupWorkList, SafeHandle handle);
    internal static void AddToCleanupList(CleanupWorkListElement& pCleanupWorkList, Delegate del);
    internal static void DestroyCleanupList(CleanupWorkListElement& pCleanupWorkList);
    internal static Exception GetHRExceptionObject(int hr);
    internal static Exception InternalGetHRExceptionObject(int hr);
    internal static Exception GetCOMHRExceptionObject(int hr, IntPtr pCPCMD, object pThis);
    internal static Exception GetCOMHRExceptionObject_WinRT(int hr, IntPtr pCPCMD, object pThis);
    internal static Exception InternalGetCOMHRExceptionObject(int hr, IntPtr pCPCMD, object pThis, bool fForWinRT);
    internal static IntPtr CreateCustomMarshalerHelper(IntPtr pMD, int paramToken, IntPtr hndManagedType);
    internal static IntPtr SafeHandleAddRef(SafeHandle pHandle, Boolean& success);
    internal static void SafeHandleRelease(SafeHandle pHandle);
    internal static IntPtr GetCOMIPFromRCW(object objSrc, IntPtr pCPCMD, IntPtr& ppTarget, Boolean& pfNeedsRelease);
    internal static IntPtr GetCOMIPFromRCW_WinRT(object objSrc, IntPtr pCPCMD, IntPtr& ppTarget);
    internal static IntPtr GetCOMIPFromRCW_WinRTSharedGeneric(object objSrc, IntPtr pCPCMD, IntPtr& ppTarget);
    internal static IntPtr GetCOMIPFromRCW_WinRTDelegate(object objSrc, IntPtr pCPCMD, IntPtr& ppTarget);
    internal static bool ShouldCallWinRTInterface(object objSrc, IntPtr pCPCMD);
    internal static Delegate GetTargetForAmbiguousVariantCall(object objSrc, IntPtr pMT, Boolean& fUseString);
    internal static IntPtr GetDelegateInvokeMethod(Delegate pThis);
    internal static object GetWinRTFactoryObject(IntPtr pCPCMD);
    internal static IntPtr GetWinRTFactoryReturnValue(object pThis, IntPtr pCtorEntry);
    internal static IntPtr GetOuterInspectable(object pThis, IntPtr pCtorMD);
    internal static IntPtr ProfilerBeginTransitionCallback(IntPtr pSecretParam, IntPtr pThread, object pThis);
    internal static void ProfilerEndTransitionCallback(IntPtr pMD, IntPtr pThread);
    internal static void CheckStringLength(int length);
    internal static void CheckStringLength(UInt32 length);
    internal static void FmtClassUpdateNativeInternal(object obj, Byte* pNative, CleanupWorkListElement& pCleanupWorkList);
    internal static void FmtClassUpdateCLRInternal(object obj, Byte* pNative);
    internal static void LayoutDestroyNativeInternal(Byte* pNative, IntPtr pMT);
    internal static object AllocateInternal(IntPtr typeHandle);
    internal static void MarshalToUnmanagedVaListInternal(IntPtr va_list, UInt32 vaListSize, IntPtr pArgIterator);
    internal static void MarshalToManagedVaListInternal(IntPtr va_list, IntPtr pArgIterator);
    internal static UInt32 CalcVaListSize(IntPtr va_list);
    internal static void ValidateObject(object obj, IntPtr pMD, object pThis);
    internal static void LogPinnedArgument(IntPtr localDesc, IntPtr nativeArg);
    internal static void ValidateByref(IntPtr byref, IntPtr pMD, object pThis);
    internal static IntPtr GetStubContext();
    internal static IntPtr GetStubContextAddr();
    internal static void ArrayTypeCheck(object o, Object[] arr);
    internal static void MulticastDebuggerTraceHelper(object o, int count);
}
internal static class System.StubHelpers.SystemTypeMarshaler : object {
    internal static void ConvertToNative(Type managedType, TypeNameNative* pNativeType);
    internal static void ConvertToManaged(TypeNameNative* pNativeType, Type& managedType);
    internal static void ClearNative(TypeNameNative* pNativeType);
}
internal enum System.StubHelpers.TypeKind : Enum {
    public int value__;
    public static TypeKind Primitive;
    public static TypeKind Metadata;
    public static TypeKind Projection;
}
internal class System.StubHelpers.TypeNameNative : ValueType {
    internal IntPtr typeName;
    internal TypeKind typeKind;
}
internal static class System.StubHelpers.UriMarshaler : object {
    internal static string GetRawUriFromNative(IntPtr pUri);
    internal static IntPtr CreateNativeUriInstanceHelper(Char* rawUri, int strLen);
    internal static IntPtr CreateNativeUriInstance(string rawUri);
}
internal static class System.StubHelpers.UTF8BufferMarshaler : object {
    internal static IntPtr ConvertToNative(StringBuilder sb, IntPtr pNativeBuffer, int flags);
    internal static void ConvertToManaged(StringBuilder sb, IntPtr pNative);
}
internal static class System.StubHelpers.UTF8Marshaler : object {
    internal static IntPtr ConvertToNative(int flags, string strManaged, IntPtr pNativeBuffer);
    internal static string ConvertToManaged(IntPtr cstr);
    internal static void ClearNative(IntPtr pNative);
}
internal static class System.StubHelpers.ValueClassMarshaler : object {
    internal static void ConvertToNative(IntPtr dst, IntPtr src, IntPtr pMT, CleanupWorkListElement& pCleanupWorkList);
    internal static void ConvertToManaged(IntPtr dst, IntPtr src, IntPtr pMT);
    internal static void ClearNative(IntPtr dst, IntPtr pMT);
}
internal static class System.StubHelpers.VBByValStrMarshaler : object {
    internal static IntPtr ConvertToNative(string strManaged, bool fBestFit, bool fThrowOnUnmappableChar, Int32& cch);
    internal static string ConvertToManaged(IntPtr pNative, int cch);
    internal static void ClearNative(IntPtr pNative);
}
internal static class System.StubHelpers.WinRTTypeNameConverter : object {
    internal static string ConvertToWinRTTypeName(Type managedType, Boolean& isPrimitive);
    internal static Type GetTypeFromWinRTTypeName(string typeName, Boolean& isPrimitive);
}
internal static class System.StubHelpers.WSTRBufferMarshaler : object {
    internal static IntPtr ConvertToNative(string strManaged);
    internal static string ConvertToManaged(IntPtr bstr);
    internal static void ClearNative(IntPtr pNative);
}
[NullableAttribute("0")]
[NullableContextAttribute("2")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.SystemException : Exception {
    public SystemException(string message);
    public SystemException(string message, Exception innerException);
    [NullableContextAttribute("1")]
protected SystemException(SerializationInfo info, StreamingContext context);
}
internal class System.SZArrayEnumerator : object {
    private Array _array;
    private int _index;
    private int _endIndex;
    public object Current { get; }
    internal SZArrayEnumerator(Array array);
    public sealed virtual object Clone();
    public sealed virtual bool MoveNext();
    public sealed virtual object get_Current();
    public sealed virtual void Reset();
}
internal class System.SZArrayHelper : object {
    internal IEnumerator`1<T> GetEnumerator();
    private void CopyTo(T[] array, int index);
    internal int get_Count();
    internal T get_Item(int index);
    internal void set_Item(int index, T value);
    private void Add(T value);
    private bool Contains(T value);
    private bool get_IsReadOnly();
    private void Clear();
    private int IndexOf(T value);
    private void Insert(int index, T value);
    private bool Remove(T value);
    private void RemoveAt(int index);
}
internal class System.SZGenericArrayEnumerator`1 : object {
    private T[] _array;
    private int _index;
    internal static SZGenericArrayEnumerator`1<T> Empty;
    public T Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal SZGenericArrayEnumerator`1(T[] array);
    private static SZGenericArrayEnumerator`1();
    public sealed virtual bool MoveNext();
    public sealed virtual T get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
    public sealed virtual void Dispose();
}
public class System.Text.ASCIIEncoding : Encoding {
    internal static ASCIIEncodingSealed s_default;
    public bool IsSingleByte { get; }
    private static ASCIIEncoding();
    internal sealed virtual void SetDefaultFallbacks();
    [NullableContextAttribute("1")]
public virtual int GetByteCount(Char[] chars, int index, int count);
    [NullableContextAttribute("1")]
public virtual int GetByteCount(string chars);
    [CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count);
    public virtual int GetByteCount(ReadOnlySpan`1<char> chars);
    private int GetByteCountCommon(Char* pChars, int charCount);
    private protected sealed virtual int GetByteCountFast(Char* pChars, int charsLength, EncoderFallback fallback, Int32& charsConsumed);
    [NullableContextAttribute("1")]
public virtual int GetBytes(string chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [NullableContextAttribute("1")]
public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual int GetBytes(ReadOnlySpan`1<char> chars, Span`1<byte> bytes);
    private int GetBytesCommon(Char* pChars, int charCount, Byte* pBytes, int byteCount);
    private protected sealed virtual int GetBytesFast(Char* pChars, int charsLength, Byte* pBytes, int bytesLength, Int32& charsConsumed);
    private protected sealed virtual int GetBytesWithFallback(ReadOnlySpan`1<char> chars, int originalCharsLength, Span`1<byte> bytes, int originalBytesLength, EncoderNLS encoder);
    [NullableContextAttribute("1")]
public virtual int GetCharCount(Byte[] bytes, int index, int count);
    [CLSCompliantAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count);
    public virtual int GetCharCount(ReadOnlySpan`1<byte> bytes);
    private int GetCharCountCommon(Byte* pBytes, int byteCount);
    private protected sealed virtual int GetCharCountFast(Byte* pBytes, int bytesLength, DecoderFallback fallback, Int32& bytesConsumed);
    [NullableContextAttribute("1")]
public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    public virtual int GetChars(ReadOnlySpan`1<byte> bytes, Span`1<char> chars);
    private int GetCharsCommon(Byte* pBytes, int byteCount, Char* pChars, int charCount);
    private protected sealed virtual int GetCharsFast(Byte* pBytes, int bytesLength, Char* pChars, int charsLength, Int32& bytesConsumed);
    private protected sealed virtual int GetCharsWithFallback(ReadOnlySpan`1<byte> bytes, int originalBytesLength, Span`1<char> chars, int originalCharsLength, DecoderNLS decoder);
    [NullableContextAttribute("1")]
public virtual string GetString(Byte[] bytes, int byteIndex, int byteCount);
    internal sealed virtual bool TryGetByteCount(Rune value, Int32& byteCount);
    internal sealed virtual OperationStatus EncodeRune(Rune value, Span`1<byte> bytes, Int32& bytesWritten);
    internal sealed virtual OperationStatus DecodeFirstRune(ReadOnlySpan`1<byte> bytes, Rune& value, Int32& bytesConsumed);
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual bool get_IsSingleByte();
    [NullableContextAttribute("1")]
public virtual Decoder GetDecoder();
    [NullableContextAttribute("1")]
public virtual Encoder GetEncoder();
}
internal static class System.Text.ASCIIUtility : object {
    private static bool AllBytesInUInt64AreAscii(ulong value);
    private static bool AllCharsInUInt32AreAscii(UInt32 value);
    private static bool AllCharsInUInt64AreAscii(ulong value);
    private static bool FirstCharInUInt32IsAscii(UInt32 value);
    public static ulong GetIndexOfFirstNonAsciiByte(Byte* pBuffer, ulong bufferLength);
    private static ulong GetIndexOfFirstNonAsciiByte_Default(Byte* pBuffer, ulong bufferLength);
    private static ulong GetIndexOfFirstNonAsciiByte_Sse2(Byte* pBuffer, ulong bufferLength);
    public static ulong GetIndexOfFirstNonAsciiChar(Char* pBuffer, ulong bufferLength);
    private static ulong GetIndexOfFirstNonAsciiChar_Default(Char* pBuffer, ulong bufferLength);
    private static ulong GetIndexOfFirstNonAsciiChar_Sse2(Char* pBuffer, ulong bufferLength);
    private static void NarrowFourUtf16CharsToAsciiAndWriteToBuffer(Byte& outputBuffer, ulong value);
    private static void NarrowTwoUtf16CharsToAsciiAndWriteToBuffer(Byte& outputBuffer, UInt32 value);
    public static ulong NarrowUtf16ToAscii(Char* pUtf16Buffer, Byte* pAsciiBuffer, ulong elementCount);
    private static ulong NarrowUtf16ToAscii_Sse2(Char* pUtf16Buffer, Byte* pAsciiBuffer, ulong elementCount);
    public static ulong WidenAsciiToUtf16(Byte* pAsciiBuffer, Char* pUtf16Buffer, ulong elementCount);
    private static ulong WidenAsciiToUtf16_Sse2(Byte* pAsciiBuffer, Char* pUtf16Buffer, ulong elementCount);
    internal static void WidenFourAsciiBytesToUtf16AndWriteToBuffer(Char& outputBuffer, UInt32 value);
    internal static bool AllBytesInUInt32AreAscii(UInt32 value);
    internal static UInt32 CountNumberOfLeadingAsciiBytesFromUInt32WithSomeNonAsciiData(UInt32 value);
}
internal class System.Text.CodePageDataItem : object {
    [CompilerGeneratedAttribute]
private int <CodePage>k__BackingField;
    [CompilerGeneratedAttribute]
private int <UIFamilyCodePage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WebName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HeaderName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BodyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Flags>k__BackingField;
    public int UIFamilyCodePage { get; }
    public string WebName { get; }
    public string HeaderName { get; }
    public string BodyName { get; }
    public string DisplayName { get; }
    public UInt32 Flags { get; }
    internal CodePageDataItem(int codePage, int uiFamilyCodePage, string webName, string headerName, string bodyName, string displayName, UInt32 flags);
    [CompilerGeneratedAttribute]
public int get_UIFamilyCodePage();
    [CompilerGeneratedAttribute]
public string get_WebName();
    [CompilerGeneratedAttribute]
public string get_HeaderName();
    [CompilerGeneratedAttribute]
public string get_BodyName();
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    [CompilerGeneratedAttribute]
public UInt32 get_Flags();
}
public abstract class System.Text.Decoder : object {
    internal DecoderFallback _fallback;
    internal DecoderFallbackBuffer _fallbackBuffer;
    [NullableAttribute("2")]
public DecoderFallback Fallback { get; public set; }
    [NullableAttribute("1")]
public DecoderFallbackBuffer FallbackBuffer { get; }
    internal bool InternalHasFallbackBuffer { get; }
    [NullableContextAttribute("2")]
public DecoderFallback get_Fallback();
    [NullableContextAttribute("2")]
public void set_Fallback(DecoderFallback value);
    [NullableContextAttribute("1")]
public DecoderFallbackBuffer get_FallbackBuffer();
    internal bool get_InternalHasFallbackBuffer();
    public virtual void Reset();
    [NullableContextAttribute("1")]
public abstract virtual int GetCharCount(Byte[] bytes, int index, int count);
    [NullableContextAttribute("1")]
public virtual int GetCharCount(Byte[] bytes, int index, int count, bool flush);
    [CLSCompliantAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count, bool flush);
    public virtual int GetCharCount(ReadOnlySpan`1<byte> bytes, bool flush);
    [NullableContextAttribute("1")]
public abstract virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    [NullableContextAttribute("1")]
public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex, bool flush);
    [CLSCompliantAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, bool flush);
    public virtual int GetChars(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, bool flush);
    [NullableContextAttribute("1")]
public virtual void Convert(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex, int charCount, bool flush, Int32& bytesUsed, Int32& charsUsed, Boolean& completed);
    [CLSCompliantAttribute("False")]
public virtual void Convert(Byte* bytes, int byteCount, Char* chars, int charCount, bool flush, Int32& bytesUsed, Int32& charsUsed, Boolean& completed);
    public virtual void Convert(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, bool flush, Int32& bytesUsed, Int32& charsUsed, Boolean& completed);
}
public class System.Text.DecoderExceptionFallback : DecoderFallback {
    public int MaxCharCount { get; }
    [NullableContextAttribute("1")]
public virtual DecoderFallbackBuffer CreateFallbackBuffer();
    public virtual int get_MaxCharCount();
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
public class System.Text.DecoderExceptionFallbackBuffer : DecoderFallbackBuffer {
    public int Remaining { get; }
    [NullableContextAttribute("1")]
public virtual bool Fallback(Byte[] bytesUnknown, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
    public virtual int get_Remaining();
    [DoesNotReturnAttribute]
private void Throw(Byte[] bytesUnknown, int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Text.DecoderFallback : object {
    private static DecoderFallback s_replacementFallback;
    private static DecoderFallback s_exceptionFallback;
    public static DecoderFallback ReplacementFallback { get; }
    public static DecoderFallback ExceptionFallback { get; }
    public int MaxCharCount { get; }
    public static DecoderFallback get_ReplacementFallback();
    public static DecoderFallback get_ExceptionFallback();
    public abstract virtual DecoderFallbackBuffer CreateFallbackBuffer();
    public abstract virtual int get_MaxCharCount();
}
public abstract class System.Text.DecoderFallbackBuffer : object {
    internal Byte* byteStart;
    internal Char* charEnd;
    internal Encoding _encoding;
    internal DecoderNLS _decoder;
    private int _originalByteCount;
    public int Remaining { get; }
    [NullableContextAttribute("1")]
public abstract virtual bool Fallback(Byte[] bytesUnknown, int index);
    public abstract virtual char GetNextChar();
    public abstract virtual bool MovePrevious();
    public abstract virtual int get_Remaining();
    public virtual void Reset();
    internal void InternalReset();
    internal void InternalInitialize(Byte* byteStart, Char* charEnd);
    internal static DecoderFallbackBuffer CreateAndInitialize(Encoding encoding, DecoderNLS decoder, int originalByteCount);
    internal virtual bool InternalFallback(Byte[] bytes, Byte* pBytes, Char*& chars);
    internal virtual int InternalFallback(Byte[] bytes, Byte* pBytes);
    internal int InternalFallbackGetCharCount(ReadOnlySpan`1<byte> remainingBytes, int fallbackLength);
    internal bool TryInternalFallbackGetChars(ReadOnlySpan`1<byte> remainingBytes, int fallbackLength, Span`1<char> chars, Int32& charsWritten);
    private Rune GetNextRune();
    internal int DrainRemainingDataForGetCharCount();
    internal bool TryDrainRemainingDataForGetChars(Span`1<char> chars, Int32& charsWritten);
    [DoesNotReturnAttribute]
internal void ThrowLastBytesRecursive(Byte[] bytesUnknown);
}
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableContextAttribute("2")]
public class System.Text.DecoderFallbackException : ArgumentException {
    private Byte[] _bytesUnknown;
    private int _index;
    public Byte[] BytesUnknown { get; }
    public int Index { get; }
    public DecoderFallbackException(string message);
    public DecoderFallbackException(string message, Exception innerException);
    public DecoderFallbackException(string message, Byte[] bytesUnknown, int index);
    private DecoderFallbackException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public Byte[] get_BytesUnknown();
    public int get_Index();
}
internal class System.Text.DecoderNLS : Decoder {
    private Encoding _encoding;
    private bool _mustFlush;
    internal bool _throwOnOverflow;
    internal int _bytesUsed;
    private int _leftoverBytes;
    private int _leftoverByteCount;
    public bool MustFlush { get; }
    internal bool HasState { get; }
    internal bool HasLeftoverData { get; }
    internal DecoderNLS(Encoding encoding);
    public virtual void Reset();
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    public virtual int GetCharCount(Byte[] bytes, int index, int count, bool flush);
    public virtual int GetCharCount(Byte* bytes, int count, bool flush);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex, bool flush);
    public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, bool flush);
    public virtual void Convert(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex, int charCount, bool flush, Int32& bytesUsed, Int32& charsUsed, Boolean& completed);
    public virtual void Convert(Byte* bytes, int byteCount, Char* chars, int charCount, bool flush, Int32& bytesUsed, Int32& charsUsed, Boolean& completed);
    public bool get_MustFlush();
    internal virtual bool get_HasState();
    internal void ClearMustFlush();
    internal ReadOnlySpan`1<byte> GetLeftoverData();
    internal void SetLeftoverData(ReadOnlySpan`1<byte> bytes);
    internal bool get_HasLeftoverData();
    internal void ClearLeftoverData();
    internal int DrainLeftoverDataForGetCharCount(ReadOnlySpan`1<byte> bytes, Int32& bytesConsumed);
    internal int DrainLeftoverDataForGetChars(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, Int32& bytesConsumed);
    private static int ConcatInto(ReadOnlySpan`1<byte> srcLeft, ReadOnlySpan`1<byte> srcRight, Span`1<byte> dest);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Text.DecoderReplacementFallback : DecoderFallback {
    private string _strDefault;
    public string DefaultString { get; }
    public int MaxCharCount { get; }
    public DecoderReplacementFallback(string replacement);
    public string get_DefaultString();
    public virtual DecoderFallbackBuffer CreateFallbackBuffer();
    public virtual int get_MaxCharCount();
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Text.DecoderReplacementFallbackBuffer : DecoderFallbackBuffer {
    private string _strDefault;
    private int _fallbackCount;
    private int _fallbackIndex;
    public int Remaining { get; }
    public DecoderReplacementFallbackBuffer(DecoderReplacementFallback fallback);
    public virtual bool Fallback(Byte[] bytesUnknown, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
    public virtual int get_Remaining();
    public virtual void Reset();
    internal virtual int InternalFallback(Byte[] bytes, Byte* pBytes);
}
public abstract class System.Text.Encoder : object {
    internal EncoderFallback _fallback;
    internal EncoderFallbackBuffer _fallbackBuffer;
    [NullableAttribute("2")]
public EncoderFallback Fallback { get; public set; }
    [NullableAttribute("1")]
public EncoderFallbackBuffer FallbackBuffer { get; }
    internal bool InternalHasFallbackBuffer { get; }
    [NullableContextAttribute("2")]
public EncoderFallback get_Fallback();
    [NullableContextAttribute("2")]
public void set_Fallback(EncoderFallback value);
    [NullableContextAttribute("1")]
public EncoderFallbackBuffer get_FallbackBuffer();
    internal bool get_InternalHasFallbackBuffer();
    public virtual void Reset();
    [NullableContextAttribute("1")]
public abstract virtual int GetByteCount(Char[] chars, int index, int count, bool flush);
    [CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count, bool flush);
    public virtual int GetByteCount(ReadOnlySpan`1<char> chars, bool flush);
    [NullableContextAttribute("1")]
public abstract virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex, bool flush);
    [CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, bool flush);
    public virtual int GetBytes(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, bool flush);
    [NullableContextAttribute("1")]
public virtual void Convert(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex, int byteCount, bool flush, Int32& charsUsed, Int32& bytesUsed, Boolean& completed);
    [CLSCompliantAttribute("False")]
public virtual void Convert(Char* chars, int charCount, Byte* bytes, int byteCount, bool flush, Int32& charsUsed, Int32& bytesUsed, Boolean& completed);
    public virtual void Convert(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, bool flush, Int32& charsUsed, Int32& bytesUsed, Boolean& completed);
}
public class System.Text.EncoderExceptionFallback : EncoderFallback {
    public int MaxCharCount { get; }
    [NullableContextAttribute("1")]
public virtual EncoderFallbackBuffer CreateFallbackBuffer();
    public virtual int get_MaxCharCount();
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
public class System.Text.EncoderExceptionFallbackBuffer : EncoderFallbackBuffer {
    public int Remaining { get; }
    public virtual bool Fallback(char charUnknown, int index);
    public virtual bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
    public virtual int get_Remaining();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Text.EncoderFallback : object {
    private static EncoderFallback s_replacementFallback;
    private static EncoderFallback s_exceptionFallback;
    public static EncoderFallback ReplacementFallback { get; }
    public static EncoderFallback ExceptionFallback { get; }
    public int MaxCharCount { get; }
    public static EncoderFallback get_ReplacementFallback();
    public static EncoderFallback get_ExceptionFallback();
    public abstract virtual EncoderFallbackBuffer CreateFallbackBuffer();
    public abstract virtual int get_MaxCharCount();
}
public abstract class System.Text.EncoderFallbackBuffer : object {
    internal Char* charStart;
    internal Char* charEnd;
    internal EncoderNLS encoder;
    internal bool setEncoder;
    internal bool bUsedEncoder;
    internal bool bFallingBack;
    internal int iRecursionCount;
    private Encoding encoding;
    private int originalCharCount;
    public int Remaining { get; }
    public abstract virtual bool Fallback(char charUnknown, int index);
    public abstract virtual bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
    public abstract virtual char GetNextChar();
    public abstract virtual bool MovePrevious();
    public abstract virtual int get_Remaining();
    public virtual void Reset();
    internal void InternalReset();
    internal void InternalInitialize(Char* charStart, Char* charEnd, EncoderNLS encoder, bool setEncoder);
    internal static EncoderFallbackBuffer CreateAndInitialize(Encoding encoding, EncoderNLS encoder, int originalCharCount);
    internal char InternalGetNextChar();
    private bool InternalFallback(ReadOnlySpan`1<char> chars, Int32& charsConsumed);
    internal int InternalFallbackGetByteCount(ReadOnlySpan`1<char> chars, Int32& charsConsumed);
    internal bool TryInternalFallbackGetBytes(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, Int32& charsConsumed, Int32& bytesWritten);
    internal bool TryDrainRemainingDataForGetBytes(Span`1<byte> bytes, Int32& bytesWritten);
    internal int DrainRemainingDataForGetByteCount();
    private Rune GetNextRune();
    internal virtual bool InternalFallback(char ch, Char*& chars);
    [DoesNotReturnAttribute]
internal void ThrowLastCharRecursive(int charRecursive);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Text.EncoderFallbackException : ArgumentException {
    private char _charUnknown;
    private char _charUnknownHigh;
    private char _charUnknownLow;
    private int _index;
    public char CharUnknown { get; }
    public char CharUnknownHigh { get; }
    public char CharUnknownLow { get; }
    public int Index { get; }
    public EncoderFallbackException(string message);
    public EncoderFallbackException(string message, Exception innerException);
    internal EncoderFallbackException(string message, char charUnknown, int index);
    internal EncoderFallbackException(string message, char charUnknownHigh, char charUnknownLow, int index);
    private EncoderFallbackException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public char get_CharUnknown();
    public char get_CharUnknownHigh();
    public char get_CharUnknownLow();
    public int get_Index();
    public bool IsUnknownSurrogate();
}
internal class System.Text.EncoderNLS : Encoder {
    internal char _charLeftOver;
    private Encoding _encoding;
    private bool _mustFlush;
    internal bool _throwOnOverflow;
    internal int _charsUsed;
    public Encoding Encoding { get; }
    public bool MustFlush { get; }
    internal bool HasLeftoverData { get; }
    internal bool HasState { get; }
    internal EncoderNLS(Encoding encoding);
    public virtual void Reset();
    public virtual int GetByteCount(Char[] chars, int index, int count, bool flush);
    public virtual int GetByteCount(Char* chars, int count, bool flush);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex, bool flush);
    public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, bool flush);
    public virtual void Convert(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex, int byteCount, bool flush, Int32& charsUsed, Int32& bytesUsed, Boolean& completed);
    public virtual void Convert(Char* chars, int charCount, Byte* bytes, int byteCount, bool flush, Int32& charsUsed, Int32& bytesUsed, Boolean& completed);
    public Encoding get_Encoding();
    public bool get_MustFlush();
    internal bool get_HasLeftoverData();
    internal virtual bool get_HasState();
    internal void ClearMustFlush();
    internal int DrainLeftoverDataForGetByteCount(ReadOnlySpan`1<char> chars, Int32& charsConsumed);
    internal bool TryDrainLeftoverDataForGetBytes(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, Int32& charsConsumed, Int32& bytesWritten);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Text.EncoderReplacementFallback : EncoderFallback {
    private string _strDefault;
    public string DefaultString { get; }
    public int MaxCharCount { get; }
    public EncoderReplacementFallback(string replacement);
    public string get_DefaultString();
    public virtual EncoderFallbackBuffer CreateFallbackBuffer();
    public virtual int get_MaxCharCount();
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
public class System.Text.EncoderReplacementFallbackBuffer : EncoderFallbackBuffer {
    private string _strDefault;
    private int _fallbackCount;
    private int _fallbackIndex;
    public int Remaining { get; }
    [NullableContextAttribute("1")]
public EncoderReplacementFallbackBuffer(EncoderReplacementFallback fallback);
    public virtual bool Fallback(char charUnknown, int index);
    public virtual bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
    public virtual int get_Remaining();
    public virtual void Reset();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Text.Encoding : object {
    private static UTF8EncodingSealed s_defaultEncoding;
    internal int _codePage;
    internal CodePageDataItem _dataItem;
    [OptionalFieldAttribute]
private bool _isReadOnly;
    internal EncoderFallback encoderFallback;
    internal DecoderFallback decoderFallback;
    public static Encoding Default { get; }
    [NullableAttribute("0")]
public ReadOnlySpan`1<byte> Preamble { get; }
    public string BodyName { get; }
    public string EncodingName { get; }
    public string HeaderName { get; }
    public string WebName { get; }
    public int WindowsCodePage { get; }
    public bool IsBrowserDisplay { get; }
    public bool IsBrowserSave { get; }
    public bool IsMailNewsDisplay { get; }
    public bool IsMailNewsSave { get; }
    public bool IsSingleByte { get; }
    public EncoderFallback EncoderFallback { get; public set; }
    public DecoderFallback DecoderFallback { get; public set; }
    public bool IsReadOnly { get; private protected set; }
    public static Encoding ASCII { get; }
    private static Encoding Latin1 { get; }
    public int CodePage { get; }
    public static Encoding Unicode { get; }
    public static Encoding BigEndianUnicode { get; }
    public static Encoding UTF7 { get; }
    public static Encoding UTF8 { get; }
    public static Encoding UTF32 { get; }
    private static Encoding BigEndianUTF32 { get; }
    protected Encoding(int codePage);
    [NullableContextAttribute("2")]
protected Encoding(int codePage, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
    private static Encoding();
    public static Encoding get_Default();
    internal virtual void SetDefaultFallbacks();
    public static Byte[] Convert(Encoding srcEncoding, Encoding dstEncoding, Byte[] bytes);
    public static Byte[] Convert(Encoding srcEncoding, Encoding dstEncoding, Byte[] bytes, int index, int count);
    public static void RegisterProvider(EncodingProvider provider);
    public static Encoding GetEncoding(int codepage);
    public static Encoding GetEncoding(int codepage, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
    public static Encoding GetEncoding(string name);
    public static Encoding GetEncoding(string name, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
    public static EncodingInfo[] GetEncodings();
    public virtual Byte[] GetPreamble();
    [NullableContextAttribute("0")]
public virtual ReadOnlySpan`1<byte> get_Preamble();
    private void GetDataItem();
    public virtual string get_BodyName();
    public virtual string get_EncodingName();
    public virtual string get_HeaderName();
    public virtual string get_WebName();
    public virtual int get_WindowsCodePage();
    public virtual bool get_IsBrowserDisplay();
    public virtual bool get_IsBrowserSave();
    public virtual bool get_IsMailNewsDisplay();
    public virtual bool get_IsMailNewsSave();
    public virtual bool get_IsSingleByte();
    public EncoderFallback get_EncoderFallback();
    public void set_EncoderFallback(EncoderFallback value);
    public DecoderFallback get_DecoderFallback();
    public void set_DecoderFallback(DecoderFallback value);
    public virtual object Clone();
    public bool get_IsReadOnly();
    private protected void set_IsReadOnly(bool value);
    public static Encoding get_ASCII();
    private static Encoding get_Latin1();
    public virtual int GetByteCount(Char[] chars);
    public virtual int GetByteCount(string s);
    public abstract virtual int GetByteCount(Char[] chars, int index, int count);
    public int GetByteCount(string s, int index, int count);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count);
    [NullableContextAttribute("0")]
public virtual int GetByteCount(ReadOnlySpan`1<char> chars);
    public virtual Byte[] GetBytes(Char[] chars);
    public virtual Byte[] GetBytes(Char[] chars, int index, int count);
    public abstract virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual Byte[] GetBytes(string s);
    public Byte[] GetBytes(string s, int index, int count);
    public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [CLSCompliantAttribute("False")]
[NullableContextAttribute("0")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    [NullableContextAttribute("0")]
public virtual int GetBytes(ReadOnlySpan`1<char> chars, Span`1<byte> bytes);
    public virtual int GetCharCount(Byte[] bytes);
    public abstract virtual int GetCharCount(Byte[] bytes, int index, int count);
    [CLSCompliantAttribute("False")]
[NullableContextAttribute("0")]
public virtual int GetCharCount(Byte* bytes, int count);
    [NullableContextAttribute("0")]
public virtual int GetCharCount(ReadOnlySpan`1<byte> bytes);
    public virtual Char[] GetChars(Byte[] bytes);
    public virtual Char[] GetChars(Byte[] bytes, int index, int count);
    public abstract virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    [NullableContextAttribute("0")]
public virtual int GetChars(ReadOnlySpan`1<byte> bytes, Span`1<char> chars);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public string GetString(Byte* bytes, int byteCount);
    [NullableContextAttribute("0")]
public string GetString(ReadOnlySpan`1<byte> bytes);
    public virtual int get_CodePage();
    public bool IsAlwaysNormalized();
    public virtual bool IsAlwaysNormalized(NormalizationForm form);
    public virtual Decoder GetDecoder();
    public virtual Encoder GetEncoder();
    public abstract virtual int GetMaxByteCount(int charCount);
    public abstract virtual int GetMaxCharCount(int byteCount);
    public virtual string GetString(Byte[] bytes);
    public virtual string GetString(Byte[] bytes, int index, int count);
    public static Encoding get_Unicode();
    public static Encoding get_BigEndianUnicode();
    public static Encoding get_UTF7();
    public static Encoding get_UTF8();
    public static Encoding get_UTF32();
    private static Encoding get_BigEndianUTF32();
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public virtual int GetHashCode();
    internal virtual Char[] GetBestFitUnicodeToBytesData();
    internal virtual Char[] GetBestFitBytesToUnicodeData();
    [DoesNotReturnAttribute]
internal void ThrowBytesOverflow();
    internal void ThrowBytesOverflow(EncoderNLS encoder, bool nothingEncoded);
    [DoesNotReturnAttribute]
[StackTraceHiddenAttribute]
internal static void ThrowConversionOverflow();
    [StackTraceHiddenAttribute]
[DoesNotReturnAttribute]
internal void ThrowCharsOverflow();
    internal void ThrowCharsOverflow(DecoderNLS decoder, bool nothingDecoded);
    internal virtual OperationStatus DecodeFirstRune(ReadOnlySpan`1<byte> bytes, Rune& value, Int32& bytesConsumed);
    internal virtual OperationStatus EncodeRune(Rune value, Span`1<byte> bytes, Int32& bytesWritten);
    internal virtual bool TryGetByteCount(Rune value, Int32& byteCount);
    internal virtual int GetByteCount(Char* pChars, int charCount, EncoderNLS encoder);
    private protected virtual int GetByteCountFast(Char* pChars, int charsLength, EncoderFallback fallback, Int32& charsConsumed);
    private protected int GetByteCountWithFallback(Char* pCharsOriginal, int originalCharCount, int charsConsumedSoFar);
    private int GetByteCountWithFallback(Char* pOriginalChars, int originalCharCount, int charsConsumedSoFar, EncoderNLS encoder);
    private protected virtual int GetByteCountWithFallback(ReadOnlySpan`1<char> chars, int originalCharsLength, EncoderNLS encoder);
    internal virtual int GetBytes(Char* pChars, int charCount, Byte* pBytes, int byteCount, EncoderNLS encoder);
    private protected virtual int GetBytesFast(Char* pChars, int charsLength, Byte* pBytes, int bytesLength, Int32& charsConsumed);
    private protected int GetBytesWithFallback(Char* pOriginalChars, int originalCharCount, Byte* pOriginalBytes, int originalByteCount, int charsConsumedSoFar, int bytesWrittenSoFar);
    private int GetBytesWithFallback(Char* pOriginalChars, int originalCharCount, Byte* pOriginalBytes, int originalByteCount, int charsConsumedSoFar, int bytesWrittenSoFar, EncoderNLS encoder);
    private protected virtual int GetBytesWithFallback(ReadOnlySpan`1<char> chars, int originalCharsLength, Span`1<byte> bytes, int originalBytesLength, EncoderNLS encoder);
    internal virtual int GetCharCount(Byte* pBytes, int byteCount, DecoderNLS decoder);
    private protected virtual int GetCharCountFast(Byte* pBytes, int bytesLength, DecoderFallback fallback, Int32& bytesConsumed);
    private protected int GetCharCountWithFallback(Byte* pBytesOriginal, int originalByteCount, int bytesConsumedSoFar);
    private int GetCharCountWithFallback(Byte* pOriginalBytes, int originalByteCount, int bytesConsumedSoFar, DecoderNLS decoder);
    private int GetCharCountWithFallback(ReadOnlySpan`1<byte> bytes, int originalBytesLength, DecoderNLS decoder);
    internal virtual int GetChars(Byte* pBytes, int byteCount, Char* pChars, int charCount, DecoderNLS decoder);
    private protected virtual int GetCharsFast(Byte* pBytes, int bytesLength, Char* pChars, int charsLength, Int32& bytesConsumed);
    private protected int GetCharsWithFallback(Byte* pOriginalBytes, int originalByteCount, Char* pOriginalChars, int originalCharCount, int bytesConsumedSoFar, int charsWrittenSoFar);
    private protected int GetCharsWithFallback(Byte* pOriginalBytes, int originalByteCount, Char* pOriginalChars, int originalCharCount, int bytesConsumedSoFar, int charsWrittenSoFar, DecoderNLS decoder);
    private protected virtual int GetCharsWithFallback(ReadOnlySpan`1<byte> bytes, int originalBytesLength, Span`1<char> chars, int originalCharsLength, DecoderNLS decoder);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Text.EncodingInfo : object {
    [CompilerGeneratedAttribute]
private int <CodePage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    public int CodePage { get; }
    public string Name { get; }
    public string DisplayName { get; }
    internal EncodingInfo(int codePage, string name, string displayName);
    [CompilerGeneratedAttribute]
public int get_CodePage();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    public Encoding GetEncoding();
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
internal abstract class System.Text.EncodingNLS : Encoding {
    protected EncodingNLS(int codePage);
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetByteCount(string s);
    public virtual int GetByteCount(Char* chars, int count);
    public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    public virtual int GetCharCount(Byte* bytes, int count);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    public virtual string GetString(Byte[] bytes, int index, int count);
    public virtual Decoder GetDecoder();
    public virtual Encoder GetEncoder();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Text.EncodingProvider : object {
    private static object s_InternalSyncObject;
    private static EncodingProvider[] modreq(System.Runtime.CompilerServices.IsVolatile) s_providers;
    private static EncodingProvider();
    public abstract virtual Encoding GetEncoding(string name);
    [NullableContextAttribute("2")]
public abstract virtual Encoding GetEncoding(int codepage);
    public virtual Encoding GetEncoding(string name, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
    public virtual Encoding GetEncoding(int codepage, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
    internal static void AddProvider(EncodingProvider provider);
    internal static Encoding GetEncodingFromProvider(int codepage);
    internal static Encoding GetEncodingFromProvider(string encodingName);
    internal static Encoding GetEncodingFromProvider(int codepage, EncoderFallback enc, DecoderFallback dec);
    internal static Encoding GetEncodingFromProvider(string encodingName, EncoderFallback enc, DecoderFallback dec);
}
internal static class System.Text.EncodingTable : object {
    private static Int32[] s_encodingNameIndices;
    private static UInt16[] s_codePagesByName;
    private static UInt16[] s_mappedCodePages;
    private static Int32[] s_uiFamilyCodePages;
    private static Int32[] s_webNameIndices;
    private static Int32[] s_englishNameIndices;
    private static UInt32[] s_flags;
    private static Hashtable s_nameToCodePage;
    private static CodePageDataItem[] s_codePageToCodePageData;
    private static EncodingTable();
    internal static int GetCodePageFromName(string name);
    private static int InternalGetCodePageFromName(string name);
    internal static EncodingInfo[] GetEncodings();
    internal static CodePageDataItem GetCodePageDataItem(int codePage);
    private static CodePageDataItem InternalGetCodePageDataItem(int codePage, int index);
    private static string GetDisplayName(int codePage, int englishNameIndex);
}
internal class System.Text.InternalDecoderBestFitFallback : DecoderFallback {
    internal Encoding _encoding;
    internal Char[] _arrayBestFit;
    internal char _cReplacement;
    public int MaxCharCount { get; }
    internal InternalDecoderBestFitFallback(Encoding encoding);
    public virtual DecoderFallbackBuffer CreateFallbackBuffer();
    public virtual int get_MaxCharCount();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
internal class System.Text.InternalDecoderBestFitFallbackBuffer : DecoderFallbackBuffer {
    private char _cBestFit;
    private int _iCount;
    private int _iSize;
    private InternalDecoderBestFitFallback _oFallback;
    private static object s_InternalSyncObject;
    private static object InternalSyncObject { get; }
    public int Remaining { get; }
    public InternalDecoderBestFitFallbackBuffer(InternalDecoderBestFitFallback fallback);
    private static object get_InternalSyncObject();
    public virtual bool Fallback(Byte[] bytesUnknown, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
    public virtual int get_Remaining();
    public virtual void Reset();
    internal virtual int InternalFallback(Byte[] bytes, Byte* pBytes);
    private char TryBestFit(Byte[] bytesCheck);
}
internal class System.Text.InternalEncoderBestFitFallback : EncoderFallback {
    internal Encoding _encoding;
    internal Char[] _arrayBestFit;
    public int MaxCharCount { get; }
    internal InternalEncoderBestFitFallback(Encoding encoding);
    public virtual EncoderFallbackBuffer CreateFallbackBuffer();
    public virtual int get_MaxCharCount();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
internal class System.Text.InternalEncoderBestFitFallbackBuffer : EncoderFallbackBuffer {
    private char _cBestFit;
    private InternalEncoderBestFitFallback _oFallback;
    private int _iCount;
    private int _iSize;
    private static object s_InternalSyncObject;
    private static object InternalSyncObject { get; }
    public int Remaining { get; }
    public InternalEncoderBestFitFallbackBuffer(InternalEncoderBestFitFallback fallback);
    private static object get_InternalSyncObject();
    public virtual bool Fallback(char charUnknown, int index);
    public virtual bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
    public virtual int get_Remaining();
    public virtual void Reset();
    private char TryBestFit(char cUnknown);
}
internal class System.Text.Latin1Encoding : EncodingNLS {
    internal static Latin1Encoding s_default;
    private static Char[] arrayCharBestFit;
    public bool IsSingleByte { get; }
    private static Latin1Encoding();
    internal virtual int GetByteCount(Char* chars, int charCount, EncoderNLS encoder);
    internal virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS encoder);
    internal virtual int GetCharCount(Byte* bytes, int count, DecoderNLS decoder);
    internal virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS decoder);
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual bool get_IsSingleByte();
    public virtual bool IsAlwaysNormalized(NormalizationForm form);
    internal virtual Char[] GetBestFitUnicodeToBytesData();
}
public enum System.Text.NormalizationForm : Enum {
    public int value__;
    public static NormalizationForm FormC;
    public static NormalizationForm FormD;
    public static NormalizationForm FormKC;
    public static NormalizationForm FormKD;
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
[IsReadOnlyAttribute]
public class System.Text.Rune : ValueType {
    private UInt32 _value;
    private static ReadOnlySpan`1<byte> AsciiCharInfo { get; }
    [NullableAttribute("1")]
private string DebuggerDisplay { get; }
    public bool IsAscii { get; }
    public bool IsBmp { get; }
    public int Plane { get; }
    public static Rune ReplacementChar { get; }
    public int Utf16SequenceLength { get; }
    public int Utf8SequenceLength { get; }
    public int Value { get; }
    public Rune(char ch);
    public Rune(char highSurrogate, char lowSurrogate);
    public Rune(int value);
    [CLSCompliantAttribute("False")]
public Rune(UInt32 value);
    private Rune(UInt32 scalarValue, bool unused);
    private static ReadOnlySpan`1<byte> get_AsciiCharInfo();
    public static bool op_Equality(Rune left, Rune right);
    public static bool op_Inequality(Rune left, Rune right);
    public static bool op_LessThan(Rune left, Rune right);
    public static bool op_LessThanOrEqual(Rune left, Rune right);
    public static bool op_GreaterThan(Rune left, Rune right);
    public static bool op_GreaterThanOrEqual(Rune left, Rune right);
    public static Rune op_Explicit(char ch);
    [CLSCompliantAttribute("False")]
public static Rune op_Explicit(UInt32 value);
    public static Rune op_Explicit(int value);
    private string get_DebuggerDisplay();
    public bool get_IsAscii();
    public bool get_IsBmp();
    public int get_Plane();
    public static Rune get_ReplacementChar();
    public int get_Utf16SequenceLength();
    public int get_Utf8SequenceLength();
    public int get_Value();
    private static Rune ChangeCaseCultureAware(Rune rune, TextInfo textInfo, bool toUpper);
    public sealed virtual int CompareTo(Rune other);
    public static OperationStatus DecodeFromUtf16(ReadOnlySpan`1<char> source, Rune& result, Int32& charsConsumed);
    public static OperationStatus DecodeFromUtf8(ReadOnlySpan`1<byte> source, Rune& result, Int32& bytesConsumed);
    public static OperationStatus DecodeLastFromUtf16(ReadOnlySpan`1<char> source, Rune& result, Int32& charsConsumed);
    public static OperationStatus DecodeLastFromUtf8(ReadOnlySpan`1<byte> source, Rune& value, Int32& bytesConsumed);
    public int EncodeToUtf16(Span`1<char> destination);
    public int EncodeToUtf8(Span`1<byte> destination);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Rune other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public static Rune GetRuneAt(string input, int index);
    public static bool IsValid(int value);
    [CLSCompliantAttribute("False")]
public static bool IsValid(UInt32 value);
    internal static int ReadFirstRuneFromUtf16Buffer(ReadOnlySpan`1<char> input);
    private static int ReadRuneFromString(string input, int index);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public static bool TryCreate(char ch, Rune& result);
    public static bool TryCreate(char highSurrogate, char lowSurrogate, Rune& result);
    public static bool TryCreate(int value, Rune& result);
    [CLSCompliantAttribute("False")]
public static bool TryCreate(UInt32 value, Rune& result);
    public bool TryEncodeToUtf16(Span`1<char> destination, Int32& charsWritten);
    public bool TryEncodeToUtf8(Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("1")]
public static bool TryGetRuneAt(string input, int index, Rune& value);
    internal static Rune UnsafeCreate(UInt32 scalarValue);
    public static double GetNumericValue(Rune value);
    public static UnicodeCategory GetUnicodeCategory(Rune value);
    private static UnicodeCategory GetUnicodeCategoryNonAscii(Rune value);
    private static bool IsCategoryLetter(UnicodeCategory category);
    private static bool IsCategoryLetterOrDecimalDigit(UnicodeCategory category);
    private static bool IsCategoryNumber(UnicodeCategory category);
    private static bool IsCategoryPunctuation(UnicodeCategory category);
    private static bool IsCategorySeparator(UnicodeCategory category);
    private static bool IsCategorySymbol(UnicodeCategory category);
    public static bool IsControl(Rune value);
    public static bool IsDigit(Rune value);
    public static bool IsLetter(Rune value);
    public static bool IsLetterOrDigit(Rune value);
    public static bool IsLower(Rune value);
    public static bool IsNumber(Rune value);
    public static bool IsPunctuation(Rune value);
    public static bool IsSeparator(Rune value);
    public static bool IsSymbol(Rune value);
    public static bool IsUpper(Rune value);
    public static bool IsWhiteSpace(Rune value);
    [NullableContextAttribute("1")]
public static Rune ToLower(Rune value, CultureInfo culture);
    public static Rune ToLowerInvariant(Rune value);
    [NullableContextAttribute("1")]
public static Rune ToUpper(Rune value, CultureInfo culture);
    public static Rune ToUpperInvariant(Rune value);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
public class System.Text.SpanRuneEnumerator : ValueType {
    private ReadOnlySpan`1<char> _remaining;
    private Rune _current;
    public Rune Current { get; }
    internal SpanRuneEnumerator(ReadOnlySpan`1<char> buffer);
    public Rune get_Current();
    public SpanRuneEnumerator GetEnumerator();
    public bool MoveNext();
}
[NullableAttribute("0")]
[DefaultMemberAttribute("Chars")]
[NullableContextAttribute("1")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Text.StringBuilder : object {
    internal Char[] m_ChunkChars;
    internal StringBuilder m_ChunkPrevious;
    internal int m_ChunkLength;
    internal int m_ChunkOffset;
    internal int m_MaxCapacity;
    public int Capacity { get; public set; }
    public int MaxCapacity { get; }
    public int Length { get; public set; }
    public char Chars { get; public set; }
    [NullableAttribute("0")]
private Span`1<char> RemainingCurrentChunk { get; }
    public StringBuilder(int capacity);
    [NullableContextAttribute("2")]
public StringBuilder(string value);
    [NullableContextAttribute("2")]
public StringBuilder(string value, int capacity);
    [NullableContextAttribute("2")]
public StringBuilder(string value, int startIndex, int length, int capacity);
    public StringBuilder(int capacity, int maxCapacity);
    private StringBuilder(SerializationInfo info, StreamingContext context);
    private StringBuilder(StringBuilder from);
    private StringBuilder(int size, int maxCapacity, StringBuilder previousBlock);
    private int GetReplaceBufferCapacity(int requiredCapacity);
    internal void ReplaceBufferInternal(Char* newBuffer, int newLength);
    internal void ReplaceBufferUtf8Internal(ReadOnlySpan`1<byte> source);
    internal void ReplaceBufferAnsiInternal(SByte* newBuffer, int newLength);
    internal void InternalCopy(IntPtr dest, int len);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public int get_Capacity();
    public void set_Capacity(int value);
    public int get_MaxCapacity();
    public int EnsureCapacity(int capacity);
    public virtual string ToString();
    public string ToString(int startIndex, int length);
    public StringBuilder Clear();
    public int get_Length();
    public void set_Length(int value);
    public char get_Chars(int index);
    public void set_Chars(int index, char value);
    public ChunkEnumerator GetChunks();
    public StringBuilder Append(char value, int repeatCount);
    public StringBuilder Append(Char[] value, int startIndex, int charCount);
    public StringBuilder Append(string value);
    private void AppendHelper(string value);
    public StringBuilder Append(string value, int startIndex, int count);
    public StringBuilder Append(StringBuilder value);
    public StringBuilder Append(StringBuilder value, int startIndex, int count);
    private StringBuilder AppendCore(StringBuilder value, int startIndex, int count);
    public StringBuilder AppendLine();
    public StringBuilder AppendLine(string value);
    public void CopyTo(int sourceIndex, Char[] destination, int destinationIndex, int count);
    [NullableContextAttribute("0")]
public void CopyTo(int sourceIndex, Span`1<char> destination, int count);
    public StringBuilder Insert(int index, string value, int count);
    public StringBuilder Remove(int startIndex, int length);
    public StringBuilder Append(bool value);
    public StringBuilder Append(char value);
    [CLSCompliantAttribute("False")]
public StringBuilder Append(sbyte value);
    public StringBuilder Append(byte value);
    public StringBuilder Append(short value);
    public StringBuilder Append(int value);
    public StringBuilder Append(long value);
    public StringBuilder Append(float value);
    public StringBuilder Append(double value);
    public StringBuilder Append(decimal value);
    [CLSCompliantAttribute("False")]
public StringBuilder Append(ushort value);
    [CLSCompliantAttribute("False")]
public StringBuilder Append(UInt32 value);
    [CLSCompliantAttribute("False")]
public StringBuilder Append(ulong value);
    private StringBuilder AppendSpanFormattable(T value);
    internal StringBuilder AppendSpanFormattable(T value, string format, IFormatProvider provider);
    public StringBuilder Append(object value);
    public StringBuilder Append(Char[] value);
    [NullableContextAttribute("0")]
public StringBuilder Append(ReadOnlySpan`1<char> value);
    [NullableContextAttribute("0")]
public StringBuilder Append(ReadOnlyMemory`1<char> value);
    public StringBuilder AppendJoin(string separator, Object[] values);
    public StringBuilder AppendJoin(string separator, IEnumerable`1<T> values);
    public StringBuilder AppendJoin(string separator, String[] values);
    public StringBuilder AppendJoin(char separator, Object[] values);
    public StringBuilder AppendJoin(char separator, IEnumerable`1<T> values);
    public StringBuilder AppendJoin(char separator, String[] values);
    private StringBuilder AppendJoinCore(Char* separator, int separatorLength, IEnumerable`1<T> values);
    private StringBuilder AppendJoinCore(Char* separator, int separatorLength, T[] values);
    public StringBuilder Insert(int index, string value);
    public StringBuilder Insert(int index, bool value);
    [CLSCompliantAttribute("False")]
public StringBuilder Insert(int index, sbyte value);
    public StringBuilder Insert(int index, byte value);
    public StringBuilder Insert(int index, short value);
    public StringBuilder Insert(int index, char value);
    public StringBuilder Insert(int index, Char[] value);
    public StringBuilder Insert(int index, Char[] value, int startIndex, int charCount);
    public StringBuilder Insert(int index, int value);
    public StringBuilder Insert(int index, long value);
    public StringBuilder Insert(int index, float value);
    public StringBuilder Insert(int index, double value);
    public StringBuilder Insert(int index, decimal value);
    [CLSCompliantAttribute("False")]
public StringBuilder Insert(int index, ushort value);
    [CLSCompliantAttribute("False")]
public StringBuilder Insert(int index, UInt32 value);
    [CLSCompliantAttribute("False")]
public StringBuilder Insert(int index, ulong value);
    public StringBuilder Insert(int index, object value);
    [NullableContextAttribute("0")]
public StringBuilder Insert(int index, ReadOnlySpan`1<char> value);
    public StringBuilder AppendFormat(string format, object arg0);
    public StringBuilder AppendFormat(string format, object arg0, object arg1);
    [NullableContextAttribute("2")]
public StringBuilder AppendFormat(string format, object arg0, object arg1, object arg2);
    public StringBuilder AppendFormat(string format, Object[] args);
    public StringBuilder AppendFormat(IFormatProvider provider, string format, object arg0);
    [NullableContextAttribute("2")]
public StringBuilder AppendFormat(IFormatProvider provider, string format, object arg0, object arg1);
    [NullableContextAttribute("2")]
public StringBuilder AppendFormat(IFormatProvider provider, string format, object arg0, object arg1, object arg2);
    public StringBuilder AppendFormat(IFormatProvider provider, string format, Object[] args);
    private static void FormatError();
    internal StringBuilder AppendFormatHelper(IFormatProvider provider, string format, ParamsArray args);
    public StringBuilder Replace(string oldValue, string newValue);
    [NullableContextAttribute("2")]
public bool Equals(StringBuilder sb);
    [NullableContextAttribute("0")]
public bool Equals(ReadOnlySpan`1<char> span);
    public StringBuilder Replace(string oldValue, string newValue, int startIndex, int count);
    public StringBuilder Replace(char oldChar, char newChar);
    public StringBuilder Replace(char oldChar, char newChar, int startIndex, int count);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public StringBuilder Append(Char* value, int valueCount);
    private void Insert(int index, Char* value, int valueCount);
    private void ReplaceAllInChunk(Int32[] replacements, int replacementsCount, StringBuilder sourceChunk, int removeCount, string value);
    private bool StartsWith(StringBuilder chunk, int indexInChunk, int count, string value);
    private void ReplaceInPlaceAtChunk(StringBuilder& chunk, Int32& indexInChunk, Char* value, int count);
    private static void ThreadSafeCopy(Char* sourcePtr, Char[] destination, int destinationIndex, int count);
    private static void ThreadSafeCopy(Char[] source, int sourceIndex, Span`1<char> destination, int destinationIndex, int count);
    private StringBuilder FindChunkForIndex(int index);
    private StringBuilder FindChunkForByte(int byteIndex);
    private Span`1<char> get_RemainingCurrentChunk();
    private StringBuilder Next(StringBuilder chunk);
    private void ExpandByABlock(int minBlockCharCount);
    private void MakeRoom(int index, int count, StringBuilder& chunk, Int32& indexInChunk, bool doNotMoveFollowingChars);
    private void Remove(int startIndex, int count, StringBuilder& chunk, Int32& indexInChunk);
}
internal static class System.Text.StringBuilderCache : object {
    [ThreadStaticAttribute]
private static StringBuilder t_cachedInstance;
    public static StringBuilder Acquire(int capacity);
    public static void Release(StringBuilder sb);
    public static string GetStringAndRelease(StringBuilder sb);
}
public class System.Text.StringRuneEnumerator : ValueType {
    private string _string;
    private Rune _current;
    private int _nextIndex;
    public Rune Current { get; }
    [NullableAttribute("2")]
private object System.Collections.IEnumerator.Current { get; }
    internal StringRuneEnumerator(string value);
    public sealed virtual Rune get_Current();
    public StringRuneEnumerator GetEnumerator();
    public sealed virtual bool MoveNext();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    private sealed virtual override void System.IDisposable.Dispose();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<Rune> System.Collections.Generic.IEnumerable<System.Text.Rune>.GetEnumerator();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
}
internal static class System.Text.Unicode.Utf16Utility : object {
    internal static bool AllCharsInUInt32AreAscii(UInt32 value);
    internal static bool AllCharsInUInt64AreAscii(ulong value);
    internal static UInt32 ConvertAllAsciiCharsInUInt32ToLowercase(UInt32 value);
    internal static UInt32 ConvertAllAsciiCharsInUInt32ToUppercase(UInt32 value);
    internal static bool UInt32ContainsAnyLowercaseAsciiChar(UInt32 value);
    internal static bool UInt32ContainsAnyUppercaseAsciiChar(UInt32 value);
    internal static bool UInt32OrdinalIgnoreCaseAscii(UInt32 valueA, UInt32 valueB);
    internal static bool UInt64OrdinalIgnoreCaseAscii(ulong valueA, ulong valueB);
    public static Char* GetPointerToFirstInvalidChar(Char* pInputBuffer, int inputLength, Int64& utf8CodeUnitCountAdjustment, Int32& scalarCountAdjustment);
}
public static class System.Text.Unicode.Utf8 : object {
    public static OperationStatus FromUtf16(ReadOnlySpan`1<char> source, Span`1<byte> destination, Int32& charsRead, Int32& bytesWritten, bool replaceInvalidSequences, bool isFinalBlock);
    public static OperationStatus ToUtf16(ReadOnlySpan`1<byte> source, Span`1<char> destination, Int32& bytesRead, Int32& charsWritten, bool replaceInvalidSequences, bool isFinalBlock);
}
internal static class System.Text.Unicode.Utf8Utility : object {
    private static UInt32 ExtractCharFromFirstThreeByteSequence(UInt32 value);
    private static UInt32 ExtractCharFromFirstTwoByteSequence(UInt32 value);
    private static UInt32 ExtractCharsFromFourByteSequence(UInt32 value);
    private static UInt32 ExtractFourUtf8BytesFromSurrogatePair(UInt32 value);
    private static UInt32 ExtractTwoCharsPackedFromTwoAdjacentTwoByteSequences(UInt32 value);
    private static UInt32 ExtractTwoUtf8TwoByteSequencesFromTwoPackedUtf16Chars(UInt32 value);
    private static UInt32 ExtractUtf8TwoByteSequenceFromFirstUtf16Char(UInt32 value);
    private static bool IsFirstCharAscii(UInt32 value);
    private static bool IsFirstCharAtLeastThreeUtf8Bytes(UInt32 value);
    private static bool IsFirstCharSurrogate(UInt32 value);
    private static bool IsFirstCharTwoUtf8Bytes(UInt32 value);
    private static bool IsLowByteUtf8ContinuationByte(UInt32 value);
    private static bool IsSecondCharAscii(UInt32 value);
    private static bool IsSecondCharAtLeastThreeUtf8Bytes(UInt32 value);
    private static bool IsSecondCharSurrogate(UInt32 value);
    private static bool IsSecondCharTwoUtf8Bytes(UInt32 value);
    private static bool IsUtf8ContinuationByte(Byte& value);
    private static bool IsWellFormedUtf16SurrogatePair(UInt32 value);
    private static UInt32 ToLittleEndian(UInt32 value);
    private static bool UInt32BeginsWithOverlongUtf8TwoByteSequence(UInt32 value);
    private static bool UInt32BeginsWithUtf8FourByteMask(UInt32 value);
    private static bool UInt32BeginsWithUtf8ThreeByteMask(UInt32 value);
    private static bool UInt32BeginsWithUtf8TwoByteMask(UInt32 value);
    private static bool UInt32EndsWithOverlongUtf8TwoByteSequence(UInt32 value);
    private static bool UInt32EndsWithUtf8TwoByteMask(UInt32 value);
    private static bool UInt32BeginsWithValidUtf8TwoByteSequenceLittleEndian(UInt32 value);
    private static bool UInt32EndsWithValidUtf8TwoByteSequenceLittleEndian(UInt32 value);
    private static bool UInt32FirstByteIsAscii(UInt32 value);
    private static bool UInt32FourthByteIsAscii(UInt32 value);
    private static bool UInt32SecondByteIsAscii(UInt32 value);
    private static bool UInt32ThirdByteIsAscii(UInt32 value);
    private static void WriteTwoUtf16CharsAsTwoUtf8ThreeByteSequences(Byte& outputBuffer, UInt32 value);
    private static void WriteFirstUtf16CharAsUtf8ThreeByteSequence(Byte& outputBuffer, UInt32 value);
    public static OperationStatus TranscodeToUtf16(Byte* pInputBuffer, int inputLength, Char* pOutputBuffer, int outputCharsRemaining, Byte*& pInputBufferRemaining, Char*& pOutputBufferRemaining);
    public static OperationStatus TranscodeToUtf8(Char* pInputBuffer, int inputLength, Byte* pOutputBuffer, int outputBytesRemaining, Char*& pInputBufferRemaining, Byte*& pOutputBufferRemaining);
    public static Byte* GetPointerToFirstInvalidByte(Byte* pInputBuffer, int inputLength, Int32& utf16CodeUnitCountAdjustment, Int32& scalarCountAdjustment);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Text.UnicodeEncoding : Encoding {
    internal static UnicodeEncoding s_bigEndianDefault;
    internal static UnicodeEncoding s_littleEndianDefault;
    private bool isThrowException;
    private bool bigEndian;
    private bool byteOrderMark;
    public static int CharSize;
    [NullableAttribute("0")]
public ReadOnlySpan`1<byte> Preamble { get; }
    public UnicodeEncoding(bool bigEndian, bool byteOrderMark);
    public UnicodeEncoding(bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes);
    private static UnicodeEncoding();
    internal sealed virtual void SetDefaultFallbacks();
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetByteCount(string s);
    [CLSCompliantAttribute("False")]
[NullableContextAttribute("0")]
public virtual int GetByteCount(Char* chars, int count);
    public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    [CLSCompliantAttribute("False")]
[NullableContextAttribute("0")]
public virtual int GetCharCount(Byte* bytes, int count);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    [CLSCompliantAttribute("False")]
[NullableContextAttribute("0")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    public virtual string GetString(Byte[] bytes, int index, int count);
    internal sealed virtual int GetByteCount(Char* chars, int count, EncoderNLS encoder);
    internal sealed virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS encoder);
    internal sealed virtual int GetCharCount(Byte* bytes, int count, DecoderNLS baseDecoder);
    internal sealed virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS baseDecoder);
    public virtual Encoder GetEncoder();
    public virtual Decoder GetDecoder();
    public virtual Byte[] GetPreamble();
    [NullableContextAttribute("0")]
public virtual ReadOnlySpan`1<byte> get_Preamble();
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
internal static class System.Text.UnicodeUtility : object {
    public static int GetPlane(UInt32 codePoint);
    public static UInt32 GetScalarFromUtf16SurrogatePair(UInt32 highSurrogateCodePoint, UInt32 lowSurrogateCodePoint);
    public static int GetUtf16SequenceLength(UInt32 value);
    public static void GetUtf16SurrogatesFromSupplementaryPlaneScalar(UInt32 value, Char& highSurrogateCodePoint, Char& lowSurrogateCodePoint);
    public static int GetUtf8SequenceLength(UInt32 value);
    public static bool IsAsciiCodePoint(UInt32 value);
    public static bool IsBmpCodePoint(UInt32 value);
    public static bool IsHighSurrogateCodePoint(UInt32 value);
    public static bool IsInRangeInclusive(UInt32 value, UInt32 lowerBound, UInt32 upperBound);
    public static bool IsLowSurrogateCodePoint(UInt32 value);
    public static bool IsSurrogateCodePoint(UInt32 value);
    public static bool IsValidUnicodeScalar(UInt32 value);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Text.UTF32Encoding : Encoding {
    internal static UTF32Encoding s_default;
    internal static UTF32Encoding s_bigEndianDefault;
    private bool _emitUTF32ByteOrderMark;
    private bool _isThrowException;
    private bool _bigEndian;
    [NullableAttribute("0")]
public ReadOnlySpan`1<byte> Preamble { get; }
    public UTF32Encoding(bool bigEndian, bool byteOrderMark);
    public UTF32Encoding(bool bigEndian, bool byteOrderMark, bool throwOnInvalidCharacters);
    private static UTF32Encoding();
    internal virtual void SetDefaultFallbacks();
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetByteCount(string s);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count);
    public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    [CLSCompliantAttribute("False")]
[NullableContextAttribute("0")]
public virtual int GetCharCount(Byte* bytes, int count);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    [CLSCompliantAttribute("False")]
[NullableContextAttribute("0")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    public virtual string GetString(Byte[] bytes, int index, int count);
    internal virtual int GetByteCount(Char* chars, int count, EncoderNLS encoder);
    internal virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS encoder);
    internal virtual int GetCharCount(Byte* bytes, int count, DecoderNLS baseDecoder);
    internal virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS baseDecoder);
    private UInt32 GetSurrogate(char cHigh, char cLow);
    private char GetHighSurrogate(UInt32 iChar);
    private char GetLowSurrogate(UInt32 iChar);
    public virtual Decoder GetDecoder();
    public virtual Encoder GetEncoder();
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual Byte[] GetPreamble();
    [NullableContextAttribute("0")]
public virtual ReadOnlySpan`1<byte> get_Preamble();
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Text.UTF7Encoding : Encoding {
    internal static UTF7Encoding s_default;
    private Byte[] _base64Bytes;
    private SByte[] _base64Values;
    private Boolean[] _directEncode;
    private bool _allowOptionals;
    public UTF7Encoding(bool allowOptionals);
    private static UTF7Encoding();
    private void MakeTables();
    internal sealed virtual void SetDefaultFallbacks();
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetByteCount(string s);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count);
    public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [CLSCompliantAttribute("False")]
[NullableContextAttribute("0")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    [CLSCompliantAttribute("False")]
[NullableContextAttribute("0")]
public virtual int GetCharCount(Byte* bytes, int count);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    [CLSCompliantAttribute("False")]
[NullableContextAttribute("0")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    public virtual string GetString(Byte[] bytes, int index, int count);
    internal sealed virtual int GetByteCount(Char* chars, int count, EncoderNLS baseEncoder);
    internal sealed virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS baseEncoder);
    internal sealed virtual int GetCharCount(Byte* bytes, int count, DecoderNLS baseDecoder);
    internal sealed virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS baseDecoder);
    public virtual Decoder GetDecoder();
    public virtual Encoder GetEncoder();
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
}
public class System.Text.UTF8Encoding : Encoding {
    internal static UTF8EncodingSealed s_default;
    internal bool _emitUTF8Identifier;
    private bool _isThrowException;
    internal static ReadOnlySpan`1<byte> PreambleSpan { get; }
    public ReadOnlySpan`1<byte> Preamble { get; }
    public UTF8Encoding(bool encoderShouldEmitUTF8Identifier);
    public UTF8Encoding(bool encoderShouldEmitUTF8Identifier, bool throwOnInvalidBytes);
    private static UTF8Encoding();
    internal static ReadOnlySpan`1<byte> get_PreambleSpan();
    internal sealed virtual void SetDefaultFallbacks();
    [NullableContextAttribute("1")]
public virtual int GetByteCount(Char[] chars, int index, int count);
    [NullableContextAttribute("1")]
public virtual int GetByteCount(string chars);
    [CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count);
    public virtual int GetByteCount(ReadOnlySpan`1<char> chars);
    private int GetByteCountCommon(Char* pChars, int charCount);
    private protected sealed virtual int GetByteCountFast(Char* pChars, int charsLength, EncoderFallback fallback, Int32& charsConsumed);
    [NullableContextAttribute("1")]
public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [NullableContextAttribute("1")]
public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual int GetBytes(ReadOnlySpan`1<char> chars, Span`1<byte> bytes);
    private int GetBytesCommon(Char* pChars, int charCount, Byte* pBytes, int byteCount);
    private protected sealed virtual int GetBytesFast(Char* pChars, int charsLength, Byte* pBytes, int bytesLength, Int32& charsConsumed);
    [NullableContextAttribute("1")]
public virtual int GetCharCount(Byte[] bytes, int index, int count);
    [CLSCompliantAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count);
    public virtual int GetCharCount(ReadOnlySpan`1<byte> bytes);
    [NullableContextAttribute("1")]
public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    public virtual int GetChars(ReadOnlySpan`1<byte> bytes, Span`1<char> chars);
    private int GetCharsCommon(Byte* pBytes, int byteCount, Char* pChars, int charCount);
    private protected sealed virtual int GetCharsFast(Byte* pBytes, int bytesLength, Char* pChars, int charsLength, Int32& bytesConsumed);
    private protected sealed virtual int GetCharsWithFallback(ReadOnlySpan`1<byte> bytes, int originalBytesLength, Span`1<char> chars, int originalCharsLength, DecoderNLS decoder);
    [NullableContextAttribute("1")]
public virtual string GetString(Byte[] bytes, int index, int count);
    private int GetCharCountCommon(Byte* pBytes, int byteCount);
    private protected sealed virtual int GetCharCountFast(Byte* pBytes, int bytesLength, DecoderFallback fallback, Int32& bytesConsumed);
    [NullableContextAttribute("1")]
public virtual Decoder GetDecoder();
    [NullableContextAttribute("1")]
public virtual Encoder GetEncoder();
    internal sealed virtual bool TryGetByteCount(Rune value, Int32& byteCount);
    internal sealed virtual OperationStatus EncodeRune(Rune value, Span`1<byte> bytes, Int32& bytesWritten);
    internal sealed virtual OperationStatus DecodeFirstRune(ReadOnlySpan`1<byte> bytes, Rune& value, Int32& bytesConsumed);
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    [NullableContextAttribute("1")]
public virtual Byte[] GetPreamble();
    public virtual ReadOnlySpan`1<byte> get_Preamble();
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[DefaultMemberAttribute("Item")]
internal class System.Text.ValueStringBuilder : ValueType {
    private Char[] _arrayToReturnToPool;
    private Span`1<char> _chars;
    private int _pos;
    public int Length { get; public set; }
    public int Capacity { get; }
    public Char& Item { get; }
    public Span`1<char> RawChars { get; }
    public ValueStringBuilder(Span`1<char> initialBuffer);
    public ValueStringBuilder(int initialCapacity);
    public int get_Length();
    public void set_Length(int value);
    public int get_Capacity();
    public void EnsureCapacity(int capacity);
    public Char& GetPinnableReference();
    public Char& GetPinnableReference(bool terminate);
    public Char& get_Item(int index);
    public virtual string ToString();
    public Span`1<char> get_RawChars();
    public ReadOnlySpan`1<char> AsSpan(bool terminate);
    public ReadOnlySpan`1<char> AsSpan();
    public ReadOnlySpan`1<char> AsSpan(int start);
    public ReadOnlySpan`1<char> AsSpan(int start, int length);
    public bool TryCopyTo(Span`1<char> destination, Int32& charsWritten);
    public void Insert(int index, string s);
    public void Append(char c);
    public void Append(string s);
    private void AppendSlow(string s);
    public void Append(char c, int count);
    public void Append(Char* value, int length);
    public void Append(ReadOnlySpan`1<char> value);
    public Span`1<char> AppendSpan(int length);
    private void GrowAndAppend(char c);
    private void Grow(int additionalCapacityBeyondPos);
    public void Dispose();
}
internal class System.Threading._IOCompletionCallback : object {
    private IOCompletionCallback _ioCompletionCallback;
    private ExecutionContext _executionContext;
    private UInt32 _errorCode;
    private UInt32 _numBytes;
    private NativeOverlapped* _pNativeOverlapped;
    internal static ContextCallback _ccb;
    internal _IOCompletionCallback(IOCompletionCallback ioCompletionCallback, ExecutionContext executionContext);
    private static _IOCompletionCallback();
    internal static void IOCompletionCallback_Context(object state);
    internal static void PerformIOCompletionCallback(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* pNativeOverlapped);
}
internal static class System.Threading._ThreadPoolWaitCallback : object {
    internal static bool PerformWaitCallback();
}
internal class System.Threading._ThreadPoolWaitOrTimerCallback : object {
    private WaitOrTimerCallback _waitOrTimerCallback;
    private ExecutionContext _executionContext;
    private object _state;
    private static ContextCallback _ccbt;
    private static ContextCallback _ccbf;
    internal _ThreadPoolWaitOrTimerCallback(WaitOrTimerCallback waitOrTimerCallback, object state, bool flowExecutionContext);
    private static _ThreadPoolWaitOrTimerCallback();
    private static void WaitOrTimerCallback_Context_t(object state);
    private static void WaitOrTimerCallback_Context_f(object state);
    private static void WaitOrTimerCallback_Context(object state, bool timedOut);
    internal static void PerformWaitOrTimerCallback(_ThreadPoolWaitOrTimerCallback helper, bool timedOut);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableAttribute("0")]
[NullableContextAttribute("2")]
public class System.Threading.AbandonedMutexException : SystemException {
    private int _mutexIndex;
    private Mutex _mutex;
    public Mutex Mutex { get; }
    public int MutexIndex { get; }
    public AbandonedMutexException(string message);
    public AbandonedMutexException(string message, Exception inner);
    public AbandonedMutexException(int location, WaitHandle handle);
    public AbandonedMutexException(string message, int location, WaitHandle handle);
    public AbandonedMutexException(string message, Exception inner, int location, WaitHandle handle);
    [NullableContextAttribute("1")]
protected AbandonedMutexException(SerializationInfo info, StreamingContext context);
    private void SetupException(int location, WaitHandle handle);
    public Mutex get_Mutex();
    public int get_MutexIndex();
}
public enum System.Threading.ApartmentState : Enum {
    public int value__;
    public static ApartmentState STA;
    public static ApartmentState MTA;
    public static ApartmentState Unknown;
}
public class System.Threading.AsyncFlowControl : ValueType {
    private Thread _thread;
    internal void Initialize(Thread currentThread);
    public void Undo();
    public sealed virtual void Dispose();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public bool Equals(AsyncFlowControl obj);
    public virtual int GetHashCode();
    public static bool op_Equality(AsyncFlowControl a, AsyncFlowControl b);
    public static bool op_Inequality(AsyncFlowControl a, AsyncFlowControl b);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Threading.AsyncLocal`1 : object {
    private Action`1<AsyncLocalValueChangedArgs`1<T>> m_valueChangedHandler;
    public T Value { get; public set; }
    public AsyncLocal`1(Action`1<AsyncLocalValueChangedArgs`1<T>> valueChangedHandler);
    public T get_Value();
    public void set_Value(T value);
    private sealed virtual override void System.Threading.IAsyncLocal.OnValueChanged(object previousValueObj, object currentValueObj, bool contextChanged);
}
[IsReadOnlyAttribute]
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Threading.AsyncLocalValueChangedArgs`1 : ValueType {
    [CompilerGeneratedAttribute]
private T <PreviousValue>k__BackingField;
    [CompilerGeneratedAttribute]
private T <CurrentValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ThreadContextChanged>k__BackingField;
    public T PreviousValue { get; }
    public T CurrentValue { get; }
    public bool ThreadContextChanged { get; }
    internal AsyncLocalValueChangedArgs`1(T previousValue, T currentValue, bool contextChanged);
    [CompilerGeneratedAttribute]
public T get_PreviousValue();
    [CompilerGeneratedAttribute]
public T get_CurrentValue();
    [CompilerGeneratedAttribute]
public bool get_ThreadContextChanged();
}
internal static class System.Threading.AsyncLocalValueMap : object {
    [CompilerGeneratedAttribute]
private static IAsyncLocalValueMap <Empty>k__BackingField;
    public static IAsyncLocalValueMap Empty { get; }
    private static AsyncLocalValueMap();
    [CompilerGeneratedAttribute]
public static IAsyncLocalValueMap get_Empty();
    public static bool IsEmpty(IAsyncLocalValueMap asyncLocalValueMap);
    public static IAsyncLocalValueMap Create(IAsyncLocal key, object value, bool treatNullValueAsNonexistent);
}
public class System.Threading.AutoResetEvent : EventWaitHandle {
    public AutoResetEvent(bool initialState);
}
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[NullableContextAttribute("1")]
[DebuggerDisplayAttribute("IsCancellationRequested = {IsCancellationRequested}")]
public class System.Threading.CancellationToken : ValueType {
    private CancellationTokenSource _source;
    private static Action`1<object> s_actionToActionObjShunt;
    public static CancellationToken None { get; }
    public bool IsCancellationRequested { get; }
    public bool CanBeCanceled { get; }
    public WaitHandle WaitHandle { get; }
    internal CancellationToken(CancellationTokenSource source);
    public CancellationToken(bool canceled);
    private static CancellationToken();
    public static CancellationToken get_None();
    public bool get_IsCancellationRequested();
    public bool get_CanBeCanceled();
    public WaitHandle get_WaitHandle();
    public CancellationTokenRegistration Register(Action callback);
    public CancellationTokenRegistration Register(Action callback, bool useSynchronizationContext);
    [NullableContextAttribute("2")]
public CancellationTokenRegistration Register(Action`1<object> callback, object state);
    [NullableContextAttribute("2")]
public CancellationTokenRegistration Register(Action`1<object> callback, object state, bool useSynchronizationContext);
    [NullableContextAttribute("2")]
public CancellationTokenRegistration UnsafeRegister(Action`1<object> callback, object state);
    private CancellationTokenRegistration Register(Action`1<object> callback, object state, bool useSynchronizationContext, bool useExecutionContext);
    public bool Equals(CancellationToken other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public static bool op_Equality(CancellationToken left, CancellationToken right);
    public static bool op_Inequality(CancellationToken left, CancellationToken right);
    public void ThrowIfCancellationRequested();
    [DoesNotReturnAttribute]
private void ThrowOperationCanceledException();
}
[IsReadOnlyAttribute]
public class System.Threading.CancellationTokenRegistration : ValueType {
    private long _id;
    private CallbackNode _node;
    public CancellationToken Token { get; }
    internal CancellationTokenRegistration(long id, CallbackNode node);
    public sealed virtual void Dispose();
    public sealed virtual ValueTask DisposeAsync();
    public CancellationToken get_Token();
    public bool Unregister();
    private void WaitForCallbackIfNecessary();
    private ValueTask WaitForCallbackIfNecessaryAsync();
    public static bool op_Equality(CancellationTokenRegistration left, CancellationTokenRegistration right);
    public static bool op_Inequality(CancellationTokenRegistration left, CancellationTokenRegistration right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CancellationTokenRegistration other);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Threading.CancellationTokenSource : object {
    internal static CancellationTokenSource s_canceledSource;
    internal static CancellationTokenSource s_neverCanceledSource;
    private static TimerCallback s_timerCallback;
    private static int s_numPartitions;
    private static int s_numPartitionsMask;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _state;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _threadIDExecutingCallbacks;
    private long _executingCallbackId;
    private CallbackPartition[] modreq(System.Runtime.CompilerServices.IsVolatile) _callbackPartitions;
    private TimerQueueTimer modreq(System.Runtime.CompilerServices.IsVolatile) _timer;
    private ManualResetEvent modreq(System.Runtime.CompilerServices.IsVolatile) _kernelEvent;
    private bool _disposed;
    public bool IsCancellationRequested { get; }
    internal bool IsCancellationCompleted { get; }
    internal int ThreadIDExecutingCallbacks { get; internal set; }
    public CancellationToken Token { get; }
    internal WaitHandle WaitHandle { get; }
    internal long ExecutingCallback { get; }
    public CancellationTokenSource(TimeSpan delay);
    public CancellationTokenSource(int millisecondsDelay);
    private static CancellationTokenSource();
    public bool get_IsCancellationRequested();
    internal bool get_IsCancellationCompleted();
    internal int get_ThreadIDExecutingCallbacks();
    internal void set_ThreadIDExecutingCallbacks(int value);
    public CancellationToken get_Token();
    internal WaitHandle get_WaitHandle();
    internal long get_ExecutingCallback();
    private void InitializeWithTimer(int millisecondsDelay);
    public void Cancel();
    public void Cancel(bool throwOnFirstException);
    public void CancelAfter(TimeSpan delay);
    public void CancelAfter(int millisecondsDelay);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private void ThrowIfDisposed();
    [DoesNotReturnAttribute]
private static void ThrowObjectDisposedException();
    internal CancellationTokenRegistration InternalRegister(Action`1<object> callback, object stateForCallback, SynchronizationContext syncContext, ExecutionContext executionContext);
    private void NotifyCancellation(bool throwOnFirstException);
    private void ExecuteCallbackHandlers(bool throwOnFirstException);
    private static int GetPartitionCount();
    public static CancellationTokenSource CreateLinkedTokenSource(CancellationToken token1, CancellationToken token2);
    internal static CancellationTokenSource CreateLinkedTokenSource(CancellationToken token);
    public static CancellationTokenSource CreateLinkedTokenSource(CancellationToken[] tokens);
    internal void WaitForCallbackToComplete(long id);
    internal ValueTask WaitForCallbackToCompleteAsync(long id);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Threading.CompressedStack : object {
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public static CompressedStack Capture();
    public CompressedStack CreateCopy();
    public static CompressedStack GetCompressedStack();
    public static void Run(CompressedStack compressedStack, ContextCallback callback, object state);
}
public class System.Threading.ContextCallback : MulticastDelegate {
    public ContextCallback(object object, IntPtr method);
    [NullableContextAttribute("2")]
public virtual void Invoke(object state);
    public virtual IAsyncResult BeginInvoke(object state, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Threading.ContextCallback`1 : MulticastDelegate {
    public ContextCallback`1(object object, IntPtr method);
    public virtual void Invoke(TState& state);
    public virtual IAsyncResult BeginInvoke(TState& state, AsyncCallback callback, object object);
    public virtual void EndInvoke(TState& state, IAsyncResult result);
}
internal class System.Threading.DeferredDisposableLifetime`1 : ValueType {
    private int _count;
    public bool AddRef(T obj);
    public void Release(T obj);
    public void Dispose(T obj);
}
public enum System.Threading.EventResetMode : Enum {
    public int value__;
    public static EventResetMode AutoReset;
    public static EventResetMode ManualReset;
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Threading.EventWaitHandle : WaitHandle {
    public EventWaitHandle(bool initialState, EventResetMode mode);
    [NullableContextAttribute("2")]
public EventWaitHandle(bool initialState, EventResetMode mode, string name);
    [NullableContextAttribute("2")]
public EventWaitHandle(bool initialState, EventResetMode mode, string name, Boolean& createdNew);
    private EventWaitHandle(SafeWaitHandle handle);
    public static EventWaitHandle OpenExisting(string name);
    public static bool TryOpenExisting(string name, EventWaitHandle& result);
    private void CreateEventCore(bool initialState, EventResetMode mode, string name, Boolean& createdNew);
    private static OpenExistingResult OpenExistingWorker(string name, EventWaitHandle& result);
    public bool Reset();
    public bool Set();
    internal static bool Set(SafeWaitHandle waitHandle);
}
public class System.Threading.ExecutionContext : object {
    internal static ExecutionContext Default;
    internal static ExecutionContext DefaultFlowSuppressed;
    private IAsyncLocalValueMap m_localValues;
    private IAsyncLocal[] m_localChangeNotifications;
    private bool m_isFlowSuppressed;
    private bool m_isDefault;
    internal bool HasChangeNotifications { get; }
    internal bool IsDefault { get; }
    private ExecutionContext(bool isDefault);
    private ExecutionContext(IAsyncLocalValueMap localValues, IAsyncLocal[] localChangeNotifications, bool isFlowSuppressed);
    private static ExecutionContext();
    [NullableContextAttribute("1")]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("2")]
public static ExecutionContext Capture();
    private ExecutionContext ShallowClone(bool isFlowSuppressed);
    public static AsyncFlowControl SuppressFlow();
    public static void RestoreFlow();
    public static bool IsFlowSuppressed();
    internal bool get_HasChangeNotifications();
    internal bool get_IsDefault();
    [NullableContextAttribute("1")]
public static void Run(ExecutionContext executionContext, ContextCallback callback, object state);
    internal static void RunInternal(ExecutionContext executionContext, ContextCallback callback, object state);
    internal static void RunInternal(ExecutionContext executionContext, ContextCallback`1<TState> callback, TState& state);
    internal static void RunFromThreadPoolDispatchLoop(Thread threadPoolThread, ExecutionContext executionContext, ContextCallback callback, object state);
    internal static void RunForThreadPoolUnsafe(ExecutionContext executionContext, Action`1<TState> callback, TState& state);
    internal static void RestoreChangedContextToThread(Thread currentThread, ExecutionContext contextToRestore, ExecutionContext currentContext);
    internal static void ResetThreadPoolThread(Thread currentThread);
    internal static void OnValuesChanged(ExecutionContext previousExecutionCtx, ExecutionContext nextExecutionCtx);
    [StackTraceHiddenAttribute]
[DoesNotReturnAttribute]
private static void ThrowNullContext();
    internal static object GetLocalValue(IAsyncLocal local);
    internal static void SetLocalValue(IAsyncLocal local, object newValue, bool needChangeNotifications);
    [NullableContextAttribute("1")]
public ExecutionContext CreateCopy();
    public sealed virtual void Dispose();
}
internal class System.Threading.FastRandom : ValueType {
    private UInt32 _w;
    private UInt32 _x;
    private UInt32 _y;
    private UInt32 _z;
    public FastRandom(int seed);
    public int Next(int maxValue);
}
internal interface System.Threading.IAsyncLocal {
    public abstract virtual void OnValueChanged(object previousValue, object currentValue, bool contextChanged);
}
internal interface System.Threading.IAsyncLocalValueMap {
    public abstract virtual bool TryGetValue(IAsyncLocal key, Object& value);
    public abstract virtual IAsyncLocalValueMap Set(IAsyncLocal key, object value, bool treatNullValueAsNonexistent);
}
internal interface System.Threading.IDeferredDisposable {
    public abstract virtual void OnFinalRelease(bool disposed);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Threading.Interlocked : object {
    public static int Increment(Int32& location);
    public static long Increment(Int64& location);
    public static int Decrement(Int32& location);
    public static long Decrement(Int64& location);
    public static int Exchange(Int32& location1, int value);
    public static long Exchange(Int64& location1, long value);
    public static float Exchange(Single& location1, float value);
    public static double Exchange(Double& location1, double value);
    [NullableContextAttribute("2")]
public static object Exchange(Object& location1, object value);
    public static IntPtr Exchange(IntPtr& location1, IntPtr value);
    public static T Exchange(T& location1, T value);
    public static int CompareExchange(Int32& location1, int value, int comparand);
    public static long CompareExchange(Int64& location1, long value, long comparand);
    public static float CompareExchange(Single& location1, float value, float comparand);
    public static double CompareExchange(Double& location1, double value, double comparand);
    [NullableContextAttribute("2")]
public static object CompareExchange(Object& location1, object value, object comparand);
    public static IntPtr CompareExchange(IntPtr& location1, IntPtr value, IntPtr comparand);
    public static T CompareExchange(T& location1, T value, T comparand);
    internal static int CompareExchange(Int32& location1, int value, int comparand, Boolean& succeeded);
    internal static int ExchangeAdd(Int32& location1, int value);
    internal static long ExchangeAdd(Int64& location1, long value);
    public static int Add(Int32& location1, int value);
    public static long Add(Int64& location1, long value);
    public static long Read(Int64& location);
    public static void MemoryBarrier();
    private static void _MemoryBarrierProcessWide();
    public static void MemoryBarrierProcessWide();
}
[CLSCompliantAttribute("False")]
public class System.Threading.IOCompletionCallback : MulticastDelegate {
    public IOCompletionCallback(object object, IntPtr method);
    public virtual void Invoke(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* pOVERLAP);
    public virtual IAsyncResult BeginInvoke(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* pOVERLAP, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public interface System.Threading.IThreadPoolWorkItem {
    public abstract virtual void Execute();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Threading.LazyInitializer : object {
    public static T EnsureInitialized(T& target);
    private static T EnsureInitializedCore(T& target);
    public static T EnsureInitialized(T& target, Func`1<T> valueFactory);
    private static T EnsureInitializedCore(T& target, Func`1<T> valueFactory);
    public static T EnsureInitialized(T& target, Boolean& initialized, Object& syncLock);
    private static T EnsureInitializedCore(T& target, Boolean& initialized, Object& syncLock);
    public static T EnsureInitialized(T& target, Boolean& initialized, Object& syncLock, Func`1<T> valueFactory);
    private static T EnsureInitializedCore(T& target, Boolean& initialized, Object& syncLock, Func`1<T> valueFactory);
    public static T EnsureInitialized(T& target, Object& syncLock, Func`1<T> valueFactory);
    private static T EnsureInitializedCore(T& target, Object& syncLock, Func`1<T> valueFactory);
    private static object EnsureLockInitialized(Object& syncLock);
}
public enum System.Threading.LazyThreadSafetyMode : Enum {
    public int value__;
    public static LazyThreadSafetyMode None;
    public static LazyThreadSafetyMode PublicationOnly;
    public static LazyThreadSafetyMode ExecutionAndPublication;
}
[NullableContextAttribute("2")]
[TypeForwardedFromAttribute("System.Core, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableAttribute("0")]
public class System.Threading.LockRecursionException : Exception {
    public LockRecursionException(string message);
    public LockRecursionException(string message, Exception innerException);
    [NullableContextAttribute("1")]
protected LockRecursionException(SerializationInfo info, StreamingContext context);
}
public enum System.Threading.LockRecursionPolicy : Enum {
    public int value__;
    public static LockRecursionPolicy NoRecursion;
    public static LockRecursionPolicy SupportsRecursion;
}
public class System.Threading.ManualResetEvent : EventWaitHandle {
    public ManualResetEvent(bool initialState);
}
[DebuggerDisplayAttribute("Set = {IsSet}")]
public class System.Threading.ManualResetEventSlim : object {
    private Object modreq(System.Runtime.CompilerServices.IsVolatile) m_lock;
    private ManualResetEvent modreq(System.Runtime.CompilerServices.IsVolatile) m_eventObj;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_combinedState;
    private static Action`1<object> s_cancellationTokenCallback;
    [NullableAttribute("1")]
public WaitHandle WaitHandle { get; }
    public bool IsSet { get; private set; }
    public int SpinCount { get; private set; }
    private int Waiters { get; private set; }
    public ManualResetEventSlim(bool initialState);
    public ManualResetEventSlim(bool initialState, int spinCount);
    private static ManualResetEventSlim();
    [NullableContextAttribute("1")]
public WaitHandle get_WaitHandle();
    public bool get_IsSet();
    private void set_IsSet(bool value);
    public int get_SpinCount();
    private void set_SpinCount(int value);
    private int get_Waiters();
    private void set_Waiters(int value);
    private void Initialize(bool initialState, int spinCount);
    private void EnsureLockObjectCreated();
    private bool LazyInitializeEvent();
    public void Set();
    private void Set(bool duringCancellation);
    public void Reset();
    public void Wait();
    public void Wait(CancellationToken cancellationToken);
    public bool Wait(TimeSpan timeout);
    public bool Wait(TimeSpan timeout, CancellationToken cancellationToken);
    public bool Wait(int millisecondsTimeout);
    public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private void ThrowIfDisposed();
    private static void CancellationTokenCallback(object obj);
    private void UpdateStateAtomically(int newBits, int updateBitsMask);
    private static int ExtractStatePortionAndShiftRight(int state, int mask, int rightBitShiftCount);
    private static int ExtractStatePortion(int state, int mask);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Threading.Monitor : object {
    public static long LockContentionCount { get; }
    public static void Enter(object obj);
    public static void Enter(object obj, Boolean& lockTaken);
    [DoesNotReturnAttribute]
private static void ThrowLockTakenException();
    private static void ReliableEnter(object obj, Boolean& lockTaken);
    public static void Exit(object obj);
    public static bool TryEnter(object obj);
    public static void TryEnter(object obj, Boolean& lockTaken);
    public static bool TryEnter(object obj, int millisecondsTimeout);
    private static int MillisecondsTimeoutFromTimeSpan(TimeSpan timeout);
    public static bool TryEnter(object obj, TimeSpan timeout);
    public static void TryEnter(object obj, int millisecondsTimeout, Boolean& lockTaken);
    public static void TryEnter(object obj, TimeSpan timeout, Boolean& lockTaken);
    private static void ReliableEnterTimeout(object obj, int timeout, Boolean& lockTaken);
    public static bool IsEntered(object obj);
    private static bool IsEnteredNative(object obj);
    private static bool ObjWait(bool exitContext, int millisecondsTimeout, object obj);
    public static bool Wait(object obj, int millisecondsTimeout, bool exitContext);
    public static bool Wait(object obj, TimeSpan timeout, bool exitContext);
    public static bool Wait(object obj, int millisecondsTimeout);
    public static bool Wait(object obj, TimeSpan timeout);
    public static bool Wait(object obj);
    private static void ObjPulse(object obj);
    public static void Pulse(object obj);
    private static void ObjPulseAll(object obj);
    public static void PulseAll(object obj);
    public static long get_LockContentionCount();
    private static long GetLockContentionCount();
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Threading.Mutex : WaitHandle {
    [NullableContextAttribute("2")]
public Mutex(bool initiallyOwned, string name, Boolean& createdNew);
    [NullableContextAttribute("2")]
public Mutex(bool initiallyOwned, string name);
    public Mutex(bool initiallyOwned);
    private Mutex(SafeWaitHandle handle);
    public static Mutex OpenExisting(string name);
    public static bool TryOpenExisting(string name, Mutex& result);
    private void CreateMutexCore(bool initiallyOwned, string name, Boolean& createdNew);
    private static OpenExistingResult OpenExistingWorker(string name, Mutex& result);
    public void ReleaseMutex();
}
public class System.Threading.NativeOverlapped : ValueType {
    public IntPtr InternalLow;
    public IntPtr InternalHigh;
    public int OffsetLow;
    public int OffsetHigh;
    public IntPtr EventHandle;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Threading.Overlapped : object {
    private OverlappedData _overlappedData;
    public IAsyncResult AsyncResult { get; public set; }
    public int OffsetLow { get; public set; }
    public int OffsetHigh { get; public set; }
    [ObsoleteAttribute("This property is not 64-bit compatible.  Use EventHandleIntPtr instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
public int EventHandle { get; public set; }
    public IntPtr EventHandleIntPtr { get; public set; }
    public Overlapped(int offsetLo, int offsetHi, IntPtr hEvent, IAsyncResult ar);
    [ObsoleteAttribute("This constructor is not 64-bit compatible.  Use the constructor that takes an IntPtr for the event handle.  http://go.microsoft.com/fwlink/?linkid=14202")]
public Overlapped(int offsetLo, int offsetHi, int hEvent, IAsyncResult ar);
    public IAsyncResult get_AsyncResult();
    public void set_AsyncResult(IAsyncResult value);
    public int get_OffsetLow();
    public void set_OffsetLow(int value);
    public int get_OffsetHigh();
    public void set_OffsetHigh(int value);
    public int get_EventHandle();
    public void set_EventHandle(int value);
    public IntPtr get_EventHandleIntPtr();
    public void set_EventHandleIntPtr(IntPtr value);
    [NullableContextAttribute("0")]
[ObsoleteAttribute("This method is not safe.  Use Pack (iocb, userData) instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
[CLSCompliantAttribute("False")]
public NativeOverlapped* Pack(IOCompletionCallback iocb);
    [CLSCompliantAttribute("False")]
public NativeOverlapped* Pack(IOCompletionCallback iocb, object userData);
    [NullableContextAttribute("0")]
[ObsoleteAttribute("This method is not safe.  Use UnsafePack (iocb, userData) instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
[CLSCompliantAttribute("False")]
public NativeOverlapped* UnsafePack(IOCompletionCallback iocb);
    [CLSCompliantAttribute("False")]
public NativeOverlapped* UnsafePack(IOCompletionCallback iocb, object userData);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public static Overlapped Unpack(NativeOverlapped* nativeOverlappedPtr);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public static void Free(NativeOverlapped* nativeOverlappedPtr);
}
internal class System.Threading.OverlappedData : object {
    internal IAsyncResult _asyncResult;
    internal object _callback;
    internal Overlapped _overlapped;
    private object _userObject;
    private NativeOverlapped* _pNativeOverlapped;
    private IntPtr _eventHandle;
    private int _offsetLow;
    private int _offsetHigh;
    internal Int32& OffsetLow { get; }
    internal Int32& OffsetHigh { get; }
    internal IntPtr& EventHandle { get; }
    internal OverlappedData(Overlapped overlapped);
    internal Int32& get_OffsetLow();
    internal Int32& get_OffsetHigh();
    internal IntPtr& get_EventHandle();
    internal NativeOverlapped* Pack(IOCompletionCallback iocb, object userData);
    internal NativeOverlapped* UnsafePack(IOCompletionCallback iocb, object userData);
    private NativeOverlapped* AllocateNativeOverlapped();
    internal static void FreeNativeOverlapped(NativeOverlapped* nativeOverlappedPtr);
    internal static OverlappedData GetOverlappedFromNative(NativeOverlapped* nativeOverlappedPtr);
    internal static void CheckVMForIOPacket(NativeOverlapped*& pNativeOverlapped, UInt32& errorCode, UInt32& numBytes);
}
public class System.Threading.ParameterizedThreadStart : MulticastDelegate {
    public ParameterizedThreadStart(object object, IntPtr method);
    [NullableContextAttribute("2")]
public virtual void Invoke(object obj);
    public virtual IAsyncResult BeginInvoke(object obj, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class System.Threading.PlatformHelper : object {
    private static Int32 modreq(System.Runtime.CompilerServices.IsVolatile) s_processorCount;
    private static Int32 modreq(System.Runtime.CompilerServices.IsVolatile) s_lastProcessorCountRefreshTicks;
    internal static bool IsSingleProcessor;
    internal static int ProcessorCount { get; }
    private static PlatformHelper();
    internal static int get_ProcessorCount();
}
public class System.Threading.PreAllocatedOverlapped : object {
    internal ThreadPoolBoundHandleOverlapped _overlapped;
    private DeferredDisposableLifetime`1<PreAllocatedOverlapped> _lifetime;
    [CLSCompliantAttribute("False")]
[NullableContextAttribute("2")]
public PreAllocatedOverlapped(IOCompletionCallback callback, object state, object pinData);
    internal bool AddRef();
    internal void Release();
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    private sealed virtual override void System.Threading.IDeferredDisposable.OnFinalRelease(bool disposed);
}
internal class System.Threading.QueueUserWorkItemCallback : QueueUserWorkItemCallbackBase {
    private WaitCallback _callback;
    private object _state;
    private ExecutionContext _context;
    private static Action`1<QueueUserWorkItemCallback> s_executionContextShim;
    internal QueueUserWorkItemCallback(WaitCallback callback, object state, ExecutionContext context);
    private static QueueUserWorkItemCallback();
    public virtual void Execute();
}
internal class System.Threading.QueueUserWorkItemCallback`1 : QueueUserWorkItemCallbackBase {
    private Action`1<TState> _callback;
    private TState _state;
    private ExecutionContext _context;
    internal QueueUserWorkItemCallback`1(Action`1<TState> callback, TState state, ExecutionContext context);
    public virtual void Execute();
}
internal abstract class System.Threading.QueueUserWorkItemCallbackBase : object {
    public virtual void Execute();
}
internal class System.Threading.QueueUserWorkItemCallbackDefaultContext : QueueUserWorkItemCallbackBase {
    private WaitCallback _callback;
    private object _state;
    internal QueueUserWorkItemCallbackDefaultContext(WaitCallback callback, object state);
    public virtual void Execute();
}
internal class System.Threading.QueueUserWorkItemCallbackDefaultContext`1 : QueueUserWorkItemCallbackBase {
    private Action`1<TState> _callback;
    private TState _state;
    internal QueueUserWorkItemCallbackDefaultContext`1(Action`1<TState> callback, TState state);
    public virtual void Execute();
}
internal class System.Threading.ReaderWriterCount : object {
    public long lockID;
    public int readercount;
    public int writercount;
    public int upgradecount;
    public ReaderWriterCount next;
}
public class System.Threading.ReaderWriterLockSlim : object {
    private static int ProcessorCount;
    private bool _fIsReentrant;
    private SpinLock _spinLock;
    private UInt32 _numWriteWaiters;
    private UInt32 _numReadWaiters;
    private UInt32 _numWriteUpgradeWaiters;
    private UInt32 _numUpgradeWaiters;
    private WaiterStates _waiterStates;
    private int _upgradeLockOwnerId;
    private int _writeLockOwnerId;
    private EventWaitHandle _writeEvent;
    private EventWaitHandle _readEvent;
    private EventWaitHandle _upgradeEvent;
    private EventWaitHandle _waitUpgradeEvent;
    private static long s_nextLockID;
    private long _lockID;
    [ThreadStaticAttribute]
private static ReaderWriterCount t_rwc;
    private bool _fUpgradeThreadHoldingRead;
    private UInt32 _owners;
    private bool _fDisposed;
    private bool HasNoWaiters { get; private set; }
    public bool IsReadLockHeld { get; }
    public bool IsUpgradeableReadLockHeld { get; }
    public bool IsWriteLockHeld { get; }
    public LockRecursionPolicy RecursionPolicy { get; }
    public int CurrentReadCount { get; }
    public int RecursiveReadCount { get; }
    public int RecursiveUpgradeCount { get; }
    public int RecursiveWriteCount { get; }
    public int WaitingReadCount { get; }
    public int WaitingUpgradeCount { get; }
    public int WaitingWriteCount { get; }
    public ReaderWriterLockSlim(LockRecursionPolicy recursionPolicy);
    private static ReaderWriterLockSlim();
    private void InitializeThreadCounts();
    private bool get_HasNoWaiters();
    private void set_HasNoWaiters(bool value);
    private static bool IsRWEntryEmpty(ReaderWriterCount rwc);
    private bool IsRwHashEntryChanged(ReaderWriterCount lrwc);
    private ReaderWriterCount GetThreadRWCount(bool dontAllocate);
    public void EnterReadLock();
    public bool TryEnterReadLock(TimeSpan timeout);
    public bool TryEnterReadLock(int millisecondsTimeout);
    private bool TryEnterReadLock(TimeoutTracker timeout);
    private bool TryEnterReadLockCore(TimeoutTracker timeout);
    public void EnterWriteLock();
    public bool TryEnterWriteLock(TimeSpan timeout);
    public bool TryEnterWriteLock(int millisecondsTimeout);
    private bool TryEnterWriteLock(TimeoutTracker timeout);
    private bool TryEnterWriteLockCore(TimeoutTracker timeout);
    public void EnterUpgradeableReadLock();
    public bool TryEnterUpgradeableReadLock(TimeSpan timeout);
    public bool TryEnterUpgradeableReadLock(int millisecondsTimeout);
    private bool TryEnterUpgradeableReadLock(TimeoutTracker timeout);
    private bool TryEnterUpgradeableReadLockCore(TimeoutTracker timeout);
    public void ExitReadLock();
    public void ExitWriteLock();
    public void ExitUpgradeableReadLock();
    private void LazyCreateEvent(EventWaitHandle& waitEvent, EnterLockType enterLockType);
    private bool WaitOnEvent(EventWaitHandle waitEvent, UInt32& numWaiters, TimeoutTracker timeout, EnterLockType enterLockType);
    private void ExitAndWakeUpAppropriateWaiters();
    private void ExitAndWakeUpAppropriateWaitersPreferringWriters();
    private void ExitAndWakeUpAppropriateReadWaiters();
    private bool IsWriterAcquired();
    private void SetWriterAcquired();
    private void ClearWriterAcquired();
    private void SetWritersWaiting();
    private void ClearWritersWaiting();
    private void SetUpgraderWaiting();
    private void ClearUpgraderWaiting();
    private UInt32 GetNumReaders();
    private bool ShouldSpinForEnterAnyRead();
    private bool ShouldSpinForEnterAnyWrite(bool isUpgradeToWrite);
    private static void SpinWait(int spinCount);
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    public bool get_IsReadLockHeld();
    public bool get_IsUpgradeableReadLockHeld();
    public bool get_IsWriteLockHeld();
    public LockRecursionPolicy get_RecursionPolicy();
    public int get_CurrentReadCount();
    public int get_RecursiveReadCount();
    public int get_RecursiveUpgradeCount();
    public int get_RecursiveWriteCount();
    public int get_WaitingReadCount();
    public int get_WaitingUpgradeCount();
    public int get_WaitingWriteCount();
}
public class System.Threading.RegisteredWaitHandle : MarshalByRefObject {
    private RegisteredWaitHandleSafe internalRegisteredWait;
    internal void SetHandle(IntPtr handle);
    internal void SetWaitObject(WaitHandle waitObject);
    [NullableContextAttribute("2")]
public bool Unregister(WaitHandle waitObject);
}
internal class System.Threading.RegisteredWaitHandleSafe : CriticalFinalizerObject {
    private IntPtr registeredWaitHandle;
    private WaitHandle m_internalWaitObject;
    private bool bReleaseNeeded;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_lock;
    private static IntPtr InvalidHandle { get; }
    private static IntPtr get_InvalidHandle();
    internal IntPtr GetHandle();
    internal void SetHandle(IntPtr handle);
    internal void SetWaitObject(WaitHandle waitObject);
    internal bool Unregister(WaitHandle waitObject);
    private bool ValidHandle();
    protected virtual override void Finalize();
    private static void WaitHandleCleanupNative(IntPtr handle);
    private static bool UnregisterWaitNative(IntPtr handle, SafeHandle waitObject);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Threading.Semaphore : WaitHandle {
    public Semaphore(int initialCount, int maximumCount);
    [NullableContextAttribute("2")]
public Semaphore(int initialCount, int maximumCount, string name);
    [NullableContextAttribute("2")]
public Semaphore(int initialCount, int maximumCount, string name, Boolean& createdNew);
    private Semaphore(SafeWaitHandle handle);
    public static Semaphore OpenExisting(string name);
    public static bool TryOpenExisting(string name, Semaphore& result);
    public int Release();
    public int Release(int releaseCount);
    private void CreateSemaphoreCore(int initialCount, int maximumCount, string name, Boolean& createdNew);
    private static OpenExistingResult OpenExistingWorker(string name, Semaphore& result);
    private int ReleaseCore(int releaseCount);
}
[TypeForwardedFromAttribute("System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableAttribute("0")]
[NullableContextAttribute("2")]
public class System.Threading.SemaphoreFullException : SystemException {
    public SemaphoreFullException(string message);
    public SemaphoreFullException(string message, Exception innerException);
    [NullableContextAttribute("1")]
protected SemaphoreFullException(SerializationInfo info, StreamingContext context);
}
[NullableAttribute("0")]
[DebuggerDisplayAttribute("Current Count = {m_currentCount}")]
[NullableContextAttribute("1")]
public class System.Threading.SemaphoreSlim : object {
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_currentCount;
    private int m_maxCount;
    private int m_waitCount;
    private int m_countOfWaitersPulsedToWake;
    private StrongBox`1<bool> m_lockObjAndDisposed;
    private ManualResetEvent modreq(System.Runtime.CompilerServices.IsVolatile) m_waitHandle;
    private TaskNode m_asyncHead;
    private TaskNode m_asyncTail;
    private static Task`1<bool> s_trueTask;
    private static Task`1<bool> s_falseTask;
    private static Action`1<object> s_cancellationTokenCanceledEventHandler;
    public int CurrentCount { get; }
    public WaitHandle AvailableWaitHandle { get; }
    public SemaphoreSlim(int initialCount);
    public SemaphoreSlim(int initialCount, int maxCount);
    private static SemaphoreSlim();
    public int get_CurrentCount();
    public WaitHandle get_AvailableWaitHandle();
    public void Wait();
    public void Wait(CancellationToken cancellationToken);
    public bool Wait(TimeSpan timeout);
    public bool Wait(TimeSpan timeout, CancellationToken cancellationToken);
    public bool Wait(int millisecondsTimeout);
    public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken);
    private bool WaitUntilCountOrTimeout(int millisecondsTimeout, UInt32 startTime, CancellationToken cancellationToken);
    public Task WaitAsync();
    public Task WaitAsync(CancellationToken cancellationToken);
    public Task`1<bool> WaitAsync(int millisecondsTimeout);
    public Task`1<bool> WaitAsync(TimeSpan timeout);
    public Task`1<bool> WaitAsync(TimeSpan timeout, CancellationToken cancellationToken);
    public Task`1<bool> WaitAsync(int millisecondsTimeout, CancellationToken cancellationToken);
    private TaskNode CreateAndAddAsyncWaiter();
    private bool RemoveAsyncWaiter(TaskNode task);
    [AsyncStateMachineAttribute("System.Threading.SemaphoreSlim/<WaitUntilCountOrTimeoutAsync>d__33")]
private Task`1<bool> WaitUntilCountOrTimeoutAsync(TaskNode asyncWaiter, int millisecondsTimeout, CancellationToken cancellationToken);
    public int Release();
    public int Release(int releaseCount);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private static void CancellationTokenCanceledEventHandler(object obj);
    private void CheckDispose();
}
public class System.Threading.SendOrPostCallback : MulticastDelegate {
    public SendOrPostCallback(object object, IntPtr method);
    [NullableContextAttribute("2")]
public virtual void Invoke(object state);
    public virtual IAsyncResult BeginInvoke(object state, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[DebuggerTypeProxyAttribute("System.Threading.SpinLock/SystemThreading_SpinLockDebugView")]
[DebuggerDisplayAttribute("IsHeld = {IsHeld}")]
public class System.Threading.SpinLock : ValueType {
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _owner;
    public bool IsHeld { get; }
    public bool IsHeldByCurrentThread { get; }
    public bool IsThreadOwnerTrackingEnabled { get; }
    public SpinLock(bool enableThreadOwnerTracking);
    private static int CompareExchange(Int32& location, int value, int comparand, Boolean& success);
    public void Enter(Boolean& lockTaken);
    public void TryEnter(Boolean& lockTaken);
    public void TryEnter(TimeSpan timeout, Boolean& lockTaken);
    public void TryEnter(int millisecondsTimeout, Boolean& lockTaken);
    private void ContinueTryEnter(int millisecondsTimeout, Boolean& lockTaken);
    private void DecrementWaiters();
    private void ContinueTryEnterWithThreadTracking(int millisecondsTimeout, UInt32 startTime, Boolean& lockTaken);
    public void Exit();
    public void Exit(bool useMemoryBarrier);
    private void ExitSlowPath(bool useMemoryBarrier);
    public bool get_IsHeld();
    public bool get_IsHeldByCurrentThread();
    public bool get_IsThreadOwnerTrackingEnabled();
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Threading.SpinWait : ValueType {
    internal static int SpinCountforSpinBeforeWait;
    private int _count;
    public int Count { get; internal set; }
    public bool NextSpinWillYield { get; }
    private static SpinWait();
    public int get_Count();
    internal void set_Count(int value);
    public bool get_NextSpinWillYield();
    public void SpinOnce();
    public void SpinOnce(int sleep1Threshold);
    private void SpinOnceCore(int sleep1Threshold);
    public void Reset();
    public static void SpinUntil(Func`1<bool> condition);
    public static bool SpinUntil(Func`1<bool> condition, TimeSpan timeout);
    public static bool SpinUntil(Func`1<bool> condition, int millisecondsTimeout);
}
internal enum System.Threading.StackCrawlMark : Enum {
    public int value__;
    public static StackCrawlMark LookForMe;
    public static StackCrawlMark LookForMyCaller;
    public static StackCrawlMark LookForMyCallersCaller;
    public static StackCrawlMark LookForThread;
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Threading.SynchronizationContext : object {
    private static Func`2<object, SynchronizationContext> s_createSynchronizationContextDelegate;
    private bool _requireWaitNotification;
    [NullableAttribute("2")]
public static SynchronizationContext Current { get; }
    private static int InvokeWaitMethodHelper(SynchronizationContext syncContext, IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout);
    [NullableContextAttribute("2")]
public static SynchronizationContext get_Current();
    private static SynchronizationContext GetWinRTContext();
    private static SynchronizationContext GetWinRTSynchronizationContext(object dispatcher);
    private static object GetWinRTDispatcherForCurrentThread();
    protected void SetWaitNotificationRequired();
    public bool IsWaitNotificationRequired();
    public virtual void Send(SendOrPostCallback d, object state);
    public virtual void Post(SendOrPostCallback d, object state);
    public virtual void OperationStarted();
    public virtual void OperationCompleted();
    [CLSCompliantAttribute("False")]
public virtual int Wait(IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout);
    [CLSCompliantAttribute("False")]
protected static int WaitHelper(IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout);
    [NullableContextAttribute("2")]
public static void SetSynchronizationContext(SynchronizationContext syncContext);
    public virtual SynchronizationContext CreateCopy();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Threading.SynchronizationLockException : SystemException {
    public SynchronizationLockException(string message);
    public SynchronizationLockException(string message, Exception innerException);
    [NullableContextAttribute("1")]
protected SynchronizationLockException(SerializationInfo info, StreamingContext context);
}
internal class System.Threading.SystemThreading_ThreadLocalDebugView`1 : object {
    private ThreadLocal`1<T> _tlocal;
    public bool IsValueCreated { get; }
    public T Value { get; }
    public List`1<T> Values { get; }
    public SystemThreading_ThreadLocalDebugView`1(ThreadLocal`1<T> tlocal);
    public bool get_IsValueCreated();
    public T get_Value();
    public List`1<T> get_Values();
}
internal enum System.Threading.Tasks.AsyncCausalityStatus : Enum {
    public int value__;
    public static AsyncCausalityStatus Started;
    public static AsyncCausalityStatus Completed;
    public static AsyncCausalityStatus Canceled;
    public static AsyncCausalityStatus Error;
}
internal static class System.Threading.Tasks.AsyncCausalityTracer : object {
    private static Guid s_PlatformId;
    private static IAsyncCausalityTracerStatics s_TracerFactory;
    private static Loggers f_LoggingOn;
    internal static bool LoggingOn { get; }
    private static AsyncCausalityTracer();
    internal static void EnableToETW(bool enabled);
    internal static bool get_LoggingOn();
    private static void TracingStatusChangedHandler(object sender, TracingStatusChangedEventArgs args);
    internal static void TraceOperationCreation(Task task, string operationName);
    internal static void TraceOperationCompletion(Task task, AsyncCausalityStatus status);
    internal static void TraceOperationRelation(Task task, CausalityRelation relation);
    internal static void TraceSynchronousWorkStart(Task task, CausalitySynchronousWork work);
    internal static void TraceSynchronousWorkCompletion(CausalitySynchronousWork work);
    private static void LogAndDisable(Exception ex);
    private static ulong GetOperationId(UInt32 taskId);
}
internal class System.Threading.Tasks.AwaitTaskContinuation : TaskContinuation {
    private ExecutionContext m_capturedContext;
    protected Action m_action;
    protected int m_continuationId;
    private static ContextCallback s_invokeContextCallback;
    private static Action`1<Action> s_invokeAction;
    internal static bool IsValidLocationForInlining { get; }
    internal AwaitTaskContinuation(Action action, bool flowExecutionContext);
    private static AwaitTaskContinuation();
    protected Task CreateTask(Action`1<object> action, object state, TaskScheduler scheduler);
    internal virtual void Run(Task task, bool canInlineContinuationTask);
    internal static bool get_IsValidLocationForInlining();
    private sealed virtual override void System.Threading.IThreadPoolWorkItem.Execute();
    protected static ContextCallback GetInvokeActionCallback();
    protected void RunCallback(ContextCallback callback, object state, Task& currentTask);
    internal static void RunOrScheduleAction(Action action, bool allowInlining);
    internal static void RunOrScheduleAction(IAsyncStateMachineBox box, bool allowInlining);
    internal static void UnsafeScheduleAction(Action action, Task task);
    internal virtual Delegate[] GetDelegateContinuationsForDebugger();
}
internal enum System.Threading.Tasks.CausalityRelation : Enum {
    public int value__;
    public static CausalityRelation AssignDelegate;
    public static CausalityRelation Join;
    public static CausalityRelation Choice;
    public static CausalityRelation Cancel;
    public static CausalityRelation Error;
}
internal enum System.Threading.Tasks.CausalitySynchronousWork : Enum {
    public int value__;
    public static CausalitySynchronousWork CompletionNotification;
    public static CausalitySynchronousWork ProgressNotification;
    public static CausalitySynchronousWork Execution;
}
internal class System.Threading.Tasks.CompletionActionInvoker : object {
    private ITaskCompletionAction m_action;
    private Task m_completingTask;
    internal CompletionActionInvoker(ITaskCompletionAction action, Task completingTask);
    private sealed virtual override void System.Threading.IThreadPoolWorkItem.Execute();
}
[DebuggerTypeProxyAttribute("System.Threading.Tasks.ConcurrentExclusiveSchedulerPair/DebugView")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("Concurrent={ConcurrentTaskCountForDebugger}, Exclusive={ExclusiveTaskCountForDebugger}, Mode={ModeForDebugger}")]
[NullableContextAttribute("1")]
public class System.Threading.Tasks.ConcurrentExclusiveSchedulerPair : object {
    private ThreadLocal`1<ProcessingMode> m_threadProcessingMode;
    private ConcurrentExclusiveTaskScheduler m_concurrentTaskScheduler;
    private ConcurrentExclusiveTaskScheduler m_exclusiveTaskScheduler;
    private TaskScheduler m_underlyingTaskScheduler;
    private int m_maxConcurrencyLevel;
    private int m_maxItemsPerTask;
    private int m_processingCount;
    private CompletionState m_completionState;
    private SchedulerWorkItem m_threadPoolWorkItem;
    private static int DefaultMaxConcurrencyLevel { get; }
    private object ValueLock { get; }
    public Task Completion { get; }
    private bool CompletionRequested { get; }
    private bool ReadyToComplete { get; }
    public TaskScheduler ConcurrentScheduler { get; }
    public TaskScheduler ExclusiveScheduler { get; }
    private int ConcurrentTaskCountForDebugger { get; }
    private int ExclusiveTaskCountForDebugger { get; }
    private ProcessingMode ModeForDebugger { get; }
    public ConcurrentExclusiveSchedulerPair(TaskScheduler taskScheduler);
    public ConcurrentExclusiveSchedulerPair(TaskScheduler taskScheduler, int maxConcurrencyLevel);
    public ConcurrentExclusiveSchedulerPair(TaskScheduler taskScheduler, int maxConcurrencyLevel, int maxItemsPerTask);
    private static int get_DefaultMaxConcurrencyLevel();
    private object get_ValueLock();
    public void Complete();
    public Task get_Completion();
    private CompletionState EnsureCompletionStateInitialized();
    private bool get_CompletionRequested();
    private void RequestCompletion();
    private void CleanupStateIfCompletingAndQuiesced();
    private bool get_ReadyToComplete();
    private void CompleteTaskAsync();
    private void FaultWithTask(Task faultedTask);
    public TaskScheduler get_ConcurrentScheduler();
    public TaskScheduler get_ExclusiveScheduler();
    private int get_ConcurrentTaskCountForDebugger();
    private int get_ExclusiveTaskCountForDebugger();
    private void ProcessAsyncIfNecessary(bool fairly);
    private bool TryQueueThreadPoolWorkItem(bool fairly);
    private void ProcessExclusiveTasks();
    private void ProcessConcurrentTasks();
    private ProcessingMode get_ModeForDebugger();
    internal static TaskCreationOptions GetCreationOptionsForTask(bool isReplacementReplica);
}
internal class System.Threading.Tasks.ContinuationResultTaskFromResultTask`2 : Task`1<TResult> {
    private Task`1<TAntecedentResult> m_antecedent;
    public ContinuationResultTaskFromResultTask`2(Task`1<TAntecedentResult> antecedent, Delegate function, object state, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions);
    internal virtual void InnerInvoke();
}
internal class System.Threading.Tasks.ContinuationResultTaskFromTask`1 : Task`1<TResult> {
    private Task m_antecedent;
    public ContinuationResultTaskFromTask`1(Task antecedent, Delegate function, object state, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions);
    internal virtual void InnerInvoke();
}
internal class System.Threading.Tasks.ContinuationTaskFromResultTask`1 : Task {
    private Task`1<TAntecedentResult> m_antecedent;
    public ContinuationTaskFromResultTask`1(Task`1<TAntecedentResult> antecedent, Delegate action, object state, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions);
    internal virtual void InnerInvoke();
}
internal class System.Threading.Tasks.ContinuationTaskFromTask : Task {
    private Task m_antecedent;
    public ContinuationTaskFromTask(Task antecedent, Delegate action, object state, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions);
    internal virtual void InnerInvoke();
}
internal static class System.Threading.Tasks.GenericDelegateCache`2 : object {
    internal static Func`3<Task`1<Task>, object, TResult> CWAnyFuncDelegate;
    internal static Func`3<Task`1<Task>, object, TResult> CWAnyActionDelegate;
    internal static Func`3<Task`1<Task`1[]>, object, TResult> CWAllFuncDelegate;
    internal static Func`3<Task`1<Task`1[]>, object, TResult> CWAllActionDelegate;
    private static GenericDelegateCache`2();
}
[FlagsAttribute]
internal enum System.Threading.Tasks.InternalTaskOptions : Enum {
    public int value__;
    public static InternalTaskOptions None;
    public static InternalTaskOptions InternalOptionsMask;
    public static InternalTaskOptions ContinuationTask;
    public static InternalTaskOptions PromiseTask;
    public static InternalTaskOptions LazyCancellation;
    public static InternalTaskOptions QueuedByRuntime;
    public static InternalTaskOptions DoNotDispose;
}
internal interface System.Threading.Tasks.IProducerConsumerQueue`1 {
    public bool IsEmpty { get; }
    public int Count { get; }
    public abstract virtual void Enqueue(T item);
    public abstract virtual bool TryDequeue(T& result);
    public abstract virtual bool get_IsEmpty();
    public abstract virtual int get_Count();
}
internal interface System.Threading.Tasks.ITaskCompletionAction {
    public bool InvokeMayRunArbitraryCode { get; }
    public abstract virtual void Invoke(Task completingTask);
    public abstract virtual bool get_InvokeMayRunArbitraryCode();
}
[DebuggerDisplayAttribute("Count = {Count}")]
internal class System.Threading.Tasks.MultiProducerMultiConsumerQueue`1 : ConcurrentQueue`1<T> {
    private bool System.Threading.Tasks.IProducerConsumerQueue<T>.IsEmpty { get; }
    private int System.Threading.Tasks.IProducerConsumerQueue<T>.Count { get; }
    private sealed virtual override void System.Threading.Tasks.IProducerConsumerQueue<T>.Enqueue(T item);
    private sealed virtual override bool System.Threading.Tasks.IProducerConsumerQueue<T>.TryDequeue(T& result);
    private sealed virtual override bool System.Threading.Tasks.IProducerConsumerQueue<T>.get_IsEmpty();
    private sealed virtual override int System.Threading.Tasks.IProducerConsumerQueue<T>.get_Count();
}
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Threading.Tasks.SingleProducerSingleConsumerQueue`1/SingleProducerSingleConsumerQueue_DebugView")]
internal class System.Threading.Tasks.SingleProducerSingleConsumerQueue`1 : object {
    private Segment modreq(System.Runtime.CompilerServices.IsVolatile) m_head;
    private Segment modreq(System.Runtime.CompilerServices.IsVolatile) m_tail;
    public bool IsEmpty { get; }
    public int Count { get; }
    public sealed virtual void Enqueue(T item);
    private void EnqueueSlow(T item, Segment& segment);
    public sealed virtual bool TryDequeue(T& result);
    private bool TryDequeueSlow(Segment& segment, T[]& array, T& result);
    public sealed virtual bool get_IsEmpty();
    [IteratorStateMachineAttribute("System.Threading.Tasks.SingleProducerSingleConsumerQueue`1/<GetEnumerator>d__11")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
}
[NullableContextAttribute("2")]
public interface System.Threading.Tasks.Sources.IValueTaskSource {
    public abstract virtual ValueTaskSourceStatus GetStatus(short token);
    public abstract virtual void OnCompleted(Action`1<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags);
    public abstract virtual void GetResult(short token);
}
[NullableContextAttribute("2")]
public interface System.Threading.Tasks.Sources.IValueTaskSource`1 {
    public abstract virtual ValueTaskSourceStatus GetStatus(short token);
    public abstract virtual void OnCompleted(Action`1<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags);
    [NullableContextAttribute("1")]
public abstract virtual TResult GetResult(short token);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Threading.Tasks.Sources.ManualResetValueTaskSourceCore`1 : ValueType {
    private Action`1<object> _continuation;
    private object _continuationState;
    private ExecutionContext _executionContext;
    private object _capturedContext;
    private bool _completed;
    [AllowNullAttribute]
[MaybeNullAttribute]
private TResult _result;
    private ExceptionDispatchInfo _error;
    private short _version;
    [CompilerGeneratedAttribute]
private bool <RunContinuationsAsynchronously>k__BackingField;
    public bool RunContinuationsAsynchronously { get; public set; }
    public short Version { get; }
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public bool get_RunContinuationsAsynchronously();
    [CompilerGeneratedAttribute]
public void set_RunContinuationsAsynchronously(bool value);
    public void Reset();
    public void SetResult(TResult result);
    public void SetException(Exception error);
    public short get_Version();
    public ValueTaskSourceStatus GetStatus(short token);
    [StackTraceHiddenAttribute]
public TResult GetResult(short token);
    [NullableContextAttribute("2")]
public void OnCompleted(Action`1<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags);
    private void ValidateToken(short token);
    private void SignalCompletion();
    private void InvokeContinuation();
}
internal static class System.Threading.Tasks.Sources.ManualResetValueTaskSourceCoreShared : object {
    internal static Action`1<object> s_sentinel;
    private static ManualResetValueTaskSourceCoreShared();
    private static void CompletionSentinel(object _);
}
[FlagsAttribute]
public enum System.Threading.Tasks.Sources.ValueTaskSourceOnCompletedFlags : Enum {
    public int value__;
    public static ValueTaskSourceOnCompletedFlags None;
    public static ValueTaskSourceOnCompletedFlags UseSchedulingContext;
    public static ValueTaskSourceOnCompletedFlags FlowExecutionContext;
}
public enum System.Threading.Tasks.Sources.ValueTaskSourceStatus : Enum {
    public int value__;
    public static ValueTaskSourceStatus Pending;
    public static ValueTaskSourceStatus Succeeded;
    public static ValueTaskSourceStatus Faulted;
    public static ValueTaskSourceStatus Canceled;
}
internal class System.Threading.Tasks.StandardTaskContinuation : TaskContinuation {
    internal Task m_task;
    internal TaskContinuationOptions m_options;
    private TaskScheduler m_taskScheduler;
    internal StandardTaskContinuation(Task task, TaskContinuationOptions options, TaskScheduler scheduler);
    internal virtual void Run(Task completedTask, bool canInlineContinuationTask);
    internal virtual Delegate[] GetDelegateContinuationsForDebugger();
}
internal class System.Threading.Tasks.SynchronizationContextAwaitTaskContinuation : AwaitTaskContinuation {
    private static SendOrPostCallback s_postCallback;
    private static ContextCallback s_postActionCallback;
    private SynchronizationContext m_syncContext;
    internal SynchronizationContextAwaitTaskContinuation(SynchronizationContext context, Action action, bool flowExecutionContext);
    private static SynchronizationContextAwaitTaskContinuation();
    internal sealed virtual void Run(Task task, bool canInlineContinuationTask);
    private static void PostAction(object state);
    private static Action GetActionLogDelegate(int continuationId, Action action);
    private static ContextCallback GetPostActionCallback();
}
internal class System.Threading.Tasks.SynchronizationContextTaskScheduler : TaskScheduler {
    private SynchronizationContext m_synchronizationContext;
    private static SendOrPostCallback s_postCallback;
    public int MaximumConcurrencyLevel { get; }
    private static SynchronizationContextTaskScheduler();
    protected internal virtual void QueueTask(Task task);
    protected virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
    protected virtual IEnumerable`1<Task> GetScheduledTasks();
    public virtual int get_MaximumConcurrencyLevel();
}
internal class System.Threading.Tasks.SystemThreadingTasks_FutureDebugView`1 : object {
    private Task`1<TResult> m_task;
    public TResult Result { get; }
    public object AsyncState { get; }
    public TaskCreationOptions CreationOptions { get; }
    public Exception Exception { get; }
    public int Id { get; }
    public bool CancellationPending { get; }
    public TaskStatus Status { get; }
    public SystemThreadingTasks_FutureDebugView`1(Task`1<TResult> task);
    public TResult get_Result();
    public object get_AsyncState();
    public TaskCreationOptions get_CreationOptions();
    public Exception get_Exception();
    public int get_Id();
    public bool get_CancellationPending();
    public TaskStatus get_Status();
}
internal class System.Threading.Tasks.SystemThreadingTasks_TaskDebugView : object {
    private Task m_task;
    public object AsyncState { get; }
    public TaskCreationOptions CreationOptions { get; }
    public Exception Exception { get; }
    public int Id { get; }
    public bool CancellationPending { get; }
    public TaskStatus Status { get; }
    public SystemThreadingTasks_TaskDebugView(Task task);
    public object get_AsyncState();
    public TaskCreationOptions get_CreationOptions();
    public Exception get_Exception();
    public int get_Id();
    public bool get_CancellationPending();
    public TaskStatus get_Status();
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
[DebuggerDisplayAttribute("Id = {Id}, Status = {Status}, Method = {DebuggerDisplayMethodDescription}")]
[DebuggerTypeProxyAttribute("System.Threading.Tasks.SystemThreadingTasks_TaskDebugView")]
public class System.Threading.Tasks.Task : object {
    [ThreadStaticAttribute]
internal static Task t_currentTask;
    internal static int s_taskIdCounter;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_taskId;
    internal Delegate m_action;
    internal object m_stateObject;
    internal TaskScheduler m_taskScheduler;
    internal Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_stateFlags;
    private Object modreq(System.Runtime.CompilerServices.IsVolatile) m_continuationObject;
    private static object s_taskCompletionSentinel;
    internal static bool s_asyncDebuggingEnabled;
    private static Dictionary`2<int, Task> s_currentActiveTasks;
    internal ContingentProperties m_contingentProperties;
    [CompilerGeneratedAttribute]
private static TaskFactory <Factory>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task <CompletedTask>k__BackingField;
    private static ContextCallback s_ecCallback;
    [NullableAttribute("2")]
private Task ParentForDebugger { get; }
    private int StateFlagsForDebugger { get; }
    private string DebuggerDisplayMethodDescription { get; }
    internal TaskCreationOptions Options { get; }
    internal bool IsWaitNotificationEnabledOrNotRanToCompletion { get; }
    internal bool ShouldNotifyDebuggerOfWaitCompletion { get; }
    internal bool IsWaitNotificationEnabled { get; }
    public int Id { get; }
    public static Nullable`1<int> CurrentId { get; }
    [NullableAttribute("2")]
internal static Task InternalCurrent { get; }
    [NullableAttribute("2")]
public AggregateException Exception { get; }
    public TaskStatus Status { get; }
    public bool IsCanceled { get; }
    internal bool IsCancellationRequested { get; }
    internal CancellationToken CancellationToken { get; }
    internal bool IsCancellationAcknowledged { get; }
    public bool IsCompleted { get; }
    public bool IsCompletedSuccessfully { get; }
    public TaskCreationOptions CreationOptions { get; }
    private WaitHandle System.IAsyncResult.AsyncWaitHandle { get; }
    [NullableAttribute("2")]
public object AsyncState { get; }
    private bool System.IAsyncResult.CompletedSynchronously { get; }
    [NullableAttribute("2")]
internal TaskScheduler ExecutingTaskScheduler { get; }
    public static TaskFactory Factory { get; }
    public static Task CompletedTask { get; }
    internal ManualResetEventSlim CompletedEvent { get; }
    internal bool ExceptionRecorded { get; }
    public bool IsFaulted { get; }
    [NullableAttribute("2")]
internal ExecutionContext CapturedContext { get; internal set; }
    internal bool IsExceptionObservedByParent { get; }
    internal bool IsDelegateInvoked { get; }
    internal Task(bool canceled, TaskCreationOptions creationOptions, CancellationToken ct);
    internal Task(object state, TaskCreationOptions creationOptions, bool promiseStyle);
    public Task(Action action);
    public Task(Action action, CancellationToken cancellationToken);
    public Task(Action action, TaskCreationOptions creationOptions);
    public Task(Action action, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
    [NullableContextAttribute("2")]
public Task(Action`1<object> action, object state);
    [NullableContextAttribute("2")]
public Task(Action`1<object> action, object state, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public Task(Action`1<object> action, object state, TaskCreationOptions creationOptions);
    [NullableContextAttribute("2")]
public Task(Action`1<object> action, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
    internal Task(Delegate action, object state, Task parent, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
    private static Task();
    private Task get_ParentForDebugger();
    private int get_StateFlagsForDebugger();
    internal static bool AddToActiveTasks(Task task);
    internal static void RemoveFromActiveTasks(Task task);
    internal void TaskConstructorCore(Delegate action, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
    private void AssignCancellationToken(CancellationToken cancellationToken, Task antecedent, TaskContinuation continuation);
    private string get_DebuggerDisplayMethodDescription();
    internal TaskCreationOptions get_Options();
    internal static TaskCreationOptions OptionsMethod(int flags);
    internal bool AtomicStateUpdate(int newBits, int illegalBits);
    private bool AtomicStateUpdateSlow(int newBits, int illegalBits);
    internal bool AtomicStateUpdate(int newBits, int illegalBits, Int32& oldFlags);
    internal void SetNotificationForWaitCompletion(bool enabled);
    internal bool NotifyDebuggerOfWaitCompletionIfNecessary();
    internal static bool AnyTaskRequiresNotifyDebuggerOfWaitCompletion(Task[] tasks);
    internal bool get_IsWaitNotificationEnabledOrNotRanToCompletion();
    internal virtual bool get_ShouldNotifyDebuggerOfWaitCompletion();
    internal bool get_IsWaitNotificationEnabled();
    private void NotifyDebuggerOfWaitCompletion();
    internal bool MarkStarted();
    internal void FireTaskScheduledIfNeeded(TaskScheduler ts);
    internal void AddNewChild();
    internal void DisregardChild();
    public void Start();
    public void Start(TaskScheduler scheduler);
    public void RunSynchronously();
    public void RunSynchronously(TaskScheduler scheduler);
    internal void InternalRunSynchronously(TaskScheduler scheduler, bool waitForCompletion);
    internal static Task InternalStartNew(Task creatingTask, Delegate action, object state, CancellationToken cancellationToken, TaskScheduler scheduler, TaskCreationOptions options, InternalTaskOptions internalOptions);
    internal static int NewId();
    public int get_Id();
    public static Nullable`1<int> get_CurrentId();
    internal static Task get_InternalCurrent();
    internal static Task InternalCurrentIfAttached(TaskCreationOptions creationOptions);
    [NullableContextAttribute("2")]
public AggregateException get_Exception();
    public TaskStatus get_Status();
    public bool get_IsCanceled();
    internal bool get_IsCancellationRequested();
    internal ContingentProperties EnsureContingentPropertiesInitialized();
    internal ContingentProperties EnsureContingentPropertiesInitializedUnsafe();
    internal CancellationToken get_CancellationToken();
    internal bool get_IsCancellationAcknowledged();
    public sealed virtual bool get_IsCompleted();
    private static bool IsCompletedMethod(int flags);
    public bool get_IsCompletedSuccessfully();
    public TaskCreationOptions get_CreationOptions();
    private sealed virtual override WaitHandle System.IAsyncResult.get_AsyncWaitHandle();
    [NullableContextAttribute("2")]
public sealed virtual object get_AsyncState();
    private sealed virtual override bool System.IAsyncResult.get_CompletedSynchronously();
    internal TaskScheduler get_ExecutingTaskScheduler();
    [CompilerGeneratedAttribute]
public static TaskFactory get_Factory();
    [CompilerGeneratedAttribute]
public static Task get_CompletedTask();
    internal ManualResetEventSlim get_CompletedEvent();
    internal bool get_ExceptionRecorded();
    public bool get_IsFaulted();
    internal ExecutionContext get_CapturedContext();
    internal void set_CapturedContext(ExecutionContext value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    internal void ScheduleAndStart(bool needsProtection);
    internal void AddException(object exceptionObject);
    internal void AddException(object exceptionObject, bool representsCancellation);
    private AggregateException GetExceptions(bool includeTaskCanceledExceptions);
    internal ReadOnlyCollection`1<ExceptionDispatchInfo> GetExceptionDispatchInfos();
    internal ExceptionDispatchInfo GetCancellationExceptionDispatchInfo();
    internal void ThrowIfExceptional(bool includeTaskCanceledExceptions);
    internal static void ThrowAsync(Exception exception, SynchronizationContext targetContext);
    internal void UpdateExceptionObservedStatus();
    internal bool get_IsExceptionObservedByParent();
    internal bool get_IsDelegateInvoked();
    internal void Finish(bool userDelegateExecute);
    private void FinishSlow(bool userDelegateExecute);
    private void FinishStageTwo();
    internal void FinishStageThree();
    internal void NotifyParentIfPotentiallyAttachedTask();
    internal void ProcessChildCompletion(Task childTask);
    internal void AddExceptionsFromChildren(ContingentProperties props);
    internal bool ExecuteEntry();
    internal virtual void ExecuteFromThreadPool(Thread threadPoolThread);
    internal void ExecuteEntryUnsafe(Thread threadPoolThread);
    internal void ExecuteEntryCancellationRequestedOrCanceled();
    private void ExecuteWithThreadLocal(Task& currentTaskSlot, Thread threadPoolThread);
    internal virtual void InnerInvoke();
    private void HandleException(Exception unhandledException);
    public TaskAwaiter GetAwaiter();
    public ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext);
    internal void SetContinuationForAwait(Action continuationAction, bool continueOnCapturedContext, bool flowExecutionContext);
    internal void UnsafeSetContinuationForAwait(IAsyncStateMachineBox stateMachineBox, bool continueOnCapturedContext);
    public static YieldAwaitable Yield();
    public void Wait();
    public bool Wait(TimeSpan timeout);
    public void Wait(CancellationToken cancellationToken);
    public bool Wait(int millisecondsTimeout);
    public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken);
    private bool WrappedTryRunInline();
    internal bool InternalWait(int millisecondsTimeout, CancellationToken cancellationToken);
    private bool InternalWaitCore(int millisecondsTimeout, CancellationToken cancellationToken);
    private bool SpinThenBlockingWait(int millisecondsTimeout, CancellationToken cancellationToken);
    private bool SpinWait(int millisecondsTimeout);
    internal bool InternalCancel(bool bCancelNonExecutingOnly);
    internal void RecordInternalCancellationRequest();
    internal void RecordInternalCancellationRequest(CancellationToken tokenToRecord);
    internal void RecordInternalCancellationRequest(CancellationToken tokenToRecord, object cancellationException);
    internal void CancellationCleanupLogic();
    private void SetCancellationAcknowledged();
    internal bool TrySetResult();
    internal bool TrySetException(object exceptionObject);
    internal bool TrySetCanceled(CancellationToken tokenToRecord);
    internal bool TrySetCanceled(CancellationToken tokenToRecord, object cancellationException);
    internal void FinishContinuations();
    private void RunContinuations(object continuationObject);
    private void RunOrQueueCompletionAction(ITaskCompletionAction completionAction, bool allowInlining);
    private static void LogFinishCompletionNotification();
    public Task ContinueWith(Action`1<Task> continuationAction);
    public Task ContinueWith(Action`1<Task> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWith(Action`1<Task> continuationAction, TaskScheduler scheduler);
    public Task ContinueWith(Action`1<Task> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`1<Task> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    private Task ContinueWith(Action`1<Task> continuationAction, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`2<Task, object> continuationAction, object state);
    public Task ContinueWith(Action`2<Task, object> continuationAction, object state, CancellationToken cancellationToken);
    public Task ContinueWith(Action`2<Task, object> continuationAction, object state, TaskScheduler scheduler);
    public Task ContinueWith(Action`2<Task, object> continuationAction, object state, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`2<Task, object> continuationAction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    private Task ContinueWith(Action`2<Task, object> continuationAction, object state, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    private Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions);
    [NullableContextAttribute("2")]
public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state);
    [NullableContextAttribute("2")]
public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state, TaskScheduler scheduler);
    [NullableContextAttribute("2")]
public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    private Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions);
    internal static void CreationOptionsFromContinuationOptions(TaskContinuationOptions continuationOptions, TaskCreationOptions& creationOptions, InternalTaskOptions& internalOptions);
    internal void ContinueWithCore(Task continuationTask, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions options);
    internal void AddCompletionAction(ITaskCompletionAction action);
    internal void AddCompletionAction(ITaskCompletionAction action, bool addBeforeOthers);
    private bool AddTaskContinuationComplex(object tc, bool addBeforeOthers);
    private bool AddTaskContinuation(object tc, bool addBeforeOthers);
    internal void RemoveContinuation(object continuationObject);
    public static void WaitAll(Task[] tasks);
    public static bool WaitAll(Task[] tasks, TimeSpan timeout);
    public static bool WaitAll(Task[] tasks, int millisecondsTimeout);
    public static void WaitAll(Task[] tasks, CancellationToken cancellationToken);
    public static bool WaitAll(Task[] tasks, int millisecondsTimeout, CancellationToken cancellationToken);
    private static bool WaitAllCore(Task[] tasks, int millisecondsTimeout, CancellationToken cancellationToken);
    private static void AddToList(T item, List`1& list, int initSize);
    private static bool WaitAllBlockingCore(List`1<Task> tasks, int millisecondsTimeout, CancellationToken cancellationToken);
    internal static void AddExceptionsForCompletedTask(List`1& exceptions, Task t);
    public static int WaitAny(Task[] tasks);
    public static int WaitAny(Task[] tasks, TimeSpan timeout);
    public static int WaitAny(Task[] tasks, CancellationToken cancellationToken);
    public static int WaitAny(Task[] tasks, int millisecondsTimeout);
    public static int WaitAny(Task[] tasks, int millisecondsTimeout, CancellationToken cancellationToken);
    private static int WaitAnyCore(Task[] tasks, int millisecondsTimeout, CancellationToken cancellationToken);
    public static Task`1<TResult> FromResult(TResult result);
    public static Task FromException(Exception exception);
    public static Task`1<TResult> FromException(Exception exception);
    public static Task FromCanceled(CancellationToken cancellationToken);
    public static Task`1<TResult> FromCanceled(CancellationToken cancellationToken);
    internal static Task FromCanceled(OperationCanceledException exception);
    internal static Task`1<TResult> FromCanceled(OperationCanceledException exception);
    public static Task Run(Action action);
    public static Task Run(Action action, CancellationToken cancellationToken);
    public static Task`1<TResult> Run(Func`1<TResult> function);
    public static Task`1<TResult> Run(Func`1<TResult> function, CancellationToken cancellationToken);
    public static Task Run(Func`1<Task> function);
    public static Task Run(Func`1<Task> function, CancellationToken cancellationToken);
    public static Task`1<TResult> Run(Func`1<Task`1<TResult>> function);
    public static Task`1<TResult> Run(Func`1<Task`1<TResult>> function, CancellationToken cancellationToken);
    public static Task Delay(TimeSpan delay);
    public static Task Delay(TimeSpan delay, CancellationToken cancellationToken);
    public static Task Delay(int millisecondsDelay);
    public static Task Delay(int millisecondsDelay, CancellationToken cancellationToken);
    public static Task WhenAll(IEnumerable`1<Task> tasks);
    public static Task WhenAll(Task[] tasks);
    private static Task InternalWhenAll(Task[] tasks);
    public static Task`1<TResult[]> WhenAll(IEnumerable`1<Task`1<TResult>> tasks);
    public static Task`1<TResult[]> WhenAll(Task`1[] tasks);
    private static Task`1<TResult[]> InternalWhenAll(Task`1[] tasks);
    public static Task`1<Task> WhenAny(Task[] tasks);
    public static Task`1<Task> WhenAny(IEnumerable`1<Task> tasks);
    public static Task`1<Task`1<TResult>> WhenAny(Task`1[] tasks);
    public static Task`1<Task`1<TResult>> WhenAny(IEnumerable`1<Task`1<TResult>> tasks);
    internal static Task`1<TResult> CreateUnwrapPromise(Task outerTask, bool lookForOce);
    internal virtual Delegate[] GetDelegateContinuationsForDebugger();
    private static Delegate[] GetDelegatesFromContinuationObject(object continuationObject);
    private static Task GetActiveTaskFromId(int taskId);
}
[NullableContextAttribute("1")]
[DebuggerDisplayAttribute("Id = {Id}, Status = {Status}, Method = {DebuggerDisplayMethodDescription}, Result = {DebuggerDisplayResultDescription}")]
[NullableAttribute("0")]
[DebuggerTypeProxyAttribute("System.Threading.Tasks.SystemThreadingTasks_FutureDebugView`1")]
public class System.Threading.Tasks.Task`1 : Task {
    [MaybeNullAttribute]
internal TResult m_result;
    private static TaskFactory`1<TResult> s_Factory;
    private string DebuggerDisplayResultDescription { get; }
    private string DebuggerDisplayMethodDescription { get; }
    [DebuggerBrowsableAttribute("0")]
public TResult Result { get; }
    internal TResult ResultOnSuccess { get; }
    public static TaskFactory`1<TResult> Factory { get; }
    internal Task`1(object state, TaskCreationOptions options);
    internal Task`1(TResult result);
    internal Task`1(bool canceled, TResult result, TaskCreationOptions creationOptions, CancellationToken ct);
    public Task`1(Func`1<TResult> function);
    public Task`1(Func`1<TResult> function, CancellationToken cancellationToken);
    public Task`1(Func`1<TResult> function, TaskCreationOptions creationOptions);
    public Task`1(Func`1<TResult> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
    [NullableContextAttribute("2")]
public Task`1(Func`2<object, TResult> function, object state);
    [NullableContextAttribute("2")]
public Task`1(Func`2<object, TResult> function, object state, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public Task`1(Func`2<object, TResult> function, object state, TaskCreationOptions creationOptions);
    [NullableContextAttribute("2")]
public Task`1(Func`2<object, TResult> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
    internal Task`1(Func`1<TResult> valueSelector, Task parent, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
    internal Task`1(Delegate valueSelector, object state, Task parent, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
    private static Task`1();
    internal static Task`1<TResult> StartNew(Task parent, Func`1<TResult> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
    internal static Task`1<TResult> StartNew(Task parent, Func`2<object, TResult> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
    private string get_DebuggerDisplayResultDescription();
    private string get_DebuggerDisplayMethodDescription();
    internal bool TrySetResult(TResult result);
    internal void DangerousSetResult(TResult result);
    public TResult get_Result();
    internal TResult get_ResultOnSuccess();
    internal TResult GetResultCore(bool waitCompletionNotification);
    public static TaskFactory`1<TResult> get_Factory();
    internal virtual void InnerInvoke();
    public TaskAwaiter`1<TResult> GetAwaiter();
    public ConfiguredTaskAwaitable`1<TResult> ConfigureAwait(bool continueOnCapturedContext);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, TaskScheduler scheduler);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state);
    public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, CancellationToken cancellationToken);
    public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, TaskScheduler scheduler);
    public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, TaskScheduler scheduler);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions);
    [NullableContextAttribute("2")]
public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state);
    [NullableContextAttribute("2")]
public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, CancellationToken cancellationToken);
    public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, TaskScheduler scheduler);
    [NullableContextAttribute("2")]
public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, TaskContinuationOptions continuationOptions);
    public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Threading.Tasks.TaskAsyncEnumerableExtensions : object {
    [ExtensionAttribute]
public static ConfiguredAsyncDisposable ConfigureAwait(IAsyncDisposable source, bool continueOnCapturedContext);
    [ExtensionAttribute]
public static ConfiguredCancelableAsyncEnumerable`1<T> ConfigureAwait(IAsyncEnumerable`1<T> source, bool continueOnCapturedContext);
    [ExtensionAttribute]
public static ConfiguredCancelableAsyncEnumerable`1<T> WithCancellation(IAsyncEnumerable`1<T> source, CancellationToken cancellationToken);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableAttribute("0")]
[NullableContextAttribute("2")]
public class System.Threading.Tasks.TaskCanceledException : OperationCanceledException {
    private Task _canceledTask;
    public Task Task { get; }
    public TaskCanceledException(string message);
    public TaskCanceledException(string message, Exception innerException);
    public TaskCanceledException(string message, Exception innerException, CancellationToken token);
    public TaskCanceledException(Task task);
    [NullableContextAttribute("1")]
protected TaskCanceledException(SerializationInfo info, StreamingContext context);
    public Task get_Task();
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Threading.Tasks.TaskCompletionSource`1 : object {
    private Task`1<TResult> _task;
    public Task`1<TResult> Task { get; }
    public TaskCompletionSource`1(TaskCreationOptions creationOptions);
    [NullableContextAttribute("2")]
public TaskCompletionSource`1(object state);
    [NullableContextAttribute("2")]
public TaskCompletionSource`1(object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> get_Task();
    private void SpinUntilCompleted();
    public bool TrySetException(Exception exception);
    public bool TrySetException(IEnumerable`1<Exception> exceptions);
    public void SetException(Exception exception);
    public void SetException(IEnumerable`1<Exception> exceptions);
    public bool TrySetResult(TResult result);
    public void SetResult(TResult result);
    public bool TrySetCanceled();
    public bool TrySetCanceled(CancellationToken cancellationToken);
    public void SetCanceled();
}
internal abstract class System.Threading.Tasks.TaskContinuation : object {
    internal abstract virtual void Run(Task completedTask, bool canInlineContinuationTask);
    protected static void InlineIfPossibleOrElseQueue(Task task, bool needsProtection);
    internal abstract virtual Delegate[] GetDelegateContinuationsForDebugger();
}
[FlagsAttribute]
public enum System.Threading.Tasks.TaskContinuationOptions : Enum {
    public int value__;
    public static TaskContinuationOptions None;
    public static TaskContinuationOptions PreferFairness;
    public static TaskContinuationOptions LongRunning;
    public static TaskContinuationOptions AttachedToParent;
    public static TaskContinuationOptions DenyChildAttach;
    public static TaskContinuationOptions HideScheduler;
    public static TaskContinuationOptions LazyCancellation;
    public static TaskContinuationOptions RunContinuationsAsynchronously;
    public static TaskContinuationOptions NotOnRanToCompletion;
    public static TaskContinuationOptions NotOnFaulted;
    public static TaskContinuationOptions NotOnCanceled;
    public static TaskContinuationOptions OnlyOnRanToCompletion;
    public static TaskContinuationOptions OnlyOnFaulted;
    public static TaskContinuationOptions OnlyOnCanceled;
    public static TaskContinuationOptions ExecuteSynchronously;
}
[FlagsAttribute]
public enum System.Threading.Tasks.TaskCreationOptions : Enum {
    public int value__;
    public static TaskCreationOptions None;
    public static TaskCreationOptions PreferFairness;
    public static TaskCreationOptions LongRunning;
    public static TaskCreationOptions AttachedToParent;
    public static TaskCreationOptions DenyChildAttach;
    public static TaskCreationOptions HideScheduler;
    public static TaskCreationOptions RunContinuationsAsynchronously;
}
internal class System.Threading.Tasks.TaskExceptionHolder : object {
    private Task m_task;
    private List`1 modreq(System.Runtime.CompilerServices.IsVolatile) m_faultExceptions;
    private ExceptionDispatchInfo m_cancellationException;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_isHandled;
    internal bool ContainsFaultList { get; }
    internal TaskExceptionHolder(Task task);
    protected virtual override void Finalize();
    internal bool get_ContainsFaultList();
    internal void Add(object exceptionObject, bool representsCancellation);
    private void SetCancellationException(object exceptionObject);
    private void AddFaultException(object exceptionObject);
    private void MarkAsUnhandled();
    internal void MarkAsHandled(bool calledFromFinalizer);
    internal AggregateException CreateExceptionObject(bool calledFromFinalizer, Exception includeThisException);
    internal ReadOnlyCollection`1<ExceptionDispatchInfo> GetExceptionDispatchInfos();
    internal ExceptionDispatchInfo GetCancellationExceptionDispatchInfo();
}
[NullableAttribute("0")]
[ExtensionAttribute]
[NullableContextAttribute("1")]
public static class System.Threading.Tasks.TaskExtensions : object {
    [ExtensionAttribute]
public static Task Unwrap(Task`1<Task> task);
    [ExtensionAttribute]
public static Task`1<TResult> Unwrap(Task`1<Task`1<TResult>> task);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Threading.Tasks.TaskFactory : object {
    private CancellationToken m_defaultCancellationToken;
    private TaskScheduler m_defaultScheduler;
    private TaskCreationOptions m_defaultCreationOptions;
    private TaskContinuationOptions m_defaultContinuationOptions;
    private TaskScheduler DefaultScheduler { get; }
    public CancellationToken CancellationToken { get; }
    [NullableAttribute("2")]
public TaskScheduler Scheduler { get; }
    public TaskCreationOptions CreationOptions { get; }
    public TaskContinuationOptions ContinuationOptions { get; }
    public TaskFactory(CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public TaskFactory(TaskScheduler scheduler);
    public TaskFactory(TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions);
    [NullableContextAttribute("2")]
public TaskFactory(CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    private TaskScheduler get_DefaultScheduler();
    private TaskScheduler GetDefaultScheduler(Task currTask);
    internal static void CheckCreationOptions(TaskCreationOptions creationOptions);
    public CancellationToken get_CancellationToken();
    [NullableContextAttribute("2")]
public TaskScheduler get_Scheduler();
    public TaskCreationOptions get_CreationOptions();
    public TaskContinuationOptions get_ContinuationOptions();
    public Task StartNew(Action action);
    public Task StartNew(Action action, CancellationToken cancellationToken);
    public Task StartNew(Action action, TaskCreationOptions creationOptions);
    public Task StartNew(Action action, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task StartNew(Action`1<object> action, object state);
    public Task StartNew(Action`1<object> action, object state, CancellationToken cancellationToken);
    public Task StartNew(Action`1<object> action, object state, TaskCreationOptions creationOptions);
    public Task StartNew(Action`1<object> action, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> StartNew(Func`1<TResult> function);
    public Task`1<TResult> StartNew(Func`1<TResult> function, CancellationToken cancellationToken);
    public Task`1<TResult> StartNew(Func`1<TResult> function, TaskCreationOptions creationOptions);
    public Task`1<TResult> StartNew(Func`1<TResult> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    [NullableContextAttribute("2")]
public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state);
    [NullableContextAttribute("2")]
public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task FromAsync(IAsyncResult asyncResult, Action`1<IAsyncResult> endMethod);
    public Task FromAsync(IAsyncResult asyncResult, Action`1<IAsyncResult> endMethod, TaskCreationOptions creationOptions);
    public Task FromAsync(IAsyncResult asyncResult, Action`1<IAsyncResult> endMethod, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, object state);
    public Task FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, object state, TaskCreationOptions creationOptions);
    public Task FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, object state);
    public Task FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, object state, TaskCreationOptions creationOptions);
    public Task FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, object state);
    public Task FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, object state, TaskCreationOptions creationOptions);
    public Task FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);
    public Task FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, object state);
    public Task`1<TResult> FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, object state);
    public Task`1<TResult> FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state);
    public Task`1<TResult> FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);
    public Task`1<TResult> FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, TaskCreationOptions creationOptions);
    internal static void CheckFromAsyncOptions(TaskCreationOptions creationOptions, bool hasBeginMethod);
    internal static Task`1<Task[]> CommonCWAllLogic(Task[] tasksCopy);
    internal static Task`1<Task`1[]> CommonCWAllLogic(Task`1[] tasksCopy);
    public Task ContinueWhenAll(Task[] tasks, Action`1<Task[]> continuationAction);
    public Task ContinueWhenAll(Task[] tasks, Action`1<Task[]> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWhenAll(Task[] tasks, Action`1<Task[]> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWhenAll(Task[] tasks, Action`1<Task[]> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task ContinueWhenAll(Task`1[] tasks, Action`1<Task`1[]> continuationAction);
    public Task ContinueWhenAll(Task`1[] tasks, Action`1<Task`1[]> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWhenAll(Task`1[] tasks, Action`1<Task`1[]> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWhenAll(Task`1[] tasks, Action`1<Task`1[]> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal static Task`1<Task> CommonCWAnyLogic(IList`1<Task> tasks, bool isSyncBlocking);
    internal static void CommonCWAnyLogicCleanup(Task`1<Task> continuation);
    public Task ContinueWhenAny(Task[] tasks, Action`1<Task> continuationAction);
    public Task ContinueWhenAny(Task[] tasks, Action`1<Task> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWhenAny(Task[] tasks, Action`1<Task> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWhenAny(Task[] tasks, Action`1<Task> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task ContinueWhenAny(Task`1[] tasks, Action`1<Task`1<TAntecedentResult>> continuationAction);
    public Task ContinueWhenAny(Task`1[] tasks, Action`1<Task`1<TAntecedentResult>> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWhenAny(Task`1[] tasks, Action`1<Task`1<TAntecedentResult>> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWhenAny(Task`1[] tasks, Action`1<Task`1<TAntecedentResult>> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal static Task[] CheckMultiContinuationTasksAndCopy(Task[] tasks);
    internal static Task`1[] CheckMultiContinuationTasksAndCopy(Task`1[] tasks);
    internal static void CheckMultiTaskContinuationOptions(TaskContinuationOptions continuationOptions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Threading.Tasks.TaskFactory`1 : object {
    private CancellationToken m_defaultCancellationToken;
    private TaskScheduler m_defaultScheduler;
    private TaskCreationOptions m_defaultCreationOptions;
    private TaskContinuationOptions m_defaultContinuationOptions;
    private TaskScheduler DefaultScheduler { get; }
    public CancellationToken CancellationToken { get; }
    [NullableAttribute("2")]
public TaskScheduler Scheduler { get; }
    public TaskCreationOptions CreationOptions { get; }
    public TaskContinuationOptions ContinuationOptions { get; }
    public TaskFactory`1(CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public TaskFactory`1(TaskScheduler scheduler);
    public TaskFactory`1(TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions);
    [NullableContextAttribute("2")]
public TaskFactory`1(CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    private TaskScheduler get_DefaultScheduler();
    private TaskScheduler GetDefaultScheduler(Task currTask);
    public CancellationToken get_CancellationToken();
    [NullableContextAttribute("2")]
public TaskScheduler get_Scheduler();
    public TaskCreationOptions get_CreationOptions();
    public TaskContinuationOptions get_ContinuationOptions();
    public Task`1<TResult> StartNew(Func`1<TResult> function);
    public Task`1<TResult> StartNew(Func`1<TResult> function, CancellationToken cancellationToken);
    public Task`1<TResult> StartNew(Func`1<TResult> function, TaskCreationOptions creationOptions);
    public Task`1<TResult> StartNew(Func`1<TResult> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, CancellationToken cancellationToken);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    private static void FromAsyncCoreLogic(IAsyncResult iar, Func`2<IAsyncResult, TResult> endFunction, Action`1<IAsyncResult> endAction, Task`1<TResult> promise, bool requiresSynchronization);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    internal static Task`1<TResult> FromAsyncImpl(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endFunction, Action`1<IAsyncResult> endAction, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, object state);
    public Task`1<TResult> FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, object state, TaskCreationOptions creationOptions);
    internal static Task`1<TResult> FromAsyncImpl(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endFunction, Action`1<IAsyncResult> endAction, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, object state);
    public Task`1<TResult> FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, object state, TaskCreationOptions creationOptions);
    internal static Task`1<TResult> FromAsyncImpl(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endFunction, Action`1<IAsyncResult> endAction, TArg1 arg1, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state);
    public Task`1<TResult> FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state, TaskCreationOptions creationOptions);
    internal static Task`1<TResult> FromAsyncImpl(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endFunction, Action`1<IAsyncResult> endAction, TArg1 arg1, TArg2 arg2, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);
    public Task`1<TResult> FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, TaskCreationOptions creationOptions);
    internal static Task`1<TResult> FromAsyncImpl(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endFunction, Action`1<IAsyncResult> endAction, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, TaskCreationOptions creationOptions);
    internal static Task`1<TResult> FromAsyncTrim(TInstance thisRef, TArgs args, Func`5<TInstance, TArgs, AsyncCallback, object, IAsyncResult> beginMethod, Func`3<TInstance, IAsyncResult, TResult> endMethod);
    private static Task`1<TResult> CreateCanceledTask(TaskContinuationOptions continuationOptions, CancellationToken ct);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal static Task`1<TResult> ContinueWhenAllImpl(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, Action`1<Task`1[]> continuationAction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler);
    internal static Task`1<TResult> ContinueWhenAllImpl(Task[] tasks, Func`2<Task[], TResult> continuationFunction, Action`1<Task[]> continuationAction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal static Task`1<TResult> ContinueWhenAnyImpl(Task[] tasks, Func`2<Task, TResult> continuationFunction, Action`1<Task> continuationAction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler);
    internal static Task`1<TResult> ContinueWhenAnyImpl(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, Action`1<Task`1<TAntecedentResult>> continuationAction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
[DebuggerDisplayAttribute("Id={Id}")]
[DebuggerTypeProxyAttribute("System.Threading.Tasks.TaskScheduler/SystemThreadingTasks_TaskSchedulerDebugView")]
public abstract class System.Threading.Tasks.TaskScheduler : object {
    private static ConditionalWeakTable`2<TaskScheduler, object> s_activeTaskSchedulers;
    private static TaskScheduler s_defaultTaskScheduler;
    internal static int s_taskSchedulerIdCounter;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_taskSchedulerId;
    [CompilerGeneratedAttribute]
private static EventHandler`1<UnobservedTaskExceptionEventArgs> UnobservedTaskException;
    public int MaximumConcurrencyLevel { get; }
    internal bool RequiresAtomicStartTransition { get; }
    public static TaskScheduler Default { get; }
    public static TaskScheduler Current { get; }
    [NullableAttribute("2")]
internal static TaskScheduler InternalCurrent { get; }
    public int Id { get; }
    private static TaskScheduler();
    protected internal abstract virtual void QueueTask(Task task);
    protected abstract virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
    protected abstract virtual IEnumerable`1<Task> GetScheduledTasks();
    public virtual int get_MaximumConcurrencyLevel();
    internal bool TryRunInline(Task task, bool taskWasPreviouslyQueued);
    protected internal virtual bool TryDequeue(Task task);
    internal virtual void NotifyWorkItemProgress();
    internal virtual bool get_RequiresAtomicStartTransition();
    internal void InternalQueueTask(Task task);
    private void AddToActiveTaskSchedulers();
    public static TaskScheduler get_Default();
    public static TaskScheduler get_Current();
    internal static TaskScheduler get_InternalCurrent();
    public static TaskScheduler FromCurrentSynchronizationContext();
    public int get_Id();
    protected bool TryExecuteTask(Task task);
    [CompilerGeneratedAttribute]
public static void add_UnobservedTaskException(EventHandler`1<UnobservedTaskExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_UnobservedTaskException(EventHandler`1<UnobservedTaskExceptionEventArgs> value);
    internal static void PublishUnobservedTaskException(object sender, UnobservedTaskExceptionEventArgs ueea);
    internal Task[] GetScheduledTasksForDebugger();
    internal static TaskScheduler[] GetTaskSchedulersForDebugger();
}
internal class System.Threading.Tasks.TaskSchedulerAwaitTaskContinuation : AwaitTaskContinuation {
    private TaskScheduler m_scheduler;
    internal TaskSchedulerAwaitTaskContinuation(TaskScheduler scheduler, Action action, bool flowExecutionContext);
    internal sealed virtual void Run(Task ignored, bool canInlineContinuationTask);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Threading.Tasks.TaskSchedulerException : Exception {
    public TaskSchedulerException(string message);
    public TaskSchedulerException(Exception innerException);
    public TaskSchedulerException(string message, Exception innerException);
    [NullableContextAttribute("1")]
protected TaskSchedulerException(SerializationInfo info, StreamingContext context);
}
public enum System.Threading.Tasks.TaskStatus : Enum {
    public int value__;
    public static TaskStatus Created;
    public static TaskStatus WaitingForActivation;
    public static TaskStatus WaitingToRun;
    public static TaskStatus Running;
    public static TaskStatus WaitingForChildrenToComplete;
    public static TaskStatus RanToCompletion;
    public static TaskStatus Canceled;
    public static TaskStatus Faulted;
}
internal static class System.Threading.Tasks.TaskToApm : object {
    public static IAsyncResult Begin(Task task, AsyncCallback callback, object state);
    public static void End(IAsyncResult asyncResult);
    public static TResult End(IAsyncResult asyncResult);
    private static void InvokeCallbackWhenTaskCompletes(Task antecedent, AsyncCallback callback, IAsyncResult asyncResult);
}
internal class System.Threading.Tasks.ThreadPoolTaskScheduler : TaskScheduler {
    private static ParameterizedThreadStart s_longRunningThreadWork;
    internal bool RequiresAtomicStartTransition { get; }
    private static ThreadPoolTaskScheduler();
    protected internal virtual void QueueTask(Task task);
    protected virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
    protected internal virtual bool TryDequeue(Task task);
    protected virtual IEnumerable`1<Task> GetScheduledTasks();
    [IteratorStateMachineAttribute("System.Threading.Tasks.ThreadPoolTaskScheduler/<FilterTasksFromWorkItems>d__6")]
private IEnumerable`1<Task> FilterTasksFromWorkItems(IEnumerable`1<object> tpwItems);
    internal virtual void NotifyWorkItemProgress();
    internal virtual bool get_RequiresAtomicStartTransition();
}
[EventSourceAttribute]
internal class System.Threading.Tasks.TplEventSource : EventSource {
    internal bool TasksSetActivityIds;
    internal bool Debug;
    private bool DebugActivityId;
    public static TplEventSource Log;
    private static TplEventSource();
    protected virtual void OnEventCommand(EventCommandEventArgs command);
    [EventAttribute("7")]
public void TaskScheduled(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID, int CreatingTaskID, int TaskCreationOptions, int appDomain);
    [EventAttribute("8")]
public void TaskStarted(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID);
    [EventAttribute("9")]
public void TaskCompleted(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID, bool IsExceptional);
    [EventAttribute("10")]
public void TaskWaitBegin(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID, TaskWaitBehavior Behavior, int ContinueWithTaskID);
    [EventAttribute("11")]
public void TaskWaitEnd(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID);
    [EventAttribute("13")]
public void TaskWaitContinuationComplete(int TaskID);
    [EventAttribute("19")]
public void TaskWaitContinuationStarted(int TaskID);
    [EventAttribute("12")]
public void AwaitTaskContinuationScheduled(int OriginatingTaskSchedulerID, int OriginatingTaskID, int ContinuwWithTaskId);
    [EventAttribute("14")]
public void TraceOperationBegin(int TaskID, string OperationName, long RelatedContext);
    [EventAttribute("16")]
public void TraceOperationRelation(int TaskID, CausalityRelation Relation);
    [EventAttribute("15")]
public void TraceOperationEnd(int TaskID, AsyncCausalityStatus Status);
    [EventAttribute("17")]
public void TraceSynchronousWorkBegin(int TaskID, CausalitySynchronousWork Work);
    [EventAttribute("18")]
public void TraceSynchronousWorkEnd(CausalitySynchronousWork Work);
    [NonEventAttribute]
public void RunningContinuationList(int TaskID, int Index, object Object);
    [EventAttribute("21")]
public void RunningContinuationList(int TaskID, int Index, long Object);
    [EventAttribute("23")]
public void DebugFacilityMessage(string Facility, string Message);
    [EventAttribute("24")]
public void DebugFacilityMessage1(string Facility, string Message, string Value1);
    [EventAttribute("25")]
public void SetActivityId(Guid NewId);
    [EventAttribute("26")]
public void NewID(int TaskID);
    [NonEventAttribute]
public void IncompleteAsyncMethod(IAsyncStateMachineBox stateMachineBox);
    [EventAttribute("27")]
private void IncompleteAsyncMethod(string stateMachineDescription);
    internal static Guid CreateGuidForTaskID(int taskID);
}
[NullableAttribute("0")]
[NullableContextAttribute("2")]
public class System.Threading.Tasks.UnobservedTaskExceptionEventArgs : EventArgs {
    private AggregateException m_exception;
    internal bool m_observed;
    public bool Observed { get; }
    public AggregateException Exception { get; }
    public UnobservedTaskExceptionEventArgs(AggregateException exception);
    public void SetObserved();
    public bool get_Observed();
    public AggregateException get_Exception();
}
internal class System.Threading.Tasks.UnwrapPromise`1 : Task`1<TResult> {
    private byte _state;
    private bool _lookForOce;
    public bool InvokeMayRunArbitraryCode { get; }
    public UnwrapPromise`1(Task outerTask, bool lookForOce);
    public sealed virtual void Invoke(Task completingTask);
    private void InvokeCore(Task completingTask);
    private void InvokeCoreAsync(Task completingTask);
    private void ProcessCompletedOuterTask(Task task);
    private bool TrySetFromTask(Task task, bool lookForOce);
    private void ProcessInnerTask(Task task);
    public sealed virtual bool get_InvokeMayRunArbitraryCode();
}
[IsReadOnlyAttribute]
[NullableAttribute("0")]
[NullableContextAttribute("1")]
[AsyncMethodBuilderAttribute("System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder")]
public class System.Threading.Tasks.ValueTask : ValueType {
    private static Task s_canceledTask;
    internal object _obj;
    internal short _token;
    internal bool _continueOnCapturedContext;
    internal static Task CompletedTask { get; }
    public bool IsCompleted { get; }
    public bool IsCompletedSuccessfully { get; }
    public bool IsFaulted { get; }
    public bool IsCanceled { get; }
    public ValueTask(Task task);
    public ValueTask(IValueTaskSource source, short token);
    private ValueTask(object obj, short token, bool continueOnCapturedContext);
    private static ValueTask();
    internal static Task get_CompletedTask();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTask other);
    public static bool op_Equality(ValueTask left, ValueTask right);
    public static bool op_Inequality(ValueTask left, ValueTask right);
    public Task AsTask();
    public ValueTask Preserve();
    private Task GetTaskForValueTaskSource(IValueTaskSource t);
    public bool get_IsCompleted();
    public bool get_IsCompletedSuccessfully();
    public bool get_IsFaulted();
    public bool get_IsCanceled();
    internal void ThrowIfCompletedUnsuccessfully();
    public ValueTaskAwaiter GetAwaiter();
    public ConfiguredValueTaskAwaitable ConfigureAwait(bool continueOnCapturedContext);
}
[NullableContextAttribute("1")]
[IsReadOnlyAttribute]
[AsyncMethodBuilderAttribute("System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder`1")]
[NullableAttribute("0")]
public class System.Threading.Tasks.ValueTask`1 : ValueType {
    private static Task`1<TResult> s_canceledTask;
    internal object _obj;
    [AllowNullAttribute]
internal TResult _result;
    internal short _token;
    internal bool _continueOnCapturedContext;
    public bool IsCompleted { get; }
    public bool IsCompletedSuccessfully { get; }
    public bool IsFaulted { get; }
    public bool IsCanceled { get; }
    [DebuggerBrowsableAttribute("0")]
public TResult Result { get; }
    public ValueTask`1(TResult result);
    public ValueTask`1(Task`1<TResult> task);
    public ValueTask`1(IValueTaskSource`1<TResult> source, short token);
    private ValueTask`1(object obj, TResult result, short token, bool continueOnCapturedContext);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTask`1<TResult> other);
    public static bool op_Equality(ValueTask`1<TResult> left, ValueTask`1<TResult> right);
    public static bool op_Inequality(ValueTask`1<TResult> left, ValueTask`1<TResult> right);
    public Task`1<TResult> AsTask();
    public ValueTask`1<TResult> Preserve();
    private Task`1<TResult> GetTaskForValueTaskSource(IValueTaskSource`1<TResult> t);
    public bool get_IsCompleted();
    public bool get_IsCompletedSuccessfully();
    public bool get_IsFaulted();
    public bool get_IsCanceled();
    public TResult get_Result();
    public ValueTaskAwaiter`1<TResult> GetAwaiter();
    public ConfiguredValueTaskAwaitable`1<TResult> ConfigureAwait(bool continueOnCapturedContext);
    [NullableContextAttribute("2")]
public virtual string ToString();
}
internal class System.Threading.Tasks.VoidTaskResult : ValueType {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Threading.Thread : CriticalFinalizerObject {
    internal ExecutionContext _executionContext;
    internal SynchronizationContext _synchronizationContext;
    private string _name;
    private Delegate _delegate;
    private object _threadStartArg;
    private IntPtr _DONT_USE_InternalThread;
    private int _priority;
    private int _managedThreadId;
    private static int s_optimalMaxSpinWaitsPerSpinIteration;
    [ThreadStaticAttribute]
private static int t_currentProcessorIdCache;
    private static int ProcessorIdCacheShift;
    private static int ProcessorIdCacheCountDownMask;
    private static int ProcessorIdRefreshRate;
    private static AsyncLocal`1<IPrincipal> s_asyncLocalPrincipal;
    [ThreadStaticAttribute]
private static Thread t_currentThread;
    public int ManagedThreadId { get; }
    public bool IsAlive { get; }
    public bool IsBackground { get; public set; }
    public bool IsThreadPoolThread { get; }
    public ThreadPriority Priority { get; public set; }
    internal static ulong CurrentOSThreadId { get; }
    public ThreadState ThreadState { get; }
    internal static int OptimalMaxSpinWaitsPerSpinIteration { get; }
    public CultureInfo CurrentCulture { get; public set; }
    public CultureInfo CurrentUICulture { get; public set; }
    [NullableAttribute("2")]
public static IPrincipal CurrentPrincipal { get; public set; }
    public static Thread CurrentThread { get; }
    [NullableAttribute("2")]
public ExecutionContext ExecutionContext { get; }
    [NullableAttribute("2")]
public string Name { get; public set; }
    [ObsoleteAttribute("The ApartmentState property has been deprecated.  Use GetApartmentState, SetApartmentState or TrySetApartmentState instead.", "False")]
public ApartmentState ApartmentState { get; public set; }
    public Thread(ThreadStart start);
    public Thread(ThreadStart start, int maxStackSize);
    public Thread(ParameterizedThreadStart start);
    public Thread(ParameterizedThreadStart start, int maxStackSize);
    private void Create(ThreadStart start);
    private void Create(ThreadStart start, int maxStackSize);
    private void Create(ParameterizedThreadStart start);
    private void Create(ParameterizedThreadStart start, int maxStackSize);
    public int get_ManagedThreadId();
    internal ThreadHandle GetNativeHandle();
    [NullableContextAttribute("2")]
public void Start(object parameter);
    public void Start();
    private void SetCultureOnUnstartedThreadNoCheck(CultureInfo value, bool uiCulture);
    private void StartInternal();
    private static IntPtr InternalGetCurrentThread();
    private static void SleepInternal(int millisecondsTimeout);
    public static void Sleep(int millisecondsTimeout);
    private static void SpinWaitInternal(int iterations);
    public static void SpinWait(int iterations);
    private static BOOL YieldInternal();
    public static bool Yield();
    private static Thread InitializeCurrentThread();
    [ReliabilityContractAttribute("3", "1")]
private static Thread GetCurrentThreadNative();
    private void SetStartHelper(Delegate start, int maxStackSize);
    private void SetStart(Delegate start, int maxStackSize);
    protected virtual override void Finalize();
    private void InternalFinalize();
    private void StartupSetApartmentStateInternal();
    private static void InformThreadNameChange(ThreadHandle t, string name, int len);
    internal static DeserializationTracker GetThreadDeserializationTracker(StackCrawlMark& stackMark);
    public bool get_IsAlive();
    public bool get_IsBackground();
    public void set_IsBackground(bool value);
    private bool IsBackgroundNative();
    private void SetBackgroundNative(bool isBackground);
    public bool get_IsThreadPoolThread();
    public ThreadPriority get_Priority();
    public void set_Priority(ThreadPriority value);
    private int GetPriorityNative();
    private void SetPriorityNative(int priority);
    internal static ulong get_CurrentOSThreadId();
    private static ulong GetCurrentOSThreadId();
    public ThreadState get_ThreadState();
    private int GetThreadStateNative();
    public ApartmentState GetApartmentState();
    private bool TrySetApartmentStateUnchecked(ApartmentState state);
    internal bool SetApartmentStateHelper(ApartmentState state, bool fireMDAOnMismatch);
    internal int GetApartmentStateNative();
    internal int SetApartmentStateNative(int state, bool fireMDAOnMismatch);
    public void DisableComObjectEagerCleanup();
    public void Interrupt();
    public bool Join(int millisecondsTimeout);
    private static int GetOptimalMaxSpinWaitsPerSpinIterationInternal();
    internal static int get_OptimalMaxSpinWaitsPerSpinIteration();
    private static int CalculateOptimalMaxSpinWaitsPerSpinIteration();
    private static int GetCurrentProcessorNumber();
    private static int RefreshCurrentProcessorId();
    public static int GetCurrentProcessorId();
    internal void ResetThreadPoolThread();
    private void RequireCurrentThread();
    private void SetCultureOnUnstartedThread(CultureInfo value, bool uiCulture);
    private void ThreadNameChanged(string value);
    public CultureInfo get_CurrentCulture();
    public void set_CurrentCulture(CultureInfo value);
    public CultureInfo get_CurrentUICulture();
    public void set_CurrentUICulture(CultureInfo value);
    [NullableContextAttribute("2")]
public static IPrincipal get_CurrentPrincipal();
    [NullableContextAttribute("2")]
public static void set_CurrentPrincipal(IPrincipal value);
    public static Thread get_CurrentThread();
    [NullableContextAttribute("2")]
public ExecutionContext get_ExecutionContext();
    [NullableContextAttribute("2")]
public string get_Name();
    [NullableContextAttribute("2")]
public void set_Name(string value);
    public void Abort();
    [NullableContextAttribute("2")]
public void Abort(object stateInfo);
    public static void ResetAbort();
    [ObsoleteAttribute("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  https://go.microsoft.com/fwlink/?linkid=14202", "False")]
public void Suspend();
    [ObsoleteAttribute("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  https://go.microsoft.com/fwlink/?linkid=14202", "False")]
public void Resume();
    public static void BeginCriticalRegion();
    public static void EndCriticalRegion();
    public static void BeginThreadAffinity();
    public static void EndThreadAffinity();
    public static LocalDataStoreSlot AllocateDataSlot();
    public static LocalDataStoreSlot AllocateNamedDataSlot(string name);
    public static LocalDataStoreSlot GetNamedDataSlot(string name);
    public static void FreeNamedDataSlot(string name);
    public static object GetData(LocalDataStoreSlot slot);
    public static void SetData(LocalDataStoreSlot slot, object data);
    public ApartmentState get_ApartmentState();
    public void set_ApartmentState(ApartmentState value);
    public void SetApartmentState(ApartmentState state);
    public bool TrySetApartmentState(ApartmentState state);
    [ObsoleteAttribute("Thread.GetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")]
public CompressedStack GetCompressedStack();
    [ObsoleteAttribute("Thread.SetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")]
public void SetCompressedStack(CompressedStack stack);
    public static AppDomain GetDomain();
    public static int GetDomainID();
    public virtual int GetHashCode();
    public void Join();
    public bool Join(TimeSpan timeout);
    public static void MemoryBarrier();
    public static void Sleep(TimeSpan timeout);
    public static byte VolatileRead(Byte& address);
    public static double VolatileRead(Double& address);
    public static short VolatileRead(Int16& address);
    public static int VolatileRead(Int32& address);
    public static long VolatileRead(Int64& address);
    public static IntPtr VolatileRead(IntPtr& address);
    [NullableContextAttribute("2")]
public static object VolatileRead(Object& address);
    [CLSCompliantAttribute("False")]
public static sbyte VolatileRead(SByte& address);
    public static float VolatileRead(Single& address);
    [CLSCompliantAttribute("False")]
public static ushort VolatileRead(UInt16& address);
    [CLSCompliantAttribute("False")]
public static UInt32 VolatileRead(UInt32& address);
    [CLSCompliantAttribute("False")]
public static ulong VolatileRead(UInt64& address);
    [CLSCompliantAttribute("False")]
public static UIntPtr VolatileRead(UIntPtr& address);
    public static void VolatileWrite(Byte& address, byte value);
    public static void VolatileWrite(Double& address, double value);
    public static void VolatileWrite(Int16& address, short value);
    public static void VolatileWrite(Int32& address, int value);
    public static void VolatileWrite(Int64& address, long value);
    public static void VolatileWrite(IntPtr& address, IntPtr value);
    [NullableContextAttribute("2")]
public static void VolatileWrite(Object& address, object value);
    [CLSCompliantAttribute("False")]
public static void VolatileWrite(SByte& address, sbyte value);
    public static void VolatileWrite(Single& address, float value);
    [CLSCompliantAttribute("False")]
public static void VolatileWrite(UInt16& address, ushort value);
    [CLSCompliantAttribute("False")]
public static void VolatileWrite(UInt32& address, UInt32 value);
    [CLSCompliantAttribute("False")]
public static void VolatileWrite(UInt64& address, ulong value);
    [CLSCompliantAttribute("False")]
public static void VolatileWrite(UIntPtr& address, UIntPtr value);
    private static Exception GetApartmentStateChangeFailedException();
}
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableContextAttribute("2")]
public class System.Threading.ThreadAbortException : SystemException {
    public object ExceptionState { get; }
    internal ThreadAbortException(SerializationInfo info, StreamingContext context);
    public object get_ExceptionState();
}
[IsReadOnlyAttribute]
internal class System.Threading.ThreadHandle : ValueType {
    private IntPtr _ptr;
    internal ThreadHandle(IntPtr pThread);
}
internal class System.Threading.ThreadHelper : object {
    private Delegate _start;
    internal CultureInfo _startCulture;
    internal CultureInfo _startUICulture;
    private object _startArg;
    private ExecutionContext _executionContext;
    internal static ContextCallback s_threadStartContextCallback;
    internal ThreadHelper(Delegate start);
    private static ThreadHelper();
    internal void SetExecutionContextHelper(ExecutionContext ec);
    private static void ThreadStart_Context(object state);
    private void InitializeCulture();
    internal void ThreadStart(object obj);
    internal void ThreadStart();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Threading.ThreadInterruptedException : SystemException {
    public ThreadInterruptedException(string message);
    public ThreadInterruptedException(string message, Exception innerException);
    [NullableContextAttribute("1")]
protected ThreadInterruptedException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[DebuggerTypeProxyAttribute("System.Threading.SystemThreading_ThreadLocalDebugView`1")]
[DebuggerDisplayAttribute("IsValueCreated={IsValueCreated}, Value={ValueForDebugDisplay}, Count={ValuesCountForDebugDisplay}")]
[NullableAttribute("0")]
public class System.Threading.ThreadLocal`1 : object {
    private Func`1<T> _valueFactory;
    [ThreadStaticAttribute]
private static LinkedSlotVolatile[] ts_slotArray;
    [ThreadStaticAttribute]
private static FinalizationHelper<T> ts_finalizationHelper;
    private int _idComplement;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _initialized;
    private static IdManager<T> s_idManager;
    private LinkedSlot<T> _linkedSlot;
    private bool _trackAllValues;
    [DebuggerBrowsableAttribute("0")]
public T Value { get; public set; }
    public IList`1<T> Values { get; }
    private int ValuesCountForDebugDisplay { get; }
    public bool IsValueCreated { get; }
    internal T ValueForDebugDisplay { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal List`1<T> ValuesForDebugDisplay { get; }
    public ThreadLocal`1(bool trackAllValues);
    public ThreadLocal`1(Func`1<T> valueFactory);
    public ThreadLocal`1(Func`1<T> valueFactory, bool trackAllValues);
    private static ThreadLocal`1();
    private void Initialize(Func`1<T> valueFactory, bool trackAllValues);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    [NullableContextAttribute("2")]
public virtual string ToString();
    public T get_Value();
    public void set_Value(T value);
    private T GetValueSlow();
    private void SetValueSlow(T value, LinkedSlotVolatile[] slotArray);
    private void CreateLinkedSlot(LinkedSlotVolatile[] slotArray, int id, T value);
    public IList`1<T> get_Values();
    private List`1<T> GetValuesAsList();
    private int get_ValuesCountForDebugDisplay();
    public bool get_IsValueCreated();
    internal T get_ValueForDebugDisplay();
    internal List`1<T> get_ValuesForDebugDisplay();
    private void GrowTable(LinkedSlotVolatile[]& table, int minLength);
    private static int GetNewTableSize(int minSize);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Threading.ThreadPool : object {
    public static int ThreadCount { get; }
    public static long CompletedWorkItemCount { get; }
    private static long PendingUnmanagedWorkItemCount { get; }
    public static long PendingWorkItemCount { get; }
    internal static bool KeepDispatching(int startTickCount);
    public static bool SetMaxThreads(int workerThreads, int completionPortThreads);
    public static void GetMaxThreads(Int32& workerThreads, Int32& completionPortThreads);
    public static bool SetMinThreads(int workerThreads, int completionPortThreads);
    public static void GetMinThreads(Int32& workerThreads, Int32& completionPortThreads);
    public static void GetAvailableThreads(Int32& workerThreads, Int32& completionPortThreads);
    public static int get_ThreadCount();
    public static long get_CompletedWorkItemCount();
    private static long GetCompletedWorkItemCount();
    private static long get_PendingUnmanagedWorkItemCount();
    private static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce, bool compressStack);
    internal static BOOL RequestWorkerThread();
    private static bool PostQueuedCompletionStatus(NativeOverlapped* overlapped);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public static bool UnsafeQueueNativeOverlapped(NativeOverlapped* overlapped);
    private static void EnsureInitialized();
    private static void EnsureVMInitializedCore();
    private static bool SetMinThreadsNative(int workerThreads, int completionPortThreads);
    private static bool SetMaxThreadsNative(int workerThreads, int completionPortThreads);
    private static void GetMinThreadsNative(Int32& workerThreads, Int32& completionPortThreads);
    private static void GetMaxThreadsNative(Int32& workerThreads, Int32& completionPortThreads);
    private static void GetAvailableThreadsNative(Int32& workerThreads, Int32& completionPortThreads);
    internal static bool NotifyWorkItemComplete();
    internal static void ReportThreadStatus(bool isWorking);
    internal static void NotifyWorkItemProgress();
    internal static void NotifyWorkItemProgressNative();
    private static void InitializeVMTp(Boolean& enableWorkerTracking);
    private static IntPtr RegisterWaitForSingleObjectNative(WaitHandle waitHandle, object state, UInt32 timeOutInterval, bool executeOnlyOnce, RegisteredWaitHandle registeredWaitHandle);
    [ObsoleteAttribute("ThreadPool.BindHandle(IntPtr) has been deprecated.  Please use ThreadPool.BindHandle(SafeHandle) instead.", "False")]
public static bool BindHandle(IntPtr osHandle);
    public static bool BindHandle(SafeHandle osHandle);
    private static bool BindIOCompletionCallbackNative(IntPtr fileHandle);
    [CLSCompliantAttribute("False")]
public static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);
    [CLSCompliantAttribute("False")]
public static RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);
    public static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);
    public static RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);
    public static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);
    public static RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);
    public static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);
    public static RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);
    public static bool QueueUserWorkItem(WaitCallback callBack);
    public static bool QueueUserWorkItem(WaitCallback callBack, object state);
    public static bool QueueUserWorkItem(Action`1<TState> callBack, TState state, bool preferLocal);
    public static bool UnsafeQueueUserWorkItem(Action`1<TState> callBack, TState state, bool preferLocal);
    public static bool UnsafeQueueUserWorkItem(WaitCallback callBack, object state);
    public static bool UnsafeQueueUserWorkItem(IThreadPoolWorkItem callBack, bool preferLocal);
    internal static void UnsafeQueueUserWorkItemInternal(object callBack, bool preferLocal);
    internal static bool TryPopCustomWorkItem(object workItem);
    [IteratorStateMachineAttribute("System.Threading.ThreadPool/<GetQueuedWorkItems>d__50")]
internal static IEnumerable`1<object> GetQueuedWorkItems();
    [IteratorStateMachineAttribute("System.Threading.ThreadPool/<GetLocallyQueuedWorkItems>d__51")]
internal static IEnumerable`1<object> GetLocallyQueuedWorkItems();
    internal static IEnumerable`1<object> GetGloballyQueuedWorkItems();
    private static Object[] ToObjectArray(IEnumerable`1<object> workitems);
    internal static Object[] GetQueuedWorkItemsForDebugger();
    internal static Object[] GetGloballyQueuedWorkItemsForDebugger();
    internal static Object[] GetLocallyQueuedWorkItemsForDebugger();
    public static long get_PendingWorkItemCount();
}
public class System.Threading.ThreadPoolBoundHandle : object {
    private SafeHandle _handle;
    private bool _isDisposed;
    [NullableAttribute("1")]
public SafeHandle Handle { get; }
    private ThreadPoolBoundHandle(SafeHandle handle);
    [NullableContextAttribute("1")]
public SafeHandle get_Handle();
    [NullableContextAttribute("1")]
public static ThreadPoolBoundHandle BindHandle(SafeHandle handle);
    [CLSCompliantAttribute("False")]
[NullableContextAttribute("2")]
public NativeOverlapped* AllocateNativeOverlapped(IOCompletionCallback callback, object state, object pinData);
    [CLSCompliantAttribute("False")]
public NativeOverlapped* AllocateNativeOverlapped(PreAllocatedOverlapped preAllocated);
    [CLSCompliantAttribute("False")]
public void FreeNativeOverlapped(NativeOverlapped* overlapped);
    [CLSCompliantAttribute("False")]
public static object GetNativeOverlappedState(NativeOverlapped* overlapped);
    private static ThreadPoolBoundHandleOverlapped GetOverlappedWrapper(NativeOverlapped* overlapped, ThreadPoolBoundHandle expectedBoundHandle);
    public sealed virtual void Dispose();
    private void EnsureNotDisposed();
    private static ThreadPoolBoundHandle BindHandleCore(SafeHandle handle);
}
internal class System.Threading.ThreadPoolBoundHandleOverlapped : Overlapped {
    private static IOCompletionCallback s_completionCallback;
    private IOCompletionCallback _userCallback;
    internal object _userState;
    internal PreAllocatedOverlapped _preAllocated;
    internal NativeOverlapped* _nativeOverlapped;
    internal ThreadPoolBoundHandle _boundHandle;
    internal bool _completed;
    public ThreadPoolBoundHandleOverlapped(IOCompletionCallback callback, object state, object pinData, PreAllocatedOverlapped preAllocated);
    private static ThreadPoolBoundHandleOverlapped();
    private static void CompletionCallback(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* nativeOverlapped);
}
internal static class System.Threading.ThreadPoolGlobals : object {
    public static int processorCount;
    public static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) threadPoolInitialized;
    public static bool enableWorkerTracking;
    public static ThreadPoolWorkQueue workQueue;
    internal static Action`1<object> s_invokeAsyncStateMachineBox;
    private static ThreadPoolGlobals();
}
internal class System.Threading.ThreadPoolWorkQueue : object {
    internal bool loggingEnabled;
    internal ConcurrentQueue`1<object> workItems;
    private PaddingFor32 pad1;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) numOutstandingThreadRequests;
    private PaddingFor32 pad2;
    public long LocalCount { get; }
    public long GlobalCount { get; }
    public ThreadPoolWorkQueueThreadLocals GetOrCreateThreadLocals();
    private ThreadPoolWorkQueueThreadLocals CreateThreadLocals();
    internal void EnsureThreadRequested();
    internal void MarkThreadRequestSatisfied();
    public void Enqueue(object callback, bool forceGlobal);
    internal bool LocalFindAndPop(object callback);
    public object Dequeue(ThreadPoolWorkQueueThreadLocals tl, Boolean& missedSteal);
    public long get_LocalCount();
    public long get_GlobalCount();
    internal static bool Dispatch();
}
internal class System.Threading.ThreadPoolWorkQueueThreadLocals : object {
    [ThreadStaticAttribute]
public static ThreadPoolWorkQueueThreadLocals threadLocals;
    public ThreadPoolWorkQueue workQueue;
    public WorkStealingQueue workStealingQueue;
    public Thread currentThread;
    public FastRandom random;
    public ThreadPoolWorkQueueThreadLocals(ThreadPoolWorkQueue tpq);
    protected virtual override void Finalize();
}
public enum System.Threading.ThreadPriority : Enum {
    public int value__;
    public static ThreadPriority Lowest;
    public static ThreadPriority BelowNormal;
    public static ThreadPriority Normal;
    public static ThreadPriority AboveNormal;
    public static ThreadPriority Highest;
}
public class System.Threading.ThreadStart : MulticastDelegate {
    public ThreadStart(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Threading.ThreadStartException : SystemException {
    internal ThreadStartException(Exception reason);
    private ThreadStartException(SerializationInfo info, StreamingContext context);
}
[FlagsAttribute]
public enum System.Threading.ThreadState : Enum {
    public int value__;
    public static ThreadState Running;
    public static ThreadState StopRequested;
    public static ThreadState SuspendRequested;
    public static ThreadState Background;
    public static ThreadState Unstarted;
    public static ThreadState Stopped;
    public static ThreadState WaitSleepJoin;
    public static ThreadState Suspended;
    public static ThreadState AbortRequested;
    public static ThreadState Aborted;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Threading.ThreadStateException : SystemException {
    public ThreadStateException(string message);
    public ThreadStateException(string message, Exception innerException);
    [NullableContextAttribute("1")]
protected ThreadStateException(SerializationInfo info, StreamingContext context);
}
public static class System.Threading.Timeout : object {
    public static TimeSpan InfiniteTimeSpan;
    public static int Infinite;
    private static Timeout();
}
internal static class System.Threading.TimeoutHelper : object {
    public static UInt32 GetTime();
    public static int UpdateTimeOut(UInt32 startTime, int originalWaitMillisecondsTimeout);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Threading.Timer : MarshalByRefObject {
    private TimerHolder _timer;
    public static long ActiveCount { get; }
    public Timer(TimerCallback callback, object state, int dueTime, int period);
    internal Timer(TimerCallback callback, object state, int dueTime, int period, bool flowExecutionContext);
    public Timer(TimerCallback callback, object state, TimeSpan dueTime, TimeSpan period);
    [CLSCompliantAttribute("False")]
public Timer(TimerCallback callback, object state, UInt32 dueTime, UInt32 period);
    public Timer(TimerCallback callback, object state, long dueTime, long period);
    public Timer(TimerCallback callback);
    private void TimerSetup(TimerCallback callback, object state, UInt32 dueTime, UInt32 period, bool flowExecutionContext);
    public bool Change(int dueTime, int period);
    public bool Change(TimeSpan dueTime, TimeSpan period);
    [CLSCompliantAttribute("False")]
public bool Change(UInt32 dueTime, UInt32 period);
    public bool Change(long dueTime, long period);
    public static long get_ActiveCount();
    public bool Dispose(WaitHandle notifyObject);
    public sealed virtual void Dispose();
    public sealed virtual ValueTask DisposeAsync();
}
public class System.Threading.TimerCallback : MulticastDelegate {
    public TimerCallback(object object, IntPtr method);
    [NullableContextAttribute("2")]
public virtual void Invoke(object state);
    public virtual IAsyncResult BeginInvoke(object state, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Threading.TimerHolder : object {
    internal TimerQueueTimer _timer;
    public TimerHolder(TimerQueueTimer timer);
    protected virtual override void Finalize();
    public void Close();
    public bool Close(WaitHandle notifyObject);
    public ValueTask CloseAsync();
}
internal class System.Threading.TimerQueue : object {
    private int _id;
    private AppDomainTimerSafeHandle m_appDomainTimer;
    [CompilerGeneratedAttribute]
private static TimerQueue[] <Instances>k__BackingField;
    private bool _isTimerScheduled;
    private long _currentTimerStartTicks;
    private UInt32 _currentTimerDuration;
    private TimerQueueTimer _shortTimers;
    private TimerQueueTimer _longTimers;
    private long _currentAbsoluteThreshold;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _pauseTicks;
    [CompilerGeneratedAttribute]
private long <ActiveCount>k__BackingField;
    public static TimerQueue[] Instances { get; }
    public long ActiveCount { get; private set; }
    private static long TickCount64 { get; }
    private TimerQueue(int id);
    private static TimerQueue();
    private bool SetTimer(UInt32 actualDuration);
    internal static void AppDomainTimerCallback(int id);
    private static AppDomainTimerSafeHandle CreateAppDomainTimer(UInt32 dueTime, int id);
    private static bool ChangeAppDomainTimer(AppDomainTimerSafeHandle handle, UInt32 dueTime);
    private static bool DeleteAppDomainTimer(IntPtr handle);
    [CompilerGeneratedAttribute]
public static TimerQueue[] get_Instances();
    private static TimerQueue[] CreateTimerQueues();
    private bool EnsureTimerFiresBy(UInt32 requestedDuration);
    private void FireNextTimers();
    [CompilerGeneratedAttribute]
public long get_ActiveCount();
    [CompilerGeneratedAttribute]
private void set_ActiveCount(long value);
    public bool UpdateTimer(TimerQueueTimer timer, UInt32 dueTime, UInt32 period);
    public void MoveTimerToCorrectList(TimerQueueTimer timer, bool shortList);
    private void LinkTimer(TimerQueueTimer timer);
    private void UnlinkTimer(TimerQueueTimer timer);
    public void DeleteTimer(TimerQueueTimer timer);
    private static long get_TickCount64();
}
internal class System.Threading.TimerQueueTimer : object {
    private TimerQueue _associatedTimerQueue;
    internal TimerQueueTimer _next;
    internal TimerQueueTimer _prev;
    internal bool _short;
    internal long _startTicks;
    internal UInt32 _dueTime;
    internal UInt32 _period;
    private TimerCallback _timerCallback;
    private object _state;
    private ExecutionContext _executionContext;
    private int _callbacksRunning;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _canceled;
    private Object modreq(System.Runtime.CompilerServices.IsVolatile) _notifyWhenNoCallbacksRunning;
    private static ContextCallback s_callCallbackInContext;
    internal TimerQueueTimer(TimerCallback timerCallback, object state, UInt32 dueTime, UInt32 period, bool flowExecutionContext);
    private static TimerQueueTimer();
    internal bool Change(UInt32 dueTime, UInt32 period);
    public void Close();
    public bool Close(WaitHandle toSignal);
    public ValueTask CloseAsync();
    private sealed virtual override void System.Threading.IThreadPoolWorkItem.Execute();
    internal void Fire(bool isThreadPool);
    internal void SignalNoCallbacksRunning();
    internal void CallCallback(bool isThreadPool);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public static class System.Threading.Volatile : object {
    [NonVersionableAttribute]
[IntrinsicAttribute]
public static bool Read(Boolean& location);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static void Write(Boolean& location, bool value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static byte Read(Byte& location);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static void Write(Byte& location, byte value);
    [NonVersionableAttribute]
[IntrinsicAttribute]
public static double Read(Double& location);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static void Write(Double& location, double value);
    [NonVersionableAttribute]
[IntrinsicAttribute]
public static short Read(Int16& location);
    [NonVersionableAttribute]
[IntrinsicAttribute]
public static void Write(Int16& location, short value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static int Read(Int32& location);
    [NonVersionableAttribute]
[IntrinsicAttribute]
public static void Write(Int32& location, int value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static long Read(Int64& location);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static void Write(Int64& location, long value);
    [NonVersionableAttribute]
[IntrinsicAttribute]
public static IntPtr Read(IntPtr& location);
    [NonVersionableAttribute]
[IntrinsicAttribute]
public static void Write(IntPtr& location, IntPtr value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static sbyte Read(SByte& location);
    [NonVersionableAttribute]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static void Write(SByte& location, sbyte value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static float Read(Single& location);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static void Write(Single& location, float value);
    [NonVersionableAttribute]
[CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static ushort Read(UInt16& location);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
[NonVersionableAttribute]
public static void Write(UInt16& location, ushort value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static UInt32 Read(UInt32& location);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static void Write(UInt32& location, UInt32 value);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
[IntrinsicAttribute]
public static ulong Read(UInt64& location);
    [IntrinsicAttribute]
[NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static void Write(UInt64& location, ulong value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
[NonVersionableAttribute]
public static UIntPtr Read(UIntPtr& location);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
[NonVersionableAttribute]
public static void Write(UIntPtr& location, UIntPtr value);
    [NonVersionableAttribute]
[IntrinsicAttribute]
public static T Read(T& location);
    [NonVersionableAttribute]
[IntrinsicAttribute]
public static void Write(T& location, T value);
}
public class System.Threading.WaitCallback : MulticastDelegate {
    public WaitCallback(object object, IntPtr method);
    [NullableContextAttribute("2")]
public virtual void Invoke(object state);
    public virtual IAsyncResult BeginInvoke(object state, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public abstract class System.Threading.WaitHandle : MarshalByRefObject {
    internal static int MaxWaitHandles;
    protected static IntPtr InvalidHandle;
    private SafeWaitHandle _waitHandle;
    [ThreadStaticAttribute]
private static SafeWaitHandle[] t_safeWaitHandlesForRent;
    internal static int WaitSuccess;
    internal static int WaitAbandoned;
    public static int WaitTimeout;
    [ObsoleteAttribute("Use the SafeWaitHandle property instead.")]
public IntPtr Handle { get; public set; }
    public SafeWaitHandle SafeWaitHandle { get; public set; }
    private static WaitHandle();
    private static int WaitOneCore(IntPtr waitHandle, int millisecondsTimeout);
    internal static int WaitMultipleIgnoringSyncContext(Span`1<IntPtr> waitHandles, bool waitAll, int millisecondsTimeout);
    private static int WaitMultipleIgnoringSyncContext(IntPtr* waitHandles, int numHandles, bool waitAll, int millisecondsTimeout);
    private static int SignalAndWaitCore(IntPtr waitHandleToSignal, IntPtr waitHandleToWaitOn, int millisecondsTimeout);
    private static int SignalAndWaitNative(IntPtr waitHandleToSignal, IntPtr waitHandleToWaitOn, int millisecondsTimeout);
    public virtual IntPtr get_Handle();
    public virtual void set_Handle(IntPtr value);
    public SafeWaitHandle get_SafeWaitHandle();
    public void set_SafeWaitHandle(SafeWaitHandle value);
    internal static int ToTimeoutMilliseconds(TimeSpan timeout);
    public virtual void Close();
    protected virtual void Dispose(bool explicitDisposing);
    public sealed virtual void Dispose();
    public virtual bool WaitOne(int millisecondsTimeout);
    private bool WaitOneNoCheck(int millisecondsTimeout);
    private static SafeWaitHandle[] RentSafeWaitHandleArray(int capacity);
    private static void ReturnSafeWaitHandleArray(SafeWaitHandle[] safeWaitHandles);
    private static void ObtainSafeWaitHandles(ReadOnlySpan`1<WaitHandle> waitHandles, Span`1<SafeWaitHandle> safeWaitHandles, Span`1<IntPtr> unsafeWaitHandles);
    private static int WaitMultiple(WaitHandle[] waitHandles, bool waitAll, int millisecondsTimeout);
    private static int WaitMultiple(ReadOnlySpan`1<WaitHandle> waitHandles, bool waitAll, int millisecondsTimeout);
    private static bool SignalAndWait(WaitHandle toSignal, WaitHandle toWaitOn, int millisecondsTimeout);
    public virtual bool WaitOne(TimeSpan timeout);
    public virtual bool WaitOne();
    public virtual bool WaitOne(int millisecondsTimeout, bool exitContext);
    public virtual bool WaitOne(TimeSpan timeout, bool exitContext);
    public static bool WaitAll(WaitHandle[] waitHandles, int millisecondsTimeout);
    public static bool WaitAll(WaitHandle[] waitHandles, TimeSpan timeout);
    public static bool WaitAll(WaitHandle[] waitHandles);
    public static bool WaitAll(WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);
    public static bool WaitAll(WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);
    public static int WaitAny(WaitHandle[] waitHandles, int millisecondsTimeout);
    public static int WaitAny(WaitHandle[] waitHandles, TimeSpan timeout);
    public static int WaitAny(WaitHandle[] waitHandles);
    public static int WaitAny(WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);
    public static int WaitAny(WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);
    public static bool SignalAndWait(WaitHandle toSignal, WaitHandle toWaitOn);
    public static bool SignalAndWait(WaitHandle toSignal, WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);
    public static bool SignalAndWait(WaitHandle toSignal, WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);
}
[NullableAttribute("0")]
[NullableContextAttribute("2")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Threading.WaitHandleCannotBeOpenedException : ApplicationException {
    public WaitHandleCannotBeOpenedException(string message);
    public WaitHandleCannotBeOpenedException(string message, Exception innerException);
    [NullableContextAttribute("1")]
protected WaitHandleCannotBeOpenedException(SerializationInfo info, StreamingContext context);
}
public class System.Threading.WaitOrTimerCallback : MulticastDelegate {
    public WaitOrTimerCallback(object object, IntPtr method);
    [NullableContextAttribute("2")]
public virtual void Invoke(object state, bool timedOut);
    public virtual IAsyncResult BeginInvoke(object state, bool timedOut, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("256")]
public class System.ThreadStaticAttribute : Attribute {
}
[StackTraceHiddenAttribute]
internal static class System.ThrowHelper : object {
    [DoesNotReturnAttribute]
internal static void ThrowArrayTypeMismatchException();
    [DoesNotReturnAttribute]
internal static void ThrowInvalidTypeWithPointersNotSupported(Type targetType);
    [DoesNotReturnAttribute]
internal static void ThrowIndexOutOfRangeException();
    [DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException();
    [DoesNotReturnAttribute]
internal static void ThrowArgumentException_DestinationTooShort();
    [DoesNotReturnAttribute]
internal static void ThrowArgumentException_OverlapAlignmentMismatch();
    [DoesNotReturnAttribute]
internal static void ThrowArgumentException_CannotExtractScalar(ExceptionArgument argument);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRange_IndexException();
    [DoesNotReturnAttribute]
internal static void ThrowIndexArgumentOutOfRange_NeedNonNegNumException();
    [DoesNotReturnAttribute]
internal static void ThrowValueArgumentOutOfRange_NeedNonNegNumException();
    [DoesNotReturnAttribute]
internal static void ThrowLengthArgumentOutOfRange_ArgumentOutOfRange_NeedNonNegNum();
    [DoesNotReturnAttribute]
internal static void ThrowStartIndexArgumentOutOfRange_ArgumentOutOfRange_Index();
    [DoesNotReturnAttribute]
internal static void ThrowCountArgumentOutOfRange_ArgumentOutOfRange_Count();
    [DoesNotReturnAttribute]
internal static void ThrowWrongKeyTypeArgumentException(T key, Type targetType);
    [DoesNotReturnAttribute]
internal static void ThrowWrongValueTypeArgumentException(T value, Type targetType);
    private static ArgumentException GetAddingDuplicateWithKeyArgumentException(object key);
    [DoesNotReturnAttribute]
internal static void ThrowAddingDuplicateWithKeyArgumentException(T key);
    [DoesNotReturnAttribute]
internal static void ThrowKeyNotFoundException(T key);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentException(ExceptionResource resource);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentException(ExceptionResource resource, ExceptionArgument argument);
    private static ArgumentNullException GetArgumentNullException(ExceptionArgument argument);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentNullException(ExceptionArgument argument);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentNullException(ExceptionArgument argument, ExceptionResource resource);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException(ExceptionArgument argument);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException(ExceptionArgument argument, ExceptionResource resource);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException(ExceptionArgument argument, int paramNumber, ExceptionResource resource);
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException();
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException(ExceptionResource resource);
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException(ExceptionResource resource, Exception e);
    [DoesNotReturnAttribute]
internal static void ThrowSerializationException(ExceptionResource resource);
    [DoesNotReturnAttribute]
internal static void ThrowRankException(ExceptionResource resource);
    [DoesNotReturnAttribute]
internal static void ThrowNotSupportedException(ExceptionResource resource);
    [DoesNotReturnAttribute]
internal static void ThrowObjectDisposedException(ExceptionResource resource);
    [DoesNotReturnAttribute]
internal static void ThrowNotSupportedException();
    [DoesNotReturnAttribute]
internal static void ThrowAggregateException(List`1<Exception> exceptions);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentException_Argument_InvalidArrayType();
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException_InvalidOperation_EnumNotStarted();
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException_InvalidOperation_EnumEnded();
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException_EnumCurrent(int index);
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException_InvalidOperation_EnumFailedVersion();
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException_InvalidOperation_EnumOpCantHappen();
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException_InvalidOperation_NoValue();
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException_ConcurrentOperationsNotSupported();
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException_HandleIsNotInitialized();
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException_HandleIsNotPinned();
    [DoesNotReturnAttribute]
internal static void ThrowArraySegmentCtorValidationFailedExceptions(Array array, int offset, int count);
    [DoesNotReturnAttribute]
internal static void ThrowFormatException_BadFormatSpecifier();
    [DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException_PrecisionTooLarge();
    [DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException_SymbolDoesNotFit();
    private static Exception GetArraySegmentCtorValidationFailedException(Array array, int offset, int count);
    private static ArgumentException GetArgumentException(ExceptionResource resource);
    private static InvalidOperationException GetInvalidOperationException(ExceptionResource resource);
    private static ArgumentException GetWrongKeyTypeArgumentException(object key, Type targetType);
    private static ArgumentException GetWrongValueTypeArgumentException(object value, Type targetType);
    private static KeyNotFoundException GetKeyNotFoundException(object key);
    private static ArgumentOutOfRangeException GetArgumentOutOfRangeException(ExceptionArgument argument, ExceptionResource resource);
    private static ArgumentException GetArgumentException(ExceptionResource resource, ExceptionArgument argument);
    private static ArgumentOutOfRangeException GetArgumentOutOfRangeException(ExceptionArgument argument, int paramNumber, ExceptionResource resource);
    private static InvalidOperationException GetInvalidOperationException_EnumCurrent(int index);
    internal static void IfNullAndNullsAreIllegalThenThrow(object value, ExceptionArgument argName);
    internal static void ThrowForUnsupportedVectorBaseType();
    private static string GetArgumentName(ExceptionArgument argument);
    private static string GetResourceString(ExceptionResource resource);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.TimeoutException : SystemException {
    public TimeoutException(string message);
    public TimeoutException(string message, Exception innerException);
    [NullableContextAttribute("1")]
protected TimeoutException(SerializationInfo info, StreamingContext context);
}
[IsReadOnlyAttribute]
public class System.TimeSpan : ValueType {
    public static long TicksPerMillisecond;
    public static long TicksPerSecond;
    public static long TicksPerMinute;
    public static long TicksPerHour;
    public static long TicksPerDay;
    public static TimeSpan Zero;
    public static TimeSpan MaxValue;
    public static TimeSpan MinValue;
    internal long _ticks;
    public long Ticks { get; }
    public int Days { get; }
    public int Hours { get; }
    public int Milliseconds { get; }
    public int Minutes { get; }
    public int Seconds { get; }
    public double TotalDays { get; }
    public double TotalHours { get; }
    public double TotalMilliseconds { get; }
    public double TotalMinutes { get; }
    public double TotalSeconds { get; }
    public TimeSpan(long ticks);
    public TimeSpan(int hours, int minutes, int seconds);
    public TimeSpan(int days, int hours, int minutes, int seconds);
    public TimeSpan(int days, int hours, int minutes, int seconds, int milliseconds);
    private static TimeSpan();
    public long get_Ticks();
    public int get_Days();
    public int get_Hours();
    public int get_Milliseconds();
    public int get_Minutes();
    public int get_Seconds();
    public double get_TotalDays();
    public double get_TotalHours();
    public double get_TotalMilliseconds();
    public double get_TotalMinutes();
    public double get_TotalSeconds();
    public TimeSpan Add(TimeSpan ts);
    public static int Compare(TimeSpan t1, TimeSpan t2);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(TimeSpan value);
    public static TimeSpan FromDays(double value);
    public TimeSpan Duration();
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public sealed virtual bool Equals(TimeSpan obj);
    public static bool Equals(TimeSpan t1, TimeSpan t2);
    public virtual int GetHashCode();
    public static TimeSpan FromHours(double value);
    private static TimeSpan Interval(double value, double scale);
    public static TimeSpan FromMilliseconds(double value);
    public static TimeSpan FromMinutes(double value);
    public TimeSpan Negate();
    public static TimeSpan FromSeconds(double value);
    public TimeSpan Subtract(TimeSpan ts);
    public TimeSpan Multiply(double factor);
    public TimeSpan Divide(double divisor);
    public double Divide(TimeSpan ts);
    public static TimeSpan FromTicks(long value);
    internal static long TimeToTicks(int hour, int minute, int second);
    private static void ValidateStyles(TimeSpanStyles style, string parameterName);
    [NullableContextAttribute("1")]
public static TimeSpan Parse(string s);
    [NullableContextAttribute("1")]
public static TimeSpan Parse(string input, IFormatProvider formatProvider);
    public static TimeSpan Parse(ReadOnlySpan`1<char> input, IFormatProvider formatProvider);
    [NullableContextAttribute("1")]
public static TimeSpan ParseExact(string input, string format, IFormatProvider formatProvider);
    [NullableContextAttribute("1")]
public static TimeSpan ParseExact(string input, String[] formats, IFormatProvider formatProvider);
    [NullableContextAttribute("1")]
public static TimeSpan ParseExact(string input, string format, IFormatProvider formatProvider, TimeSpanStyles styles);
    public static TimeSpan ParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, IFormatProvider formatProvider, TimeSpanStyles styles);
    [NullableContextAttribute("1")]
public static TimeSpan ParseExact(string input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles);
    public static TimeSpan ParseExact(ReadOnlySpan`1<char> input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, TimeSpan& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, TimeSpan& result);
    [NullableContextAttribute("2")]
public static bool TryParse(string input, IFormatProvider formatProvider, TimeSpan& result);
    public static bool TryParse(ReadOnlySpan`1<char> input, IFormatProvider formatProvider, TimeSpan& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(string input, string format, IFormatProvider formatProvider, TimeSpan& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, IFormatProvider formatProvider, TimeSpan& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(string input, String[] formats, IFormatProvider formatProvider, TimeSpan& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> input, String[] formats, IFormatProvider formatProvider, TimeSpan& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(string input, string format, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(string input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider formatProvider);
    public static TimeSpan op_UnaryNegation(TimeSpan t);
    public static TimeSpan op_Subtraction(TimeSpan t1, TimeSpan t2);
    public static TimeSpan op_UnaryPlus(TimeSpan t);
    public static TimeSpan op_Addition(TimeSpan t1, TimeSpan t2);
    public static TimeSpan op_Multiply(TimeSpan timeSpan, double factor);
    public static TimeSpan op_Multiply(double factor, TimeSpan timeSpan);
    public static TimeSpan op_Division(TimeSpan timeSpan, double divisor);
    public static double op_Division(TimeSpan t1, TimeSpan t2);
    public static bool op_Equality(TimeSpan t1, TimeSpan t2);
    public static bool op_Inequality(TimeSpan t1, TimeSpan t2);
    public static bool op_LessThan(TimeSpan t1, TimeSpan t2);
    public static bool op_LessThanOrEqual(TimeSpan t1, TimeSpan t2);
    public static bool op_GreaterThan(TimeSpan t1, TimeSpan t2);
    public static bool op_GreaterThanOrEqual(TimeSpan t1, TimeSpan t2);
}
[NullableContextAttribute("1")]
[ObsoleteAttribute("System.TimeZone has been deprecated.  Please investigate the use of System.TimeZoneInfo instead.")]
[NullableAttribute("0")]
public abstract class System.TimeZone : object {
    private static TimeZone modreq(System.Runtime.CompilerServices.IsVolatile) currentTimeZone;
    private static object s_InternalSyncObject;
    private static object InternalSyncObject { get; }
    public static TimeZone CurrentTimeZone { get; }
    public string StandardName { get; }
    public string DaylightName { get; }
    private static TimeZone();
    private static object get_InternalSyncObject();
    public static TimeZone get_CurrentTimeZone();
    internal static void ResetTimeZone();
    public abstract virtual string get_StandardName();
    public abstract virtual string get_DaylightName();
    public abstract virtual TimeSpan GetUtcOffset(DateTime time);
    public virtual DateTime ToUniversalTime(DateTime time);
    public virtual DateTime ToLocalTime(DateTime time);
    public abstract virtual DaylightTime GetDaylightChanges(int year);
    public virtual bool IsDaylightSavingTime(DateTime time);
    public static bool IsDaylightSavingTime(DateTime time, DaylightTime daylightTimes);
    internal static TimeSpan CalculateUtcOffset(DateTime time, DaylightTime daylightTimes);
}
[TypeForwardedFromAttribute("System.Core, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.TimeZoneInfo : object {
    private string _id;
    private string _displayName;
    private string _standardDisplayName;
    private string _daylightDisplayName;
    private TimeSpan _baseUtcOffset;
    private bool _supportsDaylightSavingTime;
    private AdjustmentRule[] _adjustmentRules;
    private static TimeZoneInfo s_utcTimeZone;
    private static CachedData s_cachedData;
    private static DateTime s_maxDateOnly;
    private static DateTime s_minDateOnly;
    private static TimeSpan MaxOffset;
    private static TimeSpan MinOffset;
    public string Id { get; }
    public string DisplayName { get; }
    public string StandardName { get; }
    public string DaylightName { get; }
    public TimeSpan BaseUtcOffset { get; }
    public bool SupportsDaylightSavingTime { get; }
    public static TimeZoneInfo Local { get; }
    public static TimeZoneInfo Utc { get; }
    private TimeZoneInfo(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, AdjustmentRule[] adjustmentRules, bool disableDaylightSavingTime);
    private TimeZoneInfo(SerializationInfo info, StreamingContext context);
    private TimeZoneInfo(TIME_ZONE_INFORMATION& zone, bool dstDisabled);
    private static TimeZoneInfo();
    public string get_Id();
    public string get_DisplayName();
    public string get_StandardName();
    public string get_DaylightName();
    public TimeSpan get_BaseUtcOffset();
    public bool get_SupportsDaylightSavingTime();
    public TimeSpan[] GetAmbiguousTimeOffsets(DateTimeOffset dateTimeOffset);
    public TimeSpan[] GetAmbiguousTimeOffsets(DateTime dateTime);
    private AdjustmentRule GetAdjustmentRuleForAmbiguousOffsets(DateTime adjustedTime, Nullable`1& ruleIndex);
    private AdjustmentRule GetPreviousAdjustmentRule(AdjustmentRule rule, Nullable`1<int> ruleIndex);
    public TimeSpan GetUtcOffset(DateTimeOffset dateTimeOffset);
    public TimeSpan GetUtcOffset(DateTime dateTime);
    internal static TimeSpan GetLocalUtcOffset(DateTime dateTime, TimeZoneInfoOptions flags);
    internal TimeSpan GetUtcOffset(DateTime dateTime, TimeZoneInfoOptions flags);
    private TimeSpan GetUtcOffset(DateTime dateTime, TimeZoneInfoOptions flags, CachedData cachedData);
    public bool IsAmbiguousTime(DateTimeOffset dateTimeOffset);
    public bool IsAmbiguousTime(DateTime dateTime);
    internal bool IsAmbiguousTime(DateTime dateTime, TimeZoneInfoOptions flags);
    public bool IsDaylightSavingTime(DateTimeOffset dateTimeOffset);
    public bool IsDaylightSavingTime(DateTime dateTime);
    internal bool IsDaylightSavingTime(DateTime dateTime, TimeZoneInfoOptions flags);
    private bool IsDaylightSavingTime(DateTime dateTime, TimeZoneInfoOptions flags, CachedData cachedData);
    public bool IsInvalidTime(DateTime dateTime);
    public static void ClearCachedData();
    public static DateTimeOffset ConvertTimeBySystemTimeZoneId(DateTimeOffset dateTimeOffset, string destinationTimeZoneId);
    public static DateTime ConvertTimeBySystemTimeZoneId(DateTime dateTime, string destinationTimeZoneId);
    public static DateTime ConvertTimeBySystemTimeZoneId(DateTime dateTime, string sourceTimeZoneId, string destinationTimeZoneId);
    public static DateTimeOffset ConvertTime(DateTimeOffset dateTimeOffset, TimeZoneInfo destinationTimeZone);
    public static DateTime ConvertTime(DateTime dateTime, TimeZoneInfo destinationTimeZone);
    public static DateTime ConvertTime(DateTime dateTime, TimeZoneInfo sourceTimeZone, TimeZoneInfo destinationTimeZone);
    internal static DateTime ConvertTime(DateTime dateTime, TimeZoneInfo sourceTimeZone, TimeZoneInfo destinationTimeZone, TimeZoneInfoOptions flags);
    private static DateTime ConvertTime(DateTime dateTime, TimeZoneInfo sourceTimeZone, TimeZoneInfo destinationTimeZone, TimeZoneInfoOptions flags, CachedData cachedData);
    public static DateTime ConvertTimeFromUtc(DateTime dateTime, TimeZoneInfo destinationTimeZone);
    public static DateTime ConvertTimeToUtc(DateTime dateTime);
    internal static DateTime ConvertTimeToUtc(DateTime dateTime, TimeZoneInfoOptions flags);
    public static DateTime ConvertTimeToUtc(DateTime dateTime, TimeZoneInfo sourceTimeZone);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(TimeZoneInfo other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public static TimeZoneInfo FromSerializedString(string source);
    public virtual int GetHashCode();
    public static ReadOnlyCollection`1<TimeZoneInfo> GetSystemTimeZones();
    public bool HasSameRules(TimeZoneInfo other);
    public static TimeZoneInfo get_Local();
    public string ToSerializedString();
    public virtual string ToString();
    public static TimeZoneInfo get_Utc();
    public static TimeZoneInfo CreateCustomTimeZone(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName);
    [NullableContextAttribute("2")]
public static TimeZoneInfo CreateCustomTimeZone(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, AdjustmentRule[] adjustmentRules);
    [NullableContextAttribute("2")]
public static TimeZoneInfo CreateCustomTimeZone(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, AdjustmentRule[] adjustmentRules, bool disableDaylightSavingTime);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    private AdjustmentRule GetAdjustmentRuleForTime(DateTime dateTime, Nullable`1& ruleIndex);
    private AdjustmentRule GetAdjustmentRuleForTime(DateTime dateTime, bool dateTimeisUtc, Nullable`1& ruleIndex);
    private int CompareAdjustmentRuleToDateTime(AdjustmentRule rule, AdjustmentRule previousRule, DateTime dateTime, DateTime dateOnly, bool dateTimeisUtc);
    private DateTime ConvertToUtc(DateTime dateTime, TimeSpan daylightDelta, TimeSpan baseUtcOffsetDelta);
    private DateTime ConvertFromUtc(DateTime dateTime, TimeSpan daylightDelta, TimeSpan baseUtcOffsetDelta);
    private DateTime ConvertToFromUtc(DateTime dateTime, TimeSpan daylightDelta, TimeSpan baseUtcOffsetDelta, bool convertToUtc);
    private static DateTime ConvertUtcToTimeZone(long ticks, TimeZoneInfo destinationTimeZone, Boolean& isAmbiguousLocalDst);
    private DaylightTimeStruct GetDaylightTime(int year, AdjustmentRule rule, Nullable`1<int> ruleIndex);
    private static bool GetIsDaylightSavings(DateTime time, AdjustmentRule rule, DaylightTimeStruct daylightTime, TimeZoneInfoOptions flags);
    private TimeSpan GetDaylightSavingsStartOffsetFromUtc(TimeSpan baseUtcOffset, AdjustmentRule rule, Nullable`1<int> ruleIndex);
    private TimeSpan GetDaylightSavingsEndOffsetFromUtc(TimeSpan baseUtcOffset, AdjustmentRule rule);
    private static bool GetIsDaylightSavingsFromUtc(DateTime time, int year, TimeSpan utc, AdjustmentRule rule, Nullable`1<int> ruleIndex, Boolean& isAmbiguousLocalDst, TimeZoneInfo zone);
    private static bool CheckIsDst(DateTime startTime, DateTime time, DateTime endTime, bool ignoreYearAdjustment, AdjustmentRule rule);
    private static bool GetIsAmbiguousTime(DateTime time, AdjustmentRule rule, DaylightTimeStruct daylightTime);
    private static bool GetIsInvalidTime(DateTime time, AdjustmentRule rule, DaylightTimeStruct daylightTime);
    private static TimeSpan GetUtcOffset(DateTime time, TimeZoneInfo zone, TimeZoneInfoOptions flags);
    private static TimeSpan GetUtcOffsetFromUtc(DateTime time, TimeZoneInfo zone);
    private static TimeSpan GetUtcOffsetFromUtc(DateTime time, TimeZoneInfo zone, Boolean& isDaylightSavings);
    internal static TimeSpan GetUtcOffsetFromUtc(DateTime time, TimeZoneInfo zone, Boolean& isDaylightSavings, Boolean& isAmbiguousLocalDst);
    internal static DateTime TransitionTimeToDateTime(int year, TransitionTime transitionTime);
    private static TimeZoneInfoResult TryGetTimeZone(string id, bool dstDisabled, TimeZoneInfo& value, Exception& e, CachedData cachedData, bool alwaysFallbackToLocalMachine);
    private static TimeZoneInfoResult TryGetTimeZoneFromLocalMachine(string id, bool dstDisabled, TimeZoneInfo& value, Exception& e, CachedData cachedData);
    private static void ValidateTimeZoneInfo(string id, TimeSpan baseUtcOffset, AdjustmentRule[] adjustmentRules, Boolean& adjustmentRulesSupportDst);
    internal static bool UtcOffsetOutOfRange(TimeSpan offset);
    private static TimeSpan GetUtcOffset(TimeSpan baseUtcOffset, AdjustmentRule adjustmentRule);
    private static bool IsValidAdjustmentRuleOffest(TimeSpan baseUtcOffset, AdjustmentRule adjustmentRule);
    public AdjustmentRule[] GetAdjustmentRules();
    private static void PopulateAllSystemTimeZones(CachedData cachedData);
    private static bool CheckDaylightSavingTimeNotSupported(TIME_ZONE_INFORMATION& timeZone);
    private static AdjustmentRule CreateAdjustmentRuleFromTimeZoneInformation(REG_TZI_FORMAT& timeZoneInformation, DateTime startDate, DateTime endDate, int defaultBaseUtcOffset);
    private static string FindIdFromTimeZoneInformation(TIME_ZONE_INFORMATION& timeZone, Boolean& dstDisabled);
    private static TimeZoneInfo GetLocalTimeZone(CachedData cachedData);
    private static TimeZoneInfo GetLocalTimeZoneFromWin32Data(TIME_ZONE_INFORMATION& timeZoneInformation, bool dstDisabled);
    public static TimeZoneInfo FindSystemTimeZoneById(string id);
    internal static TimeSpan GetDateTimeNowUtcOffsetFromUtc(DateTime time, Boolean& isAmbiguousLocalDst);
    private static bool TransitionTimeFromTimeZoneInformation(REG_TZI_FORMAT& timeZoneInformation, TransitionTime& transitionTime, bool readStartDate);
    private static bool TryCreateAdjustmentRules(string id, REG_TZI_FORMAT& defaultTimeZoneInformation, AdjustmentRule[]& rules, Exception& e, int defaultBaseUtcOffset);
    private static bool TryGetTimeZoneEntryFromRegistry(RegistryKey key, string name, REG_TZI_FORMAT& dtzi);
    private static bool TryCompareStandardDate(TIME_ZONE_INFORMATION& timeZone, REG_TZI_FORMAT& registryTimeZoneInfo);
    private static bool TryCompareTimeZoneInformationToRegistry(TIME_ZONE_INFORMATION& timeZone, string id, Boolean& dstDisabled);
    private static string TryGetLocalizedNameByMuiNativeResource(string resource);
    private static string TryGetLocalizedNameByNativeResource(string filePath, int resource);
    private static void GetLocalizedNamesByRegistryKey(RegistryKey key, String& displayName, String& standardName, String& daylightName);
    private static TimeZoneInfoResult TryGetTimeZoneFromLocalMachine(string id, TimeZoneInfo& value, Exception& e);
}
[FlagsAttribute]
internal enum System.TimeZoneInfoOptions : Enum {
    public int value__;
    public static TimeZoneInfoOptions None;
    public static TimeZoneInfoOptions NoThrowOnInvalidTime;
}
[NullableContextAttribute("2")]
[TypeForwardedFromAttribute("System.Core, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableAttribute("0")]
public class System.TimeZoneNotFoundException : Exception {
    public TimeZoneNotFoundException(string message);
    public TimeZoneNotFoundException(string message, Exception innerException);
    [NullableContextAttribute("1")]
protected TimeZoneNotFoundException(SerializationInfo info, StreamingContext context);
}
internal enum System.TokenType : Enum {
    public int value__;
    public static TokenType NumberToken;
    public static TokenType YearNumberToken;
    public static TokenType Am;
    public static TokenType Pm;
    public static TokenType MonthToken;
    public static TokenType EndOfString;
    public static TokenType DayOfWeekToken;
    public static TokenType TimeZoneToken;
    public static TokenType EraToken;
    public static TokenType DateWordToken;
    public static TokenType UnknownToken;
    public static TokenType HebrewNumber;
    public static TokenType JapaneseEraToken;
    public static TokenType TEraToken;
    public static TokenType IgnorableSymbol;
    public static TokenType SEP_Unk;
    public static TokenType SEP_End;
    public static TokenType SEP_Space;
    public static TokenType SEP_Am;
    public static TokenType SEP_Pm;
    public static TokenType SEP_Date;
    public static TokenType SEP_Time;
    public static TokenType SEP_YearSuff;
    public static TokenType SEP_MonthSuff;
    public static TokenType SEP_DaySuff;
    public static TokenType SEP_HourSuff;
    public static TokenType SEP_MinuteSuff;
    public static TokenType SEP_SecondSuff;
    public static TokenType SEP_LocalTimeMark;
    public static TokenType SEP_DateOrOffset;
    public static TokenType RegularTokenMask;
    public static TokenType SeparatorTokenMask;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Tuple : object {
    public static Tuple`1<T1> Create(T1 item1);
    public static Tuple`2<T1, T2> Create(T1 item1, T2 item2);
    public static Tuple`3<T1, T2, T3> Create(T1 item1, T2 item2, T3 item3);
    public static Tuple`4<T1, T2, T3, T4> Create(T1 item1, T2 item2, T3 item3, T4 item4);
    public static Tuple`5<T1, T2, T3, T4, T5> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
    public static Tuple`6<T1, T2, T3, T4, T5, T6> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
    public static Tuple`7<T1, T2, T3, T4, T5, T6, T7> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
    public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`1<T8>> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8);
    internal static int CombineHashCodes(int h1, int h2);
    internal static int CombineHashCodes(int h1, int h2, int h3);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6, int h7);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6, int h7, int h8);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Tuple`1 : object {
    private T1 m_Item1;
    [NullableAttribute("1")]
public T1 Item1 { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.ITuple.Item { get; }
    [NullableContextAttribute("1")]
public Tuple`1(T1 item1);
    [NullableContextAttribute("1")]
public T1 get_Item1();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    [NullableContextAttribute("1")]
public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToString(StringBuilder sb);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Tuple`2 : object {
    private T1 m_Item1;
    private T2 m_Item2;
    [NullableAttribute("1")]
public T1 Item1 { get; }
    [NullableAttribute("1")]
public T2 Item2 { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.ITuple.Item { get; }
    [NullableContextAttribute("1")]
public Tuple`2(T1 item1, T2 item2);
    [NullableContextAttribute("1")]
public T1 get_Item1();
    [NullableContextAttribute("1")]
public T2 get_Item2();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    [NullableContextAttribute("1")]
public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToString(StringBuilder sb);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Tuple`3 : object {
    private T1 m_Item1;
    private T2 m_Item2;
    private T3 m_Item3;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public Tuple`3(T1 item1, T2 item2, T3 item3);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToString(StringBuilder sb);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Tuple`4 : object {
    private T1 m_Item1;
    private T2 m_Item2;
    private T3 m_Item3;
    private T4 m_Item4;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public Tuple`4(T1 item1, T2 item2, T3 item3, T4 item4);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToString(StringBuilder sb);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Tuple`5 : object {
    private T1 m_Item1;
    private T2 m_Item2;
    private T3 m_Item3;
    private T4 m_Item4;
    private T5 m_Item5;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public Tuple`5(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToString(StringBuilder sb);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Tuple`6 : object {
    private T1 m_Item1;
    private T2 m_Item2;
    private T3 m_Item3;
    private T4 m_Item4;
    private T5 m_Item5;
    private T6 m_Item6;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    public T6 Item6 { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public Tuple`6(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
    public T6 get_Item6();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToString(StringBuilder sb);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Tuple`7 : object {
    private T1 m_Item1;
    private T2 m_Item2;
    private T3 m_Item3;
    private T4 m_Item4;
    private T5 m_Item5;
    private T6 m_Item6;
    private T7 m_Item7;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    public T6 Item6 { get; }
    public T7 Item7 { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public Tuple`7(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
    public T6 get_Item6();
    public T7 get_Item7();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToString(StringBuilder sb);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.Tuple`8 : object {
    private T1 m_Item1;
    private T2 m_Item2;
    private T3 m_Item3;
    private T4 m_Item4;
    private T5 m_Item5;
    private T6 m_Item6;
    private T7 m_Item7;
    private TRest m_Rest;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    public T6 Item6 { get; }
    public T7 Item7 { get; }
    public TRest Rest { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public Tuple`8(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
    public T6 get_Item6();
    public T7 get_Item7();
    public TRest get_Rest();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToString(StringBuilder sb);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[NullableAttribute("0")]
[NullableContextAttribute("2")]
[ExtensionAttribute]
public static class System.TupleExtensions : object {
    [ExtensionAttribute]
[NullableContextAttribute("1")]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`1<T1> value, T1& item1);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`2<T1, T2> value, T1& item1, T2& item2);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[NullableContextAttribute("1")]
public static void Deconstruct(Tuple`3<T1, T2, T3> value, T1& item1, T2& item2, T3& item3);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[NullableContextAttribute("1")]
public static void Deconstruct(Tuple`4<T1, T2, T3, T4> value, T1& item1, T2& item2, T3& item3, T4& item4);
    [ExtensionAttribute]
[NullableContextAttribute("1")]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`5<T1, T2, T3, T4, T5> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5);
    [EditorBrowsableAttribute("1")]
[ExtensionAttribute]
[NullableContextAttribute("1")]
public static void Deconstruct(Tuple`6<T1, T2, T3, T4, T5, T6> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6);
    [EditorBrowsableAttribute("1")]
[ExtensionAttribute]
[NullableContextAttribute("1")]
public static void Deconstruct(Tuple`7<T1, T2, T3, T4, T5, T6, T7> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[NullableContextAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`1<T8>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`2<T8, T9>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9);
    [EditorBrowsableAttribute("1")]
[ExtensionAttribute]
[NullableContextAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`3<T8, T9, T10>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10);
    [EditorBrowsableAttribute("1")]
[NullableContextAttribute("1")]
[ExtensionAttribute]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`4<T8, T9, T10, T11>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11);
    [EditorBrowsableAttribute("1")]
[NullableContextAttribute("1")]
[ExtensionAttribute]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`5<T8, T9, T10, T11, T12>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[NullableContextAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`6<T8, T9, T10, T11, T12, T13>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13);
    [EditorBrowsableAttribute("1")]
[ExtensionAttribute]
[NullableContextAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`7<T8, T9, T10, T11, T12, T13, T14>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`1<T15>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15);
    [ExtensionAttribute]
[NullableContextAttribute("1")]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`2<T15, T16>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`3<T15, T16, T17>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17);
    [EditorBrowsableAttribute("1")]
[ExtensionAttribute]
[NullableContextAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`4<T15, T16, T17, T18>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17, T18& item18);
    [EditorBrowsableAttribute("1")]
[ExtensionAttribute]
[NullableContextAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`5<T15, T16, T17, T18, T19>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17, T18& item18, T19& item19);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`6<T15, T16, T17, T18, T19, T20>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17, T18& item18, T19& item19, T20& item20);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`7<T15, T16, T17, T18, T19, T20, T21>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17, T18& item18, T19& item19, T20& item20, T21& item21);
    [ExtensionAttribute]
[NullableContextAttribute("1")]
public static ValueTuple`1<T1> ToValueTuple(Tuple`1<T1> value);
    [ExtensionAttribute]
public static ValueTuple`2<T1, T2> ToValueTuple(Tuple`2<T1, T2> value);
    [ExtensionAttribute]
public static ValueTuple`3<T1, T2, T3> ToValueTuple(Tuple`3<T1, T2, T3> value);
    [ExtensionAttribute]
public static ValueTuple`4<T1, T2, T3, T4> ToValueTuple(Tuple`4<T1, T2, T3, T4> value);
    [ExtensionAttribute]
public static ValueTuple`5<T1, T2, T3, T4, T5> ToValueTuple(Tuple`5<T1, T2, T3, T4, T5> value);
    [ExtensionAttribute]
public static ValueTuple`6<T1, T2, T3, T4, T5, T6> ToValueTuple(Tuple`6<T1, T2, T3, T4, T5, T6> value);
    [ExtensionAttribute]
public static ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> ToValueTuple(Tuple`7<T1, T2, T3, T4, T5, T6, T7> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`1<T8>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`1<T8>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`2<T8, T9>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`2<T8, T9>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`3<T8, T9, T10>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`3<T8, T9, T10>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`4<T8, T9, T10, T11>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`4<T8, T9, T10, T11>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`5<T8, T9, T10, T11, T12>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`5<T8, T9, T10, T11, T12>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`6<T8, T9, T10, T11, T12, T13>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`6<T8, T9, T10, T11, T12, T13>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`7<T8, T9, T10, T11, T12, T13, T14>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`7<T8, T9, T10, T11, T12, T13, T14>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`1<T15>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`1<T15>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`2<T15, T16>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`2<T15, T16>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`3<T15, T16, T17>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`3<T15, T16, T17>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`4<T15, T16, T17, T18>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`4<T15, T16, T17, T18>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`5<T15, T16, T17, T18, T19>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`5<T15, T16, T17, T18, T19>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`6<T15, T16, T17, T18, T19, T20>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`6<T15, T16, T17, T18, T19, T20>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`7<T15, T16, T17, T18, T19, T20, T21>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`7<T15, T16, T17, T18, T19, T20, T21>>> value);
    [ExtensionAttribute]
[NullableContextAttribute("1")]
public static Tuple`1<T1> ToTuple(ValueTuple`1<T1> value);
    [ExtensionAttribute]
public static Tuple`2<T1, T2> ToTuple(ValueTuple`2<T1, T2> value);
    [ExtensionAttribute]
public static Tuple`3<T1, T2, T3> ToTuple(ValueTuple`3<T1, T2, T3> value);
    [ExtensionAttribute]
public static Tuple`4<T1, T2, T3, T4> ToTuple(ValueTuple`4<T1, T2, T3, T4> value);
    [ExtensionAttribute]
public static Tuple`5<T1, T2, T3, T4, T5> ToTuple(ValueTuple`5<T1, T2, T3, T4, T5> value);
    [ExtensionAttribute]
public static Tuple`6<T1, T2, T3, T4, T5, T6> ToTuple(ValueTuple`6<T1, T2, T3, T4, T5, T6> value);
    [ExtensionAttribute]
public static Tuple`7<T1, T2, T3, T4, T5, T6, T7> ToTuple(ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`1<T8>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`1<T8>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`2<T8, T9>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`2<T8, T9>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`3<T8, T9, T10>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`3<T8, T9, T10>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`4<T8, T9, T10, T11>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`4<T8, T9, T10, T11>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`5<T8, T9, T10, T11, T12>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`5<T8, T9, T10, T11, T12>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`6<T8, T9, T10, T11, T12, T13>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`6<T8, T9, T10, T11, T12, T13>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`7<T8, T9, T10, T11, T12, T13, T14>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`7<T8, T9, T10, T11, T12, T13, T14>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`1<T15>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`1<T15>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`2<T15, T16>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`2<T15, T16>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`3<T15, T16, T17>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`3<T15, T16, T17>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`4<T15, T16, T17, T18>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`4<T15, T16, T17, T18>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`5<T15, T16, T17, T18, T19>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`5<T15, T16, T17, T18, T19>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`6<T15, T16, T17, T18, T19, T20>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`6<T15, T16, T17, T18, T19, T20>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`7<T15, T16, T17, T18, T19, T20, T21>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`7<T15, T16, T17, T18, T19, T20, T21>>> value);
    private static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, TRest> CreateLong(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);
    private static Tuple`8<T1, T2, T3, T4, T5, T6, T7, TRest> CreateLongRef(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Type : MemberInfo {
    private static Binder modreq(System.Runtime.CompilerServices.IsVolatile) s_defaultBinder;
    public static char Delimiter;
    public static Type[] EmptyTypes;
    public static object Missing;
    public static MemberFilter FilterAttribute;
    public static MemberFilter FilterName;
    public static MemberFilter FilterNameIgnoreCase;
    public bool IsInterface { get; }
    internal bool IsWindowsRuntimeObject { get; }
    internal bool IsExportedToWindowsRuntime { get; }
    public MemberTypes MemberType { get; }
    [NullableAttribute("2")]
public string Namespace { get; }
    [NullableAttribute("2")]
public string AssemblyQualifiedName { get; }
    [NullableAttribute("2")]
public string FullName { get; }
    public Assembly Assembly { get; }
    public Module Module { get; }
    public bool IsNested { get; }
    [NullableAttribute("2")]
public Type DeclaringType { get; }
    [NullableAttribute("2")]
public MethodBase DeclaringMethod { get; }
    [NullableAttribute("2")]
public Type ReflectedType { get; }
    public Type UnderlyingSystemType { get; }
    public bool IsTypeDefinition { get; }
    public bool IsArray { get; }
    public bool IsByRef { get; }
    public bool IsPointer { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericTypeParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public bool IsGenericType { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    public bool IsByRefLike { get; }
    public bool HasElementType { get; }
    public Type[] GenericTypeArguments { get; }
    public int GenericParameterPosition { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public TypeAttributes Attributes { get; }
    public bool IsAbstract { get; }
    public bool IsImport { get; }
    public bool IsSealed { get; }
    public bool IsSpecialName { get; }
    public bool IsClass { get; }
    public bool IsNestedAssembly { get; }
    public bool IsNestedFamANDAssem { get; }
    public bool IsNestedFamily { get; }
    public bool IsNestedFamORAssem { get; }
    public bool IsNestedPrivate { get; }
    public bool IsNestedPublic { get; }
    public bool IsNotPublic { get; }
    public bool IsPublic { get; }
    public bool IsAutoLayout { get; }
    public bool IsExplicitLayout { get; }
    public bool IsLayoutSequential { get; }
    public bool IsAnsiClass { get; }
    public bool IsAutoClass { get; }
    public bool IsUnicodeClass { get; }
    public bool IsCOMObject { get; }
    public bool IsContextful { get; }
    public bool IsEnum { get; }
    public bool IsMarshalByRef { get; }
    public bool IsPrimitive { get; }
    public bool IsValueType { get; }
    public bool IsSignatureType { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    [NullableAttribute("2")]
public StructLayoutAttribute StructLayoutAttribute { get; }
    [NullableAttribute("2")]
public ConstructorInfo TypeInitializer { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public Guid GUID { get; }
    [NullableAttribute("2")]
public Type BaseType { get; }
    public static Binder DefaultBinder { get; }
    public bool IsSerializable { get; }
    public bool ContainsGenericParameters { get; }
    public bool IsVisible { get; }
    private static Type();
    public bool get_IsInterface();
    public static Type GetType(string typeName, bool throwOnError, bool ignoreCase);
    public static Type GetType(string typeName, bool throwOnError);
    public static Type GetType(string typeName);
    public static Type GetType(string typeName, Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver);
    public static Type GetType(string typeName, Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver, bool throwOnError);
    public static Type GetType(string typeName, Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver, bool throwOnError, bool ignoreCase);
    [NullableContextAttribute("2")]
public static Type GetTypeFromProgID(string progID, string server, bool throwOnError);
    [NullableContextAttribute("2")]
public static Type GetTypeFromCLSID(Guid clsid, string server, bool throwOnError);
    internal virtual RuntimeTypeHandle GetTypeHandleInternal();
    internal static RuntimeType GetTypeFromHandleUnsafe(IntPtr handle);
    public static Type GetTypeFromHandle(RuntimeTypeHandle handle);
    internal bool get_IsWindowsRuntimeObject();
    internal bool get_IsExportedToWindowsRuntime();
    internal virtual bool IsWindowsRuntimeObjectImpl();
    internal virtual bool IsExportedToWindowsRuntimeImpl();
    internal virtual string FormatTypeName();
    [NullableContextAttribute("2")]
public static bool op_Equality(Type left, Type right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(Type left, Type right);
    internal bool IsRuntimeImplemented();
    public virtual MemberTypes get_MemberType();
    public Type GetType();
    [NullableContextAttribute("2")]
public abstract virtual string get_Namespace();
    [NullableContextAttribute("2")]
public abstract virtual string get_AssemblyQualifiedName();
    [NullableContextAttribute("2")]
public abstract virtual string get_FullName();
    public abstract virtual Assembly get_Assembly();
    public abstract virtual Module get_Module();
    public bool get_IsNested();
    [NullableContextAttribute("2")]
public virtual Type get_DeclaringType();
    [NullableContextAttribute("2")]
public virtual MethodBase get_DeclaringMethod();
    [NullableContextAttribute("2")]
public virtual Type get_ReflectedType();
    public abstract virtual Type get_UnderlyingSystemType();
    public virtual bool get_IsTypeDefinition();
    public bool get_IsArray();
    protected abstract virtual bool IsArrayImpl();
    public bool get_IsByRef();
    protected abstract virtual bool IsByRefImpl();
    public bool get_IsPointer();
    protected abstract virtual bool IsPointerImpl();
    public virtual bool get_IsConstructedGenericType();
    public virtual bool get_IsGenericParameter();
    public virtual bool get_IsGenericTypeParameter();
    public virtual bool get_IsGenericMethodParameter();
    public virtual bool get_IsGenericType();
    public virtual bool get_IsGenericTypeDefinition();
    public virtual bool get_IsSZArray();
    public virtual bool get_IsVariableBoundArray();
    public virtual bool get_IsByRefLike();
    public bool get_HasElementType();
    protected abstract virtual bool HasElementTypeImpl();
    [NullableContextAttribute("2")]
public abstract virtual Type GetElementType();
    public virtual int GetArrayRank();
    public virtual Type GetGenericTypeDefinition();
    public virtual Type[] get_GenericTypeArguments();
    public virtual Type[] GetGenericArguments();
    public virtual int get_GenericParameterPosition();
    public virtual GenericParameterAttributes get_GenericParameterAttributes();
    public virtual Type[] GetGenericParameterConstraints();
    public TypeAttributes get_Attributes();
    protected abstract virtual TypeAttributes GetAttributeFlagsImpl();
    public bool get_IsAbstract();
    public bool get_IsImport();
    public bool get_IsSealed();
    public bool get_IsSpecialName();
    public bool get_IsClass();
    public bool get_IsNestedAssembly();
    public bool get_IsNestedFamANDAssem();
    public bool get_IsNestedFamily();
    public bool get_IsNestedFamORAssem();
    public bool get_IsNestedPrivate();
    public bool get_IsNestedPublic();
    public bool get_IsNotPublic();
    public bool get_IsPublic();
    public bool get_IsAutoLayout();
    public bool get_IsExplicitLayout();
    public bool get_IsLayoutSequential();
    public bool get_IsAnsiClass();
    public bool get_IsAutoClass();
    public bool get_IsUnicodeClass();
    public bool get_IsCOMObject();
    protected abstract virtual bool IsCOMObjectImpl();
    public bool get_IsContextful();
    protected virtual bool IsContextfulImpl();
    public virtual bool get_IsEnum();
    public bool get_IsMarshalByRef();
    protected virtual bool IsMarshalByRefImpl();
    public bool get_IsPrimitive();
    protected abstract virtual bool IsPrimitiveImpl();
    public bool get_IsValueType();
    protected virtual bool IsValueTypeImpl();
    public virtual bool get_IsSignatureType();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    [NullableContextAttribute("2")]
public virtual StructLayoutAttribute get_StructLayoutAttribute();
    [NullableContextAttribute("2")]
public ConstructorInfo get_TypeInitializer();
    public ConstructorInfo GetConstructor(Type[] types);
    [NullableContextAttribute("2")]
public ConstructorInfo GetConstructor(BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
    [NullableContextAttribute("2")]
public ConstructorInfo GetConstructor(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [NullableContextAttribute("2")]
protected abstract virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public ConstructorInfo[] GetConstructors();
    public abstract virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    public EventInfo GetEvent(string name);
    public abstract virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents();
    public abstract virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public FieldInfo GetField(string name);
    public abstract virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public FieldInfo[] GetFields();
    public abstract virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public MemberInfo[] GetMember(string name);
    public virtual MemberInfo[] GetMember(string name, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public MemberInfo[] GetMembers();
    public abstract virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    public MethodInfo GetMethod(string name);
    public sealed virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr);
    public MethodInfo GetMethod(string name, Type[] types);
    public MethodInfo GetMethod(string name, Type[] types, ParameterModifier[] modifiers);
    [NullableContextAttribute("2")]
public sealed virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
    [NullableContextAttribute("2")]
public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [NullableContextAttribute("2")]
protected abstract virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public MethodInfo GetMethod(string name, int genericParameterCount, Type[] types);
    public MethodInfo GetMethod(string name, int genericParameterCount, Type[] types, ParameterModifier[] modifiers);
    [NullableContextAttribute("2")]
public MethodInfo GetMethod(string name, int genericParameterCount, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
    [NullableContextAttribute("2")]
public MethodInfo GetMethod(string name, int genericParameterCount, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [NullableContextAttribute("2")]
protected virtual MethodInfo GetMethodImpl(string name, int genericParameterCount, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public MethodInfo[] GetMethods();
    public abstract virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public Type GetNestedType(string name);
    public abstract virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public Type[] GetNestedTypes();
    public abstract virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public PropertyInfo GetProperty(string name);
    public sealed virtual PropertyInfo GetProperty(string name, BindingFlags bindingAttr);
    [NullableContextAttribute("2")]
public PropertyInfo GetProperty(string name, Type returnType);
    public PropertyInfo GetProperty(string name, Type[] types);
    public PropertyInfo GetProperty(string name, Type returnType, Type[] types);
    [NullableContextAttribute("2")]
public PropertyInfo GetProperty(string name, Type returnType, Type[] types, ParameterModifier[] modifiers);
    [NullableContextAttribute("2")]
public sealed virtual PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    [NullableContextAttribute("2")]
protected abstract virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public PropertyInfo[] GetProperties();
    public abstract virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public virtual MemberInfo[] GetDefaultMembers();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public static RuntimeTypeHandle GetTypeHandle(object o);
    public static Type[] GetTypeArray(Object[] args);
    [NullableContextAttribute("2")]
public static TypeCode GetTypeCode(Type type);
    protected virtual TypeCode GetTypeCodeImpl();
    public abstract virtual Guid get_GUID();
    [NullableContextAttribute("2")]
public static Type GetTypeFromCLSID(Guid clsid);
    [NullableContextAttribute("2")]
public static Type GetTypeFromCLSID(Guid clsid, bool throwOnError);
    [NullableContextAttribute("2")]
public static Type GetTypeFromCLSID(Guid clsid, string server);
    public static Type GetTypeFromProgID(string progID);
    public static Type GetTypeFromProgID(string progID, bool throwOnError);
    [NullableContextAttribute("2")]
public static Type GetTypeFromProgID(string progID, string server);
    [NullableContextAttribute("2")]
public abstract virtual Type get_BaseType();
    [NullableContextAttribute("2")]
[DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args);
    [NullableContextAttribute("2")]
[DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, CultureInfo culture);
    [NullableContextAttribute("2")]
public abstract virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public Type GetInterface(string name);
    public abstract virtual Type GetInterface(string name, bool ignoreCase);
    public abstract virtual Type[] GetInterfaces();
    public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    [NullableContextAttribute("2")]
public virtual bool IsInstanceOfType(object o);
    [NullableContextAttribute("2")]
public virtual bool IsEquivalentTo(Type other);
    public virtual Type GetEnumUnderlyingType();
    public virtual Array GetEnumValues();
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
    public virtual Type MakeByRefType();
    public virtual Type MakeGenericType(Type[] typeArguments);
    public virtual Type MakePointerType();
    public static Type MakeGenericSignatureType(Type genericTypeDefinition, Type[] typeArguments);
    public static Type MakeGenericMethodParameter(int position);
    public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object o);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(Type o);
    public static Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase);
    public static Binder get_DefaultBinder();
    public virtual bool IsEnumDefined(object value);
    public virtual string GetEnumName(object value);
    public virtual String[] GetEnumNames();
    private Array GetEnumRawConstantValues();
    private void GetEnumData(String[]& enumNames, Array& enumValues);
    private static int BinarySearch(Array array, object value);
    internal static bool IsIntegerType(Type t);
    public virtual bool get_IsSerializable();
    public virtual bool get_ContainsGenericParameters();
    internal Type GetRootElementType();
    public bool get_IsVisible();
    public virtual Type[] FindInterfaces(TypeFilter filter, object filterCriteria);
    [NullableContextAttribute("2")]
public virtual MemberInfo[] FindMembers(MemberTypes memberType, BindingFlags bindingAttr, MemberFilter filter, object filterCriteria);
    public virtual bool IsSubclassOf(Type c);
    [NullableContextAttribute("2")]
public virtual bool IsAssignableFrom(Type c);
    internal bool ImplementInterface(Type ifaceType);
    private static bool FilterAttributeImpl(MemberInfo m, object filterCriteria);
    private static bool FilterNameImpl(MemberInfo m, object filterCriteria, StringComparison comparison);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.TypeAccessException : TypeLoadException {
    public TypeAccessException(string message);
    public TypeAccessException(string message, Exception inner);
    [NullableContextAttribute("1")]
protected TypeAccessException(SerializationInfo info, StreamingContext context);
}
public enum System.TypeCode : Enum {
    public int value__;
    public static TypeCode Empty;
    public static TypeCode Object;
    public static TypeCode DBNull;
    public static TypeCode Boolean;
    public static TypeCode Char;
    public static TypeCode SByte;
    public static TypeCode Byte;
    public static TypeCode Int16;
    public static TypeCode UInt16;
    public static TypeCode Int32;
    public static TypeCode UInt32;
    public static TypeCode Int64;
    public static TypeCode UInt64;
    public static TypeCode Single;
    public static TypeCode Double;
    public static TypeCode Decimal;
    public static TypeCode DateTime;
    public static TypeCode String;
}
[NonVersionableAttribute]
[NullableAttribute("0")]
[CLSCompliantAttribute("False")]
[IsByRefLikeAttribute]
[NullableContextAttribute("1")]
public class System.TypedReference : ValueType {
    private IntPtr Value;
    private IntPtr Type;
    internal bool IsNull { get; }
    [CLSCompliantAttribute("False")]
public static TypedReference MakeTypedReference(object target, FieldInfo[] flds);
    private static void InternalMakeTypedReference(Void* result, object target, IntPtr[] flds, RuntimeType lastFieldType);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object o);
    public static object ToObject(TypedReference value);
    internal static object InternalToObject(Void* value);
    internal bool get_IsNull();
    public static Type GetTargetType(TypedReference value);
    public static RuntimeTypeHandle TargetTypeToken(TypedReference value);
    [CLSCompliantAttribute("False")]
[NullableContextAttribute("2")]
public static void SetTypedReference(TypedReference target, object value);
    internal static void InternalSetTypedReference(Void* target, object value);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.TypeInitializationException : SystemException {
    private string _typeName;
    public string TypeName { get; }
    [NullableContextAttribute("2")]
public TypeInitializationException(string fullTypeName, Exception innerException);
    internal TypeInitializationException(string message);
    internal TypeInitializationException(string fullTypeName, string message, Exception innerException);
    internal TypeInitializationException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public string get_TypeName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.TypeLoadException : SystemException {
    private string _className;
    private string _assemblyName;
    private string _messageArg;
    private int _resourceId;
    public string Message { get; }
    public string TypeName { get; }
    private TypeLoadException(string className, string assemblyName, string messageArg, int resourceId);
    [NullableContextAttribute("2")]
public TypeLoadException(string message);
    [NullableContextAttribute("2")]
public TypeLoadException(string message, Exception inner);
    protected TypeLoadException(SerializationInfo info, StreamingContext context);
    private void SetMessageField();
    private static void GetTypeLoadExceptionMessage(int resourceId, StringHandleOnStack retString);
    public virtual string get_Message();
    public string get_TypeName();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal enum System.TypeNameFormatFlags : Enum {
    public int value__;
    public static TypeNameFormatFlags FormatBasic;
    public static TypeNameFormatFlags FormatNamespace;
    public static TypeNameFormatFlags FormatFullInst;
    public static TypeNameFormatFlags FormatAssembly;
    public static TypeNameFormatFlags FormatSignature;
    public static TypeNameFormatFlags FormatNoVersion;
    public static TypeNameFormatFlags FormatAngleBrackets;
    public static TypeNameFormatFlags FormatStubInfo;
    public static TypeNameFormatFlags FormatGenericParam;
}
internal enum System.TypeNameKind : Enum {
    public int value__;
    public static TypeNameKind Name;
    public static TypeNameKind ToString;
    public static TypeNameKind FullName;
}
internal class System.TypeNameParser : object {
    private SafeTypeNameParserHandle m_NativeParser;
    private static Char[] SPECIAL_CHARS;
    private TypeNameParser(SafeTypeNameParserHandle handle);
    private static TypeNameParser();
    private static void _CreateTypeNameParser(string typeName, ObjectHandleOnStack retHandle, bool throwOnError);
    private static void _GetNames(SafeTypeNameParserHandle pTypeNameParser, ObjectHandleOnStack retArray);
    private static void _GetTypeArguments(SafeTypeNameParserHandle pTypeNameParser, ObjectHandleOnStack retArray);
    private static void _GetModifiers(SafeTypeNameParserHandle pTypeNameParser, ObjectHandleOnStack retArray);
    private static void _GetAssemblyName(SafeTypeNameParserHandle pTypeNameParser, StringHandleOnStack retString);
    internal static Type GetType(string typeName, Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver, bool throwOnError, bool ignoreCase, StackCrawlMark& stackMark);
    public sealed virtual void Dispose();
    private Type ConstructType(Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver, bool throwOnError, bool ignoreCase, StackCrawlMark& stackMark);
    private static Assembly ResolveAssembly(string asmName, Func`2<AssemblyName, Assembly> assemblyResolver, bool throwOnError, StackCrawlMark& stackMark);
    private static Type ResolveType(Assembly assembly, String[] names, Func`4<Assembly, string, bool, Type> typeResolver, bool throwOnError, bool ignoreCase, StackCrawlMark& stackMark);
    private static string EscapeTypeName(string name);
    private static SafeTypeNameParserHandle CreateTypeNameParser(string typeName, bool throwOnError);
    private String[] GetNames();
    private SafeTypeNameParserHandle[] GetTypeArguments();
    private Int32[] GetModifiers();
    private string GetAssemblyName();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.TypeUnloadedException : SystemException {
    public TypeUnloadedException(string message);
    public TypeUnloadedException(string message, Exception innerException);
    [NullableContextAttribute("1")]
protected TypeUnloadedException(SerializationInfo info, StreamingContext context);
}
[CLSCompliantAttribute("False")]
[IsReadOnlyAttribute]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.UInt16 : ValueType {
    private ushort m_value;
    public static ushort MaxValue;
    public static ushort MinValue;
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(ushort value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(ushort obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public sealed virtual string ToString(IFormatProvider provider);
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public static ushort Parse(string s);
    [CLSCompliantAttribute("False")]
[NullableContextAttribute("1")]
public static ushort Parse(string s, NumberStyles style);
    [CLSCompliantAttribute("False")]
[NullableContextAttribute("1")]
public static ushort Parse(string s, IFormatProvider provider);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public static ushort Parse(string s, NumberStyles style, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ushort Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    private static ushort Parse(ReadOnlySpan`1<char> s, NumberStyles style, NumberFormatInfo info);
    [NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static bool TryParse(string s, UInt16& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<char> s, UInt16& result);
    [NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, UInt16& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, UInt16& result);
    private static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, NumberFormatInfo info, UInt16& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[IsReadOnlyAttribute]
[CLSCompliantAttribute("False")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.UInt32 : ValueType {
    private UInt32 m_value;
    public static UInt32 MaxValue;
    public static UInt32 MinValue;
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(UInt32 value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(UInt32 obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public sealed virtual string ToString(IFormatProvider provider);
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public static UInt32 Parse(string s);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public static UInt32 Parse(string s, NumberStyles style);
    [CLSCompliantAttribute("False")]
[NullableContextAttribute("1")]
public static UInt32 Parse(string s, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
[NullableContextAttribute("1")]
public static UInt32 Parse(string s, NumberStyles style, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static UInt32 Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    [NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static bool TryParse(string s, UInt32& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<char> s, UInt32& result);
    [NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, UInt32& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, UInt32& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[CLSCompliantAttribute("False")]
[IsReadOnlyAttribute]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.UInt64 : ValueType {
    private ulong m_value;
    public static ulong MaxValue;
    public static ulong MinValue;
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(ulong value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(ulong obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public sealed virtual string ToString(IFormatProvider provider);
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
[NullableContextAttribute("1")]
public static ulong Parse(string s);
    [CLSCompliantAttribute("False")]
[NullableContextAttribute("1")]
public static ulong Parse(string s, NumberStyles style);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public static ulong Parse(string s, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
[NullableContextAttribute("1")]
public static ulong Parse(string s, NumberStyles style, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ulong Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    [NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static bool TryParse(string s, UInt64& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<char> s, UInt64& result);
    [NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, UInt64& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, UInt64& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[IsReadOnlyAttribute]
[CLSCompliantAttribute("False")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.UIntPtr : ValueType {
    private Void* _value;
    [IntrinsicAttribute]
public static UIntPtr Zero;
    public static int Size { get; }
    [NonVersionableAttribute]
[IntrinsicAttribute]
public UIntPtr(UInt32 value);
    [NonVersionableAttribute]
[IntrinsicAttribute]
public UIntPtr(ulong value);
    [NonVersionableAttribute]
[IntrinsicAttribute]
public UIntPtr(Void* value);
    private UIntPtr(SerializationInfo info, StreamingContext context);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    private sealed virtual override bool System.IEquatable<System.UIntPtr>.Equals(UIntPtr other);
    public virtual int GetHashCode();
    [NonVersionableAttribute]
[IntrinsicAttribute]
public UInt32 ToUInt32();
    [NonVersionableAttribute]
[IntrinsicAttribute]
public ulong ToUInt64();
    [NonVersionableAttribute]
[IntrinsicAttribute]
public static UIntPtr op_Explicit(UInt32 value);
    [NonVersionableAttribute]
[IntrinsicAttribute]
public static UIntPtr op_Explicit(ulong value);
    [NonVersionableAttribute]
[IntrinsicAttribute]
public static UIntPtr op_Explicit(Void* value);
    [NonVersionableAttribute]
[IntrinsicAttribute]
public static Void* op_Explicit(UIntPtr value);
    [NonVersionableAttribute]
[IntrinsicAttribute]
public static UInt32 op_Explicit(UIntPtr value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static ulong op_Explicit(UIntPtr value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static bool op_Equality(UIntPtr value1, UIntPtr value2);
    [NonVersionableAttribute]
[IntrinsicAttribute]
public static bool op_Inequality(UIntPtr value1, UIntPtr value2);
    [NonVersionableAttribute]
public static UIntPtr Add(UIntPtr pointer, int offset);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static UIntPtr op_Addition(UIntPtr pointer, int offset);
    [NonVersionableAttribute]
public static UIntPtr Subtract(UIntPtr pointer, int offset);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static UIntPtr op_Subtraction(UIntPtr pointer, int offset);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static int get_Size();
    [IntrinsicAttribute]
[NonVersionableAttribute]
public Void* ToPointer();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.UnauthorizedAccessException : SystemException {
    public UnauthorizedAccessException(string message);
    public UnauthorizedAccessException(string message, Exception inner);
    [NullableContextAttribute("1")]
protected UnauthorizedAccessException(SerializationInfo info, StreamingContext context);
}
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.UnhandledExceptionEventArgs : EventArgs {
    private object _exception;
    private bool _isTerminating;
    public object ExceptionObject { get; }
    public bool IsTerminating { get; }
    public UnhandledExceptionEventArgs(object exception, bool isTerminating);
    public object get_ExceptionObject();
    public bool get_IsTerminating();
}
public class System.UnhandledExceptionEventHandler : MulticastDelegate {
    public UnhandledExceptionEventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender, UnhandledExceptionEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, UnhandledExceptionEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.UnitySerializationHolder : object {
    private int _unityType;
    private string _data;
    [NullableContextAttribute("1")]
public UnitySerializationHolder(SerializationInfo info, StreamingContext context);
    internal static void GetUnitySerializationInfo(SerializationInfo info, int unityType);
    [NullableContextAttribute("1")]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("1")]
public sealed virtual object GetRealObject(StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableAttribute("0")]
[NullableContextAttribute("1")]
public class System.ValueTuple : ValueType {
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.ITuple.Item { get; }
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    public static ValueTuple Create();
    public static ValueTuple`1<T1> Create(T1 item1);
    public static ValueTuple`2<T1, T2> Create(T1 item1, T2 item2);
    public static ValueTuple`3<T1, T2, T3> Create(T1 item1, T2 item2, T3 item3);
    public static ValueTuple`4<T1, T2, T3, T4> Create(T1 item1, T2 item2, T3 item3, T4 item4);
    public static ValueTuple`5<T1, T2, T3, T4, T5> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
    public static ValueTuple`6<T1, T2, T3, T4, T5, T6> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
    public static ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
    public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`1<T8>> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8);
    internal static int CombineHashCodes(int h1, int h2);
    internal static int CombineHashCodes(int h1, int h2, int h3);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6, int h7);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6, int h7, int h8);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ValueTuple`1 : ValueType {
    [NullableAttribute("1")]
public T1 Item1;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.ITuple.Item { get; }
    [NullableContextAttribute("1")]
public ValueTuple`1(T1 item1);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`1<T1> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`1<T1> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    [NullableContextAttribute("1")]
public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ValueTuple`2 : ValueType {
    [NullableAttribute("1")]
public T1 Item1;
    [NullableAttribute("1")]
public T2 Item2;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.ITuple.Item { get; }
    [NullableContextAttribute("1")]
public ValueTuple`2(T1 item1, T2 item2);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`2<T1, T2> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`2<T1, T2> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private int GetHashCodeCore(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    [NullableContextAttribute("1")]
public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ValueTuple`3 : ValueType {
    [NullableAttribute("1")]
public T1 Item1;
    [NullableAttribute("1")]
public T2 Item2;
    [NullableAttribute("1")]
public T3 Item3;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.ITuple.Item { get; }
    [NullableContextAttribute("1")]
public ValueTuple`3(T1 item1, T2 item2, T3 item3);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`3<T1, T2, T3> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`3<T1, T2, T3> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private int GetHashCodeCore(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    [NullableContextAttribute("1")]
public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ValueTuple`4 : ValueType {
    [NullableAttribute("1")]
public T1 Item1;
    [NullableAttribute("1")]
public T2 Item2;
    [NullableAttribute("1")]
public T3 Item3;
    [NullableAttribute("1")]
public T4 Item4;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.ITuple.Item { get; }
    [NullableContextAttribute("1")]
public ValueTuple`4(T1 item1, T2 item2, T3 item3, T4 item4);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`4<T1, T2, T3, T4> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`4<T1, T2, T3, T4> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private int GetHashCodeCore(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    [NullableContextAttribute("1")]
public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableContextAttribute("1")]
public class System.ValueTuple`5 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    public T5 Item5;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public ValueTuple`5(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`5<T1, T2, T3, T4, T5> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`5<T1, T2, T3, T4, T5> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private int GetHashCodeCore(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ValueTuple`6 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    public T5 Item5;
    public T6 Item6;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public ValueTuple`6(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`6<T1, T2, T3, T4, T5, T6> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`6<T1, T2, T3, T4, T5, T6> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private int GetHashCodeCore(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[NullableContextAttribute("1")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableAttribute("0")]
public class System.ValueTuple`7 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    public T5 Item5;
    public T6 Item6;
    public T7 Item7;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public ValueTuple`7(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private int GetHashCodeCore(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ValueTuple`8 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    public T5 Item5;
    public T6 Item6;
    public T7 Item7;
    [NullableAttribute("0")]
public TRest Rest;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public ValueTuple`8(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, TRest> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, TRest> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private int GetHashCodeCore(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableAttribute("0")]
[NullableContextAttribute("2")]
public abstract class System.ValueType : object {
    public virtual bool Equals(object obj);
    private static bool CanCompareBits(object obj);
    private static bool FastEqualsCheck(object a, object b);
    public virtual int GetHashCode();
    internal static int GetHashCodeOfPtr(IntPtr ptr);
    public virtual string ToString();
}
internal class System.Variant : ValueType {
    private object _objref;
    private long _data;
    private int _flags;
    internal static int CV_EMPTY;
    internal static int CV_VOID;
    internal static int CV_BOOLEAN;
    internal static int CV_CHAR;
    internal static int CV_I1;
    internal static int CV_U1;
    internal static int CV_I2;
    internal static int CV_U2;
    internal static int CV_I4;
    internal static int CV_U4;
    internal static int CV_I8;
    internal static int CV_U8;
    internal static int CV_R4;
    internal static int CV_R8;
    internal static int CV_STRING;
    internal static int CV_PTR;
    internal static int CV_DATETIME;
    internal static int CV_TIMESPAN;
    internal static int CV_OBJECT;
    internal static int CV_DECIMAL;
    internal static int CV_ENUM;
    internal static int CV_MISSING;
    internal static int CV_NULL;
    internal static int CV_LAST;
    internal static int TypeCodeBitMask;
    internal static int VTBitMask;
    internal static int VTBitShift;
    internal static int ArrayBitMask;
    internal static int EnumI1;
    internal static int EnumU1;
    internal static int EnumI2;
    internal static int EnumU2;
    internal static int EnumI4;
    internal static int EnumU4;
    internal static int EnumI8;
    internal static int EnumU8;
    internal static int EnumMask;
    internal static Type[] ClassTypes;
    internal static Variant Empty;
    internal static Variant Missing;
    internal static Variant DBNull;
    internal int CVType { get; }
    internal Variant(int flags, object or, long data);
    public Variant(bool val);
    public Variant(sbyte val);
    public Variant(byte val);
    public Variant(short val);
    public Variant(ushort val);
    public Variant(char val);
    public Variant(int val);
    public Variant(UInt32 val);
    public Variant(long val);
    public Variant(ulong val);
    public Variant(float val);
    public Variant(double val);
    public Variant(DateTime val);
    public Variant(decimal val);
    public Variant(object obj);
    private static Variant();
    internal void SetFieldsObject(object val);
    internal int get_CVType();
    public object ToObject();
    private object BoxEnum();
    internal static void MarshalHelperConvertObjectToVariant(object o, Variant& v);
    internal static object MarshalHelperConvertVariantToObject(Variant& v);
    internal static void MarshalHelperCastVariant(object pValue, int vt, Variant& v);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Version : object {
    private int _Major;
    private int _Minor;
    private int _Build;
    private int _Revision;
    public int Major { get; }
    public int Minor { get; }
    public int Build { get; }
    public int Revision { get; }
    public short MajorRevision { get; }
    public short MinorRevision { get; }
    private int DefaultFormatFieldCount { get; }
    public Version(int major, int minor, int build, int revision);
    public Version(int major, int minor, int build);
    public Version(int major, int minor);
    [NullableContextAttribute("1")]
public Version(string version);
    private Version(Version version);
    [NullableContextAttribute("1")]
public sealed virtual object Clone();
    public int get_Major();
    public int get_Minor();
    public int get_Build();
    public int get_Revision();
    public short get_MajorRevision();
    public short get_MinorRevision();
    public sealed virtual int CompareTo(object version);
    public sealed virtual int CompareTo(Version value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Version obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(int fieldCount);
    [NullableContextAttribute("0")]
public bool TryFormat(Span`1<char> destination, Int32& charsWritten);
    [NullableContextAttribute("0")]
public bool TryFormat(Span`1<char> destination, int fieldCount, Int32& charsWritten);
    private sealed virtual override bool System.ISpanFormattable.TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    private int get_DefaultFormatFieldCount();
    private StringBuilder ToCachedStringBuilder(int fieldCount);
    [NullableContextAttribute("1")]
public static Version Parse(string input);
    [NullableContextAttribute("0")]
public static Version Parse(ReadOnlySpan`1<char> input);
    public static bool TryParse(string input, Version& result);
    [NullableContextAttribute("0")]
public static bool TryParse(ReadOnlySpan`1<char> input, Version& result);
    private static Version ParseVersion(ReadOnlySpan`1<char> input, bool throwOnFailure);
    private static bool TryParseComponent(ReadOnlySpan`1<char> component, string componentName, bool throwOnFailure, Int32& parsedComponent);
    public static bool op_Equality(Version v1, Version v2);
    public static bool op_Inequality(Version v1, Version v2);
    public static bool op_LessThan(Version v1, Version v2);
    public static bool op_LessThanOrEqual(Version v1, Version v2);
    public static bool op_GreaterThan(Version v1, Version v2);
    public static bool op_GreaterThanOrEqual(Version v1, Version v2);
}
public class System.Void : ValueType {
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[NullableAttribute("0")]
[NullableContextAttribute("2")]
public class System.WeakReference : object {
    internal IntPtr m_handle;
    public bool IsAlive { get; }
    public bool TrackResurrection { get; }
    public object Target { get; public set; }
    public WeakReference(object target);
    public WeakReference(object target, bool trackResurrection);
    [NullableContextAttribute("1")]
protected WeakReference(SerializationInfo info, StreamingContext context);
    public virtual bool get_IsAlive();
    public virtual bool get_TrackResurrection();
    public virtual object get_Target();
    public virtual void set_Target(object value);
    protected virtual override void Finalize();
    private void Create(object target, bool trackResurrection);
    private bool IsTrackResurrection();
    [NullableContextAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.WeakReference`1 : object {
    internal IntPtr m_handle;
    private T Target { get; private set; }
    public WeakReference`1(T target);
    public WeakReference`1(T target, bool trackResurrection);
    internal WeakReference`1(SerializationInfo info, StreamingContext context);
    public void SetTarget(T target);
    private T get_Target();
    private void set_Target(T value);
    protected virtual override void Finalize();
    private void Create(T target, bool trackResurrection);
    private bool IsTrackResurrection();
    public bool TryGetTarget(T& target);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal enum Windows.Foundation.Diagnostics.AsyncCausalityStatus : Enum {
    public int value__;
    public static AsyncCausalityStatus Canceled;
    public static AsyncCausalityStatus Completed;
    public static AsyncCausalityStatus Error;
    public static AsyncCausalityStatus Started;
}
internal enum Windows.Foundation.Diagnostics.CausalityRelation : Enum {
    public int value__;
    public static CausalityRelation AssignDelegate;
    public static CausalityRelation Join;
    public static CausalityRelation Choice;
    public static CausalityRelation Cancel;
    public static CausalityRelation Error;
}
internal enum Windows.Foundation.Diagnostics.CausalitySource : Enum {
    public int value__;
    public static CausalitySource Application;
    public static CausalitySource Library;
    public static CausalitySource System;
}
internal enum Windows.Foundation.Diagnostics.CausalitySynchronousWork : Enum {
    public int value__;
    public static CausalitySynchronousWork CompletionNotification;
    public static CausalitySynchronousWork ProgressNotification;
    public static CausalitySynchronousWork Execution;
}
internal enum Windows.Foundation.Diagnostics.CausalityTraceLevel : Enum {
    public int value__;
    public static CausalityTraceLevel Required;
    public static CausalityTraceLevel Important;
    public static CausalityTraceLevel Verbose;
}
[GuidAttribute("50850B26-267E-451B-A890-AB6A370245EE")]
internal interface Windows.Foundation.Diagnostics.IAsyncCausalityTracerStatics {
    public abstract virtual void TraceOperationCreation(CausalityTraceLevel traceLevel, CausalitySource source, Guid platformId, ulong operationId, string operationName, ulong relatedContext);
    public abstract virtual void TraceOperationCompletion(CausalityTraceLevel traceLevel, CausalitySource source, Guid platformId, ulong operationId, AsyncCausalityStatus status);
    public abstract virtual void TraceOperationRelation(CausalityTraceLevel traceLevel, CausalitySource source, Guid platformId, ulong operationId, CausalityRelation relation);
    public abstract virtual void TraceSynchronousWorkStart(CausalityTraceLevel traceLevel, CausalitySource source, Guid platformId, ulong operationId, CausalitySynchronousWork work);
    public abstract virtual void TraceSynchronousWorkCompletion(CausalityTraceLevel traceLevel, CausalitySource source, CausalitySynchronousWork work);
    public abstract virtual EventRegistrationToken add_TracingStatusChanged(EventHandler`1<TracingStatusChangedEventArgs> eventHandler);
}
[GuidAttribute("410B7711-FF3B-477F-9C9A-D2EFDA302DC3")]
internal interface Windows.Foundation.Diagnostics.ITracingStatusChangedEventArgs {
    public bool Enabled { get; }
    public CausalityTraceLevel TraceLevel { get; }
    public abstract virtual bool get_Enabled();
    public abstract virtual CausalityTraceLevel get_TraceLevel();
}
[GuidAttribute("410B7711-FF3B-477F-9C9A-D2EFDA302DC3")]
internal class Windows.Foundation.Diagnostics.TracingStatusChangedEventArgs : object {
    public bool Enabled { get; }
    public CausalityTraceLevel TraceLevel { get; }
    public sealed virtual bool get_Enabled();
    public sealed virtual CausalityTraceLevel get_TraceLevel();
}
