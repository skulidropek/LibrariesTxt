internal static class FxResources.System.IO.Compression.SR : object {
}
internal static class Interop : object {
}
internal enum System.IO.Compression.BlockType : Enum {
    public int value__;
    public static BlockType Uncompressed;
    public static BlockType Static;
    public static BlockType Dynamic;
}
internal class System.IO.Compression.CheckSumAndSizeWriteStream : Stream {
    private Stream _baseStream;
    private Stream _baseBaseStream;
    private long _position;
    private UInt32 _checksum;
    private bool _leaveOpenOnClose;
    private bool _canWrite;
    private bool _isDisposed;
    private bool _everWritten;
    private long _initialPosition;
    private ZipArchiveEntry _zipArchiveEntry;
    private EventHandler _onClose;
    private Action`6<long, long, UInt32, Stream, ZipArchiveEntry, EventHandler> _saveCrcAndSizes;
    public long Length { get; }
    public long Position { get; public set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public CheckSumAndSizeWriteStream(Stream baseStream, Stream baseBaseStream, bool leaveOpenOnClose, ZipArchiveEntry entry, EventHandler onClose, Action`6<long, long, UInt32, Stream, ZipArchiveEntry, EventHandler> saveCrcAndSizes);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    private void ThrowIfDisposed();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    protected virtual void Dispose(bool disposing);
    public virtual void Write(ReadOnlySpan`1<byte> source);
}
public enum System.IO.Compression.CompressionLevel : Enum {
    public int value__;
    public static CompressionLevel Optimal;
    public static CompressionLevel Fastest;
    public static CompressionLevel NoCompression;
}
public enum System.IO.Compression.CompressionMode : Enum {
    public int value__;
    public static CompressionMode Decompress;
    public static CompressionMode Compress;
}
internal static class System.IO.Compression.Crc32Helper : object {
    public static UInt32 UpdateCrc32(UInt32 crc32, Byte[] buffer, int offset, int length);
    public static UInt32 UpdateCrc32(UInt32 crc32, ReadOnlySpan`1<byte> buffer);
}
internal class System.IO.Compression.DeflateManagedStream : Stream {
    private Stream _stream;
    private bool _leaveOpen;
    private InflaterManaged _inflater;
    private Byte[] _buffer;
    private int _asyncOperations;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal DeflateManagedStream(Stream stream, CompressionMethodValues method, long uncompressedSize);
    internal void InitializeInflater(Stream stream, bool leaveOpen, IFileFormatReader reader, CompressionMethodValues method, long uncompressedSize);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] array, int offset, int count);
    private void ValidateParameters(Byte[] array, int offset, int count);
    private void EnsureNotDisposed();
    private static void ThrowStreamClosedException();
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual Task`1<int> ReadAsync(Byte[] array, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.Compression.DeflateManagedStream/<ReadAsyncCore>d__30")]
private Task`1<int> ReadAsyncCore(Task`1<int> readTask, Byte[] array, int offset, int count, CancellationToken cancellationToken);
    public virtual void Write(Byte[] array, int offset, int count);
    private void PurgeBuffers(bool disposing);
    protected virtual void Dispose(bool disposing);
}
internal class System.IO.Compression.Deflater : object {
    private ZLibStreamHandle _zlibStream;
    private MemoryHandle _inputBufferHandle;
    private bool _isDisposed;
    private object SyncLock { get; }
    internal Deflater(CompressionLevel compressionLevel, int windowBits);
    private object get_SyncLock();
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    public bool NeedsInput();
    internal void SetInput(ReadOnlyMemory`1<byte> inputBuffer);
    internal void SetInput(Byte* inputBufferPtr, int count);
    internal int GetDeflateOutput(Byte[] outputBuffer);
    private ErrorCode ReadDeflateOutput(Byte[] outputBuffer, FlushCode flushCode, Int32& bytesRead);
    internal bool Finish(Byte[] outputBuffer, Int32& bytesRead);
    internal bool Flush(Byte[] outputBuffer, Int32& bytesRead);
    private void DeallocateInputBufferHandle();
    private void DeflateInit(CompressionLevel compressionLevel, int windowBits, int memLevel, CompressionStrategy strategy);
    private ErrorCode Deflate(FlushCode flushCode);
}
public class System.IO.Compression.DeflateStream : Stream {
    private Stream _stream;
    private CompressionMode _mode;
    private bool _leaveOpen;
    private Inflater _inflater;
    private Deflater _deflater;
    private Byte[] _buffer;
    private int _activeAsyncOperation;
    private bool _wroteBytes;
    public Stream BaseStream { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    private bool AsyncOperationIsActive { get; }
    internal DeflateStream(Stream stream, CompressionMode mode, long uncompressedSize);
    public DeflateStream(Stream stream, CompressionMode mode);
    public DeflateStream(Stream stream, CompressionMode mode, bool leaveOpen);
    public DeflateStream(Stream stream, CompressionLevel compressionLevel);
    public DeflateStream(Stream stream, CompressionLevel compressionLevel, bool leaveOpen);
    internal DeflateStream(Stream stream, CompressionMode mode, bool leaveOpen, int windowBits, long uncompressedSize);
    internal DeflateStream(Stream stream, CompressionLevel compressionLevel, bool leaveOpen, int windowBits);
    internal void InitializeInflater(Stream stream, bool leaveOpen, int windowBits, long uncompressedSize);
    internal void InitializeDeflater(Stream stream, bool leaveOpen, int windowBits, CompressionLevel compressionLevel);
    private void InitializeBuffer();
    private void EnsureBufferInitialized();
    public Stream get_BaseStream();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.Compression.DeflateStream/<FlushAsyncCore>d__35")]
private Task FlushAsyncCore(CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int ReadByte();
    public virtual int Read(Byte[] array, int offset, int count);
    public virtual int Read(Span`1<byte> buffer);
    internal int ReadCore(Span`1<byte> buffer);
    private void ValidateParameters(Byte[] array, int offset, int count);
    private void EnsureNotDisposed();
    private static void ThrowStreamClosedException();
    private void EnsureDecompressionMode();
    private static void ThrowCannotReadFromDeflateStreamException();
    private void EnsureCompressionMode();
    private static void ThrowCannotWriteToDeflateStreamException();
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual Task`1<int> ReadAsync(Byte[] array, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    internal ValueTask`1<int> ReadAsyncMemory(Memory`1<byte> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.Compression.DeflateStream/<FinishReadAsyncMemory>d__54")]
private ValueTask`1<int> FinishReadAsyncMemory(ValueTask`1<int> readTask, Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual void Write(Byte[] array, int offset, int count);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    internal void WriteCore(ReadOnlySpan`1<byte> buffer);
    private void WriteDeflaterOutput();
    private void FlushBuffers();
    private void PurgeBuffers(bool disposing);
    [AsyncStateMachineAttribute("System.IO.Compression.DeflateStream/<PurgeBuffersAsync>d__61")]
private Task PurgeBuffersAsync();
    protected virtual void Dispose(bool disposing);
    public virtual ValueTask DisposeAsync();
    [AsyncStateMachineAttribute("System.IO.Compression.DeflateStream/<DisposeAsyncCore>d__64")]
private ValueTask DisposeAsyncCore();
    public virtual IAsyncResult BeginWrite(Byte[] array, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual Task WriteAsync(Byte[] array, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    internal ValueTask WriteAsyncMemory(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.Compression.DeflateStream/<WriteAsyncMemoryCore>d__70")]
private Task WriteAsyncMemoryCore(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.Compression.DeflateStream/<WriteDeflaterOutputAsync>d__71")]
private Task WriteDeflaterOutputAsync(CancellationToken cancellationToken);
    public virtual void CopyTo(Stream destination, int bufferSize);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    private bool get_AsyncOperationIsActive();
    private void EnsureNoActiveAsyncOperation();
    private void AsyncOperationStarting();
    private void AsyncOperationCompleting();
    private static void ThrowInvalidBeginCall();
}
public class System.IO.Compression.GZipStream : Stream {
    private DeflateStream _deflateStream;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public Stream BaseStream { get; }
    public GZipStream(Stream stream, CompressionMode mode);
    public GZipStream(Stream stream, CompressionMode mode, bool leaveOpen);
    public GZipStream(Stream stream, CompressionLevel compressionLevel);
    public GZipStream(Stream stream, CompressionLevel compressionLevel, bool leaveOpen);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int ReadByte();
    public virtual IAsyncResult BeginRead(Byte[] array, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual int Read(Byte[] array, int offset, int count);
    public virtual int Read(Span`1<byte> buffer);
    public virtual IAsyncResult BeginWrite(Byte[] array, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Write(Byte[] array, int offset, int count);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual void CopyTo(Stream destination, int bufferSize);
    protected virtual void Dispose(bool disposing);
    public virtual ValueTask DisposeAsync();
    public Stream get_BaseStream();
    public virtual Task`1<int> ReadAsync(Byte[] array, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual Task WriteAsync(Byte[] array, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    private void CheckDeflateStream();
    private static void ThrowStreamClosedException();
}
internal class System.IO.Compression.HuffmanTree : object {
    private int _tableBits;
    private Int16[] _table;
    private Int16[] _left;
    private Int16[] _right;
    private Byte[] _codeLengthArray;
    private int _tableMask;
    [CompilerGeneratedAttribute]
private static HuffmanTree <StaticLiteralLengthTree>k__BackingField;
    [CompilerGeneratedAttribute]
private static HuffmanTree <StaticDistanceTree>k__BackingField;
    public static HuffmanTree StaticLiteralLengthTree { get; }
    public static HuffmanTree StaticDistanceTree { get; }
    public HuffmanTree(Byte[] codeLengths);
    private static HuffmanTree();
    [CompilerGeneratedAttribute]
public static HuffmanTree get_StaticLiteralLengthTree();
    [CompilerGeneratedAttribute]
public static HuffmanTree get_StaticDistanceTree();
    private static Byte[] GetStaticLiteralTreeLength();
    private static Byte[] GetStaticDistanceTreeLength();
    private static UInt32 BitReverse(UInt32 code, int length);
    private UInt32[] CalculateHuffmanCode();
    private void CreateTable();
    public int GetNextSymbol(InputBuffer input);
}
internal interface System.IO.Compression.IFileFormatReader {
    public abstract virtual bool ReadHeader(InputBuffer input);
    public abstract virtual bool ReadFooter(InputBuffer input);
    public abstract virtual void UpdateWithBytesRead(Byte[] buffer, int offset, int bytesToCopy);
    public abstract virtual void Validate();
}
internal class System.IO.Compression.Inflater : object {
    private bool _finished;
    private bool _isDisposed;
    private int _windowBits;
    private ZLibStreamHandle _zlibStream;
    private GCHandle _inputBufferHandle;
    private long _uncompressedSize;
    private long _currentInflatedCount;
    private object SyncLock { get; }
    internal Inflater(int windowBits, long uncompressedSize);
    private object get_SyncLock();
    public bool Finished();
    public bool Inflate(Byte& b);
    public int Inflate(Byte[] bytes, int offset, int length);
    public int Inflate(Span`1<byte> destination);
    public int InflateVerified(Byte* bufPtr, int length);
    private void ReadOutput(Byte* bufPtr, int length, Int32& bytesRead);
    private bool ResetStreamForLeftoverInput();
    internal bool IsGzipStream();
    public bool NeedsInput();
    public void SetInput(Byte[] inputBuffer, int startIndex, int count);
    private void Dispose(bool disposing);
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    private void InflateInit(int windowBits);
    private ErrorCode ReadInflateOutput(Byte* bufPtr, int length, FlushCode flushCode, Int32& bytesRead);
    private ErrorCode Inflate(FlushCode flushCode);
    private void DeallocateInputBufferHandle();
}
internal class System.IO.Compression.InflaterManaged : object {
    private static Byte[] s_extraLengthBits;
    private static Int32[] s_lengthBase;
    private static Int32[] s_distanceBasePosition;
    private static Byte[] s_codeOrder;
    private static Byte[] s_staticDistanceTreeTable;
    private OutputWindow _output;
    private InputBuffer _input;
    private HuffmanTree _literalLengthTree;
    private HuffmanTree _distanceTree;
    private InflaterState _state;
    private bool _hasFormatReader;
    private int _bfinal;
    private BlockType _blockType;
    private Byte[] _blockLengthBuffer;
    private int _blockLength;
    private int _length;
    private int _distanceCode;
    private int _extraBits;
    private int _loopCounter;
    private int _literalLengthCodeCount;
    private int _distanceCodeCount;
    private int _codeLengthCodeCount;
    private int _codeArraySize;
    private int _lengthCode;
    private Byte[] _codeList;
    private Byte[] _codeLengthTreeCodeLength;
    private bool _deflate64;
    private HuffmanTree _codeLengthTree;
    private long _uncompressedSize;
    private long _currentInflatedCount;
    private IFileFormatReader _formatReader;
    internal InflaterManaged(IFileFormatReader reader, bool deflate64, long uncompressedSize);
    private static InflaterManaged();
    private void Reset();
    public void SetInput(Byte[] inputBytes, int offset, int length);
    public bool Finished();
    public int Inflate(Byte[] bytes, int offset, int length);
    private bool Decode();
    private bool DecodeUncompressedBlock(Boolean& end_of_block);
    private bool DecodeBlock(Boolean& end_of_block_code_seen);
    private bool DecodeDynamicBlockHeader();
    public void Dispose();
}
internal enum System.IO.Compression.InflaterState : Enum {
    public int value__;
    public static InflaterState ReadingHeader;
    public static InflaterState ReadingBFinal;
    public static InflaterState ReadingBType;
    public static InflaterState ReadingNumLitCodes;
    public static InflaterState ReadingNumDistCodes;
    public static InflaterState ReadingNumCodeLengthCodes;
    public static InflaterState ReadingCodeLengthCodes;
    public static InflaterState ReadingTreeCodesBefore;
    public static InflaterState ReadingTreeCodesAfter;
    public static InflaterState DecodeTop;
    public static InflaterState HaveInitialLength;
    public static InflaterState HaveFullLength;
    public static InflaterState HaveDistCode;
    public static InflaterState UncompressedAligning;
    public static InflaterState UncompressedByte1;
    public static InflaterState UncompressedByte2;
    public static InflaterState UncompressedByte3;
    public static InflaterState UncompressedByte4;
    public static InflaterState DecodingUncompressed;
    public static InflaterState StartReadingFooter;
    public static InflaterState ReadingFooter;
    public static InflaterState VerifyingFooter;
    public static InflaterState Done;
}
internal class System.IO.Compression.InputBuffer : object {
    private Byte[] _buffer;
    private int _start;
    private int _end;
    private UInt32 _bitBuffer;
    private int _bitsInBuffer;
    public int AvailableBits { get; }
    public int AvailableBytes { get; }
    public int get_AvailableBits();
    public int get_AvailableBytes();
    public bool EnsureBitsAvailable(int count);
    public UInt32 TryLoad16Bits();
    private UInt32 GetBitMask(int count);
    public int GetBits(int count);
    public int CopyTo(Byte[] output, int offset, int length);
    public bool NeedsInput();
    public void SetInput(Byte[] buffer, int offset, int length);
    public void SkipBits(int n);
    public void SkipToByteBoundary();
}
internal class System.IO.Compression.OutputWindow : object {
    private Byte[] _window;
    private int _end;
    private int _bytesUsed;
    public int FreeBytes { get; }
    public int AvailableBytes { get; }
    internal void ClearBytesUsed();
    public void Write(byte b);
    public void WriteLengthDistance(int length, int distance);
    public int CopyFrom(InputBuffer input, int length);
    public int get_FreeBytes();
    public int get_AvailableBytes();
    public int CopyTo(Byte[] output, int offset, int length);
}
internal class System.IO.Compression.PositionPreservingWriteOnlyStreamWrapper : Stream {
    private Stream _stream;
    private long _position;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Position { get; public set; }
    public bool CanTimeout { get; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public long Length { get; }
    public PositionPreservingWriteOnlyStreamWrapper(Stream stream);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void WriteByte(byte value);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual bool get_CanTimeout();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public virtual long get_Length();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
}
internal class System.IO.Compression.SubReadStream : Stream {
    private long _startInSuperStream;
    private long _positionInSuperStream;
    private long _endInSuperStream;
    private Stream _superStream;
    private bool _canRead;
    private bool _isDisposed;
    public long Length { get; }
    public long Position { get; public set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public SubReadStream(Stream superStream, long startPosition, long maxLength);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    private void ThrowIfDisposed();
    private void ThrowIfCantRead();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    protected virtual void Dispose(bool disposing);
    public virtual int Read(Span`1<byte> destination);
}
internal class System.IO.Compression.WrappedStream : Stream {
    private Stream _baseStream;
    private bool _closeBaseStream;
    private Action`1<ZipArchiveEntry> _onClosed;
    private ZipArchiveEntry _zipArchiveEntry;
    private bool _isDisposed;
    public long Length { get; }
    public long Position { get; public set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    internal WrappedStream(Stream baseStream, bool closeBaseStream);
    private WrappedStream(Stream baseStream, bool closeBaseStream, ZipArchiveEntry entry, Action`1<ZipArchiveEntry> onClosed);
    internal WrappedStream(Stream baseStream, ZipArchiveEntry entry, Action`1<ZipArchiveEntry> onClosed);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    private void ThrowIfDisposed();
    private void ThrowIfCantRead();
    private void ThrowIfCantWrite();
    private void ThrowIfCantSeek();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    protected virtual void Dispose(bool disposing);
    public virtual void Write(ReadOnlySpan`1<byte> source);
}
internal class System.IO.Compression.Zip64EndOfCentralDirectoryLocator : ValueType {
    public UInt32 NumberOfDiskWithZip64EOCD;
    public ulong OffsetOfZip64EOCD;
    public UInt32 TotalNumberOfDisks;
    public static bool TryReadBlock(BinaryReader reader, Zip64EndOfCentralDirectoryLocator& zip64EOCDLocator);
    public static void WriteBlock(Stream stream, long zip64EOCDRecordStart);
}
internal class System.IO.Compression.Zip64EndOfCentralDirectoryRecord : ValueType {
    public ulong SizeOfThisRecord;
    public ushort VersionMadeBy;
    public ushort VersionNeededToExtract;
    public UInt32 NumberOfThisDisk;
    public UInt32 NumberOfDiskWithStartOfCD;
    public ulong NumberOfEntriesOnThisDisk;
    public ulong NumberOfEntriesTotal;
    public ulong SizeOfCentralDirectory;
    public ulong OffsetOfCentralDirectory;
    public static bool TryReadBlock(BinaryReader reader, Zip64EndOfCentralDirectoryRecord& zip64EOCDRecord);
    public static void WriteBlock(Stream stream, long numberOfEntries, long startOfCentralDirectory, long sizeOfCentralDirectory);
}
internal class System.IO.Compression.Zip64ExtraField : ValueType {
    private ushort _size;
    private Nullable`1<long> _uncompressedSize;
    private Nullable`1<long> _compressedSize;
    private Nullable`1<long> _localHeaderOffset;
    private Nullable`1<int> _startDiskNumber;
    public ushort TotalSize { get; }
    public Nullable`1<long> UncompressedSize { get; public set; }
    public Nullable`1<long> CompressedSize { get; public set; }
    public Nullable`1<long> LocalHeaderOffset { get; public set; }
    public Nullable`1<int> StartDiskNumber { get; }
    public ushort get_TotalSize();
    public Nullable`1<long> get_UncompressedSize();
    public void set_UncompressedSize(Nullable`1<long> value);
    public Nullable`1<long> get_CompressedSize();
    public void set_CompressedSize(Nullable`1<long> value);
    public Nullable`1<long> get_LocalHeaderOffset();
    public void set_LocalHeaderOffset(Nullable`1<long> value);
    public Nullable`1<int> get_StartDiskNumber();
    private void UpdateSize();
    public static Zip64ExtraField GetJustZip64Block(Stream extraFieldStream, bool readUncompressedSize, bool readCompressedSize, bool readLocalHeaderOffset, bool readStartDiskNumber);
    private static bool TryGetZip64BlockFromGenericExtraField(ZipGenericExtraField extraField, bool readUncompressedSize, bool readCompressedSize, bool readLocalHeaderOffset, bool readStartDiskNumber, Zip64ExtraField& zip64Block);
    public static Zip64ExtraField GetAndRemoveZip64Block(List`1<ZipGenericExtraField> extraFields, bool readUncompressedSize, bool readCompressedSize, bool readLocalHeaderOffset, bool readStartDiskNumber);
    public static void RemoveZip64Blocks(List`1<ZipGenericExtraField> extraFields);
    public void WriteBlock(Stream stream);
}
public class System.IO.Compression.ZipArchive : object {
    private Stream _archiveStream;
    private ZipArchiveEntry _archiveStreamOwner;
    private BinaryReader _archiveReader;
    private ZipArchiveMode _mode;
    private List`1<ZipArchiveEntry> _entries;
    private ReadOnlyCollection`1<ZipArchiveEntry> _entriesCollection;
    private Dictionary`2<string, ZipArchiveEntry> _entriesDictionary;
    private bool _readEntries;
    private bool _leaveOpen;
    private long _centralDirectoryStart;
    private bool _isDisposed;
    private UInt32 _numberOfThisDisk;
    private long _expectedNumberOfEntries;
    private Stream _backingStream;
    private Byte[] _archiveComment;
    private Encoding _entryNameEncoding;
    public ReadOnlyCollection`1<ZipArchiveEntry> Entries { get; }
    public ZipArchiveMode Mode { get; }
    internal BinaryReader ArchiveReader { get; }
    internal Stream ArchiveStream { get; }
    internal UInt32 NumberOfThisDisk { get; }
    internal Encoding EntryNameEncoding { get; private set; }
    public ZipArchive(Stream stream);
    public ZipArchive(Stream stream, ZipArchiveMode mode);
    public ZipArchive(Stream stream, ZipArchiveMode mode, bool leaveOpen);
    public ZipArchive(Stream stream, ZipArchiveMode mode, bool leaveOpen, Encoding entryNameEncoding);
    public ReadOnlyCollection`1<ZipArchiveEntry> get_Entries();
    public ZipArchiveMode get_Mode();
    public ZipArchiveEntry CreateEntry(string entryName);
    public ZipArchiveEntry CreateEntry(string entryName, CompressionLevel compressionLevel);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    public ZipArchiveEntry GetEntry(string entryName);
    internal BinaryReader get_ArchiveReader();
    internal Stream get_ArchiveStream();
    internal UInt32 get_NumberOfThisDisk();
    internal Encoding get_EntryNameEncoding();
    private void set_EntryNameEncoding(Encoding value);
    private ZipArchiveEntry DoCreateEntry(string entryName, Nullable`1<CompressionLevel> compressionLevel);
    internal void AcquireArchiveStream(ZipArchiveEntry entry);
    private void AddEntry(ZipArchiveEntry entry);
    internal void ReleaseArchiveStream(ZipArchiveEntry entry);
    internal void RemoveEntry(ZipArchiveEntry entry);
    internal void ThrowIfDisposed();
    private void CloseStreams();
    private void EnsureCentralDirectoryRead();
    private void Init(Stream stream, ZipArchiveMode mode, bool leaveOpen);
    private void ReadCentralDirectory();
    private void ReadEndOfCentralDirectory();
    private void TryReadZip64EndOfCentralDirectory(ZipEndOfCentralDirectoryBlock eocd, long eocdStart);
    private void WriteFile();
    private void WriteArchiveEpilogue(long startOfCentralDirectory, long sizeOfCentralDirectory);
}
public class System.IO.Compression.ZipArchiveEntry : object {
    private ZipArchive _archive;
    private bool _originallyInArchive;
    private int _diskNumberStart;
    private ZipVersionMadeByPlatform _versionMadeByPlatform;
    private ZipVersionNeededValues _versionMadeBySpecification;
    internal ZipVersionNeededValues _versionToExtract;
    private BitFlagValues _generalPurposeBitFlag;
    private CompressionMethodValues _storedCompressionMethod;
    private DateTimeOffset _lastModified;
    private long _compressedSize;
    private long _uncompressedSize;
    private long _offsetOfLocalHeader;
    private Nullable`1<long> _storedOffsetOfCompressedData;
    private UInt32 _crc32;
    private Byte[][] _compressedBytes;
    private MemoryStream _storedUncompressedData;
    private bool _currentlyOpenForWrite;
    private bool _everOpenedForWrite;
    private Stream _outstandingWriteStream;
    private UInt32 _externalFileAttr;
    private string _storedEntryName;
    private Byte[] _storedEntryNameBytes;
    private List`1<ZipGenericExtraField> _cdUnknownExtraFields;
    private List`1<ZipGenericExtraField> _lhUnknownExtraFields;
    private Byte[] _fileComment;
    private Nullable`1<CompressionLevel> _compressionLevel;
    private static bool s_allowLargeZipArchiveEntriesInUpdateMode;
    public ZipArchive Archive { get; }
    [CLSCompliantAttribute("False")]
public UInt32 Crc32 { get; }
    public long CompressedLength { get; }
    public int ExternalAttributes { get; public set; }
    public string FullName { get; private set; }
    public DateTimeOffset LastWriteTime { get; public set; }
    public long Length { get; }
    public string Name { get; }
    internal bool EverOpenedForWrite { get; }
    private long OffsetOfCompressedData { get; }
    private MemoryStream UncompressedData { get; }
    private CompressionMethodValues CompressionMethod { get; private set; }
    internal ZipArchiveEntry(ZipArchive archive, ZipCentralDirectoryFileHeader cd);
    internal ZipArchiveEntry(ZipArchive archive, string entryName, CompressionLevel compressionLevel);
    internal ZipArchiveEntry(ZipArchive archive, string entryName);
    private static ZipArchiveEntry();
    public ZipArchive get_Archive();
    public UInt32 get_Crc32();
    public long get_CompressedLength();
    public int get_ExternalAttributes();
    public void set_ExternalAttributes(int value);
    public string get_FullName();
    private void set_FullName(string value);
    public DateTimeOffset get_LastWriteTime();
    public void set_LastWriteTime(DateTimeOffset value);
    public long get_Length();
    public string get_Name();
    public void Delete();
    public Stream Open();
    public virtual string ToString();
    internal bool get_EverOpenedForWrite();
    private long get_OffsetOfCompressedData();
    private MemoryStream get_UncompressedData();
    private CompressionMethodValues get_CompressionMethod();
    private void set_CompressionMethod(CompressionMethodValues value);
    private string DecodeEntryName(Byte[] entryNameBytes);
    private Byte[] EncodeEntryName(string entryName, Boolean& isUTF8);
    internal void WriteAndFinishLocalEntry();
    internal void WriteCentralDirectoryFileHeader();
    internal bool LoadLocalHeaderExtraFieldAndCompressedBytesIfNeeded();
    internal void ThrowIfNotOpenable(bool needToUncompress, bool needToLoadIntoMemory);
    private CheckSumAndSizeWriteStream GetDataCompressor(Stream backingStream, bool leaveBackingStreamOpen, EventHandler onClose);
    private Stream GetDataDecompressor(Stream compressedStreamToRead);
    private Stream OpenInReadMode(bool checkOpenable);
    private Stream OpenInWriteMode();
    private Stream OpenInUpdateMode();
    private bool IsOpenable(bool needToUncompress, bool needToLoadIntoMemory, String& message);
    private bool SizesTooLarge();
    private bool WriteLocalFileHeader(bool isEmptyFile);
    private void WriteLocalFileHeaderAndDataIfNeeded();
    private void WriteCrcAndSizesInLocalHeader(bool zip64HeaderUsed);
    private void WriteDataDescriptor();
    private void UnloadStreams();
    private void CloseStreams();
    private void VersionToExtractAtLeast(ZipVersionNeededValues value);
    private void ThrowIfInvalidArchive();
    private static string GetFileName_Windows(string path);
    private static string GetFileName_Unix(string path);
    internal static string ParseFileName(string path, ZipVersionMadeByPlatform madeByPlatform);
}
public enum System.IO.Compression.ZipArchiveMode : Enum {
    public int value__;
    public static ZipArchiveMode Read;
    public static ZipArchiveMode Create;
    public static ZipArchiveMode Update;
}
internal class System.IO.Compression.ZipCentralDirectoryFileHeader : ValueType {
    public byte VersionMadeByCompatibility;
    public byte VersionMadeBySpecification;
    public ushort VersionNeededToExtract;
    public ushort GeneralPurposeBitFlag;
    public ushort CompressionMethod;
    public UInt32 LastModified;
    public UInt32 Crc32;
    public long CompressedSize;
    public long UncompressedSize;
    public ushort FilenameLength;
    public ushort ExtraFieldLength;
    public ushort FileCommentLength;
    public int DiskNumberStart;
    public ushort InternalFileAttributes;
    public UInt32 ExternalFileAttributes;
    public long RelativeOffsetOfLocalHeader;
    public Byte[] Filename;
    public Byte[] FileComment;
    public List`1<ZipGenericExtraField> ExtraFields;
    public static bool TryReadBlock(BinaryReader reader, bool saveExtraFieldsAndComments, ZipCentralDirectoryFileHeader& header);
}
internal class System.IO.Compression.ZipEndOfCentralDirectoryBlock : ValueType {
    public UInt32 Signature;
    public ushort NumberOfThisDisk;
    public ushort NumberOfTheDiskWithTheStartOfTheCentralDirectory;
    public ushort NumberOfEntriesInTheCentralDirectoryOnThisDisk;
    public ushort NumberOfEntriesInTheCentralDirectory;
    public UInt32 SizeOfCentralDirectory;
    public UInt32 OffsetOfStartOfCentralDirectoryWithRespectToTheStartingDiskNumber;
    public Byte[] ArchiveComment;
    public static void WriteBlock(Stream stream, long numberOfEntries, long startOfCentralDirectory, long sizeOfCentralDirectory, Byte[] archiveComment);
    public static bool TryReadBlock(BinaryReader reader, ZipEndOfCentralDirectoryBlock& eocdBlock);
}
internal class System.IO.Compression.ZipGenericExtraField : ValueType {
    private ushort _tag;
    private ushort _size;
    private Byte[] _data;
    public ushort Tag { get; }
    public ushort Size { get; }
    public Byte[] Data { get; }
    public ushort get_Tag();
    public ushort get_Size();
    public Byte[] get_Data();
    public void WriteBlock(Stream stream);
    public static bool TryReadBlock(BinaryReader reader, long endExtraField, ZipGenericExtraField& field);
    public static List`1<ZipGenericExtraField> ParseExtraField(Stream extraFieldData);
    public static int TotalSize(List`1<ZipGenericExtraField> fields);
    public static void WriteAllBlocks(List`1<ZipGenericExtraField> fields, Stream stream);
}
[ExtensionAttribute]
internal static class System.IO.Compression.ZipHelper : object {
    private static DateTime s_invalidDateIndicator;
    private static ZipHelper();
    internal static bool RequiresUnicode(string test);
    internal static void ReadBytes(Stream stream, Byte[] buffer, int bytesToRead);
    internal static DateTime DosTimeToDateTime(UInt32 dateTime);
    internal static UInt32 DateTimeToDosTime(DateTime dateTime);
    internal static bool SeekBackwardsToSignature(Stream stream, UInt32 signatureToFind, int maxBytesToRead);
    [ExtensionAttribute]
internal static void AdvanceToPosition(Stream stream, long position);
    private static bool SeekBackwardsAndRead(Stream stream, Byte[] buffer, Int32& bufferPointer);
}
[IsReadOnlyAttribute]
internal class System.IO.Compression.ZipLocalFileHeader : ValueType {
    public static List`1<ZipGenericExtraField> GetExtraFields(BinaryReader reader);
    public static bool TrySkipBlock(BinaryReader reader);
}
internal enum System.IO.Compression.ZipVersionMadeByPlatform : Enum {
    public byte value__;
    public static ZipVersionMadeByPlatform Windows;
    public static ZipVersionMadeByPlatform Unix;
}
internal enum System.IO.Compression.ZipVersionNeededValues : Enum {
    public ushort value__;
    public static ZipVersionNeededValues Default;
    public static ZipVersionNeededValues ExplicitDirectory;
    public static ZipVersionNeededValues Deflate;
    public static ZipVersionNeededValues Deflate64;
    public static ZipVersionNeededValues Zip64;
}
[TypeForwardedFromAttribute("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.IO.Compression.ZLibException : IOException {
    private string _zlibErrorContext;
    private string _zlibErrorMessage;
    private ErrorCode _zlibErrorCode;
    public ZLibException(string message, string zlibErrorContext, int zlibErrorCode, string zlibErrorMessage);
    public ZLibException(string message, Exception innerException);
    protected ZLibException(SerializationInfo info, StreamingContext context);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo si, StreamingContext context);
}
internal static class System.IO.Compression.ZLibNative : object {
    internal static IntPtr ZNullPtr;
    private static ZLibNative();
    public static ErrorCode CreateZLibStreamForDeflate(ZLibStreamHandle& zLibStreamHandle, CompressionLevel level, int windowBits, int memLevel, CompressionStrategy strategy);
    public static ErrorCode CreateZLibStreamForInflate(ZLibStreamHandle& zLibStreamHandle, int windowBits);
}
internal static class System.IO.StreamHelpers : object {
    public static void ValidateCopyToArgs(Stream source, Stream destination, int bufferSize);
}
internal static class System.SR : object {
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string ArgumentOutOfRange_Enum { get; }
    internal static string ArgumentOutOfRange_NeedPosNum { get; }
    internal static string CannotReadFromDeflateStream { get; }
    internal static string CannotWriteToDeflateStream { get; }
    internal static string GenericInvalidData { get; }
    internal static string InvalidArgumentOffsetCount { get; }
    internal static string InvalidBeginCall { get; }
    internal static string InvalidBlockLength { get; }
    internal static string InvalidHuffmanData { get; }
    internal static string NotSupported { get; }
    internal static string NotSupported_UnreadableStream { get; }
    internal static string NotSupported_UnwritableStream { get; }
    internal static string ObjectDisposed_StreamClosed { get; }
    internal static string UnknownBlockType { get; }
    internal static string UnknownState { get; }
    internal static string ZLibErrorDLLLoadError { get; }
    internal static string ZLibErrorInconsistentStream { get; }
    internal static string ZLibErrorIncorrectInitParameters { get; }
    internal static string ZLibErrorNotEnoughMemory { get; }
    internal static string ZLibErrorVersionMismatch { get; }
    internal static string ZLibErrorUnexpected { get; }
    internal static string ArgumentNeedNonNegative { get; }
    internal static string CannotBeEmpty { get; }
    internal static string CDCorrupt { get; }
    internal static string CentralDirectoryInvalid { get; }
    internal static string CreateInReadMode { get; }
    internal static string CreateModeCapabilities { get; }
    internal static string CreateModeCreateEntryWhileOpen { get; }
    internal static string CreateModeWriteOnceAndOneEntryAtATime { get; }
    internal static string DateTimeOutOfRange { get; }
    internal static string DeletedEntry { get; }
    internal static string DeleteOnlyInUpdate { get; }
    internal static string DeleteOpenEntry { get; }
    internal static string EntriesInCreateMode { get; }
    internal static string EntryNameEncodingNotSupported { get; }
    internal static string EntryNamesTooLong { get; }
    internal static string EntryTooLarge { get; }
    internal static string EOCDNotFound { get; }
    internal static string FieldTooBigCompressedSize { get; }
    internal static string FieldTooBigLocalHeaderOffset { get; }
    internal static string FieldTooBigNumEntries { get; }
    internal static string FieldTooBigOffsetToCD { get; }
    internal static string FieldTooBigOffsetToZip64EOCD { get; }
    internal static string FieldTooBigStartDiskNumber { get; }
    internal static string FieldTooBigUncompressedSize { get; }
    internal static string FrozenAfterWrite { get; }
    internal static string HiddenStreamName { get; }
    internal static string LengthAfterWrite { get; }
    internal static string LocalFileHeaderCorrupt { get; }
    internal static string NumEntriesWrong { get; }
    internal static string OffsetLengthInvalid { get; }
    internal static string ReadingNotSupported { get; }
    internal static string ReadModeCapabilities { get; }
    internal static string ReadOnlyArchive { get; }
    internal static string SeekingNotSupported { get; }
    internal static string SetLengthRequiresSeekingAndWriting { get; }
    internal static string SplitSpanned { get; }
    internal static string UnexpectedEndOfStream { get; }
    internal static string UnsupportedCompression { get; }
    internal static string UnsupportedCompressionMethod { get; }
    internal static string UpdateModeCapabilities { get; }
    internal static string UpdateModeOneStream { get; }
    internal static string WritingNotSupported { get; }
    internal static string Zip64EOCDNotWhereExpected { get; }
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, object p1);
    internal static ResourceManager get_ResourceManager();
    internal static string get_ArgumentOutOfRange_Enum();
    internal static string get_ArgumentOutOfRange_NeedPosNum();
    internal static string get_CannotReadFromDeflateStream();
    internal static string get_CannotWriteToDeflateStream();
    internal static string get_GenericInvalidData();
    internal static string get_InvalidArgumentOffsetCount();
    internal static string get_InvalidBeginCall();
    internal static string get_InvalidBlockLength();
    internal static string get_InvalidHuffmanData();
    internal static string get_NotSupported();
    internal static string get_NotSupported_UnreadableStream();
    internal static string get_NotSupported_UnwritableStream();
    internal static string get_ObjectDisposed_StreamClosed();
    internal static string get_UnknownBlockType();
    internal static string get_UnknownState();
    internal static string get_ZLibErrorDLLLoadError();
    internal static string get_ZLibErrorInconsistentStream();
    internal static string get_ZLibErrorIncorrectInitParameters();
    internal static string get_ZLibErrorNotEnoughMemory();
    internal static string get_ZLibErrorVersionMismatch();
    internal static string get_ZLibErrorUnexpected();
    internal static string get_ArgumentNeedNonNegative();
    internal static string get_CannotBeEmpty();
    internal static string get_CDCorrupt();
    internal static string get_CentralDirectoryInvalid();
    internal static string get_CreateInReadMode();
    internal static string get_CreateModeCapabilities();
    internal static string get_CreateModeCreateEntryWhileOpen();
    internal static string get_CreateModeWriteOnceAndOneEntryAtATime();
    internal static string get_DateTimeOutOfRange();
    internal static string get_DeletedEntry();
    internal static string get_DeleteOnlyInUpdate();
    internal static string get_DeleteOpenEntry();
    internal static string get_EntriesInCreateMode();
    internal static string get_EntryNameEncodingNotSupported();
    internal static string get_EntryNamesTooLong();
    internal static string get_EntryTooLarge();
    internal static string get_EOCDNotFound();
    internal static string get_FieldTooBigCompressedSize();
    internal static string get_FieldTooBigLocalHeaderOffset();
    internal static string get_FieldTooBigNumEntries();
    internal static string get_FieldTooBigOffsetToCD();
    internal static string get_FieldTooBigOffsetToZip64EOCD();
    internal static string get_FieldTooBigStartDiskNumber();
    internal static string get_FieldTooBigUncompressedSize();
    internal static string get_FrozenAfterWrite();
    internal static string get_HiddenStreamName();
    internal static string get_LengthAfterWrite();
    internal static string get_LocalFileHeaderCorrupt();
    internal static string get_NumEntriesWrong();
    internal static string get_OffsetLengthInvalid();
    internal static string get_ReadingNotSupported();
    internal static string get_ReadModeCapabilities();
    internal static string get_ReadOnlyArchive();
    internal static string get_SeekingNotSupported();
    internal static string get_SetLengthRequiresSeekingAndWriting();
    internal static string get_SplitSpanned();
    internal static string get_UnexpectedEndOfStream();
    internal static string get_UnsupportedCompression();
    internal static string get_UnsupportedCompressionMethod();
    internal static string get_UpdateModeCapabilities();
    internal static string get_UpdateModeOneStream();
    internal static string get_WritingNotSupported();
    internal static string get_Zip64EOCDNotWhereExpected();
}
internal static class System.Threading.Tasks.TaskToApm : object {
    public static IAsyncResult Begin(Task task, AsyncCallback callback, object state);
    public static void End(IAsyncResult asyncResult);
    public static TResult End(IAsyncResult asyncResult);
    private static void InvokeCallbackWhenTaskCompletes(Task antecedent, AsyncCallback callback, IAsyncResult asyncResult);
}
