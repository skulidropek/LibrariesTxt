internal static class FxResources.System.IO.FileSystem.SR : object {
}
internal static class Interop : object {
}
internal class Microsoft.Win32.SafeHandles.SafeFindHandle : SafeHandle {
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
[ExtensionAttribute]
internal static class System.FixedBufferExtensions : object {
    [ExtensionAttribute]
internal static string GetStringFromFixedBuffer(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
internal static int GetFixedBufferStringLength(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
internal static bool FixedBufferEqualsString(ReadOnlySpan`1<char> span, string value);
}
public static class System.IO.Directory : object {
    public static DirectoryInfo GetParent(string path);
    public static DirectoryInfo CreateDirectory(string path);
    public static bool Exists(string path);
    public static void SetCreationTime(string path, DateTime creationTime);
    public static void SetCreationTimeUtc(string path, DateTime creationTimeUtc);
    public static DateTime GetCreationTime(string path);
    public static DateTime GetCreationTimeUtc(string path);
    public static void SetLastWriteTime(string path, DateTime lastWriteTime);
    public static void SetLastWriteTimeUtc(string path, DateTime lastWriteTimeUtc);
    public static DateTime GetLastWriteTime(string path);
    public static DateTime GetLastWriteTimeUtc(string path);
    public static void SetLastAccessTime(string path, DateTime lastAccessTime);
    public static void SetLastAccessTimeUtc(string path, DateTime lastAccessTimeUtc);
    public static DateTime GetLastAccessTime(string path);
    public static DateTime GetLastAccessTimeUtc(string path);
    public static String[] GetFiles(string path);
    public static String[] GetFiles(string path, string searchPattern);
    public static String[] GetFiles(string path, string searchPattern, SearchOption searchOption);
    public static String[] GetFiles(string path, string searchPattern, EnumerationOptions enumerationOptions);
    public static String[] GetDirectories(string path);
    public static String[] GetDirectories(string path, string searchPattern);
    public static String[] GetDirectories(string path, string searchPattern, SearchOption searchOption);
    public static String[] GetDirectories(string path, string searchPattern, EnumerationOptions enumerationOptions);
    public static String[] GetFileSystemEntries(string path);
    public static String[] GetFileSystemEntries(string path, string searchPattern);
    public static String[] GetFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    public static String[] GetFileSystemEntries(string path, string searchPattern, EnumerationOptions enumerationOptions);
    internal static IEnumerable`1<string> InternalEnumeratePaths(string path, string searchPattern, SearchTarget searchTarget, EnumerationOptions options);
    public static IEnumerable`1<string> EnumerateDirectories(string path);
    public static IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern);
    public static IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption);
    public static IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern, EnumerationOptions enumerationOptions);
    public static IEnumerable`1<string> EnumerateFiles(string path);
    public static IEnumerable`1<string> EnumerateFiles(string path, string searchPattern);
    public static IEnumerable`1<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption);
    public static IEnumerable`1<string> EnumerateFiles(string path, string searchPattern, EnumerationOptions enumerationOptions);
    public static IEnumerable`1<string> EnumerateFileSystemEntries(string path);
    public static IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern);
    public static IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    public static IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern, EnumerationOptions enumerationOptions);
    public static string GetDirectoryRoot(string path);
    public static string GetCurrentDirectory();
    public static void SetCurrentDirectory(string path);
    public static void Move(string sourceDirName, string destDirName);
    public static void Delete(string path);
    public static void Delete(string path, bool recursive);
    public static String[] GetLogicalDrives();
}
public class System.IO.DirectoryInfo : FileSystemInfo {
    private bool _isNormalized;
    public DirectoryInfo Parent { get; }
    public DirectoryInfo Root { get; }
    public DirectoryInfo(string path);
    internal DirectoryInfo(string originalPath, string fullPath, string fileName, bool isNormalized);
    private void Init(string originalPath, string fullPath, string fileName, bool isNormalized);
    public DirectoryInfo get_Parent();
    public DirectoryInfo CreateSubdirectory(string path);
    public void Create();
    public FileInfo[] GetFiles();
    public FileInfo[] GetFiles(string searchPattern);
    public FileInfo[] GetFiles(string searchPattern, SearchOption searchOption);
    public FileInfo[] GetFiles(string searchPattern, EnumerationOptions enumerationOptions);
    public FileSystemInfo[] GetFileSystemInfos();
    public FileSystemInfo[] GetFileSystemInfos(string searchPattern);
    public FileSystemInfo[] GetFileSystemInfos(string searchPattern, SearchOption searchOption);
    public FileSystemInfo[] GetFileSystemInfos(string searchPattern, EnumerationOptions enumerationOptions);
    public DirectoryInfo[] GetDirectories();
    public DirectoryInfo[] GetDirectories(string searchPattern);
    public DirectoryInfo[] GetDirectories(string searchPattern, SearchOption searchOption);
    public DirectoryInfo[] GetDirectories(string searchPattern, EnumerationOptions enumerationOptions);
    public IEnumerable`1<DirectoryInfo> EnumerateDirectories();
    public IEnumerable`1<DirectoryInfo> EnumerateDirectories(string searchPattern);
    public IEnumerable`1<DirectoryInfo> EnumerateDirectories(string searchPattern, SearchOption searchOption);
    public IEnumerable`1<DirectoryInfo> EnumerateDirectories(string searchPattern, EnumerationOptions enumerationOptions);
    public IEnumerable`1<FileInfo> EnumerateFiles();
    public IEnumerable`1<FileInfo> EnumerateFiles(string searchPattern);
    public IEnumerable`1<FileInfo> EnumerateFiles(string searchPattern, SearchOption searchOption);
    public IEnumerable`1<FileInfo> EnumerateFiles(string searchPattern, EnumerationOptions enumerationOptions);
    public IEnumerable`1<FileSystemInfo> EnumerateFileSystemInfos();
    public IEnumerable`1<FileSystemInfo> EnumerateFileSystemInfos(string searchPattern);
    public IEnumerable`1<FileSystemInfo> EnumerateFileSystemInfos(string searchPattern, SearchOption searchOption);
    public IEnumerable`1<FileSystemInfo> EnumerateFileSystemInfos(string searchPattern, EnumerationOptions enumerationOptions);
    private IEnumerable`1<FileSystemInfo> InternalEnumerateInfos(string path, string searchPattern, SearchTarget searchTarget, EnumerationOptions options);
    public DirectoryInfo get_Root();
    public void MoveTo(string destDirName);
    public virtual void Delete();
    public void Delete(bool recursive);
}
internal class System.IO.DisableMediaInsertionPrompt : ValueType {
    private bool _disableSuccess;
    private UInt32 _oldMode;
    public static DisableMediaInsertionPrompt Create();
    public sealed virtual void Dispose();
}
internal static class System.IO.DriveInfoInternal : object {
    public static String[] GetLogicalDrives();
    public static string NormalizeDriveName(string driveName);
}
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[IsByRefLikeAttribute]
public class System.IO.Enumeration.FileSystemEntry : ValueType {
    internal FILE_FULL_DIR_INFORMATION* _info;
    [CompilerGeneratedAttribute]
private ReadOnlySpan`1<char> <Directory>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlySpan`1<char> <RootDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlySpan`1<char> <OriginalRootDirectory>k__BackingField;
    public ReadOnlySpan`1<char> Directory { get; private set; }
    public ReadOnlySpan`1<char> RootDirectory { get; private set; }
    public ReadOnlySpan`1<char> OriginalRootDirectory { get; private set; }
    public ReadOnlySpan`1<char> FileName { get; }
    public FileAttributes Attributes { get; }
    public long Length { get; }
    public DateTimeOffset CreationTimeUtc { get; }
    public DateTimeOffset LastAccessTimeUtc { get; }
    public DateTimeOffset LastWriteTimeUtc { get; }
    public bool IsDirectory { get; }
    public bool IsHidden { get; }
    public string ToSpecifiedFullPath();
    internal static void Initialize(FileSystemEntry& entry, FILE_FULL_DIR_INFORMATION* info, ReadOnlySpan`1<char> directory, ReadOnlySpan`1<char> rootDirectory, ReadOnlySpan`1<char> originalRootDirectory);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public ReadOnlySpan`1<char> get_Directory();
    [CompilerGeneratedAttribute]
private void set_Directory(ReadOnlySpan`1<char> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ReadOnlySpan`1<char> get_RootDirectory();
    [CompilerGeneratedAttribute]
private void set_RootDirectory(ReadOnlySpan`1<char> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ReadOnlySpan`1<char> get_OriginalRootDirectory();
    [CompilerGeneratedAttribute]
private void set_OriginalRootDirectory(ReadOnlySpan`1<char> value);
    public ReadOnlySpan`1<char> get_FileName();
    public FileAttributes get_Attributes();
    public long get_Length();
    public DateTimeOffset get_CreationTimeUtc();
    public DateTimeOffset get_LastAccessTimeUtc();
    public DateTimeOffset get_LastWriteTimeUtc();
    public bool get_IsDirectory();
    public bool get_IsHidden();
    public FileSystemInfo ToFileSystemInfo();
    public string ToFullPath();
}
public class System.IO.Enumeration.FileSystemEnumerable`1 : object {
    private DelegateEnumerator<TResult> _enumerator;
    private FindTransform<TResult> _transform;
    private EnumerationOptions _options;
    private string _directory;
    [CompilerGeneratedAttribute]
private FindPredicate<TResult> <ShouldIncludePredicate>k__BackingField;
    [CompilerGeneratedAttribute]
private FindPredicate<TResult> <ShouldRecursePredicate>k__BackingField;
    public FindPredicate<TResult> ShouldIncludePredicate { get; public set; }
    public FindPredicate<TResult> ShouldRecursePredicate { get; public set; }
    public FileSystemEnumerable`1(string directory, FindTransform<TResult> transform, EnumerationOptions options);
    internal FileSystemEnumerable`1(string directory, FindTransform<TResult> transform, EnumerationOptions options, bool isNormalized);
    [CompilerGeneratedAttribute]
public FindPredicate<TResult> get_ShouldIncludePredicate();
    [CompilerGeneratedAttribute]
public void set_ShouldIncludePredicate(FindPredicate<TResult> value);
    [CompilerGeneratedAttribute]
public FindPredicate<TResult> get_ShouldRecursePredicate();
    [CompilerGeneratedAttribute]
public void set_ShouldRecursePredicate(FindPredicate<TResult> value);
    public sealed virtual IEnumerator`1<TResult> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal static class System.IO.Enumeration.FileSystemEnumerableFactory : object {
    private static Char[] s_unixEscapeChars;
    private static FileSystemEnumerableFactory();
    internal static bool NormalizeInputs(String& directory, String& expression, MatchType matchType);
    private static bool MatchesPattern(string expression, ReadOnlySpan`1<char> name, EnumerationOptions options);
    internal static IEnumerable`1<string> UserFiles(string directory, string expression, EnumerationOptions options);
    internal static IEnumerable`1<string> UserDirectories(string directory, string expression, EnumerationOptions options);
    internal static IEnumerable`1<string> UserEntries(string directory, string expression, EnumerationOptions options);
    internal static IEnumerable`1<FileInfo> FileInfos(string directory, string expression, EnumerationOptions options, bool isNormalized);
    internal static IEnumerable`1<DirectoryInfo> DirectoryInfos(string directory, string expression, EnumerationOptions options, bool isNormalized);
    internal static IEnumerable`1<FileSystemInfo> FileSystemInfos(string directory, string expression, EnumerationOptions options, bool isNormalized);
}
public abstract class System.IO.Enumeration.FileSystemEnumerator`1 : CriticalFinalizerObject {
    private string _originalRootDirectory;
    private string _rootDirectory;
    private EnumerationOptions _options;
    private object _lock;
    private FILE_FULL_DIR_INFORMATION* _entry;
    private TResult _current;
    private IntPtr _buffer;
    private int _bufferLength;
    private IntPtr _directoryHandle;
    private string _currentPath;
    private bool _lastEntryFound;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Queue`1<ValueTuple`2<IntPtr, string>> _pending;
    public TResult Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public FileSystemEnumerator`1(string directory, EnumerationOptions options);
    internal FileSystemEnumerator`1(string directory, bool isNormalized, EnumerationOptions options);
    protected virtual bool ShouldIncludeEntry(FileSystemEntry& entry);
    protected virtual bool ShouldRecurseIntoEntry(FileSystemEntry& entry);
    protected abstract virtual TResult TransformEntry(FileSystemEntry& entry);
    protected virtual void OnDirectoryFinished(ReadOnlySpan`1<char> directory);
    protected virtual bool ContinueOnError(int error);
    public sealed virtual TResult get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    private void DirectoryFinished();
    public sealed virtual void Reset();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    private void Init();
    private void CloseDirectoryHandle();
    private IntPtr CreateDirectoryHandle(string path, bool ignoreNotFound);
    private bool ContinueOnDirectoryError(int error, bool ignoreNotFound);
    public sealed virtual bool MoveNext();
    private void FindNextEntry();
    private bool DequeueNextDirectory();
    private void InternalDispose(bool disposing);
    private bool GetData();
    private IntPtr CreateRelativeDirectoryHandle(ReadOnlySpan`1<char> relativePath, string fullPath);
}
public static class System.IO.Enumeration.FileSystemName : object {
    private static Char[] s_wildcardChars;
    private static Char[] s_simpleWildcardChars;
    private static FileSystemName();
    public static string TranslateWin32Expression(string expression);
    public static bool MatchesWin32Expression(ReadOnlySpan`1<char> expression, ReadOnlySpan`1<char> name, bool ignoreCase);
    public static bool MatchesSimpleExpression(ReadOnlySpan`1<char> expression, ReadOnlySpan`1<char> name, bool ignoreCase);
    private static bool MatchPattern(ReadOnlySpan`1<char> expression, ReadOnlySpan`1<char> name, bool ignoreCase, bool useExtendedWildcards);
}
public class System.IO.EnumerationOptions : object {
    [CompilerGeneratedAttribute]
private static EnumerationOptions <Compatible>k__BackingField;
    [CompilerGeneratedAttribute]
private static EnumerationOptions <CompatibleRecursive>k__BackingField;
    [CompilerGeneratedAttribute]
private static EnumerationOptions <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RecurseSubdirectories>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreInaccessible>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BufferSize>k__BackingField;
    [CompilerGeneratedAttribute]
private FileAttributes <AttributesToSkip>k__BackingField;
    [CompilerGeneratedAttribute]
private MatchType <MatchType>k__BackingField;
    [CompilerGeneratedAttribute]
private MatchCasing <MatchCasing>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReturnSpecialDirectories>k__BackingField;
    internal static EnumerationOptions Compatible { get; }
    private static EnumerationOptions CompatibleRecursive { get; }
    internal static EnumerationOptions Default { get; }
    public bool RecurseSubdirectories { get; public set; }
    public bool IgnoreInaccessible { get; public set; }
    public int BufferSize { get; public set; }
    public FileAttributes AttributesToSkip { get; public set; }
    public MatchType MatchType { get; public set; }
    public MatchCasing MatchCasing { get; public set; }
    public bool ReturnSpecialDirectories { get; public set; }
    private static EnumerationOptions();
    [CompilerGeneratedAttribute]
internal static EnumerationOptions get_Compatible();
    [CompilerGeneratedAttribute]
private static EnumerationOptions get_CompatibleRecursive();
    [CompilerGeneratedAttribute]
internal static EnumerationOptions get_Default();
    internal static EnumerationOptions FromSearchOption(SearchOption searchOption);
    [CompilerGeneratedAttribute]
public bool get_RecurseSubdirectories();
    [CompilerGeneratedAttribute]
public void set_RecurseSubdirectories(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreInaccessible();
    [CompilerGeneratedAttribute]
public void set_IgnoreInaccessible(bool value);
    [CompilerGeneratedAttribute]
public int get_BufferSize();
    [CompilerGeneratedAttribute]
public void set_BufferSize(int value);
    [CompilerGeneratedAttribute]
public FileAttributes get_AttributesToSkip();
    [CompilerGeneratedAttribute]
public void set_AttributesToSkip(FileAttributes value);
    [CompilerGeneratedAttribute]
public MatchType get_MatchType();
    [CompilerGeneratedAttribute]
public void set_MatchType(MatchType value);
    [CompilerGeneratedAttribute]
public MatchCasing get_MatchCasing();
    [CompilerGeneratedAttribute]
public void set_MatchCasing(MatchCasing value);
    [CompilerGeneratedAttribute]
public bool get_ReturnSpecialDirectories();
    [CompilerGeneratedAttribute]
public void set_ReturnSpecialDirectories(bool value);
}
internal static class System.IO.Error : object {
    internal static Exception GetEndOfFile();
}
public static class System.IO.File : object {
    private static Encoding s_UTF8NoBOM;
    private static Encoding UTF8NoBOM { get; }
    public static StreamReader OpenText(string path);
    public static StreamWriter CreateText(string path);
    public static StreamWriter AppendText(string path);
    public static void Copy(string sourceFileName, string destFileName);
    public static void Copy(string sourceFileName, string destFileName, bool overwrite);
    public static FileStream Create(string path);
    public static FileStream Create(string path, int bufferSize);
    public static FileStream Create(string path, int bufferSize, FileOptions options);
    public static void Delete(string path);
    public static bool Exists(string path);
    public static FileStream Open(string path, FileMode mode);
    public static FileStream Open(string path, FileMode mode, FileAccess access);
    public static FileStream Open(string path, FileMode mode, FileAccess access, FileShare share);
    internal static DateTimeOffset GetUtcDateTimeOffset(DateTime dateTime);
    public static void SetCreationTime(string path, DateTime creationTime);
    public static void SetCreationTimeUtc(string path, DateTime creationTimeUtc);
    public static DateTime GetCreationTime(string path);
    public static DateTime GetCreationTimeUtc(string path);
    public static void SetLastAccessTime(string path, DateTime lastAccessTime);
    public static void SetLastAccessTimeUtc(string path, DateTime lastAccessTimeUtc);
    public static DateTime GetLastAccessTime(string path);
    public static DateTime GetLastAccessTimeUtc(string path);
    public static void SetLastWriteTime(string path, DateTime lastWriteTime);
    public static void SetLastWriteTimeUtc(string path, DateTime lastWriteTimeUtc);
    public static DateTime GetLastWriteTime(string path);
    public static DateTime GetLastWriteTimeUtc(string path);
    public static FileAttributes GetAttributes(string path);
    public static void SetAttributes(string path, FileAttributes fileAttributes);
    public static FileStream OpenRead(string path);
    public static FileStream OpenWrite(string path);
    public static string ReadAllText(string path);
    public static string ReadAllText(string path, Encoding encoding);
    private static string InternalReadAllText(string path, Encoding encoding);
    public static void WriteAllText(string path, string contents);
    public static void WriteAllText(string path, string contents, Encoding encoding);
    public static Byte[] ReadAllBytes(string path);
    private static Byte[] ReadAllBytesUnknownLength(FileStream fs);
    public static void WriteAllBytes(string path, Byte[] bytes);
    private static void InternalWriteAllBytes(string path, Byte[] bytes);
    public static String[] ReadAllLines(string path);
    public static String[] ReadAllLines(string path, Encoding encoding);
    private static String[] InternalReadAllLines(string path, Encoding encoding);
    public static IEnumerable`1<string> ReadLines(string path);
    public static IEnumerable`1<string> ReadLines(string path, Encoding encoding);
    public static void WriteAllLines(string path, String[] contents);
    public static void WriteAllLines(string path, IEnumerable`1<string> contents);
    public static void WriteAllLines(string path, String[] contents, Encoding encoding);
    public static void WriteAllLines(string path, IEnumerable`1<string> contents, Encoding encoding);
    private static void InternalWriteAllLines(TextWriter writer, IEnumerable`1<string> contents);
    public static void AppendAllText(string path, string contents);
    public static void AppendAllText(string path, string contents, Encoding encoding);
    public static void AppendAllLines(string path, IEnumerable`1<string> contents);
    public static void AppendAllLines(string path, IEnumerable`1<string> contents, Encoding encoding);
    public static void Replace(string sourceFileName, string destinationFileName, string destinationBackupFileName);
    public static void Replace(string sourceFileName, string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors);
    public static void Move(string sourceFileName, string destFileName);
    public static void Move(string sourceFileName, string destFileName, bool overwrite);
    public static void Encrypt(string path);
    public static void Decrypt(string path);
    private static Encoding get_UTF8NoBOM();
    private static StreamReader AsyncStreamReader(string path, Encoding encoding);
    private static StreamWriter AsyncStreamWriter(string path, Encoding encoding, bool append);
    public static Task`1<string> ReadAllTextAsync(string path, CancellationToken cancellationToken);
    public static Task`1<string> ReadAllTextAsync(string path, Encoding encoding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.File/<InternalReadAllTextAsync>d__68")]
private static Task`1<string> InternalReadAllTextAsync(string path, Encoding encoding, CancellationToken cancellationToken);
    public static Task WriteAllTextAsync(string path, string contents, CancellationToken cancellationToken);
    public static Task WriteAllTextAsync(string path, string contents, Encoding encoding, CancellationToken cancellationToken);
    public static Task`1<Byte[]> ReadAllBytesAsync(string path, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.File/<InternalReadAllBytesAsync>d__72")]
private static Task`1<Byte[]> InternalReadAllBytesAsync(FileStream fs, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.File/<InternalReadAllBytesUnknownLengthAsync>d__73")]
private static Task`1<Byte[]> InternalReadAllBytesUnknownLengthAsync(FileStream fs, CancellationToken cancellationToken);
    public static Task WriteAllBytesAsync(string path, Byte[] bytes, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.File/<InternalWriteAllBytesAsync>d__75")]
private static Task InternalWriteAllBytesAsync(string path, Byte[] bytes, CancellationToken cancellationToken);
    public static Task`1<String[]> ReadAllLinesAsync(string path, CancellationToken cancellationToken);
    public static Task`1<String[]> ReadAllLinesAsync(string path, Encoding encoding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.File/<InternalReadAllLinesAsync>d__78")]
private static Task`1<String[]> InternalReadAllLinesAsync(string path, Encoding encoding, CancellationToken cancellationToken);
    public static Task WriteAllLinesAsync(string path, IEnumerable`1<string> contents, CancellationToken cancellationToken);
    public static Task WriteAllLinesAsync(string path, IEnumerable`1<string> contents, Encoding encoding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.File/<InternalWriteAllLinesAsync>d__81")]
private static Task InternalWriteAllLinesAsync(TextWriter writer, IEnumerable`1<string> contents, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.File/<InternalWriteAllTextAsync>d__82")]
private static Task InternalWriteAllTextAsync(StreamWriter sw, string contents, CancellationToken cancellationToken);
    public static Task AppendAllTextAsync(string path, string contents, CancellationToken cancellationToken);
    public static Task AppendAllTextAsync(string path, string contents, Encoding encoding, CancellationToken cancellationToken);
    public static Task AppendAllLinesAsync(string path, IEnumerable`1<string> contents, CancellationToken cancellationToken);
    public static Task AppendAllLinesAsync(string path, IEnumerable`1<string> contents, Encoding encoding, CancellationToken cancellationToken);
}
public class System.IO.FileInfo : FileSystemInfo {
    public long Length { get; }
    public string DirectoryName { get; }
    public DirectoryInfo Directory { get; }
    public bool IsReadOnly { get; public set; }
    public FileInfo(string fileName);
    internal FileInfo(string originalPath, string fullPath, string fileName, bool isNormalized);
    public long get_Length();
    public string get_DirectoryName();
    public DirectoryInfo get_Directory();
    public bool get_IsReadOnly();
    public void set_IsReadOnly(bool value);
    public StreamReader OpenText();
    public StreamWriter CreateText();
    public StreamWriter AppendText();
    public FileInfo CopyTo(string destFileName);
    public FileInfo CopyTo(string destFileName, bool overwrite);
    public FileStream Create();
    public virtual void Delete();
    public FileStream Open(FileMode mode);
    public FileStream Open(FileMode mode, FileAccess access);
    public FileStream Open(FileMode mode, FileAccess access, FileShare share);
    public FileStream OpenRead();
    public FileStream OpenWrite();
    public void MoveTo(string destFileName);
    public void MoveTo(string destFileName, bool overwrite);
    public FileInfo Replace(string destinationFileName, string destinationBackupFileName);
    public FileInfo Replace(string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors);
    public void Decrypt();
    public void Encrypt();
}
internal static class System.IO.FileSystem : object {
    public static bool DirectoryExists(string fullPath);
    private static bool DirectoryExists(string path, Int32& lastError);
    public static bool FileExists(string fullPath);
    internal static int FillAttributeInfo(string path, WIN32_FILE_ATTRIBUTE_DATA& data, bool returnErrorOnNotFound);
    public static void CreateDirectory(string fullPath, Byte[] securityDescriptor);
    public static void CopyFile(string sourceFullPath, string destFullPath, bool overwrite);
    public static void ReplaceFile(string sourceFullPath, string destFullPath, string destBackupFullPath, bool ignoreMetadataErrors);
    public static void DeleteFile(string fullPath);
    public static FileAttributes GetAttributes(string fullPath);
    public static DateTimeOffset GetCreationTime(string fullPath);
    public static DateTimeOffset GetLastAccessTime(string fullPath);
    public static DateTimeOffset GetLastWriteTime(string fullPath);
    public static void MoveDirectory(string sourceFullPath, string destFullPath);
    public static void MoveFile(string sourceFullPath, string destFullPath, bool overwrite);
    private static SafeFileHandle OpenHandle(string fullPath, bool asDirectory);
    public static void RemoveDirectory(string fullPath, bool recursive);
    private static void GetFindData(string fullPath, WIN32_FIND_DATA& findData);
    private static bool IsNameSurrogateReparsePoint(WIN32_FIND_DATA& data);
    private static void RemoveDirectoryRecursive(string fullPath, WIN32_FIND_DATA& findData, bool topLevel);
    private static void RemoveDirectoryInternal(string fullPath, bool topLevel, bool allowDirectoryNotEmpty);
    public static void SetAttributes(string fullPath, FileAttributes attributes);
    public static void SetCreationTime(string fullPath, DateTimeOffset time, bool asDirectory);
    public static void SetLastAccessTime(string fullPath, DateTimeOffset time, bool asDirectory);
    public static void SetLastWriteTime(string fullPath, DateTimeOffset time, bool asDirectory);
    public static String[] GetLogicalDrives();
    public static void Encrypt(string path);
    public static void Decrypt(string path);
    private static void ThrowExceptionEncryptDecryptFail(string fullPath);
}
public abstract class System.IO.FileSystemInfo : MarshalByRefObject {
    protected string FullPath;
    protected string OriginalPath;
    internal string _name;
    private WIN32_FILE_ATTRIBUTE_DATA _data;
    private int _dataInitialized;
    public string FullName { get; }
    public string Extension { get; }
    public string Name { get; }
    public bool Exists { get; }
    public DateTime CreationTime { get; public set; }
    public DateTime CreationTimeUtc { get; public set; }
    public DateTime LastAccessTime { get; public set; }
    public DateTime LastAccessTimeUtc { get; public set; }
    public DateTime LastWriteTime { get; public set; }
    public DateTime LastWriteTimeUtc { get; public set; }
    public FileAttributes Attributes { get; public set; }
    internal bool ExistsCore { get; }
    internal DateTimeOffset CreationTimeCore { get; internal set; }
    internal DateTimeOffset LastAccessTimeCore { get; internal set; }
    internal DateTimeOffset LastWriteTimeCore { get; internal set; }
    internal long LengthCore { get; }
    internal string NormalizedPath { get; }
    protected FileSystemInfo(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string get_FullName();
    public string get_Extension();
    public virtual string get_Name();
    public virtual bool get_Exists();
    public abstract virtual void Delete();
    public DateTime get_CreationTime();
    public void set_CreationTime(DateTime value);
    public DateTime get_CreationTimeUtc();
    public void set_CreationTimeUtc(DateTime value);
    public DateTime get_LastAccessTime();
    public void set_LastAccessTime(DateTime value);
    public DateTime get_LastAccessTimeUtc();
    public void set_LastAccessTimeUtc(DateTime value);
    public DateTime get_LastWriteTime();
    public void set_LastWriteTime(DateTime value);
    public DateTime get_LastWriteTimeUtc();
    public void set_LastWriteTimeUtc(DateTime value);
    public virtual string ToString();
    internal static FileSystemInfo Create(string fullPath, FileSystemEntry& findData);
    internal void Invalidate();
    internal void Init(FILE_FULL_DIR_INFORMATION* info);
    public FileAttributes get_Attributes();
    public void set_Attributes(FileAttributes value);
    internal bool get_ExistsCore();
    internal DateTimeOffset get_CreationTimeCore();
    internal void set_CreationTimeCore(DateTimeOffset value);
    internal DateTimeOffset get_LastAccessTimeCore();
    internal void set_LastAccessTimeCore(DateTimeOffset value);
    internal DateTimeOffset get_LastWriteTimeCore();
    internal void set_LastWriteTimeCore(DateTimeOffset value);
    internal long get_LengthCore();
    private void EnsureDataInitialized();
    public void Refresh();
    internal string get_NormalizedPath();
}
internal abstract class System.IO.Iterator`1 : object {
    private int _threadId;
    internal int state;
    internal TSource current;
    public TSource Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public sealed virtual TSource get_Current();
    protected abstract virtual Iterator`1<TSource> Clone();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public sealed virtual IEnumerator`1<TSource> GetEnumerator();
    public abstract virtual bool MoveNext();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
}
public enum System.IO.MatchCasing : Enum {
    public int value__;
    public static MatchCasing PlatformDefault;
    public static MatchCasing CaseSensitive;
    public static MatchCasing CaseInsensitive;
}
public enum System.IO.MatchType : Enum {
    public int value__;
    public static MatchType Simple;
    public static MatchType Win32;
}
internal static class System.IO.PathInternal : object {
    private static bool s_isCaseSensitive;
    internal static StringComparison StringComparison { get; }
    internal static bool IsCaseSensitive { get; }
    private static PathInternal();
    internal static bool StartsWithDirectorySeparator(ReadOnlySpan`1<char> path);
    internal static string EnsureTrailingSeparator(string path);
    internal static bool IsRoot(ReadOnlySpan`1<char> path);
    internal static string TrimEndingDirectorySeparator(string path);
    internal static bool EndsInDirectorySeparator(ReadOnlySpan`1<char> path);
    public static bool EndsInDirectorySeparator(string path);
    internal static StringComparison get_StringComparison();
    internal static bool get_IsCaseSensitive();
    private static bool GetIsCaseSensitive();
    internal static bool IsValidDriveChar(char value);
    internal static bool EndsWithPeriodOrSpace(string path);
    internal static string EnsureExtendedPrefixIfNeeded(string path);
    internal static string EnsureExtendedPrefix(string path);
    internal static bool IsDevice(ReadOnlySpan`1<char> path);
    internal static bool IsDeviceUNC(ReadOnlySpan`1<char> path);
    internal static bool IsExtended(ReadOnlySpan`1<char> path);
    internal static int GetRootLength(ReadOnlySpan`1<char> path);
    internal static bool IsPartiallyQualified(ReadOnlySpan`1<char> path);
    internal static bool IsDirectorySeparator(char c);
    internal static bool IsEffectivelyEmpty(ReadOnlySpan`1<char> path);
}
internal class System.IO.ReadLinesIterator : Iterator`1<string> {
    private string _path;
    private Encoding _encoding;
    private StreamReader _reader;
    private ReadLinesIterator(string path, Encoding encoding, StreamReader reader);
    public virtual bool MoveNext();
    protected virtual Iterator`1<string> Clone();
    protected virtual void Dispose(bool disposing);
    internal static ReadLinesIterator CreateIterator(string path, Encoding encoding);
    private static ReadLinesIterator CreateIterator(string path, Encoding encoding, StreamReader reader);
}
public enum System.IO.SearchOption : Enum {
    public int value__;
    public static SearchOption TopDirectoryOnly;
    public static SearchOption AllDirectories;
}
internal enum System.IO.SearchTarget : Enum {
    public int value__;
    public static SearchTarget Files;
    public static SearchTarget Directories;
    public static SearchTarget Both;
}
internal static class System.IO.Win32Marshal : object {
    internal static Exception GetExceptionForLastWin32Error(string path);
    internal static Exception GetExceptionForWin32Error(int errorCode, string path);
    internal static int MakeHRFromErrorCode(int errorCode);
    internal static string GetMessage(int errorCode);
}
internal static class System.SR : object {
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string Arg_FileIsDirectory_Name { get; }
    internal static string Arg_InvalidFileAttrs { get; }
    internal static string Arg_MustBeDriveLetterOrRootDir { get; }
    internal static string Arg_Path2IsRooted { get; }
    internal static string Arg_PathIsVolume { get; }
    internal static string ArgumentNull_FileName { get; }
    internal static string ArgumentNull_Path { get; }
    internal static string ArgumentOutOfRange_Enum { get; }
    internal static string Argument_EmptyFileName { get; }
    internal static string Argument_EmptyPath { get; }
    internal static string Argument_InvalidPathChars { get; }
    internal static string Argument_InvalidSubPath { get; }
    internal static string Argument_PathEmpty { get; }
    internal static string IO_AlreadyExists_Name { get; }
    internal static string IO_EOF_ReadBeyondEOF { get; }
    internal static string IO_FileExists_Name { get; }
    internal static string IO_FileNotFound { get; }
    internal static string IO_FileNotFound_FileName { get; }
    internal static string IO_FileTooLong2GB { get; }
    internal static string IO_PathNotFound_NoPathName { get; }
    internal static string IO_PathNotFound_Path { get; }
    internal static string IO_PathTooLong { get; }
    internal static string IO_SharingViolation_File { get; }
    internal static string IO_SharingViolation_NoFileName { get; }
    internal static string IO_SourceDestMustBeDifferent { get; }
    internal static string IO_SourceDestMustHaveSameRoot { get; }
    internal static string UnauthorizedAccess_IODenied_NoPathName { get; }
    internal static string UnauthorizedAccess_IODenied_Path { get; }
    internal static string PlatformNotSupported_FileEncryption { get; }
    internal static string IO_PathTooLong_Path { get; }
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static ResourceManager get_ResourceManager();
    internal static string get_Arg_FileIsDirectory_Name();
    internal static string get_Arg_InvalidFileAttrs();
    internal static string get_Arg_MustBeDriveLetterOrRootDir();
    internal static string get_Arg_Path2IsRooted();
    internal static string get_Arg_PathIsVolume();
    internal static string get_ArgumentNull_FileName();
    internal static string get_ArgumentNull_Path();
    internal static string get_ArgumentOutOfRange_Enum();
    internal static string get_Argument_EmptyFileName();
    internal static string get_Argument_EmptyPath();
    internal static string get_Argument_InvalidPathChars();
    internal static string get_Argument_InvalidSubPath();
    internal static string get_Argument_PathEmpty();
    internal static string get_IO_AlreadyExists_Name();
    internal static string get_IO_EOF_ReadBeyondEOF();
    internal static string get_IO_FileExists_Name();
    internal static string get_IO_FileNotFound();
    internal static string get_IO_FileNotFound_FileName();
    internal static string get_IO_FileTooLong2GB();
    internal static string get_IO_PathNotFound_NoPathName();
    internal static string get_IO_PathNotFound_Path();
    internal static string get_IO_PathTooLong();
    internal static string get_IO_SharingViolation_File();
    internal static string get_IO_SharingViolation_NoFileName();
    internal static string get_IO_SourceDestMustBeDifferent();
    internal static string get_IO_SourceDestMustHaveSameRoot();
    internal static string get_UnauthorizedAccess_IODenied_NoPathName();
    internal static string get_UnauthorizedAccess_IODenied_Path();
    internal static string get_PlatformNotSupported_FileEncryption();
    internal static string get_IO_PathTooLong_Path();
}
[IsByRefLikeAttribute]
[DefaultMemberAttribute("Item")]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class System.Text.ValueStringBuilder : ValueType {
    private Char[] _arrayToReturnToPool;
    private Span`1<char> _chars;
    private int _pos;
    public int Length { get; }
    public Char& Item { get; }
    public ValueStringBuilder(Span`1<char> initialBuffer);
    public int get_Length();
    public Char& get_Item(int index);
    public virtual string ToString();
    public void Append(char c);
    private void GrowAndAppend(char c);
    private void Grow(int additionalCapacityBeyondPos);
    public void Dispose();
}
