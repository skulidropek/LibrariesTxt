internal static class FxResources.System.Linq.Parallel.SR : object {
}
internal static class System.Linq.AggregationMinMaxHelpers`1 : object {
    private static T Reduce(IEnumerable`1<T> source, int sign);
    internal static T ReduceMin(IEnumerable`1<T> source);
    internal static T ReduceMax(IEnumerable`1<T> source);
    private static Func`3<Pair`2<bool, T>, T, Pair`2<bool, T>> MakeIntermediateReduceFunction(int sign);
    private static Func`3<Pair`2<bool, T>, Pair`2<bool, T>, Pair`2<bool, T>> MakeFinalReduceFunction(int sign);
    private static Func`2<Pair`2<bool, T>, T> MakeResultSelectorFunction();
}
public class System.Linq.OrderedParallelQuery`1 : ParallelQuery`1<TSource> {
    private QueryOperator`1<TSource> _sortOp;
    internal QueryOperator`1<TSource> SortOperator { get; }
    internal IOrderedEnumerable`1<TSource> OrderedEnumerable { get; }
    internal OrderedParallelQuery`1(QueryOperator`1<TSource> sortOp);
    internal QueryOperator`1<TSource> get_SortOperator();
    internal IOrderedEnumerable`1<TSource> get_OrderedEnumerable();
    public virtual IEnumerator`1<TSource> GetEnumerator();
}
internal class System.Linq.Parallel.AnyAllSearchOperator`1 : UnaryQueryOperator`2<TInput, bool> {
    private Func`2<TInput, bool> _predicate;
    private bool _qualification;
    internal bool LimitsParallelism { get; }
    internal AnyAllSearchOperator`1(IEnumerable`1<TInput> child, bool qualification, Func`2<TInput, bool> predicate);
    internal bool Aggregate();
    internal virtual QueryResults`1<bool> Open(QuerySettings settings, bool preferStriping);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TInput, TKey> inputStream, IPartitionedStreamRecipient`1<bool> recipient, bool preferStriping, QuerySettings settings);
    [ExcludeFromCodeCoverageAttribute]
internal virtual IEnumerable`1<bool> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal class System.Linq.Parallel.ArrayMergeHelper`1 : object {
    private QueryResults`1<TInputOutput> _queryResults;
    private TInputOutput[] _outputArray;
    private QuerySettings _settings;
    public ArrayMergeHelper`1(QuerySettings settings, QueryResults`1<TInputOutput> queryResults);
    private void ToArrayElement(int index);
    public sealed virtual void Execute();
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual IEnumerator`1<TInputOutput> GetEnumerator();
    public sealed virtual TInputOutput[] GetResultsAsArray();
}
internal class System.Linq.Parallel.AssociativeAggregationOperator`3 : UnaryQueryOperator`2<TInput, TIntermediate> {
    private TIntermediate _seed;
    private bool _seedIsSpecified;
    private bool _throwIfEmpty;
    private Func`3<TIntermediate, TInput, TIntermediate> _intermediateReduce;
    private Func`3<TIntermediate, TIntermediate, TIntermediate> _finalReduce;
    private Func`2<TIntermediate, TOutput> _resultSelector;
    private Func`1<TIntermediate> _seedFactory;
    internal bool LimitsParallelism { get; }
    internal AssociativeAggregationOperator`3(IEnumerable`1<TInput> child, TIntermediate seed, Func`1<TIntermediate> seedFactory, bool seedIsSpecified, Func`3<TIntermediate, TInput, TIntermediate> intermediateReduce, Func`3<TIntermediate, TIntermediate, TIntermediate> finalReduce, Func`2<TIntermediate, TOutput> resultSelector, bool throwIfEmpty, QueryAggregationOptions options);
    internal TOutput Aggregate();
    internal virtual QueryResults`1<TIntermediate> Open(QuerySettings settings, bool preferStriping);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TInput, TKey> inputStream, IPartitionedStreamRecipient`1<TIntermediate> recipient, bool preferStriping, QuerySettings settings);
    [ExcludeFromCodeCoverageAttribute]
internal virtual IEnumerable`1<TIntermediate> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal class System.Linq.Parallel.AsynchronousChannel`1 : object {
    private T[][] _buffer;
    private int _index;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _producerBufferIndex;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _consumerBufferIndex;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _done;
    private T[] _producerChunk;
    private int _producerChunkIndex;
    private T[] _consumerChunk;
    private int _consumerChunkIndex;
    private int _chunkSize;
    private ManualResetEventSlim _producerEvent;
    private IntValueEvent _consumerEvent;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _producerIsWaiting;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _consumerIsWaiting;
    private CancellationToken _cancellationToken;
    internal bool IsFull { get; }
    internal bool IsChunkBufferEmpty { get; }
    internal bool IsDone { get; }
    internal AsynchronousChannel`1(int index, int chunkSize, CancellationToken cancellationToken, IntValueEvent consumerEvent);
    internal AsynchronousChannel`1(int index, int capacity, int chunkSize, CancellationToken cancellationToken, IntValueEvent consumerEvent);
    internal bool get_IsFull();
    internal bool get_IsChunkBufferEmpty();
    internal bool get_IsDone();
    internal void FlushBuffers();
    internal void SetDone();
    internal void Enqueue(T item);
    private void EnqueueChunk(T[] chunk);
    private void WaitUntilNonFull();
    private void FlushCachedChunk();
    internal bool TryDequeue(T& item);
    private bool TryDequeueChunk(T[]& chunk);
    internal bool TryDequeue(T& item, Boolean& isDone);
    private bool TryDequeueChunk(T[]& chunk, Boolean& isDone);
    private T[] InternalDequeueChunk();
    internal void DoneWithDequeueWait();
    public sealed virtual void Dispose();
}
internal class System.Linq.Parallel.AsynchronousChannelMergeEnumerator`1 : MergeEnumerator`1<T> {
    private AsynchronousChannel`1[] _channels;
    private IntValueEvent _consumerEvent;
    private Boolean[] _done;
    private int _channelIndex;
    private T _currentElement;
    public T Current { get; }
    internal AsynchronousChannelMergeEnumerator`1(QueryTaskGroupState taskGroupState, AsynchronousChannel`1[] channels, IntValueEvent consumerEvent);
    public virtual T get_Current();
    public virtual bool MoveNext();
    private bool MoveNextSlowPath();
    public virtual void Dispose();
}
internal abstract class System.Linq.Parallel.BinaryQueryOperator`3 : QueryOperator`1<TOutput> {
    private QueryOperator`1<TLeftInput> _leftChild;
    private QueryOperator`1<TRightInput> _rightChild;
    private OrdinalIndexState _indexState;
    internal QueryOperator`1<TLeftInput> LeftChild { get; }
    internal QueryOperator`1<TRightInput> RightChild { get; }
    internal OrdinalIndexState OrdinalIndexState { get; }
    internal BinaryQueryOperator`3(ParallelQuery`1<TLeftInput> leftChild, ParallelQuery`1<TRightInput> rightChild);
    internal BinaryQueryOperator`3(QueryOperator`1<TLeftInput> leftChild, QueryOperator`1<TRightInput> rightChild);
    internal QueryOperator`1<TLeftInput> get_LeftChild();
    internal QueryOperator`1<TRightInput> get_RightChild();
    internal sealed virtual OrdinalIndexState get_OrdinalIndexState();
    protected void SetOrdinalIndex(OrdinalIndexState indexState);
    public abstract virtual void WrapPartitionedStream(PartitionedStream`2<TLeftInput, TLeftKey> leftPartitionedStream, PartitionedStream`2<TRightInput, TRightKey> rightPartitionedStream, IPartitionedStreamRecipient`1<TOutput> outputRecipient, bool preferStriping, QuerySettings settings);
}
internal static class System.Linq.Parallel.CancellableEnumerable : object {
    [IteratorStateMachineAttribute("System.Linq.Parallel.CancellableEnumerable/<Wrap>d__0`1")]
internal static IEnumerable`1<TElement> Wrap(IEnumerable`1<TElement> source, CancellationToken token);
}
internal class System.Linq.Parallel.CancellationState : object {
    internal CancellationTokenSource InternalCancellationTokenSource;
    internal CancellationToken ExternalCancellationToken;
    internal CancellationTokenSource MergedCancellationTokenSource;
    internal Shared`1<bool> TopLevelDisposedFlag;
    internal CancellationToken MergedCancellationToken { get; }
    internal CancellationState(CancellationToken externalCancellationToken);
    internal CancellationToken get_MergedCancellationToken();
    internal static void ThrowIfCanceled(CancellationToken token);
    internal static void ThrowWithStandardMessageIfCanceled(CancellationToken externalCancellationToken);
}
internal class System.Linq.Parallel.ConcatKey`2 : ValueType {
    private TLeftKey _leftKey;
    private TRightKey _rightKey;
    private bool _isLeft;
    private ConcatKey`2(TLeftKey leftKey, TRightKey rightKey, bool isLeft);
    internal static ConcatKey`2<TLeftKey, TRightKey> MakeLeft(TLeftKey leftKey);
    internal static ConcatKey`2<TLeftKey, TRightKey> MakeRight(TRightKey rightKey);
    internal static IComparer`1<ConcatKey`2<TLeftKey, TRightKey>> MakeComparer(IComparer`1<TLeftKey> leftComparer, IComparer`1<TRightKey> rightComparer);
}
internal class System.Linq.Parallel.ConcatQueryOperator`1 : BinaryQueryOperator`3<TSource, TSource, TSource> {
    private bool _prematureMergeLeft;
    private bool _prematureMergeRight;
    internal bool LimitsParallelism { get; }
    internal ConcatQueryOperator`1(ParallelQuery`1<TSource> firstChild, ParallelQuery`1<TSource> secondChild);
    internal virtual QueryResults`1<TSource> Open(QuerySettings settings, bool preferStriping);
    public virtual void WrapPartitionedStream(PartitionedStream`2<TSource, TLeftKey> leftStream, PartitionedStream`2<TSource, TRightKey> rightStream, IPartitionedStreamRecipient`1<TSource> outputRecipient, bool preferStriping, QuerySettings settings);
    private void WrapHelper(PartitionedStream`2<TSource, TLeftKey> leftStreamInc, PartitionedStream`2<TSource, TRightKey> rightStream, IPartitionedStreamRecipient`1<TSource> outputRecipient, QuerySettings settings, bool preferStriping);
    private void WrapHelper2(PartitionedStream`2<TSource, TLeftKey> leftStreamInc, PartitionedStream`2<TSource, TRightKey> rightStreamInc, IPartitionedStreamRecipient`1<TSource> outputRecipient);
    internal virtual IEnumerable`1<TSource> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal class System.Linq.Parallel.ContainsSearchOperator`1 : UnaryQueryOperator`2<TInput, bool> {
    private TInput _searchValue;
    private IEqualityComparer`1<TInput> _comparer;
    internal bool LimitsParallelism { get; }
    internal ContainsSearchOperator`1(IEnumerable`1<TInput> child, TInput searchValue, IEqualityComparer`1<TInput> comparer);
    internal bool Aggregate();
    internal virtual QueryResults`1<bool> Open(QuerySettings settings, bool preferStriping);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TInput, TKey> inputStream, IPartitionedStreamRecipient`1<bool> recipient, bool preferStriping, QuerySettings settings);
    [ExcludeFromCodeCoverageAttribute]
internal virtual IEnumerable`1<bool> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal class System.Linq.Parallel.CountAggregationOperator`1 : InlinedAggregationOperator`3<TSource, int, int> {
    internal CountAggregationOperator`1(IEnumerable`1<TSource> child);
    protected virtual int InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<int, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<TSource, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.DecimalAverageAggregationOperator : InlinedAggregationOperator`3<decimal, Pair`2<decimal, long>, decimal> {
    internal DecimalAverageAggregationOperator(IEnumerable`1<decimal> child);
    protected virtual decimal InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Pair`2<decimal, long>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<decimal, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.DecimalMinMaxAggregationOperator : InlinedAggregationOperator`3<decimal, decimal, decimal> {
    private int _sign;
    internal DecimalMinMaxAggregationOperator(IEnumerable`1<decimal> child, int sign);
    protected virtual decimal InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<decimal, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<decimal, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.DecimalSumAggregationOperator : InlinedAggregationOperator`3<decimal, decimal, decimal> {
    internal DecimalSumAggregationOperator(IEnumerable`1<decimal> child);
    protected virtual decimal InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<decimal, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<decimal, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.DefaultIfEmptyQueryOperator`1 : UnaryQueryOperator`2<TSource, TSource> {
    private TSource _defaultValue;
    internal bool LimitsParallelism { get; }
    internal DefaultIfEmptyQueryOperator`1(IEnumerable`1<TSource> child, TSource defaultValue);
    internal virtual QueryResults`1<TSource> Open(QuerySettings settings, bool preferStriping);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TSource, TKey> inputStream, IPartitionedStreamRecipient`1<TSource> recipient, bool preferStriping, QuerySettings settings);
    internal virtual IEnumerable`1<TSource> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal class System.Linq.Parallel.DefaultMergeHelper`2 : object {
    private QueryTaskGroupState _taskGroupState;
    private PartitionedStream`2<TInputOutput, TIgnoreKey> _partitions;
    private AsynchronousChannel`1[] _asyncChannels;
    private SynchronousChannel`1[] _syncChannels;
    private IEnumerator`1<TInputOutput> _channelEnumerator;
    private TaskScheduler _taskScheduler;
    private bool _ignoreOutput;
    internal DefaultMergeHelper`2(PartitionedStream`2<TInputOutput, TIgnoreKey> partitions, bool ignoreOutput, ParallelMergeOptions options, TaskScheduler taskScheduler, CancellationState cancellationState, int queryId);
    private sealed virtual override void System.Linq.Parallel.IMergeHelper<TInputOutput>.Execute();
    private sealed virtual override IEnumerator`1<TInputOutput> System.Linq.Parallel.IMergeHelper<TInputOutput>.GetEnumerator();
    public sealed virtual TInputOutput[] GetResultsAsArray();
}
internal class System.Linq.Parallel.DistinctQueryOperator`1 : UnaryQueryOperator`2<TInputOutput, TInputOutput> {
    private IEqualityComparer`1<TInputOutput> _comparer;
    internal bool LimitsParallelism { get; }
    internal DistinctQueryOperator`1(IEnumerable`1<TInputOutput> source, IEqualityComparer`1<TInputOutput> comparer);
    internal virtual QueryResults`1<TInputOutput> Open(QuerySettings settings, bool preferStriping);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TInputOutput, TKey> inputStream, IPartitionedStreamRecipient`1<TInputOutput> recipient, bool preferStriping, QuerySettings settings);
    private void WrapPartitionedStreamHelper(PartitionedStream`2<Pair`2<TInputOutput, NoKeyMemoizationRequired>, TKey> hashStream, IPartitionedStreamRecipient`1<TInputOutput> recipient, CancellationToken cancellationToken);
    internal virtual bool get_LimitsParallelism();
    internal virtual IEnumerable`1<TInputOutput> AsSequentialQuery(CancellationToken token);
}
internal class System.Linq.Parallel.DoubleAverageAggregationOperator : InlinedAggregationOperator`3<double, Pair`2<double, long>, double> {
    internal DoubleAverageAggregationOperator(IEnumerable`1<double> child);
    protected virtual double InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Pair`2<double, long>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<double, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.DoubleMinMaxAggregationOperator : InlinedAggregationOperator`3<double, double, double> {
    private int _sign;
    internal DoubleMinMaxAggregationOperator(IEnumerable`1<double> child, int sign);
    protected virtual double InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<double, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<double, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.DoubleSumAggregationOperator : InlinedAggregationOperator`3<double, double, double> {
    internal DoubleSumAggregationOperator(IEnumerable`1<double> child);
    protected virtual double InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<double, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<double, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.ElementAtQueryOperator`1 : UnaryQueryOperator`2<TSource, TSource> {
    private int _index;
    private bool _prematureMerge;
    private bool _limitsParallelism;
    internal bool LimitsParallelism { get; }
    internal ElementAtQueryOperator`1(IEnumerable`1<TSource> child, int index);
    internal virtual QueryResults`1<TSource> Open(QuerySettings settings, bool preferStriping);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TSource, TKey> inputStream, IPartitionedStreamRecipient`1<TSource> recipient, bool preferStriping, QuerySettings settings);
    [ExcludeFromCodeCoverageAttribute]
internal virtual IEnumerable`1<TSource> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
    internal bool Aggregate(TSource& result, bool withDefaultValue);
}
internal class System.Linq.Parallel.EmptyEnumerable`1 : ParallelQuery`1<T> {
    private static EmptyEnumerable`1 modreq(System.Runtime.CompilerServices.IsVolatile) s_instance;
    private static EmptyEnumerator`1 modreq(System.Runtime.CompilerServices.IsVolatile) s_enumeratorInstance;
    internal static EmptyEnumerable`1<T> Instance { get; }
    internal static EmptyEnumerable`1<T> get_Instance();
    public virtual IEnumerator`1<T> GetEnumerator();
}
internal class System.Linq.Parallel.EmptyEnumerator`1 : QueryOperatorEnumerator`2<T, int> {
    public T Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal virtual bool MoveNext(T& currentElement, Int32& currentKey);
    public sealed virtual T get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
}
internal class System.Linq.Parallel.EnumerableWrapperWeakToStrong : object {
    private IEnumerable _wrappedEnumerable;
    internal EnumerableWrapperWeakToStrong(IEnumerable wrappedEnumerable);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<object> GetEnumerator();
}
internal static class System.Linq.Parallel.ExceptionAggregator : object {
    [IteratorStateMachineAttribute("System.Linq.Parallel.ExceptionAggregator/<WrapEnumerable>d__0`1")]
internal static IEnumerable`1<TElement> WrapEnumerable(IEnumerable`1<TElement> source, CancellationState cancellationState);
    [IteratorStateMachineAttribute("System.Linq.Parallel.ExceptionAggregator/<WrapQueryEnumerator>d__1`2")]
internal static IEnumerable`1<TElement> WrapQueryEnumerator(QueryOperatorEnumerator`2<TElement, TIgnoreKey> source, CancellationState cancellationState);
    internal static void ThrowOCEorAggregateException(Exception ex, CancellationState cancellationState);
    internal static Func`2<T, U> WrapFunc(Func`2<T, U> f, CancellationState cancellationState);
    private static bool ThrowAnOCE(Exception ex, CancellationState cancellationState);
}
internal class System.Linq.Parallel.ExceptQueryOperator`1 : BinaryQueryOperator`3<TInputOutput, TInputOutput, TInputOutput> {
    private IEqualityComparer`1<TInputOutput> _comparer;
    internal bool LimitsParallelism { get; }
    internal ExceptQueryOperator`1(ParallelQuery`1<TInputOutput> left, ParallelQuery`1<TInputOutput> right, IEqualityComparer`1<TInputOutput> comparer);
    internal virtual QueryResults`1<TInputOutput> Open(QuerySettings settings, bool preferStriping);
    public virtual void WrapPartitionedStream(PartitionedStream`2<TInputOutput, TLeftKey> leftStream, PartitionedStream`2<TInputOutput, TRightKey> rightStream, IPartitionedStreamRecipient`1<TInputOutput> outputRecipient, bool preferStriping, QuerySettings settings);
    private void WrapPartitionedStreamHelper(PartitionedStream`2<Pair`2<TInputOutput, NoKeyMemoizationRequired>, TLeftKey> leftHashStream, PartitionedStream`2<TInputOutput, TRightKey> rightPartitionedStream, IPartitionedStreamRecipient`1<TInputOutput> outputRecipient, CancellationToken cancellationToken);
    internal virtual IEnumerable`1<TInputOutput> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
[ExtensionAttribute]
internal static class System.Linq.Parallel.ExchangeUtilities : object {
    internal static PartitionedStream`2<T, int> PartitionDataSource(IEnumerable`1<T> source, int partitionCount, bool useStriping);
    internal static PartitionedStream`2<Pair`2<TElement, THashKey>, int> HashRepartition(PartitionedStream`2<TElement, TIgnoreKey> source, Func`2<TElement, THashKey> keySelector, IEqualityComparer`1<THashKey> keyComparer, IEqualityComparer`1<TElement> elementComparer, CancellationToken cancellationToken);
    internal static PartitionedStream`2<Pair`2<TElement, THashKey>, TOrderKey> HashRepartitionOrdered(PartitionedStream`2<TElement, TOrderKey> source, Func`2<TElement, THashKey> keySelector, IEqualityComparer`1<THashKey> keyComparer, IEqualityComparer`1<TElement> elementComparer, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static OrdinalIndexState Worse(OrdinalIndexState state1, OrdinalIndexState state2);
    [ExtensionAttribute]
internal static bool IsWorseThan(OrdinalIndexState state1, OrdinalIndexState state2);
}
internal class System.Linq.Parallel.FirstQueryOperator`1 : UnaryQueryOperator`2<TSource, TSource> {
    private Func`2<TSource, bool> _predicate;
    private bool _prematureMergeNeeded;
    internal bool LimitsParallelism { get; }
    internal FirstQueryOperator`1(IEnumerable`1<TSource> child, Func`2<TSource, bool> predicate);
    internal virtual QueryResults`1<TSource> Open(QuerySettings settings, bool preferStriping);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TSource, TKey> inputStream, IPartitionedStreamRecipient`1<TSource> recipient, bool preferStriping, QuerySettings settings);
    private void WrapHelper(PartitionedStream`2<TSource, TKey> inputStream, IPartitionedStreamRecipient`1<TSource> recipient, QuerySettings settings);
    [ExcludeFromCodeCoverageAttribute]
internal virtual IEnumerable`1<TSource> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal class System.Linq.Parallel.FixedMaxHeap`1 : object {
    private TElement[] _elements;
    private int _count;
    private IComparer`1<TElement> _comparer;
    internal int Count { get; }
    internal int Size { get; }
    internal TElement MaxValue { get; }
    internal FixedMaxHeap`1(int maximumSize, IComparer`1<TElement> comparer);
    internal int get_Count();
    internal int get_Size();
    internal TElement get_MaxValue();
    internal void Clear();
    internal bool Insert(TElement e);
    internal void ReplaceMax(TElement newValue);
    internal void RemoveMax();
    private void Swap(int i, int j);
    private void HeapifyRoot();
    private void HeapifyLastLeaf();
}
internal class System.Linq.Parallel.FloatAverageAggregationOperator : InlinedAggregationOperator`3<float, Pair`2<double, long>, float> {
    internal FloatAverageAggregationOperator(IEnumerable`1<float> child);
    protected virtual float InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Pair`2<double, long>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<float, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.FloatMinMaxAggregationOperator : InlinedAggregationOperator`3<float, float, float> {
    private int _sign;
    internal FloatMinMaxAggregationOperator(IEnumerable`1<float> child, int sign);
    protected virtual float InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<float, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<float, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.FloatSumAggregationOperator : InlinedAggregationOperator`3<float, double, float> {
    internal FloatSumAggregationOperator(IEnumerable`1<float> child);
    protected virtual float InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<double, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<float, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.ForAllOperator`1 : UnaryQueryOperator`2<TInput, TInput> {
    private Action`1<TInput> _elementAction;
    internal bool LimitsParallelism { get; }
    internal ForAllOperator`1(IEnumerable`1<TInput> child, Action`1<TInput> elementAction);
    internal void RunSynchronously();
    internal virtual QueryResults`1<TInput> Open(QuerySettings settings, bool preferStriping);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TInput, TKey> inputStream, IPartitionedStreamRecipient`1<TInput> recipient, bool preferStriping, QuerySettings settings);
    [ExcludeFromCodeCoverageAttribute]
internal virtual IEnumerable`1<TInput> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal class System.Linq.Parallel.ForAllSpoolingTask`2 : SpoolingTaskBase {
    private QueryOperatorEnumerator`2<TInputOutput, TIgnoreKey> _source;
    internal ForAllSpoolingTask`2(int taskIndex, QueryTaskGroupState groupState, QueryOperatorEnumerator`2<TInputOutput, TIgnoreKey> source);
    protected virtual void SpoolingWork();
    protected virtual void SpoolingFinally();
}
internal class System.Linq.Parallel.GroupByElementSelectorQueryOperatorEnumerator`4 : GroupByQueryOperatorEnumerator`4<TSource, TGroupKey, TElement, TOrderKey> {
    private Func`2<TSource, TElement> _elementSelector;
    internal GroupByElementSelectorQueryOperatorEnumerator`4(QueryOperatorEnumerator`2<Pair`2<TSource, TGroupKey>, TOrderKey> source, IEqualityComparer`1<TGroupKey> keyComparer, Func`2<TSource, TElement> elementSelector, CancellationToken cancellationToken);
    protected virtual HashLookup`2<Wrapper`1<TGroupKey>, ListChunk`1<TElement>> BuildHashLookup();
}
internal class System.Linq.Parallel.GroupByGrouping`2 : object {
    private KeyValuePair`2<Wrapper`1<TGroupKey>, ListChunk`1<TElement>> _keyValues;
    private TGroupKey System.Linq.IGrouping<TGroupKey,TElement>.Key { get; }
    internal GroupByGrouping`2(KeyValuePair`2<Wrapper`1<TGroupKey>, ListChunk`1<TElement>> keyValues);
    private sealed virtual override TGroupKey System.Linq.IGrouping<TGroupKey,TElement>.get_Key();
    private sealed virtual override IEnumerator`1<TElement> System.Collections.Generic.IEnumerable<TElement>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class System.Linq.Parallel.GroupByIdentityQueryOperatorEnumerator`3 : GroupByQueryOperatorEnumerator`4<TSource, TGroupKey, TSource, TOrderKey> {
    internal GroupByIdentityQueryOperatorEnumerator`3(QueryOperatorEnumerator`2<Pair`2<TSource, TGroupKey>, TOrderKey> source, IEqualityComparer`1<TGroupKey> keyComparer, CancellationToken cancellationToken);
    protected virtual HashLookup`2<Wrapper`1<TGroupKey>, ListChunk`1<TSource>> BuildHashLookup();
}
internal class System.Linq.Parallel.GroupByQueryOperator`3 : UnaryQueryOperator`2<TSource, IGrouping`2<TGroupKey, TElement>> {
    private Func`2<TSource, TGroupKey> _keySelector;
    private Func`2<TSource, TElement> _elementSelector;
    private IEqualityComparer`1<TGroupKey> _keyComparer;
    internal bool LimitsParallelism { get; }
    internal GroupByQueryOperator`3(IEnumerable`1<TSource> child, Func`2<TSource, TGroupKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TGroupKey> keyComparer);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TSource, TKey> inputStream, IPartitionedStreamRecipient`1<IGrouping`2<TGroupKey, TElement>> recipient, bool preferStriping, QuerySettings settings);
    private void WrapPartitionedStreamHelper(PartitionedStream`2<Pair`2<TSource, TGroupKey>, TKey> hashStream, IPartitionedStreamRecipient`1<IGrouping`2<TGroupKey, TElement>> recipient, CancellationToken cancellationToken);
    private void WrapPartitionedStreamHelperOrdered(PartitionedStream`2<Pair`2<TSource, TGroupKey>, TKey> hashStream, IPartitionedStreamRecipient`1<IGrouping`2<TGroupKey, TElement>> recipient, CancellationToken cancellationToken);
    internal virtual QueryResults`1<IGrouping`2<TGroupKey, TElement>> Open(QuerySettings settings, bool preferStriping);
    internal virtual IEnumerable`1<IGrouping`2<TGroupKey, TElement>> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal abstract class System.Linq.Parallel.GroupByQueryOperatorEnumerator`4 : QueryOperatorEnumerator`2<IGrouping`2<TGroupKey, TElement>, TOrderKey> {
    protected QueryOperatorEnumerator`2<Pair`2<TSource, TGroupKey>, TOrderKey> _source;
    protected IEqualityComparer`1<TGroupKey> _keyComparer;
    protected CancellationToken _cancellationToken;
    private Mutables<TSource, TGroupKey, TElement, TOrderKey> _mutables;
    protected GroupByQueryOperatorEnumerator`4(QueryOperatorEnumerator`2<Pair`2<TSource, TGroupKey>, TOrderKey> source, IEqualityComparer`1<TGroupKey> keyComparer, CancellationToken cancellationToken);
    internal virtual bool MoveNext(IGrouping`2& currentElement, TOrderKey& currentKey);
    protected abstract virtual HashLookup`2<Wrapper`1<TGroupKey>, ListChunk`1<TElement>> BuildHashLookup();
    protected virtual void Dispose(bool disposing);
}
internal abstract class System.Linq.Parallel.GroupJoinHashLookup`4 : HashJoinHashLookup`3<THashKey, IEnumerable`1<TElement>, TOrderKey> {
    private HashLookup`2<THashKey, TBaseElement> _base;
    protected TOrderKey EmptyValueKey { get; }
    internal GroupJoinHashLookup`4(HashLookup`2<THashKey, TBaseElement> baseLookup);
    public virtual bool TryGetValue(THashKey key, HashLookupValueList`2& value);
    private Pair`2<IEnumerable`1<TElement>, TOrderKey> GetValueList(THashKey key);
    protected abstract virtual Pair`2<IEnumerable`1<TElement>, TOrderKey> CreateValuePair(TBaseElement baseValue);
    protected abstract virtual TOrderKey get_EmptyValueKey();
}
internal class System.Linq.Parallel.GroupJoinHashLookupBuilder`3 : HashLookupBuilder`3<IEnumerable`1<TElement>, int, THashKey> {
    private QueryOperatorEnumerator`2<Pair`2<TElement, THashKey>, TOrderKey> _dataSource;
    private IEqualityComparer`1<THashKey> _keyComparer;
    internal GroupJoinHashLookupBuilder`3(QueryOperatorEnumerator`2<Pair`2<TElement, THashKey>, TOrderKey> dataSource, IEqualityComparer`1<THashKey> keyComparer);
    public virtual HashJoinHashLookup`3<THashKey, IEnumerable`1<TElement>, int> BuildHashLookup(CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.GroupJoinQueryOperator`4 : BinaryQueryOperator`3<TLeftInput, TRightInput, TOutput> {
    private Func`2<TLeftInput, TKey> _leftKeySelector;
    private Func`2<TRightInput, TKey> _rightKeySelector;
    private Func`3<TLeftInput, IEnumerable`1<TRightInput>, TOutput> _resultSelector;
    private IEqualityComparer`1<TKey> _keyComparer;
    internal bool LimitsParallelism { get; }
    internal GroupJoinQueryOperator`4(ParallelQuery`1<TLeftInput> left, ParallelQuery`1<TRightInput> right, Func`2<TLeftInput, TKey> leftKeySelector, Func`2<TRightInput, TKey> rightKeySelector, Func`3<TLeftInput, IEnumerable`1<TRightInput>, TOutput> resultSelector, IEqualityComparer`1<TKey> keyComparer);
    internal virtual QueryResults`1<TOutput> Open(QuerySettings settings, bool preferStriping);
    public virtual void WrapPartitionedStream(PartitionedStream`2<TLeftInput, TLeftKey> leftStream, PartitionedStream`2<TRightInput, TRightKey> rightStream, IPartitionedStreamRecipient`1<TOutput> outputRecipient, bool preferStriping, QuerySettings settings);
    private void WrapPartitionedStreamHelper(PartitionedStream`2<Pair`2<TLeftInput, TKey>, TLeftKey> leftHashStream, PartitionedStream`2<TRightInput, TRightKey> rightPartitionedStream, IPartitionedStreamRecipient`1<TOutput> outputRecipient, int partitionCount, CancellationToken cancellationToken);
    private void WrapPartitionedStreamHelper(PartitionedStream`2<Pair`2<TLeftInput, TKey>, TLeftKey> leftHashStream, HashLookupBuilder`3[] rightLookupBuilders, IComparer`1<TRightKey> rightKeyComparer, IPartitionedStreamRecipient`1<TOutput> outputRecipient, int partitionCount, CancellationToken cancellationToken);
    private IComparer`1<Pair`2<bool, TRightKey>> CreateComparer(IComparer`1<TRightKey> comparer);
    private IComparer`1<Pair`2<TLeftKey, TRightKey>> CreateComparer(IComparer`1<TLeftKey> leftKeyComparer, IComparer`1<TRightKey> rightKeyComparer);
    private void WrapPartitionedStreamHelper(PartitionedStream`2<Pair`2<TLeftInput, TKey>, TLeftKey> leftHashStream, HashLookupBuilder`3[] rightLookupBuilders, HashJoinOutputKeyBuilder`3<TLeftKey, TRightKey, TOutputKey> outputKeyBuilder, IComparer`1<TOutputKey> outputKeyComparer, IPartitionedStreamRecipient`1<TOutput> outputRecipient, int partitionCount, CancellationToken cancellationToken);
    internal virtual IEnumerable`1<TOutput> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal class System.Linq.Parallel.GrowingArray`1 : object {
    private T[] _array;
    private int _count;
    internal T[] InternalArray { get; }
    internal T[] get_InternalArray();
    internal void Add(T element);
    private void GrowArray(int newSize);
    internal void CopyFrom(T[] otherArray, int otherCount);
}
internal abstract class System.Linq.Parallel.HashJoinHashLookup`3 : object {
    public abstract virtual bool TryGetValue(THashKey key, HashLookupValueList`2& value);
}
internal abstract class System.Linq.Parallel.HashJoinOutputKeyBuilder`3 : object {
    public abstract virtual TOutputKey Combine(TLeftKey leftKey, TRightKey rightKey);
}
internal class System.Linq.Parallel.HashJoinQueryOperatorEnumerator`7 : QueryOperatorEnumerator`2<TOutput, TOutputKey> {
    private QueryOperatorEnumerator`2<Pair`2<TLeftInput, THashKey>, TLeftKey> _leftSource;
    private HashLookupBuilder`3<TRightInput, TRightKey, THashKey> _rightLookupBuilder;
    private Func`3<TLeftInput, TRightInput, TOutput> _resultSelector;
    private HashJoinOutputKeyBuilder`3<TLeftKey, TRightKey, TOutputKey> _outputKeyBuilder;
    private CancellationToken _cancellationToken;
    private Mutables<TLeftInput, TLeftKey, TRightInput, TRightKey, THashKey, TOutput, TOutputKey> _mutables;
    internal HashJoinQueryOperatorEnumerator`7(QueryOperatorEnumerator`2<Pair`2<TLeftInput, THashKey>, TLeftKey> leftSource, HashLookupBuilder`3<TRightInput, TRightKey, THashKey> rightLookupBuilder, Func`3<TLeftInput, TRightInput, TOutput> resultSelector, HashJoinOutputKeyBuilder`3<TLeftKey, TRightKey, TOutputKey> outputKeyBuilder, CancellationToken cancellationToken);
    internal virtual bool MoveNext(TOutput& currentElement, TOutputKey& currentKey);
    protected virtual void Dispose(bool disposing);
}
[DefaultMemberAttribute("Item")]
internal class System.Linq.Parallel.HashLookup`2 : object {
    private Int32[] buckets;
    private Slot[] slots;
    private int count;
    private int freeList;
    private IEqualityComparer`1<TKey> comparer;
    unknown TValue Item {internal set; }
    internal int Count { get; }
    internal KeyValuePair`2<TKey, TValue> Item { get; }
    internal HashLookup`2(IEqualityComparer`1<TKey> comparer);
    internal bool Add(TKey key, TValue value);
    internal bool TryGetValue(TKey key, TValue& value);
    internal void set_Item(TKey key, TValue value);
    private int GetKeyHashCode(TKey key);
    private bool AreKeysEqual(TKey key1, TKey key2);
    private bool Find(TKey key, bool add, bool set, TValue& value);
    private void Resize();
    internal int get_Count();
    internal KeyValuePair`2<TKey, TValue> get_Item(int index);
}
internal abstract class System.Linq.Parallel.HashLookupBuilder`3 : object {
    public abstract virtual HashJoinHashLookup`3<THashKey, TElement, TOrderKey> BuildHashLookup(CancellationToken cancellationToken);
    protected void BuildBaseHashLookup(QueryOperatorEnumerator`2<Pair`2<TBaseElement, THashKey>, TBaseOrderKey> dataSource, TBaseBuilder baseHashBuilder, CancellationToken cancellationToken);
    public void Dispose();
    protected virtual void Dispose(bool disposing);
}
internal class System.Linq.Parallel.HashLookupValueList`2 : ValueType {
    private Pair`2<TElement, TOrderKey> _head;
    private ListChunk`1<Pair`2<TElement, TOrderKey>> _tail;
    internal Pair`2<TElement, TOrderKey> Head { get; }
    internal ListChunk`1<Pair`2<TElement, TOrderKey>> Tail { get; }
    internal HashLookupValueList`2(TElement firstValue, TOrderKey firstOrderKey);
    internal Pair`2<TElement, TOrderKey> get_Head();
    internal ListChunk`1<Pair`2<TElement, TOrderKey>> get_Tail();
    internal bool Add(TElement value, TOrderKey orderKey);
    private static Pair`2<TElement, TOrderKey> CreatePair(TElement value, TOrderKey orderKey);
}
internal class System.Linq.Parallel.HashRepartitionEnumerator`3 : QueryOperatorEnumerator`2<Pair`2<TInputOutput, THashKey>, int> {
    private int _partitionCount;
    private int _partitionIndex;
    private Func`2<TInputOutput, THashKey> _keySelector;
    private HashRepartitionStream`3<TInputOutput, THashKey, int> _repartitionStream;
    private ListChunk`1[][] _valueExchangeMatrix;
    private QueryOperatorEnumerator`2<TInputOutput, TIgnoreKey> _source;
    private CountdownEvent _barrier;
    private CancellationToken _cancellationToken;
    private Mutables<TInputOutput, THashKey, TIgnoreKey> _mutables;
    internal HashRepartitionEnumerator`3(QueryOperatorEnumerator`2<TInputOutput, TIgnoreKey> source, int partitionCount, int partitionIndex, Func`2<TInputOutput, THashKey> keySelector, HashRepartitionStream`3<TInputOutput, THashKey, int> repartitionStream, CountdownEvent barrier, ListChunk`1[][] valueExchangeMatrix, CancellationToken cancellationToken);
    internal virtual bool MoveNext(Pair`2& currentElement, Int32& currentKey);
    private void EnumerateAndRedistributeElements();
    protected virtual void Dispose(bool disposed);
}
internal abstract class System.Linq.Parallel.HashRepartitionStream`3 : PartitionedStream`2<Pair`2<TInputOutput, THashKey>, TOrderKey> {
    private IEqualityComparer`1<THashKey> _keyComparer;
    private IEqualityComparer`1<TInputOutput> _elementComparer;
    private int _distributionMod;
    internal HashRepartitionStream`3(int partitionsCount, IComparer`1<TOrderKey> orderKeyComparer, IEqualityComparer`1<THashKey> hashKeyComparer, IEqualityComparer`1<TInputOutput> elementComparer);
    internal int GetHashCode(TInputOutput element);
    internal int GetHashCode(THashKey key);
}
internal interface System.Linq.Parallel.IMergeHelper`1 {
    public abstract virtual void Execute();
    public abstract virtual IEnumerator`1<TInputOutput> GetEnumerator();
    public abstract virtual TInputOutput[] GetResultsAsArray();
}
internal class System.Linq.Parallel.IndexedSelectQueryOperator`2 : UnaryQueryOperator`2<TInput, TOutput> {
    private Func`3<TInput, int, TOutput> _selector;
    private bool _prematureMerge;
    private bool _limitsParallelism;
    internal bool LimitsParallelism { get; }
    internal IndexedSelectQueryOperator`2(IEnumerable`1<TInput> child, Func`3<TInput, int, TOutput> selector);
    private void InitOrdinalIndexState();
    internal virtual QueryResults`1<TOutput> Open(QuerySettings settings, bool preferStriping);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TInput, TKey> inputStream, IPartitionedStreamRecipient`1<TOutput> recipient, bool preferStriping, QuerySettings settings);
    internal virtual bool get_LimitsParallelism();
    internal virtual IEnumerable`1<TOutput> AsSequentialQuery(CancellationToken token);
}
internal class System.Linq.Parallel.IndexedWhereQueryOperator`1 : UnaryQueryOperator`2<TInputOutput, TInputOutput> {
    private Func`3<TInputOutput, int, bool> _predicate;
    private bool _prematureMerge;
    private bool _limitsParallelism;
    internal bool LimitsParallelism { get; }
    internal IndexedWhereQueryOperator`1(IEnumerable`1<TInputOutput> child, Func`3<TInputOutput, int, bool> predicate);
    private void InitOrdinalIndexState();
    internal virtual QueryResults`1<TInputOutput> Open(QuerySettings settings, bool preferStriping);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TInputOutput, TKey> inputStream, IPartitionedStreamRecipient`1<TInputOutput> recipient, bool preferStriping, QuerySettings settings);
    internal virtual IEnumerable`1<TInputOutput> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal abstract class System.Linq.Parallel.InlinedAggregationOperator`3 : UnaryQueryOperator`2<TSource, TIntermediate> {
    internal bool LimitsParallelism { get; }
    internal InlinedAggregationOperator`3(IEnumerable`1<TSource> child);
    internal TResult Aggregate();
    protected abstract virtual TResult InternalAggregate(Exception& singularExceptionToThrow);
    internal virtual QueryResults`1<TIntermediate> Open(QuerySettings settings, bool preferStriping);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TSource, TKey> inputStream, IPartitionedStreamRecipient`1<TIntermediate> recipient, bool preferStriping, QuerySettings settings);
    protected abstract virtual QueryOperatorEnumerator`2<TIntermediate, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<TSource, TKey> source, object sharedData, CancellationToken cancellationToken);
    [ExcludeFromCodeCoverageAttribute]
internal virtual IEnumerable`1<TIntermediate> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal abstract class System.Linq.Parallel.InlinedAggregationOperatorEnumerator`1 : QueryOperatorEnumerator`2<TIntermediate, int> {
    private int _partitionIndex;
    private bool _done;
    protected CancellationToken _cancellationToken;
    internal InlinedAggregationOperatorEnumerator`1(int partitionIndex, CancellationToken cancellationToken);
    internal sealed virtual bool MoveNext(TIntermediate& currentElement, Int32& currentKey);
    protected abstract virtual bool MoveNextCore(TIntermediate& currentElement);
}
internal class System.Linq.Parallel.IntAverageAggregationOperator : InlinedAggregationOperator`3<int, Pair`2<long, long>, double> {
    internal IntAverageAggregationOperator(IEnumerable`1<int> child);
    protected virtual double InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Pair`2<long, long>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<int, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.IntersectQueryOperator`1 : BinaryQueryOperator`3<TInputOutput, TInputOutput, TInputOutput> {
    private IEqualityComparer`1<TInputOutput> _comparer;
    internal bool LimitsParallelism { get; }
    internal IntersectQueryOperator`1(ParallelQuery`1<TInputOutput> left, ParallelQuery`1<TInputOutput> right, IEqualityComparer`1<TInputOutput> comparer);
    internal virtual QueryResults`1<TInputOutput> Open(QuerySettings settings, bool preferStriping);
    public virtual void WrapPartitionedStream(PartitionedStream`2<TInputOutput, TLeftKey> leftPartitionedStream, PartitionedStream`2<TInputOutput, TRightKey> rightPartitionedStream, IPartitionedStreamRecipient`1<TInputOutput> outputRecipient, bool preferStriping, QuerySettings settings);
    private void WrapPartitionedStreamHelper(PartitionedStream`2<Pair`2<TInputOutput, NoKeyMemoizationRequired>, TLeftKey> leftHashStream, PartitionedStream`2<TInputOutput, TRightKey> rightPartitionedStream, IPartitionedStreamRecipient`1<TInputOutput> outputRecipient, CancellationToken cancellationToken);
    internal virtual bool get_LimitsParallelism();
    internal virtual IEnumerable`1<TInputOutput> AsSequentialQuery(CancellationToken token);
}
internal class System.Linq.Parallel.IntMinMaxAggregationOperator : InlinedAggregationOperator`3<int, int, int> {
    private int _sign;
    internal IntMinMaxAggregationOperator(IEnumerable`1<int> child, int sign);
    protected virtual int InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<int, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<int, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.IntSumAggregationOperator : InlinedAggregationOperator`3<int, int, int> {
    internal IntSumAggregationOperator(IEnumerable`1<int> child);
    protected virtual int InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<int, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<int, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.IntValueEvent : ManualResetEventSlim {
    internal int Value;
    internal void Set(int index);
}
internal interface System.Linq.Parallel.IParallelPartitionable`1 {
    public abstract virtual QueryOperatorEnumerator`2[] GetPartitions(int partitionCount);
}
internal interface System.Linq.Parallel.IPartitionedStreamRecipient`1 {
    public abstract virtual void Receive(PartitionedStream`2<TElement, TKey> partitionedStream);
}
internal class System.Linq.Parallel.JaggedArray`1 : object {
    public static TElement[][] Allocate(int size1, int size2);
}
internal class System.Linq.Parallel.JoinHashLookupBuilder`3 : HashLookupBuilder`3<TElement, TOrderKey, THashKey> {
    private QueryOperatorEnumerator`2<Pair`2<TElement, THashKey>, TOrderKey> _dataSource;
    private IEqualityComparer`1<THashKey> _keyComparer;
    internal JoinHashLookupBuilder`3(QueryOperatorEnumerator`2<Pair`2<TElement, THashKey>, TOrderKey> dataSource, IEqualityComparer`1<THashKey> keyComparer);
    public virtual HashJoinHashLookup`3<THashKey, TElement, TOrderKey> BuildHashLookup(CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
}
internal class System.Linq.Parallel.JoinQueryOperator`4 : BinaryQueryOperator`3<TLeftInput, TRightInput, TOutput> {
    private Func`2<TLeftInput, TKey> _leftKeySelector;
    private Func`2<TRightInput, TKey> _rightKeySelector;
    private Func`3<TLeftInput, TRightInput, TOutput> _resultSelector;
    private IEqualityComparer`1<TKey> _keyComparer;
    internal bool LimitsParallelism { get; }
    internal JoinQueryOperator`4(ParallelQuery`1<TLeftInput> left, ParallelQuery`1<TRightInput> right, Func`2<TLeftInput, TKey> leftKeySelector, Func`2<TRightInput, TKey> rightKeySelector, Func`3<TLeftInput, TRightInput, TOutput> resultSelector, IEqualityComparer`1<TKey> keyComparer);
    public virtual void WrapPartitionedStream(PartitionedStream`2<TLeftInput, TLeftKey> leftStream, PartitionedStream`2<TRightInput, TRightKey> rightStream, IPartitionedStreamRecipient`1<TOutput> outputRecipient, bool preferStriping, QuerySettings settings);
    private void WrapPartitionedStreamHelper(PartitionedStream`2<Pair`2<TLeftInput, TKey>, TLeftKey> leftHashStream, PartitionedStream`2<TRightInput, TRightKey> rightPartitionedStream, IPartitionedStreamRecipient`1<TOutput> outputRecipient, CancellationToken cancellationToken);
    private void WrapPartitionedStreamHelper(PartitionedStream`2<Pair`2<TLeftInput, TKey>, TLeftKey> leftHashStream, PartitionedStream`2<Pair`2<TRightInput, TKey>, TRightKey> rightHashStream, HashJoinOutputKeyBuilder`3<TLeftKey, TRightKey, TOutputKey> outputKeyBuilder, IComparer`1<TOutputKey> outputKeyComparer, IPartitionedStreamRecipient`1<TOutput> outputRecipient, CancellationToken cancellationToken);
    internal virtual QueryResults`1<TOutput> Open(QuerySettings settings, bool preferStriping);
    internal virtual IEnumerable`1<TOutput> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal class System.Linq.Parallel.LastQueryOperator`1 : UnaryQueryOperator`2<TSource, TSource> {
    private Func`2<TSource, bool> _predicate;
    private bool _prematureMergeNeeded;
    internal bool LimitsParallelism { get; }
    internal LastQueryOperator`1(IEnumerable`1<TSource> child, Func`2<TSource, bool> predicate);
    internal virtual QueryResults`1<TSource> Open(QuerySettings settings, bool preferStriping);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TSource, TKey> inputStream, IPartitionedStreamRecipient`1<TSource> recipient, bool preferStriping, QuerySettings settings);
    private void WrapHelper(PartitionedStream`2<TSource, TKey> inputStream, IPartitionedStreamRecipient`1<TSource> recipient, QuerySettings settings);
    [ExcludeFromCodeCoverageAttribute]
internal virtual IEnumerable`1<TSource> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal class System.Linq.Parallel.LeftKeyOutputKeyBuilder`2 : HashJoinOutputKeyBuilder`3<TLeftKey, TRightKey, TLeftKey> {
    public virtual TLeftKey Combine(TLeftKey leftKey, TRightKey rightKey);
}
internal class System.Linq.Parallel.ListChunk`1 : object {
    internal TInputOutput[] _chunk;
    private int _chunkCount;
    private ListChunk`1<TInputOutput> _nextChunk;
    private ListChunk`1<TInputOutput> _tailChunk;
    internal ListChunk`1<TInputOutput> Next { get; }
    internal int Count { get; }
    internal ListChunk`1(int size);
    internal void Add(TInputOutput e);
    internal ListChunk`1<TInputOutput> get_Next();
    internal int get_Count();
    [IteratorStateMachineAttribute("System.Linq.Parallel.ListChunk`1/<GetEnumerator>d__10")]
public sealed virtual IEnumerator`1<TInputOutput> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class System.Linq.Parallel.ListQueryResults`1 : QueryResults`1<T> {
    private IList`1<T> _source;
    private int _partitionCount;
    private bool _useStriping;
    internal bool IsIndexible { get; }
    internal int ElementsCount { get; }
    internal ListQueryResults`1(IList`1<T> source, int partitionCount, bool useStriping);
    internal virtual void GivePartitionedStream(IPartitionedStreamRecipient`1<T> recipient);
    internal virtual bool get_IsIndexible();
    internal virtual int get_ElementsCount();
    internal virtual T GetElement(int index);
    internal PartitionedStream`2<T, int> GetPartitionedStream();
}
internal class System.Linq.Parallel.LongAverageAggregationOperator : InlinedAggregationOperator`3<long, Pair`2<long, long>, double> {
    internal LongAverageAggregationOperator(IEnumerable`1<long> child);
    protected virtual double InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Pair`2<long, long>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<long, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.LongCountAggregationOperator`1 : InlinedAggregationOperator`3<TSource, long, long> {
    internal LongCountAggregationOperator`1(IEnumerable`1<TSource> child);
    protected virtual long InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<long, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<TSource, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.LongMinMaxAggregationOperator : InlinedAggregationOperator`3<long, long, long> {
    private int _sign;
    internal LongMinMaxAggregationOperator(IEnumerable`1<long> child, int sign);
    protected virtual long InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<long, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<long, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.LongSumAggregationOperator : InlinedAggregationOperator`3<long, long, long> {
    internal LongSumAggregationOperator(IEnumerable`1<long> child);
    protected virtual long InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<long, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<long, TKey> source, object sharedData, CancellationToken cancellationToken);
}
[DefaultMemberAttribute("Item")]
internal class System.Linq.Parallel.Lookup`2 : object {
    private IDictionary`2<TKey, IGrouping`2<TKey, TElement>> _dict;
    private IEqualityComparer`1<TKey> _comparer;
    private IGrouping`2<TKey, TElement> _defaultKeyGrouping;
    public int Count { get; }
    public IEnumerable`1<TElement> Item { get; }
    internal Lookup`2(IEqualityComparer`1<TKey> comparer);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerable`1<TElement> get_Item(TKey key);
    public sealed virtual bool Contains(TKey key);
    internal void Add(IGrouping`2<TKey, TElement> grouping);
    [IteratorStateMachineAttribute("System.Linq.Parallel.Lookup`2/<GetEnumerator>d__10")]
public sealed virtual IEnumerator`1<IGrouping`2<TKey, TElement>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal abstract class System.Linq.Parallel.MergeEnumerator`1 : object {
    protected QueryTaskGroupState _taskGroupState;
    public TInputOutput Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    protected MergeEnumerator`1(QueryTaskGroupState taskGroupState);
    public abstract virtual TInputOutput get_Current();
    public abstract virtual bool MoveNext();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public virtual void Reset();
    public virtual void Dispose();
}
internal class System.Linq.Parallel.MergeExecutor`1 : object {
    private IMergeHelper`1<TInputOutput> _mergeHelper;
    internal static MergeExecutor`1<TInputOutput> Execute(PartitionedStream`2<TInputOutput, TKey> partitions, bool ignoreOutput, ParallelMergeOptions options, TaskScheduler taskScheduler, bool isOrdered, CancellationState cancellationState, int queryId);
    private void Execute();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<TInputOutput> GetEnumerator();
    internal TInputOutput[] GetResultsAsArray();
    internal static AsynchronousChannel`1[] MakeAsynchronousChannels(int partitionCount, ParallelMergeOptions options, IntValueEvent consumerEvent, CancellationToken cancellationToken);
    internal static SynchronousChannel`1[] MakeSynchronousChannels(int partitionCount);
}
internal class System.Linq.Parallel.NoKeyMemoizationRequired : ValueType {
}
internal class System.Linq.Parallel.NullableDecimalAverageAggregationOperator : InlinedAggregationOperator`3<Nullable`1<decimal>, Pair`2<decimal, long>, Nullable`1<decimal>> {
    internal NullableDecimalAverageAggregationOperator(IEnumerable`1<Nullable`1<decimal>> child);
    protected virtual Nullable`1<decimal> InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Pair`2<decimal, long>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<decimal>, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.NullableDecimalMinMaxAggregationOperator : InlinedAggregationOperator`3<Nullable`1<decimal>, Nullable`1<decimal>, Nullable`1<decimal>> {
    private int _sign;
    internal NullableDecimalMinMaxAggregationOperator(IEnumerable`1<Nullable`1<decimal>> child, int sign);
    protected virtual Nullable`1<decimal> InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Nullable`1<decimal>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<decimal>, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.NullableDecimalSumAggregationOperator : InlinedAggregationOperator`3<Nullable`1<decimal>, Nullable`1<decimal>, Nullable`1<decimal>> {
    internal NullableDecimalSumAggregationOperator(IEnumerable`1<Nullable`1<decimal>> child);
    protected virtual Nullable`1<decimal> InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Nullable`1<decimal>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<decimal>, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.NullableDoubleAverageAggregationOperator : InlinedAggregationOperator`3<Nullable`1<double>, Pair`2<double, long>, Nullable`1<double>> {
    internal NullableDoubleAverageAggregationOperator(IEnumerable`1<Nullable`1<double>> child);
    protected virtual Nullable`1<double> InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Pair`2<double, long>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<double>, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.NullableDoubleMinMaxAggregationOperator : InlinedAggregationOperator`3<Nullable`1<double>, Nullable`1<double>, Nullable`1<double>> {
    private int _sign;
    internal NullableDoubleMinMaxAggregationOperator(IEnumerable`1<Nullable`1<double>> child, int sign);
    protected virtual Nullable`1<double> InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Nullable`1<double>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<double>, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.NullableDoubleSumAggregationOperator : InlinedAggregationOperator`3<Nullable`1<double>, Nullable`1<double>, Nullable`1<double>> {
    internal NullableDoubleSumAggregationOperator(IEnumerable`1<Nullable`1<double>> child);
    protected virtual Nullable`1<double> InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Nullable`1<double>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<double>, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.NullableFloatAverageAggregationOperator : InlinedAggregationOperator`3<Nullable`1<float>, Pair`2<double, long>, Nullable`1<float>> {
    internal NullableFloatAverageAggregationOperator(IEnumerable`1<Nullable`1<float>> child);
    protected virtual Nullable`1<float> InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Pair`2<double, long>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<float>, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.NullableFloatMinMaxAggregationOperator : InlinedAggregationOperator`3<Nullable`1<float>, Nullable`1<float>, Nullable`1<float>> {
    private int _sign;
    internal NullableFloatMinMaxAggregationOperator(IEnumerable`1<Nullable`1<float>> child, int sign);
    protected virtual Nullable`1<float> InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Nullable`1<float>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<float>, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.NullableFloatSumAggregationOperator : InlinedAggregationOperator`3<Nullable`1<float>, Nullable`1<double>, Nullable`1<float>> {
    internal NullableFloatSumAggregationOperator(IEnumerable`1<Nullable`1<float>> child);
    protected virtual Nullable`1<float> InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Nullable`1<double>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<float>, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.NullableIntAverageAggregationOperator : InlinedAggregationOperator`3<Nullable`1<int>, Pair`2<long, long>, Nullable`1<double>> {
    internal NullableIntAverageAggregationOperator(IEnumerable`1<Nullable`1<int>> child);
    protected virtual Nullable`1<double> InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Pair`2<long, long>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<int>, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.NullableIntMinMaxAggregationOperator : InlinedAggregationOperator`3<Nullable`1<int>, Nullable`1<int>, Nullable`1<int>> {
    private int _sign;
    internal NullableIntMinMaxAggregationOperator(IEnumerable`1<Nullable`1<int>> child, int sign);
    protected virtual Nullable`1<int> InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Nullable`1<int>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<int>, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.NullableIntSumAggregationOperator : InlinedAggregationOperator`3<Nullable`1<int>, Nullable`1<int>, Nullable`1<int>> {
    internal NullableIntSumAggregationOperator(IEnumerable`1<Nullable`1<int>> child);
    protected virtual Nullable`1<int> InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Nullable`1<int>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<int>, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.NullableLongAverageAggregationOperator : InlinedAggregationOperator`3<Nullable`1<long>, Pair`2<long, long>, Nullable`1<double>> {
    internal NullableLongAverageAggregationOperator(IEnumerable`1<Nullable`1<long>> child);
    protected virtual Nullable`1<double> InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Pair`2<long, long>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<long>, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.NullableLongMinMaxAggregationOperator : InlinedAggregationOperator`3<Nullable`1<long>, Nullable`1<long>, Nullable`1<long>> {
    private int _sign;
    internal NullableLongMinMaxAggregationOperator(IEnumerable`1<Nullable`1<long>> child, int sign);
    protected virtual Nullable`1<long> InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Nullable`1<long>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<long>, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.NullableLongSumAggregationOperator : InlinedAggregationOperator`3<Nullable`1<long>, Nullable`1<long>, Nullable`1<long>> {
    internal NullableLongSumAggregationOperator(IEnumerable`1<Nullable`1<long>> child);
    protected virtual Nullable`1<long> InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Nullable`1<long>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<long>, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.OrderedGroupByElementSelectorQueryOperatorEnumerator`4 : OrderedGroupByQueryOperatorEnumerator`4<TSource, TGroupKey, TElement, TOrderKey> {
    private Func`2<TSource, TElement> _elementSelector;
    internal OrderedGroupByElementSelectorQueryOperatorEnumerator`4(QueryOperatorEnumerator`2<Pair`2<TSource, TGroupKey>, TOrderKey> source, Func`2<TSource, TGroupKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TGroupKey> keyComparer, IComparer`1<TOrderKey> orderComparer, CancellationToken cancellationToken);
    protected virtual HashLookup`2<Wrapper`1<TGroupKey>, GroupKeyData<TSource, TGroupKey, TElement, TOrderKey>> BuildHashLookup();
}
internal class System.Linq.Parallel.OrderedGroupByGrouping`3 : object {
    private TGroupKey _groupKey;
    private ListChunk`1<Pair`2<TOrderKey, TElement>> _values;
    private TElement[] _sortedValues;
    private IComparer`1<TOrderKey> _orderComparer;
    private TGroupKey System.Linq.IGrouping<TGroupKey,TElement>.Key { get; }
    internal OrderedGroupByGrouping`3(TGroupKey groupKey, IComparer`1<TOrderKey> orderComparer);
    private sealed virtual override TGroupKey System.Linq.IGrouping<TGroupKey,TElement>.get_Key();
    private sealed virtual override IEnumerator`1<TElement> System.Collections.Generic.IEnumerable<TElement>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal void Add(TElement value, TOrderKey orderKey);
    internal void DoneAdding();
}
internal class System.Linq.Parallel.OrderedGroupByIdentityQueryOperatorEnumerator`3 : OrderedGroupByQueryOperatorEnumerator`4<TSource, TGroupKey, TSource, TOrderKey> {
    internal OrderedGroupByIdentityQueryOperatorEnumerator`3(QueryOperatorEnumerator`2<Pair`2<TSource, TGroupKey>, TOrderKey> source, Func`2<TSource, TGroupKey> keySelector, IEqualityComparer`1<TGroupKey> keyComparer, IComparer`1<TOrderKey> orderComparer, CancellationToken cancellationToken);
    protected virtual HashLookup`2<Wrapper`1<TGroupKey>, GroupKeyData<TSource, TGroupKey, TSource, TOrderKey>> BuildHashLookup();
}
internal abstract class System.Linq.Parallel.OrderedGroupByQueryOperatorEnumerator`4 : QueryOperatorEnumerator`2<IGrouping`2<TGroupKey, TElement>, TOrderKey> {
    protected QueryOperatorEnumerator`2<Pair`2<TSource, TGroupKey>, TOrderKey> _source;
    private Func`2<TSource, TGroupKey> _keySelector;
    protected IEqualityComparer`1<TGroupKey> _keyComparer;
    protected IComparer`1<TOrderKey> _orderComparer;
    protected CancellationToken _cancellationToken;
    private Mutables<TSource, TGroupKey, TElement, TOrderKey> _mutables;
    protected OrderedGroupByQueryOperatorEnumerator`4(QueryOperatorEnumerator`2<Pair`2<TSource, TGroupKey>, TOrderKey> source, Func`2<TSource, TGroupKey> keySelector, IEqualityComparer`1<TGroupKey> keyComparer, IComparer`1<TOrderKey> orderComparer, CancellationToken cancellationToken);
    internal virtual bool MoveNext(IGrouping`2& currentElement, TOrderKey& currentKey);
    protected abstract virtual HashLookup`2<Wrapper`1<TGroupKey>, GroupKeyData<TSource, TGroupKey, TElement, TOrderKey>> BuildHashLookup();
    protected virtual void Dispose(bool disposing);
}
internal class System.Linq.Parallel.OrderedGroupJoinHashLookupBuilder`3 : HashLookupBuilder`3<IEnumerable`1<TElement>, Pair`2<bool, TOrderKey>, THashKey> {
    private QueryOperatorEnumerator`2<Pair`2<TElement, THashKey>, TOrderKey> _dataSource;
    private IEqualityComparer`1<THashKey> _keyComparer;
    private IComparer`1<TOrderKey> _orderKeyComparer;
    internal OrderedGroupJoinHashLookupBuilder`3(QueryOperatorEnumerator`2<Pair`2<TElement, THashKey>, TOrderKey> dataSource, IEqualityComparer`1<THashKey> keyComparer, IComparer`1<TOrderKey> orderKeyComparer);
    public virtual HashJoinHashLookup`3<THashKey, IEnumerable`1<TElement>, Pair`2<bool, TOrderKey>> BuildHashLookup(CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.OrderedHashRepartitionEnumerator`3 : QueryOperatorEnumerator`2<Pair`2<TInputOutput, THashKey>, TOrderKey> {
    private int _partitionCount;
    private int _partitionIndex;
    private Func`2<TInputOutput, THashKey> _keySelector;
    private HashRepartitionStream`3<TInputOutput, THashKey, TOrderKey> _repartitionStream;
    private ListChunk`1[][] _valueExchangeMatrix;
    private ListChunk`1[][] _keyExchangeMatrix;
    private QueryOperatorEnumerator`2<TInputOutput, TOrderKey> _source;
    private CountdownEvent _barrier;
    private CancellationToken _cancellationToken;
    private Mutables<TInputOutput, THashKey, TOrderKey> _mutables;
    internal OrderedHashRepartitionEnumerator`3(QueryOperatorEnumerator`2<TInputOutput, TOrderKey> source, int partitionCount, int partitionIndex, Func`2<TInputOutput, THashKey> keySelector, OrderedHashRepartitionStream`3<TInputOutput, THashKey, TOrderKey> repartitionStream, CountdownEvent barrier, ListChunk`1[][] valueExchangeMatrix, ListChunk`1[][] keyExchangeMatrix, CancellationToken cancellationToken);
    internal virtual bool MoveNext(Pair`2& currentElement, TOrderKey& currentKey);
    private void EnumerateAndRedistributeElements();
    protected virtual void Dispose(bool disposing);
}
internal class System.Linq.Parallel.OrderedHashRepartitionStream`3 : HashRepartitionStream`3<TInputOutput, THashKey, TOrderKey> {
    internal OrderedHashRepartitionStream`3(PartitionedStream`2<TInputOutput, TOrderKey> inputStream, Func`2<TInputOutput, THashKey> hashKeySelector, IEqualityComparer`1<THashKey> hashKeyComparer, IEqualityComparer`1<TInputOutput> elementComparer, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.OrderingQueryOperator`1 : QueryOperator`1<TSource> {
    private QueryOperator`1<TSource> _child;
    private OrdinalIndexState _ordinalIndexState;
    internal bool LimitsParallelism { get; }
    internal OrdinalIndexState OrdinalIndexState { get; }
    public OrderingQueryOperator`1(QueryOperator`1<TSource> child, bool orderOn);
    internal virtual QueryResults`1<TSource> Open(QuerySettings settings, bool preferStriping);
    internal virtual IEnumerator`1<TSource> GetEnumerator(Nullable`1<ParallelMergeOptions> mergeOptions, bool suppressOrderPreservation);
    internal virtual IEnumerable`1<TSource> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
    internal virtual OrdinalIndexState get_OrdinalIndexState();
}
internal class System.Linq.Parallel.OrderPreservingMergeHelper`2 : object {
    private QueryTaskGroupState _taskGroupState;
    private PartitionedStream`2<TInputOutput, TKey> _partitions;
    private Shared`1<TInputOutput[]> _results;
    private TaskScheduler _taskScheduler;
    internal OrderPreservingMergeHelper`2(PartitionedStream`2<TInputOutput, TKey> partitions, TaskScheduler taskScheduler, CancellationState cancellationState, int queryId);
    private sealed virtual override void System.Linq.Parallel.IMergeHelper<TInputOutput>.Execute();
    private sealed virtual override IEnumerator`1<TInputOutput> System.Linq.Parallel.IMergeHelper<TInputOutput>.GetEnumerator();
    public sealed virtual TInputOutput[] GetResultsAsArray();
}
internal class System.Linq.Parallel.OrderPreservingPipeliningMergeHelper`2 : object {
    private QueryTaskGroupState _taskGroupState;
    private PartitionedStream`2<TOutput, TKey> _partitions;
    private TaskScheduler _taskScheduler;
    private bool _autoBuffered;
    private Queue`1[] _buffers;
    private Boolean[] _producerDone;
    private Boolean[] _producerWaiting;
    private Boolean[] _consumerWaiting;
    private Object[] _bufferLocks;
    private IComparer`1<Producer`1<TKey>> _producerComparer;
    internal OrderPreservingPipeliningMergeHelper`2(PartitionedStream`2<TOutput, TKey> partitions, TaskScheduler taskScheduler, CancellationState cancellationState, bool autoBuffered, int queryId, IComparer`1<TKey> keyComparer);
    private sealed virtual override void System.Linq.Parallel.IMergeHelper<TOutput>.Execute();
    private sealed virtual override IEnumerator`1<TOutput> System.Linq.Parallel.IMergeHelper<TOutput>.GetEnumerator();
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual TOutput[] GetResultsAsArray();
}
internal class System.Linq.Parallel.OrderPreservingPipeliningSpoolingTask`2 : SpoolingTaskBase {
    private QueryTaskGroupState _taskGroupState;
    private QueryOperatorEnumerator`2<TOutput, TKey> _partition;
    private Boolean[] _consumerWaiting;
    private Boolean[] _producerWaiting;
    private Boolean[] _producerDone;
    private int _partitionIndex;
    private Queue`1[] _buffers;
    private object _bufferLock;
    private bool _autoBuffered;
    internal OrderPreservingPipeliningSpoolingTask`2(QueryOperatorEnumerator`2<TOutput, TKey> partition, QueryTaskGroupState taskGroupState, Boolean[] consumerWaiting, Boolean[] producerWaiting, Boolean[] producerDone, int partitionIndex, Queue`1[] buffers, object bufferLock, bool autoBuffered);
    protected virtual void SpoolingWork();
    public static void Spool(QueryTaskGroupState groupState, PartitionedStream`2<TOutput, TKey> partitions, Boolean[] consumerWaiting, Boolean[] producerWaiting, Boolean[] producerDone, Queue`1[] buffers, Object[] bufferLocks, TaskScheduler taskScheduler, bool autoBuffered);
    protected virtual void SpoolingFinally();
}
internal class System.Linq.Parallel.OrderPreservingSpoolingTask`2 : SpoolingTaskBase {
    private Shared`1<TInputOutput[]> _results;
    private SortHelper`1<TInputOutput> _sortHelper;
    private OrderPreservingSpoolingTask`2(int taskIndex, QueryTaskGroupState groupState, Shared`1<TInputOutput[]> results, SortHelper`1<TInputOutput> sortHelper);
    internal static void Spool(QueryTaskGroupState groupState, PartitionedStream`2<TInputOutput, TKey> partitions, Shared`1<TInputOutput[]> results, TaskScheduler taskScheduler);
    protected virtual void SpoolingWork();
}
internal enum System.Linq.Parallel.OrdinalIndexState : Enum {
    public byte value__;
    public static OrdinalIndexState Indexable;
    public static OrdinalIndexState Correct;
    public static OrdinalIndexState Increasing;
    public static OrdinalIndexState Shuffled;
}
internal class System.Linq.Parallel.Pair`2 : ValueType {
    internal T _first;
    internal U _second;
    public T First { get; public set; }
    public U Second { get; public set; }
    public Pair`2(T first, U second);
    public T get_First();
    public void set_First(T value);
    public U get_Second();
    public void set_Second(U value);
}
internal class System.Linq.Parallel.PairComparer`2 : object {
    private IComparer`1<T> _comparer1;
    private IComparer`1<U> _comparer2;
    public PairComparer`2(IComparer`1<T> comparer1, IComparer`1<U> comparer2);
    public sealed virtual int Compare(Pair`2<T, U> x, Pair`2<T, U> y);
}
internal class System.Linq.Parallel.PairOutputKeyBuilder`2 : HashJoinOutputKeyBuilder`3<TLeftKey, TRightKey, Pair`2<TLeftKey, TRightKey>> {
    public virtual Pair`2<TLeftKey, TRightKey> Combine(TLeftKey leftKey, TRightKey rightKey);
}
internal class System.Linq.Parallel.ParallelEnumerableWrapper : ParallelQuery`1<object> {
    private IEnumerable _source;
    internal ParallelEnumerableWrapper(IEnumerable source);
    internal virtual IEnumerator GetEnumeratorUntyped();
    public virtual IEnumerator`1<object> GetEnumerator();
}
internal class System.Linq.Parallel.ParallelEnumerableWrapper`1 : ParallelQuery`1<T> {
    private IEnumerable`1<T> _wrappedEnumerable;
    internal IEnumerable`1<T> WrappedEnumerable { get; }
    internal ParallelEnumerableWrapper`1(IEnumerable`1<T> wrappedEnumerable);
    internal IEnumerable`1<T> get_WrappedEnumerable();
    public virtual IEnumerator`1<T> GetEnumerator();
}
internal class System.Linq.Parallel.PartitionedDataSource`1 : PartitionedStream`2<T, int> {
    internal PartitionedDataSource`1(IEnumerable`1<T> source, int partitionCount, bool useStriping);
    private void InitializePartitions(IEnumerable`1<T> source, int partitionCount, bool useStriping);
    private static QueryOperatorEnumerator`2[] MakePartitions(IEnumerator`1<T> source, int partitionCount);
}
[DefaultMemberAttribute("Item")]
internal class System.Linq.Parallel.PartitionedStream`2 : object {
    protected QueryOperatorEnumerator`2[] _partitions;
    private IComparer`1<TKey> _keyComparer;
    private OrdinalIndexState _indexState;
    internal QueryOperatorEnumerator`2<TElement, TKey> Item { get; internal set; }
    public int PartitionCount { get; }
    internal IComparer`1<TKey> KeyComparer { get; }
    internal OrdinalIndexState OrdinalIndexState { get; }
    internal PartitionedStream`2(int partitionCount, IComparer`1<TKey> keyComparer, OrdinalIndexState indexState);
    internal QueryOperatorEnumerator`2<TElement, TKey> get_Item(int index);
    internal void set_Item(int index, QueryOperatorEnumerator`2<TElement, TKey> value);
    public int get_PartitionCount();
    internal IComparer`1<TKey> get_KeyComparer();
    internal OrdinalIndexState get_OrdinalIndexState();
}
internal class System.Linq.Parallel.PartitionedStreamMerger`1 : object {
    private bool _forEffectMerge;
    private ParallelMergeOptions _mergeOptions;
    private bool _isOrdered;
    private MergeExecutor`1<TOutput> _mergeExecutor;
    private TaskScheduler _taskScheduler;
    private int _queryId;
    private CancellationState _cancellationState;
    internal MergeExecutor`1<TOutput> MergeExecutor { get; }
    internal PartitionedStreamMerger`1(bool forEffectMerge, ParallelMergeOptions mergeOptions, TaskScheduler taskScheduler, bool outputOrdered, CancellationState cancellationState, int queryId);
    internal MergeExecutor`1<TOutput> get_MergeExecutor();
    public sealed virtual void Receive(PartitionedStream`2<TOutput, TKey> partitionedStream);
}
internal class System.Linq.Parallel.PartitionerQueryOperator`1 : QueryOperator`1<TElement> {
    private Partitioner`1<TElement> _partitioner;
    internal bool Orderable { get; }
    internal OrdinalIndexState OrdinalIndexState { get; }
    internal bool LimitsParallelism { get; }
    internal PartitionerQueryOperator`1(Partitioner`1<TElement> partitioner);
    internal bool get_Orderable();
    internal virtual QueryResults`1<TElement> Open(QuerySettings settings, bool preferStriping);
    [IteratorStateMachineAttribute("System.Linq.Parallel.PartitionerQueryOperator`1/<AsSequentialQuery>d__5")]
internal virtual IEnumerable`1<TElement> AsSequentialQuery(CancellationToken token);
    internal virtual OrdinalIndexState get_OrdinalIndexState();
    internal static OrdinalIndexState GetOrdinalIndexState(Partitioner`1<TElement> partitioner);
    internal virtual bool get_LimitsParallelism();
}
internal class System.Linq.Parallel.PipelineSpoolingTask`2 : SpoolingTaskBase {
    private QueryOperatorEnumerator`2<TInputOutput, TIgnoreKey> _source;
    private AsynchronousChannel`1<TInputOutput> _destination;
    internal PipelineSpoolingTask`2(int taskIndex, QueryTaskGroupState groupState, QueryOperatorEnumerator`2<TInputOutput, TIgnoreKey> source, AsynchronousChannel`1<TInputOutput> destination);
    protected virtual void SpoolingWork();
    protected virtual void SpoolingFinally();
}
[EventSourceAttribute]
internal class System.Linq.Parallel.PlinqEtwProvider : EventSource {
    internal static PlinqEtwProvider Log;
    private static int s_defaultSchedulerId;
    private static int s_queryId;
    private static PlinqEtwProvider();
    [NonEventAttribute]
internal static int NextQueryId();
    [NonEventAttribute]
internal void ParallelQueryBegin(int queryId);
    [EventAttribute("1")]
private void ParallelQueryBegin(int taskSchedulerId, int taskId, int queryId);
    [NonEventAttribute]
internal void ParallelQueryEnd(int queryId);
    [EventAttribute("2")]
private void ParallelQueryEnd(int taskSchedulerId, int taskId, int queryId);
    [NonEventAttribute]
internal void ParallelQueryFork(int queryId);
    [EventAttribute("3")]
private void ParallelQueryFork(int taskSchedulerId, int taskId, int queryId);
    [NonEventAttribute]
internal void ParallelQueryJoin(int queryId);
    [EventAttribute("4")]
private void ParallelQueryJoin(int taskSchedulerId, int taskId, int queryId);
}
[IsReadOnlyAttribute]
internal class System.Linq.Parallel.Producer`1 : ValueType {
    internal TKey MaxKey;
    internal int ProducerIndex;
    internal Producer`1(TKey maxKey, int producerIndex);
}
internal class System.Linq.Parallel.ProducerComparerInt : object {
    public sealed virtual int Compare(Producer`1<int> x, Producer`1<int> y);
}
[FlagsAttribute]
internal enum System.Linq.Parallel.QueryAggregationOptions : Enum {
    public int value__;
    public static QueryAggregationOptions None;
    public static QueryAggregationOptions Associative;
    public static QueryAggregationOptions Commutative;
    public static QueryAggregationOptions AssociativeCommutative;
}
internal class System.Linq.Parallel.QueryExecutionOption`1 : QueryOperator`1<TSource> {
    private QueryOperator`1<TSource> _child;
    private OrdinalIndexState _indexState;
    internal OrdinalIndexState OrdinalIndexState { get; }
    internal bool LimitsParallelism { get; }
    internal QueryExecutionOption`1(QueryOperator`1<TSource> source, QuerySettings settings);
    internal virtual QueryResults`1<TSource> Open(QuerySettings settings, bool preferStriping);
    internal virtual IEnumerable`1<TSource> AsSequentialQuery(CancellationToken token);
    internal virtual OrdinalIndexState get_OrdinalIndexState();
    internal virtual bool get_LimitsParallelism();
}
internal static class System.Linq.Parallel.QueryLifecycle : object {
    internal static void LogicalQueryExecutionBegin(int queryID);
    internal static void LogicalQueryExecutionEnd(int queryID);
}
internal class System.Linq.Parallel.QueryOpeningEnumerator`1 : object {
    private QueryOperator`1<TOutput> _queryOperator;
    private IEnumerator`1<TOutput> _openedQueryEnumerator;
    private QuerySettings _querySettings;
    private Nullable`1<ParallelMergeOptions> _mergeOptions;
    private bool _suppressOrderPreservation;
    private int _moveNextIteration;
    private bool _hasQueryOpeningFailed;
    private Shared`1<bool> _topLevelDisposedFlag;
    private CancellationTokenSource _topLevelCancellationTokenSource;
    public TOutput Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal QueryOpeningEnumerator`1(QueryOperator`1<TOutput> queryOperator, Nullable`1<ParallelMergeOptions> mergeOptions, bool suppressOrderPreservation);
    public sealed virtual TOutput get_Current();
    public sealed virtual void Dispose();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    private void OpenQuery();
    public sealed virtual void Reset();
}
internal abstract class System.Linq.Parallel.QueryOperator`1 : ParallelQuery`1<TOutput> {
    protected bool _outputOrdered;
    internal bool OutputOrdered { get; }
    internal bool LimitsParallelism { get; }
    internal OrdinalIndexState OrdinalIndexState { get; }
    internal QueryOperator`1(QuerySettings settings);
    internal QueryOperator`1(bool isOrdered, QuerySettings settings);
    internal abstract virtual QueryResults`1<TOutput> Open(QuerySettings settings, bool preferStriping);
    public virtual IEnumerator`1<TOutput> GetEnumerator();
    public IEnumerator`1<TOutput> GetEnumerator(Nullable`1<ParallelMergeOptions> mergeOptions);
    internal bool get_OutputOrdered();
    internal virtual IEnumerator`1<TOutput> GetEnumerator(Nullable`1<ParallelMergeOptions> mergeOptions, bool suppressOrderPreservation);
    internal IEnumerator`1<TOutput> GetOpenedEnumerator(Nullable`1<ParallelMergeOptions> mergeOptions, bool suppressOrder, bool forEffect, QuerySettings querySettings);
    private QueryResults`1<TOutput> GetQueryResults(QuerySettings querySettings);
    internal TOutput[] ExecuteAndGetResultsAsArray();
    internal abstract virtual IEnumerable`1<TOutput> AsSequentialQuery(CancellationToken token);
    internal abstract virtual bool get_LimitsParallelism();
    internal abstract virtual OrdinalIndexState get_OrdinalIndexState();
    internal static ListQueryResults`1<TOutput> ExecuteAndCollectResults(PartitionedStream`2<TOutput, TKey> openedChild, int partitionCount, bool outputOrdered, bool useStriping, QuerySettings settings);
    internal static QueryOperator`1<TOutput> AsQueryOperator(IEnumerable`1<TOutput> source);
}
internal abstract class System.Linq.Parallel.QueryOperatorEnumerator`2 : object {
    internal abstract virtual bool MoveNext(TElement& currentElement, TKey& currentKey);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    internal virtual void Reset();
    internal IEnumerator`1<TElement> AsClassicEnumerator();
}
[DefaultMemberAttribute("Item")]
internal abstract class System.Linq.Parallel.QueryResults`1 : object {
    internal bool IsIndexible { get; }
    internal int ElementsCount { get; }
    public T Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    internal abstract virtual void GivePartitionedStream(IPartitionedStreamRecipient`1<T> recipient);
    internal virtual bool get_IsIndexible();
    internal virtual T GetElement(int index);
    internal virtual int get_ElementsCount();
    private sealed virtual override int System.Collections.Generic.IList<T>.IndexOf(T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Contains(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int arrayIndex);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    [IteratorStateMachineAttribute("System.Linq.Parallel.QueryResults`1/<System-Collections-Generic-IEnumerable<T>-GetEnumerator>d__21")]
private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class System.Linq.Parallel.QuerySettings : ValueType {
    private TaskScheduler _taskScheduler;
    private Nullable`1<int> _degreeOfParallelism;
    private CancellationState _cancellationState;
    private Nullable`1<ParallelExecutionMode> _executionMode;
    private Nullable`1<ParallelMergeOptions> _mergeOptions;
    private int _queryId;
    internal CancellationState CancellationState { get; internal set; }
    internal TaskScheduler TaskScheduler { get; internal set; }
    internal Nullable`1<int> DegreeOfParallelism { get; internal set; }
    internal Nullable`1<ParallelExecutionMode> ExecutionMode { get; internal set; }
    internal Nullable`1<ParallelMergeOptions> MergeOptions { get; internal set; }
    internal int QueryId { get; }
    internal static QuerySettings Empty { get; }
    internal QuerySettings(TaskScheduler taskScheduler, Nullable`1<int> degreeOfParallelism, CancellationToken externalCancellationToken, Nullable`1<ParallelExecutionMode> executionMode, Nullable`1<ParallelMergeOptions> mergeOptions);
    internal CancellationState get_CancellationState();
    internal void set_CancellationState(CancellationState value);
    internal TaskScheduler get_TaskScheduler();
    internal void set_TaskScheduler(TaskScheduler value);
    internal Nullable`1<int> get_DegreeOfParallelism();
    internal void set_DegreeOfParallelism(Nullable`1<int> value);
    internal Nullable`1<ParallelExecutionMode> get_ExecutionMode();
    internal void set_ExecutionMode(Nullable`1<ParallelExecutionMode> value);
    internal Nullable`1<ParallelMergeOptions> get_MergeOptions();
    internal void set_MergeOptions(Nullable`1<ParallelMergeOptions> value);
    internal int get_QueryId();
    internal QuerySettings Merge(QuerySettings settings2);
    internal QuerySettings WithPerExecutionSettings();
    internal QuerySettings WithPerExecutionSettings(CancellationTokenSource topLevelCancellationTokenSource, Shared`1<bool> topLevelDisposedFlag);
    internal QuerySettings WithDefaults();
    internal static QuerySettings get_Empty();
    public void CleanStateAtQueryEnd();
}
internal abstract class System.Linq.Parallel.QueryTask : object {
    protected int _taskIndex;
    protected QueryTaskGroupState _groupState;
    private static Action`1<object> s_runTaskSynchronouslyDelegate;
    private static Action`1<object> s_baseWorkDelegate;
    protected QueryTask(int taskIndex, QueryTaskGroupState groupState);
    private static QueryTask();
    private static void RunTaskSynchronously(object o);
    internal Task RunSynchronously(TaskScheduler taskScheduler);
    internal Task RunAsynchronously(TaskScheduler taskScheduler);
    private void BaseWork(object unused);
    protected abstract virtual void Work();
}
internal class System.Linq.Parallel.QueryTaskGroupState : object {
    private Task _rootTask;
    private int _alreadyEnded;
    private CancellationState _cancellationState;
    private int _queryId;
    internal bool IsAlreadyEnded { get; }
    internal CancellationState CancellationState { get; }
    internal int QueryId { get; }
    internal QueryTaskGroupState(CancellationState cancellationState, int queryId);
    internal bool get_IsAlreadyEnded();
    internal CancellationState get_CancellationState();
    internal int get_QueryId();
    internal void QueryBegin(Task rootTask);
    internal void QueryEnd(bool userInitiatedDispose);
}
internal class System.Linq.Parallel.RangeEnumerable : ParallelQuery`1<int> {
    private int _from;
    private int _count;
    internal RangeEnumerable(int from, int count);
    public sealed virtual QueryOperatorEnumerator`2[] GetPartitions(int partitionCount);
    public virtual IEnumerator`1<int> GetEnumerator();
}
internal class System.Linq.Parallel.RepeatEnumerable`1 : ParallelQuery`1<TResult> {
    private TResult _element;
    private int _count;
    internal RepeatEnumerable`1(TResult element, int count);
    public sealed virtual QueryOperatorEnumerator`2[] GetPartitions(int partitionCount);
    public virtual IEnumerator`1<TResult> GetEnumerator();
}
internal class System.Linq.Parallel.ReverseComparer`1 : object {
    private IComparer`1<T> _comparer;
    internal ReverseComparer`1(IComparer`1<T> comparer);
    public sealed virtual int Compare(T x, T y);
}
internal class System.Linq.Parallel.ReverseQueryOperator`1 : UnaryQueryOperator`2<TSource, TSource> {
    internal bool LimitsParallelism { get; }
    internal ReverseQueryOperator`1(IEnumerable`1<TSource> child);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TSource, TKey> inputStream, IPartitionedStreamRecipient`1<TSource> recipient, bool preferStriping, QuerySettings settings);
    internal virtual QueryResults`1<TSource> Open(QuerySettings settings, bool preferStriping);
    internal virtual IEnumerable`1<TSource> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal class System.Linq.Parallel.ScanQueryOperator`1 : QueryOperator`1<TElement> {
    private IEnumerable`1<TElement> _data;
    public IEnumerable`1<TElement> Data { get; }
    internal OrdinalIndexState OrdinalIndexState { get; }
    internal bool LimitsParallelism { get; }
    internal ScanQueryOperator`1(IEnumerable`1<TElement> data);
    public IEnumerable`1<TElement> get_Data();
    internal virtual QueryResults`1<TElement> Open(QuerySettings settings, bool preferStriping);
    internal virtual IEnumerator`1<TElement> GetEnumerator(Nullable`1<ParallelMergeOptions> mergeOptions, bool suppressOrderPreservation);
    internal virtual IEnumerable`1<TElement> AsSequentialQuery(CancellationToken token);
    internal virtual OrdinalIndexState get_OrdinalIndexState();
    internal virtual bool get_LimitsParallelism();
}
internal static class System.Linq.Parallel.Scheduling : object {
    internal static int DefaultDegreeOfParallelism;
    private static Scheduling();
    internal static int GetDefaultDegreeOfParallelism();
    internal static int GetDefaultChunkSize();
}
internal class System.Linq.Parallel.SelectManyQueryOperator`3 : UnaryQueryOperator`2<TLeftInput, TOutput> {
    private Func`2<TLeftInput, IEnumerable`1<TRightInput>> _rightChildSelector;
    private Func`3<TLeftInput, int, IEnumerable`1<TRightInput>> _indexedRightChildSelector;
    private Func`3<TLeftInput, TRightInput, TOutput> _resultSelector;
    private bool _prematureMerge;
    private bool _limitsParallelism;
    internal bool LimitsParallelism { get; }
    internal SelectManyQueryOperator`3(IEnumerable`1<TLeftInput> leftChild, Func`2<TLeftInput, IEnumerable`1<TRightInput>> rightChildSelector, Func`3<TLeftInput, int, IEnumerable`1<TRightInput>> indexedRightChildSelector, Func`3<TLeftInput, TRightInput, TOutput> resultSelector);
    private void InitOrderIndex();
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TLeftInput, TLeftKey> inputStream, IPartitionedStreamRecipient`1<TOutput> recipient, bool preferStriping, QuerySettings settings);
    private void WrapPartitionedStreamNotIndexed(PartitionedStream`2<TLeftInput, TLeftKey> inputStream, IPartitionedStreamRecipient`1<TOutput> recipient, QuerySettings settings);
    private void WrapPartitionedStreamIndexed(PartitionedStream`2<TLeftInput, int> inputStream, IPartitionedStreamRecipient`1<TOutput> recipient, QuerySettings settings);
    internal virtual QueryResults`1<TOutput> Open(QuerySettings settings, bool preferStriping);
    internal virtual IEnumerable`1<TOutput> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal class System.Linq.Parallel.SelectQueryOperator`2 : UnaryQueryOperator`2<TInput, TOutput> {
    private Func`2<TInput, TOutput> _selector;
    internal bool LimitsParallelism { get; }
    internal SelectQueryOperator`2(IEnumerable`1<TInput> child, Func`2<TInput, TOutput> selector);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TInput, TKey> inputStream, IPartitionedStreamRecipient`1<TOutput> recipient, bool preferStriping, QuerySettings settings);
    internal virtual QueryResults`1<TOutput> Open(QuerySettings settings, bool preferStriping);
    internal virtual IEnumerable`1<TOutput> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal class System.Linq.Parallel.Set`1 : object {
    private Int32[] _buckets;
    private Slot[] _slots;
    private int _count;
    private IEqualityComparer`1<TElement> _comparer;
    public Set`1(IEqualityComparer`1<TElement> comparer);
    public bool Add(TElement value);
    public bool Contains(TElement value);
    public bool Remove(TElement value);
    private bool Find(TElement value, bool add);
    private void Resize();
    internal int InternalGetHashCode(TElement value);
}
internal class System.Linq.Parallel.Shared`1 : object {
    internal T Value;
    internal Shared`1(T value);
}
internal class System.Linq.Parallel.SingleQueryOperator`1 : UnaryQueryOperator`2<TSource, TSource> {
    private Func`2<TSource, bool> _predicate;
    internal bool LimitsParallelism { get; }
    internal SingleQueryOperator`1(IEnumerable`1<TSource> child, Func`2<TSource, bool> predicate);
    internal virtual QueryResults`1<TSource> Open(QuerySettings settings, bool preferStriping);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TSource, TKey> inputStream, IPartitionedStreamRecipient`1<TSource> recipient, bool preferStriping, QuerySettings settings);
    [ExcludeFromCodeCoverageAttribute]
internal virtual IEnumerable`1<TSource> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal abstract class System.Linq.Parallel.SortHelper`1 : object {
    internal abstract virtual TInputOutput[] Sort();
}
internal class System.Linq.Parallel.SortHelper`2 : SortHelper`1<TInputOutput> {
    private QueryOperatorEnumerator`2<TInputOutput, TKey> _source;
    private int _partitionCount;
    private int _partitionIndex;
    private QueryTaskGroupState _groupState;
    private Int32[][] _sharedIndices;
    private GrowingArray`1[] _sharedKeys;
    private TInputOutput[][] _sharedValues;
    private Barrier[][] _sharedBarriers;
    private OrdinalIndexState _indexState;
    private IComparer`1<TKey> _keyComparer;
    private SortHelper`2(QueryOperatorEnumerator`2<TInputOutput, TKey> source, int partitionCount, int partitionIndex, QueryTaskGroupState groupState, Int32[][] sharedIndices, OrdinalIndexState indexState, IComparer`1<TKey> keyComparer, GrowingArray`1[] sharedkeys, TInputOutput[][] sharedValues, Barrier[][] sharedBarriers);
    internal static SortHelper`2[] GenerateSortHelpers(PartitionedStream`2<TInputOutput, TKey> partitions, QueryTaskGroupState groupState);
    public sealed virtual void Dispose();
    internal virtual TInputOutput[] Sort();
    private void BuildKeysFromSource(GrowingArray`1& keys, List`1& values);
    private void QuickSortIndicesInPlace(GrowingArray`1<TKey> keys, List`1<TInputOutput> values, OrdinalIndexState ordinalIndexState);
    private void MergeSortCooperatively();
    private int ComputePartnerIndex(int phase);
    private void QuickSort(int left, int right, TKey[] keys, Int32[] indices, CancellationToken cancelToken);
}
internal class System.Linq.Parallel.SortQueryOperator`2 : UnaryQueryOperator`2<TInputOutput, TInputOutput> {
    private Func`2<TInputOutput, TSortKey> _keySelector;
    private IComparer`1<TSortKey> _comparer;
    internal bool LimitsParallelism { get; }
    internal SortQueryOperator`2(IEnumerable`1<TInputOutput> source, Func`2<TInputOutput, TSortKey> keySelector, IComparer`1<TSortKey> comparer, bool descending);
    private sealed virtual override IOrderedEnumerable`1<TInputOutput> System.Linq.IOrderedEnumerable<TInputOutput>.CreateOrderedEnumerable(Func`2<TInputOutput, TKey2> key2Selector, IComparer`1<TKey2> key2Comparer, bool descending);
    internal virtual QueryResults`1<TInputOutput> Open(QuerySettings settings, bool preferStriping);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TInputOutput, TKey> inputStream, IPartitionedStreamRecipient`1<TInputOutput> recipient, bool preferStriping, QuerySettings settings);
    internal virtual IEnumerable`1<TInputOutput> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal class System.Linq.Parallel.SortQueryOperatorEnumerator`3 : QueryOperatorEnumerator`2<TInputOutput, TSortKey> {
    private QueryOperatorEnumerator`2<TInputOutput, TKey> _source;
    private Func`2<TInputOutput, TSortKey> _keySelector;
    internal SortQueryOperatorEnumerator`3(QueryOperatorEnumerator`2<TInputOutput, TKey> source, Func`2<TInputOutput, TSortKey> keySelector);
    internal virtual bool MoveNext(TInputOutput& currentElement, TSortKey& currentKey);
    protected virtual void Dispose(bool disposing);
}
internal class System.Linq.Parallel.SortQueryOperatorResults`2 : QueryResults`1<TInputOutput> {
    protected QueryResults`1<TInputOutput> _childQueryResults;
    private SortQueryOperator`2<TInputOutput, TSortKey> _op;
    private QuerySettings _settings;
    internal bool IsIndexible { get; }
    internal SortQueryOperatorResults`2(QueryResults`1<TInputOutput> childQueryResults, SortQueryOperator`2<TInputOutput, TSortKey> op, QuerySettings settings);
    internal virtual bool get_IsIndexible();
    internal virtual void GivePartitionedStream(IPartitionedStreamRecipient`1<TInputOutput> recipient);
}
internal static class System.Linq.Parallel.SpoolingTask : object {
    internal static void SpoolStopAndGo(QueryTaskGroupState groupState, PartitionedStream`2<TInputOutput, TIgnoreKey> partitions, SynchronousChannel`1[] channels, TaskScheduler taskScheduler);
    internal static void SpoolPipeline(QueryTaskGroupState groupState, PartitionedStream`2<TInputOutput, TIgnoreKey> partitions, AsynchronousChannel`1[] channels, TaskScheduler taskScheduler);
    internal static void SpoolForAll(QueryTaskGroupState groupState, PartitionedStream`2<TInputOutput, TIgnoreKey> partitions, TaskScheduler taskScheduler);
}
internal abstract class System.Linq.Parallel.SpoolingTaskBase : QueryTask {
    protected SpoolingTaskBase(int taskIndex, QueryTaskGroupState groupState);
    protected virtual void Work();
    protected abstract virtual void SpoolingWork();
    protected virtual void SpoolingFinally();
}
internal class System.Linq.Parallel.StopAndGoSpoolingTask`2 : SpoolingTaskBase {
    private QueryOperatorEnumerator`2<TInputOutput, TIgnoreKey> _source;
    private SynchronousChannel`1<TInputOutput> _destination;
    internal StopAndGoSpoolingTask`2(int taskIndex, QueryTaskGroupState groupState, QueryOperatorEnumerator`2<TInputOutput, TIgnoreKey> source, SynchronousChannel`1<TInputOutput> destination);
    protected virtual void SpoolingWork();
    protected virtual void SpoolingFinally();
}
internal class System.Linq.Parallel.SynchronousChannel`1 : object {
    private Queue`1<T> _queue;
    internal int Count { get; }
    internal void Init();
    internal void Enqueue(T item);
    internal T Dequeue();
    internal void SetDone();
    internal void CopyTo(T[] array, int arrayIndex);
    internal int get_Count();
}
internal class System.Linq.Parallel.SynchronousChannelMergeEnumerator`1 : MergeEnumerator`1<T> {
    private SynchronousChannel`1[] _channels;
    private int _channelIndex;
    private T _currentElement;
    public T Current { get; }
    internal SynchronousChannelMergeEnumerator`1(QueryTaskGroupState taskGroupState, SynchronousChannel`1[] channels);
    public virtual T get_Current();
    public virtual bool MoveNext();
}
internal class System.Linq.Parallel.TakeOrSkipQueryOperator`1 : UnaryQueryOperator`2<TResult, TResult> {
    private int _count;
    private bool _take;
    private bool _prematureMerge;
    internal bool LimitsParallelism { get; }
    internal TakeOrSkipQueryOperator`1(IEnumerable`1<TResult> child, int count, bool take);
    private OrdinalIndexState OutputOrdinalIndexState();
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TResult, TKey> inputStream, IPartitionedStreamRecipient`1<TResult> recipient, bool preferStriping, QuerySettings settings);
    private void WrapHelper(PartitionedStream`2<TResult, TKey> inputStream, IPartitionedStreamRecipient`1<TResult> recipient, QuerySettings settings);
    internal virtual QueryResults`1<TResult> Open(QuerySettings settings, bool preferStriping);
    internal virtual bool get_LimitsParallelism();
    internal virtual IEnumerable`1<TResult> AsSequentialQuery(CancellationToken token);
}
internal class System.Linq.Parallel.TakeOrSkipWhileQueryOperator`1 : UnaryQueryOperator`2<TResult, TResult> {
    private Func`2<TResult, bool> _predicate;
    private Func`3<TResult, int, bool> _indexedPredicate;
    private bool _take;
    private bool _prematureMerge;
    private bool _limitsParallelism;
    internal bool LimitsParallelism { get; }
    internal TakeOrSkipWhileQueryOperator`1(IEnumerable`1<TResult> child, Func`2<TResult, bool> predicate, Func`3<TResult, int, bool> indexedPredicate, bool take);
    private void InitOrderIndexState();
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TResult, TKey> inputStream, IPartitionedStreamRecipient`1<TResult> recipient, bool preferStriping, QuerySettings settings);
    private void WrapHelper(PartitionedStream`2<TResult, TKey> inputStream, IPartitionedStreamRecipient`1<TResult> recipient, QuerySettings settings);
    internal virtual QueryResults`1<TResult> Open(QuerySettings settings, bool preferStriping);
    internal virtual IEnumerable`1<TResult> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal abstract class System.Linq.Parallel.UnaryQueryOperator`2 : QueryOperator`1<TOutput> {
    private QueryOperator`1<TInput> _child;
    private OrdinalIndexState _indexState;
    internal QueryOperator`1<TInput> Child { get; }
    internal OrdinalIndexState OrdinalIndexState { get; }
    internal UnaryQueryOperator`2(IEnumerable`1<TInput> child);
    internal UnaryQueryOperator`2(IEnumerable`1<TInput> child, bool outputOrdered);
    private UnaryQueryOperator`2(QueryOperator`1<TInput> child);
    internal UnaryQueryOperator`2(QueryOperator`1<TInput> child, bool outputOrdered);
    private UnaryQueryOperator`2(QueryOperator`1<TInput> child, bool outputOrdered, QuerySettings settings);
    internal QueryOperator`1<TInput> get_Child();
    internal sealed virtual OrdinalIndexState get_OrdinalIndexState();
    protected void SetOrdinalIndexState(OrdinalIndexState indexState);
    internal abstract virtual void WrapPartitionedStream(PartitionedStream`2<TInput, TKey> inputStream, IPartitionedStreamRecipient`1<TOutput> recipient, bool preferStriping, QuerySettings settings);
}
internal class System.Linq.Parallel.UnionQueryOperator`1 : BinaryQueryOperator`3<TInputOutput, TInputOutput, TInputOutput> {
    private IEqualityComparer`1<TInputOutput> _comparer;
    internal bool LimitsParallelism { get; }
    internal UnionQueryOperator`1(ParallelQuery`1<TInputOutput> left, ParallelQuery`1<TInputOutput> right, IEqualityComparer`1<TInputOutput> comparer);
    internal virtual QueryResults`1<TInputOutput> Open(QuerySettings settings, bool preferStriping);
    public virtual void WrapPartitionedStream(PartitionedStream`2<TInputOutput, TLeftKey> leftStream, PartitionedStream`2<TInputOutput, TRightKey> rightStream, IPartitionedStreamRecipient`1<TInputOutput> outputRecipient, bool preferStriping, QuerySettings settings);
    private void WrapPartitionedStreamFixedLeftType(PartitionedStream`2<Pair`2<TInputOutput, NoKeyMemoizationRequired>, TLeftKey> leftHashStream, PartitionedStream`2<TInputOutput, TRightKey> rightStream, IPartitionedStreamRecipient`1<TInputOutput> outputRecipient, int partitionCount, CancellationToken cancellationToken);
    private void WrapPartitionedStreamFixedBothTypes(PartitionedStream`2<Pair`2<TInputOutput, NoKeyMemoizationRequired>, TLeftKey> leftHashStream, PartitionedStream`2<Pair`2<TInputOutput, NoKeyMemoizationRequired>, TRightKey> rightHashStream, IPartitionedStreamRecipient`1<TInputOutput> outputRecipient, int partitionCount, CancellationToken cancellationToken);
    internal virtual IEnumerable`1<TInputOutput> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal class System.Linq.Parallel.UnorderedHashRepartitionStream`3 : HashRepartitionStream`3<TInputOutput, THashKey, int> {
    internal UnorderedHashRepartitionStream`3(PartitionedStream`2<TInputOutput, TIgnoreKey> inputStream, Func`2<TInputOutput, THashKey> keySelector, IEqualityComparer`1<THashKey> keyComparer, IEqualityComparer`1<TInputOutput> elementComparer, CancellationToken cancellationToken);
}
internal static class System.Linq.Parallel.Util : object {
    private static FastIntComparer s_fastIntComparer;
    private static FastLongComparer s_fastLongComparer;
    private static FastFloatComparer s_fastFloatComparer;
    private static FastDoubleComparer s_fastDoubleComparer;
    private static FastDateTimeComparer s_fastDateTimeComparer;
    private static Util();
    internal static int Sign(int x);
    internal static Comparer`1<TKey> GetDefaultComparer();
}
internal class System.Linq.Parallel.WhereQueryOperator`1 : UnaryQueryOperator`2<TInputOutput, TInputOutput> {
    private Func`2<TInputOutput, bool> _predicate;
    internal bool LimitsParallelism { get; }
    internal WhereQueryOperator`1(IEnumerable`1<TInputOutput> child, Func`2<TInputOutput, bool> predicate);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TInputOutput, TKey> inputStream, IPartitionedStreamRecipient`1<TInputOutput> recipient, bool preferStriping, QuerySettings settings);
    internal virtual QueryResults`1<TInputOutput> Open(QuerySettings settings, bool preferStriping);
    internal virtual IEnumerable`1<TInputOutput> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal class System.Linq.Parallel.Wrapper`1 : ValueType {
    internal T Value;
    internal Wrapper`1(T value);
}
internal class System.Linq.Parallel.WrapperEqualityComparer`1 : ValueType {
    private IEqualityComparer`1<T> _comparer;
    internal WrapperEqualityComparer`1(IEqualityComparer`1<T> comparer);
    public sealed virtual bool Equals(Wrapper`1<T> x, Wrapper`1<T> y);
    public sealed virtual int GetHashCode(Wrapper`1<T> x);
}
internal class System.Linq.Parallel.ZipQueryOperator`3 : QueryOperator`1<TOutput> {
    private Func`3<TLeftInput, TRightInput, TOutput> _resultSelector;
    private QueryOperator`1<TLeftInput> _leftChild;
    private QueryOperator`1<TRightInput> _rightChild;
    private bool _prematureMergeLeft;
    private bool _prematureMergeRight;
    private bool _limitsParallelism;
    internal OrdinalIndexState OrdinalIndexState { get; }
    internal bool LimitsParallelism { get; }
    internal ZipQueryOperator`3(ParallelQuery`1<TLeftInput> leftChildSource, ParallelQuery`1<TRightInput> rightChildSource, Func`3<TLeftInput, TRightInput, TOutput> resultSelector);
    private ZipQueryOperator`3(QueryOperator`1<TLeftInput> left, QueryOperator`1<TRightInput> right, Func`3<TLeftInput, TRightInput, TOutput> resultSelector);
    internal virtual QueryResults`1<TOutput> Open(QuerySettings settings, bool preferStriping);
    [IteratorStateMachineAttribute("System.Linq.Parallel.ZipQueryOperator`3/<AsSequentialQuery>d__9")]
internal virtual IEnumerable`1<TOutput> AsSequentialQuery(CancellationToken token);
    internal virtual OrdinalIndexState get_OrdinalIndexState();
    internal virtual bool get_LimitsParallelism();
}
[ExtensionAttribute]
public static class System.Linq.ParallelEnumerable : object {
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> AsParallel(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> AsParallel(Partitioner`1<TSource> source);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> AsOrdered(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static ParallelQuery AsOrdered(ParallelQuery source);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> AsUnordered(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static ParallelQuery AsParallel(IEnumerable source);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> AsSequential(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> WithDegreeOfParallelism(ParallelQuery`1<TSource> source, int degreeOfParallelism);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> WithCancellation(ParallelQuery`1<TSource> source, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> WithExecutionMode(ParallelQuery`1<TSource> source, ParallelExecutionMode executionMode);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> WithMergeOptions(ParallelQuery`1<TSource> source, ParallelMergeOptions mergeOptions);
    public static ParallelQuery`1<int> Range(int start, int count);
    public static ParallelQuery`1<TResult> Repeat(TResult element, int count);
    public static ParallelQuery`1<TResult> Empty();
    [ExtensionAttribute]
public static void ForAll(ParallelQuery`1<TSource> source, Action`1<TSource> action);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Where(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Where(ParallelQuery`1<TSource> source, Func`3<TSource, int, bool> predicate);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> Select(ParallelQuery`1<TSource> source, Func`2<TSource, TResult> selector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> Select(ParallelQuery`1<TSource> source, Func`3<TSource, int, TResult> selector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> Zip(ParallelQuery`1<TFirst> first, ParallelQuery`1<TSecond> second, Func`3<TFirst, TSecond, TResult> resultSelector);
    [ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
[ExtensionAttribute]
public static ParallelQuery`1<TResult> Zip(ParallelQuery`1<TFirst> first, IEnumerable`1<TSecond> second, Func`3<TFirst, TSecond, TResult> resultSelector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> Join(ParallelQuery`1<TOuter> outer, ParallelQuery`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, TInner, TResult> resultSelector);
    [ExtensionAttribute]
[ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
public static ParallelQuery`1<TResult> Join(ParallelQuery`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, TInner, TResult> resultSelector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> Join(ParallelQuery`1<TOuter> outer, ParallelQuery`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, TInner, TResult> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
[ExtensionAttribute]
public static ParallelQuery`1<TResult> Join(ParallelQuery`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, TInner, TResult> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> GroupJoin(ParallelQuery`1<TOuter> outer, ParallelQuery`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, IEnumerable`1<TInner>, TResult> resultSelector);
    [ExtensionAttribute]
[ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
public static ParallelQuery`1<TResult> GroupJoin(ParallelQuery`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, IEnumerable`1<TInner>, TResult> resultSelector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> GroupJoin(ParallelQuery`1<TOuter> outer, ParallelQuery`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, IEnumerable`1<TInner>, TResult> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
[ExtensionAttribute]
public static ParallelQuery`1<TResult> GroupJoin(ParallelQuery`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, IEnumerable`1<TInner>, TResult> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> SelectMany(ParallelQuery`1<TSource> source, Func`2<TSource, IEnumerable`1<TResult>> selector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> SelectMany(ParallelQuery`1<TSource> source, Func`3<TSource, int, IEnumerable`1<TResult>> selector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> SelectMany(ParallelQuery`1<TSource> source, Func`2<TSource, IEnumerable`1<TCollection>> collectionSelector, Func`3<TSource, TCollection, TResult> resultSelector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> SelectMany(ParallelQuery`1<TSource> source, Func`3<TSource, int, IEnumerable`1<TCollection>> collectionSelector, Func`3<TSource, TCollection, TResult> resultSelector);
    [ExtensionAttribute]
public static OrderedParallelQuery`1<TSource> OrderBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static OrderedParallelQuery`1<TSource> OrderBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static OrderedParallelQuery`1<TSource> OrderByDescending(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static OrderedParallelQuery`1<TSource> OrderByDescending(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static OrderedParallelQuery`1<TSource> ThenBy(OrderedParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static OrderedParallelQuery`1<TSource> ThenBy(OrderedParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static OrderedParallelQuery`1<TSource> ThenByDescending(OrderedParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static OrderedParallelQuery`1<TSource> ThenByDescending(OrderedParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<IGrouping`2<TKey, TSource>> GroupBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static ParallelQuery`1<IGrouping`2<TKey, TSource>> GroupBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<IGrouping`2<TKey, TElement>> GroupBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector);
    [ExtensionAttribute]
public static ParallelQuery`1<IGrouping`2<TKey, TElement>> GroupBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> GroupBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`3<TKey, IEnumerable`1<TSource>, TResult> resultSelector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> GroupBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`3<TKey, IEnumerable`1<TSource>, TResult> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> GroupBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, Func`3<TKey, IEnumerable`1<TElement>, TResult> resultSelector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> GroupBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, Func`3<TKey, IEnumerable`1<TElement>, TResult> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
private static T PerformAggregation(ParallelQuery`1<T> source, Func`3<T, T, T> reduce, T seed, bool seedIsSpecified, bool throwIfEmpty, QueryAggregationOptions options);
    [ExtensionAttribute]
private static TAccumulate PerformSequentialAggregation(ParallelQuery`1<TSource> source, TAccumulate seed, bool seedIsSpecified, Func`3<TAccumulate, TSource, TAccumulate> func);
    [ExtensionAttribute]
public static TSource Aggregate(ParallelQuery`1<TSource> source, Func`3<TSource, TSource, TSource> func);
    [ExtensionAttribute]
internal static TSource Aggregate(ParallelQuery`1<TSource> source, Func`3<TSource, TSource, TSource> func, QueryAggregationOptions options);
    [ExtensionAttribute]
public static TAccumulate Aggregate(ParallelQuery`1<TSource> source, TAccumulate seed, Func`3<TAccumulate, TSource, TAccumulate> func);
    [ExtensionAttribute]
internal static TAccumulate Aggregate(ParallelQuery`1<TSource> source, TAccumulate seed, Func`3<TAccumulate, TSource, TAccumulate> func, QueryAggregationOptions options);
    [ExtensionAttribute]
public static TResult Aggregate(ParallelQuery`1<TSource> source, TAccumulate seed, Func`3<TAccumulate, TSource, TAccumulate> func, Func`2<TAccumulate, TResult> resultSelector);
    [ExtensionAttribute]
public static TResult Aggregate(ParallelQuery`1<TSource> source, TAccumulate seed, Func`3<TAccumulate, TSource, TAccumulate> updateAccumulatorFunc, Func`3<TAccumulate, TAccumulate, TAccumulate> combineAccumulatorsFunc, Func`2<TAccumulate, TResult> resultSelector);
    [ExtensionAttribute]
public static TResult Aggregate(ParallelQuery`1<TSource> source, Func`1<TAccumulate> seedFactory, Func`3<TAccumulate, TSource, TAccumulate> updateAccumulatorFunc, Func`3<TAccumulate, TAccumulate, TAccumulate> combineAccumulatorsFunc, Func`2<TAccumulate, TResult> resultSelector);
    [ExtensionAttribute]
public static int Count(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static int Count(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static long LongCount(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static long LongCount(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static int Sum(ParallelQuery`1<int> source);
    [ExtensionAttribute]
public static Nullable`1<int> Sum(ParallelQuery`1<Nullable`1<int>> source);
    [ExtensionAttribute]
public static long Sum(ParallelQuery`1<long> source);
    [ExtensionAttribute]
public static Nullable`1<long> Sum(ParallelQuery`1<Nullable`1<long>> source);
    [ExtensionAttribute]
public static float Sum(ParallelQuery`1<float> source);
    [ExtensionAttribute]
public static Nullable`1<float> Sum(ParallelQuery`1<Nullable`1<float>> source);
    [ExtensionAttribute]
public static double Sum(ParallelQuery`1<double> source);
    [ExtensionAttribute]
public static Nullable`1<double> Sum(ParallelQuery`1<Nullable`1<double>> source);
    [ExtensionAttribute]
public static decimal Sum(ParallelQuery`1<decimal> source);
    [ExtensionAttribute]
public static Nullable`1<decimal> Sum(ParallelQuery`1<Nullable`1<decimal>> source);
    [ExtensionAttribute]
public static int Sum(ParallelQuery`1<TSource> source, Func`2<TSource, int> selector);
    [ExtensionAttribute]
public static Nullable`1<int> Sum(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<int>> selector);
    [ExtensionAttribute]
public static long Sum(ParallelQuery`1<TSource> source, Func`2<TSource, long> selector);
    [ExtensionAttribute]
public static Nullable`1<long> Sum(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<long>> selector);
    [ExtensionAttribute]
public static float Sum(ParallelQuery`1<TSource> source, Func`2<TSource, float> selector);
    [ExtensionAttribute]
public static Nullable`1<float> Sum(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<float>> selector);
    [ExtensionAttribute]
public static double Sum(ParallelQuery`1<TSource> source, Func`2<TSource, double> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Sum(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<double>> selector);
    [ExtensionAttribute]
public static decimal Sum(ParallelQuery`1<TSource> source, Func`2<TSource, decimal> selector);
    [ExtensionAttribute]
public static Nullable`1<decimal> Sum(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<decimal>> selector);
    [ExtensionAttribute]
public static int Min(ParallelQuery`1<int> source);
    [ExtensionAttribute]
public static Nullable`1<int> Min(ParallelQuery`1<Nullable`1<int>> source);
    [ExtensionAttribute]
public static long Min(ParallelQuery`1<long> source);
    [ExtensionAttribute]
public static Nullable`1<long> Min(ParallelQuery`1<Nullable`1<long>> source);
    [ExtensionAttribute]
public static float Min(ParallelQuery`1<float> source);
    [ExtensionAttribute]
public static Nullable`1<float> Min(ParallelQuery`1<Nullable`1<float>> source);
    [ExtensionAttribute]
public static double Min(ParallelQuery`1<double> source);
    [ExtensionAttribute]
public static Nullable`1<double> Min(ParallelQuery`1<Nullable`1<double>> source);
    [ExtensionAttribute]
public static decimal Min(ParallelQuery`1<decimal> source);
    [ExtensionAttribute]
public static Nullable`1<decimal> Min(ParallelQuery`1<Nullable`1<decimal>> source);
    [ExtensionAttribute]
public static TSource Min(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static int Min(ParallelQuery`1<TSource> source, Func`2<TSource, int> selector);
    [ExtensionAttribute]
public static Nullable`1<int> Min(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<int>> selector);
    [ExtensionAttribute]
public static long Min(ParallelQuery`1<TSource> source, Func`2<TSource, long> selector);
    [ExtensionAttribute]
public static Nullable`1<long> Min(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<long>> selector);
    [ExtensionAttribute]
public static float Min(ParallelQuery`1<TSource> source, Func`2<TSource, float> selector);
    [ExtensionAttribute]
public static Nullable`1<float> Min(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<float>> selector);
    [ExtensionAttribute]
public static double Min(ParallelQuery`1<TSource> source, Func`2<TSource, double> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Min(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<double>> selector);
    [ExtensionAttribute]
public static decimal Min(ParallelQuery`1<TSource> source, Func`2<TSource, decimal> selector);
    [ExtensionAttribute]
public static Nullable`1<decimal> Min(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<decimal>> selector);
    [ExtensionAttribute]
public static TResult Min(ParallelQuery`1<TSource> source, Func`2<TSource, TResult> selector);
    [ExtensionAttribute]
public static int Max(ParallelQuery`1<int> source);
    [ExtensionAttribute]
public static Nullable`1<int> Max(ParallelQuery`1<Nullable`1<int>> source);
    [ExtensionAttribute]
public static long Max(ParallelQuery`1<long> source);
    [ExtensionAttribute]
public static Nullable`1<long> Max(ParallelQuery`1<Nullable`1<long>> source);
    [ExtensionAttribute]
public static float Max(ParallelQuery`1<float> source);
    [ExtensionAttribute]
public static Nullable`1<float> Max(ParallelQuery`1<Nullable`1<float>> source);
    [ExtensionAttribute]
public static double Max(ParallelQuery`1<double> source);
    [ExtensionAttribute]
public static Nullable`1<double> Max(ParallelQuery`1<Nullable`1<double>> source);
    [ExtensionAttribute]
public static decimal Max(ParallelQuery`1<decimal> source);
    [ExtensionAttribute]
public static Nullable`1<decimal> Max(ParallelQuery`1<Nullable`1<decimal>> source);
    [ExtensionAttribute]
public static TSource Max(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static int Max(ParallelQuery`1<TSource> source, Func`2<TSource, int> selector);
    [ExtensionAttribute]
public static Nullable`1<int> Max(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<int>> selector);
    [ExtensionAttribute]
public static long Max(ParallelQuery`1<TSource> source, Func`2<TSource, long> selector);
    [ExtensionAttribute]
public static Nullable`1<long> Max(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<long>> selector);
    [ExtensionAttribute]
public static float Max(ParallelQuery`1<TSource> source, Func`2<TSource, float> selector);
    [ExtensionAttribute]
public static Nullable`1<float> Max(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<float>> selector);
    [ExtensionAttribute]
public static double Max(ParallelQuery`1<TSource> source, Func`2<TSource, double> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Max(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<double>> selector);
    [ExtensionAttribute]
public static decimal Max(ParallelQuery`1<TSource> source, Func`2<TSource, decimal> selector);
    [ExtensionAttribute]
public static Nullable`1<decimal> Max(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<decimal>> selector);
    [ExtensionAttribute]
public static TResult Max(ParallelQuery`1<TSource> source, Func`2<TSource, TResult> selector);
    [ExtensionAttribute]
public static double Average(ParallelQuery`1<int> source);
    [ExtensionAttribute]
public static Nullable`1<double> Average(ParallelQuery`1<Nullable`1<int>> source);
    [ExtensionAttribute]
public static double Average(ParallelQuery`1<long> source);
    [ExtensionAttribute]
public static Nullable`1<double> Average(ParallelQuery`1<Nullable`1<long>> source);
    [ExtensionAttribute]
public static float Average(ParallelQuery`1<float> source);
    [ExtensionAttribute]
public static Nullable`1<float> Average(ParallelQuery`1<Nullable`1<float>> source);
    [ExtensionAttribute]
public static double Average(ParallelQuery`1<double> source);
    [ExtensionAttribute]
public static Nullable`1<double> Average(ParallelQuery`1<Nullable`1<double>> source);
    [ExtensionAttribute]
public static decimal Average(ParallelQuery`1<decimal> source);
    [ExtensionAttribute]
public static Nullable`1<decimal> Average(ParallelQuery`1<Nullable`1<decimal>> source);
    [ExtensionAttribute]
public static double Average(ParallelQuery`1<TSource> source, Func`2<TSource, int> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Average(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<int>> selector);
    [ExtensionAttribute]
public static double Average(ParallelQuery`1<TSource> source, Func`2<TSource, long> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Average(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<long>> selector);
    [ExtensionAttribute]
public static float Average(ParallelQuery`1<TSource> source, Func`2<TSource, float> selector);
    [ExtensionAttribute]
public static Nullable`1<float> Average(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<float>> selector);
    [ExtensionAttribute]
public static double Average(ParallelQuery`1<TSource> source, Func`2<TSource, double> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Average(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<double>> selector);
    [ExtensionAttribute]
public static decimal Average(ParallelQuery`1<TSource> source, Func`2<TSource, decimal> selector);
    [ExtensionAttribute]
public static Nullable`1<decimal> Average(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<decimal>> selector);
    [ExtensionAttribute]
public static bool Any(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static bool Any(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static bool All(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static bool Contains(ParallelQuery`1<TSource> source, TSource value);
    [ExtensionAttribute]
public static bool Contains(ParallelQuery`1<TSource> source, TSource value, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Take(ParallelQuery`1<TSource> source, int count);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> TakeWhile(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> TakeWhile(ParallelQuery`1<TSource> source, Func`3<TSource, int, bool> predicate);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Skip(ParallelQuery`1<TSource> source, int count);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> SkipWhile(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> SkipWhile(ParallelQuery`1<TSource> source, Func`3<TSource, int, bool> predicate);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Concat(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second);
    [ExtensionAttribute]
[ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
public static ParallelQuery`1<TSource> Concat(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second);
    [ExtensionAttribute]
public static bool SequenceEqual(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second);
    [ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
[ExtensionAttribute]
public static bool SequenceEqual(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second);
    [ExtensionAttribute]
public static bool SequenceEqual(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    private static void DisposeEnumerator(IEnumerator`1<TSource> e, CancellationState cancelState);
    [ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
[ExtensionAttribute]
public static bool SequenceEqual(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Distinct(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Distinct(ParallelQuery`1<TSource> source, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Union(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second);
    [ExtensionAttribute]
[ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
public static ParallelQuery`1<TSource> Union(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Union(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
[ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
public static ParallelQuery`1<TSource> Union(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Intersect(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second);
    [ExtensionAttribute]
[ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
public static ParallelQuery`1<TSource> Intersect(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Intersect(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
[ExtensionAttribute]
public static ParallelQuery`1<TSource> Intersect(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Except(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second);
    [ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
[ExtensionAttribute]
public static ParallelQuery`1<TSource> Except(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Except(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
[ExtensionAttribute]
public static ParallelQuery`1<TSource> Except(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> AsEnumerable(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static TSource[] ToArray(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static List`1<TSource> ToList(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TSource> ToDictionary(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TSource> ToDictionary(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TElement> ToDictionary(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TElement> ToDictionary(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static ILookup`2<TKey, TSource> ToLookup(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static ILookup`2<TKey, TSource> ToLookup(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static ILookup`2<TKey, TElement> ToLookup(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector);
    [ExtensionAttribute]
public static ILookup`2<TKey, TElement> ToLookup(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Reverse(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> OfType(ParallelQuery source);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> Cast(ParallelQuery source);
    private static TSource GetOneWithPossibleDefault(QueryOperator`1<TSource> queryOp, bool throwIfTwo, bool defaultIfEmpty);
    [ExtensionAttribute]
public static TSource First(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static TSource First(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static TSource FirstOrDefault(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static TSource FirstOrDefault(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static TSource Last(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static TSource Last(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static TSource LastOrDefault(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static TSource LastOrDefault(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static TSource Single(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static TSource Single(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static TSource SingleOrDefault(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static TSource SingleOrDefault(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> DefaultIfEmpty(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> DefaultIfEmpty(ParallelQuery`1<TSource> source, TSource defaultValue);
    [ExtensionAttribute]
public static TSource ElementAt(ParallelQuery`1<TSource> source, int index);
    [ExtensionAttribute]
public static TSource ElementAtOrDefault(ParallelQuery`1<TSource> source, int index);
}
public enum System.Linq.ParallelExecutionMode : Enum {
    public int value__;
    public static ParallelExecutionMode Default;
    public static ParallelExecutionMode ForceParallelism;
}
public enum System.Linq.ParallelMergeOptions : Enum {
    public int value__;
    public static ParallelMergeOptions Default;
    public static ParallelMergeOptions NotBuffered;
    public static ParallelMergeOptions AutoBuffered;
    public static ParallelMergeOptions FullyBuffered;
}
public class System.Linq.ParallelQuery : object {
    private QuerySettings _specifiedSettings;
    internal QuerySettings SpecifiedQuerySettings { get; }
    internal ParallelQuery(QuerySettings specifiedSettings);
    internal QuerySettings get_SpecifiedQuerySettings();
    [ExcludeFromCodeCoverageAttribute]
internal virtual ParallelQuery`1<TCastTo> Cast();
    [ExcludeFromCodeCoverageAttribute]
internal virtual ParallelQuery`1<TCastTo> OfType();
    [ExcludeFromCodeCoverageAttribute]
internal virtual IEnumerator GetEnumeratorUntyped();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Linq.ParallelQuery`1 : ParallelQuery {
    internal ParallelQuery`1(QuerySettings settings);
    internal sealed virtual ParallelQuery`1<TCastTo> Cast();
    internal sealed virtual ParallelQuery`1<TCastTo> OfType();
    internal virtual IEnumerator GetEnumeratorUntyped();
    public virtual IEnumerator`1<TSource> GetEnumerator();
}
internal static class System.SR : object {
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string MoreThanOneMatch { get; }
    internal static string NoElements { get; }
    internal static string ParallelPartitionable_NullReturn { get; }
    internal static string ParallelPartitionable_IncorretElementCount { get; }
    internal static string ParallelPartitionable_NullElement { get; }
    internal static string PLINQ_CommonEnumerator_Current_NotStarted { get; }
    internal static string PLINQ_ExternalCancellationRequested { get; }
    internal static string PLINQ_DisposeRequested { get; }
    internal static string ParallelQuery_DuplicateTaskScheduler { get; }
    internal static string ParallelQuery_DuplicateDOP { get; }
    internal static string ParallelQuery_DuplicateExecutionMode { get; }
    internal static string PartitionerQueryOperator_NullPartitionList { get; }
    internal static string PartitionerQueryOperator_WrongNumberOfPartitions { get; }
    internal static string PartitionerQueryOperator_NullPartition { get; }
    internal static string ParallelQuery_DuplicateWithCancellation { get; }
    internal static string ParallelQuery_DuplicateMergeOptions { get; }
    internal static string PLINQ_EnumerationPreviouslyFailed { get; }
    internal static string ParallelQuery_PartitionerNotOrderable { get; }
    internal static string ParallelQuery_InvalidAsOrderedCall { get; }
    internal static string ParallelQuery_InvalidNonGenericAsOrderedCall { get; }
    internal static string ParallelEnumerable_BinaryOpMustUseAsParallel { get; }
    internal static string ParallelEnumerable_WithQueryExecutionMode_InvalidMode { get; }
    internal static string ParallelEnumerable_WithMergeOptions_InvalidOptions { get; }
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static ResourceManager get_ResourceManager();
    internal static string get_MoreThanOneMatch();
    internal static string get_NoElements();
    internal static string get_ParallelPartitionable_NullReturn();
    internal static string get_ParallelPartitionable_IncorretElementCount();
    internal static string get_ParallelPartitionable_NullElement();
    internal static string get_PLINQ_CommonEnumerator_Current_NotStarted();
    internal static string get_PLINQ_ExternalCancellationRequested();
    internal static string get_PLINQ_DisposeRequested();
    internal static string get_ParallelQuery_DuplicateTaskScheduler();
    internal static string get_ParallelQuery_DuplicateDOP();
    internal static string get_ParallelQuery_DuplicateExecutionMode();
    internal static string get_PartitionerQueryOperator_NullPartitionList();
    internal static string get_PartitionerQueryOperator_WrongNumberOfPartitions();
    internal static string get_PartitionerQueryOperator_NullPartition();
    internal static string get_ParallelQuery_DuplicateWithCancellation();
    internal static string get_ParallelQuery_DuplicateMergeOptions();
    internal static string get_PLINQ_EnumerationPreviouslyFailed();
    internal static string get_ParallelQuery_PartitionerNotOrderable();
    internal static string get_ParallelQuery_InvalidAsOrderedCall();
    internal static string get_ParallelQuery_InvalidNonGenericAsOrderedCall();
    internal static string get_ParallelEnumerable_BinaryOpMustUseAsParallel();
    internal static string get_ParallelEnumerable_WithQueryExecutionMode_InvalidMode();
    internal static string get_ParallelEnumerable_WithMergeOptions_InvalidOptions();
}
