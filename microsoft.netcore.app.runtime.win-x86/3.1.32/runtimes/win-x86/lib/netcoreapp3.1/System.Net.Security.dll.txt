internal static class FxResources.System.Net.Security.SR : object {
}
internal static class Interop : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal class System.Collections.Generic.BidirectionalDictionary`2 : object {
    private Dictionary`2<T1, T2> _forward;
    private Dictionary`2<T2, T1> _backward;
    public BidirectionalDictionary`2(int capacity);
    public void Add(T1 item1, T2 item2);
    public bool TryGetForward(T1 item1, T2& item2);
    public bool TryGetBackward(T2 item2, T1& item1);
    public Enumerator<T1, T2> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<T1, T2>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<T1,T2>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class System.Net.AsyncProtocolCallback : MulticastDelegate {
    public AsyncProtocolCallback(object object, IntPtr method);
    public virtual void Invoke(AsyncProtocolRequest asyncRequest);
    public virtual IAsyncResult BeginInvoke(AsyncProtocolRequest asyncRequest, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Net.AsyncProtocolRequest : object {
    private AsyncProtocolCallback _callback;
    private int _completionStatus;
    public LazyAsyncResult UserAsyncResult;
    public int Result;
    public object AsyncState;
    public CancellationToken CancellationToken;
    public Byte[] Buffer;
    public int Offset;
    public int Count;
    internal object AsyncObject { get; }
    public bool MustCompleteSynchronously { get; }
    internal bool IsUserCompleted { get; }
    public AsyncProtocolRequest(LazyAsyncResult userAsyncResult, CancellationToken cancellationToken);
    public void SetNextRequest(Byte[] buffer, int offset, int count, AsyncProtocolCallback callback);
    internal object get_AsyncObject();
    internal void CompleteRequest(int result);
    public bool get_MustCompleteSynchronously();
    internal void CompleteUserWithError(Exception e);
    internal void CompleteUser();
    internal void CompleteUser(int userResult);
    internal bool get_IsUserCompleted();
}
internal class System.Net.BufferAsyncResult : LazyAsyncResult {
    public static object ResultSentinal;
    private int _countOrResult;
    [CompilerGeneratedAttribute]
private Byte[] <Buffer>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    public Byte[] Buffer { get; }
    public int Offset { get; }
    public int Count { get; }
    public int Int32Result { get; public set; }
    public BufferAsyncResult(object asyncObject, Byte[] buffer, int offset, int count, object asyncState, AsyncCallback asyncCallback);
    private static BufferAsyncResult();
    [CompilerGeneratedAttribute]
public Byte[] get_Buffer();
    [CompilerGeneratedAttribute]
public int get_Offset();
    public int get_Count();
    public int get_Int32Result();
    public void set_Int32Result(int value);
}
internal static class System.Net.CertificateValidationPal : object {
    private static object s_syncObject;
    private static X509Store modreq(System.Runtime.CompilerServices.IsVolatile) s_myCertStoreEx;
    private static X509Store modreq(System.Runtime.CompilerServices.IsVolatile) s_myMachineCertStoreEx;
    private static CertificateValidationPal();
    internal static X509Store EnsureStoreOpened(bool isMachineStore);
    internal static SslPolicyErrors VerifyCertificateProperties(SafeDeleteContext securityContext, X509Chain chain, X509Certificate2 remoteCertificate, bool checkCertName, bool isServer, string hostName);
    internal static X509Certificate2 GetRemoteCertificate(SafeDeleteContext securityContext, X509Certificate2Collection& remoteCertificateCollection);
    internal static String[] GetRequestCertificateAuthorities(SafeDeleteContext securityContext);
    internal static X509Store OpenStore(StoreLocation storeLocation);
    private static UInt32 Verify(SafeX509ChainHandle chainContext, CERT_CHAIN_POLICY_PARA& cpp);
}
internal static class System.Net.ContextFlagsAdapterPal : object {
    private static ContextFlagMapping[] s_contextFlagMapping;
    private static ContextFlagsAdapterPal();
    internal static ContextFlagsPal GetContextFlagsPalFromInterop(ContextFlags win32Flags);
    internal static ContextFlags GetInteropFromContextFlagsPal(ContextFlagsPal flags);
}
[FlagsAttribute]
internal enum System.Net.ContextFlagsPal : Enum {
    public int value__;
    public static ContextFlagsPal None;
    public static ContextFlagsPal Delegate;
    public static ContextFlagsPal MutualAuth;
    public static ContextFlagsPal ReplayDetect;
    public static ContextFlagsPal SequenceDetect;
    public static ContextFlagsPal Confidentiality;
    public static ContextFlagsPal UseSessionKey;
    public static ContextFlagsPal AllocateMemory;
    public static ContextFlagsPal Connection;
    public static ContextFlagsPal InitExtendedError;
    public static ContextFlagsPal AcceptExtendedError;
    public static ContextFlagsPal InitStream;
    public static ContextFlagsPal AcceptStream;
    public static ContextFlagsPal InitIntegrity;
    public static ContextFlagsPal AcceptIntegrity;
    public static ContextFlagsPal InitManualCredValidation;
    public static ContextFlagsPal InitUseSuppliedCreds;
    public static ContextFlagsPal InitIdentify;
    public static ContextFlagsPal AcceptIdentify;
    public static ContextFlagsPal ProxyBindings;
    public static ContextFlagsPal AllowMissingBindings;
    public static ContextFlagsPal UnverifiedTargetName;
}
internal static class System.Net.ExceptionCheck : object {
    internal static bool IsFatal(Exception exception);
}
internal static class System.Net.FixedSizeReader : object {
    public static int ReadPacket(Stream transport, Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("System.Net.FixedSizeReader/<ReadPacketAsync>d__1")]
public static Task ReadPacketAsync(Stream transport, AsyncProtocolRequest request);
}
internal class System.Net.FrameHeader : object {
    private int _MessageId;
    private int _MajorV;
    private int _MinorV;
    private int _PayloadSize;
    public int Size { get; }
    public int MaxMessageSize { get; }
    public int MessageId { get; public set; }
    public int MajorV { get; }
    public int MinorV { get; }
    public int PayloadSize { get; public set; }
    public FrameHeader(int messageId, int majorV, int minorV);
    public int get_Size();
    public int get_MaxMessageSize();
    public int get_MessageId();
    public void set_MessageId(int value);
    public int get_MajorV();
    public int get_MinorV();
    public int get_PayloadSize();
    public void set_PayloadSize(int value);
    public void CopyTo(Byte[] dest, int start);
    public void CopyFrom(Byte[] bytes, int start, FrameHeader verifier);
}
internal static class System.Net.GlobalSSPI : object {
    internal static SSPIAuthType SSPIAuth;
    internal static SSPISecureChannelType SSPISecureChannel;
    private static GlobalSSPI();
}
internal class System.Net.InternalException : Exception {
    private object _unexpectedValue;
    public string Message { get; }
    internal InternalException(object unexpectedValue);
    public virtual string get_Message();
}
internal class System.Net.LazyAsyncResult : object {
    [ThreadStaticAttribute]
private static ThreadContext t_threadContext;
    private object _asyncObject;
    private object _asyncState;
    private AsyncCallback _asyncCallback;
    private object _result;
    private int _intCompleted;
    private bool _userEvent;
    private object _event;
    private static ThreadContext CurrentThreadContext { get; }
    internal object AsyncObject { get; }
    public object AsyncState { get; }
    public WaitHandle AsyncWaitHandle { get; }
    public bool CompletedSynchronously { get; }
    public bool IsCompleted { get; }
    internal bool InternalPeekCompleted { get; }
    internal object Result { get; internal set; }
    internal LazyAsyncResult(object myObject, object myState, AsyncCallback myCallBack);
    private static ThreadContext get_CurrentThreadContext();
    internal object get_AsyncObject();
    public sealed virtual object get_AsyncState();
    public sealed virtual WaitHandle get_AsyncWaitHandle();
    private bool LazilyCreateEvent(ManualResetEvent& waitHandle);
    public sealed virtual bool get_CompletedSynchronously();
    public sealed virtual bool get_IsCompleted();
    internal bool get_InternalPeekCompleted();
    internal object get_Result();
    internal void set_Result(object value);
    protected void ProtectedInvokeCallback(object result, IntPtr userToken);
    internal void InvokeCallback(object result);
    internal void InvokeCallback();
    protected virtual void Complete(IntPtr userToken);
    private static void WorkerThreadComplete(object state);
    protected virtual void Cleanup();
    internal object InternalWaitForCompletion();
    private object WaitForCompletion(bool snap);
}
internal static class System.Net.NegotiationInfoClass : object {
    internal static string GetAuthenticationPackageName(SafeHandle safeHandle, int negotiationState);
}
[EventSourceAttribute]
internal class System.Net.NetEventSource : EventSource {
    private static int SecureChannelCtorId;
    private static int LocatingPrivateKeyId;
    private static int CertIsType2Id;
    private static int FoundCertInStoreId;
    private static int NotFoundCertInStoreId;
    private static int RemoteCertificateId;
    private static int CertificateFromDelegateId;
    private static int NoDelegateNoClientCertId;
    private static int NoDelegateButClientCertId;
    private static int AttemptingRestartUsingCertId;
    private static int NoIssuersTryAllCertsId;
    private static int LookForMatchingCertsId;
    private static int SelectedCertId;
    private static int CertsAfterFilteringId;
    private static int FindingMatchingCertsId;
    private static int UsingCachedCredentialId;
    private static int SspiSelectedCipherSuitId;
    private static int RemoteCertificateErrorId;
    private static int RemoteVertificateValidId;
    private static int RemoteCertificateSuccesId;
    private static int RemoteCertificateInvalidId;
    public static NetEventSource Log;
    private static string MissingMember;
    private static string NullInstance;
    private static string StaticMethodObject;
    private static string NoParameters;
    private static int MaxDumpSize;
    private static int EnterEventId;
    private static int ExitEventId;
    private static int AssociateEventId;
    private static int InfoEventId;
    private static int ErrorEventId;
    private static int CriticalFailureEventId;
    private static int DumpArrayEventId;
    private static int EnumerateSecurityPackagesId;
    private static int SspiPackageNotFoundId;
    private static int AcquireDefaultCredentialId;
    private static int AcquireCredentialsHandleId;
    private static int InitializeSecurityContextId;
    private static int SecurityContextInputBufferId;
    private static int SecurityContextInputBuffersId;
    private static int AcceptSecuritContextId;
    private static int OperationReturnedSomethingId;
    private static int NextAvailableEventId;
    public static bool IsEnabled { get; }
    private static NetEventSource();
    [NonEventAttribute]
public static void DumpBuffer(object thisOrContextObject, ReadOnlyMemory`1<byte> buffer, string memberName);
    [EventAttribute("8")]
public void EnumerateSecurityPackages(string securityPackage);
    [EventAttribute("9")]
public void SspiPackageNotFound(string packageName);
    [NonEventAttribute]
public void SecureChannelCtor(SecureChannel secureChannel, string hostname, X509CertificateCollection clientCertificates, EncryptionPolicy encryptionPolicy);
    [EventAttribute("17")]
private void SecureChannelCtor(string hostname, int secureChannelHash, int clientCertificatesCount, EncryptionPolicy encryptionPolicy);
    [NonEventAttribute]
public void LocatingPrivateKey(X509Certificate x509Certificate, SecureChannel secureChannel);
    [EventAttribute("18")]
private void LocatingPrivateKey(string x509Certificate, int secureChannelHash);
    [NonEventAttribute]
public void CertIsType2(SecureChannel secureChannel);
    [EventAttribute("19")]
private void CertIsType2(int secureChannelHash);
    [NonEventAttribute]
public void FoundCertInStore(bool serverMode, SecureChannel secureChannel);
    [EventAttribute("20")]
private void FoundCertInStore(string store, int secureChannelHash);
    [NonEventAttribute]
public void NotFoundCertInStore(SecureChannel secureChannel);
    [EventAttribute("21")]
private void NotFoundCertInStore(int secureChannelHash);
    [NonEventAttribute]
public void RemoteCertificate(X509Certificate remoteCertificate);
    [EventAttribute("22")]
private void RemoteCertificate(string remoteCertificate);
    [NonEventAttribute]
public void CertificateFromDelegate(SecureChannel secureChannel);
    [EventAttribute("23")]
private void CertificateFromDelegate(int secureChannelHash);
    [NonEventAttribute]
public void NoDelegateNoClientCert(SecureChannel secureChannel);
    [EventAttribute("24")]
private void NoDelegateNoClientCert(int secureChannelHash);
    [NonEventAttribute]
public void NoDelegateButClientCert(SecureChannel secureChannel);
    [EventAttribute("25")]
private void NoDelegateButClientCert(int secureChannelHash);
    [NonEventAttribute]
public void AttemptingRestartUsingCert(X509Certificate clientCertificate, SecureChannel secureChannel);
    [EventAttribute("26")]
private void AttemptingRestartUsingCert(string clientCertificate, int secureChannelHash);
    [NonEventAttribute]
public void NoIssuersTryAllCerts(SecureChannel secureChannel);
    [EventAttribute("27")]
private void NoIssuersTryAllCerts(int secureChannelHash);
    [NonEventAttribute]
public void LookForMatchingCerts(int issuersCount, SecureChannel secureChannel);
    [EventAttribute("28")]
private void LookForMatchingCerts(int issuersCount, int secureChannelHash);
    [NonEventAttribute]
public void SelectedCert(X509Certificate clientCertificate, SecureChannel secureChannel);
    [EventAttribute("29")]
private void SelectedCert(string clientCertificate, int secureChannelHash);
    [NonEventAttribute]
public void CertsAfterFiltering(int filteredCertsCount, SecureChannel secureChannel);
    [EventAttribute("30")]
private void CertsAfterFiltering(int filteredCertsCount, int secureChannelHash);
    [NonEventAttribute]
public void FindingMatchingCerts(SecureChannel secureChannel);
    [EventAttribute("31")]
private void FindingMatchingCerts(int secureChannelHash);
    [NonEventAttribute]
public void UsingCachedCredential(SecureChannel secureChannel);
    [EventAttribute("32")]
private void UsingCachedCredential(int secureChannelHash);
    [EventAttribute("33")]
public void SspiSelectedCipherSuite(string process, SslProtocols sslProtocol, CipherAlgorithmType cipherAlgorithm, int cipherStrength, HashAlgorithmType hashAlgorithm, int hashStrength, ExchangeAlgorithmType keyExchangeAlgorithm, int keyExchangeStrength);
    [NonEventAttribute]
public void RemoteCertificateError(SecureChannel secureChannel, string message);
    [EventAttribute("34")]
private void RemoteCertificateError(int secureChannelHash, string message);
    [NonEventAttribute]
public void RemoteCertDeclaredValid(SecureChannel secureChannel);
    [EventAttribute("35")]
private void RemoteCertDeclaredValid(int secureChannelHash);
    [NonEventAttribute]
public void RemoteCertHasNoErrors(SecureChannel secureChannel);
    [EventAttribute("36")]
private void RemoteCertHasNoErrors(int secureChannelHash);
    [NonEventAttribute]
public void RemoteCertUserDeclaredInvalid(SecureChannel secureChannel);
    [EventAttribute("37")]
private void RemoteCertUserDeclaredInvalid(int secureChannelHash);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, int arg2, int arg3, int arg4, int arg5, int arg6, int arg7, int arg8);
    [NonEventAttribute]
public static void Enter(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Enter(object thisOrContextObject, object arg0, string memberName);
    [NonEventAttribute]
public static void Enter(object thisOrContextObject, object arg0, object arg1, string memberName);
    [NonEventAttribute]
public static void Enter(object thisOrContextObject, object arg0, object arg1, object arg2, string memberName);
    [EventAttribute("1")]
private void Enter(string thisOrContextObject, string memberName, string parameters);
    [NonEventAttribute]
public static void Exit(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Exit(object thisOrContextObject, object arg0, string memberName);
    [NonEventAttribute]
public static void Exit(object thisOrContextObject, object arg0, object arg1, string memberName);
    [EventAttribute("2")]
private void Exit(string thisOrContextObject, string memberName, string result);
    [NonEventAttribute]
public static void Info(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Info(object thisOrContextObject, object message, string memberName);
    [EventAttribute("4")]
private void Info(string thisOrContextObject, string memberName, string message);
    [NonEventAttribute]
public static void Error(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Error(object thisOrContextObject, object message, string memberName);
    [EventAttribute("5")]
private void ErrorMessage(string thisOrContextObject, string memberName, string message);
    [NonEventAttribute]
public static void Fail(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Fail(object thisOrContextObject, object message, string memberName);
    [EventAttribute("6")]
private void CriticalFailure(string thisOrContextObject, string memberName, string message);
    [NonEventAttribute]
public static void DumpBuffer(object thisOrContextObject, Byte[] buffer, string memberName);
    [NonEventAttribute]
public static void DumpBuffer(object thisOrContextObject, Byte[] buffer, int offset, int count, string memberName);
    [NonEventAttribute]
public static void DumpBuffer(object thisOrContextObject, IntPtr bufferPtr, int count, string memberName);
    [EventAttribute("7")]
private void DumpBuffer(string thisOrContextObject, string memberName, Byte[] buffer);
    [NonEventAttribute]
public static void Associate(object first, object second, string memberName);
    [NonEventAttribute]
public static void Associate(object thisOrContextObject, object first, object second, string memberName);
    [EventAttribute("3")]
private void Associate(string thisOrContextObject, string memberName, string first, string second);
    [ConditionalAttribute("DEBUG_NETEVENTSOURCE_MISUSE")]
private static void DebugValidateArg(object arg);
    [ConditionalAttribute("DEBUG_NETEVENTSOURCE_MISUSE")]
private static void DebugValidateArg(FormattableString arg);
    public static bool get_IsEnabled();
    [NonEventAttribute]
public static string IdOf(object value);
    [NonEventAttribute]
public static int GetHashCode(object value);
    [NonEventAttribute]
public static object Format(object value);
    [NonEventAttribute]
private static string Format(FormattableString s);
    private static void AdditionalCustomizedToString(T value, String& result);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, string arg3, string arg4);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, Byte[] arg3);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, int arg2, int arg3, int arg4);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, int arg2, string arg3);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, int arg3);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, string arg3, int arg4);
    [EventAttribute("10")]
public void AcquireDefaultCredential(string packageName, CredentialUse intent);
    [NonEventAttribute]
public void AcquireCredentialsHandle(string packageName, CredentialUse intent, object authdata);
    [EventAttribute("11")]
public void AcquireCredentialsHandle(string packageName, CredentialUse intent, string authdata);
    [NonEventAttribute]
public void InitializeSecurityContext(SafeFreeCredentials credential, SafeDeleteContext context, string targetName, ContextFlags inFlags);
    [EventAttribute("12")]
private void InitializeSecurityContext(string credential, string context, string targetName, ContextFlags inFlags);
    [NonEventAttribute]
public void AcceptSecurityContext(SafeFreeCredentials credential, SafeDeleteContext context, ContextFlags inFlags);
    [EventAttribute("15")]
private void AcceptSecurityContext(string credential, string context, ContextFlags inFlags);
    [EventAttribute("16")]
public void OperationReturnedSomething(string operation, SECURITY_STATUS errorCode);
    [EventAttribute("13")]
public void SecurityContextInputBuffer(string context, int inputBufferSize, int outputBufferSize, SECURITY_STATUS errorCode);
    [EventAttribute("14")]
public void SecurityContextInputBuffers(string context, int inputBuffersSize, int outputBufferSize, SECURITY_STATUS errorCode);
}
internal class System.Net.NTAuthentication : object {
    private static ContextCallback s_InitializeCallback;
    private bool _isServer;
    private SafeFreeCredentials _credentialsHandle;
    private SafeDeleteContext _securityContext;
    private string _spn;
    private int _tokenSize;
    private ContextFlagsPal _requestedContextFlags;
    private ContextFlagsPal _contextFlags;
    private bool _isCompleted;
    private string _package;
    private string _lastProtocolName;
    private string _protocolName;
    private string _clientSpecifiedSpn;
    private ChannelBinding _channelBinding;
    internal string AssociatedName { get; }
    internal bool IsConfidentialityFlag { get; }
    internal bool IsIntegrityFlag { get; }
    internal bool IsMutualAuthFlag { get; }
    internal bool IsDelegationFlag { get; }
    internal bool IsIdentifyFlag { get; }
    internal string Spn { get; }
    internal bool IsNTLM { get; }
    internal bool IsCompleted { get; }
    internal bool IsValidContext { get; }
    internal bool IsServer { get; }
    internal string ClientSpecifiedSpn { get; }
    internal string ProtocolName { get; }
    internal bool IsKerberos { get; }
    internal NTAuthentication(bool isServer, string package, NetworkCredential credential, string spn, ContextFlagsPal requestedContextFlags, ChannelBinding channelBinding);
    private static NTAuthentication();
    internal string get_AssociatedName();
    internal bool get_IsConfidentialityFlag();
    internal bool get_IsIntegrityFlag();
    internal bool get_IsMutualAuthFlag();
    internal bool get_IsDelegationFlag();
    internal bool get_IsIdentifyFlag();
    internal string get_Spn();
    internal bool get_IsNTLM();
    private static void InitializeCallback(object state);
    internal int Encrypt(Byte[] buffer, int offset, int count, Byte[]& output, UInt32 sequenceNumber);
    internal int Decrypt(Byte[] payload, int offset, int count, Int32& newOffset, UInt32 expectedSeqNumber);
    internal bool get_IsCompleted();
    internal bool get_IsValidContext();
    internal bool get_IsServer();
    internal string get_ClientSpecifiedSpn();
    internal string get_ProtocolName();
    internal bool get_IsKerberos();
    private void Initialize(bool isServer, string package, NetworkCredential credential, string spn, ContextFlagsPal requestedContextFlags, ChannelBinding channelBinding);
    internal SafeDeleteContext GetContext(SecurityStatusPal& status);
    internal void CloseContext();
    internal int VerifySignature(Byte[] buffer, int offset, int count);
    internal int MakeSignature(Byte[] buffer, int offset, int count, Byte[]& output);
    internal string GetOutgoingBlob(string incomingBlob);
    internal Byte[] GetOutgoingBlob(Byte[] incomingBlob, bool thrownOnError);
    internal Byte[] GetOutgoingBlob(Byte[] incomingBlob, bool throwOnError, SecurityStatusPal& statusCode);
    private string GetClientSpecifiedSpn();
}
internal class System.Net.SecPkgContext_Bindings : ValueType {
    internal int BindingsLength;
    internal IntPtr Bindings;
}
internal class System.Net.SecPkgContext_CipherInfo : ValueType {
    private int dwVersion;
    private int dwProtocol;
    public int dwCipherSuite;
    private int dwBaseCipherSuite;
    [FixedBufferAttribute("System.Char", "64")]
private <szCipherSuite>e__FixedBuffer szCipherSuite;
    [FixedBufferAttribute("System.Char", "64")]
private <szCipher>e__FixedBuffer szCipher;
    private int dwCipherLen;
    private int dwCipherBlockLen;
    [FixedBufferAttribute("System.Char", "64")]
private <szHash>e__FixedBuffer szHash;
    private int dwHashLen;
    [FixedBufferAttribute("System.Char", "64")]
private <szExchange>e__FixedBuffer szExchange;
    private int dwMinExchangeLen;
    private int dwMaxExchangeLen;
    [FixedBufferAttribute("System.Char", "64")]
private <szCertificate>e__FixedBuffer szCertificate;
    private int dwKeyType;
}
internal class System.Net.SecPkgContext_ConnectionInfo : ValueType {
    public int Protocol;
    public int DataCipherAlg;
    public int DataKeySize;
    public int DataHashAlg;
    public int DataHashKeySize;
    public int KeyExchangeAlg;
    public int KeyExchKeySize;
}
internal class System.Net.SecPkgContext_NegotiationInfoW : ValueType {
    internal IntPtr PackageInfo;
    internal UInt32 NegotiationState;
}
internal class System.Net.SecPkgContext_Sizes : ValueType {
    public int cbMaxToken;
    public int cbMaxSignature;
    public int cbBlockSize;
    public int cbSecurityTrailer;
}
internal class System.Net.SecPkgContext_StreamSizes : ValueType {
    public int cbHeader;
    public int cbTrailer;
    public int cbMaximumMessage;
    public int cBuffers;
    public int cbBlockSize;
}
public abstract class System.Net.Security.AuthenticatedStream : Stream {
    private Stream _innerStream;
    private bool _leaveStreamOpen;
    public bool LeaveInnerStreamOpen { get; }
    protected Stream InnerStream { get; }
    public bool IsAuthenticated { get; }
    public bool IsMutuallyAuthenticated { get; }
    public bool IsEncrypted { get; }
    public bool IsSigned { get; }
    public bool IsServer { get; }
    protected AuthenticatedStream(Stream innerStream, bool leaveInnerStreamOpen);
    public bool get_LeaveInnerStreamOpen();
    protected Stream get_InnerStream();
    protected virtual void Dispose(bool disposing);
    public virtual ValueTask DisposeAsync();
    public abstract virtual bool get_IsAuthenticated();
    public abstract virtual bool get_IsMutuallyAuthenticated();
    public abstract virtual bool get_IsEncrypted();
    public abstract virtual bool get_IsSigned();
    public abstract virtual bool get_IsServer();
}
public class System.Net.Security.CipherSuitesPolicy : object {
    [CompilerGeneratedAttribute]
private CipherSuitesPolicyPal <Pal>k__BackingField;
    internal CipherSuitesPolicyPal Pal { get; private set; }
    [CLSCompliantAttribute("False")]
public IEnumerable`1<TlsCipherSuite> AllowedCipherSuites { get; }
    [CLSCompliantAttribute("False")]
public CipherSuitesPolicy(IEnumerable`1<TlsCipherSuite> allowedCipherSuites);
    [CompilerGeneratedAttribute]
internal CipherSuitesPolicyPal get_Pal();
    [CompilerGeneratedAttribute]
private void set_Pal(CipherSuitesPolicyPal value);
    [IteratorStateMachineAttribute("System.Net.Security.CipherSuitesPolicy/<get_AllowedCipherSuites>d__6")]
public IEnumerable`1<TlsCipherSuite> get_AllowedCipherSuites();
}
internal class System.Net.Security.CipherSuitesPolicyPal : object {
    internal CipherSuitesPolicyPal(IEnumerable`1<TlsCipherSuite> allowedCipherSuites);
    internal IEnumerable`1<TlsCipherSuite> GetCipherSuites();
}
public enum System.Net.Security.EncryptionPolicy : Enum {
    public int value__;
    public static EncryptionPolicy RequireEncryption;
    public static EncryptionPolicy AllowNoEncryption;
    public static EncryptionPolicy NoEncryption;
}
public class System.Net.Security.LocalCertificateSelectionCallback : MulticastDelegate {
    public LocalCertificateSelectionCallback(object object, IntPtr method);
    public virtual X509Certificate Invoke(object sender, string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers);
    public virtual IAsyncResult BeginInvoke(object sender, string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers, AsyncCallback callback, object object);
    public virtual X509Certificate EndInvoke(IAsyncResult result);
}
internal class System.Net.Security.LocalCertSelectionCallback : MulticastDelegate {
    public LocalCertSelectionCallback(object object, IntPtr method);
    public virtual X509Certificate Invoke(string targetHost, X509CertificateCollection localCertificates, X509Certificate2 remoteCertificate, String[] acceptableIssuers);
    public virtual IAsyncResult BeginInvoke(string targetHost, X509CertificateCollection localCertificates, X509Certificate2 remoteCertificate, String[] acceptableIssuers, AsyncCallback callback, object object);
    public virtual X509Certificate EndInvoke(IAsyncResult result);
}
internal class System.Net.Security.NegoState : object {
    private static Byte[] s_emptyMessage;
    private static AsyncCallback s_readCallback;
    private static AsyncCallback s_writeCallback;
    private Stream _innerStream;
    private bool _leaveStreamOpen;
    private Exception _exception;
    private StreamFramer _framer;
    private NTAuthentication _context;
    private int _nestedAuth;
    private bool _canRetryAuthentication;
    private ProtectionLevel _expectedProtectionLevel;
    private TokenImpersonationLevel _expectedImpersonationLevel;
    private UInt32 _writeSequenceNumber;
    private UInt32 _readSequenceNumber;
    private ExtendedProtectionPolicy _extendedProtectionPolicy;
    private bool _remoteOk;
    internal static string DefaultPackage { get; }
    internal bool IsAuthenticated { get; }
    internal bool IsMutuallyAuthenticated { get; }
    internal bool IsEncrypted { get; }
    internal bool IsSigned { get; }
    internal bool IsServer { get; }
    internal bool CanGetSecureStream { get; }
    internal TokenImpersonationLevel AllowedImpersonation { get; }
    private TokenImpersonationLevel PrivateImpersonationLevel { get; }
    private bool HandshakeComplete { get; }
    internal NegoState(Stream innerStream, bool leaveStreamOpen);
    private static NegoState();
    internal static string get_DefaultPackage();
    internal IIdentity GetIdentity();
    internal void ValidateCreateContext(string package, NetworkCredential credential, string servicePrincipalName, ExtendedProtectionPolicy policy, ProtectionLevel protectionLevel, TokenImpersonationLevel impersonationLevel);
    internal void ValidateCreateContext(string package, bool isServer, NetworkCredential credential, string servicePrincipalName, ChannelBinding channelBinding, ProtectionLevel protectionLevel, TokenImpersonationLevel impersonationLevel);
    private Exception SetException(Exception e);
    internal bool get_IsAuthenticated();
    internal bool get_IsMutuallyAuthenticated();
    internal bool get_IsEncrypted();
    internal bool get_IsSigned();
    internal bool get_IsServer();
    internal bool get_CanGetSecureStream();
    internal TokenImpersonationLevel get_AllowedImpersonation();
    private TokenImpersonationLevel get_PrivateImpersonationLevel();
    private bool get_HandshakeComplete();
    internal void CheckThrow(bool authSucessCheck);
    internal void Close();
    internal void ProcessAuthentication(LazyAsyncResult lazyResult);
    internal void EndProcessAuthentication(IAsyncResult result);
    private bool CheckSpn();
    private void StartSendBlob(Byte[] message, LazyAsyncResult lazyResult);
    private void CheckCompletionBeforeNextReceive(LazyAsyncResult lazyResult);
    private void StartReceiveBlob(LazyAsyncResult lazyResult);
    private void ProcessReceivedBlob(Byte[] message, LazyAsyncResult lazyResult);
    private void CheckCompletionBeforeNextSend(Byte[] message, LazyAsyncResult lazyResult);
    private void StartSendAuthResetSignal(LazyAsyncResult lazyResult, Byte[] message, Exception exception);
    private static void WriteCallback(IAsyncResult transportResult);
    private static void ReadCallback(IAsyncResult transportResult);
    internal static bool IsError(SecurityStatusPal status);
    private Byte[] GetOutgoingBlob(Byte[] incomingBlob, Exception& e);
    internal int EncryptData(Byte[] buffer, int offset, int count, Byte[]& outBuffer);
    internal int DecryptData(Byte[] buffer, int offset, int count, Int32& newOffset);
    internal static void ThrowCredentialException(long error);
    internal static bool IsLogonDeniedException(Exception exception);
}
public class System.Net.Security.NegotiateStream : AuthenticatedStream {
    private NegoState _negoState;
    private string _package;
    private IIdentity _remoteIdentity;
    private static AsyncCallback s_writeCallback;
    private static AsyncProtocolCallback s_readCallback;
    private int _NestedWrite;
    private int _NestedRead;
    private Byte[] _ReadHeader;
    private Byte[] _InternalBuffer;
    private int _InternalOffset;
    private int _InternalBufferCount;
    public bool IsAuthenticated { get; }
    public bool IsMutuallyAuthenticated { get; }
    public bool IsEncrypted { get; }
    public bool IsSigned { get; }
    public bool IsServer { get; }
    public TokenImpersonationLevel ImpersonationLevel { get; }
    public IIdentity RemoteIdentity { get; }
    public bool CanSeek { get; }
    public bool CanRead { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public long Length { get; }
    public long Position { get; public set; }
    private Byte[] InternalBuffer { get; }
    private int InternalOffset { get; }
    private int InternalBufferCount { get; }
    public NegotiateStream(Stream innerStream);
    public NegotiateStream(Stream innerStream, bool leaveInnerStreamOpen);
    private static NegotiateStream();
    public virtual IAsyncResult BeginAuthenticateAsClient(AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsClient(NetworkCredential credential, string targetName, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsClient(NetworkCredential credential, ChannelBinding binding, string targetName, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsClient(NetworkCredential credential, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsClient(NetworkCredential credential, ChannelBinding binding, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel, AsyncCallback asyncCallback, object asyncState);
    public virtual void EndAuthenticateAsClient(IAsyncResult asyncResult);
    public virtual void AuthenticateAsServer();
    public virtual void AuthenticateAsServer(ExtendedProtectionPolicy policy);
    public virtual void AuthenticateAsServer(NetworkCredential credential, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel);
    public virtual void AuthenticateAsServer(NetworkCredential credential, ExtendedProtectionPolicy policy, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel);
    public virtual IAsyncResult BeginAuthenticateAsServer(AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsServer(ExtendedProtectionPolicy policy, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsServer(NetworkCredential credential, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsServer(NetworkCredential credential, ExtendedProtectionPolicy policy, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel, AsyncCallback asyncCallback, object asyncState);
    public virtual void EndAuthenticateAsServer(IAsyncResult asyncResult);
    public virtual void AuthenticateAsClient();
    public virtual void AuthenticateAsClient(NetworkCredential credential, string targetName);
    public virtual void AuthenticateAsClient(NetworkCredential credential, ChannelBinding binding, string targetName);
    public virtual void AuthenticateAsClient(NetworkCredential credential, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel);
    public virtual void AuthenticateAsClient(NetworkCredential credential, ChannelBinding binding, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel);
    public virtual Task AuthenticateAsClientAsync();
    public virtual Task AuthenticateAsClientAsync(NetworkCredential credential, string targetName);
    public virtual Task AuthenticateAsClientAsync(NetworkCredential credential, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel);
    public virtual Task AuthenticateAsClientAsync(NetworkCredential credential, ChannelBinding binding, string targetName);
    public virtual Task AuthenticateAsClientAsync(NetworkCredential credential, ChannelBinding binding, string targetName, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel allowedImpersonationLevel);
    public virtual Task AuthenticateAsServerAsync();
    public virtual Task AuthenticateAsServerAsync(ExtendedProtectionPolicy policy);
    public virtual Task AuthenticateAsServerAsync(NetworkCredential credential, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel);
    public virtual Task AuthenticateAsServerAsync(NetworkCredential credential, ExtendedProtectionPolicy policy, ProtectionLevel requiredProtectionLevel, TokenImpersonationLevel requiredImpersonationLevel);
    public virtual bool get_IsAuthenticated();
    public virtual bool get_IsMutuallyAuthenticated();
    public virtual bool get_IsEncrypted();
    public virtual bool get_IsSigned();
    public virtual bool get_IsServer();
    public virtual TokenImpersonationLevel get_ImpersonationLevel();
    public virtual IIdentity get_RemoteIdentity();
    public virtual bool get_CanSeek();
    public virtual bool get_CanRead();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void SetLength(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    [AsyncStateMachineAttribute("System.Net.Security.NegotiateStream/<DisposeAsync>d__72")]
public virtual ValueTask DisposeAsync();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    public virtual void EndWrite(IAsyncResult asyncResult);
    private void InitializeStreamPart();
    private Byte[] get_InternalBuffer();
    private int get_InternalOffset();
    private int get_InternalBufferCount();
    private void DecrementInternalBufferCount(int decrCount);
    private void EnsureInternalBufferSize(int bytes);
    private void AdjustInternalBufferOffsetSize(int bytes, int offset);
    private void ValidateParameters(Byte[] buffer, int offset, int count);
    private void ProcessWrite(Byte[] buffer, int offset, int count, AsyncProtocolRequest asyncRequest);
    private void StartWriting(Byte[] buffer, int offset, int count, AsyncProtocolRequest asyncRequest);
    private int ProcessRead(Byte[] buffer, int offset, int count, AsyncProtocolRequest asyncRequest);
    private int StartReading(Byte[] buffer, int offset, int count, AsyncProtocolRequest asyncRequest);
    private int StartFrameHeader(Byte[] buffer, int offset, int count, AsyncProtocolRequest asyncRequest);
    private int StartFrameBody(int readBytes, Byte[] buffer, int offset, int count, AsyncProtocolRequest asyncRequest);
    private int ProcessFrameBody(int readBytes, Byte[] buffer, int offset, int count, AsyncProtocolRequest asyncRequest);
    private static void WriteCallback(IAsyncResult transportResult);
    private static void ReadCallback(AsyncProtocolRequest asyncRequest);
    [DebuggerHiddenAttribute]
[CompilerGeneratedAttribute]
private ValueTask <>n__0();
}
internal static class System.Net.Security.NegotiateStreamPal : object {
    internal static IIdentity GetIdentity(NTAuthentication context);
    internal static string QueryContextAssociatedName(SafeDeleteContext securityContext);
    internal static void ValidateImpersonationLevel(TokenImpersonationLevel impersonationLevel);
    internal static int Encrypt(SafeDeleteContext securityContext, Byte[] buffer, int offset, int count, bool isConfidential, bool isNtlm, Byte[]& output, UInt32 sequenceNumber);
    internal static int Decrypt(SafeDeleteContext securityContext, Byte[] buffer, int offset, int count, bool isConfidential, bool isNtlm, Int32& newOffset, UInt32 sequenceNumber);
    private static int DecryptNtlm(SafeDeleteContext securityContext, Byte[] buffer, int offset, int count, bool isConfidential, Int32& newOffset, UInt32 sequenceNumber);
    internal static int QueryMaxTokenSize(string package);
    internal static SafeFreeCredentials AcquireDefaultCredential(string package, bool isServer);
    internal static SafeFreeCredentials AcquireCredentialsHandle(string package, bool isServer, NetworkCredential credential);
    internal static string QueryContextClientSpecifiedSpn(SafeDeleteContext securityContext);
    internal static string QueryContextAuthenticationPackage(SafeDeleteContext securityContext);
    internal static SecurityStatusPal InitializeSecurityContext(SafeFreeCredentials& credentialsHandle, SafeDeleteContext& securityContext, string spn, ContextFlagsPal requestedContextFlags, Byte[] incomingBlob, ChannelBinding channelBinding, Byte[]& resultBlob, ContextFlagsPal& contextFlags);
    internal static SecurityStatusPal CompleteAuthToken(SafeDeleteContext& securityContext, Byte[] incomingBlob);
    internal static SecurityStatusPal AcceptSecurityContext(SafeFreeCredentials credentialsHandle, SafeDeleteContext& securityContext, ContextFlagsPal requestedContextFlags, Byte[] incomingBlob, ChannelBinding channelBinding, Byte[]& resultBlob, ContextFlagsPal& contextFlags);
    internal static Win32Exception CreateExceptionFromError(SecurityStatusPal statusCode);
    internal static int VerifySignature(SafeDeleteContext securityContext, Byte[] buffer, int offset, int count);
    internal static int MakeSignature(SafeDeleteContext securityContext, Byte[] buffer, int offset, int count, Byte[]& output);
}
public enum System.Net.Security.ProtectionLevel : Enum {
    public int value__;
    public static ProtectionLevel None;
    public static ProtectionLevel Sign;
    public static ProtectionLevel EncryptAndSign;
}
internal class System.Net.Security.ProtocolToken : object {
    internal SecurityStatusPal Status;
    internal Byte[] Payload;
    internal int Size;
    internal bool Failed { get; }
    internal bool Done { get; }
    internal bool Renegotiate { get; }
    internal bool CloseConnection { get; }
    internal ProtocolToken(Byte[] data, SecurityStatusPal status);
    internal bool get_Failed();
    internal bool get_Done();
    internal bool get_Renegotiate();
    internal bool get_CloseConnection();
    internal Exception GetException();
}
public class System.Net.Security.RemoteCertificateValidationCallback : MulticastDelegate {
    public RemoteCertificateValidationCallback(object object, IntPtr method);
    public virtual bool Invoke(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors);
    public virtual IAsyncResult BeginInvoke(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class System.Net.Security.RemoteCertValidationCallback : MulticastDelegate {
    public RemoteCertValidationCallback(object object, IntPtr method);
    public virtual bool Invoke(string host, X509Certificate2 certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors);
    public virtual IAsyncResult BeginInvoke(string host, X509Certificate2 certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class System.Net.Security.SafeCredentialReference : CriticalHandleMinusOneIsInvalid {
    internal SafeFreeCredentials Target;
    private SafeCredentialReference(SafeFreeCredentials target);
    internal static SafeCredentialReference CreateReference(SafeFreeCredentials target);
    protected virtual bool ReleaseHandle();
}
internal abstract class System.Net.Security.SafeDeleteContext : SafeHandle {
    internal CredHandle _handle;
    private static IdnMapping s_idnMapping;
    protected SafeFreeCredentials _EffectiveCredential;
    public bool IsInvalid { get; }
    private static SafeDeleteContext();
    public virtual bool get_IsInvalid();
    public virtual string ToString();
    internal static int InitializeSecurityContext(SafeFreeCredentials& inCredentials, SafeDeleteContext& refContext, string targetName, ContextFlags inFlags, Endianness endianness, ReadOnlySpan`1<SecurityBuffer> inSecBuffers, SecurityBuffer& outSecBuffer, ContextFlags& outFlags);
    private static int MustRunInitializeSecurityContext(SafeFreeCredentials& inCredentials, bool isContextAbsent, Byte* targetName, ContextFlags inFlags, Endianness endianness, SecBufferDesc* inputBuffer, SafeDeleteContext outContext, SecBufferDesc& outputBuffer, ContextFlags& attributes, SafeFreeContextBuffer handleTemplate);
    internal static int AcceptSecurityContext(SafeFreeCredentials& inCredentials, SafeDeleteContext& refContext, ContextFlags inFlags, Endianness endianness, ReadOnlySpan`1<SecurityBuffer> inSecBuffers, SecurityBuffer& outSecBuffer, ContextFlags& outFlags);
    private static int MustRunAcceptSecurityContext_SECURITY(SafeFreeCredentials& inCredentials, bool isContextAbsent, SecBufferDesc* inputBuffer, ContextFlags inFlags, Endianness endianness, SafeDeleteContext outContext, SecBufferDesc& outputBuffer, ContextFlags& outFlags, SafeFreeContextBuffer handleTemplate);
    internal static int CompleteAuthToken(SafeDeleteContext& refContext, SecurityBuffer& inSecBuffer);
    internal static int ApplyControlToken(SafeDeleteContext& refContext, SecurityBuffer& inSecBuffer);
}
internal class System.Net.Security.SafeDeleteContext_SECURITY : SafeDeleteContext {
    protected virtual bool ReleaseHandle();
}
internal class System.Net.Security.SafeFreeCertContext : SafeHandleZeroOrMinusOneIsInvalid {
    internal void Set(IntPtr value);
    protected virtual bool ReleaseHandle();
}
internal abstract class System.Net.Security.SafeFreeContextBuffer : SafeHandleZeroOrMinusOneIsInvalid {
    internal void Set(IntPtr value);
    internal static int EnumeratePackages(Int32& pkgnum, SafeFreeContextBuffer& pkgArray);
    internal static SafeFreeContextBuffer CreateEmptyHandle();
    public static int QueryContextAttributes(SafeDeleteContext phContext, ContextAttribute contextAttribute, Byte* buffer, SafeHandle refHandle);
}
internal class System.Net.Security.SafeFreeContextBuffer_SECURITY : SafeFreeContextBuffer {
    protected virtual bool ReleaseHandle();
}
internal abstract class System.Net.Security.SafeFreeContextBufferChannelBinding : ChannelBinding {
    private int _size;
    public int Size { get; }
    public bool IsInvalid { get; }
    public virtual int get_Size();
    public virtual bool get_IsInvalid();
    internal void Set(IntPtr value);
    internal static SafeFreeContextBufferChannelBinding CreateEmptyHandle();
    public static int QueryContextChannelBinding(SafeDeleteContext phContext, ContextAttribute contextAttribute, SecPkgContext_Bindings* buffer, SafeFreeContextBufferChannelBinding refHandle);
    public virtual string ToString();
}
internal class System.Net.Security.SafeFreeContextBufferChannelBinding_SECURITY : SafeFreeContextBufferChannelBinding {
    protected virtual bool ReleaseHandle();
}
internal class System.Net.Security.SafeFreeCredential_SECURITY : SafeFreeCredentials {
    protected virtual bool ReleaseHandle();
}
internal abstract class System.Net.Security.SafeFreeCredentials : SafeHandle {
    internal CredHandle _handle;
    public bool IsInvalid { get; }
    public virtual bool get_IsInvalid();
    public static int AcquireDefaultCredential(string package, CredentialUse intent, SafeFreeCredentials& outCredential);
    public static int AcquireCredentialsHandle(string package, CredentialUse intent, SafeSspiAuthDataHandle& authdata, SafeFreeCredentials& outCredential);
    public static int AcquireCredentialsHandle(string package, CredentialUse intent, SCHANNEL_CRED& authdata, SafeFreeCredentials& outCredential);
}
internal class System.Net.Security.SafeSspiAuthDataHandle : SafeHandleZeroOrMinusOneIsInvalid {
    protected virtual bool ReleaseHandle();
}
internal class System.Net.Security.SecureChannel : object {
    private SafeFreeCredentials _credentialsHandle;
    private SafeDeleteContext _securityContext;
    private SslConnectionInfo _connectionInfo;
    private X509Certificate _selectedClientCertificate;
    private bool _isRemoteCertificateAvailable;
    private int _headerSize;
    private int _trailerSize;
    private int _maxDataSize;
    private bool _refreshCredentialNeeded;
    private SslAuthenticationOptions _sslAuthenticationOptions;
    private SslApplicationProtocol _negotiatedApplicationProtocol;
    private static Oid s_serverAuthOid;
    private static Oid s_clientAuthOid;
    internal X509Certificate LocalServerCertificate { get; }
    internal X509Certificate LocalClientCertificate { get; }
    internal bool IsRemoteCertificateAvailable { get; }
    internal X509RevocationMode CheckCertRevocationStatus { get; }
    internal int MaxDataSize { get; }
    internal SslConnectionInfo ConnectionInfo { get; }
    internal bool IsValidContext { get; }
    internal bool IsServer { get; }
    internal bool RemoteCertRequired { get; }
    internal SslApplicationProtocol NegotiatedApplicationProtocol { get; }
    internal SecureChannel(SslAuthenticationOptions sslAuthenticationOptions);
    private static SecureChannel();
    internal X509Certificate get_LocalServerCertificate();
    internal X509Certificate get_LocalClientCertificate();
    internal bool get_IsRemoteCertificateAvailable();
    internal ChannelBinding GetChannelBinding(ChannelBindingKind kind);
    internal X509RevocationMode get_CheckCertRevocationStatus();
    internal int get_MaxDataSize();
    internal SslConnectionInfo get_ConnectionInfo();
    internal bool get_IsValidContext();
    internal bool get_IsServer();
    internal bool get_RemoteCertRequired();
    internal SslApplicationProtocol get_NegotiatedApplicationProtocol();
    internal void SetRefreshCredentialNeeded();
    internal void Close();
    private X509Certificate2 EnsurePrivateKey(X509Certificate certificate);
    private static X509Certificate2 MakeEx(X509Certificate certificate);
    private String[] GetRequestCertificateAuthorities();
    private bool AcquireClientCredentials(Byte[]& thumbPrint);
    private static List`1<T> EnsureInitialized(List`1& list);
    private bool AcquireServerCredentials(Byte[]& thumbPrint, Byte[] clientHello);
    internal ProtocolToken NextMessage(Byte[] incoming, int offset, int count);
    private SecurityStatusPal GenerateToken(Byte[] input, int offset, int count, Byte[]& output);
    internal void ProcessHandshakeSuccess();
    internal SecurityStatusPal Encrypt(ReadOnlyMemory`1<byte> buffer, Byte[]& output, Int32& resultSize);
    internal SecurityStatusPal Decrypt(Byte[] payload, Int32& offset, Int32& count);
    internal bool VerifyRemoteCertificate(RemoteCertValidationCallback remoteCertValidationCallback, ProtocolToken& alertToken);
    public ProtocolToken CreateFatalHandshakeAlertToken(SslPolicyErrors sslPolicyErrors, X509Chain chain);
    public ProtocolToken CreateShutdownToken();
    private ProtocolToken GenerateAlertToken();
    private static TlsAlertMessage GetAlertMessageFromChain(X509Chain chain);
    private void LogCertificateValidation(RemoteCertValidationCallback remoteCertValidationCallback, SslPolicyErrors sslPolicyErrors, bool success, X509Chain chain);
}
internal class System.Net.Security.SecurityBuffer : ValueType {
    public int offset;
    public int size;
    public SecurityBufferType type;
    public Byte[] token;
    public SafeHandle unmanagedToken;
    public SecurityBuffer(Byte[] data, int offset, int size, SecurityBufferType tokentype);
    public SecurityBuffer(Byte[] data, SecurityBufferType tokentype);
    public SecurityBuffer(int size, SecurityBufferType tokentype);
    public SecurityBuffer(ChannelBinding binding);
}
internal enum System.Net.Security.SecurityBufferType : Enum {
    public int value__;
    public static SecurityBufferType SECBUFFER_EMPTY;
    public static SecurityBufferType SECBUFFER_DATA;
    public static SecurityBufferType SECBUFFER_TOKEN;
    public static SecurityBufferType SECBUFFER_PKG_PARAMS;
    public static SecurityBufferType SECBUFFER_MISSING;
    public static SecurityBufferType SECBUFFER_EXTRA;
    public static SecurityBufferType SECBUFFER_STREAM_TRAILER;
    public static SecurityBufferType SECBUFFER_STREAM_HEADER;
    public static SecurityBufferType SECBUFFER_PADDING;
    public static SecurityBufferType SECBUFFER_STREAM;
    public static SecurityBufferType SECBUFFER_CHANNEL_BINDINGS;
    public static SecurityBufferType SECBUFFER_TARGET_HOST;
    public static SecurityBufferType SECBUFFER_ALERT;
    public static SecurityBufferType SECBUFFER_APPLICATION_PROTOCOLS;
    public static SecurityBufferType SECBUFFER_READONLY;
    public static SecurityBufferType SECBUFFER_READONLY_WITH_CHECKSUM;
}
internal class System.Net.Security.SecurityContextTokenHandle : CriticalHandleZeroOrMinusOneIsInvalid {
    private int _disposed;
    internal IntPtr DangerousGetHandle();
    protected virtual bool ReleaseHandle();
}
public class System.Net.Security.ServerCertificateSelectionCallback : MulticastDelegate {
    public ServerCertificateSelectionCallback(object object, IntPtr method);
    public virtual X509Certificate Invoke(object sender, string hostName);
    public virtual IAsyncResult BeginInvoke(object sender, string hostName, AsyncCallback callback, object object);
    public virtual X509Certificate EndInvoke(IAsyncResult result);
}
internal class System.Net.Security.ServerCertSelectionCallback : MulticastDelegate {
    public ServerCertSelectionCallback(object object, IntPtr method);
    public virtual X509Certificate Invoke(string hostName);
    public virtual IAsyncResult BeginInvoke(string hostName, AsyncCallback callback, object object);
    public virtual X509Certificate EndInvoke(IAsyncResult result);
}
internal class System.Net.Security.SniHelper : object {
    private static IdnMapping s_idnMapping;
    private static Encoding s_encoding;
    private static SniHelper();
    public static string GetServerName(Byte[] clientHello);
    private static string GetSniFromSslPlainText(ReadOnlySpan`1<byte> sslPlainText);
    private static string GetSniFromSslHandshake(ReadOnlySpan`1<byte> sslHandshake);
    private static string GetSniFromClientHello(ReadOnlySpan`1<byte> clientHello);
    private static string GetSniFromExtension(ReadOnlySpan`1<byte> extension, ReadOnlySpan`1& remainingBytes, Boolean& invalid);
    private static string GetSniFromServerNameList(ReadOnlySpan`1<byte> serverNameListExtension, ReadOnlySpan`1& remainingBytes, Boolean& invalid);
    private static string GetSniFromServerName(ReadOnlySpan`1<byte> serverName, Boolean& invalid);
    private static string GetSniFromHostNameStruct(ReadOnlySpan`1<byte> hostNameStruct, Boolean& invalid);
    private static string DecodeString(ReadOnlySpan`1<byte> bytes);
    private static int ReadUInt24BigEndian(ReadOnlySpan`1<byte> bytes);
    private static ReadOnlySpan`1<byte> SkipBytes(ReadOnlySpan`1<byte> bytes, int numberOfBytesToSkip);
    private static ReadOnlySpan`1<byte> SkipOpaqueType1(ReadOnlySpan`1<byte> bytes);
    private static ReadOnlySpan`1<byte> SkipOpaqueType2(ReadOnlySpan`1<byte> bytes, Boolean& invalid);
    private static IdnMapping CreateIdnMapping();
    private static Encoding CreateEncoding();
}
[IsReadOnlyAttribute]
public class System.Net.Security.SslApplicationProtocol : ValueType {
    private static Encoding s_utf8;
    private static Byte[] s_http2Utf8;
    private static Byte[] s_http11Utf8;
    public static SslApplicationProtocol Http2;
    public static SslApplicationProtocol Http11;
    private Byte[] _readOnlyProtocol;
    public ReadOnlyMemory`1<byte> Protocol { get; }
    internal SslApplicationProtocol(Byte[] protocol, bool copy);
    public SslApplicationProtocol(Byte[] protocol);
    public SslApplicationProtocol(string protocol);
    private static SslApplicationProtocol();
    public ReadOnlyMemory`1<byte> get_Protocol();
    public sealed virtual bool Equals(SslApplicationProtocol other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(SslApplicationProtocol left, SslApplicationProtocol right);
    public static bool op_Inequality(SslApplicationProtocol left, SslApplicationProtocol right);
    [CompilerGeneratedAttribute]
internal static char <ToString>g__GetHexValue|14_0(int i);
}
internal class System.Net.Security.SslAuthenticationOptions : object {
    [CompilerGeneratedAttribute]
private bool <AllowRenegotiation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetHost>k__BackingField;
    [CompilerGeneratedAttribute]
private X509CertificateCollection <ClientCertificates>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<SslApplicationProtocol> <ApplicationProtocols>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsServer>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate <ServerCertificate>k__BackingField;
    [CompilerGeneratedAttribute]
private SslProtocols <EnabledSslProtocols>k__BackingField;
    [CompilerGeneratedAttribute]
private X509RevocationMode <CertificateRevocationCheckMode>k__BackingField;
    [CompilerGeneratedAttribute]
private EncryptionPolicy <EncryptionPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RemoteCertRequired>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CheckCertName>k__BackingField;
    [CompilerGeneratedAttribute]
private RemoteCertValidationCallback <CertValidationDelegate>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalCertSelectionCallback <CertSelectionDelegate>k__BackingField;
    [CompilerGeneratedAttribute]
private ServerCertSelectionCallback <ServerCertSelectionDelegate>k__BackingField;
    [CompilerGeneratedAttribute]
private CipherSuitesPolicy <CipherSuitesPolicy>k__BackingField;
    internal bool AllowRenegotiation { get; internal set; }
    internal string TargetHost { get; internal set; }
    internal X509CertificateCollection ClientCertificates { get; internal set; }
    internal List`1<SslApplicationProtocol> ApplicationProtocols { get; }
    internal bool IsServer { get; internal set; }
    internal X509Certificate ServerCertificate { get; internal set; }
    internal SslProtocols EnabledSslProtocols { get; internal set; }
    internal X509RevocationMode CertificateRevocationCheckMode { get; internal set; }
    internal EncryptionPolicy EncryptionPolicy { get; internal set; }
    internal bool RemoteCertRequired { get; internal set; }
    internal bool CheckCertName { get; internal set; }
    internal RemoteCertValidationCallback CertValidationDelegate { get; internal set; }
    internal LocalCertSelectionCallback CertSelectionDelegate { get; internal set; }
    internal ServerCertSelectionCallback ServerCertSelectionDelegate { get; internal set; }
    unknown CipherSuitesPolicy CipherSuitesPolicy {internal set; }
    internal SslAuthenticationOptions(SslClientAuthenticationOptions sslClientAuthenticationOptions, RemoteCertValidationCallback remoteCallback, LocalCertSelectionCallback localCallback);
    internal SslAuthenticationOptions(SslServerAuthenticationOptions sslServerAuthenticationOptions);
    private static SslProtocols FilterOutIncompatibleSslProtocols(SslProtocols protocols);
    [CompilerGeneratedAttribute]
internal bool get_AllowRenegotiation();
    [CompilerGeneratedAttribute]
internal void set_AllowRenegotiation(bool value);
    [CompilerGeneratedAttribute]
internal string get_TargetHost();
    [CompilerGeneratedAttribute]
internal void set_TargetHost(string value);
    [CompilerGeneratedAttribute]
internal X509CertificateCollection get_ClientCertificates();
    [CompilerGeneratedAttribute]
internal void set_ClientCertificates(X509CertificateCollection value);
    [CompilerGeneratedAttribute]
internal List`1<SslApplicationProtocol> get_ApplicationProtocols();
    [CompilerGeneratedAttribute]
internal bool get_IsServer();
    [CompilerGeneratedAttribute]
internal void set_IsServer(bool value);
    [CompilerGeneratedAttribute]
internal X509Certificate get_ServerCertificate();
    [CompilerGeneratedAttribute]
internal void set_ServerCertificate(X509Certificate value);
    [CompilerGeneratedAttribute]
internal SslProtocols get_EnabledSslProtocols();
    [CompilerGeneratedAttribute]
internal void set_EnabledSslProtocols(SslProtocols value);
    [CompilerGeneratedAttribute]
internal X509RevocationMode get_CertificateRevocationCheckMode();
    [CompilerGeneratedAttribute]
internal void set_CertificateRevocationCheckMode(X509RevocationMode value);
    [CompilerGeneratedAttribute]
internal EncryptionPolicy get_EncryptionPolicy();
    [CompilerGeneratedAttribute]
internal void set_EncryptionPolicy(EncryptionPolicy value);
    [CompilerGeneratedAttribute]
internal bool get_RemoteCertRequired();
    [CompilerGeneratedAttribute]
internal void set_RemoteCertRequired(bool value);
    [CompilerGeneratedAttribute]
internal bool get_CheckCertName();
    [CompilerGeneratedAttribute]
internal void set_CheckCertName(bool value);
    [CompilerGeneratedAttribute]
internal RemoteCertValidationCallback get_CertValidationDelegate();
    [CompilerGeneratedAttribute]
internal void set_CertValidationDelegate(RemoteCertValidationCallback value);
    [CompilerGeneratedAttribute]
internal LocalCertSelectionCallback get_CertSelectionDelegate();
    [CompilerGeneratedAttribute]
internal void set_CertSelectionDelegate(LocalCertSelectionCallback value);
    [CompilerGeneratedAttribute]
internal ServerCertSelectionCallback get_ServerCertSelectionDelegate();
    [CompilerGeneratedAttribute]
internal void set_ServerCertSelectionDelegate(ServerCertSelectionCallback value);
    [CompilerGeneratedAttribute]
internal void set_CipherSuitesPolicy(CipherSuitesPolicy value);
}
public class System.Net.Security.SslClientAuthenticationOptions : object {
    private EncryptionPolicy _encryptionPolicy;
    private X509RevocationMode _checkCertificateRevocation;
    private SslProtocols _enabledSslProtocols;
    private bool _allowRenegotiation;
    [CompilerGeneratedAttribute]
private LocalCertificateSelectionCallback <LocalCertificateSelectionCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private RemoteCertificateValidationCallback <RemoteCertificateValidationCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<SslApplicationProtocol> <ApplicationProtocols>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetHost>k__BackingField;
    [CompilerGeneratedAttribute]
private X509CertificateCollection <ClientCertificates>k__BackingField;
    [CompilerGeneratedAttribute]
private CipherSuitesPolicy <CipherSuitesPolicy>k__BackingField;
    public bool AllowRenegotiation { get; public set; }
    public LocalCertificateSelectionCallback LocalCertificateSelectionCallback { get; public set; }
    public RemoteCertificateValidationCallback RemoteCertificateValidationCallback { get; public set; }
    public List`1<SslApplicationProtocol> ApplicationProtocols { get; public set; }
    public string TargetHost { get; public set; }
    public X509CertificateCollection ClientCertificates { get; public set; }
    public X509RevocationMode CertificateRevocationCheckMode { get; public set; }
    public EncryptionPolicy EncryptionPolicy { get; public set; }
    public SslProtocols EnabledSslProtocols { get; public set; }
    public CipherSuitesPolicy CipherSuitesPolicy { get; public set; }
    public bool get_AllowRenegotiation();
    public void set_AllowRenegotiation(bool value);
    [CompilerGeneratedAttribute]
public LocalCertificateSelectionCallback get_LocalCertificateSelectionCallback();
    [CompilerGeneratedAttribute]
public void set_LocalCertificateSelectionCallback(LocalCertificateSelectionCallback value);
    [CompilerGeneratedAttribute]
public RemoteCertificateValidationCallback get_RemoteCertificateValidationCallback();
    [CompilerGeneratedAttribute]
public void set_RemoteCertificateValidationCallback(RemoteCertificateValidationCallback value);
    [CompilerGeneratedAttribute]
public List`1<SslApplicationProtocol> get_ApplicationProtocols();
    [CompilerGeneratedAttribute]
public void set_ApplicationProtocols(List`1<SslApplicationProtocol> value);
    [CompilerGeneratedAttribute]
public string get_TargetHost();
    [CompilerGeneratedAttribute]
public void set_TargetHost(string value);
    [CompilerGeneratedAttribute]
public X509CertificateCollection get_ClientCertificates();
    [CompilerGeneratedAttribute]
public void set_ClientCertificates(X509CertificateCollection value);
    public X509RevocationMode get_CertificateRevocationCheckMode();
    public void set_CertificateRevocationCheckMode(X509RevocationMode value);
    public EncryptionPolicy get_EncryptionPolicy();
    public void set_EncryptionPolicy(EncryptionPolicy value);
    public SslProtocols get_EnabledSslProtocols();
    public void set_EnabledSslProtocols(SslProtocols value);
    [CompilerGeneratedAttribute]
public CipherSuitesPolicy get_CipherSuitesPolicy();
    [CompilerGeneratedAttribute]
public void set_CipherSuitesPolicy(CipherSuitesPolicy value);
}
internal class System.Net.Security.SslConnectionInfo : object {
    [CompilerGeneratedAttribute]
private int <Protocol>k__BackingField;
    [CompilerGeneratedAttribute]
private TlsCipherSuite <TlsCipherSuite>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DataCipherAlg>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DataKeySize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DataHashAlg>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DataHashKeySize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <KeyExchangeAlg>k__BackingField;
    [CompilerGeneratedAttribute]
private int <KeyExchKeySize>k__BackingField;
    public int Protocol { get; }
    public TlsCipherSuite TlsCipherSuite { get; private set; }
    public int DataCipherAlg { get; private set; }
    public int DataKeySize { get; private set; }
    public int DataHashAlg { get; private set; }
    public int DataHashKeySize { get; private set; }
    public int KeyExchangeAlg { get; private set; }
    public int KeyExchKeySize { get; private set; }
    public SslConnectionInfo(SecPkgContext_ConnectionInfo interopConnectionInfo, TlsCipherSuite cipherSuite);
    [CompilerGeneratedAttribute]
public int get_Protocol();
    [CompilerGeneratedAttribute]
public TlsCipherSuite get_TlsCipherSuite();
    [CompilerGeneratedAttribute]
private void set_TlsCipherSuite(TlsCipherSuite value);
    [CompilerGeneratedAttribute]
public int get_DataCipherAlg();
    [CompilerGeneratedAttribute]
private void set_DataCipherAlg(int value);
    [CompilerGeneratedAttribute]
public int get_DataKeySize();
    [CompilerGeneratedAttribute]
private void set_DataKeySize(int value);
    [CompilerGeneratedAttribute]
public int get_DataHashAlg();
    [CompilerGeneratedAttribute]
private void set_DataHashAlg(int value);
    [CompilerGeneratedAttribute]
public int get_DataHashKeySize();
    [CompilerGeneratedAttribute]
private void set_DataHashKeySize(int value);
    [CompilerGeneratedAttribute]
public int get_KeyExchangeAlg();
    [CompilerGeneratedAttribute]
private void set_KeyExchangeAlg(int value);
    [CompilerGeneratedAttribute]
public int get_KeyExchKeySize();
    [CompilerGeneratedAttribute]
private void set_KeyExchKeySize(int value);
}
public class System.Net.Security.SslServerAuthenticationOptions : object {
    private X509RevocationMode _checkCertificateRevocation;
    private SslProtocols _enabledSslProtocols;
    private EncryptionPolicy _encryptionPolicy;
    private bool _allowRenegotiation;
    [CompilerGeneratedAttribute]
private bool <ClientCertificateRequired>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<SslApplicationProtocol> <ApplicationProtocols>k__BackingField;
    [CompilerGeneratedAttribute]
private RemoteCertificateValidationCallback <RemoteCertificateValidationCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private ServerCertificateSelectionCallback <ServerCertificateSelectionCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate <ServerCertificate>k__BackingField;
    [CompilerGeneratedAttribute]
private CipherSuitesPolicy <CipherSuitesPolicy>k__BackingField;
    public bool AllowRenegotiation { get; public set; }
    public bool ClientCertificateRequired { get; public set; }
    public List`1<SslApplicationProtocol> ApplicationProtocols { get; public set; }
    public RemoteCertificateValidationCallback RemoteCertificateValidationCallback { get; public set; }
    public ServerCertificateSelectionCallback ServerCertificateSelectionCallback { get; public set; }
    public X509Certificate ServerCertificate { get; public set; }
    public SslProtocols EnabledSslProtocols { get; public set; }
    public X509RevocationMode CertificateRevocationCheckMode { get; public set; }
    public EncryptionPolicy EncryptionPolicy { get; public set; }
    public CipherSuitesPolicy CipherSuitesPolicy { get; public set; }
    public bool get_AllowRenegotiation();
    public void set_AllowRenegotiation(bool value);
    [CompilerGeneratedAttribute]
public bool get_ClientCertificateRequired();
    [CompilerGeneratedAttribute]
public void set_ClientCertificateRequired(bool value);
    [CompilerGeneratedAttribute]
public List`1<SslApplicationProtocol> get_ApplicationProtocols();
    [CompilerGeneratedAttribute]
public void set_ApplicationProtocols(List`1<SslApplicationProtocol> value);
    [CompilerGeneratedAttribute]
public RemoteCertificateValidationCallback get_RemoteCertificateValidationCallback();
    [CompilerGeneratedAttribute]
public void set_RemoteCertificateValidationCallback(RemoteCertificateValidationCallback value);
    [CompilerGeneratedAttribute]
public ServerCertificateSelectionCallback get_ServerCertificateSelectionCallback();
    [CompilerGeneratedAttribute]
public void set_ServerCertificateSelectionCallback(ServerCertificateSelectionCallback value);
    [CompilerGeneratedAttribute]
public X509Certificate get_ServerCertificate();
    [CompilerGeneratedAttribute]
public void set_ServerCertificate(X509Certificate value);
    public SslProtocols get_EnabledSslProtocols();
    public void set_EnabledSslProtocols(SslProtocols value);
    public X509RevocationMode get_CertificateRevocationCheckMode();
    public void set_CertificateRevocationCheckMode(X509RevocationMode value);
    public EncryptionPolicy get_EncryptionPolicy();
    public void set_EncryptionPolicy(EncryptionPolicy value);
    [CompilerGeneratedAttribute]
public CipherSuitesPolicy get_CipherSuitesPolicy();
    [CompilerGeneratedAttribute]
public void set_CipherSuitesPolicy(CipherSuitesPolicy value);
}
internal static class System.Net.Security.SslSessionsCache : object {
    private static ConcurrentDictionary`2<SslCredKey, SafeCredentialReference> s_cachedCreds;
    private static SslSessionsCache();
    internal static SafeFreeCredentials TryCachedCredential(Byte[] thumbPrint, SslProtocols sslProtocols, bool isServer, EncryptionPolicy encryptionPolicy);
    internal static void CacheCredential(SafeFreeCredentials creds, Byte[] thumbPrint, SslProtocols sslProtocols, bool isServer, EncryptionPolicy encryptionPolicy);
}
public class System.Net.Security.SslStream : AuthenticatedStream {
    private X509Certificate2 _remoteCertificate;
    private bool _remoteCertificateExposed;
    internal RemoteCertificateValidationCallback _userCertificateValidationCallback;
    internal LocalCertificateSelectionCallback _userCertificateSelectionCallback;
    internal ServerCertificateSelectionCallback _userServerCertificateSelectionCallback;
    internal RemoteCertValidationCallback _certValidationDelegate;
    internal LocalCertSelectionCallback _certSelectionDelegate;
    internal EncryptionPolicy _encryptionPolicy;
    private Stream _innerStream;
    private SecureChannel _context;
    private ExceptionDispatchInfo _exception;
    private bool _shutdown;
    private bool _handshakeCompleted;
    internal Byte[] _internalBuffer;
    internal int _internalOffset;
    internal int _internalBufferCount;
    internal int _decryptedBytesOffset;
    internal int _decryptedBytesCount;
    private int _nestedWrite;
    private int _nestedRead;
    private static int s_uniqueNameInteger;
    private static AsyncProtocolCallback s_partialFrameCallback;
    private static AsyncProtocolCallback s_readFrameCallback;
    private static AsyncCallback s_writeCallback;
    private SslAuthenticationOptions _sslAuthenticationOptions;
    private int _nestedAuth;
    private SecurityStatusPal _securityStatus;
    private CachedSessionStatus _CachedSession;
    private Byte[] _queuedReadData;
    private int _queuedReadCount;
    private bool _pendingReHandshake;
    private int _lockWriteState;
    private object _queuedWriteStateRequest;
    private int _lockReadState;
    private object _queuedReadStateRequest;
    private static ExceptionDispatchInfo s_disposedSentinel;
    private Framing _Framing;
    public SslApplicationProtocol NegotiatedApplicationProtocol { get; }
    public TransportContext TransportContext { get; }
    public bool IsAuthenticated { get; }
    public bool IsMutuallyAuthenticated { get; }
    public bool IsEncrypted { get; }
    public bool IsSigned { get; }
    public bool IsServer { get; }
    public SslProtocols SslProtocol { get; }
    public bool CheckCertRevocationStatus { get; }
    public X509Certificate LocalCertificate { get; }
    public X509Certificate RemoteCertificate { get; }
    [CLSCompliantAttribute("False")]
public TlsCipherSuite NegotiatedCipherSuite { get; }
    public CipherAlgorithmType CipherAlgorithm { get; }
    public int CipherStrength { get; }
    public HashAlgorithmType HashAlgorithm { get; }
    public int HashStrength { get; }
    public ExchangeAlgorithmType KeyExchangeAlgorithm { get; }
    public int KeyExchangeStrength { get; }
    public bool CanSeek { get; }
    public bool CanRead { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public long Length { get; }
    public long Position { get; public set; }
    private bool RemoteCertRequired { get; }
    private object SyncLock { get; }
    private int MaxDataSize { get; }
    public SslStream(Stream innerStream);
    public SslStream(Stream innerStream, bool leaveInnerStreamOpen);
    public SslStream(Stream innerStream, bool leaveInnerStreamOpen, RemoteCertificateValidationCallback userCertificateValidationCallback);
    public SslStream(Stream innerStream, bool leaveInnerStreamOpen, RemoteCertificateValidationCallback userCertificateValidationCallback, LocalCertificateSelectionCallback userCertificateSelectionCallback);
    public SslStream(Stream innerStream, bool leaveInnerStreamOpen, RemoteCertificateValidationCallback userCertificateValidationCallback, LocalCertificateSelectionCallback userCertificateSelectionCallback, EncryptionPolicy encryptionPolicy);
    private static SslStream();
    public SslApplicationProtocol get_NegotiatedApplicationProtocol();
    private void SetAndVerifyValidationCallback(RemoteCertificateValidationCallback callback);
    private void SetAndVerifySelectionCallback(LocalCertificateSelectionCallback callback);
    private bool UserCertValidationCallbackWrapper(string hostName, X509Certificate2 certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors);
    private X509Certificate UserCertSelectionCallbackWrapper(string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers);
    private X509Certificate ServerCertSelectionCallbackWrapper(string targetHost);
    private SslAuthenticationOptions CreateAuthenticationOptions(SslServerAuthenticationOptions sslServerAuthenticationOptions);
    public virtual IAsyncResult BeginAuthenticateAsClient(string targetHost, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsClient(string targetHost, X509CertificateCollection clientCertificates, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsClient(string targetHost, X509CertificateCollection clientCertificates, SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);
    internal IAsyncResult BeginAuthenticateAsClient(SslClientAuthenticationOptions sslClientAuthenticationOptions, CancellationToken cancellationToken, AsyncCallback asyncCallback, object asyncState);
    public virtual void EndAuthenticateAsClient(IAsyncResult asyncResult);
    public virtual IAsyncResult BeginAuthenticateAsServer(X509Certificate serverCertificate, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsServer(X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);
    public virtual IAsyncResult BeginAuthenticateAsServer(X509Certificate serverCertificate, bool clientCertificateRequired, SslProtocols enabledSslProtocols, bool checkCertificateRevocation, AsyncCallback asyncCallback, object asyncState);
    private IAsyncResult BeginAuthenticateAsServer(SslServerAuthenticationOptions sslServerAuthenticationOptions, CancellationToken cancellationToken, AsyncCallback asyncCallback, object asyncState);
    public virtual void EndAuthenticateAsServer(IAsyncResult asyncResult);
    internal IAsyncResult BeginShutdown(AsyncCallback asyncCallback, object asyncState);
    internal void EndShutdown(IAsyncResult asyncResult);
    public TransportContext get_TransportContext();
    internal ChannelBinding GetChannelBinding(ChannelBindingKind kind);
    public virtual void AuthenticateAsClient(string targetHost);
    public virtual void AuthenticateAsClient(string targetHost, X509CertificateCollection clientCertificates, bool checkCertificateRevocation);
    public virtual void AuthenticateAsClient(string targetHost, X509CertificateCollection clientCertificates, SslProtocols enabledSslProtocols, bool checkCertificateRevocation);
    private void AuthenticateAsClient(SslClientAuthenticationOptions sslClientAuthenticationOptions);
    public virtual void AuthenticateAsServer(X509Certificate serverCertificate);
    public virtual void AuthenticateAsServer(X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation);
    public virtual void AuthenticateAsServer(X509Certificate serverCertificate, bool clientCertificateRequired, SslProtocols enabledSslProtocols, bool checkCertificateRevocation);
    private void AuthenticateAsServer(SslServerAuthenticationOptions sslServerAuthenticationOptions);
    public virtual Task AuthenticateAsClientAsync(string targetHost);
    public virtual Task AuthenticateAsClientAsync(string targetHost, X509CertificateCollection clientCertificates, bool checkCertificateRevocation);
    public virtual Task AuthenticateAsClientAsync(string targetHost, X509CertificateCollection clientCertificates, SslProtocols enabledSslProtocols, bool checkCertificateRevocation);
    public Task AuthenticateAsClientAsync(SslClientAuthenticationOptions sslClientAuthenticationOptions, CancellationToken cancellationToken);
    public virtual Task AuthenticateAsServerAsync(X509Certificate serverCertificate);
    public virtual Task AuthenticateAsServerAsync(X509Certificate serverCertificate, bool clientCertificateRequired, bool checkCertificateRevocation);
    public virtual Task AuthenticateAsServerAsync(X509Certificate serverCertificate, bool clientCertificateRequired, SslProtocols enabledSslProtocols, bool checkCertificateRevocation);
    public Task AuthenticateAsServerAsync(SslServerAuthenticationOptions sslServerAuthenticationOptions, CancellationToken cancellationToken);
    public virtual Task ShutdownAsync();
    public virtual bool get_IsAuthenticated();
    public virtual bool get_IsMutuallyAuthenticated();
    public virtual bool get_IsEncrypted();
    public virtual bool get_IsSigned();
    public virtual bool get_IsServer();
    public virtual SslProtocols get_SslProtocol();
    public virtual bool get_CheckCertRevocationStatus();
    public virtual X509Certificate get_LocalCertificate();
    public virtual X509Certificate get_RemoteCertificate();
    public virtual TlsCipherSuite get_NegotiatedCipherSuite();
    public virtual CipherAlgorithmType get_CipherAlgorithm();
    public virtual int get_CipherStrength();
    public virtual HashAlgorithmType get_HashAlgorithm();
    public virtual int get_HashStrength();
    public virtual ExchangeAlgorithmType get_KeyExchangeAlgorithm();
    public virtual int get_KeyExchangeStrength();
    public virtual bool get_CanSeek();
    public virtual bool get_CanRead();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void SetLength(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    [AsyncStateMachineAttribute("System.Net.Security.SslStream/<DisposeAsync>d__127")]
public virtual ValueTask DisposeAsync();
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public void Write(Byte[] buffer);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    private void ThrowIfExceptional();
    private void ValidateCreateContext(SslClientAuthenticationOptions sslClientAuthenticationOptions, RemoteCertValidationCallback remoteCallback, LocalCertSelectionCallback localCallback);
    private void ValidateCreateContext(SslAuthenticationOptions sslAuthenticationOptions);
    private bool get_RemoteCertRequired();
    private object get_SyncLock();
    private int get_MaxDataSize();
    private void SetException(Exception e);
    private void CheckThrow(bool authSuccessCheck, bool shutdownCheck);
    private void CloseInternal();
    private SecurityStatusPal EncryptData(ReadOnlyMemory`1<byte> buffer, Byte[]& outBuffer, Int32& outSize);
    private SecurityStatusPal DecryptData();
    private SecurityStatusPal PrivateDecryptData(Byte[] buffer, Int32& offset, Int32& count);
    private Exception EnqueueOldKeyDecryptedData(Byte[] buffer, int offset, int count);
    private int CheckOldKeyDecryptedData(Memory`1<byte> buffer);
    private void ProcessAuthentication(LazyAsyncResult lazyResult, CancellationToken cancellationToken);
    private void ReplyOnReAuthentication(Byte[] buffer, CancellationToken cancellationToken);
    private void ForceAuthentication(bool receiveFirst, Byte[] buffer, AsyncProtocolRequest asyncRequest);
    private void EndProcessAuthentication(IAsyncResult result);
    private void InternalEndProcessAuthentication(LazyAsyncResult lazyResult);
    private void StartSendBlob(Byte[] incoming, int count, AsyncProtocolRequest asyncRequest);
    private void CheckCompletionBeforeNextReceive(ProtocolToken message, AsyncProtocolRequest asyncRequest);
    private void StartReceiveBlob(Byte[] buffer, AsyncProtocolRequest asyncRequest);
    private void StartReadFrame(Byte[] buffer, int readBytes, AsyncProtocolRequest asyncRequest);
    private void ProcessReceivedBlob(Byte[] buffer, int count, AsyncProtocolRequest asyncRequest);
    private void StartSendAuthResetSignal(ProtocolToken message, AsyncProtocolRequest asyncRequest, ExceptionDispatchInfo exception);
    private bool CompleteHandshake(ProtocolToken& alertToken);
    private static void WriteCallback(IAsyncResult transportResult);
    private static void PartialFrameCallback(AsyncProtocolRequest asyncRequest);
    private static void ReadFrameCallback(AsyncProtocolRequest asyncRequest);
    private bool CheckEnqueueHandshakeRead(Byte[]& buffer, AsyncProtocolRequest request);
    private void FinishHandshakeRead(int newState);
    private int CheckEnqueueRead(Memory`1<byte> buffer);
    private ValueTask`1<int> CheckEnqueueReadAsync(Memory`1<byte> buffer);
    private void FinishRead(Byte[] renegotiateBuffer);
    private Task CheckEnqueueWriteAsync();
    private void CheckEnqueueWrite();
    private void FinishWrite();
    private void HandleQueuedCallback(Object& queuedStateRequest);
    private bool CheckEnqueueHandshake(Byte[] buffer, AsyncProtocolRequest asyncRequest);
    private void FinishHandshake(Exception e, AsyncProtocolRequest asyncRequest);
    [AsyncStateMachineAttribute("System.Net.Security.SslStream/<WriteAsyncChunked>d__209`1")]
private Task WriteAsyncChunked(TWriteAdapter writeAdapter, ReadOnlyMemory`1<byte> buffer);
    private ValueTask WriteSingleChunk(TWriteAdapter writeAdapter, ReadOnlyMemory`1<byte> buffer);
    private void ValidateParameters(Byte[] buffer, int offset, int count);
    protected virtual override void Finalize();
    private void ReturnReadBufferIfEmpty();
    [AsyncStateMachineAttribute("System.Net.Security.SslStream/<ReadAsyncInternal>d__214`1")]
private ValueTask`1<int> ReadAsyncInternal(TReadAdapter adapter, Memory`1<byte> buffer);
    private ValueTask`1<int> FillBufferAsync(TReadAdapter adapter, int minSize);
    [AsyncStateMachineAttribute("System.Net.Security.SslStream/<WriteAsyncInternal>d__216`1")]
private Task WriteAsyncInternal(TWriteAdapter writeAdapter, ReadOnlyMemory`1<byte> buffer);
    private void ConsumeBufferedBytes(int byteCount);
    private int CopyDecryptedData(Memory`1<byte> buffer);
    private void ResetReadBuffer();
    private static Byte[] EnsureBufferSize(Byte[] buffer, int copyCount, int size);
    private Framing DetectFraming(Byte[] bytes, int length);
    private int GetRemainingFrameSize(Byte[] buffer, int offset, int dataSize);
    private void AsyncResumeHandshake(object state);
    private void AsyncResumeHandshakeRead(AsyncProtocolRequest asyncRequest);
    private void RehandshakeCompleteCallback(IAsyncResult result);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private ValueTask <>n__0();
    [CompilerGeneratedAttribute]
[AsyncStateMachineAttribute("System.Net.Security.SslStream/<<WriteSingleChunk>g__WaitForWriteIOSlot|210_0>d`1")]
private Task <WriteSingleChunk>g__WaitForWriteIOSlot|210_0(TWriteAdapter wAdapter, Task lockTask, ReadOnlyMemory`1<byte> buff);
    [CompilerGeneratedAttribute]
[AsyncStateMachineAttribute("System.Net.Security.SslStream/<<WriteSingleChunk>g__CompleteAsync|210_1>d`1")]
private Task <WriteSingleChunk>g__CompleteAsync|210_1(ValueTask writeTask, Byte[] bufferToReturn);
    [AsyncStateMachineAttribute("System.Net.Security.SslStream/<<FillBufferAsync>g__InternalFillBufferAsync|215_0>d`1")]
[CompilerGeneratedAttribute]
private ValueTask`1<int> <FillBufferAsync>g__InternalFillBufferAsync|215_0(TReadAdapter adap, ValueTask`1<int> task, int min, int initial);
}
internal static class System.Net.Security.SslStreamPal : object {
    private static Byte[] s_schannelShutdownBytes;
    private static SslStreamPal();
    public static Exception GetException(SecurityStatusPal status);
    public static void VerifyPackageInfo();
    public static Byte[] ConvertAlpnProtocolListToByteArray(List`1<SslApplicationProtocol> protocols);
    public static SecurityStatusPal AcceptSecurityContext(SafeFreeCredentials& credentialsHandle, SafeDeleteContext& context, ArraySegment`1<byte> input, Byte[]& outputBuffer, SslAuthenticationOptions sslAuthenticationOptions);
    public static SecurityStatusPal InitializeSecurityContext(SafeFreeCredentials& credentialsHandle, SafeDeleteContext& context, string targetName, ArraySegment`1<byte> input, Byte[]& outputBuffer, SslAuthenticationOptions sslAuthenticationOptions);
    private static void GetIncomingSecurityBuffers(SslAuthenticationOptions options, Nullable`1& incomingSecurity, Span`1& incomingSecurityBuffers);
    public static SafeFreeCredentials AcquireCredentialsHandle(X509Certificate certificate, SslProtocols protocols, EncryptionPolicy policy, bool isServer);
    internal static Byte[] GetNegotiatedApplicationProtocol(SafeDeleteContext context);
    public static SecurityStatusPal EncryptMessage(SafeDeleteContext securityContext, ReadOnlyMemory`1<byte> input, int headerSize, int trailerSize, Byte[]& output, Int32& resultSize);
    public static SecurityStatusPal DecryptMessage(SafeDeleteContext securityContext, Byte[] buffer, Int32& offset, Int32& count);
    public static SecurityStatusPal ApplyAlertToken(SafeFreeCredentials& credentialsHandle, SafeDeleteContext securityContext, TlsAlertType alertType, TlsAlertMessage alertMessage);
    public static SecurityStatusPal ApplyShutdownToken(SafeFreeCredentials& credentialsHandle, SafeDeleteContext securityContext);
    public static SafeFreeContextBufferChannelBinding QueryContextChannelBinding(SafeDeleteContext securityContext, ChannelBindingKind attribute);
    public static void QueryContextStreamSizes(SafeDeleteContext securityContext, StreamSizes& streamSizes);
    public static void QueryContextConnectionInfo(SafeDeleteContext securityContext, SslConnectionInfo& connectionInfo);
    private static int GetProtocolFlagsFromSslProtocols(SslProtocols protocols, bool isServer);
    private static SCHANNEL_CRED CreateSecureCredential(int version, X509Certificate certificate, Flags flags, int protocols, EncryptionPolicy policy);
    private static SafeFreeCredentials AcquireCredentialsHandle(CredentialUse credUsage, SCHANNEL_CRED secureCredential);
}
internal static class System.Net.Security.SSPIHandleCache : object {
    private static SafeCredentialReference[] s_cacheSlots;
    private static int s_current;
    private static SSPIHandleCache();
    internal static void CacheCredential(SafeFreeCredentials newHandle);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class System.Net.Security.ThreeSecurityBuffers : ValueType {
    internal SecurityBuffer _item0;
    private SecurityBuffer _item1;
    private SecurityBuffer _item2;
}
internal enum System.Net.Security.TlsAlertMessage : Enum {
    public int value__;
    public static TlsAlertMessage CloseNotify;
    public static TlsAlertMessage UnexpectedMessage;
    public static TlsAlertMessage BadRecordMac;
    public static TlsAlertMessage DecryptionFailed;
    public static TlsAlertMessage RecordOverflow;
    public static TlsAlertMessage DecompressionFail;
    public static TlsAlertMessage HandshakeFailure;
    public static TlsAlertMessage BadCertificate;
    public static TlsAlertMessage UnsupportedCert;
    public static TlsAlertMessage CertificateRevoked;
    public static TlsAlertMessage CertificateExpired;
    public static TlsAlertMessage CertificateUnknown;
    public static TlsAlertMessage IllegalParameter;
    public static TlsAlertMessage UnknownCA;
    public static TlsAlertMessage AccessDenied;
    public static TlsAlertMessage DecodeError;
    public static TlsAlertMessage DecryptError;
    public static TlsAlertMessage ExportRestriction;
    public static TlsAlertMessage ProtocolVersion;
    public static TlsAlertMessage InsuffientSecurity;
    public static TlsAlertMessage InternalError;
    public static TlsAlertMessage UserCanceled;
    public static TlsAlertMessage NoRenegotiation;
    public static TlsAlertMessage UnsupportedExt;
}
internal enum System.Net.Security.TlsAlertType : Enum {
    public int value__;
    public static TlsAlertType Warning;
    public static TlsAlertType Fatal;
}
[CLSCompliantAttribute("False")]
public enum System.Net.Security.TlsCipherSuite : Enum {
    public ushort value__;
    public static TlsCipherSuite TLS_NULL_WITH_NULL_NULL;
    public static TlsCipherSuite TLS_RSA_WITH_NULL_MD5;
    public static TlsCipherSuite TLS_RSA_WITH_NULL_SHA;
    public static TlsCipherSuite TLS_RSA_EXPORT_WITH_RC4_40_MD5;
    public static TlsCipherSuite TLS_RSA_WITH_RC4_128_MD5;
    public static TlsCipherSuite TLS_RSA_WITH_RC4_128_SHA;
    public static TlsCipherSuite TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5;
    public static TlsCipherSuite TLS_RSA_WITH_IDEA_CBC_SHA;
    public static TlsCipherSuite TLS_RSA_EXPORT_WITH_DES40_CBC_SHA;
    public static TlsCipherSuite TLS_RSA_WITH_DES_CBC_SHA;
    public static TlsCipherSuite TLS_RSA_WITH_3DES_EDE_CBC_SHA;
    public static TlsCipherSuite TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA;
    public static TlsCipherSuite TLS_DH_DSS_WITH_DES_CBC_SHA;
    public static TlsCipherSuite TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA;
    public static TlsCipherSuite TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA;
    public static TlsCipherSuite TLS_DH_RSA_WITH_DES_CBC_SHA;
    public static TlsCipherSuite TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA;
    public static TlsCipherSuite TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA;
    public static TlsCipherSuite TLS_DHE_DSS_WITH_DES_CBC_SHA;
    public static TlsCipherSuite TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA;
    public static TlsCipherSuite TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA;
    public static TlsCipherSuite TLS_DHE_RSA_WITH_DES_CBC_SHA;
    public static TlsCipherSuite TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA;
    public static TlsCipherSuite TLS_DH_anon_EXPORT_WITH_RC4_40_MD5;
    public static TlsCipherSuite TLS_DH_anon_WITH_RC4_128_MD5;
    public static TlsCipherSuite TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA;
    public static TlsCipherSuite TLS_DH_anon_WITH_DES_CBC_SHA;
    public static TlsCipherSuite TLS_DH_anon_WITH_3DES_EDE_CBC_SHA;
    public static TlsCipherSuite TLS_KRB5_WITH_DES_CBC_SHA;
    public static TlsCipherSuite TLS_KRB5_WITH_3DES_EDE_CBC_SHA;
    public static TlsCipherSuite TLS_KRB5_WITH_RC4_128_SHA;
    public static TlsCipherSuite TLS_KRB5_WITH_IDEA_CBC_SHA;
    public static TlsCipherSuite TLS_KRB5_WITH_DES_CBC_MD5;
    public static TlsCipherSuite TLS_KRB5_WITH_3DES_EDE_CBC_MD5;
    public static TlsCipherSuite TLS_KRB5_WITH_RC4_128_MD5;
    public static TlsCipherSuite TLS_KRB5_WITH_IDEA_CBC_MD5;
    public static TlsCipherSuite TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA;
    public static TlsCipherSuite TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA;
    public static TlsCipherSuite TLS_KRB5_EXPORT_WITH_RC4_40_SHA;
    public static TlsCipherSuite TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5;
    public static TlsCipherSuite TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5;
    public static TlsCipherSuite TLS_KRB5_EXPORT_WITH_RC4_40_MD5;
    public static TlsCipherSuite TLS_PSK_WITH_NULL_SHA;
    public static TlsCipherSuite TLS_DHE_PSK_WITH_NULL_SHA;
    public static TlsCipherSuite TLS_RSA_PSK_WITH_NULL_SHA;
    public static TlsCipherSuite TLS_RSA_WITH_AES_128_CBC_SHA;
    public static TlsCipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA;
    public static TlsCipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA;
    public static TlsCipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA;
    public static TlsCipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA;
    public static TlsCipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA;
    public static TlsCipherSuite TLS_RSA_WITH_AES_256_CBC_SHA;
    public static TlsCipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA;
    public static TlsCipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA;
    public static TlsCipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA;
    public static TlsCipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA;
    public static TlsCipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA;
    public static TlsCipherSuite TLS_RSA_WITH_NULL_SHA256;
    public static TlsCipherSuite TLS_RSA_WITH_AES_128_CBC_SHA256;
    public static TlsCipherSuite TLS_RSA_WITH_AES_256_CBC_SHA256;
    public static TlsCipherSuite TLS_DH_DSS_WITH_AES_128_CBC_SHA256;
    public static TlsCipherSuite TLS_DH_RSA_WITH_AES_128_CBC_SHA256;
    public static TlsCipherSuite TLS_DHE_DSS_WITH_AES_128_CBC_SHA256;
    public static TlsCipherSuite TLS_RSA_WITH_CAMELLIA_128_CBC_SHA;
    public static TlsCipherSuite TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA;
    public static TlsCipherSuite TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA;
    public static TlsCipherSuite TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA;
    public static TlsCipherSuite TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA;
    public static TlsCipherSuite TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA;
    public static TlsCipherSuite TLS_DHE_RSA_WITH_AES_128_CBC_SHA256;
    public static TlsCipherSuite TLS_DH_DSS_WITH_AES_256_CBC_SHA256;
    public static TlsCipherSuite TLS_DH_RSA_WITH_AES_256_CBC_SHA256;
    public static TlsCipherSuite TLS_DHE_DSS_WITH_AES_256_CBC_SHA256;
    public static TlsCipherSuite TLS_DHE_RSA_WITH_AES_256_CBC_SHA256;
    public static TlsCipherSuite TLS_DH_anon_WITH_AES_128_CBC_SHA256;
    public static TlsCipherSuite TLS_DH_anon_WITH_AES_256_CBC_SHA256;
    public static TlsCipherSuite TLS_RSA_WITH_CAMELLIA_256_CBC_SHA;
    public static TlsCipherSuite TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA;
    public static TlsCipherSuite TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA;
    public static TlsCipherSuite TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA;
    public static TlsCipherSuite TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA;
    public static TlsCipherSuite TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA;
    public static TlsCipherSuite TLS_PSK_WITH_RC4_128_SHA;
    public static TlsCipherSuite TLS_PSK_WITH_3DES_EDE_CBC_SHA;
    public static TlsCipherSuite TLS_PSK_WITH_AES_128_CBC_SHA;
    public static TlsCipherSuite TLS_PSK_WITH_AES_256_CBC_SHA;
    public static TlsCipherSuite TLS_DHE_PSK_WITH_RC4_128_SHA;
    public static TlsCipherSuite TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA;
    public static TlsCipherSuite TLS_DHE_PSK_WITH_AES_128_CBC_SHA;
    public static TlsCipherSuite TLS_DHE_PSK_WITH_AES_256_CBC_SHA;
    public static TlsCipherSuite TLS_RSA_PSK_WITH_RC4_128_SHA;
    public static TlsCipherSuite TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA;
    public static TlsCipherSuite TLS_RSA_PSK_WITH_AES_128_CBC_SHA;
    public static TlsCipherSuite TLS_RSA_PSK_WITH_AES_256_CBC_SHA;
    public static TlsCipherSuite TLS_RSA_WITH_SEED_CBC_SHA;
    public static TlsCipherSuite TLS_DH_DSS_WITH_SEED_CBC_SHA;
    public static TlsCipherSuite TLS_DH_RSA_WITH_SEED_CBC_SHA;
    public static TlsCipherSuite TLS_DHE_DSS_WITH_SEED_CBC_SHA;
    public static TlsCipherSuite TLS_DHE_RSA_WITH_SEED_CBC_SHA;
    public static TlsCipherSuite TLS_DH_anon_WITH_SEED_CBC_SHA;
    public static TlsCipherSuite TLS_RSA_WITH_AES_128_GCM_SHA256;
    public static TlsCipherSuite TLS_RSA_WITH_AES_256_GCM_SHA384;
    public static TlsCipherSuite TLS_DHE_RSA_WITH_AES_128_GCM_SHA256;
    public static TlsCipherSuite TLS_DHE_RSA_WITH_AES_256_GCM_SHA384;
    public static TlsCipherSuite TLS_DH_RSA_WITH_AES_128_GCM_SHA256;
    public static TlsCipherSuite TLS_DH_RSA_WITH_AES_256_GCM_SHA384;
    public static TlsCipherSuite TLS_DHE_DSS_WITH_AES_128_GCM_SHA256;
    public static TlsCipherSuite TLS_DHE_DSS_WITH_AES_256_GCM_SHA384;
    public static TlsCipherSuite TLS_DH_DSS_WITH_AES_128_GCM_SHA256;
    public static TlsCipherSuite TLS_DH_DSS_WITH_AES_256_GCM_SHA384;
    public static TlsCipherSuite TLS_DH_anon_WITH_AES_128_GCM_SHA256;
    public static TlsCipherSuite TLS_DH_anon_WITH_AES_256_GCM_SHA384;
    public static TlsCipherSuite TLS_PSK_WITH_AES_128_GCM_SHA256;
    public static TlsCipherSuite TLS_PSK_WITH_AES_256_GCM_SHA384;
    public static TlsCipherSuite TLS_DHE_PSK_WITH_AES_128_GCM_SHA256;
    public static TlsCipherSuite TLS_DHE_PSK_WITH_AES_256_GCM_SHA384;
    public static TlsCipherSuite TLS_RSA_PSK_WITH_AES_128_GCM_SHA256;
    public static TlsCipherSuite TLS_RSA_PSK_WITH_AES_256_GCM_SHA384;
    public static TlsCipherSuite TLS_PSK_WITH_AES_128_CBC_SHA256;
    public static TlsCipherSuite TLS_PSK_WITH_AES_256_CBC_SHA384;
    public static TlsCipherSuite TLS_PSK_WITH_NULL_SHA256;
    public static TlsCipherSuite TLS_PSK_WITH_NULL_SHA384;
    public static TlsCipherSuite TLS_DHE_PSK_WITH_AES_128_CBC_SHA256;
    public static TlsCipherSuite TLS_DHE_PSK_WITH_AES_256_CBC_SHA384;
    public static TlsCipherSuite TLS_DHE_PSK_WITH_NULL_SHA256;
    public static TlsCipherSuite TLS_DHE_PSK_WITH_NULL_SHA384;
    public static TlsCipherSuite TLS_RSA_PSK_WITH_AES_128_CBC_SHA256;
    public static TlsCipherSuite TLS_RSA_PSK_WITH_AES_256_CBC_SHA384;
    public static TlsCipherSuite TLS_RSA_PSK_WITH_NULL_SHA256;
    public static TlsCipherSuite TLS_RSA_PSK_WITH_NULL_SHA384;
    public static TlsCipherSuite TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256;
    public static TlsCipherSuite TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256;
    public static TlsCipherSuite TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256;
    public static TlsCipherSuite TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256;
    public static TlsCipherSuite TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256;
    public static TlsCipherSuite TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256;
    public static TlsCipherSuite TLS_AES_128_GCM_SHA256;
    public static TlsCipherSuite TLS_AES_256_GCM_SHA384;
    public static TlsCipherSuite TLS_CHACHA20_POLY1305_SHA256;
    public static TlsCipherSuite TLS_AES_128_CCM_SHA256;
    public static TlsCipherSuite TLS_AES_128_CCM_8_SHA256;
    public static TlsCipherSuite TLS_ECDH_ECDSA_WITH_NULL_SHA;
    public static TlsCipherSuite TLS_ECDH_ECDSA_WITH_RC4_128_SHA;
    public static TlsCipherSuite TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA;
    public static TlsCipherSuite TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA;
    public static TlsCipherSuite TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA;
    public static TlsCipherSuite TLS_ECDHE_ECDSA_WITH_NULL_SHA;
    public static TlsCipherSuite TLS_ECDHE_ECDSA_WITH_RC4_128_SHA;
    public static TlsCipherSuite TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA;
    public static TlsCipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA;
    public static TlsCipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA;
    public static TlsCipherSuite TLS_ECDH_RSA_WITH_NULL_SHA;
    public static TlsCipherSuite TLS_ECDH_RSA_WITH_RC4_128_SHA;
    public static TlsCipherSuite TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA;
    public static TlsCipherSuite TLS_ECDH_RSA_WITH_AES_128_CBC_SHA;
    public static TlsCipherSuite TLS_ECDH_RSA_WITH_AES_256_CBC_SHA;
    public static TlsCipherSuite TLS_ECDHE_RSA_WITH_NULL_SHA;
    public static TlsCipherSuite TLS_ECDHE_RSA_WITH_RC4_128_SHA;
    public static TlsCipherSuite TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA;
    public static TlsCipherSuite TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA;
    public static TlsCipherSuite TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA;
    public static TlsCipherSuite TLS_ECDH_anon_WITH_NULL_SHA;
    public static TlsCipherSuite TLS_ECDH_anon_WITH_RC4_128_SHA;
    public static TlsCipherSuite TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA;
    public static TlsCipherSuite TLS_ECDH_anon_WITH_AES_128_CBC_SHA;
    public static TlsCipherSuite TLS_ECDH_anon_WITH_AES_256_CBC_SHA;
    public static TlsCipherSuite TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA;
    public static TlsCipherSuite TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA;
    public static TlsCipherSuite TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA;
    public static TlsCipherSuite TLS_SRP_SHA_WITH_AES_128_CBC_SHA;
    public static TlsCipherSuite TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA;
    public static TlsCipherSuite TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA;
    public static TlsCipherSuite TLS_SRP_SHA_WITH_AES_256_CBC_SHA;
    public static TlsCipherSuite TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA;
    public static TlsCipherSuite TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA;
    public static TlsCipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256;
    public static TlsCipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384;
    public static TlsCipherSuite TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256;
    public static TlsCipherSuite TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384;
    public static TlsCipherSuite TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256;
    public static TlsCipherSuite TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384;
    public static TlsCipherSuite TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256;
    public static TlsCipherSuite TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384;
    public static TlsCipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256;
    public static TlsCipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384;
    public static TlsCipherSuite TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256;
    public static TlsCipherSuite TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384;
    public static TlsCipherSuite TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256;
    public static TlsCipherSuite TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384;
    public static TlsCipherSuite TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256;
    public static TlsCipherSuite TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384;
    public static TlsCipherSuite TLS_ECDHE_PSK_WITH_RC4_128_SHA;
    public static TlsCipherSuite TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA;
    public static TlsCipherSuite TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA;
    public static TlsCipherSuite TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA;
    public static TlsCipherSuite TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256;
    public static TlsCipherSuite TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384;
    public static TlsCipherSuite TLS_ECDHE_PSK_WITH_NULL_SHA;
    public static TlsCipherSuite TLS_ECDHE_PSK_WITH_NULL_SHA256;
    public static TlsCipherSuite TLS_ECDHE_PSK_WITH_NULL_SHA384;
    public static TlsCipherSuite TLS_RSA_WITH_ARIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_RSA_WITH_ARIA_256_CBC_SHA384;
    public static TlsCipherSuite TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384;
    public static TlsCipherSuite TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384;
    public static TlsCipherSuite TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384;
    public static TlsCipherSuite TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384;
    public static TlsCipherSuite TLS_DH_anon_WITH_ARIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_DH_anon_WITH_ARIA_256_CBC_SHA384;
    public static TlsCipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384;
    public static TlsCipherSuite TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384;
    public static TlsCipherSuite TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384;
    public static TlsCipherSuite TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384;
    public static TlsCipherSuite TLS_RSA_WITH_ARIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_RSA_WITH_ARIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_DH_anon_WITH_ARIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_DH_anon_WITH_ARIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_PSK_WITH_ARIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_PSK_WITH_ARIA_256_CBC_SHA384;
    public static TlsCipherSuite TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384;
    public static TlsCipherSuite TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384;
    public static TlsCipherSuite TLS_PSK_WITH_ARIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_PSK_WITH_ARIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384;
    public static TlsCipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384;
    public static TlsCipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384;
    public static TlsCipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384;
    public static TlsCipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384;
    public static TlsCipherSuite TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256;
    public static TlsCipherSuite TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384;
    public static TlsCipherSuite TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384;
    public static TlsCipherSuite TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384;
    public static TlsCipherSuite TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384;
    public static TlsCipherSuite TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256;
    public static TlsCipherSuite TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384;
    public static TlsCipherSuite TLS_RSA_WITH_AES_128_CCM;
    public static TlsCipherSuite TLS_RSA_WITH_AES_256_CCM;
    public static TlsCipherSuite TLS_DHE_RSA_WITH_AES_128_CCM;
    public static TlsCipherSuite TLS_DHE_RSA_WITH_AES_256_CCM;
    public static TlsCipherSuite TLS_RSA_WITH_AES_128_CCM_8;
    public static TlsCipherSuite TLS_RSA_WITH_AES_256_CCM_8;
    public static TlsCipherSuite TLS_DHE_RSA_WITH_AES_128_CCM_8;
    public static TlsCipherSuite TLS_DHE_RSA_WITH_AES_256_CCM_8;
    public static TlsCipherSuite TLS_PSK_WITH_AES_128_CCM;
    public static TlsCipherSuite TLS_PSK_WITH_AES_256_CCM;
    public static TlsCipherSuite TLS_DHE_PSK_WITH_AES_128_CCM;
    public static TlsCipherSuite TLS_DHE_PSK_WITH_AES_256_CCM;
    public static TlsCipherSuite TLS_PSK_WITH_AES_128_CCM_8;
    public static TlsCipherSuite TLS_PSK_WITH_AES_256_CCM_8;
    public static TlsCipherSuite TLS_PSK_DHE_WITH_AES_128_CCM_8;
    public static TlsCipherSuite TLS_PSK_DHE_WITH_AES_256_CCM_8;
    public static TlsCipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CCM;
    public static TlsCipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CCM;
    public static TlsCipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8;
    public static TlsCipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8;
    public static TlsCipherSuite TLS_ECCPWD_WITH_AES_128_GCM_SHA256;
    public static TlsCipherSuite TLS_ECCPWD_WITH_AES_256_GCM_SHA384;
    public static TlsCipherSuite TLS_ECCPWD_WITH_AES_128_CCM_SHA256;
    public static TlsCipherSuite TLS_ECCPWD_WITH_AES_256_CCM_SHA384;
    public static TlsCipherSuite TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256;
    public static TlsCipherSuite TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256;
    public static TlsCipherSuite TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256;
    public static TlsCipherSuite TLS_PSK_WITH_CHACHA20_POLY1305_SHA256;
    public static TlsCipherSuite TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256;
    public static TlsCipherSuite TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256;
    public static TlsCipherSuite TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256;
    public static TlsCipherSuite TLS_ECDHE_PSK_WITH_AES_128_GCM_SHA256;
    public static TlsCipherSuite TLS_ECDHE_PSK_WITH_AES_256_GCM_SHA384;
    public static TlsCipherSuite TLS_ECDHE_PSK_WITH_AES_128_CCM_8_SHA256;
    public static TlsCipherSuite TLS_ECDHE_PSK_WITH_AES_128_CCM_SHA256;
}
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[IsByRefLikeAttribute]
internal class System.Net.Security.TwoSecurityBuffers : ValueType {
    internal SecurityBuffer _item0;
    private SecurityBuffer _item1;
}
internal class System.Net.SecurityPackageInfo : ValueType {
    internal int Capabilities;
    internal short Version;
    internal short RPCID;
    internal int MaxToken;
    internal IntPtr Name;
    internal IntPtr Comment;
}
internal class System.Net.SecurityPackageInfoClass : object {
    internal int Capabilities;
    internal short Version;
    internal short RPCID;
    internal int MaxToken;
    internal string Name;
    internal string Comment;
    internal SecurityPackageInfoClass(SafeHandle safeHandle, int index);
    public virtual string ToString();
}
internal static class System.Net.SecurityStatusAdapterPal : object {
    private static BidirectionalDictionary`2<SECURITY_STATUS, SecurityStatusPalErrorCode> s_statusDictionary;
    private static SecurityStatusAdapterPal();
    internal static SecurityStatusPal GetSecurityStatusPalFromNativeInt(int win32SecurityStatus);
    internal static SecurityStatusPal GetSecurityStatusPalFromInterop(SECURITY_STATUS win32SecurityStatus, bool attachException);
    internal static SECURITY_STATUS GetInteropFromSecurityStatusPal(SecurityStatusPal status);
}
[IsReadOnlyAttribute]
internal class System.Net.SecurityStatusPal : ValueType {
    public SecurityStatusPalErrorCode ErrorCode;
    public Exception Exception;
    public SecurityStatusPal(SecurityStatusPalErrorCode errorCode, Exception exception);
    public virtual string ToString();
}
internal enum System.Net.SecurityStatusPalErrorCode : Enum {
    public int value__;
    public static SecurityStatusPalErrorCode NotSet;
    public static SecurityStatusPalErrorCode OK;
    public static SecurityStatusPalErrorCode ContinueNeeded;
    public static SecurityStatusPalErrorCode CompleteNeeded;
    public static SecurityStatusPalErrorCode CompAndContinue;
    public static SecurityStatusPalErrorCode ContextExpired;
    public static SecurityStatusPalErrorCode CredentialsNeeded;
    public static SecurityStatusPalErrorCode Renegotiate;
    public static SecurityStatusPalErrorCode OutOfMemory;
    public static SecurityStatusPalErrorCode InvalidHandle;
    public static SecurityStatusPalErrorCode Unsupported;
    public static SecurityStatusPalErrorCode TargetUnknown;
    public static SecurityStatusPalErrorCode InternalError;
    public static SecurityStatusPalErrorCode PackageNotFound;
    public static SecurityStatusPalErrorCode NotOwner;
    public static SecurityStatusPalErrorCode CannotInstall;
    public static SecurityStatusPalErrorCode InvalidToken;
    public static SecurityStatusPalErrorCode CannotPack;
    public static SecurityStatusPalErrorCode QopNotSupported;
    public static SecurityStatusPalErrorCode NoImpersonation;
    public static SecurityStatusPalErrorCode LogonDenied;
    public static SecurityStatusPalErrorCode UnknownCredentials;
    public static SecurityStatusPalErrorCode NoCredentials;
    public static SecurityStatusPalErrorCode MessageAltered;
    public static SecurityStatusPalErrorCode OutOfSequence;
    public static SecurityStatusPalErrorCode NoAuthenticatingAuthority;
    public static SecurityStatusPalErrorCode IncompleteMessage;
    public static SecurityStatusPalErrorCode IncompleteCredentials;
    public static SecurityStatusPalErrorCode BufferNotEnough;
    public static SecurityStatusPalErrorCode WrongPrincipal;
    public static SecurityStatusPalErrorCode TimeSkew;
    public static SecurityStatusPalErrorCode UntrustedRoot;
    public static SecurityStatusPalErrorCode IllegalMessage;
    public static SecurityStatusPalErrorCode CertUnknown;
    public static SecurityStatusPalErrorCode CertExpired;
    public static SecurityStatusPalErrorCode DecryptFailure;
    public static SecurityStatusPalErrorCode AlgorithmMismatch;
    public static SecurityStatusPalErrorCode SecurityQosFailed;
    public static SecurityStatusPalErrorCode SmartcardLogonRequired;
    public static SecurityStatusPalErrorCode UnsupportedPreauth;
    public static SecurityStatusPalErrorCode BadBinding;
    public static SecurityStatusPalErrorCode DowngradeDetected;
    public static SecurityStatusPalErrorCode ApplicationProtocolMismatch;
}
internal class System.Net.SslStreamContext : TransportContext {
    private SslStream _sslStream;
    internal SslStreamContext(SslStream sslStream);
    public virtual ChannelBinding GetChannelBinding(ChannelBindingKind kind);
}
internal class System.Net.SSPIAuthType : object {
    private static SecurityPackageInfoClass[] modreq(System.Runtime.CompilerServices.IsVolatile) s_securityPackages;
    public SecurityPackageInfoClass[] SecurityPackages { get; public set; }
    public sealed virtual SecurityPackageInfoClass[] get_SecurityPackages();
    public sealed virtual void set_SecurityPackages(SecurityPackageInfoClass[] value);
    public sealed virtual int EnumerateSecurityPackages(Int32& pkgnum, SafeFreeContextBuffer& pkgArray);
    public sealed virtual int AcquireCredentialsHandle(string moduleName, CredentialUse usage, SafeSspiAuthDataHandle& authdata, SafeFreeCredentials& outCredential);
    public sealed virtual int AcquireDefaultCredential(string moduleName, CredentialUse usage, SafeFreeCredentials& outCredential);
    public sealed virtual int AcquireCredentialsHandle(string moduleName, CredentialUse usage, SCHANNEL_CRED& authdata, SafeFreeCredentials& outCredential);
    public sealed virtual int AcceptSecurityContext(SafeFreeCredentials credential, SafeDeleteContext& context, ReadOnlySpan`1<SecurityBuffer> inputBuffers, ContextFlags inFlags, Endianness endianness, SecurityBuffer& outputBuffer, ContextFlags& outFlags);
    public sealed virtual int InitializeSecurityContext(SafeFreeCredentials& credential, SafeDeleteContext& context, string targetName, ContextFlags inFlags, Endianness endianness, ReadOnlySpan`1<SecurityBuffer> inputBuffers, SecurityBuffer& outputBuffer, ContextFlags& outFlags);
    public sealed virtual int EncryptMessage(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32 sequenceNumber);
    public sealed virtual int DecryptMessage(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32 sequenceNumber);
    public sealed virtual int MakeSignature(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32 sequenceNumber);
    public sealed virtual int VerifySignature(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32 sequenceNumber);
    public sealed virtual int QueryContextChannelBinding(SafeDeleteContext context, ContextAttribute attribute, SafeFreeContextBufferChannelBinding& binding);
    public sealed virtual int QueryContextAttributes(SafeDeleteContext context, ContextAttribute attribute, Span`1<byte> buffer, Type handleType, SafeHandle& refHandle);
    public sealed virtual int QuerySecurityContextToken(SafeDeleteContext phContext, SecurityContextTokenHandle& phToken);
    public int CompleteAuthToken(SafeDeleteContext& refContext, SecurityBuffer& inputBuffer);
    private static int GetSecurityContextToken(SafeDeleteContext phContext, SecurityContextTokenHandle& safeHandle);
    public int ApplyControlToken(SafeDeleteContext& refContext, SecurityBuffer& inputBuffers);
    private sealed virtual override int System.Net.SSPIInterface.CompleteAuthToken(SafeDeleteContext& refContext, SecurityBuffer& modreq(System.Runtime.InteropServices.InAttribute) inputBuffer);
    private sealed virtual override int System.Net.SSPIInterface.ApplyControlToken(SafeDeleteContext& refContext, SecurityBuffer& modreq(System.Runtime.InteropServices.InAttribute) inputBuffer);
}
internal interface System.Net.SSPIInterface {
    public SecurityPackageInfoClass[] SecurityPackages { get; public set; }
    public abstract virtual SecurityPackageInfoClass[] get_SecurityPackages();
    public abstract virtual void set_SecurityPackages(SecurityPackageInfoClass[] value);
    public abstract virtual int EnumerateSecurityPackages(Int32& pkgnum, SafeFreeContextBuffer& pkgArray);
    public abstract virtual int AcquireCredentialsHandle(string moduleName, CredentialUse usage, SafeSspiAuthDataHandle& authdata, SafeFreeCredentials& outCredential);
    public abstract virtual int AcquireCredentialsHandle(string moduleName, CredentialUse usage, SCHANNEL_CRED& authdata, SafeFreeCredentials& outCredential);
    public abstract virtual int AcquireDefaultCredential(string moduleName, CredentialUse usage, SafeFreeCredentials& outCredential);
    public abstract virtual int AcceptSecurityContext(SafeFreeCredentials credential, SafeDeleteContext& context, ReadOnlySpan`1<SecurityBuffer> inputBuffers, ContextFlags inFlags, Endianness endianness, SecurityBuffer& outputBuffer, ContextFlags& outFlags);
    public abstract virtual int InitializeSecurityContext(SafeFreeCredentials& credential, SafeDeleteContext& context, string targetName, ContextFlags inFlags, Endianness endianness, ReadOnlySpan`1<SecurityBuffer> inputBuffers, SecurityBuffer& outputBuffer, ContextFlags& outFlags);
    public abstract virtual int EncryptMessage(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32 sequenceNumber);
    public abstract virtual int DecryptMessage(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32 sequenceNumber);
    public abstract virtual int MakeSignature(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32 sequenceNumber);
    public abstract virtual int VerifySignature(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32 sequenceNumber);
    public abstract virtual int QueryContextChannelBinding(SafeDeleteContext phContext, ContextAttribute attribute, SafeFreeContextBufferChannelBinding& refHandle);
    public abstract virtual int QueryContextAttributes(SafeDeleteContext phContext, ContextAttribute attribute, Span`1<byte> buffer, Type handleType, SafeHandle& refHandle);
    public abstract virtual int QuerySecurityContextToken(SafeDeleteContext phContext, SecurityContextTokenHandle& phToken);
    public abstract virtual int CompleteAuthToken(SafeDeleteContext& refContext, SecurityBuffer& modreq(System.Runtime.InteropServices.InAttribute) inputBuffer);
    public abstract virtual int ApplyControlToken(SafeDeleteContext& refContext, SecurityBuffer& modreq(System.Runtime.InteropServices.InAttribute) inputBuffer);
}
internal class System.Net.SSPISecureChannelType : object {
    private static SecurityPackageInfoClass[] modreq(System.Runtime.CompilerServices.IsVolatile) s_securityPackages;
    public SecurityPackageInfoClass[] SecurityPackages { get; public set; }
    public sealed virtual SecurityPackageInfoClass[] get_SecurityPackages();
    public sealed virtual void set_SecurityPackages(SecurityPackageInfoClass[] value);
    public sealed virtual int EnumerateSecurityPackages(Int32& pkgnum, SafeFreeContextBuffer& pkgArray);
    public sealed virtual int AcquireCredentialsHandle(string moduleName, CredentialUse usage, SafeSspiAuthDataHandle& authdata, SafeFreeCredentials& outCredential);
    public sealed virtual int AcquireDefaultCredential(string moduleName, CredentialUse usage, SafeFreeCredentials& outCredential);
    public sealed virtual int AcquireCredentialsHandle(string moduleName, CredentialUse usage, SCHANNEL_CRED& authdata, SafeFreeCredentials& outCredential);
    public sealed virtual int AcceptSecurityContext(SafeFreeCredentials credential, SafeDeleteContext& context, ReadOnlySpan`1<SecurityBuffer> inputBuffers, ContextFlags inFlags, Endianness endianness, SecurityBuffer& outputBuffer, ContextFlags& outFlags);
    public sealed virtual int InitializeSecurityContext(SafeFreeCredentials& credential, SafeDeleteContext& context, string targetName, ContextFlags inFlags, Endianness endianness, ReadOnlySpan`1<SecurityBuffer> inputBuffers, SecurityBuffer& outputBuffer, ContextFlags& outFlags);
    public sealed virtual int EncryptMessage(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32 sequenceNumber);
    public sealed virtual int DecryptMessage(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32 sequenceNumber);
    public sealed virtual int MakeSignature(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32 sequenceNumber);
    public sealed virtual int VerifySignature(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32 sequenceNumber);
    public sealed virtual int QueryContextChannelBinding(SafeDeleteContext phContext, ContextAttribute attribute, SafeFreeContextBufferChannelBinding& refHandle);
    public sealed virtual int QueryContextAttributes(SafeDeleteContext phContext, ContextAttribute attribute, Span`1<byte> buffer, Type handleType, SafeHandle& refHandle);
    public sealed virtual int QuerySecurityContextToken(SafeDeleteContext phContext, SecurityContextTokenHandle& phToken);
    public int CompleteAuthToken(SafeDeleteContext& refContext, SecurityBuffer& inputBuffer);
    public int ApplyControlToken(SafeDeleteContext& refContext, SecurityBuffer& inputBuffer);
    private sealed virtual override int System.Net.SSPIInterface.CompleteAuthToken(SafeDeleteContext& refContext, SecurityBuffer& modreq(System.Runtime.InteropServices.InAttribute) inputBuffer);
    private sealed virtual override int System.Net.SSPIInterface.ApplyControlToken(SafeDeleteContext& refContext, SecurityBuffer& modreq(System.Runtime.InteropServices.InAttribute) inputBuffer);
}
internal static class System.Net.SSPIWrapper : object {
    internal static SecurityPackageInfoClass[] EnumerateSecurityPackages(SSPIInterface secModule);
    internal static SecurityPackageInfoClass GetVerifyPackageInfo(SSPIInterface secModule, string packageName, bool throwIfMissing);
    public static SafeFreeCredentials AcquireDefaultCredential(SSPIInterface secModule, string package, CredentialUse intent);
    public static SafeFreeCredentials AcquireCredentialsHandle(SSPIInterface secModule, string package, CredentialUse intent, SafeSspiAuthDataHandle& authdata);
    public static SafeFreeCredentials AcquireCredentialsHandle(SSPIInterface secModule, string package, CredentialUse intent, SCHANNEL_CRED scc);
    internal static int InitializeSecurityContext(SSPIInterface secModule, SafeFreeCredentials& credential, SafeDeleteContext& context, string targetName, ContextFlags inFlags, Endianness datarep, ReadOnlySpan`1<SecurityBuffer> inputBuffers, SecurityBuffer& outputBuffer, ContextFlags& outFlags);
    internal static int AcceptSecurityContext(SSPIInterface secModule, SafeFreeCredentials credential, SafeDeleteContext& context, ContextFlags inFlags, Endianness datarep, ReadOnlySpan`1<SecurityBuffer> inputBuffers, SecurityBuffer& outputBuffer, ContextFlags& outFlags);
    internal static int CompleteAuthToken(SSPIInterface secModule, SafeDeleteContext& context, SecurityBuffer& inputBuffer);
    internal static int ApplyControlToken(SSPIInterface secModule, SafeDeleteContext& context, SecurityBuffer& inputBuffer);
    public static int QuerySecurityContextToken(SSPIInterface secModule, SafeDeleteContext context, SecurityContextTokenHandle& token);
    public static int EncryptMessage(SSPIInterface secModule, SafeDeleteContext context, Span`1<SecurityBuffer> input, UInt32 sequenceNumber);
    public static int DecryptMessage(SSPIInterface secModule, SafeDeleteContext context, Span`1<SecurityBuffer> input, UInt32 sequenceNumber);
    internal static int MakeSignature(SSPIInterface secModule, SafeDeleteContext context, Span`1<SecurityBuffer> input, UInt32 sequenceNumber);
    public static int VerifySignature(SSPIInterface secModule, SafeDeleteContext context, Span`1<SecurityBuffer> input, UInt32 sequenceNumber);
    private static int EncryptDecryptHelper(OP op, SSPIInterface secModule, SafeDeleteContext context, Span`1<SecurityBuffer> input, UInt32 sequenceNumber);
    public static SafeFreeContextBufferChannelBinding QueryContextChannelBinding(SSPIInterface secModule, SafeDeleteContext securityContext, ContextAttribute contextAttribute);
    public static bool QueryBlittableContextAttributes(SSPIInterface secModule, SafeDeleteContext securityContext, ContextAttribute contextAttribute, T& attribute);
    public static bool QueryBlittableContextAttributes(SSPIInterface secModule, SafeDeleteContext securityContext, ContextAttribute contextAttribute, Type safeHandleType, SafeHandle& sspiHandle, T& attribute);
    public static string QueryStringContextAttributes(SSPIInterface secModule, SafeDeleteContext securityContext, ContextAttribute contextAttribute);
    public static SafeFreeCertContext QueryContextAttributes_SECPKG_ATTR_REMOTE_CERT_CONTEXT(SSPIInterface secModule, SafeDeleteContext securityContext);
    public static bool QueryContextAttributes_SECPKG_ATTR_ISSUER_LIST_EX(SSPIInterface secModule, SafeDeleteContext securityContext, SecPkgContext_IssuerListInfoEx& ctx, SafeHandle& sspiHandle);
    public static string ErrorDescription(int errorCode);
}
internal class System.Net.StreamFramer : object {
    private Stream _transport;
    private bool _eof;
    private FrameHeader _writeHeader;
    private FrameHeader _curReadHeader;
    private FrameHeader _readVerifier;
    private Byte[] _readHeaderBuffer;
    private Byte[] _writeHeaderBuffer;
    private AsyncCallback _readFrameCallback;
    private AsyncCallback _beginWriteCallback;
    public FrameHeader ReadHeader { get; }
    public FrameHeader WriteHeader { get; }
    public Stream Transport { get; }
    public StreamFramer(Stream Transport);
    public FrameHeader get_ReadHeader();
    public FrameHeader get_WriteHeader();
    public Stream get_Transport();
    public Byte[] ReadMessage();
    public IAsyncResult BeginReadMessage(AsyncCallback asyncCallback, object stateObject);
    private void ReadFrameCallback(IAsyncResult transportResult);
    private void ReadFrameComplete(IAsyncResult transportResult);
    public Byte[] EndReadMessage(IAsyncResult asyncResult);
    public void WriteMessage(Byte[] message);
    public IAsyncResult BeginWriteMessage(Byte[] message, AsyncCallback asyncCallback, object stateObject);
    private void BeginWriteCallback(IAsyncResult transportResult);
    private void BeginWriteComplete(IAsyncResult transportResult);
    public void EndWriteMessage(IAsyncResult asyncResult);
}
internal class System.Net.StreamSizes : ValueType {
    [CompilerGeneratedAttribute]
private int <Header>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Trailer>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaximumMessage>k__BackingField;
    public int Header { get; private set; }
    public int Trailer { get; private set; }
    public int MaximumMessage { get; private set; }
    public StreamSizes(SecPkgContext_StreamSizes interopStreamSizes);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Header();
    [CompilerGeneratedAttribute]
private void set_Header(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Trailer();
    [CompilerGeneratedAttribute]
private void set_Trailer(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_MaximumMessage();
    [CompilerGeneratedAttribute]
private void set_MaximumMessage(int value);
}
internal static class System.Net.UnmanagedCertificateContext : object {
    internal static X509Certificate2Collection GetRemoteCertificatesFromStoreContext(SafeFreeCertContext certContext);
    internal static X509Certificate2Collection GetRemoteCertificatesFromStoreContext(IntPtr certContext);
}
internal class System.Net.WorkerAsyncResult : LazyAsyncResult {
    public Byte[] Buffer;
    public int Offset;
    public int End;
    public bool HeaderDone;
    public WorkerAsyncResult(object asyncObject, object asyncState, AsyncCallback savedAsyncCallback, Byte[] buffer, int offset, int end);
}
internal static class System.NotImplemented : object {
    internal static Exception ByDesignWithMessage(string message);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsUnmanagedAttribute : Attribute {
}
[TypeForwardedFromAttribute("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Security.Authentication.AuthenticationException : SystemException {
    public AuthenticationException(string message);
    public AuthenticationException(string message, Exception innerException);
    protected AuthenticationException(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
public class System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy : object {
    private ServiceNameCollection _customServiceNames;
    private PolicyEnforcement _policyEnforcement;
    private ProtectionScenario _protectionScenario;
    private ChannelBinding _customChannelBinding;
    public ServiceNameCollection CustomServiceNames { get; }
    public PolicyEnforcement PolicyEnforcement { get; }
    public ProtectionScenario ProtectionScenario { get; }
    public ChannelBinding CustomChannelBinding { get; }
    public static bool OSSupportsExtendedProtection { get; }
    public ExtendedProtectionPolicy(PolicyEnforcement policyEnforcement, ProtectionScenario protectionScenario, ServiceNameCollection customServiceNames);
    public ExtendedProtectionPolicy(PolicyEnforcement policyEnforcement, ProtectionScenario protectionScenario, ICollection customServiceNames);
    public ExtendedProtectionPolicy(PolicyEnforcement policyEnforcement, ChannelBinding customChannelBinding);
    public ExtendedProtectionPolicy(PolicyEnforcement policyEnforcement);
    protected ExtendedProtectionPolicy(SerializationInfo info, StreamingContext context);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public ServiceNameCollection get_CustomServiceNames();
    public PolicyEnforcement get_PolicyEnforcement();
    public ProtectionScenario get_ProtectionScenario();
    public ChannelBinding get_CustomChannelBinding();
    public virtual string ToString();
    public static bool get_OSSupportsExtendedProtection();
}
public enum System.Security.Authentication.ExtendedProtection.PolicyEnforcement : Enum {
    public int value__;
    public static PolicyEnforcement Never;
    public static PolicyEnforcement WhenSupported;
    public static PolicyEnforcement Always;
}
public enum System.Security.Authentication.ExtendedProtection.ProtectionScenario : Enum {
    public int value__;
    public static ProtectionScenario TransportSelected;
    public static ProtectionScenario TrustedProxy;
}
public class System.Security.Authentication.ExtendedProtection.ServiceNameCollection : ReadOnlyCollectionBase {
    public ServiceNameCollection(ICollection items);
    private ServiceNameCollection(IList list, string serviceName);
    private ServiceNameCollection(IList list, IEnumerable serviceNames);
    private ServiceNameCollection(IList list, int additionalCapacity);
    public bool Contains(string searchServiceName);
    public ServiceNameCollection Merge(string serviceName);
    public ServiceNameCollection Merge(IEnumerable serviceNames);
    private void AddIfNew(IEnumerable serviceNames, bool expectStrings);
    private void AddIfNew(List`1<string> serviceNames);
    private void AddIfNew(IList serviceNames);
    private void AddIfNew(string serviceName);
    private static int GetCountOrOne(IEnumerable collection);
    private static string NormalizeServiceName(string inputServiceName);
}
[TypeForwardedFromAttribute("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Security.Authentication.InvalidCredentialException : AuthenticationException {
    public InvalidCredentialException(string message);
    public InvalidCredentialException(string message, Exception innerException);
    protected InvalidCredentialException(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
internal static class System.SR : object {
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string net_noseek { get; }
    internal static string net_securitypackagesupport { get; }
    internal static string net_MethodNotImplementedException { get; }
    internal static string net_io_readfailure { get; }
    internal static string net_io_connectionclosed { get; }
    internal static string net_io_invalidnestedcall { get; }
    internal static string net_io_invalidendcall { get; }
    internal static string net_io_must_be_rw_stream { get; }
    internal static string net_io_header_id { get; }
    internal static string net_io_out_range { get; }
    internal static string net_io_encrypt { get; }
    internal static string net_io_decrypt { get; }
    internal static string net_io_read { get; }
    internal static string net_io_write { get; }
    internal static string net_io_eof { get; }
    internal static string net_io_async_result { get; }
    internal static string net_ssl_io_frame { get; }
    internal static string net_ssl_io_renego { get; }
    internal static string net_ssl_io_cert_validation { get; }
    internal static string net_ssl_io_no_server_cert { get; }
    internal static string net_ssl_io_already_shutdown { get; }
    internal static string net_auth_bad_client_creds { get; }
    internal static string net_auth_bad_client_creds_or_target_mismatch { get; }
    internal static string net_auth_context_expectation { get; }
    internal static string net_auth_context_expectation_remote { get; }
    internal static string net_auth_supported_impl_levels { get; }
    internal static string net_auth_reauth { get; }
    internal static string net_auth_noauth { get; }
    internal static string net_auth_client_server { get; }
    internal static string net_auth_SSPI { get; }
    internal static string net_auth_eof { get; }
    internal static string net_auth_alert { get; }
    internal static string net_auth_ignored_reauth { get; }
    internal static string net_auth_message_not_encrypted { get; }
    internal static string net_auth_must_specify_extended_protection_scheme { get; }
    internal static string net_frame_size { get; }
    internal static string net_frame_read_io { get; }
    internal static string net_frame_read_size { get; }
    internal static string net_frame_max_size { get; }
    internal static string net_offset_plus_count { get; }
    internal static string net_invalid_enum { get; }
    internal static string net_log_open_store_failed { get; }
    internal static string net_log_remote_cert_has_errors { get; }
    internal static string net_log_remote_cert_not_available { get; }
    internal static string net_log_remote_cert_name_mismatch { get; }
    internal static string event_OperationReturnedSomething { get; }
    internal static string net_log_operation_failed_with_error { get; }
    internal static string SSPIInvalidHandleType { get; }
    internal static string security_ExtendedProtectionPolicy_UseDifferentConstructorForNever { get; }
    internal static string security_ExtendedProtectionPolicy_NoEmptyServiceNameCollection { get; }
    internal static string security_ServiceNameCollection_EmptyServiceName { get; }
    internal static string net_ssl_app_protocols_invalid { get; }
    internal static string net_ssl_app_protocol_invalid { get; }
    internal static string net_conflicting_options { get; }
    internal static string net_ssl_ciphersuites_policy_not_supported { get; }
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static ResourceManager get_ResourceManager();
    internal static string get_net_noseek();
    internal static string get_net_securitypackagesupport();
    internal static string get_net_MethodNotImplementedException();
    internal static string get_net_io_readfailure();
    internal static string get_net_io_connectionclosed();
    internal static string get_net_io_invalidnestedcall();
    internal static string get_net_io_invalidendcall();
    internal static string get_net_io_must_be_rw_stream();
    internal static string get_net_io_header_id();
    internal static string get_net_io_out_range();
    internal static string get_net_io_encrypt();
    internal static string get_net_io_decrypt();
    internal static string get_net_io_read();
    internal static string get_net_io_write();
    internal static string get_net_io_eof();
    internal static string get_net_io_async_result();
    internal static string get_net_ssl_io_frame();
    internal static string get_net_ssl_io_renego();
    internal static string get_net_ssl_io_cert_validation();
    internal static string get_net_ssl_io_no_server_cert();
    internal static string get_net_ssl_io_already_shutdown();
    internal static string get_net_auth_bad_client_creds();
    internal static string get_net_auth_bad_client_creds_or_target_mismatch();
    internal static string get_net_auth_context_expectation();
    internal static string get_net_auth_context_expectation_remote();
    internal static string get_net_auth_supported_impl_levels();
    internal static string get_net_auth_reauth();
    internal static string get_net_auth_noauth();
    internal static string get_net_auth_client_server();
    internal static string get_net_auth_SSPI();
    internal static string get_net_auth_eof();
    internal static string get_net_auth_alert();
    internal static string get_net_auth_ignored_reauth();
    internal static string get_net_auth_message_not_encrypted();
    internal static string get_net_auth_must_specify_extended_protection_scheme();
    internal static string get_net_frame_size();
    internal static string get_net_frame_read_io();
    internal static string get_net_frame_read_size();
    internal static string get_net_frame_max_size();
    internal static string get_net_offset_plus_count();
    internal static string get_net_invalid_enum();
    internal static string get_net_log_open_store_failed();
    internal static string get_net_log_remote_cert_has_errors();
    internal static string get_net_log_remote_cert_not_available();
    internal static string get_net_log_remote_cert_name_mismatch();
    internal static string get_event_OperationReturnedSomething();
    internal static string get_net_log_operation_failed_with_error();
    internal static string get_SSPIInvalidHandleType();
    internal static string get_security_ExtendedProtectionPolicy_UseDifferentConstructorForNever();
    internal static string get_security_ExtendedProtectionPolicy_NoEmptyServiceNameCollection();
    internal static string get_security_ServiceNameCollection_EmptyServiceName();
    internal static string get_net_ssl_app_protocols_invalid();
    internal static string get_net_ssl_app_protocol_invalid();
    internal static string get_net_conflicting_options();
    internal static string get_net_ssl_ciphersuites_policy_not_supported();
}
internal static class System.Threading.Tasks.TaskToApm : object {
    public static IAsyncResult Begin(Task task, AsyncCallback callback, object state);
    public static void End(IAsyncResult asyncResult);
    public static TResult End(IAsyncResult asyncResult);
    private static void InvokeCallbackWhenTaskCompletes(Task antecedent, AsyncCallback callback, IAsyncResult asyncResult);
}
