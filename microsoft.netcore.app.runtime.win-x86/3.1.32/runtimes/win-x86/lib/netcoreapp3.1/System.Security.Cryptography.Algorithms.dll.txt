internal static class FxResources.System.Security.Cryptography.Algorithms.SR : object {
}
internal static class Internal.Cryptography.AesBCryptModes : object {
    private static SafeAlgorithmHandle s_hAlgCbc;
    private static SafeAlgorithmHandle s_hAlgEcb;
    private static AesBCryptModes();
    internal static SafeAlgorithmHandle GetSharedHandle(CipherMode cipherMode);
    internal static SafeAlgorithmHandle OpenAesAlgorithm(string cipherMode);
}
internal class Internal.Cryptography.AesImplementation : Aes {
    public sealed virtual ICryptoTransform CreateDecryptor();
    public sealed virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public sealed virtual ICryptoTransform CreateEncryptor();
    public sealed virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public sealed virtual void GenerateIV();
    public sealed virtual void GenerateKey();
    protected sealed virtual void Dispose(bool disposing);
    private ICryptoTransform CreateTransform(Byte[] rgbKey, Byte[] rgbIV, bool encrypting);
    private static ICryptoTransform CreateTransformCore(CipherMode cipherMode, PaddingMode paddingMode, Byte[] key, Byte[] iv, int blockSize, bool encrypting);
}
internal abstract class Internal.Cryptography.BasicSymmetricCipher : object {
    [CompilerGeneratedAttribute]
private int <BlockSizeInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <IV>k__BackingField;
    public int BlockSizeInBytes { get; private set; }
    protected Byte[] IV { get; private set; }
    protected BasicSymmetricCipher(Byte[] iv, int blockSizeInBytes);
    public abstract virtual int Transform(Byte[] input, int inputOffset, int count, Byte[] output, int outputOffset);
    public abstract virtual Byte[] TransformFinal(Byte[] input, int inputOffset, int count);
    [CompilerGeneratedAttribute]
public int get_BlockSizeInBytes();
    [CompilerGeneratedAttribute]
private void set_BlockSizeInBytes(int value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
protected Byte[] get_IV();
    [CompilerGeneratedAttribute]
private void set_IV(Byte[] value);
}
internal class Internal.Cryptography.BasicSymmetricCipherBCrypt : BasicSymmetricCipher {
    private bool _encrypting;
    private SafeKeyHandle _hKey;
    private Byte[] _currentIv;
    public BasicSymmetricCipherBCrypt(SafeAlgorithmHandle algorithm, CipherMode cipherMode, int blockSizeInBytes, Byte[] key, bool ownsParentHandle, Byte[] iv, bool encrypting);
    protected virtual void Dispose(bool disposing);
    public virtual int Transform(Byte[] input, int inputOffset, int count, Byte[] output, int outputOffset);
    public virtual Byte[] TransformFinal(Byte[] input, int inputOffset, int count);
    private void Reset();
}
[ExtensionAttribute]
internal static class Internal.Cryptography.CngCommon : object {
    public static Byte[] HashData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    public static bool TryHashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, Int32& bytesWritten);
    public static Byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm);
    [ExtensionAttribute]
public static Byte[] SignHash(SafeNCryptKeyHandle keyHandle, ReadOnlySpan`1<byte> hash, AsymmetricPaddingMode paddingMode, Void* pPaddingInfo, int estimatedSize);
    [ExtensionAttribute]
public static bool TrySignHash(SafeNCryptKeyHandle keyHandle, ReadOnlySpan`1<byte> hash, Span`1<byte> signature, AsymmetricPaddingMode paddingMode, Void* pPaddingInfo, Int32& bytesWritten);
    [ExtensionAttribute]
public static bool VerifyHash(SafeNCryptKeyHandle keyHandle, ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature, AsymmetricPaddingMode paddingMode, Void* pPaddingInfo);
}
[ExtensionAttribute]
internal static class Internal.Cryptography.CryptoThrowHelper : object {
    [ExtensionAttribute]
public static CryptographicException ToCryptographicException(int hr);
}
internal static class Internal.Cryptography.DesBCryptModes : object {
    private static SafeAlgorithmHandle s_hAlgCbc;
    private static SafeAlgorithmHandle s_hAlgEcb;
    private static DesBCryptModes();
    internal static SafeAlgorithmHandle GetSharedHandle(CipherMode cipherMode);
    private static SafeAlgorithmHandle OpenDesAlgorithm(string cipherMode);
}
internal class Internal.Cryptography.DesImplementation : DES {
    public virtual ICryptoTransform CreateDecryptor();
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateEncryptor();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual void GenerateIV();
    public sealed virtual void GenerateKey();
    private ICryptoTransform CreateTransform(Byte[] rgbKey, Byte[] rgbIV, bool encrypting);
    private static ICryptoTransform CreateTransformCore(CipherMode cipherMode, PaddingMode paddingMode, Byte[] key, Byte[] iv, int blockSize, bool encrypting);
}
[ExtensionAttribute]
internal static class Internal.Cryptography.ErrorCodeHelper : object {
    [ExtensionAttribute]
public static CryptographicException ToCryptographicException(ErrorCode errorCode);
}
[ExtensionAttribute]
internal static class Internal.Cryptography.HashAlgorithmNames : object {
    private static HashSet`1<string> s_allNames;
    private static HashAlgorithmNames();
    [ExtensionAttribute]
public static string ToAlgorithmName(HashAlgorithm hashAlgorithm);
    public static string ToUpper(string hashAlgorithName);
    private static HashSet`1<string> CreateAllNames();
}
internal abstract class Internal.Cryptography.HashProvider : object {
    public int HashSizeInBytes { get; }
    public void AppendHashData(Byte[] data, int offset, int count);
    public abstract virtual void AppendHashData(ReadOnlySpan`1<byte> data);
    public abstract virtual Byte[] FinalizeHashAndReset();
    public abstract virtual bool TryFinalizeHashAndReset(Span`1<byte> destination, Int32& bytesWritten);
    public abstract virtual int get_HashSizeInBytes();
    public sealed virtual void Dispose();
    public abstract virtual void Dispose(bool disposing);
}
internal class Internal.Cryptography.HashProviderCng : HashProvider {
    private SafeBCryptAlgorithmHandle _hAlgorithm;
    private SafeBCryptHashHandle _hHash;
    private Byte[] _key;
    private bool _reusable;
    private int _hashSize;
    public int HashSizeInBytes { get; }
    public HashProviderCng(string hashAlgId, Byte[] key);
    public sealed virtual void AppendHashData(ReadOnlySpan`1<byte> source);
    public sealed virtual Byte[] FinalizeHashAndReset();
    public virtual bool TryFinalizeHashAndReset(Span`1<byte> destination, Int32& bytesWritten);
    public sealed virtual void Dispose(bool disposing);
    public sealed virtual int get_HashSizeInBytes();
    private void ResetHashObject();
    private void DestroyHash();
}
internal static class Internal.Cryptography.HashProviderDispenser : object {
    public static HashProvider CreateHashProvider(string hashAlgorithmId);
    public static HashProvider CreateMacProvider(string hashAlgorithmId, Byte[] key);
}
[ExtensionAttribute]
internal static class Internal.Cryptography.Helpers : object {
    [ExtensionAttribute]
public static bool UsesIv(CipherMode cipherMode);
    [ExtensionAttribute]
public static Byte[] GetCipherIv(CipherMode cipherMode, Byte[] iv);
    public static Byte[] GenerateRandom(int count);
    public static void WriteInt(UInt32 i, Byte[] arr, int offset);
    [ExtensionAttribute]
public static Byte[] FixupKeyParity(Byte[] key);
    internal static void ConvertIntToByteArray(UInt32 value, Byte[] dest);
    [ExtensionAttribute]
public static Byte[] CloneByteArray(Byte[] src);
}
internal class Internal.Cryptography.HMACCommon : object {
    [CompilerGeneratedAttribute]
private Byte[] <ActualKey>k__BackingField;
    private string _hashAlgorithmId;
    private HashProvider _hMacProvider;
    private HashProvider modreq(System.Runtime.CompilerServices.IsVolatile) _lazyHashProvider;
    private int _blockSize;
    public int HashSizeInBits { get; }
    public Byte[] ActualKey { get; private set; }
    public HMACCommon(string hashAlgorithmId, Byte[] key, int blockSize);
    public int get_HashSizeInBits();
    public void ChangeKey(Byte[] key);
    [CompilerGeneratedAttribute]
public Byte[] get_ActualKey();
    [CompilerGeneratedAttribute]
private void set_ActualKey(Byte[] value);
    public void AppendHashData(Byte[] data, int offset, int count);
    public void AppendHashData(ReadOnlySpan`1<byte> source);
    public Byte[] FinalizeHashAndReset();
    public bool TryFinalizeHashAndReset(Span`1<byte> destination, Int32& bytesWritten);
    public void Dispose(bool disposing);
}
internal static class Internal.Cryptography.RC2BCryptModes : object {
    internal static SafeAlgorithmHandle GetHandle(CipherMode cipherMode, int effectiveKeyLength);
    private static SafeAlgorithmHandle OpenRC2Algorithm(string cipherMode, int effectiveKeyLength);
}
internal class Internal.Cryptography.RC2Implementation : RC2 {
    public int EffectiveKeySize { get; public set; }
    public virtual int get_EffectiveKeySize();
    public virtual void set_EffectiveKeySize(int value);
    public virtual ICryptoTransform CreateDecryptor();
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateEncryptor();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual void GenerateIV();
    public sealed virtual void GenerateKey();
    private ICryptoTransform CreateTransform(Byte[] rgbKey, Byte[] rgbIV, bool encrypting);
    private static ICryptoTransform CreateTransformCore(CipherMode cipherMode, PaddingMode paddingMode, Byte[] key, int effectiveKeyLength, Byte[] iv, int blockSize, bool encrypting);
}
internal class Internal.Cryptography.RijndaelImplementation : Rijndael {
    private Aes _impl;
    public int BlockSize { get; public set; }
    public Byte[] IV { get; public set; }
    public Byte[] Key { get; public set; }
    public int KeySize { get; public set; }
    public CipherMode Mode { get; public set; }
    public PaddingMode Padding { get; public set; }
    public KeySizes[] LegalKeySizes { get; }
    public virtual int get_BlockSize();
    public virtual void set_BlockSize(int value);
    public virtual Byte[] get_IV();
    public virtual void set_IV(Byte[] value);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual CipherMode get_Mode();
    public virtual void set_Mode(CipherMode value);
    public virtual PaddingMode get_Padding();
    public virtual void set_Padding(PaddingMode value);
    public virtual KeySizes[] get_LegalKeySizes();
    public virtual ICryptoTransform CreateEncryptor();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateDecryptor();
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual void GenerateIV();
    public virtual void GenerateKey();
    protected virtual void Dispose(bool disposing);
}
internal static class Internal.Cryptography.TripleDesBCryptModes : object {
    private static SafeAlgorithmHandle s_hAlgCbc;
    private static SafeAlgorithmHandle s_hAlgEcb;
    private static TripleDesBCryptModes();
    internal static SafeAlgorithmHandle GetSharedHandle(CipherMode cipherMode);
    private static SafeAlgorithmHandle Open3DesAlgorithm(string cipherMode);
}
internal class Internal.Cryptography.TripleDesImplementation : TripleDES {
    public virtual ICryptoTransform CreateDecryptor();
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateEncryptor();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual void GenerateIV();
    public sealed virtual void GenerateKey();
    private ICryptoTransform CreateTransform(Byte[] rgbKey, Byte[] rgbIV, bool encrypting);
    private static ICryptoTransform CreateTransformCore(CipherMode cipherMode, PaddingMode paddingMode, Byte[] key, Byte[] iv, int blockSize, bool encrypting);
}
internal class Internal.Cryptography.UniversalCryptoDecryptor : UniversalCryptoTransform {
    private Byte[] _heldoverCipher;
    private bool DepaddingRequired { get; }
    public UniversalCryptoDecryptor(PaddingMode paddingMode, BasicSymmetricCipher basicSymmetricCipher);
    protected sealed virtual int UncheckedTransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    protected sealed virtual Byte[] UncheckedTransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    protected sealed virtual void Dispose(bool disposing);
    private void Reset();
    private bool get_DepaddingRequired();
    private Byte[] DepadBlock(Byte[] block, int offset, int count);
}
internal class Internal.Cryptography.UniversalCryptoEncryptor : UniversalCryptoTransform {
    public UniversalCryptoEncryptor(PaddingMode paddingMode, BasicSymmetricCipher basicSymmetricCipher);
    protected sealed virtual int UncheckedTransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    protected sealed virtual Byte[] UncheckedTransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    private Byte[] PadBlock(Byte[] block, int offset, int count);
}
internal abstract class Internal.Cryptography.UniversalCryptoTransform : object {
    [CompilerGeneratedAttribute]
private PaddingMode <PaddingMode>k__BackingField;
    [CompilerGeneratedAttribute]
private BasicSymmetricCipher <BasicSymmetricCipher>k__BackingField;
    public bool CanReuseTransform { get; }
    public bool CanTransformMultipleBlocks { get; }
    public int InputBlockSize { get; }
    public int OutputBlockSize { get; }
    protected PaddingMode PaddingMode { get; private set; }
    protected BasicSymmetricCipher BasicSymmetricCipher { get; private set; }
    protected UniversalCryptoTransform(PaddingMode paddingMode, BasicSymmetricCipher basicSymmetricCipher);
    public static ICryptoTransform Create(PaddingMode paddingMode, BasicSymmetricCipher cipher, bool encrypting);
    public sealed virtual bool get_CanReuseTransform();
    public sealed virtual bool get_CanTransformMultipleBlocks();
    public sealed virtual int get_InputBlockSize();
    public sealed virtual int get_OutputBlockSize();
    public sealed virtual void Dispose();
    public sealed virtual int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    public sealed virtual Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    protected virtual void Dispose(bool disposing);
    protected abstract virtual int UncheckedTransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    protected abstract virtual Byte[] UncheckedTransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    [CompilerGeneratedAttribute]
protected PaddingMode get_PaddingMode();
    [CompilerGeneratedAttribute]
private void set_PaddingMode(PaddingMode value);
    [CompilerGeneratedAttribute]
protected BasicSymmetricCipher get_BasicSymmetricCipher();
    [CompilerGeneratedAttribute]
private void set_BasicSymmetricCipher(BasicSymmetricCipher value);
}
[ExtensionAttribute]
internal static class Internal.NativeCrypto.Cng : object {
    public static SafeAlgorithmHandle BCryptOpenAlgorithmProvider(string pszAlgId, string pszImplementation, OpenAlgorithmProviderFlags dwFlags);
    [ExtensionAttribute]
public static SafeKeyHandle BCryptImportKey(SafeAlgorithmHandle hAlg, ReadOnlySpan`1<byte> key);
    [ExtensionAttribute]
public static void SetCipherMode(SafeAlgorithmHandle hAlg, string cipherMode);
    [ExtensionAttribute]
public static void SetEffectiveKeyLength(SafeAlgorithmHandle hAlg, int effectiveKeyLength);
    [ExtensionAttribute]
public static int BCryptEncrypt(SafeKeyHandle hKey, Byte[] input, int inputOffset, int inputCount, Byte[] iv, Byte[] output, int outputOffset, int outputCount);
    [ExtensionAttribute]
public static int BCryptDecrypt(SafeKeyHandle hKey, Byte[] input, int inputOffset, int inputCount, Byte[] iv, Byte[] output, int outputOffset, int outputCount);
    private static Exception CreateCryptographicException(NTSTATUS ntStatus);
}
internal class Internal.NativeCrypto.SafeAlgorithmHandle : SafeBCryptHandle {
    protected sealed virtual bool ReleaseHandle();
    private static UInt32 BCryptCloseAlgorithmProvider(IntPtr hAlgorithm, int dwFlags);
}
internal class Internal.NativeCrypto.SafeKeyHandle : SafeBCryptHandle {
    private SafeAlgorithmHandle _parentHandle;
    public void SetParentHandle(SafeAlgorithmHandle parentHandle);
    protected sealed virtual bool ReleaseHandle();
    private static UInt32 BCryptDestroyKey(IntPtr hKey);
}
internal static class Interop : object {
}
internal class Microsoft.Win32.SafeHandles.DuplicateSafeNCryptKeyHandle : SafeNCryptKeyHandle {
    private SafeNCryptKeyHandle _original;
    public DuplicateSafeNCryptKeyHandle(SafeNCryptKeyHandle original);
    protected virtual bool ReleaseHandle();
}
internal class Microsoft.Win32.SafeHandles.SafeBCryptAlgorithmHandle : SafeBCryptHandle {
    protected sealed virtual bool ReleaseHandle();
}
internal abstract class Microsoft.Win32.SafeHandles.SafeBCryptHandle : SafeHandle {
    public bool IsInvalid { get; }
    public sealed virtual bool get_IsInvalid();
    protected abstract virtual bool ReleaseHandle();
}
internal class Microsoft.Win32.SafeHandles.SafeBCryptHashHandle : SafeBCryptHandle {
    protected sealed virtual bool ReleaseHandle();
}
internal class Microsoft.Win32.SafeHandles.SafeNCryptHandle : SafeHandle {
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
internal class Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle : SafeNCryptHandle {
}
internal class Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle : SafeNCryptHandle {
}
internal class Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle : SafeNCryptHandle {
}
internal class Microsoft.Win32.SafeHandles.SafeUnicodeStringHandle : SafeHandle {
    public bool IsInvalid { get; }
    public SafeUnicodeStringHandle(string s);
    public SafeUnicodeStringHandle(ReadOnlySpan`1<char> s);
    public sealed virtual bool get_IsInvalid();
    protected sealed virtual bool ReleaseHandle();
}
internal class System.Buffers.PointerMemoryManager`1 : MemoryManager`1<T> {
    private Void* _pointer;
    private int _length;
    internal PointerMemoryManager`1(Void* pointer, int length);
    protected virtual void Dispose(bool disposing);
    public virtual Span`1<T> GetSpan();
    public virtual MemoryHandle Pin(int elementIndex);
    public virtual void Unpin();
}
public abstract class System.Security.Cryptography.Aes : SymmetricAlgorithm {
    private static KeySizes[] s_legalBlockSizes;
    private static KeySizes[] s_legalKeySizes;
    private static Aes();
    public static Aes Create();
    public static Aes Create(string algorithmName);
}
internal class System.Security.Cryptography.AesAEAD : object {
    public static void CheckKeySize(int keySizeInBits);
    public static void CheckArgumentsForNull(Byte[] nonce, Byte[] plaintext, Byte[] ciphertext, Byte[] tag);
    public static void Encrypt(SafeAlgorithmHandle algorithm, SafeKeyHandle keyHandle, ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> associatedData, ReadOnlySpan`1<byte> plaintext, Span`1<byte> ciphertext, Span`1<byte> tag);
    public static void Decrypt(SafeAlgorithmHandle algorithm, SafeKeyHandle keyHandle, ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> associatedData, ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> tag, Span`1<byte> plaintext, bool clearPlaintextOnFailure);
}
public class System.Security.Cryptography.AesCcm : object {
    [CompilerGeneratedAttribute]
private static KeySizes <NonceByteSizes>k__BackingField;
    [CompilerGeneratedAttribute]
private static KeySizes <TagByteSizes>k__BackingField;
    private static SafeAlgorithmHandle s_aesCcm;
    private SafeKeyHandle _keyHandle;
    public static KeySizes NonceByteSizes { get; }
    public static KeySizes TagByteSizes { get; }
    public AesCcm(ReadOnlySpan`1<byte> key);
    public AesCcm(Byte[] key);
    private static AesCcm();
    [CompilerGeneratedAttribute]
public static KeySizes get_NonceByteSizes();
    [CompilerGeneratedAttribute]
public static KeySizes get_TagByteSizes();
    public void Encrypt(Byte[] nonce, Byte[] plaintext, Byte[] ciphertext, Byte[] tag, Byte[] associatedData);
    public void Encrypt(ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> plaintext, Span`1<byte> ciphertext, Span`1<byte> tag, ReadOnlySpan`1<byte> associatedData);
    public void Decrypt(Byte[] nonce, Byte[] ciphertext, Byte[] tag, Byte[] plaintext, Byte[] associatedData);
    public void Decrypt(ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> tag, Span`1<byte> plaintext, ReadOnlySpan`1<byte> associatedData);
    private static void CheckParameters(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> tag);
    private void ImportKey(ReadOnlySpan`1<byte> key);
    private void EncryptInternal(ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> plaintext, Span`1<byte> ciphertext, Span`1<byte> tag, ReadOnlySpan`1<byte> associatedData);
    private void DecryptInternal(ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> tag, Span`1<byte> plaintext, ReadOnlySpan`1<byte> associatedData);
    public sealed virtual void Dispose();
}
public class System.Security.Cryptography.AesGcm : object {
    [CompilerGeneratedAttribute]
private static KeySizes <NonceByteSizes>k__BackingField;
    [CompilerGeneratedAttribute]
private static KeySizes <TagByteSizes>k__BackingField;
    private static SafeAlgorithmHandle s_aesGcm;
    private SafeKeyHandle _keyHandle;
    public static KeySizes NonceByteSizes { get; }
    public static KeySizes TagByteSizes { get; }
    public AesGcm(ReadOnlySpan`1<byte> key);
    public AesGcm(Byte[] key);
    private static AesGcm();
    [CompilerGeneratedAttribute]
public static KeySizes get_NonceByteSizes();
    [CompilerGeneratedAttribute]
public static KeySizes get_TagByteSizes();
    public void Encrypt(Byte[] nonce, Byte[] plaintext, Byte[] ciphertext, Byte[] tag, Byte[] associatedData);
    public void Encrypt(ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> plaintext, Span`1<byte> ciphertext, Span`1<byte> tag, ReadOnlySpan`1<byte> associatedData);
    public void Decrypt(Byte[] nonce, Byte[] ciphertext, Byte[] tag, Byte[] plaintext, Byte[] associatedData);
    public void Decrypt(ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> tag, Span`1<byte> plaintext, ReadOnlySpan`1<byte> associatedData);
    private static void CheckParameters(ReadOnlySpan`1<byte> plaintext, ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> tag);
    private void ImportKey(ReadOnlySpan`1<byte> key);
    private void EncryptInternal(ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> plaintext, Span`1<byte> ciphertext, Span`1<byte> tag, ReadOnlySpan`1<byte> associatedData);
    private void DecryptInternal(ReadOnlySpan`1<byte> nonce, ReadOnlySpan`1<byte> ciphertext, ReadOnlySpan`1<byte> tag, Span`1<byte> plaintext, ReadOnlySpan`1<byte> associatedData);
    public sealed virtual void Dispose();
}
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.AesManaged : Aes {
    private Aes _impl;
    public int FeedbackSize { get; public set; }
    public int BlockSize { get; public set; }
    public Byte[] IV { get; public set; }
    public Byte[] Key { get; public set; }
    public int KeySize { get; public set; }
    public CipherMode Mode { get; public set; }
    public PaddingMode Padding { get; public set; }
    public KeySizes[] LegalBlockSizes { get; }
    public KeySizes[] LegalKeySizes { get; }
    public virtual int get_FeedbackSize();
    public virtual void set_FeedbackSize(int value);
    public virtual int get_BlockSize();
    public virtual void set_BlockSize(int value);
    public virtual Byte[] get_IV();
    public virtual void set_IV(Byte[] value);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual CipherMode get_Mode();
    public virtual void set_Mode(CipherMode value);
    public virtual PaddingMode get_Padding();
    public virtual void set_Padding(PaddingMode value);
    public virtual KeySizes[] get_LegalBlockSizes();
    public virtual KeySizes[] get_LegalKeySizes();
    public virtual ICryptoTransform CreateEncryptor();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateDecryptor();
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual void GenerateIV();
    public virtual void GenerateKey();
    protected virtual void Dispose(bool disposing);
}
internal class System.Security.Cryptography.Asn1.AlgorithmIdentifierAsn : ValueType {
    internal Oid Algorithm;
    internal Nullable`1<ReadOnlyMemory`1<byte>> Parameters;
    internal static ReadOnlyMemory`1<byte> ExplicitDerNull;
    private static AlgorithmIdentifierAsn();
    internal static void Decode(AsnReader reader, AlgorithmIdentifierAsn& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, AlgorithmIdentifierAsn& decoded);
    internal bool HasNullEquivalentParameters();
    private static bool RepresentsNull(Nullable`1<ReadOnlyMemory`1<byte>> parameters);
}
internal class System.Security.Cryptography.Asn1.Asn1Tag : ValueType {
    private byte _controlFlags;
    [CompilerGeneratedAttribute]
private int <TagValue>k__BackingField;
    public static Asn1Tag EndOfContents;
    public static Asn1Tag Boolean;
    public static Asn1Tag Integer;
    public static Asn1Tag PrimitiveBitString;
    public static Asn1Tag ConstructedBitString;
    public static Asn1Tag PrimitiveOctetString;
    public static Asn1Tag ConstructedOctetString;
    public static Asn1Tag Null;
    public static Asn1Tag ObjectIdentifier;
    public static Asn1Tag Enumerated;
    public static Asn1Tag Sequence;
    public static Asn1Tag SetOf;
    public static Asn1Tag UtcTime;
    public static Asn1Tag GeneralizedTime;
    public TagClass TagClass { get; }
    public bool IsConstructed { get; }
    public int TagValue { get; private set; }
    private Asn1Tag(byte controlFlags, int tagValue);
    public Asn1Tag(TagClass tagClass, int tagValue, bool isConstructed);
    private static Asn1Tag();
    public TagClass get_TagClass();
    public bool get_IsConstructed();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_TagValue();
    [CompilerGeneratedAttribute]
private void set_TagValue(int value);
    public Asn1Tag AsConstructed();
    public Asn1Tag AsPrimitive();
    public static bool TryDecode(ReadOnlySpan`1<byte> source, Asn1Tag& tag, Int32& bytesConsumed);
    public int CalculateEncodedSize();
    public bool TryEncode(Span`1<byte> destination, Int32& bytesWritten);
    public sealed virtual bool Equals(Asn1Tag other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Asn1Tag left, Asn1Tag right);
    public static bool op_Inequality(Asn1Tag left, Asn1Tag right);
    public bool HasSameClassAndValue(Asn1Tag other);
    public virtual string ToString();
}
internal enum System.Security.Cryptography.Asn1.AsnEncodingRules : Enum {
    public int value__;
    public static AsnEncodingRules BER;
    public static AsnEncodingRules CER;
    public static AsnEncodingRules DER;
}
internal class System.Security.Cryptography.Asn1.AsnReader : object {
    private ReadOnlyMemory`1<byte> _data;
    [CompilerGeneratedAttribute]
private AsnEncodingRules <RuleSet>k__BackingField;
    public AsnEncodingRules RuleSet { get; }
    public bool HasData { get; }
    public AsnReader(ReadOnlyMemory`1<byte> data, AsnEncodingRules ruleSet);
    [CompilerGeneratedAttribute]
public AsnEncodingRules get_RuleSet();
    public bool get_HasData();
    public void ThrowIfNotEmpty();
    public Asn1Tag PeekTag();
    public ReadOnlyMemory`1<byte> PeekEncodedValue();
    public ReadOnlyMemory`1<byte> ReadEncodedValue();
    private static bool TryReadLength(ReadOnlySpan`1<byte> source, AsnEncodingRules ruleSet, Nullable`1& length, Int32& bytesRead);
    internal Asn1Tag ReadTagAndLength(Nullable`1& contentsLength, Int32& bytesRead);
    private static void ValidateEndOfContents(Asn1Tag tag, Nullable`1<int> length, int headerLength);
    private int SeekEndOfContents(ReadOnlyMemory`1<byte> source);
    private static ReadOnlyMemory`1<byte> Slice(ReadOnlyMemory`1<byte> source, int offset, Nullable`1<int> length);
    private static void CheckEncodingRules(AsnEncodingRules ruleSet);
    private static void CheckExpectedTag(Asn1Tag tag, Asn1Tag expectedTag, UniversalTagNumber tagNumber);
    public bool TryReadPrimitiveBitStringValue(Int32& unusedBitCount, ReadOnlyMemory`1& value);
    public bool TryReadPrimitiveBitStringValue(Asn1Tag expectedTag, Int32& unusedBitCount, ReadOnlyMemory`1& value);
    public bool TryCopyBitStringBytes(Asn1Tag expectedTag, Span`1<byte> destination, Int32& unusedBitCount, Int32& bytesWritten);
    public bool TryCopyBitStringBytes(Asn1Tag expectedTag, ArraySegment`1<byte> destination, Int32& unusedBitCount, Int32& bytesWritten);
    public Byte[] ReadBitString(Int32& unusedBitCount);
    public Byte[] ReadBitString(Asn1Tag expectedTag, Int32& unusedBitCount);
    private void ParsePrimitiveBitStringContents(ReadOnlyMemory`1<byte> source, Int32& unusedBitCount, ReadOnlyMemory`1& value, Byte& normalizedLastByte);
    private static void CopyBitStringValue(ReadOnlyMemory`1<byte> value, byte normalizedLastByte, Span`1<byte> destination);
    private int CountConstructedBitString(ReadOnlyMemory`1<byte> source, bool isIndefinite);
    private void CopyConstructedBitString(ReadOnlyMemory`1<byte> source, Span`1<byte> destination, bool isIndefinite, Int32& unusedBitCount, Int32& bytesRead, Int32& bytesWritten);
    private int ProcessConstructedBitString(ReadOnlyMemory`1<byte> source, Span`1<byte> destination, BitStringCopyAction copyAction, bool isIndefinite, Int32& lastUnusedBitCount, Int32& bytesRead);
    private bool TryCopyConstructedBitStringValue(ReadOnlyMemory`1<byte> source, Span`1<byte> dest, bool isIndefinite, Int32& unusedBitCount, Int32& bytesRead, Int32& bytesWritten);
    private bool TryReadPrimitiveBitStringValue(Asn1Tag expectedTag, Asn1Tag& actualTag, Nullable`1& contentsLength, Int32& headerLength, Int32& unusedBitCount, ReadOnlyMemory`1& value, Byte& normalizedLastByte);
    public ReadOnlyMemory`1<byte> ReadIntegerBytes();
    public ReadOnlyMemory`1<byte> ReadIntegerBytes(Asn1Tag expectedTag);
    public BigInteger ReadInteger();
    public BigInteger ReadInteger(Asn1Tag expectedTag);
    public bool TryReadInt32(Int32& value);
    public bool TryReadInt32(Asn1Tag expectedTag, Int32& value);
    public bool TryReadUInt8(Byte& value);
    public bool TryReadUInt8(Asn1Tag expectedTag, Byte& value);
    private ReadOnlyMemory`1<byte> GetIntegerContents(Asn1Tag expectedTag, UniversalTagNumber tagNumber, Int32& headerLength);
    private bool TryReadSignedInteger(int sizeLimit, Asn1Tag expectedTag, UniversalTagNumber tagNumber, Int64& value);
    private bool TryReadUnsignedInteger(int sizeLimit, Asn1Tag expectedTag, UniversalTagNumber tagNumber, UInt64& value);
    public bool TryCopyOctetStringBytes(Span`1<byte> destination, Int32& bytesWritten);
    public bool TryCopyOctetStringBytes(Asn1Tag expectedTag, Span`1<byte> destination, Int32& bytesWritten);
    public bool TryCopyOctetStringBytes(Asn1Tag expectedTag, ArraySegment`1<byte> destination, Int32& bytesWritten);
    public Byte[] ReadOctetString();
    public Byte[] ReadOctetString(Asn1Tag expectedTag);
    private bool TryReadPrimitiveOctetStringBytes(Asn1Tag expectedTag, Asn1Tag& actualTag, Nullable`1& contentLength, Int32& headerLength, ReadOnlyMemory`1& contents, UniversalTagNumber universalTagNumber);
    private bool TryReadPrimitiveOctetStringBytes(Asn1Tag expectedTag, UniversalTagNumber universalTagNumber, ReadOnlyMemory`1& contents);
    public bool TryReadPrimitiveOctetStringBytes(ReadOnlyMemory`1& contents);
    public bool TryReadPrimitiveOctetStringBytes(Asn1Tag expectedTag, ReadOnlyMemory`1& contents);
    private int CountConstructedOctetString(ReadOnlyMemory`1<byte> source, bool isIndefinite);
    private void CopyConstructedOctetString(ReadOnlyMemory`1<byte> source, Span`1<byte> destination, bool isIndefinite, Int32& bytesRead, Int32& bytesWritten);
    private int CopyConstructedOctetString(ReadOnlyMemory`1<byte> source, Span`1<byte> destination, bool write, bool isIndefinite, Int32& bytesRead);
    private bool TryCopyConstructedOctetStringContents(ReadOnlyMemory`1<byte> source, Span`1<byte> dest, bool isIndefinite, Int32& bytesRead, Int32& bytesWritten);
    public string ReadObjectIdentifierAsString();
    public string ReadObjectIdentifierAsString(Asn1Tag expectedTag);
    public Oid ReadObjectIdentifier();
    public Oid ReadObjectIdentifier(Asn1Tag expectedTag);
    private static void ReadSubIdentifier(ReadOnlySpan`1<byte> source, Int32& bytesRead, Nullable`1& smallValue, Nullable`1& largeValue);
    private string ReadObjectIdentifierAsString(Asn1Tag expectedTag, Int32& totalBytesRead);
    public AsnReader ReadSequence(Asn1Tag expectedTag);
    public AsnReader ReadSetOf(bool skipSortOrderValidation);
    public AsnReader ReadSetOf(Asn1Tag expectedTag, bool skipSortOrderValidation);
}
internal class System.Security.Cryptography.Asn1.AsnWriter : object {
    private Byte[] _buffer;
    private int _offset;
    private Stack`1<ValueTuple`3<Asn1Tag, int, UniversalTagNumber>> _nestingStack;
    [CompilerGeneratedAttribute]
private AsnEncodingRules <RuleSet>k__BackingField;
    public AsnEncodingRules RuleSet { get; }
    public AsnWriter(AsnEncodingRules ruleSet);
    [CompilerGeneratedAttribute]
public AsnEncodingRules get_RuleSet();
    public sealed virtual void Dispose();
    public bool TryEncode(Span`1<byte> destination, Int32& bytesWritten);
    public Byte[] Encode();
    internal ReadOnlySpan`1<byte> EncodeAsSpan();
    public bool ValueEquals(ReadOnlySpan`1<byte> other);
    private void CheckDisposed();
    private void EnsureWriteCapacity(int pendingCount);
    private void WriteTag(Asn1Tag tag);
    private void WriteLength(int length);
    private static int GetEncodedLengthSubsequentByteCount(int length);
    public void WriteEncodedValue(ReadOnlySpan`1<byte> preEncodedValue);
    private void WriteEncodedValue(ReadOnlyMemory`1<byte> preEncodedValue);
    private void WriteEndOfContents();
    private void PushTag(Asn1Tag tag, UniversalTagNumber tagType);
    private void PopTag(Asn1Tag tag, UniversalTagNumber tagType, bool sortContents);
    private static void SortContents(Byte[] buffer, int start, int end);
    internal static void Reverse(Span`1<byte> span);
    private static void CheckUniversalTag(Asn1Tag tag, UniversalTagNumber universalTagNumber);
    public void WriteBitString(ReadOnlySpan`1<byte> bitString, int unusedBitCount);
    private void WriteBitStringCore(Asn1Tag tag, ReadOnlySpan`1<byte> bitString, int unusedBitCount);
    public void WriteBitString(int byteLength, TState state, SpanAction`2<byte, TState> action, int unusedBitCount);
    private void WriteBitStringCore(Asn1Tag tag, int byteLength, TState state, SpanAction`2<byte, TState> action, int unusedBitCount);
    private static bool CheckValidLastByte(byte lastByte, int unusedBitCount);
    private static int DetermineCerBitStringTotalLength(Asn1Tag tag, int contentLength);
    private void WriteConstructedCerBitString(Asn1Tag tag, ReadOnlySpan`1<byte> payload, int unusedBitCount);
    public void WriteInteger(long value);
    public void WriteInteger(ReadOnlySpan`1<byte> value);
    public void WriteIntegerUnsigned(ReadOnlySpan`1<byte> value);
    private void WriteIntegerCore(Asn1Tag tag, long value);
    private void WriteNonNegativeIntegerCore(Asn1Tag tag, ulong value);
    private void WriteIntegerUnsignedCore(Asn1Tag tag, ReadOnlySpan`1<byte> value);
    private void WriteIntegerCore(Asn1Tag tag, ReadOnlySpan`1<byte> value);
    public void WriteNull();
    private void WriteNullCore(Asn1Tag tag);
    public void WriteOctetString(ReadOnlySpan`1<byte> octetString);
    public void WriteOctetString(Asn1Tag tag, ReadOnlySpan`1<byte> octetString);
    private void WriteOctetStringCore(Asn1Tag tag, ReadOnlySpan`1<byte> octetString);
    private void WriteConstructedCerOctetString(Asn1Tag tag, ReadOnlySpan`1<byte> payload);
    public void WriteObjectIdentifier(Oid oid);
    public void WriteObjectIdentifier(string oidValue);
    public void WriteObjectIdentifier(ReadOnlySpan`1<char> oidValue);
    private void WriteObjectIdentifierCore(Asn1Tag tag, ReadOnlySpan`1<char> oidValue);
    private static BigInteger ParseSubIdentifier(ReadOnlySpan`1& oidValue);
    private static int AtoI(char c);
    private static int EncodeSubIdentifier(Span`1<byte> dest, BigInteger& subIdentifier);
    public void PushSequence();
    public void PushSequence(Asn1Tag tag);
    public void PopSequence();
    public void PopSequence(Asn1Tag tag);
    private void PushSequenceCore(Asn1Tag tag);
    private void PopSequenceCore(Asn1Tag tag);
}
internal class System.Security.Cryptography.Asn1.AttributeAsn : ValueType {
    internal Oid AttrType;
    internal ReadOnlyMemory`1[] AttrValues;
    internal static void Decode(AsnReader reader, AttributeAsn& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, AttributeAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.CurveAsn : ValueType {
    internal ReadOnlyMemory`1<byte> A;
    internal ReadOnlyMemory`1<byte> B;
    internal Nullable`1<ReadOnlyMemory`1<byte>> Seed;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static void Decode(AsnReader reader, CurveAsn& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, CurveAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.DssParms : ValueType {
    internal BigInteger P;
    internal BigInteger Q;
    internal BigInteger G;
    internal static DssParms Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static DssParms Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, DssParms& decoded);
}
internal class System.Security.Cryptography.Asn1.ECDomainParameters : ValueType {
    internal Nullable`1<SpecifiedECDomain> Specified;
    internal Oid Named;
    internal void Encode(AsnWriter writer);
    internal static ECDomainParameters Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, ECDomainParameters& decoded);
}
internal class System.Security.Cryptography.Asn1.ECPrivateKey : ValueType {
    internal byte Version;
    internal ReadOnlyMemory`1<byte> PrivateKey;
    internal Nullable`1<ECDomainParameters> Parameters;
    internal Nullable`1<ReadOnlyMemory`1<byte>> PublicKey;
    internal static ECPrivateKey Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static ECPrivateKey Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, ECPrivateKey& decoded);
}
internal class System.Security.Cryptography.Asn1.EncryptedPrivateKeyInfoAsn : ValueType {
    internal AlgorithmIdentifierAsn EncryptionAlgorithm;
    internal ReadOnlyMemory`1<byte> EncryptedData;
    internal static void Decode(AsnReader reader, EncryptedPrivateKeyInfoAsn& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, EncryptedPrivateKeyInfoAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.FieldID : ValueType {
    internal string FieldType;
    internal ReadOnlyMemory`1<byte> Parameters;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static void Decode(AsnReader reader, FieldID& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, FieldID& decoded);
}
internal class System.Security.Cryptography.Asn1.PBEParameter : ValueType {
    internal ReadOnlyMemory`1<byte> Salt;
    internal int IterationCount;
    internal static PBEParameter Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static PBEParameter Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, PBEParameter& decoded);
}
internal class System.Security.Cryptography.Asn1.PBES2Params : ValueType {
    internal AlgorithmIdentifierAsn KeyDerivationFunc;
    internal AlgorithmIdentifierAsn EncryptionScheme;
    internal static PBES2Params Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static PBES2Params Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, PBES2Params& decoded);
}
internal class System.Security.Cryptography.Asn1.Pbkdf2Params : ValueType {
    private static Byte[] s_defaultPrf;
    internal Pbkdf2SaltChoice Salt;
    internal int IterationCount;
    internal Nullable`1<byte> KeyLength;
    internal AlgorithmIdentifierAsn Prf;
    private static Pbkdf2Params();
    internal static Pbkdf2Params Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static Pbkdf2Params Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, Pbkdf2Params& decoded);
}
internal class System.Security.Cryptography.Asn1.Pbkdf2SaltChoice : ValueType {
    internal Nullable`1<ReadOnlyMemory`1<byte>> Specified;
    internal Nullable`1<AlgorithmIdentifierAsn> OtherSource;
    internal static void Decode(AsnReader reader, Pbkdf2SaltChoice& decoded);
}
internal class System.Security.Cryptography.Asn1.PrivateKeyInfoAsn : ValueType {
    internal byte Version;
    internal AlgorithmIdentifierAsn PrivateKeyAlgorithm;
    internal ReadOnlyMemory`1<byte> PrivateKey;
    internal AttributeAsn[] Attributes;
    internal static void Decode(AsnReader reader, PrivateKeyInfoAsn& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, PrivateKeyInfoAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.Rc2CbcParameters : ValueType {
    internal int Rc2Version;
    internal ReadOnlyMemory`1<byte> Iv;
    private static Byte[] s_rc2EkbEncoding;
    private static Rc2CbcParameters();
    internal static Rc2CbcParameters Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static Rc2CbcParameters Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, Rc2CbcParameters& decoded);
    internal int GetEffectiveKeyBits();
}
internal class System.Security.Cryptography.Asn1.RSAPrivateKeyAsn : ValueType {
    internal byte Version;
    internal BigInteger Modulus;
    internal BigInteger PublicExponent;
    internal BigInteger PrivateExponent;
    internal BigInteger Prime1;
    internal BigInteger Prime2;
    internal BigInteger Exponent1;
    internal BigInteger Exponent2;
    internal BigInteger Coefficient;
    internal static RSAPrivateKeyAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static RSAPrivateKeyAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, RSAPrivateKeyAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.RSAPublicKeyAsn : ValueType {
    internal BigInteger Modulus;
    internal BigInteger PublicExponent;
    internal static RSAPublicKeyAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static RSAPublicKeyAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, RSAPublicKeyAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.SetOfValueComparer : object {
    [CompilerGeneratedAttribute]
private static SetOfValueComparer <Instance>k__BackingField;
    internal static SetOfValueComparer Instance { get; }
    private static SetOfValueComparer();
    [CompilerGeneratedAttribute]
internal static SetOfValueComparer get_Instance();
    public sealed virtual int Compare(ReadOnlyMemory`1<byte> x, ReadOnlyMemory`1<byte> y);
}
internal class System.Security.Cryptography.Asn1.SpecifiedECDomain : ValueType {
    internal byte Version;
    internal FieldID FieldID;
    internal CurveAsn Curve;
    internal ReadOnlyMemory`1<byte> Base;
    internal ReadOnlyMemory`1<byte> Order;
    internal Nullable`1<ReadOnlyMemory`1<byte>> Cofactor;
    internal Oid Hash;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static void Decode(AsnReader reader, SpecifiedECDomain& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, SpecifiedECDomain& decoded);
}
internal class System.Security.Cryptography.Asn1.SubjectPublicKeyInfoAsn : ValueType {
    internal AlgorithmIdentifierAsn Algorithm;
    internal ReadOnlyMemory`1<byte> SubjectPublicKey;
    internal static void Decode(AsnReader reader, SubjectPublicKeyInfoAsn& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, SubjectPublicKeyInfoAsn& decoded);
}
internal enum System.Security.Cryptography.Asn1.TagClass : Enum {
    public byte value__;
    public static TagClass Universal;
    public static TagClass Application;
    public static TagClass ContextSpecific;
    public static TagClass Private;
}
internal enum System.Security.Cryptography.Asn1.UniversalTagNumber : Enum {
    public int value__;
    public static UniversalTagNumber EndOfContents;
    public static UniversalTagNumber Boolean;
    public static UniversalTagNumber Integer;
    public static UniversalTagNumber BitString;
    public static UniversalTagNumber OctetString;
    public static UniversalTagNumber Null;
    public static UniversalTagNumber ObjectIdentifier;
    public static UniversalTagNumber ObjectDescriptor;
    public static UniversalTagNumber External;
    public static UniversalTagNumber InstanceOf;
    public static UniversalTagNumber Real;
    public static UniversalTagNumber Enumerated;
    public static UniversalTagNumber Embedded;
    public static UniversalTagNumber UTF8String;
    public static UniversalTagNumber RelativeObjectIdentifier;
    public static UniversalTagNumber Time;
    public static UniversalTagNumber Sequence;
    public static UniversalTagNumber SequenceOf;
    public static UniversalTagNumber Set;
    public static UniversalTagNumber SetOf;
    public static UniversalTagNumber NumericString;
    public static UniversalTagNumber PrintableString;
    public static UniversalTagNumber TeletexString;
    public static UniversalTagNumber T61String;
    public static UniversalTagNumber VideotexString;
    public static UniversalTagNumber IA5String;
    public static UniversalTagNumber UtcTime;
    public static UniversalTagNumber GeneralizedTime;
    public static UniversalTagNumber GraphicString;
    public static UniversalTagNumber VisibleString;
    public static UniversalTagNumber ISO646String;
    public static UniversalTagNumber GeneralString;
    public static UniversalTagNumber UniversalString;
    public static UniversalTagNumber UnrestrictedCharacterString;
    public static UniversalTagNumber BMPString;
    public static UniversalTagNumber Date;
    public static UniversalTagNumber TimeOfDay;
    public static UniversalTagNumber DateTime;
    public static UniversalTagNumber Duration;
    public static UniversalTagNumber ObjectIdentifierIRI;
    public static UniversalTagNumber RelativeObjectIdentifierIRI;
}
public abstract class System.Security.Cryptography.AsymmetricKeyExchangeDeformatter : object {
    public string Parameters { get; public set; }
    public abstract virtual string get_Parameters();
    public abstract virtual void set_Parameters(string value);
    public abstract virtual void SetKey(AsymmetricAlgorithm key);
    public abstract virtual Byte[] DecryptKeyExchange(Byte[] rgb);
}
public abstract class System.Security.Cryptography.AsymmetricKeyExchangeFormatter : object {
    public string Parameters { get; }
    public abstract virtual string get_Parameters();
    public abstract virtual void SetKey(AsymmetricAlgorithm key);
    public abstract virtual Byte[] CreateKeyExchange(Byte[] data);
    public abstract virtual Byte[] CreateKeyExchange(Byte[] data, Type symAlgType);
}
public abstract class System.Security.Cryptography.AsymmetricSignatureDeformatter : object {
    public abstract virtual void SetKey(AsymmetricAlgorithm key);
    public abstract virtual void SetHashAlgorithm(string strName);
    public virtual bool VerifySignature(HashAlgorithm hash, Byte[] rgbSignature);
    public abstract virtual bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature);
}
public abstract class System.Security.Cryptography.AsymmetricSignatureFormatter : object {
    public abstract virtual void SetKey(AsymmetricAlgorithm key);
    public abstract virtual void SetHashAlgorithm(string strName);
    public virtual Byte[] CreateSignature(HashAlgorithm hash);
    public abstract virtual Byte[] CreateSignature(Byte[] rgbHash);
}
[FlagsAttribute]
internal enum System.Security.Cryptography.CngExportPolicies : Enum {
    public int value__;
    public static CngExportPolicies None;
    public static CngExportPolicies AllowPlaintextExport;
}
[FlagsAttribute]
internal enum System.Security.Cryptography.CngKeyCreationOptions : Enum {
    public int value__;
    public static CngKeyCreationOptions None;
}
internal static class System.Security.Cryptography.CngKeyLite : object {
    private static SafeNCryptProviderHandle s_microsoftSoftwareProviderHandle;
    private static Byte[] s_pkcs12TripleDesOidBytes;
    private static CngKeyLite();
    internal static SafeNCryptKeyHandle ImportKeyBlob(string blobType, ReadOnlySpan`1<byte> keyBlob, bool encrypted, ReadOnlySpan`1<char> password);
    internal static SafeNCryptKeyHandle ImportKeyBlob(string blobType, Byte[] keyBlob, string curveName);
    internal static Byte[] ExportKeyBlob(SafeNCryptKeyHandle keyHandle, string blobType);
    internal static Byte[] ExportPkcs8KeyBlob(SafeNCryptKeyHandle keyHandle, ReadOnlySpan`1<char> password, int kdfCount);
    internal static bool TryExportPkcs8KeyBlob(SafeNCryptKeyHandle keyHandle, ReadOnlySpan`1<char> password, int kdfCount, Span`1<byte> destination, Int32& bytesWritten);
    internal static bool ExportPkcs8KeyBlob(bool allocate, SafeNCryptKeyHandle keyHandle, ReadOnlySpan`1<char> password, int kdfCount, Span`1<byte> destination, Int32& bytesWritten, Byte[]& allocated);
    internal static SafeNCryptKeyHandle GenerateNewExportableKey(string algorithm, int keySize);
    internal static SafeNCryptKeyHandle GenerateNewExportableKey(string algorithm, string curveName);
    internal static SafeNCryptKeyHandle GenerateNewExportableKey(string algorithm, ECCurve& explicitCurve);
    private static void SetExportable(SafeNCryptKeyHandle keyHandle);
    private static void SetKeyLength(SafeNCryptKeyHandle keyHandle, int keySize);
    internal static int GetKeyLength(SafeNCryptKeyHandle keyHandle);
    private static SafeNCryptProviderHandle OpenNCryptProvider(string providerName);
    private static Byte[] GetProperty(SafeNCryptHandle ncryptHandle, string propertyName, CngPropertyOptions options);
    internal static string GetPropertyAsString(SafeNCryptHandle ncryptHandle, string propertyName, CngPropertyOptions options);
    internal static string GetCurveName(SafeNCryptHandle ncryptHandle);
    internal static void SetCurveName(SafeNCryptHandle keyHandle, string curveName);
    private static void SetProperty(SafeNCryptHandle ncryptHandle, string propertyName, Byte[] value);
}
internal static class System.Security.Cryptography.CngPkcs8 : object {
    private static PbeParameters s_platformParameters;
    private static CngPkcs8();
    private static Pkcs8Response ImportPkcs8(ReadOnlySpan`1<byte> keyBlob);
    private static Pkcs8Response ImportPkcs8(ReadOnlySpan`1<byte> keyBlob, ReadOnlySpan`1<char> password);
    internal static bool IsPlatformScheme(PbeParameters pbeParameters);
    internal static Byte[] ExportEncryptedPkcs8PrivateKey(AsymmetricAlgorithm key, ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters);
    internal static bool TryExportEncryptedPkcs8PrivateKey(AsymmetricAlgorithm key, ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    internal static Byte[] ExportEncryptedPkcs8PrivateKey(AsymmetricAlgorithm key, ReadOnlySpan`1<char> password, PbeParameters pbeParameters);
    internal static bool TryExportEncryptedPkcs8PrivateKey(AsymmetricAlgorithm key, ReadOnlySpan`1<char> password, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    internal static Pkcs8Response ImportPkcs8PrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    internal static Pkcs8Response ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    internal static Pkcs8Response ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    private static AsnWriter RewriteEncryptedPkcs8PrivateKey(AsymmetricAlgorithm key, ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters);
    private static AsnWriter RewriteEncryptedPkcs8PrivateKey(AsymmetricAlgorithm key, ReadOnlySpan`1<char> password, PbeParameters pbeParameters);
    private static void FillRandomAsciiString(Span`1<char> destination);
}
[FlagsAttribute]
internal enum System.Security.Cryptography.CngPropertyOptions : Enum {
    public int value__;
    public static CngPropertyOptions None;
    public static CngPropertyOptions Persist;
}
public class System.Security.Cryptography.CryptoConfig : object {
    private static Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_defaultOidHT;
    private static Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_defaultNameHT;
    private static Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) appNameHT;
    private static Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) appOidHT;
    private static Char[] SepArray;
    private static object s_InternalSyncObject;
    public static bool AllowOnlyFipsAlgorithms { get; }
    private static Dictionary`2<string, string> DefaultOidHT { get; }
    private static Dictionary`2<string, object> DefaultNameHT { get; }
    private static CryptoConfig();
    public static bool get_AllowOnlyFipsAlgorithms();
    private static Dictionary`2<string, string> get_DefaultOidHT();
    private static Dictionary`2<string, object> get_DefaultNameHT();
    public static void AddAlgorithm(Type algorithm, String[] names);
    public static object CreateFromName(string name, Object[] args);
    public static object CreateFromName(string name);
    public static void AddOID(string oid, String[] names);
    public static string MapNameToOID(string name);
    public static Byte[] EncodeOID(string str);
    private static void EncodeSingleOidNum(UInt32 value, Byte[] destination, Int32& index);
}
internal static class System.Security.Cryptography.CryptoPool : object {
    internal static Byte[] Rent(int minimumLength);
    internal static void Return(Byte[] array, int clearSize);
}
public abstract class System.Security.Cryptography.DeriveBytes : object {
    public abstract virtual Byte[] GetBytes(int cb);
    public abstract virtual void Reset();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
[EditorBrowsableAttribute("1")]
public abstract class System.Security.Cryptography.DES : SymmetricAlgorithm {
    private static KeySizes[] s_legalBlockSizes;
    private static KeySizes[] s_legalKeySizes;
    public Byte[] Key { get; public set; }
    private static DES();
    public static DES Create();
    public static DES Create(string algName);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public static bool IsWeakKey(Byte[] rgbKey);
    public static bool IsSemiWeakKey(Byte[] rgbKey);
    private static bool IsLegalKeySize(Byte[] rgbKey);
    private static ulong QuadWordFromBigEndian(Byte[] block);
}
public abstract class System.Security.Cryptography.DSA : AsymmetricAlgorithm {
    public abstract virtual DSAParameters ExportParameters(bool includePrivateParameters);
    public abstract virtual void ImportParameters(DSAParameters parameters);
    public static DSA Create(string algName);
    public static DSA Create(int keySizeInBits);
    public static DSA Create(DSAParameters parameters);
    public abstract virtual Byte[] CreateSignature(Byte[] rgbHash);
    public abstract virtual bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature);
    protected virtual Byte[] HashData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    protected virtual Byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm);
    public Byte[] SignData(Byte[] data, HashAlgorithmName hashAlgorithm);
    public virtual Byte[] SignData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    public virtual Byte[] SignData(Stream data, HashAlgorithmName hashAlgorithm);
    public bool VerifyData(Byte[] data, Byte[] signature, HashAlgorithmName hashAlgorithm);
    public virtual bool VerifyData(Byte[] data, int offset, int count, Byte[] signature, HashAlgorithmName hashAlgorithm);
    public virtual bool VerifyData(Stream data, Byte[] signature, HashAlgorithmName hashAlgorithm);
    public virtual bool TryCreateSignature(ReadOnlySpan`1<byte> hash, Span`1<byte> destination, Int32& bytesWritten);
    protected virtual bool TryHashData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, Int32& bytesWritten);
    public virtual bool TrySignData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, Int32& bytesWritten);
    public virtual bool VerifyData(ReadOnlySpan`1<byte> data, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm);
    public virtual bool VerifySignature(ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature);
    private static Exception DerivedClassMustOverride();
    internal static Exception HashAlgorithmNameNullOrEmpty();
    public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportPkcs8PrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportSubjectPublicKeyInfo(Span`1<byte> destination, Int32& bytesWritten);
    private AsnWriter WritePkcs8();
    private AsnWriter WriteSubjectPublicKeyInfo();
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportPkcs8PrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportSubjectPublicKeyInfo(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    private static Byte[] ReadRequiredElement(ParseState& state, string name, int sizeHint);
    public virtual void FromXmlString(string xmlString);
    public virtual string ToXmlString(bool includePrivateParameters);
    public static DSA Create();
}
internal static class System.Security.Cryptography.DSAImplementation : object {
}
internal static class System.Security.Cryptography.DSAKeyFormatHelper : object {
    private static String[] s_validOids;
    private static DSAKeyFormatHelper();
    internal static void ReadDsaPrivateKey(ReadOnlyMemory`1<byte> xBytes, AlgorithmIdentifierAsn& algId, DSAParameters& ret);
    internal static void ReadDsaPublicKey(ReadOnlyMemory`1<byte> yBytes, AlgorithmIdentifierAsn& algId, DSAParameters& ret);
    internal static void ReadSubjectPublicKeyInfo(ReadOnlySpan`1<byte> source, Int32& bytesRead, DSAParameters& key);
    internal static void ReadPkcs8(ReadOnlySpan`1<byte> source, Int32& bytesRead, DSAParameters& key);
    internal static void ReadEncryptedPkcs8(ReadOnlySpan`1<byte> source, ReadOnlySpan`1<char> password, Int32& bytesRead, DSAParameters& key);
    internal static void ReadEncryptedPkcs8(ReadOnlySpan`1<byte> source, ReadOnlySpan`1<byte> passwordBytes, Int32& bytesRead, DSAParameters& key);
    internal static AsnWriter WriteSubjectPublicKeyInfo(DSAParameters& dsaParameters);
    internal static AsnWriter WritePkcs8(DSAParameters& dsaParameters);
    private static void WriteAlgorithmId(AsnWriter writer, DSAParameters& dsaParameters);
    private static void WriteKeyComponent(AsnWriter writer, Byte[] component, bool bitString);
}
public class System.Security.Cryptography.DSAParameters : ValueType {
    public Byte[] P;
    public Byte[] Q;
    public Byte[] G;
    public Byte[] Y;
    public Byte[] J;
    public Byte[] X;
    public Byte[] Seed;
    public int Counter;
}
public class System.Security.Cryptography.DSASignatureDeformatter : AsymmetricSignatureDeformatter {
    private DSA _dsaKey;
    public DSASignatureDeformatter(AsymmetricAlgorithm key);
    public virtual void SetKey(AsymmetricAlgorithm key);
    public virtual void SetHashAlgorithm(string strName);
    public virtual bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature);
}
public class System.Security.Cryptography.DSASignatureFormatter : AsymmetricSignatureFormatter {
    private DSA _dsaKey;
    public DSASignatureFormatter(AsymmetricAlgorithm key);
    public virtual void SetKey(AsymmetricAlgorithm key);
    public virtual void SetHashAlgorithm(string strName);
    public virtual Byte[] CreateSignature(Byte[] rgbHash);
}
internal static class System.Security.Cryptography.EccKeyFormatHelper : object {
    private static String[] s_validOids;
    private static EccKeyFormatHelper();
    internal static ECParameters FromECPrivateKey(ReadOnlySpan`1<byte> key, Int32& bytesRead);
    internal static void FromECPrivateKey(ReadOnlyMemory`1<byte> keyData, AlgorithmIdentifierAsn& algId, ECParameters& ret);
    internal static void FromECPublicKey(ReadOnlyMemory`1<byte> key, AlgorithmIdentifierAsn& algId, ECParameters& ret);
    private static void ValidateParameters(Nullable`1<ECDomainParameters> keyParameters, AlgorithmIdentifierAsn& algId);
    private static ECCurve GetCurve(ECDomainParameters& domainParameters);
    internal static AsnWriter WriteSubjectPublicKeyInfo(ECParameters& ecParameters);
    private static AsnWriter WriteAlgorithmIdentifier(ECParameters& ecParameters);
    private static void WriteAlgorithmIdentifier(ECParameters& ecParameters, AsnWriter writer);
    internal static AsnWriter WritePkcs8PrivateKey(ECParameters& ecParameters);
    private static void WriteEcParameters(ECParameters& ecParameters, AsnWriter writer);
    private static void WriteUncompressedPublicKey(ECParameters& ecParameters, AsnWriter writer);
    internal static AsnWriter WriteECPrivateKey(ECParameters& ecParameters);
    private static AsnWriter WriteEcPrivateKey(ECParameters& ecParameters, bool includeDomainParameters);
}
internal static class System.Security.Cryptography.ECCng : object {
    internal static ECC_CURVE_ALG_ID_ENUM GetHashAlgorithmId(Nullable`1<HashAlgorithmName> name);
    internal static Nullable`1<HashAlgorithmName> GetHashAlgorithmName(ECC_CURVE_ALG_ID_ENUM hashId);
    internal static bool IsECNamedCurve(string algorithm);
    internal static string SpecialNistAlgorithmToCurveName(string algorithm, String& oidValue);
    internal static Byte[] GetNamedCurveBlob(ECParameters& parameters, bool ecdh);
    internal static Byte[] GetPrimeCurveBlob(ECParameters& parameters, bool ecdh);
    internal static void ExportNamedCurveParameters(ECParameters& ecParams, Byte[] ecBlob, bool includePrivateParameters);
    internal static void ExportPrimeCurveParameters(ECParameters& ecParams, Byte[] ecBlob, bool includePrivateParameters);
    internal static Byte[] GetPrimeCurveParameterBlob(ECCurve& curve);
    private static void CheckMagicValueOfKey(KeyBlobMagicNumber magic, bool includePrivateParameters);
    private static bool IsMagicValueOfKeyPrivate(KeyBlobMagicNumber magic);
    private static bool IsMagicValueOfKeyPublic(KeyBlobMagicNumber magic);
    private static KeyBlobMagicNumber EcdsaCurveNameToMagicNumber(string name, bool includePrivateParameters);
    private static KeyBlobMagicNumber EcdhCurveNameToMagicNumber(string name, bool includePrivateParameters);
    private static ECC_CURVE_TYPE_ENUM ConvertToCurveTypeEnum(ECCurveType value);
    private static ECCurveType ConvertToCurveTypeEnum(ECC_CURVE_TYPE_ENUM value);
    internal static SafeNCryptKeyHandle ImportKeyBlob(string blobType, ReadOnlySpan`1<byte> keyBlob, string curveName, SafeNCryptProviderHandle provider);
    internal static string EcdsaCurveNameToAlgorithm(string algorithm);
    internal static string EcdhCurveNameToAlgorithm(string algorithm);
}
internal class System.Security.Cryptography.ECCngKey : object {
    private SafeNCryptKeyHandle _keyHandle;
    private int _lastKeySize;
    private string _lastAlgorithm;
    private bool _disposed;
    private string _algorithmGroup;
    private string _disposedName;
    [CompilerGeneratedAttribute]
private int <KeySize>k__BackingField;
    internal int KeySize { get; private set; }
    internal ECCngKey(string algorithmGroup, string disposedName);
    [CompilerGeneratedAttribute]
internal int get_KeySize();
    [CompilerGeneratedAttribute]
private void set_KeySize(int value);
    internal string GetCurveName(int callerKeySizeProperty, String& oidValue);
    internal SafeNCryptKeyHandle GetDuplicatedKeyHandle(int callerKeySizeProperty);
    internal void GenerateKey(ECCurve curve);
    internal void FullDispose();
    internal void DisposeKey();
    internal void SetHandle(SafeNCryptKeyHandle keyHandle, string algorithmName);
    internal void ThrowIfDisposed();
}
[DebuggerDisplayAttribute("ECCurve: {Oid}")]
public class System.Security.Cryptography.ECCurve : ValueType {
    public Byte[] A;
    public Byte[] B;
    public ECPoint G;
    public Byte[] Order;
    public Byte[] Cofactor;
    public Byte[] Seed;
    public ECCurveType CurveType;
    public Nullable`1<HashAlgorithmName> Hash;
    public Byte[] Polynomial;
    public Byte[] Prime;
    private Oid _oid;
    public Oid Oid { get; private set; }
    public bool IsPrime { get; }
    public bool IsCharacteristic2 { get; }
    public bool IsExplicit { get; }
    public bool IsNamed { get; }
    public Oid get_Oid();
    private void set_Oid(Oid value);
    private static ECCurve Create(Oid oid);
    public static ECCurve CreateFromOid(Oid curveOid);
    public static ECCurve CreateFromFriendlyName(string oidFriendlyName);
    public static ECCurve CreateFromValue(string oidValue);
    private static ECCurve CreateFromValueAndName(string oidValue, string oidFriendlyName);
    public bool get_IsPrime();
    public bool get_IsCharacteristic2();
    public bool get_IsExplicit();
    public bool get_IsNamed();
    public void Validate();
    private bool HasAnyExplicitParameters();
}
public abstract class System.Security.Cryptography.ECDiffieHellman : AsymmetricAlgorithm {
    private static String[] s_validOids;
    public string KeyExchangeAlgorithm { get; }
    public string SignatureAlgorithm { get; }
    public ECDiffieHellmanPublicKey PublicKey { get; }
    private static ECDiffieHellman();
    public virtual string get_KeyExchangeAlgorithm();
    public virtual string get_SignatureAlgorithm();
    public static ECDiffieHellman Create(string algorithm);
    public abstract virtual ECDiffieHellmanPublicKey get_PublicKey();
    public virtual Byte[] DeriveKeyMaterial(ECDiffieHellmanPublicKey otherPartyPublicKey);
    public Byte[] DeriveKeyFromHash(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm);
    public virtual Byte[] DeriveKeyFromHash(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm, Byte[] secretPrepend, Byte[] secretAppend);
    public Byte[] DeriveKeyFromHmac(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm, Byte[] hmacKey);
    public virtual Byte[] DeriveKeyFromHmac(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm, Byte[] hmacKey, Byte[] secretPrepend, Byte[] secretAppend);
    public virtual Byte[] DeriveKeyTls(ECDiffieHellmanPublicKey otherPartyPublicKey, Byte[] prfLabel, Byte[] prfSeed);
    private static Exception DerivedClassMustOverride();
    public virtual ECParameters ExportParameters(bool includePrivateParameters);
    public virtual ECParameters ExportExplicitParameters(bool includePrivateParameters);
    public virtual void ImportParameters(ECParameters parameters);
    public virtual void GenerateKey(ECCurve curve);
    public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportPkcs8PrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportSubjectPublicKeyInfo(Span`1<byte> destination, Int32& bytesWritten);
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportPkcs8PrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportSubjectPublicKeyInfo(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportECPrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual Byte[] ExportECPrivateKey();
    public virtual bool TryExportECPrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    public virtual void FromXmlString(string xmlString);
    public virtual string ToXmlString(bool includePrivateParameters);
    public static ECDiffieHellman Create();
    public static ECDiffieHellman Create(ECCurve curve);
    public static ECDiffieHellman Create(ECParameters parameters);
}
internal static class System.Security.Cryptography.ECDiffieHellmanImplementation : object {
}
public abstract class System.Security.Cryptography.ECDiffieHellmanPublicKey : object {
    private Byte[] _keyBlob;
    protected ECDiffieHellmanPublicKey(Byte[] keyBlob);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual Byte[] ToByteArray();
    public virtual string ToXmlString();
    public virtual ECParameters ExportParameters();
    public virtual ECParameters ExportExplicitParameters();
}
public abstract class System.Security.Cryptography.ECDsa : AsymmetricAlgorithm {
    private static String[] s_validOids;
    public string KeyExchangeAlgorithm { get; }
    public string SignatureAlgorithm { get; }
    private static ECDsa();
    public static ECDsa Create(string algorithm);
    public virtual ECParameters ExportParameters(bool includePrivateParameters);
    public virtual ECParameters ExportExplicitParameters(bool includePrivateParameters);
    public virtual void ImportParameters(ECParameters parameters);
    public virtual void GenerateKey(ECCurve curve);
    public virtual Byte[] SignData(Byte[] data, HashAlgorithmName hashAlgorithm);
    public virtual Byte[] SignData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    public virtual bool TrySignData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, Int32& bytesWritten);
    public virtual Byte[] SignData(Stream data, HashAlgorithmName hashAlgorithm);
    public bool VerifyData(Byte[] data, Byte[] signature, HashAlgorithmName hashAlgorithm);
    public virtual bool VerifyData(Byte[] data, int offset, int count, Byte[] signature, HashAlgorithmName hashAlgorithm);
    public virtual bool VerifyData(ReadOnlySpan`1<byte> data, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm);
    public bool VerifyData(Stream data, Byte[] signature, HashAlgorithmName hashAlgorithm);
    public abstract virtual Byte[] SignHash(Byte[] hash);
    public abstract virtual bool VerifyHash(Byte[] hash, Byte[] signature);
    public virtual string get_KeyExchangeAlgorithm();
    public virtual string get_SignatureAlgorithm();
    protected virtual Byte[] HashData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    protected virtual Byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm);
    protected virtual bool TryHashData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, Int32& bytesWritten);
    public virtual bool TrySignHash(ReadOnlySpan`1<byte> hash, Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool VerifyHash(ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature);
    public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportPkcs8PrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportSubjectPublicKeyInfo(Span`1<byte> destination, Int32& bytesWritten);
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportPkcs8PrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportSubjectPublicKeyInfo(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportECPrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual Byte[] ExportECPrivateKey();
    public virtual bool TryExportECPrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    public virtual void FromXmlString(string xmlString);
    public virtual string ToXmlString(bool includePrivateParameters);
    public static ECDsa Create();
    public static ECDsa Create(ECCurve curve);
    public static ECDsa Create(ECParameters parameters);
}
internal static class System.Security.Cryptography.ECDsaImplementation : object {
}
public class System.Security.Cryptography.ECParameters : ValueType {
    public ECPoint Q;
    public Byte[] D;
    public ECCurve Curve;
    public void Validate();
}
public class System.Security.Cryptography.ECPoint : ValueType {
    public Byte[] X;
    public Byte[] Y;
}
public class System.Security.Cryptography.HMACMD5 : HMAC {
    private HMACCommon _hMacCommon;
    public Byte[] Key { get; public set; }
    public HMACMD5(Byte[] key);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    protected virtual void HashCore(Byte[] rgb, int ib, int cb);
    protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    protected virtual Byte[] HashFinal();
    protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
    public virtual void Initialize();
    protected virtual void Dispose(bool disposing);
}
public class System.Security.Cryptography.HMACSHA1 : HMAC {
    private HMACCommon _hMacCommon;
    public Byte[] Key { get; public set; }
    public HMACSHA1(Byte[] key);
    [EditorBrowsableAttribute("1")]
public HMACSHA1(Byte[] key, bool useManagedSha1);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    protected virtual void HashCore(Byte[] rgb, int ib, int cb);
    protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    protected virtual Byte[] HashFinal();
    protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
    public virtual void Initialize();
    protected virtual void Dispose(bool disposing);
}
public class System.Security.Cryptography.HMACSHA256 : HMAC {
    private HMACCommon _hMacCommon;
    public Byte[] Key { get; public set; }
    public HMACSHA256(Byte[] key);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    protected virtual void HashCore(Byte[] rgb, int ib, int cb);
    protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    protected virtual Byte[] HashFinal();
    protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
    public virtual void Initialize();
    protected virtual void Dispose(bool disposing);
}
public class System.Security.Cryptography.HMACSHA384 : HMAC {
    private HMACCommon _hMacCommon;
    public bool ProduceLegacyHmacValues { get; public set; }
    public Byte[] Key { get; public set; }
    public HMACSHA384(Byte[] key);
    public bool get_ProduceLegacyHmacValues();
    public void set_ProduceLegacyHmacValues(bool value);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    protected virtual void HashCore(Byte[] rgb, int ib, int cb);
    protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    protected virtual Byte[] HashFinal();
    protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
    public virtual void Initialize();
    protected virtual void Dispose(bool disposing);
}
public class System.Security.Cryptography.HMACSHA512 : HMAC {
    private HMACCommon _hMacCommon;
    public bool ProduceLegacyHmacValues { get; public set; }
    public Byte[] Key { get; public set; }
    public HMACSHA512(Byte[] key);
    public bool get_ProduceLegacyHmacValues();
    public void set_ProduceLegacyHmacValues(bool value);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    protected virtual void HashCore(Byte[] rgb, int ib, int cb);
    protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    protected virtual Byte[] HashFinal();
    protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
    public virtual void Initialize();
    protected virtual void Dispose(bool disposing);
}
public class System.Security.Cryptography.IncrementalHash : object {
    private HashAlgorithmName _algorithmName;
    private HashProvider _hash;
    private HMACCommon _hmac;
    private bool _disposed;
    public HashAlgorithmName AlgorithmName { get; }
    private IncrementalHash(HashAlgorithmName name, HashProvider hash);
    private IncrementalHash(HashAlgorithmName name, HMACCommon hmac);
    public HashAlgorithmName get_AlgorithmName();
    public void AppendData(Byte[] data);
    public void AppendData(Byte[] data, int offset, int count);
    public void AppendData(ReadOnlySpan`1<byte> data);
    public Byte[] GetHashAndReset();
    public bool TryGetHashAndReset(Span`1<byte> destination, Int32& bytesWritten);
    public sealed virtual void Dispose();
    public static IncrementalHash CreateHash(HashAlgorithmName hashAlgorithm);
    public static IncrementalHash CreateHMAC(HashAlgorithmName hashAlgorithm, Byte[] key);
}
[ExtensionAttribute]
internal static class System.Security.Cryptography.KeyBlobHelpers : object {
    [ExtensionAttribute]
internal static Byte[] ExportKeyParameter(BigInteger value, int length);
    [ExtensionAttribute]
internal static void WriteKeyParameterInteger(AsnWriter writer, ReadOnlySpan`1<byte> integer);
}
internal static class System.Security.Cryptography.KeyFormatHelper : object {
    internal static void ReadSubjectPublicKeyInfo(String[] validOids, ReadOnlySpan`1<byte> source, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    internal static ReadOnlyMemory`1<byte> ReadSubjectPublicKeyInfo(String[] validOids, ReadOnlyMemory`1<byte> source, Int32& bytesRead);
    private static void ReadSubjectPublicKeyInfo(String[] validOids, ReadOnlyMemory`1<byte> source, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    internal static void ReadPkcs8(String[] validOids, ReadOnlySpan`1<byte> source, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    internal static ReadOnlyMemory`1<byte> ReadPkcs8(String[] validOids, ReadOnlyMemory`1<byte> source, Int32& bytesRead);
    private static void ReadPkcs8(String[] validOids, ReadOnlyMemory`1<byte> source, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    internal static void ReadEncryptedPkcs8(String[] validOids, ReadOnlySpan`1<byte> source, ReadOnlySpan`1<char> password, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    internal static void ReadEncryptedPkcs8(String[] validOids, ReadOnlySpan`1<byte> source, ReadOnlySpan`1<byte> passwordBytes, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    private static void ReadEncryptedPkcs8(String[] validOids, ReadOnlyMemory`1<byte> source, ReadOnlySpan`1<char> password, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    private static void ReadEncryptedPkcs8(String[] validOids, ReadOnlyMemory`1<byte> source, ReadOnlySpan`1<byte> passwordBytes, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    private static void ReadEncryptedPkcs8(String[] validOids, ReadOnlyMemory`1<byte> source, ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> passwordBytes, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    internal static AsnWriter WritePkcs8(AsnWriter algorithmIdentifierWriter, AsnWriter privateKeyWriter);
    internal static AsnWriter WriteEncryptedPkcs8(ReadOnlySpan`1<char> password, AsnWriter pkcs8Writer, PbeParameters pbeParameters);
    internal static AsnWriter WriteEncryptedPkcs8(ReadOnlySpan`1<byte> passwordBytes, AsnWriter pkcs8Writer, PbeParameters pbeParameters);
    private static AsnWriter WriteEncryptedPkcs8(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> passwordBytes, AsnWriter pkcs8Writer, PbeParameters pbeParameters);
    internal static ArraySegment`1<byte> DecryptPkcs8(ReadOnlySpan`1<char> inputPassword, ReadOnlyMemory`1<byte> source, Int32& bytesRead);
    internal static ArraySegment`1<byte> DecryptPkcs8(ReadOnlySpan`1<byte> inputPasswordBytes, ReadOnlyMemory`1<byte> source, Int32& bytesRead);
    private static ArraySegment`1<byte> DecryptPkcs8(ReadOnlySpan`1<char> inputPassword, ReadOnlySpan`1<byte> inputPasswordBytes, ReadOnlyMemory`1<byte> source, Int32& bytesRead);
    internal static AsnWriter ReencryptPkcs8(ReadOnlySpan`1<char> inputPassword, ReadOnlyMemory`1<byte> current, ReadOnlySpan`1<char> newPassword, PbeParameters pbeParameters);
    internal static AsnWriter ReencryptPkcs8(ReadOnlySpan`1<char> inputPassword, ReadOnlyMemory`1<byte> current, ReadOnlySpan`1<byte> newPasswordBytes, PbeParameters pbeParameters);
}
[ExtensionAttribute]
internal static class System.Security.Cryptography.KeySizeHelpers : object {
    [ExtensionAttribute]
public static KeySizes[] CloneKeySizesArray(KeySizes[] src);
    [ExtensionAttribute]
public static bool IsLegalSize(int size, KeySizes legalSizes);
    [ExtensionAttribute]
public static bool IsLegalSize(int size, KeySizes[] legalSizes);
    [ExtensionAttribute]
public static bool IsLegalSize(int size, KeySizes legalSizes, Boolean& validatedByZeroSkipSizeKeySizes);
    [ExtensionAttribute]
public static bool IsLegalSize(int size, KeySizes[] legalSizes, Boolean& validatedByZeroSkipSizeKeySizes);
}
public abstract class System.Security.Cryptography.MaskGenerationMethod : object {
    public abstract virtual Byte[] GenerateMask(Byte[] rgbSeed, int cbReturn);
}
public abstract class System.Security.Cryptography.MD5 : HashAlgorithm {
    public static MD5 Create();
    public static MD5 Create(string algName);
}
internal static class System.Security.Cryptography.PasswordBasedEncryption : object {
    private static CryptographicException AlgorithmKdfRequiresChars(string algId);
    internal static void ValidatePbeParameters(PbeParameters pbeParameters, ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> passwordBytes);
    internal static int Decrypt(AlgorithmIdentifierAsn& algorithmIdentifier, ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> encryptedData, Span`1<byte> destination);
    internal static void InitiateEncryption(PbeParameters pbeParameters, SymmetricAlgorithm& cipher, String& hmacOid, String& encryptionAlgorithmOid, Boolean& isPkcs12);
    internal static int Encrypt(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> passwordBytes, SymmetricAlgorithm cipher, bool isPkcs12, ReadOnlySpan`1<byte> source, PbeParameters pbeParameters, ReadOnlySpan`1<byte> salt, Byte[] destination, Span`1<byte> ivDest);
    private static int Pbes2Decrypt(Nullable`1<ReadOnlyMemory`1<byte>> algorithmParameters, ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> encryptedData, Span`1<byte> destination);
    private static int Pbes2Decrypt(Nullable`1<ReadOnlyMemory`1<byte>> algorithmParameters, ReadOnlySpan`1<byte> password, ReadOnlySpan`1<byte> encryptedData, Span`1<byte> destination);
    private static SymmetricAlgorithm OpenCipher(AlgorithmIdentifierAsn encryptionScheme, Nullable`1<byte> requestedKeyLength, Span`1& iv);
    private static void ReadIvParameter(Nullable`1<ReadOnlyMemory`1<byte>> encryptionSchemeParameters, int length, Span`1& iv);
    private static Rfc2898DeriveBytes OpenPbkdf2(ReadOnlySpan`1<byte> password, Nullable`1<ReadOnlyMemory`1<byte>> parameters, Nullable`1& requestedKeyLength);
    private static int Pbes1Decrypt(Nullable`1<ReadOnlyMemory`1<byte>> algorithmParameters, ReadOnlySpan`1<byte> password, IncrementalHash hasher, SymmetricAlgorithm cipher, ReadOnlySpan`1<byte> encryptedData, Span`1<byte> destination);
    private static int Pkcs12PbeDecrypt(AlgorithmIdentifierAsn algorithmIdentifier, ReadOnlySpan`1<char> password, HashAlgorithmName hashAlgorithm, SymmetricAlgorithm cipher, ReadOnlySpan`1<byte> encryptedData, Span`1<byte> destination);
    private static int Decrypt(SymmetricAlgorithm cipher, ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> iv, ReadOnlySpan`1<byte> encryptedData, Span`1<byte> destination);
    private static void Pbkdf1(IncrementalHash hasher, ReadOnlySpan`1<byte> password, ReadOnlySpan`1<byte> salt, int iterationCount, Span`1<byte> dk);
    internal static void WritePbeAlgorithmIdentifier(AsnWriter writer, bool isPkcs12, string encryptionAlgorithmOid, Span`1<byte> salt, int iterationCount, string hmacOid, Span`1<byte> iv);
    internal static int NormalizeIterationCount(int iterationCount);
}
internal static class System.Security.Cryptography.Pkcs.Pkcs12Kdf : object {
    private static Dictionary`2<HashAlgorithmName, Tuple`2<int, int>> s_uvLookup;
    private static Pkcs12Kdf();
    internal static void DeriveCipherKey(ReadOnlySpan`1<char> password, HashAlgorithmName hashAlgorithm, int iterationCount, ReadOnlySpan`1<byte> salt, Span`1<byte> destination);
    internal static void DeriveIV(ReadOnlySpan`1<char> password, HashAlgorithmName hashAlgorithm, int iterationCount, ReadOnlySpan`1<byte> salt, Span`1<byte> destination);
    private static void Derive(ReadOnlySpan`1<char> password, HashAlgorithmName hashAlgorithm, int iterationCount, byte id, ReadOnlySpan`1<byte> salt, Span`1<byte> destination);
    private static void AddPlusOne(Span`1<byte> into, Span`1<byte> addend);
    private static void CircularCopy(ReadOnlySpan`1<byte> bytes, Span`1<byte> destination);
    private static void CircularCopyUtf16BE(ReadOnlySpan`1<char> password, Span`1<byte> destination);
}
public class System.Security.Cryptography.PKCS1MaskGenerationMethod : MaskGenerationMethod {
    private string _hashNameValue;
    public string HashName { get; public set; }
    public string get_HashName();
    public void set_HashName(string value);
    public virtual Byte[] GenerateMask(Byte[] rgbSeed, int cbReturn);
}
public abstract class System.Security.Cryptography.RandomNumberGenerator : object {
    public static RandomNumberGenerator Create();
    public static RandomNumberGenerator Create(string rngName);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public abstract virtual void GetBytes(Byte[] data);
    public virtual void GetBytes(Byte[] data, int offset, int count);
    public virtual void GetBytes(Span`1<byte> data);
    public virtual void GetNonZeroBytes(Byte[] data);
    public virtual void GetNonZeroBytes(Span`1<byte> data);
    public static void Fill(Span`1<byte> data);
    public static int GetInt32(int fromInclusive, int toExclusive);
    public static int GetInt32(int toExclusive);
    internal void VerifyGetBytes(Byte[] data, int offset, int count);
}
internal class System.Security.Cryptography.RandomNumberGeneratorImplementation : RandomNumberGenerator {
    internal static void FillSpan(Span`1<byte> data);
    public virtual void GetBytes(Byte[] data);
    public virtual void GetBytes(Byte[] data, int offset, int count);
    public virtual void GetBytes(Span`1<byte> data);
    public virtual void GetNonZeroBytes(Byte[] data);
    public virtual void GetNonZeroBytes(Span`1<byte> data);
    private static void GetBytes(Byte* pbBuffer, int count);
}
[EditorBrowsableAttribute("1")]
public abstract class System.Security.Cryptography.RC2 : SymmetricAlgorithm {
    protected int EffectiveKeySizeValue;
    private static KeySizes[] s_legalBlockSizes;
    private static KeySizes[] s_legalKeySizes;
    public int KeySize { get; public set; }
    public int EffectiveKeySize { get; public set; }
    private static RC2();
    public static RC2 Create();
    public static RC2 Create(string AlgName);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual int get_EffectiveKeySize();
    public virtual void set_EffectiveKeySize(int value);
}
public class System.Security.Cryptography.Rfc2898DeriveBytes : DeriveBytes {
    private Byte[] _password;
    private Byte[] _salt;
    private UInt32 _iterations;
    private HMAC _hmac;
    private int _blockSize;
    private Byte[] _buffer;
    private UInt32 _block;
    private int _startIndex;
    private int _endIndex;
    [CompilerGeneratedAttribute]
private HashAlgorithmName <HashAlgorithm>k__BackingField;
    public HashAlgorithmName HashAlgorithm { get; }
    public int IterationCount { get; public set; }
    public Byte[] Salt { get; public set; }
    public Rfc2898DeriveBytes(Byte[] password, Byte[] salt, int iterations);
    public Rfc2898DeriveBytes(Byte[] password, Byte[] salt, int iterations, HashAlgorithmName hashAlgorithm);
    public Rfc2898DeriveBytes(string password, Byte[] salt);
    public Rfc2898DeriveBytes(string password, Byte[] salt, int iterations);
    public Rfc2898DeriveBytes(string password, Byte[] salt, int iterations, HashAlgorithmName hashAlgorithm);
    public Rfc2898DeriveBytes(string password, int saltSize);
    public Rfc2898DeriveBytes(string password, int saltSize, int iterations);
    public Rfc2898DeriveBytes(string password, int saltSize, int iterations, HashAlgorithmName hashAlgorithm);
    [CompilerGeneratedAttribute]
public HashAlgorithmName get_HashAlgorithm();
    public int get_IterationCount();
    public void set_IterationCount(int value);
    public Byte[] get_Salt();
    public void set_Salt(Byte[] value);
    protected virtual void Dispose(bool disposing);
    public virtual Byte[] GetBytes(int cb);
    public Byte[] CryptDeriveKey(string algname, string alghashname, int keySize, Byte[] rgbIV);
    public virtual void Reset();
    private HMAC OpenHmac();
    private void Initialize();
    private void Func();
}
[EditorBrowsableAttribute("1")]
public abstract class System.Security.Cryptography.Rijndael : SymmetricAlgorithm {
    private static KeySizes[] s_legalBlockSizes;
    private static KeySizes[] s_legalKeySizes;
    private static Rijndael();
    public static Rijndael Create();
    public static Rijndael Create(string algName);
}
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.RijndaelManaged : Rijndael {
    private Aes _impl;
    public int BlockSize { get; public set; }
    public Byte[] IV { get; public set; }
    public Byte[] Key { get; public set; }
    public int KeySize { get; public set; }
    public CipherMode Mode { get; public set; }
    public PaddingMode Padding { get; public set; }
    public KeySizes[] LegalKeySizes { get; }
    public virtual int get_BlockSize();
    public virtual void set_BlockSize(int value);
    public virtual Byte[] get_IV();
    public virtual void set_IV(Byte[] value);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual CipherMode get_Mode();
    public virtual void set_Mode(CipherMode value);
    public virtual PaddingMode get_Padding();
    public virtual void set_Padding(PaddingMode value);
    public virtual KeySizes[] get_LegalKeySizes();
    public virtual ICryptoTransform CreateEncryptor();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateDecryptor();
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual void GenerateIV();
    public virtual void GenerateKey();
    protected virtual void Dispose(bool disposing);
}
public abstract class System.Security.Cryptography.RSA : AsymmetricAlgorithm {
    public string KeyExchangeAlgorithm { get; }
    public string SignatureAlgorithm { get; }
    public static RSA Create(string algName);
    public static RSA Create(int keySizeInBits);
    public static RSA Create(RSAParameters parameters);
    public abstract virtual RSAParameters ExportParameters(bool includePrivateParameters);
    public abstract virtual void ImportParameters(RSAParameters parameters);
    public virtual Byte[] Encrypt(Byte[] data, RSAEncryptionPadding padding);
    public virtual Byte[] Decrypt(Byte[] data, RSAEncryptionPadding padding);
    public virtual Byte[] SignHash(Byte[] hash, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual bool VerifyHash(Byte[] hash, Byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    protected virtual Byte[] HashData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    protected virtual Byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm);
    public virtual bool TryDecrypt(ReadOnlySpan`1<byte> data, Span`1<byte> destination, RSAEncryptionPadding padding, Int32& bytesWritten);
    public virtual bool TryEncrypt(ReadOnlySpan`1<byte> data, Span`1<byte> destination, RSAEncryptionPadding padding, Int32& bytesWritten);
    protected virtual bool TryHashData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, Int32& bytesWritten);
    public virtual bool TrySignHash(ReadOnlySpan`1<byte> hash, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding, Int32& bytesWritten);
    public virtual bool VerifyHash(ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    private static Exception DerivedClassMustOverride();
    public virtual Byte[] DecryptValue(Byte[] rgb);
    public virtual Byte[] EncryptValue(Byte[] rgb);
    public Byte[] SignData(Byte[] data, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual Byte[] SignData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual Byte[] SignData(Stream data, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual bool TrySignData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding, Int32& bytesWritten);
    public bool VerifyData(Byte[] data, Byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual bool VerifyData(Byte[] data, int offset, int count, Byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public bool VerifyData(Stream data, Byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual bool VerifyData(ReadOnlySpan`1<byte> data, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual Byte[] ExportRSAPrivateKey();
    public virtual bool TryExportRSAPrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    public virtual Byte[] ExportRSAPublicKey();
    public virtual bool TryExportRSAPublicKey(Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportSubjectPublicKeyInfo(Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportPkcs8PrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    private AsnWriter WritePkcs8PrivateKey();
    public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    private AsnWriter WritePkcs1PublicKey();
    private AsnWriter WritePkcs1PrivateKey();
    public virtual void ImportSubjectPublicKeyInfo(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportRSAPublicKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportRSAPrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportPkcs8PrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    private static void ClearPrivateParameters(RSAParameters& rsaParameters);
    public virtual string get_KeyExchangeAlgorithm();
    public virtual string get_SignatureAlgorithm();
    private static Exception HashAlgorithmNameNullOrEmpty();
    private static Byte[] ReadRequiredElement(ParseState& state, string name, int sizeHint);
    public virtual void FromXmlString(string xmlString);
    public virtual string ToXmlString(bool includePrivateParameters);
    public static RSA Create();
}
public class System.Security.Cryptography.RSAEncryptionPadding : object {
    private static RSAEncryptionPadding s_pkcs1;
    private static RSAEncryptionPadding s_oaepSHA1;
    private static RSAEncryptionPadding s_oaepSHA256;
    private static RSAEncryptionPadding s_oaepSHA384;
    private static RSAEncryptionPadding s_oaepSHA512;
    private RSAEncryptionPaddingMode _mode;
    private HashAlgorithmName _oaepHashAlgorithm;
    public static RSAEncryptionPadding Pkcs1 { get; }
    public static RSAEncryptionPadding OaepSHA1 { get; }
    public static RSAEncryptionPadding OaepSHA256 { get; }
    public static RSAEncryptionPadding OaepSHA384 { get; }
    public static RSAEncryptionPadding OaepSHA512 { get; }
    public RSAEncryptionPaddingMode Mode { get; }
    public HashAlgorithmName OaepHashAlgorithm { get; }
    private RSAEncryptionPadding(RSAEncryptionPaddingMode mode, HashAlgorithmName oaepHashAlgorithm);
    private static RSAEncryptionPadding();
    public static RSAEncryptionPadding get_Pkcs1();
    public static RSAEncryptionPadding get_OaepSHA1();
    public static RSAEncryptionPadding get_OaepSHA256();
    public static RSAEncryptionPadding get_OaepSHA384();
    public static RSAEncryptionPadding get_OaepSHA512();
    public static RSAEncryptionPadding CreateOaep(HashAlgorithmName hashAlgorithm);
    public RSAEncryptionPaddingMode get_Mode();
    public HashAlgorithmName get_OaepHashAlgorithm();
    public virtual int GetHashCode();
    private static int CombineHashCodes(int h1, int h2);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(RSAEncryptionPadding other);
    public static bool op_Equality(RSAEncryptionPadding left, RSAEncryptionPadding right);
    public static bool op_Inequality(RSAEncryptionPadding left, RSAEncryptionPadding right);
    public virtual string ToString();
}
public enum System.Security.Cryptography.RSAEncryptionPaddingMode : Enum {
    public int value__;
    public static RSAEncryptionPaddingMode Pkcs1;
    public static RSAEncryptionPaddingMode Oaep;
}
internal static class System.Security.Cryptography.RSAImplementation : object {
}
internal static class System.Security.Cryptography.RSAKeyFormatHelper : object {
    private static String[] s_validOids;
    private static RSAKeyFormatHelper();
    internal static void FromPkcs1PrivateKey(ReadOnlyMemory`1<byte> keyData, AlgorithmIdentifierAsn& algId, RSAParameters& ret);
    internal static void ReadRsaPublicKey(ReadOnlyMemory`1<byte> keyData, AlgorithmIdentifierAsn& algId, RSAParameters& ret);
    internal static ReadOnlyMemory`1<byte> ReadSubjectPublicKeyInfo(ReadOnlyMemory`1<byte> source, Int32& bytesRead);
    internal static ReadOnlyMemory`1<byte> ReadPkcs8(ReadOnlyMemory`1<byte> source, Int32& bytesRead);
    internal static void ReadEncryptedPkcs8(ReadOnlySpan`1<byte> source, ReadOnlySpan`1<char> password, Int32& bytesRead, RSAParameters& key);
    internal static void ReadEncryptedPkcs8(ReadOnlySpan`1<byte> source, ReadOnlySpan`1<byte> passwordBytes, Int32& bytesRead, RSAParameters& key);
    internal static AsnWriter WriteSubjectPublicKeyInfo(ReadOnlySpan`1& pkcs1PublicKey);
    internal static AsnWriter WritePkcs8PrivateKey(ReadOnlySpan`1& pkcs1PrivateKey);
    private static void WriteAlgorithmIdentifier(AsnWriter writer);
    internal static AsnWriter WritePkcs1PublicKey(RSAParameters& rsaParameters);
    internal static AsnWriter WritePkcs1PrivateKey(RSAParameters& rsaParameters);
}
public class System.Security.Cryptography.RSAOAEPKeyExchangeDeformatter : AsymmetricKeyExchangeDeformatter {
    private RSA _rsaKey;
    public string Parameters { get; public set; }
    public RSAOAEPKeyExchangeDeformatter(AsymmetricAlgorithm key);
    public virtual string get_Parameters();
    public virtual void set_Parameters(string value);
    public virtual Byte[] DecryptKeyExchange(Byte[] rgbData);
    public virtual void SetKey(AsymmetricAlgorithm key);
}
public class System.Security.Cryptography.RSAOAEPKeyExchangeFormatter : AsymmetricKeyExchangeFormatter {
    private Byte[] ParameterValue;
    private RSA _rsaKey;
    private RandomNumberGenerator RngValue;
    public Byte[] Parameter { get; public set; }
    public string Parameters { get; }
    public RandomNumberGenerator Rng { get; public set; }
    public RSAOAEPKeyExchangeFormatter(AsymmetricAlgorithm key);
    public Byte[] get_Parameter();
    public void set_Parameter(Byte[] value);
    public virtual string get_Parameters();
    public RandomNumberGenerator get_Rng();
    public void set_Rng(RandomNumberGenerator value);
    public virtual void SetKey(AsymmetricAlgorithm key);
    public virtual Byte[] CreateKeyExchange(Byte[] rgbData, Type symAlgType);
    public virtual Byte[] CreateKeyExchange(Byte[] rgbData);
}
internal class System.Security.Cryptography.RsaPaddingProcessor : object {
    private static Byte[] s_eightZeros;
    private static ConcurrentDictionary`2<HashAlgorithmName, RsaPaddingProcessor> s_lookup;
    private HashAlgorithmName _hashAlgorithmName;
    private int _hLen;
    private RsaPaddingProcessor(HashAlgorithmName hashAlgorithmName, int hLen);
    private static RsaPaddingProcessor();
    internal static int BytesRequiredForBitCount(int keySizeInBits);
    internal static RsaPaddingProcessor OpenProcessor(HashAlgorithmName hashAlgorithmName);
    internal static void PadPkcs1Encryption(ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    internal void PadOaep(ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    private void Mgf1(IncrementalHash hasher, ReadOnlySpan`1<byte> mgfSeed, Span`1<byte> mask);
    private static void FillNonZeroBytes(Span`1<byte> data);
    private static void Xor(Span`1<byte> a, ReadOnlySpan`1<byte> b);
}
public class System.Security.Cryptography.RSAParameters : ValueType {
    public Byte[] D;
    public Byte[] DP;
    public Byte[] DQ;
    public Byte[] Exponent;
    public Byte[] InverseQ;
    public Byte[] Modulus;
    public Byte[] P;
    public Byte[] Q;
}
public class System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter : AsymmetricKeyExchangeDeformatter {
    private RSA _rsaKey;
    private RandomNumberGenerator RngValue;
    public RandomNumberGenerator RNG { get; public set; }
    public string Parameters { get; public set; }
    public RSAPKCS1KeyExchangeDeformatter(AsymmetricAlgorithm key);
    public RandomNumberGenerator get_RNG();
    public void set_RNG(RandomNumberGenerator value);
    public virtual string get_Parameters();
    public virtual void set_Parameters(string value);
    public virtual Byte[] DecryptKeyExchange(Byte[] rgbIn);
    public virtual void SetKey(AsymmetricAlgorithm key);
}
public class System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter : AsymmetricKeyExchangeFormatter {
    private RSA _rsaKey;
    private RandomNumberGenerator RngValue;
    public string Parameters { get; }
    public RandomNumberGenerator Rng { get; public set; }
    public RSAPKCS1KeyExchangeFormatter(AsymmetricAlgorithm key);
    public virtual string get_Parameters();
    public RandomNumberGenerator get_Rng();
    public void set_Rng(RandomNumberGenerator value);
    public virtual void SetKey(AsymmetricAlgorithm key);
    public virtual Byte[] CreateKeyExchange(Byte[] rgbData, Type symAlgType);
    public virtual Byte[] CreateKeyExchange(Byte[] rgbData);
}
public class System.Security.Cryptography.RSAPKCS1SignatureDeformatter : AsymmetricSignatureDeformatter {
    private RSA _rsaKey;
    private string _algName;
    public RSAPKCS1SignatureDeformatter(AsymmetricAlgorithm key);
    public virtual void SetKey(AsymmetricAlgorithm key);
    public virtual void SetHashAlgorithm(string strName);
    public virtual bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature);
}
public class System.Security.Cryptography.RSAPKCS1SignatureFormatter : AsymmetricSignatureFormatter {
    private RSA _rsaKey;
    private string _algName;
    public RSAPKCS1SignatureFormatter(AsymmetricAlgorithm key);
    public virtual void SetKey(AsymmetricAlgorithm key);
    public virtual void SetHashAlgorithm(string strName);
    public virtual Byte[] CreateSignature(Byte[] rgbHash);
}
public class System.Security.Cryptography.RSASignaturePadding : object {
    private static RSASignaturePadding s_pkcs1;
    private static RSASignaturePadding s_pss;
    private RSASignaturePaddingMode _mode;
    public static RSASignaturePadding Pkcs1 { get; }
    public static RSASignaturePadding Pss { get; }
    public RSASignaturePaddingMode Mode { get; }
    private RSASignaturePadding(RSASignaturePaddingMode mode);
    private static RSASignaturePadding();
    public static RSASignaturePadding get_Pkcs1();
    public static RSASignaturePadding get_Pss();
    public RSASignaturePaddingMode get_Mode();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(RSASignaturePadding other);
    public static bool op_Equality(RSASignaturePadding left, RSASignaturePadding right);
    public static bool op_Inequality(RSASignaturePadding left, RSASignaturePadding right);
    public virtual string ToString();
}
public enum System.Security.Cryptography.RSASignaturePaddingMode : Enum {
    public int value__;
    public static RSASignaturePaddingMode Pkcs1;
    public static RSASignaturePaddingMode Pss;
}
public abstract class System.Security.Cryptography.SHA1 : HashAlgorithm {
    public static SHA1 Create();
    public static SHA1 Create(string hashName);
}
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.SHA1Managed : SHA1 {
    private HashProvider _hashProvider;
    protected sealed virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected sealed virtual void HashCore(ReadOnlySpan`1<byte> source);
    protected sealed virtual Byte[] HashFinal();
    protected sealed virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
    public sealed virtual void Initialize();
    protected sealed virtual void Dispose(bool disposing);
}
public abstract class System.Security.Cryptography.SHA256 : HashAlgorithm {
    public static SHA256 Create();
    public static SHA256 Create(string hashName);
}
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.SHA256Managed : SHA256 {
    private HashProvider _hashProvider;
    protected sealed virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected sealed virtual void HashCore(ReadOnlySpan`1<byte> source);
    protected sealed virtual Byte[] HashFinal();
    protected sealed virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
    public sealed virtual void Initialize();
    protected sealed virtual void Dispose(bool disposing);
}
public abstract class System.Security.Cryptography.SHA384 : HashAlgorithm {
    public static SHA384 Create();
    public static SHA384 Create(string hashName);
}
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.SHA384Managed : SHA384 {
    private HashProvider _hashProvider;
    protected sealed virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected sealed virtual void HashCore(ReadOnlySpan`1<byte> source);
    protected sealed virtual Byte[] HashFinal();
    protected sealed virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
    public sealed virtual void Initialize();
    protected sealed virtual void Dispose(bool disposing);
}
public abstract class System.Security.Cryptography.SHA512 : HashAlgorithm {
    public static SHA512 Create();
    public static SHA512 Create(string hashName);
}
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.SHA512Managed : SHA512 {
    private HashProvider _hashProvider;
    protected sealed virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected sealed virtual void HashCore(ReadOnlySpan`1<byte> source);
    protected sealed virtual Byte[] HashFinal();
    protected sealed virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
    public sealed virtual void Initialize();
    protected sealed virtual void Dispose(bool disposing);
}
public class System.Security.Cryptography.SignatureDescription : object {
    [CompilerGeneratedAttribute]
private string <KeyAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DigestAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FormatterAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeformatterAlgorithm>k__BackingField;
    public string KeyAlgorithm { get; public set; }
    public string DigestAlgorithm { get; public set; }
    public string FormatterAlgorithm { get; public set; }
    public string DeformatterAlgorithm { get; public set; }
    public SignatureDescription(SecurityElement el);
    [CompilerGeneratedAttribute]
public string get_KeyAlgorithm();
    [CompilerGeneratedAttribute]
public void set_KeyAlgorithm(string value);
    [CompilerGeneratedAttribute]
public string get_DigestAlgorithm();
    [CompilerGeneratedAttribute]
public void set_DigestAlgorithm(string value);
    [CompilerGeneratedAttribute]
public string get_FormatterAlgorithm();
    [CompilerGeneratedAttribute]
public void set_FormatterAlgorithm(string value);
    [CompilerGeneratedAttribute]
public string get_DeformatterAlgorithm();
    [CompilerGeneratedAttribute]
public void set_DeformatterAlgorithm(string value);
    public virtual AsymmetricSignatureDeformatter CreateDeformatter(AsymmetricAlgorithm key);
    public virtual AsymmetricSignatureFormatter CreateFormatter(AsymmetricAlgorithm key);
    public virtual HashAlgorithm CreateDigest();
}
public abstract class System.Security.Cryptography.TripleDES : SymmetricAlgorithm {
    private static KeySizes[] s_legalBlockSizes;
    private static KeySizes[] s_legalKeySizes;
    public Byte[] Key { get; public set; }
    private static TripleDES();
    public static TripleDES Create();
    public static TripleDES Create(string str);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public static bool IsWeakKey(Byte[] rgbKey);
    private static bool EqualBytes(Byte[] rgbKey, int start1, int start2, int count);
}
internal static class System.Security.Cryptography.XmlKeyHelper : object {
    internal static ParseState ParseDocument(string xmlString);
    internal static bool HasElement(ParseState& state, string name);
    internal static Byte[] ReadCryptoBinary(ParseState& state, string name, int sizeHint);
    internal static int ReadCryptoBinaryInt32(Byte[] buf);
    internal static void WriteCryptoBinary(string name, int value, StringBuilder builder);
    internal static void WriteCryptoBinary(string name, ReadOnlySpan`1<byte> value, StringBuilder builder);
}
internal static class System.SR : object {
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string ArgumentOutOfRange_NeedNonNegNum { get; }
    internal static string ArgumentOutOfRange_NeedPosNum { get; }
    internal static string Argument_InvalidRandomRange { get; }
    internal static string Argument_InvalidOffLen { get; }
    internal static string Argument_InvalidOidValue { get; }
    internal static string Argument_InvalidValue { get; }
    internal static string ArgumentNull_Buffer { get; }
    internal static string Cryptography_AlgKdfRequiresChars { get; }
    internal static string Cryptography_ArgECDHKeySizeMismatch { get; }
    internal static string Cryptography_ArgECDHRequiresECDHKey { get; }
    internal static string Cryptography_Asn_UniversalValueIsFixed { get; }
    internal static string Cryptography_Asn_UnusedBitCountRange { get; }
    internal static string Cryptography_AsnWriter_EncodeUnbalancedStack { get; }
    internal static string Cryptography_AsnWriter_PopWrongTag { get; }
    internal static string Cryptography_AuthTagMismatch { get; }
    internal static string Cryptography_Config_EncodedOIDError { get; }
    internal static string Cryptography_CSP_NoPrivateKey { get; }
    internal static string Cryptography_Der_Invalid_Encoding { get; }
    internal static string Cryptography_Encryption_MessageTooLong { get; }
    internal static string Cryptography_ECXmlSerializationFormatRequired { get; }
    internal static string Cryptography_ECC_NamedCurvesOnly { get; }
    internal static string Cryptography_FromXmlParseError { get; }
    internal static string Cryptography_HashAlgorithmNameNullOrEmpty { get; }
    internal static string Cryptography_InvalidOID { get; }
    internal static string Cryptography_CurveNotSupported { get; }
    internal static string Cryptography_InvalidCurveOid { get; }
    internal static string Cryptography_InvalidCurveKeyParameters { get; }
    internal static string Cryptography_InvalidDsaParameters_MissingFields { get; }
    internal static string Cryptography_InvalidDsaParameters_MismatchedPGY { get; }
    internal static string Cryptography_InvalidDsaParameters_MismatchedQX { get; }
    internal static string Cryptography_InvalidDsaParameters_MismatchedPJ { get; }
    internal static string Cryptography_InvalidDsaParameters_SeedRestriction_ShortKey { get; }
    internal static string Cryptography_InvalidDsaParameters_QRestriction_ShortKey { get; }
    internal static string Cryptography_InvalidDsaParameters_QRestriction_LargeKey { get; }
    internal static string Cryptography_InvalidFromXmlString { get; }
    internal static string Cryptography_InvalidECCharacteristic2Curve { get; }
    internal static string Cryptography_InvalidECPrimeCurve { get; }
    internal static string Cryptography_InvalidECNamedCurve { get; }
    internal static string Cryptography_InvalidKeySize { get; }
    internal static string Cryptography_InvalidKey_SemiWeak { get; }
    internal static string Cryptography_InvalidKey_Weak { get; }
    internal static string Cryptography_InvalidNonceLength { get; }
    internal static string Cryptography_InvalidTagLength { get; }
    internal static string Cryptography_InvalidIVSize { get; }
    internal static string Cryptography_InvalidOperation { get; }
    internal static string Cryptography_InvalidPadding { get; }
    internal static string Cryptography_InvalidRsaParameters { get; }
    internal static string Cryptography_KeyTooSmall { get; }
    internal static string Cryptography_MissingIV { get; }
    internal static string Cryptography_MissingKey { get; }
    internal static string Cryptography_MissingOID { get; }
    internal static string Cryptography_MustTransformWholeBlock { get; }
    internal static string Cryptography_NotValidPrivateKey { get; }
    internal static string Cryptography_NotValidPublicOrPrivateKey { get; }
    internal static string Cryptography_PartialBlock { get; }
    internal static string Cryptography_PasswordDerivedBytes_FewBytesSalt { get; }
    internal static string Cryptography_Pkcs8_EncryptedReadFailed { get; }
    internal static string Cryptography_PlaintextCiphertextLengthMismatch { get; }
    internal static string Cryptography_RC2_EKS40 { get; }
    internal static string Cryptography_RC2_EKSKS { get; }
    internal static string Cryptography_RC2_EKSKS2 { get; }
    internal static string Cryptography_Rijndael_BlockSize { get; }
    internal static string Cryptography_RSA_DecryptWrongSize { get; }
    internal static string Cryptography_RSAPrivateKey_VersionTooNew { get; }
    internal static string Cryptography_SignHash_WrongSize { get; }
    internal static string Cryptography_TransformBeyondEndOfBuffer { get; }
    internal static string Cryptography_UnknownAlgorithmIdentifier { get; }
    internal static string Cryptography_UnknownHashAlgorithm { get; }
    internal static string Cryptography_UnknownPaddingMode { get; }
    internal static string Cryptography_UnexpectedTransformTruncation { get; }
    internal static string Cryptography_UnsupportedPaddingMode { get; }
    internal static string NotSupported_Method { get; }
    internal static string NotSupported_SubclassOverride { get; }
    internal static string Cryptography_AlgorithmTypesMustBeVisible { get; }
    internal static string Cryptography_AddNullOrEmptyName { get; }
    internal static string Cryptography_WriteEncodedValue_OneValueAtATime { get; }
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static ResourceManager get_ResourceManager();
    internal static string get_ArgumentOutOfRange_NeedNonNegNum();
    internal static string get_ArgumentOutOfRange_NeedPosNum();
    internal static string get_Argument_InvalidRandomRange();
    internal static string get_Argument_InvalidOffLen();
    internal static string get_Argument_InvalidOidValue();
    internal static string get_Argument_InvalidValue();
    internal static string get_ArgumentNull_Buffer();
    internal static string get_Cryptography_AlgKdfRequiresChars();
    internal static string get_Cryptography_ArgECDHKeySizeMismatch();
    internal static string get_Cryptography_ArgECDHRequiresECDHKey();
    internal static string get_Cryptography_Asn_UniversalValueIsFixed();
    internal static string get_Cryptography_Asn_UnusedBitCountRange();
    internal static string get_Cryptography_AsnWriter_EncodeUnbalancedStack();
    internal static string get_Cryptography_AsnWriter_PopWrongTag();
    internal static string get_Cryptography_AuthTagMismatch();
    internal static string get_Cryptography_Config_EncodedOIDError();
    internal static string get_Cryptography_CSP_NoPrivateKey();
    internal static string get_Cryptography_Der_Invalid_Encoding();
    internal static string get_Cryptography_Encryption_MessageTooLong();
    internal static string get_Cryptography_ECXmlSerializationFormatRequired();
    internal static string get_Cryptography_ECC_NamedCurvesOnly();
    internal static string get_Cryptography_FromXmlParseError();
    internal static string get_Cryptography_HashAlgorithmNameNullOrEmpty();
    internal static string get_Cryptography_InvalidOID();
    internal static string get_Cryptography_CurveNotSupported();
    internal static string get_Cryptography_InvalidCurveOid();
    internal static string get_Cryptography_InvalidCurveKeyParameters();
    internal static string get_Cryptography_InvalidDsaParameters_MissingFields();
    internal static string get_Cryptography_InvalidDsaParameters_MismatchedPGY();
    internal static string get_Cryptography_InvalidDsaParameters_MismatchedQX();
    internal static string get_Cryptography_InvalidDsaParameters_MismatchedPJ();
    internal static string get_Cryptography_InvalidDsaParameters_SeedRestriction_ShortKey();
    internal static string get_Cryptography_InvalidDsaParameters_QRestriction_ShortKey();
    internal static string get_Cryptography_InvalidDsaParameters_QRestriction_LargeKey();
    internal static string get_Cryptography_InvalidFromXmlString();
    internal static string get_Cryptography_InvalidECCharacteristic2Curve();
    internal static string get_Cryptography_InvalidECPrimeCurve();
    internal static string get_Cryptography_InvalidECNamedCurve();
    internal static string get_Cryptography_InvalidKeySize();
    internal static string get_Cryptography_InvalidKey_SemiWeak();
    internal static string get_Cryptography_InvalidKey_Weak();
    internal static string get_Cryptography_InvalidNonceLength();
    internal static string get_Cryptography_InvalidTagLength();
    internal static string get_Cryptography_InvalidIVSize();
    internal static string get_Cryptography_InvalidOperation();
    internal static string get_Cryptography_InvalidPadding();
    internal static string get_Cryptography_InvalidRsaParameters();
    internal static string get_Cryptography_KeyTooSmall();
    internal static string get_Cryptography_MissingIV();
    internal static string get_Cryptography_MissingKey();
    internal static string get_Cryptography_MissingOID();
    internal static string get_Cryptography_MustTransformWholeBlock();
    internal static string get_Cryptography_NotValidPrivateKey();
    internal static string get_Cryptography_NotValidPublicOrPrivateKey();
    internal static string get_Cryptography_PartialBlock();
    internal static string get_Cryptography_PasswordDerivedBytes_FewBytesSalt();
    internal static string get_Cryptography_Pkcs8_EncryptedReadFailed();
    internal static string get_Cryptography_PlaintextCiphertextLengthMismatch();
    internal static string get_Cryptography_RC2_EKS40();
    internal static string get_Cryptography_RC2_EKSKS();
    internal static string get_Cryptography_RC2_EKSKS2();
    internal static string get_Cryptography_Rijndael_BlockSize();
    internal static string get_Cryptography_RSA_DecryptWrongSize();
    internal static string get_Cryptography_RSAPrivateKey_VersionTooNew();
    internal static string get_Cryptography_SignHash_WrongSize();
    internal static string get_Cryptography_TransformBeyondEndOfBuffer();
    internal static string get_Cryptography_UnknownAlgorithmIdentifier();
    internal static string get_Cryptography_UnknownHashAlgorithm();
    internal static string get_Cryptography_UnknownPaddingMode();
    internal static string get_Cryptography_UnexpectedTransformTruncation();
    internal static string get_Cryptography_UnsupportedPaddingMode();
    internal static string get_NotSupported_Method();
    internal static string get_NotSupported_SubclassOverride();
    internal static string get_Cryptography_AlgorithmTypesMustBeVisible();
    internal static string get_Cryptography_AddNullOrEmptyName();
    internal static string get_Cryptography_WriteEncodedValue_OneValueAtATime();
}
