internal static class FxResources.System.Security.Cryptography.X509Certificates.SR : object {
}
internal static class Internal.Cryptography.AsymmetricAlgorithmHelpers : object {
    public static Byte[] ConvertIeee1363ToDer(ReadOnlySpan`1<byte> input);
}
[ExtensionAttribute]
internal static class Internal.Cryptography.CryptoThrowHelper : object {
    [ExtensionAttribute]
public static CryptographicException ToCryptographicException(int hr);
}
[ExtensionAttribute]
internal static class Internal.Cryptography.Helpers : object {
    [ExtensionAttribute]
public static Byte[] CloneByteArray(Byte[] src);
    [ExtensionAttribute]
public static Char[] ToHexArrayUpper(Byte[] bytes);
    private static void ToHexArrayUpper(Byte[] bytes, Span`1<char> chars);
    [ExtensionAttribute]
public static string ToHexStringUpper(Byte[] bytes);
    [ExtensionAttribute]
public static Byte[] DecodeHexString(string hexString);
    private static byte HexToByte(char val);
    private static char NibbleToHex(byte b);
    [ExtensionAttribute]
public static bool ContentsEqual(Byte[] a1, Byte[] a2);
    [ExtensionAttribute]
internal static void AddRange(ICollection`1<T> coll, IEnumerable`1<T> newData);
    [ExtensionAttribute]
public static bool IsValidDay(Calendar calendar, int year, int month, int day, int era);
    [ExtensionAttribute]
private static bool IsValidMonth(Calendar calendar, int year, int month, int era);
    [ExtensionAttribute]
private static bool IsValidYear(Calendar calendar, int year, int era);
    public static void ValidateDer(ReadOnlyMemory`1<byte> encodedValue);
}
internal interface Internal.Cryptography.ICertificatePal {
    public int Version { get; }
    public bool Archived { get; public set; }
    public string FriendlyName { get; public set; }
    public X500DistinguishedName SubjectName { get; }
    public X500DistinguishedName IssuerName { get; }
    public IEnumerable`1<X509Extension> Extensions { get; }
    public abstract virtual int get_Version();
    public abstract virtual bool get_Archived();
    public abstract virtual void set_Archived(bool value);
    public abstract virtual string get_FriendlyName();
    public abstract virtual void set_FriendlyName(string value);
    public abstract virtual X500DistinguishedName get_SubjectName();
    public abstract virtual X500DistinguishedName get_IssuerName();
    public abstract virtual IEnumerable`1<X509Extension> get_Extensions();
    public abstract virtual RSA GetRSAPrivateKey();
    public abstract virtual DSA GetDSAPrivateKey();
    public abstract virtual ECDsa GetECDsaPrivateKey();
    public abstract virtual string GetNameInfo(X509NameType nameType, bool forIssuer);
    public abstract virtual void AppendPrivateKeyInfo(StringBuilder sb);
    public abstract virtual ICertificatePal CopyWithPrivateKey(DSA privateKey);
    public abstract virtual ICertificatePal CopyWithPrivateKey(ECDsa privateKey);
    public abstract virtual ICertificatePal CopyWithPrivateKey(RSA privateKey);
}
internal interface Internal.Cryptography.ICertificatePalCore {
    public bool HasPrivateKey { get; }
    public IntPtr Handle { get; }
    public string Issuer { get; }
    public string Subject { get; }
    public string LegacyIssuer { get; }
    public string LegacySubject { get; }
    public Byte[] Thumbprint { get; }
    public string KeyAlgorithm { get; }
    public Byte[] KeyAlgorithmParameters { get; }
    public Byte[] PublicKeyValue { get; }
    public Byte[] SerialNumber { get; }
    public string SignatureAlgorithm { get; }
    public DateTime NotAfter { get; }
    public DateTime NotBefore { get; }
    public Byte[] RawData { get; }
    public abstract virtual bool get_HasPrivateKey();
    public abstract virtual IntPtr get_Handle();
    public abstract virtual string get_Issuer();
    public abstract virtual string get_Subject();
    public abstract virtual string get_LegacyIssuer();
    public abstract virtual string get_LegacySubject();
    public abstract virtual Byte[] get_Thumbprint();
    public abstract virtual string get_KeyAlgorithm();
    public abstract virtual Byte[] get_KeyAlgorithmParameters();
    public abstract virtual Byte[] get_PublicKeyValue();
    public abstract virtual Byte[] get_SerialNumber();
    public abstract virtual string get_SignatureAlgorithm();
    public abstract virtual DateTime get_NotAfter();
    public abstract virtual DateTime get_NotBefore();
    public abstract virtual Byte[] get_RawData();
    public abstract virtual Byte[] Export(X509ContentType contentType, SafePasswordHandle password);
}
[ExtensionAttribute]
internal static class Internal.Cryptography.Pal.CertificateExtensionsCommon : object {
    [ExtensionAttribute]
public static T GetPublicKey(X509Certificate2 certificate, Predicate`1<X509Certificate2> matchesConstraints);
    [ExtensionAttribute]
public static T GetPrivateKey(X509Certificate2 certificate, Predicate`1<X509Certificate2> matchesConstraints);
    private static string GetExpectedOidValue();
}
internal class Internal.Cryptography.Pal.CertificatePal : object {
    private SafeCertContextHandle _certContext;
    public IntPtr Handle { get; }
    public string Issuer { get; }
    public string Subject { get; }
    public string LegacyIssuer { get; }
    public string LegacySubject { get; }
    public Byte[] Thumbprint { get; }
    public string KeyAlgorithm { get; }
    public Byte[] KeyAlgorithmParameters { get; }
    public Byte[] PublicKeyValue { get; }
    public Byte[] SerialNumber { get; }
    public string SignatureAlgorithm { get; }
    public DateTime NotAfter { get; }
    public DateTime NotBefore { get; }
    public Byte[] RawData { get; }
    public int Version { get; }
    public bool Archived { get; public set; }
    public string FriendlyName { get; public set; }
    public X500DistinguishedName SubjectName { get; }
    public X500DistinguishedName IssuerName { get; }
    public IEnumerable`1<X509Extension> Extensions { get; }
    internal SafeCertContextHandle CertContext { get; }
    public bool HasPrivateKey { get; }
    private CertificatePal(CertificatePal copyFrom);
    private CertificatePal(SafeCertContextHandle certContext, bool deleteKeyContainer);
    public static ICertificatePal FromHandle(IntPtr handle);
    public static ICertificatePal FromOtherCert(X509Certificate copyFrom);
    public sealed virtual IntPtr get_Handle();
    public sealed virtual string get_Issuer();
    public sealed virtual string get_Subject();
    public sealed virtual string get_LegacyIssuer();
    public sealed virtual string get_LegacySubject();
    public sealed virtual Byte[] get_Thumbprint();
    public sealed virtual string get_KeyAlgorithm();
    public sealed virtual Byte[] get_KeyAlgorithmParameters();
    private Byte[] PropagateKeyAlgorithmParametersFromChain();
    public sealed virtual Byte[] get_PublicKeyValue();
    public sealed virtual Byte[] get_SerialNumber();
    public sealed virtual string get_SignatureAlgorithm();
    public sealed virtual DateTime get_NotAfter();
    public sealed virtual DateTime get_NotBefore();
    public sealed virtual Byte[] get_RawData();
    public sealed virtual int get_Version();
    public sealed virtual bool get_Archived();
    public sealed virtual void set_Archived(bool value);
    public sealed virtual string get_FriendlyName();
    public sealed virtual void set_FriendlyName(string value);
    public sealed virtual X500DistinguishedName get_SubjectName();
    public sealed virtual X500DistinguishedName get_IssuerName();
    public sealed virtual IEnumerable`1<X509Extension> get_Extensions();
    public sealed virtual string GetNameInfo(X509NameType nameType, bool forIssuer);
    public sealed virtual void AppendPrivateKeyInfo(StringBuilder sb);
    public sealed virtual void Dispose();
    internal SafeCertContextHandle get_CertContext();
    private static CertNameType MapNameType(X509NameType nameType);
    private string GetIssuerOrSubject(bool issuer, bool reverse);
    public sealed virtual Byte[] Export(X509ContentType contentType, SafePasswordHandle password);
    public static ICertificatePal FromBlob(Byte[] rawData, SafePasswordHandle password, X509KeyStorageFlags keyStorageFlags);
    public static ICertificatePal FromFile(string fileName, SafePasswordHandle password, X509KeyStorageFlags keyStorageFlags);
    private static ICertificatePal FromBlobOrFile(Byte[] rawData, string fileName, SafePasswordHandle password, X509KeyStorageFlags keyStorageFlags);
    private static SafeCertContextHandle GetSignerInPKCS7Store(SafeCertStoreHandle hCertStore, SafeCryptMsgHandle hCryptMsg);
    private static SafeCertContextHandle FilterPFXStore(Byte[] rawData, SafePasswordHandle password, PfxCertStoreFlags pfxCertStoreFlags);
    private static PfxCertStoreFlags MapKeyStorageFlags(X509KeyStorageFlags keyStorageFlags);
    public sealed virtual bool get_HasPrivateKey();
    public sealed virtual RSA GetRSAPrivateKey();
    public sealed virtual DSA GetDSAPrivateKey();
    public sealed virtual ECDsa GetECDsaPrivateKey();
    public sealed virtual ICertificatePal CopyWithPrivateKey(DSA dsa);
    public sealed virtual ICertificatePal CopyWithPrivateKey(ECDsa ecdsa);
    public sealed virtual ICertificatePal CopyWithPrivateKey(RSA rsa);
    private T GetPrivateKey(Func`2<CspParameters, T> createCsp, Func`2<CngKey, T> createCng);
    private static SafeNCryptKeyHandle TryAcquireCngPrivateKey(SafeCertContextHandle certificateContext, CngKeyHandleOpenOptions& handleOptions);
    private CspParameters GetPrivateKeyCsp();
    private ICertificatePal CopyWithPersistedCngKey(CngKey cngKey);
    private static int GuessKeySpec(CngProvider provider, string keyName, bool machineKey, CngAlgorithmGroup algorithmGroup);
    private static bool TryGuessKeySpec(CspParameters cspParameters, CngAlgorithmGroup algorithmGroup, Int32& keySpec);
    private static bool TryGuessRsaKeySpec(CspParameters cspParameters, Int32& keySpec);
    private static bool TryGuessDsaKeySpec(CspParameters cspParameters, Int32& keySpec);
    private ICertificatePal CopyWithPersistedCapiKey(CspKeyContainerInfo keyContainerInfo);
    private ICertificatePal CopyWithEphemeralKey(CngKey cngKey);
}
internal class Internal.Cryptography.Pal.ChainPal : object {
    private SafeX509ChainHandle _chain;
    private static X509ChainErrorMapping[] s_x509ChainErrorMappings;
    public X509ChainElement[] ChainElements { get; }
    public X509ChainStatus[] ChainStatus { get; }
    public SafeX509ChainHandle SafeHandle { get; }
    private ChainPal(SafeX509ChainHandle chain);
    private static ChainPal();
    public static ChainPal BuildChain(bool useMachineContext, ICertificatePal cert, X509Certificate2Collection extraStore, OidCollection applicationPolicy, OidCollection certificatePolicy, X509RevocationMode revocationMode, X509RevocationFlag revocationFlag, DateTime verificationTime, TimeSpan timeout);
    private static SafeCertStoreHandle ConvertExtraStoreToSafeHandle(X509Certificate2Collection extraStore);
    private static CertChainFlags MapRevocationFlags(X509RevocationMode revocationMode, X509RevocationFlag revocationFlag);
    public static IChainPal FromHandle(IntPtr chainContext);
    public sealed virtual Nullable`1<bool> Verify(X509VerificationFlags flags, Exception& exception);
    public sealed virtual X509ChainElement[] get_ChainElements();
    public sealed virtual X509ChainStatus[] get_ChainStatus();
    public sealed virtual SafeX509ChainHandle get_SafeHandle();
    public static bool ReleaseSafeX509ChainHandle(IntPtr handle);
    public sealed virtual void Dispose();
    private static X509ChainStatus[] GetChainStatusInformation(CertTrustErrorStatus dwStatus);
}
internal class Internal.Cryptography.Pal.FindPal : object {
    private static Dictionary`2<string, X509KeyUsageFlags> s_keyUsages;
    private StorePal _storePal;
    private X509Certificate2Collection _copyTo;
    private bool _validOnly;
    internal FindPal(X509Certificate2Collection findFrom, X509Certificate2Collection copyTo, bool validOnly);
    private static FindPal();
    public static X509Certificate2Collection FindFromCollection(X509Certificate2Collection coll, X509FindType findType, object findValue, bool validOnly);
    private static T ConfirmedCast(object findValue);
    private static string ConfirmedOidValue(IFindPal findPal, object findValue, OidGroup oidGroup);
    private static X509KeyUsageFlags ConfirmedX509KeyUsage(object findValue);
    internal static void ValidateOidValue(string keyValue);
    internal static BigInteger PositiveBigIntegerFromByteArray(Byte[] bytes);
    private static BigInteger LaxParseDecimalBigInteger(string decimalString);
    internal static IFindPal OpenPal(X509Certificate2Collection findFrom, X509Certificate2Collection copyTo, bool validOnly);
    public sealed virtual string NormalizeOid(string maybeOid, OidGroup expectedGroup);
    public sealed virtual void FindByThumbprint(Byte[] thumbPrint);
    public sealed virtual void FindBySubjectName(string subjectName);
    public sealed virtual void FindBySubjectDistinguishedName(string subjectDistinguishedName);
    public sealed virtual void FindByIssuerName(string issuerName);
    public sealed virtual void FindByIssuerDistinguishedName(string issuerDistinguishedName);
    public sealed virtual void FindBySerialNumber(BigInteger hexValue, BigInteger decimalValue);
    public sealed virtual void FindByTimeValid(DateTime dateTime);
    public sealed virtual void FindByTimeNotYetValid(DateTime dateTime);
    public sealed virtual void FindByTimeExpired(DateTime dateTime);
    private void FindByTime(DateTime dateTime, int compareResult);
    public sealed virtual void FindByTemplateName(string templateName);
    public sealed virtual void FindByApplicationPolicy(string oidValue);
    public sealed virtual void FindByCertificatePolicy(string oidValue);
    public sealed virtual void FindByExtension(string oidValue);
    public sealed virtual void FindByKeyUsage(X509KeyUsageFlags keyUsage);
    public sealed virtual void FindBySubjectKeyIdentifier(Byte[] keyIdentifier);
    public sealed virtual void Dispose();
    private void FindCore(Func`2<SafeCertContextHandle, bool> filter);
    private void FindCore(CertFindType dwFindType, Void* pvFindPara, Func`2<SafeCertContextHandle, bool> filter);
    private static bool VerifyCertificateIgnoringErrors(SafeCertContextHandle pCertContext);
    private static string GetCertNameInfo(SafeCertContextHandle pCertContext, CertNameType dwNameType, CertNameFlags dwNameFlags);
}
internal interface Internal.Cryptography.Pal.IChainPal {
    public X509ChainElement[] ChainElements { get; }
    public X509ChainStatus[] ChainStatus { get; }
    public SafeX509ChainHandle SafeHandle { get; }
    public abstract virtual Nullable`1<bool> Verify(X509VerificationFlags flags, Exception& exception);
    public abstract virtual X509ChainElement[] get_ChainElements();
    public abstract virtual X509ChainStatus[] get_ChainStatus();
    public abstract virtual SafeX509ChainHandle get_SafeHandle();
}
internal interface Internal.Cryptography.Pal.IExportPal {
    public abstract virtual Byte[] Export(X509ContentType contentType, SafePasswordHandle password);
}
internal interface Internal.Cryptography.Pal.IFindPal {
    public abstract virtual string NormalizeOid(string maybeOid, OidGroup expectedGroup);
    public abstract virtual void FindByThumbprint(Byte[] thumbprint);
    public abstract virtual void FindBySubjectName(string subjectName);
    public abstract virtual void FindBySubjectDistinguishedName(string subjectDistinguishedName);
    public abstract virtual void FindByIssuerName(string issuerName);
    public abstract virtual void FindByIssuerDistinguishedName(string issuerDistinguishedName);
    public abstract virtual void FindBySerialNumber(BigInteger hexValue, BigInteger decimalValue);
    public abstract virtual void FindByTimeValid(DateTime dateTime);
    public abstract virtual void FindByTimeNotYetValid(DateTime dateTime);
    public abstract virtual void FindByTimeExpired(DateTime dateTime);
    public abstract virtual void FindByTemplateName(string templateName);
    public abstract virtual void FindByApplicationPolicy(string oidValue);
    public abstract virtual void FindByCertificatePolicy(string oidValue);
    public abstract virtual void FindByExtension(string oidValue);
    public abstract virtual void FindByKeyUsage(X509KeyUsageFlags keyUsage);
    public abstract virtual void FindBySubjectKeyIdentifier(Byte[] keyIdentifier);
}
internal interface Internal.Cryptography.Pal.ILoaderPal {
    public abstract virtual void MoveTo(X509Certificate2Collection collection);
}
internal interface Internal.Cryptography.Pal.IStorePal {
    public SafeHandle SafeHandle { get; }
    public abstract virtual void CloneTo(X509Certificate2Collection collection);
    public abstract virtual void Add(ICertificatePal cert);
    public abstract virtual void Remove(ICertificatePal cert);
    public abstract virtual SafeHandle get_SafeHandle();
}
internal interface Internal.Cryptography.Pal.IX509Pal {
    public bool SupportsLegacyBasicConstraintsExtension { get; }
    public abstract virtual AsymmetricAlgorithm DecodePublicKey(Oid oid, Byte[] encodedKeyValue, Byte[] encodedParameters, ICertificatePal certificatePal);
    public abstract virtual string X500DistinguishedNameDecode(Byte[] encodedDistinguishedName, X500DistinguishedNameFlags flag);
    public abstract virtual Byte[] X500DistinguishedNameEncode(string distinguishedName, X500DistinguishedNameFlags flag);
    public abstract virtual string X500DistinguishedNameFormat(Byte[] encodedDistinguishedName, bool multiLine);
    public abstract virtual X509ContentType GetCertContentType(Byte[] rawData);
    public abstract virtual X509ContentType GetCertContentType(string fileName);
    public abstract virtual Byte[] EncodeX509KeyUsageExtension(X509KeyUsageFlags keyUsages);
    public abstract virtual void DecodeX509KeyUsageExtension(Byte[] encoded, X509KeyUsageFlags& keyUsages);
    public abstract virtual bool get_SupportsLegacyBasicConstraintsExtension();
    public abstract virtual Byte[] EncodeX509BasicConstraints2Extension(bool certificateAuthority, bool hasPathLengthConstraint, int pathLengthConstraint);
    public abstract virtual void DecodeX509BasicConstraintsExtension(Byte[] encoded, Boolean& certificateAuthority, Boolean& hasPathLengthConstraint, Int32& pathLengthConstraint);
    public abstract virtual void DecodeX509BasicConstraints2Extension(Byte[] encoded, Boolean& certificateAuthority, Boolean& hasPathLengthConstraint, Int32& pathLengthConstraint);
    public abstract virtual Byte[] EncodeX509EnhancedKeyUsageExtension(OidCollection usages);
    public abstract virtual void DecodeX509EnhancedKeyUsageExtension(Byte[] encoded, OidCollection& usages);
    public abstract virtual Byte[] EncodeX509SubjectKeyIdentifierExtension(Byte[] subjectKeyIdentifier);
    public abstract virtual void DecodeX509SubjectKeyIdentifierExtension(Byte[] encoded, Byte[]& subjectKeyIdentifier);
    public abstract virtual Byte[] ComputeCapiSha1OfPublicKey(PublicKey key);
}
internal class Internal.Cryptography.Pal.Native.CERT_BASIC_CONSTRAINTS_INFO : ValueType {
    public CRYPT_BIT_BLOB SubjectType;
    public int fPathLenConstraint;
    public int dwPathLenConstraint;
    public int cSubtreesConstraint;
    public CRYPTOAPI_BLOB* rgSubtreesConstraint;
}
internal class Internal.Cryptography.Pal.Native.CERT_BASIC_CONSTRAINTS2_INFO : ValueType {
    public int fCA;
    public int fPathLenConstraint;
    public int dwPathLenConstraint;
}
internal class Internal.Cryptography.Pal.Native.CERT_CHAIN_CONTEXT : ValueType {
    public int cbSize;
    public CERT_TRUST_STATUS TrustStatus;
    public int cChain;
    public CERT_SIMPLE_CHAIN** rgpChain;
    public int cLowerQualityChainContext;
    public CERT_CHAIN_CONTEXT** rgpLowerQualityChainContext;
    public int fHasRevocationFreshnessTime;
    public int dwRevocationFreshnessTime;
    public int dwCreateFlags;
    public Guid ChainId;
}
internal class Internal.Cryptography.Pal.Native.CERT_CHAIN_ELEMENT : ValueType {
    public int cbSize;
    public CERT_CONTEXT* pCertContext;
    public CERT_TRUST_STATUS TrustStatus;
    public IntPtr pRevocationInfo;
    public IntPtr pIssuanceUsage;
    public IntPtr pApplicationUsage;
    public IntPtr pwszExtendedErrorInfo;
}
internal class Internal.Cryptography.Pal.Native.CERT_CHAIN_PARA : ValueType {
    public int cbSize;
    public CERT_USAGE_MATCH RequestedUsage;
    public CERT_USAGE_MATCH RequestedIssuancePolicy;
    public int dwUrlRetrievalTimeout;
    public int fCheckRevocationFreshnessTime;
    public int dwRevocationFreshnessTime;
    public FILETIME* pftCacheResync;
    public int pStrongSignPara;
    public int dwStrongSignFlags;
}
internal class Internal.Cryptography.Pal.Native.CERT_CHAIN_POLICY_PARA : ValueType {
    public int cbSize;
    public int dwFlags;
    public IntPtr pvExtraPolicyPara;
}
internal class Internal.Cryptography.Pal.Native.CERT_CHAIN_POLICY_STATUS : ValueType {
    public int cbSize;
    public int dwError;
    public IntPtr lChainIndex;
    public IntPtr lElementIndex;
    public IntPtr pvExtraPolicyStatus;
}
internal class Internal.Cryptography.Pal.Native.CERT_CONTEXT : ValueType {
    public CertEncodingType dwCertEncodingType;
    public Byte* pbCertEncoded;
    public int cbCertEncoded;
    public CERT_INFO* pCertInfo;
    public IntPtr hCertStore;
}
internal class Internal.Cryptography.Pal.Native.CERT_DSS_PARAMETERS : ValueType {
    public CRYPTOAPI_BLOB p;
    public CRYPTOAPI_BLOB q;
    public CRYPTOAPI_BLOB g;
}
internal class Internal.Cryptography.Pal.Native.CERT_ENHKEY_USAGE : ValueType {
    public int cUsageIdentifier;
    public IntPtr* rgpszUsageIdentifier;
}
internal class Internal.Cryptography.Pal.Native.CERT_EXTENSION : ValueType {
    public IntPtr pszObjId;
    public int fCritical;
    public CRYPTOAPI_BLOB Value;
}
internal class Internal.Cryptography.Pal.Native.CERT_INFO : ValueType {
    public int dwVersion;
    public CRYPTOAPI_BLOB SerialNumber;
    public CRYPT_ALGORITHM_IDENTIFIER SignatureAlgorithm;
    public CRYPTOAPI_BLOB Issuer;
    public FILETIME NotBefore;
    public FILETIME NotAfter;
    public CRYPTOAPI_BLOB Subject;
    public CERT_PUBLIC_KEY_INFO SubjectPublicKeyInfo;
    public CRYPT_BIT_BLOB IssuerUniqueId;
    public CRYPT_BIT_BLOB SubjectUniqueId;
    public int cExtension;
    public CERT_EXTENSION* rgExtension;
}
internal class Internal.Cryptography.Pal.Native.CERT_NAME_VALUE : ValueType {
    public int dwValueType;
    public CRYPTOAPI_BLOB Value;
}
internal class Internal.Cryptography.Pal.Native.CERT_POLICIES_INFO : ValueType {
    public int cPolicyInfo;
    public CERT_POLICY_INFO* rgPolicyInfo;
}
internal class Internal.Cryptography.Pal.Native.CERT_POLICY_INFO : ValueType {
    public IntPtr pszPolicyIdentifier;
    public int cPolicyQualifier;
    public IntPtr rgPolicyQualifier;
}
internal class Internal.Cryptography.Pal.Native.CERT_PUBLIC_KEY_INFO : ValueType {
    public CRYPT_ALGORITHM_IDENTIFIER Algorithm;
    public CRYPT_BIT_BLOB PublicKey;
}
internal class Internal.Cryptography.Pal.Native.CERT_SIMPLE_CHAIN : ValueType {
    public int cbSize;
    public CERT_TRUST_STATUS TrustStatus;
    public int cElement;
    public CERT_CHAIN_ELEMENT** rgpElement;
    public IntPtr pTrustListInfo;
    public int fHasRevocationFreshnessTime;
    public int dwRevocationFreshnessTime;
}
internal class Internal.Cryptography.Pal.Native.CERT_TEMPLATE_EXT : ValueType {
    public IntPtr pszObjId;
    public int dwMajorVersion;
    public int fMinorVersion;
    public int dwMinorVersion;
}
internal class Internal.Cryptography.Pal.Native.CERT_TRUST_STATUS : ValueType {
    public CertTrustErrorStatus dwErrorStatus;
    public CertTrustInfoStatus dwInfoStatus;
}
internal class Internal.Cryptography.Pal.Native.CERT_USAGE_MATCH : ValueType {
    public CertUsageMatchType dwType;
    public CTL_USAGE Usage;
}
[FlagsAttribute]
internal enum Internal.Cryptography.Pal.Native.CertChainFlags : Enum {
    public int value__;
    public static CertChainFlags None;
    public static CertChainFlags CERT_CHAIN_REVOCATION_CHECK_END_CERT;
    public static CertChainFlags CERT_CHAIN_REVOCATION_CHECK_CHAIN;
    public static CertChainFlags CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT;
    public static CertChainFlags CERT_CHAIN_REVOCATION_CHECK_CACHE_ONLY;
}
internal enum Internal.Cryptography.Pal.Native.CertContextPropId : Enum {
    public int value__;
    public static CertContextPropId CERT_KEY_PROV_INFO_PROP_ID;
    public static CertContextPropId CERT_SHA1_HASH_PROP_ID;
    public static CertContextPropId CERT_KEY_CONTEXT_PROP_ID;
    public static CertContextPropId CERT_FRIENDLY_NAME_PROP_ID;
    public static CertContextPropId CERT_ARCHIVED_PROP_ID;
    public static CertContextPropId CERT_KEY_IDENTIFIER_PROP_ID;
    public static CertContextPropId CERT_PUBKEY_ALG_PARA_PROP_ID;
    public static CertContextPropId CERT_NCRYPT_KEY_HANDLE_PROP_ID;
    public static CertContextPropId CERT_CLR_DELETE_KEY_PROP_ID;
}
[FlagsAttribute]
internal enum Internal.Cryptography.Pal.Native.CertControlStoreFlags : Enum {
    public int value__;
    public static CertControlStoreFlags None;
}
internal enum Internal.Cryptography.Pal.Native.CertControlStoreType : Enum {
    public int value__;
    public static CertControlStoreType CERT_STORE_CTRL_AUTO_RESYNC;
}
internal enum Internal.Cryptography.Pal.Native.CertEncodingType : Enum {
    public int value__;
    public static CertEncodingType PKCS_7_ASN_ENCODING;
    public static CertEncodingType X509_ASN_ENCODING;
    public static CertEncodingType All;
}
[FlagsAttribute]
internal enum Internal.Cryptography.Pal.Native.CertFindFlags : Enum {
    public int value__;
    public static CertFindFlags None;
}
internal enum Internal.Cryptography.Pal.Native.CertFindType : Enum {
    public int value__;
    public static CertFindType CERT_FIND_SUBJECT_CERT;
    public static CertFindType CERT_FIND_HASH;
    public static CertFindType CERT_FIND_SUBJECT_STR;
    public static CertFindType CERT_FIND_ISSUER_STR;
    public static CertFindType CERT_FIND_EXISTING;
    public static CertFindType CERT_FIND_ANY;
}
[FlagsAttribute]
internal enum Internal.Cryptography.Pal.Native.CertNameFlags : Enum {
    public int value__;
    public static CertNameFlags None;
    public static CertNameFlags CERT_NAME_ISSUER_FLAG;
}
internal enum Internal.Cryptography.Pal.Native.CertNameStringType : Enum {
    public int value__;
    public static CertNameStringType CERT_X500_NAME_STR;
    public static CertNameStringType CERT_NAME_STR_REVERSE_FLAG;
}
[FlagsAttribute]
internal enum Internal.Cryptography.Pal.Native.CertNameStrTypeAndFlags : Enum {
    public int value__;
    public static CertNameStrTypeAndFlags CERT_SIMPLE_NAME_STR;
    public static CertNameStrTypeAndFlags CERT_OID_NAME_STR;
    public static CertNameStrTypeAndFlags CERT_X500_NAME_STR;
    public static CertNameStrTypeAndFlags CERT_NAME_STR_SEMICOLON_FLAG;
    public static CertNameStrTypeAndFlags CERT_NAME_STR_NO_PLUS_FLAG;
    public static CertNameStrTypeAndFlags CERT_NAME_STR_NO_QUOTING_FLAG;
    public static CertNameStrTypeAndFlags CERT_NAME_STR_CRLF_FLAG;
    public static CertNameStrTypeAndFlags CERT_NAME_STR_COMMA_FLAG;
    public static CertNameStrTypeAndFlags CERT_NAME_STR_REVERSE_FLAG;
    public static CertNameStrTypeAndFlags CERT_NAME_STR_DISABLE_IE4_UTF8_FLAG;
    public static CertNameStrTypeAndFlags CERT_NAME_STR_ENABLE_T61_UNICODE_FLAG;
    public static CertNameStrTypeAndFlags CERT_NAME_STR_ENABLE_UTF8_UNICODE_FLAG;
    public static CertNameStrTypeAndFlags CERT_NAME_STR_FORCE_UTF8_DIR_STR_FLAG;
}
internal enum Internal.Cryptography.Pal.Native.CertNameType : Enum {
    public int value__;
    public static CertNameType CERT_NAME_EMAIL_TYPE;
    public static CertNameType CERT_NAME_RDN_TYPE;
    public static CertNameType CERT_NAME_ATTR_TYPE;
    public static CertNameType CERT_NAME_SIMPLE_DISPLAY_TYPE;
    public static CertNameType CERT_NAME_FRIENDLY_DISPLAY_TYPE;
    public static CertNameType CERT_NAME_DNS_TYPE;
    public static CertNameType CERT_NAME_URL_TYPE;
    public static CertNameType CERT_NAME_UPN_TYPE;
}
internal enum Internal.Cryptography.Pal.Native.CertQueryObjectType : Enum {
    public int value__;
    public static CertQueryObjectType CERT_QUERY_OBJECT_FILE;
    public static CertQueryObjectType CERT_QUERY_OBJECT_BLOB;
}
[FlagsAttribute]
internal enum Internal.Cryptography.Pal.Native.CertSetPropertyFlags : Enum {
    public int value__;
    public static CertSetPropertyFlags CERT_SET_PROPERTY_INHIBIT_PERSIST_FLAG;
    public static CertSetPropertyFlags None;
}
internal enum Internal.Cryptography.Pal.Native.CertStoreAddDisposition : Enum {
    public int value__;
    public static CertStoreAddDisposition CERT_STORE_ADD_NEW;
    public static CertStoreAddDisposition CERT_STORE_ADD_USE_EXISTING;
    public static CertStoreAddDisposition CERT_STORE_ADD_REPLACE_EXISTING;
    public static CertStoreAddDisposition CERT_STORE_ADD_ALWAYS;
    public static CertStoreAddDisposition CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES;
    public static CertStoreAddDisposition CERT_STORE_ADD_NEWER;
    public static CertStoreAddDisposition CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES;
}
[FlagsAttribute]
internal enum Internal.Cryptography.Pal.Native.CertStoreFlags : Enum {
    public int value__;
    public static CertStoreFlags CERT_STORE_NO_CRYPT_RELEASE_FLAG;
    public static CertStoreFlags CERT_STORE_SET_LOCALIZED_NAME_FLAG;
    public static CertStoreFlags CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG;
    public static CertStoreFlags CERT_STORE_DELETE_FLAG;
    public static CertStoreFlags CERT_STORE_UNSAFE_PHYSICAL_FLAG;
    public static CertStoreFlags CERT_STORE_SHARE_STORE_FLAG;
    public static CertStoreFlags CERT_STORE_SHARE_CONTEXT_FLAG;
    public static CertStoreFlags CERT_STORE_MANIFOLD_FLAG;
    public static CertStoreFlags CERT_STORE_ENUM_ARCHIVED_FLAG;
    public static CertStoreFlags CERT_STORE_UPDATE_KEYID_FLAG;
    public static CertStoreFlags CERT_STORE_BACKUP_RESTORE_FLAG;
    public static CertStoreFlags CERT_STORE_READONLY_FLAG;
    public static CertStoreFlags CERT_STORE_OPEN_EXISTING_FLAG;
    public static CertStoreFlags CERT_STORE_CREATE_NEW_FLAG;
    public static CertStoreFlags CERT_STORE_MAXIMUM_ALLOWED_FLAG;
    public static CertStoreFlags CERT_SYSTEM_STORE_CURRENT_USER;
    public static CertStoreFlags CERT_SYSTEM_STORE_LOCAL_MACHINE;
    public static CertStoreFlags None;
}
internal enum Internal.Cryptography.Pal.Native.CertStoreProvider : Enum {
    public int value__;
    public static CertStoreProvider CERT_STORE_PROV_MEMORY;
    public static CertStoreProvider CERT_STORE_PROV_SYSTEM_W;
}
internal enum Internal.Cryptography.Pal.Native.CertStoreSaveAs : Enum {
    public int value__;
    public static CertStoreSaveAs CERT_STORE_SAVE_AS_STORE;
    public static CertStoreSaveAs CERT_STORE_SAVE_AS_PKCS7;
}
internal enum Internal.Cryptography.Pal.Native.CertStoreSaveTo : Enum {
    public int value__;
    public static CertStoreSaveTo CERT_STORE_SAVE_TO_MEMORY;
}
[FlagsAttribute]
internal enum Internal.Cryptography.Pal.Native.CertTrustErrorStatus : Enum {
    public int value__;
    public static CertTrustErrorStatus CERT_TRUST_NO_ERROR;
    public static CertTrustErrorStatus CERT_TRUST_IS_NOT_TIME_VALID;
    public static CertTrustErrorStatus CERT_TRUST_IS_NOT_TIME_NESTED;
    public static CertTrustErrorStatus CERT_TRUST_IS_REVOKED;
    public static CertTrustErrorStatus CERT_TRUST_IS_NOT_SIGNATURE_VALID;
    public static CertTrustErrorStatus CERT_TRUST_IS_NOT_VALID_FOR_USAGE;
    public static CertTrustErrorStatus CERT_TRUST_IS_UNTRUSTED_ROOT;
    public static CertTrustErrorStatus CERT_TRUST_REVOCATION_STATUS_UNKNOWN;
    public static CertTrustErrorStatus CERT_TRUST_IS_CYCLIC;
    public static CertTrustErrorStatus CERT_TRUST_INVALID_EXTENSION;
    public static CertTrustErrorStatus CERT_TRUST_INVALID_POLICY_CONSTRAINTS;
    public static CertTrustErrorStatus CERT_TRUST_INVALID_BASIC_CONSTRAINTS;
    public static CertTrustErrorStatus CERT_TRUST_INVALID_NAME_CONSTRAINTS;
    public static CertTrustErrorStatus CERT_TRUST_HAS_NOT_SUPPORTED_NAME_CONSTRAINT;
    public static CertTrustErrorStatus CERT_TRUST_HAS_NOT_DEFINED_NAME_CONSTRAINT;
    public static CertTrustErrorStatus CERT_TRUST_HAS_NOT_PERMITTED_NAME_CONSTRAINT;
    public static CertTrustErrorStatus CERT_TRUST_HAS_EXCLUDED_NAME_CONSTRAINT;
    public static CertTrustErrorStatus CERT_TRUST_IS_OFFLINE_REVOCATION;
    public static CertTrustErrorStatus CERT_TRUST_NO_ISSUANCE_CHAIN_POLICY;
    public static CertTrustErrorStatus CERT_TRUST_IS_EXPLICIT_DISTRUST;
    public static CertTrustErrorStatus CERT_TRUST_HAS_NOT_SUPPORTED_CRITICAL_EXT;
    public static CertTrustErrorStatus CERT_TRUST_HAS_WEAK_SIGNATURE;
    public static CertTrustErrorStatus CERT_TRUST_IS_PARTIAL_CHAIN;
    public static CertTrustErrorStatus CERT_TRUST_CTL_IS_NOT_TIME_VALID;
    public static CertTrustErrorStatus CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID;
    public static CertTrustErrorStatus CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE;
}
[FlagsAttribute]
internal enum Internal.Cryptography.Pal.Native.CertTrustInfoStatus : Enum {
    public int value__;
    public static CertTrustInfoStatus CERT_TRUST_HAS_EXACT_MATCH_ISSUER;
    public static CertTrustInfoStatus CERT_TRUST_HAS_KEY_MATCH_ISSUER;
    public static CertTrustInfoStatus CERT_TRUST_HAS_NAME_MATCH_ISSUER;
    public static CertTrustInfoStatus CERT_TRUST_IS_SELF_SIGNED;
    public static CertTrustInfoStatus CERT_TRUST_HAS_PREFERRED_ISSUER;
    public static CertTrustInfoStatus CERT_TRUST_HAS_ISSUANCE_CHAIN_POLICY;
    public static CertTrustInfoStatus CERT_TRUST_HAS_VALID_NAME_CONSTRAINTS;
    public static CertTrustInfoStatus CERT_TRUST_IS_COMPLEX_CHAIN;
}
internal enum Internal.Cryptography.Pal.Native.CertUsageMatchType : Enum {
    public int value__;
    public static CertUsageMatchType USAGE_MATCH_TYPE_AND;
    public static CertUsageMatchType USAGE_MATCH_TYPE_OR;
}
internal enum Internal.Cryptography.Pal.Native.ChainEngine : Enum {
    public int value__;
    public static ChainEngine HCCE_CURRENT_USER;
    public static ChainEngine HCCE_LOCAL_MACHINE;
}
internal enum Internal.Cryptography.Pal.Native.ChainPolicy : Enum {
    public int value__;
    public static ChainPolicy CERT_CHAIN_POLICY_BASE;
}
internal class Internal.Cryptography.Pal.Native.CMSG_SIGNER_INFO_Partial : ValueType {
    public int dwVersion;
    public CRYPTOAPI_BLOB Issuer;
    public CRYPTOAPI_BLOB SerialNumber;
}
internal enum Internal.Cryptography.Pal.Native.ContentType : Enum {
    public int value__;
    public static ContentType CERT_QUERY_CONTENT_CERT;
    public static ContentType CERT_QUERY_CONTENT_CTL;
    public static ContentType CERT_QUERY_CONTENT_CRL;
    public static ContentType CERT_QUERY_CONTENT_SERIALIZED_STORE;
    public static ContentType CERT_QUERY_CONTENT_SERIALIZED_CERT;
    public static ContentType CERT_QUERY_CONTENT_SERIALIZED_CTL;
    public static ContentType CERT_QUERY_CONTENT_SERIALIZED_CRL;
    public static ContentType CERT_QUERY_CONTENT_PKCS7_SIGNED;
    public static ContentType CERT_QUERY_CONTENT_PKCS7_UNSIGNED;
    public static ContentType CERT_QUERY_CONTENT_PKCS7_SIGNED_EMBED;
    public static ContentType CERT_QUERY_CONTENT_PKCS10;
    public static ContentType CERT_QUERY_CONTENT_PFX;
    public static ContentType CERT_QUERY_CONTENT_CERT_PAIR;
    public static ContentType CERT_QUERY_CONTENT_PFX_AND_LOAD;
}
internal class Internal.Cryptography.Pal.Native.CRYPT_ALGORITHM_IDENTIFIER : ValueType {
    public IntPtr pszObjId;
    public CRYPTOAPI_BLOB Parameters;
}
internal class Internal.Cryptography.Pal.Native.CRYPT_BIT_BLOB : ValueType {
    public int cbData;
    public Byte* pbData;
    public int cUnusedBits;
    public Byte[] ToByteArray();
}
internal class Internal.Cryptography.Pal.Native.CRYPT_KEY_PROV_INFO : ValueType {
    public Char* pwszContainerName;
    public Char* pwszProvName;
    public int dwProvType;
    public CryptAcquireContextFlags dwFlags;
    public int cProvParam;
    public IntPtr rgProvParam;
    public int dwKeySpec;
}
[FlagsAttribute]
internal enum Internal.Cryptography.Pal.Native.CryptAcquireContextFlags : Enum {
    public int value__;
    public static CryptAcquireContextFlags CRYPT_DELETEKEYSET;
    public static CryptAcquireContextFlags CRYPT_MACHINE_KEYSET;
    public static CryptAcquireContextFlags None;
}
internal enum Internal.Cryptography.Pal.Native.CryptAcquireFlags : Enum {
    public int value__;
    public static CryptAcquireFlags CRYPT_ACQUIRE_ONLY_NCRYPT_KEY_FLAG;
}
[FlagsAttribute]
internal enum Internal.Cryptography.Pal.Native.CryptDecodeObjectFlags : Enum {
    public int value__;
    public static CryptDecodeObjectFlags None;
}
internal enum Internal.Cryptography.Pal.Native.CryptDecodeObjectStructType : Enum {
    public int value__;
    public static CryptDecodeObjectStructType CNG_RSA_PUBLIC_KEY_BLOB;
    public static CryptDecodeObjectStructType X509_DSS_PUBLICKEY;
    public static CryptDecodeObjectStructType X509_DSS_PARAMETERS;
    public static CryptDecodeObjectStructType X509_KEY_USAGE;
    public static CryptDecodeObjectStructType X509_BASIC_CONSTRAINTS;
    public static CryptDecodeObjectStructType X509_BASIC_CONSTRAINTS2;
    public static CryptDecodeObjectStructType X509_ENHANCED_KEY_USAGE;
    public static CryptDecodeObjectStructType X509_CERT_POLICIES;
    public static CryptDecodeObjectStructType X509_UNICODE_ANY_STRING;
    public static CryptDecodeObjectStructType X509_CERTIFICATE_TEMPLATE;
}
internal enum Internal.Cryptography.Pal.Native.CryptMessageParameterType : Enum {
    public int value__;
    public static CryptMessageParameterType CMSG_SIGNER_COUNT_PARAM;
    public static CryptMessageParameterType CMSG_SIGNER_INFO_PARAM;
}
internal class Internal.Cryptography.Pal.Native.CRYPTOAPI_BLOB : ValueType {
    public int cbData;
    public Byte* pbData;
    public CRYPTOAPI_BLOB(int cbData, Byte* pbData);
    public Byte[] ToByteArray();
}
internal class Internal.Cryptography.Pal.Native.CTL_USAGE : ValueType {
    public int cUsageIdentifier;
    public IntPtr rgpszUsageIdentifier;
}
[FlagsAttribute]
internal enum Internal.Cryptography.Pal.Native.ExpectedContentTypeFlags : Enum {
    public int value__;
    public static ExpectedContentTypeFlags CERT_QUERY_CONTENT_FLAG_CERT;
    public static ExpectedContentTypeFlags CERT_QUERY_CONTENT_FLAG_CTL;
    public static ExpectedContentTypeFlags CERT_QUERY_CONTENT_FLAG_CRL;
    public static ExpectedContentTypeFlags CERT_QUERY_CONTENT_FLAG_SERIALIZED_STORE;
    public static ExpectedContentTypeFlags CERT_QUERY_CONTENT_FLAG_SERIALIZED_CERT;
    public static ExpectedContentTypeFlags CERT_QUERY_CONTENT_FLAG_SERIALIZED_CTL;
    public static ExpectedContentTypeFlags CERT_QUERY_CONTENT_FLAG_SERIALIZED_CRL;
    public static ExpectedContentTypeFlags CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED;
    public static ExpectedContentTypeFlags CERT_QUERY_CONTENT_FLAG_PKCS7_UNSIGNED;
    public static ExpectedContentTypeFlags CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED_EMBED;
    public static ExpectedContentTypeFlags CERT_QUERY_CONTENT_FLAG_PKCS10;
    public static ExpectedContentTypeFlags CERT_QUERY_CONTENT_FLAG_PFX;
    public static ExpectedContentTypeFlags CERT_QUERY_CONTENT_FLAG_CERT_PAIR;
    public static ExpectedContentTypeFlags CERT_QUERY_CONTENT_FLAG_PFX_AND_LOAD;
    public static ExpectedContentTypeFlags CERT_QUERY_CONTENT_FLAG_ALL;
}
[FlagsAttribute]
internal enum Internal.Cryptography.Pal.Native.ExpectedFormatTypeFlags : Enum {
    public int value__;
    public static ExpectedFormatTypeFlags CERT_QUERY_FORMAT_FLAG_BINARY;
    public static ExpectedFormatTypeFlags CERT_QUERY_FORMAT_FLAG_BASE64_ENCODED;
    public static ExpectedFormatTypeFlags CERT_QUERY_FORMAT_FLAG_ASN_ASCII_HEX_ENCODED;
    public static ExpectedFormatTypeFlags CERT_QUERY_FORMAT_FLAG_ALL;
}
internal class Internal.Cryptography.Pal.Native.FILETIME : ValueType {
    private UInt32 ftTimeLow;
    private UInt32 ftTimeHigh;
    public DateTime ToDateTime();
    public static FILETIME FromDateTime(DateTime dt);
}
internal enum Internal.Cryptography.Pal.Native.FormatType : Enum {
    public int value__;
    public static FormatType CERT_QUERY_FORMAT_BINARY;
    public static FormatType CERT_QUERY_FORMAT_BASE64_ENCODED;
    public static FormatType CERT_QUERY_FORMAT_ASN_ASCII_HEX_ENCODED;
}
[ExtensionAttribute]
internal static class Internal.Cryptography.Pal.Native.Helpers : object {
    [ExtensionAttribute]
public static SafeHandle ToLpstrArray(OidCollection oids, Int32& numOids);
    [ExtensionAttribute]
public static Byte[] ValueAsAscii(Oid oid);
    [ExtensionAttribute]
public static void DecodeObject(Byte[] encoded, CryptDecodeObjectStructType lpszStructType, DecodedObjectReceiver receiver);
    [ExtensionAttribute]
public static void DecodeObject(Byte[] encoded, string lpszStructType, DecodedObjectReceiver receiver);
    [ExtensionAttribute]
public static bool DecodeObjectNoThrow(Byte[] encoded, CryptDecodeObjectStructType lpszStructType, DecodedObjectReceiver receiver);
}
[FlagsAttribute]
internal enum Internal.Cryptography.Pal.Native.PfxCertStoreFlags : Enum {
    public int value__;
    public static PfxCertStoreFlags CRYPT_EXPORTABLE;
    public static PfxCertStoreFlags CRYPT_USER_PROTECTED;
    public static PfxCertStoreFlags CRYPT_MACHINE_KEYSET;
    public static PfxCertStoreFlags CRYPT_USER_KEYSET;
    public static PfxCertStoreFlags PKCS12_PREFER_CNG_KSP;
    public static PfxCertStoreFlags PKCS12_ALWAYS_CNG_KSP;
    public static PfxCertStoreFlags PKCS12_ALLOW_OVERWRITE_KEY;
    public static PfxCertStoreFlags PKCS12_NO_PERSIST_KEY;
    public static PfxCertStoreFlags PKCS12_INCLUDE_EXTENDED_PROPERTIES;
    public static PfxCertStoreFlags None;
}
[FlagsAttribute]
internal enum Internal.Cryptography.Pal.Native.PFXExportFlags : Enum {
    public int value__;
    public static PFXExportFlags REPORT_NO_PRIVATE_KEY;
    public static PFXExportFlags REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY;
    public static PFXExportFlags EXPORT_PRIVATE_KEYS;
    public static PFXExportFlags None;
}
internal class Internal.Cryptography.Pal.Native.SafeCertContextHandle : SafePointerHandle`1<SafeCertContextHandle> {
    private SafeCertContextHandle _parent;
    public CERT_CONTEXT* CertContext { get; }
    public bool HasPersistedPrivateKey { get; }
    public bool HasEphemeralPrivateKey { get; }
    public bool ContainsPrivateKey { get; }
    public SafeCertContextHandle(SafeCertContextHandle parent);
    protected virtual bool ReleaseHandle();
    public CERT_CONTEXT* get_CertContext();
    public CERT_CONTEXT* Disconnect();
    public bool get_HasPersistedPrivateKey();
    public bool get_HasEphemeralPrivateKey();
    public bool get_ContainsPrivateKey();
    public SafeCertContextHandle Duplicate();
    private bool CertHasProperty(CertContextPropId propertyId);
}
internal class Internal.Cryptography.Pal.Native.SafeCertContextHandleWithKeyContainerDeletion : SafeCertContextHandle {
    protected sealed virtual bool ReleaseHandle();
    public static void DeleteKeyContainer(SafeCertContextHandle pCertContext);
}
internal class Internal.Cryptography.Pal.Native.SafeCertStoreHandle : SafePointerHandle`1<SafeCertStoreHandle> {
    protected sealed virtual bool ReleaseHandle();
}
internal class Internal.Cryptography.Pal.Native.SafeCryptMsgHandle : SafePointerHandle`1<SafeCryptMsgHandle> {
    protected sealed virtual bool ReleaseHandle();
}
internal class Internal.Cryptography.Pal.Native.SafeLocalAllocHandle : SafePointerHandle`1<SafeLocalAllocHandle> {
    public static SafeLocalAllocHandle Create(int cb);
    protected sealed virtual bool ReleaseHandle();
}
internal abstract class Internal.Cryptography.Pal.Native.SafePointerHandle`1 : SafeHandle {
    public bool IsInvalid { get; }
    public static T InvalidHandle { get; }
    public sealed virtual bool get_IsInvalid();
    public static T get_InvalidHandle();
    protected virtual void Dispose(bool disposing);
}
internal class Internal.Cryptography.Pal.StorePal : object {
    private SafeCertStoreHandle _certStore;
    internal SafeCertStoreHandle SafeCertStoreHandle { get; }
    private SafeHandle Internal.Cryptography.Pal.IStorePal.SafeHandle { get; }
    internal StorePal(SafeCertStoreHandle certStore);
    public static IStorePal FromHandle(IntPtr storeHandle);
    public sealed virtual void CloneTo(X509Certificate2Collection collection);
    public void CopyTo(X509Certificate2Collection collection);
    public sealed virtual void Add(ICertificatePal certificate);
    public sealed virtual void Remove(ICertificatePal certificate);
    public sealed virtual void Dispose();
    internal SafeCertStoreHandle get_SafeCertStoreHandle();
    private sealed virtual override SafeHandle Internal.Cryptography.Pal.IStorePal.get_SafeHandle();
    public sealed virtual void MoveTo(X509Certificate2Collection collection);
    public sealed virtual Byte[] Export(X509ContentType contentType, SafePasswordHandle password);
    private Byte[] SaveToMemoryStore(CertStoreSaveAs dwSaveAs);
    public static ILoaderPal FromBlob(Byte[] rawData, SafePasswordHandle password, X509KeyStorageFlags keyStorageFlags);
    public static ILoaderPal FromFile(string fileName, SafePasswordHandle password, X509KeyStorageFlags keyStorageFlags);
    private static StorePal FromBlobOrFile(Byte[] rawData, string fileName, SafePasswordHandle password, X509KeyStorageFlags keyStorageFlags);
    public static IExportPal FromCertificate(ICertificatePalCore cert);
    public static IExportPal LinkFromCertificateCollection(X509Certificate2Collection certificates);
    public static IStorePal FromSystemStore(string storeName, StoreLocation storeLocation, OpenFlags openFlags);
    private static PfxCertStoreFlags MapKeyStorageFlags(X509KeyStorageFlags keyStorageFlags);
    private static CertStoreFlags MapX509StoreFlags(StoreLocation storeLocation, OpenFlags flags);
}
internal class Internal.Cryptography.Pal.X509Pal : object {
    public static IX509Pal Instance;
    public bool SupportsLegacyBasicConstraintsExtension { get; }
    private static X509Pal();
    public sealed virtual Byte[] EncodeX509KeyUsageExtension(X509KeyUsageFlags keyUsages);
    public sealed virtual void DecodeX509KeyUsageExtension(Byte[] encoded, X509KeyUsageFlags& keyUsages);
    public sealed virtual bool get_SupportsLegacyBasicConstraintsExtension();
    public sealed virtual Byte[] EncodeX509BasicConstraints2Extension(bool certificateAuthority, bool hasPathLengthConstraint, int pathLengthConstraint);
    public sealed virtual void DecodeX509BasicConstraintsExtension(Byte[] encoded, Boolean& certificateAuthority, Boolean& hasPathLengthConstraint, Int32& pathLengthConstraint);
    public sealed virtual void DecodeX509BasicConstraints2Extension(Byte[] encoded, Boolean& certificateAuthority, Boolean& hasPathLengthConstraint, Int32& pathLengthConstraint);
    public sealed virtual Byte[] EncodeX509EnhancedKeyUsageExtension(OidCollection usages);
    public sealed virtual void DecodeX509EnhancedKeyUsageExtension(Byte[] encoded, OidCollection& usages);
    public sealed virtual Byte[] EncodeX509SubjectKeyIdentifierExtension(Byte[] subjectKeyIdentifier);
    public sealed virtual void DecodeX509SubjectKeyIdentifierExtension(Byte[] encoded, Byte[]& subjectKeyIdentifier);
    public sealed virtual Byte[] ComputeCapiSha1OfPublicKey(PublicKey key);
    public sealed virtual X509ContentType GetCertContentType(Byte[] rawData);
    public sealed virtual X509ContentType GetCertContentType(string fileName);
    private static X509ContentType MapContentType(ContentType contentType);
    public sealed virtual AsymmetricAlgorithm DecodePublicKey(Oid oid, Byte[] encodedKeyValue, Byte[] encodedParameters, ICertificatePal certificatePal);
    private static ECDsa DecodeECDsaPublicKey(CertificatePal certificatePal);
    private static SafeBCryptKeyHandle ImportPublicKeyInfo(SafeCertContextHandle certContext);
    private static Byte[] ExportKeyBlob(SafeBCryptKeyHandle bCryptKeyHandle, CngKeyBlobFormat blobFormat);
    private static void ExportNamedCurveParameters(ECParameters& ecParams, Byte[] ecBlob, bool includePrivateParameters);
    private static Byte[] DecodeKeyBlob(CryptDecodeObjectStructType lpszStructType, Byte[] encodedKeyValue);
    private static Byte[] ConstructDSSPublicKeyCspBlob(Byte[] encodedKeyValue, Byte[] encodedParameters);
    private static Byte[] DecodeDssKeyValue(Byte[] encodedKeyValue);
    private static void DecodeDssParameters(Byte[] encodedParameters, Byte[]& p, Byte[]& q, Byte[]& g);
    private static bool HasExplicitParameters(SafeBCryptKeyHandle bcryptHandle);
    private static string GetCurveName(SafeBCryptKeyHandle bcryptHandle);
    private static string GetPropertyAsString(SafeBCryptKeyHandle cryptHandle, string propertyName);
    private static Byte[] GetProperty(SafeBCryptKeyHandle cryptHandle, string propertyName);
    public sealed virtual string X500DistinguishedNameDecode(Byte[] encodedDistinguishedName, X500DistinguishedNameFlags flag);
    public sealed virtual Byte[] X500DistinguishedNameEncode(string distinguishedName, X500DistinguishedNameFlags flag);
    public sealed virtual string X500DistinguishedNameFormat(Byte[] encodedDistinguishedName, bool multiLine);
    private static CertNameStrTypeAndFlags MapNameToStrFlag(X500DistinguishedNameFlags flag);
}
internal class Internal.Cryptography.PinAndClear : ValueType {
    private Byte[] _data;
    private GCHandle _gcHandle;
    internal static PinAndClear Track(Byte[] data);
    public sealed virtual void Dispose();
}
internal static class Interop : object {
}
internal abstract class Microsoft.Win32.SafeHandles.SafeBCryptHandle : SafeHandle {
    public bool IsInvalid { get; }
    public sealed virtual bool get_IsInvalid();
    protected abstract virtual bool ReleaseHandle();
}
internal class Microsoft.Win32.SafeHandles.SafeBCryptKeyHandle : SafeBCryptHandle {
    protected sealed virtual bool ReleaseHandle();
}
internal static class Microsoft.Win32.SafeHandles.SafeHandleCache`1 : object {
    private static T s_invalidHandle;
    internal static T GetInvalidHandle(Func`1<T> invalidHandleFactory);
    internal static bool IsCachedInvalidHandle(SafeHandle handle);
}
internal class Microsoft.Win32.SafeHandles.SafePasswordHandle : SafeHandle {
    public bool IsInvalid { get; }
    public static SafePasswordHandle InvalidHandle { get; }
    public SafePasswordHandle(string password);
    public SafePasswordHandle(SecureString password);
    protected virtual bool ReleaseHandle();
    protected virtual void Dispose(bool disposing);
    public virtual bool get_IsInvalid();
    public static SafePasswordHandle get_InvalidHandle();
    private IntPtr CreateHandle(string password);
    private IntPtr CreateHandle(SecureString password);
    private void FreeHandle();
}
public class Microsoft.Win32.SafeHandles.SafeX509ChainHandle : SafeHandleZeroOrMinusOneIsInvalid {
    internal static SafeX509ChainHandle InvalidHandle { get; }
    internal static SafeX509ChainHandle get_InvalidHandle();
    protected virtual bool ReleaseHandle();
    protected virtual void Dispose(bool disposing);
}
internal class System.Buffers.PointerMemoryManager`1 : MemoryManager`1<T> {
    private Void* _pointer;
    private int _length;
    internal PointerMemoryManager`1(Void* pointer, int length);
    protected virtual void Dispose(bool disposing);
    public virtual Span`1<T> GetSpan();
    public virtual MemoryHandle Pin(int elementIndex);
    public virtual void Unpin();
}
internal class System.Security.Cryptography.Asn1.AlgorithmIdentifierAsn : ValueType {
    internal Oid Algorithm;
    internal Nullable`1<ReadOnlyMemory`1<byte>> Parameters;
    internal static ReadOnlyMemory`1<byte> ExplicitDerNull;
    private static AlgorithmIdentifierAsn();
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static AlgorithmIdentifierAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static AlgorithmIdentifierAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, AlgorithmIdentifierAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.Asn1Tag : ValueType {
    private byte _controlFlags;
    [CompilerGeneratedAttribute]
private int <TagValue>k__BackingField;
    public static Asn1Tag EndOfContents;
    public static Asn1Tag Boolean;
    public static Asn1Tag Integer;
    public static Asn1Tag PrimitiveBitString;
    public static Asn1Tag ConstructedBitString;
    public static Asn1Tag PrimitiveOctetString;
    public static Asn1Tag ConstructedOctetString;
    public static Asn1Tag Null;
    public static Asn1Tag ObjectIdentifier;
    public static Asn1Tag Enumerated;
    public static Asn1Tag Sequence;
    public static Asn1Tag SetOf;
    public static Asn1Tag UtcTime;
    public static Asn1Tag GeneralizedTime;
    public TagClass TagClass { get; }
    public bool IsConstructed { get; }
    public int TagValue { get; private set; }
    private Asn1Tag(byte controlFlags, int tagValue);
    public Asn1Tag(UniversalTagNumber universalTagNumber, bool isConstructed);
    public Asn1Tag(TagClass tagClass, int tagValue, bool isConstructed);
    private static Asn1Tag();
    public TagClass get_TagClass();
    public bool get_IsConstructed();
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public int get_TagValue();
    [CompilerGeneratedAttribute]
private void set_TagValue(int value);
    public Asn1Tag AsConstructed();
    public Asn1Tag AsPrimitive();
    public static bool TryDecode(ReadOnlySpan`1<byte> source, Asn1Tag& tag, Int32& bytesConsumed);
    public int CalculateEncodedSize();
    public bool TryEncode(Span`1<byte> destination, Int32& bytesWritten);
    public sealed virtual bool Equals(Asn1Tag other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Asn1Tag left, Asn1Tag right);
    public static bool op_Inequality(Asn1Tag left, Asn1Tag right);
    public bool HasSameClassAndValue(Asn1Tag other);
    public virtual string ToString();
}
internal static class System.Security.Cryptography.Asn1.AsnCharacterStringEncodings : object {
    private static Encoding s_utf8Encoding;
    private static Encoding s_bmpEncoding;
    private static Encoding s_ia5Encoding;
    private static Encoding s_visibleStringEncoding;
    private static Encoding s_numericStringEncoding;
    private static Encoding s_printableStringEncoding;
    private static Encoding s_t61Encoding;
    private static AsnCharacterStringEncodings();
    internal static Encoding GetEncoding(UniversalTagNumber encodingType);
}
internal enum System.Security.Cryptography.Asn1.AsnEncodingRules : Enum {
    public int value__;
    public static AsnEncodingRules BER;
    public static AsnEncodingRules CER;
    public static AsnEncodingRules DER;
}
internal class System.Security.Cryptography.Asn1.AsnReader : object {
    private ReadOnlyMemory`1<byte> _data;
    [CompilerGeneratedAttribute]
private AsnEncodingRules <RuleSet>k__BackingField;
    public AsnEncodingRules RuleSet { get; }
    public bool HasData { get; }
    public AsnReader(ReadOnlyMemory`1<byte> data, AsnEncodingRules ruleSet);
    [CompilerGeneratedAttribute]
public AsnEncodingRules get_RuleSet();
    public bool get_HasData();
    public void ThrowIfNotEmpty();
    public Asn1Tag PeekTag();
    public ReadOnlyMemory`1<byte> PeekEncodedValue();
    public ReadOnlyMemory`1<byte> PeekContentBytes();
    public ReadOnlyMemory`1<byte> ReadEncodedValue();
    private static bool TryReadLength(ReadOnlySpan`1<byte> source, AsnEncodingRules ruleSet, Nullable`1& length, Int32& bytesRead);
    internal Asn1Tag ReadTagAndLength(Nullable`1& contentsLength, Int32& bytesRead);
    private static void ValidateEndOfContents(Asn1Tag tag, Nullable`1<int> length, int headerLength);
    private int SeekEndOfContents(ReadOnlyMemory`1<byte> source);
    private static ReadOnlyMemory`1<byte> Slice(ReadOnlyMemory`1<byte> source, int offset, Nullable`1<int> length);
    private static void CheckEncodingRules(AsnEncodingRules ruleSet);
    private static void CheckExpectedTag(Asn1Tag tag, Asn1Tag expectedTag, UniversalTagNumber tagNumber);
    public Oid ReadObjectIdentifier();
    public Oid ReadObjectIdentifier(Asn1Tag expectedTag);
    private static void ReadSubIdentifier(ReadOnlySpan`1<byte> source, Int32& bytesRead, Nullable`1& smallValue, Nullable`1& largeValue);
    private string ReadObjectIdentifierAsString(Asn1Tag expectedTag, Int32& totalBytesRead);
    public AsnReader ReadSequence(Asn1Tag expectedTag);
}
internal class System.Security.Cryptography.Asn1.AsnWriter : object {
    private Byte[] _buffer;
    private int _offset;
    private Stack`1<ValueTuple`3<Asn1Tag, int, UniversalTagNumber>> _nestingStack;
    [CompilerGeneratedAttribute]
private AsnEncodingRules <RuleSet>k__BackingField;
    public AsnEncodingRules RuleSet { get; }
    public AsnWriter(AsnEncodingRules ruleSet);
    [CompilerGeneratedAttribute]
public AsnEncodingRules get_RuleSet();
    public sealed virtual void Dispose();
    public Byte[] Encode();
    internal ReadOnlySpan`1<byte> EncodeAsSpan();
    private void CheckDisposed();
    private void EnsureWriteCapacity(int pendingCount);
    private void WriteTag(Asn1Tag tag);
    private void WriteLength(int length);
    private static int GetEncodedLengthSubsequentByteCount(int length);
    public void WriteEncodedValue(ReadOnlySpan`1<byte> preEncodedValue);
    private void WriteEncodedValue(ReadOnlyMemory`1<byte> preEncodedValue);
    private void WriteEndOfContents();
    private void PushTag(Asn1Tag tag, UniversalTagNumber tagType);
    private void PopTag(Asn1Tag tag, UniversalTagNumber tagType, bool sortContents);
    private static void SortContents(Byte[] buffer, int start, int end);
    internal static void Reverse(Span`1<byte> span);
    private static void CheckUniversalTag(Asn1Tag tag, UniversalTagNumber universalTagNumber);
    public void WriteBitString(ReadOnlySpan`1<byte> bitString, int unusedBitCount);
    public void WriteBitString(Asn1Tag tag, ReadOnlySpan`1<byte> bitString, int unusedBitCount);
    private void WriteBitStringCore(Asn1Tag tag, ReadOnlySpan`1<byte> bitString, int unusedBitCount);
    private static bool CheckValidLastByte(byte lastByte, int unusedBitCount);
    private static int DetermineCerBitStringTotalLength(Asn1Tag tag, int contentLength);
    private void WriteConstructedCerBitString(Asn1Tag tag, ReadOnlySpan`1<byte> payload, int unusedBitCount);
    public void WriteBoolean(bool value);
    private void WriteBooleanCore(Asn1Tag tag, bool value);
    public void WriteGeneralizedTime(DateTimeOffset value, bool omitFractionalSeconds);
    private void WriteGeneralizedTimeCore(Asn1Tag tag, DateTimeOffset value, bool omitFractionalSeconds);
    public void WriteInteger(long value);
    public void WriteInteger(BigInteger value);
    public void WriteInteger(ReadOnlySpan`1<byte> value);
    public void WriteIntegerUnsigned(ReadOnlySpan`1<byte> value);
    private void WriteIntegerCore(Asn1Tag tag, long value);
    private void WriteNonNegativeIntegerCore(Asn1Tag tag, ulong value);
    private void WriteIntegerUnsignedCore(Asn1Tag tag, ReadOnlySpan`1<byte> value);
    private void WriteIntegerCore(Asn1Tag tag, ReadOnlySpan`1<byte> value);
    private void WriteIntegerCore(Asn1Tag tag, BigInteger value);
    public void WriteNull();
    private void WriteNullCore(Asn1Tag tag);
    public void WriteOctetString(ReadOnlySpan`1<byte> octetString);
    public void WriteOctetString(Asn1Tag tag, ReadOnlySpan`1<byte> octetString);
    private void WriteOctetStringCore(Asn1Tag tag, ReadOnlySpan`1<byte> octetString);
    private void WriteConstructedCerOctetString(Asn1Tag tag, ReadOnlySpan`1<byte> payload);
    public void WriteObjectIdentifier(Oid oid);
    public void WriteObjectIdentifier(string oidValue);
    public void WriteObjectIdentifier(ReadOnlySpan`1<char> oidValue);
    public void WriteObjectIdentifier(Asn1Tag tag, string oidValue);
    public void WriteObjectIdentifier(Asn1Tag tag, ReadOnlySpan`1<char> oidValue);
    private void WriteObjectIdentifierCore(Asn1Tag tag, ReadOnlySpan`1<char> oidValue);
    private static BigInteger ParseSubIdentifier(ReadOnlySpan`1& oidValue);
    private static int AtoI(char c);
    private static int EncodeSubIdentifier(Span`1<byte> dest, BigInteger& subIdentifier);
    public void PushSequence();
    public void PushSequence(Asn1Tag tag);
    public void PopSequence();
    public void PopSequence(Asn1Tag tag);
    private void PushSequenceCore(Asn1Tag tag);
    private void PopSequenceCore(Asn1Tag tag);
    public void PushSetOf();
    public void PushSetOf(Asn1Tag tag);
    public void PopSetOf();
    public void PopSetOf(Asn1Tag tag);
    private void PushSetOfCore(Asn1Tag tag);
    private void PopSetOfCore(Asn1Tag tag);
    public void WriteCharacterString(UniversalTagNumber encodingType, string str);
    public void WriteCharacterString(UniversalTagNumber encodingType, ReadOnlySpan`1<char> str);
    public void WriteCharacterString(Asn1Tag tag, UniversalTagNumber encodingType, string str);
    public void WriteCharacterString(Asn1Tag tag, UniversalTagNumber encodingType, ReadOnlySpan`1<char> str);
    private void WriteCharacterStringCore(Asn1Tag tag, Encoding encoding, ReadOnlySpan`1<char> str);
    private void WriteConstructedCerCharacterString(Asn1Tag tag, Encoding encoding, ReadOnlySpan`1<char> str, int size);
    public void WriteUtcTime(DateTimeOffset value);
    private void WriteUtcTimeCore(Asn1Tag tag, DateTimeOffset value);
}
internal class System.Security.Cryptography.Asn1.AttributeAsn : ValueType {
    internal Oid AttrType;
    internal ReadOnlyMemory`1[] AttrValues;
    public AttributeAsn(AsnEncodedData attribute);
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
}
internal class System.Security.Cryptography.Asn1.BMPEncoding : SpanBasedEncoding {
    protected virtual int GetBytes(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, bool write);
    protected virtual int GetChars(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, bool write);
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
}
internal class System.Security.Cryptography.Asn1.DirectoryStringAsn : ValueType {
    internal string TeletexString;
    internal string PrintableString;
    internal Nullable`1<ReadOnlyMemory`1<byte>> UniversalString;
    internal string Utf8String;
    internal string BmpString;
    internal void Encode(AsnWriter writer);
}
internal class System.Security.Cryptography.Asn1.EdiPartyNameAsn : ValueType {
    internal Nullable`1<DirectoryStringAsn> NameAssigner;
    internal DirectoryStringAsn PartyName;
    internal void Encode(AsnWriter writer, Asn1Tag tag);
}
internal class System.Security.Cryptography.Asn1.GeneralNameAsn : ValueType {
    internal Nullable`1<OtherNameAsn> OtherName;
    internal string Rfc822Name;
    internal string DnsName;
    internal Nullable`1<ReadOnlyMemory`1<byte>> X400Address;
    internal Nullable`1<ReadOnlyMemory`1<byte>> DirectoryName;
    internal Nullable`1<EdiPartyNameAsn> EdiPartyName;
    internal string Uri;
    internal Nullable`1<ReadOnlyMemory`1<byte>> IPAddress;
    internal string RegisteredId;
    internal void Encode(AsnWriter writer);
}
internal class System.Security.Cryptography.Asn1.IA5Encoding : RestrictedAsciiStringEncoding {
}
internal class System.Security.Cryptography.Asn1.NumericStringEncoding : RestrictedAsciiStringEncoding {
}
internal class System.Security.Cryptography.Asn1.OtherNameAsn : ValueType {
    internal string TypeId;
    internal ReadOnlyMemory`1<byte> Value;
    internal void Encode(AsnWriter writer, Asn1Tag tag);
}
internal class System.Security.Cryptography.Asn1.PrintableStringEncoding : RestrictedAsciiStringEncoding {
}
internal class System.Security.Cryptography.Asn1.PssParamsAsn : ValueType {
    private static Byte[] s_defaultHashAlgorithm;
    private static Byte[] s_defaultMaskGenAlgorithm;
    private static Byte[] s_defaultSaltLength;
    private static Byte[] s_defaultTrailerField;
    internal AlgorithmIdentifierAsn HashAlgorithm;
    internal AlgorithmIdentifierAsn MaskGenAlgorithm;
    internal int SaltLength;
    internal int TrailerField;
    private static PssParamsAsn();
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
}
internal abstract class System.Security.Cryptography.Asn1.RestrictedAsciiStringEncoding : SpanBasedEncoding {
    private Boolean[] _isAllowed;
    protected RestrictedAsciiStringEncoding(byte minCharAllowed, byte maxCharAllowed);
    protected RestrictedAsciiStringEncoding(IEnumerable`1<char> allowedChars);
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    protected virtual int GetBytes(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, bool write);
    protected virtual int GetChars(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, bool write);
}
internal class System.Security.Cryptography.Asn1.SetOfValueComparer : object {
    [CompilerGeneratedAttribute]
private static SetOfValueComparer <Instance>k__BackingField;
    internal static SetOfValueComparer Instance { get; }
    private static SetOfValueComparer();
    [CompilerGeneratedAttribute]
internal static SetOfValueComparer get_Instance();
    public sealed virtual int Compare(ReadOnlyMemory`1<byte> x, ReadOnlyMemory`1<byte> y);
}
internal abstract class System.Security.Cryptography.Asn1.SpanBasedEncoding : Encoding {
    protected abstract virtual int GetBytes(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, bool write);
    protected abstract virtual int GetChars(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, bool write);
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetByteCount(Char* chars, int count);
    public virtual int GetByteCount(string s);
    public virtual int GetByteCount(ReadOnlySpan`1<char> chars);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    public virtual int GetCharCount(Byte* bytes, int count);
    public virtual int GetCharCount(ReadOnlySpan`1<byte> bytes);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
}
internal class System.Security.Cryptography.Asn1.SubjectPublicKeyInfoAsn : ValueType {
    internal AlgorithmIdentifierAsn Algorithm;
    internal ReadOnlyMemory`1<byte> SubjectPublicKey;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
}
internal class System.Security.Cryptography.Asn1.T61Encoding : Encoding {
    private static Encoding s_utf8Encoding;
    private static Encoding s_latin1Encoding;
    private static T61Encoding();
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetByteCount(Char* chars, int count);
    public virtual int GetByteCount(string s);
    public virtual int GetByteCount(ReadOnlySpan`1<char> chars);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    public virtual int GetCharCount(Byte* bytes, int count);
    public virtual int GetCharCount(ReadOnlySpan`1<byte> bytes);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
}
internal enum System.Security.Cryptography.Asn1.TagClass : Enum {
    public byte value__;
    public static TagClass Universal;
    public static TagClass Application;
    public static TagClass ContextSpecific;
    public static TagClass Private;
}
internal enum System.Security.Cryptography.Asn1.UniversalTagNumber : Enum {
    public int value__;
    public static UniversalTagNumber EndOfContents;
    public static UniversalTagNumber Boolean;
    public static UniversalTagNumber Integer;
    public static UniversalTagNumber BitString;
    public static UniversalTagNumber OctetString;
    public static UniversalTagNumber Null;
    public static UniversalTagNumber ObjectIdentifier;
    public static UniversalTagNumber ObjectDescriptor;
    public static UniversalTagNumber External;
    public static UniversalTagNumber InstanceOf;
    public static UniversalTagNumber Real;
    public static UniversalTagNumber Enumerated;
    public static UniversalTagNumber Embedded;
    public static UniversalTagNumber UTF8String;
    public static UniversalTagNumber RelativeObjectIdentifier;
    public static UniversalTagNumber Time;
    public static UniversalTagNumber Sequence;
    public static UniversalTagNumber SequenceOf;
    public static UniversalTagNumber Set;
    public static UniversalTagNumber SetOf;
    public static UniversalTagNumber NumericString;
    public static UniversalTagNumber PrintableString;
    public static UniversalTagNumber TeletexString;
    public static UniversalTagNumber T61String;
    public static UniversalTagNumber VideotexString;
    public static UniversalTagNumber IA5String;
    public static UniversalTagNumber UtcTime;
    public static UniversalTagNumber GeneralizedTime;
    public static UniversalTagNumber GraphicString;
    public static UniversalTagNumber VisibleString;
    public static UniversalTagNumber ISO646String;
    public static UniversalTagNumber GeneralString;
    public static UniversalTagNumber UniversalString;
    public static UniversalTagNumber UnrestrictedCharacterString;
    public static UniversalTagNumber BMPString;
    public static UniversalTagNumber Date;
    public static UniversalTagNumber TimeOfDay;
    public static UniversalTagNumber DateTime;
    public static UniversalTagNumber Duration;
    public static UniversalTagNumber ObjectIdentifierIRI;
    public static UniversalTagNumber RelativeObjectIdentifierIRI;
}
internal class System.Security.Cryptography.Asn1.VisibleStringEncoding : RestrictedAsciiStringEncoding {
}
internal class System.Security.Cryptography.Asn1.X509ExtensionAsn : ValueType {
    private static Byte[] s_defaultCritical;
    internal Oid ExtnId;
    internal bool Critical;
    internal ReadOnlyMemory`1<byte> ExtnValue;
    public X509ExtensionAsn(X509Extension extension);
    private static X509ExtensionAsn();
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
}
internal static class System.Security.Cryptography.CryptoPool : object {
    internal static Byte[] Rent(int minimumLength);
    internal static void Return(Byte[] array, int clearSize);
}
[ExtensionAttribute]
internal static class System.Security.Cryptography.KeyBlobHelpers : object {
    [ExtensionAttribute]
internal static void WriteKeyParameterInteger(AsnWriter writer, ReadOnlySpan`1<byte> integer);
}
internal class System.Security.Cryptography.X509Certificates.Asn1.CertificateAsn : ValueType {
    internal TbsCertificateAsn TbsCertificate;
    internal AlgorithmIdentifierAsn SignatureAlgorithm;
    internal ReadOnlyMemory`1<byte> SignatureValue;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
}
internal class System.Security.Cryptography.X509Certificates.Asn1.CertificationRequestAsn : ValueType {
    internal CertificationRequestInfoAsn CertificationRequestInfo;
    internal AlgorithmIdentifierAsn SignatureAlgorithm;
    internal ReadOnlyMemory`1<byte> SignatureValue;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
}
internal class System.Security.Cryptography.X509Certificates.Asn1.CertificationRequestInfoAsn : ValueType {
    internal BigInteger Version;
    internal ReadOnlyMemory`1<byte> Subject;
    internal SubjectPublicKeyInfoAsn SubjectPublicKeyInfo;
    internal AttributeAsn[] Attributes;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
}
internal class System.Security.Cryptography.X509Certificates.Asn1.TbsCertificateAsn : ValueType {
    private static Byte[] s_defaultVersion;
    internal int Version;
    internal ReadOnlyMemory`1<byte> SerialNumber;
    internal AlgorithmIdentifierAsn SignatureAlgorithm;
    internal ReadOnlyMemory`1<byte> Issuer;
    internal ValidityAsn Validity;
    internal ReadOnlyMemory`1<byte> Subject;
    internal SubjectPublicKeyInfoAsn SubjectPublicKeyInfo;
    internal Nullable`1<ReadOnlyMemory`1<byte>> IssuerUniqueId;
    internal Nullable`1<ReadOnlyMemory`1<byte>> SubjectUniqueId;
    internal X509ExtensionAsn[] Extensions;
    private static TbsCertificateAsn();
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
}
internal class System.Security.Cryptography.X509Certificates.Asn1.TimeAsn : ValueType {
    internal Nullable`1<DateTimeOffset> UtcTime;
    internal Nullable`1<DateTimeOffset> GeneralTime;
    public TimeAsn(DateTimeOffset dateTimeOffset);
    internal void Encode(AsnWriter writer);
}
internal class System.Security.Cryptography.X509Certificates.Asn1.ValidityAsn : ValueType {
    internal TimeAsn NotBefore;
    internal TimeAsn NotAfter;
    public ValidityAsn(DateTimeOffset notBefore, DateTimeOffset notAfter);
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
}
public class System.Security.Cryptography.X509Certificates.CertificateRequest : object {
    private AsymmetricAlgorithm _key;
    private X509SignatureGenerator _generator;
    private RSASignaturePadding _rsaPadding;
    [CompilerGeneratedAttribute]
private X500DistinguishedName <SubjectName>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<X509Extension> <CertificateExtensions>k__BackingField;
    [CompilerGeneratedAttribute]
private PublicKey <PublicKey>k__BackingField;
    [CompilerGeneratedAttribute]
private HashAlgorithmName <HashAlgorithm>k__BackingField;
    public X500DistinguishedName SubjectName { get; }
    public Collection`1<X509Extension> CertificateExtensions { get; }
    public PublicKey PublicKey { get; }
    public HashAlgorithmName HashAlgorithm { get; }
    public CertificateRequest(string subjectName, ECDsa key, HashAlgorithmName hashAlgorithm);
    public CertificateRequest(X500DistinguishedName subjectName, ECDsa key, HashAlgorithmName hashAlgorithm);
    public CertificateRequest(string subjectName, RSA key, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public CertificateRequest(X500DistinguishedName subjectName, RSA key, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public CertificateRequest(X500DistinguishedName subjectName, PublicKey publicKey, HashAlgorithmName hashAlgorithm);
    [CompilerGeneratedAttribute]
public X500DistinguishedName get_SubjectName();
    [CompilerGeneratedAttribute]
public Collection`1<X509Extension> get_CertificateExtensions();
    [CompilerGeneratedAttribute]
public PublicKey get_PublicKey();
    [CompilerGeneratedAttribute]
public HashAlgorithmName get_HashAlgorithm();
    public Byte[] CreateSigningRequest();
    public Byte[] CreateSigningRequest(X509SignatureGenerator signatureGenerator);
    public X509Certificate2 CreateSelfSigned(DateTimeOffset notBefore, DateTimeOffset notAfter);
    public X509Certificate2 Create(X509Certificate2 issuerCertificate, DateTimeOffset notBefore, DateTimeOffset notAfter, Byte[] serialNumber);
    public X509Certificate2 Create(X500DistinguishedName issuerName, X509SignatureGenerator generator, DateTimeOffset notBefore, DateTimeOffset notAfter, Byte[] serialNumber);
    private ReadOnlyMemory`1<byte> NormalizeSerialNumber(Byte[] serialNumber);
}
[ExtensionAttribute]
public static class System.Security.Cryptography.X509Certificates.DSACertificateExtensions : object {
    [ExtensionAttribute]
public static DSA GetDSAPublicKey(X509Certificate2 certificate);
    [ExtensionAttribute]
public static DSA GetDSAPrivateKey(X509Certificate2 certificate);
    [ExtensionAttribute]
public static X509Certificate2 CopyWithPrivateKey(X509Certificate2 certificate, DSA privateKey);
}
[ExtensionAttribute]
public static class System.Security.Cryptography.X509Certificates.ECDsaCertificateExtensions : object {
    [ExtensionAttribute]
public static ECDsa GetECDsaPublicKey(X509Certificate2 certificate);
    [ExtensionAttribute]
public static ECDsa GetECDsaPrivateKey(X509Certificate2 certificate);
    [ExtensionAttribute]
public static X509Certificate2 CopyWithPrivateKey(X509Certificate2 certificate, ECDsa privateKey);
    private static bool HasECDsaKeyUsage(X509Certificate2 certificate);
    private static bool IsSameKey(ECDsa a, ECDsa b);
}
internal class System.Security.Cryptography.X509Certificates.ECDsaX509SignatureGenerator : X509SignatureGenerator {
    private ECDsa _key;
    internal ECDsaX509SignatureGenerator(ECDsa key);
    public virtual Byte[] GetSignatureAlgorithmIdentifier(HashAlgorithmName hashAlgorithm);
    public virtual Byte[] SignData(Byte[] data, HashAlgorithmName hashAlgorithm);
    protected virtual PublicKey BuildPublicKey();
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.OpenFlags : Enum {
    public int value__;
    public static OpenFlags ReadOnly;
    public static OpenFlags ReadWrite;
    public static OpenFlags MaxAllowed;
    public static OpenFlags OpenExistingOnly;
    public static OpenFlags IncludeArchived;
}
internal class System.Security.Cryptography.X509Certificates.Pkcs10CertificationRequestInfo : object {
    [CompilerGeneratedAttribute]
private X500DistinguishedName <Subject>k__BackingField;
    [CompilerGeneratedAttribute]
private PublicKey <PublicKey>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<X501Attribute> <Attributes>k__BackingField;
    internal X500DistinguishedName Subject { get; internal set; }
    internal PublicKey PublicKey { get; internal set; }
    internal Collection`1<X501Attribute> Attributes { get; }
    internal Pkcs10CertificationRequestInfo(X500DistinguishedName subject, PublicKey publicKey, IEnumerable`1<X501Attribute> attributes);
    [CompilerGeneratedAttribute]
internal X500DistinguishedName get_Subject();
    [CompilerGeneratedAttribute]
internal void set_Subject(X500DistinguishedName value);
    [CompilerGeneratedAttribute]
internal PublicKey get_PublicKey();
    [CompilerGeneratedAttribute]
internal void set_PublicKey(PublicKey value);
    [CompilerGeneratedAttribute]
internal Collection`1<X501Attribute> get_Attributes();
    internal Byte[] ToPkcs10Request(X509SignatureGenerator signatureGenerator, HashAlgorithmName hashAlgorithm);
}
internal class System.Security.Cryptography.X509Certificates.Pkcs9ExtensionRequest : X501Attribute {
    internal Pkcs9ExtensionRequest(IEnumerable`1<X509Extension> extensions);
    private static Byte[] EncodeAttribute(IEnumerable`1<X509Extension> extensions);
}
public class System.Security.Cryptography.X509Certificates.PublicKey : object {
    private Oid _oid;
    private AsymmetricAlgorithm _key;
    [CompilerGeneratedAttribute]
private AsnEncodedData <EncodedKeyValue>k__BackingField;
    [CompilerGeneratedAttribute]
private AsnEncodedData <EncodedParameters>k__BackingField;
    public AsnEncodedData EncodedKeyValue { get; private set; }
    public AsnEncodedData EncodedParameters { get; private set; }
    public AsymmetricAlgorithm Key { get; }
    public Oid Oid { get; }
    public PublicKey(Oid oid, AsnEncodedData parameters, AsnEncodedData keyValue);
    [CompilerGeneratedAttribute]
public AsnEncodedData get_EncodedKeyValue();
    [CompilerGeneratedAttribute]
private void set_EncodedKeyValue(AsnEncodedData value);
    [CompilerGeneratedAttribute]
public AsnEncodedData get_EncodedParameters();
    [CompilerGeneratedAttribute]
private void set_EncodedParameters(AsnEncodedData value);
    public AsymmetricAlgorithm get_Key();
    public Oid get_Oid();
}
[ExtensionAttribute]
public static class System.Security.Cryptography.X509Certificates.RSACertificateExtensions : object {
    [ExtensionAttribute]
public static RSA GetRSAPublicKey(X509Certificate2 certificate);
    [ExtensionAttribute]
public static RSA GetRSAPrivateKey(X509Certificate2 certificate);
    [ExtensionAttribute]
public static X509Certificate2 CopyWithPrivateKey(X509Certificate2 certificate, RSA privateKey);
}
internal class System.Security.Cryptography.X509Certificates.RSAPkcs1X509SignatureGenerator : X509SignatureGenerator {
    private RSA _key;
    internal RSAPkcs1X509SignatureGenerator(RSA key);
    public virtual Byte[] SignData(Byte[] data, HashAlgorithmName hashAlgorithm);
    protected virtual PublicKey BuildPublicKey();
    internal static PublicKey BuildPublicKey(RSA rsa);
    public virtual Byte[] GetSignatureAlgorithmIdentifier(HashAlgorithmName hashAlgorithm);
}
internal class System.Security.Cryptography.X509Certificates.RSAPssX509SignatureGenerator : X509SignatureGenerator {
    private RSA _key;
    private RSASignaturePadding _padding;
    internal RSAPssX509SignatureGenerator(RSA key, RSASignaturePadding padding);
    public virtual Byte[] GetSignatureAlgorithmIdentifier(HashAlgorithmName hashAlgorithm);
    public virtual Byte[] SignData(Byte[] data, HashAlgorithmName hashAlgorithm);
    protected virtual PublicKey BuildPublicKey();
}
public enum System.Security.Cryptography.X509Certificates.StoreLocation : Enum {
    public int value__;
    public static StoreLocation CurrentUser;
    public static StoreLocation LocalMachine;
}
public enum System.Security.Cryptography.X509Certificates.StoreName : Enum {
    public int value__;
    public static StoreName AddressBook;
    public static StoreName AuthRoot;
    public static StoreName CertificateAuthority;
    public static StoreName Disallowed;
    public static StoreName My;
    public static StoreName Root;
    public static StoreName TrustedPeople;
    public static StoreName TrustedPublisher;
}
public class System.Security.Cryptography.X509Certificates.SubjectAlternativeNameBuilder : object {
    private static IdnMapping s_idnMapping;
    private List`1<Byte[]> _encodedNames;
    private static SubjectAlternativeNameBuilder();
    public void AddEmailAddress(string emailAddress);
    public void AddDnsName(string dnsName);
    public void AddUri(Uri uri);
    public void AddIpAddress(IPAddress ipAddress);
    public void AddUserPrincipalName(string upn);
    public X509Extension Build(bool critical);
    private void AddGeneralName(GeneralNameAsn generalName);
}
public class System.Security.Cryptography.X509Certificates.X500DistinguishedName : AsnEncodedData {
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _lazyDistinguishedName;
    public string Name { get; }
    public X500DistinguishedName(Byte[] encodedDistinguishedName);
    public X500DistinguishedName(AsnEncodedData encodedDistinguishedName);
    public X500DistinguishedName(X500DistinguishedName distinguishedName);
    public X500DistinguishedName(string distinguishedName);
    public X500DistinguishedName(string distinguishedName, X500DistinguishedNameFlags flag);
    public string get_Name();
    public string Decode(X500DistinguishedNameFlags flag);
    public virtual string Format(bool multiLine);
    private static Byte[] Encode(string distinguishedName, X500DistinguishedNameFlags flags);
    private static void ThrowIfInvalid(X500DistinguishedNameFlags flags);
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.X500DistinguishedNameFlags : Enum {
    public int value__;
    public static X500DistinguishedNameFlags None;
    public static X500DistinguishedNameFlags Reversed;
    public static X500DistinguishedNameFlags UseSemicolons;
    public static X500DistinguishedNameFlags DoNotUsePlusSign;
    public static X500DistinguishedNameFlags DoNotUseQuotes;
    public static X500DistinguishedNameFlags UseCommas;
    public static X500DistinguishedNameFlags UseNewLines;
    public static X500DistinguishedNameFlags UseUTF8Encoding;
    public static X500DistinguishedNameFlags UseT61Encoding;
    public static X500DistinguishedNameFlags ForceUTF8Encoding;
}
internal class System.Security.Cryptography.X509Certificates.X501Attribute : AsnEncodedData {
    internal X501Attribute(string oid, Byte[] rawData);
}
public class System.Security.Cryptography.X509Certificates.X509BasicConstraintsExtension : X509Extension {
    private bool _certificateAuthority;
    private bool _hasPathLenConstraint;
    private int _pathLenConstraint;
    private bool _decoded;
    public bool CertificateAuthority { get; }
    public bool HasPathLengthConstraint { get; }
    public int PathLengthConstraint { get; }
    public X509BasicConstraintsExtension(bool certificateAuthority, bool hasPathLengthConstraint, int pathLengthConstraint, bool critical);
    public X509BasicConstraintsExtension(AsnEncodedData encodedBasicConstraints, bool critical);
    public bool get_CertificateAuthority();
    public bool get_HasPathLengthConstraint();
    public int get_PathLengthConstraint();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    private static Byte[] EncodeExtension(bool certificateAuthority, bool hasPathLengthConstraint, int pathLengthConstraint);
    private void DecodeExtension();
}
public class System.Security.Cryptography.X509Certificates.X509Certificate : object {
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyCertHash;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _lazyIssuer;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _lazySubject;
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazySerialNumber;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _lazyKeyAlgorithm;
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyKeyAlgorithmParameters;
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyPublicKey;
    private DateTime _lazyNotBefore;
    private DateTime _lazyNotAfter;
    [CompilerGeneratedAttribute]
private ICertificatePalCore <Pal>k__BackingField;
    public IntPtr Handle { get; }
    public string Issuer { get; }
    public string Subject { get; }
    internal ICertificatePalCore Pal { get; private set; }
    public X509Certificate(Byte[] data);
    public X509Certificate(Byte[] rawData, string password);
    [CLSCompliantAttribute("False")]
public X509Certificate(Byte[] rawData, SecureString password);
    public X509Certificate(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
    [CLSCompliantAttribute("False")]
public X509Certificate(Byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags);
    public X509Certificate(IntPtr handle);
    internal X509Certificate(ICertificatePalCore pal);
    public X509Certificate(string fileName);
    public X509Certificate(string fileName, string password);
    [CLSCompliantAttribute("False")]
public X509Certificate(string fileName, SecureString password);
    public X509Certificate(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    [CLSCompliantAttribute("False")]
public X509Certificate(string fileName, SecureString password, X509KeyStorageFlags keyStorageFlags);
    public X509Certificate(X509Certificate cert);
    public X509Certificate(SerializationInfo info, StreamingContext context);
    public virtual void Reset();
    public static X509Certificate CreateFromCertFile(string filename);
    public static X509Certificate CreateFromSignedFile(string filename);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    public IntPtr get_Handle();
    public string get_Issuer();
    public string get_Subject();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual bool Equals(object obj);
    public virtual bool Equals(X509Certificate other);
    public virtual Byte[] Export(X509ContentType contentType);
    public virtual Byte[] Export(X509ContentType contentType, string password);
    [CLSCompliantAttribute("False")]
public virtual Byte[] Export(X509ContentType contentType, SecureString password);
    public virtual string GetRawCertDataString();
    public virtual Byte[] GetCertHash();
    public virtual Byte[] GetCertHash(HashAlgorithmName hashAlgorithm);
    public virtual bool TryGetCertHash(HashAlgorithmName hashAlgorithm, Span`1<byte> destination, Int32& bytesWritten);
    public virtual string GetCertHashString();
    public virtual string GetCertHashString(HashAlgorithmName hashAlgorithm);
    private Byte[] GetRawCertHash();
    public virtual string GetEffectiveDateString();
    public virtual string GetExpirationDateString();
    public virtual string GetFormat();
    public virtual string GetPublicKeyString();
    public virtual Byte[] GetRawCertData();
    public virtual int GetHashCode();
    public virtual string GetKeyAlgorithm();
    public virtual Byte[] GetKeyAlgorithmParameters();
    public virtual string GetKeyAlgorithmParametersString();
    public virtual Byte[] GetPublicKey();
    public virtual Byte[] GetSerialNumber();
    public virtual string GetSerialNumberString();
    private Byte[] GetRawSerialNumber();
    [ObsoleteAttribute("This method has been deprecated.  Please use the Subject property instead.  https://go.microsoft.com/fwlink/?linkid=14202")]
public virtual string GetName();
    [ObsoleteAttribute("This method has been deprecated.  Please use the Issuer property instead.  https://go.microsoft.com/fwlink/?linkid=14202")]
public virtual string GetIssuerName();
    public virtual string ToString();
    public virtual string ToString(bool fVerbose);
    public virtual void Import(Byte[] rawData);
    public virtual void Import(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
    [CLSCompliantAttribute("False")]
public virtual void Import(Byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags);
    public virtual void Import(string fileName);
    public virtual void Import(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    [CLSCompliantAttribute("False")]
public virtual void Import(string fileName, SecureString password, X509KeyStorageFlags keyStorageFlags);
    [CompilerGeneratedAttribute]
internal ICertificatePalCore get_Pal();
    [CompilerGeneratedAttribute]
private void set_Pal(ICertificatePalCore value);
    internal DateTime GetNotAfter();
    internal DateTime GetNotBefore();
    internal void ThrowIfInvalid();
    protected static string FormatDate(DateTime date);
    internal static void ValidateKeyStorageFlags(X509KeyStorageFlags keyStorageFlags);
    private void VerifyContentType(X509ContentType contentType);
}
public class System.Security.Cryptography.X509Certificates.X509Certificate2 : X509Certificate {
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyRawData;
    private Oid modreq(System.Runtime.CompilerServices.IsVolatile) _lazySignatureAlgorithm;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _lazyVersion;
    private X500DistinguishedName modreq(System.Runtime.CompilerServices.IsVolatile) _lazySubjectName;
    private X500DistinguishedName modreq(System.Runtime.CompilerServices.IsVolatile) _lazyIssuerName;
    private PublicKey modreq(System.Runtime.CompilerServices.IsVolatile) _lazyPublicKey;
    private AsymmetricAlgorithm modreq(System.Runtime.CompilerServices.IsVolatile) _lazyPrivateKey;
    private X509ExtensionCollection modreq(System.Runtime.CompilerServices.IsVolatile) _lazyExtensions;
    internal ICertificatePal Pal { get; }
    public bool Archived { get; public set; }
    public X509ExtensionCollection Extensions { get; }
    public string FriendlyName { get; public set; }
    public bool HasPrivateKey { get; }
    public AsymmetricAlgorithm PrivateKey { get; public set; }
    public X500DistinguishedName IssuerName { get; }
    public DateTime NotAfter { get; }
    public DateTime NotBefore { get; }
    public PublicKey PublicKey { get; }
    public Byte[] RawData { get; }
    public string SerialNumber { get; }
    public Oid SignatureAlgorithm { get; }
    public X500DistinguishedName SubjectName { get; }
    public string Thumbprint { get; }
    public int Version { get; }
    public X509Certificate2(Byte[] rawData);
    public X509Certificate2(Byte[] rawData, string password);
    [CLSCompliantAttribute("False")]
public X509Certificate2(Byte[] rawData, SecureString password);
    public X509Certificate2(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
    [CLSCompliantAttribute("False")]
public X509Certificate2(Byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags);
    public X509Certificate2(IntPtr handle);
    internal X509Certificate2(ICertificatePal pal);
    public X509Certificate2(string fileName);
    public X509Certificate2(string fileName, string password);
    [CLSCompliantAttribute("False")]
public X509Certificate2(string fileName, SecureString password);
    public X509Certificate2(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    [CLSCompliantAttribute("False")]
public X509Certificate2(string fileName, SecureString password, X509KeyStorageFlags keyStorageFlags);
    public X509Certificate2(X509Certificate certificate);
    protected X509Certificate2(SerializationInfo info, StreamingContext context);
    public virtual void Reset();
    internal ICertificatePal get_Pal();
    public bool get_Archived();
    public void set_Archived(bool value);
    public X509ExtensionCollection get_Extensions();
    public string get_FriendlyName();
    public void set_FriendlyName(string value);
    public bool get_HasPrivateKey();
    public AsymmetricAlgorithm get_PrivateKey();
    public void set_PrivateKey(AsymmetricAlgorithm value);
    public X500DistinguishedName get_IssuerName();
    public DateTime get_NotAfter();
    public DateTime get_NotBefore();
    public PublicKey get_PublicKey();
    public Byte[] get_RawData();
    public string get_SerialNumber();
    public Oid get_SignatureAlgorithm();
    public X500DistinguishedName get_SubjectName();
    public string get_Thumbprint();
    public int get_Version();
    public static X509ContentType GetCertContentType(Byte[] rawData);
    public static X509ContentType GetCertContentType(string fileName);
    public string GetNameInfo(X509NameType nameType, bool forIssuer);
    public virtual string ToString();
    public virtual string ToString(bool verbose);
    public virtual void Import(Byte[] rawData);
    public virtual void Import(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
    [CLSCompliantAttribute("False")]
public virtual void Import(Byte[] rawData, SecureString password, X509KeyStorageFlags keyStorageFlags);
    public virtual void Import(string fileName);
    public virtual void Import(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    [CLSCompliantAttribute("False")]
public virtual void Import(string fileName, SecureString password, X509KeyStorageFlags keyStorageFlags);
    public bool Verify();
    private static X509Extension CreateCustomExtensionIfAny(Oid oid);
}
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.X509Certificates.X509Certificate2Collection : X509CertificateCollection {
    public X509Certificate2 Item { get; public set; }
    public X509Certificate2Collection(X509Certificate2 certificate);
    public X509Certificate2Collection(X509Certificate2[] certificates);
    public X509Certificate2Collection(X509Certificate2Collection certificates);
    public X509Certificate2 get_Item(int index);
    public void set_Item(int index, X509Certificate2 value);
    public int Add(X509Certificate2 certificate);
    public void AddRange(X509Certificate2[] certificates);
    public void AddRange(X509Certificate2Collection certificates);
    public bool Contains(X509Certificate2 certificate);
    public Byte[] Export(X509ContentType contentType);
    public Byte[] Export(X509ContentType contentType, string password);
    public X509Certificate2Collection Find(X509FindType findType, object findValue, bool validOnly);
    public X509Certificate2Enumerator GetEnumerator();
    public void Import(Byte[] rawData);
    public void Import(Byte[] rawData, string password, X509KeyStorageFlags keyStorageFlags);
    public void Import(string fileName);
    public void Import(string fileName, string password, X509KeyStorageFlags keyStorageFlags);
    public void Insert(int index, X509Certificate2 certificate);
    public void Remove(X509Certificate2 certificate);
    public void RemoveRange(X509Certificate2[] certificates);
    public void RemoveRange(X509Certificate2Collection certificates);
}
public class System.Security.Cryptography.X509Certificates.X509Certificate2Enumerator : object {
    private IEnumerator _enumerator;
    public X509Certificate2 Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal X509Certificate2Enumerator(X509Certificate2Collection collection);
    public X509Certificate2 get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public bool MoveNext();
    private sealed virtual override bool System.Collections.IEnumerator.MoveNext();
    public void Reset();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
}
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.X509Certificates.X509CertificateCollection : CollectionBase {
    public X509Certificate Item { get; public set; }
    public X509CertificateCollection(X509Certificate[] value);
    public X509CertificateCollection(X509CertificateCollection value);
    public X509Certificate get_Item(int index);
    public void set_Item(int index, X509Certificate value);
    public int Add(X509Certificate value);
    public void AddRange(X509Certificate[] value);
    public void AddRange(X509CertificateCollection value);
    public bool Contains(X509Certificate value);
    public void CopyTo(X509Certificate[] array, int index);
    public X509CertificateEnumerator GetEnumerator();
    public virtual int GetHashCode();
    public int IndexOf(X509Certificate value);
    public void Insert(int index, X509Certificate value);
    public void Remove(X509Certificate value);
    protected virtual void OnValidate(object value);
}
public class System.Security.Cryptography.X509Certificates.X509Chain : object {
    private X509ChainPolicy _chainPolicy;
    private X509ChainStatus[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyChainStatus;
    private X509ChainElementCollection _chainElements;
    private IChainPal _pal;
    private bool _useMachineContext;
    private object _syncRoot;
    public X509ChainElementCollection ChainElements { get; }
    public X509ChainPolicy ChainPolicy { get; public set; }
    public X509ChainStatus[] ChainStatus { get; }
    public IntPtr ChainContext { get; }
    public SafeX509ChainHandle SafeHandle { get; }
    public X509Chain(bool useMachineContext);
    public X509Chain(IntPtr chainContext);
    public static X509Chain Create();
    public X509ChainElementCollection get_ChainElements();
    public X509ChainPolicy get_ChainPolicy();
    public void set_ChainPolicy(X509ChainPolicy value);
    public X509ChainStatus[] get_ChainStatus();
    public IntPtr get_ChainContext();
    public SafeX509ChainHandle get_SafeHandle();
    public bool Build(X509Certificate2 certificate);
    internal bool Build(X509Certificate2 certificate, bool throwOnException);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public void Reset();
}
public class System.Security.Cryptography.X509Certificates.X509ChainElement : object {
    [CompilerGeneratedAttribute]
private X509Certificate2 <Certificate>k__BackingField;
    [CompilerGeneratedAttribute]
private X509ChainStatus[] <ChainElementStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Information>k__BackingField;
    public X509Certificate2 Certificate { get; private set; }
    public X509ChainStatus[] ChainElementStatus { get; private set; }
    public string Information { get; private set; }
    internal X509ChainElement(X509Certificate2 certificate, X509ChainStatus[] chainElementStatus, string information);
    [CompilerGeneratedAttribute]
public X509Certificate2 get_Certificate();
    [CompilerGeneratedAttribute]
private void set_Certificate(X509Certificate2 value);
    [CompilerGeneratedAttribute]
public X509ChainStatus[] get_ChainElementStatus();
    [CompilerGeneratedAttribute]
private void set_ChainElementStatus(X509ChainStatus[] value);
    [CompilerGeneratedAttribute]
public string get_Information();
    [CompilerGeneratedAttribute]
private void set_Information(string value);
}
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.X509Certificates.X509ChainElementCollection : object {
    private X509ChainElement[] _elements;
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public X509ChainElement Item { get; }
    internal X509ChainElementCollection(X509ChainElement[] chainElements);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public X509ChainElement get_Item(int index);
    public void CopyTo(X509ChainElement[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public X509ChainElementEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Security.Cryptography.X509Certificates.X509ChainElementEnumerator : object {
    private X509ChainElementCollection _chainElements;
    private int _current;
    public X509ChainElement Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal X509ChainElementEnumerator(X509ChainElementCollection chainElements);
    public X509ChainElement get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
public class System.Security.Cryptography.X509Certificates.X509ChainPolicy : object {
    private X509RevocationMode _revocationMode;
    private X509RevocationFlag _revocationFlag;
    private X509VerificationFlags _verificationFlags;
    internal OidCollection _applicationPolicy;
    internal OidCollection _certificatePolicy;
    internal X509Certificate2Collection _extraStore;
    [CompilerGeneratedAttribute]
private DateTime <VerificationTime>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <UrlRetrievalTimeout>k__BackingField;
    public OidCollection ApplicationPolicy { get; }
    public OidCollection CertificatePolicy { get; }
    public X509Certificate2Collection ExtraStore { get; }
    public X509RevocationMode RevocationMode { get; public set; }
    public X509RevocationFlag RevocationFlag { get; public set; }
    public X509VerificationFlags VerificationFlags { get; public set; }
    public DateTime VerificationTime { get; public set; }
    public TimeSpan UrlRetrievalTimeout { get; public set; }
    public OidCollection get_ApplicationPolicy();
    public OidCollection get_CertificatePolicy();
    public X509Certificate2Collection get_ExtraStore();
    public X509RevocationMode get_RevocationMode();
    public void set_RevocationMode(X509RevocationMode value);
    public X509RevocationFlag get_RevocationFlag();
    public void set_RevocationFlag(X509RevocationFlag value);
    public X509VerificationFlags get_VerificationFlags();
    public void set_VerificationFlags(X509VerificationFlags value);
    [CompilerGeneratedAttribute]
public DateTime get_VerificationTime();
    [CompilerGeneratedAttribute]
public void set_VerificationTime(DateTime value);
    [CompilerGeneratedAttribute]
public TimeSpan get_UrlRetrievalTimeout();
    [CompilerGeneratedAttribute]
public void set_UrlRetrievalTimeout(TimeSpan value);
    public void Reset();
}
public class System.Security.Cryptography.X509Certificates.X509ChainStatus : ValueType {
    [CompilerGeneratedAttribute]
private X509ChainStatusFlags <Status>k__BackingField;
    private string _statusInformation;
    public X509ChainStatusFlags Status { get; public set; }
    public string StatusInformation { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public X509ChainStatusFlags get_Status();
    [CompilerGeneratedAttribute]
public void set_Status(X509ChainStatusFlags value);
    public string get_StatusInformation();
    public void set_StatusInformation(string value);
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.X509ChainStatusFlags : Enum {
    public int value__;
    public static X509ChainStatusFlags NoError;
    public static X509ChainStatusFlags NotTimeValid;
    public static X509ChainStatusFlags NotTimeNested;
    public static X509ChainStatusFlags Revoked;
    public static X509ChainStatusFlags NotSignatureValid;
    public static X509ChainStatusFlags NotValidForUsage;
    public static X509ChainStatusFlags UntrustedRoot;
    public static X509ChainStatusFlags RevocationStatusUnknown;
    public static X509ChainStatusFlags Cyclic;
    public static X509ChainStatusFlags InvalidExtension;
    public static X509ChainStatusFlags InvalidPolicyConstraints;
    public static X509ChainStatusFlags InvalidBasicConstraints;
    public static X509ChainStatusFlags InvalidNameConstraints;
    public static X509ChainStatusFlags HasNotSupportedNameConstraint;
    public static X509ChainStatusFlags HasNotDefinedNameConstraint;
    public static X509ChainStatusFlags HasNotPermittedNameConstraint;
    public static X509ChainStatusFlags HasExcludedNameConstraint;
    public static X509ChainStatusFlags PartialChain;
    public static X509ChainStatusFlags CtlNotTimeValid;
    public static X509ChainStatusFlags CtlNotSignatureValid;
    public static X509ChainStatusFlags CtlNotValidForUsage;
    public static X509ChainStatusFlags OfflineRevocation;
    public static X509ChainStatusFlags NoIssuanceChainPolicy;
    public static X509ChainStatusFlags ExplicitDistrust;
    public static X509ChainStatusFlags HasNotSupportedCriticalExtension;
    public static X509ChainStatusFlags HasWeakSignature;
}
public enum System.Security.Cryptography.X509Certificates.X509ContentType : Enum {
    public int value__;
    public static X509ContentType Unknown;
    public static X509ContentType Cert;
    public static X509ContentType SerializedCert;
    public static X509ContentType Pfx;
    public static X509ContentType Pkcs12;
    public static X509ContentType SerializedStore;
    public static X509ContentType Pkcs7;
    public static X509ContentType Authenticode;
}
public class System.Security.Cryptography.X509Certificates.X509EnhancedKeyUsageExtension : X509Extension {
    private OidCollection _enhancedKeyUsages;
    private bool _decoded;
    public OidCollection EnhancedKeyUsages { get; }
    public X509EnhancedKeyUsageExtension(AsnEncodedData encodedEnhancedKeyUsages, bool critical);
    public X509EnhancedKeyUsageExtension(OidCollection enhancedKeyUsages, bool critical);
    public OidCollection get_EnhancedKeyUsages();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    private static Byte[] EncodeExtension(OidCollection enhancedKeyUsages);
}
public class System.Security.Cryptography.X509Certificates.X509Extension : AsnEncodedData {
    [CompilerGeneratedAttribute]
private bool <Critical>k__BackingField;
    public bool Critical { get; public set; }
    public X509Extension(AsnEncodedData encodedExtension, bool critical);
    public X509Extension(Oid oid, Byte[] rawData, bool critical);
    public X509Extension(string oid, Byte[] rawData, bool critical);
    internal X509Extension(string oidValue);
    [CompilerGeneratedAttribute]
public bool get_Critical();
    [CompilerGeneratedAttribute]
public void set_Critical(bool value);
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
}
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.X509Certificates.X509ExtensionCollection : object {
    private List`1<X509Extension> _list;
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public X509Extension Item { get; }
    public X509Extension Item { get; }
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public X509Extension get_Item(int index);
    public X509Extension get_Item(string oid);
    public int Add(X509Extension extension);
    public void CopyTo(X509Extension[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public X509ExtensionEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Security.Cryptography.X509Certificates.X509ExtensionEnumerator : object {
    private X509ExtensionCollection _extensions;
    private int _current;
    public X509Extension Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal X509ExtensionEnumerator(X509ExtensionCollection extensions);
    public X509Extension get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
public enum System.Security.Cryptography.X509Certificates.X509FindType : Enum {
    public int value__;
    public static X509FindType FindByThumbprint;
    public static X509FindType FindBySubjectName;
    public static X509FindType FindBySubjectDistinguishedName;
    public static X509FindType FindByIssuerName;
    public static X509FindType FindByIssuerDistinguishedName;
    public static X509FindType FindBySerialNumber;
    public static X509FindType FindByTimeValid;
    public static X509FindType FindByTimeNotYetValid;
    public static X509FindType FindByTimeExpired;
    public static X509FindType FindByTemplateName;
    public static X509FindType FindByApplicationPolicy;
    public static X509FindType FindByCertificatePolicy;
    public static X509FindType FindByExtension;
    public static X509FindType FindByKeyUsage;
    public static X509FindType FindBySubjectKeyIdentifier;
}
public enum System.Security.Cryptography.X509Certificates.X509IncludeOption : Enum {
    public int value__;
    public static X509IncludeOption None;
    public static X509IncludeOption ExcludeRoot;
    public static X509IncludeOption EndCertOnly;
    public static X509IncludeOption WholeChain;
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.X509KeyStorageFlags : Enum {
    public int value__;
    public static X509KeyStorageFlags DefaultKeySet;
    public static X509KeyStorageFlags UserKeySet;
    public static X509KeyStorageFlags MachineKeySet;
    public static X509KeyStorageFlags Exportable;
    public static X509KeyStorageFlags UserProtected;
    public static X509KeyStorageFlags PersistKeySet;
    public static X509KeyStorageFlags EphemeralKeySet;
}
public class System.Security.Cryptography.X509Certificates.X509KeyUsageExtension : X509Extension {
    private bool _decoded;
    private X509KeyUsageFlags _keyUsages;
    public X509KeyUsageFlags KeyUsages { get; }
    public X509KeyUsageExtension(AsnEncodedData encodedKeyUsage, bool critical);
    public X509KeyUsageExtension(X509KeyUsageFlags keyUsages, bool critical);
    public X509KeyUsageFlags get_KeyUsages();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.X509KeyUsageFlags : Enum {
    public int value__;
    public static X509KeyUsageFlags None;
    public static X509KeyUsageFlags EncipherOnly;
    public static X509KeyUsageFlags CrlSign;
    public static X509KeyUsageFlags KeyCertSign;
    public static X509KeyUsageFlags KeyAgreement;
    public static X509KeyUsageFlags DataEncipherment;
    public static X509KeyUsageFlags KeyEncipherment;
    public static X509KeyUsageFlags NonRepudiation;
    public static X509KeyUsageFlags DigitalSignature;
    public static X509KeyUsageFlags DecipherOnly;
}
public enum System.Security.Cryptography.X509Certificates.X509NameType : Enum {
    public int value__;
    public static X509NameType SimpleName;
    public static X509NameType EmailName;
    public static X509NameType UpnName;
    public static X509NameType DnsName;
    public static X509NameType DnsFromAlternativeName;
    public static X509NameType UrlName;
}
public enum System.Security.Cryptography.X509Certificates.X509RevocationFlag : Enum {
    public int value__;
    public static X509RevocationFlag EndCertificateOnly;
    public static X509RevocationFlag EntireChain;
    public static X509RevocationFlag ExcludeRoot;
}
public enum System.Security.Cryptography.X509Certificates.X509RevocationMode : Enum {
    public int value__;
    public static X509RevocationMode NoCheck;
    public static X509RevocationMode Online;
    public static X509RevocationMode Offline;
}
public abstract class System.Security.Cryptography.X509Certificates.X509SignatureGenerator : object {
    private PublicKey _publicKey;
    public PublicKey PublicKey { get; }
    public PublicKey get_PublicKey();
    public abstract virtual Byte[] GetSignatureAlgorithmIdentifier(HashAlgorithmName hashAlgorithm);
    public abstract virtual Byte[] SignData(Byte[] data, HashAlgorithmName hashAlgorithm);
    protected abstract virtual PublicKey BuildPublicKey();
    public static X509SignatureGenerator CreateForECDsa(ECDsa key);
    public static X509SignatureGenerator CreateForRSA(RSA key, RSASignaturePadding signaturePadding);
}
public class System.Security.Cryptography.X509Certificates.X509Store : object {
    private IStorePal _storePal;
    [CompilerGeneratedAttribute]
private StoreLocation <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public IntPtr StoreHandle { get; }
    public StoreLocation Location { get; private set; }
    public string Name { get; private set; }
    public X509Certificate2Collection Certificates { get; }
    public bool IsOpen { get; }
    public X509Store(string storeName);
    public X509Store(StoreName storeName);
    public X509Store(StoreLocation storeLocation);
    public X509Store(StoreName storeName, StoreLocation storeLocation);
    public X509Store(StoreName storeName, StoreLocation storeLocation, OpenFlags flags);
    public X509Store(string storeName, StoreLocation storeLocation);
    public X509Store(string storeName, StoreLocation storeLocation, OpenFlags flags);
    public X509Store(IntPtr storeHandle);
    public IntPtr get_StoreHandle();
    [CompilerGeneratedAttribute]
public StoreLocation get_Location();
    [CompilerGeneratedAttribute]
private void set_Location(StoreLocation value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    public void Open(OpenFlags flags);
    public X509Certificate2Collection get_Certificates();
    public bool get_IsOpen();
    public void Add(X509Certificate2 certificate);
    public void AddRange(X509Certificate2Collection certificates);
    public void Remove(X509Certificate2 certificate);
    public void RemoveRange(X509Certificate2Collection certificates);
    public sealed virtual void Dispose();
    public void Close();
}
public class System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierExtension : X509Extension {
    private string _subjectKeyIdentifier;
    private bool _decoded;
    public string SubjectKeyIdentifier { get; }
    public X509SubjectKeyIdentifierExtension(AsnEncodedData encodedSubjectKeyIdentifier, bool critical);
    public X509SubjectKeyIdentifierExtension(Byte[] subjectKeyIdentifier, bool critical);
    public X509SubjectKeyIdentifierExtension(PublicKey key, bool critical);
    public X509SubjectKeyIdentifierExtension(PublicKey key, X509SubjectKeyIdentifierHashAlgorithm algorithm, bool critical);
    public X509SubjectKeyIdentifierExtension(string subjectKeyIdentifier, bool critical);
    public string get_SubjectKeyIdentifier();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    private static Byte[] EncodeExtension(Byte[] subjectKeyIdentifier);
    private static Byte[] EncodeExtension(string subjectKeyIdentifier);
    private static Byte[] EncodeExtension(PublicKey key, X509SubjectKeyIdentifierHashAlgorithm algorithm);
    private static Byte[] GenerateSubjectKeyIdentifierFromPublicKey(PublicKey key, X509SubjectKeyIdentifierHashAlgorithm algorithm);
    private static Byte[] ComputeSha1(Byte[] data);
}
public enum System.Security.Cryptography.X509Certificates.X509SubjectKeyIdentifierHashAlgorithm : Enum {
    public int value__;
    public static X509SubjectKeyIdentifierHashAlgorithm Sha1;
    public static X509SubjectKeyIdentifierHashAlgorithm ShortSha1;
    public static X509SubjectKeyIdentifierHashAlgorithm CapiSha1;
}
[FlagsAttribute]
public enum System.Security.Cryptography.X509Certificates.X509VerificationFlags : Enum {
    public int value__;
    public static X509VerificationFlags NoFlag;
    public static X509VerificationFlags IgnoreNotTimeValid;
    public static X509VerificationFlags IgnoreCtlNotTimeValid;
    public static X509VerificationFlags IgnoreNotTimeNested;
    public static X509VerificationFlags IgnoreInvalidBasicConstraints;
    public static X509VerificationFlags AllowUnknownCertificateAuthority;
    public static X509VerificationFlags IgnoreWrongUsage;
    public static X509VerificationFlags IgnoreInvalidName;
    public static X509VerificationFlags IgnoreInvalidPolicy;
    public static X509VerificationFlags IgnoreEndRevocationUnknown;
    public static X509VerificationFlags IgnoreCtlSignerRevocationUnknown;
    public static X509VerificationFlags IgnoreCertificateAuthorityRevocationUnknown;
    public static X509VerificationFlags IgnoreRootRevocationUnknown;
    public static X509VerificationFlags AllFlags;
}
internal static class System.SR : object {
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string Arg_EmptyOrNullArray { get; }
    internal static string Arg_EmptyOrNullString { get; }
    internal static string Arg_EnumIllegalVal { get; }
    internal static string Arg_InvalidHandle { get; }
    internal static string Arg_InvalidType { get; }
    internal static string Arg_OutOfRange_NeedNonNegNum { get; }
    internal static string Arg_RankMultiDimNotSupported { get; }
    internal static string Argument_InvalidFlag { get; }
    internal static string Argument_InvalidNameType { get; }
    internal static string Argument_InvalidOffLen { get; }
    internal static string Argument_InvalidOidValue { get; }
    internal static string ArgumentOutOfRange_Index { get; }
    internal static string Cryptography_Cert_AlreadyHasPrivateKey { get; }
    internal static string Cryptography_CertReq_AlgorithmMustMatch { get; }
    internal static string Cryptography_CertReq_BasicConstraintsRequired { get; }
    internal static string Cryptography_CertReq_DatesReversed { get; }
    internal static string Cryptography_CertReq_DuplicateExtension { get; }
    internal static string Cryptography_CertReq_IssuerBasicConstraintsInvalid { get; }
    internal static string Cryptography_CertReq_IssuerKeyUsageInvalid { get; }
    internal static string Cryptography_CertReq_IssuerRequiresPrivateKey { get; }
    internal static string Cryptography_CertReq_NotAfterNotNested { get; }
    internal static string Cryptography_CertReq_NotBeforeNotNested { get; }
    internal static string Cryptography_CertReq_NoKeyProvided { get; }
    internal static string Cryptography_CertReq_RSAPaddingRequired { get; }
    internal static string Cryptography_ECC_NamedCurvesOnly { get; }
    internal static string Cryptography_Der_Invalid_Encoding { get; }
    internal static string Cryptography_HashAlgorithmNameNullOrEmpty { get; }
    internal static string Cryptography_InvalidContextHandle { get; }
    internal static string Cryptography_InvalidHandle { get; }
    internal static string Cryptography_InvalidPaddingMode { get; }
    internal static string Cryptography_InvalidStoreHandle { get; }
    internal static string Cryptography_PrivateKey_DoesNotMatch { get; }
    internal static string Cryptography_PrivateKey_WrongAlgorithm { get; }
    internal static string Cryptography_UnknownHashAlgorithm { get; }
    internal static string Cryptography_UnknownKeyAlgorithm { get; }
    internal static string Cryptography_X509_ExtensionMismatch { get; }
    internal static string Cryptography_X509_InvalidContentType { get; }
    internal static string Cryptography_X509_InvalidFindType { get; }
    internal static string Cryptography_X509_InvalidFindValue { get; }
    internal static string Cryptography_X509_InvalidFlagCombination { get; }
    internal static string Cryptography_X509_StoreNotOpen { get; }
    internal static string InvalidOperation_EnumNotStarted { get; }
    internal static string NotSupported_ECDsa_Csp { get; }
    internal static string NotSupported_KeyAlgorithm { get; }
    internal static string NotSupported_ImmutableX509Certificate { get; }
    internal static string Unknown_Error { get; }
    internal static string Cryptography_Invalid_IA5String { get; }
    internal static string Cryptography_WriteEncodedValue_OneValueAtATime { get; }
    internal static string Cryptography_Asn_UniversalValueIsFixed { get; }
    internal static string Cryptography_Asn_UnusedBitCountRange { get; }
    internal static string Cryptography_AsnWriter_EncodeUnbalancedStack { get; }
    internal static string Cryptography_AsnWriter_PopWrongTag { get; }
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static ResourceManager get_ResourceManager();
    internal static string get_Arg_EmptyOrNullArray();
    internal static string get_Arg_EmptyOrNullString();
    internal static string get_Arg_EnumIllegalVal();
    internal static string get_Arg_InvalidHandle();
    internal static string get_Arg_InvalidType();
    internal static string get_Arg_OutOfRange_NeedNonNegNum();
    internal static string get_Arg_RankMultiDimNotSupported();
    internal static string get_Argument_InvalidFlag();
    internal static string get_Argument_InvalidNameType();
    internal static string get_Argument_InvalidOffLen();
    internal static string get_Argument_InvalidOidValue();
    internal static string get_ArgumentOutOfRange_Index();
    internal static string get_Cryptography_Cert_AlreadyHasPrivateKey();
    internal static string get_Cryptography_CertReq_AlgorithmMustMatch();
    internal static string get_Cryptography_CertReq_BasicConstraintsRequired();
    internal static string get_Cryptography_CertReq_DatesReversed();
    internal static string get_Cryptography_CertReq_DuplicateExtension();
    internal static string get_Cryptography_CertReq_IssuerBasicConstraintsInvalid();
    internal static string get_Cryptography_CertReq_IssuerKeyUsageInvalid();
    internal static string get_Cryptography_CertReq_IssuerRequiresPrivateKey();
    internal static string get_Cryptography_CertReq_NotAfterNotNested();
    internal static string get_Cryptography_CertReq_NotBeforeNotNested();
    internal static string get_Cryptography_CertReq_NoKeyProvided();
    internal static string get_Cryptography_CertReq_RSAPaddingRequired();
    internal static string get_Cryptography_ECC_NamedCurvesOnly();
    internal static string get_Cryptography_Der_Invalid_Encoding();
    internal static string get_Cryptography_HashAlgorithmNameNullOrEmpty();
    internal static string get_Cryptography_InvalidContextHandle();
    internal static string get_Cryptography_InvalidHandle();
    internal static string get_Cryptography_InvalidPaddingMode();
    internal static string get_Cryptography_InvalidStoreHandle();
    internal static string get_Cryptography_PrivateKey_DoesNotMatch();
    internal static string get_Cryptography_PrivateKey_WrongAlgorithm();
    internal static string get_Cryptography_UnknownHashAlgorithm();
    internal static string get_Cryptography_UnknownKeyAlgorithm();
    internal static string get_Cryptography_X509_ExtensionMismatch();
    internal static string get_Cryptography_X509_InvalidContentType();
    internal static string get_Cryptography_X509_InvalidFindType();
    internal static string get_Cryptography_X509_InvalidFindValue();
    internal static string get_Cryptography_X509_InvalidFlagCombination();
    internal static string get_Cryptography_X509_StoreNotOpen();
    internal static string get_InvalidOperation_EnumNotStarted();
    internal static string get_NotSupported_ECDsa_Csp();
    internal static string get_NotSupported_KeyAlgorithm();
    internal static string get_NotSupported_ImmutableX509Certificate();
    internal static string get_Unknown_Error();
    internal static string get_Cryptography_Invalid_IA5String();
    internal static string get_Cryptography_WriteEncodedValue_OneValueAtATime();
    internal static string get_Cryptography_Asn_UniversalValueIsFixed();
    internal static string get_Cryptography_Asn_UnusedBitCountRange();
    internal static string get_Cryptography_AsnWriter_EncodeUnbalancedStack();
    internal static string get_Cryptography_AsnWriter_PopWrongTag();
}
