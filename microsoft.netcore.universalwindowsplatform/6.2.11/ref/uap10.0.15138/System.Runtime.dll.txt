[SecurityCriticalAttribute]
public abstract class Microsoft.Win32.SafeHandles.CriticalHandleMinusOneIsInvalid : CriticalHandle {
    public bool IsInvalid { get; }
    [SecurityCriticalAttribute]
public virtual bool get_IsInvalid();
}
[SecurityCriticalAttribute]
public abstract class Microsoft.Win32.SafeHandles.CriticalHandleZeroOrMinusOneIsInvalid : CriticalHandle {
    public bool IsInvalid { get; }
    [SecurityCriticalAttribute]
public virtual bool get_IsInvalid();
}
[SecurityCriticalAttribute]
public class Microsoft.Win32.SafeHandles.SafeFileHandle : SafeHandleZeroOrMinusOneIsInvalid {
    public bool IsInvalid { get; }
    public SafeFileHandle(IntPtr preexistingHandle, bool ownsHandle);
    [SecurityCriticalAttribute]
public virtual bool get_IsInvalid();
    [SecurityCriticalAttribute]
protected virtual bool ReleaseHandle();
}
[SecurityCriticalAttribute]
public abstract class Microsoft.Win32.SafeHandles.SafeHandleMinusOneIsInvalid : SafeHandle {
    public bool IsInvalid { get; }
    protected SafeHandleMinusOneIsInvalid(bool ownsHandle);
    [SecurityCriticalAttribute]
public virtual bool get_IsInvalid();
}
[SecurityCriticalAttribute]
public abstract class Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid : SafeHandle {
    public bool IsInvalid { get; }
    protected SafeHandleZeroOrMinusOneIsInvalid(bool ownsHandle);
    [SecurityCriticalAttribute]
public virtual bool get_IsInvalid();
}
[SecurityCriticalAttribute]
public class Microsoft.Win32.SafeHandles.SafeWaitHandle : SafeHandleZeroOrMinusOneIsInvalid {
    public SafeWaitHandle(IntPtr existingHandle, bool ownsHandle);
    [SecurityCriticalAttribute]
protected virtual bool ReleaseHandle();
}
public class System.AccessViolationException : SystemException {
    public AccessViolationException(string message);
    public AccessViolationException(string message, Exception innerException);
    protected AccessViolationException(SerializationInfo info, StreamingContext context);
}
public class System.Action : MulticastDelegate {
    public Action(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`1 : MulticastDelegate {
    public Action`1(object object, IntPtr method);
    public virtual void Invoke(T obj);
    public virtual IAsyncResult BeginInvoke(T obj, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`10 : MulticastDelegate {
    public Action`10(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`11 : MulticastDelegate {
    public Action`11(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`12 : MulticastDelegate {
    public Action`12(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`13 : MulticastDelegate {
    public Action`13(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`14 : MulticastDelegate {
    public Action`14(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`15 : MulticastDelegate {
    public Action`15(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`16 : MulticastDelegate {
    public Action`16(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`2 : MulticastDelegate {
    public Action`2(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`3 : MulticastDelegate {
    public Action`3(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`4 : MulticastDelegate {
    public Action`4(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`5 : MulticastDelegate {
    public Action`5(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`6 : MulticastDelegate {
    public Action`6(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`7 : MulticastDelegate {
    public Action`7(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`8 : MulticastDelegate {
    public Action`8(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`9 : MulticastDelegate {
    public Action`9(object object, IntPtr method);
    public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public static class System.Activator : object {
    public static object CreateInstance(Type type);
    public static object CreateInstance(Type type, bool nonPublic);
    public static object CreateInstance(Type type, Object[] args);
    public static object CreateInstance(Type type, Object[] args, Object[] activationAttributes);
    public static object CreateInstance(Type type, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture);
    public static object CreateInstance(Type type, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    public static T CreateInstance();
}
public class System.AggregateException : Exception {
    public ReadOnlyCollection`1<Exception> InnerExceptions { get; }
    public string Message { get; }
    public AggregateException(IEnumerable`1<Exception> innerExceptions);
    public AggregateException(Exception[] innerExceptions);
    public AggregateException(string message);
    public AggregateException(string message, IEnumerable`1<Exception> innerExceptions);
    public AggregateException(string message, Exception innerException);
    public AggregateException(string message, Exception[] innerExceptions);
    protected AggregateException(SerializationInfo info, StreamingContext context);
    public ReadOnlyCollection`1<Exception> get_InnerExceptions();
    public virtual string get_Message();
    public AggregateException Flatten();
    public virtual Exception GetBaseException();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public void Handle(Func`2<Exception, bool> predicate);
    public virtual string ToString();
}
public static class System.AppContext : object {
    public static string BaseDirectory { get; }
    public static string TargetFrameworkName { get; }
    public static string get_BaseDirectory();
    public static void SetSwitch(string switchName, bool isEnabled);
    public static bool TryGetSwitch(string switchName, Boolean& isEnabled);
    public static string get_TargetFrameworkName();
    public static object GetData(string name);
}
public class System.ApplicationException : Exception {
    public ApplicationException(string message);
    public ApplicationException(string message, Exception innerException);
    protected ApplicationException(SerializationInfo info, StreamingContext context);
}
public class System.ArgumentException : SystemException {
    public string Message { get; }
    public string ParamName { get; }
    public ArgumentException(string message);
    public ArgumentException(string message, Exception innerException);
    public ArgumentException(string message, string paramName);
    public ArgumentException(string message, string paramName, Exception innerException);
    protected ArgumentException(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
    public virtual string get_ParamName();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.ArgumentNullException : ArgumentException {
    public ArgumentNullException(string paramName);
    public ArgumentNullException(string message, Exception innerException);
    public ArgumentNullException(string paramName, string message);
    protected ArgumentNullException(SerializationInfo info, StreamingContext context);
}
public class System.ArgumentOutOfRangeException : ArgumentException {
    public object ActualValue { get; }
    public string Message { get; }
    public ArgumentOutOfRangeException(string paramName);
    public ArgumentOutOfRangeException(string message, Exception innerException);
    public ArgumentOutOfRangeException(string paramName, object actualValue, string message);
    public ArgumentOutOfRangeException(string paramName, string message);
    protected ArgumentOutOfRangeException(SerializationInfo info, StreamingContext context);
    public virtual object get_ActualValue();
    public virtual string get_Message();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.ArithmeticException : SystemException {
    public ArithmeticException(string message);
    public ArithmeticException(string message, Exception innerException);
    protected ArithmeticException(SerializationInfo info, StreamingContext context);
}
public abstract class System.Array : object {
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public int Length { get; }
    public long LongLength { get; }
    public int Rank { get; }
    public object SyncRoot { get; }
    private int System.Collections.ICollection.Count { get; }
    private object System.Collections.IList.Item { get; private set; }
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public int get_Length();
    public long get_LongLength();
    public int get_Rank();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public static ReadOnlyCollection`1<T> AsReadOnly(T[] array);
    public static int BinarySearch(Array array, int index, int length, object value);
    public static int BinarySearch(Array array, int index, int length, object value, IComparer comparer);
    public static int BinarySearch(Array array, object value);
    public static int BinarySearch(Array array, object value, IComparer comparer);
    public static int BinarySearch(T[] array, T value);
    public static int BinarySearch(T[] array, T value, IComparer`1<T> comparer);
    public static int BinarySearch(T[] array, int index, int length, T value);
    public static int BinarySearch(T[] array, int index, int length, T value, IComparer`1<T> comparer);
    public static void Clear(Array array, int index, int length);
    public sealed virtual object Clone();
    public static void ConstrainedCopy(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);
    public static TOutput[] ConvertAll(TInput[] array, Converter`2<TInput, TOutput> converter);
    public static void Copy(Array sourceArray, Array destinationArray, int length);
    public static void Copy(Array sourceArray, Array destinationArray, long length);
    public static void Copy(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);
    public static void Copy(Array sourceArray, long sourceIndex, Array destinationArray, long destinationIndex, long length);
    public sealed virtual void CopyTo(Array array, int index);
    public void CopyTo(Array array, long index);
    public static Array CreateInstance(Type elementType, int length);
    public static Array CreateInstance(Type elementType, int length1, int length2);
    public static Array CreateInstance(Type elementType, int length1, int length2, int length3);
    public static Array CreateInstance(Type elementType, Int32[] lengths);
    public static Array CreateInstance(Type elementType, Int32[] lengths, Int32[] lowerBounds);
    public static Array CreateInstance(Type elementType, Int64[] lengths);
    public static T[] Empty();
    public static bool Exists(T[] array, Predicate`1<T> match);
    public static void Fill(T[] array, T value);
    public static void Fill(T[] array, T value, int startIndex, int count);
    public static T Find(T[] array, Predicate`1<T> match);
    public static T[] FindAll(T[] array, Predicate`1<T> match);
    public static int FindIndex(T[] array, int startIndex, int count, Predicate`1<T> match);
    public static int FindIndex(T[] array, int startIndex, Predicate`1<T> match);
    public static int FindIndex(T[] array, Predicate`1<T> match);
    public static T FindLast(T[] array, Predicate`1<T> match);
    public static int FindLastIndex(T[] array, int startIndex, int count, Predicate`1<T> match);
    public static int FindLastIndex(T[] array, int startIndex, Predicate`1<T> match);
    public static int FindLastIndex(T[] array, Predicate`1<T> match);
    public static void ForEach(T[] array, Action`1<T> action);
    public sealed virtual IEnumerator GetEnumerator();
    public int GetLength(int dimension);
    public long GetLongLength(int dimension);
    public int GetLowerBound(int dimension);
    public int GetUpperBound(int dimension);
    public object GetValue(int index);
    public object GetValue(int index1, int index2);
    public object GetValue(int index1, int index2, int index3);
    public object GetValue(Int32[] indices);
    public object GetValue(long index);
    public object GetValue(long index1, long index2);
    public object GetValue(long index1, long index2, long index3);
    public object GetValue(Int64[] indices);
    public static int IndexOf(Array array, object value);
    public static int IndexOf(Array array, object value, int startIndex);
    public static int IndexOf(Array array, object value, int startIndex, int count);
    public static int IndexOf(T[] array, T value);
    public static int IndexOf(T[] array, T value, int startIndex);
    public static int IndexOf(T[] array, T value, int startIndex, int count);
    public void Initialize();
    public static int LastIndexOf(Array array, object value);
    public static int LastIndexOf(Array array, object value, int startIndex);
    public static int LastIndexOf(Array array, object value, int startIndex, int count);
    public static int LastIndexOf(T[] array, T value);
    public static int LastIndexOf(T[] array, T value, int startIndex);
    public static int LastIndexOf(T[] array, T value, int startIndex, int count);
    public static void Resize(T[]& array, int newSize);
    public static void Reverse(Array array);
    public static void Reverse(Array array, int index, int length);
    public static void Reverse(T[] array);
    public static void Reverse(T[] array, int index, int length);
    public void SetValue(object value, int index);
    public void SetValue(object value, int index1, int index2);
    public void SetValue(object value, int index1, int index2, int index3);
    public void SetValue(object value, Int32[] indices);
    public void SetValue(object value, long index);
    public void SetValue(object value, long index1, long index2);
    public void SetValue(object value, long index1, long index2, long index3);
    public void SetValue(object value, Int64[] indices);
    public static void Sort(Array array);
    public static void Sort(Array keys, Array items);
    public static void Sort(Array keys, Array items, IComparer comparer);
    public static void Sort(Array keys, Array items, int index, int length);
    public static void Sort(Array keys, Array items, int index, int length, IComparer comparer);
    public static void Sort(Array array, IComparer comparer);
    public static void Sort(Array array, int index, int length);
    public static void Sort(Array array, int index, int length, IComparer comparer);
    public static void Sort(T[] array);
    public static void Sort(T[] array, IComparer`1<T> comparer);
    public static void Sort(T[] array, Comparison`1<T> comparison);
    public static void Sort(T[] array, int index, int length);
    public static void Sort(T[] array, int index, int length, IComparer`1<T> comparer);
    public static void Sort(TKey[] keys, TValue[] items);
    public static void Sort(TKey[] keys, TValue[] items, IComparer`1<TKey> comparer);
    public static void Sort(TKey[] keys, TValue[] items, int index, int length);
    public static void Sort(TKey[] keys, TValue[] items, int index, int length, IComparer`1<TKey> comparer);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    public static bool TrueForAll(T[] array, Predicate`1<T> match);
}
[DefaultMemberAttribute("Item")]
public class System.ArraySegment`1 : ValueType {
    public T[] Array { get; }
    public int Count { get; }
    public static ArraySegment`1<T> Empty { get; }
    public int Offset { get; }
    public T Item { get; public set; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private T System.Collections.Generic.IList<T>.Item { get; private set; }
    private T System.Collections.Generic.IReadOnlyList<T>.Item { get; }
    public ArraySegment`1(T[] array);
    public ArraySegment`1(T[] array, int offset, int count);
    public T[] get_Array();
    public sealed virtual int get_Count();
    public static ArraySegment`1<T> get_Empty();
    public int get_Offset();
    public T get_Item(int index);
    public void set_Item(int index, T value);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override T System.Collections.Generic.IList<T>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.set_Item(int index, T value);
    private sealed virtual override T System.Collections.Generic.IReadOnlyList<T>.get_Item(int index);
    public void CopyTo(T[] destination);
    public void CopyTo(T[] destination, int destinationIndex);
    public void CopyTo(ArraySegment`1<T> destination);
    public bool Equals(ArraySegment`1<T> obj);
    public virtual bool Equals(object obj);
    public Enumerator<T> GetEnumerator();
    public virtual int GetHashCode();
    public ArraySegment`1<T> Slice(int index);
    public ArraySegment`1<T> Slice(int index, int count);
    public T[] ToArray();
    public static bool op_Equality(ArraySegment`1<T> a, ArraySegment`1<T> b);
    public static ArraySegment`1<T> op_Implicit(T[] array);
    public static bool op_Inequality(ArraySegment`1<T> a, ArraySegment`1<T> b);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Contains(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override int System.Collections.Generic.IList<T>.IndexOf(T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.ArrayTypeMismatchException : SystemException {
    public ArrayTypeMismatchException(string message);
    public ArrayTypeMismatchException(string message, Exception innerException);
    protected ArrayTypeMismatchException(SerializationInfo info, StreamingContext context);
}
public class System.AsyncCallback : MulticastDelegate {
    public AsyncCallback(object object, IntPtr method);
    public virtual void Invoke(IAsyncResult ar);
    public virtual IAsyncResult BeginInvoke(IAsyncResult ar, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("32767")]
public abstract class System.Attribute : object {
    public object TypeId { get; }
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
    public virtual bool Match(object obj);
    public virtual object get_TypeId();
    public static Attribute GetCustomAttribute(Assembly element, Type attributeType);
    public static Attribute GetCustomAttribute(Assembly element, Type attributeType, bool inherit);
    public static Attribute GetCustomAttribute(MemberInfo element, Type attributeType);
    public static Attribute GetCustomAttribute(MemberInfo element, Type attributeType, bool inherit);
    public static Attribute GetCustomAttribute(Module element, Type attributeType);
    public static Attribute GetCustomAttribute(Module element, Type attributeType, bool inherit);
    public static Attribute GetCustomAttribute(ParameterInfo element, Type attributeType);
    public static Attribute GetCustomAttribute(ParameterInfo element, Type attributeType, bool inherit);
    public static Attribute[] GetCustomAttributes(Assembly element);
    public static Attribute[] GetCustomAttributes(Assembly element, bool inherit);
    public static Attribute[] GetCustomAttributes(Assembly element, Type attributeType);
    public static Attribute[] GetCustomAttributes(Assembly element, Type attributeType, bool inherit);
    public static Attribute[] GetCustomAttributes(MemberInfo element);
    public static Attribute[] GetCustomAttributes(MemberInfo element, bool inherit);
    public static Attribute[] GetCustomAttributes(MemberInfo element, Type type);
    public static Attribute[] GetCustomAttributes(MemberInfo element, Type type, bool inherit);
    public static Attribute[] GetCustomAttributes(Module element);
    public static Attribute[] GetCustomAttributes(Module element, bool inherit);
    public static Attribute[] GetCustomAttributes(Module element, Type attributeType);
    public static Attribute[] GetCustomAttributes(Module element, Type attributeType, bool inherit);
    public static Attribute[] GetCustomAttributes(ParameterInfo element);
    public static Attribute[] GetCustomAttributes(ParameterInfo element, bool inherit);
    public static Attribute[] GetCustomAttributes(ParameterInfo element, Type attributeType);
    public static Attribute[] GetCustomAttributes(ParameterInfo element, Type attributeType, bool inherit);
    public static bool IsDefined(Assembly element, Type attributeType);
    public static bool IsDefined(Assembly element, Type attributeType, bool inherit);
    public static bool IsDefined(MemberInfo element, Type attributeType);
    public static bool IsDefined(MemberInfo element, Type attributeType, bool inherit);
    public static bool IsDefined(Module element, Type attributeType);
    public static bool IsDefined(Module element, Type attributeType, bool inherit);
    public static bool IsDefined(ParameterInfo element, Type attributeType);
    public static bool IsDefined(ParameterInfo element, Type attributeType, bool inherit);
}
[FlagsAttribute]
public enum System.AttributeTargets : Enum {
    public int value__;
    public static AttributeTargets All;
    public static AttributeTargets Assembly;
    public static AttributeTargets Class;
    public static AttributeTargets Constructor;
    public static AttributeTargets Delegate;
    public static AttributeTargets Enum;
    public static AttributeTargets Event;
    public static AttributeTargets Field;
    public static AttributeTargets GenericParameter;
    public static AttributeTargets Interface;
    public static AttributeTargets Method;
    public static AttributeTargets Module;
    public static AttributeTargets Parameter;
    public static AttributeTargets Property;
    public static AttributeTargets ReturnValue;
    public static AttributeTargets Struct;
}
[AttributeUsageAttribute("4")]
public class System.AttributeUsageAttribute : Attribute {
    public bool AllowMultiple { get; public set; }
    public bool Inherited { get; public set; }
    public AttributeTargets ValidOn { get; }
    public AttributeUsageAttribute(AttributeTargets validOn);
    public bool get_AllowMultiple();
    public void set_AllowMultiple(bool value);
    public bool get_Inherited();
    public void set_Inherited(bool value);
    public AttributeTargets get_ValidOn();
}
public class System.BadImageFormatException : SystemException {
    public string FileName { get; }
    public string FusionLog { get; }
    public string Message { get; }
    public BadImageFormatException(string message);
    public BadImageFormatException(string message, Exception inner);
    public BadImageFormatException(string message, string fileName);
    public BadImageFormatException(string message, string fileName, Exception inner);
    protected BadImageFormatException(SerializationInfo info, StreamingContext context);
    public string get_FileName();
    public string get_FusionLog();
    public virtual string get_Message();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
}
public class System.Boolean : ValueType {
    public static string FalseString;
    public static string TrueString;
    public sealed virtual int CompareTo(bool value);
    public sealed virtual bool Equals(bool obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool Parse(string value);
    public sealed virtual int CompareTo(object obj);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    public sealed virtual string ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public virtual string ToString();
    public static bool TryParse(string value, Boolean& result);
}
public static class System.Buffer : object {
    public static void BlockCopy(Array src, int srcOffset, Array dst, int dstOffset, int count);
    public static int ByteLength(Array array);
    public static byte GetByte(Array array, int index);
    [CLSCompliantAttribute("False")]
[SecurityCriticalAttribute]
public static void MemoryCopy(Void* source, Void* destination, long destinationSizeInBytes, long sourceBytesToCopy);
    [CLSCompliantAttribute("False")]
[SecurityCriticalAttribute]
public static void MemoryCopy(Void* source, Void* destination, ulong destinationSizeInBytes, ulong sourceBytesToCopy);
    public static void SetByte(Array array, int index, byte value);
}
public class System.Byte : ValueType {
    public static byte MaxValue;
    public static byte MinValue;
    public sealed virtual int CompareTo(byte value);
    public sealed virtual bool Equals(byte obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static byte Parse(string s);
    public static byte Parse(string s, NumberStyles style);
    public static byte Parse(string s, NumberStyles style, IFormatProvider provider);
    public static byte Parse(string s, IFormatProvider provider);
    public sealed virtual int CompareTo(object value);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public static bool TryParse(string s, Byte& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Byte& result);
}
public class System.Char : ValueType {
    public static char MaxValue;
    public static char MinValue;
    public sealed virtual int CompareTo(char value);
    public static string ConvertFromUtf32(int utf32);
    public static int ConvertToUtf32(char highSurrogate, char lowSurrogate);
    public static int ConvertToUtf32(string s, int index);
    public sealed virtual bool Equals(char obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static double GetNumericValue(char c);
    public static double GetNumericValue(string s, int index);
    public static UnicodeCategory GetUnicodeCategory(char c);
    public static UnicodeCategory GetUnicodeCategory(string s, int index);
    public static bool IsControl(char c);
    public static bool IsControl(string s, int index);
    public static bool IsDigit(char c);
    public static bool IsDigit(string s, int index);
    public static bool IsHighSurrogate(char c);
    public static bool IsHighSurrogate(string s, int index);
    public static bool IsLetter(char c);
    public static bool IsLetter(string s, int index);
    public static bool IsLetterOrDigit(char c);
    public static bool IsLetterOrDigit(string s, int index);
    public static bool IsLower(char c);
    public static bool IsLower(string s, int index);
    public static bool IsLowSurrogate(char c);
    public static bool IsLowSurrogate(string s, int index);
    public static bool IsNumber(char c);
    public static bool IsNumber(string s, int index);
    public static bool IsPunctuation(char c);
    public static bool IsPunctuation(string s, int index);
    public static bool IsSeparator(char c);
    public static bool IsSeparator(string s, int index);
    public static bool IsSurrogate(char c);
    public static bool IsSurrogate(string s, int index);
    public static bool IsSurrogatePair(char highSurrogate, char lowSurrogate);
    public static bool IsSurrogatePair(string s, int index);
    public static bool IsSymbol(char c);
    public static bool IsSymbol(string s, int index);
    public static bool IsUpper(char c);
    public static bool IsUpper(string s, int index);
    public static bool IsWhiteSpace(char c);
    public static bool IsWhiteSpace(string s, int index);
    public static char Parse(string s);
    public sealed virtual int CompareTo(object value);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    public sealed virtual string ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public static char ToLower(char c);
    public static char ToLower(char c, CultureInfo culture);
    public static char ToLowerInvariant(char c);
    public virtual string ToString();
    public static string ToString(char c);
    public static char ToUpper(char c);
    public static char ToUpper(char c, CultureInfo culture);
    public static char ToUpperInvariant(char c);
    public static bool TryParse(string s, Char& result);
}
public class System.CharEnumerator : object {
    public char Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public sealed virtual char get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual object Clone();
    public sealed virtual void Dispose();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
[AttributeUsageAttribute("32767")]
public class System.CLSCompliantAttribute : Attribute {
    public bool IsCompliant { get; }
    public CLSCompliantAttribute(bool isCompliant);
    public bool get_IsCompliant();
}
public class System.Collections.DictionaryEntry : ValueType {
    public object Key { get; public set; }
    public object Value { get; public set; }
    public DictionaryEntry(object key, object value);
    [EditorBrowsableAttribute("1")]
public void Deconstruct(Object& key, Object& value);
    public object get_Key();
    public void set_Key(object value);
    public object get_Value();
    public void set_Value(object value);
}
public interface System.Collections.Generic.ICollection`1 {
    public int Count { get; }
    public bool IsReadOnly { get; }
    public abstract virtual int get_Count();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual void Add(T item);
    public abstract virtual void Clear();
    public abstract virtual bool Contains(T item);
    public abstract virtual void CopyTo(T[] array, int arrayIndex);
    public abstract virtual bool Remove(T item);
}
public interface System.Collections.Generic.IComparer`1 {
    public abstract virtual int Compare(T x, T y);
}
[DefaultMemberAttribute("Item")]
public interface System.Collections.Generic.IDictionary`2 {
    public TValue Item { get; public set; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public abstract virtual TValue get_Item(TKey key);
    public abstract virtual void set_Item(TKey key, TValue value);
    public abstract virtual ICollection`1<TKey> get_Keys();
    public abstract virtual ICollection`1<TValue> get_Values();
    public abstract virtual void Add(TKey key, TValue value);
    public abstract virtual bool ContainsKey(TKey key);
    public abstract virtual bool Remove(TKey key);
    public abstract virtual bool TryGetValue(TKey key, TValue& value);
}
public interface System.Collections.Generic.IEnumerable`1 {
    public abstract virtual IEnumerator`1<T> GetEnumerator();
}
public interface System.Collections.Generic.IEnumerator`1 {
    public T Current { get; }
    public abstract virtual T get_Current();
}
public interface System.Collections.Generic.IEqualityComparer`1 {
    public abstract virtual bool Equals(T x, T y);
    public abstract virtual int GetHashCode(T obj);
}
[DefaultMemberAttribute("Item")]
public interface System.Collections.Generic.IList`1 {
    public T Item { get; public set; }
    public abstract virtual T get_Item(int index);
    public abstract virtual void set_Item(int index, T value);
    public abstract virtual int IndexOf(T item);
    public abstract virtual void Insert(int index, T item);
    public abstract virtual void RemoveAt(int index);
}
public interface System.Collections.Generic.IReadOnlyCollection`1 {
    public int Count { get; }
    public abstract virtual int get_Count();
}
[DefaultMemberAttribute("Item")]
public interface System.Collections.Generic.IReadOnlyDictionary`2 {
    public TValue Item { get; }
    public IEnumerable`1<TKey> Keys { get; }
    public IEnumerable`1<TValue> Values { get; }
    public abstract virtual TValue get_Item(TKey key);
    public abstract virtual IEnumerable`1<TKey> get_Keys();
    public abstract virtual IEnumerable`1<TValue> get_Values();
    public abstract virtual bool ContainsKey(TKey key);
    public abstract virtual bool TryGetValue(TKey key, TValue& value);
}
[DefaultMemberAttribute("Item")]
public interface System.Collections.Generic.IReadOnlyList`1 {
    public T Item { get; }
    public abstract virtual T get_Item(int index);
}
public interface System.Collections.Generic.ISet`1 {
    public abstract virtual bool Add(T item);
    public abstract virtual void ExceptWith(IEnumerable`1<T> other);
    public abstract virtual void IntersectWith(IEnumerable`1<T> other);
    public abstract virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public abstract virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public abstract virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public abstract virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public abstract virtual bool Overlaps(IEnumerable`1<T> other);
    public abstract virtual bool SetEquals(IEnumerable`1<T> other);
    public abstract virtual void SymmetricExceptWith(IEnumerable`1<T> other);
    public abstract virtual void UnionWith(IEnumerable`1<T> other);
}
public class System.Collections.Generic.KeyNotFoundException : SystemException {
    public KeyNotFoundException(string message);
    public KeyNotFoundException(string message, Exception innerException);
    protected KeyNotFoundException(SerializationInfo info, StreamingContext context);
}
public static class System.Collections.Generic.KeyValuePair : object {
    public static KeyValuePair`2<TKey, TValue> Create(TKey key, TValue value);
}
public class System.Collections.Generic.KeyValuePair`2 : ValueType {
    public TKey Key { get; }
    public TValue Value { get; }
    public KeyValuePair`2(TKey key, TValue value);
    [EditorBrowsableAttribute("1")]
public void Deconstruct(TKey& key, TValue& value);
    public TKey get_Key();
    public TValue get_Value();
    public virtual string ToString();
}
public interface System.Collections.ICollection {
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public abstract virtual int get_Count();
    public abstract virtual bool get_IsSynchronized();
    public abstract virtual object get_SyncRoot();
    public abstract virtual void CopyTo(Array array, int index);
}
public interface System.Collections.IComparer {
    public abstract virtual int Compare(object x, object y);
}
[DefaultMemberAttribute("Item")]
public interface System.Collections.IDictionary {
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public object Item { get; public set; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public abstract virtual bool get_IsFixedSize();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual object get_Item(object key);
    public abstract virtual void set_Item(object key, object value);
    public abstract virtual ICollection get_Keys();
    public abstract virtual ICollection get_Values();
    public abstract virtual void Add(object key, object value);
    public abstract virtual void Clear();
    public abstract virtual bool Contains(object key);
    public abstract virtual IDictionaryEnumerator GetEnumerator();
    public abstract virtual void Remove(object key);
}
public interface System.Collections.IDictionaryEnumerator {
    public DictionaryEntry Entry { get; }
    public object Key { get; }
    public object Value { get; }
    public abstract virtual DictionaryEntry get_Entry();
    public abstract virtual object get_Key();
    public abstract virtual object get_Value();
}
public interface System.Collections.IEnumerable {
    public abstract virtual IEnumerator GetEnumerator();
}
public interface System.Collections.IEnumerator {
    public object Current { get; }
    public abstract virtual object get_Current();
    public abstract virtual bool MoveNext();
    public abstract virtual void Reset();
}
public interface System.Collections.IEqualityComparer {
    public abstract virtual bool Equals(object x, object y);
    public abstract virtual int GetHashCode(object obj);
}
[DefaultMemberAttribute("Item")]
public interface System.Collections.IList {
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public object Item { get; public set; }
    public abstract virtual bool get_IsFixedSize();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual object get_Item(int index);
    public abstract virtual void set_Item(int index, object value);
    public abstract virtual int Add(object value);
    public abstract virtual void Clear();
    public abstract virtual bool Contains(object value);
    public abstract virtual int IndexOf(object value);
    public abstract virtual void Insert(int index, object value);
    public abstract virtual void Remove(object value);
    public abstract virtual void RemoveAt(int index);
}
public interface System.Collections.IStructuralComparable {
    public abstract virtual int CompareTo(object other, IComparer comparer);
}
public interface System.Collections.IStructuralEquatable {
    public abstract virtual bool Equals(object other, IEqualityComparer comparer);
    public abstract virtual int GetHashCode(IEqualityComparer comparer);
}
[DefaultMemberAttribute("Item")]
public class System.Collections.ObjectModel.Collection`1 : object {
    public int Count { get; }
    public T Item { get; public set; }
    protected IList`1<T> Items { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public Collection`1(IList`1<T> list);
    public sealed virtual int get_Count();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    protected IList`1<T> get_Items();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    protected virtual void ClearItems();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int index);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    protected virtual void InsertItem(int index, T item);
    public sealed virtual bool Remove(T item);
    public sealed virtual void RemoveAt(int index);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, T item);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
}
[DefaultMemberAttribute("Item")]
public class System.Collections.ObjectModel.ReadOnlyCollection`1 : object {
    public int Count { get; }
    public T Item { get; }
    protected IList`1<T> Items { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private T System.Collections.Generic.IList<T>.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public ReadOnlyCollection`1(IList`1<T> list);
    public sealed virtual int get_Count();
    public sealed virtual T get_Item(int index);
    protected IList`1<T> get_Items();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override T System.Collections.Generic.IList<T>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.set_Item(int index, T value);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual bool Contains(T value);
    public sealed virtual void CopyTo(T[] array, int index);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public sealed virtual int IndexOf(T value);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T value);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T value);
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T value);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
}
public class System.Comparison`1 : MulticastDelegate {
    public Comparison`1(object object, IntPtr method);
    public virtual int Invoke(T x, T y);
    public virtual IAsyncResult BeginInvoke(T x, T y, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.DefaultValueAttribute : Attribute {
    public object Value { get; }
    public DefaultValueAttribute(bool value);
    public DefaultValueAttribute(byte value);
    public DefaultValueAttribute(char value);
    public DefaultValueAttribute(double value);
    public DefaultValueAttribute(short value);
    public DefaultValueAttribute(int value);
    public DefaultValueAttribute(long value);
    public DefaultValueAttribute(object value);
    public DefaultValueAttribute(float value);
    public DefaultValueAttribute(string value);
    [CLSCompliantAttribute("False")]
public DefaultValueAttribute(sbyte value);
    [CLSCompliantAttribute("False")]
public DefaultValueAttribute(ushort value);
    [CLSCompliantAttribute("False")]
public DefaultValueAttribute(UInt32 value);
    [CLSCompliantAttribute("False")]
public DefaultValueAttribute(ulong value);
    public DefaultValueAttribute(Type type, string value);
    public virtual object get_Value();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    protected void SetValue(object value);
}
[AttributeUsageAttribute("6140")]
public class System.ComponentModel.EditorBrowsableAttribute : Attribute {
    public EditorBrowsableState State { get; }
    public EditorBrowsableAttribute(EditorBrowsableState state);
    public EditorBrowsableState get_State();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public enum System.ComponentModel.EditorBrowsableState : Enum {
    public int value__;
    public static EditorBrowsableState Advanced;
    public static EditorBrowsableState Always;
    public static EditorBrowsableState Never;
}
public enum System.Configuration.Assemblies.AssemblyHashAlgorithm : Enum {
    public int value__;
    public static AssemblyHashAlgorithm MD5;
    public static AssemblyHashAlgorithm None;
    public static AssemblyHashAlgorithm SHA1;
    public static AssemblyHashAlgorithm SHA256;
    public static AssemblyHashAlgorithm SHA384;
    public static AssemblyHashAlgorithm SHA512;
}
public enum System.Configuration.Assemblies.AssemblyVersionCompatibility : Enum {
    public int value__;
    public static AssemblyVersionCompatibility SameMachine;
    public static AssemblyVersionCompatibility SameProcess;
    public static AssemblyVersionCompatibility SameDomain;
}
public class System.Converter`2 : MulticastDelegate {
    public Converter`2(object object, IntPtr method);
    public virtual TOutput Invoke(TInput input);
    public virtual IAsyncResult BeginInvoke(TInput input, AsyncCallback callback, object object);
    public virtual TOutput EndInvoke(IAsyncResult result);
}
public class System.DateTime : ValueType {
    public static DateTime MaxValue;
    public static DateTime MinValue;
    public DateTime Date { get; }
    public int Day { get; }
    public DayOfWeek DayOfWeek { get; }
    public int DayOfYear { get; }
    public int Hour { get; }
    public DateTimeKind Kind { get; }
    public int Millisecond { get; }
    public int Minute { get; }
    public int Month { get; }
    public static DateTime Now { get; }
    public int Second { get; }
    public long Ticks { get; }
    public TimeSpan TimeOfDay { get; }
    public static DateTime Today { get; }
    public static DateTime UtcNow { get; }
    public int Year { get; }
    public DateTime(int year, int month, int day);
    public DateTime(int year, int month, int day, Calendar calendar);
    public DateTime(int year, int month, int day, int hour, int minute, int second);
    public DateTime(int year, int month, int day, int hour, int minute, int second, DateTimeKind kind);
    public DateTime(int year, int month, int day, int hour, int minute, int second, Calendar calendar);
    public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond);
    public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, DateTimeKind kind);
    public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, Calendar calendar);
    public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, Calendar calendar, DateTimeKind kind);
    public DateTime(long ticks);
    public DateTime(long ticks, DateTimeKind kind);
    public DateTime get_Date();
    public int get_Day();
    public DayOfWeek get_DayOfWeek();
    public int get_DayOfYear();
    public int get_Hour();
    public DateTimeKind get_Kind();
    public int get_Millisecond();
    public int get_Minute();
    public int get_Month();
    public static DateTime get_Now();
    public int get_Second();
    public long get_Ticks();
    public TimeSpan get_TimeOfDay();
    public static DateTime get_Today();
    public static DateTime get_UtcNow();
    public int get_Year();
    public DateTime Add(TimeSpan value);
    public DateTime AddDays(double value);
    public DateTime AddHours(double value);
    public DateTime AddMilliseconds(double value);
    public DateTime AddMinutes(double value);
    public DateTime AddMonths(int months);
    public DateTime AddSeconds(double value);
    public DateTime AddTicks(long value);
    public DateTime AddYears(int value);
    public static int Compare(DateTime t1, DateTime t2);
    public sealed virtual int CompareTo(DateTime value);
    public int CompareTo(object value);
    public static int DaysInMonth(int year, int month);
    public sealed virtual bool Equals(DateTime value);
    public static bool Equals(DateTime t1, DateTime t2);
    public virtual bool Equals(object value);
    public static DateTime FromBinary(long dateData);
    public static DateTime FromFileTime(long fileTime);
    public static DateTime FromFileTimeUtc(long fileTime);
    public static DateTime FromOADate(double d);
    public String[] GetDateTimeFormats();
    public String[] GetDateTimeFormats(char format);
    public String[] GetDateTimeFormats(char format, IFormatProvider provider);
    public String[] GetDateTimeFormats(IFormatProvider provider);
    public virtual int GetHashCode();
    public TypeCode GetTypeCode();
    public bool IsDaylightSavingTime();
    public static bool IsLeapYear(int year);
    public static DateTime op_Addition(DateTime d, TimeSpan t);
    public static bool op_Equality(DateTime d1, DateTime d2);
    public static bool op_GreaterThan(DateTime t1, DateTime t2);
    public static bool op_GreaterThanOrEqual(DateTime t1, DateTime t2);
    public static bool op_Inequality(DateTime d1, DateTime d2);
    public static bool op_LessThan(DateTime t1, DateTime t2);
    public static bool op_LessThanOrEqual(DateTime t1, DateTime t2);
    public static TimeSpan op_Subtraction(DateTime d1, DateTime d2);
    public static DateTime op_Subtraction(DateTime d, TimeSpan t);
    public static DateTime Parse(string s);
    public static DateTime Parse(string s, IFormatProvider provider);
    public static DateTime Parse(string s, IFormatProvider provider, DateTimeStyles styles);
    public static DateTime ParseExact(string s, string format, IFormatProvider provider);
    public static DateTime ParseExact(string s, string format, IFormatProvider provider, DateTimeStyles style);
    public static DateTime ParseExact(string s, String[] formats, IFormatProvider provider, DateTimeStyles style);
    public static DateTime SpecifyKind(DateTime value, DateTimeKind kind);
    public TimeSpan Subtract(DateTime value);
    public DateTime Subtract(TimeSpan value);
    private sealed virtual override int System.IComparable.CompareTo(object value);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public long ToBinary();
    public long ToFileTime();
    public long ToFileTimeUtc();
    public DateTime ToLocalTime();
    public string ToLongDateString();
    public string ToLongTimeString();
    public double ToOADate();
    public string ToShortDateString();
    public string ToShortTimeString();
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public DateTime ToUniversalTime();
    public static bool TryParse(string s, DateTime& result);
    public static bool TryParse(string s, IFormatProvider provider, DateTimeStyles styles, DateTime& result);
    public static bool TryParseExact(string s, string format, IFormatProvider provider, DateTimeStyles style, DateTime& result);
    public static bool TryParseExact(string s, String[] formats, IFormatProvider provider, DateTimeStyles style, DateTime& result);
}
public enum System.DateTimeKind : Enum {
    public int value__;
    public static DateTimeKind Local;
    public static DateTimeKind Unspecified;
    public static DateTimeKind Utc;
}
public class System.DateTimeOffset : ValueType {
    public static DateTimeOffset MaxValue;
    public static DateTimeOffset MinValue;
    public DateTime Date { get; }
    public DateTime DateTime { get; }
    public int Day { get; }
    public DayOfWeek DayOfWeek { get; }
    public int DayOfYear { get; }
    public int Hour { get; }
    public DateTime LocalDateTime { get; }
    public int Millisecond { get; }
    public int Minute { get; }
    public int Month { get; }
    public static DateTimeOffset Now { get; }
    public TimeSpan Offset { get; }
    public int Second { get; }
    public long Ticks { get; }
    public TimeSpan TimeOfDay { get; }
    public DateTime UtcDateTime { get; }
    public static DateTimeOffset UtcNow { get; }
    public long UtcTicks { get; }
    public int Year { get; }
    public DateTimeOffset(DateTime dateTime);
    public DateTimeOffset(DateTime dateTime, TimeSpan offset);
    public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, Calendar calendar, TimeSpan offset);
    public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, TimeSpan offset);
    public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, TimeSpan offset);
    public DateTimeOffset(long ticks, TimeSpan offset);
    public DateTime get_Date();
    public DateTime get_DateTime();
    public int get_Day();
    public DayOfWeek get_DayOfWeek();
    public int get_DayOfYear();
    public int get_Hour();
    public DateTime get_LocalDateTime();
    public int get_Millisecond();
    public int get_Minute();
    public int get_Month();
    public static DateTimeOffset get_Now();
    public TimeSpan get_Offset();
    public int get_Second();
    public long get_Ticks();
    public TimeSpan get_TimeOfDay();
    public DateTime get_UtcDateTime();
    public static DateTimeOffset get_UtcNow();
    public long get_UtcTicks();
    public int get_Year();
    public DateTimeOffset Add(TimeSpan timeSpan);
    public DateTimeOffset AddDays(double days);
    public DateTimeOffset AddHours(double hours);
    public DateTimeOffset AddMilliseconds(double milliseconds);
    public DateTimeOffset AddMinutes(double minutes);
    public DateTimeOffset AddMonths(int months);
    public DateTimeOffset AddSeconds(double seconds);
    public DateTimeOffset AddTicks(long ticks);
    public DateTimeOffset AddYears(int years);
    public static int Compare(DateTimeOffset first, DateTimeOffset second);
    public sealed virtual int CompareTo(DateTimeOffset other);
    public sealed virtual bool Equals(DateTimeOffset other);
    public static bool Equals(DateTimeOffset first, DateTimeOffset second);
    public virtual bool Equals(object obj);
    public bool EqualsExact(DateTimeOffset other);
    public static DateTimeOffset FromFileTime(long fileTime);
    public static DateTimeOffset FromUnixTimeMilliseconds(long milliseconds);
    public static DateTimeOffset FromUnixTimeSeconds(long seconds);
    public virtual int GetHashCode();
    public static DateTimeOffset op_Addition(DateTimeOffset dateTimeOffset, TimeSpan timeSpan);
    public static bool op_Equality(DateTimeOffset left, DateTimeOffset right);
    public static bool op_GreaterThan(DateTimeOffset left, DateTimeOffset right);
    public static bool op_GreaterThanOrEqual(DateTimeOffset left, DateTimeOffset right);
    public static DateTimeOffset op_Implicit(DateTime dateTime);
    public static bool op_Inequality(DateTimeOffset left, DateTimeOffset right);
    public static bool op_LessThan(DateTimeOffset left, DateTimeOffset right);
    public static bool op_LessThanOrEqual(DateTimeOffset left, DateTimeOffset right);
    public static TimeSpan op_Subtraction(DateTimeOffset left, DateTimeOffset right);
    public static DateTimeOffset op_Subtraction(DateTimeOffset dateTimeOffset, TimeSpan timeSpan);
    public static DateTimeOffset Parse(string input);
    public static DateTimeOffset Parse(string input, IFormatProvider formatProvider);
    public static DateTimeOffset Parse(string input, IFormatProvider formatProvider, DateTimeStyles styles);
    public static DateTimeOffset ParseExact(string input, string format, IFormatProvider formatProvider);
    public static DateTimeOffset ParseExact(string input, string format, IFormatProvider formatProvider, DateTimeStyles styles);
    public static DateTimeOffset ParseExact(string input, String[] formats, IFormatProvider formatProvider, DateTimeStyles styles);
    public TimeSpan Subtract(DateTimeOffset value);
    public DateTimeOffset Subtract(TimeSpan value);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public long ToFileTime();
    public DateTimeOffset ToLocalTime();
    public DateTimeOffset ToOffset(TimeSpan offset);
    public virtual string ToString();
    public string ToString(IFormatProvider formatProvider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public DateTimeOffset ToUniversalTime();
    public long ToUnixTimeMilliseconds();
    public long ToUnixTimeSeconds();
    public static bool TryParse(string input, DateTimeOffset& result);
    public static bool TryParse(string input, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
    public static bool TryParseExact(string input, string format, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
    public static bool TryParseExact(string input, String[] formats, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
}
public enum System.DayOfWeek : Enum {
    public int value__;
    public static DayOfWeek Friday;
    public static DayOfWeek Monday;
    public static DayOfWeek Saturday;
    public static DayOfWeek Sunday;
    public static DayOfWeek Thursday;
    public static DayOfWeek Tuesday;
    public static DayOfWeek Wednesday;
}
public class System.DBNull : object {
    public static DBNull Value;
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
}
public class System.Decimal : ValueType {
    [DecimalConstantAttribute("0", "0", "4294967295", "4294967295", "4294967295")]
public static decimal MaxValue;
    [DecimalConstantAttribute("0", "128", "0", "0", "1")]
public static decimal MinusOne;
    [DecimalConstantAttribute("0", "128", "4294967295", "4294967295", "4294967295")]
public static decimal MinValue;
    [DecimalConstantAttribute("0", "0", "0", "0", "1")]
public static decimal One;
    [DecimalConstantAttribute("0", "0", "0", "0", "0")]
public static decimal Zero;
    public Decimal(double value);
    public Decimal(int value);
    public Decimal(int lo, int mid, int hi, bool isNegative, byte scale);
    public Decimal(Int32[] bits);
    public Decimal(long value);
    public Decimal(float value);
    [CLSCompliantAttribute("False")]
public Decimal(UInt32 value);
    [CLSCompliantAttribute("False")]
public Decimal(ulong value);
    public static decimal Add(decimal d1, decimal d2);
    public static decimal Ceiling(decimal d);
    public static int Compare(decimal d1, decimal d2);
    public sealed virtual int CompareTo(decimal value);
    public static decimal Divide(decimal d1, decimal d2);
    public sealed virtual bool Equals(decimal value);
    public static bool Equals(decimal d1, decimal d2);
    public virtual bool Equals(object value);
    public static decimal Floor(decimal d);
    public static decimal FromOACurrency(long cy);
    public static Int32[] GetBits(decimal d);
    public virtual int GetHashCode();
    public static decimal Multiply(decimal d1, decimal d2);
    public static decimal Negate(decimal d);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    public static decimal op_Addition(decimal d1, decimal d2);
    public static decimal op_Decrement(decimal d);
    public static decimal op_Division(decimal d1, decimal d2);
    public static bool op_Equality(decimal d1, decimal d2);
    public static byte op_Explicit(decimal value);
    public static char op_Explicit(decimal value);
    public static double op_Explicit(decimal value);
    public static short op_Explicit(decimal value);
    public static int op_Explicit(decimal value);
    public static long op_Explicit(decimal value);
    [CLSCompliantAttribute("False")]
public static sbyte op_Explicit(decimal value);
    public static float op_Explicit(decimal value);
    [CLSCompliantAttribute("False")]
public static ushort op_Explicit(decimal value);
    [CLSCompliantAttribute("False")]
public static UInt32 op_Explicit(decimal value);
    [CLSCompliantAttribute("False")]
public static ulong op_Explicit(decimal value);
    public static decimal op_Explicit(double value);
    public static decimal op_Explicit(float value);
    public static bool op_GreaterThan(decimal d1, decimal d2);
    public static bool op_GreaterThanOrEqual(decimal d1, decimal d2);
    public static decimal op_Implicit(byte value);
    public static decimal op_Implicit(char value);
    public static decimal op_Implicit(short value);
    public static decimal op_Implicit(int value);
    public static decimal op_Implicit(long value);
    [CLSCompliantAttribute("False")]
public static decimal op_Implicit(sbyte value);
    [CLSCompliantAttribute("False")]
public static decimal op_Implicit(ushort value);
    [CLSCompliantAttribute("False")]
public static decimal op_Implicit(UInt32 value);
    [CLSCompliantAttribute("False")]
public static decimal op_Implicit(ulong value);
    public static decimal op_Increment(decimal d);
    public static bool op_Inequality(decimal d1, decimal d2);
    public static bool op_LessThan(decimal d1, decimal d2);
    public static bool op_LessThanOrEqual(decimal d1, decimal d2);
    public static decimal op_Modulus(decimal d1, decimal d2);
    public static decimal op_Multiply(decimal d1, decimal d2);
    public static decimal op_Subtraction(decimal d1, decimal d2);
    public static decimal op_UnaryNegation(decimal d);
    public static decimal op_UnaryPlus(decimal d);
    public static decimal Parse(string s);
    public static decimal Parse(string s, NumberStyles style);
    public static decimal Parse(string s, NumberStyles style, IFormatProvider provider);
    public static decimal Parse(string s, IFormatProvider provider);
    public static decimal Remainder(decimal d1, decimal d2);
    public static decimal Round(decimal d);
    public static decimal Round(decimal d, int decimals);
    public static decimal Round(decimal d, int decimals, MidpointRounding mode);
    public static decimal Round(decimal d, MidpointRounding mode);
    public static decimal Subtract(decimal d1, decimal d2);
    public sealed virtual int CompareTo(object value);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public static byte ToByte(decimal value);
    public static double ToDouble(decimal d);
    public static short ToInt16(decimal value);
    public static int ToInt32(decimal d);
    public static long ToInt64(decimal d);
    public static long ToOACurrency(decimal value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(decimal value);
    public static float ToSingle(decimal d);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(decimal value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(decimal d);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(decimal d);
    public static decimal Truncate(decimal d);
    public static bool TryParse(string s, Decimal& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Decimal& result);
}
public abstract class System.Delegate : object {
    public MethodInfo Method { get; }
    public object Target { get; }
    protected Delegate(object target, string method);
    protected Delegate(Type target, string method);
    public MethodInfo get_Method();
    public object get_Target();
    public virtual object Clone();
    public static Delegate Combine(Delegate a, Delegate b);
    public static Delegate Combine(Delegate[] delegates);
    protected virtual Delegate CombineImpl(Delegate d);
    public static Delegate CreateDelegate(Type type, object firstArgument, MethodInfo method);
    public static Delegate CreateDelegate(Type type, object firstArgument, MethodInfo method, bool throwOnBindFailure);
    public static Delegate CreateDelegate(Type type, object target, string method);
    public static Delegate CreateDelegate(Type type, object target, string method, bool ignoreCase);
    public static Delegate CreateDelegate(Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure);
    public static Delegate CreateDelegate(Type type, MethodInfo method);
    public static Delegate CreateDelegate(Type type, MethodInfo method, bool throwOnBindFailure);
    public static Delegate CreateDelegate(Type type, Type target, string method);
    public static Delegate CreateDelegate(Type type, Type target, string method, bool ignoreCase);
    public static Delegate CreateDelegate(Type type, Type target, string method, bool ignoreCase, bool throwOnBindFailure);
    public object DynamicInvoke(Object[] args);
    protected virtual object DynamicInvokeImpl(Object[] args);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual Delegate[] GetInvocationList();
    protected virtual MethodInfo GetMethodImpl();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public static bool op_Equality(Delegate d1, Delegate d2);
    public static bool op_Inequality(Delegate d1, Delegate d2);
    public static Delegate Remove(Delegate source, Delegate value);
    public static Delegate RemoveAll(Delegate source, Delegate value);
    protected virtual Delegate RemoveImpl(Delegate d);
}
[AttributeUsageAttribute("68")]
public class System.Diagnostics.ConditionalAttribute : Attribute {
    public string ConditionString { get; }
    public ConditionalAttribute(string conditionString);
    public string get_ConditionString();
}
[AttributeUsageAttribute("3")]
public class System.Diagnostics.DebuggableAttribute : Attribute {
    public DebuggingModes DebuggingFlags { get; }
    public bool IsJITOptimizerDisabled { get; }
    public bool IsJITTrackingEnabled { get; }
    public DebuggableAttribute(bool isJITTrackingEnabled, bool isJITOptimizerDisabled);
    public DebuggableAttribute(DebuggingModes modes);
    public DebuggingModes get_DebuggingFlags();
    public bool get_IsJITOptimizerDisabled();
    public bool get_IsJITTrackingEnabled();
}
public class System.DivideByZeroException : ArithmeticException {
    public DivideByZeroException(string message);
    public DivideByZeroException(string message, Exception innerException);
    protected DivideByZeroException(SerializationInfo info, StreamingContext context);
}
public class System.Double : ValueType {
    public static double MinValue;
    public static double MaxValue;
    public static double Epsilon;
    public static double NegativeInfinity;
    public static double PositiveInfinity;
    public static double NaN;
    public sealed virtual int CompareTo(double value);
    public sealed virtual bool Equals(double obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool IsInfinity(double d);
    public static bool IsNaN(double d);
    public static bool IsNegativeInfinity(double d);
    public static bool IsPositiveInfinity(double d);
    public static bool op_Equality(double left, double right);
    public static bool op_GreaterThan(double left, double right);
    public static bool op_GreaterThanOrEqual(double left, double right);
    public static bool op_Inequality(double left, double right);
    public static bool op_LessThan(double left, double right);
    public static bool op_LessThanOrEqual(double left, double right);
    public static double Parse(string s);
    public static double Parse(string s, NumberStyles style);
    public static double Parse(string s, NumberStyles style, IFormatProvider provider);
    public static double Parse(string s, IFormatProvider provider);
    public sealed virtual int CompareTo(object value);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public static bool TryParse(string s, Double& result);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Double& result);
}
public class System.DuplicateWaitObjectException : ArgumentException {
    public DuplicateWaitObjectException(string parameterName);
    public DuplicateWaitObjectException(string parameterName, string message);
    public DuplicateWaitObjectException(string message, Exception innerException);
    protected DuplicateWaitObjectException(SerializationInfo info, StreamingContext context);
}
public class System.EntryPointNotFoundException : TypeLoadException {
    public EntryPointNotFoundException(string message);
    public EntryPointNotFoundException(string message, Exception inner);
    protected EntryPointNotFoundException(SerializationInfo info, StreamingContext context);
}
public abstract class System.Enum : ValueType {
    public sealed virtual int CompareTo(object target);
    public virtual bool Equals(object obj);
    public static string Format(Type enumType, object value, string format);
    public virtual int GetHashCode();
    public static string GetName(Type enumType, object value);
    public static String[] GetNames(Type enumType);
    public TypeCode GetTypeCode();
    public static Type GetUnderlyingType(Type enumType);
    public static Array GetValues(Type enumType);
    public bool HasFlag(Enum flag);
    public static bool IsDefined(Type enumType, object value);
    public static object Parse(Type enumType, string value);
    public static object Parse(Type enumType, string value, bool ignoreCase);
    public static TEnum Parse(string value);
    public static TEnum Parse(string value, bool ignoreCase);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public static object ToObject(Type enumType, object value);
    public static object ToObject(Type enumType, int value);
    public static object ToObject(Type enumType, long value);
    public static object ToObject(Type enumType, byte value);
    public static object ToObject(Type enumType, short value);
    [CLSCompliantAttribute("False")]
public static object ToObject(Type enumType, UInt32 value);
    [CLSCompliantAttribute("False")]
public static object ToObject(Type enumType, ulong value);
    [CLSCompliantAttribute("False")]
public static object ToObject(Type enumType, sbyte value);
    [CLSCompliantAttribute("False")]
public static object ToObject(Type enumType, ushort value);
    public virtual string ToString();
    public string ToString(string format);
    [ObsoleteAttribute("The provider argument is not used. Please use ToString().")]
public sealed virtual string ToString(IFormatProvider provider);
    [ObsoleteAttribute("The provider argument is not used. Please use ToString(String).")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public static bool TryParse(Type enumType, string value, Object& result);
    public static bool TryParse(Type enumType, string value, bool ignoreCase, Object& result);
    public static bool TryParse(string value, TEnum& result);
    public static bool TryParse(string value, bool ignoreCase, TEnum& result);
}
public class System.EventArgs : object {
    public static EventArgs Empty;
}
public class System.EventHandler : MulticastDelegate {
    public EventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, EventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, EventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.EventHandler`1 : MulticastDelegate {
    public EventHandler`1(object object, IntPtr method);
    public virtual void Invoke(object sender, TEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, TEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Exception : object {
    public IDictionary Data { get; }
    public string HelpLink { get; public set; }
    public int HResult { get; protected set; }
    public Exception InnerException { get; }
    public string Message { get; }
    public string Source { get; public set; }
    public string StackTrace { get; }
    public MethodBase TargetSite { get; }
    public Exception(string message);
    public Exception(string message, Exception innerException);
    protected Exception(SerializationInfo info, StreamingContext context);
    public virtual IDictionary get_Data();
    public Type GetType();
    public virtual string get_HelpLink();
    public virtual void set_HelpLink(string value);
    public int get_HResult();
    protected void set_HResult(int value);
    public Exception get_InnerException();
    public virtual string get_Message();
    public virtual string get_Source();
    public virtual void set_Source(string value);
    public virtual string get_StackTrace();
    public MethodBase get_TargetSite();
    protected void add_SerializeObjectState(EventHandler`1<SafeSerializationEventArgs> value);
    protected void remove_SerializeObjectState(EventHandler`1<SafeSerializationEventArgs> value);
    public virtual Exception GetBaseException();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
}
[ObsoleteAttribute("This type previously indicated an unspecified fatal error in the runtime. The runtime no longer raises this exception so this type is obsolete.")]
public class System.ExecutionEngineException : SystemException {
    public ExecutionEngineException(string message);
    public ExecutionEngineException(string message, Exception innerException);
}
public class System.FieldAccessException : MemberAccessException {
    public FieldAccessException(string message);
    public FieldAccessException(string message, Exception inner);
    protected FieldAccessException(SerializationInfo info, StreamingContext context);
}
public class System.FileStyleUriParser : UriParser {
}
[AttributeUsageAttribute("16")]
public class System.FlagsAttribute : Attribute {
}
public class System.FormatException : SystemException {
    public FormatException(string message);
    public FormatException(string message, Exception innerException);
    protected FormatException(SerializationInfo info, StreamingContext context);
}
public abstract class System.FormattableString : object {
    public int ArgumentCount { get; }
    public string Format { get; }
    public abstract virtual int get_ArgumentCount();
    public abstract virtual string get_Format();
    public abstract virtual object GetArgument(int index);
    public abstract virtual Object[] GetArguments();
    public static string Invariant(FormattableString formattable);
    private sealed virtual override string System.IFormattable.ToString(string ignored, IFormatProvider formatProvider);
    public virtual string ToString();
    public abstract virtual string ToString(IFormatProvider formatProvider);
}
public class System.FtpStyleUriParser : UriParser {
}
public class System.Func`1 : MulticastDelegate {
    public Func`1(object object, IntPtr method);
    public virtual TResult Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`10 : MulticastDelegate {
    public Func`10(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`11 : MulticastDelegate {
    public Func`11(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`12 : MulticastDelegate {
    public Func`12(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`13 : MulticastDelegate {
    public Func`13(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`14 : MulticastDelegate {
    public Func`14(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`15 : MulticastDelegate {
    public Func`15(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`16 : MulticastDelegate {
    public Func`16(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`17 : MulticastDelegate {
    public Func`17(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`2 : MulticastDelegate {
    public Func`2(object object, IntPtr method);
    public virtual TResult Invoke(T arg);
    public virtual IAsyncResult BeginInvoke(T arg, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`3 : MulticastDelegate {
    public Func`3(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`4 : MulticastDelegate {
    public Func`4(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`5 : MulticastDelegate {
    public Func`5(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`6 : MulticastDelegate {
    public Func`6(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`7 : MulticastDelegate {
    public Func`7(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`8 : MulticastDelegate {
    public Func`8(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`9 : MulticastDelegate {
    public Func`9(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public static class System.GC : object {
    public static int MaxGeneration { get; }
    public static int get_MaxGeneration();
    [SecurityCriticalAttribute]
public static void AddMemoryPressure(long bytesAllocated);
    public static void CancelFullGCNotification();
    public static void Collect();
    public static void Collect(int generation);
    public static void Collect(int generation, GCCollectionMode mode);
    public static void Collect(int generation, GCCollectionMode mode, bool blocking);
    public static void Collect(int generation, GCCollectionMode mode, bool blocking, bool compacting);
    public static int CollectionCount(int generation);
    public static void EndNoGCRegion();
    public static int GetGeneration(object obj);
    public static int GetGeneration(WeakReference wo);
    public static long GetTotalMemory(bool forceFullCollection);
    public static void KeepAlive(object obj);
    public static void RegisterForFullGCNotification(int maxGenerationThreshold, int largeObjectHeapThreshold);
    [SecurityCriticalAttribute]
public static void RemoveMemoryPressure(long bytesAllocated);
    public static void ReRegisterForFinalize(object obj);
    public static void SuppressFinalize(object obj);
    public static bool TryStartNoGCRegion(long totalSize);
    public static bool TryStartNoGCRegion(long totalSize, bool disallowFullBlockingGC);
    public static bool TryStartNoGCRegion(long totalSize, long lohSize);
    public static bool TryStartNoGCRegion(long totalSize, long lohSize, bool disallowFullBlockingGC);
    public static GCNotificationStatus WaitForFullGCApproach();
    public static GCNotificationStatus WaitForFullGCApproach(int millisecondsTimeout);
    public static GCNotificationStatus WaitForFullGCComplete();
    public static GCNotificationStatus WaitForFullGCComplete(int millisecondsTimeout);
    public static void WaitForPendingFinalizers();
    public static long GetAllocatedBytesForCurrentThread();
}
public enum System.GCCollectionMode : Enum {
    public int value__;
    public static GCCollectionMode Default;
    public static GCCollectionMode Forced;
    public static GCCollectionMode Optimized;
}
public enum System.GCNotificationStatus : Enum {
    public int value__;
    public static GCNotificationStatus Canceled;
    public static GCNotificationStatus Failed;
    public static GCNotificationStatus NotApplicable;
    public static GCNotificationStatus Succeeded;
    public static GCNotificationStatus Timeout;
}
public class System.GenericUriParser : UriParser {
    public GenericUriParser(GenericUriParserOptions options);
}
[FlagsAttribute]
public enum System.GenericUriParserOptions : Enum {
    public int value__;
    public static GenericUriParserOptions AllowEmptyAuthority;
    public static GenericUriParserOptions Default;
    public static GenericUriParserOptions DontCompressPath;
    public static GenericUriParserOptions DontConvertPathBackslashes;
    public static GenericUriParserOptions DontUnescapePathDotsAndSlashes;
    public static GenericUriParserOptions GenericAuthority;
    public static GenericUriParserOptions Idn;
    public static GenericUriParserOptions IriParsing;
    public static GenericUriParserOptions NoFragment;
    public static GenericUriParserOptions NoPort;
    public static GenericUriParserOptions NoQuery;
    public static GenericUriParserOptions NoUserInfo;
}
public abstract class System.Globalization.Calendar : object {
    public static int CurrentEra;
    public CalendarAlgorithmType AlgorithmType { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    public Int32[] Eras { get; }
    public bool IsReadOnly { get; }
    public DateTime MaxSupportedDateTime { get; }
    public DateTime MinSupportedDateTime { get; }
    public int TwoDigitYearMax { get; public set; }
    public virtual CalendarAlgorithmType get_AlgorithmType();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    public abstract virtual Int32[] get_Eras();
    public bool get_IsReadOnly();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual DateTime AddDays(DateTime time, int days);
    public virtual DateTime AddHours(DateTime time, int hours);
    public virtual DateTime AddMilliseconds(DateTime time, double milliseconds);
    public virtual DateTime AddMinutes(DateTime time, int minutes);
    public abstract virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddSeconds(DateTime time, int seconds);
    public virtual DateTime AddWeeks(DateTime time, int weeks);
    public abstract virtual DateTime AddYears(DateTime time, int years);
    public virtual object Clone();
    public abstract virtual int GetDayOfMonth(DateTime time);
    public abstract virtual DayOfWeek GetDayOfWeek(DateTime time);
    public abstract virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month);
    public abstract virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year);
    public abstract virtual int GetDaysInYear(int year, int era);
    public abstract virtual int GetEra(DateTime time);
    public virtual int GetHour(DateTime time);
    public virtual int GetLeapMonth(int year);
    public virtual int GetLeapMonth(int year, int era);
    public virtual double GetMilliseconds(DateTime time);
    public virtual int GetMinute(DateTime time);
    public abstract virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year);
    public abstract virtual int GetMonthsInYear(int year, int era);
    public virtual int GetSecond(DateTime time);
    public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public abstract virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day);
    public abstract virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapMonth(int year, int month);
    public abstract virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year);
    public abstract virtual bool IsLeapYear(int year, int era);
    public static Calendar ReadOnly(Calendar calendar);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond);
    public abstract virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int ToFourDigitYear(int year);
}
public enum System.Globalization.CalendarAlgorithmType : Enum {
    public int value__;
    public static CalendarAlgorithmType LunarCalendar;
    public static CalendarAlgorithmType LunisolarCalendar;
    public static CalendarAlgorithmType SolarCalendar;
    public static CalendarAlgorithmType Unknown;
}
public enum System.Globalization.CalendarWeekRule : Enum {
    public int value__;
    public static CalendarWeekRule FirstDay;
    public static CalendarWeekRule FirstFourDayWeek;
    public static CalendarWeekRule FirstFullWeek;
}
public static class System.Globalization.CharUnicodeInfo : object {
    public static int GetDecimalDigitValue(char ch);
    public static int GetDecimalDigitValue(string s, int index);
    public static int GetDigitValue(char ch);
    public static int GetDigitValue(string s, int index);
    public static double GetNumericValue(char ch);
    public static double GetNumericValue(string s, int index);
    public static UnicodeCategory GetUnicodeCategory(char ch);
    public static UnicodeCategory GetUnicodeCategory(string s, int index);
}
public class System.Globalization.ChineseLunisolarCalendar : EastAsianLunisolarCalendar {
    public static int ChineseEra;
    public Int32[] Eras { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    public DateTime MaxSupportedDateTime { get; }
    public DateTime MinSupportedDateTime { get; }
    public virtual Int32[] get_Eras();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual int GetEra(DateTime time);
}
public class System.Globalization.CompareInfo : object {
    public int LCID { get; }
    public string Name { get; }
    public SortVersion Version { get; }
    public int get_LCID();
    public virtual string get_Name();
    public virtual int Compare(string string1, int offset1, int length1, string string2, int offset2, int length2);
    public virtual int Compare(string string1, int offset1, int length1, string string2, int offset2, int length2, CompareOptions options);
    public virtual int Compare(string string1, int offset1, string string2, int offset2);
    public virtual int Compare(string string1, int offset1, string string2, int offset2, CompareOptions options);
    public virtual int Compare(string string1, string string2);
    public virtual int Compare(string string1, string string2, CompareOptions options);
    public virtual bool Equals(object value);
    public static CompareInfo GetCompareInfo(int culture);
    public static CompareInfo GetCompareInfo(string name);
    public static CompareInfo GetCompareInfo(int culture, Assembly assembly);
    public static CompareInfo GetCompareInfo(string name, Assembly assembly);
    public virtual int GetHashCode();
    public virtual int GetHashCode(string source, CompareOptions options);
    public virtual SortKey GetSortKey(string source);
    public virtual SortKey GetSortKey(string source, CompareOptions options);
    public virtual int IndexOf(string source, char value);
    public virtual int IndexOf(string source, char value, CompareOptions options);
    public virtual int IndexOf(string source, char value, int startIndex);
    public virtual int IndexOf(string source, char value, int startIndex, CompareOptions options);
    public virtual int IndexOf(string source, char value, int startIndex, int count);
    public virtual int IndexOf(string source, char value, int startIndex, int count, CompareOptions options);
    public virtual int IndexOf(string source, string value);
    public virtual int IndexOf(string source, string value, CompareOptions options);
    public virtual int IndexOf(string source, string value, int startIndex);
    public virtual int IndexOf(string source, string value, int startIndex, CompareOptions options);
    public virtual int IndexOf(string source, string value, int startIndex, int count);
    public virtual int IndexOf(string source, string value, int startIndex, int count, CompareOptions options);
    public virtual bool IsPrefix(string source, string prefix);
    public virtual bool IsPrefix(string source, string prefix, CompareOptions options);
    public static bool IsSortable(char ch);
    public static bool IsSortable(string text);
    public virtual bool IsSuffix(string source, string suffix);
    public virtual bool IsSuffix(string source, string suffix, CompareOptions options);
    public virtual int LastIndexOf(string source, char value);
    public virtual int LastIndexOf(string source, char value, CompareOptions options);
    public virtual int LastIndexOf(string source, char value, int startIndex);
    public virtual int LastIndexOf(string source, char value, int startIndex, CompareOptions options);
    public virtual int LastIndexOf(string source, char value, int startIndex, int count);
    public virtual int LastIndexOf(string source, char value, int startIndex, int count, CompareOptions options);
    public virtual int LastIndexOf(string source, string value);
    public virtual int LastIndexOf(string source, string value, CompareOptions options);
    public virtual int LastIndexOf(string source, string value, int startIndex, CompareOptions options);
    public virtual int LastIndexOf(string source, string value, int startIndex);
    public virtual int LastIndexOf(string source, string value, int startIndex, int count);
    public virtual int LastIndexOf(string source, string value, int startIndex, int count, CompareOptions options);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    public virtual string ToString();
    public SortVersion get_Version();
}
[FlagsAttribute]
public enum System.Globalization.CompareOptions : Enum {
    public int value__;
    public static CompareOptions IgnoreCase;
    public static CompareOptions IgnoreKanaType;
    public static CompareOptions IgnoreNonSpace;
    public static CompareOptions IgnoreSymbols;
    public static CompareOptions IgnoreWidth;
    public static CompareOptions None;
    public static CompareOptions Ordinal;
    public static CompareOptions OrdinalIgnoreCase;
    public static CompareOptions StringSort;
}
public class System.Globalization.CultureInfo : object {
    public Calendar Calendar { get; }
    public CompareInfo CompareInfo { get; }
    public CultureTypes CultureTypes { get; }
    public static CultureInfo CurrentCulture { get; public set; }
    public static CultureInfo CurrentUICulture { get; public set; }
    public DateTimeFormatInfo DateTimeFormat { get; public set; }
    public static CultureInfo DefaultThreadCurrentCulture { get; public set; }
    public static CultureInfo DefaultThreadCurrentUICulture { get; public set; }
    public string DisplayName { get; }
    public string EnglishName { get; }
    public string IetfLanguageTag { get; }
    public static CultureInfo InstalledUICulture { get; }
    public static CultureInfo InvariantCulture { get; }
    public bool IsNeutralCulture { get; }
    public bool IsReadOnly { get; }
    public int KeyboardLayoutId { get; }
    public int LCID { get; }
    public string Name { get; }
    public string NativeName { get; }
    public NumberFormatInfo NumberFormat { get; public set; }
    public Calendar[] OptionalCalendars { get; }
    public CultureInfo Parent { get; }
    public TextInfo TextInfo { get; }
    public string ThreeLetterISOLanguageName { get; }
    public string ThreeLetterWindowsLanguageName { get; }
    public string TwoLetterISOLanguageName { get; }
    public bool UseUserOverride { get; }
    public CultureInfo(int culture);
    public CultureInfo(int culture, bool useUserOverride);
    public CultureInfo(string name);
    public CultureInfo(string name, bool useUserOverride);
    public virtual Calendar get_Calendar();
    public virtual CompareInfo get_CompareInfo();
    public CultureTypes get_CultureTypes();
    public static CultureInfo get_CurrentCulture();
    public static void set_CurrentCulture(CultureInfo value);
    public static CultureInfo get_CurrentUICulture();
    public static void set_CurrentUICulture(CultureInfo value);
    public virtual DateTimeFormatInfo get_DateTimeFormat();
    public virtual void set_DateTimeFormat(DateTimeFormatInfo value);
    public static CultureInfo get_DefaultThreadCurrentCulture();
    public static void set_DefaultThreadCurrentCulture(CultureInfo value);
    public static CultureInfo get_DefaultThreadCurrentUICulture();
    public static void set_DefaultThreadCurrentUICulture(CultureInfo value);
    public virtual string get_DisplayName();
    public virtual string get_EnglishName();
    public string get_IetfLanguageTag();
    public static CultureInfo get_InstalledUICulture();
    public static CultureInfo get_InvariantCulture();
    public virtual bool get_IsNeutralCulture();
    public bool get_IsReadOnly();
    public virtual int get_KeyboardLayoutId();
    public virtual int get_LCID();
    public virtual string get_Name();
    public virtual string get_NativeName();
    public virtual NumberFormatInfo get_NumberFormat();
    public virtual void set_NumberFormat(NumberFormatInfo value);
    public virtual Calendar[] get_OptionalCalendars();
    public virtual CultureInfo get_Parent();
    public virtual TextInfo get_TextInfo();
    public virtual string get_ThreeLetterISOLanguageName();
    public virtual string get_ThreeLetterWindowsLanguageName();
    public virtual string get_TwoLetterISOLanguageName();
    public bool get_UseUserOverride();
    public void ClearCachedData();
    public virtual object Clone();
    public static CultureInfo CreateSpecificCulture(string name);
    public virtual bool Equals(object value);
    public CultureInfo GetConsoleFallbackUICulture();
    public static CultureInfo GetCultureInfo(int culture);
    public static CultureInfo GetCultureInfo(string name);
    public static CultureInfo GetCultureInfo(string name, string altName);
    public static CultureInfo GetCultureInfoByIetfLanguageTag(string name);
    public static CultureInfo[] GetCultures(CultureTypes types);
    public virtual object GetFormat(Type formatType);
    public virtual int GetHashCode();
    public static CultureInfo ReadOnly(CultureInfo ci);
    public virtual string ToString();
}
public class System.Globalization.CultureNotFoundException : ArgumentException {
    public Nullable`1<int> InvalidCultureId { get; }
    public string InvalidCultureName { get; }
    public string Message { get; }
    public CultureNotFoundException(string message);
    public CultureNotFoundException(string message, Exception innerException);
    public CultureNotFoundException(string message, int invalidCultureId, Exception innerException);
    public CultureNotFoundException(string paramName, int invalidCultureId, string message);
    public CultureNotFoundException(string paramName, string message);
    public CultureNotFoundException(string message, string invalidCultureName, Exception innerException);
    public CultureNotFoundException(string paramName, string invalidCultureName, string message);
    protected CultureNotFoundException(SerializationInfo info, StreamingContext context);
    public virtual Nullable`1<int> get_InvalidCultureId();
    public virtual string get_InvalidCultureName();
    public virtual string get_Message();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[FlagsAttribute]
public enum System.Globalization.CultureTypes : Enum {
    public int value__;
    public static CultureTypes AllCultures;
    [ObsoleteAttribute("This value has been deprecated.  Please use other values in CultureTypes.")]
public static CultureTypes FrameworkCultures;
    public static CultureTypes InstalledWin32Cultures;
    public static CultureTypes NeutralCultures;
    public static CultureTypes ReplacementCultures;
    public static CultureTypes SpecificCultures;
    public static CultureTypes UserCustomCulture;
    [ObsoleteAttribute("This value has been deprecated.  Please use other values in CultureTypes.")]
public static CultureTypes WindowsOnlyCultures;
}
public class System.Globalization.DateTimeFormatInfo : object {
    public String[] AbbreviatedDayNames { get; public set; }
    public String[] AbbreviatedMonthGenitiveNames { get; public set; }
    public String[] AbbreviatedMonthNames { get; public set; }
    public string AMDesignator { get; public set; }
    public Calendar Calendar { get; public set; }
    public CalendarWeekRule CalendarWeekRule { get; public set; }
    public static DateTimeFormatInfo CurrentInfo { get; }
    public string DateSeparator { get; public set; }
    public String[] DayNames { get; public set; }
    public DayOfWeek FirstDayOfWeek { get; public set; }
    public string FullDateTimePattern { get; public set; }
    public static DateTimeFormatInfo InvariantInfo { get; }
    public bool IsReadOnly { get; }
    public string LongDatePattern { get; public set; }
    public string LongTimePattern { get; public set; }
    public string MonthDayPattern { get; public set; }
    public String[] MonthGenitiveNames { get; public set; }
    public String[] MonthNames { get; public set; }
    public string NativeCalendarName { get; }
    public string PMDesignator { get; public set; }
    public string RFC1123Pattern { get; }
    public string ShortDatePattern { get; public set; }
    public String[] ShortestDayNames { get; public set; }
    public string ShortTimePattern { get; public set; }
    public string SortableDateTimePattern { get; }
    public string TimeSeparator { get; public set; }
    public string UniversalSortableDateTimePattern { get; }
    public string YearMonthPattern { get; public set; }
    public String[] get_AbbreviatedDayNames();
    public void set_AbbreviatedDayNames(String[] value);
    public String[] get_AbbreviatedMonthGenitiveNames();
    public void set_AbbreviatedMonthGenitiveNames(String[] value);
    public String[] get_AbbreviatedMonthNames();
    public void set_AbbreviatedMonthNames(String[] value);
    public string get_AMDesignator();
    public void set_AMDesignator(string value);
    public Calendar get_Calendar();
    public void set_Calendar(Calendar value);
    public CalendarWeekRule get_CalendarWeekRule();
    public void set_CalendarWeekRule(CalendarWeekRule value);
    public static DateTimeFormatInfo get_CurrentInfo();
    public string get_DateSeparator();
    public void set_DateSeparator(string value);
    public String[] get_DayNames();
    public void set_DayNames(String[] value);
    public DayOfWeek get_FirstDayOfWeek();
    public void set_FirstDayOfWeek(DayOfWeek value);
    public string get_FullDateTimePattern();
    public void set_FullDateTimePattern(string value);
    public static DateTimeFormatInfo get_InvariantInfo();
    public bool get_IsReadOnly();
    public string get_LongDatePattern();
    public void set_LongDatePattern(string value);
    public string get_LongTimePattern();
    public void set_LongTimePattern(string value);
    public string get_MonthDayPattern();
    public void set_MonthDayPattern(string value);
    public String[] get_MonthGenitiveNames();
    public void set_MonthGenitiveNames(String[] value);
    public String[] get_MonthNames();
    public void set_MonthNames(String[] value);
    public string get_NativeCalendarName();
    public string get_PMDesignator();
    public void set_PMDesignator(string value);
    public string get_RFC1123Pattern();
    public string get_ShortDatePattern();
    public void set_ShortDatePattern(string value);
    public String[] get_ShortestDayNames();
    public void set_ShortestDayNames(String[] value);
    public string get_ShortTimePattern();
    public void set_ShortTimePattern(string value);
    public string get_SortableDateTimePattern();
    public string get_TimeSeparator();
    public void set_TimeSeparator(string value);
    public string get_UniversalSortableDateTimePattern();
    public string get_YearMonthPattern();
    public void set_YearMonthPattern(string value);
    public sealed virtual object Clone();
    public string GetAbbreviatedDayName(DayOfWeek dayofweek);
    public string GetAbbreviatedEraName(int era);
    public string GetAbbreviatedMonthName(int month);
    public String[] GetAllDateTimePatterns();
    public String[] GetAllDateTimePatterns(char format);
    public string GetDayName(DayOfWeek dayofweek);
    public int GetEra(string eraName);
    public string GetEraName(int era);
    public sealed virtual object GetFormat(Type formatType);
    public static DateTimeFormatInfo GetInstance(IFormatProvider provider);
    public string GetMonthName(int month);
    public string GetShortestDayName(DayOfWeek dayOfWeek);
    public static DateTimeFormatInfo ReadOnly(DateTimeFormatInfo dtfi);
    public void SetAllDateTimePatterns(String[] patterns, char format);
}
[FlagsAttribute]
public enum System.Globalization.DateTimeStyles : Enum {
    public int value__;
    public static DateTimeStyles AdjustToUniversal;
    public static DateTimeStyles AllowInnerWhite;
    public static DateTimeStyles AllowLeadingWhite;
    public static DateTimeStyles AllowTrailingWhite;
    public static DateTimeStyles AllowWhiteSpaces;
    public static DateTimeStyles AssumeLocal;
    public static DateTimeStyles AssumeUniversal;
    public static DateTimeStyles NoCurrentDateDefault;
    public static DateTimeStyles None;
    public static DateTimeStyles RoundtripKind;
}
public class System.Globalization.DaylightTime : object {
    public TimeSpan Delta { get; }
    public DateTime End { get; }
    public DateTime Start { get; }
    public DaylightTime(DateTime start, DateTime end, TimeSpan delta);
    public TimeSpan get_Delta();
    public DateTime get_End();
    public DateTime get_Start();
}
public enum System.Globalization.DigitShapes : Enum {
    public int value__;
    public static DigitShapes Context;
    public static DigitShapes NativeNational;
    public static DigitShapes None;
}
public abstract class System.Globalization.EastAsianLunisolarCalendar : Calendar {
    public CalendarAlgorithmType AlgorithmType { get; }
    public int TwoDigitYearMax { get; public set; }
    public virtual CalendarAlgorithmType get_AlgorithmType();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public int GetCelestialStem(int sexagenaryYear);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetSexagenaryYear(DateTime time);
    public int GetTerrestrialBranch(int sexagenaryYear);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int ToFourDigitYear(int year);
}
public class System.Globalization.GregorianCalendar : Calendar {
    public static int ADEra;
    public CalendarAlgorithmType AlgorithmType { get; }
    public GregorianCalendarTypes CalendarType { get; public set; }
    public Int32[] Eras { get; }
    public DateTime MaxSupportedDateTime { get; }
    public DateTime MinSupportedDateTime { get; }
    public int TwoDigitYearMax { get; public set; }
    public GregorianCalendar(GregorianCalendarTypes type);
    public virtual CalendarAlgorithmType get_AlgorithmType();
    public virtual GregorianCalendarTypes get_CalendarType();
    public virtual void set_CalendarType(GregorianCalendarTypes value);
    public virtual Int32[] get_Eras();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual int GetLeapMonth(int year, int era);
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int ToFourDigitYear(int year);
}
public enum System.Globalization.GregorianCalendarTypes : Enum {
    public int value__;
    public static GregorianCalendarTypes Arabic;
    public static GregorianCalendarTypes Localized;
    public static GregorianCalendarTypes MiddleEastFrench;
    public static GregorianCalendarTypes TransliteratedEnglish;
    public static GregorianCalendarTypes TransliteratedFrench;
    public static GregorianCalendarTypes USEnglish;
}
public class System.Globalization.HebrewCalendar : Calendar {
    public static int HebrewEra;
    public CalendarAlgorithmType AlgorithmType { get; }
    public Int32[] Eras { get; }
    public DateTime MaxSupportedDateTime { get; }
    public DateTime MinSupportedDateTime { get; }
    public int TwoDigitYearMax { get; public set; }
    public virtual CalendarAlgorithmType get_AlgorithmType();
    public virtual Int32[] get_Eras();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual int GetLeapMonth(int year, int era);
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int ToFourDigitYear(int year);
}
public class System.Globalization.HijriCalendar : Calendar {
    public static int HijriEra;
    public CalendarAlgorithmType AlgorithmType { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    public Int32[] Eras { get; }
    public int HijriAdjustment { get; public set; }
    public DateTime MaxSupportedDateTime { get; }
    public DateTime MinSupportedDateTime { get; }
    public int TwoDigitYearMax { get; public set; }
    public virtual CalendarAlgorithmType get_AlgorithmType();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    public virtual Int32[] get_Eras();
    public int get_HijriAdjustment();
    public void set_HijriAdjustment(int value);
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual int GetLeapMonth(int year, int era);
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int ToFourDigitYear(int year);
}
public class System.Globalization.IdnMapping : object {
    public bool AllowUnassigned { get; public set; }
    public bool UseStd3AsciiRules { get; public set; }
    public bool get_AllowUnassigned();
    public void set_AllowUnassigned(bool value);
    public bool get_UseStd3AsciiRules();
    public void set_UseStd3AsciiRules(bool value);
    public virtual bool Equals(object obj);
    public string GetAscii(string unicode);
    public string GetAscii(string unicode, int index);
    public string GetAscii(string unicode, int index, int count);
    public virtual int GetHashCode();
    public string GetUnicode(string ascii);
    public string GetUnicode(string ascii, int index);
    public string GetUnicode(string ascii, int index, int count);
}
public class System.Globalization.JapaneseCalendar : Calendar {
    public CalendarAlgorithmType AlgorithmType { get; }
    public Int32[] Eras { get; }
    public DateTime MaxSupportedDateTime { get; }
    public DateTime MinSupportedDateTime { get; }
    public int TwoDigitYearMax { get; public set; }
    public virtual CalendarAlgorithmType get_AlgorithmType();
    public virtual Int32[] get_Eras();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual int GetLeapMonth(int year, int era);
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int ToFourDigitYear(int year);
}
public class System.Globalization.JapaneseLunisolarCalendar : EastAsianLunisolarCalendar {
    public static int JapaneseEra;
    protected int DaysInYearBeforeMinSupportedYear { get; }
    public Int32[] Eras { get; }
    public DateTime MaxSupportedDateTime { get; }
    public DateTime MinSupportedDateTime { get; }
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    public virtual Int32[] get_Eras();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual int GetEra(DateTime time);
}
public class System.Globalization.JulianCalendar : Calendar {
    public static int JulianEra;
    public CalendarAlgorithmType AlgorithmType { get; }
    public Int32[] Eras { get; }
    public DateTime MaxSupportedDateTime { get; }
    public DateTime MinSupportedDateTime { get; }
    public int TwoDigitYearMax { get; public set; }
    public virtual CalendarAlgorithmType get_AlgorithmType();
    public virtual Int32[] get_Eras();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual int GetLeapMonth(int year, int era);
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int ToFourDigitYear(int year);
}
public class System.Globalization.KoreanCalendar : Calendar {
    public static int KoreanEra;
    public CalendarAlgorithmType AlgorithmType { get; }
    public Int32[] Eras { get; }
    public DateTime MaxSupportedDateTime { get; }
    public DateTime MinSupportedDateTime { get; }
    public int TwoDigitYearMax { get; public set; }
    public virtual CalendarAlgorithmType get_AlgorithmType();
    public virtual Int32[] get_Eras();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual int GetLeapMonth(int year, int era);
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int ToFourDigitYear(int year);
}
public class System.Globalization.KoreanLunisolarCalendar : EastAsianLunisolarCalendar {
    public static int GregorianEra;
    protected int DaysInYearBeforeMinSupportedYear { get; }
    public Int32[] Eras { get; }
    public DateTime MaxSupportedDateTime { get; }
    public DateTime MinSupportedDateTime { get; }
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    public virtual Int32[] get_Eras();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual int GetEra(DateTime time);
}
public class System.Globalization.NumberFormatInfo : object {
    public int CurrencyDecimalDigits { get; public set; }
    public string CurrencyDecimalSeparator { get; public set; }
    public string CurrencyGroupSeparator { get; public set; }
    public Int32[] CurrencyGroupSizes { get; public set; }
    public int CurrencyNegativePattern { get; public set; }
    public int CurrencyPositivePattern { get; public set; }
    public string CurrencySymbol { get; public set; }
    public static NumberFormatInfo CurrentInfo { get; }
    public DigitShapes DigitSubstitution { get; public set; }
    public static NumberFormatInfo InvariantInfo { get; }
    public bool IsReadOnly { get; }
    public string NaNSymbol { get; public set; }
    public String[] NativeDigits { get; public set; }
    public string NegativeInfinitySymbol { get; public set; }
    public string NegativeSign { get; public set; }
    public int NumberDecimalDigits { get; public set; }
    public string NumberDecimalSeparator { get; public set; }
    public string NumberGroupSeparator { get; public set; }
    public Int32[] NumberGroupSizes { get; public set; }
    public int NumberNegativePattern { get; public set; }
    public int PercentDecimalDigits { get; public set; }
    public string PercentDecimalSeparator { get; public set; }
    public string PercentGroupSeparator { get; public set; }
    public Int32[] PercentGroupSizes { get; public set; }
    public int PercentNegativePattern { get; public set; }
    public int PercentPositivePattern { get; public set; }
    public string PercentSymbol { get; public set; }
    public string PerMilleSymbol { get; public set; }
    public string PositiveInfinitySymbol { get; public set; }
    public string PositiveSign { get; public set; }
    public int get_CurrencyDecimalDigits();
    public void set_CurrencyDecimalDigits(int value);
    public string get_CurrencyDecimalSeparator();
    public void set_CurrencyDecimalSeparator(string value);
    public string get_CurrencyGroupSeparator();
    public void set_CurrencyGroupSeparator(string value);
    public Int32[] get_CurrencyGroupSizes();
    public void set_CurrencyGroupSizes(Int32[] value);
    public int get_CurrencyNegativePattern();
    public void set_CurrencyNegativePattern(int value);
    public int get_CurrencyPositivePattern();
    public void set_CurrencyPositivePattern(int value);
    public string get_CurrencySymbol();
    public void set_CurrencySymbol(string value);
    public static NumberFormatInfo get_CurrentInfo();
    public DigitShapes get_DigitSubstitution();
    public void set_DigitSubstitution(DigitShapes value);
    public static NumberFormatInfo get_InvariantInfo();
    public bool get_IsReadOnly();
    public string get_NaNSymbol();
    public void set_NaNSymbol(string value);
    public String[] get_NativeDigits();
    public void set_NativeDigits(String[] value);
    public string get_NegativeInfinitySymbol();
    public void set_NegativeInfinitySymbol(string value);
    public string get_NegativeSign();
    public void set_NegativeSign(string value);
    public int get_NumberDecimalDigits();
    public void set_NumberDecimalDigits(int value);
    public string get_NumberDecimalSeparator();
    public void set_NumberDecimalSeparator(string value);
    public string get_NumberGroupSeparator();
    public void set_NumberGroupSeparator(string value);
    public Int32[] get_NumberGroupSizes();
    public void set_NumberGroupSizes(Int32[] value);
    public int get_NumberNegativePattern();
    public void set_NumberNegativePattern(int value);
    public int get_PercentDecimalDigits();
    public void set_PercentDecimalDigits(int value);
    public string get_PercentDecimalSeparator();
    public void set_PercentDecimalSeparator(string value);
    public string get_PercentGroupSeparator();
    public void set_PercentGroupSeparator(string value);
    public Int32[] get_PercentGroupSizes();
    public void set_PercentGroupSizes(Int32[] value);
    public int get_PercentNegativePattern();
    public void set_PercentNegativePattern(int value);
    public int get_PercentPositivePattern();
    public void set_PercentPositivePattern(int value);
    public string get_PercentSymbol();
    public void set_PercentSymbol(string value);
    public string get_PerMilleSymbol();
    public void set_PerMilleSymbol(string value);
    public string get_PositiveInfinitySymbol();
    public void set_PositiveInfinitySymbol(string value);
    public string get_PositiveSign();
    public void set_PositiveSign(string value);
    public sealed virtual object Clone();
    public sealed virtual object GetFormat(Type formatType);
    public static NumberFormatInfo GetInstance(IFormatProvider formatProvider);
    public static NumberFormatInfo ReadOnly(NumberFormatInfo nfi);
}
[FlagsAttribute]
public enum System.Globalization.NumberStyles : Enum {
    public int value__;
    public static NumberStyles AllowCurrencySymbol;
    public static NumberStyles AllowDecimalPoint;
    public static NumberStyles AllowExponent;
    public static NumberStyles AllowHexSpecifier;
    public static NumberStyles AllowLeadingSign;
    public static NumberStyles AllowLeadingWhite;
    public static NumberStyles AllowParentheses;
    public static NumberStyles AllowThousands;
    public static NumberStyles AllowTrailingSign;
    public static NumberStyles AllowTrailingWhite;
    public static NumberStyles Any;
    public static NumberStyles Currency;
    public static NumberStyles Float;
    public static NumberStyles HexNumber;
    public static NumberStyles Integer;
    public static NumberStyles None;
    public static NumberStyles Number;
}
public class System.Globalization.PersianCalendar : Calendar {
    public static int PersianEra;
    public CalendarAlgorithmType AlgorithmType { get; }
    public Int32[] Eras { get; }
    public DateTime MaxSupportedDateTime { get; }
    public DateTime MinSupportedDateTime { get; }
    public int TwoDigitYearMax { get; public set; }
    public virtual CalendarAlgorithmType get_AlgorithmType();
    public virtual Int32[] get_Eras();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual int GetLeapMonth(int year, int era);
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int ToFourDigitYear(int year);
}
public class System.Globalization.RegionInfo : object {
    public string CurrencyEnglishName { get; }
    public string CurrencyNativeName { get; }
    public string CurrencySymbol { get; }
    public static RegionInfo CurrentRegion { get; }
    public string DisplayName { get; }
    public string EnglishName { get; }
    public int GeoId { get; }
    public bool IsMetric { get; }
    public string ISOCurrencySymbol { get; }
    public string Name { get; }
    public string NativeName { get; }
    public string ThreeLetterISORegionName { get; }
    public string ThreeLetterWindowsRegionName { get; }
    public string TwoLetterISORegionName { get; }
    public RegionInfo(int culture);
    public RegionInfo(string name);
    public virtual string get_CurrencyEnglishName();
    public virtual string get_CurrencyNativeName();
    public virtual string get_CurrencySymbol();
    public static RegionInfo get_CurrentRegion();
    public virtual string get_DisplayName();
    public virtual string get_EnglishName();
    public virtual int get_GeoId();
    public virtual bool get_IsMetric();
    public virtual string get_ISOCurrencySymbol();
    public virtual string get_Name();
    public virtual string get_NativeName();
    public virtual string get_ThreeLetterISORegionName();
    public virtual string get_ThreeLetterWindowsRegionName();
    public virtual string get_TwoLetterISORegionName();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class System.Globalization.SortKey : object {
    public Byte[] KeyData { get; }
    public string OriginalString { get; }
    public virtual Byte[] get_KeyData();
    public virtual string get_OriginalString();
    public static int Compare(SortKey sortkey1, SortKey sortkey2);
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class System.Globalization.SortVersion : object {
    public int FullVersion { get; }
    public Guid SortId { get; }
    public SortVersion(int fullVersion, Guid sortId);
    public int get_FullVersion();
    public Guid get_SortId();
    public sealed virtual bool Equals(SortVersion other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(SortVersion left, SortVersion right);
    public static bool op_Inequality(SortVersion left, SortVersion right);
}
public class System.Globalization.StringInfo : object {
    public int LengthInTextElements { get; }
    public string String { get; public set; }
    public StringInfo(string value);
    public int get_LengthInTextElements();
    public string get_String();
    public void set_String(string value);
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public static string GetNextTextElement(string str);
    public static string GetNextTextElement(string str, int index);
    public static TextElementEnumerator GetTextElementEnumerator(string str);
    public static TextElementEnumerator GetTextElementEnumerator(string str, int index);
    public static Int32[] ParseCombiningCharacters(string str);
    public string SubstringByTextElements(int startingTextElement);
    public string SubstringByTextElements(int startingTextElement, int lengthInTextElements);
}
public class System.Globalization.TaiwanCalendar : Calendar {
    public CalendarAlgorithmType AlgorithmType { get; }
    public Int32[] Eras { get; }
    public DateTime MaxSupportedDateTime { get; }
    public DateTime MinSupportedDateTime { get; }
    public int TwoDigitYearMax { get; public set; }
    public virtual CalendarAlgorithmType get_AlgorithmType();
    public virtual Int32[] get_Eras();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual int GetLeapMonth(int year, int era);
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int ToFourDigitYear(int year);
}
public class System.Globalization.TaiwanLunisolarCalendar : EastAsianLunisolarCalendar {
    protected int DaysInYearBeforeMinSupportedYear { get; }
    public Int32[] Eras { get; }
    public DateTime MaxSupportedDateTime { get; }
    public DateTime MinSupportedDateTime { get; }
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    public virtual Int32[] get_Eras();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual int GetEra(DateTime time);
}
public class System.Globalization.TextElementEnumerator : object {
    public object Current { get; }
    public int ElementIndex { get; }
    public sealed virtual object get_Current();
    public int get_ElementIndex();
    public string GetTextElement();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
public class System.Globalization.TextInfo : object {
    public int ANSICodePage { get; }
    public string CultureName { get; }
    public int EBCDICCodePage { get; }
    public bool IsReadOnly { get; }
    public bool IsRightToLeft { get; }
    public int LCID { get; }
    public string ListSeparator { get; public set; }
    public int MacCodePage { get; }
    public int OEMCodePage { get; }
    public virtual int get_ANSICodePage();
    public string get_CultureName();
    public virtual int get_EBCDICCodePage();
    public bool get_IsReadOnly();
    public bool get_IsRightToLeft();
    public int get_LCID();
    public virtual string get_ListSeparator();
    public virtual void set_ListSeparator(string value);
    public virtual int get_MacCodePage();
    public virtual int get_OEMCodePage();
    public virtual object Clone();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static TextInfo ReadOnly(TextInfo textInfo);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    public virtual char ToLower(char c);
    public virtual string ToLower(string str);
    public virtual string ToString();
    public string ToTitleCase(string str);
    public virtual char ToUpper(char c);
    public virtual string ToUpper(string str);
}
public class System.Globalization.ThaiBuddhistCalendar : Calendar {
    public static int ThaiBuddhistEra;
    public CalendarAlgorithmType AlgorithmType { get; }
    public Int32[] Eras { get; }
    public DateTime MaxSupportedDateTime { get; }
    public DateTime MinSupportedDateTime { get; }
    public int TwoDigitYearMax { get; public set; }
    public virtual CalendarAlgorithmType get_AlgorithmType();
    public virtual Int32[] get_Eras();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual int GetLeapMonth(int year, int era);
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int ToFourDigitYear(int year);
}
[FlagsAttribute]
public enum System.Globalization.TimeSpanStyles : Enum {
    public int value__;
    public static TimeSpanStyles AssumeNegative;
    public static TimeSpanStyles None;
}
public class System.Globalization.UmAlQuraCalendar : Calendar {
    public static int UmAlQuraEra;
    public CalendarAlgorithmType AlgorithmType { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    public Int32[] Eras { get; }
    public DateTime MaxSupportedDateTime { get; }
    public DateTime MinSupportedDateTime { get; }
    public int TwoDigitYearMax { get; public set; }
    public virtual CalendarAlgorithmType get_AlgorithmType();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    public virtual Int32[] get_Eras();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual int GetLeapMonth(int year, int era);
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int ToFourDigitYear(int year);
}
public enum System.Globalization.UnicodeCategory : Enum {
    public int value__;
    public static UnicodeCategory ClosePunctuation;
    public static UnicodeCategory ConnectorPunctuation;
    public static UnicodeCategory Control;
    public static UnicodeCategory CurrencySymbol;
    public static UnicodeCategory DashPunctuation;
    public static UnicodeCategory DecimalDigitNumber;
    public static UnicodeCategory EnclosingMark;
    public static UnicodeCategory FinalQuotePunctuation;
    public static UnicodeCategory Format;
    public static UnicodeCategory InitialQuotePunctuation;
    public static UnicodeCategory LetterNumber;
    public static UnicodeCategory LineSeparator;
    public static UnicodeCategory LowercaseLetter;
    public static UnicodeCategory MathSymbol;
    public static UnicodeCategory ModifierLetter;
    public static UnicodeCategory ModifierSymbol;
    public static UnicodeCategory NonSpacingMark;
    public static UnicodeCategory OpenPunctuation;
    public static UnicodeCategory OtherLetter;
    public static UnicodeCategory OtherNotAssigned;
    public static UnicodeCategory OtherNumber;
    public static UnicodeCategory OtherPunctuation;
    public static UnicodeCategory OtherSymbol;
    public static UnicodeCategory ParagraphSeparator;
    public static UnicodeCategory PrivateUse;
    public static UnicodeCategory SpaceSeparator;
    public static UnicodeCategory SpacingCombiningMark;
    public static UnicodeCategory Surrogate;
    public static UnicodeCategory TitlecaseLetter;
    public static UnicodeCategory UppercaseLetter;
}
public class System.GopherStyleUriParser : UriParser {
}
public class System.Guid : ValueType {
    public static Guid Empty;
    public Guid(Byte[] b);
    public Guid(int a, short b, short c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k);
    public Guid(int a, short b, short c, Byte[] d);
    public Guid(string g);
    [CLSCompliantAttribute("False")]
public Guid(UInt32 a, ushort b, ushort c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(Guid value);
    public sealed virtual bool Equals(Guid g);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public static Guid NewGuid();
    public static bool op_Equality(Guid a, Guid b);
    public static bool op_Inequality(Guid a, Guid b);
    public static Guid Parse(string input);
    public static Guid ParseExact(string input, string format);
    public Byte[] ToByteArray();
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public static bool TryParse(string input, Guid& result);
    public static bool TryParseExact(string input, string format, Guid& result);
}
public class System.HttpStyleUriParser : UriParser {
}
public interface System.IAsyncResult {
    public object AsyncState { get; }
    public WaitHandle AsyncWaitHandle { get; }
    public bool CompletedSynchronously { get; }
    public bool IsCompleted { get; }
    public abstract virtual object get_AsyncState();
    public abstract virtual WaitHandle get_AsyncWaitHandle();
    public abstract virtual bool get_CompletedSynchronously();
    public abstract virtual bool get_IsCompleted();
}
public interface System.ICloneable {
    public abstract virtual object Clone();
}
public interface System.IComparable {
    public abstract virtual int CompareTo(object obj);
}
public interface System.IComparable`1 {
    public abstract virtual int CompareTo(T other);
}
[CLSCompliantAttribute("False")]
public interface System.IConvertible {
    public abstract virtual TypeCode GetTypeCode();
    public abstract virtual bool ToBoolean(IFormatProvider provider);
    public abstract virtual byte ToByte(IFormatProvider provider);
    public abstract virtual char ToChar(IFormatProvider provider);
    public abstract virtual DateTime ToDateTime(IFormatProvider provider);
    public abstract virtual decimal ToDecimal(IFormatProvider provider);
    public abstract virtual double ToDouble(IFormatProvider provider);
    public abstract virtual short ToInt16(IFormatProvider provider);
    public abstract virtual int ToInt32(IFormatProvider provider);
    public abstract virtual long ToInt64(IFormatProvider provider);
    public abstract virtual sbyte ToSByte(IFormatProvider provider);
    public abstract virtual float ToSingle(IFormatProvider provider);
    public abstract virtual string ToString(IFormatProvider provider);
    public abstract virtual object ToType(Type conversionType, IFormatProvider provider);
    public abstract virtual ushort ToUInt16(IFormatProvider provider);
    public abstract virtual UInt32 ToUInt32(IFormatProvider provider);
    public abstract virtual ulong ToUInt64(IFormatProvider provider);
}
public interface System.ICustomFormatter {
    public abstract virtual string Format(string format, object arg, IFormatProvider formatProvider);
}
public interface System.IDisposable {
    public abstract virtual void Dispose();
}
public interface System.IEquatable`1 {
    public abstract virtual bool Equals(T other);
}
public interface System.IFormatProvider {
    public abstract virtual object GetFormat(Type formatType);
}
public interface System.IFormattable {
    public abstract virtual string ToString(string format, IFormatProvider formatProvider);
}
public class System.IndexOutOfRangeException : SystemException {
    public IndexOutOfRangeException(string message);
    public IndexOutOfRangeException(string message, Exception innerException);
}
public class System.InsufficientExecutionStackException : SystemException {
    public InsufficientExecutionStackException(string message);
    public InsufficientExecutionStackException(string message, Exception innerException);
}
public class System.InsufficientMemoryException : OutOfMemoryException {
    public InsufficientMemoryException(string message);
    public InsufficientMemoryException(string message, Exception innerException);
}
public class System.Int16 : ValueType {
    public static short MaxValue;
    public static short MinValue;
    public sealed virtual int CompareTo(short value);
    public sealed virtual bool Equals(short obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static short Parse(string s);
    public static short Parse(string s, NumberStyles style);
    public static short Parse(string s, NumberStyles style, IFormatProvider provider);
    public static short Parse(string s, IFormatProvider provider);
    public sealed virtual int CompareTo(object value);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Int16& result);
    public static bool TryParse(string s, Int16& result);
}
public class System.Int32 : ValueType {
    public static int MaxValue;
    public static int MinValue;
    public sealed virtual int CompareTo(int value);
    public sealed virtual bool Equals(int obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static int Parse(string s);
    public static int Parse(string s, NumberStyles style);
    public static int Parse(string s, NumberStyles style, IFormatProvider provider);
    public static int Parse(string s, IFormatProvider provider);
    public sealed virtual int CompareTo(object value);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Int32& result);
    public static bool TryParse(string s, Int32& result);
}
public class System.Int64 : ValueType {
    public static long MaxValue;
    public static long MinValue;
    public sealed virtual int CompareTo(long value);
    public sealed virtual bool Equals(long obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static long Parse(string s);
    public static long Parse(string s, NumberStyles style);
    public static long Parse(string s, NumberStyles style, IFormatProvider provider);
    public static long Parse(string s, IFormatProvider provider);
    public sealed virtual int CompareTo(object value);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Int64& result);
    public static bool TryParse(string s, Int64& result);
}
public class System.IntPtr : ValueType {
    public static IntPtr Zero;
    public static int Size { get; }
    public IntPtr(int value);
    public IntPtr(long value);
    [CLSCompliantAttribute("False")]
[SecurityCriticalAttribute]
public IntPtr(Void* value);
    public static int get_Size();
    public static IntPtr Add(IntPtr pointer, int offset);
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.IEquatable<System.IntPtr>.Equals(IntPtr other);
    public virtual int GetHashCode();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public static IntPtr op_Addition(IntPtr pointer, int offset);
    public static bool op_Equality(IntPtr value1, IntPtr value2);
    public static IntPtr op_Explicit(int value);
    public static IntPtr op_Explicit(long value);
    public static int op_Explicit(IntPtr value);
    public static long op_Explicit(IntPtr value);
    [CLSCompliantAttribute("False")]
public static Void* op_Explicit(IntPtr value);
    [CLSCompliantAttribute("False")]
[SecurityCriticalAttribute]
public static IntPtr op_Explicit(Void* value);
    public static bool op_Inequality(IntPtr value1, IntPtr value2);
    public static IntPtr op_Subtraction(IntPtr pointer, int offset);
    public static IntPtr Subtract(IntPtr pointer, int offset);
    public int ToInt32();
    public long ToInt64();
    [CLSCompliantAttribute("False")]
public Void* ToPointer();
    public virtual string ToString();
    public string ToString(string format);
}
public class System.InvalidCastException : SystemException {
    public InvalidCastException(string message);
    public InvalidCastException(string message, Exception innerException);
    public InvalidCastException(string message, int errorCode);
    protected InvalidCastException(SerializationInfo info, StreamingContext context);
}
public class System.InvalidOperationException : SystemException {
    public InvalidOperationException(string message);
    public InvalidOperationException(string message, Exception innerException);
    protected InvalidOperationException(SerializationInfo info, StreamingContext context);
}
public class System.InvalidProgramException : SystemException {
    public InvalidProgramException(string message);
    public InvalidProgramException(string message, Exception inner);
}
public class System.InvalidTimeZoneException : Exception {
    public InvalidTimeZoneException(string message);
    public InvalidTimeZoneException(string message, Exception innerException);
    protected InvalidTimeZoneException(SerializationInfo info, StreamingContext context);
}
public class System.IO.DirectoryNotFoundException : IOException {
    public DirectoryNotFoundException(string message);
    public DirectoryNotFoundException(string message, Exception innerException);
    protected DirectoryNotFoundException(SerializationInfo info, StreamingContext context);
}
[FlagsAttribute]
public enum System.IO.FileAccess : Enum {
    public int value__;
    public static FileAccess Read;
    public static FileAccess ReadWrite;
    public static FileAccess Write;
}
[FlagsAttribute]
public enum System.IO.FileAttributes : Enum {
    public int value__;
    public static FileAttributes Archive;
    public static FileAttributes Compressed;
    public static FileAttributes Device;
    public static FileAttributes Directory;
    public static FileAttributes Encrypted;
    public static FileAttributes Hidden;
    public static FileAttributes IntegrityStream;
    public static FileAttributes Normal;
    public static FileAttributes NoScrubData;
    public static FileAttributes NotContentIndexed;
    public static FileAttributes Offline;
    public static FileAttributes ReadOnly;
    public static FileAttributes ReparsePoint;
    public static FileAttributes SparseFile;
    public static FileAttributes System;
    public static FileAttributes Temporary;
}
public class System.IO.FileLoadException : IOException {
    public string FileName { get; }
    public string FusionLog { get; }
    public string Message { get; }
    public FileLoadException(string message);
    public FileLoadException(string message, Exception inner);
    public FileLoadException(string message, string fileName);
    public FileLoadException(string message, string fileName, Exception inner);
    protected FileLoadException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public string get_FileName();
    public string get_FusionLog();
    public virtual string get_Message();
    public virtual string ToString();
}
public enum System.IO.FileMode : Enum {
    public int value__;
    public static FileMode Append;
    public static FileMode Create;
    public static FileMode CreateNew;
    public static FileMode Open;
    public static FileMode OpenOrCreate;
    public static FileMode Truncate;
}
public class System.IO.FileNotFoundException : IOException {
    public string FileName { get; }
    public string FusionLog { get; }
    public string Message { get; }
    public FileNotFoundException(string message);
    public FileNotFoundException(string message, Exception innerException);
    public FileNotFoundException(string message, string fileName);
    public FileNotFoundException(string message, string fileName, Exception innerException);
    protected FileNotFoundException(SerializationInfo info, StreamingContext context);
    public string get_FileName();
    public string get_FusionLog();
    public virtual string get_Message();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
}
[FlagsAttribute]
public enum System.IO.FileOptions : Enum {
    public int value__;
    public static FileOptions Asynchronous;
    public static FileOptions DeleteOnClose;
    public static FileOptions Encrypted;
    public static FileOptions None;
    public static FileOptions RandomAccess;
    public static FileOptions SequentialScan;
    public static FileOptions WriteThrough;
}
[FlagsAttribute]
public enum System.IO.FileShare : Enum {
    public int value__;
    public static FileShare Delete;
    public static FileShare Inheritable;
    public static FileShare None;
    public static FileShare Read;
    public static FileShare ReadWrite;
    public static FileShare Write;
}
public class System.IO.FileStream : Stream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    [ObsoleteAttribute("This property has been deprecated.  Please use FileStream's SafeFileHandle property instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
public IntPtr Handle { get; }
    public bool IsAsync { get; }
    public long Length { get; }
    public string Name { get; }
    public long Position { get; public set; }
    public SafeFileHandle SafeFileHandle { get; }
    [ObsoleteAttribute("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead.  http://go.microsoft.com/fwlink/?linkid=14202")]
public FileStream(IntPtr handle, FileAccess access);
    [ObsoleteAttribute("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  http://go.microsoft.com/fwlink/?linkid=14202")]
public FileStream(IntPtr handle, FileAccess access, bool ownsHandle);
    [ObsoleteAttribute("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  http://go.microsoft.com/fwlink/?linkid=14202")]
public FileStream(IntPtr handle, FileAccess access, bool ownsHandle, int bufferSize);
    [ObsoleteAttribute("This constructor has been deprecated.  Please use new FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync) instead, and optionally make a new SafeFileHandle with ownsHandle=false if needed.  http://go.microsoft.com/fwlink/?linkid=14202")]
public FileStream(IntPtr handle, FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);
    public FileStream(SafeFileHandle handle, FileAccess access);
    public FileStream(SafeFileHandle handle, FileAccess access, int bufferSize);
    public FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync);
    public FileStream(string path, FileMode mode);
    public FileStream(string path, FileMode mode, FileAccess access);
    public FileStream(string path, FileMode mode, FileAccess access, FileShare share);
    public FileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize);
    public FileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, bool useAsync);
    public FileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, FileOptions options);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual IntPtr get_Handle();
    public virtual bool get_IsAsync();
    public virtual long get_Length();
    public string get_Name();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual SafeFileHandle get_SafeFileHandle();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    public virtual void Flush();
    public virtual void Flush(bool flushToDisk);
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] array, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void Lock(long position, long length);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] array, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void WriteByte(byte value);
    public virtual void Unlock(long position, long length);
}
public enum System.IO.HandleInheritability : Enum {
    public int value__;
    public static HandleInheritability Inheritable;
    public static HandleInheritability None;
}
public class System.IO.IOException : SystemException {
    public IOException(string message);
    public IOException(string message, Exception innerException);
    public IOException(string message, int hresult);
    protected IOException(SerializationInfo info, StreamingContext context);
}
public class System.IO.PathTooLongException : IOException {
    public PathTooLongException(string message);
    public PathTooLongException(string message, Exception innerException);
    protected PathTooLongException(SerializationInfo info, StreamingContext context);
}
public enum System.IO.SeekOrigin : Enum {
    public int value__;
    public static SeekOrigin Begin;
    public static SeekOrigin Current;
    public static SeekOrigin End;
}
public abstract class System.IO.Stream : MarshalByRefObject {
    public static Stream Null;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public abstract virtual bool get_CanRead();
    public abstract virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public abstract virtual bool get_CanWrite();
    public abstract virtual long get_Length();
    public abstract virtual long get_Position();
    public abstract virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public void CopyTo(Stream destination);
    public virtual void CopyTo(Stream destination, int bufferSize);
    public Task CopyToAsync(Stream destination);
    public Task CopyToAsync(Stream destination, int bufferSize);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual void Close();
    [ObsoleteAttribute("CreateWaitHandle will be removed eventually.  Please use "new ManualResetEvent(false)" instead.")]
protected virtual WaitHandle CreateWaitHandle();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public abstract virtual void Flush();
    public Task FlushAsync();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    [ObsoleteAttribute("Do not call or override this method.")]
protected virtual void ObjectInvariant();
    public abstract virtual int Read(Byte[] buffer, int offset, int count);
    public Task`1<int> ReadAsync(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public abstract virtual long Seek(long offset, SeekOrigin origin);
    public abstract virtual void SetLength(long value);
    public static Stream Synchronized(Stream stream);
    public abstract virtual void Write(Byte[] buffer, int offset, int count);
    public Task WriteAsync(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
}
public interface System.IObservable`1 {
    public abstract virtual IDisposable Subscribe(IObserver`1<T> observer);
}
public interface System.IObserver`1 {
    public abstract virtual void OnCompleted();
    public abstract virtual void OnError(Exception error);
    public abstract virtual void OnNext(T value);
}
public interface System.IProgress`1 {
    public abstract virtual void Report(T value);
}
public class System.Lazy`1 : object {
    public bool IsValueCreated { get; }
    public T Value { get; }
    public Lazy`1(T value);
    public Lazy`1(bool isThreadSafe);
    public Lazy`1(Func`1<T> valueFactory);
    public Lazy`1(Func`1<T> valueFactory, bool isThreadSafe);
    public Lazy`1(Func`1<T> valueFactory, LazyThreadSafetyMode mode);
    public Lazy`1(LazyThreadSafetyMode mode);
    public bool get_IsValueCreated();
    public T get_Value();
    public virtual string ToString();
}
public class System.Lazy`2 : Lazy`1<T> {
    public TMetadata Metadata { get; }
    public Lazy`2(TMetadata metadata);
    public Lazy`2(TMetadata metadata, bool isThreadSafe);
    public Lazy`2(TMetadata metadata, LazyThreadSafetyMode mode);
    public Lazy`2(Func`1<T> valueFactory, TMetadata metadata);
    public Lazy`2(Func`1<T> valueFactory, TMetadata metadata, bool isThreadSafe);
    public Lazy`2(Func`1<T> valueFactory, TMetadata metadata, LazyThreadSafetyMode mode);
    public TMetadata get_Metadata();
}
public class System.LdapStyleUriParser : UriParser {
}
public abstract class System.MarshalByRefObject : object {
    public object GetLifetimeService();
    public virtual object InitializeLifetimeService();
    protected MarshalByRefObject MemberwiseClone(bool cloneIdentity);
}
public class System.MemberAccessException : SystemException {
    public MemberAccessException(string message);
    public MemberAccessException(string message, Exception inner);
    protected MemberAccessException(SerializationInfo info, StreamingContext context);
}
public class System.MethodAccessException : MemberAccessException {
    public MethodAccessException(string message);
    public MethodAccessException(string message, Exception inner);
    protected MethodAccessException(SerializationInfo info, StreamingContext context);
}
public enum System.MidpointRounding : Enum {
    public int value__;
    public static MidpointRounding ToEven;
    public static MidpointRounding AwayFromZero;
}
public class System.MissingFieldException : MissingMemberException {
    public string Message { get; }
    public MissingFieldException(string message);
    public MissingFieldException(string className, string fieldName);
    public MissingFieldException(string message, Exception inner);
    protected MissingFieldException(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
}
public class System.MissingMemberException : MemberAccessException {
    protected string ClassName;
    protected string MemberName;
    protected Byte[] Signature;
    public string Message { get; }
    public MissingMemberException(string message);
    public MissingMemberException(string className, string memberName);
    public MissingMemberException(string message, Exception inner);
    protected MissingMemberException(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.MissingMethodException : MissingMemberException {
    public string Message { get; }
    public MissingMethodException(string message);
    public MissingMethodException(string className, string methodName);
    public MissingMethodException(string message, Exception inner);
    protected MissingMethodException(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
}
public class System.ModuleHandle : ValueType {
    public static ModuleHandle EmptyHandle;
    public int MDStreamVersion { get; }
    public int get_MDStreamVersion();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(ModuleHandle handle);
    public static bool op_Equality(ModuleHandle left, ModuleHandle right);
    public static bool op_Inequality(ModuleHandle left, ModuleHandle right);
    public RuntimeTypeHandle GetRuntimeTypeHandleFromMetadataToken(int typeToken);
    public RuntimeTypeHandle ResolveTypeHandle(int typeToken);
    public RuntimeTypeHandle ResolveTypeHandle(int typeToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext);
    public RuntimeMethodHandle GetRuntimeMethodHandleFromMetadataToken(int methodToken);
    public RuntimeMethodHandle ResolveMethodHandle(int methodToken);
    public RuntimeMethodHandle ResolveMethodHandle(int methodToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext);
    public RuntimeFieldHandle GetRuntimeFieldHandleFromMetadataToken(int fieldToken);
    public RuntimeFieldHandle ResolveFieldHandle(int fieldToken);
    public RuntimeFieldHandle ResolveFieldHandle(int fieldToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext);
}
[AttributeUsageAttribute("64")]
public class System.MTAThreadAttribute : Attribute {
}
public abstract class System.MulticastDelegate : Delegate {
    protected MulticastDelegate(object target, string method);
    protected MulticastDelegate(Type target, string method);
    protected sealed virtual Delegate CombineImpl(Delegate follow);
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
    public sealed virtual Delegate[] GetInvocationList();
    protected virtual MethodInfo GetMethodImpl();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public static bool op_Equality(MulticastDelegate d1, MulticastDelegate d2);
    public static bool op_Inequality(MulticastDelegate d1, MulticastDelegate d2);
    protected sealed virtual Delegate RemoveImpl(Delegate value);
}
public class System.MulticastNotSupportedException : SystemException {
    public MulticastNotSupportedException(string message);
    public MulticastNotSupportedException(string message, Exception inner);
}
public class System.NetPipeStyleUriParser : UriParser {
}
public class System.NetTcpStyleUriParser : UriParser {
}
public class System.NewsStyleUriParser : UriParser {
}
[AttributeUsageAttribute("256")]
public class System.NonSerializedAttribute : Attribute {
}
public class System.NotFiniteNumberException : ArithmeticException {
    [CompilerGeneratedAttribute]
private double <OffendingNumber>k__BackingField;
    public double OffendingNumber { get; }
    public NotFiniteNumberException(double offendingNumber);
    public NotFiniteNumberException(string message);
    public NotFiniteNumberException(string message, double offendingNumber);
    public NotFiniteNumberException(string message, Exception innerException);
    public NotFiniteNumberException(string message, double offendingNumber, Exception innerException);
    protected NotFiniteNumberException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public double get_OffendingNumber();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.NotImplementedException : SystemException {
    public NotImplementedException(string message);
    public NotImplementedException(string message, Exception inner);
    protected NotImplementedException(SerializationInfo info, StreamingContext context);
}
public class System.NotSupportedException : SystemException {
    public NotSupportedException(string message);
    public NotSupportedException(string message, Exception innerException);
    protected NotSupportedException(SerializationInfo info, StreamingContext context);
}
public static class System.Nullable : object {
    public static int Compare(Nullable`1<T> n1, Nullable`1<T> n2);
    public static bool Equals(Nullable`1<T> n1, Nullable`1<T> n2);
    public static Type GetUnderlyingType(Type nullableType);
}
public class System.Nullable`1 : ValueType {
    public bool HasValue { get; }
    public T Value { get; }
    public Nullable`1(T value);
    public bool get_HasValue();
    public T get_Value();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public T GetValueOrDefault();
    public T GetValueOrDefault(T defaultValue);
    public static T op_Explicit(Nullable`1<T> value);
    public static Nullable`1<T> op_Implicit(T value);
    public virtual string ToString();
}
public class System.NullReferenceException : SystemException {
    public NullReferenceException(string message);
    public NullReferenceException(string message, Exception innerException);
    protected NullReferenceException(SerializationInfo info, StreamingContext context);
}
public class System.Object {
    public virtual bool Equals(object obj);
    public static bool Equals(object objA, object objB);
    protected virtual void Finalize();
    public virtual int GetHashCode();
    public Type GetType();
    protected object MemberwiseClone();
    public static bool ReferenceEquals(object objA, object objB);
    public virtual string ToString();
}
public class System.ObjectDisposedException : InvalidOperationException {
    public string Message { get; }
    public string ObjectName { get; }
    public ObjectDisposedException(string objectName);
    public ObjectDisposedException(string message, Exception innerException);
    public ObjectDisposedException(string objectName, string message);
    protected ObjectDisposedException(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
    public string get_ObjectName();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("6140")]
public class System.ObsoleteAttribute : Attribute {
    public bool IsError { get; }
    public string Message { get; }
    public ObsoleteAttribute(string message);
    public ObsoleteAttribute(string message, bool error);
    public bool get_IsError();
    public string get_Message();
}
public class System.OutOfMemoryException : SystemException {
    public OutOfMemoryException(string message);
    public OutOfMemoryException(string message, Exception innerException);
    protected OutOfMemoryException(SerializationInfo info, StreamingContext context);
}
public class System.OverflowException : ArithmeticException {
    public OverflowException(string message);
    public OverflowException(string message, Exception innerException);
    protected OverflowException(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("2048")]
public class System.ParamArrayAttribute : Attribute {
}
public class System.PlatformNotSupportedException : NotSupportedException {
    public PlatformNotSupportedException(string message);
    public PlatformNotSupportedException(string message, Exception inner);
    protected PlatformNotSupportedException(SerializationInfo info, StreamingContext context);
}
public class System.Predicate`1 : MulticastDelegate {
    public Predicate`1(object object, IntPtr method);
    public virtual bool Invoke(T obj);
    public virtual IAsyncResult BeginInvoke(T obj, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public class System.RankException : SystemException {
    public RankException(string message);
    public RankException(string message, Exception innerException);
    protected RankException(SerializationInfo info, StreamingContext context);
}
public class System.Reflection.AmbiguousMatchException : SystemException {
    public AmbiguousMatchException(string message);
    public AmbiguousMatchException(string message, Exception inner);
}
public abstract class System.Reflection.Assembly : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<TypeInfo> <DefinedTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Module> <Modules>k__BackingField;
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public IEnumerable`1<TypeInfo> DefinedTypes { get; }
    public string EscapedCodeBase { get; }
    public IEnumerable`1<Type> ExportedTypes { get; }
    public MethodInfo EntryPoint { get; }
    public string FullName { get; }
    public bool GlobalAssemblyCache { get; }
    public long HostContext { get; }
    public bool IsDynamic { get; }
    public bool IsFullyTrusted { get; }
    public Module ManifestModule { get; }
    public IEnumerable`1<Module> Modules { get; }
    public bool ReflectionOnly { get; }
    public SecurityRuleSet SecurityRuleSet { get; }
    public string Location { get; }
    public string CodeBase { get; }
    public string ImageRuntimeVersion { get; }
    public virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    [CompilerGeneratedAttribute]
public virtual IEnumerable`1<TypeInfo> get_DefinedTypes();
    public virtual string get_EscapedCodeBase();
    public virtual IEnumerable`1<Type> get_ExportedTypes();
    public virtual MethodInfo get_EntryPoint();
    public virtual string get_FullName();
    public virtual bool get_GlobalAssemblyCache();
    public virtual long get_HostContext();
    public virtual bool get_IsDynamic();
    public bool get_IsFullyTrusted();
    public virtual Module get_ManifestModule();
    public virtual void add_ModuleResolve(ModuleResolveEventHandler value);
    public virtual void remove_ModuleResolve(ModuleResolveEventHandler value);
    [CompilerGeneratedAttribute]
public virtual IEnumerable`1<Module> get_Modules();
    public virtual bool get_ReflectionOnly();
    public virtual SecurityRuleSet get_SecurityRuleSet();
    public virtual bool Equals(object o);
    public static bool op_Equality(Assembly left, Assembly right);
    public static bool op_Inequality(Assembly left, Assembly right);
    public static Assembly GetAssembly(Type type);
    public static Assembly GetCallingAssembly();
    public virtual FileStream GetFile(string name);
    public virtual FileStream[] GetFiles();
    public virtual FileStream[] GetFiles(bool getResourceModules);
    public virtual int GetHashCode();
    public virtual ManifestResourceInfo GetManifestResourceInfo(string resourceName);
    public virtual String[] GetManifestResourceNames();
    public virtual Stream GetManifestResourceStream(string name);
    public virtual Stream GetManifestResourceStream(Type type, string name);
    public virtual Module GetModule(string name);
    public Module[] GetModules();
    public virtual Module[] GetModules(bool getResourceModules);
    public virtual AssemblyName GetName(bool copiedName);
    public virtual AssemblyName GetName();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual Type GetType(string name);
    public virtual Type GetType(string name, bool throwOnError, bool ignoreCase);
    public static Assembly Load(Byte[] rawAssembly);
    public static Assembly Load(Byte[] rawAssembly, Byte[] rawSymbolStore);
    public static Assembly Load(AssemblyName assemblyRef);
    public static Assembly Load(string assemblyString);
    public static Assembly LoadFile(string path);
    public static Assembly LoadFrom(string assemblyFile);
    public static Assembly LoadFrom(string assemblyFile, Byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm);
    public Module LoadModule(string moduleName, Byte[] rawModule);
    public virtual Module LoadModule(string moduleName, Byte[] rawModule, Byte[] rawSymbolStore);
    [ObsoleteAttribute("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public static Assembly LoadWithPartialName(string partialName);
    public static Assembly GetEntryAssembly();
    public static Assembly GetExecutingAssembly();
    public Module[] GetLoadedModules();
    public virtual Module[] GetLoadedModules(bool getResourceModules);
    public virtual string get_Location();
    public virtual string ToString();
    public static Assembly UnsafeLoadFrom(string assemblyFile);
    public virtual string get_CodeBase();
    public virtual string get_ImageRuntimeVersion();
    public object CreateInstance(string typeName);
    public object CreateInstance(string typeName, bool ignoreCase);
    public virtual object CreateInstance(string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    public static string CreateQualifiedName(string assemblyName, string typeName);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual Type[] GetExportedTypes();
    public virtual AssemblyName[] GetReferencedAssemblies();
    public virtual Assembly GetSatelliteAssembly(CultureInfo culture);
    public virtual Assembly GetSatelliteAssembly(CultureInfo culture, Version version);
    public virtual Type GetType(string name, bool throwOnError);
    public virtual Type[] GetTypes();
    public static Assembly ReflectionOnlyLoad(Byte[] rawAssembly);
    public static Assembly ReflectionOnlyLoad(string assemblyString);
    public static Assembly ReflectionOnlyLoadFrom(string assemblyFile);
    public virtual bool IsDefined(Type attributeType, bool inherit);
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyAlgorithmIdAttribute : Attribute {
    [CLSCompliantAttribute("False")]
public UInt32 AlgorithmId { get; }
    public AssemblyAlgorithmIdAttribute(AssemblyHashAlgorithm algorithmId);
    [CLSCompliantAttribute("False")]
public AssemblyAlgorithmIdAttribute(UInt32 algorithmId);
    public UInt32 get_AlgorithmId();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyCompanyAttribute : Attribute {
    public string Company { get; }
    public AssemblyCompanyAttribute(string company);
    public string get_Company();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyConfigurationAttribute : Attribute {
    public string Configuration { get; }
    public AssemblyConfigurationAttribute(string configuration);
    public string get_Configuration();
}
public enum System.Reflection.AssemblyContentType : Enum {
    public int value__;
    public static AssemblyContentType Default;
    public static AssemblyContentType WindowsRuntime;
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyCopyrightAttribute : Attribute {
    public string Copyright { get; }
    public AssemblyCopyrightAttribute(string copyright);
    public string get_Copyright();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyCultureAttribute : Attribute {
    public string Culture { get; }
    public AssemblyCultureAttribute(string culture);
    public string get_Culture();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyDefaultAliasAttribute : Attribute {
    public string DefaultAlias { get; }
    public AssemblyDefaultAliasAttribute(string defaultAlias);
    public string get_DefaultAlias();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyDelaySignAttribute : Attribute {
    public bool DelaySign { get; }
    public AssemblyDelaySignAttribute(bool delaySign);
    public bool get_DelaySign();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyDescriptionAttribute : Attribute {
    public string Description { get; }
    public AssemblyDescriptionAttribute(string description);
    public string get_Description();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyFileVersionAttribute : Attribute {
    public string Version { get; }
    public AssemblyFileVersionAttribute(string version);
    public string get_Version();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyFlagsAttribute : Attribute {
    public int AssemblyFlags { get; }
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute("This property has been deprecated. Please use AssemblyFlags instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public UInt32 Flags { get; }
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute("This constructor has been deprecated. Please use AssemblyFlagsAttribute(AssemblyNameFlags) instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public AssemblyFlagsAttribute(UInt32 flags);
    [ObsoleteAttribute("This constructor has been deprecated. Please use AssemblyFlagsAttribute(AssemblyNameFlags) instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public AssemblyFlagsAttribute(int assemblyFlags);
    public AssemblyFlagsAttribute(AssemblyNameFlags assemblyFlags);
    public int get_AssemblyFlags();
    public UInt32 get_Flags();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyInformationalVersionAttribute : Attribute {
    public string InformationalVersion { get; }
    public AssemblyInformationalVersionAttribute(string informationalVersion);
    public string get_InformationalVersion();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyKeyFileAttribute : Attribute {
    public string KeyFile { get; }
    public AssemblyKeyFileAttribute(string keyFile);
    public string get_KeyFile();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyKeyNameAttribute : Attribute {
    public string KeyName { get; }
    public AssemblyKeyNameAttribute(string keyName);
    public string get_KeyName();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyMetadataAttribute : Attribute {
    public string Key { get; }
    public string Value { get; }
    public AssemblyMetadataAttribute(string key, string value);
    public string get_Key();
    public string get_Value();
}
public class System.Reflection.AssemblyName : object {
    public string CodeBase { get; public set; }
    public AssemblyContentType ContentType { get; public set; }
    public CultureInfo CultureInfo { get; public set; }
    public string CultureName { get; public set; }
    public string EscapedCodeBase { get; }
    public AssemblyNameFlags Flags { get; public set; }
    public string FullName { get; }
    public AssemblyHashAlgorithm HashAlgorithm { get; public set; }
    public StrongNameKeyPair KeyPair { get; public set; }
    public AssemblyVersionCompatibility VersionCompatibility { get; public set; }
    public string Name { get; public set; }
    public ProcessorArchitecture ProcessorArchitecture { get; public set; }
    public Version Version { get; public set; }
    public AssemblyName(string assemblyName);
    public string get_CodeBase();
    public void set_CodeBase(string value);
    public AssemblyContentType get_ContentType();
    public void set_ContentType(AssemblyContentType value);
    public CultureInfo get_CultureInfo();
    public void set_CultureInfo(CultureInfo value);
    public string get_CultureName();
    public void set_CultureName(string value);
    public string get_EscapedCodeBase();
    public AssemblyNameFlags get_Flags();
    public void set_Flags(AssemblyNameFlags value);
    public string get_FullName();
    public AssemblyHashAlgorithm get_HashAlgorithm();
    public void set_HashAlgorithm(AssemblyHashAlgorithm value);
    public StrongNameKeyPair get_KeyPair();
    public void set_KeyPair(StrongNameKeyPair value);
    public AssemblyVersionCompatibility get_VersionCompatibility();
    public void set_VersionCompatibility(AssemblyVersionCompatibility value);
    public string get_Name();
    public void set_Name(string value);
    public ProcessorArchitecture get_ProcessorArchitecture();
    public void set_ProcessorArchitecture(ProcessorArchitecture value);
    public Version get_Version();
    public void set_Version(Version value);
    public sealed virtual object Clone();
    public static AssemblyName GetAssemblyName(string assemblyFile);
    public Byte[] GetPublicKey();
    public Byte[] GetPublicKeyToken();
    public void SetPublicKey(Byte[] publicKey);
    public void SetPublicKeyToken(Byte[] publicKeyToken);
    public virtual string ToString();
    public static bool ReferenceMatchesDefinition(AssemblyName reference, AssemblyName definition);
    [SecurityCriticalAttribute]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public sealed virtual void OnDeserialization(object sender);
}
[FlagsAttribute]
public enum System.Reflection.AssemblyNameFlags : Enum {
    public int value__;
    public static AssemblyNameFlags EnableJITcompileOptimizer;
    public static AssemblyNameFlags EnableJITcompileTracking;
    public static AssemblyNameFlags None;
    public static AssemblyNameFlags PublicKey;
    public static AssemblyNameFlags Retargetable;
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyProductAttribute : Attribute {
    public string Product { get; }
    public AssemblyProductAttribute(string product);
    public string get_Product();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblySignatureKeyAttribute : Attribute {
    public string Countersignature { get; }
    public string PublicKey { get; }
    public AssemblySignatureKeyAttribute(string publicKey, string countersignature);
    public string get_Countersignature();
    public string get_PublicKey();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyTitleAttribute : Attribute {
    public string Title { get; }
    public AssemblyTitleAttribute(string title);
    public string get_Title();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyTrademarkAttribute : Attribute {
    public string Trademark { get; }
    public AssemblyTrademarkAttribute(string trademark);
    public string get_Trademark();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyVersionAttribute : Attribute {
    public string Version { get; }
    public AssemblyVersionAttribute(string version);
    public string get_Version();
}
public abstract class System.Reflection.Binder : object {
    public abstract virtual FieldInfo BindToField(BindingFlags bindingAttr, FieldInfo[] match, object value, CultureInfo culture);
    public abstract virtual MethodBase BindToMethod(BindingFlags bindingAttr, MethodBase[] match, Object[]& args, ParameterModifier[] modifiers, CultureInfo culture, String[] names, Object& state);
    public abstract virtual object ChangeType(object value, Type type, CultureInfo culture);
    public abstract virtual void ReorderArgumentArray(Object[]& args, object state);
    public abstract virtual MethodBase SelectMethod(BindingFlags bindingAttr, MethodBase[] match, Type[] types, ParameterModifier[] modifiers);
    public abstract virtual PropertyInfo SelectProperty(BindingFlags bindingAttr, PropertyInfo[] match, Type returnType, Type[] indexes, ParameterModifier[] modifiers);
}
[FlagsAttribute]
public enum System.Reflection.BindingFlags : Enum {
    public int value__;
    public static BindingFlags CreateInstance;
    public static BindingFlags DeclaredOnly;
    public static BindingFlags Default;
    public static BindingFlags ExactBinding;
    public static BindingFlags FlattenHierarchy;
    public static BindingFlags GetField;
    public static BindingFlags GetProperty;
    public static BindingFlags IgnoreCase;
    public static BindingFlags IgnoreReturn;
    public static BindingFlags Instance;
    public static BindingFlags InvokeMethod;
    public static BindingFlags NonPublic;
    public static BindingFlags OptionalParamBinding;
    public static BindingFlags Public;
    public static BindingFlags PutDispProperty;
    public static BindingFlags PutRefDispProperty;
    public static BindingFlags SetField;
    public static BindingFlags SetProperty;
    public static BindingFlags Static;
    public static BindingFlags SuppressChangeType;
}
[FlagsAttribute]
public enum System.Reflection.CallingConventions : Enum {
    public int value__;
    public static CallingConventions Any;
    public static CallingConventions ExplicitThis;
    public static CallingConventions HasThis;
    public static CallingConventions Standard;
    public static CallingConventions VarArgs;
}
public abstract class System.Reflection.ConstructorInfo : MethodBase {
    public static string ConstructorName;
    public static string TypeConstructorName;
    public MemberTypes MemberType { get; }
    public virtual bool Equals(object obj);
    public static bool op_Equality(ConstructorInfo left, ConstructorInfo right);
    public static bool op_Inequality(ConstructorInfo left, ConstructorInfo right);
    public virtual int GetHashCode();
    public object Invoke(Object[] parameters);
    public abstract virtual object Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual MemberTypes get_MemberType();
}
public class System.Reflection.CustomAttributeData : object {
    public Type AttributeType { get; }
    public IList`1<CustomAttributeTypedArgument> ConstructorArguments { get; }
    public IList`1<CustomAttributeNamedArgument> NamedArguments { get; }
    public ConstructorInfo Constructor { get; }
    public Type get_AttributeType();
    public virtual IList`1<CustomAttributeTypedArgument> get_ConstructorArguments();
    public virtual IList`1<CustomAttributeNamedArgument> get_NamedArguments();
    public virtual ConstructorInfo get_Constructor();
    public virtual bool Equals(object obj);
    public static IList`1<CustomAttributeData> GetCustomAttributes(Assembly target);
    public static IList`1<CustomAttributeData> GetCustomAttributes(MemberInfo target);
    public static IList`1<CustomAttributeData> GetCustomAttributes(Module target);
    public static IList`1<CustomAttributeData> GetCustomAttributes(ParameterInfo target);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class System.Reflection.CustomAttributeExtensions : object {
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(Assembly element, Type attributeType);
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(MemberInfo element, Type attributeType);
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(MemberInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(Module element, Type attributeType);
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(ParameterInfo element, Type attributeType);
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(ParameterInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static T GetCustomAttribute(Assembly element);
    [ExtensionAttribute]
public static T GetCustomAttribute(MemberInfo element);
    [ExtensionAttribute]
public static T GetCustomAttribute(MemberInfo element, bool inherit);
    [ExtensionAttribute]
public static T GetCustomAttribute(Module element);
    [ExtensionAttribute]
public static T GetCustomAttribute(ParameterInfo element);
    [ExtensionAttribute]
public static T GetCustomAttribute(ParameterInfo element, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(Assembly element);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(Assembly element, Type attributeType);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(MemberInfo element);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(MemberInfo element, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(MemberInfo element, Type attributeType);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(MemberInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(Module element);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(Module element, Type attributeType);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(ParameterInfo element);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(ParameterInfo element, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(ParameterInfo element, Type attributeType);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(ParameterInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(Assembly element);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(MemberInfo element);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(MemberInfo element, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(Module element);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(ParameterInfo element);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(ParameterInfo element, bool inherit);
    [ExtensionAttribute]
public static bool IsDefined(Assembly element, Type attributeType);
    [ExtensionAttribute]
public static bool IsDefined(MemberInfo element, Type attributeType);
    [ExtensionAttribute]
public static bool IsDefined(MemberInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static bool IsDefined(Module element, Type attributeType);
    [ExtensionAttribute]
public static bool IsDefined(ParameterInfo element, Type attributeType);
    [ExtensionAttribute]
public static bool IsDefined(ParameterInfo element, Type attributeType, bool inherit);
}
public class System.Reflection.CustomAttributeFormatException : FormatException {
    public CustomAttributeFormatException(string message);
    public CustomAttributeFormatException(string message, Exception inner);
    protected CustomAttributeFormatException(SerializationInfo info, StreamingContext context);
}
public class System.Reflection.CustomAttributeNamedArgument : ValueType {
    public bool IsField { get; }
    public MemberInfo MemberInfo { get; }
    public string MemberName { get; }
    public CustomAttributeTypedArgument TypedValue { get; }
    public CustomAttributeNamedArgument(MemberInfo memberInfo, object value);
    public CustomAttributeNamedArgument(MemberInfo memberInfo, CustomAttributeTypedArgument typedArgument);
    internal CustomAttributeNamedArgument(Type attributeType, string memberName, bool isField, CustomAttributeTypedArgument typedValue);
    public bool get_IsField();
    public MemberInfo get_MemberInfo();
    public string get_MemberName();
    public CustomAttributeTypedArgument get_TypedValue();
    public static bool op_Equality(CustomAttributeNamedArgument left, CustomAttributeNamedArgument right);
    public static bool op_Inequality(CustomAttributeNamedArgument left, CustomAttributeNamedArgument right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class System.Reflection.CustomAttributeTypedArgument : ValueType {
    public Type ArgumentType { get; }
    public object Value { get; }
    public CustomAttributeTypedArgument(object value);
    public CustomAttributeTypedArgument(Type argumentType, object value);
    public Type get_ArgumentType();
    public object get_Value();
    public static bool op_Equality(CustomAttributeTypedArgument left, CustomAttributeTypedArgument right);
    public static bool op_Inequality(CustomAttributeTypedArgument left, CustomAttributeTypedArgument right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[AttributeUsageAttribute("1036")]
public class System.Reflection.DefaultMemberAttribute : Attribute {
    public string MemberName { get; }
    public DefaultMemberAttribute(string memberName);
    public string get_MemberName();
}
[FlagsAttribute]
public enum System.Reflection.EventAttributes : Enum {
    public int value__;
    public static EventAttributes None;
    public static EventAttributes ReservedMask;
    public static EventAttributes RTSpecialName;
    public static EventAttributes SpecialName;
}
public abstract class System.Reflection.EventInfo : MemberInfo {
    public MethodInfo AddMethod { get; }
    public EventAttributes Attributes { get; }
    public Type EventHandlerType { get; }
    public bool IsMulticast { get; }
    public bool IsSpecialName { get; }
    public MethodInfo RaiseMethod { get; }
    public MethodInfo RemoveMethod { get; }
    public MemberTypes MemberType { get; }
    public virtual MethodInfo get_AddMethod();
    public abstract virtual EventAttributes get_Attributes();
    public virtual Type get_EventHandlerType();
    public virtual bool get_IsMulticast();
    public bool get_IsSpecialName();
    public virtual MethodInfo get_RaiseMethod();
    public virtual MethodInfo get_RemoveMethod();
    public virtual void AddEventHandler(object target, Delegate handler);
    public virtual bool Equals(object obj);
    public static bool op_Equality(EventInfo left, EventInfo right);
    public static bool op_Inequality(EventInfo left, EventInfo right);
    public virtual int GetHashCode();
    public virtual void RemoveEventHandler(object target, Delegate handler);
    public MethodInfo GetAddMethod();
    public abstract virtual MethodInfo GetAddMethod(bool nonPublic);
    public MethodInfo[] GetOtherMethods();
    public virtual MethodInfo[] GetOtherMethods(bool nonPublic);
    public MethodInfo GetRaiseMethod();
    public abstract virtual MethodInfo GetRaiseMethod(bool nonPublic);
    public MethodInfo GetRemoveMethod();
    public abstract virtual MethodInfo GetRemoveMethod(bool nonPublic);
    public virtual MemberTypes get_MemberType();
}
public class System.Reflection.ExceptionHandlingClause : object {
    public ExceptionHandlingClauseOptions Flags { get; }
    public int TryOffset { get; }
    public int TryLength { get; }
    public int HandlerOffset { get; }
    public int HandlerLength { get; }
    public int FilterOffset { get; }
    public Type CatchType { get; }
    public virtual ExceptionHandlingClauseOptions get_Flags();
    public virtual int get_TryOffset();
    public virtual int get_TryLength();
    public virtual int get_HandlerOffset();
    public virtual int get_HandlerLength();
    public virtual int get_FilterOffset();
    public virtual Type get_CatchType();
    public virtual string ToString();
}
[FlagsAttribute]
public enum System.Reflection.ExceptionHandlingClauseOptions : Enum {
    public int value__;
    public static ExceptionHandlingClauseOptions Clause;
    public static ExceptionHandlingClauseOptions Filter;
    public static ExceptionHandlingClauseOptions Finally;
    public static ExceptionHandlingClauseOptions Fault;
}
[FlagsAttribute]
public enum System.Reflection.FieldAttributes : Enum {
    public int value__;
    public static FieldAttributes Assembly;
    public static FieldAttributes FamANDAssem;
    public static FieldAttributes Family;
    public static FieldAttributes FamORAssem;
    public static FieldAttributes FieldAccessMask;
    public static FieldAttributes HasDefault;
    public static FieldAttributes HasFieldMarshal;
    public static FieldAttributes HasFieldRVA;
    public static FieldAttributes InitOnly;
    public static FieldAttributes Literal;
    public static FieldAttributes NotSerialized;
    public static FieldAttributes PinvokeImpl;
    public static FieldAttributes Private;
    public static FieldAttributes PrivateScope;
    public static FieldAttributes Public;
    public static FieldAttributes ReservedMask;
    public static FieldAttributes RTSpecialName;
    public static FieldAttributes SpecialName;
    public static FieldAttributes Static;
}
public abstract class System.Reflection.FieldInfo : MemberInfo {
    public FieldAttributes Attributes { get; }
    public RuntimeFieldHandle FieldHandle { get; }
    public Type FieldType { get; }
    public bool IsAssembly { get; }
    public bool IsFamily { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsInitOnly { get; }
    public bool IsLiteral { get; }
    public bool IsNotSerialized { get; }
    public bool IsPinvokeImpl { get; }
    public bool IsPrivate { get; }
    public bool IsPublic { get; }
    public bool IsSpecialName { get; }
    public bool IsStatic { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public MemberTypes MemberType { get; }
    public abstract virtual FieldAttributes get_Attributes();
    public abstract virtual RuntimeFieldHandle get_FieldHandle();
    public abstract virtual Type get_FieldType();
    public bool get_IsAssembly();
    public bool get_IsFamily();
    public bool get_IsFamilyAndAssembly();
    public bool get_IsFamilyOrAssembly();
    public bool get_IsInitOnly();
    public bool get_IsLiteral();
    public bool get_IsNotSerialized();
    public bool get_IsPinvokeImpl();
    public bool get_IsPrivate();
    public bool get_IsPublic();
    public bool get_IsSpecialName();
    public bool get_IsStatic();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    public virtual bool Equals(object obj);
    public static bool op_Equality(FieldInfo left, FieldInfo right);
    public static bool op_Inequality(FieldInfo left, FieldInfo right);
    public static FieldInfo GetFieldFromHandle(RuntimeFieldHandle handle);
    public static FieldInfo GetFieldFromHandle(RuntimeFieldHandle handle, RuntimeTypeHandle declaringType);
    public virtual int GetHashCode();
    public virtual Type[] GetOptionalCustomModifiers();
    public virtual object GetRawConstantValue();
    public virtual Type[] GetRequiredCustomModifiers();
    public abstract virtual object GetValue(object obj);
    [CLSCompliantAttribute("False")]
public virtual object GetValueDirect(TypedReference obj);
    public virtual MemberTypes get_MemberType();
    public void SetValue(object obj, object value);
    public abstract virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
    [CLSCompliantAttribute("False")]
public virtual void SetValueDirect(TypedReference obj, object value);
}
[FlagsAttribute]
public enum System.Reflection.GenericParameterAttributes : Enum {
    public int value__;
    public static GenericParameterAttributes Contravariant;
    public static GenericParameterAttributes Covariant;
    public static GenericParameterAttributes DefaultConstructorConstraint;
    public static GenericParameterAttributes None;
    public static GenericParameterAttributes NotNullableValueTypeConstraint;
    public static GenericParameterAttributes ReferenceTypeConstraint;
    public static GenericParameterAttributes SpecialConstraintMask;
    public static GenericParameterAttributes VarianceMask;
}
public interface System.Reflection.ICustomAttributeProvider {
    public abstract virtual Object[] GetCustomAttributes(bool inherit);
    public abstract virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public abstract virtual bool IsDefined(Type attributeType, bool inherit);
}
public enum System.Reflection.ImageFileMachine : Enum {
    public int value__;
    public static ImageFileMachine I386;
    public static ImageFileMachine IA64;
    public static ImageFileMachine AMD64;
    public static ImageFileMachine ARM;
}
public class System.Reflection.InterfaceMapping : ValueType {
    public MethodInfo[] InterfaceMethods;
    public Type InterfaceType;
    public MethodInfo[] TargetMethods;
    public Type TargetType;
}
[ExtensionAttribute]
public static class System.Reflection.IntrospectionExtensions : object {
    [ExtensionAttribute]
public static TypeInfo GetTypeInfo(Type type);
}
public class System.Reflection.InvalidFilterCriteriaException : ApplicationException {
    public InvalidFilterCriteriaException(string message);
    public InvalidFilterCriteriaException(string message, Exception inner);
    protected InvalidFilterCriteriaException(SerializationInfo info, StreamingContext context);
}
public interface System.Reflection.IReflect {
    public Type UnderlyingSystemType { get; }
    public abstract virtual Type get_UnderlyingSystemType();
    public abstract virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public abstract virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public abstract virtual MemberInfo[] GetMember(string name, BindingFlags bindingAttr);
    public abstract virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    public abstract virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr);
    public abstract virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
    public abstract virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public abstract virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public abstract virtual PropertyInfo GetProperty(string name, BindingFlags bindingAttr);
    public abstract virtual PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public abstract virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
}
public interface System.Reflection.IReflectableType {
    public abstract virtual TypeInfo GetTypeInfo();
}
public class System.Reflection.LocalVariableInfo : object {
    public bool IsPinned { get; }
    public int LocalIndex { get; }
    public Type LocalType { get; }
    public virtual bool get_IsPinned();
    public virtual int get_LocalIndex();
    public virtual Type get_LocalType();
    public virtual string ToString();
}
public class System.Reflection.ManifestResourceInfo : object {
    public string FileName { get; }
    public Assembly ReferencedAssembly { get; }
    public ResourceLocation ResourceLocation { get; }
    public ManifestResourceInfo(Assembly containingAssembly, string containingFileName, ResourceLocation resourceLocation);
    public virtual string get_FileName();
    public virtual Assembly get_ReferencedAssembly();
    public virtual ResourceLocation get_ResourceLocation();
}
public class System.Reflection.MemberFilter : MulticastDelegate {
    public MemberFilter(object object, IntPtr method);
    public virtual bool Invoke(MemberInfo m, object filterCriteria);
    public virtual IAsyncResult BeginInvoke(MemberInfo m, object filterCriteria, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public abstract class System.Reflection.MemberInfo : object {
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public Type DeclaringType { get; }
    public int MetadataToken { get; }
    public Module Module { get; }
    public string Name { get; }
    public MemberTypes MemberType { get; }
    public Type ReflectedType { get; }
    public virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public abstract virtual Type get_DeclaringType();
    public virtual int get_MetadataToken();
    public virtual Module get_Module();
    public abstract virtual string get_Name();
    public virtual bool Equals(object obj);
    public static bool op_Equality(MemberInfo left, MemberInfo right);
    public static bool op_Inequality(MemberInfo left, MemberInfo right);
    public virtual int GetHashCode();
    public abstract virtual MemberTypes get_MemberType();
    public abstract virtual Type get_ReflectedType();
    public abstract virtual Object[] GetCustomAttributes(bool inherit);
    public abstract virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public abstract virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
}
[FlagsAttribute]
public enum System.Reflection.MemberTypes : Enum {
    public int value__;
    public static MemberTypes Constructor;
    public static MemberTypes Event;
    public static MemberTypes Field;
    public static MemberTypes Method;
    public static MemberTypes Property;
    public static MemberTypes TypeInfo;
    public static MemberTypes Custom;
    public static MemberTypes NestedType;
    public static MemberTypes All;
}
[FlagsAttribute]
public enum System.Reflection.MethodAttributes : Enum {
    public int value__;
    public static MethodAttributes Abstract;
    public static MethodAttributes Assembly;
    public static MethodAttributes CheckAccessOnOverride;
    public static MethodAttributes FamANDAssem;
    public static MethodAttributes Family;
    public static MethodAttributes FamORAssem;
    public static MethodAttributes Final;
    public static MethodAttributes HasSecurity;
    public static MethodAttributes HideBySig;
    public static MethodAttributes MemberAccessMask;
    public static MethodAttributes NewSlot;
    public static MethodAttributes PinvokeImpl;
    public static MethodAttributes Private;
    public static MethodAttributes PrivateScope;
    public static MethodAttributes Public;
    public static MethodAttributes RequireSecObject;
    public static MethodAttributes ReservedMask;
    public static MethodAttributes ReuseSlot;
    public static MethodAttributes RTSpecialName;
    public static MethodAttributes SpecialName;
    public static MethodAttributes Static;
    public static MethodAttributes UnmanagedExport;
    public static MethodAttributes Virtual;
    public static MethodAttributes VtableLayoutMask;
}
public abstract class System.Reflection.MethodBase : MemberInfo {
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public bool ContainsGenericParameters { get; }
    public bool IsAbstract { get; }
    public bool IsAssembly { get; }
    public bool IsConstructor { get; }
    public bool IsFamily { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsFinal { get; }
    public bool IsGenericMethod { get; }
    public bool IsGenericMethodDefinition { get; }
    public bool IsConstructedGenericMethod { get; }
    public bool IsHideBySig { get; }
    public bool IsPrivate { get; }
    public bool IsPublic { get; }
    public bool IsSpecialName { get; }
    public bool IsStatic { get; }
    public bool IsVirtual { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public MethodImplAttributes MethodImplementationFlags { get; }
    public abstract virtual MethodAttributes get_Attributes();
    public virtual CallingConventions get_CallingConvention();
    public virtual bool get_ContainsGenericParameters();
    public bool get_IsAbstract();
    public bool get_IsAssembly();
    public bool get_IsConstructor();
    public bool get_IsFamily();
    public bool get_IsFamilyAndAssembly();
    public bool get_IsFamilyOrAssembly();
    public bool get_IsFinal();
    public virtual bool get_IsGenericMethod();
    public virtual bool get_IsGenericMethodDefinition();
    public virtual bool get_IsConstructedGenericMethod();
    public bool get_IsHideBySig();
    public bool get_IsPrivate();
    public bool get_IsPublic();
    public bool get_IsSpecialName();
    public bool get_IsStatic();
    public bool get_IsVirtual();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    public abstract virtual RuntimeMethodHandle get_MethodHandle();
    public virtual MethodImplAttributes get_MethodImplementationFlags();
    public virtual bool Equals(object obj);
    public static bool op_Equality(MethodBase left, MethodBase right);
    public static bool op_Inequality(MethodBase left, MethodBase right);
    public static MethodBase GetCurrentMethod();
    public virtual Type[] GetGenericArguments();
    public virtual int GetHashCode();
    [SecuritySafeCriticalAttribute]
public virtual MethodBody GetMethodBody();
    public static MethodBase GetMethodFromHandle(RuntimeMethodHandle handle);
    public static MethodBase GetMethodFromHandle(RuntimeMethodHandle handle, RuntimeTypeHandle declaringType);
    public abstract virtual ParameterInfo[] GetParameters();
    public object Invoke(object obj, Object[] parameters);
    public abstract virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public abstract virtual MethodImplAttributes GetMethodImplementationFlags();
}
public class System.Reflection.MethodBody : object {
    public int LocalSignatureMetadataToken { get; }
    public IList`1<LocalVariableInfo> LocalVariables { get; }
    public int MaxStackSize { get; }
    public bool InitLocals { get; }
    public IList`1<ExceptionHandlingClause> ExceptionHandlingClauses { get; }
    public virtual int get_LocalSignatureMetadataToken();
    public virtual IList`1<LocalVariableInfo> get_LocalVariables();
    public virtual int get_MaxStackSize();
    public virtual bool get_InitLocals();
    public virtual Byte[] GetILAsByteArray();
    public virtual IList`1<ExceptionHandlingClause> get_ExceptionHandlingClauses();
}
public enum System.Reflection.MethodImplAttributes : Enum {
    public int value__;
    public static MethodImplAttributes AggressiveInlining;
    public static MethodImplAttributes CodeTypeMask;
    public static MethodImplAttributes ForwardRef;
    public static MethodImplAttributes IL;
    public static MethodImplAttributes InternalCall;
    public static MethodImplAttributes Managed;
    public static MethodImplAttributes ManagedMask;
    public static MethodImplAttributes MaxMethodImplVal;
    public static MethodImplAttributes Native;
    public static MethodImplAttributes NoInlining;
    public static MethodImplAttributes NoOptimization;
    public static MethodImplAttributes OPTIL;
    public static MethodImplAttributes PreserveSig;
    public static MethodImplAttributes Runtime;
    public static MethodImplAttributes Synchronized;
    public static MethodImplAttributes Unmanaged;
}
public abstract class System.Reflection.MethodInfo : MethodBase {
    public ParameterInfo ReturnParameter { get; }
    public Type ReturnType { get; }
    public MemberTypes MemberType { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    public abstract virtual MethodInfo GetBaseDefinition();
    public virtual ParameterInfo get_ReturnParameter();
    public virtual Type get_ReturnType();
    public virtual Delegate CreateDelegate(Type delegateType);
    public virtual Delegate CreateDelegate(Type delegateType, object target);
    public virtual bool Equals(object obj);
    public static bool op_Equality(MethodInfo left, MethodInfo right);
    public static bool op_Inequality(MethodInfo left, MethodInfo right);
    public virtual Type[] GetGenericArguments();
    public virtual MethodInfo GetGenericMethodDefinition();
    public virtual int GetHashCode();
    public virtual MethodInfo MakeGenericMethod(Type[] typeArguments);
    public virtual MemberTypes get_MemberType();
    public abstract virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
}
public class System.Reflection.Missing : object {
    public static Missing Value;
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
public abstract class System.Reflection.Module : object {
    public static TypeFilter FilterTypeName;
    public static TypeFilter FilterTypeNameIgnoreCase;
    public Assembly Assembly { get; }
    public ModuleHandle ModuleHandle { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public string FullyQualifiedName { get; }
    public int MDStreamVersion { get; }
    public int MetadataToken { get; }
    public string Name { get; }
    public Guid ModuleVersionId { get; }
    public string ScopeName { get; }
    public virtual Assembly get_Assembly();
    public ModuleHandle get_ModuleHandle();
    public virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public virtual string get_FullyQualifiedName();
    public virtual int get_MDStreamVersion();
    public virtual int get_MetadataToken();
    public virtual string get_Name();
    public virtual bool Equals(object o);
    public static bool op_Equality(Module left, Module right);
    public static bool op_Inequality(Module left, Module right);
    public virtual int GetHashCode();
    public virtual Type GetType(string className, bool throwOnError, bool ignoreCase);
    public virtual string ToString();
    public virtual Guid get_ModuleVersionId();
    public virtual string get_ScopeName();
    public virtual Type[] FindTypes(TypeFilter filter, object filterCriteria);
    public FieldInfo GetField(string name);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public FieldInfo[] GetFields();
    public virtual FieldInfo[] GetFields(BindingFlags bindingFlags);
    public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public MethodInfo GetMethod(string name);
    public MethodInfo GetMethod(string name, Type[] types);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public MethodInfo[] GetMethods();
    public virtual MethodInfo[] GetMethods(BindingFlags bindingFlags);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual void GetPEKind(PortableExecutableKinds& peKind, ImageFileMachine& machine);
    public virtual Type GetType(string className);
    public virtual Type GetType(string className, bool ignoreCase);
    public virtual Type[] GetTypes();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual bool IsResource();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public FieldInfo ResolveField(int metadataToken);
    public virtual FieldInfo ResolveField(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public MemberInfo ResolveMember(int metadataToken);
    public virtual MemberInfo ResolveMember(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public MethodBase ResolveMethod(int metadataToken);
    public virtual MethodBase ResolveMethod(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual Byte[] ResolveSignature(int metadataToken);
    public virtual string ResolveString(int metadataToken);
    public Type ResolveType(int metadataToken);
    public virtual Type ResolveType(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
}
public class System.Reflection.ModuleResolveEventHandler : MulticastDelegate {
    public ModuleResolveEventHandler(object object, IntPtr method);
    public virtual Module Invoke(object sender, ResolveEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ResolveEventArgs e, AsyncCallback callback, object object);
    public virtual Module EndInvoke(IAsyncResult result);
}
public class System.Reflection.ObfuscateAssemblyAttribute : Attribute {
    public bool AssemblyIsPrivate { get; }
    public bool StripAfterObfuscation { get; public set; }
    public ObfuscateAssemblyAttribute(bool assemblyIsPrivate);
    public bool get_AssemblyIsPrivate();
    public bool get_StripAfterObfuscation();
    public void set_StripAfterObfuscation(bool value);
}
public class System.Reflection.ObfuscationAttribute : Attribute {
    public bool StripAfterObfuscation { get; public set; }
    public bool Exclude { get; public set; }
    public bool ApplyToMembers { get; public set; }
    public string Feature { get; public set; }
    public bool get_StripAfterObfuscation();
    public void set_StripAfterObfuscation(bool value);
    public bool get_Exclude();
    public void set_Exclude(bool value);
    public bool get_ApplyToMembers();
    public void set_ApplyToMembers(bool value);
    public string get_Feature();
    public void set_Feature(string value);
}
[FlagsAttribute]
public enum System.Reflection.ParameterAttributes : Enum {
    public int value__;
    public static ParameterAttributes HasDefault;
    public static ParameterAttributes HasFieldMarshal;
    public static ParameterAttributes In;
    public static ParameterAttributes Lcid;
    public static ParameterAttributes None;
    public static ParameterAttributes Optional;
    public static ParameterAttributes Out;
    public static ParameterAttributes Reserved3;
    public static ParameterAttributes Reserved4;
    public static ParameterAttributes ReservedMask;
    public static ParameterAttributes Retval;
}
public class System.Reflection.ParameterInfo : object {
    protected string NameImpl;
    protected Type ClassImpl;
    protected int PositionImpl;
    protected ParameterAttributes AttrsImpl;
    protected object DefaultValueImpl;
    protected MemberInfo MemberImpl;
    public ParameterAttributes Attributes { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public object DefaultValue { get; }
    public bool HasDefaultValue { get; }
    public bool IsIn { get; }
    public bool IsLcid { get; }
    public bool IsOptional { get; }
    public bool IsOut { get; }
    public bool IsRetval { get; }
    public MemberInfo Member { get; }
    public int MetadataToken { get; }
    public string Name { get; }
    public Type ParameterType { get; }
    public int Position { get; }
    public object RawDefaultValue { get; }
    public virtual ParameterAttributes get_Attributes();
    public virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public virtual object get_DefaultValue();
    public virtual bool get_HasDefaultValue();
    public bool get_IsIn();
    public bool get_IsLcid();
    public bool get_IsOptional();
    public bool get_IsOut();
    public bool get_IsRetval();
    public virtual MemberInfo get_Member();
    public virtual int get_MetadataToken();
    public virtual string get_Name();
    public virtual Type get_ParameterType();
    public virtual int get_Position();
    public virtual Type[] GetOptionalCustomModifiers();
    public sealed virtual object GetRealObject(StreamingContext context);
    public virtual Type[] GetRequiredCustomModifiers();
    public virtual object get_RawDefaultValue();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
public class System.Reflection.ParameterModifier : ValueType {
    public bool Item { get; public set; }
    public ParameterModifier(int parameterCount);
    public bool get_Item(int index);
    public void set_Item(int index, bool value);
}
[CLSCompliantAttribute("False")]
public class System.Reflection.Pointer : object {
    [SecurityCriticalAttribute]
public static object Box(Void* ptr, Type type);
    [SecurityCriticalAttribute]
public static Void* Unbox(object ptr);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
[FlagsAttribute]
public enum System.Reflection.PortableExecutableKinds : Enum {
    public int value__;
    public static PortableExecutableKinds NotAPortableExecutableImage;
    public static PortableExecutableKinds ILOnly;
    public static PortableExecutableKinds Required32Bit;
    public static PortableExecutableKinds PE32Plus;
    public static PortableExecutableKinds Unmanaged32Bit;
    public static PortableExecutableKinds Preferred32Bit;
}
public enum System.Reflection.ProcessorArchitecture : Enum {
    public int value__;
    public static ProcessorArchitecture Amd64;
    public static ProcessorArchitecture Arm;
    public static ProcessorArchitecture IA64;
    public static ProcessorArchitecture MSIL;
    public static ProcessorArchitecture None;
    public static ProcessorArchitecture X86;
}
[FlagsAttribute]
public enum System.Reflection.PropertyAttributes : Enum {
    public int value__;
    public static PropertyAttributes HasDefault;
    public static PropertyAttributes None;
    public static PropertyAttributes Reserved2;
    public static PropertyAttributes Reserved3;
    public static PropertyAttributes Reserved4;
    public static PropertyAttributes ReservedMask;
    public static PropertyAttributes RTSpecialName;
    public static PropertyAttributes SpecialName;
}
public abstract class System.Reflection.PropertyInfo : MemberInfo {
    public PropertyAttributes Attributes { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public MethodInfo GetMethod { get; }
    public bool IsSpecialName { get; }
    public Type PropertyType { get; }
    public MethodInfo SetMethod { get; }
    public MemberTypes MemberType { get; }
    public abstract virtual PropertyAttributes get_Attributes();
    public abstract virtual bool get_CanRead();
    public abstract virtual bool get_CanWrite();
    public virtual MethodInfo get_GetMethod();
    public bool get_IsSpecialName();
    public abstract virtual Type get_PropertyType();
    public virtual MethodInfo get_SetMethod();
    public virtual bool Equals(object obj);
    public static bool op_Equality(PropertyInfo left, PropertyInfo right);
    public static bool op_Inequality(PropertyInfo left, PropertyInfo right);
    public virtual object GetConstantValue();
    public virtual int GetHashCode();
    public abstract virtual ParameterInfo[] GetIndexParameters();
    public object GetValue(object obj);
    public virtual object GetValue(object obj, Object[] index);
    public abstract virtual object GetValue(object obj, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public void SetValue(object obj, object value);
    public virtual void SetValue(object obj, object value, Object[] index);
    public abstract virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public virtual MemberTypes get_MemberType();
    public MethodInfo[] GetAccessors();
    public abstract virtual MethodInfo[] GetAccessors(bool nonPublic);
    public MethodInfo GetGetMethod();
    public abstract virtual MethodInfo GetGetMethod(bool nonPublic);
    public MethodInfo GetSetMethod();
    public abstract virtual MethodInfo GetSetMethod(bool nonPublic);
    public virtual Type[] GetOptionalCustomModifiers();
    public virtual object GetRawConstantValue();
    public virtual Type[] GetRequiredCustomModifiers();
}
public abstract class System.Reflection.ReflectionContext : object {
    public virtual TypeInfo GetTypeForObject(object value);
    public abstract virtual Assembly MapAssembly(Assembly assembly);
    public abstract virtual TypeInfo MapType(TypeInfo type);
}
public class System.Reflection.ReflectionTypeLoadException : SystemException {
    public Exception[] LoaderExceptions { get; }
    public Type[] Types { get; }
    public ReflectionTypeLoadException(Type[] classes, Exception[] exceptions);
    public ReflectionTypeLoadException(Type[] classes, Exception[] exceptions, string message);
    public Exception[] get_LoaderExceptions();
    public Type[] get_Types();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[FlagsAttribute]
public enum System.Reflection.ResourceAttributes : Enum {
    public int value__;
    public static ResourceAttributes Private;
    public static ResourceAttributes Public;
}
[FlagsAttribute]
public enum System.Reflection.ResourceLocation : Enum {
    public int value__;
    public static ResourceLocation ContainedInAnotherAssembly;
    public static ResourceLocation ContainedInManifestFile;
    public static ResourceLocation Embedded;
}
[ExtensionAttribute]
public static class System.Reflection.RuntimeReflectionExtensions : object {
    [ExtensionAttribute]
public static MethodInfo GetMethodInfo(Delegate del);
    [ExtensionAttribute]
public static MethodInfo GetRuntimeBaseDefinition(MethodInfo method);
    [ExtensionAttribute]
public static EventInfo GetRuntimeEvent(Type type, string name);
    [ExtensionAttribute]
public static IEnumerable`1<EventInfo> GetRuntimeEvents(Type type);
    [ExtensionAttribute]
public static FieldInfo GetRuntimeField(Type type, string name);
    [ExtensionAttribute]
public static IEnumerable`1<FieldInfo> GetRuntimeFields(Type type);
    [ExtensionAttribute]
public static InterfaceMapping GetRuntimeInterfaceMap(TypeInfo typeInfo, Type interfaceType);
    [ExtensionAttribute]
public static MethodInfo GetRuntimeMethod(Type type, string name, Type[] parameters);
    [ExtensionAttribute]
public static IEnumerable`1<MethodInfo> GetRuntimeMethods(Type type);
    [ExtensionAttribute]
public static IEnumerable`1<PropertyInfo> GetRuntimeProperties(Type type);
    [ExtensionAttribute]
public static PropertyInfo GetRuntimeProperty(Type type, string name);
}
public class System.Reflection.StrongNameKeyPair : object {
    public Byte[] PublicKey { get; }
    public StrongNameKeyPair(Byte[] keyPairArray);
    public StrongNameKeyPair(FileStream keyPairFile);
    protected StrongNameKeyPair(SerializationInfo info, StreamingContext context);
    public StrongNameKeyPair(string keyPairContainer);
    [SecuritySafeCriticalAttribute]
public Byte[] get_PublicKey();
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.Reflection.TargetException : ApplicationException {
    public TargetException(string message);
    public TargetException(string message, Exception inner);
    protected TargetException(SerializationInfo info, StreamingContext context);
}
public class System.Reflection.TargetInvocationException : ApplicationException {
    public TargetInvocationException(Exception inner);
    public TargetInvocationException(string message, Exception inner);
}
public class System.Reflection.TargetParameterCountException : ApplicationException {
    public TargetParameterCountException(string message);
    public TargetParameterCountException(string message, Exception inner);
}
[FlagsAttribute]
public enum System.Reflection.TypeAttributes : Enum {
    public int value__;
    public static TypeAttributes Abstract;
    public static TypeAttributes AnsiClass;
    public static TypeAttributes AutoClass;
    public static TypeAttributes AutoLayout;
    public static TypeAttributes BeforeFieldInit;
    public static TypeAttributes Class;
    public static TypeAttributes ClassSemanticsMask;
    public static TypeAttributes CustomFormatClass;
    public static TypeAttributes CustomFormatMask;
    public static TypeAttributes ExplicitLayout;
    public static TypeAttributes HasSecurity;
    public static TypeAttributes Import;
    public static TypeAttributes Interface;
    public static TypeAttributes LayoutMask;
    public static TypeAttributes NestedAssembly;
    public static TypeAttributes NestedFamANDAssem;
    public static TypeAttributes NestedFamily;
    public static TypeAttributes NestedFamORAssem;
    public static TypeAttributes NestedPrivate;
    public static TypeAttributes NestedPublic;
    public static TypeAttributes NotPublic;
    public static TypeAttributes Public;
    public static TypeAttributes ReservedMask;
    public static TypeAttributes RTSpecialName;
    public static TypeAttributes Sealed;
    public static TypeAttributes SequentialLayout;
    public static TypeAttributes Serializable;
    public static TypeAttributes SpecialName;
    public static TypeAttributes StringFormatMask;
    public static TypeAttributes UnicodeClass;
    public static TypeAttributes VisibilityMask;
    public static TypeAttributes WindowsRuntime;
}
public class System.Reflection.TypeDelegator : TypeInfo {
    protected Type typeImpl;
    public Guid GUID { get; }
    public int MetadataToken { get; }
    public Module Module { get; }
    public Assembly Assembly { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public string Name { get; }
    public string FullName { get; }
    public string Namespace { get; }
    public string AssemblyQualifiedName { get; }
    public Type BaseType { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsTypeDefinition { get; }
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    public Type UnderlyingSystemType { get; }
    public TypeDelegator(Type delegatingType);
    public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    public virtual Guid get_GUID();
    public virtual int get_MetadataToken();
    public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public virtual Module get_Module();
    public virtual Assembly get_Assembly();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public virtual string get_Name();
    public virtual string get_FullName();
    public virtual string get_Namespace();
    public virtual string get_AssemblyQualifiedName();
    public virtual Type get_BaseType();
    protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public virtual Type GetInterface(string name, bool ignoreCase);
    public virtual Type[] GetInterfaces();
    public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents();
    protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    protected virtual bool IsArrayImpl();
    protected virtual bool IsPrimitiveImpl();
    protected virtual bool IsByRefImpl();
    protected virtual bool IsPointerImpl();
    protected virtual bool IsValueTypeImpl();
    protected virtual bool IsCOMObjectImpl();
    public virtual bool get_IsConstructedGenericType();
    public virtual bool get_IsTypeDefinition();
    public virtual bool get_IsSZArray();
    public virtual bool get_IsVariableBoundArray();
    public virtual Type GetElementType();
    protected virtual bool HasElementTypeImpl();
    public virtual Type get_UnderlyingSystemType();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
}
public class System.Reflection.TypeFilter : MulticastDelegate {
    public TypeFilter(object object, IntPtr method);
    public virtual bool Invoke(Type m, object filterCriteria);
    public virtual IAsyncResult BeginInvoke(Type m, object filterCriteria, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public abstract class System.Reflection.TypeInfo : Type {
    public IEnumerable`1<ConstructorInfo> DeclaredConstructors { get; }
    public IEnumerable`1<EventInfo> DeclaredEvents { get; }
    public IEnumerable`1<FieldInfo> DeclaredFields { get; }
    public IEnumerable`1<MemberInfo> DeclaredMembers { get; }
    public IEnumerable`1<MethodInfo> DeclaredMethods { get; }
    public IEnumerable`1<TypeInfo> DeclaredNestedTypes { get; }
    public IEnumerable`1<PropertyInfo> DeclaredProperties { get; }
    public Type[] GenericTypeParameters { get; }
    public IEnumerable`1<Type> ImplementedInterfaces { get; }
    public virtual IEnumerable`1<ConstructorInfo> get_DeclaredConstructors();
    public virtual IEnumerable`1<EventInfo> get_DeclaredEvents();
    public virtual IEnumerable`1<FieldInfo> get_DeclaredFields();
    public virtual IEnumerable`1<MemberInfo> get_DeclaredMembers();
    public virtual IEnumerable`1<MethodInfo> get_DeclaredMethods();
    public virtual IEnumerable`1<TypeInfo> get_DeclaredNestedTypes();
    public virtual IEnumerable`1<PropertyInfo> get_DeclaredProperties();
    public virtual Type[] get_GenericTypeParameters();
    public virtual IEnumerable`1<Type> get_ImplementedInterfaces();
    public virtual Type AsType();
    public virtual EventInfo GetDeclaredEvent(string name);
    public virtual FieldInfo GetDeclaredField(string name);
    public virtual MethodInfo GetDeclaredMethod(string name);
    public virtual IEnumerable`1<MethodInfo> GetDeclaredMethods(string name);
    public virtual TypeInfo GetDeclaredNestedType(string name);
    public virtual PropertyInfo GetDeclaredProperty(string name);
    public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    private sealed virtual override TypeInfo System.Reflection.IReflectableType.GetTypeInfo();
}
public class System.ResolveEventArgs : EventArgs {
    public string Name { get; }
    public Assembly RequestingAssembly { get; }
    public ResolveEventArgs(string name);
    public ResolveEventArgs(string name, Assembly requestingAssembly);
    public string get_Name();
    public Assembly get_RequestingAssembly();
}
[AttributeUsageAttribute("1")]
public class System.Runtime.AssemblyTargetedPatchBandAttribute : Attribute {
    public string TargetedPatchBand { get; }
    public AssemblyTargetedPatchBandAttribute(string targetedPatchBand);
    public string get_TargetedPatchBand();
}
[AttributeUsageAttribute("32767")]
internal class System.Runtime.CompilerServices.__BlockReflectionAttribute : Attribute {
}
[AttributeUsageAttribute("256")]
public class System.Runtime.CompilerServices.AccessedThroughPropertyAttribute : Attribute {
    public string PropertyName { get; }
    public AccessedThroughPropertyAttribute(string propertyName);
    public string get_PropertyName();
}
[AttributeUsageAttribute("64")]
public class System.Runtime.CompilerServices.AsyncStateMachineAttribute : StateMachineAttribute {
    public AsyncStateMachineAttribute(Type stateMachineType);
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.CompilerServices.CallerFilePathAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.CompilerServices.CallerLineNumberAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.CompilerServices.CallerMemberNameAttribute : Attribute {
}
[FlagsAttribute]
public enum System.Runtime.CompilerServices.CompilationRelaxations : Enum {
    public int value__;
    public static CompilationRelaxations NoStringInterning;
}
[AttributeUsageAttribute("71")]
public class System.Runtime.CompilerServices.CompilationRelaxationsAttribute : Attribute {
    public int CompilationRelaxations { get; }
    public CompilationRelaxationsAttribute(int relaxations);
    public CompilationRelaxationsAttribute(CompilationRelaxations relaxations);
    public int get_CompilationRelaxations();
}
[AttributeUsageAttribute("32767")]
public class System.Runtime.CompilerServices.CompilerGeneratedAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
public class System.Runtime.CompilerServices.CompilerGlobalScopeAttribute : Attribute {
}
public class System.Runtime.CompilerServices.ConditionalWeakTable`2 : object {
    public void Add(TKey key, TValue value);
    public void AddOrUpdate(TKey key, TValue value);
    public void Clear();
    protected virtual override void Finalize();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public TValue GetOrCreateValue(TKey key);
    public TValue GetValue(TKey key, CreateValueCallback<TKey, TValue> createValueCallback);
    public bool Remove(TKey key);
    public bool TryGetValue(TKey key, TValue& value);
}
public class System.Runtime.CompilerServices.ConfiguredTaskAwaitable : ValueType {
    public ConfiguredTaskAwaiter GetAwaiter();
}
public class System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1 : ValueType {
    public ConfiguredTaskAwaiter<TResult> GetAwaiter();
}
[AttributeUsageAttribute("2304")]
public abstract class System.Runtime.CompilerServices.CustomConstantAttribute : Attribute {
    public object Value { get; }
    public abstract virtual object get_Value();
}
[AttributeUsageAttribute("2304")]
public class System.Runtime.CompilerServices.DateTimeConstantAttribute : CustomConstantAttribute {
    public object Value { get; }
    public DateTimeConstantAttribute(long ticks);
    public virtual object get_Value();
}
[AttributeUsageAttribute("2304")]
public class System.Runtime.CompilerServices.DecimalConstantAttribute : Attribute {
    public decimal Value { get; }
    public DecimalConstantAttribute(byte scale, byte sign, int hi, int mid, int low);
    [CLSCompliantAttribute("False")]
public DecimalConstantAttribute(byte scale, byte sign, UInt32 hi, UInt32 mid, UInt32 low);
    public decimal get_Value();
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.DefaultDependencyAttribute : Attribute {
    public LoadHint LoadHint { get; }
    public DefaultDependencyAttribute(LoadHint loadHintArgument);
    public LoadHint get_LoadHint();
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.DependencyAttribute : Attribute {
    public string DependentAssembly { get; }
    public LoadHint LoadHint { get; }
    public DependencyAttribute(string dependentAssemblyArgument, LoadHint loadHintArgument);
    public string get_DependentAssembly();
    public LoadHint get_LoadHint();
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.DisablePrivateReflectionAttribute : Attribute {
}
public class System.Runtime.CompilerServices.DiscardableAttribute : Attribute {
}
[AttributeUsageAttribute("69")]
public class System.Runtime.CompilerServices.ExtensionAttribute : Attribute {
}
[AttributeUsageAttribute("256")]
public class System.Runtime.CompilerServices.FixedAddressValueTypeAttribute : Attribute {
}
[AttributeUsageAttribute("256")]
public class System.Runtime.CompilerServices.FixedBufferAttribute : Attribute {
    public Type ElementType { get; }
    public int Length { get; }
    public FixedBufferAttribute(Type elementType, int length);
    public Type get_ElementType();
    public int get_Length();
}
public static class System.Runtime.CompilerServices.FormattableStringFactory : object {
    public static FormattableString Create(string format, Object[] arguments);
}
public interface System.Runtime.CompilerServices.ICriticalNotifyCompletion {
    [SecurityCriticalAttribute]
public abstract virtual void UnsafeOnCompleted(Action continuation);
}
[AttributeUsageAttribute("128")]
public class System.Runtime.CompilerServices.IndexerNameAttribute : Attribute {
    public IndexerNameAttribute(string indexerName);
}
public interface System.Runtime.CompilerServices.INotifyCompletion {
    public abstract virtual void OnCompleted(Action continuation);
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.InternalsVisibleToAttribute : Attribute {
    public bool AllInternalsVisible { get; public set; }
    public string AssemblyName { get; }
    public InternalsVisibleToAttribute(string assemblyName);
    public bool get_AllInternalsVisible();
    public void set_AllInternalsVisible(bool value);
    public string get_AssemblyName();
}
[EditorBrowsableAttribute("1")]
[AttributeUsageAttribute("8")]
public class System.Runtime.CompilerServices.IsByRefLikeAttribute : Attribute {
}
public static class System.Runtime.CompilerServices.IsConst : object {
}
[EditorBrowsableAttribute("1")]
[AttributeUsageAttribute("32767")]
public class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
public interface System.Runtime.CompilerServices.IStrongBox {
    public object Value { get; public set; }
    public abstract virtual object get_Value();
    public abstract virtual void set_Value(object value);
}
public static class System.Runtime.CompilerServices.IsVolatile : object {
}
[AttributeUsageAttribute("64")]
public class System.Runtime.CompilerServices.IteratorStateMachineAttribute : StateMachineAttribute {
    public IteratorStateMachineAttribute(Type stateMachineType);
}
[DefaultMemberAttribute("Item")]
public interface System.Runtime.CompilerServices.ITuple {
    public int Length { get; }
    public object Item { get; }
    public abstract virtual int get_Length();
    public abstract virtual object get_Item(int index);
}
public enum System.Runtime.CompilerServices.LoadHint : Enum {
    public int value__;
    public static LoadHint Always;
    public static LoadHint Default;
    public static LoadHint Sometimes;
}
public enum System.Runtime.CompilerServices.MethodCodeType : Enum {
    public int value__;
    public static MethodCodeType IL;
    public static MethodCodeType Native;
    public static MethodCodeType OPTIL;
    public static MethodCodeType Runtime;
}
[AttributeUsageAttribute("96")]
public class System.Runtime.CompilerServices.MethodImplAttribute : Attribute {
    public MethodCodeType MethodCodeType;
    public MethodImplOptions Value { get; }
    public MethodImplAttribute(short value);
    public MethodImplAttribute(MethodImplOptions methodImplOptions);
    public MethodImplOptions get_Value();
}
[FlagsAttribute]
public enum System.Runtime.CompilerServices.MethodImplOptions : Enum {
    public int value__;
    public static MethodImplOptions AggressiveInlining;
    public static MethodImplOptions ForwardRef;
    public static MethodImplOptions InternalCall;
    public static MethodImplOptions NoInlining;
    public static MethodImplOptions NoOptimization;
    public static MethodImplOptions PreserveSig;
    public static MethodImplOptions Synchronized;
    public static MethodImplOptions Unmanaged;
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.ReferenceAssemblyAttribute : Attribute {
    public string Description { get; }
    public ReferenceAssemblyAttribute(string description);
    public string get_Description();
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.RuntimeCompatibilityAttribute : Attribute {
    public bool WrapNonExceptionThrows { get; public set; }
    public bool get_WrapNonExceptionThrows();
    public void set_WrapNonExceptionThrows(bool value);
}
public static class System.Runtime.CompilerServices.RuntimeFeature : object {
    public static bool IsSupported(string feature);
}
public static class System.Runtime.CompilerServices.RuntimeHelpers : object {
    public static int OffsetToStringData { get; }
    public static bool Equals(object o1, object o2);
    public static int get_OffsetToStringData();
    public static void EnsureSufficientExecutionStack();
    public static int GetHashCode(object o);
    public static object GetObjectValue(object obj);
    public static void InitializeArray(Array array, RuntimeFieldHandle fldHandle);
    public static void RunClassConstructor(RuntimeTypeHandle type);
    public static void RunModuleConstructor(ModuleHandle module);
    public static void ExecuteCodeWithGuaranteedCleanup(TryCode code, CleanupCode backoutCode, object userData);
    [ReliabilityContractAttribute("3", "1")]
[SecurityCriticalAttribute]
public static void PrepareConstrainedRegions();
    [ReliabilityContractAttribute("3", "1")]
[SecurityCriticalAttribute]
public static void PrepareConstrainedRegionsNoOP();
    public static void PrepareContractedDelegate(Delegate d);
    public static void PrepareDelegate(Delegate d);
    [SecurityCriticalAttribute]
public static void PrepareMethod(RuntimeMethodHandle method);
    [SecurityCriticalAttribute]
public static void PrepareMethod(RuntimeMethodHandle method, RuntimeTypeHandle[] instantiation);
    [SecurityCriticalAttribute]
public static void ProbeForSufficientStack();
    public static bool TryEnsureSufficientExecutionStack();
    public static object GetUninitializedObject(Type type);
    public static bool IsReferenceOrContainsReferences();
}
public class System.Runtime.CompilerServices.RuntimeWrappedException : Exception {
    public object WrappedException { get; }
    public object get_WrappedException();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("972")]
public class System.Runtime.CompilerServices.SpecialNameAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class System.Runtime.CompilerServices.StateMachineAttribute : Attribute {
    public Type StateMachineType { get; }
    public StateMachineAttribute(Type stateMachineType);
    public Type get_StateMachineType();
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.StringFreezingAttribute : Attribute {
}
public class System.Runtime.CompilerServices.StrongBox`1 : object {
    public T Value;
    private object System.Runtime.CompilerServices.IStrongBox.Value { get; private set; }
    public StrongBox`1(T value);
    private sealed virtual override object System.Runtime.CompilerServices.IStrongBox.get_Value();
    private sealed virtual override void System.Runtime.CompilerServices.IStrongBox.set_Value(object value);
}
[AttributeUsageAttribute("3")]
public class System.Runtime.CompilerServices.SuppressIldasmAttribute : Attribute {
}
public class System.Runtime.CompilerServices.TaskAwaiter : ValueType {
    public bool IsCompleted { get; }
    public bool get_IsCompleted();
    public void GetResult();
    public sealed virtual void OnCompleted(Action continuation);
    [SecurityCriticalAttribute]
public sealed virtual void UnsafeOnCompleted(Action continuation);
}
public class System.Runtime.CompilerServices.TaskAwaiter`1 : ValueType {
    public bool IsCompleted { get; }
    public bool get_IsCompleted();
    public TResult GetResult();
    public sealed virtual void OnCompleted(Action continuation);
    [SecurityCriticalAttribute]
public sealed virtual void UnsafeOnCompleted(Action continuation);
}
[CLSCompliantAttribute("False")]
[AttributeUsageAttribute("11148")]
public class System.Runtime.CompilerServices.TupleElementNamesAttribute : Attribute {
    public IList`1<string> TransformNames { get; }
    public TupleElementNamesAttribute(String[] transformNames);
    public IList`1<string> get_TransformNames();
}
[AttributeUsageAttribute("5148")]
public class System.Runtime.CompilerServices.TypeForwardedFromAttribute : Attribute {
    public string AssemblyFullName { get; }
    public TypeForwardedFromAttribute(string assemblyFullName);
    public string get_AssemblyFullName();
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.TypeForwardedToAttribute : Attribute {
    public Type Destination { get; }
    public TypeForwardedToAttribute(Type destination);
    public Type get_Destination();
}
[AttributeUsageAttribute("8")]
public class System.Runtime.CompilerServices.UnsafeValueTypeAttribute : Attribute {
}
public class System.Runtime.CompilerServices.YieldAwaitable : ValueType {
    public YieldAwaiter GetAwaiter();
}
public enum System.Runtime.ConstrainedExecution.Cer : Enum {
    public int value__;
    public static Cer MayFail;
    public static Cer None;
    public static Cer Success;
}
public enum System.Runtime.ConstrainedExecution.Consistency : Enum {
    public int value__;
    public static Consistency MayCorruptAppDomain;
    public static Consistency MayCorruptInstance;
    public static Consistency MayCorruptProcess;
    public static Consistency WillNotCorruptState;
}
public abstract class System.Runtime.ConstrainedExecution.CriticalFinalizerObject : object {
    protected virtual override void Finalize();
}
[AttributeUsageAttribute("96")]
public class System.Runtime.ConstrainedExecution.PrePrepareMethodAttribute : Attribute {
}
[AttributeUsageAttribute("1133")]
public class System.Runtime.ConstrainedExecution.ReliabilityContractAttribute : Attribute {
    public Cer Cer { get; }
    public Consistency ConsistencyGuarantee { get; }
    public ReliabilityContractAttribute(Consistency consistencyGuarantee, Cer cer);
    public Cer get_Cer();
    public Consistency get_ConsistencyGuarantee();
}
public class System.Runtime.ExceptionServices.ExceptionDispatchInfo : object {
    public Exception SourceException { get; }
    public Exception get_SourceException();
    public static ExceptionDispatchInfo Capture(Exception source);
    public void Throw();
    public static void Throw(Exception source);
}
public class System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs : EventArgs {
    public Exception Exception { get; }
    public FirstChanceExceptionEventArgs(Exception exception);
    public Exception get_Exception();
}
[AttributeUsageAttribute("64")]
public class System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute : Attribute {
}
public enum System.Runtime.GCLargeObjectHeapCompactionMode : Enum {
    public int value__;
    public static GCLargeObjectHeapCompactionMode CompactOnce;
    public static GCLargeObjectHeapCompactionMode Default;
}
public enum System.Runtime.GCLatencyMode : Enum {
    public int value__;
    public static GCLatencyMode Batch;
    public static GCLatencyMode Interactive;
    public static GCLatencyMode LowLatency;
    public static GCLatencyMode SustainedLowLatency;
    public static GCLatencyMode NoGCRegion;
}
public static class System.Runtime.GCSettings : object {
    public static bool IsServerGC { get; }
    public static GCLargeObjectHeapCompactionMode LargeObjectHeapCompactionMode { get; public set; }
    public static GCLatencyMode LatencyMode { get; public set; }
    public static bool get_IsServerGC();
    public static GCLargeObjectHeapCompactionMode get_LargeObjectHeapCompactionMode();
    [SecurityCriticalAttribute]
public static void set_LargeObjectHeapCompactionMode(GCLargeObjectHeapCompactionMode value);
    public static GCLatencyMode get_LatencyMode();
    [SecurityCriticalAttribute]
public static void set_LatencyMode(GCLatencyMode value);
}
public enum System.Runtime.InteropServices.CharSet : Enum {
    public int value__;
    public static CharSet Ansi;
    public static CharSet Auto;
    public static CharSet None;
    public static CharSet Unicode;
}
[AttributeUsageAttribute("5597")]
public class System.Runtime.InteropServices.ComVisibleAttribute : Attribute {
    public bool Value { get; }
    public ComVisibleAttribute(bool visibility);
    public bool get_Value();
}
public abstract class System.Runtime.InteropServices.CriticalHandle : CriticalFinalizerObject {
    protected IntPtr handle;
    public bool IsClosed { get; }
    public bool IsInvalid { get; }
    protected CriticalHandle(IntPtr invalidHandleValue);
    public bool get_IsClosed();
    public abstract virtual bool get_IsInvalid();
    public void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    protected abstract virtual bool ReleaseHandle();
    protected void SetHandle(IntPtr handle);
    public void SetHandleAsInvalid();
}
public class System.Runtime.InteropServices.ExternalException : SystemException {
    [CompilerGeneratedAttribute]
private int <ErrorCode>k__BackingField;
    public int ErrorCode { get; }
    public ExternalException(string message);
    public ExternalException(string message, Exception inner);
    public ExternalException(string message, int errorCode);
    protected ExternalException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public virtual int get_ErrorCode();
    public virtual string ToString();
}
[AttributeUsageAttribute("256")]
public class System.Runtime.InteropServices.FieldOffsetAttribute : Attribute {
    public int Value { get; }
    public FieldOffsetAttribute(int offset);
    public int get_Value();
}
public enum System.Runtime.InteropServices.LayoutKind : Enum {
    public int value__;
    public static LayoutKind Auto;
    public static LayoutKind Explicit;
    public static LayoutKind Sequential;
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.InteropServices.OutAttribute : Attribute {
}
[SecurityCriticalAttribute]
public abstract class System.Runtime.InteropServices.SafeHandle : CriticalFinalizerObject {
    protected IntPtr handle;
    public bool IsClosed { get; }
    public bool IsInvalid { get; }
    protected SafeHandle(IntPtr invalidHandleValue, bool ownsHandle);
    public bool get_IsClosed();
    public abstract virtual bool get_IsInvalid();
    [SecurityCriticalAttribute]
public void Close();
    [SecurityCriticalAttribute]
public void DangerousAddRef(Boolean& success);
    public IntPtr DangerousGetHandle();
    [SecurityCriticalAttribute]
public void DangerousRelease();
    [SecuritySafeCriticalAttribute]
public sealed virtual void Dispose();
    [SecurityCriticalAttribute]
protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    protected abstract virtual bool ReleaseHandle();
    protected void SetHandle(IntPtr handle);
    [SecurityCriticalAttribute]
public void SetHandleAsInvalid();
}
[AttributeUsageAttribute("12")]
public class System.Runtime.InteropServices.StructLayoutAttribute : Attribute {
    public CharSet CharSet;
    public int Pack;
    public int Size;
    public LayoutKind Value { get; }
    public StructLayoutAttribute(short layoutKind);
    public StructLayoutAttribute(LayoutKind layoutKind);
    public LayoutKind get_Value();
}
public class System.Runtime.MemoryFailPoint : CriticalFinalizerObject {
    public MemoryFailPoint(int sizeInMegabytes);
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
}
public interface System.Runtime.Serialization.IDeserializationCallback {
    public abstract virtual void OnDeserialization(object sender);
}
[CLSCompliantAttribute("False")]
public interface System.Runtime.Serialization.IFormatterConverter {
    public abstract virtual object Convert(object value, Type type);
    public abstract virtual object Convert(object value, TypeCode typeCode);
    public abstract virtual bool ToBoolean(object value);
    public abstract virtual char ToChar(object value);
    [CLSCompliantAttribute("False")]
public abstract virtual sbyte ToSByte(object value);
    public abstract virtual byte ToByte(object value);
    public abstract virtual short ToInt16(object value);
    [CLSCompliantAttribute("False")]
public abstract virtual ushort ToUInt16(object value);
    public abstract virtual int ToInt32(object value);
    [CLSCompliantAttribute("False")]
public abstract virtual UInt32 ToUInt32(object value);
    public abstract virtual long ToInt64(object value);
    [CLSCompliantAttribute("False")]
public abstract virtual ulong ToUInt64(object value);
    public abstract virtual float ToSingle(object value);
    public abstract virtual double ToDouble(object value);
    public abstract virtual decimal ToDecimal(object value);
    public abstract virtual DateTime ToDateTime(object value);
    public abstract virtual string ToString(object value);
}
public interface System.Runtime.Serialization.IObjectReference {
    public abstract virtual object GetRealObject(StreamingContext context);
}
public interface System.Runtime.Serialization.ISafeSerializationData {
    public abstract virtual void CompleteDeserialization(object deserialized);
}
public interface System.Runtime.Serialization.ISerializable {
    public abstract virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("64")]
public class System.Runtime.Serialization.OnDeserializedAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class System.Runtime.Serialization.OnDeserializingAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class System.Runtime.Serialization.OnSerializedAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class System.Runtime.Serialization.OnSerializingAttribute : Attribute {
}
[AttributeUsageAttribute("256")]
public class System.Runtime.Serialization.OptionalFieldAttribute : Attribute {
    public int VersionAdded { get; public set; }
    public int get_VersionAdded();
    public void set_VersionAdded(int value);
}
public class System.Runtime.Serialization.SafeSerializationEventArgs : EventArgs {
    public StreamingContext StreamingContext { get; }
    public StreamingContext get_StreamingContext();
    public void AddSerializedState(ISafeSerializationData serializedState);
}
public class System.Runtime.Serialization.SerializationEntry : ValueType {
    public string Name { get; }
    public Type ObjectType { get; }
    public object Value { get; }
    public string get_Name();
    public Type get_ObjectType();
    public object get_Value();
}
public class System.Runtime.Serialization.SerializationException : SystemException {
    public SerializationException(string message);
    public SerializationException(string message, Exception innerException);
    protected SerializationException(SerializationInfo info, StreamingContext context);
}
public class System.Runtime.Serialization.SerializationInfo : object {
    public string AssemblyName { get; public set; }
    public string FullTypeName { get; public set; }
    public int MemberCount { get; }
    public Type ObjectType { get; }
    public bool IsFullTypeNameSetExplicit { get; }
    public bool IsAssemblyNameSetExplicit { get; }
    [CLSCompliantAttribute("False")]
public SerializationInfo(Type type, IFormatterConverter converter);
    [CLSCompliantAttribute("False")]
public SerializationInfo(Type type, IFormatterConverter converter, bool requireSameTokenInPartialTrust);
    public string get_AssemblyName();
    public void set_AssemblyName(string value);
    public string get_FullTypeName();
    public void set_FullTypeName(string value);
    public int get_MemberCount();
    public Type get_ObjectType();
    public bool get_IsFullTypeNameSetExplicit();
    public bool get_IsAssemblyNameSetExplicit();
    public void AddValue(string name, bool value);
    public void AddValue(string name, byte value);
    public void AddValue(string name, char value);
    public void AddValue(string name, DateTime value);
    public void AddValue(string name, decimal value);
    public void AddValue(string name, double value);
    public void AddValue(string name, short value);
    public void AddValue(string name, int value);
    public void AddValue(string name, long value);
    public void AddValue(string name, object value);
    public void AddValue(string name, object value, Type type);
    [CLSCompliantAttribute("False")]
public void AddValue(string name, sbyte value);
    public void AddValue(string name, float value);
    [CLSCompliantAttribute("False")]
public void AddValue(string name, ushort value);
    [CLSCompliantAttribute("False")]
public void AddValue(string name, UInt32 value);
    [CLSCompliantAttribute("False")]
public void AddValue(string name, ulong value);
    public bool GetBoolean(string name);
    public byte GetByte(string name);
    public char GetChar(string name);
    public DateTime GetDateTime(string name);
    public decimal GetDecimal(string name);
    public double GetDouble(string name);
    public SerializationInfoEnumerator GetEnumerator();
    public short GetInt16(string name);
    public int GetInt32(string name);
    public long GetInt64(string name);
    [CLSCompliantAttribute("False")]
public sbyte GetSByte(string name);
    public float GetSingle(string name);
    public string GetString(string name);
    [CLSCompliantAttribute("False")]
public ushort GetUInt16(string name);
    [CLSCompliantAttribute("False")]
public UInt32 GetUInt32(string name);
    [CLSCompliantAttribute("False")]
public ulong GetUInt64(string name);
    public object GetValue(string name, Type type);
    public void SetType(Type type);
}
public class System.Runtime.Serialization.SerializationInfoEnumerator : object {
    public SerializationEntry Current { get; }
    public string Name { get; }
    public Type ObjectType { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public object Value { get; }
    public SerializationEntry get_Current();
    public string get_Name();
    public Type get_ObjectType();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public object get_Value();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
public class System.Runtime.Serialization.StreamingContext : ValueType {
    public StreamingContextStates State { get; }
    public object Context { get; }
    public StreamingContext(StreamingContextStates state);
    public StreamingContext(StreamingContextStates state, object additional);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public StreamingContextStates get_State();
    public object get_Context();
}
[FlagsAttribute]
public enum System.Runtime.Serialization.StreamingContextStates : Enum {
    public int value__;
    public static StreamingContextStates CrossProcess;
    public static StreamingContextStates CrossMachine;
    public static StreamingContextStates File;
    public static StreamingContextStates Persistence;
    public static StreamingContextStates Remoting;
    public static StreamingContextStates Other;
    public static StreamingContextStates Clone;
    public static StreamingContextStates CrossAppDomain;
    public static StreamingContextStates All;
}
[AttributeUsageAttribute("64")]
public class System.Runtime.TargetedPatchingOptOutAttribute : Attribute {
    public string Reason { get; }
    public TargetedPatchingOptOutAttribute(string reason);
    public string get_Reason();
}
[AttributeUsageAttribute("1")]
public class System.Runtime.Versioning.TargetFrameworkAttribute : Attribute {
    public string FrameworkDisplayName { get; public set; }
    public string FrameworkName { get; }
    public TargetFrameworkAttribute(string frameworkName);
    public string get_FrameworkDisplayName();
    public void set_FrameworkDisplayName(string value);
    public string get_FrameworkName();
}
public class System.RuntimeArgumentHandle : ValueType {
}
public class System.RuntimeFieldHandle : ValueType {
    public IntPtr Value { get; }
    public virtual bool Equals(object obj);
    public bool Equals(RuntimeFieldHandle handle);
    public virtual int GetHashCode();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public static bool op_Equality(RuntimeFieldHandle left, RuntimeFieldHandle right);
    public static bool op_Inequality(RuntimeFieldHandle left, RuntimeFieldHandle right);
    public IntPtr get_Value();
}
public class System.RuntimeMethodHandle : ValueType {
    public IntPtr Value { get; }
    public virtual bool Equals(object obj);
    public bool Equals(RuntimeMethodHandle handle);
    public virtual int GetHashCode();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public static bool op_Equality(RuntimeMethodHandle left, RuntimeMethodHandle right);
    public static bool op_Inequality(RuntimeMethodHandle left, RuntimeMethodHandle right);
    public IntPtr get_Value();
    public IntPtr GetFunctionPointer();
}
public class System.RuntimeTypeHandle : ValueType {
    public IntPtr Value { get; }
    public virtual bool Equals(object obj);
    public bool Equals(RuntimeTypeHandle handle);
    public virtual int GetHashCode();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public static bool op_Equality(object left, RuntimeTypeHandle right);
    public static bool op_Equality(RuntimeTypeHandle left, object right);
    public static bool op_Inequality(object left, RuntimeTypeHandle right);
    public static bool op_Inequality(RuntimeTypeHandle left, object right);
    public IntPtr get_Value();
    public ModuleHandle GetModuleHandle();
}
[CLSCompliantAttribute("False")]
public class System.SByte : ValueType {
    public static sbyte MaxValue;
    public static sbyte MinValue;
    public sealed virtual int CompareTo(sbyte value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(sbyte obj);
    public virtual int GetHashCode();
    [CLSCompliantAttribute("False")]
public static sbyte Parse(string s);
    [CLSCompliantAttribute("False")]
public static sbyte Parse(string s, NumberStyles style);
    [CLSCompliantAttribute("False")]
public static sbyte Parse(string s, NumberStyles style, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static sbyte Parse(string s, IFormatProvider provider);
    public sealed virtual int CompareTo(object obj);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, SByte& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, SByte& result);
}
[AttributeUsageAttribute("1")]
public class System.Security.AllowPartiallyTrustedCallersAttribute : Attribute {
    public PartialTrustVisibilityLevel PartialTrustVisibilityLevel { get; public set; }
    public PartialTrustVisibilityLevel get_PartialTrustVisibilityLevel();
    public void set_PartialTrustVisibilityLevel(PartialTrustVisibilityLevel value);
}
public class System.Security.Cryptography.CryptographicException : SystemException {
    public CryptographicException(int hr);
    protected CryptographicException(SerializationInfo info, StreamingContext context);
    public CryptographicException(string message);
    public CryptographicException(string message, Exception inner);
    public CryptographicException(string format, string insert);
}
public enum System.Security.PartialTrustVisibilityLevel : Enum {
    public int value__;
    public static PartialTrustVisibilityLevel NotVisibleByDefault;
    public static PartialTrustVisibilityLevel VisibleToAllHosts;
}
[AttributeUsageAttribute("5501")]
public class System.Security.SecurityCriticalAttribute : Attribute {
    [ObsoleteAttribute("SecurityCriticalScope is only used for .NET 2.0 transparency compatibility.")]
public SecurityCriticalScope Scope { get; }
    public SecurityCriticalAttribute(SecurityCriticalScope scope);
    public SecurityCriticalScope get_Scope();
}
[ObsoleteAttribute("SecurityCriticalScope is only used for .NET 2.0 transparency compatibility.")]
public enum System.Security.SecurityCriticalScope : Enum {
    public int value__;
    public static SecurityCriticalScope Everything;
    public static SecurityCriticalScope Explicit;
}
public class System.Security.SecurityException : SystemException {
    public object Demanded { get; public set; }
    public object DenySetInstance { get; public set; }
    public AssemblyName FailedAssemblyInfo { get; public set; }
    public string GrantedSet { get; public set; }
    public MethodInfo Method { get; public set; }
    public string PermissionState { get; public set; }
    public Type PermissionType { get; public set; }
    public object PermitOnlySetInstance { get; public set; }
    public string RefusedSet { get; public set; }
    public string Url { get; public set; }
    protected SecurityException(SerializationInfo info, StreamingContext context);
    public SecurityException(string message);
    public SecurityException(string message, Exception inner);
    public SecurityException(string message, Type type);
    public SecurityException(string message, Type type, string state);
    public object get_Demanded();
    public void set_Demanded(object value);
    public object get_DenySetInstance();
    public void set_DenySetInstance(object value);
    public AssemblyName get_FailedAssemblyInfo();
    public void set_FailedAssemblyInfo(AssemblyName value);
    public string get_GrantedSet();
    public void set_GrantedSet(string value);
    public MethodInfo get_Method();
    public void set_Method(MethodInfo value);
    public string get_PermissionState();
    public void set_PermissionState(string value);
    public Type get_PermissionType();
    public void set_PermissionType(Type value);
    public object get_PermitOnlySetInstance();
    public void set_PermitOnlySetInstance(object value);
    public string get_RefusedSet();
    public void set_RefusedSet(string value);
    public string get_Url();
    public void set_Url(string value);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
}
[AttributeUsageAttribute("1")]
public class System.Security.SecurityRulesAttribute : Attribute {
    public SecurityRuleSet RuleSet { get; }
    public bool SkipVerificationInFullTrust { get; public set; }
    public SecurityRulesAttribute(SecurityRuleSet ruleSet);
    public SecurityRuleSet get_RuleSet();
    public bool get_SkipVerificationInFullTrust();
    public void set_SkipVerificationInFullTrust(bool value);
}
public enum System.Security.SecurityRuleSet : Enum {
    public byte value__;
    public static SecurityRuleSet Level1;
    public static SecurityRuleSet Level2;
    public static SecurityRuleSet None;
}
[AttributeUsageAttribute("5500")]
public class System.Security.SecuritySafeCriticalAttribute : Attribute {
}
[AttributeUsageAttribute("1")]
public class System.Security.SecurityTransparentAttribute : Attribute {
}
[AttributeUsageAttribute("5501")]
[ObsoleteAttribute("SecurityTreatAsSafe is only used for .NET 2.0 transparency compatibility.  Please use the SecuritySafeCriticalAttribute instead.")]
public class System.Security.SecurityTreatAsSafeAttribute : Attribute {
}
[AttributeUsageAttribute("5188")]
public class System.Security.SuppressUnmanagedCodeSecurityAttribute : Attribute {
}
[AttributeUsageAttribute("2")]
public class System.Security.UnverifiableCodeAttribute : Attribute {
}
public class System.Security.VerificationException : SystemException {
    protected VerificationException(SerializationInfo info, StreamingContext context);
    public VerificationException(string message);
    public VerificationException(string message, Exception innerException);
}
[AttributeUsageAttribute("4124")]
public class System.SerializableAttribute : Attribute {
}
public class System.Single : ValueType {
    public static float MinValue;
    public static float Epsilon;
    public static float MaxValue;
    public static float PositiveInfinity;
    public static float NegativeInfinity;
    public static float NaN;
    public sealed virtual int CompareTo(float value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(float obj);
    public virtual int GetHashCode();
    public static bool IsInfinity(float f);
    public static bool IsNaN(float f);
    public static bool IsNegativeInfinity(float f);
    public static bool IsPositiveInfinity(float f);
    public static bool op_Equality(float left, float right);
    public static bool op_GreaterThan(float left, float right);
    public static bool op_GreaterThanOrEqual(float left, float right);
    public static bool op_Inequality(float left, float right);
    public static bool op_LessThan(float left, float right);
    public static bool op_LessThanOrEqual(float left, float right);
    public static float Parse(string s);
    public static float Parse(string s, NumberStyles style);
    public static float Parse(string s, NumberStyles style, IFormatProvider provider);
    public static float Parse(string s, IFormatProvider provider);
    public sealed virtual int CompareTo(object value);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, Single& result);
    public static bool TryParse(string s, Single& result);
}
public class System.StackOverflowException : SystemException {
    public StackOverflowException(string message);
    public StackOverflowException(string message, Exception innerException);
}
[AttributeUsageAttribute("64")]
public class System.STAThreadAttribute : Attribute {
}
[DefaultMemberAttribute("Chars")]
public class System.String : object {
    public static string Empty;
    public char Chars { get; }
    public int Length { get; }
    [CLSCompliantAttribute("False")]
[SecurityCriticalAttribute]
public String(Char* value);
    [CLSCompliantAttribute("False")]
[SecurityCriticalAttribute]
public String(Char* value, int startIndex, int length);
    public String(char c, int count);
    public String(Char[] value);
    public String(Char[] value, int startIndex, int length);
    [CLSCompliantAttribute("False")]
public String(SByte* value);
    [CLSCompliantAttribute("False")]
public String(SByte* value, int startIndex, int length);
    [CLSCompliantAttribute("False")]
public String(SByte* value, int startIndex, int length, Encoding enc);
    public char get_Chars(int index);
    public int get_Length();
    public sealed virtual object Clone();
    public static int Compare(string strA, int indexA, string strB, int indexB, int length);
    public static int Compare(string strA, int indexA, string strB, int indexB, int length, bool ignoreCase);
    public static int Compare(string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType);
    public static int Compare(string strA, string strB);
    public static int Compare(string strA, string strB, bool ignoreCase);
    public static int Compare(string strA, string strB, bool ignoreCase, CultureInfo culture);
    public static int Compare(string strA, string strB, CultureInfo culture, CompareOptions options);
    public static int Compare(string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, CultureInfo culture);
    public static int Compare(string strA, int indexA, string strB, int indexB, int length, CultureInfo culture, CompareOptions options);
    public static int Compare(string strA, string strB, StringComparison comparisonType);
    public static int CompareOrdinal(string strA, int indexA, string strB, int indexB, int length);
    public static int CompareOrdinal(string strA, string strB);
    public sealed virtual int CompareTo(string strB);
    public static string Concat(IEnumerable`1<string> values);
    public static string Concat(object arg0);
    public static string Concat(object arg0, object arg1);
    public static string Concat(object arg0, object arg1, object arg2);
    public static string Concat(Object[] args);
    public static string Concat(string str0, string str1);
    public static string Concat(string str0, string str1, string str2);
    public static string Concat(string str0, string str1, string str2, string str3);
    [CLSCompliantAttribute("False")]
public static string Concat(String[] values);
    public static string Concat(IEnumerable`1<T> values);
    public bool Contains(string value);
    public bool Contains(string value, StringComparison comparisonType);
    public static string Copy(string str);
    public void CopyTo(int sourceIndex, Char[] destination, int destinationIndex, int count);
    public bool EndsWith(char value);
    public bool EndsWith(string value);
    public bool EndsWith(string value, bool ignoreCase, CultureInfo culture);
    public bool EndsWith(string value, StringComparison comparisonType);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(string value);
    public static bool Equals(string a, string b);
    public static bool Equals(string a, string b, StringComparison comparisonType);
    public bool Equals(string value, StringComparison comparisonType);
    public static string Format(IFormatProvider provider, string format, object arg0);
    public static string Format(IFormatProvider provider, string format, object arg0, object arg1);
    public static string Format(IFormatProvider provider, string format, object arg0, object arg1, object arg2);
    public static string Format(IFormatProvider provider, string format, Object[] args);
    public static string Format(string format, object arg0);
    public static string Format(string format, object arg0, object arg1);
    public static string Format(string format, object arg0, object arg1, object arg2);
    public static string Format(string format, Object[] args);
    public CharEnumerator GetEnumerator();
    public virtual int GetHashCode();
    public int GetHashCode(StringComparison comparisonType);
    public int IndexOf(char value);
    public int IndexOf(char value, int startIndex);
    public int IndexOf(char value, int startIndex, int count);
    public int IndexOf(string value);
    public int IndexOf(string value, int startIndex);
    public int IndexOf(string value, int startIndex, int count);
    public int IndexOf(string value, int startIndex, int count, StringComparison comparisonType);
    public int IndexOf(string value, int startIndex, StringComparison comparisonType);
    public int IndexOf(string value, StringComparison comparisonType);
    public int IndexOfAny(Char[] anyOf);
    public int IndexOfAny(Char[] anyOf, int startIndex);
    public int IndexOfAny(Char[] anyOf, int startIndex, int count);
    public string Insert(int startIndex, string value);
    public static string Intern(string str);
    public static string IsInterned(string str);
    public bool IsNormalized();
    public bool IsNormalized(NormalizationForm normalizationForm);
    public static bool IsNullOrEmpty(string value);
    public static bool IsNullOrWhiteSpace(string value);
    public static string Join(string separator, IEnumerable`1<string> values);
    public static string Join(string separator, Object[] values);
    public static string Join(string separator, String[] value);
    public static string Join(string separator, String[] value, int startIndex, int count);
    public static string Join(string separator, IEnumerable`1<T> values);
    public static string Join(char separator, Object[] values);
    public static string Join(char separator, String[] value);
    public static string Join(char separator, String[] value, int startIndex, int count);
    public static string Join(char separator, IEnumerable`1<T> values);
    public int LastIndexOf(char value);
    public int LastIndexOf(char value, int startIndex);
    public int LastIndexOf(char value, int startIndex, int count);
    public int LastIndexOf(string value);
    public int LastIndexOf(string value, int startIndex);
    public int LastIndexOf(string value, int startIndex, int count);
    public int LastIndexOf(string value, int startIndex, int count, StringComparison comparisonType);
    public int LastIndexOf(string value, int startIndex, StringComparison comparisonType);
    public int LastIndexOf(string value, StringComparison comparisonType);
    public int LastIndexOfAny(Char[] anyOf);
    public int LastIndexOfAny(Char[] anyOf, int startIndex);
    public int LastIndexOfAny(Char[] anyOf, int startIndex, int count);
    public string Normalize();
    public string Normalize(NormalizationForm normalizationForm);
    public static bool op_Equality(string a, string b);
    public static bool op_Inequality(string a, string b);
    public string PadLeft(int totalWidth);
    public string PadLeft(int totalWidth, char paddingChar);
    public string PadRight(int totalWidth);
    public string PadRight(int totalWidth, char paddingChar);
    public string Remove(int startIndex);
    public string Remove(int startIndex, int count);
    public string Replace(char oldChar, char newChar);
    public string Replace(string oldValue, string newValue);
    public string Replace(string oldValue, string newValue, StringComparison comparisonType);
    public string Replace(string oldValue, string newValue, bool ignoreCase, CultureInfo culture);
    public String[] Split(char separator, StringSplitOptions options);
    public String[] Split(char separator, int count, StringSplitOptions options);
    public String[] Split(string separator, StringSplitOptions options);
    public String[] Split(string separator, int count, StringSplitOptions options);
    public String[] Split(Char[] separator);
    public String[] Split(Char[] separator, int count);
    public String[] Split(Char[] separator, int count, StringSplitOptions options);
    public String[] Split(Char[] separator, StringSplitOptions options);
    public String[] Split(String[] separator, int count, StringSplitOptions options);
    public String[] Split(String[] separator, StringSplitOptions options);
    public bool StartsWith(char value);
    public bool StartsWith(string value);
    public bool StartsWith(string value, bool ignoreCase, CultureInfo culture);
    public bool StartsWith(string value, StringComparison comparisonType);
    public string Substring(int startIndex);
    public string Substring(int startIndex, int length);
    private sealed virtual override IEnumerator`1<char> System.Collections.Generic.IEnumerable<System.Char>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int CompareTo(object value);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    public sealed virtual string ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public Char[] ToCharArray();
    public Char[] ToCharArray(int startIndex, int length);
    public string ToLower();
    public string ToLower(CultureInfo culture);
    public string ToLowerInvariant();
    public virtual string ToString();
    public string ToUpper();
    public string ToUpper(CultureInfo culture);
    public string ToUpperInvariant();
    public string Trim();
    public string Trim(char trimChar);
    public string Trim(Char[] trimChars);
    public string TrimEnd();
    public string TrimEnd(char trimChar);
    public string TrimEnd(Char[] trimChars);
    public string TrimStart();
    public string TrimStart(char trimChar);
    public string TrimStart(Char[] trimChars);
}
public enum System.StringComparison : Enum {
    public int value__;
    public static StringComparison CurrentCulture;
    public static StringComparison CurrentCultureIgnoreCase;
    public static StringComparison InvariantCulture;
    public static StringComparison InvariantCultureIgnoreCase;
    public static StringComparison Ordinal;
    public static StringComparison OrdinalIgnoreCase;
}
[FlagsAttribute]
public enum System.StringSplitOptions : Enum {
    public int value__;
    public static StringSplitOptions None;
    public static StringSplitOptions RemoveEmptyEntries;
}
public class System.SystemException : Exception {
    public SystemException(string message);
    public SystemException(string message, Exception innerException);
    protected SystemException(SerializationInfo info, StreamingContext context);
}
public abstract class System.Text.Decoder : object {
    public DecoderFallback Fallback { get; public set; }
    public DecoderFallbackBuffer FallbackBuffer { get; }
    public DecoderFallback get_Fallback();
    public void set_Fallback(DecoderFallback value);
    public DecoderFallbackBuffer get_FallbackBuffer();
    [CLSCompliantAttribute("False")]
public virtual void Convert(Byte* bytes, int byteCount, Char* chars, int charCount, bool flush, Int32& bytesUsed, Int32& charsUsed, Boolean& completed);
    public virtual void Convert(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex, int charCount, bool flush, Int32& bytesUsed, Int32& charsUsed, Boolean& completed);
    [CLSCompliantAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count, bool flush);
    public abstract virtual int GetCharCount(Byte[] bytes, int index, int count);
    public virtual int GetCharCount(Byte[] bytes, int index, int count, bool flush);
    [CLSCompliantAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, bool flush);
    public abstract virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex, bool flush);
    public virtual void Reset();
}
public class System.Text.DecoderExceptionFallback : DecoderFallback {
    public int MaxCharCount { get; }
    public virtual int get_MaxCharCount();
    public virtual DecoderFallbackBuffer CreateFallbackBuffer();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
public class System.Text.DecoderExceptionFallbackBuffer : DecoderFallbackBuffer {
    public int Remaining { get; }
    public virtual int get_Remaining();
    public virtual bool Fallback(Byte[] bytesUnknown, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
}
public abstract class System.Text.DecoderFallback : object {
    public static DecoderFallback ExceptionFallback { get; }
    public int MaxCharCount { get; }
    public static DecoderFallback ReplacementFallback { get; }
    public static DecoderFallback get_ExceptionFallback();
    public abstract virtual int get_MaxCharCount();
    public static DecoderFallback get_ReplacementFallback();
    public abstract virtual DecoderFallbackBuffer CreateFallbackBuffer();
}
public abstract class System.Text.DecoderFallbackBuffer : object {
    public int Remaining { get; }
    public abstract virtual int get_Remaining();
    public abstract virtual bool Fallback(Byte[] bytesUnknown, int index);
    public abstract virtual char GetNextChar();
    public abstract virtual bool MovePrevious();
    public virtual void Reset();
}
public class System.Text.DecoderFallbackException : ArgumentException {
    public Byte[] BytesUnknown { get; }
    public int Index { get; }
    public DecoderFallbackException(string message);
    public DecoderFallbackException(string message, Byte[] bytesUnknown, int index);
    public DecoderFallbackException(string message, Exception innerException);
    public Byte[] get_BytesUnknown();
    public int get_Index();
}
public class System.Text.DecoderReplacementFallback : DecoderFallback {
    public string DefaultString { get; }
    public int MaxCharCount { get; }
    public DecoderReplacementFallback(string replacement);
    public string get_DefaultString();
    public virtual int get_MaxCharCount();
    public virtual DecoderFallbackBuffer CreateFallbackBuffer();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
public class System.Text.DecoderReplacementFallbackBuffer : DecoderFallbackBuffer {
    public int Remaining { get; }
    public DecoderReplacementFallbackBuffer(DecoderReplacementFallback fallback);
    public virtual int get_Remaining();
    public virtual bool Fallback(Byte[] bytesUnknown, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
    [SecuritySafeCriticalAttribute]
public virtual void Reset();
}
public abstract class System.Text.Encoder : object {
    public EncoderFallback Fallback { get; public set; }
    public EncoderFallbackBuffer FallbackBuffer { get; }
    public EncoderFallback get_Fallback();
    public void set_Fallback(EncoderFallback value);
    public EncoderFallbackBuffer get_FallbackBuffer();
    [CLSCompliantAttribute("False")]
public virtual void Convert(Char* chars, int charCount, Byte* bytes, int byteCount, bool flush, Int32& charsUsed, Int32& bytesUsed, Boolean& completed);
    public virtual void Convert(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex, int byteCount, bool flush, Int32& charsUsed, Int32& bytesUsed, Boolean& completed);
    [CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count, bool flush);
    public abstract virtual int GetByteCount(Char[] chars, int index, int count, bool flush);
    [CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, bool flush);
    public abstract virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex, bool flush);
    public virtual void Reset();
}
public class System.Text.EncoderExceptionFallback : EncoderFallback {
    public int MaxCharCount { get; }
    public virtual int get_MaxCharCount();
    public virtual EncoderFallbackBuffer CreateFallbackBuffer();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
public class System.Text.EncoderExceptionFallbackBuffer : EncoderFallbackBuffer {
    public int Remaining { get; }
    public virtual int get_Remaining();
    public virtual bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
    public virtual bool Fallback(char charUnknown, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
}
public abstract class System.Text.EncoderFallback : object {
    public static EncoderFallback ExceptionFallback { get; }
    public int MaxCharCount { get; }
    public static EncoderFallback ReplacementFallback { get; }
    public static EncoderFallback get_ExceptionFallback();
    public abstract virtual int get_MaxCharCount();
    public static EncoderFallback get_ReplacementFallback();
    public abstract virtual EncoderFallbackBuffer CreateFallbackBuffer();
}
public abstract class System.Text.EncoderFallbackBuffer : object {
    public int Remaining { get; }
    public abstract virtual int get_Remaining();
    public abstract virtual bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
    public abstract virtual bool Fallback(char charUnknown, int index);
    public abstract virtual char GetNextChar();
    public abstract virtual bool MovePrevious();
    public virtual void Reset();
}
public class System.Text.EncoderFallbackException : ArgumentException {
    public char CharUnknown { get; }
    public char CharUnknownHigh { get; }
    public char CharUnknownLow { get; }
    public int Index { get; }
    public EncoderFallbackException(string message);
    public EncoderFallbackException(string message, Exception innerException);
    public char get_CharUnknown();
    public char get_CharUnknownHigh();
    public char get_CharUnknownLow();
    public int get_Index();
    public bool IsUnknownSurrogate();
}
public class System.Text.EncoderReplacementFallback : EncoderFallback {
    public string DefaultString { get; }
    public int MaxCharCount { get; }
    public EncoderReplacementFallback(string replacement);
    public string get_DefaultString();
    public virtual int get_MaxCharCount();
    public virtual EncoderFallbackBuffer CreateFallbackBuffer();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
public class System.Text.EncoderReplacementFallbackBuffer : EncoderFallbackBuffer {
    public int Remaining { get; }
    public EncoderReplacementFallbackBuffer(EncoderReplacementFallback fallback);
    public virtual int get_Remaining();
    public virtual bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
    public virtual bool Fallback(char charUnknown, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
    [SecuritySafeCriticalAttribute]
public virtual void Reset();
}
public abstract class System.Text.Encoding : object {
    public static Encoding ASCII { get; }
    public static Encoding BigEndianUnicode { get; }
    public string BodyName { get; }
    public int CodePage { get; }
    public DecoderFallback DecoderFallback { get; public set; }
    public static Encoding Default { get; }
    public EncoderFallback EncoderFallback { get; public set; }
    public string EncodingName { get; }
    public string HeaderName { get; }
    public bool IsBrowserDisplay { get; }
    public bool IsBrowserSave { get; }
    public bool IsMailNewsDisplay { get; }
    public bool IsMailNewsSave { get; }
    public bool IsReadOnly { get; }
    public bool IsSingleByte { get; }
    public static Encoding Unicode { get; }
    public static Encoding UTF32 { get; }
    public static Encoding UTF7 { get; }
    public static Encoding UTF8 { get; }
    public string WebName { get; }
    public int WindowsCodePage { get; }
    protected Encoding(int codePage);
    protected Encoding(int codePage, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
    public static Encoding get_ASCII();
    public static Encoding get_BigEndianUnicode();
    public virtual string get_BodyName();
    public virtual int get_CodePage();
    public DecoderFallback get_DecoderFallback();
    public void set_DecoderFallback(DecoderFallback value);
    public static Encoding get_Default();
    public EncoderFallback get_EncoderFallback();
    public void set_EncoderFallback(EncoderFallback value);
    public virtual string get_EncodingName();
    public virtual string get_HeaderName();
    public virtual bool get_IsBrowserDisplay();
    public virtual bool get_IsBrowserSave();
    public virtual bool get_IsMailNewsDisplay();
    public virtual bool get_IsMailNewsSave();
    public bool get_IsReadOnly();
    public virtual bool get_IsSingleByte();
    public static Encoding get_Unicode();
    public static Encoding get_UTF32();
    public static Encoding get_UTF7();
    public static Encoding get_UTF8();
    public virtual string get_WebName();
    public virtual int get_WindowsCodePage();
    public virtual object Clone();
    public static Byte[] Convert(Encoding srcEncoding, Encoding dstEncoding, Byte[] bytes);
    public static Byte[] Convert(Encoding srcEncoding, Encoding dstEncoding, Byte[] bytes, int index, int count);
    public virtual bool Equals(object value);
    [CLSCompliantAttribute("False")]
[SecurityCriticalAttribute]
public virtual int GetByteCount(Char* chars, int count);
    public virtual int GetByteCount(Char[] chars);
    public abstract virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetByteCount(string s);
    public int GetByteCount(string s, int index, int count);
    [CLSCompliantAttribute("False")]
[SecurityCriticalAttribute]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual Byte[] GetBytes(Char[] chars);
    public virtual Byte[] GetBytes(Char[] chars, int index, int count);
    public abstract virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual Byte[] GetBytes(string s);
    public Byte[] GetBytes(string s, int index, int count);
    public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [CLSCompliantAttribute("False")]
[SecurityCriticalAttribute]
public virtual int GetCharCount(Byte* bytes, int count);
    public virtual int GetCharCount(Byte[] bytes);
    public abstract virtual int GetCharCount(Byte[] bytes, int index, int count);
    [CLSCompliantAttribute("False")]
[SecurityCriticalAttribute]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    public virtual Char[] GetChars(Byte[] bytes);
    public virtual Char[] GetChars(Byte[] bytes, int index, int count);
    public abstract virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    public virtual Decoder GetDecoder();
    public virtual Encoder GetEncoder();
    public static Encoding GetEncoding(int codepage);
    public static Encoding GetEncoding(int codepage, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
    public static Encoding GetEncoding(string name);
    public static Encoding GetEncoding(string name, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
    public static EncodingInfo[] GetEncodings();
    public virtual int GetHashCode();
    public abstract virtual int GetMaxByteCount(int charCount);
    public abstract virtual int GetMaxCharCount(int byteCount);
    public virtual Byte[] GetPreamble();
    [CLSCompliantAttribute("False")]
[SecurityCriticalAttribute]
public string GetString(Byte* bytes, int byteCount);
    public virtual string GetString(Byte[] bytes);
    public virtual string GetString(Byte[] bytes, int index, int count);
    public bool IsAlwaysNormalized();
    public virtual bool IsAlwaysNormalized(NormalizationForm form);
    [SecurityCriticalAttribute]
public static void RegisterProvider(EncodingProvider provider);
}
public class System.Text.EncodingInfo : object {
    public int CodePage { get; }
    public string DisplayName { get; }
    public string Name { get; }
    public int get_CodePage();
    public string get_DisplayName();
    public string get_Name();
    public virtual bool Equals(object value);
    public Encoding GetEncoding();
    public virtual int GetHashCode();
}
public abstract class System.Text.EncodingProvider : object {
    public abstract virtual Encoding GetEncoding(int codepage);
    public virtual Encoding GetEncoding(int codepage, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
    public abstract virtual Encoding GetEncoding(string name);
    public virtual Encoding GetEncoding(string name, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
}
public enum System.Text.NormalizationForm : Enum {
    public int value__;
    public static NormalizationForm FormC;
    public static NormalizationForm FormD;
    public static NormalizationForm FormKC;
    public static NormalizationForm FormKD;
}
[DefaultMemberAttribute("Chars")]
public class System.Text.StringBuilder : object {
    public int Capacity { get; public set; }
    public char Chars { get; public set; }
    public int Length { get; public set; }
    public int MaxCapacity { get; }
    public StringBuilder(int capacity);
    public StringBuilder(int capacity, int maxCapacity);
    public StringBuilder(string value);
    public StringBuilder(string value, int capacity);
    public StringBuilder(string value, int startIndex, int length, int capacity);
    public int get_Capacity();
    public void set_Capacity(int value);
    public char get_Chars(int index);
    public void set_Chars(int index, char value);
    public int get_Length();
    public void set_Length(int value);
    public int get_MaxCapacity();
    public StringBuilder Append(bool value);
    public StringBuilder Append(byte value);
    public StringBuilder Append(char value);
    [CLSCompliantAttribute("False")]
[SecurityCriticalAttribute]
public StringBuilder Append(Char* value, int valueCount);
    public StringBuilder Append(char value, int repeatCount);
    public StringBuilder Append(Char[] value);
    public StringBuilder Append(Char[] value, int startIndex, int charCount);
    public StringBuilder Append(decimal value);
    public StringBuilder Append(double value);
    public StringBuilder Append(short value);
    public StringBuilder Append(int value);
    public StringBuilder Append(long value);
    public StringBuilder Append(object value);
    [CLSCompliantAttribute("False")]
public StringBuilder Append(sbyte value);
    public StringBuilder Append(float value);
    public StringBuilder Append(string value);
    public StringBuilder Append(string value, int startIndex, int count);
    [CLSCompliantAttribute("False")]
public StringBuilder Append(ushort value);
    [CLSCompliantAttribute("False")]
public StringBuilder Append(UInt32 value);
    [CLSCompliantAttribute("False")]
public StringBuilder Append(ulong value);
    public StringBuilder AppendFormat(IFormatProvider provider, string format, object arg0);
    public StringBuilder AppendFormat(IFormatProvider provider, string format, object arg0, object arg1);
    public StringBuilder AppendFormat(IFormatProvider provider, string format, object arg0, object arg1, object arg2);
    public StringBuilder AppendFormat(IFormatProvider provider, string format, Object[] args);
    public StringBuilder AppendFormat(string format, object arg0);
    public StringBuilder AppendFormat(string format, object arg0, object arg1);
    public StringBuilder AppendFormat(string format, object arg0, object arg1, object arg2);
    public StringBuilder AppendFormat(string format, Object[] args);
    public StringBuilder AppendLine();
    public StringBuilder AppendLine(string value);
    public StringBuilder AppendJoin(string separator, Object[] values);
    public StringBuilder AppendJoin(string separator, IEnumerable`1<T> values);
    public StringBuilder AppendJoin(string separator, String[] values);
    public StringBuilder AppendJoin(char separator, Object[] values);
    public StringBuilder AppendJoin(char separator, IEnumerable`1<T> values);
    public StringBuilder AppendJoin(char separator, String[] values);
    public StringBuilder Clear();
    public void CopyTo(int sourceIndex, Char[] destination, int destinationIndex, int count);
    public int EnsureCapacity(int capacity);
    public bool Equals(StringBuilder sb);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public StringBuilder Insert(int index, bool value);
    public StringBuilder Insert(int index, byte value);
    public StringBuilder Insert(int index, char value);
    public StringBuilder Insert(int index, Char[] value);
    public StringBuilder Insert(int index, Char[] value, int startIndex, int charCount);
    public StringBuilder Insert(int index, decimal value);
    public StringBuilder Insert(int index, double value);
    public StringBuilder Insert(int index, short value);
    public StringBuilder Insert(int index, int value);
    public StringBuilder Insert(int index, long value);
    public StringBuilder Insert(int index, object value);
    [CLSCompliantAttribute("False")]
public StringBuilder Insert(int index, sbyte value);
    public StringBuilder Insert(int index, float value);
    public StringBuilder Insert(int index, string value);
    public StringBuilder Insert(int index, string value, int count);
    [CLSCompliantAttribute("False")]
public StringBuilder Insert(int index, ushort value);
    [CLSCompliantAttribute("False")]
public StringBuilder Insert(int index, UInt32 value);
    [CLSCompliantAttribute("False")]
public StringBuilder Insert(int index, ulong value);
    public StringBuilder Remove(int startIndex, int length);
    public StringBuilder Replace(char oldChar, char newChar);
    public StringBuilder Replace(char oldChar, char newChar, int startIndex, int count);
    public StringBuilder Replace(string oldValue, string newValue);
    public StringBuilder Replace(string oldValue, string newValue, int startIndex, int count);
    public virtual string ToString();
    public string ToString(int startIndex, int length);
}
public class System.Threading.CancellationToken : ValueType {
    public bool CanBeCanceled { get; }
    public bool IsCancellationRequested { get; }
    public static CancellationToken None { get; }
    public WaitHandle WaitHandle { get; }
    public CancellationToken(bool canceled);
    public bool get_CanBeCanceled();
    public bool get_IsCancellationRequested();
    public static CancellationToken get_None();
    public WaitHandle get_WaitHandle();
    public virtual bool Equals(object other);
    public bool Equals(CancellationToken other);
    public virtual int GetHashCode();
    public static bool op_Equality(CancellationToken left, CancellationToken right);
    public static bool op_Inequality(CancellationToken left, CancellationToken right);
    public CancellationTokenRegistration Register(Action callback);
    public CancellationTokenRegistration Register(Action callback, bool useSynchronizationContext);
    public CancellationTokenRegistration Register(Action`1<object> callback, object state);
    public CancellationTokenRegistration Register(Action`1<object> callback, object state, bool useSynchronizationContext);
    public void ThrowIfCancellationRequested();
}
public class System.Threading.CancellationTokenRegistration : ValueType {
    public sealed virtual void Dispose();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CancellationTokenRegistration other);
    public virtual int GetHashCode();
    public static bool op_Equality(CancellationTokenRegistration left, CancellationTokenRegistration right);
    public static bool op_Inequality(CancellationTokenRegistration left, CancellationTokenRegistration right);
}
public enum System.Threading.LazyThreadSafetyMode : Enum {
    public int value__;
    public static LazyThreadSafetyMode ExecutionAndPublication;
    public static LazyThreadSafetyMode None;
    public static LazyThreadSafetyMode PublicationOnly;
}
public class System.Threading.Tasks.Task : object {
    public object AsyncState { get; }
    public static Task CompletedTask { get; }
    public TaskCreationOptions CreationOptions { get; }
    public static Nullable`1<int> CurrentId { get; }
    public AggregateException Exception { get; }
    public static TaskFactory Factory { get; }
    public int Id { get; }
    public bool IsCanceled { get; }
    public bool IsCompleted { get; }
    public bool IsCompletedSuccessfully { get; }
    public bool IsFaulted { get; }
    public TaskStatus Status { get; }
    private WaitHandle System.IAsyncResult.AsyncWaitHandle { get; }
    private bool System.IAsyncResult.CompletedSynchronously { get; }
    public Task(Action action);
    public Task(Action action, CancellationToken cancellationToken);
    public Task(Action action, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
    public Task(Action action, TaskCreationOptions creationOptions);
    public Task(Action`1<object> action, object state);
    public Task(Action`1<object> action, object state, CancellationToken cancellationToken);
    public Task(Action`1<object> action, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
    public Task(Action`1<object> action, object state, TaskCreationOptions creationOptions);
    public sealed virtual object get_AsyncState();
    public static Task get_CompletedTask();
    public TaskCreationOptions get_CreationOptions();
    public static Nullable`1<int> get_CurrentId();
    public AggregateException get_Exception();
    public static TaskFactory get_Factory();
    public int get_Id();
    public bool get_IsCanceled();
    public sealed virtual bool get_IsCompleted();
    public bool get_IsCompletedSuccessfully();
    public bool get_IsFaulted();
    public TaskStatus get_Status();
    private sealed virtual override WaitHandle System.IAsyncResult.get_AsyncWaitHandle();
    private sealed virtual override bool System.IAsyncResult.get_CompletedSynchronously();
    public ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext);
    public Task ContinueWith(Action`2<Task, object> continuationAction, object state);
    public Task ContinueWith(Action`2<Task, object> continuationAction, object state, CancellationToken cancellationToken);
    public Task ContinueWith(Action`2<Task, object> continuationAction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task ContinueWith(Action`2<Task, object> continuationAction, object state, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`2<Task, object> continuationAction, object state, TaskScheduler scheduler);
    public Task ContinueWith(Action`1<Task> continuationAction);
    public Task ContinueWith(Action`1<Task> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWith(Action`1<Task> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task ContinueWith(Action`1<Task> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`1<Task> continuationAction, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state);
    public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state, TaskScheduler scheduler);
    public static Task Delay(int millisecondsDelay);
    public static Task Delay(int millisecondsDelay, CancellationToken cancellationToken);
    public static Task Delay(TimeSpan delay);
    public static Task Delay(TimeSpan delay, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public static Task FromCanceled(CancellationToken cancellationToken);
    public static Task`1<TResult> FromCanceled(CancellationToken cancellationToken);
    public static Task FromException(Exception exception);
    public static Task`1<TResult> FromException(Exception exception);
    public static Task`1<TResult> FromResult(TResult result);
    public TaskAwaiter GetAwaiter();
    public static Task Run(Action action);
    public static Task Run(Action action, CancellationToken cancellationToken);
    public static Task Run(Func`1<Task> function);
    public static Task Run(Func`1<Task> function, CancellationToken cancellationToken);
    public static Task`1<TResult> Run(Func`1<TResult> function);
    public static Task`1<TResult> Run(Func`1<TResult> function, CancellationToken cancellationToken);
    public static Task`1<TResult> Run(Func`1<Task`1<TResult>> function);
    public static Task`1<TResult> Run(Func`1<Task`1<TResult>> function, CancellationToken cancellationToken);
    public void RunSynchronously();
    public void RunSynchronously(TaskScheduler scheduler);
    public void Start();
    public void Start(TaskScheduler scheduler);
    public void Wait();
    public bool Wait(int millisecondsTimeout);
    public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken);
    public void Wait(CancellationToken cancellationToken);
    public bool Wait(TimeSpan timeout);
    public static void WaitAll(Task[] tasks);
    public static bool WaitAll(Task[] tasks, int millisecondsTimeout);
    public static bool WaitAll(Task[] tasks, int millisecondsTimeout, CancellationToken cancellationToken);
    public static void WaitAll(Task[] tasks, CancellationToken cancellationToken);
    public static bool WaitAll(Task[] tasks, TimeSpan timeout);
    public static int WaitAny(Task[] tasks);
    public static int WaitAny(Task[] tasks, int millisecondsTimeout);
    public static int WaitAny(Task[] tasks, int millisecondsTimeout, CancellationToken cancellationToken);
    public static int WaitAny(Task[] tasks, CancellationToken cancellationToken);
    public static int WaitAny(Task[] tasks, TimeSpan timeout);
    public static Task WhenAll(IEnumerable`1<Task> tasks);
    public static Task WhenAll(Task[] tasks);
    public static Task`1<TResult[]> WhenAll(IEnumerable`1<Task`1<TResult>> tasks);
    public static Task`1<TResult[]> WhenAll(Task`1[] tasks);
    public static Task`1<Task> WhenAny(IEnumerable`1<Task> tasks);
    public static Task`1<Task> WhenAny(Task[] tasks);
    public static Task`1<Task`1<TResult>> WhenAny(IEnumerable`1<Task`1<TResult>> tasks);
    public static Task`1<Task`1<TResult>> WhenAny(Task`1[] tasks);
    public static YieldAwaitable Yield();
}
public class System.Threading.Tasks.Task`1 : Task {
    public static TaskFactory`1<TResult> Factory { get; }
    public TResult Result { get; }
    public Task`1(Func`1<TResult> function);
    public Task`1(Func`1<TResult> function, CancellationToken cancellationToken);
    public Task`1(Func`1<TResult> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
    public Task`1(Func`1<TResult> function, TaskCreationOptions creationOptions);
    public Task`1(Func`2<object, TResult> function, object state);
    public Task`1(Func`2<object, TResult> function, object state, CancellationToken cancellationToken);
    public Task`1(Func`2<object, TResult> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
    public Task`1(Func`2<object, TResult> function, object state, TaskCreationOptions creationOptions);
    public static TaskFactory`1<TResult> get_Factory();
    public TResult get_Result();
    public ConfiguredTaskAwaitable`1<TResult> ConfigureAwait(bool continueOnCapturedContext);
    public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state);
    public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, CancellationToken cancellationToken);
    public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, TaskScheduler scheduler);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, TaskScheduler scheduler);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, TaskScheduler scheduler);
    public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state);
    public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, CancellationToken cancellationToken);
    public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, TaskContinuationOptions continuationOptions);
    public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, TaskScheduler scheduler);
    public TaskAwaiter`1<TResult> GetAwaiter();
}
[FlagsAttribute]
public enum System.Threading.Tasks.TaskContinuationOptions : Enum {
    public int value__;
    public static TaskContinuationOptions AttachedToParent;
    public static TaskContinuationOptions DenyChildAttach;
    public static TaskContinuationOptions ExecuteSynchronously;
    public static TaskContinuationOptions HideScheduler;
    public static TaskContinuationOptions LazyCancellation;
    public static TaskContinuationOptions LongRunning;
    public static TaskContinuationOptions None;
    public static TaskContinuationOptions NotOnCanceled;
    public static TaskContinuationOptions NotOnFaulted;
    public static TaskContinuationOptions NotOnRanToCompletion;
    public static TaskContinuationOptions OnlyOnCanceled;
    public static TaskContinuationOptions OnlyOnFaulted;
    public static TaskContinuationOptions OnlyOnRanToCompletion;
    public static TaskContinuationOptions PreferFairness;
    public static TaskContinuationOptions RunContinuationsAsynchronously;
}
[FlagsAttribute]
public enum System.Threading.Tasks.TaskCreationOptions : Enum {
    public int value__;
    public static TaskCreationOptions AttachedToParent;
    public static TaskCreationOptions DenyChildAttach;
    public static TaskCreationOptions HideScheduler;
    public static TaskCreationOptions LongRunning;
    public static TaskCreationOptions None;
    public static TaskCreationOptions PreferFairness;
    public static TaskCreationOptions RunContinuationsAsynchronously;
}
public class System.Threading.Tasks.TaskFactory : object {
    public CancellationToken CancellationToken { get; }
    public TaskContinuationOptions ContinuationOptions { get; }
    public TaskCreationOptions CreationOptions { get; }
    public TaskScheduler Scheduler { get; }
    public TaskFactory(CancellationToken cancellationToken);
    public TaskFactory(CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public TaskFactory(TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions);
    public TaskFactory(TaskScheduler scheduler);
    public CancellationToken get_CancellationToken();
    public TaskContinuationOptions get_ContinuationOptions();
    public TaskCreationOptions get_CreationOptions();
    public TaskScheduler get_Scheduler();
    public Task ContinueWhenAll(Task[] tasks, Action`1<Task[]> continuationAction);
    public Task ContinueWhenAll(Task[] tasks, Action`1<Task[]> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWhenAll(Task[] tasks, Action`1<Task[]> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task ContinueWhenAll(Task[] tasks, Action`1<Task[]> continuationAction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task ContinueWhenAll(Task`1[] tasks, Action`1<Task`1[]> continuationAction);
    public Task ContinueWhenAll(Task`1[] tasks, Action`1<Task`1[]> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWhenAll(Task`1[] tasks, Action`1<Task`1[]> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task ContinueWhenAll(Task`1[] tasks, Action`1<Task`1[]> continuationAction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task ContinueWhenAny(Task[] tasks, Action`1<Task> continuationAction);
    public Task ContinueWhenAny(Task[] tasks, Action`1<Task> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWhenAny(Task[] tasks, Action`1<Task> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task ContinueWhenAny(Task[] tasks, Action`1<Task> continuationAction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task ContinueWhenAny(Task`1[] tasks, Action`1<Task`1<TAntecedentResult>> continuationAction);
    public Task ContinueWhenAny(Task`1[] tasks, Action`1<Task`1<TAntecedentResult>> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWhenAny(Task`1[] tasks, Action`1<Task`1<TAntecedentResult>> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task ContinueWhenAny(Task`1[] tasks, Action`1<Task`1<TAntecedentResult>> continuationAction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, object state);
    public Task FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, object state, TaskCreationOptions creationOptions);
    public Task FromAsync(IAsyncResult asyncResult, Action`1<IAsyncResult> endMethod);
    public Task FromAsync(IAsyncResult asyncResult, Action`1<IAsyncResult> endMethod, TaskCreationOptions creationOptions);
    public Task FromAsync(IAsyncResult asyncResult, Action`1<IAsyncResult> endMethod, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, object state);
    public Task FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, object state);
    public Task`1<TResult> FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, object state);
    public Task FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, object state);
    public Task`1<TResult> FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, object state, TaskCreationOptions creationOptions);
    public Task FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);
    public Task FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state);
    public Task`1<TResult> FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);
    public Task`1<TResult> FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, TaskCreationOptions creationOptions);
    public Task StartNew(Action action);
    public Task StartNew(Action action, CancellationToken cancellationToken);
    public Task StartNew(Action action, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task StartNew(Action action, TaskCreationOptions creationOptions);
    public Task StartNew(Action`1<object> action, object state);
    public Task StartNew(Action`1<object> action, object state, CancellationToken cancellationToken);
    public Task StartNew(Action`1<object> action, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task StartNew(Action`1<object> action, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> StartNew(Func`1<TResult> function);
    public Task`1<TResult> StartNew(Func`1<TResult> function, CancellationToken cancellationToken);
    public Task`1<TResult> StartNew(Func`1<TResult> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> StartNew(Func`1<TResult> function, TaskCreationOptions creationOptions);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, CancellationToken cancellationToken);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, TaskCreationOptions creationOptions);
}
public class System.Threading.Tasks.TaskFactory`1 : object {
    public CancellationToken CancellationToken { get; }
    public TaskContinuationOptions ContinuationOptions { get; }
    public TaskCreationOptions CreationOptions { get; }
    public TaskScheduler Scheduler { get; }
    public TaskFactory`1(CancellationToken cancellationToken);
    public TaskFactory`1(CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public TaskFactory`1(TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions);
    public TaskFactory`1(TaskScheduler scheduler);
    public CancellationToken get_CancellationToken();
    public TaskContinuationOptions get_ContinuationOptions();
    public TaskCreationOptions get_CreationOptions();
    public TaskScheduler get_Scheduler();
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, object state);
    public Task`1<TResult> FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, object state);
    public Task`1<TResult> FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state);
    public Task`1<TResult> FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);
    public Task`1<TResult> FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> StartNew(Func`1<TResult> function);
    public Task`1<TResult> StartNew(Func`1<TResult> function, CancellationToken cancellationToken);
    public Task`1<TResult> StartNew(Func`1<TResult> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> StartNew(Func`1<TResult> function, TaskCreationOptions creationOptions);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, CancellationToken cancellationToken);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, TaskCreationOptions creationOptions);
}
public abstract class System.Threading.Tasks.TaskScheduler : object {
    public static TaskScheduler Current { get; }
    public static TaskScheduler Default { get; }
    public int Id { get; }
    public int MaximumConcurrencyLevel { get; }
    public static TaskScheduler get_Current();
    public static TaskScheduler get_Default();
    public int get_Id();
    public virtual int get_MaximumConcurrencyLevel();
    public static void add_UnobservedTaskException(EventHandler`1<UnobservedTaskExceptionEventArgs> value);
    public static void remove_UnobservedTaskException(EventHandler`1<UnobservedTaskExceptionEventArgs> value);
    public static TaskScheduler FromCurrentSynchronizationContext();
    [SecurityCriticalAttribute]
protected abstract virtual IEnumerable`1<Task> GetScheduledTasks();
    [SecurityCriticalAttribute]
protected internal abstract virtual void QueueTask(Task task);
    [SecurityCriticalAttribute]
protected internal virtual bool TryDequeue(Task task);
    [SecurityCriticalAttribute]
protected bool TryExecuteTask(Task task);
    [SecurityCriticalAttribute]
protected abstract virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
}
public enum System.Threading.Tasks.TaskStatus : Enum {
    public int value__;
    public static TaskStatus Canceled;
    public static TaskStatus Created;
    public static TaskStatus Faulted;
    public static TaskStatus RanToCompletion;
    public static TaskStatus Running;
    public static TaskStatus WaitingForActivation;
    public static TaskStatus WaitingForChildrenToComplete;
    public static TaskStatus WaitingToRun;
}
public class System.Threading.Tasks.UnobservedTaskExceptionEventArgs : EventArgs {
    public AggregateException Exception { get; }
    public bool Observed { get; }
    public UnobservedTaskExceptionEventArgs(AggregateException exception);
    public AggregateException get_Exception();
    public bool get_Observed();
    public void SetObserved();
}
public static class System.Threading.Timeout : object {
    public static int Infinite;
    public static TimeSpan InfiniteTimeSpan;
}
public abstract class System.Threading.WaitHandle : MarshalByRefObject {
    protected static IntPtr InvalidHandle;
    public static int WaitTimeout;
    [ObsoleteAttribute("Use the SafeWaitHandle property instead.")]
public IntPtr Handle { get; public set; }
    public SafeWaitHandle SafeWaitHandle { get; public set; }
    public virtual void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool explicitDisposing);
    [SecuritySafeCriticalAttribute]
public virtual IntPtr get_Handle();
    [SecurityCriticalAttribute]
public virtual void set_Handle(IntPtr value);
    [SecurityCriticalAttribute]
public SafeWaitHandle get_SafeWaitHandle();
    [SecurityCriticalAttribute]
public void set_SafeWaitHandle(SafeWaitHandle value);
    public static bool SignalAndWait(WaitHandle toSignal, WaitHandle toWaitOn);
    public static bool SignalAndWait(WaitHandle toSignal, WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);
    public static bool SignalAndWait(WaitHandle toSignal, WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);
    public static bool WaitAll(WaitHandle[] waitHandles);
    public static bool WaitAll(WaitHandle[] waitHandles, int millisecondsTimeout);
    public static bool WaitAll(WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);
    public static bool WaitAll(WaitHandle[] waitHandles, TimeSpan timeout);
    public static bool WaitAll(WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);
    public static int WaitAny(WaitHandle[] waitHandles);
    public static int WaitAny(WaitHandle[] waitHandles, int millisecondsTimeout);
    public static int WaitAny(WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);
    public static int WaitAny(WaitHandle[] waitHandles, TimeSpan timeout);
    public static int WaitAny(WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);
    public virtual bool WaitOne();
    public virtual bool WaitOne(int millisecondsTimeout);
    public virtual bool WaitOne(int millisecondsTimeout, bool exitContext);
    public virtual bool WaitOne(TimeSpan timeout);
    public virtual bool WaitOne(TimeSpan timeout, bool exitContext);
}
[ExtensionAttribute]
public static class System.Threading.WaitHandleExtensions : object {
    [ExtensionAttribute]
[SecurityCriticalAttribute]
public static SafeWaitHandle GetSafeWaitHandle(WaitHandle waitHandle);
    [ExtensionAttribute]
[SecurityCriticalAttribute]
public static void SetSafeWaitHandle(WaitHandle waitHandle, SafeWaitHandle value);
}
[AttributeUsageAttribute("256")]
public class System.ThreadStaticAttribute : Attribute {
}
public class System.TimeoutException : SystemException {
    public TimeoutException(string message);
    public TimeoutException(string message, Exception innerException);
    protected TimeoutException(SerializationInfo info, StreamingContext context);
}
public class System.TimeSpan : ValueType {
    public static TimeSpan MaxValue;
    public static TimeSpan MinValue;
    public static long TicksPerDay;
    public static long TicksPerHour;
    public static long TicksPerMillisecond;
    public static long TicksPerMinute;
    public static long TicksPerSecond;
    public static TimeSpan Zero;
    public int Days { get; }
    public int Hours { get; }
    public int Milliseconds { get; }
    public int Minutes { get; }
    public int Seconds { get; }
    public long Ticks { get; }
    public double TotalDays { get; }
    public double TotalHours { get; }
    public double TotalMilliseconds { get; }
    public double TotalMinutes { get; }
    public double TotalSeconds { get; }
    public TimeSpan(int hours, int minutes, int seconds);
    public TimeSpan(int days, int hours, int minutes, int seconds);
    public TimeSpan(int days, int hours, int minutes, int seconds, int milliseconds);
    public TimeSpan(long ticks);
    public int get_Days();
    public int get_Hours();
    public int get_Milliseconds();
    public int get_Minutes();
    public int get_Seconds();
    public long get_Ticks();
    public double get_TotalDays();
    public double get_TotalHours();
    public double get_TotalMilliseconds();
    public double get_TotalMinutes();
    public double get_TotalSeconds();
    public TimeSpan Add(TimeSpan ts);
    public static int Compare(TimeSpan t1, TimeSpan t2);
    public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(TimeSpan value);
    public TimeSpan Divide(double divisor);
    public double Divide(TimeSpan ts);
    public TimeSpan Duration();
    public virtual bool Equals(object value);
    public sealed virtual bool Equals(TimeSpan obj);
    public static bool Equals(TimeSpan t1, TimeSpan t2);
    public static TimeSpan FromDays(double value);
    public static TimeSpan FromHours(double value);
    public static TimeSpan FromMilliseconds(double value);
    public static TimeSpan FromMinutes(double value);
    public static TimeSpan FromSeconds(double value);
    public static TimeSpan FromTicks(long value);
    public virtual int GetHashCode();
    public TimeSpan Multiply(double factor);
    public TimeSpan Negate();
    public static TimeSpan op_Addition(TimeSpan t1, TimeSpan t2);
    public static double op_Division(TimeSpan t1, TimeSpan t2);
    public static TimeSpan op_Division(TimeSpan timeSpan, double divisor);
    public static bool op_Equality(TimeSpan t1, TimeSpan t2);
    public static bool op_GreaterThan(TimeSpan t1, TimeSpan t2);
    public static bool op_GreaterThanOrEqual(TimeSpan t1, TimeSpan t2);
    public static bool op_Inequality(TimeSpan t1, TimeSpan t2);
    public static bool op_LessThan(TimeSpan t1, TimeSpan t2);
    public static bool op_LessThanOrEqual(TimeSpan t1, TimeSpan t2);
    public static TimeSpan op_Subtraction(TimeSpan t1, TimeSpan t2);
    public static TimeSpan op_Multiply(TimeSpan timeSpan, double factor);
    public static TimeSpan op_Multiply(double factor, TimeSpan timeSpan);
    public static TimeSpan op_UnaryNegation(TimeSpan t);
    public static TimeSpan op_UnaryPlus(TimeSpan t);
    public static TimeSpan Parse(string s);
    public static TimeSpan Parse(string input, IFormatProvider formatProvider);
    public static TimeSpan ParseExact(string input, string format, IFormatProvider formatProvider);
    public static TimeSpan ParseExact(string input, string format, IFormatProvider formatProvider, TimeSpanStyles styles);
    public static TimeSpan ParseExact(string input, String[] formats, IFormatProvider formatProvider);
    public static TimeSpan ParseExact(string input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles);
    public TimeSpan Subtract(TimeSpan ts);
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public static bool TryParse(string input, IFormatProvider formatProvider, TimeSpan& result);
    public static bool TryParse(string s, TimeSpan& result);
    public static bool TryParseExact(string input, string format, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result);
    public static bool TryParseExact(string input, string format, IFormatProvider formatProvider, TimeSpan& result);
    public static bool TryParseExact(string input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result);
    public static bool TryParseExact(string input, String[] formats, IFormatProvider formatProvider, TimeSpan& result);
}
[ObsoleteAttribute("System.TimeZone has been deprecated.  Please investigate the use of System.TimeZoneInfo instead.")]
public abstract class System.TimeZone : object {
    public static TimeZone CurrentTimeZone { get; }
    public string DaylightName { get; }
    public string StandardName { get; }
    public static TimeZone get_CurrentTimeZone();
    public abstract virtual string get_DaylightName();
    public abstract virtual string get_StandardName();
    public abstract virtual DaylightTime GetDaylightChanges(int year);
    public abstract virtual TimeSpan GetUtcOffset(DateTime time);
    public virtual bool IsDaylightSavingTime(DateTime time);
    public static bool IsDaylightSavingTime(DateTime time, DaylightTime daylightTimes);
    public virtual DateTime ToLocalTime(DateTime time);
    public virtual DateTime ToUniversalTime(DateTime time);
}
public class System.TimeZoneInfo : object {
    public TimeSpan BaseUtcOffset { get; }
    public string DaylightName { get; }
    public string DisplayName { get; }
    public string Id { get; }
    public static TimeZoneInfo Local { get; }
    public string StandardName { get; }
    public bool SupportsDaylightSavingTime { get; }
    public static TimeZoneInfo Utc { get; }
    public TimeSpan get_BaseUtcOffset();
    public string get_DaylightName();
    public string get_DisplayName();
    public string get_Id();
    public static TimeZoneInfo get_Local();
    public string get_StandardName();
    public bool get_SupportsDaylightSavingTime();
    public static TimeZoneInfo get_Utc();
    public static void ClearCachedData();
    public static DateTime ConvertTime(DateTime dateTime, TimeZoneInfo destinationTimeZone);
    public static DateTime ConvertTime(DateTime dateTime, TimeZoneInfo sourceTimeZone, TimeZoneInfo destinationTimeZone);
    public static DateTimeOffset ConvertTime(DateTimeOffset dateTimeOffset, TimeZoneInfo destinationTimeZone);
    public static DateTime ConvertTimeBySystemTimeZoneId(DateTime dateTime, string destinationTimeZoneId);
    public static DateTime ConvertTimeBySystemTimeZoneId(DateTime dateTime, string sourceTimeZoneId, string destinationTimeZoneId);
    public static DateTimeOffset ConvertTimeBySystemTimeZoneId(DateTimeOffset dateTimeOffset, string destinationTimeZoneId);
    public static DateTime ConvertTimeFromUtc(DateTime dateTime, TimeZoneInfo destinationTimeZone);
    public static DateTime ConvertTimeToUtc(DateTime dateTime);
    public static DateTime ConvertTimeToUtc(DateTime dateTime, TimeZoneInfo sourceTimeZone);
    public static TimeZoneInfo CreateCustomTimeZone(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName);
    public static TimeZoneInfo CreateCustomTimeZone(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, AdjustmentRule[] adjustmentRules);
    public static TimeZoneInfo CreateCustomTimeZone(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, AdjustmentRule[] adjustmentRules, bool disableDaylightSavingTime);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(TimeZoneInfo other);
    public static TimeZoneInfo FindSystemTimeZoneById(string id);
    public static TimeZoneInfo FromSerializedString(string source);
    public AdjustmentRule[] GetAdjustmentRules();
    public TimeSpan[] GetAmbiguousTimeOffsets(DateTime dateTime);
    public TimeSpan[] GetAmbiguousTimeOffsets(DateTimeOffset dateTimeOffset);
    public virtual int GetHashCode();
    public static ReadOnlyCollection`1<TimeZoneInfo> GetSystemTimeZones();
    public TimeSpan GetUtcOffset(DateTime dateTime);
    public TimeSpan GetUtcOffset(DateTimeOffset dateTimeOffset);
    public bool HasSameRules(TimeZoneInfo other);
    public bool IsAmbiguousTime(DateTime dateTime);
    public bool IsAmbiguousTime(DateTimeOffset dateTimeOffset);
    public bool IsDaylightSavingTime(DateTime dateTime);
    public bool IsDaylightSavingTime(DateTimeOffset dateTimeOffset);
    public bool IsInvalidTime(DateTime dateTime);
    public string ToSerializedString();
    public virtual string ToString();
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.TimeZoneNotFoundException : Exception {
    protected TimeZoneNotFoundException(SerializationInfo info, StreamingContext context);
    public TimeZoneNotFoundException(string message);
    public TimeZoneNotFoundException(string message, Exception innerException);
}
public static class System.Tuple : object {
    public static Tuple`1<T1> Create(T1 item1);
    public static Tuple`2<T1, T2> Create(T1 item1, T2 item2);
    public static Tuple`3<T1, T2, T3> Create(T1 item1, T2 item2, T3 item3);
    public static Tuple`4<T1, T2, T3, T4> Create(T1 item1, T2 item2, T3 item3, T4 item4);
    public static Tuple`5<T1, T2, T3, T4, T5> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
    public static Tuple`6<T1, T2, T3, T4, T5, T6> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
    public static Tuple`7<T1, T2, T3, T4, T5, T6, T7> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
    public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`1<T8>> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8);
}
public class System.Tuple`1 : object {
    public T1 Item1 { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    public Tuple`1(T1 item1);
    public T1 get_Item1();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public virtual string ToString();
}
public class System.Tuple`2 : object {
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    public Tuple`2(T1 item1, T2 item2);
    public T1 get_Item1();
    public T2 get_Item2();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public virtual string ToString();
}
public class System.Tuple`3 : object {
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    public Tuple`3(T1 item1, T2 item2, T3 item3);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public virtual string ToString();
}
public class System.Tuple`4 : object {
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    public Tuple`4(T1 item1, T2 item2, T3 item3, T4 item4);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public virtual string ToString();
}
public class System.Tuple`5 : object {
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    public Tuple`5(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public virtual string ToString();
}
public class System.Tuple`6 : object {
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    public T6 Item6 { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    public Tuple`6(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
    public T6 get_Item6();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public virtual string ToString();
}
public class System.Tuple`7 : object {
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    public T6 Item6 { get; }
    public T7 Item7 { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    public Tuple`7(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
    public T6 get_Item6();
    public T7 get_Item7();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public virtual string ToString();
}
public class System.Tuple`8 : object {
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    public T6 Item6 { get; }
    public T7 Item7 { get; }
    public TRest Rest { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    public Tuple`8(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
    public T6 get_Item6();
    public T7 get_Item7();
    public TRest get_Rest();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public virtual string ToString();
}
[ExtensionAttribute]
public static class System.TupleExtensions : object {
    [ExtensionAttribute]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`7<T15, T16, T17, T18, T19, T20, T21>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17, T18& item18, T19& item19, T20& item20, T21& item21);
    [ExtensionAttribute]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`6<T15, T16, T17, T18, T19, T20>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17, T18& item18, T19& item19, T20& item20);
    [ExtensionAttribute]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`5<T15, T16, T17, T18, T19>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17, T18& item18, T19& item19);
    [ExtensionAttribute]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`4<T15, T16, T17, T18>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17, T18& item18);
    [ExtensionAttribute]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`3<T15, T16, T17>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17);
    [ExtensionAttribute]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`2<T15, T16>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16);
    [ExtensionAttribute]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`1<T15>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15);
    [ExtensionAttribute]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`7<T8, T9, T10, T11, T12, T13, T14>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14);
    [ExtensionAttribute]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`6<T8, T9, T10, T11, T12, T13>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13);
    [ExtensionAttribute]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`5<T8, T9, T10, T11, T12>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12);
    [ExtensionAttribute]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`4<T8, T9, T10, T11>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11);
    [ExtensionAttribute]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`3<T8, T9, T10>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10);
    [ExtensionAttribute]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`2<T8, T9>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9);
    [ExtensionAttribute]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`1<T8>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8);
    [ExtensionAttribute]
public static void Deconstruct(Tuple`7<T1, T2, T3, T4, T5, T6, T7> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7);
    [ExtensionAttribute]
public static void Deconstruct(Tuple`6<T1, T2, T3, T4, T5, T6> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6);
    [ExtensionAttribute]
public static void Deconstruct(Tuple`5<T1, T2, T3, T4, T5> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5);
    [ExtensionAttribute]
public static void Deconstruct(Tuple`4<T1, T2, T3, T4> value, T1& item1, T2& item2, T3& item3, T4& item4);
    [ExtensionAttribute]
public static void Deconstruct(Tuple`3<T1, T2, T3> value, T1& item1, T2& item2, T3& item3);
    [ExtensionAttribute]
public static void Deconstruct(Tuple`2<T1, T2> value, T1& item1, T2& item2);
    [ExtensionAttribute]
public static void Deconstruct(Tuple`1<T1> value, T1& item1);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`7<T15, T16, T17, T18, T19, T20, T21>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`7<T15, T16, T17, T18, T19, T20, T21>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`6<T15, T16, T17, T18, T19, T20>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`6<T15, T16, T17, T18, T19, T20>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`5<T15, T16, T17, T18, T19>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`5<T15, T16, T17, T18, T19>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`4<T15, T16, T17, T18>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`4<T15, T16, T17, T18>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`3<T15, T16, T17>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`3<T15, T16, T17>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`2<T15, T16>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`2<T15, T16>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`1<T15>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`1<T15>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`7<T8, T9, T10, T11, T12, T13, T14>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`7<T8, T9, T10, T11, T12, T13, T14>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`6<T8, T9, T10, T11, T12, T13>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`6<T8, T9, T10, T11, T12, T13>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`5<T8, T9, T10, T11, T12>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`5<T8, T9, T10, T11, T12>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`4<T8, T9, T10, T11>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`4<T8, T9, T10, T11>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`3<T8, T9, T10>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`3<T8, T9, T10>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`2<T8, T9>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`2<T8, T9>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`1<T8>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`1<T8>> value);
    [ExtensionAttribute]
public static Tuple`7<T1, T2, T3, T4, T5, T6, T7> ToTuple(ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> value);
    [ExtensionAttribute]
public static Tuple`6<T1, T2, T3, T4, T5, T6> ToTuple(ValueTuple`6<T1, T2, T3, T4, T5, T6> value);
    [ExtensionAttribute]
public static Tuple`5<T1, T2, T3, T4, T5> ToTuple(ValueTuple`5<T1, T2, T3, T4, T5> value);
    [ExtensionAttribute]
public static Tuple`4<T1, T2, T3, T4> ToTuple(ValueTuple`4<T1, T2, T3, T4> value);
    [ExtensionAttribute]
public static Tuple`3<T1, T2, T3> ToTuple(ValueTuple`3<T1, T2, T3> value);
    [ExtensionAttribute]
public static Tuple`2<T1, T2> ToTuple(ValueTuple`2<T1, T2> value);
    [ExtensionAttribute]
public static Tuple`1<T1> ToTuple(ValueTuple`1<T1> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`7<T15, T16, T17, T18, T19, T20, T21>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`7<T15, T16, T17, T18, T19, T20, T21>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`6<T15, T16, T17, T18, T19, T20>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`6<T15, T16, T17, T18, T19, T20>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`5<T15, T16, T17, T18, T19>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`5<T15, T16, T17, T18, T19>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`4<T15, T16, T17, T18>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`4<T15, T16, T17, T18>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`3<T15, T16, T17>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`3<T15, T16, T17>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`2<T15, T16>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`2<T15, T16>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`1<T15>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`1<T15>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`7<T8, T9, T10, T11, T12, T13, T14>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`7<T8, T9, T10, T11, T12, T13, T14>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`6<T8, T9, T10, T11, T12, T13>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`6<T8, T9, T10, T11, T12, T13>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`5<T8, T9, T10, T11, T12>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`5<T8, T9, T10, T11, T12>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`4<T8, T9, T10, T11>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`4<T8, T9, T10, T11>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`3<T8, T9, T10>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`3<T8, T9, T10>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`2<T8, T9>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`2<T8, T9>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`1<T8>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`1<T8>> value);
    [ExtensionAttribute]
public static ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> ToValueTuple(Tuple`7<T1, T2, T3, T4, T5, T6, T7> value);
    [ExtensionAttribute]
public static ValueTuple`6<T1, T2, T3, T4, T5, T6> ToValueTuple(Tuple`6<T1, T2, T3, T4, T5, T6> value);
    [ExtensionAttribute]
public static ValueTuple`5<T1, T2, T3, T4, T5> ToValueTuple(Tuple`5<T1, T2, T3, T4, T5> value);
    [ExtensionAttribute]
public static ValueTuple`4<T1, T2, T3, T4> ToValueTuple(Tuple`4<T1, T2, T3, T4> value);
    [ExtensionAttribute]
public static ValueTuple`3<T1, T2, T3> ToValueTuple(Tuple`3<T1, T2, T3> value);
    [ExtensionAttribute]
public static ValueTuple`2<T1, T2> ToValueTuple(Tuple`2<T1, T2> value);
    [ExtensionAttribute]
public static ValueTuple`1<T1> ToValueTuple(Tuple`1<T1> value);
}
public abstract class System.Type : MemberInfo {
    public static char Delimiter;
    public static Type[] EmptyTypes;
    public static MemberFilter FilterAttribute;
    public static MemberFilter FilterName;
    public static MemberFilter FilterNameIgnoreCase;
    public static object Missing;
    public Assembly Assembly { get; }
    public string AssemblyQualifiedName { get; }
    public TypeAttributes Attributes { get; }
    public Type BaseType { get; }
    public bool ContainsGenericParameters { get; }
    public MethodBase DeclaringMethod { get; }
    public Type DeclaringType { get; }
    public static Binder DefaultBinder { get; }
    public string FullName { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public int GenericParameterPosition { get; }
    public Type[] GenericTypeArguments { get; }
    public Guid GUID { get; }
    public bool HasElementType { get; }
    public bool IsAbstract { get; }
    public bool IsAnsiClass { get; }
    public bool IsArray { get; }
    public bool IsAutoClass { get; }
    public bool IsAutoLayout { get; }
    public bool IsByRef { get; }
    public bool IsClass { get; }
    public bool IsCOMObject { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsContextful { get; }
    public bool IsEnum { get; }
    public bool IsExplicitLayout { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericType { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsImport { get; }
    public bool IsInterface { get; }
    public bool IsLayoutSequential { get; }
    public bool IsMarshalByRef { get; }
    public bool IsNested { get; }
    public bool IsNestedAssembly { get; }
    public bool IsNestedFamANDAssem { get; }
    public bool IsNestedFamily { get; }
    public bool IsNestedFamORAssem { get; }
    public bool IsNestedPrivate { get; }
    public bool IsNestedPublic { get; }
    public bool IsNotPublic { get; }
    public bool IsPointer { get; }
    public bool IsPrimitive { get; }
    public bool IsPublic { get; }
    public bool IsSealed { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public bool IsSerializable { get; }
    public bool IsSpecialName { get; }
    public bool IsTypeDefinition { get; }
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    public bool IsUnicodeClass { get; }
    public bool IsValueType { get; }
    public bool IsVisible { get; }
    public MemberTypes MemberType { get; }
    public Module Module { get; }
    public string Namespace { get; }
    public Type ReflectedType { get; }
    public StructLayoutAttribute StructLayoutAttribute { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public ConstructorInfo TypeInitializer { get; }
    public Type UnderlyingSystemType { get; }
    [SecuritySafeCriticalAttribute]
public static bool op_Equality(Type left, Type right);
    [SecuritySafeCriticalAttribute]
public static bool op_Inequality(Type left, Type right);
    public abstract virtual Assembly get_Assembly();
    public abstract virtual string get_AssemblyQualifiedName();
    public TypeAttributes get_Attributes();
    public abstract virtual Type get_BaseType();
    public virtual bool get_ContainsGenericParameters();
    public virtual MethodBase get_DeclaringMethod();
    public virtual Type get_DeclaringType();
    public static Binder get_DefaultBinder();
    public abstract virtual string get_FullName();
    public virtual GenericParameterAttributes get_GenericParameterAttributes();
    public virtual int get_GenericParameterPosition();
    public virtual Type[] get_GenericTypeArguments();
    public abstract virtual Guid get_GUID();
    public bool get_HasElementType();
    public bool get_IsAbstract();
    public bool get_IsAnsiClass();
    public bool get_IsArray();
    public bool get_IsAutoClass();
    public bool get_IsAutoLayout();
    public bool get_IsByRef();
    public bool get_IsClass();
    public bool get_IsCOMObject();
    public virtual bool get_IsConstructedGenericType();
    public bool get_IsContextful();
    public virtual bool get_IsEnum();
    public bool get_IsExplicitLayout();
    public virtual bool get_IsGenericParameter();
    public virtual bool get_IsGenericType();
    public virtual bool get_IsGenericTypeDefinition();
    public bool get_IsImport();
    [SecuritySafeCriticalAttribute]
public bool get_IsInterface();
    public bool get_IsLayoutSequential();
    public bool get_IsMarshalByRef();
    public bool get_IsNested();
    public bool get_IsNestedAssembly();
    public bool get_IsNestedFamANDAssem();
    public bool get_IsNestedFamily();
    public bool get_IsNestedFamORAssem();
    public bool get_IsNestedPrivate();
    public bool get_IsNestedPublic();
    public bool get_IsNotPublic();
    public bool get_IsPointer();
    public bool get_IsPrimitive();
    public bool get_IsPublic();
    public bool get_IsSealed();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    public virtual bool get_IsSerializable();
    public bool get_IsSpecialName();
    public virtual bool get_IsTypeDefinition();
    public virtual bool get_IsSZArray();
    public virtual bool get_IsVariableBoundArray();
    public bool get_IsUnicodeClass();
    public bool get_IsValueType();
    public bool get_IsVisible();
    public virtual MemberTypes get_MemberType();
    public abstract virtual Module get_Module();
    public abstract virtual string get_Namespace();
    public virtual Type get_ReflectedType();
    public virtual StructLayoutAttribute get_StructLayoutAttribute();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public ConstructorInfo get_TypeInitializer();
    public abstract virtual Type get_UnderlyingSystemType();
    public virtual bool Equals(object o);
    public virtual bool Equals(Type o);
    public virtual Type[] FindInterfaces(TypeFilter filter, object filterCriteria);
    public virtual MemberInfo[] FindMembers(MemberTypes memberType, BindingFlags bindingAttr, MemberFilter filter, object filterCriteria);
    public virtual int GetArrayRank();
    protected abstract virtual TypeAttributes GetAttributeFlagsImpl();
    public ConstructorInfo GetConstructor(BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
    public ConstructorInfo GetConstructor(Type[] types);
    protected abstract virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public ConstructorInfo[] GetConstructors();
    public abstract virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    public ConstructorInfo GetConstructor(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual MemberInfo[] GetDefaultMembers();
    public abstract virtual Type GetElementType();
    public virtual string GetEnumName(object value);
    public virtual String[] GetEnumNames();
    public virtual Type GetEnumUnderlyingType();
    public virtual Array GetEnumValues();
    public EventInfo GetEvent(string name);
    public abstract virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents();
    public abstract virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public FieldInfo GetField(string name);
    public abstract virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public FieldInfo[] GetFields();
    public abstract virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public virtual Type[] GetGenericArguments();
    public virtual Type[] GetGenericParameterConstraints();
    public virtual Type GetGenericTypeDefinition();
    public virtual int GetHashCode();
    public Type GetInterface(string name);
    public abstract virtual Type GetInterface(string name, bool ignoreCase);
    public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    public abstract virtual Type[] GetInterfaces();
    public MemberInfo[] GetMember(string name);
    public virtual MemberInfo[] GetMember(string name, BindingFlags bindingAttr);
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public MemberInfo[] GetMembers();
    public abstract virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    public MethodInfo GetMethod(string name);
    public sealed virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr);
    public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public sealed virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
    public MethodInfo GetMethod(string name, Type[] types);
    public MethodInfo GetMethod(string name, Type[] types, ParameterModifier[] modifiers);
    protected abstract virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public MethodInfo[] GetMethods();
    public abstract virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public Type GetNestedType(string name);
    public abstract virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public Type[] GetNestedTypes();
    public abstract virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public PropertyInfo[] GetProperties();
    public abstract virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    public PropertyInfo GetProperty(string name);
    public sealed virtual PropertyInfo GetProperty(string name, BindingFlags bindingAttr);
    public sealed virtual PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public PropertyInfo GetProperty(string name, Type returnType);
    public PropertyInfo GetProperty(string name, Type returnType, Type[] types);
    public PropertyInfo GetProperty(string name, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public PropertyInfo GetProperty(string name, Type[] types);
    protected abstract virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public Type GetType();
    public static Type GetType(string typeName);
    public static Type GetType(string typeName, bool throwOnError);
    public static Type GetType(string typeName, bool throwOnError, bool ignoreCase);
    public static Type GetType(string typeName, Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver);
    public static Type GetType(string typeName, Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver, bool throwOnError);
    public static Type GetType(string typeName, Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver, bool throwOnError, bool ignoreCase);
    public static Type[] GetTypeArray(Object[] args);
    public static TypeCode GetTypeCode(Type type);
    protected virtual TypeCode GetTypeCodeImpl();
    [SecuritySafeCriticalAttribute]
public static Type GetTypeFromCLSID(Guid clsid);
    [SecuritySafeCriticalAttribute]
public static Type GetTypeFromCLSID(Guid clsid, bool throwOnError);
    [SecuritySafeCriticalAttribute]
public static Type GetTypeFromCLSID(Guid clsid, string server);
    [SecuritySafeCriticalAttribute]
public static Type GetTypeFromCLSID(Guid clsid, string server, bool throwOnError);
    [SecuritySafeCriticalAttribute]
public static Type GetTypeFromHandle(RuntimeTypeHandle handle);
    [SecurityCriticalAttribute]
public static Type GetTypeFromProgID(string progID);
    [SecurityCriticalAttribute]
public static Type GetTypeFromProgID(string progID, bool throwOnError);
    [SecurityCriticalAttribute]
public static Type GetTypeFromProgID(string progID, string server);
    [SecurityCriticalAttribute]
public static Type GetTypeFromProgID(string progID, string server, bool throwOnError);
    public static RuntimeTypeHandle GetTypeHandle(object o);
    protected abstract virtual bool HasElementTypeImpl();
    public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args);
    public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, CultureInfo culture);
    public abstract virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    protected abstract virtual bool IsArrayImpl();
    public virtual bool IsAssignableFrom(Type c);
    protected abstract virtual bool IsByRefImpl();
    protected abstract virtual bool IsCOMObjectImpl();
    protected virtual bool IsContextfulImpl();
    public virtual bool IsEnumDefined(object value);
    public virtual bool IsEquivalentTo(Type other);
    public virtual bool IsInstanceOfType(object o);
    protected virtual bool IsMarshalByRefImpl();
    protected abstract virtual bool IsPointerImpl();
    protected abstract virtual bool IsPrimitiveImpl();
    public virtual bool IsSubclassOf(Type c);
    protected virtual bool IsValueTypeImpl();
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
    public virtual Type MakeByRefType();
    public virtual Type MakeGenericType(Type[] typeArguments);
    public virtual Type MakePointerType();
    public static Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase);
    public virtual string ToString();
}
public class System.TypeAccessException : TypeLoadException {
    public TypeAccessException(string message);
    public TypeAccessException(string message, Exception inner);
    protected TypeAccessException(SerializationInfo info, StreamingContext context);
}
public enum System.TypeCode : Enum {
    public int value__;
    public static TypeCode Boolean;
    public static TypeCode Byte;
    public static TypeCode Char;
    public static TypeCode DateTime;
    public static TypeCode DBNull;
    public static TypeCode Decimal;
    public static TypeCode Double;
    public static TypeCode Empty;
    public static TypeCode Int16;
    public static TypeCode Int32;
    public static TypeCode Int64;
    public static TypeCode Object;
    public static TypeCode SByte;
    public static TypeCode Single;
    public static TypeCode String;
    public static TypeCode UInt16;
    public static TypeCode UInt32;
    public static TypeCode UInt64;
}
[CLSCompliantAttribute("False")]
public class System.TypedReference : ValueType {
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public static Type GetTargetType(TypedReference value);
    [CLSCompliantAttribute("False")]
public static TypedReference MakeTypedReference(object target, FieldInfo[] flds);
    [CLSCompliantAttribute("False")]
public static void SetTypedReference(TypedReference target, object value);
    public static RuntimeTypeHandle TargetTypeToken(TypedReference value);
    public static object ToObject(TypedReference value);
}
public class System.TypeInitializationException : SystemException {
    public string TypeName { get; }
    public TypeInitializationException(string fullTypeName, Exception innerException);
    public string get_TypeName();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.TypeLoadException : SystemException {
    public string Message { get; }
    public string TypeName { get; }
    public TypeLoadException(string message);
    public TypeLoadException(string message, Exception inner);
    protected TypeLoadException(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
    public string get_TypeName();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.TypeUnloadedException : SystemException {
    public TypeUnloadedException(string message);
    public TypeUnloadedException(string message, Exception innerException);
    protected TypeUnloadedException(SerializationInfo info, StreamingContext context);
}
[CLSCompliantAttribute("False")]
public class System.UInt16 : ValueType {
    public static ushort MaxValue;
    public static ushort MinValue;
    public sealed virtual int CompareTo(ushort value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ushort obj);
    public virtual int GetHashCode();
    [CLSCompliantAttribute("False")]
public static ushort Parse(string s);
    [CLSCompliantAttribute("False")]
public static ushort Parse(string s, NumberStyles style);
    [CLSCompliantAttribute("False")]
public static ushort Parse(string s, NumberStyles style, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ushort Parse(string s, IFormatProvider provider);
    public sealed virtual int CompareTo(object value);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, UInt16& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, UInt16& result);
}
[CLSCompliantAttribute("False")]
public class System.UInt32 : ValueType {
    public static UInt32 MaxValue;
    public static UInt32 MinValue;
    public sealed virtual int CompareTo(UInt32 value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(UInt32 obj);
    public virtual int GetHashCode();
    [CLSCompliantAttribute("False")]
public static UInt32 Parse(string s);
    [CLSCompliantAttribute("False")]
public static UInt32 Parse(string s, NumberStyles style);
    [CLSCompliantAttribute("False")]
public static UInt32 Parse(string s, NumberStyles style, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static UInt32 Parse(string s, IFormatProvider provider);
    public sealed virtual int CompareTo(object value);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, UInt32& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, UInt32& result);
}
[CLSCompliantAttribute("False")]
public class System.UInt64 : ValueType {
    public static ulong MaxValue;
    public static ulong MinValue;
    public sealed virtual int CompareTo(ulong value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ulong obj);
    public virtual int GetHashCode();
    [CLSCompliantAttribute("False")]
public static ulong Parse(string s);
    [CLSCompliantAttribute("False")]
public static ulong Parse(string s, NumberStyles style);
    [CLSCompliantAttribute("False")]
public static ulong Parse(string s, NumberStyles style, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ulong Parse(string s, IFormatProvider provider);
    public sealed virtual int CompareTo(object value);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, NumberStyles style, IFormatProvider provider, UInt64& result);
    [CLSCompliantAttribute("False")]
public static bool TryParse(string s, UInt64& result);
}
[CLSCompliantAttribute("False")]
public class System.UIntPtr : ValueType {
    public static UIntPtr Zero;
    public static int Size { get; }
    public UIntPtr(UInt32 value);
    public UIntPtr(ulong value);
    [CLSCompliantAttribute("False")]
[SecurityCriticalAttribute]
public UIntPtr(Void* value);
    public static int get_Size();
    public static UIntPtr Add(UIntPtr pointer, int offset);
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.IEquatable<System.UIntPtr>.Equals(UIntPtr other);
    public virtual int GetHashCode();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public static UIntPtr op_Addition(UIntPtr pointer, int offset);
    public static bool op_Equality(UIntPtr value1, UIntPtr value2);
    public static UIntPtr op_Explicit(UInt32 value);
    public static UIntPtr op_Explicit(ulong value);
    public static UInt32 op_Explicit(UIntPtr value);
    public static ulong op_Explicit(UIntPtr value);
    [CLSCompliantAttribute("False")]
[SecurityCriticalAttribute]
public static Void* op_Explicit(UIntPtr value);
    [CLSCompliantAttribute("False")]
[SecurityCriticalAttribute]
public static UIntPtr op_Explicit(Void* value);
    public static bool op_Inequality(UIntPtr value1, UIntPtr value2);
    public static UIntPtr op_Subtraction(UIntPtr pointer, int offset);
    public static UIntPtr Subtract(UIntPtr pointer, int offset);
    [CLSCompliantAttribute("False")]
public Void* ToPointer();
    public virtual string ToString();
    public UInt32 ToUInt32();
    public ulong ToUInt64();
}
public class System.UnauthorizedAccessException : SystemException {
    public UnauthorizedAccessException(string message);
    public UnauthorizedAccessException(string message, Exception inner);
    protected UnauthorizedAccessException(SerializationInfo info, StreamingContext context);
}
public class System.UnhandledExceptionEventArgs : EventArgs {
    public object ExceptionObject { get; }
    public bool IsTerminating { get; }
    public UnhandledExceptionEventArgs(object exception, bool isTerminating);
    public object get_ExceptionObject();
    public bool get_IsTerminating();
}
public class System.UnhandledExceptionEventHandler : MulticastDelegate {
    public UnhandledExceptionEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, UnhandledExceptionEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, UnhandledExceptionEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Uri : object {
    public static string SchemeDelimiter;
    public static string UriSchemeFile;
    public static string UriSchemeFtp;
    public static string UriSchemeGopher;
    public static string UriSchemeHttp;
    public static string UriSchemeHttps;
    public static string UriSchemeMailto;
    public static string UriSchemeNetPipe;
    public static string UriSchemeNetTcp;
    public static string UriSchemeNews;
    public static string UriSchemeNntp;
    public string AbsolutePath { get; }
    public string AbsoluteUri { get; }
    public string Authority { get; }
    public string DnsSafeHost { get; }
    public string Fragment { get; }
    public string Host { get; }
    public UriHostNameType HostNameType { get; }
    public string IdnHost { get; }
    public bool IsAbsoluteUri { get; }
    public bool IsDefaultPort { get; }
    public bool IsFile { get; }
    public bool IsLoopback { get; }
    public bool IsUnc { get; }
    public string LocalPath { get; }
    public string OriginalString { get; }
    public string PathAndQuery { get; }
    public int Port { get; }
    public string Query { get; }
    public string Scheme { get; }
    public String[] Segments { get; }
    public bool UserEscaped { get; }
    public string UserInfo { get; }
    protected Uri(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public Uri(string uriString);
    public Uri(string uriString, UriKind uriKind);
    [ObsoleteAttribute("The constructor has been deprecated. Please use new Uri(string). The dontEscape parameter is deprecated and is always false. http://go.microsoft.com/fwlink/?linkid=14202")]
public Uri(string uriString, bool dontEscape);
    public Uri(Uri baseUri, string relativeUri);
    [ObsoleteAttribute("The constructor has been deprecated. Please new Uri(Uri, string). The dontEscape parameter is deprecated and is always false. http://go.microsoft.com/fwlink/?linkid=14202")]
public Uri(Uri baseUri, string relativeUri, bool dontEscape);
    public Uri(Uri baseUri, Uri relativeUri);
    public string get_AbsolutePath();
    public string get_AbsoluteUri();
    public string get_Authority();
    public string get_DnsSafeHost();
    public string get_Fragment();
    public string get_Host();
    public UriHostNameType get_HostNameType();
    public string get_IdnHost();
    public bool get_IsAbsoluteUri();
    public bool get_IsDefaultPort();
    public bool get_IsFile();
    public bool get_IsLoopback();
    public bool get_IsUnc();
    public string get_LocalPath();
    public string get_OriginalString();
    public string get_PathAndQuery();
    public int get_Port();
    public string get_Query();
    public string get_Scheme();
    public String[] get_Segments();
    public bool get_UserEscaped();
    public string get_UserInfo();
    [ObsoleteAttribute("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")]
protected virtual void Canonicalize();
    public static UriHostNameType CheckHostName(string name);
    public static bool CheckSchemeName(string schemeName);
    [ObsoleteAttribute("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")]
protected virtual void CheckSecurity();
    public static int Compare(Uri uri1, Uri uri2, UriComponents partsToCompare, UriFormat compareFormat, StringComparison comparisonType);
    public virtual bool Equals(object comparand);
    [ObsoleteAttribute("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")]
protected virtual void Escape();
    public static string EscapeDataString(string stringToEscape);
    [ObsoleteAttribute("The method has been deprecated. Please use GetComponents() or static EscapeUriString() to escape a Uri component or a string. http://go.microsoft.com/fwlink/?linkid=14202")]
protected static string EscapeString(string str);
    public static string EscapeUriString(string stringToEscape);
    public static int FromHex(char digit);
    public string GetComponents(UriComponents components, UriFormat format);
    public virtual int GetHashCode();
    public bool IsBaseOf(Uri uri);
    public string GetLeftPart(UriPartial part);
    protected void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public static string HexEscape(char character);
    public static char HexUnescape(string pattern, Int32& index);
    [ObsoleteAttribute("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")]
protected virtual bool IsBadFileSystemCharacter(char character);
    [ObsoleteAttribute("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")]
protected static bool IsExcludedCharacter(char character);
    public static bool IsHexDigit(char character);
    public static bool IsHexEncoding(string pattern, int index);
    [ObsoleteAttribute("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")]
protected virtual bool IsReservedCharacter(char character);
    public bool IsWellFormedOriginalString();
    public static bool IsWellFormedUriString(string uriString, UriKind uriKind);
    [ObsoleteAttribute("The method has been deprecated. Please use MakeRelativeUri(Uri uri). http://go.microsoft.com/fwlink/?linkid=14202")]
public string MakeRelative(Uri toUri);
    public Uri MakeRelativeUri(Uri uri);
    public static bool op_Equality(Uri uri1, Uri uri2);
    public static bool op_Inequality(Uri uri1, Uri uri2);
    [ObsoleteAttribute("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")]
protected virtual void Parse();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual string ToString();
    public static bool TryCreate(string uriString, UriKind uriKind, Uri& result);
    public static bool TryCreate(Uri baseUri, string relativeUri, Uri& result);
    public static bool TryCreate(Uri baseUri, Uri relativeUri, Uri& result);
    [ObsoleteAttribute("The method has been deprecated. Please use GetComponents() or static UnescapeDataString() to unescape a Uri component or a string. http://go.microsoft.com/fwlink/?linkid=14202")]
protected virtual string Unescape(string path);
    public static string UnescapeDataString(string stringToUnescape);
}
[FlagsAttribute]
public enum System.UriComponents : Enum {
    public int value__;
    public static UriComponents AbsoluteUri;
    public static UriComponents Fragment;
    public static UriComponents Host;
    public static UriComponents HostAndPort;
    public static UriComponents HttpRequestUrl;
    public static UriComponents KeepDelimiter;
    public static UriComponents NormalizedHost;
    public static UriComponents Path;
    public static UriComponents PathAndQuery;
    public static UriComponents Port;
    public static UriComponents Query;
    public static UriComponents Scheme;
    public static UriComponents SchemeAndServer;
    public static UriComponents SerializationInfoString;
    public static UriComponents StrongAuthority;
    public static UriComponents StrongPort;
    public static UriComponents UserInfo;
}
public enum System.UriFormat : Enum {
    public int value__;
    public static UriFormat SafeUnescaped;
    public static UriFormat Unescaped;
    public static UriFormat UriEscaped;
}
public class System.UriFormatException : FormatException {
    protected UriFormatException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public UriFormatException(string textString);
    public UriFormatException(string textString, Exception e);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
public enum System.UriHostNameType : Enum {
    public int value__;
    public static UriHostNameType Basic;
    public static UriHostNameType Dns;
    public static UriHostNameType IPv4;
    public static UriHostNameType IPv6;
    public static UriHostNameType Unknown;
}
public enum System.UriKind : Enum {
    public int value__;
    public static UriKind Absolute;
    public static UriKind Relative;
    public static UriKind RelativeOrAbsolute;
}
public abstract class System.UriParser : object {
    protected virtual string GetComponents(Uri uri, UriComponents components, UriFormat format);
    protected virtual void InitializeAndValidate(Uri uri, UriFormatException& parsingError);
    protected virtual bool IsBaseOf(Uri baseUri, Uri relativeUri);
    public static bool IsKnownScheme(string schemeName);
    protected virtual bool IsWellFormedOriginalString(Uri uri);
    protected virtual UriParser OnNewUri();
    protected virtual void OnRegister(string schemeName, int defaultPort);
    public static void Register(UriParser uriParser, string schemeName, int defaultPort);
    protected virtual string Resolve(Uri baseUri, Uri relativeUri, UriFormatException& parsingError);
}
public enum System.UriPartial : Enum {
    public int value__;
    public static UriPartial Authority;
    public static UriPartial Path;
    public static UriPartial Query;
    public static UriPartial Scheme;
}
public class System.ValueTuple : ValueType {
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    public static ValueTuple Create();
    public static ValueTuple`1<T1> Create(T1 item1);
    public static ValueTuple`2<T1, T2> Create(T1 item1, T2 item2);
    public static ValueTuple`3<T1, T2, T3> Create(T1 item1, T2 item2, T3 item3);
    public static ValueTuple`4<T1, T2, T3, T4> Create(T1 item1, T2 item2, T3 item3, T4 item4);
    public static ValueTuple`5<T1, T2, T3, T4, T5> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
    public static ValueTuple`6<T1, T2, T3, T4, T5, T6> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
    public static ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
    public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`1<T8>> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8);
}
public class System.ValueTuple`1 : ValueType {
    public T1 Item1;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public ValueTuple`1(T1 item1);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`1<T1> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`1<T1> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
public class System.ValueTuple`2 : ValueType {
    public T1 Item1;
    public T2 Item2;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public ValueTuple`2(T1 item1, T2 item2);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`2<T1, T2> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`2<T1, T2> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
public class System.ValueTuple`3 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public ValueTuple`3(T1 item1, T2 item2, T3 item3);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`3<T1, T2, T3> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`3<T1, T2, T3> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
public class System.ValueTuple`4 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public ValueTuple`4(T1 item1, T2 item2, T3 item3, T4 item4);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`4<T1, T2, T3, T4> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`4<T1, T2, T3, T4> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
public class System.ValueTuple`5 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    public T5 Item5;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public ValueTuple`5(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`5<T1, T2, T3, T4, T5> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`5<T1, T2, T3, T4, T5> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
public class System.ValueTuple`6 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    public T5 Item5;
    public T6 Item6;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public ValueTuple`6(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`6<T1, T2, T3, T4, T5, T6> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`6<T1, T2, T3, T4, T5, T6> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
public class System.ValueTuple`7 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    public T5 Item5;
    public T6 Item6;
    public T7 Item7;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public ValueTuple`7(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
public class System.ValueTuple`8 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    public T5 Item5;
    public T6 Item6;
    public T7 Item7;
    public TRest Rest;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public ValueTuple`8(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, TRest> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, TRest> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
public abstract class System.ValueType : object {
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class System.Version : object {
    public int Build { get; }
    public int Major { get; }
    public short MajorRevision { get; }
    public int Minor { get; }
    public short MinorRevision { get; }
    public int Revision { get; }
    public Version(int major, int minor);
    public Version(int major, int minor, int build);
    public Version(int major, int minor, int build, int revision);
    public Version(string version);
    public int get_Build();
    public int get_Major();
    public short get_MajorRevision();
    public int get_Minor();
    public short get_MinorRevision();
    public int get_Revision();
    public sealed virtual object Clone();
    public sealed virtual int CompareTo(object version);
    public sealed virtual int CompareTo(Version value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Version obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Version v1, Version v2);
    public static bool op_GreaterThan(Version v1, Version v2);
    public static bool op_GreaterThanOrEqual(Version v1, Version v2);
    public static bool op_Inequality(Version v1, Version v2);
    public static bool op_LessThan(Version v1, Version v2);
    public static bool op_LessThanOrEqual(Version v1, Version v2);
    public static Version Parse(string input);
    public virtual string ToString();
    public string ToString(int fieldCount);
    public static bool TryParse(string input, Version& result);
}
public class System.Void : ValueType {
}
public class System.WeakReference : object {
    public bool IsAlive { get; }
    public object Target { get; public set; }
    public bool TrackResurrection { get; }
    public WeakReference(object target);
    public WeakReference(object target, bool trackResurrection);
    protected WeakReference(SerializationInfo info, StreamingContext context);
    public virtual bool get_IsAlive();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual object get_Target();
    public virtual void set_Target(object value);
    public virtual bool get_TrackResurrection();
    protected virtual override void Finalize();
}
public class System.WeakReference`1 : object {
    public WeakReference`1(T target);
    public WeakReference`1(T target, bool trackResurrection);
    protected virtual override void Finalize();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public void SetTarget(T target);
    public bool TryGetTarget(T& target);
}
