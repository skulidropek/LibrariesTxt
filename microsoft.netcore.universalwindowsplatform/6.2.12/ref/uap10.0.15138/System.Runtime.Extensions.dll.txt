public class System.AppDomain : MarshalByRefObject {
    public static AppDomain CurrentDomain { get; }
    public string BaseDirectory { get; }
    public string RelativeSearchPath { get; }
    public string DynamicDirectory { get; }
    public string FriendlyName { get; }
    public int Id { get; }
    public bool IsFullyTrusted { get; }
    public bool IsHomogenous { get; }
    public static bool MonitoringIsEnabled { get; public set; }
    public long MonitoringSurvivedMemorySize { get; }
    public static long MonitoringSurvivedProcessMemorySize { get; }
    public long MonitoringTotalAllocatedMemorySize { get; }
    public TimeSpan MonitoringTotalProcessorTime { get; }
    public bool ShadowCopyFiles { get; }
    public static AppDomain get_CurrentDomain();
    public string get_BaseDirectory();
    public string get_RelativeSearchPath();
    public void add_UnhandledException(UnhandledExceptionEventHandler value);
    public void remove_UnhandledException(UnhandledExceptionEventHandler value);
    public string get_DynamicDirectory();
    public string get_FriendlyName();
    public int get_Id();
    public bool get_IsFullyTrusted();
    public bool get_IsHomogenous();
    public static bool get_MonitoringIsEnabled();
    public static void set_MonitoringIsEnabled(bool value);
    public long get_MonitoringSurvivedMemorySize();
    public static long get_MonitoringSurvivedProcessMemorySize();
    public long get_MonitoringTotalAllocatedMemorySize();
    public TimeSpan get_MonitoringTotalProcessorTime();
    public void add_AssemblyLoad(AssemblyLoadEventHandler value);
    public void remove_AssemblyLoad(AssemblyLoadEventHandler value);
    public void add_AssemblyResolve(ResolveEventHandler value);
    public void remove_AssemblyResolve(ResolveEventHandler value);
    public void add_DomainUnload(EventHandler value);
    public void remove_DomainUnload(EventHandler value);
    public void add_FirstChanceException(EventHandler`1<FirstChanceExceptionEventArgs> value);
    public void remove_FirstChanceException(EventHandler`1<FirstChanceExceptionEventArgs> value);
    public void add_ProcessExit(EventHandler value);
    public void remove_ProcessExit(EventHandler value);
    public void add_ReflectionOnlyAssemblyResolve(ResolveEventHandler value);
    public void remove_ReflectionOnlyAssemblyResolve(ResolveEventHandler value);
    public void add_ResourceResolve(ResolveEventHandler value);
    public void remove_ResourceResolve(ResolveEventHandler value);
    public void add_TypeResolve(ResolveEventHandler value);
    public void remove_TypeResolve(ResolveEventHandler value);
    public string ApplyPolicy(string assemblyName);
    public static AppDomain CreateDomain(string friendlyName);
    public int ExecuteAssembly(string assemblyFile);
    public int ExecuteAssembly(string assemblyFile, String[] args);
    public int ExecuteAssembly(string assemblyFile, String[] args, Byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm);
    public int ExecuteAssemblyByName(AssemblyName assemblyName, String[] args);
    public int ExecuteAssemblyByName(string assemblyName);
    public int ExecuteAssemblyByName(string assemblyName, String[] args);
    public Assembly[] GetAssemblies();
    [ObsoleteAttribute("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.  http://go.microsoft.com/fwlink/?linkid=14202", "False")]
public static int GetCurrentThreadId();
    public object GetData(string name);
    public Nullable`1<bool> IsCompatibilitySwitchSet(string value);
    public bool IsDefaultAppDomain();
    public bool IsFinalizingForUnload();
    public Assembly Load(Byte[] rawAssembly);
    public Assembly Load(Byte[] rawAssembly, Byte[] rawSymbolStore);
    public Assembly Load(AssemblyName assemblyRef);
    public Assembly Load(string assemblyString);
    public Assembly[] ReflectionOnlyGetAssemblies();
    public void SetData(string name, object data);
    [ObsoleteAttribute("AppDomain.SetDynamicBase has been deprecated. Please investigate the use of AppDomainSetup.DynamicBase instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public void SetDynamicBase(string path);
    public void SetPrincipalPolicy(PrincipalPolicy policy);
    public void SetThreadPrincipal(IPrincipal principal);
    public virtual string ToString();
    public static void Unload(AppDomain domain);
    public bool get_ShadowCopyFiles();
    [ObsoleteAttribute("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public void AppendPrivatePath(string path);
    [ObsoleteAttribute("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public void ClearPrivatePath();
    [ObsoleteAttribute("AppDomain.ClearShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public void ClearShadowCopyPath();
    [ObsoleteAttribute("AppDomain.SetCachePath has been deprecated. Please investigate the use of AppDomainSetup.CachePath instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public void SetCachePath(string path);
    [ObsoleteAttribute("AppDomain.SetShadowCopyFiles has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyFiles instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public void SetShadowCopyFiles();
    [ObsoleteAttribute("AppDomain.SetShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public void SetShadowCopyPath(string path);
}
public class System.AppDomainUnloadedException : SystemException {
    protected AppDomainUnloadedException(SerializationInfo info, StreamingContext context);
    public AppDomainUnloadedException(string message);
    public AppDomainUnloadedException(string message, Exception innerException);
}
public class System.ApplicationId : object {
    public string Culture { get; }
    public string Name { get; }
    public string ProcessorArchitecture { get; }
    public Byte[] PublicKeyToken { get; }
    public Version Version { get; }
    public ApplicationId(Byte[] publicKeyToken, string name, Version version, string processorArchitecture, string culture);
    public string get_Culture();
    public string get_Name();
    public string get_ProcessorArchitecture();
    public Byte[] get_PublicKeyToken();
    public Version get_Version();
    public ApplicationId Copy();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class System.AssemblyLoadEventArgs : EventArgs {
    public Assembly LoadedAssembly { get; }
    public AssemblyLoadEventArgs(Assembly loadedAssembly);
    public Assembly get_LoadedAssembly();
}
public class System.AssemblyLoadEventHandler : MulticastDelegate {
    public AssemblyLoadEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, AssemblyLoadEventArgs args);
    public virtual IAsyncResult BeginInvoke(object sender, AssemblyLoadEventArgs args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[FlagsAttribute]
public enum System.Base64FormattingOptions : Enum {
    public int value__;
    public static Base64FormattingOptions None;
    public static Base64FormattingOptions InsertLineBreaks;
}
public static class System.BitConverter : object {
    public static bool IsLittleEndian;
    public static long DoubleToInt64Bits(double value);
    public static Byte[] GetBytes(bool value);
    public static Byte[] GetBytes(char value);
    public static Byte[] GetBytes(double value);
    public static Byte[] GetBytes(short value);
    public static Byte[] GetBytes(int value);
    public static Byte[] GetBytes(long value);
    public static Byte[] GetBytes(float value);
    [CLSCompliantAttribute("False")]
public static Byte[] GetBytes(ushort value);
    [CLSCompliantAttribute("False")]
public static Byte[] GetBytes(UInt32 value);
    [CLSCompliantAttribute("False")]
public static Byte[] GetBytes(ulong value);
    public static float Int32BitsToSingle(int value);
    public static double Int64BitsToDouble(long value);
    public static int SingleToInt32Bits(float value);
    public static bool ToBoolean(Byte[] value, int startIndex);
    public static char ToChar(Byte[] value, int startIndex);
    public static double ToDouble(Byte[] value, int startIndex);
    public static short ToInt16(Byte[] value, int startIndex);
    public static int ToInt32(Byte[] value, int startIndex);
    public static long ToInt64(Byte[] value, int startIndex);
    public static float ToSingle(Byte[] value, int startIndex);
    public static string ToString(Byte[] value);
    public static string ToString(Byte[] value, int startIndex);
    public static string ToString(Byte[] value, int startIndex, int length);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(Byte[] value, int startIndex);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(Byte[] value, int startIndex);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(Byte[] value, int startIndex);
}
public class System.CannotUnloadAppDomainException : SystemException {
    protected CannotUnloadAppDomainException(SerializationInfo info, StreamingContext context);
    public CannotUnloadAppDomainException(string message);
    public CannotUnloadAppDomainException(string message, Exception innerException);
}
public class System.CodeDom.Compiler.IndentedTextWriter : TextWriter {
    public static string DefaultTabString;
    public Encoding Encoding { get; }
    public string NewLine { get; public set; }
    public int Indent { get; public set; }
    public TextWriter InnerWriter { get; }
    internal string TabString { get; }
    public IndentedTextWriter(TextWriter writer);
    public IndentedTextWriter(TextWriter writer, string tabString);
    public virtual Encoding get_Encoding();
    public virtual string get_NewLine();
    public virtual void set_NewLine(string value);
    public int get_Indent();
    public void set_Indent(int value);
    public TextWriter get_InnerWriter();
    internal string get_TabString();
    public virtual void Close();
    public virtual void Flush();
    protected virtual void OutputTabs();
    public virtual void Write(string s);
    public virtual void Write(bool value);
    public virtual void Write(char value);
    public virtual void Write(Char[] buffer);
    public virtual void Write(Char[] buffer, int index, int count);
    public virtual void Write(double value);
    public virtual void Write(float value);
    public virtual void Write(int value);
    public virtual void Write(long value);
    public virtual void Write(object value);
    public virtual void Write(string format, object arg0);
    public virtual void Write(string format, object arg0, object arg1);
    public virtual void Write(string format, Object[] arg);
    public void WriteLineNoTabs(string s);
    public virtual void WriteLine(string s);
    public virtual void WriteLine();
    public virtual void WriteLine(bool value);
    public virtual void WriteLine(char value);
    public virtual void WriteLine(Char[] buffer);
    public virtual void WriteLine(Char[] buffer, int index, int count);
    public virtual void WriteLine(double value);
    public virtual void WriteLine(float value);
    public virtual void WriteLine(int value);
    public virtual void WriteLine(long value);
    public virtual void WriteLine(object value);
    public virtual void WriteLine(string format, object arg0);
    public virtual void WriteLine(string format, object arg0, object arg1);
    public virtual void WriteLine(string format, Object[] arg);
    [CLSCompliantAttribute("False")]
public virtual void WriteLine(UInt32 value);
}
[DefaultMemberAttribute("Item")]
public class System.Collections.ArrayList : object {
    public int Capacity { get; public set; }
    public int Count { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object Item { get; public set; }
    public object SyncRoot { get; }
    public ArrayList(ICollection c);
    public ArrayList(int capacity);
    public virtual int get_Capacity();
    public virtual void set_Capacity(int value);
    public virtual int get_Count();
    public virtual bool get_IsFixedSize();
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsSynchronized();
    public virtual object get_Item(int index);
    public virtual void set_Item(int index, object value);
    public virtual object get_SyncRoot();
    public static ArrayList Adapter(IList list);
    public virtual int Add(object value);
    public virtual void AddRange(ICollection c);
    public virtual int BinarySearch(int index, int count, object value, IComparer comparer);
    public virtual int BinarySearch(object value);
    public virtual int BinarySearch(object value, IComparer comparer);
    public virtual void Clear();
    public virtual object Clone();
    public virtual bool Contains(object item);
    public virtual void CopyTo(Array array);
    public virtual void CopyTo(Array array, int arrayIndex);
    public virtual void CopyTo(int index, Array array, int arrayIndex, int count);
    public static ArrayList FixedSize(ArrayList list);
    public static IList FixedSize(IList list);
    public virtual IEnumerator GetEnumerator();
    public virtual IEnumerator GetEnumerator(int index, int count);
    public virtual ArrayList GetRange(int index, int count);
    public virtual int IndexOf(object value);
    public virtual int IndexOf(object value, int startIndex);
    public virtual int IndexOf(object value, int startIndex, int count);
    public virtual void Insert(int index, object value);
    public virtual void InsertRange(int index, ICollection c);
    public virtual int LastIndexOf(object value);
    public virtual int LastIndexOf(object value, int startIndex);
    public virtual int LastIndexOf(object value, int startIndex, int count);
    public static ArrayList ReadOnly(ArrayList list);
    public static IList ReadOnly(IList list);
    public virtual void Remove(object obj);
    public virtual void RemoveAt(int index);
    public virtual void RemoveRange(int index, int count);
    public static ArrayList Repeat(object value, int count);
    public virtual void Reverse();
    public virtual void Reverse(int index, int count);
    public virtual void SetRange(int index, ICollection c);
    public virtual void Sort();
    public virtual void Sort(IComparer comparer);
    public virtual void Sort(int index, int count, IComparer comparer);
    public static ArrayList Synchronized(ArrayList list);
    public static IList Synchronized(IList list);
    public virtual Object[] ToArray();
    public virtual Array ToArray(Type type);
    public virtual void TrimToSize();
}
public class System.Collections.Comparer : object {
    public static Comparer Default;
    public static Comparer DefaultInvariant;
    public Comparer(CultureInfo culture);
    private Comparer(SerializationInfo info, StreamingContext context);
    public sealed virtual int Compare(object a, object b);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[DefaultMemberAttribute("Item")]
public class System.Collections.Hashtable : object {
    [ObsoleteAttribute("Please use KeyComparer properties.")]
protected IComparer comparer { get; protected set; }
    public int Count { get; }
    protected IEqualityComparer EqualityComparer { get; }
    [ObsoleteAttribute("Please use EqualityComparer property.")]
protected IHashCodeProvider hcp { get; protected set; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object Item { get; public set; }
    public ICollection Keys { get; }
    public object SyncRoot { get; }
    public ICollection Values { get; }
    public Hashtable(IDictionary d);
    public Hashtable(IDictionary d, IEqualityComparer equalityComparer);
    [ObsoleteAttribute("Please use Hashtable(IDictionary, IEqualityComparer) instead.")]
public Hashtable(IDictionary d, IHashCodeProvider hcp, IComparer comparer);
    public Hashtable(IDictionary d, float loadFactor);
    public Hashtable(IDictionary d, float loadFactor, IEqualityComparer equalityComparer);
    [ObsoleteAttribute("Please use Hashtable(IDictionary, float, IEqualityComparer) instead.")]
public Hashtable(IDictionary d, float loadFactor, IHashCodeProvider hcp, IComparer comparer);
    public Hashtable(IEqualityComparer equalityComparer);
    [ObsoleteAttribute("Please use Hashtable(IEqualityComparer) instead.")]
public Hashtable(IHashCodeProvider hcp, IComparer comparer);
    public Hashtable(int capacity);
    public Hashtable(int capacity, IEqualityComparer equalityComparer);
    [ObsoleteAttribute("Please use Hashtable(int, IEqualityComparer) instead.")]
public Hashtable(int capacity, IHashCodeProvider hcp, IComparer comparer);
    public Hashtable(int capacity, float loadFactor);
    public Hashtable(int capacity, float loadFactor, IEqualityComparer equalityComparer);
    [ObsoleteAttribute("Please use Hashtable(int, float, IEqualityComparer) instead.")]
public Hashtable(int capacity, float loadFactor, IHashCodeProvider hcp, IComparer comparer);
    protected Hashtable(SerializationInfo info, StreamingContext context);
    protected IComparer get_comparer();
    protected void set_comparer(IComparer value);
    public virtual int get_Count();
    protected IEqualityComparer get_EqualityComparer();
    protected IHashCodeProvider get_hcp();
    protected void set_hcp(IHashCodeProvider value);
    public virtual bool get_IsFixedSize();
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsSynchronized();
    public virtual object get_Item(object key);
    public virtual void set_Item(object key, object value);
    public virtual ICollection get_Keys();
    public virtual object get_SyncRoot();
    public virtual ICollection get_Values();
    public virtual void Add(object key, object value);
    public virtual void Clear();
    public virtual object Clone();
    public virtual bool Contains(object key);
    public virtual bool ContainsKey(object key);
    public virtual bool ContainsValue(object value);
    public virtual void CopyTo(Array array, int arrayIndex);
    public virtual IDictionaryEnumerator GetEnumerator();
    protected virtual int GetHash(object key);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    protected virtual bool KeyEquals(object item, object key);
    public virtual void OnDeserialization(object sender);
    public virtual void Remove(object key);
    public static Hashtable Synchronized(Hashtable table);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ObsoleteAttribute("Please use IEqualityComparer instead.")]
public interface System.Collections.IHashCodeProvider {
    public abstract virtual int GetHashCode(object obj);
}
public abstract class System.ContextBoundObject : MarshalByRefObject {
}
public class System.ContextMarshalException : SystemException {
    protected ContextMarshalException(SerializationInfo info, StreamingContext context);
    public ContextMarshalException(string message);
    public ContextMarshalException(string message, Exception inner);
}
public class System.ContextStaticAttribute : Attribute {
}
public static class System.Convert : object {
    public static object DBNull;
    public static object ChangeType(object value, TypeCode typeCode);
    public static bool IsDBNull(object value);
    public static int ToBase64CharArray(Byte[] inArray, int offsetIn, int length, Char[] outArray, int offsetOut, Base64FormattingOptions options);
    public static string ToBase64String(Byte[] inArray, Base64FormattingOptions options);
    public static string ToBase64String(Byte[] inArray, int offset, int length, Base64FormattingOptions options);
    public static bool ToBoolean(char value);
    public static bool ToBoolean(DateTime value);
    public static byte ToByte(DateTime value);
    public static char ToChar(bool value);
    public static char ToChar(char value);
    public static char ToChar(DateTime value);
    public static char ToChar(decimal value);
    public static char ToChar(double value);
    public static char ToChar(float value);
    public static DateTime ToDateTime(bool value);
    public static DateTime ToDateTime(byte value);
    public static DateTime ToDateTime(char value);
    public static DateTime ToDateTime(DateTime value);
    public static DateTime ToDateTime(decimal value);
    public static DateTime ToDateTime(double value);
    public static DateTime ToDateTime(short value);
    public static DateTime ToDateTime(int value);
    public static DateTime ToDateTime(long value);
    [CLSCompliantAttribute("False")]
public static DateTime ToDateTime(sbyte value);
    public static DateTime ToDateTime(float value);
    [CLSCompliantAttribute("False")]
public static DateTime ToDateTime(ushort value);
    [CLSCompliantAttribute("False")]
public static DateTime ToDateTime(UInt32 value);
    [CLSCompliantAttribute("False")]
public static DateTime ToDateTime(ulong value);
    public static decimal ToDecimal(char value);
    public static decimal ToDecimal(DateTime value);
    public static double ToDouble(char value);
    public static double ToDouble(DateTime value);
    public static short ToInt16(DateTime value);
    public static int ToInt32(DateTime value);
    public static long ToInt64(DateTime value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(DateTime value);
    public static float ToSingle(char value);
    public static float ToSingle(DateTime value);
    public static string ToString(string value);
    public static string ToString(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(DateTime value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(DateTime value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(DateTime value);
    public static object ChangeType(object value, Type conversionType);
    public static object ChangeType(object value, Type conversionType, IFormatProvider provider);
    public static object ChangeType(object value, TypeCode typeCode, IFormatProvider provider);
    public static Byte[] FromBase64CharArray(Char[] inArray, int offset, int length);
    public static Byte[] FromBase64String(string s);
    public static TypeCode GetTypeCode(object value);
    public static int ToBase64CharArray(Byte[] inArray, int offsetIn, int length, Char[] outArray, int offsetOut);
    public static string ToBase64String(Byte[] inArray);
    public static string ToBase64String(Byte[] inArray, int offset, int length);
    public static bool ToBoolean(bool value);
    public static bool ToBoolean(byte value);
    public static bool ToBoolean(decimal value);
    public static bool ToBoolean(double value);
    public static bool ToBoolean(short value);
    public static bool ToBoolean(int value);
    public static bool ToBoolean(long value);
    public static bool ToBoolean(object value);
    public static bool ToBoolean(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static bool ToBoolean(sbyte value);
    public static bool ToBoolean(float value);
    public static bool ToBoolean(string value);
    public static bool ToBoolean(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static bool ToBoolean(ushort value);
    [CLSCompliantAttribute("False")]
public static bool ToBoolean(UInt32 value);
    [CLSCompliantAttribute("False")]
public static bool ToBoolean(ulong value);
    public static byte ToByte(bool value);
    public static byte ToByte(byte value);
    public static byte ToByte(char value);
    public static byte ToByte(decimal value);
    public static byte ToByte(double value);
    public static byte ToByte(short value);
    public static byte ToByte(int value);
    public static byte ToByte(long value);
    public static byte ToByte(object value);
    public static byte ToByte(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static byte ToByte(sbyte value);
    public static byte ToByte(float value);
    public static byte ToByte(string value);
    public static byte ToByte(string value, IFormatProvider provider);
    public static byte ToByte(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static byte ToByte(ushort value);
    [CLSCompliantAttribute("False")]
public static byte ToByte(UInt32 value);
    [CLSCompliantAttribute("False")]
public static byte ToByte(ulong value);
    public static char ToChar(byte value);
    public static char ToChar(short value);
    public static char ToChar(int value);
    public static char ToChar(long value);
    public static char ToChar(object value);
    public static char ToChar(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static char ToChar(sbyte value);
    public static char ToChar(string value);
    public static char ToChar(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static char ToChar(ushort value);
    [CLSCompliantAttribute("False")]
public static char ToChar(UInt32 value);
    [CLSCompliantAttribute("False")]
public static char ToChar(ulong value);
    public static DateTime ToDateTime(object value);
    public static DateTime ToDateTime(object value, IFormatProvider provider);
    public static DateTime ToDateTime(string value);
    public static DateTime ToDateTime(string value, IFormatProvider provider);
    public static decimal ToDecimal(bool value);
    public static decimal ToDecimal(byte value);
    public static decimal ToDecimal(decimal value);
    public static decimal ToDecimal(double value);
    public static decimal ToDecimal(short value);
    public static decimal ToDecimal(int value);
    public static decimal ToDecimal(long value);
    public static decimal ToDecimal(object value);
    public static decimal ToDecimal(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static decimal ToDecimal(sbyte value);
    public static decimal ToDecimal(float value);
    public static decimal ToDecimal(string value);
    public static decimal ToDecimal(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static decimal ToDecimal(ushort value);
    [CLSCompliantAttribute("False")]
public static decimal ToDecimal(UInt32 value);
    [CLSCompliantAttribute("False")]
public static decimal ToDecimal(ulong value);
    public static double ToDouble(bool value);
    public static double ToDouble(byte value);
    public static double ToDouble(decimal value);
    public static double ToDouble(double value);
    public static double ToDouble(short value);
    public static double ToDouble(int value);
    public static double ToDouble(long value);
    public static double ToDouble(object value);
    public static double ToDouble(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static double ToDouble(sbyte value);
    public static double ToDouble(float value);
    public static double ToDouble(string value);
    public static double ToDouble(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static double ToDouble(ushort value);
    [CLSCompliantAttribute("False")]
public static double ToDouble(UInt32 value);
    [CLSCompliantAttribute("False")]
public static double ToDouble(ulong value);
    public static short ToInt16(bool value);
    public static short ToInt16(byte value);
    public static short ToInt16(char value);
    public static short ToInt16(decimal value);
    public static short ToInt16(double value);
    public static short ToInt16(short value);
    public static short ToInt16(int value);
    public static short ToInt16(long value);
    public static short ToInt16(object value);
    public static short ToInt16(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static short ToInt16(sbyte value);
    public static short ToInt16(float value);
    public static short ToInt16(string value);
    public static short ToInt16(string value, IFormatProvider provider);
    public static short ToInt16(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static short ToInt16(ushort value);
    [CLSCompliantAttribute("False")]
public static short ToInt16(UInt32 value);
    [CLSCompliantAttribute("False")]
public static short ToInt16(ulong value);
    public static int ToInt32(bool value);
    public static int ToInt32(byte value);
    public static int ToInt32(char value);
    public static int ToInt32(decimal value);
    public static int ToInt32(double value);
    public static int ToInt32(short value);
    public static int ToInt32(int value);
    public static int ToInt32(long value);
    public static int ToInt32(object value);
    public static int ToInt32(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static int ToInt32(sbyte value);
    public static int ToInt32(float value);
    public static int ToInt32(string value);
    public static int ToInt32(string value, IFormatProvider provider);
    public static int ToInt32(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static int ToInt32(ushort value);
    [CLSCompliantAttribute("False")]
public static int ToInt32(UInt32 value);
    [CLSCompliantAttribute("False")]
public static int ToInt32(ulong value);
    public static long ToInt64(bool value);
    public static long ToInt64(byte value);
    public static long ToInt64(char value);
    public static long ToInt64(decimal value);
    public static long ToInt64(double value);
    public static long ToInt64(short value);
    public static long ToInt64(int value);
    public static long ToInt64(long value);
    public static long ToInt64(object value);
    public static long ToInt64(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static long ToInt64(sbyte value);
    public static long ToInt64(float value);
    public static long ToInt64(string value);
    public static long ToInt64(string value, IFormatProvider provider);
    public static long ToInt64(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static long ToInt64(ushort value);
    [CLSCompliantAttribute("False")]
public static long ToInt64(UInt32 value);
    [CLSCompliantAttribute("False")]
public static long ToInt64(ulong value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(bool value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(byte value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(char value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(decimal value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(double value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(short value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(int value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(long value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(object value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(sbyte value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(float value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(string value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(ushort value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(UInt32 value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(ulong value);
    public static float ToSingle(bool value);
    public static float ToSingle(byte value);
    public static float ToSingle(decimal value);
    public static float ToSingle(double value);
    public static float ToSingle(short value);
    public static float ToSingle(int value);
    public static float ToSingle(long value);
    public static float ToSingle(object value);
    public static float ToSingle(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static float ToSingle(sbyte value);
    public static float ToSingle(float value);
    public static float ToSingle(string value);
    public static float ToSingle(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static float ToSingle(ushort value);
    [CLSCompliantAttribute("False")]
public static float ToSingle(UInt32 value);
    [CLSCompliantAttribute("False")]
public static float ToSingle(ulong value);
    public static string ToString(bool value);
    public static string ToString(bool value, IFormatProvider provider);
    public static string ToString(byte value);
    public static string ToString(byte value, IFormatProvider provider);
    public static string ToString(byte value, int toBase);
    public static string ToString(char value);
    public static string ToString(char value, IFormatProvider provider);
    public static string ToString(DateTime value);
    public static string ToString(DateTime value, IFormatProvider provider);
    public static string ToString(decimal value);
    public static string ToString(decimal value, IFormatProvider provider);
    public static string ToString(double value);
    public static string ToString(double value, IFormatProvider provider);
    public static string ToString(short value);
    public static string ToString(short value, IFormatProvider provider);
    public static string ToString(short value, int toBase);
    public static string ToString(int value);
    public static string ToString(int value, IFormatProvider provider);
    public static string ToString(int value, int toBase);
    public static string ToString(long value);
    public static string ToString(long value, IFormatProvider provider);
    public static string ToString(long value, int toBase);
    public static string ToString(object value);
    public static string ToString(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static string ToString(sbyte value);
    [CLSCompliantAttribute("False")]
public static string ToString(sbyte value, IFormatProvider provider);
    public static string ToString(float value);
    public static string ToString(float value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static string ToString(ushort value);
    [CLSCompliantAttribute("False")]
public static string ToString(ushort value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static string ToString(UInt32 value);
    [CLSCompliantAttribute("False")]
public static string ToString(UInt32 value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static string ToString(ulong value);
    [CLSCompliantAttribute("False")]
public static string ToString(ulong value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(bool value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(byte value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(char value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(decimal value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(double value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(short value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(int value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(long value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(object value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(sbyte value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(float value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(string value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(ushort value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(UInt32 value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(ulong value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(bool value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(byte value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(char value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(decimal value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(double value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(short value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(int value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(long value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(object value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(sbyte value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(float value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(string value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(ushort value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(UInt32 value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(ulong value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(bool value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(byte value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(char value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(decimal value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(double value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(short value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(int value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(long value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(object value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(sbyte value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(float value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(string value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(ushort value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(UInt32 value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(ulong value);
}
public class System.Diagnostics.Stopwatch : object {
    public static long Frequency;
    public static bool IsHighResolution;
    public TimeSpan Elapsed { get; }
    public long ElapsedMilliseconds { get; }
    public long ElapsedTicks { get; }
    public bool IsRunning { get; }
    public TimeSpan get_Elapsed();
    public long get_ElapsedMilliseconds();
    public long get_ElapsedTicks();
    public bool get_IsRunning();
    public static long GetTimestamp();
    public void Reset();
    public void Restart();
    public void Start();
    public static Stopwatch StartNew();
    public void Stop();
}
public static class System.Environment : object {
    public static string CommandLine { get; }
    public static string CurrentDirectory { get; public set; }
    public static int CurrentManagedThreadId { get; }
    public static int ExitCode { get; public set; }
    public static bool HasShutdownStarted { get; }
    public static bool Is64BitProcess { get; }
    public static bool Is64BitOperatingSystem { get; }
    public static string MachineName { get; }
    public static string NewLine { get; }
    public static OperatingSystem OSVersion { get; }
    public static int ProcessorCount { get; }
    public static string StackTrace { get; }
    public static string SystemDirectory { get; }
    public static int SystemPageSize { get; }
    public static int TickCount { get; }
    public static bool UserInteractive { get; }
    public static string UserName { get; }
    public static string UserDomainName { get; }
    public static Version Version { get; }
    public static long WorkingSet { get; }
    public static string get_CommandLine();
    public static string get_CurrentDirectory();
    public static void set_CurrentDirectory(string value);
    public static int get_CurrentManagedThreadId();
    public static int get_ExitCode();
    public static void set_ExitCode(int value);
    public static bool get_HasShutdownStarted();
    public static bool get_Is64BitProcess();
    public static bool get_Is64BitOperatingSystem();
    public static string get_MachineName();
    public static string get_NewLine();
    public static OperatingSystem get_OSVersion();
    public static int get_ProcessorCount();
    public static string get_StackTrace();
    public static string get_SystemDirectory();
    public static int get_SystemPageSize();
    public static int get_TickCount();
    public static bool get_UserInteractive();
    public static string get_UserName();
    public static string get_UserDomainName();
    public static Version get_Version();
    public static long get_WorkingSet();
    public static string ExpandEnvironmentVariables(string name);
    public static void Exit(int exitCode);
    [SecurityCriticalAttribute]
public static void FailFast(string message);
    [SecurityCriticalAttribute]
public static void FailFast(string message, Exception exception);
    public static String[] GetCommandLineArgs();
    public static string GetEnvironmentVariable(string variable);
    public static string GetEnvironmentVariable(string variable, EnvironmentVariableTarget target);
    public static IDictionary GetEnvironmentVariables();
    public static IDictionary GetEnvironmentVariables(EnvironmentVariableTarget target);
    public static string GetFolderPath(SpecialFolder folder);
    public static string GetFolderPath(SpecialFolder folder, SpecialFolderOption option);
    public static String[] GetLogicalDrives();
    public static void SetEnvironmentVariable(string variable, string value);
    public static void SetEnvironmentVariable(string variable, string value, EnvironmentVariableTarget target);
}
public enum System.EnvironmentVariableTarget : Enum {
    public int value__;
    public static EnvironmentVariableTarget Process;
    public static EnvironmentVariableTarget User;
    public static EnvironmentVariableTarget Machine;
}
[ExtensionAttribute]
public static class System.Globalization.GlobalizationExtensions : object {
    [ExtensionAttribute]
public static StringComparer GetStringComparer(CompareInfo compareInfo, CompareOptions options);
}
public class System.IO.BinaryReader : object {
    public Stream BaseStream { get; }
    public BinaryReader(Stream input);
    public BinaryReader(Stream input, Encoding encoding);
    public BinaryReader(Stream input, Encoding encoding, bool leaveOpen);
    public virtual Stream get_BaseStream();
    public virtual void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual void FillBuffer(int numBytes);
    public virtual int PeekChar();
    public virtual int Read();
    public virtual int Read(Byte[] buffer, int index, int count);
    public virtual int Read(Char[] buffer, int index, int count);
    protected internal int Read7BitEncodedInt();
    public virtual bool ReadBoolean();
    public virtual byte ReadByte();
    public virtual Byte[] ReadBytes(int count);
    public virtual char ReadChar();
    public virtual Char[] ReadChars(int count);
    public virtual decimal ReadDecimal();
    public virtual double ReadDouble();
    public virtual short ReadInt16();
    public virtual int ReadInt32();
    public virtual long ReadInt64();
    [CLSCompliantAttribute("False")]
public virtual sbyte ReadSByte();
    public virtual float ReadSingle();
    public virtual string ReadString();
    [CLSCompliantAttribute("False")]
public virtual ushort ReadUInt16();
    [CLSCompliantAttribute("False")]
public virtual UInt32 ReadUInt32();
    [CLSCompliantAttribute("False")]
public virtual ulong ReadUInt64();
}
public class System.IO.BinaryWriter : object {
    public static BinaryWriter Null;
    protected Stream OutStream;
    public Stream BaseStream { get; }
    public BinaryWriter(Stream output);
    public BinaryWriter(Stream output, Encoding encoding);
    public BinaryWriter(Stream output, Encoding encoding, bool leaveOpen);
    public virtual Stream get_BaseStream();
    public virtual void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    public virtual long Seek(int offset, SeekOrigin origin);
    public virtual void Write(bool value);
    public virtual void Write(byte value);
    public virtual void Write(Byte[] buffer);
    public virtual void Write(Byte[] buffer, int index, int count);
    public virtual void Write(char ch);
    public virtual void Write(Char[] chars);
    public virtual void Write(Char[] chars, int index, int count);
    public virtual void Write(decimal value);
    public virtual void Write(double value);
    public virtual void Write(short value);
    public virtual void Write(int value);
    public virtual void Write(long value);
    [CLSCompliantAttribute("False")]
public virtual void Write(sbyte value);
    public virtual void Write(float value);
    public virtual void Write(string value);
    [CLSCompliantAttribute("False")]
public virtual void Write(ushort value);
    [CLSCompliantAttribute("False")]
public virtual void Write(UInt32 value);
    [CLSCompliantAttribute("False")]
public virtual void Write(ulong value);
    protected void Write7BitEncodedInt(int value);
}
public class System.IO.BufferedStream : Stream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public Stream UnderlyingStream { get; }
    public int BufferSize { get; }
    public BufferedStream(Stream stream);
    public BufferedStream(Stream stream, int bufferSize);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    protected virtual void Dispose(bool disposing);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] array, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] array, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
    public Stream get_UnderlyingStream();
    public int get_BufferSize();
}
public class System.IO.EndOfStreamException : IOException {
    public EndOfStreamException(string message);
    public EndOfStreamException(string message, Exception innerException);
    protected EndOfStreamException(SerializationInfo info, StreamingContext context);
}
public class System.IO.InvalidDataException : SystemException {
    public InvalidDataException(string message);
    public InvalidDataException(string message, Exception innerException);
}
public class System.IO.MemoryStream : Stream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public int Capacity { get; public set; }
    public long Length { get; }
    public long Position { get; public set; }
    public MemoryStream(Byte[] buffer);
    public MemoryStream(Byte[] buffer, bool writable);
    public MemoryStream(Byte[] buffer, int index, int count);
    public MemoryStream(Byte[] buffer, int index, int count, bool writable);
    public MemoryStream(Byte[] buffer, int index, int count, bool writable, bool publiclyVisible);
    public MemoryStream(int capacity);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual int get_Capacity();
    public virtual void set_Capacity(int value);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void CopyTo(Stream destination, int bufferSize);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual Byte[] GetBuffer();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin loc);
    public virtual void SetLength(long value);
    public virtual Byte[] ToArray();
    public virtual bool TryGetBuffer(ArraySegment`1& buffer);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
    public virtual void WriteTo(Stream stream);
}
public static class System.IO.Path : object {
    public static char AltDirectorySeparatorChar;
    public static char DirectorySeparatorChar;
    [ObsoleteAttribute("Please use GetInvalidPathChars or GetInvalidFileNameChars instead.")]
public static Char[] InvalidPathChars;
    public static char PathSeparator;
    public static char VolumeSeparatorChar;
    public static string ChangeExtension(string path, string extension);
    public static string Combine(string path1, string path2);
    public static string Combine(string path1, string path2, string path3);
    public static string Combine(string path1, string path2, string path3, string path4);
    public static string Combine(String[] paths);
    public static string GetDirectoryName(string path);
    public static string GetExtension(string path);
    public static string GetFileName(string path);
    public static string GetFileNameWithoutExtension(string path);
    public static string GetFullPath(string path);
    public static Char[] GetInvalidFileNameChars();
    public static Char[] GetInvalidPathChars();
    public static string GetPathRoot(string path);
    public static string GetRandomFileName();
    public static string GetTempFileName();
    public static string GetTempPath();
    public static bool HasExtension(string path);
    public static bool IsPathRooted(string path);
    public static string GetRelativePath(string relativeTo, string path);
}
public class System.IO.StreamReader : TextReader {
    public static StreamReader Null;
    public Stream BaseStream { get; }
    public Encoding CurrentEncoding { get; }
    public bool EndOfStream { get; }
    public StreamReader(Stream stream);
    public StreamReader(Stream stream, bool detectEncodingFromByteOrderMarks);
    public StreamReader(Stream stream, Encoding encoding);
    public StreamReader(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks);
    public StreamReader(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);
    public StreamReader(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize, bool leaveOpen);
    public StreamReader(string path);
    public StreamReader(string path, bool detectEncodingFromByteOrderMarks);
    public StreamReader(string path, Encoding encoding);
    public StreamReader(string path, Encoding encoding, bool detectEncodingFromByteOrderMarks);
    public StreamReader(string path, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);
    public virtual Stream get_BaseStream();
    public virtual Encoding get_CurrentEncoding();
    public bool get_EndOfStream();
    public void DiscardBufferedData();
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public virtual int Peek();
    public virtual int Read();
    public virtual int Read(Char[] buffer, int index, int count);
    public virtual Task`1<int> ReadAsync(Char[] buffer, int index, int count);
    public virtual int ReadBlock(Char[] buffer, int index, int count);
    public virtual Task`1<int> ReadBlockAsync(Char[] buffer, int index, int count);
    public virtual string ReadLine();
    public virtual Task`1<string> ReadLineAsync();
    public virtual string ReadToEnd();
    public virtual Task`1<string> ReadToEndAsync();
}
public class System.IO.StreamWriter : TextWriter {
    public static StreamWriter Null;
    public bool AutoFlush { get; public set; }
    public Stream BaseStream { get; }
    public Encoding Encoding { get; }
    public StreamWriter(Stream stream);
    public StreamWriter(Stream stream, Encoding encoding);
    public StreamWriter(Stream stream, Encoding encoding, int bufferSize);
    public StreamWriter(Stream stream, Encoding encoding, int bufferSize, bool leaveOpen);
    public StreamWriter(string path);
    public StreamWriter(string path, bool append);
    public StreamWriter(string path, bool append, Encoding encoding);
    public StreamWriter(string path, bool append, Encoding encoding, int bufferSize);
    public virtual bool get_AutoFlush();
    public virtual void set_AutoFlush(bool value);
    public virtual Stream get_BaseStream();
    public virtual Encoding get_Encoding();
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    public virtual Task FlushAsync();
    public virtual void Write(char value);
    public virtual void Write(Char[] buffer);
    public virtual void Write(Char[] buffer, int index, int count);
    public virtual void Write(string value);
    public virtual Task WriteAsync(char value);
    public virtual Task WriteAsync(Char[] buffer, int index, int count);
    public virtual Task WriteAsync(string value);
    public virtual Task WriteLineAsync();
    public virtual Task WriteLineAsync(char value);
    public virtual Task WriteLineAsync(Char[] buffer, int index, int count);
    public virtual Task WriteLineAsync(string value);
}
public class System.IO.StringReader : TextReader {
    public StringReader(string s);
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public virtual int Peek();
    public virtual int Read();
    public virtual int Read(Char[] buffer, int index, int count);
    public virtual Task`1<int> ReadAsync(Char[] buffer, int index, int count);
    public virtual Task`1<int> ReadBlockAsync(Char[] buffer, int index, int count);
    public virtual string ReadLine();
    public virtual Task`1<string> ReadLineAsync();
    public virtual string ReadToEnd();
    public virtual Task`1<string> ReadToEndAsync();
}
public class System.IO.StringWriter : TextWriter {
    public Encoding Encoding { get; }
    public StringWriter(IFormatProvider formatProvider);
    public StringWriter(StringBuilder sb);
    public StringWriter(StringBuilder sb, IFormatProvider formatProvider);
    public virtual Encoding get_Encoding();
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public virtual Task FlushAsync();
    public virtual StringBuilder GetStringBuilder();
    public virtual string ToString();
    public virtual void Write(char value);
    public virtual void Write(Char[] buffer, int index, int count);
    public virtual void Write(string value);
    public virtual Task WriteAsync(char value);
    public virtual Task WriteAsync(Char[] buffer, int index, int count);
    public virtual Task WriteAsync(string value);
    public virtual Task WriteLineAsync(char value);
    public virtual Task WriteLineAsync(Char[] buffer, int index, int count);
    public virtual Task WriteLineAsync(string value);
}
public abstract class System.IO.TextReader : MarshalByRefObject {
    public static TextReader Null;
    public virtual void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual int Peek();
    public virtual int Read();
    public virtual int Read(Char[] buffer, int index, int count);
    public virtual Task`1<int> ReadAsync(Char[] buffer, int index, int count);
    public virtual int ReadBlock(Char[] buffer, int index, int count);
    public virtual Task`1<int> ReadBlockAsync(Char[] buffer, int index, int count);
    public virtual string ReadLine();
    public virtual Task`1<string> ReadLineAsync();
    public virtual string ReadToEnd();
    public virtual Task`1<string> ReadToEndAsync();
    public static TextReader Synchronized(TextReader reader);
}
public abstract class System.IO.TextWriter : MarshalByRefObject {
    protected Char[] CoreNewLine;
    public static TextWriter Null;
    public Encoding Encoding { get; }
    public IFormatProvider FormatProvider { get; }
    public string NewLine { get; public set; }
    protected TextWriter(IFormatProvider formatProvider);
    public abstract virtual Encoding get_Encoding();
    public virtual IFormatProvider get_FormatProvider();
    public virtual string get_NewLine();
    public virtual void set_NewLine(string value);
    public virtual void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    public virtual Task FlushAsync();
    public static TextWriter Synchronized(TextWriter writer);
    public virtual void Write(bool value);
    public virtual void Write(char value);
    public virtual void Write(Char[] buffer);
    public virtual void Write(Char[] buffer, int index, int count);
    public virtual void Write(decimal value);
    public virtual void Write(double value);
    public virtual void Write(int value);
    public virtual void Write(long value);
    public virtual void Write(object value);
    public virtual void Write(float value);
    public virtual void Write(string value);
    public virtual void Write(string format, object arg0);
    public virtual void Write(string format, object arg0, object arg1);
    public virtual void Write(string format, object arg0, object arg1, object arg2);
    public virtual void Write(string format, Object[] arg);
    [CLSCompliantAttribute("False")]
public virtual void Write(UInt32 value);
    [CLSCompliantAttribute("False")]
public virtual void Write(ulong value);
    public virtual Task WriteAsync(char value);
    public Task WriteAsync(Char[] buffer);
    public virtual Task WriteAsync(Char[] buffer, int index, int count);
    public virtual Task WriteAsync(string value);
    public virtual void WriteLine();
    public virtual void WriteLine(bool value);
    public virtual void WriteLine(char value);
    public virtual void WriteLine(Char[] buffer);
    public virtual void WriteLine(Char[] buffer, int index, int count);
    public virtual void WriteLine(decimal value);
    public virtual void WriteLine(double value);
    public virtual void WriteLine(int value);
    public virtual void WriteLine(long value);
    public virtual void WriteLine(object value);
    public virtual void WriteLine(float value);
    public virtual void WriteLine(string value);
    public virtual void WriteLine(string format, object arg0);
    public virtual void WriteLine(string format, object arg0, object arg1);
    public virtual void WriteLine(string format, object arg0, object arg1, object arg2);
    public virtual void WriteLine(string format, Object[] arg);
    [CLSCompliantAttribute("False")]
public virtual void WriteLine(UInt32 value);
    [CLSCompliantAttribute("False")]
public virtual void WriteLine(ulong value);
    public virtual Task WriteLineAsync();
    public virtual Task WriteLineAsync(char value);
    public Task WriteLineAsync(Char[] buffer);
    public virtual Task WriteLineAsync(Char[] buffer, int index, int count);
    public virtual Task WriteLineAsync(string value);
}
public enum System.LoaderOptimization : Enum {
    public int value__;
    [ObsoleteAttribute("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public static LoaderOptimization DisallowBindings;
    [ObsoleteAttribute("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")]
public static LoaderOptimization DomainMask;
    public static LoaderOptimization MultiDomain;
    public static LoaderOptimization MultiDomainHost;
    public static LoaderOptimization NotSpecified;
    public static LoaderOptimization SingleDomain;
}
[AttributeUsageAttribute("64")]
public class System.LoaderOptimizationAttribute : Attribute {
    public LoaderOptimization Value { get; }
    public LoaderOptimizationAttribute(byte value);
    public LoaderOptimizationAttribute(LoaderOptimization value);
    public LoaderOptimization get_Value();
}
public static class System.Math : object {
    public static double PI;
    public static double E;
    public static decimal Abs(decimal value);
    public static double Abs(double value);
    public static short Abs(short value);
    public static int Abs(int value);
    public static long Abs(long value);
    [CLSCompliantAttribute("False")]
public static sbyte Abs(sbyte value);
    public static float Abs(float value);
    public static double Acos(double d);
    public static double Asin(double d);
    public static double Atan(double d);
    public static double Atan2(double y, double x);
    public static long BigMul(int a, int b);
    public static decimal Ceiling(decimal d);
    public static double Ceiling(double a);
    public static byte Clamp(byte value, byte min, byte max);
    public static decimal Clamp(decimal value, decimal min, decimal max);
    public static double Clamp(double value, double min, double max);
    public static short Clamp(short value, short min, short max);
    public static int Clamp(int value, int min, int max);
    public static long Clamp(long value, long min, long max);
    [CLSCompliantAttribute("False")]
public static sbyte Clamp(sbyte value, sbyte min, sbyte max);
    public static float Clamp(float value, float min, float max);
    [CLSCompliantAttribute("False")]
public static ushort Clamp(ushort value, ushort min, ushort max);
    [CLSCompliantAttribute("False")]
public static UInt32 Clamp(UInt32 value, UInt32 min, UInt32 max);
    [CLSCompliantAttribute("False")]
public static ulong Clamp(ulong value, ulong min, ulong max);
    public static double Cos(double d);
    public static double Cosh(double value);
    public static int DivRem(int a, int b, Int32& result);
    public static long DivRem(long a, long b, Int64& result);
    public static double Exp(double d);
    public static decimal Floor(decimal d);
    public static double Floor(double d);
    public static double IEEERemainder(double x, double y);
    public static double Log(double d);
    public static double Log(double a, double newBase);
    public static double Log10(double d);
    public static byte Max(byte val1, byte val2);
    public static decimal Max(decimal val1, decimal val2);
    public static double Max(double val1, double val2);
    public static short Max(short val1, short val2);
    public static int Max(int val1, int val2);
    public static long Max(long val1, long val2);
    [CLSCompliantAttribute("False")]
public static sbyte Max(sbyte val1, sbyte val2);
    public static float Max(float val1, float val2);
    [CLSCompliantAttribute("False")]
public static ushort Max(ushort val1, ushort val2);
    [CLSCompliantAttribute("False")]
public static UInt32 Max(UInt32 val1, UInt32 val2);
    [CLSCompliantAttribute("False")]
public static ulong Max(ulong val1, ulong val2);
    public static byte Min(byte val1, byte val2);
    public static decimal Min(decimal val1, decimal val2);
    public static double Min(double val1, double val2);
    public static short Min(short val1, short val2);
    public static int Min(int val1, int val2);
    public static long Min(long val1, long val2);
    [CLSCompliantAttribute("False")]
public static sbyte Min(sbyte val1, sbyte val2);
    public static float Min(float val1, float val2);
    [CLSCompliantAttribute("False")]
public static ushort Min(ushort val1, ushort val2);
    [CLSCompliantAttribute("False")]
public static UInt32 Min(UInt32 val1, UInt32 val2);
    [CLSCompliantAttribute("False")]
public static ulong Min(ulong val1, ulong val2);
    public static double Pow(double x, double y);
    public static decimal Round(decimal d);
    public static decimal Round(decimal d, int decimals);
    public static decimal Round(decimal d, int decimals, MidpointRounding mode);
    public static decimal Round(decimal d, MidpointRounding mode);
    public static double Round(double a);
    public static double Round(double value, int digits);
    public static double Round(double value, int digits, MidpointRounding mode);
    public static double Round(double value, MidpointRounding mode);
    public static int Sign(decimal value);
    public static int Sign(double value);
    public static int Sign(short value);
    public static int Sign(int value);
    public static int Sign(long value);
    [CLSCompliantAttribute("False")]
public static int Sign(sbyte value);
    public static int Sign(float value);
    public static double Sin(double a);
    public static double Sinh(double value);
    public static double Sqrt(double d);
    public static double Tan(double a);
    public static double Tanh(double value);
    public static decimal Truncate(decimal d);
    public static double Truncate(double d);
}
public static class System.MathF : object {
    public static float PI;
    public static float E;
    public static float Abs(float x);
    public static float Acos(float x);
    public static float Asin(float x);
    public static float Atan(float x);
    public static float Atan2(float y, float x);
    public static float Ceiling(float x);
    public static float Cos(float x);
    public static float Cosh(float x);
    public static float Exp(float x);
    public static float Floor(float x);
    public static float IEEERemainder(float x, float y);
    public static float Log(float x);
    public static float Log(float x, float y);
    public static float Log10(float x);
    public static float Max(float x, float y);
    public static float Min(float x, float y);
    public static float Pow(float x, float y);
    public static float Round(float x);
    public static float Round(float x, int digits);
    public static float Round(float x, int digits, MidpointRounding mode);
    public static float Round(float x, MidpointRounding mode);
    public static int Sign(float x);
    public static float Sin(float x);
    public static float Sinh(float x);
    public static float Sqrt(float x);
    public static float Tan(float x);
    public static float Tanh(float x);
    public static float Truncate(float x);
}
public static class System.Net.WebUtility : object {
    public static string HtmlDecode(string value);
    public static void HtmlDecode(string value, TextWriter output);
    public static string HtmlEncode(string value);
    public static void HtmlEncode(string value, TextWriter output);
    public static string UrlDecode(string encodedValue);
    public static Byte[] UrlDecodeToBytes(Byte[] encodedValue, int offset, int count);
    public static string UrlEncode(string value);
    public static Byte[] UrlEncodeToBytes(Byte[] value, int offset, int count);
}
public class System.OperatingSystem : object {
    public PlatformID Platform { get; }
    public string ServicePack { get; }
    public Version Version { get; }
    public string VersionString { get; }
    public OperatingSystem(PlatformID platform, Version version);
    public PlatformID get_Platform();
    public string get_ServicePack();
    public Version get_Version();
    public sealed virtual object Clone();
    public virtual string ToString();
    public string get_VersionString();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public enum System.PlatformID : Enum {
    public int value__;
    [EditorBrowsableAttribute("1")]
public static PlatformID Win32S;
    [EditorBrowsableAttribute("1")]
public static PlatformID Win32Windows;
    public static PlatformID Win32NT;
    [EditorBrowsableAttribute("1")]
public static PlatformID WinCE;
    public static PlatformID Unix;
    [EditorBrowsableAttribute("1")]
public static PlatformID Xbox;
    [EditorBrowsableAttribute("1")]
public static PlatformID MacOSX;
}
public class System.Progress`1 : object {
    public Progress`1(Action`1<T> handler);
    public void add_ProgressChanged(EventHandler`1<T> value);
    public void remove_ProgressChanged(EventHandler`1<T> value);
    protected virtual void OnReport(T value);
    private sealed virtual override void System.IProgress<T>.Report(T value);
}
public class System.Random : object {
    public Random(int Seed);
    public virtual int Next();
    public virtual int Next(int maxValue);
    public virtual int Next(int minValue, int maxValue);
    public virtual void NextBytes(Byte[] buffer);
    public virtual double NextDouble();
    protected virtual double Sample();
}
public class System.Reflection.AssemblyNameProxy : MarshalByRefObject {
    public AssemblyName GetAssemblyName(string assemblyFile);
}
public class System.ResolveEventHandler : MulticastDelegate {
    public ResolveEventHandler(object object, IntPtr method);
    public virtual Assembly Invoke(object sender, ResolveEventArgs args);
    public virtual IAsyncResult BeginInvoke(object sender, ResolveEventArgs args, AsyncCallback callback, object object);
    public virtual Assembly EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("32767")]
internal class System.Runtime.CompilerServices.__BlockReflectionAttribute : Attribute {
}
[AttributeUsageAttribute("5887")]
public class System.Runtime.Versioning.ComponentGuaranteesAttribute : Attribute {
    public ComponentGuaranteesOptions Guarantees { get; }
    public ComponentGuaranteesAttribute(ComponentGuaranteesOptions guarantees);
    public ComponentGuaranteesOptions get_Guarantees();
}
[FlagsAttribute]
public enum System.Runtime.Versioning.ComponentGuaranteesOptions : Enum {
    public int value__;
    public static ComponentGuaranteesOptions Exchange;
    public static ComponentGuaranteesOptions None;
    public static ComponentGuaranteesOptions SideBySide;
    public static ComponentGuaranteesOptions Stable;
}
public class System.Runtime.Versioning.FrameworkName : object {
    public string FullName { get; }
    public string Identifier { get; }
    public string Profile { get; }
    public Version Version { get; }
    public FrameworkName(string frameworkName);
    public FrameworkName(string identifier, Version version);
    public FrameworkName(string identifier, Version version, string profile);
    public string get_FullName();
    public string get_Identifier();
    public string get_Profile();
    public Version get_Version();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(FrameworkName other);
    public virtual int GetHashCode();
    public static bool op_Equality(FrameworkName left, FrameworkName right);
    public static bool op_Inequality(FrameworkName left, FrameworkName right);
    public virtual string ToString();
}
[AttributeUsageAttribute("224")]
[ConditionalAttribute("RESOURCE_ANNOTATION_WORK")]
public class System.Runtime.Versioning.ResourceConsumptionAttribute : Attribute {
    public ResourceScope ConsumptionScope { get; }
    public ResourceScope ResourceScope { get; }
    public ResourceConsumptionAttribute(ResourceScope resourceScope);
    public ResourceConsumptionAttribute(ResourceScope resourceScope, ResourceScope consumptionScope);
    public ResourceScope get_ConsumptionScope();
    public ResourceScope get_ResourceScope();
}
[AttributeUsageAttribute("480")]
[ConditionalAttribute("RESOURCE_ANNOTATION_WORK")]
public class System.Runtime.Versioning.ResourceExposureAttribute : Attribute {
    public ResourceScope ResourceExposureLevel { get; }
    public ResourceExposureAttribute(ResourceScope exposureLevel);
    public ResourceScope get_ResourceExposureLevel();
}
[FlagsAttribute]
public enum System.Runtime.Versioning.ResourceScope : Enum {
    public int value__;
    public static ResourceScope AppDomain;
    public static ResourceScope Assembly;
    public static ResourceScope Library;
    public static ResourceScope Machine;
    public static ResourceScope None;
    public static ResourceScope Private;
    public static ResourceScope Process;
}
public static class System.Runtime.Versioning.VersioningHelper : object {
    public static string MakeVersionSafeName(string name, ResourceScope from, ResourceScope to);
    public static string MakeVersionSafeName(string name, ResourceScope from, ResourceScope to, Type type);
}
public interface System.Security.IPermission {
    public abstract virtual IPermission Copy();
    public abstract virtual void Demand();
    public abstract virtual IPermission Intersect(IPermission target);
    public abstract virtual bool IsSubsetOf(IPermission target);
    public abstract virtual IPermission Union(IPermission target);
}
public interface System.Security.ISecurityEncodable {
    public abstract virtual void FromXml(SecurityElement e);
    public abstract virtual SecurityElement ToXml();
}
[AttributeUsageAttribute("109")]
public abstract class System.Security.Permissions.CodeAccessSecurityAttribute : SecurityAttribute {
    protected CodeAccessSecurityAttribute(SecurityAction action);
}
public enum System.Security.Permissions.SecurityAction : Enum {
    public int value__;
    public static SecurityAction Assert;
    public static SecurityAction Demand;
    [ObsoleteAttribute("Deny is obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public static SecurityAction Deny;
    public static SecurityAction InheritanceDemand;
    public static SecurityAction LinkDemand;
    public static SecurityAction PermitOnly;
    [ObsoleteAttribute("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public static SecurityAction RequestMinimum;
    [ObsoleteAttribute("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public static SecurityAction RequestOptional;
    [ObsoleteAttribute("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")]
public static SecurityAction RequestRefuse;
}
[AttributeUsageAttribute("109")]
public abstract class System.Security.Permissions.SecurityAttribute : Attribute {
    [CompilerGeneratedAttribute]
private SecurityAction <Action>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Unrestricted>k__BackingField;
    public SecurityAction Action { get; public set; }
    public bool Unrestricted { get; public set; }
    protected SecurityAttribute(SecurityAction action);
    [CompilerGeneratedAttribute]
public SecurityAction get_Action();
    [CompilerGeneratedAttribute]
public void set_Action(SecurityAction value);
    [CompilerGeneratedAttribute]
public bool get_Unrestricted();
    [CompilerGeneratedAttribute]
public void set_Unrestricted(bool value);
    public abstract virtual IPermission CreatePermission();
}
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.SecurityPermissionAttribute : CodeAccessSecurityAttribute {
    [CompilerGeneratedAttribute]
private bool <Assertion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <BindingRedirects>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ControlAppDomain>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ControlDomainPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ControlEvidence>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ControlPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ControlPrincipal>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ControlThread>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Execution>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityPermissionFlag <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Infrastructure>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RemotingConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SerializationFormatter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipVerification>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UnmanagedCode>k__BackingField;
    public bool Assertion { get; public set; }
    public bool BindingRedirects { get; public set; }
    public bool ControlAppDomain { get; public set; }
    public bool ControlDomainPolicy { get; public set; }
    public bool ControlEvidence { get; public set; }
    public bool ControlPolicy { get; public set; }
    public bool ControlPrincipal { get; public set; }
    public bool ControlThread { get; public set; }
    public bool Execution { get; public set; }
    public SecurityPermissionFlag Flags { get; public set; }
    public bool Infrastructure { get; public set; }
    public bool RemotingConfiguration { get; public set; }
    public bool SerializationFormatter { get; public set; }
    public bool SkipVerification { get; public set; }
    public bool UnmanagedCode { get; public set; }
    public SecurityPermissionAttribute(SecurityAction action);
    [CompilerGeneratedAttribute]
public bool get_Assertion();
    [CompilerGeneratedAttribute]
public void set_Assertion(bool value);
    [CompilerGeneratedAttribute]
public bool get_BindingRedirects();
    [CompilerGeneratedAttribute]
public void set_BindingRedirects(bool value);
    [CompilerGeneratedAttribute]
public bool get_ControlAppDomain();
    [CompilerGeneratedAttribute]
public void set_ControlAppDomain(bool value);
    [CompilerGeneratedAttribute]
public bool get_ControlDomainPolicy();
    [CompilerGeneratedAttribute]
public void set_ControlDomainPolicy(bool value);
    [CompilerGeneratedAttribute]
public bool get_ControlEvidence();
    [CompilerGeneratedAttribute]
public void set_ControlEvidence(bool value);
    [CompilerGeneratedAttribute]
public bool get_ControlPolicy();
    [CompilerGeneratedAttribute]
public void set_ControlPolicy(bool value);
    [CompilerGeneratedAttribute]
public bool get_ControlPrincipal();
    [CompilerGeneratedAttribute]
public void set_ControlPrincipal(bool value);
    [CompilerGeneratedAttribute]
public bool get_ControlThread();
    [CompilerGeneratedAttribute]
public void set_ControlThread(bool value);
    [CompilerGeneratedAttribute]
public bool get_Execution();
    [CompilerGeneratedAttribute]
public void set_Execution(bool value);
    [CompilerGeneratedAttribute]
public SecurityPermissionFlag get_Flags();
    [CompilerGeneratedAttribute]
public void set_Flags(SecurityPermissionFlag value);
    [CompilerGeneratedAttribute]
public bool get_Infrastructure();
    [CompilerGeneratedAttribute]
public void set_Infrastructure(bool value);
    [CompilerGeneratedAttribute]
public bool get_RemotingConfiguration();
    [CompilerGeneratedAttribute]
public void set_RemotingConfiguration(bool value);
    [CompilerGeneratedAttribute]
public bool get_SerializationFormatter();
    [CompilerGeneratedAttribute]
public void set_SerializationFormatter(bool value);
    [CompilerGeneratedAttribute]
public bool get_SkipVerification();
    [CompilerGeneratedAttribute]
public void set_SkipVerification(bool value);
    [CompilerGeneratedAttribute]
public bool get_UnmanagedCode();
    [CompilerGeneratedAttribute]
public void set_UnmanagedCode(bool value);
    public virtual IPermission CreatePermission();
}
[FlagsAttribute]
public enum System.Security.Permissions.SecurityPermissionFlag : Enum {
    public int value__;
    public static SecurityPermissionFlag AllFlags;
    public static SecurityPermissionFlag Assertion;
    public static SecurityPermissionFlag BindingRedirects;
    public static SecurityPermissionFlag ControlAppDomain;
    public static SecurityPermissionFlag ControlDomainPolicy;
    public static SecurityPermissionFlag ControlEvidence;
    public static SecurityPermissionFlag ControlPolicy;
    public static SecurityPermissionFlag ControlPrincipal;
    public static SecurityPermissionFlag ControlThread;
    public static SecurityPermissionFlag Execution;
    public static SecurityPermissionFlag Infrastructure;
    public static SecurityPermissionFlag NoFlags;
    public static SecurityPermissionFlag RemotingConfiguration;
    public static SecurityPermissionFlag SerializationFormatter;
    public static SecurityPermissionFlag SkipVerification;
    public static SecurityPermissionFlag UnmanagedCode;
}
public class System.Security.SecurityElement : object {
    [CompilerGeneratedAttribute]
private Hashtable <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private ArrayList <Children>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Tag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    public Hashtable Attributes { get; public set; }
    public ArrayList Children { get; public set; }
    public string Tag { get; public set; }
    public string Text { get; public set; }
    public SecurityElement(string tag);
    public SecurityElement(string tag, string text);
    [CompilerGeneratedAttribute]
public Hashtable get_Attributes();
    [CompilerGeneratedAttribute]
public void set_Attributes(Hashtable value);
    [CompilerGeneratedAttribute]
public ArrayList get_Children();
    [CompilerGeneratedAttribute]
public void set_Children(ArrayList value);
    [CompilerGeneratedAttribute]
public string get_Tag();
    [CompilerGeneratedAttribute]
public void set_Tag(string value);
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public void set_Text(string value);
    public void AddAttribute(string name, string value);
    public void AddChild(SecurityElement child);
    public string Attribute(string name);
    public SecurityElement Copy();
    public bool Equal(SecurityElement other);
    public static string Escape(string str);
    public static SecurityElement FromString(string xml);
    public static bool IsValidAttributeName(string name);
    public static bool IsValidAttributeValue(string value);
    public static bool IsValidTag(string tag);
    public static bool IsValidText(string text);
    public SecurityElement SearchForChildByTag(string tag);
    public string SearchForTextOfTag(string tag);
    public virtual string ToString();
}
public abstract class System.StringComparer : object {
    public static StringComparer CurrentCulture { get; }
    public static StringComparer CurrentCultureIgnoreCase { get; }
    public static StringComparer InvariantCulture { get; }
    public static StringComparer InvariantCultureIgnoreCase { get; }
    public static StringComparer Ordinal { get; }
    public static StringComparer OrdinalIgnoreCase { get; }
    public static StringComparer get_CurrentCulture();
    public static StringComparer get_CurrentCultureIgnoreCase();
    public static StringComparer get_InvariantCulture();
    public static StringComparer get_InvariantCultureIgnoreCase();
    public static StringComparer get_Ordinal();
    public static StringComparer get_OrdinalIgnoreCase();
    public static StringComparer FromComparison(StringComparison comparisonType);
    public abstract virtual int Compare(string x, string y);
    public static StringComparer Create(CultureInfo culture, bool ignoreCase);
    public bool Equals(object x, object y);
    public abstract virtual bool Equals(string x, string y);
    public int GetHashCode(object obj);
    public abstract virtual int GetHashCode(string obj);
    public sealed virtual int Compare(object x, object y);
    private sealed virtual override bool System.Collections.IEqualityComparer.Equals(object x, object y);
    private sealed virtual override int System.Collections.IEqualityComparer.GetHashCode(object obj);
}
[ExtensionAttribute]
public static class System.StringNormalizationExtensions : object {
    [ExtensionAttribute]
public static bool IsNormalized(string value);
    [ExtensionAttribute]
[SecurityCriticalAttribute]
public static bool IsNormalized(string value, NormalizationForm normalizationForm);
    [ExtensionAttribute]
public static string Normalize(string value);
    [ExtensionAttribute]
[SecurityCriticalAttribute]
public static string Normalize(string value, NormalizationForm normalizationForm);
}
public class System.UriBuilder : object {
    public string Fragment { get; public set; }
    public string Host { get; public set; }
    public string Password { get; public set; }
    public string Path { get; public set; }
    public int Port { get; public set; }
    public string Query { get; public set; }
    public string Scheme { get; public set; }
    public Uri Uri { get; }
    public string UserName { get; public set; }
    public UriBuilder(string uri);
    public UriBuilder(string schemeName, string hostName);
    public UriBuilder(string scheme, string host, int portNumber);
    public UriBuilder(string scheme, string host, int port, string pathValue);
    public UriBuilder(string scheme, string host, int port, string path, string extraValue);
    public UriBuilder(Uri uri);
    public string get_Fragment();
    public void set_Fragment(string value);
    public string get_Host();
    public void set_Host(string value);
    public string get_Password();
    public void set_Password(string value);
    public string get_Path();
    public void set_Path(string value);
    public int get_Port();
    public void set_Port(int value);
    public string get_Query();
    public void set_Query(string value);
    public string get_Scheme();
    public void set_Scheme(string value);
    public Uri get_Uri();
    public string get_UserName();
    public void set_UserName(string value);
    public virtual bool Equals(object rparam);
    public virtual int GetHashCode();
    public virtual string ToString();
}
