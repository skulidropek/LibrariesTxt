public class Humanizer.Bytes.ByteRate : object {
    [CompilerGeneratedAttribute]
private ByteSize <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Interval>k__BackingField;
    public ByteSize Size { get; private set; }
    public TimeSpan Interval { get; private set; }
    public ByteRate(ByteSize size, TimeSpan interval);
    [CompilerGeneratedAttribute]
public ByteSize get_Size();
    [CompilerGeneratedAttribute]
private void set_Size(ByteSize value);
    [CompilerGeneratedAttribute]
public TimeSpan get_Interval();
    [CompilerGeneratedAttribute]
private void set_Interval(TimeSpan value);
    public string Humanize(TimeUnit timeUnit);
    public string Humanize(string format, TimeUnit timeUnit);
}
public class Humanizer.Bytes.ByteSize : ValueType {
    public static ByteSize MinValue;
    public static ByteSize MaxValue;
    public static long BitsInByte;
    public static long BytesInKilobyte;
    public static long BytesInMegabyte;
    public static long BytesInGigabyte;
    public static long BytesInTerabyte;
    public static string BitSymbol;
    public static string ByteSymbol;
    public static string KilobyteSymbol;
    public static string MegabyteSymbol;
    public static string GigabyteSymbol;
    public static string TerabyteSymbol;
    [CompilerGeneratedAttribute]
private long <Bits>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Bytes>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Kilobytes>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Megabytes>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Gigabytes>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Terabytes>k__BackingField;
    public long Bits { get; private set; }
    public double Bytes { get; private set; }
    public double Kilobytes { get; private set; }
    public double Megabytes { get; private set; }
    public double Gigabytes { get; private set; }
    public double Terabytes { get; private set; }
    public string LargestWholeNumberSymbol { get; }
    public double LargestWholeNumberValue { get; }
    public ByteSize(double byteSize);
    private static ByteSize();
    [CompilerGeneratedAttribute]
public long get_Bits();
    [CompilerGeneratedAttribute]
private void set_Bits(long value);
    [CompilerGeneratedAttribute]
public double get_Bytes();
    [CompilerGeneratedAttribute]
private void set_Bytes(double value);
    [CompilerGeneratedAttribute]
public double get_Kilobytes();
    [CompilerGeneratedAttribute]
private void set_Kilobytes(double value);
    [CompilerGeneratedAttribute]
public double get_Megabytes();
    [CompilerGeneratedAttribute]
private void set_Megabytes(double value);
    [CompilerGeneratedAttribute]
public double get_Gigabytes();
    [CompilerGeneratedAttribute]
private void set_Gigabytes(double value);
    [CompilerGeneratedAttribute]
public double get_Terabytes();
    [CompilerGeneratedAttribute]
private void set_Terabytes(double value);
    public string get_LargestWholeNumberSymbol();
    public double get_LargestWholeNumberValue();
    public static ByteSize FromBits(long value);
    public static ByteSize FromBytes(double value);
    public static ByteSize FromKilobytes(double value);
    public static ByteSize FromMegabytes(double value);
    public static ByteSize FromGigabytes(double value);
    public static ByteSize FromTerabytes(double value);
    public virtual string ToString();
    public string ToString(string format);
    public virtual bool Equals(object value);
    public sealed virtual bool Equals(ByteSize value);
    public virtual int GetHashCode();
    public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(ByteSize other);
    public ByteSize Add(ByteSize bs);
    public ByteSize AddBits(long value);
    public ByteSize AddBytes(double value);
    public ByteSize AddKilobytes(double value);
    public ByteSize AddMegabytes(double value);
    public ByteSize AddGigabytes(double value);
    public ByteSize AddTerabytes(double value);
    public ByteSize Subtract(ByteSize bs);
    public static ByteSize op_Addition(ByteSize b1, ByteSize b2);
    public static ByteSize op_Increment(ByteSize b);
    public static ByteSize op_UnaryNegation(ByteSize b);
    public static ByteSize op_Decrement(ByteSize b);
    public static bool op_Equality(ByteSize b1, ByteSize b2);
    public static bool op_Inequality(ByteSize b1, ByteSize b2);
    public static bool op_LessThan(ByteSize b1, ByteSize b2);
    public static bool op_LessThanOrEqual(ByteSize b1, ByteSize b2);
    public static bool op_GreaterThan(ByteSize b1, ByteSize b2);
    public static bool op_GreaterThanOrEqual(ByteSize b1, ByteSize b2);
    public static bool TryParse(string s, ByteSize& result);
    public static ByteSize Parse(string s);
}
[ExtensionAttribute]
public static class Humanizer.ByteSizeExtensions : object {
    [ExtensionAttribute]
public static ByteSize Bits(byte input);
    [ExtensionAttribute]
public static ByteSize Bits(sbyte input);
    [ExtensionAttribute]
public static ByteSize Bits(short input);
    [ExtensionAttribute]
public static ByteSize Bits(ushort input);
    [ExtensionAttribute]
public static ByteSize Bits(int input);
    [ExtensionAttribute]
public static ByteSize Bits(UInt32 input);
    [ExtensionAttribute]
public static ByteSize Bits(long input);
    [ExtensionAttribute]
public static ByteSize Bytes(byte input);
    [ExtensionAttribute]
public static ByteSize Bytes(sbyte input);
    [ExtensionAttribute]
public static ByteSize Bytes(short input);
    [ExtensionAttribute]
public static ByteSize Bytes(ushort input);
    [ExtensionAttribute]
public static ByteSize Bytes(int input);
    [ExtensionAttribute]
public static ByteSize Bytes(UInt32 input);
    [ExtensionAttribute]
public static ByteSize Bytes(double input);
    [ExtensionAttribute]
public static ByteSize Bytes(long input);
    [ExtensionAttribute]
public static ByteSize Kilobytes(byte input);
    [ExtensionAttribute]
public static ByteSize Kilobytes(sbyte input);
    [ExtensionAttribute]
public static ByteSize Kilobytes(short input);
    [ExtensionAttribute]
public static ByteSize Kilobytes(ushort input);
    [ExtensionAttribute]
public static ByteSize Kilobytes(int input);
    [ExtensionAttribute]
public static ByteSize Kilobytes(UInt32 input);
    [ExtensionAttribute]
public static ByteSize Kilobytes(double input);
    [ExtensionAttribute]
public static ByteSize Kilobytes(long input);
    [ExtensionAttribute]
public static ByteSize Megabytes(byte input);
    [ExtensionAttribute]
public static ByteSize Megabytes(sbyte input);
    [ExtensionAttribute]
public static ByteSize Megabytes(short input);
    [ExtensionAttribute]
public static ByteSize Megabytes(ushort input);
    [ExtensionAttribute]
public static ByteSize Megabytes(int input);
    [ExtensionAttribute]
public static ByteSize Megabytes(UInt32 input);
    [ExtensionAttribute]
public static ByteSize Megabytes(double input);
    [ExtensionAttribute]
public static ByteSize Megabytes(long input);
    [ExtensionAttribute]
public static ByteSize Gigabytes(byte input);
    [ExtensionAttribute]
public static ByteSize Gigabytes(sbyte input);
    [ExtensionAttribute]
public static ByteSize Gigabytes(short input);
    [ExtensionAttribute]
public static ByteSize Gigabytes(ushort input);
    [ExtensionAttribute]
public static ByteSize Gigabytes(int input);
    [ExtensionAttribute]
public static ByteSize Gigabytes(UInt32 input);
    [ExtensionAttribute]
public static ByteSize Gigabytes(double input);
    [ExtensionAttribute]
public static ByteSize Gigabytes(long input);
    [ExtensionAttribute]
public static ByteSize Terabytes(byte input);
    [ExtensionAttribute]
public static ByteSize Terabytes(sbyte input);
    [ExtensionAttribute]
public static ByteSize Terabytes(short input);
    [ExtensionAttribute]
public static ByteSize Terabytes(ushort input);
    [ExtensionAttribute]
public static ByteSize Terabytes(int input);
    [ExtensionAttribute]
public static ByteSize Terabytes(UInt32 input);
    [ExtensionAttribute]
public static ByteSize Terabytes(double input);
    [ExtensionAttribute]
public static ByteSize Terabytes(long input);
    [ExtensionAttribute]
public static string Humanize(ByteSize input, string format);
    [ExtensionAttribute]
public static ByteRate Per(ByteSize size, TimeSpan interval);
}
[ExtensionAttribute]
public static class Humanizer.CasingExtensions : object {
    [ExtensionAttribute]
public static string ApplyCase(string input, LetterCasing casing);
}
[ExtensionAttribute]
public static class Humanizer.CollectionHumanizeExtensions : object {
    [ExtensionAttribute]
public static string Humanize(IEnumerable`1<T> collection);
    [ExtensionAttribute]
public static string Humanize(IEnumerable`1<T> collection, Func`2<T, string> displayFormatter);
    [ExtensionAttribute]
public static string Humanize(IEnumerable`1<T> collection, string separator);
    [ExtensionAttribute]
public static string Humanize(IEnumerable`1<T> collection, Func`2<T, string> displayFormatter, string separator);
}
internal class Humanizer.Configuration.CollectionFormatterRegistry : LocaliserRegistry`1<ICollectionFormatter> {
}
public static class Humanizer.Configuration.Configurator : object {
    private static LocaliserRegistry`1<ICollectionFormatter> _collectionFormatters;
    private static LocaliserRegistry`1<IFormatter> _formatters;
    private static LocaliserRegistry`1<INumberToWordsConverter> _numberToWordsConverters;
    private static LocaliserRegistry`1<IOrdinalizer> _ordinalizers;
    private static LocaliserRegistry`1<IDateToOrdinalWordConverter> _dateToOrdinalWordConverters;
    private static IDateTimeHumanizeStrategy _dateTimeHumanizeStrategy;
    private static IDateTimeOffsetHumanizeStrategy _dateTimeOffsetHumanizeStrategy;
    private static Func`2<PropertyInfo, bool> DefaultEnumDescriptionPropertyLocator;
    private static Func`2<PropertyInfo, bool> _enumDescriptionPropertyLocator;
    public static LocaliserRegistry`1<ICollectionFormatter> CollectionFormatters { get; }
    public static LocaliserRegistry`1<IFormatter> Formatters { get; }
    public static LocaliserRegistry`1<INumberToWordsConverter> NumberToWordsConverters { get; }
    public static LocaliserRegistry`1<IOrdinalizer> Ordinalizers { get; }
    public static LocaliserRegistry`1<IDateToOrdinalWordConverter> DateToOrdinalWordsConverters { get; }
    internal static ICollectionFormatter CollectionFormatter { get; }
    internal static IOrdinalizer Ordinalizer { get; }
    internal static IDateToOrdinalWordConverter DateToOrdinalWordsConverter { get; }
    public static IDateTimeHumanizeStrategy DateTimeHumanizeStrategy { get; public set; }
    public static IDateTimeOffsetHumanizeStrategy DateTimeOffsetHumanizeStrategy { get; public set; }
    public static Func`2<PropertyInfo, bool> EnumDescriptionPropertyLocator { get; public set; }
    private static Configurator();
    public static LocaliserRegistry`1<ICollectionFormatter> get_CollectionFormatters();
    public static LocaliserRegistry`1<IFormatter> get_Formatters();
    public static LocaliserRegistry`1<INumberToWordsConverter> get_NumberToWordsConverters();
    public static LocaliserRegistry`1<IOrdinalizer> get_Ordinalizers();
    public static LocaliserRegistry`1<IDateToOrdinalWordConverter> get_DateToOrdinalWordsConverters();
    internal static ICollectionFormatter get_CollectionFormatter();
    internal static IFormatter GetFormatter(CultureInfo culture);
    internal static INumberToWordsConverter GetNumberToWordsConverter(CultureInfo culture);
    internal static IOrdinalizer get_Ordinalizer();
    internal static IDateToOrdinalWordConverter get_DateToOrdinalWordsConverter();
    public static IDateTimeHumanizeStrategy get_DateTimeHumanizeStrategy();
    public static void set_DateTimeHumanizeStrategy(IDateTimeHumanizeStrategy value);
    public static IDateTimeOffsetHumanizeStrategy get_DateTimeOffsetHumanizeStrategy();
    public static void set_DateTimeOffsetHumanizeStrategy(IDateTimeOffsetHumanizeStrategy value);
    public static Func`2<PropertyInfo, bool> get_EnumDescriptionPropertyLocator();
    public static void set_EnumDescriptionPropertyLocator(Func`2<PropertyInfo, bool> value);
}
internal class Humanizer.Configuration.DateToOrdinalWordsConverterRegistry : LocaliserRegistry`1<IDateToOrdinalWordConverter> {
}
internal class Humanizer.Configuration.FormatterRegistry : LocaliserRegistry`1<IFormatter> {
    private void RegisterDefaultFormatter(string localeCode);
    private void RegisterCzechSlovakPolishFormatter(string localeCode);
}
public class Humanizer.Configuration.LocaliserRegistry`1 : object {
    private IDictionary`2<string, Func`2<CultureInfo, TLocaliser>> _localisers;
    private Func`2<CultureInfo, TLocaliser> _defaultLocaliser;
    public LocaliserRegistry`1(TLocaliser defaultLocaliser);
    public LocaliserRegistry`1(Func`2<CultureInfo, TLocaliser> defaultLocaliser);
    public TLocaliser ResolveForUiCulture();
    public TLocaliser ResolveForCulture(CultureInfo culture);
    public void Register(string localeCode, TLocaliser localiser);
    public void Register(string localeCode, Func`2<CultureInfo, TLocaliser> localiser);
    private Func`2<CultureInfo, TLocaliser> FindLocaliser(CultureInfo culture);
}
internal class Humanizer.Configuration.NumberToWordsConverterRegistry : LocaliserRegistry`1<INumberToWordsConverter> {
}
internal class Humanizer.Configuration.OrdinalizerRegistry : LocaliserRegistry`1<IOrdinalizer> {
}
[ExtensionAttribute]
public static class Humanizer.DateHumanizeExtensions : object {
    [ExtensionAttribute]
public static string Humanize(DateTime input, bool utcDate, Nullable`1<DateTime> dateToCompareAgainst, CultureInfo culture);
    [ExtensionAttribute]
public static string Humanize(Nullable`1<DateTime> input, bool utcDate, Nullable`1<DateTime> dateToCompareAgainst, CultureInfo culture);
    [ExtensionAttribute]
public static string Humanize(DateTimeOffset input, Nullable`1<DateTimeOffset> dateToCompareAgainst, CultureInfo culture);
    [ExtensionAttribute]
public static string Humanize(Nullable`1<DateTimeOffset> input, Nullable`1<DateTimeOffset> dateToCompareAgainst, CultureInfo culture);
}
internal static class Humanizer.DateTimeHumanizeStrategy.DateTimeHumanizeAlgorithms : object {
    public static string PrecisionHumanize(DateTime input, DateTime comparisonBase, double precision, CultureInfo culture);
    public static string DefaultHumanize(DateTime input, DateTime comparisonBase, CultureInfo culture);
}
public class Humanizer.DateTimeHumanizeStrategy.DefaultDateTimeHumanizeStrategy : object {
    public sealed virtual string Humanize(DateTime input, DateTime comparisonBase, CultureInfo culture);
}
public class Humanizer.DateTimeHumanizeStrategy.DefaultDateTimeOffsetHumanizeStrategy : object {
    public sealed virtual string Humanize(DateTimeOffset input, DateTimeOffset comparisonBase, CultureInfo culture);
}
public interface Humanizer.DateTimeHumanizeStrategy.IDateTimeHumanizeStrategy {
    public abstract virtual string Humanize(DateTime input, DateTime comparisonBase, CultureInfo culture);
}
public interface Humanizer.DateTimeHumanizeStrategy.IDateTimeOffsetHumanizeStrategy {
    public abstract virtual string Humanize(DateTimeOffset input, DateTimeOffset comparisonBase, CultureInfo culture);
}
public class Humanizer.DateTimeHumanizeStrategy.PrecisionDateTimeHumanizeStrategy : object {
    private double _precision;
    public PrecisionDateTimeHumanizeStrategy(double precision);
    public sealed virtual string Humanize(DateTime input, DateTime comparisonBase, CultureInfo culture);
}
public class Humanizer.DateTimeHumanizeStrategy.PrecisionDateTimeOffsetHumanizeStrategy : object {
    private double _precision;
    public PrecisionDateTimeOffsetHumanizeStrategy(double precision);
    public sealed virtual string Humanize(DateTimeOffset input, DateTimeOffset comparisonBase, CultureInfo culture);
}
[ExtensionAttribute]
public static class Humanizer.DateToOrdinalWordsExtensions : object {
    [ExtensionAttribute]
public static string ToOrdinalWords(DateTime input);
    [ExtensionAttribute]
public static string ToOrdinalWords(DateTime input, GrammaticalCase grammaticalCase);
}
[ExtensionAttribute]
public static class Humanizer.EnumDehumanizeExtensions : object {
    [ExtensionAttribute]
public static TTargetEnum DehumanizeTo(string input);
    [ExtensionAttribute]
public static Enum DehumanizeTo(string input, Type targetEnum, OnNoMatch onNoMatch);
    private static object DehumanizeToPrivate(string input, Type targetEnum, OnNoMatch onNoMatch);
}
[ExtensionAttribute]
public static class Humanizer.EnumHumanizeExtensions : object {
    private static string DisplayAttributeTypeName;
    private static string DisplayAttributeGetDescriptionMethodName;
    private static string DisplayAttributeGetNameMethodName;
    private static Func`2<PropertyInfo, bool> StringTypedProperty;
    private static EnumHumanizeExtensions();
    [ExtensionAttribute]
public static string Humanize(Enum input);
    private static bool IsBitFieldEnum(TypeInfo typeInfo);
    private static string GetCustomDescription(MemberInfo memberInfo);
    [ExtensionAttribute]
public static string Humanize(Enum input, LetterCasing casing);
}
internal class Humanizer.FixedLengthTruncator : object {
    public sealed virtual string Truncate(string value, int length, string truncationString, TruncateFrom truncateFrom);
}
internal class Humanizer.FixedNumberOfCharactersTruncator : object {
    public sealed virtual string Truncate(string value, int length, string truncationString, TruncateFrom truncateFrom);
}
internal class Humanizer.FixedNumberOfWordsTruncator : object {
    public sealed virtual string Truncate(string value, int length, string truncationString, TruncateFrom truncateFrom);
    private static string TruncateFromRight(string value, int length, string truncationString);
    private static string TruncateFromLeft(string value, int length, string truncationString);
}
public enum Humanizer.GrammaticalCase : Enum {
    public int value__;
    public static GrammaticalCase Nominative;
    public static GrammaticalCase Genitive;
    public static GrammaticalCase Dative;
    public static GrammaticalCase Accusative;
    public static GrammaticalCase Instrumental;
    public static GrammaticalCase Prepositional;
}
public enum Humanizer.GrammaticalGender : Enum {
    public int value__;
    public static GrammaticalGender Masculine;
    public static GrammaticalGender Feminine;
    public static GrammaticalGender Neuter;
}
public class Humanizer.In : object {
    public static DateTime January { get; }
    public static DateTime February { get; }
    public static DateTime March { get; }
    public static DateTime April { get; }
    public static DateTime May { get; }
    public static DateTime June { get; }
    public static DateTime July { get; }
    public static DateTime August { get; }
    public static DateTime September { get; }
    public static DateTime October { get; }
    public static DateTime November { get; }
    public static DateTime December { get; }
    public static DateTime TheYear(int year);
    public static DateTime get_January();
    public static DateTime JanuaryOf(int year);
    public static DateTime get_February();
    public static DateTime FebruaryOf(int year);
    public static DateTime get_March();
    public static DateTime MarchOf(int year);
    public static DateTime get_April();
    public static DateTime AprilOf(int year);
    public static DateTime get_May();
    public static DateTime MayOf(int year);
    public static DateTime get_June();
    public static DateTime JuneOf(int year);
    public static DateTime get_July();
    public static DateTime JulyOf(int year);
    public static DateTime get_August();
    public static DateTime AugustOf(int year);
    public static DateTime get_September();
    public static DateTime SeptemberOf(int year);
    public static DateTime get_October();
    public static DateTime OctoberOf(int year);
    public static DateTime get_November();
    public static DateTime NovemberOf(int year);
    public static DateTime get_December();
    public static DateTime DecemberOf(int year);
}
public static class Humanizer.Inflections.Vocabularies : object {
    private static Lazy`1<Vocabulary> Instance;
    public static Vocabulary Default { get; }
    private static Vocabularies();
    public static Vocabulary get_Default();
    private static Vocabulary BuildDefault();
}
public class Humanizer.Inflections.Vocabulary : object {
    private List`1<Rule> _plurals;
    private List`1<Rule> _singulars;
    private List`1<string> _uncountables;
    public void AddIrregular(string singular, string plural, bool matchEnding);
    public void AddUncountable(string word);
    public void AddPlural(string rule, string replacement);
    public void AddSingular(string rule, string replacement);
    public string Pluralize(string word, bool inputIsKnownToBeSingular);
    public string Singularize(string word, bool inputIsKnownToBePlural);
    private string ApplyRules(IList`1<Rule> rules, string word);
    private bool IsUncountable(string word);
}
[ExtensionAttribute]
public static class Humanizer.InflectorExtensions : object {
    [ExtensionAttribute]
public static string Pluralize(string word, bool inputIsKnownToBeSingular);
    [ExtensionAttribute]
public static string Singularize(string word, bool inputIsKnownToBePlural);
    [ExtensionAttribute]
public static string Titleize(string input);
    [ExtensionAttribute]
public static string Pascalize(string input);
    [ExtensionAttribute]
public static string Camelize(string input);
    [ExtensionAttribute]
public static string Underscore(string input);
    [ExtensionAttribute]
public static string Dasherize(string underscoredWord);
    [ExtensionAttribute]
public static string Hyphenate(string underscoredWord);
    [ExtensionAttribute]
public static string Kebaberize(string input);
}
public interface Humanizer.IStringTransformer {
    public abstract virtual string Transform(string input);
}
public interface Humanizer.ITruncator {
    public abstract virtual string Truncate(string value, int length, string truncationString, TruncateFrom truncateFrom);
}
public enum Humanizer.LetterCasing : Enum {
    public int value__;
    public static LetterCasing Title;
    public static LetterCasing AllCaps;
    public static LetterCasing LowerCase;
    public static LetterCasing Sentence;
}
internal class Humanizer.Localisation.CollectionFormatters.DefaultCollectionFormatter : object {
    protected string DefaultSeparator;
    public DefaultCollectionFormatter(string defaultSeparator);
    public virtual string Humanize(IEnumerable`1<T> collection);
    public virtual string Humanize(IEnumerable`1<T> collection, Func`2<T, string> objectFormatter);
    public virtual string Humanize(IEnumerable`1<T> collection, string separator);
    public virtual string Humanize(IEnumerable`1<T> collection, Func`2<T, string> objectFormatter, string separator);
    protected virtual string GetConjunctionFormatString(int itemCount);
}
public interface Humanizer.Localisation.CollectionFormatters.ICollectionFormatter {
    public abstract virtual string Humanize(IEnumerable`1<T> collection);
    public abstract virtual string Humanize(IEnumerable`1<T> collection, Func`2<T, string> objectFormatter);
    public abstract virtual string Humanize(IEnumerable`1<T> collection, string separator);
    public abstract virtual string Humanize(IEnumerable`1<T> collection, Func`2<T, string> objectFormatter, string separator);
}
internal class Humanizer.Localisation.CollectionFormatters.OxfordStyleCollectionFormatter : DefaultCollectionFormatter {
    public OxfordStyleCollectionFormatter(string defaultSeparator);
    protected virtual string GetConjunctionFormatString(int itemCount);
}
internal class Humanizer.Localisation.DateToOrdinalWords.DefaultDateToOrdinalWordConverter : object {
    public virtual string Convert(DateTime date);
    public virtual string Convert(DateTime date, GrammaticalCase grammaticalCase);
}
public interface Humanizer.Localisation.DateToOrdinalWords.IDateToOrdinalWordConverter {
    public abstract virtual string Convert(DateTime date);
    public abstract virtual string Convert(DateTime date, GrammaticalCase grammaticalCase);
}
internal class Humanizer.Localisation.DateToOrdinalWords.UsDateToOrdinalWordsConverter : DefaultDateToOrdinalWordConverter {
    public virtual string Convert(DateTime date);
}
internal class Humanizer.Localisation.Formatters.ArabicFormatter : DefaultFormatter {
    private static string DualPostfix;
    private static string PluralPostfix;
    protected virtual string GetResourceKey(string resourceKey, int number);
}
internal class Humanizer.Localisation.Formatters.CroatianFormatter : DefaultFormatter {
    private static string DualTrialQuadralPostfix;
    protected virtual string GetResourceKey(string resourceKey, int number);
}
internal class Humanizer.Localisation.Formatters.CzechSlovakPolishFormatter : DefaultFormatter {
    private static string PaucalPostfix;
    public CzechSlovakPolishFormatter(string localeCode);
    protected virtual string GetResourceKey(string resourceKey, int number);
}
public class Humanizer.Localisation.Formatters.DefaultFormatter : object {
    private CultureInfo _culture;
    public DefaultFormatter(string localeCode);
    public virtual string DateHumanize_Now();
    public virtual string DateHumanize_Never();
    public virtual string DateHumanize(TimeUnit timeUnit, Tense timeUnitTense, int unit);
    public virtual string TimeSpanHumanize_Zero();
    public virtual string TimeSpanHumanize(TimeUnit timeUnit, int unit);
    private string GetResourceForDate(TimeUnit unit, Tense timeUnitTense, int count);
    private string GetResourceForTimeSpan(TimeUnit unit, int count);
    protected virtual string Format(string resourceKey);
    protected virtual string Format(string resourceKey, int number);
    protected virtual string GetResourceKey(string resourceKey, int number);
    protected virtual string GetResourceKey(string resourceKey);
}
internal class Humanizer.Localisation.Formatters.HebrewFormatter : DefaultFormatter {
    private static string DualPostfix;
    private static string PluralPostfix;
    protected virtual string GetResourceKey(string resourceKey, int number);
}
public interface Humanizer.Localisation.Formatters.IFormatter {
    public abstract virtual string DateHumanize_Now();
    public abstract virtual string DateHumanize_Never();
    public abstract virtual string DateHumanize(TimeUnit timeUnit, Tense timeUnitTense, int unit);
    public abstract virtual string TimeSpanHumanize_Zero();
    public abstract virtual string TimeSpanHumanize(TimeUnit timeUnit, int unit);
}
internal class Humanizer.Localisation.Formatters.RomanianFormatter : DefaultFormatter {
    private static int PrepositionIndicatingDecimals;
    private static int MaxNumeralWithNoPreposition;
    private static int MinNumeralWithNoPreposition;
    private static string UnitPreposition;
    private static string RomanianCultureCode;
    private static double Divider;
    private CultureInfo _romanianCulture;
    private static RomanianFormatter();
    protected virtual string Format(string resourceKey, int number);
    private static bool ShouldUsePreposition(int number);
}
internal class Humanizer.Localisation.Formatters.RussianFormatter : DefaultFormatter {
    protected virtual string GetResourceKey(string resourceKey, int number);
    private string GetSuffix(RussianGrammaticalNumber grammaticalNumber);
}
internal class Humanizer.Localisation.Formatters.SerbianFormatter : DefaultFormatter {
    private static string PaucalPostfix;
    public SerbianFormatter(string localeCode);
    protected virtual string GetResourceKey(string resourceKey, int number);
}
internal class Humanizer.Localisation.Formatters.SlovenianFormatter : DefaultFormatter {
    private static string DualPostfix;
    private static string TrialQuadralPostfix;
    protected virtual string GetResourceKey(string resourceKey, int number);
}
internal class Humanizer.Localisation.Formatters.UkrainianFormatter : DefaultFormatter {
    protected virtual string GetResourceKey(string resourceKey, int number);
    private string GetSuffix(RussianGrammaticalNumber grammaticalNumber);
}
internal enum Humanizer.Localisation.GrammaticalNumber.RussianGrammaticalNumber : Enum {
    public int value__;
    public static RussianGrammaticalNumber Singular;
    public static RussianGrammaticalNumber Paucal;
    public static RussianGrammaticalNumber Plural;
}
internal static class Humanizer.Localisation.GrammaticalNumber.RussianGrammaticalNumberDetector : object {
    public static RussianGrammaticalNumber Detect(int number);
}
internal class Humanizer.Localisation.NumberToWords.AfrikaansNumberToWordsConverter : GenderlessNumberToWordsConverter {
    private static String[] UnitsMap;
    private static String[] TensMap;
    private static Dictionary`2<int, string> OrdinalExceptions;
    private static AfrikaansNumberToWordsConverter();
    public virtual string Convert(long number);
    public virtual string ConvertToOrdinal(int number);
    private string Convert(int number, bool isOrdinal);
    private static string GetUnitValue(int number, bool isOrdinal);
    private static string RemoveOnePrefix(string toWords);
    private static bool ExceptionNumbersToWords(int number, String& words);
}
internal class Humanizer.Localisation.NumberToWords.ArabicNumberToWordsConverter : GenderedNumberToWordsConverter {
    private static String[] Groups;
    private static String[] AppendedGroups;
    private static String[] PluralGroups;
    private static String[] OnesGroup;
    private static String[] TensGroup;
    private static String[] HundredsGroup;
    private static String[] AppendedTwos;
    private static String[] Twos;
    private static String[] FeminineOnesGroup;
    private static Dictionary`2<string, string> OrdinalExceptions;
    private static Dictionary`2<string, string> FeminineOrdinalExceptions;
    private static ArabicNumberToWordsConverter();
    public virtual string Convert(long input, GrammaticalGender gender);
    public virtual string ConvertToOrdinal(int number, GrammaticalGender gender);
    private static string ParseNumber(string word, int number, GrammaticalGender gender);
}
internal class Humanizer.Localisation.NumberToWords.BanglaNumberToWordsConverter : GenderlessNumberToWordsConverter {
    private static String[] UnitsMap;
    private static String[] HundredsMap;
    private static Dictionary`2<int, string> OrdinalExceptions;
    private static BanglaNumberToWordsConverter();
    public virtual string ConvertToOrdinal(int number);
    public virtual string Convert(long input);
    private static bool ExceptionNumbersToWords(int number, String& words);
}
internal class Humanizer.Localisation.NumberToWords.BrazilianPortugueseNumberToWordsConverter : GenderedNumberToWordsConverter {
    private static String[] PortugueseUnitsMap;
    private static String[] PortugueseTensMap;
    private static String[] PortugueseHundredsMap;
    private static String[] PortugueseOrdinalUnitsMap;
    private static String[] PortugueseOrdinalTensMap;
    private static String[] PortugueseOrdinalHundredsMap;
    private static BrazilianPortugueseNumberToWordsConverter();
    public virtual string Convert(long input, GrammaticalGender gender);
    public virtual string ConvertToOrdinal(int number, GrammaticalGender gender);
    private static string ApplyGender(string toWords, GrammaticalGender gender);
    private static string ApplyOrdinalGender(string toWords, GrammaticalGender gender);
}
internal class Humanizer.Localisation.NumberToWords.DefaultNumberToWordsConverter : GenderlessNumberToWordsConverter {
    private CultureInfo _culture;
    public DefaultNumberToWordsConverter(CultureInfo culture);
    public virtual string Convert(long number);
    public virtual string ConvertToOrdinal(int number);
}
internal class Humanizer.Localisation.NumberToWords.DutchNumberToWordsConverter : GenderlessNumberToWordsConverter {
    private static String[] UnitsMap;
    private static String[] TensMap;
    private static Fact[] Hunderds;
    private static Dictionary`2<string, string> OrdinalExceptions;
    private static Char[] EndingCharForSte;
    private static DutchNumberToWordsConverter();
    public virtual string Convert(long input);
    public virtual string ConvertToOrdinal(int number);
}
internal class Humanizer.Localisation.NumberToWords.EnglishNumberToWordsConverter : GenderlessNumberToWordsConverter {
    private static String[] UnitsMap;
    private static String[] TensMap;
    private static Dictionary`2<long, string> OrdinalExceptions;
    private static EnglishNumberToWordsConverter();
    public virtual string Convert(long number);
    public virtual string ConvertToOrdinal(int number);
    private string Convert(long number, bool isOrdinal);
    private static string GetUnitValue(long number, bool isOrdinal);
    private static string RemoveOnePrefix(string toWords);
    private static bool ExceptionNumbersToWords(long number, String& words);
}
internal class Humanizer.Localisation.NumberToWords.FarsiNumberToWordsConverter : GenderlessNumberToWordsConverter {
    private static String[] FarsiHundredsMap;
    private static String[] FarsiTensMap;
    private static String[] FarsiUnitsMap;
    private static FarsiNumberToWordsConverter();
    public virtual string Convert(long input);
    public virtual string ConvertToOrdinal(int number);
    [CompilerGeneratedAttribute]
private string <Convert>b__3_0(int n);
    [CompilerGeneratedAttribute]
private string <Convert>b__3_1(int n);
    [CompilerGeneratedAttribute]
private string <Convert>b__3_2(int n);
}
internal class Humanizer.Localisation.NumberToWords.FinnishNumberToWordsConverter : GenderlessNumberToWordsConverter {
    private static String[] UnitsMap;
    private static String[] OrdinalUnitsMap;
    private static Dictionary`2<int, string> OrdinalExceptions;
    private static FinnishNumberToWordsConverter();
    public virtual string Convert(long input);
    private string GetOrdinalUnit(int number, bool useExceptions);
    private string ToOrdinal(int number, bool useExceptions);
    public virtual string ConvertToOrdinal(int number);
}
internal class Humanizer.Localisation.NumberToWords.FrenchBelgianNumberToWordsConverter : FrenchNumberToWordsConverterBase {
    protected virtual void CollectPartsUnderAHundred(ICollection`1<string> parts, Int32& number, GrammaticalGender gender, bool pluralize);
    protected virtual string GetTens(int tens);
}
internal class Humanizer.Localisation.NumberToWords.FrenchNumberToWordsConverter : FrenchNumberToWordsConverterBase {
    protected virtual void CollectPartsUnderAHundred(ICollection`1<string> parts, Int32& number, GrammaticalGender gender, bool pluralize);
    protected virtual string GetTens(int tens);
}
internal abstract class Humanizer.Localisation.NumberToWords.FrenchNumberToWordsConverterBase : GenderedNumberToWordsConverter {
    private static String[] UnitsMap;
    private static String[] TensMap;
    private static FrenchNumberToWordsConverterBase();
    public virtual string Convert(long input, GrammaticalGender gender);
    public virtual string ConvertToOrdinal(int number, GrammaticalGender gender);
    protected static string GetUnits(int number, GrammaticalGender gender);
    private static void CollectHundreds(ICollection`1<string> parts, Int32& number, int d, string form, bool pluralize);
    private void CollectParts(ICollection`1<string> parts, Int32& number, int d, string form);
    private void CollectPartsUnderAThousand(ICollection`1<string> parts, int number, GrammaticalGender gender, bool pluralize);
    private void CollectThousands(ICollection`1<string> parts, Int32& number, int d, string form);
    protected virtual void CollectPartsUnderAHundred(ICollection`1<string> parts, Int32& number, GrammaticalGender gender, bool pluralize);
    protected virtual string GetTens(int tens);
}
internal class Humanizer.Localisation.NumberToWords.FrenchSwissNumberToWordsConverter : FrenchNumberToWordsConverterBase {
}
internal abstract class Humanizer.Localisation.NumberToWords.GenderedNumberToWordsConverter : object {
    private GrammaticalGender _defaultGender;
    protected GenderedNumberToWordsConverter(GrammaticalGender defaultGender);
    public sealed virtual string Convert(long number);
    public abstract virtual string Convert(long number, GrammaticalGender gender);
    public sealed virtual string ConvertToOrdinal(int number);
    public abstract virtual string ConvertToOrdinal(int number, GrammaticalGender gender);
}
internal abstract class Humanizer.Localisation.NumberToWords.GenderlessNumberToWordsConverter : object {
    public abstract virtual string Convert(long number);
    public sealed virtual string Convert(long number, GrammaticalGender gender);
    public abstract virtual string ConvertToOrdinal(int number);
    public sealed virtual string ConvertToOrdinal(int number, GrammaticalGender gender);
}
internal class Humanizer.Localisation.NumberToWords.GermanNumberToWordsConverter : GenderedNumberToWordsConverter {
    private static String[] UnitsMap;
    private static String[] TensMap;
    private static String[] UnitsOrdinal;
    private static String[] MillionOrdinalSingular;
    private static String[] MillionOrdinalPlural;
    private static String[] BillionOrdinalSingular;
    private static String[] BillionOrdinalPlural;
    private static GermanNumberToWordsConverter();
    public virtual string Convert(long input, GrammaticalGender gender);
    public virtual string ConvertToOrdinal(int number, GrammaticalGender gender);
    private string Part(string pluralFormat, string singular, int number);
    private static int NoRestIndex(int number);
    private static string GetEndingForGender(GrammaticalGender gender);
}
internal class Humanizer.Localisation.NumberToWords.HebrewNumberToWordsConverter : GenderedNumberToWordsConverter {
    private static String[] UnitsFeminine;
    private static String[] UnitsMasculine;
    private static String[] TensUnit;
    private CultureInfo _culture;
    public HebrewNumberToWordsConverter(CultureInfo culture);
    private static HebrewNumberToWordsConverter();
    public virtual string Convert(long input, GrammaticalGender gender);
    public virtual string ConvertToOrdinal(int number, GrammaticalGender gender);
    private void ToBigNumber(int number, Group group, List`1<string> parts);
    private void ToThousands(int number, List`1<string> parts);
    private static void ToHundreds(int number, List`1<string> parts);
}
public interface Humanizer.Localisation.NumberToWords.INumberToWordsConverter {
    public abstract virtual string Convert(long number);
    public abstract virtual string Convert(long number, GrammaticalGender gender);
    public abstract virtual string ConvertToOrdinal(int number);
    public abstract virtual string ConvertToOrdinal(int number, GrammaticalGender gender);
}
internal class Humanizer.Localisation.NumberToWords.Italian.ItalianCardinalNumberCruncher : object {
    protected int _fullNumber;
    protected List`1<int> _threeDigitParts;
    protected GrammaticalGender _gender;
    protected ThreeDigitSets _nextSet;
    protected static String[] _unitsNumberToText;
    protected static String[] _tensOver20NumberToText;
    protected static String[] _teensUnder20NumberToText;
    protected static String[] _hundredNumberToText;
    public ItalianCardinalNumberCruncher(int number, GrammaticalGender gender);
    private static ItalianCardinalNumberCruncher();
    public string Convert();
    protected static List`1<int> SplitEveryThreeDigits(int number);
    public Func`2<int, string> GetNextPartConverter();
    protected static string ThreeDigitSetConverter(int number, bool thisIsLastSet);
    protected string UnitsConverter(int number);
    protected static string ThousandsConverter(int number);
    protected static string MillionsConverter(int number);
    protected static string BillionsConverter(int number);
}
internal class Humanizer.Localisation.NumberToWords.Italian.ItalianOrdinalNumberCruncher : object {
    protected int _fullNumber;
    protected GrammaticalGender _gender;
    private string _genderSuffix;
    protected static String[] _unitsUnder10NumberToText;
    protected static int _lengthOf10AsCardinal;
    public ItalianOrdinalNumberCruncher(int number, GrammaticalGender gender);
    private static ItalianOrdinalNumberCruncher();
    public string Convert();
}
internal class Humanizer.Localisation.NumberToWords.ItalianNumberToWordsConverter : GenderedNumberToWordsConverter {
    public virtual string Convert(long input, GrammaticalGender gender);
    public virtual string ConvertToOrdinal(int number, GrammaticalGender gender);
}
internal class Humanizer.Localisation.NumberToWords.NorwegianBokmalNumberToWordsConverter : GenderedNumberToWordsConverter {
    private static String[] UnitsMap;
    private static String[] TensMap;
    private static Dictionary`2<int, string> OrdinalExceptions;
    private static NorwegianBokmalNumberToWordsConverter();
    public virtual string Convert(long number, GrammaticalGender gender);
    public virtual string ConvertToOrdinal(int number, GrammaticalGender gender);
    private string Convert(int number, bool isOrdinal, GrammaticalGender gender);
    private static string GetUnitValue(int number, bool isOrdinal);
    private static bool ExceptionNumbersToWords(int number, String& words);
    private string Part(string pluralFormat, string singular, int number, bool postfixSpace);
}
internal class Humanizer.Localisation.NumberToWords.PolishNumberToWordsConverter : GenderlessNumberToWordsConverter {
    private static String[] HundredsMap;
    private static String[] TensMap;
    private static String[] UnitsMap;
    private CultureInfo _culture;
    public PolishNumberToWordsConverter(CultureInfo culture);
    private static PolishNumberToWordsConverter();
    private static void CollectPartsUnderThousand(ICollection`1<string> parts, int number);
    private static int GetMappingIndex(int number);
    public virtual string Convert(long input);
    public virtual string ConvertToOrdinal(int number);
}
internal class Humanizer.Localisation.NumberToWords.Romanian.RomanianCardinalNumberConverter : object {
    private String[] _units;
    private String[] _teensUnder20NumberToText;
    private String[] _tensOver20NumberToText;
    private string _feminineSingular;
    private string _masculineSingular;
    private string _joinGroups;
    private string _joinAbove20;
    private string _minusSign;
    public string Convert(int number, GrammaticalGender gender);
    private List`1<int> SplitEveryThreeDigits(int number);
    private Func`3<int, GrammaticalGender, string> GetNextPartConverter(ThreeDigitSets currentSet);
    private string ThreeDigitSetConverter(int number, GrammaticalGender gender, bool thisIsLastSet);
    private string getPartByGender(string multiGenderPart, GrammaticalGender gender);
    private bool IsAbove20(int number);
    private string HundredsToText(int hundreds);
    private string UnitsConverter(int number, GrammaticalGender gender);
    private string ThousandsConverter(int number, GrammaticalGender gender);
    private string MillionsConverter(int number, GrammaticalGender gender);
    private string BillionsConverter(int number, GrammaticalGender gender);
}
internal class Humanizer.Localisation.NumberToWords.Romanian.RomanianOrdinalNumberConverter : object {
    private Dictionary`2<int, string> _ordinalsUnder10;
    private string _femininePrefix;
    private string _masculinePrefix;
    private string _feminineSuffix;
    private string _masculineSuffix;
    public string Convert(int number, GrammaticalGender gender);
    private string getPartByGender(string multiGenderPart, GrammaticalGender gender);
}
internal class Humanizer.Localisation.NumberToWords.RomanianNumberToWordsConverter : GenderedNumberToWordsConverter {
    public virtual string Convert(long number, GrammaticalGender gender);
    public virtual string ConvertToOrdinal(int number, GrammaticalGender gender);
}
internal class Humanizer.Localisation.NumberToWords.RussianNumberToWordsConverter : GenderedNumberToWordsConverter {
    private static String[] HundredsMap;
    private static String[] TensMap;
    private static String[] UnitsMap;
    private static String[] UnitsOrdinalPrefixes;
    private static String[] TensOrdinalPrefixes;
    private static String[] TensOrdinal;
    private static String[] UnitsOrdinal;
    private static RussianNumberToWordsConverter();
    public virtual string Convert(long input, GrammaticalGender gender);
    public virtual string ConvertToOrdinal(int number, GrammaticalGender gender);
    private static void CollectPartsUnderOneThousand(ICollection`1<string> parts, int number, GrammaticalGender gender);
    private static string GetPrefix(int number);
    private static void CollectParts(ICollection`1<string> parts, Int32& number, int divisor, GrammaticalGender gender, String[] forms);
    private static void CollectOrdinalParts(ICollection`1<string> parts, Int32& number, int divisor, GrammaticalGender gender, string prefixedForm, String[] forms);
    private static int GetIndex(RussianGrammaticalNumber number);
    private static string ChooseOneForGrammaticalNumber(int number, String[] forms);
    private static string GetEndingForGender(GrammaticalGender gender, int number);
}
internal class Humanizer.Localisation.NumberToWords.SerbianCyrlNumberToWordsConverter : GenderlessNumberToWordsConverter {
    private static String[] UnitsMap;
    private static String[] TensMap;
    private CultureInfo _culture;
    public SerbianCyrlNumberToWordsConverter(CultureInfo culture);
    private static SerbianCyrlNumberToWordsConverter();
    public virtual string Convert(long input);
    public virtual string ConvertToOrdinal(int number);
    private string Part(string singular, string dual, string trialQuadral, string plural, int number);
}
internal class Humanizer.Localisation.NumberToWords.SerbianNumberToWordsConverter : GenderlessNumberToWordsConverter {
    private static String[] UnitsMap;
    private static String[] TensMap;
    private CultureInfo _culture;
    public SerbianNumberToWordsConverter(CultureInfo culture);
    private static SerbianNumberToWordsConverter();
    public virtual string Convert(long input);
    public virtual string ConvertToOrdinal(int number);
    private string Part(string singular, string dual, string trialQuadral, string plural, int number);
}
internal class Humanizer.Localisation.NumberToWords.SlovenianNumberToWordsConverter : GenderlessNumberToWordsConverter {
    private static String[] UnitsMap;
    private static String[] TensMap;
    private CultureInfo _culture;
    public SlovenianNumberToWordsConverter(CultureInfo culture);
    private static SlovenianNumberToWordsConverter();
    public virtual string Convert(long input);
    public virtual string ConvertToOrdinal(int number);
    private string Part(string singular, string dual, string trialQuadral, string plural, int number);
}
internal class Humanizer.Localisation.NumberToWords.SpanishNumberToWordsConverter : GenderedNumberToWordsConverter {
    private static String[] UnitsMap;
    private static string Feminine1;
    private static string Feminine21;
    private static String[] TensMap;
    private static String[] HundredsMap;
    private static String[] FeminineHundredsMap;
    private static Dictionary`2<int, string> Ordinals;
    private static SpanishNumberToWordsConverter();
    public virtual string Convert(long input, GrammaticalGender gender);
    public virtual string ConvertToOrdinal(int number, GrammaticalGender gender);
}
internal class Humanizer.Localisation.NumberToWords.TurkishNumberToWordConverter : GenderlessNumberToWordsConverter {
    private static String[] UnitsMap;
    private static String[] TensMap;
    private static Dictionary`2<char, string> OrdinalSuffix;
    private static TurkishNumberToWordConverter();
    public virtual string Convert(long input);
    public virtual string ConvertToOrdinal(int number);
}
internal class Humanizer.Localisation.NumberToWords.UkrainianNumberToWordsConverter : GenderedNumberToWordsConverter {
    private static String[] HundredsMap;
    private static String[] TensMap;
    private static String[] UnitsMap;
    private static String[] UnitsOrdinalPrefixes;
    private static String[] TensOrdinalPrefixes;
    private static String[] TensOrdinal;
    private static String[] UnitsOrdinal;
    private static UkrainianNumberToWordsConverter();
    public virtual string Convert(long input, GrammaticalGender gender);
    public virtual string ConvertToOrdinal(int number, GrammaticalGender gender);
    private static void CollectPartsUnderOneThousand(ICollection`1<string> parts, int number, GrammaticalGender gender);
    private static string GetPrefix(int number);
    private static void CollectParts(ICollection`1<string> parts, Int32& number, int divisor, GrammaticalGender gender, String[] forms);
    private static void CollectOrdinalParts(ICollection`1<string> parts, Int32& number, int divisor, GrammaticalGender gender, string prefixedForm, String[] forms);
    private static int GetIndex(RussianGrammaticalNumber number);
    private static string ChooseOneForGrammaticalNumber(int number, String[] forms);
    private static string GetEndingForGender(GrammaticalGender gender, int number);
}
internal class Humanizer.Localisation.NumberToWords.UzbekCyrlNumberToWordConverter : GenderlessNumberToWordsConverter {
    private static String[] UnitsMap;
    private static String[] TensMap;
    private static String[] OrdinalSuffixes;
    private static UzbekCyrlNumberToWordConverter();
    public virtual string Convert(long input);
    private string Convert(int number, bool checkForHoundredRule);
    public virtual string ConvertToOrdinal(int number);
}
internal class Humanizer.Localisation.NumberToWords.UzbekLatnNumberToWordConverter : GenderlessNumberToWordsConverter {
    private static String[] UnitsMap;
    private static String[] TensMap;
    private static String[] OrdinalSuffixes;
    private static UzbekLatnNumberToWordConverter();
    public virtual string Convert(long input);
    private string Convert(int number, bool checkForHoundredRule);
    public virtual string ConvertToOrdinal(int number);
}
internal class Humanizer.Localisation.Ordinalizers.DefaultOrdinalizer : object {
    public virtual string Convert(int number, string numberString, GrammaticalGender gender);
    public virtual string Convert(int number, string numberString);
}
internal class Humanizer.Localisation.Ordinalizers.DutchOrdinalizer : DefaultOrdinalizer {
    public virtual string Convert(int number, string numberString);
    public virtual string Convert(int number, string numberString, GrammaticalGender gender);
}
internal class Humanizer.Localisation.Ordinalizers.EnglishOrdinalizer : DefaultOrdinalizer {
    public virtual string Convert(int number, string numberString);
}
internal class Humanizer.Localisation.Ordinalizers.GermanOrdinalizer : DefaultOrdinalizer {
    public virtual string Convert(int number, string numberString);
}
public interface Humanizer.Localisation.Ordinalizers.IOrdinalizer {
    public abstract virtual string Convert(int number, string numberString);
    public abstract virtual string Convert(int number, string numberString, GrammaticalGender gender);
}
internal class Humanizer.Localisation.Ordinalizers.ItalianOrdinalizer : DefaultOrdinalizer {
    public virtual string Convert(int number, string numberString);
    public virtual string Convert(int number, string numberString, GrammaticalGender gender);
}
internal class Humanizer.Localisation.Ordinalizers.PortugueseOrdinalizer : DefaultOrdinalizer {
    public virtual string Convert(int number, string numberString);
    public virtual string Convert(int number, string numberString, GrammaticalGender gender);
}
internal class Humanizer.Localisation.Ordinalizers.RomanianOrdinalizer : DefaultOrdinalizer {
    public virtual string Convert(int number, string numberString);
    public virtual string Convert(int number, string numberString, GrammaticalGender gender);
}
internal class Humanizer.Localisation.Ordinalizers.RussianOrdinalizer : DefaultOrdinalizer {
    public virtual string Convert(int number, string numberString);
    public virtual string Convert(int number, string numberString, GrammaticalGender gender);
}
internal class Humanizer.Localisation.Ordinalizers.SpanishOrdinalizer : DefaultOrdinalizer {
    public virtual string Convert(int number, string numberString);
    public virtual string Convert(int number, string numberString, GrammaticalGender gender);
}
internal class Humanizer.Localisation.Ordinalizers.TurkishOrdinalizer : DefaultOrdinalizer {
    public virtual string Convert(int number, string numberString);
}
internal class Humanizer.Localisation.Ordinalizers.UkrainianOrdinalizer : DefaultOrdinalizer {
    public virtual string Convert(int number, string numberString);
    public virtual string Convert(int number, string numberString, GrammaticalGender gender);
}
public class Humanizer.Localisation.ResourceKeys : object {
    private static string Single;
    private static string Multiple;
    private static void ValidateRange(int count);
}
public static class Humanizer.Localisation.Resources : object {
    private static ResourceManager ResourceManager;
    private static Resources();
    public static string GetResource(string resourceKey, CultureInfo culture);
}
public enum Humanizer.Localisation.Tense : Enum {
    public int value__;
    public static Tense Future;
    public static Tense Past;
}
public enum Humanizer.Localisation.TimeUnit : Enum {
    public int value__;
    public static TimeUnit Millisecond;
    public static TimeUnit Second;
    public static TimeUnit Minute;
    public static TimeUnit Hour;
    public static TimeUnit Day;
    public static TimeUnit Week;
    public static TimeUnit Month;
    public static TimeUnit Year;
}
[ExtensionAttribute]
public static class Humanizer.MetricNumeralExtensions : object {
    private static double BigLimit;
    private static double SmallLimit;
    private static List`1[] Symbols;
    private static Dictionary`2<char, string> Names;
    private static MetricNumeralExtensions();
    [ExtensionAttribute]
public static double FromMetric(string input);
    [ExtensionAttribute]
public static string ToMetric(int input, bool hasSpace, bool useSymbol, Nullable`1<int> decimals);
    [ExtensionAttribute]
public static string ToMetric(double input, bool hasSpace, bool useSymbol, Nullable`1<int> decimals);
    private static string CleanRepresentation(string input);
    private static double BuildNumber(string input, char last);
    private static double BuildMetricNumber(string input, char last);
    private static string ReplaceNameBySymbol(string input);
    private static string BuildRepresentation(double input, bool hasSpace, bool useSymbol, Nullable`1<int> decimals);
    private static string BuildMetricRepresentation(double input, int exponent, bool hasSpace, bool useSymbol, Nullable`1<int> decimals);
    private static string GetUnit(char symbol, bool useSymbol);
    [ExtensionAttribute]
private static bool IsOutOfRange(double input);
    [ExtensionAttribute]
private static bool IsInvalidMetricNumeral(string input);
}
public class Humanizer.NoMatchFoundException : Exception {
    public NoMatchFoundException(string message);
    public NoMatchFoundException(string message, Exception inner);
}
[ExtensionAttribute]
public static class Humanizer.NumberToNumberExtensions : object {
    [ExtensionAttribute]
public static int Tens(int input);
    [ExtensionAttribute]
public static UInt32 Tens(UInt32 input);
    [ExtensionAttribute]
public static long Tens(long input);
    [ExtensionAttribute]
public static ulong Tens(ulong input);
    [ExtensionAttribute]
public static double Tens(double input);
    [ExtensionAttribute]
public static int Hundreds(int input);
    [ExtensionAttribute]
public static UInt32 Hundreds(UInt32 input);
    [ExtensionAttribute]
public static long Hundreds(long input);
    [ExtensionAttribute]
public static ulong Hundreds(ulong input);
    [ExtensionAttribute]
public static double Hundreds(double input);
    [ExtensionAttribute]
public static int Thousands(int input);
    [ExtensionAttribute]
public static UInt32 Thousands(UInt32 input);
    [ExtensionAttribute]
public static long Thousands(long input);
    [ExtensionAttribute]
public static ulong Thousands(ulong input);
    [ExtensionAttribute]
public static double Thousands(double input);
    [ExtensionAttribute]
public static int Millions(int input);
    [ExtensionAttribute]
public static UInt32 Millions(UInt32 input);
    [ExtensionAttribute]
public static long Millions(long input);
    [ExtensionAttribute]
public static ulong Millions(ulong input);
    [ExtensionAttribute]
public static double Millions(double input);
    [ExtensionAttribute]
public static int Billions(int input);
    [ExtensionAttribute]
public static UInt32 Billions(UInt32 input);
    [ExtensionAttribute]
public static long Billions(long input);
    [ExtensionAttribute]
public static ulong Billions(ulong input);
    [ExtensionAttribute]
public static double Billions(double input);
}
[ExtensionAttribute]
public static class Humanizer.NumberToTimeSpanExtensions : object {
    [ExtensionAttribute]
public static TimeSpan Milliseconds(byte ms);
    [ExtensionAttribute]
public static TimeSpan Milliseconds(sbyte ms);
    [ExtensionAttribute]
public static TimeSpan Milliseconds(short ms);
    [ExtensionAttribute]
public static TimeSpan Milliseconds(ushort ms);
    [ExtensionAttribute]
public static TimeSpan Milliseconds(int ms);
    [ExtensionAttribute]
public static TimeSpan Milliseconds(UInt32 ms);
    [ExtensionAttribute]
public static TimeSpan Milliseconds(long ms);
    [ExtensionAttribute]
public static TimeSpan Milliseconds(ulong ms);
    [ExtensionAttribute]
public static TimeSpan Milliseconds(double ms);
    [ExtensionAttribute]
public static TimeSpan Seconds(byte seconds);
    [ExtensionAttribute]
public static TimeSpan Seconds(sbyte seconds);
    [ExtensionAttribute]
public static TimeSpan Seconds(short seconds);
    [ExtensionAttribute]
public static TimeSpan Seconds(ushort seconds);
    [ExtensionAttribute]
public static TimeSpan Seconds(int seconds);
    [ExtensionAttribute]
public static TimeSpan Seconds(UInt32 seconds);
    [ExtensionAttribute]
public static TimeSpan Seconds(long seconds);
    [ExtensionAttribute]
public static TimeSpan Seconds(ulong seconds);
    [ExtensionAttribute]
public static TimeSpan Seconds(double seconds);
    [ExtensionAttribute]
public static TimeSpan Minutes(byte minutes);
    [ExtensionAttribute]
public static TimeSpan Minutes(sbyte minutes);
    [ExtensionAttribute]
public static TimeSpan Minutes(short minutes);
    [ExtensionAttribute]
public static TimeSpan Minutes(ushort minutes);
    [ExtensionAttribute]
public static TimeSpan Minutes(int minutes);
    [ExtensionAttribute]
public static TimeSpan Minutes(UInt32 minutes);
    [ExtensionAttribute]
public static TimeSpan Minutes(long minutes);
    [ExtensionAttribute]
public static TimeSpan Minutes(ulong minutes);
    [ExtensionAttribute]
public static TimeSpan Minutes(double minutes);
    [ExtensionAttribute]
public static TimeSpan Hours(byte hours);
    [ExtensionAttribute]
public static TimeSpan Hours(sbyte hours);
    [ExtensionAttribute]
public static TimeSpan Hours(short hours);
    [ExtensionAttribute]
public static TimeSpan Hours(ushort hours);
    [ExtensionAttribute]
public static TimeSpan Hours(int hours);
    [ExtensionAttribute]
public static TimeSpan Hours(UInt32 hours);
    [ExtensionAttribute]
public static TimeSpan Hours(long hours);
    [ExtensionAttribute]
public static TimeSpan Hours(ulong hours);
    [ExtensionAttribute]
public static TimeSpan Hours(double hours);
    [ExtensionAttribute]
public static TimeSpan Days(byte days);
    [ExtensionAttribute]
public static TimeSpan Days(sbyte days);
    [ExtensionAttribute]
public static TimeSpan Days(short days);
    [ExtensionAttribute]
public static TimeSpan Days(ushort days);
    [ExtensionAttribute]
public static TimeSpan Days(int days);
    [ExtensionAttribute]
public static TimeSpan Days(UInt32 days);
    [ExtensionAttribute]
public static TimeSpan Days(long days);
    [ExtensionAttribute]
public static TimeSpan Days(ulong days);
    [ExtensionAttribute]
public static TimeSpan Days(double days);
    [ExtensionAttribute]
public static TimeSpan Weeks(byte input);
    [ExtensionAttribute]
public static TimeSpan Weeks(sbyte input);
    [ExtensionAttribute]
public static TimeSpan Weeks(short input);
    [ExtensionAttribute]
public static TimeSpan Weeks(ushort input);
    [ExtensionAttribute]
public static TimeSpan Weeks(int input);
    [ExtensionAttribute]
public static TimeSpan Weeks(UInt32 input);
    [ExtensionAttribute]
public static TimeSpan Weeks(long input);
    [ExtensionAttribute]
public static TimeSpan Weeks(ulong input);
    [ExtensionAttribute]
public static TimeSpan Weeks(double input);
}
[ExtensionAttribute]
public static class Humanizer.NumberToWordsExtension : object {
    [ExtensionAttribute]
public static string ToWords(int number, CultureInfo culture);
    [ExtensionAttribute]
public static string ToWords(int number, GrammaticalGender gender, CultureInfo culture);
    [ExtensionAttribute]
public static string ToWords(long number, CultureInfo culture);
    [ExtensionAttribute]
public static string ToWords(long number, GrammaticalGender gender, CultureInfo culture);
    [ExtensionAttribute]
public static string ToOrdinalWords(int number, CultureInfo culture);
    [ExtensionAttribute]
public static string ToOrdinalWords(int number, GrammaticalGender gender, CultureInfo culture);
}
public class Humanizer.On : object {
}
public enum Humanizer.OnNoMatch : Enum {
    public int value__;
    public static OnNoMatch ThrowsException;
    public static OnNoMatch ReturnsNull;
}
[ExtensionAttribute]
public static class Humanizer.OrdinalizeExtensions : object {
    [ExtensionAttribute]
public static string Ordinalize(string numberString);
    [ExtensionAttribute]
public static string Ordinalize(string numberString, GrammaticalGender gender);
    [ExtensionAttribute]
public static string Ordinalize(int number);
    [ExtensionAttribute]
public static string Ordinalize(int number, GrammaticalGender gender);
}
public enum Humanizer.Plurality : Enum {
    public int value__;
    public static Plurality Singular;
    public static Plurality Plural;
    public static Plurality CouldBeEither;
}
[ExtensionAttribute]
public static class Humanizer.PrepositionsExtensions : object {
    [ExtensionAttribute]
public static DateTime At(DateTime date, int hour, int min, int second, int millisecond);
    [ExtensionAttribute]
public static DateTime AtMidnight(DateTime date);
    [ExtensionAttribute]
public static DateTime AtNoon(DateTime date);
    [ExtensionAttribute]
public static DateTime In(DateTime date, int year);
}
internal static class Humanizer.RegexOptionsUtil : object {
    private static RegexOptions _compiled;
    public static RegexOptions Compiled { get; }
    private static RegexOptionsUtil();
    public static RegexOptions get_Compiled();
}
[ExtensionAttribute]
public static class Humanizer.RomanNumeralExtensions : object {
    private static int NumberOfRomanNumeralMaps;
    private static IDictionary`2<string, int> RomanNumerals;
    private static Regex ValidRomanNumeral;
    private static RomanNumeralExtensions();
    [ExtensionAttribute]
public static int FromRoman(string input);
    [ExtensionAttribute]
public static string ToRoman(int input);
    private static bool IsInvalidRomanNumeral(string input);
}
public enum Humanizer.ShowQuantityAs : Enum {
    public int value__;
    public static ShowQuantityAs None;
    public static ShowQuantityAs Numeric;
    public static ShowQuantityAs Words;
}
[ExtensionAttribute]
public static class Humanizer.StringDehumanizeExtensions : object {
    [ExtensionAttribute]
public static string Dehumanize(string input);
}
[ExtensionAttribute]
public static class Humanizer.StringExtensions : object {
    [ExtensionAttribute]
public static string FormatWith(string format, Object[] args);
    [ExtensionAttribute]
public static string FormatWith(string format, IFormatProvider provider, Object[] args);
}
[ExtensionAttribute]
public static class Humanizer.StringHumanizeExtensions : object {
    private static Regex PascalCaseWordPartsRegex;
    private static Regex FreestandingSpacingCharRegex;
    private static StringHumanizeExtensions();
    private static string FromUnderscoreDashSeparatedWords(string input);
    private static string FromPascalCase(string input);
    [ExtensionAttribute]
public static string Humanize(string input);
    [ExtensionAttribute]
public static string Humanize(string input, LetterCasing casing);
}
[ExtensionAttribute]
public static class Humanizer.TimeSpanHumanizeExtensions : object {
    private static int _daysInAWeek;
    private static double _daysInAYear;
    private static double _daysInAMonth;
    [ExtensionAttribute]
public static string Humanize(TimeSpan timeSpan, int precision, CultureInfo culture, TimeUnit maxUnit, TimeUnit minUnit, string collectionSeparator);
    [ExtensionAttribute]
public static string Humanize(TimeSpan timeSpan, int precision, bool countEmptyUnits, CultureInfo culture, TimeUnit maxUnit, TimeUnit minUnit, string collectionSeparator);
    private static IEnumerable`1<string> CreateTheTimePartsWithUpperAndLowerLimits(TimeSpan timespan, CultureInfo culture, TimeUnit maxUnit, TimeUnit minUnit);
    private static IEnumerable`1<TimeUnit> GetEnumTypesForTimeUnit();
    private static string GetTimeUnitPart(TimeUnit timeUnitToGet, TimeSpan timespan, CultureInfo culture, TimeUnit maximumTimeUnit, TimeUnit minimumTimeUnit, IFormatter cultureFormatter);
    private static int GetTimeUnitNumericalValue(TimeUnit timeUnitToGet, TimeSpan timespan, bool isTimeUnitToGetTheMaximumTimeUnit);
    private static int GetSpecialCaseMonthAsInteger(TimeSpan timespan, bool isTimeUnitToGetTheMaximumTimeUnit);
    private static int GetSpecialCaseYearAsInteger(TimeSpan timespan);
    private static int GetSpecialCaseWeeksAsInteger(TimeSpan timespan, bool isTimeUnitToGetTheMaximumTimeUnit);
    private static int GetSpecialCaseDaysAsInteger(TimeSpan timespan, bool isTimeUnitToGetTheMaximumTimeUnit);
    private static int GetNormalCaseTimeAsInteger(int timeNumberOfUnits, double totalTimeNumberOfUnits, bool isTimeUnitToGetTheMaximumTimeUnit);
    private static string BuildFormatTimePart(IFormatter cultureFormatter, TimeUnit timeUnitType, int amountOfTimeUnits);
    private static List`1<string> CreateTimePartsWithNoTimeValue(string noTimeValue);
    private static bool IsContainingOnlyNullValue(IEnumerable`1<string> timeParts);
    private static IEnumerable`1<string> SetPrecisionOfTimeSpan(IEnumerable`1<string> timeParts, int precision, bool countEmptyUnits);
    private static string ConcatenateTimeSpanParts(IEnumerable`1<string> timeSpanParts, string collectionSeparator);
}
[ExtensionAttribute]
public static class Humanizer.To : object {
    public static IStringTransformer TitleCase { get; }
    public static IStringTransformer LowerCase { get; }
    public static IStringTransformer UpperCase { get; }
    public static IStringTransformer SentenceCase { get; }
    [ExtensionAttribute]
public static string Transform(string input, IStringTransformer[] transformers);
    public static IStringTransformer get_TitleCase();
    public static IStringTransformer get_LowerCase();
    public static IStringTransformer get_UpperCase();
    public static IStringTransformer get_SentenceCase();
}
internal class Humanizer.ToLowerCase : object {
    public sealed virtual string Transform(string input);
}
[ExtensionAttribute]
public static class Humanizer.ToQuantityExtensions : object {
    [ExtensionAttribute]
public static string ToQuantity(string input, int quantity, ShowQuantityAs showQuantityAs);
    [ExtensionAttribute]
public static string ToQuantity(string input, int quantity, string format, IFormatProvider formatProvider);
    [ExtensionAttribute]
public static string ToQuantity(string input, long quantity, ShowQuantityAs showQuantityAs);
    [ExtensionAttribute]
public static string ToQuantity(string input, long quantity, string format, IFormatProvider formatProvider);
    [ExtensionAttribute]
private static string ToQuantity(string input, long quantity, ShowQuantityAs showQuantityAs, string format, IFormatProvider formatProvider);
}
internal class Humanizer.ToSentenceCase : object {
    public sealed virtual string Transform(string input);
}
internal class Humanizer.ToTitleCase : object {
    public sealed virtual string Transform(string input);
    private static bool AllCapitals(string input);
}
internal class Humanizer.ToUpperCase : object {
    public sealed virtual string Transform(string input);
}
[ExtensionAttribute]
public static class Humanizer.TruncateExtensions : object {
    [ExtensionAttribute]
public static string Truncate(string input, int length);
    [ExtensionAttribute]
public static string Truncate(string input, int length, ITruncator truncator, TruncateFrom from);
    [ExtensionAttribute]
public static string Truncate(string input, int length, string truncationString, TruncateFrom from);
    [ExtensionAttribute]
public static string Truncate(string input, int length, string truncationString, ITruncator truncator, TruncateFrom from);
}
public enum Humanizer.TruncateFrom : Enum {
    public int value__;
    public static TruncateFrom Left;
    public static TruncateFrom Right;
}
public static class Humanizer.Truncator : object {
    public static ITruncator FixedLength { get; }
    public static ITruncator FixedNumberOfCharacters { get; }
    public static ITruncator FixedNumberOfWords { get; }
    public static ITruncator get_FixedLength();
    public static ITruncator get_FixedNumberOfCharacters();
    public static ITruncator get_FixedNumberOfWords();
}
