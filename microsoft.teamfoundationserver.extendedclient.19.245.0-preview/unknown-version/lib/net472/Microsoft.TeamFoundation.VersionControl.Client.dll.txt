[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
public class Microsoft.TeamFoundation.VersionControl.Client.AcceptMergeNamespaceConflictRequiresDestinationException : VersionControlException {
    public AcceptMergeNamespaceConflictRequiresDestinationException(string message);
    public AcceptMergeNamespaceConflictRequiresDestinationException(string message, Exception ex);
    protected AcceptMergeNamespaceConflictRequiresDestinationException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.AcceptMergeVersionConflictRequiresDestinationException : VersionControlException {
    public AcceptMergeVersionConflictRequiresDestinationException(string message);
    public AcceptMergeVersionConflictRequiresDestinationException(string message, Exception ex);
    protected AcceptMergeVersionConflictRequiresDestinationException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.AcceptYoursRenameTheirsRequiresDestinationException : VersionControlException {
    public AcceptYoursRenameTheirsRequiresDestinationException(string message);
    public AcceptYoursRenameTheirsRequiresDestinationException(string message, Exception ex);
    protected AcceptYoursRenameTheirsRequiresDestinationException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.AccessControlEntryFromVersionControl : AccessControlEntry {
    private TeamFoundationIdentity m_identity;
    public TeamFoundationIdentity Identity { get; }
    public AccessControlEntryFromVersionControl(TeamFoundationIdentity identity, int allow, int deny);
    public TeamFoundationIdentity get_Identity();
}
public class Microsoft.TeamFoundation.VersionControl.Client.AccessEntry : object {
    internal int m_allowInt;
    internal int m_denyInt;
    internal int m_allowInheritedInt;
    internal int m_denyInheritedInt;
    internal Type m_enumType;
    internal String[] m_allow;
    internal String[] m_allowInherited;
    internal String[] m_deny;
    internal String[] m_denyInherited;
    private string m_displayName;
    private string m_identityName;
    public String[] Allow { get; public set; }
    public String[] AllowInherited { get; public set; }
    public String[] Deny { get; public set; }
    public String[] DenyInherited { get; public set; }
    public string IdentityName { get; public set; }
    internal AccessEntry(string identityName, int allow, int deny, int allowInherited, int denyInherited, Type enumType);
    public static int CompareIdentity(AccessEntry entry1, AccessEntry entry2);
    internal void UpdateStringArrays();
    private void AfterDeserialize();
    public String[] get_Allow();
    public void set_Allow(String[] value);
    public String[] get_AllowInherited();
    public void set_AllowInherited(String[] value);
    public String[] get_Deny();
    public void set_Deny(String[] value);
    public String[] get_DenyInherited();
    public void set_DenyInherited(String[] value);
    public string get_IdentityName();
    public void set_IdentityName(string value);
    [EditorBrowsableAttribute("1")]
public static AccessEntry FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, AccessEntry obj);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.Admin : VersionControlClientProxy {
    protected Guid CollectionServiceIdentifier { get; }
    protected string ServiceType { get; }
    public Admin(TfsTeamProjectCollection connection);
    public Admin(VersionControlServer sourceControl);
    protected virtual Guid get_CollectionServiceIdentifier();
    protected virtual string get_ServiceType();
    protected virtual Exception ConvertException(SoapException exception);
    public void GenerateRepositoryKey();
    public void OptimizeDatabase(int optimizationFlags);
    public AdminRepositoryInfo QueryRepositoryInformation();
}
public class Microsoft.TeamFoundation.VersionControl.Client.AdminRepositoryInfo : object {
    private int m_fileCount;
    private int m_folderCount;
    private int m_groupCount;
    private int m_maxChangesetID;
    private int m_pendingChangeCount;
    private int m_shelvesetCount;
    private int m_shelvesetDeletedCount;
    private int m_userCount;
    private int m_workspaceCount;
    public int FileCount { get; public set; }
    public int FolderCount { get; public set; }
    public int GroupCount { get; public set; }
    public int MaxChangesetID { get; public set; }
    public int PendingChangeCount { get; public set; }
    public int ShelvesetCount { get; public set; }
    public int ShelvesetDeletedCount { get; public set; }
    public int UserCount { get; public set; }
    public int WorkspaceCount { get; public set; }
    public int get_FileCount();
    public void set_FileCount(int value);
    public int get_FolderCount();
    public void set_FolderCount(int value);
    public int get_GroupCount();
    public void set_GroupCount(int value);
    public int get_MaxChangesetID();
    public void set_MaxChangesetID(int value);
    public int get_PendingChangeCount();
    public void set_PendingChangeCount(int value);
    public int get_ShelvesetCount();
    public void set_ShelvesetCount(int value);
    public int get_ShelvesetDeletedCount();
    public void set_ShelvesetDeletedCount(int value);
    public int get_UserCount();
    public void set_UserCount(int value);
    public int get_WorkspaceCount();
    public void set_WorkspaceCount(int value);
    [EditorBrowsableAttribute("1")]
public static AdminRepositoryInfo FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, AdminRepositoryInfo obj);
}
public class Microsoft.TeamFoundation.VersionControl.Client.AdvancedToolParameters : object {
    [CompilerGeneratedAttribute]
private bool <IsModalDialog>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldWaitForExit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CompareIsSourceReadOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CompareIsTargetReadOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MergeSourceFileSpec>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MergeTargetFileSpec>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <MergeServerGuid>k__BackingField;
    public bool IsModalDialog { get; public set; }
    public bool ShouldWaitForExit { get; public set; }
    public bool CompareIsSourceReadOnly { get; public set; }
    public bool CompareIsTargetReadOnly { get; public set; }
    public string MergeSourceFileSpec { get; public set; }
    public string MergeTargetFileSpec { get; public set; }
    public Guid MergeServerGuid { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IsModalDialog();
    [CompilerGeneratedAttribute]
public void set_IsModalDialog(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShouldWaitForExit();
    [CompilerGeneratedAttribute]
public void set_ShouldWaitForExit(bool value);
    [CompilerGeneratedAttribute]
public bool get_CompareIsSourceReadOnly();
    [CompilerGeneratedAttribute]
public void set_CompareIsSourceReadOnly(bool value);
    [CompilerGeneratedAttribute]
public bool get_CompareIsTargetReadOnly();
    [CompilerGeneratedAttribute]
public void set_CompareIsTargetReadOnly(bool value);
    [CompilerGeneratedAttribute]
public string get_MergeSourceFileSpec();
    [CompilerGeneratedAttribute]
public void set_MergeSourceFileSpec(string value);
    [CompilerGeneratedAttribute]
public string get_MergeTargetFileSpec();
    [CompilerGeneratedAttribute]
public void set_MergeTargetFileSpec(string value);
    [CompilerGeneratedAttribute]
public Guid get_MergeServerGuid();
    [CompilerGeneratedAttribute]
public void set_MergeServerGuid(Guid value);
}
public class Microsoft.TeamFoundation.VersionControl.Client.AffectedTeamProjects : object {
    private Dictionary`2<string, bool> m_affectedTeamProjects;
    public String[] TeamProjectPaths { get; }
    public AffectedTeamProjects(PendingChange[] changes);
    public AffectedTeamProjects(IEnumerable`1<PendingChange> changes);
    public String[] get_TeamProjectPaths();
    public bool Update(PendingChange[] changes);
    public bool Update(IEnumerable`1<PendingChange> changes);
}
public class Microsoft.TeamFoundation.VersionControl.Client.AffectedTeamProjectsEventArgs : EventArgs {
    private String[] m_teamProjects;
    public String[] TeamProjectPaths { get; }
    public AffectedTeamProjectsEventArgs(String[] teamProjects);
    public String[] get_TeamProjectPaths();
}
public class Microsoft.TeamFoundation.VersionControl.Client.AffectedTeamProjectsEventHandler : MulticastDelegate {
    public AffectedTeamProjectsEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, AffectedTeamProjectsEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, AffectedTeamProjectsEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.TeamFoundation.VersionControl.Client.AfterWorkItemsUpdatedEventHandler : MulticastDelegate {
    public AfterWorkItemsUpdatedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, WorkItemsUpdateEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, WorkItemsUpdateEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.Annotation : object {
    private string m_annotatedItem;
    private string m_annotationName;
    private string m_annotationValue;
    private string m_comment;
    private DateTime m_lastModifiedDate;
    private int m_version;
    public string AnnotatedItem { get; public set; }
    public string AnnotationName { get; public set; }
    public string AnnotationValue { get; public set; }
    public string Comment { get; public set; }
    public DateTime LastModifiedDate { get; public set; }
    public int Version { get; public set; }
    public string get_AnnotatedItem();
    public void set_AnnotatedItem(string value);
    public string get_AnnotationName();
    public void set_AnnotationName(string value);
    public string get_AnnotationValue();
    public void set_AnnotationValue(string value);
    public string get_Comment();
    public void set_Comment(string value);
    public DateTime get_LastModifiedDate();
    public void set_LastModifiedDate(DateTime value);
    public int get_Version();
    public void set_Version(int value);
    internal static Annotation FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    internal void ToXml(XmlWriter writer, string element);
    internal static void ToXml(XmlWriter writer, string element, Annotation obj);
}
public class Microsoft.TeamFoundation.VersionControl.Client.ArtifactIdentifierRequiredException : VersionControlException {
    public ArtifactIdentifierRequiredException(string message);
    public ArtifactIdentifierRequiredException(string message, Exception ex);
    protected ArtifactIdentifierRequiredException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.ArtifactNotFoundException : VersionControlException {
    public ArtifactNotFoundException(Uri artifactUri);
}
public class Microsoft.TeamFoundation.VersionControl.Client.AssociatedWorkItemInfo : object {
    private int m_id;
    private string m_title;
    private string m_assignedTo;
    private string m_type;
    private string m_state;
    public int Id { get; }
    public string Title { get; }
    public string AssignedTo { get; }
    public string WorkItemType { get; }
    public string State { get; }
    public int get_Id();
    public string get_Title();
    public string get_AssignedTo();
    public string get_WorkItemType();
    public string get_State();
    internal static AssociatedWorkItemInfo[] FromArtifacts(IEnumerable`1<Artifact> artifacts);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.AsyncBaselineDownloadOperation : AsyncOperation {
    private Workspace m_workspace;
    public Workspace Workspace { get; }
    public AsyncBaselineDownloadOperation(Workspace workspace);
    public Workspace get_Workspace();
}
internal class Microsoft.TeamFoundation.VersionControl.Client.AsyncBaselineDownloadState : object {
    private AsyncBaselineDownloadOperation m_asyncOp;
    public AsyncBaselineDownloadState(AsyncBaselineDownloadOperation asyncOp);
    public static void Completed(IAsyncResult asyncResult);
    public void CompleteRequest(IAsyncResult asyncResult);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.AsyncGetFileState : object {
    private GetOperation m_action;
    private bool m_existingLocalExists;
    private FileAttributes m_existingLocalAttrs;
    private bool m_newLocalExists;
    private FileAttributes m_newLocalAttrs;
    private AsyncGetOperation m_asyncOp;
    private Client m_client;
    internal Client Client { get; }
    internal AsyncGetOperation AsyncGetOperation { get; }
    public AsyncGetFileState(GetOperation action, bool existingLocalExists, FileAttributes existingLocalAttrs, bool newLocalExists, FileAttributes newLocalAttrs, AsyncGetOperation asyncOp, Client client);
    public static void Completed(IAsyncResult asyncResult);
    internal Client get_Client();
    internal AsyncGetOperation get_AsyncGetOperation();
}
internal class Microsoft.TeamFoundation.VersionControl.Client.AsyncGetOperation : AsyncOperation {
    [CompilerGeneratedAttribute]
private bool <DeleteUndoneAdds>k__BackingField;
    [CompilerGeneratedAttribute]
private ChangePendedFlags <Flags>k__BackingField;
    internal ProcessType m_type;
    private GetOptions m_options;
    internal GetStatus m_getStatus;
    internal Workspace m_workspace;
    internal Hashtable m_existingLocalHash;
    internal Dictionary`2<string, GetOperation> m_dontDeleteFolderHash;
    internal SortedList m_deletes;
    internal UpdateLocalVersionQueue m_localUpdateQueue;
    internal UpdateLocalVersionQueueOptions m_localUpdateOptions;
    internal List`1<RetryEntry> m_retryList;
    private WorkspaceLock m_workspaceLock;
    private int m_currentNumOperations;
    internal int m_totalNumOperations;
    internal bool IsPreview { get; }
    internal bool IsGetAll { get; }
    internal bool IsOverwrite { get; }
    internal bool DeleteUndoneAdds { get; private set; }
    internal ChangePendedFlags Flags { get; private set; }
    internal WorkspaceLock WorkspaceLock { get; }
    internal BaselineFolderCollection BaselineFolders { get; }
    internal AsyncGetOperation(Workspace workspace, ProcessType type, RequestType requestType, GetOptions options, bool deleteUndoneAdds, WorkspaceLock wLock, UpdateLocalVersionQueueOptions localUpdateOptions, ChangePendedFlags flags, int operationId);
    internal void QueueLocalVersionUpdate(GetOperation action, string targetLocalPath, int version);
    internal void QueueLocalVersionUpdate(GetOperation action, string targetLocalItem, int version, bool force);
    internal void QueueLocalVersionUpdate(ILocalVersionUpdate update);
    internal void ResetForRetry();
    internal void AddConflict(GetOperation action);
    internal void AddWarning(OperationStatus status, GetOperation op);
    internal void AddWarning(OperationStatus status, GetOperation op, GetOperation targetAction);
    internal int GetNextOperationNumber();
    internal bool get_IsPreview();
    internal bool get_IsGetAll();
    internal bool get_IsOverwrite();
    [CompilerGeneratedAttribute]
internal bool get_DeleteUndoneAdds();
    [CompilerGeneratedAttribute]
private void set_DeleteUndoneAdds(bool value);
    [CompilerGeneratedAttribute]
internal ChangePendedFlags get_Flags();
    [CompilerGeneratedAttribute]
private void set_Flags(ChangePendedFlags value);
    internal WorkspaceLock get_WorkspaceLock();
    internal BaselineFolderCollection get_BaselineFolders();
}
internal class Microsoft.TeamFoundation.VersionControl.Client.AsyncOperation : object {
    [CompilerGeneratedAttribute]
private int <OperationId>k__BackingField;
    private int m_maxCount;
    private object m_pendingLock;
    private SemaphoreSlim m_semaphore;
    private Exception m_exception;
    private int m_pending;
    public Exception Exception { get; public set; }
    public bool Failed { get; }
    public int Pending { get; }
    public int OperationId { get; protected set; }
    public int MaxCount { get; }
    public AsyncOperation(int maxCount);
    public sealed virtual void Dispose();
    public virtual void Begin();
    public virtual void End();
    public void WaitForCompletion();
    public bool WaitForCompletion(int millisecondsTimeout);
    public Exception get_Exception();
    public void set_Exception(Exception value);
    public bool get_Failed();
    public int get_Pending();
    [CompilerGeneratedAttribute]
public int get_OperationId();
    [CompilerGeneratedAttribute]
protected void set_OperationId(int value);
    public int get_MaxCount();
}
public class Microsoft.TeamFoundation.VersionControl.Client.AuthorizationException : SecurityException {
    public AuthorizationException(string message);
    public AuthorizationException(string message, Exception ex);
    protected AuthorizationException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.AutoMergeDisallowedException : VersionControlException {
    public AutoMergeDisallowedException(string message);
    public AutoMergeDisallowedException(string message, Exception ex);
    protected AutoMergeDisallowedException(SerializationInfo info, StreamingContext context);
}
[FlagsAttribute]
public enum Microsoft.TeamFoundation.VersionControl.Client.AutoResolveOptions : Enum {
    public int value__;
    public static AutoResolveOptions None;
    public static AutoResolveOptions OnlyLocalTarget;
    public static AutoResolveOptions OnlyServerSource;
    public static AutoResolveOptions BothLocalTargetAndServerSource;
    public static AutoResolveOptions IncomingRename;
    public static AutoResolveOptions Redundant;
    public static AutoResolveOptions Silent;
    public static AutoResolveOptions AllContent;
    public static AutoResolveOptions All;
    public static AutoResolveOptions AllSilent;
}
public class Microsoft.TeamFoundation.VersionControl.Client.BadChecksumException : VersionControlException {
    public BadChecksumException(string message);
    public BadChecksumException(string message, Exception ex);
    protected BadChecksumException(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.BaselineFileGuidComparer : object {
    public sealed virtual bool Equals(Byte[] x, Byte[] y);
    public sealed virtual int GetHashCode(Byte[] x);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.BaselineFolder : object {
    public string Partition;
    public string Path;
    public BaselineFolderState State;
    private static String[] s_partitioningFolders;
    private static int c_partitioningFolderCount;
    private static string c_tfFolderName;
    private static string c_gzExtension;
    private static string c_rwExtension;
    public static string BaselineFolderName { get; }
    public static string GzipExtension { get; }
    public static string RawExtension { get; }
    public static int PartitioningFolderCount { get; }
    private static BaselineFolder();
    public BaselineFolder(string partition, string path, BaselineFolderState state);
    public BaselineFolder Clone();
    public static BaselineFolder Create(Workspace workspace, string localFolder);
    public static void CreateBaselineFolderStructure(string path);
    public static void EnsureLocalMetadataDirectoryExists(Workspace workspace);
    public static void EnsureLocalMetadataDirectoryExists(Workspace workspace, string sourceDirectoryForAcl);
    public static void EnsureBaselineDirectoryExists(Workspace workspace, string directory);
    public string GetPathFromGuid(Byte[] baselineFileGuid);
    public static string GetPathFromGuid(string baselineFolderRootPath, Byte[] baselineFileGuid);
    public static string GetPathFromGuid(string baselineFolderRootPath, Byte[] baselineFileGuid, String& individualBaselineFolder);
    public static void CheckForValidBaselineFileGuid(Byte[] baselineFileGuid);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static string GetPartitionForPath(string localItem);
    public static string get_BaselineFolderName();
    public static string get_GzipExtension();
    public static string get_RawExtension();
    public static int get_PartitioningFolderCount();
}
internal class Microsoft.TeamFoundation.VersionControl.Client.BaselineFolderCollection : object {
    private TokenReaderWriterLock m_rwLock;
    private Workspace m_workspace;
    private BaselineFolder[] m_baselineFolders;
    private WorkingFolder[] m_workingFolders;
    private static string c_tmpExtension;
    private static int c_decompressionBufferSize;
    public WorkingFolder[] WorkingFolders { get; }
    public BaselineFolderCollection(Workspace workspace, LocalWorkspaceProperties wp);
    public int LockForRead();
    public void UnlockForRead(int token);
    public int LockForWrite();
    public void UnlockForWrite(int token);
    public void UpdateFrom(LocalWorkspaceProperties toUpdateFrom);
    public string GetNewBaselineLocation(Byte[] baselineFileGuid, string targetLocalItem, int readLockToken);
    public bool IsImmediateParentOfBaselineFolder(string sourceLocalItem);
    public void CopyBaselineToTarget(Byte[] baselineFileGuid, string targetLocalItem, long baselineFileLength, Byte[] baselineHashValue);
    public void DeleteBaseline(Byte[] baselineFileGuid);
    public static string GetNewBaselineLocation(Workspace workspace, IList`1<BaselineFolder> baselineFolders, Byte[] baselineFileGuid, string targetLocalItem);
    public static string GetBaselineLocation(Workspace workspace, IList`1<BaselineFolder> baselineFolders, Byte[] baselineFileGuid);
    public static string GetBaselineLocation(Workspace workspace, IList`1<BaselineFolder> baselineFolders, Byte[] baselineFileGuid, Boolean& isBaselineCompressed);
    public static void CopyBaselineToTarget(Workspace workspace, IList`1<BaselineFolder> baselineFolders, Byte[] baselineFileGuid, string targetLocalItem, long baselineFileLength, Byte[] baselineHashValue);
    public static void DeleteBaseline(Workspace workspace, IList`1<BaselineFolder> baselineFolders, Byte[] baselineFileGuid);
    public static void UpdateBaselineLocation(Workspace workspace, IList`1<BaselineFolder> baselineFolders, Byte[] baselineFileGuid, string currentLocalItem);
    private static BaselineFolder GetBaselineFolderForPartition(IList`1<BaselineFolder> baselineFolders, string partition);
    public void ProcessBaselineRequests(Workspace workspace, IEnumerable`1<BaselineRequest> requests);
    public void ProcessBaselineRequests(Workspace workspace, IEnumerable`1<BaselineRequest> requests, LocalBaselineRequestProgressEventHandler callback, bool throwIfCanceled, IEnumerable`1& failedLocalRequests);
    public static FileStream CreateFile(string filePath);
    public static FileStream CreateFile(String& filePath, bool createTempOnFailure, string tempUniqueString, Boolean& tempCreated);
    public WorkingFolder[] get_WorkingFolders();
}
internal enum Microsoft.TeamFoundation.VersionControl.Client.BaselineFolderState : Enum {
    public int value__;
    public static BaselineFolderState Unknown;
    public static BaselineFolderState Stale;
    public static BaselineFolderState Valid;
}
internal class Microsoft.TeamFoundation.VersionControl.Client.BaselineRequest : object {
    public Byte[] BaselineFileGuid;
    public string BaselinePartitionLocalItem;
    public string SourceLocalItem;
    public string DownloadUrl;
    public Byte[] HashValue;
    public static BaselineRequest FromDisk(Byte[] baselineFileGuid, string baselinePartitionLocalItem, string sourceLocalItem, Byte[] hashValue);
    public static BaselineRequest FromDiskAndDownloadUrl(Byte[] baselineFileGuid, string baselinePartitionLocalItem, string sourceLocalItem, string downloadUrl, Byte[] hashValue);
    public static BaselineRequest FromDownloadUrl(Byte[] baselineFileGuid, string baselinePartitionLocalItem, string downloadUrl, Byte[] hashValue);
    public static BaselineRequest MakeRemoveRequest(Byte[] baselineFileGuid);
}
public class Microsoft.TeamFoundation.VersionControl.Client.BaselineUnavailableException : VersionControlException {
    public BaselineUnavailableException(string message);
}
public class Microsoft.TeamFoundation.VersionControl.Client.BeforeWorkItemsUpdateEventHandler : MulticastDelegate {
    public BeforeWorkItemsUpdateEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, WorkItemsUpdateEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, WorkItemsUpdateEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.TeamFoundation.VersionControl.Client.BranchHistoryTreeItem : object {
    private BranchRelative m_relative;
    private int m_level;
    private BranchHistoryTreeItem m_parent;
    private List`1<BranchHistoryTreeItem> m_children;
    public BranchRelative Relative { get; }
    private IBranchRelative Microsoft.TeamFoundation.VersionControl.Common.IBranchHistoryTreeItem.Relative { get; private set; }
    public int Level { get; }
    private int Microsoft.TeamFoundation.VersionControl.Common.IBranchHistoryTreeItem.Level { get; private set; }
    public BranchHistoryTreeItem Parent { get; }
    private IBranchHistoryTreeItem Microsoft.TeamFoundation.VersionControl.Common.IBranchHistoryTreeItem.Parent { get; private set; }
    public ICollection Children { get; }
    private ICollection Microsoft.TeamFoundation.VersionControl.Common.IBranchHistoryTreeItem.Children { get; }
    internal BranchHistoryTreeItem(BranchHistoryTreeItem ourParent, BranchRelative ourRelative, int ourLevel);
    private sealed virtual override void Microsoft.TeamFoundation.VersionControl.Common.IBranchHistoryTreeItem.AddChild(IBranchHistoryTreeItem newChild);
    internal void AddChild(BranchHistoryTreeItem newChild);
    public BranchRelative get_Relative();
    private sealed virtual override IBranchRelative Microsoft.TeamFoundation.VersionControl.Common.IBranchHistoryTreeItem.get_Relative();
    private sealed virtual override void Microsoft.TeamFoundation.VersionControl.Common.IBranchHistoryTreeItem.set_Relative(IBranchRelative value);
    public int get_Level();
    private sealed virtual override int Microsoft.TeamFoundation.VersionControl.Common.IBranchHistoryTreeItem.get_Level();
    private sealed virtual override void Microsoft.TeamFoundation.VersionControl.Common.IBranchHistoryTreeItem.set_Level(int value);
    public BranchHistoryTreeItem get_Parent();
    private sealed virtual override IBranchHistoryTreeItem Microsoft.TeamFoundation.VersionControl.Common.IBranchHistoryTreeItem.get_Parent();
    private sealed virtual override void Microsoft.TeamFoundation.VersionControl.Common.IBranchHistoryTreeItem.set_Parent(IBranchHistoryTreeItem value);
    public ICollection get_Children();
    private sealed virtual override ICollection Microsoft.TeamFoundation.VersionControl.Common.IBranchHistoryTreeItem.get_Children();
    public BranchHistoryTreeItem GetRequestedItem();
    private sealed virtual override IBranchHistoryTreeItem Microsoft.TeamFoundation.VersionControl.Common.IBranchHistoryTreeItem.GetRequestedItem();
}
internal class Microsoft.TeamFoundation.VersionControl.Client.BranchHistoryUtil : object {
    internal static TBranchHistoryTreeItem[] ConvertBranchRelativeSetToHistoryTrees(ICollection`1<TBranchRelative> relatives);
}
public class Microsoft.TeamFoundation.VersionControl.Client.BranchObject : object {
    internal ItemIdentifier[] m_childBranches;
    private DateTime m_dateCreated;
    private BranchProperties m_properties;
    internal ItemIdentifier[] m_relatedBranches;
    [EditorBrowsableAttribute("1")]
public ItemIdentifier[] ChildBranchesNoClone { get; }
    [EditorBrowsableAttribute("1")]
public ItemIdentifier[] RelatedBranchesNoClone { get; }
    public ItemIdentifier[] ChildBranches { get; }
    public DateTime DateCreated { get; }
    public BranchProperties Properties { get; }
    public ItemIdentifier[] RelatedBranches { get; }
    public ItemIdentifier[] get_ChildBranchesNoClone();
    public ItemIdentifier[] get_RelatedBranchesNoClone();
    public ItemIdentifier[] get_ChildBranches();
    public DateTime get_DateCreated();
    public BranchProperties get_Properties();
    public ItemIdentifier[] get_RelatedBranches();
    [EditorBrowsableAttribute("1")]
public static BranchObject FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, BranchObject obj);
}
public class Microsoft.TeamFoundation.VersionControl.Client.BranchObjectCreatedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private BranchProperties <Properties>k__BackingField;
    public BranchProperties Properties { get; private set; }
    public BranchObjectCreatedEventArgs(BranchProperties properties);
    [CompilerGeneratedAttribute]
public BranchProperties get_Properties();
    [CompilerGeneratedAttribute]
private void set_Properties(BranchProperties value);
}
public class Microsoft.TeamFoundation.VersionControl.Client.BranchObjectCreatedEventHandler : MulticastDelegate {
    public BranchObjectCreatedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, BranchObjectCreatedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, BranchObjectCreatedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.TeamFoundation.VersionControl.Client.BranchObjectDeletedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private ItemIdentifier <RootItem>k__BackingField;
    public ItemIdentifier RootItem { get; private set; }
    public BranchObjectDeletedEventArgs(ItemIdentifier branchRootItem);
    [CompilerGeneratedAttribute]
public ItemIdentifier get_RootItem();
    [CompilerGeneratedAttribute]
private void set_RootItem(ItemIdentifier value);
}
public class Microsoft.TeamFoundation.VersionControl.Client.BranchObjectDeletedEventHandler : MulticastDelegate {
    public BranchObjectDeletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, BranchObjectDeletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, BranchObjectDeletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.TeamFoundation.VersionControl.Client.BranchObjectOwnership : object {
    private ItemIdentifier m_rootItem;
    private int m_versionedItemCount;
    public ItemIdentifier RootItem { get; public set; }
    public int VersionedItemCount { get; public set; }
    public ItemIdentifier get_RootItem();
    public void set_RootItem(ItemIdentifier value);
    public int get_VersionedItemCount();
    public void set_VersionedItemCount(int value);
    [EditorBrowsableAttribute("1")]
public static BranchObjectOwnership FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, BranchObjectOwnership obj);
}
public class Microsoft.TeamFoundation.VersionControl.Client.BranchObjectUpdatedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private BranchProperties <Properties>k__BackingField;
    public BranchProperties Properties { get; private set; }
    public BranchObjectUpdatedEventArgs(BranchProperties properties);
    [CompilerGeneratedAttribute]
public BranchProperties get_Properties();
    [CompilerGeneratedAttribute]
private void set_Properties(BranchProperties value);
}
public class Microsoft.TeamFoundation.VersionControl.Client.BranchObjectUpdatedEventHandler : MulticastDelegate {
    public BranchObjectUpdatedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, BranchObjectUpdatedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, BranchObjectUpdatedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.TeamFoundation.VersionControl.Client.BranchProperties : object {
    internal Mapping[] m_branchMappings;
    private string m_description;
    private string m_owner;
    private string m_ownerDisplayName;
    private string m_ownerUniqueName;
    private ItemIdentifier m_parentBranch;
    private ItemIdentifier m_rootItem;
    public string Owner { get; public set; }
    public string OwnerDisplayName { get; public set; }
    public Mapping[] BranchMappings { get; public set; }
    public string Description { get; public set; }
    public ItemIdentifier ParentBranch { get; public set; }
    public ItemIdentifier RootItem { get; }
    public BranchProperties(ItemIdentifier rootItem);
    public string get_Owner();
    public void set_Owner(string value);
    public string get_OwnerDisplayName();
    public void set_OwnerDisplayName(string value);
    private void AfterDeserialize();
    public Mapping[] get_BranchMappings();
    public void set_BranchMappings(Mapping[] value);
    public string get_Description();
    public void set_Description(string value);
    public ItemIdentifier get_ParentBranch();
    public void set_ParentBranch(ItemIdentifier value);
    public ItemIdentifier get_RootItem();
    [EditorBrowsableAttribute("1")]
public static BranchProperties FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, BranchProperties obj);
}
public class Microsoft.TeamFoundation.VersionControl.Client.BranchRelative : object {
    private Item m_branchFromItem;
    private int m_branchToChangeTypeEx;
    private Item m_branchToItem;
    private bool m_isRequestedItem;
    private int m_relativeFromItemId;
    private int m_relativeToItemId;
    private int Microsoft.TeamFoundation.VersionControl.Common.IBranchRelative.RelativeToItemId { get; private set; }
    private int Microsoft.TeamFoundation.VersionControl.Common.IBranchRelative.RelativeFromItemId { get; private set; }
    private bool Microsoft.TeamFoundation.VersionControl.Common.IBranchRelative.IsRequestedItem { get; private set; }
    private object Microsoft.TeamFoundation.VersionControl.Common.IBranchRelative.BranchFromItem { get; private set; }
    private object Microsoft.TeamFoundation.VersionControl.Common.IBranchRelative.BranchToItem { get; private set; }
    public ChangeType BranchToChangeType { get; }
    public Item BranchFromItem { get; }
    public Item BranchToItem { get; }
    public bool IsRequestedItem { get; }
    public int RelativeFromItemId { get; }
    public int RelativeToItemId { get; }
    private sealed virtual override int Microsoft.TeamFoundation.VersionControl.Common.IBranchRelative.get_RelativeToItemId();
    private sealed virtual override void Microsoft.TeamFoundation.VersionControl.Common.IBranchRelative.set_RelativeToItemId(int value);
    private sealed virtual override int Microsoft.TeamFoundation.VersionControl.Common.IBranchRelative.get_RelativeFromItemId();
    private sealed virtual override void Microsoft.TeamFoundation.VersionControl.Common.IBranchRelative.set_RelativeFromItemId(int value);
    private sealed virtual override bool Microsoft.TeamFoundation.VersionControl.Common.IBranchRelative.get_IsRequestedItem();
    private sealed virtual override void Microsoft.TeamFoundation.VersionControl.Common.IBranchRelative.set_IsRequestedItem(bool value);
    private sealed virtual override object Microsoft.TeamFoundation.VersionControl.Common.IBranchRelative.get_BranchFromItem();
    private sealed virtual override void Microsoft.TeamFoundation.VersionControl.Common.IBranchRelative.set_BranchFromItem(object value);
    private sealed virtual override object Microsoft.TeamFoundation.VersionControl.Common.IBranchRelative.get_BranchToItem();
    private sealed virtual override void Microsoft.TeamFoundation.VersionControl.Common.IBranchRelative.set_BranchToItem(object value);
    public ChangeType get_BranchToChangeType();
    public Item get_BranchFromItem();
    public Item get_BranchToItem();
    public bool get_IsRequestedItem();
    public int get_RelativeFromItemId();
    public int get_RelativeToItemId();
    [EditorBrowsableAttribute("1")]
public static BranchRelative FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, BranchRelative obj);
}
public class Microsoft.TeamFoundation.VersionControl.Client.BranchSourceNotCommittedException : ServerItemException {
    public BranchSourceNotCommittedException(string message);
    public BranchSourceNotCommittedException(string message, Exception ex);
    protected BranchSourceNotCommittedException(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.BufferPool : object {
    public int BufferSize;
    private Stack`1<Byte[]> m_buffers;
    private static int c_defaultBufferSize;
    private static int s_bufferSize;
    private static BufferPool();
    public BufferPool(int bufferSize);
    public Byte[] GetBuffer();
    public void ReturnBuffer(Byte[] buffer);
    public void Clear();
}
internal enum Microsoft.TeamFoundation.VersionControl.Client.CallStatus : Enum {
    public int value__;
    public static CallStatus Starting;
    public static CallStatus Compressing;
    public static CallStatus Working;
    public static CallStatus Finished;
}
[ObsoleteAttribute("This class has been deprecated and will be removed from a future release. See System.OperationCanceledException instead.", "False")]
public class Microsoft.TeamFoundation.VersionControl.Client.CancelException : OperationCanceledException {
    public CancelException(string message);
    public CancelException(Exception cancelledInnerException);
    public CancelException(string message, Exception cancelledInnerException);
    protected CancelException(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
public class Microsoft.TeamFoundation.VersionControl.Client.CannotBranchDestroyedContentException : ServerItemException {
    public CannotBranchDestroyedContentException(string message);
    public CannotBranchDestroyedContentException(string message, Exception ex);
    protected CannotBranchDestroyedContentException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.CannotChangeRootFolderException : VersionControlException {
    public CannotChangeRootFolderException(string message);
    public CannotChangeRootFolderException(string message, Exception ex);
    protected CannotChangeRootFolderException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.CannotChangeWorkspaceOwnerException : VersionControlException {
    public CannotChangeWorkspaceOwnerException(string message);
    public CannotChangeWorkspaceOwnerException(string message, Exception ex);
    protected CannotChangeWorkspaceOwnerException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.CannotCheckinAllWithEditException : VersionControlException {
    public CannotCheckinAllWithEditException(string message);
    public CannotCheckinAllWithEditException(string message, Exception ex);
    protected CannotCheckinAllWithEditException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.CannotCheckinDependantRenameException : ServerItemException {
    public CannotCheckinDependantRenameException(string message);
    public CannotCheckinDependantRenameException(string message, Exception ex);
    protected CannotCheckinDependantRenameException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.CannotCheckinPartialUndeleteException : ServerItemException {
    public CannotCheckinPartialUndeleteException(string message);
    public CannotCheckinPartialUndeleteException(string message, Exception ex);
    protected CannotCheckinPartialUndeleteException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.CannotCheckinRenameAsPendingAddConflictsException : ServerItemException {
    public CannotCheckinRenameAsPendingAddConflictsException(string message);
    public CannotCheckinRenameAsPendingAddConflictsException(string message, Exception ex);
    protected CannotCheckinRenameAsPendingAddConflictsException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.CannotCheckinRenameDueToChildConflictException : ServerItemException {
    public CannotCheckinRenameDueToChildConflictException(string message);
    public CannotCheckinRenameDueToChildConflictException(string message, Exception ex);
    protected CannotCheckinRenameDueToChildConflictException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.CannotCreateFilesInRootException : VersionControlException {
    public CannotCreateFilesInRootException(string message);
    public CannotCreateFilesInRootException(string message, Exception ex);
    protected CannotCreateFilesInRootException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.CannotCreateParentFolderException : ServerItemException {
    public CannotCreateParentFolderException(string message);
    public CannotCreateParentFolderException(string message, Exception ex);
    protected CannotCreateParentFolderException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.CannotDeleteTeamProjectFolderException : ServerItemException {
    public CannotDeleteTeamProjectFolderException(string message);
    public CannotDeleteTeamProjectFolderException(string message, Exception ex);
    protected CannotDeleteTeamProjectFolderException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.CannotDestroyRootException : ServerItemException {
    public CannotDestroyRootException(string message);
    public CannotDestroyRootException(string message, Exception ex);
    protected CannotDestroyRootException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.CannotFindLatestChangesetException : VersionControlException {
    public CannotFindLatestChangesetException(string message);
    public CannotFindLatestChangesetException(string message, Exception ex);
    protected CannotFindLatestChangesetException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.CannotLockException : ServerItemException {
    public CannotLockException(string message);
    public CannotLockException(string message, Exception ex);
    protected CannotLockException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.CannotMergeDestroyedFileException : ServerItemException {
    public CannotMergeDestroyedFileException(string message);
    public CannotMergeDestroyedFileException(string message, Exception ex);
    protected CannotMergeDestroyedFileException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.CannotMergeUnderSourceException : VersionControlException {
    public CannotMergeUnderSourceException(string message);
    public CannotMergeUnderSourceException(string message, Exception ex);
    protected CannotMergeUnderSourceException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.CannotMergeWithExistingConflictException : ServerItemException {
    public CannotMergeWithExistingConflictException(string message);
    public CannotMergeWithExistingConflictException(string message, Exception ex);
    protected CannotMergeWithExistingConflictException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.CannotMergeWithWorkspaceSpecAndPendingDeleteException : VersionControlException {
    public CannotMergeWithWorkspaceSpecAndPendingDeleteException(string message);
    public CannotMergeWithWorkspaceSpecAndPendingDeleteException(string message, Exception ex);
    protected CannotMergeWithWorkspaceSpecAndPendingDeleteException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.CannotMoveToRootException : VersionControlException {
    public CannotMoveToRootException(string message);
    public CannotMoveToRootException(string message, Exception ex);
    protected CannotMoveToRootException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.CannotPendChangeOnDestroyedFileException : ServerItemException {
    public CannotPendChangeOnDestroyedFileException(string message);
    public CannotPendChangeOnDestroyedFileException(string message, Exception ex);
    protected CannotPendChangeOnDestroyedFileException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.CannotPendEditOnDeletedFileWithGetLatestException : ServerItemException {
    public CannotPendEditOnDeletedFileWithGetLatestException(string message);
    public CannotPendEditOnDeletedFileWithGetLatestException(string message, Exception ex);
    protected CannotPendEditOnDeletedFileWithGetLatestException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.CannotPendEditOnRenamedFileWithGetLatestException : ServerItemException {
    public CannotPendEditOnRenamedFileWithGetLatestException(string message);
    public CannotPendEditOnRenamedFileWithGetLatestException(string message, Exception ex);
    protected CannotPendEditOnRenamedFileWithGetLatestException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.CannotRenameBackToOriginalSourceException : VersionControlException {
    public CannotRenameBackToOriginalSourceException(string message);
    public CannotRenameBackToOriginalSourceException(string message, Exception ex);
    protected CannotRenameBackToOriginalSourceException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.CannotRenameDueToChildConflictException : VersionControlException {
    public CannotRenameDueToChildConflictException(string message);
    public CannotRenameDueToChildConflictException(string message, Exception ex);
    protected CannotRenameDueToChildConflictException(SerializationInfo info, StreamingContext context);
    public CannotRenameDueToChildConflictException(string renamedItem, string offendingItem);
}
public class Microsoft.TeamFoundation.VersionControl.Client.CannotResolveAcceptMergeWithNonexistentVersionException : VersionControlException {
    public CannotResolveAcceptMergeWithNonexistentVersionException(string message);
    public CannotResolveAcceptMergeWithNonexistentVersionException(string message, Exception ex);
    protected CannotResolveAcceptMergeWithNonexistentVersionException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.CannotResolveBecauseShelvesetDeletedException : VersionControlException {
    public CannotResolveBecauseShelvesetDeletedException(string message);
    public CannotResolveBecauseShelvesetDeletedException(string message, Exception ex);
    protected CannotResolveBecauseShelvesetDeletedException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.CannotResolveConflictAsAutoMerge : VersionControlException {
    public CannotResolveConflictAsAutoMerge(string message);
    public CannotResolveConflictAsAutoMerge(string message, Exception ex);
    protected CannotResolveConflictAsAutoMerge(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.CannotResolveDeletedItemWithAcceptMergeException : VersionControlException {
    public CannotResolveDeletedItemWithAcceptMergeException(string message);
    public CannotResolveDeletedItemWithAcceptMergeException(string message, Exception ex);
    protected CannotResolveDeletedItemWithAcceptMergeException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.CannotResolveDueToRenameAndDelete : VersionControlException {
    public CannotResolveDueToRenameAndDelete(string message);
    public CannotResolveDueToRenameAndDelete(string message, Exception ex);
    protected CannotResolveDueToRenameAndDelete(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.CannotResolveToPartialUndeleteException : VersionControlException {
    public CannotResolveToPartialUndeleteException(string message);
    public CannotResolveToPartialUndeleteException(string message, Exception ex);
    protected CannotResolveToPartialUndeleteException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.CannotSetMappingOnRenameException : ServerItemException {
    public CannotSetMappingOnRenameException(string message);
    public CannotSetMappingOnRenameException(string message, Exception ex);
    protected CannotSetMappingOnRenameException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.CannotShelvePartialUndeleteException : ServerItemException {
    public CannotShelvePartialUndeleteException(string message);
    public CannotShelvePartialUndeleteException(string message, Exception ex);
    protected CannotShelvePartialUndeleteException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.CannotSpecifyNewNameException : VersionControlException {
    public CannotSpecifyNewNameException(string message);
    public CannotSpecifyNewNameException(string message, Exception ex);
    protected CannotSpecifyNewNameException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.CannotTakeCheckoutLockInLocalWorkspaceException : VersionControlException {
    public CannotTakeCheckoutLockInLocalWorkspaceException(string message);
    public CannotTakeCheckoutLockInLocalWorkspaceException(string message, Exception ex);
    protected CannotTakeCheckoutLockInLocalWorkspaceException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.CannotUndeleteTeamProjectFolderException : VersionControlException {
    public CannotUndeleteTeamProjectFolderException(string message);
    public CannotUndeleteTeamProjectFolderException(string message, Exception ex);
    protected CannotUndeleteTeamProjectFolderException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.CannotUndoItemExistingLockConflictsException : VersionControlException {
    public CannotUndoItemExistingLockConflictsException(string message);
    public CannotUndoItemExistingLockConflictsException(string message, Exception ex);
    protected CannotUndoItemExistingLockConflictsException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.CannotUndoRenameDueToChildConflictException : VersionControlException {
    public CannotUndoRenameDueToChildConflictException(string message);
    public CannotUndoRenameDueToChildConflictException(string message, Exception ex);
    protected CannotUndoRenameDueToChildConflictException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.CannotUnlockException : VersionControlException {
    public CannotUnlockException(string message);
    public CannotUnlockException(string message, Exception ex);
    protected CannotUnlockException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.Change : object {
    private static ChangeComparer m_comparer;
    private ReadOnlyCollection`1<MergeSource> m_mergeCollection;
    private ChangeType m_changeType;
    private Item m_item;
    internal MergeSource[] m_mergeSources;
    private int m_typeEx;
    internal static ChangeComparer Comparer { get; }
    public ChangeType ChangeType { get; }
    public ReadOnlyCollection`1<MergeSource> MergeSources { get; }
    public Item Item { get; }
    internal static ChangeComparer get_Comparer();
    public ChangeType get_ChangeType();
    public ReadOnlyCollection`1<MergeSource> get_MergeSources();
    private void AfterDeserialize();
    public Item get_Item();
    [EditorBrowsableAttribute("1")]
public static Change FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, Change obj);
}
public class Microsoft.TeamFoundation.VersionControl.Client.ChangeAlreadyPendingException : ServerItemException {
    public ChangeAlreadyPendingException(string message);
    public ChangeAlreadyPendingException(string message, Exception ex);
    protected ChangeAlreadyPendingException(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.ChangeComparer : object {
    private sealed virtual override int System.Collections.Generic.IComparer<Microsoft.TeamFoundation.VersionControl.Client.Change>.Compare(Change x, Change y);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.ChangeRequest : object {
    private int m_deletionId;
    private int m_encoding;
    private ItemSpec m_itemSpec;
    private ItemType m_itemType;
    private LockLevel m_lockLevel;
    internal PropertyValue[] m_properties;
    private RequestType m_requestType;
    private string m_targetItem;
    private ItemType m_targetItemType;
    private VersionSpec m_versionSpec;
    public int DeletionId { get; public set; }
    public int Encoding { get; public set; }
    public ItemSpec ItemSpec { get; public set; }
    public ItemType ItemType { get; public set; }
    public LockLevel LockLevel { get; public set; }
    public PropertyValue[] Properties { get; public set; }
    public RequestType RequestType { get; public set; }
    public string TargetItem { get; public set; }
    public ItemType TargetItemType { get; public set; }
    public VersionSpec VersionSpec { get; public set; }
    public ChangeRequest(ItemSpec item, VersionSpec version, RequestType requestType, ItemType itemType, int encoding, LockLevel lockLevel, int deletionId, string targetItem, bool checkTarget);
    public static ChangeRequest[] FromStrings(String[] paths, RequestType requestType, LockLevel lockLevel, RecursionType recursion, bool checkTarget);
    public static ChangeRequest[] FromItemSpecs(ItemSpec[] itemSpecs, RequestType requestType, LockLevel lockLevel, bool checkTarget);
    public int get_DeletionId();
    public void set_DeletionId(int value);
    public int get_Encoding();
    public void set_Encoding(int value);
    public ItemSpec get_ItemSpec();
    public void set_ItemSpec(ItemSpec value);
    public ItemType get_ItemType();
    public void set_ItemType(ItemType value);
    public LockLevel get_LockLevel();
    public void set_LockLevel(LockLevel value);
    public PropertyValue[] get_Properties();
    public void set_Properties(PropertyValue[] value);
    public RequestType get_RequestType();
    public void set_RequestType(RequestType value);
    public string get_TargetItem();
    public void set_TargetItem(string value);
    public ItemType get_TargetItemType();
    public void set_TargetItemType(ItemType value);
    public VersionSpec get_VersionSpec();
    public void set_VersionSpec(VersionSpec value);
    internal static ChangeRequest FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    internal void ToXml(XmlWriter writer, string element);
    internal static void ToXml(XmlWriter writer, string element, ChangeRequest obj);
}
public class Microsoft.TeamFoundation.VersionControl.Client.Changeset : object {
    private VersionControlServer m_sourceControl;
    private WorkItem[] m_workItems;
    internal Change[] m_changes;
    private int m_changesetId;
    private CheckinNote m_checkinNote;
    private string m_comment;
    private string m_committer;
    private string m_committerDisplayName;
    private DateTime m_creationDate;
    internal PropertyValue[] m_internalProperties;
    private string m_owner;
    private string m_ownerDisplayName;
    private PolicyOverrideInfo m_policyOverride;
    [XmlIgnoreAttribute]
public Uri ArtifactUri { get; }
    public AssociatedWorkItemInfo[] AssociatedWorkItems { get; }
    [XmlIgnoreAttribute]
public WorkItem[] WorkItems { get; }
    private WorkItemStore WorkItemStore { get; }
    [XmlIgnoreAttribute]
public VersionControlServer VersionControlServer { get; internal set; }
    [XmlIgnoreAttribute]
public ReadOnlyCollection`1<PropertyValue> Properties { get; }
    public Change[] Changes { get; public set; }
    public int ChangesetId { get; public set; }
    public CheckinNote CheckinNote { get; public set; }
    public string Comment { get; public set; }
    public string Committer { get; public set; }
    public string CommitterDisplayName { get; public set; }
    public DateTime CreationDate { get; public set; }
    internal PropertyValue[] InternalProperties { get; internal set; }
    public string Owner { get; public set; }
    public string OwnerDisplayName { get; public set; }
    public PolicyOverrideInfo PolicyOverride { get; public set; }
    internal Changeset(VersionControlServer sourceControl, string owner, string comment, CheckinNote checkinNote, PolicyOverrideInfo policyOverride, DateTime creationDate);
    internal void SetChangesetId(int changesetId);
    public void Update();
    public Uri get_ArtifactUri();
    public AssociatedWorkItemInfo[] get_AssociatedWorkItems();
    public WorkItem[] get_WorkItems();
    private WorkItemStore get_WorkItemStore();
    public VersionControlServer get_VersionControlServer();
    internal void set_VersionControlServer(VersionControlServer value);
    internal void SortChanges();
    public ReadOnlyCollection`1<PropertyValue> get_Properties();
    private void AfterDeserialize();
    public Change[] get_Changes();
    public void set_Changes(Change[] value);
    public int get_ChangesetId();
    public void set_ChangesetId(int value);
    public CheckinNote get_CheckinNote();
    public void set_CheckinNote(CheckinNote value);
    public string get_Comment();
    public void set_Comment(string value);
    public string get_Committer();
    public void set_Committer(string value);
    public string get_CommitterDisplayName();
    public void set_CommitterDisplayName(string value);
    public DateTime get_CreationDate();
    public void set_CreationDate(DateTime value);
    internal PropertyValue[] get_InternalProperties();
    internal void set_InternalProperties(PropertyValue[] value);
    public string get_Owner();
    public void set_Owner(string value);
    public string get_OwnerDisplayName();
    public void set_OwnerDisplayName(string value);
    public PolicyOverrideInfo get_PolicyOverride();
    public void set_PolicyOverride(PolicyOverrideInfo value);
    [EditorBrowsableAttribute("1")]
public static Changeset FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, Changeset obj);
}
public class Microsoft.TeamFoundation.VersionControl.Client.ChangesetAuthorMustBeNonGroupException : VersionControlException {
    public ChangesetAuthorMustBeNonGroupException(string message);
    public ChangesetAuthorMustBeNonGroupException(string message, Exception ex);
    protected ChangesetAuthorMustBeNonGroupException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.ChangesetMerge : object {
    private Changeset m_targetChangeset;
    private bool m_partial;
    private int m_sourceVersion;
    private int m_targetVersion;
    public Changeset TargetChangeset { get; internal set; }
    public bool Partial { get; }
    public int SourceVersion { get; }
    public int TargetVersion { get; }
    public Changeset get_TargetChangeset();
    internal void set_TargetChangeset(Changeset value);
    public bool get_Partial();
    public int get_SourceVersion();
    public int get_TargetVersion();
    [EditorBrowsableAttribute("1")]
public static ChangesetMerge FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, ChangesetMerge obj);
}
public class Microsoft.TeamFoundation.VersionControl.Client.ChangesetMergeDetails : object {
    internal Changeset[] m_changesets;
    internal ItemMerge[] m_mergedItems;
    internal ItemMerge[] m_unmergedItems;
    public Changeset[] Changesets { get; }
    public ItemMerge[] MergedItems { get; }
    public ItemMerge[] UnmergedItems { get; }
    public Changeset[] get_Changesets();
    public ItemMerge[] get_MergedItems();
    public ItemMerge[] get_UnmergedItems();
    [EditorBrowsableAttribute("1")]
public static ChangesetMergeDetails FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, ChangesetMergeDetails obj);
}
public class Microsoft.TeamFoundation.VersionControl.Client.ChangesetNotFoundException : VersionControlException {
    public ChangesetNotFoundException(string message);
    public ChangesetNotFoundException(string message, Exception ex);
    protected ChangesetNotFoundException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.ChangesetReconciledEventArgs : EventArgs {
    private int m_changesetId;
    public int ChangesetId { get; }
    public ChangesetReconciledEventArgs(int changesetId);
    public int get_ChangesetId();
}
public class Microsoft.TeamFoundation.VersionControl.Client.ChangesetReconciledEventHandler : MulticastDelegate {
    public ChangesetReconciledEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ChangesetReconciledEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ChangesetReconciledEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.TeamFoundation.VersionControl.Client.ChangesetSummary : object {
    private int m_changesetId;
    private string m_comment;
    private string m_committer;
    private string m_committerDisplayName;
    private DateTime m_creationDate;
    private string m_owner;
    private string m_ownerDisplayName;
    public int ChangesetId { get; public set; }
    public string Comment { get; public set; }
    public string Committer { get; public set; }
    public string CommitterDisplayName { get; public set; }
    public DateTime CreationDate { get; public set; }
    public string Owner { get; public set; }
    public string OwnerDisplayName { get; public set; }
    private void AfterDeserialize();
    public int get_ChangesetId();
    public void set_ChangesetId(int value);
    public string get_Comment();
    public void set_Comment(string value);
    public string get_Committer();
    public void set_Committer(string value);
    public string get_CommitterDisplayName();
    public void set_CommitterDisplayName(string value);
    public DateTime get_CreationDate();
    public void set_CreationDate(DateTime value);
    public string get_Owner();
    public void set_Owner(string value);
    public string get_OwnerDisplayName();
    public void set_OwnerDisplayName(string value);
    [EditorBrowsableAttribute("1")]
public static ChangesetSummary FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, ChangesetSummary obj);
}
public class Microsoft.TeamFoundation.VersionControl.Client.ChangesetVersionSpec : VersionSpec {
    private int m_changesetId;
    public static char Identifier;
    public int ChangesetId { get; public set; }
    public ChangesetVersionSpec(string changeset);
    public ChangesetVersionSpec(int changeset);
    private static ChangesetVersionSpec();
    public int get_ChangesetId();
    public void set_ChangesetId(int value);
    [EditorBrowsableAttribute("1")]
public static ChangesetVersionSpec FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public virtual void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, ChangesetVersionSpec obj);
    public static int ParseChangesetNumber(string changeset);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public virtual string ComputeVersionString();
}
[FlagsAttribute]
public enum Microsoft.TeamFoundation.VersionControl.Client.ChangeType : Enum {
    public int value__;
    public static ChangeType Add;
    public static ChangeType Branch;
    public static ChangeType Delete;
    public static ChangeType Edit;
    public static ChangeType Encoding;
    public static ChangeType Lock;
    public static ChangeType Merge;
    public static ChangeType None;
    public static ChangeType Property;
    public static ChangeType Rename;
    public static ChangeType Rollback;
    public static ChangeType SourceRename;
    public static ChangeType Undelete;
}
public class Microsoft.TeamFoundation.VersionControl.Client.CheckinConflict : object {
    private string m_serverItem;
    private string m_message;
    private bool m_resolvable;
    public string ServerItem { get; }
    public string Message { get; }
    public bool Resolvable { get; }
    internal CheckinConflict(string serverItem, string message, bool resolvable);
    public string get_ServerItem();
    public string get_Message();
    public bool get_Resolvable();
}
[FlagsAttribute]
public enum Microsoft.TeamFoundation.VersionControl.Client.CheckinEvaluationOptions : Enum {
    public int value__;
    public static CheckinEvaluationOptions Policies;
    public static CheckinEvaluationOptions Conflicts;
    public static CheckinEvaluationOptions Notes;
    public static CheckinEvaluationOptions AddMissingFieldValues;
    public static CheckinEvaluationOptions All;
}
public class Microsoft.TeamFoundation.VersionControl.Client.CheckinEvaluationResult : object {
    private CheckinConflict[] m_conflicts;
    private CheckinNoteFailure[] m_noteFailures;
    private PolicyFailure[] m_policyFailures;
    private Exception m_policyEvaluationException;
    public CheckinConflict[] Conflicts { get; }
    public CheckinNoteFailure[] NoteFailures { get; }
    public PolicyFailure[] PolicyFailures { get; }
    public Exception PolicyEvaluationException { get; }
    internal CheckinEvaluationResult(CheckinConflict[] conflicts, CheckinNoteFailure[] noteFailures, PolicyFailure[] policyFailures, Exception policyEvaluationException);
    public CheckinConflict[] get_Conflicts();
    public CheckinNoteFailure[] get_NoteFailures();
    public PolicyFailure[] get_PolicyFailures();
    public Exception get_PolicyEvaluationException();
}
public class Microsoft.TeamFoundation.VersionControl.Client.CheckinException : VersionControlException {
    [CompilerGeneratedAttribute]
private bool <AllResolvableConflictsWereAutoResolved>k__BackingField;
    private bool m_isResolvable;
    private CheckinConflict[] m_conflicts;
    public bool IsResolvable { get; }
    public bool AllResolvableConflictsWereAutoResolved { get; private set; }
    public CheckinConflict[] Conflicts { get; }
    public CheckinException(CheckinConflict[] conflicts, bool isResolvable, string message);
    public CheckinException(CheckinConflict[] conflicts, bool isResolvable, bool allConflictsResolved, string message);
    public CheckinException(string message);
    public CheckinException(Exception innerException);
    public CheckinException(string message, Exception innerException);
    protected CheckinException(SerializationInfo info, StreamingContext context);
    public bool get_IsResolvable();
    [CompilerGeneratedAttribute]
public bool get_AllResolvableConflictsWereAutoResolved();
    [CompilerGeneratedAttribute]
private void set_AllResolvableConflictsWereAutoResolved(bool value);
    public CheckinConflict[] get_Conflicts();
}
internal class Microsoft.TeamFoundation.VersionControl.Client.CheckinItem : object {
    private int m_itemId;
    private string m_serverItem;
    public int ItemId { get; }
    public string ServerItem { get; }
    internal CheckinItem(string serverItem, int itemId);
    internal static Dictionary`2<string, CheckinItem> FromPendingChanges(PendingChange[] pendingChanges);
    internal static Dictionary`2<string, CheckinItem> FromServerPaths(ICollection`1<string> serverPaths);
    internal static Dictionary`2<string, CheckinItem> FromCheckinItems(Dictionary`2<string, CheckinItem> sourceCheckinItems);
    public int get_ItemId();
    public string get_ServerItem();
}
public class Microsoft.TeamFoundation.VersionControl.Client.CheckinNote : object {
    internal static string m_xmlCheckinNotes;
    internal static string m_xmlNote;
    internal static string m_xmlNoteName;
    internal CheckinNoteFieldValue[] m_values;
    public CheckinNoteFieldValue[] Values { get; }
    public CheckinNote(CheckinNoteFieldValue[] values);
    public void MergeWithFieldDefinitions(CheckinNoteFieldDefinition[] fieldDefinitions);
    public CheckinNoteFailure[] Evaluate(CheckinNoteFieldDefinition[] fieldDefinitions);
    public static CheckinNoteFailure[] Evaluate(CheckinNote note, CheckinNoteFieldDefinition[] fieldDefinitions);
    internal static CheckinNote LoadFromXml(XmlNode checkinNoteNode);
    internal void SaveAsXml(XmlNode parent);
    [EditorBrowsableAttribute("1")]
public static string CanonicalizeName(string name);
    public CheckinNoteFieldValue[] get_Values();
    [EditorBrowsableAttribute("1")]
public static CheckinNote FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, CheckinNote obj);
}
public class Microsoft.TeamFoundation.VersionControl.Client.CheckinNoteFailure : object {
    private CheckinNoteFieldDefinition m_definition;
    private string m_message;
    public CheckinNoteFieldDefinition Definition { get; }
    public string Message { get; }
    public CheckinNoteFailure(CheckinNoteFieldDefinition definition, string message);
    public CheckinNoteFieldDefinition get_Definition();
    public string get_Message();
}
public class Microsoft.TeamFoundation.VersionControl.Client.CheckinNoteFieldDefinition : object {
    private static FieldDefinitionComparer m_nameComparer;
    private static FieldDefinitionComparer m_displayOrderComparer;
    private int m_displayOrder;
    private string m_name;
    private bool m_required;
    private string m_serverItem;
    public static IComparer NameComparer { get; }
    public static IComparer DisplayOrderComparer { get; }
    public int DisplayOrder { get; public set; }
    public string Name { get; public set; }
    public bool Required { get; public set; }
    public string ServerItem { get; public set; }
    public CheckinNoteFieldDefinition(string name, bool required, int displayOrder);
    internal static CheckinNoteFieldDefinition[] Consolidate(IEnumerable`1<CheckinNoteFieldDefinition> definitions);
    public static IComparer get_NameComparer();
    public static IComparer get_DisplayOrderComparer();
    public int get_DisplayOrder();
    public void set_DisplayOrder(int value);
    public string get_Name();
    public void set_Name(string value);
    public bool get_Required();
    public void set_Required(bool value);
    public string get_ServerItem();
    public void set_ServerItem(string value);
    [EditorBrowsableAttribute("1")]
public static CheckinNoteFieldDefinition FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, CheckinNoteFieldDefinition obj);
}
public class Microsoft.TeamFoundation.VersionControl.Client.CheckinNoteFieldValue : object {
    private string m_name;
    private string m_value;
    public string Name { get; public set; }
    public string Value { get; public set; }
    public CheckinNoteFieldValue(string name, string value);
    public string get_Name();
    public void set_Name(string value);
    public string get_Value();
    public void set_Value(string value);
    [EditorBrowsableAttribute("1")]
public static CheckinNoteFieldValue FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, CheckinNoteFieldValue obj);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.CheckinNotificationInfo : object {
    internal CheckinNotificationWorkItemInfo[] m_workItemInfo;
    public CheckinNotificationWorkItemInfo[] WorkItemInfo { get; public set; }
    public CheckinNotificationWorkItemInfo[] get_WorkItemInfo();
    public void set_WorkItemInfo(CheckinNotificationWorkItemInfo[] value);
    internal static CheckinNotificationInfo FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    internal void ToXml(XmlWriter writer, string element);
    internal static void ToXml(XmlWriter writer, string element, CheckinNotificationInfo obj);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.CheckinNotificationWorkItemInfo : object {
    private CheckinWorkItemAction m_checkinAction;
    private int m_id;
    public CheckinWorkItemAction CheckinAction { get; public set; }
    public int Id { get; public set; }
    public CheckinWorkItemAction get_CheckinAction();
    public void set_CheckinAction(CheckinWorkItemAction value);
    public int get_Id();
    public void set_Id(int value);
    internal static CheckinNotificationWorkItemInfo FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    internal void ToXml(XmlWriter writer, string element);
    internal static void ToXml(XmlWriter writer, string element, CheckinNotificationWorkItemInfo obj);
}
[FlagsAttribute]
public enum Microsoft.TeamFoundation.VersionControl.Client.CheckinOptions : Enum {
    public int value__;
    public static CheckinOptions None;
    public static CheckinOptions SuppressEvent;
    public static CheckinOptions ValidateCheckinOwner;
}
public abstract class Microsoft.TeamFoundation.VersionControl.Client.CheckInParameters : object {
    [CompilerGeneratedAttribute]
private string <Author>k__BackingField;
    private CheckInOptions2 m_checkInOptions;
    public string Author { get; public set; }
    public bool ValidateAuthor { get; public set; }
    public bool SuppressEvent { get; public set; }
    public bool OverrideGatedCheckIn { get; public set; }
    public bool QueueBuildForGatedCheckIn { get; public set; }
    public bool AllowUnchangedContent { get; public set; }
    public bool NoAutoResolve { get; public set; }
    internal CheckInOptions2 Options { get; internal set; }
    protected CheckInParameters(CheckInOptions2 options);
    [CompilerGeneratedAttribute]
public string get_Author();
    [CompilerGeneratedAttribute]
public void set_Author(string value);
    public bool get_ValidateAuthor();
    public void set_ValidateAuthor(bool value);
    public bool get_SuppressEvent();
    public void set_SuppressEvent(bool value);
    public bool get_OverrideGatedCheckIn();
    public void set_OverrideGatedCheckIn(bool value);
    public bool get_QueueBuildForGatedCheckIn();
    public void set_QueueBuildForGatedCheckIn(bool value);
    public bool get_AllowUnchangedContent();
    public void set_AllowUnchangedContent(bool value);
    public bool get_NoAutoResolve();
    public void set_NoAutoResolve(bool value);
    internal CheckInOptions2 get_Options();
    internal void set_Options(CheckInOptions2 value);
    internal abstract virtual void Validate();
}
internal class Microsoft.TeamFoundation.VersionControl.Client.CheckinPolicyDeserializationBinder : SerializationBinder {
    private string m_policyTypeName;
    private string m_policyAssemblyName;
    private Assembly m_policyRedirectedAssembly;
    private ResolveEventHandler m_resolveDelegate;
    private static object s_lock;
    private static PolicyType[] s_installedPolicyTypes;
    public CheckinPolicyDeserializationBinder(string policyTypeName, string policyAssemblyName);
    private static CheckinPolicyDeserializationBinder();
    public virtual Type BindToType(string assemblyName, string typeName);
    private Assembly Resolve(object sender, ResolveEventArgs e);
    private static void EnsureInstalledPolicyTypesLoaded();
    private bool IsSimilarAssembly(string assembly1, string assembly2);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.CheckinResult : object {
    private int m_changesetId;
    private int m_checkInState;
    private int m_checkInTicket;
    private DateTime m_creationDate;
    internal GetOperation[] m_localVersionUpdates;
    internal String[] m_undoneServerItems;
    public int ChangesetId { get; public set; }
    public int CheckInState { get; public set; }
    public int CheckInTicket { get; public set; }
    public DateTime CreationDate { get; public set; }
    public GetOperation[] LocalVersionUpdates { get; public set; }
    public String[] UndoneServerItems { get; public set; }
    public int get_ChangesetId();
    public void set_ChangesetId(int value);
    public int get_CheckInState();
    public void set_CheckInState(int value);
    public int get_CheckInTicket();
    public void set_CheckInTicket(int value);
    public DateTime get_CreationDate();
    public void set_CreationDate(DateTime value);
    public GetOperation[] get_LocalVersionUpdates();
    public void set_LocalVersionUpdates(GetOperation[] value);
    public String[] get_UndoneServerItems();
    public void set_UndoneServerItems(String[] value);
    internal static CheckinResult FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    internal void ToXml(XmlWriter writer, string element);
    internal static void ToXml(XmlWriter writer, string element, CheckinResult obj);
}
public enum Microsoft.TeamFoundation.VersionControl.Client.CheckinWorkItemAction : Enum {
    public int value__;
    public static CheckinWorkItemAction Associate;
    public static CheckinWorkItemAction None;
    public static CheckinWorkItemAction Resolve;
}
public class Microsoft.TeamFoundation.VersionControl.Client.CheckoutLockRequiredException : VersionControlException {
    public CheckoutLockRequiredException(string message);
    public CheckoutLockRequiredException(string message, Exception ex);
    protected CheckoutLockRequiredException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.CheckoutLocksDisabledException : VersionControlException {
    public CheckoutLocksDisabledException(string message);
    public CheckoutLocksDisabledException(string message, Exception ex);
    protected CheckoutLocksDisabledException(SerializationInfo info, StreamingContext context);
}
[EditorBrowsableAttribute("1")]
internal class Microsoft.TeamFoundation.VersionControl.Client.Client : object {
    [CompilerGeneratedAttribute]
private SetWorkspaceLocationProgressEventHandler SetWorkspaceLocationProgress;
    [CompilerGeneratedAttribute]
private ProcessingChangeEventHandler BeforeCheckinPendingChange;
    [CompilerGeneratedAttribute]
private CommitCheckinEventHandler CommitCheckin;
    [CompilerGeneratedAttribute]
private ChangesetReconciledEventHandler ChangesetReconciled;
    [CompilerGeneratedAttribute]
private FolderContentChangedEventHandler FolderContentChanged;
    [CompilerGeneratedAttribute]
private ProcessingChangeEventHandler BeforeShelvePendingChange;
    [CompilerGeneratedAttribute]
private CommitShelvesetEventHandler CommitShelveset;
    [CompilerGeneratedAttribute]
private DeletedShelvesetEventHandler DeletedShelveset;
    [CompilerGeneratedAttribute]
private UnshelveShelvesetEventHandler UnshelveShelveset;
    [CompilerGeneratedAttribute]
private MergeEventHandler Merging;
    [CompilerGeneratedAttribute]
private PendingChangeEventHandler NewPendingChange;
    [CompilerGeneratedAttribute]
private PendingChangeEventHandler UndonePendingChange;
    [CompilerGeneratedAttribute]
private ResolvedConflictEventHandler ResolvedConflict;
    [CompilerGeneratedAttribute]
private ConflictEventHandler Conflict;
    [CompilerGeneratedAttribute]
private ConflictEventHandler UnshelveConflict;
    [CompilerGeneratedAttribute]
private ExceptionEventHandler NonFatalError;
    [CompilerGeneratedAttribute]
private WorkspaceEventHandler CreatedWorkspace;
    [CompilerGeneratedAttribute]
private WorkspaceEventHandler UpdatedWorkspace;
    [CompilerGeneratedAttribute]
private WorkspaceEventHandler DeletedWorkspace;
    [CompilerGeneratedAttribute]
private WorkspaceEventHandler GetCompleted;
    [CompilerGeneratedAttribute]
private WorkspaceEventHandler PendingChangesChanged;
    [CompilerGeneratedAttribute]
private WorkspaceEventHandler PendingChangeCandidatesChanged;
    [CompilerGeneratedAttribute]
private WorkspaceCancelEventHandler BeforeDeleteWorkspace;
    [CompilerGeneratedAttribute]
private WorkItemUpdatedEventHandler WorkItemUpdated;
    [CompilerGeneratedAttribute]
private BeforeWorkItemsUpdateEventHandler BeforeWorkItemsUpdate;
    [CompilerGeneratedAttribute]
private AfterWorkItemsUpdatedEventHandler AfterWorkItemsUpdated;
    private VersionControlServer m_sourceControl;
    private RuntimeWorkspaceCache m_runtimeWorkspaceCache;
    internal static TraceSwitch m_clientTracing;
    private bool m_isCanceled;
    private static int s_resolveBatchSize;
    private static int s_processGetOperationsUnitOfWork;
    private static int c_defaultProcessGetOperationsUnitOfWork;
    private static int s_lvSizeAlertLevel;
    private static int c_defaultLvSizeAlertLevel;
    [CompilerGeneratedAttribute]
private GettingEventHandler Getting;
    public bool Canceled { get; public set; }
    public static TraceSwitch ClientTracing { get; }
    internal TfsTeamProjectCollection Tfs { get; }
    internal RuntimeWorkspaceCache RuntimeWorkspaceCache { get; }
    internal WebServiceLayer WebServiceLayer { get; }
    internal IdentitySearchFactor IMSUserNameSearchFactor { get; }
    private static Client();
    internal Client(VersionControlServer sourceControl);
    [CompilerGeneratedAttribute]
internal void add_SetWorkspaceLocationProgress(SetWorkspaceLocationProgressEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_SetWorkspaceLocationProgress(SetWorkspaceLocationProgressEventHandler value);
    internal void OnSetWorkspaceLocationProgress(SetWorkspaceLocationProgressEventArgs e);
    [CompilerGeneratedAttribute]
internal void add_BeforeCheckinPendingChange(ProcessingChangeEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_BeforeCheckinPendingChange(ProcessingChangeEventHandler value);
    internal void OnBeforeCheckinPendingChange(ProcessingChangeEventArgs e);
    [CompilerGeneratedAttribute]
internal void add_CommitCheckin(CommitCheckinEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_CommitCheckin(CommitCheckinEventHandler value);
    internal void OnCommitCheckin(CommitCheckinEventArgs e);
    [CompilerGeneratedAttribute]
internal void add_ChangesetReconciled(ChangesetReconciledEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_ChangesetReconciled(ChangesetReconciledEventHandler value);
    internal void OnChangesetReconciled(ChangesetReconciledEventArgs e);
    [CompilerGeneratedAttribute]
internal void add_FolderContentChanged(FolderContentChangedEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_FolderContentChanged(FolderContentChangedEventHandler value);
    internal void OnFolderContentChanged(FolderContentChangedEventArgs e);
    [CompilerGeneratedAttribute]
internal void add_BeforeShelvePendingChange(ProcessingChangeEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_BeforeShelvePendingChange(ProcessingChangeEventHandler value);
    internal void OnBeforeShelvePendingChange(ProcessingChangeEventArgs e);
    [CompilerGeneratedAttribute]
internal void add_CommitShelveset(CommitShelvesetEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_CommitShelveset(CommitShelvesetEventHandler value);
    internal void OnCommitShelveset(CommitShelvesetEventArgs e);
    [CompilerGeneratedAttribute]
internal void add_DeletedShelveset(DeletedShelvesetEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_DeletedShelveset(DeletedShelvesetEventHandler value);
    internal void OnDeleteShelveset(DeletedShelvesetEventArgs e);
    [CompilerGeneratedAttribute]
internal void add_UnshelveShelveset(UnshelveShelvesetEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_UnshelveShelveset(UnshelveShelvesetEventHandler value);
    private void OnUnshelveShelveset(UnshelveShelvesetEventArgs e);
    [CompilerGeneratedAttribute]
internal void add_Merging(MergeEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_Merging(MergeEventHandler value);
    private void OnMerging(MergeEventArgs e);
    [CompilerGeneratedAttribute]
internal void add_NewPendingChange(PendingChangeEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_NewPendingChange(PendingChangeEventHandler value);
    internal void OnPendingChange(PendingChangeEventArgs e);
    [CompilerGeneratedAttribute]
internal void add_UndonePendingChange(PendingChangeEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_UndonePendingChange(PendingChangeEventHandler value);
    private void OnUndonePendingChange(PendingChangeEventArgs e);
    [CompilerGeneratedAttribute]
internal void add_ResolvedConflict(ResolvedConflictEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_ResolvedConflict(ResolvedConflictEventHandler value);
    internal void OnResolvedConflict(ResolvedConflictEventArgs e);
    [CompilerGeneratedAttribute]
internal void add_Conflict(ConflictEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_Conflict(ConflictEventHandler value);
    internal void OnConflict(ConflictEventArgs e);
    [CompilerGeneratedAttribute]
internal void add_UnshelveConflict(ConflictEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_UnshelveConflict(ConflictEventHandler value);
    internal void OnUnshelveConflict(ConflictEventArgs e);
    [CompilerGeneratedAttribute]
internal void add_NonFatalError(ExceptionEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_NonFatalError(ExceptionEventHandler value);
    internal void OnNonFatalError(ExceptionEventArgs e);
    internal void OnNonFatalError(Exception exception, Workspace workspace, int operationId);
    internal void OnNonFatalError(string message, Workspace workspace, int operationId);
    [CompilerGeneratedAttribute]
internal void add_CreatedWorkspace(WorkspaceEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_CreatedWorkspace(WorkspaceEventHandler value);
    private void OnWorkspaceCreated(WorkspaceEventArgs e);
    [CompilerGeneratedAttribute]
internal void add_UpdatedWorkspace(WorkspaceEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_UpdatedWorkspace(WorkspaceEventHandler value);
    private void OnWorkspaceUpdated(WorkspaceEventArgs e);
    [CompilerGeneratedAttribute]
internal void add_DeletedWorkspace(WorkspaceEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_DeletedWorkspace(WorkspaceEventHandler value);
    private void OnWorkspaceDeleted(WorkspaceEventArgs e);
    [CompilerGeneratedAttribute]
internal void add_GetCompleted(WorkspaceEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_GetCompleted(WorkspaceEventHandler value);
    internal void OnGetCompleted(WorkspaceEventArgs e);
    [CompilerGeneratedAttribute]
internal void add_PendingChangesChanged(WorkspaceEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_PendingChangesChanged(WorkspaceEventHandler value);
    internal void OnPendingChangesChanged(WorkspaceEventArgs e);
    [CompilerGeneratedAttribute]
internal void add_PendingChangeCandidatesChanged(WorkspaceEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_PendingChangeCandidatesChanged(WorkspaceEventHandler value);
    internal void OnPendingChangeCandidatesChanged(WorkspaceEventArgs e);
    [CompilerGeneratedAttribute]
internal void add_BeforeDeleteWorkspace(WorkspaceCancelEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_BeforeDeleteWorkspace(WorkspaceCancelEventHandler value);
    private bool OnBeforeDeleteWorkspace(Workspace workspace);
    [CompilerGeneratedAttribute]
internal void add_WorkItemUpdated(WorkItemUpdatedEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_WorkItemUpdated(WorkItemUpdatedEventHandler value);
    internal void OnWorkItemUpdated(WorkItemUpdatedEventArgs e);
    [CompilerGeneratedAttribute]
internal void add_BeforeWorkItemsUpdate(BeforeWorkItemsUpdateEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_BeforeWorkItemsUpdate(BeforeWorkItemsUpdateEventHandler value);
    internal void OnBeforeWorkItemsUpdate(WorkItemsUpdateEventArgs e);
    [CompilerGeneratedAttribute]
internal void add_AfterWorkItemsUpdated(AfterWorkItemsUpdatedEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_AfterWorkItemsUpdated(AfterWorkItemsUpdatedEventHandler value);
    internal void OnAfterWorkItemsUpdated(WorkItemsUpdateEventArgs e);
    internal int PendChanges(Workspace workspace, ChangeRequest[] changeRequests, bool updateDisk, PendChangesOptions options, String[] itemAttributeFilters, String[] itemPropertyFilters, int operationId);
    internal void ResolveConflicts(Workspace workspace, IEnumerable`1<Conflict> conflicts, String[] itemAttributeFilters, String[] itemPropertyFilters, ResolveErrorOptions errorOptions, Conflict[]& resolvedConflicts, int operationId);
    internal void ResolveLocalConflicts(Workspace workspace, IEnumerable`1<Conflict> conflicts, int operationId, ResolveErrorOptions errorOptions);
    public List`1<Conflict> AutoResolveValidConflicts(Workspace workspace, IEnumerable`1<Conflict> conflicts, AutoResolveOptions resolveOptions);
    internal GetStatus Merge(Workspace workspace, ItemSpec sourceSpec, string target, VersionSpec versionFrom, VersionSpec versionTo, LockLevel lockLevel, MergeOptionsEx mergeOptions, String[] itemAttributeFilters, String[] itemPropertyFilters, int operationId);
    internal GetStatus Rollback(Workspace workspace, ItemSpec[] itemSpecs, VersionSpec itemSpecVersion, VersionSpec versionFrom, VersionSpec versionTo, LockLevel lockLevel, RollbackOptions options, String[] itemAttributeFilters, String[] itemPropertyFilters, int operationId);
    internal Shelveset Unshelve(string shelvesetName, string shelvesetOwner, Workspace workspace, ItemSpec[] items, String[] itemAttributeFilters, String[] itemPropertyFilters, String[] shelvesetPropertyNameFilters, bool merge, bool noAutoResolve, PendingChange[]& changes, Conflict[]& conflicts, int operationId);
    internal int Undo(Workspace workspace, ItemSpec[] itemSpecs, bool updateDisk, bool deleteAdds, String[] itemAttributeFilters, String[] itemPropertyFilters, int operationId);
    internal Stream DownloadFile(string downloadUrl);
    internal void DownloadFile(string downloadUrl, string localFileName);
    public BranchHistoryTreeItem[][] GetBranchHistory(string workspaceName, string workspaceOwner, ItemSpec[] itemSpecs, VersionSpec version);
    public ChangesetMergeDetails GetMergesWithDetails(string workspaceName, string workspaceOwner, string source, VersionSpec sourceVersion, int sourceDeletionId, string target, VersionSpec targetVersion, int targetDeletionId, VersionSpec versionFrom, VersionSpec versionTo, RecursionType recursion);
    public ChangesetMergeDetails GetMergesWithDetails(string workspaceName, string workspaceOwner, string source, VersionSpec sourceVersion, int sourceDeletionId, string target, VersionSpec targetVersion, int targetDeletionId, VersionSpec versionFrom, VersionSpec versionTo, RecursionType recursion, bool showAll);
    public ChangesetMerge[] GetMerges(string workspaceName, string workspaceOwner, ItemSpec sourceItemSpec, VersionSpec sourceVersion, ItemSpec targetItemSpec, VersionSpec targetVersion, VersionSpec versionFrom, VersionSpec versionTo);
    public ChangesetMerge[] GetMerges(string workspaceName, string workspaceOwner, ItemSpec sourceItemSpec, VersionSpec sourceVersion, ItemSpec targetItemSpec, VersionSpec targetVersion, VersionSpec versionFrom, VersionSpec versionTo, bool showAll);
    public MergeCandidate[] GetMergeCandidates(string workspaceName, string workspaceOwner, ItemSpec source, string target, MergeOptionsEx options);
    private Workspace QueryWorkspace(string workspaceName, string workspaceOwner);
    internal Workspace CreateWorkspace(CreateWorkspaceParameters cwp);
    internal void UpdateWorkspace(Workspace workspace, UpdateWorkspaceParameters uwp);
    internal void SetPermissionProfile(Workspace workspace, WorkspacePermissionProfile permissionProfile);
    internal void SetWorkspaceLocation(Workspace workspace, WorkspaceLocation newLocation);
    internal bool DeleteWorkspace(Workspace workspace);
    internal void SetWorkingFolder(Workspace workspace, WorkingFolder workingFolder);
    internal void DeleteWorkingFolder(Workspace workspace, WorkingFolder workingFolder);
    private void InternalSetWorkingFolder(Workspace workspace, WorkingFolder workingFolder, bool isDelete);
    private static int RemovePartialMatches(List`1<WorkingFolder> folders, WorkingFolder workingFolder, bool isDelete);
    internal Workspace GetLocalWorkspace(string localPath, bool throwIfNotFound);
    internal Workspace GetLocalWorkspace(string workspaceName, string workspaceOwner);
    public Workspace GetRepositoryWorkspace(string workspaceName, string workspaceOwner);
    public Workspace[] GetRepositoryWorkspaces(string workspaceName, string workspaceOwner, string computer);
    public Workspace[] GetRepositoryWorkspaces(string workspaceName, string workspaceOwner, string computer, WorkspacePermissions permissionsFilter);
    internal void ReportCheckInConflictsFailuresAndThrow(Workspace workspace, CheckinResult checkinResult, Failure[] conflicts, Failure[] failures, bool noAutoResolve, int operationId);
    internal CheckinConflict[] ConvertToCheckinConflicts(Failure[] failures, Boolean& isAnyResolvable);
    internal Failure[] FilterAndReportFailures(Failure[] failures, Predicate`1<Failure> failureFilter, Workspace workspace, int operationId);
    internal void ReportFailures(Failure[] failures, Workspace workspace);
    internal void ReportFailures(Failure[] failures, Workspace workspace, int operationId);
    internal void HandleItemValidationError(string item, string parameterName, ItemValidationError error);
    internal string ResolveUserDisplayName(string user);
    internal string ResolveUserUniqueName(string user);
    internal WorkspaceInfo RemoveCachedWorkspace(string workspaceName, string workspaceOwner);
    private void WorkspaceUpdateOnChange(object sender, PendingChangeEventArgs e);
    private void WorkspaceUpdateOnResolve(object sender, ResolvedConflictEventArgs e);
    internal void ThrowIfCanceled();
    internal void DeliverCrossProcessNotification(Notification notification, object data);
    internal void WorkstationNonFatalError(object sender, WorkstationExceptionEventArgs e);
    internal void CacheFileReloaded(object sender, EventArgs e);
    public bool get_Canceled();
    public void set_Canceled(bool value);
    public static TraceSwitch get_ClientTracing();
    internal TfsTeamProjectCollection get_Tfs();
    internal RuntimeWorkspaceCache get_RuntimeWorkspaceCache();
    internal WebServiceLayer get_WebServiceLayer();
    internal IdentitySearchFactor get_IMSUserNameSearchFactor();
    public GetStatus Get(Workspace workspace, String[] items, VersionSpec version, RecursionType recursionType, GetOptions options, int operationId);
    internal GetStatus Get(Workspace workspace, GetRequest[] requests, GetOptions options, int operationId);
    internal GetStatus Get(Workspace workspace, GetRequest[] requests, GetOptions options, GetFilterCallback filterCallback, object userData, String[] itemAttributeFilters, String[] itemPropertyFilters, bool alwaysQueryConflicts, Conflict[]& conflicts, int operationId);
    private String[] CalculateConflictScope(GetRequest[] getRequests, String[] writableConflictPaths, Boolean& recursive);
    private void FireGettingEvent(AsyncGetOperation asyncOp, OperationStatus status, GetOperation getOp, ChangeType targetChangeType);
    private void RecordEvent(AsyncGetOperation asyncOp, OperationStatus status, GetOperation getOp);
    private void RecordEvent(AsyncGetOperation asyncOp, OperationStatus status, GetOperation getOp, GetOperation targetOp);
    private GetStatus ProcessGetOperations(Workspace workspace, ProcessType type, GetOperation[] operations, GetOptions options, ChangePendedFlags flags, int operationId);
    private GetStatus ProcessGetOperations(Workspace workspace, ProcessType type, RequestType requestType, GetOperation[][] results, GetOptions options, GetFilterCallback filterCallback, object userData, bool deleteUndoneAdds, bool onlineOperation, ChangePendedFlags flags, int operationId);
    private UpdateLocalVersionQueueOptions CalculateUpdateLocalVersionOptions(Workspace workspace, ProcessType type, RequestType requestType, bool onlineOperation);
    private void FilterOperations(Workspace workspace, GetOperation[] actions, GetOptions options, GetFilterCallback filterCallback, object userData);
    private void ProcessOperations(AsyncGetOperation asyncOp, GetOperation[] actions);
    private void ProcessOperationsInternal(AsyncGetOperation asyncOp, GetOperation[] actions);
    private void PrepareGetOperations(AsyncGetOperation asyncOp, GetOperation[][] results, GetOperation[]& getOps);
    private void FinishDirectoryDeletionsAndMoves(AsyncGetOperation asyncOp);
    private void ClearBaselineFoldersBeneathPath(Workspace workspace, string sourceLocalItem);
    private static bool ShouldDeleteAsUndoAdd(AsyncGetOperation asyncOp, GetOperation getOp);
    [ConditionalAttribute("DEBUG")]
private void DumpGetOperations(GetOperation[] actions);
    [CompilerGeneratedAttribute]
public void add_Getting(GettingEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Getting(GettingEventHandler value);
    protected internal void OnGetting(GettingEventArgs e);
    private bool IsWritableFileConflict(AsyncGetOperation asyncOp, GetOperation action, WIN32_FILE_ATTRIBUTE_DATA newLocalAttrs);
    private static bool LocalContentIsRedundant(string localItemPath, Byte[] serverHashValue);
    internal void ProcessOperation(GetOperation action, AsyncGetOperation asyncOp);
    private void AsyncGetFile(GetOperation action, bool existingLocalExists, FileAttributes existingLocalAttrs, bool newLocalExists, FileAttributes newLocalAttrs, AsyncGetOperation asyncOp);
    internal void DeleteSource(GetOperation action, FileAttributes existingLocalAttrs);
    private bool LastPathPartDiffersInCase(string pathToCheck);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.ClientLocalVersionUpdate : object {
    private SafeFileHandle m_fileHandle;
    private string m_sourceServerItem;
    private int m_itemId;
    private string m_targetLocalItem;
    private int m_versionLocal;
    private long m_versionLocalDate;
    private int m_encoding;
    private Byte[] m_baselineHashValue;
    private long m_baselineFileLength;
    private Byte[] m_baselineFileGuid;
    private bool m_keepLocalVersionEntryOnDelete;
    private long m_lastModifiedDate;
    private string m_pendingChangeTargetServerItem;
    private string m_downloadUrl;
    private QueryItemsFetchRequest m_queryItemsFetchRequest;
    private static bool s_enableFileLocksOnGet;
    public bool SendToServer { get; }
    public bool IsCommitted { get; }
    public string SourceServerItem { get; }
    public int ItemId { get; }
    public string TargetLocalItem { get; }
    public int VersionLocal { get; }
    public long VersionLocalDate { get; }
    public int Encoding { get; }
    public Byte[] BaselineHashValue { get; }
    public long BaselineFileLength { get; }
    public Byte[] BaselineFileGuid { get; }
    public bool KeepLocalVersionEntryOnDelete { get; }
    public string PendingChangeTargetServerItem { get; public set; }
    public QueryItemsFetchRequest QueryItemsFetchRequest { get; public set; }
    public string DownloadUrl { get; public set; }
    public long LastModifiedDate { get; public set; }
    private static ClientLocalVersionUpdate();
    public ClientLocalVersionUpdate(string sourceServerItem, int itemId, string targetLocalItem, int versionLocal);
    public ClientLocalVersionUpdate(string sourceServerItem, int itemId, string targetLocalItem, int versionLocal, int encoding, bool keepLocalVersionRowOnDelete);
    public ClientLocalVersionUpdate(string sourceServerItem, int itemId, string targetLocalItem, int versionLocal, DateTime versionLocalDate, int encoding, Byte[] baselineHashValue, long baselineFileLength, Byte[] baselineFileGuid, string pendingChangeTargetServerItem);
    public sealed virtual bool get_SendToServer();
    public sealed virtual bool get_IsCommitted();
    public sealed virtual bool IsFullyPopulated(bool requireLocalVersionDate);
    public sealed virtual void UpdateFrom(Item item);
    public sealed virtual void UpdateFrom(WorkspaceLocalItem lvExisting);
    public sealed virtual void UpdateFrom(PendingChange pendingChange);
    public sealed virtual void UpdateFromPendingAdd(LocalPendingChange pendingAdd);
    public void GenerateNewBaselineFileGuid();
    public sealed virtual string get_SourceServerItem();
    public sealed virtual int get_ItemId();
    public sealed virtual string get_TargetLocalItem();
    public sealed virtual int get_VersionLocal();
    public long get_VersionLocalDate();
    public int get_Encoding();
    public sealed virtual Byte[] get_BaselineHashValue();
    public long get_BaselineFileLength();
    public sealed virtual Byte[] get_BaselineFileGuid();
    public bool get_KeepLocalVersionEntryOnDelete();
    public sealed virtual string get_PendingChangeTargetServerItem();
    public sealed virtual void set_PendingChangeTargetServerItem(string value);
    public sealed virtual QueryItemsFetchRequest get_QueryItemsFetchRequest();
    public sealed virtual void set_QueryItemsFetchRequest(QueryItemsFetchRequest value);
    public sealed virtual string get_DownloadUrl();
    public sealed virtual void set_DownloadUrl(string value);
    public long get_LastModifiedDate();
    public void set_LastModifiedDate(long value);
    private void GetFileHandle();
    public sealed virtual void Dispose();
    public void ReleaseFileHandle();
}
public class Microsoft.TeamFoundation.VersionControl.Client.CommitCheckinEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private int <OperationId>k__BackingField;
    private PendingChange[] m_changes;
    private PendingChange[] m_undoneChanges;
    private Workspace m_workspace;
    private int m_changesetId;
    private DateTime m_creationDate;
    public Workspace Workspace { get; }
    public PendingChange[] Changes { get; }
    public PendingChange[] UndoneChanges { get; }
    public int ChangesetId { get; }
    public DateTime CreationDate { get; }
    public int OperationId { get; private set; }
    internal CommitCheckinEventArgs(int changesetId, Workspace workspace, PendingChange[] changes, PendingChange[] undoneChanges, DateTime creationDate, int operationId);
    public Workspace get_Workspace();
    public PendingChange[] get_Changes();
    public PendingChange[] get_UndoneChanges();
    public int get_ChangesetId();
    public DateTime get_CreationDate();
    [CompilerGeneratedAttribute]
public int get_OperationId();
    [CompilerGeneratedAttribute]
private void set_OperationId(int value);
}
public class Microsoft.TeamFoundation.VersionControl.Client.CommitCheckinEventHandler : MulticastDelegate {
    public CommitCheckinEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, CommitCheckinEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, CommitCheckinEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.TeamFoundation.VersionControl.Client.CommitShelvesetEventArgs : EventArgs {
    private PendingChange[] m_changes;
    private Workspace m_workspace;
    private Shelveset m_shelveset;
    public PendingChange[] Changes { get; }
    public Workspace Workspace { get; }
    public Shelveset Shelveset { get; }
    internal CommitShelvesetEventArgs(Shelveset shelveset, Workspace workspace, PendingChange[] changes);
    public PendingChange[] get_Changes();
    public Workspace get_Workspace();
    public Shelveset get_Shelveset();
}
public class Microsoft.TeamFoundation.VersionControl.Client.CommitShelvesetEventHandler : MulticastDelegate {
    public CommitShelvesetEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, CommitShelvesetEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, CommitShelvesetEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.TeamFoundation.VersionControl.Client.CommittedBranchCreatedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <SourcePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetPath>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionSpec <VersionSpec>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Owner>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Comment>k__BackingField;
    [CompilerGeneratedAttribute]
private CheckinNote <CheckinNote>k__BackingField;
    [CompilerGeneratedAttribute]
private PolicyOverrideInfo <PolicyOverride>k__BackingField;
    private ReadOnlyCollection`1<Mapping> m_mappings;
    [CompilerGeneratedAttribute]
private int <ChangesetId>k__BackingField;
    public string SourcePath { get; private set; }
    public string TargetPath { get; private set; }
    public VersionSpec VersionSpec { get; private set; }
    public string Owner { get; private set; }
    public string Comment { get; private set; }
    public CheckinNote CheckinNote { get; private set; }
    public PolicyOverrideInfo PolicyOverride { get; private set; }
    public ReadOnlyCollection`1<Mapping> Mappings { get; }
    public int ChangesetId { get; private set; }
    internal CommittedBranchCreatedEventArgs(string sourcePath, string targetPath, VersionSpec version, string owner, string comment, CheckinNote checkinNote, PolicyOverrideInfo policyOverride, Mapping[] mappings, int changesetId);
    [CompilerGeneratedAttribute]
public string get_SourcePath();
    [CompilerGeneratedAttribute]
private void set_SourcePath(string value);
    [CompilerGeneratedAttribute]
public string get_TargetPath();
    [CompilerGeneratedAttribute]
private void set_TargetPath(string value);
    [CompilerGeneratedAttribute]
public VersionSpec get_VersionSpec();
    [CompilerGeneratedAttribute]
private void set_VersionSpec(VersionSpec value);
    [CompilerGeneratedAttribute]
public string get_Owner();
    [CompilerGeneratedAttribute]
private void set_Owner(string value);
    [CompilerGeneratedAttribute]
public string get_Comment();
    [CompilerGeneratedAttribute]
private void set_Comment(string value);
    [CompilerGeneratedAttribute]
public CheckinNote get_CheckinNote();
    [CompilerGeneratedAttribute]
private void set_CheckinNote(CheckinNote value);
    [CompilerGeneratedAttribute]
public PolicyOverrideInfo get_PolicyOverride();
    [CompilerGeneratedAttribute]
private void set_PolicyOverride(PolicyOverrideInfo value);
    public ReadOnlyCollection`1<Mapping> get_Mappings();
    [CompilerGeneratedAttribute]
public int get_ChangesetId();
    [CompilerGeneratedAttribute]
private void set_ChangesetId(int value);
}
public class Microsoft.TeamFoundation.VersionControl.Client.CommittedBranchCreatedEventHandler : MulticastDelegate {
    public CommittedBranchCreatedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, CommittedBranchCreatedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, CommittedBranchCreatedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.TeamFoundation.VersionControl.Client.Conflict : object {
    [CompilerGeneratedAttribute]
private bool <AutoResolved>k__BackingField;
    private PropertiesMergeSummary m_propertiesMergeSummary;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<PropertyValue> <YourProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<PropertyValue> <TheirProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<PropertyValue> <BaseProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LocalFileLastModifiedDateUsedForThreeWayMerge>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LocalFileLastModifiedDateUsedForHashValue>k__BackingField;
    private ResolutionOptions m_resolutionOptions;
    private string m_mergedFileName;
    private MergeSummary m_contentMergeSummary;
    private VersionControlServer m_sourceControl;
    private Nullable`1<bool> m_mergeValidForFileType;
    private string m_localPath;
    private string m_serverPath;
    private string m_fileName;
    private Byte[] m_localHashValue;
    private static ConflictComparer m_comparer;
    private int m_baseChangeEx;
    private ChangeType m_baseChangeType;
    private int m_baseDeletionId;
    private string m_baseDownloadUrl;
    private int m_baseEncoding;
    internal Byte[] m_baseHashValue;
    private int m_baseItemId;
    private ItemType m_baseItemType;
    private int m_basePropertyId;
    private string m_baseServerItem;
    private int m_baseVersion;
    private int m_conflictId;
    private int m_conflictOptions;
    private bool m_isForced;
    private bool m_isNamespaceConflict;
    private bool m_isResolved;
    private bool m_isShelvesetConflict;
    private int m_pendingChangeId;
    private int m_reason;
    private Resolution m_resolution;
    private string m_sourceLocalItem;
    private string m_targetLocalItem;
    private int m_theirChangeType;
    private int m_theirDeletionId;
    private string m_theirDownloadUrl;
    private int m_theirEncoding;
    internal Byte[] m_theirHashValue;
    private int m_theirItemId;
    private ItemType m_theirItemType;
    private int m_theirLastMergedVersion;
    private int m_theirPropertyId;
    private string m_theirServerItem;
    private string m_theirShelvesetName;
    private string m_theirShelvesetOwnerName;
    private int m_theirVersion;
    private int m_theirVersionFrom;
    private ConflictType m_type;
    private int m_yourChangeEx;
    private ChangeType m_yourChangeType;
    private int m_yourDeletionId;
    private string m_yourDownloadUrl;
    private int m_yourEncoding;
    private int m_yourItemId;
    private ItemType m_yourItemType;
    private int m_yourLastMergedVersion;
    private int m_yourLocalChangeEx;
    private ChangeType m_yourLocalChangeType;
    private int m_yourPropertyId;
    private string m_yourServerItem;
    private string m_yourServerItemSource;
    private int m_yourVersion;
    [EditorBrowsableAttribute("1")]
public string TheirShelvesetDisplayName { get; }
    public bool CanMergeContent { get; }
    public bool TheirFileExists { get; }
    public OperationStatus Status { get; }
    public ResolutionOptions ResolutionOptions { get; public set; }
    public string MergedFileName { get; public set; }
    public MergeSummary ContentMergeSummary { get; public set; }
    public VersionControlServer VersionControlServer { get; internal set; }
    public bool IsBaseless { get; }
    internal static IComparer Comparer { get; }
    public ChangeType BaseChangeType { get; public set; }
    public ChangeType YourLocalChangeType { get; public set; }
    public ChangeType YourChangeType { get; public set; }
    public ChangeType TheirChangeType { get; }
    private bool IsSourceRenamed { get; }
    public bool IsRollbackConflict { get; }
    public ConflictOptions Options { get; }
    public bool RequiresExplicitAcceptMerge { get; }
    public bool IsEncodingMismatched { get; }
    public bool IsBinary { get; }
    [EditorBrowsableAttribute("1")]
public bool IsBasicMergeAllowed { get; }
    [EditorBrowsableAttribute("1")]
public bool EncodingChanged { get; }
    [EditorBrowsableAttribute("1")]
public bool IsPropertyConflict { get; }
    internal bool LocalOrTargetFileInVersionControl { get; }
    private bool MergeValidForFileType { get; }
    public string LocalPath { get; }
    public string ServerPath { get; }
    public string FileName { get; }
    public string FileExtension { get; }
    public bool AutoResolved { get; internal set; }
    [EditorBrowsableAttribute("1")]
public bool IsFromDeletedShelveset { get; }
    [EditorBrowsableAttribute("1")]
public bool IsVersionConflictAndServerItemDoesNotExist { get; }
    internal bool IsVersionGetCheckinConflict { get; }
    internal bool YourNameChanged { get; }
    internal bool TheirNameChanged { get; }
    internal bool NameChangeIsRedundant { get; }
    [EditorBrowsableAttribute("1")]
public bool NameChanged { get; }
    [EditorBrowsableAttribute("1")]
public bool HasNoLocalRenames { get; }
    [EditorBrowsableAttribute("1")]
public bool MayBeRedundant { get; }
    [EditorBrowsableAttribute("1")]
public bool IsValidForAutoMerge { get; }
    public PropertiesMergeSummary PropertiesMergeSummary { get; }
    public ReadOnlyCollection`1<PropertyValue> YourProperties { get; private set; }
    public ReadOnlyCollection`1<PropertyValue> TheirProperties { get; private set; }
    public ReadOnlyCollection`1<PropertyValue> BaseProperties { get; private set; }
    [EditorBrowsableAttribute("1")]
public long LocalFileLastModifiedDateUsedForThreeWayMerge { get; public set; }
    internal bool ContentMayChanged { get; }
    [EditorBrowsableAttribute("1")]
public Byte[] LocalHashValue { get; public set; }
    internal long LocalFileLastModifiedDate { get; }
    [EditorBrowsableAttribute("1")]
public long LocalFileLastModifiedDateUsedForHashValue { get; public set; }
    [EditorBrowsableAttribute("1")]
public bool HasNoContentChange { get; }
    [EditorBrowsableAttribute("1")]
public bool HasLocalTargetContentChangeOnly { get; }
    [EditorBrowsableAttribute("1")]
public bool HasSourceServerContentChangeOnly { get; }
    [EditorBrowsableAttribute("1")]
public bool HasConflictingContentChange { get; }
    [EditorBrowsableAttribute("1")]
public bool HasConflictingPropertyChange { get; }
    private string BriefConflictGetCollisionMessage { get; }
    public int BaseDeletionId { get; public set; }
    public int BaseEncoding { get; public set; }
    public Byte[] BaseHashValue { get; public set; }
    public int BaseItemId { get; public set; }
    public ItemType BaseItemType { get; public set; }
    public int BasePropertyId { get; public set; }
    public string BaseServerItem { get; public set; }
    public int BaseVersion { get; public set; }
    public int ConflictId { get; public set; }
    public bool IsForced { get; public set; }
    public bool IsNamespaceConflict { get; public set; }
    public bool IsResolved { get; public set; }
    public bool IsShelvesetConflict { get; public set; }
    public int PendingChangeId { get; public set; }
    public int Reason { get; public set; }
    public Resolution Resolution { get; public set; }
    public string SourceLocalItem { get; public set; }
    public string TargetLocalItem { get; public set; }
    public int TheirDeletionId { get; public set; }
    public int TheirEncoding { get; public set; }
    public Byte[] TheirHashValue { get; public set; }
    public int TheirItemId { get; public set; }
    public ItemType TheirItemType { get; public set; }
    public int TheirLastMergedVersion { get; public set; }
    public int TheirPropertyId { get; public set; }
    public string TheirServerItem { get; public set; }
    public string TheirShelvesetName { get; public set; }
    public string TheirShelvesetOwnerName { get; public set; }
    public int TheirVersion { get; public set; }
    public int TheirVersionFrom { get; public set; }
    public ConflictType Type { get; public set; }
    public int YourDeletionId { get; public set; }
    public int YourEncoding { get; public set; }
    public int YourItemId { get; public set; }
    public ItemType YourItemType { get; public set; }
    public int YourLastMergedVersion { get; public set; }
    public int YourPropertyId { get; public set; }
    public string YourServerItem { get; public set; }
    public string YourServerItemSource { get; public set; }
    public int YourVersion { get; public set; }
    public string GetFullMessage();
    public string GetBriefMessage();
    public string GetDetailedMessage(bool asConflict);
    public string get_TheirShelvesetDisplayName();
    public void DownloadBaseFile(string localFileName);
    public void DownloadTheirFile(string localFileName);
    public void DownloadYourFile(string localFileName);
    private void CheckDownloadUrl(string downloadUrl, string resourceName);
    public bool get_CanMergeContent();
    public bool get_TheirFileExists();
    public OperationStatus get_Status();
    public ResolutionOptions get_ResolutionOptions();
    public void set_ResolutionOptions(ResolutionOptions value);
    public string get_MergedFileName();
    public void set_MergedFileName(string value);
    public MergeSummary get_ContentMergeSummary();
    public void set_ContentMergeSummary(MergeSummary value);
    public VersionControlServer get_VersionControlServer();
    internal void set_VersionControlServer(VersionControlServer value);
    public bool get_IsBaseless();
    internal static IComparer get_Comparer();
    public ChangeType get_BaseChangeType();
    public void set_BaseChangeType(ChangeType value);
    public ChangeType get_YourLocalChangeType();
    public void set_YourLocalChangeType(ChangeType value);
    public ChangeType get_YourChangeType();
    public void set_YourChangeType(ChangeType value);
    public ChangeType get_TheirChangeType();
    private bool get_IsSourceRenamed();
    public bool get_IsRollbackConflict();
    public ConflictOptions get_Options();
    public bool get_RequiresExplicitAcceptMerge();
    public bool get_IsEncodingMismatched();
    public bool get_IsBinary();
    public bool get_IsBasicMergeAllowed();
    public bool get_EncodingChanged();
    public bool get_IsPropertyConflict();
    internal bool get_LocalOrTargetFileInVersionControl();
    private bool get_MergeValidForFileType();
    public string get_LocalPath();
    public string get_ServerPath();
    public string get_FileName();
    public string get_FileExtension();
    [CompilerGeneratedAttribute]
public bool get_AutoResolved();
    [CompilerGeneratedAttribute]
internal void set_AutoResolved(bool value);
    public bool get_IsFromDeletedShelveset();
    public bool get_IsVersionConflictAndServerItemDoesNotExist();
    internal bool get_IsVersionGetCheckinConflict();
    internal bool get_YourNameChanged();
    internal bool get_TheirNameChanged();
    internal bool get_NameChangeIsRedundant();
    public bool get_NameChanged();
    public bool get_HasNoLocalRenames();
    public bool get_MayBeRedundant();
    public bool get_IsValidForAutoMerge();
    [EditorBrowsableAttribute("1")]
public bool IsAutoMergeApplicable(AutoResolveOptions resolveOptions);
    [EditorBrowsableAttribute("1")]
public bool IsRedundant(bool quick, Workspace workspace);
    public PropertiesMergeSummary MergeProperties(Workspace workspace);
    public PropertiesMergeSummary get_PropertiesMergeSummary();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<PropertyValue> get_YourProperties();
    [CompilerGeneratedAttribute]
private void set_YourProperties(ReadOnlyCollection`1<PropertyValue> value);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<PropertyValue> get_TheirProperties();
    [CompilerGeneratedAttribute]
private void set_TheirProperties(ReadOnlyCollection`1<PropertyValue> value);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<PropertyValue> get_BaseProperties();
    [CompilerGeneratedAttribute]
private void set_BaseProperties(ReadOnlyCollection`1<PropertyValue> value);
    public void DownloadProperties(Workspace workspace);
    private ReadOnlyCollection`1<PropertyValue> DownloadPropertiesHelper(string serverItem, VersionSpec version);
    [CompilerGeneratedAttribute]
public long get_LocalFileLastModifiedDateUsedForThreeWayMerge();
    [CompilerGeneratedAttribute]
public void set_LocalFileLastModifiedDateUsedForThreeWayMerge(long value);
    [EditorBrowsableAttribute("1")]
public void ResetChangeSummaryIfLocalFileModified();
    internal bool get_ContentMayChanged();
    public Byte[] get_LocalHashValue();
    public void set_LocalHashValue(Byte[] value);
    internal long get_LocalFileLastModifiedDate();
    [CompilerGeneratedAttribute]
public long get_LocalFileLastModifiedDateUsedForHashValue();
    [CompilerGeneratedAttribute]
public void set_LocalFileLastModifiedDateUsedForHashValue(long value);
    [EditorBrowsableAttribute("1")]
public void UpdateLocalHashValue();
    public bool get_HasNoContentChange();
    public bool get_HasLocalTargetContentChangeOnly();
    public bool get_HasSourceServerContentChangeOnly();
    public bool get_HasConflictingContentChange();
    public bool get_HasConflictingPropertyChange();
    [EditorBrowsableAttribute("1")]
public void CleanUpMergedResultFile();
    private string get_BriefConflictGetCollisionMessage();
    private string GetConflictGetCollisionPathFullMessage(string path);
    public int get_BaseDeletionId();
    public void set_BaseDeletionId(int value);
    public int get_BaseEncoding();
    public void set_BaseEncoding(int value);
    public Byte[] get_BaseHashValue();
    public void set_BaseHashValue(Byte[] value);
    public int get_BaseItemId();
    public void set_BaseItemId(int value);
    public ItemType get_BaseItemType();
    public void set_BaseItemType(ItemType value);
    public int get_BasePropertyId();
    public void set_BasePropertyId(int value);
    public string get_BaseServerItem();
    public void set_BaseServerItem(string value);
    public int get_BaseVersion();
    public void set_BaseVersion(int value);
    public int get_ConflictId();
    public void set_ConflictId(int value);
    public bool get_IsForced();
    public void set_IsForced(bool value);
    public bool get_IsNamespaceConflict();
    public void set_IsNamespaceConflict(bool value);
    public bool get_IsResolved();
    public void set_IsResolved(bool value);
    public bool get_IsShelvesetConflict();
    public void set_IsShelvesetConflict(bool value);
    public int get_PendingChangeId();
    public void set_PendingChangeId(int value);
    public int get_Reason();
    public void set_Reason(int value);
    public Resolution get_Resolution();
    public void set_Resolution(Resolution value);
    public string get_SourceLocalItem();
    public void set_SourceLocalItem(string value);
    public string get_TargetLocalItem();
    public void set_TargetLocalItem(string value);
    public int get_TheirDeletionId();
    public void set_TheirDeletionId(int value);
    public int get_TheirEncoding();
    public void set_TheirEncoding(int value);
    public Byte[] get_TheirHashValue();
    public void set_TheirHashValue(Byte[] value);
    public int get_TheirItemId();
    public void set_TheirItemId(int value);
    public ItemType get_TheirItemType();
    public void set_TheirItemType(ItemType value);
    public int get_TheirLastMergedVersion();
    public void set_TheirLastMergedVersion(int value);
    public int get_TheirPropertyId();
    public void set_TheirPropertyId(int value);
    public string get_TheirServerItem();
    public void set_TheirServerItem(string value);
    public string get_TheirShelvesetName();
    public void set_TheirShelvesetName(string value);
    public string get_TheirShelvesetOwnerName();
    public void set_TheirShelvesetOwnerName(string value);
    public int get_TheirVersion();
    public void set_TheirVersion(int value);
    public int get_TheirVersionFrom();
    public void set_TheirVersionFrom(int value);
    public ConflictType get_Type();
    public void set_Type(ConflictType value);
    public int get_YourDeletionId();
    public void set_YourDeletionId(int value);
    public int get_YourEncoding();
    public void set_YourEncoding(int value);
    public int get_YourItemId();
    public void set_YourItemId(int value);
    public ItemType get_YourItemType();
    public void set_YourItemType(ItemType value);
    public int get_YourLastMergedVersion();
    public void set_YourLastMergedVersion(int value);
    public int get_YourPropertyId();
    public void set_YourPropertyId(int value);
    public string get_YourServerItem();
    public void set_YourServerItem(string value);
    public string get_YourServerItemSource();
    public void set_YourServerItemSource(string value);
    public int get_YourVersion();
    public void set_YourVersion(int value);
    [EditorBrowsableAttribute("1")]
public static Conflict FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, Conflict obj);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.ConflictComparer : object {
    private sealed virtual override int System.Collections.IComparer.Compare(object x, object y);
}
public class Microsoft.TeamFoundation.VersionControl.Client.ConflictEventArgs : EventArgs {
    private string m_serverItem;
    private Workspace m_workspace;
    private string m_message;
    private bool m_isResolvable;
    public string ServerItem { get; }
    public Workspace Workspace { get; }
    public string Message { get; }
    public bool Resolvable { get; }
    internal ConflictEventArgs(string serverItem, Workspace workspace, string message, bool isResolvable);
    public string get_ServerItem();
    public Workspace get_Workspace();
    public string get_Message();
    public bool get_Resolvable();
}
public class Microsoft.TeamFoundation.VersionControl.Client.ConflictEventHandler : MulticastDelegate {
    public ConflictEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ConflictEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ConflictEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.ConflictInformation : object {
    private ConflictType m_conflictType;
    private int m_pendingChangeId;
    private int m_reason;
    private string m_sourceLocalItem;
    private string m_targetLocalItem;
    private int m_versionFrom;
    public ConflictType ConflictType { get; public set; }
    public int PendingChangeId { get; public set; }
    public int Reason { get; public set; }
    public string SourceLocalItem { get; public set; }
    public string TargetLocalItem { get; public set; }
    public int VersionFrom { get; public set; }
    public ConflictType get_ConflictType();
    public void set_ConflictType(ConflictType value);
    public int get_PendingChangeId();
    public void set_PendingChangeId(int value);
    public int get_Reason();
    public void set_Reason(int value);
    public string get_SourceLocalItem();
    public void set_SourceLocalItem(string value);
    public string get_TargetLocalItem();
    public void set_TargetLocalItem(string value);
    public int get_VersionFrom();
    public void set_VersionFrom(int value);
    internal static ConflictInformation FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    internal void ToXml(XmlWriter writer, string element);
    internal static void ToXml(XmlWriter writer, string element, ConflictInformation obj);
}
public enum Microsoft.TeamFoundation.VersionControl.Client.ConflictType : Enum {
    public int value__;
    public static ConflictType Checkin;
    public static ConflictType Get;
    public static ConflictType Local;
    public static ConflictType Merge;
    public static ConflictType None;
    public static ConflictType Unknown;
}
public class Microsoft.TeamFoundation.VersionControl.Client.ContentNotUploadedException : VersionControlException {
    public ContentNotUploadedException(string message);
    public ContentNotUploadedException(string message, Exception ex);
    protected ContentNotUploadedException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.ContentRequiredException : ServerItemException {
    public ContentRequiredException(string message);
    public ContentRequiredException(string message, Exception ex);
    protected ContentRequiredException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.CorruptBaselineException : VersionControlException {
    [CompilerGeneratedAttribute]
private string <TargetLocalItem>k__BackingField;
    public string TargetLocalItem { get; private set; }
    public CorruptBaselineException(string targetLocalItem, string additionalInformationMessage);
    public CorruptBaselineException(string targetLocalItem, Exception innerException);
    [CompilerGeneratedAttribute]
public string get_TargetLocalItem();
    [CompilerGeneratedAttribute]
private void set_TargetLocalItem(string value);
}
public class Microsoft.TeamFoundation.VersionControl.Client.CouldNotAddProxyException : VersionControlException {
    public CouldNotAddProxyException(string message);
    public CouldNotAddProxyException(string message, Exception ex);
    protected CouldNotAddProxyException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.CouldNotDeleteProxyException : VersionControlException {
    public CouldNotDeleteProxyException(string message);
    public CouldNotDeleteProxyException(string message, Exception ex);
    protected CouldNotDeleteProxyException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.CreateBranchObjectException : VersionControlException {
    public CreateBranchObjectException(string message);
    public CreateBranchObjectException(string message, Exception ex);
    protected CreateBranchObjectException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.CreateWorkspaceParameters : object {
    [CompilerGeneratedAttribute]
private string <WorkspaceName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OwnerName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OwnerDisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Comment>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Computer>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<WorkspaceLocation> <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private WorkingFolder[] <Folders>k__BackingField;
    [CompilerGeneratedAttribute]
private WorkspacePermissionProfile <PermissionProfile>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RemoveUnparentedCloaks>k__BackingField;
    [CompilerGeneratedAttribute]
private WorkspaceOptions <WorkspaceOptions>k__BackingField;
    public string WorkspaceName { get; public set; }
    public string OwnerName { get; public set; }
    public string OwnerDisplayName { get; public set; }
    public string Comment { get; public set; }
    public string Computer { get; public set; }
    public Nullable`1<WorkspaceLocation> Location { get; public set; }
    public WorkingFolder[] Folders { get; public set; }
    public WorkspacePermissionProfile PermissionProfile { get; public set; }
    public bool RemoveUnparentedCloaks { get; public set; }
    public WorkspaceOptions WorkspaceOptions { get; public set; }
    public CreateWorkspaceParameters(string workspaceName);
    [CompilerGeneratedAttribute]
public string get_WorkspaceName();
    [CompilerGeneratedAttribute]
public void set_WorkspaceName(string value);
    [CompilerGeneratedAttribute]
public string get_OwnerName();
    [CompilerGeneratedAttribute]
public void set_OwnerName(string value);
    [CompilerGeneratedAttribute]
public string get_OwnerDisplayName();
    [CompilerGeneratedAttribute]
public void set_OwnerDisplayName(string value);
    [CompilerGeneratedAttribute]
public string get_Comment();
    [CompilerGeneratedAttribute]
public void set_Comment(string value);
    [CompilerGeneratedAttribute]
public string get_Computer();
    [CompilerGeneratedAttribute]
public void set_Computer(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<WorkspaceLocation> get_Location();
    [CompilerGeneratedAttribute]
public void set_Location(Nullable`1<WorkspaceLocation> value);
    [CompilerGeneratedAttribute]
public WorkingFolder[] get_Folders();
    [CompilerGeneratedAttribute]
public void set_Folders(WorkingFolder[] value);
    [CompilerGeneratedAttribute]
public WorkspacePermissionProfile get_PermissionProfile();
    [CompilerGeneratedAttribute]
public void set_PermissionProfile(WorkspacePermissionProfile value);
    [CompilerGeneratedAttribute]
public bool get_RemoveUnparentedCloaks();
    [CompilerGeneratedAttribute]
public void set_RemoveUnparentedCloaks(bool value);
    [CompilerGeneratedAttribute]
public WorkspaceOptions get_WorkspaceOptions();
    [CompilerGeneratedAttribute]
public void set_WorkspaceOptions(WorkspaceOptions value);
    internal void Validate();
}
internal class Microsoft.TeamFoundation.VersionControl.Client.CrossProcessNotification : object {
    public static string GetNotificationParam(WorkspaceInfo workspaceInfo);
    public static string GetNotificationParam(Workspace workspace);
    public static string GetNotificationParam(string workspaceName, string workspaceOwner);
    private static int GetNotificationWorkspaceHashCode(Workspace workspace);
    private static int GetNotificationWorkspaceHashCode(string workspaceNotificationParam);
    private static int GetNotificationServerHashCode(Guid guid);
    public static void EnqueueForWorkspace(Workspace workspace, Notification notification);
    public static void EnqueueChangesetReconciled(VersionControlServer sourceControl, int changesetId);
    public static void EnqueueFolderContentChanged(VersionControlServer sourceControl);
    public static void EnqueueFolderContentChanged(VersionControlServer sourceControl, int changesetId);
    private static bool AdjustNotificationParametersForWindow(Notification notification, UInt32 windowFlags, object userData, IntPtr& wParam, IntPtr& lParam);
    public static bool MatchesNotification(WorkspaceInfo wsinfo, IntPtr serverHashCode, IntPtr workspaceHashCode);
    public static bool MatchesNotification(Workspace workspace, IntPtr serverHashCode, IntPtr workspaceHashCode);
    public static bool MatchesNotification(VersionControlServer sourceControl, IntPtr serverHashCode);
    private static bool MatchesServer(IntPtr serverHashCode, Guid toMatchServerGuid, Uri toMatchServerUri);
    private static bool MatchesServerAndWorkspace(IntPtr serverHashCode, IntPtr workspaceHashCode, Guid toMatchServerGuid, Uri toMatchServerUri, string toMatchWorkspaceString);
}
public class Microsoft.TeamFoundation.VersionControl.Client.DateVersionSpec : VersionSpec {
    private DateTime m_date;
    private string m_originalText;
    public static char Identifier;
    public DateTime Date { get; public set; }
    public string OriginalText { get; public set; }
    public DateVersionSpec(DateTime date);
    public DateVersionSpec(DateTime date, string originalText);
    private static DateVersionSpec();
    public DateTime get_Date();
    public void set_Date(DateTime value);
    public string get_OriginalText();
    public void set_OriginalText(string value);
    [EditorBrowsableAttribute("1")]
public static DateVersionSpec FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public virtual void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, DateVersionSpec obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public virtual string ComputeVersionString();
}
public class Microsoft.TeamFoundation.VersionControl.Client.DateVersionSpecBeforeBeginningOfRepositoryException : VersionControlException {
    public DateVersionSpecBeforeBeginningOfRepositoryException(string message);
    public DateVersionSpecBeforeBeginningOfRepositoryException(string message, Exception ex);
    protected DateVersionSpecBeforeBeginningOfRepositoryException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.DefaultToolExecutionResult : object {
    private int m_cookie;
    public int Id { get; }
    public string Name { get; }
    public bool HasExited { get; }
    public int ExitCode { get; }
    public string ExitMessage { get; }
    public bool PromptUserForMergeConfirmation { get; }
    public sealed virtual int get_Id();
    public sealed virtual string get_Name();
    public sealed virtual bool get_HasExited();
    public sealed virtual int get_ExitCode();
    public sealed virtual string get_ExitMessage();
    public sealed virtual bool get_PromptUserForMergeConfirmation();
    public sealed virtual void WaitForOperationEnd();
    public sealed virtual void Cancel();
}
public class Microsoft.TeamFoundation.VersionControl.Client.DeletedShelvesetEventArgs : EventArgs {
    private string m_name;
    private string m_owner;
    public string Name { get; }
    public string OwnerName { get; }
    internal DeletedShelvesetEventArgs(string name, string owner);
    public string get_Name();
    public string get_OwnerName();
}
public class Microsoft.TeamFoundation.VersionControl.Client.DeletedShelvesetEventHandler : MulticastDelegate {
    public DeletedShelvesetEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DeletedShelvesetEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DeletedShelvesetEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum Microsoft.TeamFoundation.VersionControl.Client.DeletedState : Enum {
    public int value__;
    public static DeletedState Any;
    public static DeletedState Deleted;
    public static DeletedState NonDeleted;
}
public class Microsoft.TeamFoundation.VersionControl.Client.DeltaException : VersionControlException {
    public DeltaException(string message);
    public DeltaException(string message, Exception ex);
    protected DeltaException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.DepthOneMappingsNotSupportedException : VersionControlException {
}
public class Microsoft.TeamFoundation.VersionControl.Client.DestroyedContentUnavailableException : VersionControlException {
    public DestroyedContentUnavailableException(string message);
    public DestroyedContentUnavailableException(string message, Exception ex);
    protected DestroyedContentUnavailableException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.DestroyedEventHandler : MulticastDelegate {
    public DestroyedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DestroyEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DestroyEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.TeamFoundation.VersionControl.Client.DestroyEventArgs : EventArgs {
    private Item m_item;
    private DestroyFlags m_flags;
    private VersionSpec m_stopAtSpec;
    public Item Item { get; }
    public DestroyFlags DestroyFlags { get; }
    public VersionSpec StopAtSpec { get; }
    internal DestroyEventArgs(Item destroyedItem, VersionSpec stopAt, DestroyFlags flags);
    public Item get_Item();
    public DestroyFlags get_DestroyFlags();
    public VersionSpec get_StopAtSpec();
}
public static class Microsoft.TeamFoundation.VersionControl.Client.Difference : object {
    private static int m_bufferSize;
    public static void VisualDiffFiles(VersionControlServer versionControl, string sourceFile, VersionSpec sourceVersion, string targetFile, VersionSpec targetVersion);
    public static void VisualDiffFiles(string sourceFile, string targetFile, string sourceFileTag, string targetFileTag, string sourceFileLabel, string targetFileLabel, bool isSourceReadOnly, bool isTargetReadOnly, bool deleteSourceOnExit, bool deleteTargetOnExit);
    public static void VisualDiffItems(VersionControlServer versionControl, IDiffItem source, IDiffItem target);
    public static void VisualDiffItems(VersionControlServer versionControl, IDiffItem source, IDiffItem target, bool modalExperience);
    public static void VisualDiffShelvedChange(VersionControlServer versionControl, string shelvesetName, PendingChange shelvedChange);
    public static bool IsEncodingSupported(int codePage);
    public static bool IsEncodingSupported(Encoding encoding);
    public static DiffSegment DiffFiles(string source, int sourceCodePage, string target, int targetCodePage, DiffOptions diffOpts);
    public static void DiffFiles(VersionControlServer versionControl, IDiffItem source, IDiffItem target, DiffOptions diffOpts, string fileNameForHeader, bool wait);
    public static void DiffFiles(VersionControlServer versionControl, IDiffItem source, IDiffItem target, DiffOptions diffOpts, string fileNameForHeader, bool wait, bool modalExperience);
    public static IDiffItem CreateTargetDiffItem(VersionControlServer versionControl, PendingChange change, VersionSpec targetVersion);
    public static IDiffItem CreateTargetDiffItem(VersionControlServer versionControl, int itemId, string path, VersionSpec itemVersion, int deletionId, VersionSpec targetVersion);
    public static IDiffItem CreateTargetDiffItem(VersionControlServer versionControl, string path, VersionSpec itemVersion, int deletionId, VersionSpec targetVersion);
    private static void DiffFilesOnDisk(VersionControlServer versionControl, DiffOptions diffOpts, string sourcePath, int sourceCodePage, string targetPath, int targetCodePage, string sourceLabelTag, string sourceLabelFile, string targetLabelTag, string targetLabelFile, string fileLabel, bool isSourceTemp, bool isTargetTemp, EventHandler exitedHandler, bool wait, bool modalExperience);
    private static void RunExternalDiffTool(string sourcePath, string targetPath, string sourceLabel, string targetLabel, string sourceLabelTag, string sourceLabelFile, string targetLabelTag, string targetLabelFile, bool isSourceTemp, bool isTargetTemp, string commandLineOptions, EventHandler exitedHandler, bool wait, bool modalExperience);
    [EditorBrowsableAttribute("1")]
public static string GetTempFilePath(string file, VersionSpec version);
}
public class Microsoft.TeamFoundation.VersionControl.Client.DiffItemLocalFile : object {
    private string m_fileName;
    private int m_encoding;
    private DateTime m_lastModifiedDate;
    private bool m_isTemporary;
    private bool m_noFile;
    private string m_label;
    private string m_labelFile;
    private bool Microsoft.TeamFoundation.VersionControl.Client.IDiffItem.IsTemporary { get; }
    private string Microsoft.TeamFoundation.VersionControl.Client.IDiffItem.Label { get; private set; }
    private string Microsoft.TeamFoundation.VersionControl.Client.IDiffItem.LabelTag { get; }
    private string Microsoft.TeamFoundation.VersionControl.Client.IDiffItem.LabelFile { get; private set; }
    public DiffItemLocalFile(string fileName, int encoding, DateTime lastModifiedDate, bool isTemporary);
    private sealed virtual override string Microsoft.TeamFoundation.VersionControl.Client.IDiffItem.GetFile();
    private sealed virtual override int Microsoft.TeamFoundation.VersionControl.Client.IDiffItem.GetEncoding();
    private sealed virtual override bool Microsoft.TeamFoundation.VersionControl.Client.IDiffItem.get_IsTemporary();
    private sealed virtual override string Microsoft.TeamFoundation.VersionControl.Client.IDiffItem.get_Label();
    private sealed virtual override void Microsoft.TeamFoundation.VersionControl.Client.IDiffItem.set_Label(string value);
    private sealed virtual override string Microsoft.TeamFoundation.VersionControl.Client.IDiffItem.get_LabelTag();
    private sealed virtual override string Microsoft.TeamFoundation.VersionControl.Client.IDiffItem.get_LabelFile();
    private sealed virtual override void Microsoft.TeamFoundation.VersionControl.Client.IDiffItem.set_LabelFile(string value);
}
public class Microsoft.TeamFoundation.VersionControl.Client.DiffItemLocalWorkspace : object {
    private string m_localFile;
    private int m_encoding;
    private string m_serverItem;
    private string m_label;
    private string m_labelFile;
    private Workspace m_workspace;
    public bool IsTemporary { get; }
    public string Label { get; public set; }
    public string LabelTag { get; }
    public string LabelFile { get; public set; }
    private DiffItemLocalWorkspace(Workspace workspace, string serverItem, string localTemporaryLocation, int encoding);
    public static DiffItemLocalWorkspace Create(Workspace workspace, string item);
    public sealed virtual string GetFile();
    public sealed virtual int GetEncoding();
    public sealed virtual bool get_IsTemporary();
    public sealed virtual string get_Label();
    public sealed virtual void set_Label(string value);
    public sealed virtual string get_LabelTag();
    public sealed virtual string get_LabelFile();
    public sealed virtual void set_LabelFile(string value);
}
public class Microsoft.TeamFoundation.VersionControl.Client.DiffItemPendingChangeBase : object {
    private string m_fileName;
    private int m_encoding;
    private PendingChange m_pendingChange;
    private string m_label;
    private string m_labelFile;
    private string m_labelTag;
    private bool Microsoft.TeamFoundation.VersionControl.Client.IDiffItem.IsTemporary { get; }
    private string Microsoft.TeamFoundation.VersionControl.Client.IDiffItem.Label { get; private set; }
    private string Microsoft.TeamFoundation.VersionControl.Client.IDiffItem.LabelTag { get; }
    private string Microsoft.TeamFoundation.VersionControl.Client.IDiffItem.LabelFile { get; private set; }
    public DiffItemPendingChangeBase(PendingChange pendingChange);
    private sealed virtual override string Microsoft.TeamFoundation.VersionControl.Client.IDiffItem.GetFile();
    private sealed virtual override int Microsoft.TeamFoundation.VersionControl.Client.IDiffItem.GetEncoding();
    private void ConstructLabel();
    private sealed virtual override bool Microsoft.TeamFoundation.VersionControl.Client.IDiffItem.get_IsTemporary();
    private sealed virtual override string Microsoft.TeamFoundation.VersionControl.Client.IDiffItem.get_Label();
    private sealed virtual override void Microsoft.TeamFoundation.VersionControl.Client.IDiffItem.set_Label(string value);
    private sealed virtual override string Microsoft.TeamFoundation.VersionControl.Client.IDiffItem.get_LabelTag();
    private sealed virtual override string Microsoft.TeamFoundation.VersionControl.Client.IDiffItem.get_LabelFile();
    private sealed virtual override void Microsoft.TeamFoundation.VersionControl.Client.IDiffItem.set_LabelFile(string value);
}
public class Microsoft.TeamFoundation.VersionControl.Client.DiffItemShelvedChange : object {
    private string m_shelvesetName;
    private PendingChange m_pendingChange;
    private string m_fileName;
    private string m_label;
    private string m_labelFile;
    private bool Microsoft.TeamFoundation.VersionControl.Client.IDiffItem.IsTemporary { get; }
    private string Microsoft.TeamFoundation.VersionControl.Client.IDiffItem.Label { get; private set; }
    private string Microsoft.TeamFoundation.VersionControl.Client.IDiffItem.LabelTag { get; }
    private string Microsoft.TeamFoundation.VersionControl.Client.IDiffItem.LabelFile { get; private set; }
    public DiffItemShelvedChange(string shelvesetName, PendingChange pendingChange);
    private sealed virtual override string Microsoft.TeamFoundation.VersionControl.Client.IDiffItem.GetFile();
    private sealed virtual override int Microsoft.TeamFoundation.VersionControl.Client.IDiffItem.GetEncoding();
    private sealed virtual override bool Microsoft.TeamFoundation.VersionControl.Client.IDiffItem.get_IsTemporary();
    private sealed virtual override string Microsoft.TeamFoundation.VersionControl.Client.IDiffItem.get_Label();
    private sealed virtual override void Microsoft.TeamFoundation.VersionControl.Client.IDiffItem.set_Label(string value);
    private sealed virtual override string Microsoft.TeamFoundation.VersionControl.Client.IDiffItem.get_LabelTag();
    private sealed virtual override string Microsoft.TeamFoundation.VersionControl.Client.IDiffItem.get_LabelFile();
    private sealed virtual override void Microsoft.TeamFoundation.VersionControl.Client.IDiffItem.set_LabelFile(string value);
}
public class Microsoft.TeamFoundation.VersionControl.Client.DiffItemVersionedFile : object {
    private Item m_item;
    private VersionSpec m_version;
    private string m_fileName;
    private string m_label;
    private string m_labelFile;
    private int m_itemId;
    private int m_changeset;
    private VersionControlServer m_versionControl;
    private string m_displayPath;
    private bool Microsoft.TeamFoundation.VersionControl.Client.IDiffItem.IsTemporary { get; }
    private string Microsoft.TeamFoundation.VersionControl.Client.IDiffItem.Label { get; private set; }
    private string Microsoft.TeamFoundation.VersionControl.Client.IDiffItem.LabelTag { get; }
    private string Microsoft.TeamFoundation.VersionControl.Client.IDiffItem.LabelFile { get; private set; }
    public DiffItemVersionedFile(VersionControlServer versionControl, int itemId, int changeset, string displayPath);
    public DiffItemVersionedFile(Item item, VersionSpec version);
    public DiffItemVersionedFile(VersionControlServer versionControl, string path, VersionSpec version);
    public DiffItemVersionedFile(VersionControlServer versionControl, string path, VersionSpec version, DeletedState state);
    private Item GetItem();
    private sealed virtual override string Microsoft.TeamFoundation.VersionControl.Client.IDiffItem.GetFile();
    private sealed virtual override int Microsoft.TeamFoundation.VersionControl.Client.IDiffItem.GetEncoding();
    private sealed virtual override bool Microsoft.TeamFoundation.VersionControl.Client.IDiffItem.get_IsTemporary();
    private sealed virtual override string Microsoft.TeamFoundation.VersionControl.Client.IDiffItem.get_Label();
    private sealed virtual override void Microsoft.TeamFoundation.VersionControl.Client.IDiffItem.set_Label(string value);
    private sealed virtual override string Microsoft.TeamFoundation.VersionControl.Client.IDiffItem.get_LabelTag();
    private sealed virtual override string Microsoft.TeamFoundation.VersionControl.Client.IDiffItem.get_LabelFile();
    private sealed virtual override void Microsoft.TeamFoundation.VersionControl.Client.IDiffItem.set_LabelFile(string value);
}
public class Microsoft.TeamFoundation.VersionControl.Client.DuplicateChangeException : VersionControlException {
    public DuplicateChangeException(string message);
    public DuplicateChangeException(string message, Exception ex);
    protected DuplicateChangeException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.DuplicateCheckinNoteFieldException : VersionControlException {
    public DuplicateCheckinNoteFieldException(string message);
    public DuplicateCheckinNoteFieldException(string message, Exception ex);
    protected DuplicateCheckinNoteFieldException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.DuplicateExtensionException : VersionControlException {
    public DuplicateExtensionException(string message);
    public DuplicateExtensionException(string message, Exception ex);
    protected DuplicateExtensionException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.DuplicateFileTypeException : VersionControlException {
    public DuplicateFileTypeException(string message);
    public DuplicateFileTypeException(string message, Exception ex);
    protected DuplicateFileTypeException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.DuplicateItemFoundException : VersionControlException {
    public DuplicateItemFoundException(string message);
    public DuplicateItemFoundException(string message, Exception ex);
    protected DuplicateItemFoundException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.DuplicateItemsInCheckInRequestException : ServerItemException {
    public DuplicateItemsInCheckInRequestException(string message);
    public DuplicateItemsInCheckInRequestException(string message, Exception ex);
    protected DuplicateItemsInCheckInRequestException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.DuplicateServerItemException : ServerItemException {
    public DuplicateServerItemException(string message);
    public DuplicateServerItemException(string message, Exception ex);
    protected DuplicateServerItemException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.DuplicateWorkingFolderException : VersionControlException {
    public DuplicateWorkingFolderException(string message);
    public DuplicateWorkingFolderException(string message, Exception ex);
    protected DuplicateWorkingFolderException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.EmptyCheckInException : ServerItemException {
    public EmptyCheckInException(string message);
    public EmptyCheckInException(string message, Exception ex);
    protected EmptyCheckInException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.EncodingDescription : ValueType {
    private int m_encoding;
    private string m_displayName;
    private string m_description;
    public int Encoding { get; }
    public string DisplayName { get; }
    public string Description { get; }
    public EncodingDescription(int encoding, string displayName, string description);
    public int get_Encoding();
    public string get_DisplayName();
    public string get_Description();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(EncodingDescription op1, EncodingDescription op2);
    public static bool op_Inequality(EncodingDescription op1, EncodingDescription op2);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.EnumeratedLocalItem : object {
    public ParentPathChildItem ParentPathChildItem;
    public UInt32 FileAttributes;
    public FILETIME LastWriteTime;
    public UInt32 FileSizeHigh;
    public UInt32 FileSizeLow;
    public string ServerItem;
    public string FullPath { get; }
    public bool IsDirectory { get; }
    public string get_FullPath();
    public bool get_IsDirectory();
    public static EnumeratedLocalItem FromFileAttributeData(string localItem, WIN32_FILE_ATTRIBUTE_DATA& attrs);
}
public class Microsoft.TeamFoundation.VersionControl.Client.ExceptionEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private int <OperationId>k__BackingField;
    private Exception m_exception;
    private Failure m_failure;
    private Workspace m_workspace;
    public Exception Exception { get; }
    public Failure Failure { get; }
    public Workspace Workspace { get; }
    public int OperationId { get; private set; }
    internal ExceptionEventArgs(Exception exception, Workspace workspace, int operationId);
    internal ExceptionEventArgs(Failure failure, Workspace workspace, int operationId);
    public Exception get_Exception();
    public Failure get_Failure();
    public Workspace get_Workspace();
    [CompilerGeneratedAttribute]
public int get_OperationId();
    [CompilerGeneratedAttribute]
private void set_OperationId(int value);
}
public class Microsoft.TeamFoundation.VersionControl.Client.ExceptionEventHandler : MulticastDelegate {
    public ExceptionEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ExceptionEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ExceptionEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.ExclusionSet : object {
    [CompilerGeneratedAttribute]
private Guid <DefaultExclusionWatermark>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastDefaultExclusionUpdate>k__BackingField;
    private HashSet`1<string> m_defaultExclusions;
    private bool m_defaultExclusionsOverwritten;
    private HashSet`1<string> m_removedExclusions;
    private static string s_defaultExclusions;
    private static string s_exclusion;
    private static string s_watermarkAttribute;
    private static string s_lastDefaultExclusionUpdateAttribute;
    public Guid DefaultExclusionWatermark { get; private set; }
    public DateTime LastDefaultExclusionUpdate { get; private set; }
    public ExclusionSet(XmlNode collectionNode);
    private static ExclusionSet();
    [CompilerGeneratedAttribute]
public Guid get_DefaultExclusionWatermark();
    [CompilerGeneratedAttribute]
private void set_DefaultExclusionWatermark(Guid value);
    [CompilerGeneratedAttribute]
public DateTime get_LastDefaultExclusionUpdate();
    [CompilerGeneratedAttribute]
private void set_LastDefaultExclusionUpdate(DateTime value);
    public bool RemoveExclusion(string exclusion);
    public String[] GetExclusions();
    public void SetDefaultExclusions(LocalItemExclusionSet exclusionsSet);
    public void Save(XmlNode outputXml);
    public void Merge(ExclusionSet exclusionSetToMergeIn);
    public void MarkClean();
}
public class Microsoft.TeamFoundation.VersionControl.Client.ExistingParentFileException : ServerItemException {
    public ExistingParentFileException(string message);
    public ExistingParentFileException(string message, Exception ex);
    protected ExistingParentFileException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.ExtendedItem : object {
    private int m_changeEx;
    private ChangeType m_changeType;
    private DateTime m_checkinDate;
    private int m_deletionId;
    private int m_encoding;
    private bool m_hasOtherPendingChange;
    private bool m_isBranch;
    private int m_itemId;
    private ItemType m_itemType;
    private string m_localItem;
    private string m_lockOwner;
    private string m_lockOwnerDisplayName;
    private LockLevel m_lockStatus;
    internal PropertyValue[] m_propertyValues;
    private string m_sourceServerItem;
    private string m_targetServerItem;
    private int m_versionLatest;
    private int m_versionLocal;
    public bool IsInWorkspace { get; }
    public bool IsLatest { get; }
    public ChangeType ChangeType { get; }
    [XmlIgnoreAttribute]
public ReadOnlyCollection`1<PropertyValue> PropertyValues { get; }
    public DateTime CheckinDate { get; public set; }
    public int DeletionId { get; }
    public int Encoding { get; }
    public bool HasOtherPendingChange { get; }
    public bool IsBranch { get; }
    public int ItemId { get; }
    public ItemType ItemType { get; }
    public string LocalItem { get; }
    public string LockOwner { get; }
    public string LockOwnerDisplayName { get; }
    public LockLevel LockStatus { get; }
    public string SourceServerItem { get; }
    public string TargetServerItem { get; }
    public int VersionLatest { get; }
    public int VersionLocal { get; }
    internal ExtendedItem(LocalPendingChangesTable pc, WorkspaceLocalItem localItem, LocalPendingChange pendingChange);
    public bool get_IsInWorkspace();
    public bool get_IsLatest();
    public ChangeType get_ChangeType();
    public ReadOnlyCollection`1<PropertyValue> get_PropertyValues();
    private void AfterDeserialize();
    public DateTime get_CheckinDate();
    public void set_CheckinDate(DateTime value);
    public int get_DeletionId();
    public int get_Encoding();
    public bool get_HasOtherPendingChange();
    public bool get_IsBranch();
    public int get_ItemId();
    public ItemType get_ItemType();
    public string get_LocalItem();
    public string get_LockOwner();
    public string get_LockOwnerDisplayName();
    public LockLevel get_LockStatus();
    public string get_SourceServerItem();
    public string get_TargetServerItem();
    public int get_VersionLatest();
    public int get_VersionLocal();
    [EditorBrowsableAttribute("1")]
public static ExtendedItem FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, ExtendedItem obj);
}
public class Microsoft.TeamFoundation.VersionControl.Client.ExtendedMerge : object {
    private ChangesetSummary m_sourceChangeset;
    private Change m_sourceItem;
    private ChangesetSummary m_targetChangeset;
    private ItemIdentifier m_targetItem;
    private int m_versionedItemCount;
    public ChangesetSummary SourceChangeset { get; }
    public Change SourceItem { get; }
    public ChangesetSummary TargetChangeset { get; }
    public ItemIdentifier TargetItem { get; }
    public int VersionedItemCount { get; }
    public ChangesetSummary get_SourceChangeset();
    public Change get_SourceItem();
    public ChangesetSummary get_TargetChangeset();
    public ItemIdentifier get_TargetItem();
    public int get_VersionedItemCount();
    [EditorBrowsableAttribute("1")]
public static ExtendedMerge FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, ExtendedMerge obj);
}
public class Microsoft.TeamFoundation.VersionControl.Client.Failure : object {
    private VersionControlServer m_sourceControl;
    private string m_code;
    private string m_computerName;
    private string m_identityName;
    private int m_itemId;
    private string m_localItem;
    private string m_message;
    private RequestType m_requestType;
    private string m_resourceName;
    private string m_serverItem;
    private SeverityType m_severity;
    internal Warning[] m_warnings;
    private string m_workspaceName;
    private string m_workspaceOwner;
    unknown string Item {internal set; }
    public VersionControlServer VersionControlServer { get; internal set; }
    public string Code { get; }
    public string ComputerName { get; }
    public string IdentityName { get; }
    public int ItemId { get; }
    public string LocalItem { get; }
    public string Message { get; }
    public RequestType RequestType { get; internal set; }
    public string ResourceName { get; }
    public string ServerItem { get; }
    public SeverityType Severity { get; }
    public Warning[] Warnings { get; }
    public string WorkspaceName { get; }
    public string WorkspaceOwner { get; }
    internal Failure(string message, SeverityType severity);
    internal Failure(string message, string code, SeverityType severity, string item);
    internal void set_Item(string value);
    public string GetFormattedMessage();
    private string FormatWorkspaceName(Warning w);
    public VersionControlServer get_VersionControlServer();
    internal void set_VersionControlServer(VersionControlServer value);
    public string get_Code();
    public string get_ComputerName();
    public string get_IdentityName();
    public int get_ItemId();
    public string get_LocalItem();
    public string get_Message();
    public RequestType get_RequestType();
    internal void set_RequestType(RequestType value);
    public string get_ResourceName();
    public string get_ServerItem();
    public SeverityType get_Severity();
    public Warning[] get_Warnings();
    public string get_WorkspaceName();
    public string get_WorkspaceOwner();
    [EditorBrowsableAttribute("1")]
public static Failure FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, Failure obj);
}
public class Microsoft.TeamFoundation.VersionControl.Client.FeatureNotSupportedException : VersionControlException {
    public FeatureNotSupportedException(string message);
    public FeatureNotSupportedException(string message, Exception ex);
    protected FeatureNotSupportedException(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.FieldDefinitionComparer : object {
    private FieldDefinitionComparison m_compareBy;
    internal FieldDefinitionComparer(FieldDefinitionComparison compareBy);
    private sealed virtual override int System.Collections.IComparer.Compare(object x, object y);
}
internal enum Microsoft.TeamFoundation.VersionControl.Client.FieldDefinitionComparison : Enum {
    public int value__;
    public static FieldDefinitionComparison Name;
    public static FieldDefinitionComparison DisplayOrder;
}
internal class Microsoft.TeamFoundation.VersionControl.Client.FileBackedPendingChangeCollection : object {
    private VersionControlServer m_versionControlServer;
    private int m_pendingChangesCount;
    private string m_tempFileName;
    private FileStream m_fileStream;
    private DeflateStream m_deflateStream;
    private XmlWriter m_xmlWriter;
    private WeakReference m_materializedWeakRef;
    private FileBackedPendingChangeInitializer m_lazyInitializer;
    private object m_lazyParameter;
    private bool m_disposed;
    public bool IsOpen { get; }
    private bool IsOpenInternal { get; }
    public int Length { get; }
    public FileBackedPendingChangeCollection(VersionControlServer versionControlServer);
    internal FileBackedPendingChangeCollection(VersionControlServer versionControlServer, FileBackedPendingChangeInitializer lazyInitializer, object lazyInitializerParameter);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    private void EnsureLazyInitialized();
    public bool get_IsOpen();
    private bool get_IsOpenInternal();
    public void Close();
    public void AddPendingChange(PendingChange change);
    public int get_Length();
    public sealed virtual IEnumerator`1<PendingChange> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public PendingChange[] Materialize();
    public static IEnumerable`1<PendingChange> FromWorkspace(Workspace workspace);
    public static IEnumerable`1<PendingChange> FromWorkspace(Workspace workspace, ItemSpec[] itemSpecs);
    public static IEnumerable`1<PendingChange> FromWorkspace(Workspace workspace, ItemSpec[] itemSpecs, int stopAfterCount);
    private static void FromWorkspaceLazyInitializer(FileBackedPendingChangeCollection collection, object parameter);
    public static FileBackedPendingChangeCollection FromShelveset(VersionControlServer versionControlServer, string shelvesetName, string shelvesetOwner);
    public static FileBackedPendingChangeCollection FromShelveset(VersionControlServer versionControlServer, string shelvesetName, string shelvesetOwner, ItemSpec[] itemSpecs);
    public static FileBackedPendingChangeCollection FromShelveset(VersionControlServer versionControlServer, string shelvesetName, string shelvesetOwner, ItemSpec[] itemSpecs, int stopAfterCount);
    private static void FromShelvesetLazyInitializer(FileBackedPendingChangeCollection collection, object parameter);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.FileBackedPendingChangeInitializer : MulticastDelegate {
    public FileBackedPendingChangeInitializer(object object, IntPtr method);
    public virtual void Invoke(FileBackedPendingChangeCollection collection, object parameter);
    public virtual IAsyncResult BeginInvoke(FileBackedPendingChangeCollection collection, object parameter, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.TeamFoundation.VersionControl.Client.FileIdNotFoundException : VersionControlException {
    public FileIdNotFoundException(string message);
    public FileIdNotFoundException(string message, Exception ex);
    protected FileIdNotFoundException(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.FileSystemWalker : object {
    private Stack m_dirStack;
    private String[] m_fileSpecs;
    private bool m_fileSpecIsDir;
    private int m_fileSpecIndex;
    private bool m_isRecursive;
    private bool m_includeDirectories;
    private string m_fileNamePattern;
    private Workspace m_workspace;
    private string m_currentFileSpec;
    private bool m_fileSpecHasMatch;
    private bool m_treatMissingItemsAsFiles;
    private int m_operationId;
    private bool m_applyLocalItemExclusions;
    private string m_lazyEvaluatorStartLocalItem;
    private Lazy`1<LocalItemExclusionEvaluator> m_lazyEvaluator;
    private Func`1<LocalItemExclusionEvaluator> m_lazyEvalDelegate;
    private HashSet`1<string> m_appliedExclusions;
    public String[] ExclusionsApplied { get; }
    private bool HasNoFileMatches { get; }
    internal FileSystemWalker(Workspace workspace, String[] fileSpecs, bool isRecursive, bool includeDirectories, bool treatMissingItemsAsFiles, bool applyLocalItemExclusions, int operationId);
    [IteratorStateMachineAttribute("Microsoft.TeamFoundation.VersionControl.Client.FileSystemWalker/<GetEnumerator>d__1")]
public IEnumerator GetEnumerator();
    private PathAndAttributes[] GetFileSystemEntries(string dirName, string pattern);
    private LocalItemExclusionEvaluator CreateLazyEvaluator();
    private bool IsIgnored(string fileName, bool isFolder);
    public String[] get_ExclusionsApplied();
    private void CheckForIllegalDollarInPath(string fileName);
    private bool get_HasNoFileMatches();
    private void CheckNoFileMatches();
    private void NextFileSpec();
}
internal class Microsoft.TeamFoundation.VersionControl.Client.FileTransferEventArgs : EventArgs {
    private string m_fileName;
    private long m_numBytesTransferred;
    private long m_numBytesTotal;
    private CallStatus m_status;
    private long m_elapsedMilliseconds;
    public string FileName { get; }
    public long NumBytesTransferred { get; }
    public long NumBytesTotal { get; }
    internal CallStatus Status { get; }
    public long ElapsedMilliseconds { get; }
    internal FileTransferEventArgs(string fileName, long numBytesTransferred, long numBytesTotal, CallStatus status, long elapsedMilliseconds);
    public string get_FileName();
    public long get_NumBytesTransferred();
    public long get_NumBytesTotal();
    internal CallStatus get_Status();
    public long get_ElapsedMilliseconds();
}
internal class Microsoft.TeamFoundation.VersionControl.Client.FileTransferEventHandler : MulticastDelegate {
    public FileTransferEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, FileTransferEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, FileTransferEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.TeamFoundation.VersionControl.Client.FileType : object {
    private static EncodingDescription[] m_encodingDescriptions;
    private static object m_lock;
    public static string AutoFileType;
    public static string TextFileType;
    public static string BinaryFileType;
    public static string BinaryFileTypeDisplayName;
    private bool m_allowMultipleCheckout;
    internal String[] m_extensions;
    private string m_name;
    public bool AllowMultipleCheckout { get; public set; }
    public String[] Extensions { get; public set; }
    public string Name { get; public set; }
    public FileType(string name, String[] extensions);
    private static FileType();
    public FileType Clone();
    public static EncodingDescription[] GetSupportedEncodingDescriptions();
    public static string GetEncodingName(int encoding);
    public static string GetDisplayName(Encoding encoding);
    public static string GetDescription(Encoding encoding);
    public static int GetEncodingCodePage(string encoding);
    public static Encoding GetEncodingFromCodePage(int codePage);
    public static int Detect(string path, string fileEncoding);
    public static int Detect(string path, string fileEncoding, bool treatMissingFileAsBinary);
    public static int Detect(string path, string fileEncoding, bool treatMissingFileAsBinary, Failure[]& failures);
    private static Encoding GetEncodingFromIntOrString(int codePage, string encoding);
    private static Encoding DetermineEncoding(string path, bool checkForBinary, bool treatMissingFileAsBinary, Failure[]& failures);
    public bool get_AllowMultipleCheckout();
    public void set_AllowMultipleCheckout(bool value);
    public String[] get_Extensions();
    public void set_Extensions(String[] value);
    public string get_Name();
    public void set_Name(string value);
    [EditorBrowsableAttribute("1")]
public static FileType FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, FileType obj);
}
public class Microsoft.TeamFoundation.VersionControl.Client.FolderContentChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private int <ChangesetId>k__BackingField;
    public int ChangesetId { get; private set; }
    public FolderContentChangedEventArgs(int changesetId);
    [CompilerGeneratedAttribute]
public int get_ChangesetId();
    [CompilerGeneratedAttribute]
private void set_ChangesetId(int value);
}
public class Microsoft.TeamFoundation.VersionControl.Client.FolderContentChangedEventHandler : MulticastDelegate {
    public FolderContentChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, FolderContentChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, FolderContentChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.TeamFoundation.VersionControl.Client.FolderContentException : ServerItemException {
    public FolderContentException(string message);
    public FolderContentException(string message, Exception ex);
    protected FolderContentException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.FolderEditException : ServerItemException {
    public FolderEditException(string message);
    public FolderEditException(string message, Exception ex);
    protected FolderEditException(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.FrameworkSecurityProvider : object {
    private VersionControlServer m_versionControlServer;
    private ISecurityService m_securityService;
    private IIdentityManagementService m_identityManagement;
    private ICommonStructureService m_commonStructureService;
    private SecurityNamespace m_repositorySecurity;
    private SecurityNamespace m_privilegeSecurity;
    private static string s_projectUriHeader;
    public FrameworkSecurityProvider(VersionControlServer versionControlServer, ISecurityService securityService, IIdentityManagementService identityManagement, SecurityNamespace privilegeSecurity, SecurityNamespace repositorySecurity);
    private static FrameworkSecurityProvider();
    public ItemSecurity[] GetPermissions(String[] identityNames, ItemSpec[] itemSpecs, RecursionType recursion);
    public SecurityChange[] SetPermissions(SecurityChange[] securityChanges);
    public GlobalSecurity GetGlobalPermissions(String[] identityNames);
    private Dictionary`2<IdentityDescriptor, TeamFoundationIdentity> ReadIdentitiesForACL(AccessControlList accessControlList);
    public PermissionChange[] SetGlobalPermissions(PermissionChange[] permissionChanges);
    public String[] GetEffectivePermissions(string userName, string item);
    public String[] GetEffectiveGlobalPermissions(string userName);
    private Dictionary`2<IdentityDescriptor, TeamFoundationIdentity> ReadIdentitiesForACLs(IEnumerable`1<AccessControlList> accessControlLists);
    private IdentityDescriptor GetRequestorIdentity();
}
public class Microsoft.TeamFoundation.VersionControl.Client.FutureDateException : VersionControlException {
    public FutureDateException(string message);
    public FutureDateException(string message, Exception ex);
    protected FutureDateException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.GatedCheckinException : ActionDeniedBySubscriberException {
    private Uri m_buildUri;
    private List`1<string> m_overridePermissionFailures;
    private List`1<KeyValuePair`2<string, Uri>> m_affectedBuildDefinitions;
    public ReadOnlyCollection`1<KeyValuePair`2<string, Uri>> AffectedBuildDefinitions { get; }
    public int QueueId { get; }
    public Uri BuildUri { get; }
    public ReadOnlyCollection`1<string> OverridePermissionFailures { get; }
    public bool HasOverridePermission { get; }
    public string ShelvesetName { get; }
    public string CheckInTicket { get; }
    public int SubCode { get; }
    public bool CheckInContainsLocks { get; }
    internal GatedCheckinException(ActionDeniedBySubscriberException actionDeniedException);
    public ReadOnlyCollection`1<KeyValuePair`2<string, Uri>> get_AffectedBuildDefinitions();
    public int get_QueueId();
    public Uri get_BuildUri();
    public ReadOnlyCollection`1<string> get_OverridePermissionFailures();
    public bool get_HasOverridePermission();
    public string get_ShelvesetName();
    public string get_CheckInTicket();
    public int get_SubCode();
    public bool get_CheckInContainsLocks();
}
public class Microsoft.TeamFoundation.VersionControl.Client.GenericException : VersionControlException {
    public GenericException(string message);
    public GenericException(string message, Exception ex);
    protected GenericException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.GetFilterCallback : MulticastDelegate {
    public GetFilterCallback(object object, IntPtr method);
    public virtual void Invoke(Workspace workspace, ILocalUpdateOperation[] operations, object userData);
    public virtual IAsyncResult BeginInvoke(Workspace workspace, ILocalUpdateOperation[] operations, object userData, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[FlagsAttribute]
public enum Microsoft.TeamFoundation.VersionControl.Client.GetItemsOptions : Enum {
    public int value__;
    public static GetItemsOptions None;
    public static GetItemsOptions Download;
    public static GetItemsOptions Unsorted;
    public static GetItemsOptions IncludeBranchInfo;
    public static GetItemsOptions IncludeSourceRenames;
    public static GetItemsOptions LocalOnly;
    public static GetItemsOptions IncludeRecursiveDeletes;
}
public class Microsoft.TeamFoundation.VersionControl.Client.GetLatestOnCheckoutDisabledException : VersionControlException {
    public GetLatestOnCheckoutDisabledException(string message);
    public GetLatestOnCheckoutDisabledException(string message, Exception ex);
    protected GetLatestOnCheckoutDisabledException(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.GetOperation : object {
    [CompilerGeneratedAttribute]
private Byte[] <BaselineFileGuid>k__BackingField;
    [CompilerGeneratedAttribute]
private WorkspaceLocalItem <LocalVersionEntry>k__BackingField;
    private DownloadUrl m_downloadUrlObj;
    private GetOperationFlags m_flags;
    private ProcessType m_processType;
    private Conflict m_mergeDetails;
    private static string s_emptySourceServerItem;
    private int m_changeEx;
    private ChangeType m_changeType;
    private int m_conflictingChangeEx;
    private ChangeType m_conflictingChangeType;
    private int m_conflictingItemId;
    private int m_deletionId;
    private string m_downloadUrl;
    private int m_encoding;
    private bool m_hasConflict;
    internal Byte[] m_hashValue;
    internal PropertyValue[] m_internalAttributes;
    internal PropertyValue[] m_internalPropertyValues;
    private bool m_isLatest;
    private byte m_isNamespaceConflict;
    private int m_itemId;
    private ItemType m_itemType;
    private LockLevel m_lockLevel;
    private int m_pendingChangeId;
    private string m_sourceLocalItem;
    private string m_sourceServerItem;
    private string m_targetLocalItem;
    private string m_targetServerItem;
    private int m_versionLocal;
    private int m_versionRevertTo;
    private int m_versionServer;
    private DateTime m_versionServerDate;
    internal bool NewContentNeeded { get; }
    internal bool IsContentDestroyed { get; }
    internal bool DownloadCompleted { get; internal set; }
    internal string CurrentLocalItem { get; }
    internal ChangeType EffectiveChangeType { get; }
    private ChangeType Microsoft.TeamFoundation.VersionControl.Client.ILocalUpdateOperation.ChangeType { get; }
    internal bool IsUndo { get; }
    internal ProcessType ProcessType { get; internal set; }
    public bool IsDelete { get; }
    public bool IsConflict { get; }
    public bool IsNamespaceConflict { get; }
    internal bool IsCaseChangingRename { get; }
    internal Conflict MergeDetails { get; internal set; }
    public bool Ignore { get; public set; }
    public ChangeType ChangeType { get; public set; }
    public ChangeType ConflictingChangeType { get; public set; }
    public bool HasPendingChange { get; }
    public string DownloadUrl { get; }
    public string SourceServerItem { get; public set; }
    internal Byte[] BaselineFileGuid { get; internal set; }
    internal WorkspaceLocalItem LocalVersionEntry { get; internal set; }
    private bool IsSourceLocalCleared { get; private set; }
    internal bool OkayToOverwriteExistingLocal { get; internal set; }
    public int ConflictingItemId { get; public set; }
    public int DeletionId { get; public set; }
    public int Encoding { get; public set; }
    public bool HasConflict { get; public set; }
    public Byte[] HashValue { get; public set; }
    internal PropertyValue[] InternalPropertyValues { get; internal set; }
    public bool IsLatest { get; public set; }
    public int ItemId { get; public set; }
    public ItemType ItemType { get; public set; }
    public LockLevel LockLevel { get; public set; }
    public int PendingChangeId { get; public set; }
    public string SourceLocalItem { get; public set; }
    public string TargetLocalItem { get; public set; }
    public string TargetServerItem { get; public set; }
    public int VersionLocal { get; public set; }
    public int VersionRevertTo { get; public set; }
    public int VersionServer { get; public set; }
    public DateTime VersionServerDate { get; public set; }
    private static GetOperation();
    internal void ClearLocalItem();
    internal bool get_NewContentNeeded();
    internal bool get_IsContentDestroyed();
    internal bool get_DownloadCompleted();
    internal void set_DownloadCompleted(bool value);
    internal string get_CurrentLocalItem();
    internal ChangeType get_EffectiveChangeType();
    private sealed virtual override ChangeType Microsoft.TeamFoundation.VersionControl.Client.ILocalUpdateOperation.get_ChangeType();
    internal bool get_IsUndo();
    internal ProcessType get_ProcessType();
    internal void set_ProcessType(ProcessType value);
    public sealed virtual bool get_IsDelete();
    public sealed virtual bool get_IsConflict();
    public bool get_IsNamespaceConflict();
    internal bool get_IsCaseChangingRename();
    internal Conflict get_MergeDetails();
    internal void set_MergeDetails(Conflict value);
    public sealed virtual bool get_Ignore();
    public sealed virtual void set_Ignore(bool value);
    public ChangeType get_ChangeType();
    public void set_ChangeType(ChangeType value);
    public ChangeType get_ConflictingChangeType();
    public void set_ConflictingChangeType(ChangeType value);
    public bool get_HasPendingChange();
    private void AfterDeserialize();
    public string get_DownloadUrl();
    public string get_SourceServerItem();
    public void set_SourceServerItem(string value);
    [CompilerGeneratedAttribute]
internal Byte[] get_BaselineFileGuid();
    [CompilerGeneratedAttribute]
internal void set_BaselineFileGuid(Byte[] value);
    [CompilerGeneratedAttribute]
internal WorkspaceLocalItem get_LocalVersionEntry();
    [CompilerGeneratedAttribute]
internal void set_LocalVersionEntry(WorkspaceLocalItem value);
    private bool get_IsSourceLocalCleared();
    private void set_IsSourceLocalCleared(bool value);
    internal bool get_OkayToOverwriteExistingLocal();
    internal void set_OkayToOverwriteExistingLocal(bool value);
    public int get_ConflictingItemId();
    public void set_ConflictingItemId(int value);
    public sealed virtual int get_DeletionId();
    public void set_DeletionId(int value);
    public int get_Encoding();
    public void set_Encoding(int value);
    public bool get_HasConflict();
    public void set_HasConflict(bool value);
    public Byte[] get_HashValue();
    public void set_HashValue(Byte[] value);
    internal PropertyValue[] get_InternalPropertyValues();
    internal void set_InternalPropertyValues(PropertyValue[] value);
    public bool get_IsLatest();
    public void set_IsLatest(bool value);
    public sealed virtual int get_ItemId();
    public void set_ItemId(int value);
    public sealed virtual ItemType get_ItemType();
    public void set_ItemType(ItemType value);
    public LockLevel get_LockLevel();
    public void set_LockLevel(LockLevel value);
    public sealed virtual int get_PendingChangeId();
    public void set_PendingChangeId(int value);
    public sealed virtual string get_SourceLocalItem();
    public void set_SourceLocalItem(string value);
    public sealed virtual string get_TargetLocalItem();
    public void set_TargetLocalItem(string value);
    public sealed virtual string get_TargetServerItem();
    public void set_TargetServerItem(string value);
    public sealed virtual int get_VersionLocal();
    public void set_VersionLocal(int value);
    public int get_VersionRevertTo();
    public void set_VersionRevertTo(int value);
    public sealed virtual int get_VersionServer();
    public void set_VersionServer(int value);
    public DateTime get_VersionServerDate();
    public void set_VersionServerDate(DateTime value);
    internal static GetOperation FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    internal void ToXml(XmlWriter writer, string element);
    internal static void ToXml(XmlWriter writer, string element, GetOperation obj);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.GetOperationComparer : object {
    private static GetOperationComparer m_comparer;
    internal static IComparer`1<GetOperation> Comparer { get; }
    private sealed virtual override int System.Collections.IComparer.Compare(object x, object y);
    private sealed virtual override int System.Collections.Generic.IComparer<Microsoft.TeamFoundation.VersionControl.Client.GetOperation>.Compare(GetOperation op1, GetOperation op2);
    internal static IComparer`1<GetOperation> get_Comparer();
}
[FlagsAttribute]
public enum Microsoft.TeamFoundation.VersionControl.Client.GetOptions : Enum {
    public int value__;
    public static GetOptions None;
    public static GetOptions Overwrite;
    public static GetOptions GetAll;
    public static GetOptions Preview;
    public static GetOptions Remap;
    public static GetOptions NoAutoResolve;
}
public class Microsoft.TeamFoundation.VersionControl.Client.GetRequest : object {
    private ItemSpec m_itemSpec;
    private VersionSpec m_versionSpec;
    public ItemSpec ItemSpec { get; public set; }
    public VersionSpec VersionSpec { get; public set; }
    public GetRequest(string item, RecursionType recursion, VersionSpec version);
    public GetRequest(ItemSpec itemSpec, VersionSpec version);
    public GetRequest(ItemSpec itemSpec, int changeset);
    public static GetRequest[] FromStrings(String[] paths, RecursionType recursion, VersionSpec version);
    public ItemSpec get_ItemSpec();
    public void set_ItemSpec(ItemSpec value);
    public VersionSpec get_VersionSpec();
    public void set_VersionSpec(VersionSpec value);
    [EditorBrowsableAttribute("1")]
public static GetRequest FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, GetRequest obj);
}
public class Microsoft.TeamFoundation.VersionControl.Client.GetStatus : object {
    [CompilerGeneratedAttribute]
private int <NumResolvedConflicts>k__BackingField;
    internal int m_numOperations;
    internal long m_numFiles;
    internal long m_numBytes;
    internal int m_numConflicts;
    internal int m_numUpdated;
    internal int m_numWarnings;
    internal List`1<Failure> m_failures;
    internal bool m_haveResolvableWarnings;
    public int NumFailures { get; }
    public int NumOperations { get; }
    public long NumFiles { get; }
    public long NumBytes { get; }
    public int NumConflicts { get; }
    public int NumResolvedConflicts { get; internal set; }
    public int NumUpdated { get; }
    public int NumWarnings { get; }
    public bool NoActionNeeded { get; }
    public bool HaveResolvableWarnings { get; }
    public void Combine(GetStatus getStatus);
    public Failure[] GetFailures();
    public int get_NumFailures();
    public int get_NumOperations();
    public long get_NumFiles();
    public long get_NumBytes();
    public int get_NumConflicts();
    [CompilerGeneratedAttribute]
public int get_NumResolvedConflicts();
    [CompilerGeneratedAttribute]
internal void set_NumResolvedConflicts(int value);
    public int get_NumUpdated();
    public int get_NumWarnings();
    public bool get_NoActionNeeded();
    public bool get_HaveResolvableWarnings();
}
public class Microsoft.TeamFoundation.VersionControl.Client.GettingEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private int <OperationId>k__BackingField;
    private Workspace m_workspace;
    private OperationStatus m_status;
    internal GetOperation m_action;
    private string m_targetLocalItem;
    private ChangeType m_targetPendingChangeType;
    private bool m_diskUpdateAttempted;
    private int m_currentNumOperations;
    private int m_totalNumOperations;
    private ReadOnlyCollection`1<PropertyValue> m_attributes;
    private ReadOnlyCollection`1<PropertyValue> m_propertyValues;
    public Workspace Workspace { get; }
    public OperationStatus Status { get; }
    public bool IsLatest { get; }
    public string SourceLocalItem { get; }
    public string TargetLocalItem { get; }
    public int Version { get; }
    public int DeletionId { get; }
    public string ServerItem { get; }
    public string SourceServerItem { get; }
    public int ItemId { get; }
    public ItemType ItemType { get; }
    public bool IsDelete { get; }
    public ChangeType ChangeType { get; }
    public bool DiskUpdateAttempted { get; }
    internal int Current { get; }
    public int Total { get; }
    internal string SourcePendingChangeTypeName { get; }
    internal string TargetPendingChangeTypeName { get; }
    [ObsoleteAttribute("Please use the Attributes property instead", "False")]
public ReadOnlyCollection`1<PropertyValue> Properties { get; }
    public ReadOnlyCollection`1<PropertyValue> Attributes { get; }
    public ReadOnlyCollection`1<PropertyValue> PropertyValues { get; }
    public int OperationId { get; private set; }
    internal GettingEventArgs(AsyncGetOperation asyncOp, OperationStatus status, GetOperation action, string localItem, int operationId);
    internal GettingEventArgs(AsyncGetOperation asyncOp, OperationStatus status, GetOperation action, string targetLocalItem, ChangeType targetPendingChangeType, int operationId);
    public string GetMessage(string targetName, String& error);
    public Workspace get_Workspace();
    public OperationStatus get_Status();
    public bool get_IsLatest();
    public string get_SourceLocalItem();
    public string get_TargetLocalItem();
    public int get_Version();
    public int get_DeletionId();
    public string get_ServerItem();
    public string get_SourceServerItem();
    public int get_ItemId();
    public ItemType get_ItemType();
    public bool get_IsDelete();
    public ChangeType get_ChangeType();
    public bool get_DiskUpdateAttempted();
    internal int get_Current();
    public int get_Total();
    internal string get_SourcePendingChangeTypeName();
    internal string get_TargetPendingChangeTypeName();
    public ReadOnlyCollection`1<PropertyValue> get_Properties();
    public ReadOnlyCollection`1<PropertyValue> get_Attributes();
    public ReadOnlyCollection`1<PropertyValue> get_PropertyValues();
    [CompilerGeneratedAttribute]
public int get_OperationId();
    [CompilerGeneratedAttribute]
private void set_OperationId(int value);
}
public class Microsoft.TeamFoundation.VersionControl.Client.GettingEventHandler : MulticastDelegate {
    public GettingEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, GettingEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, GettingEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.TeamFoundation.VersionControl.Client.GlobalSecurity : object {
    internal AccessEntry[] m_entries;
    private bool m_writable;
    public AccessEntry[] Entries { get; }
    public bool Writable { get; }
    internal GlobalSecurity(AccessEntry[] entries, bool writable);
    public AccessEntry[] get_Entries();
    public bool get_Writable();
    [EditorBrowsableAttribute("1")]
public static GlobalSecurity FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, GlobalSecurity obj);
}
internal static class Microsoft.TeamFoundation.VersionControl.Client.Helper : object {
    private static AccessEntry[] m_zeroLengthArrayOfAccessEntry;
    private static Annotation[] m_zeroLengthArrayOfAnnotation;
    private static BranchRelative[][] m_zeroLengthArrayOfArrayOfBranchRelative;
    private static ExtendedItem[][] m_zeroLengthArrayOfArrayOfExtendedItem;
    private static GetOperation[][] m_zeroLengthArrayOfArrayOfGetOperation;
    private static LocalVersion[][] m_zeroLengthArrayOfArrayOfLocalVersion;
    private static ArtifactPropertyValue[] m_zeroLengthArrayOfArtifactPropertyValue;
    private static BranchObject[] m_zeroLengthArrayOfBranchObject;
    private static BranchObjectOwnership[] m_zeroLengthArrayOfBranchObjectOwnership;
    private static BranchRelative[] m_zeroLengthArrayOfBranchRelative;
    private static Change[] m_zeroLengthArrayOfChange;
    private static ChangeRequest[] m_zeroLengthArrayOfChangeRequest;
    private static Changeset[] m_zeroLengthArrayOfChangeset;
    private static ChangesetMerge[] m_zeroLengthArrayOfChangesetMerge;
    private static CheckinNoteFieldDefinition[] m_zeroLengthArrayOfCheckinNoteFieldDefinition;
    private static CheckinNoteFieldValue[] m_zeroLengthArrayOfCheckinNoteFieldValue;
    private static CheckinNotificationWorkItemInfo[] m_zeroLengthArrayOfCheckinNotificationWorkItemInfo;
    private static Conflict[] m_zeroLengthArrayOfConflict;
    private static ExtendedItem[] m_zeroLengthArrayOfExtendedItem;
    private static ExtendedMerge[] m_zeroLengthArrayOfExtendedMerge;
    private static Failure[] m_zeroLengthArrayOfFailure;
    private static FileType[] m_zeroLengthArrayOfFileType;
    private static GetOperation[] m_zeroLengthArrayOfGetOperation;
    private static GetRequest[] m_zeroLengthArrayOfGetRequest;
    private static Int32[] m_zeroLengthArrayOfInt32;
    private static Item[] m_zeroLengthArrayOfItem;
    private static ItemIdentifier[] m_zeroLengthArrayOfItemIdentifier;
    private static ItemMerge[] m_zeroLengthArrayOfItemMerge;
    private static ItemSecurity[] m_zeroLengthArrayOfItemSecurity;
    private static ItemSet[] m_zeroLengthArrayOfItemSet;
    private static ItemSpec[] m_zeroLengthArrayOfItemSpec;
    private static LabelItemSpec[] m_zeroLengthArrayOfLabelItemSpec;
    private static LabelResult[] m_zeroLengthArrayOfLabelResult;
    private static LocalPendingChange[] m_zeroLengthArrayOfLocalPendingChange;
    private static LocalVersion[] m_zeroLengthArrayOfLocalVersion;
    private static LocalVersionUpdate[] m_zeroLengthArrayOfLocalVersionUpdate;
    private static Mapping[] m_zeroLengthArrayOfMapping;
    private static MergeCandidate[] m_zeroLengthArrayOfMergeCandidate;
    private static MergeSource[] m_zeroLengthArrayOfMergeSource;
    private static PendingChange[] m_zeroLengthArrayOfPendingChange;
    private static PendingSet[] m_zeroLengthArrayOfPendingSet;
    private static PendingState[] m_zeroLengthArrayOfPendingState;
    private static PermissionChange[] m_zeroLengthArrayOfPermissionChange;
    private static PolicyFailureInfo[] m_zeroLengthArrayOfPolicyFailureInfo;
    private static PropertyValue[] m_zeroLengthArrayOfPropertyValue;
    private static ProxyInfo[] m_zeroLengthArrayOfProxyInfo;
    private static SecurityChange[] m_zeroLengthArrayOfSecurityChange;
    private static ServerItemLocalVersionUpdate[] m_zeroLengthArrayOfServerItemLocalVersionUpdate;
    private static Shelveset[] m_zeroLengthArrayOfShelveset;
    private static String[] m_zeroLengthArrayOfString;
    private static TeamProjectFolderPermission[] m_zeroLengthArrayOfTeamProjectFolderPermission;
    private static VersionControlLabel[] m_zeroLengthArrayOfVersionControlLabel;
    private static VersionControlLink[] m_zeroLengthArrayOfVersionControlLink;
    private static Warning[] m_zeroLengthArrayOfWarning;
    private static WorkingFolder[] m_zeroLengthArrayOfWorkingFolder;
    private static Workspace[] m_zeroLengthArrayOfWorkspace;
    private static WorkspaceItem[] m_zeroLengthArrayOfWorkspaceItem;
    private static WorkspaceItemSet[] m_zeroLengthArrayOfWorkspaceItemSet;
    internal static AccessEntry[] ZeroLengthArrayOfAccessEntry { get; }
    internal static Annotation[] ZeroLengthArrayOfAnnotation { get; }
    internal static BranchRelative[][] ZeroLengthArrayOfArrayOfBranchRelative { get; }
    internal static ExtendedItem[][] ZeroLengthArrayOfArrayOfExtendedItem { get; }
    internal static GetOperation[][] ZeroLengthArrayOfArrayOfGetOperation { get; }
    internal static LocalVersion[][] ZeroLengthArrayOfArrayOfLocalVersion { get; }
    internal static ArtifactPropertyValue[] ZeroLengthArrayOfArtifactPropertyValue { get; }
    internal static BranchObject[] ZeroLengthArrayOfBranchObject { get; }
    internal static BranchObjectOwnership[] ZeroLengthArrayOfBranchObjectOwnership { get; }
    internal static BranchRelative[] ZeroLengthArrayOfBranchRelative { get; }
    internal static Change[] ZeroLengthArrayOfChange { get; }
    internal static ChangeRequest[] ZeroLengthArrayOfChangeRequest { get; }
    internal static Changeset[] ZeroLengthArrayOfChangeset { get; }
    internal static ChangesetMerge[] ZeroLengthArrayOfChangesetMerge { get; }
    internal static CheckinNoteFieldDefinition[] ZeroLengthArrayOfCheckinNoteFieldDefinition { get; }
    internal static CheckinNoteFieldValue[] ZeroLengthArrayOfCheckinNoteFieldValue { get; }
    internal static CheckinNotificationWorkItemInfo[] ZeroLengthArrayOfCheckinNotificationWorkItemInfo { get; }
    internal static Conflict[] ZeroLengthArrayOfConflict { get; }
    internal static ExtendedItem[] ZeroLengthArrayOfExtendedItem { get; }
    internal static ExtendedMerge[] ZeroLengthArrayOfExtendedMerge { get; }
    internal static Failure[] ZeroLengthArrayOfFailure { get; }
    internal static FileType[] ZeroLengthArrayOfFileType { get; }
    internal static GetOperation[] ZeroLengthArrayOfGetOperation { get; }
    internal static GetRequest[] ZeroLengthArrayOfGetRequest { get; }
    internal static Int32[] ZeroLengthArrayOfInt32 { get; }
    internal static Item[] ZeroLengthArrayOfItem { get; }
    internal static ItemIdentifier[] ZeroLengthArrayOfItemIdentifier { get; }
    internal static ItemMerge[] ZeroLengthArrayOfItemMerge { get; }
    internal static ItemSecurity[] ZeroLengthArrayOfItemSecurity { get; }
    internal static ItemSet[] ZeroLengthArrayOfItemSet { get; }
    internal static ItemSpec[] ZeroLengthArrayOfItemSpec { get; }
    internal static LabelItemSpec[] ZeroLengthArrayOfLabelItemSpec { get; }
    internal static LabelResult[] ZeroLengthArrayOfLabelResult { get; }
    internal static LocalPendingChange[] ZeroLengthArrayOfLocalPendingChange { get; }
    internal static LocalVersion[] ZeroLengthArrayOfLocalVersion { get; }
    internal static LocalVersionUpdate[] ZeroLengthArrayOfLocalVersionUpdate { get; }
    internal static Mapping[] ZeroLengthArrayOfMapping { get; }
    internal static MergeCandidate[] ZeroLengthArrayOfMergeCandidate { get; }
    internal static MergeSource[] ZeroLengthArrayOfMergeSource { get; }
    internal static PendingChange[] ZeroLengthArrayOfPendingChange { get; }
    internal static PendingSet[] ZeroLengthArrayOfPendingSet { get; }
    internal static PendingState[] ZeroLengthArrayOfPendingState { get; }
    internal static PermissionChange[] ZeroLengthArrayOfPermissionChange { get; }
    internal static PolicyFailureInfo[] ZeroLengthArrayOfPolicyFailureInfo { get; }
    internal static PropertyValue[] ZeroLengthArrayOfPropertyValue { get; }
    internal static ProxyInfo[] ZeroLengthArrayOfProxyInfo { get; }
    internal static SecurityChange[] ZeroLengthArrayOfSecurityChange { get; }
    internal static ServerItemLocalVersionUpdate[] ZeroLengthArrayOfServerItemLocalVersionUpdate { get; }
    internal static Shelveset[] ZeroLengthArrayOfShelveset { get; }
    internal static String[] ZeroLengthArrayOfString { get; }
    internal static TeamProjectFolderPermission[] ZeroLengthArrayOfTeamProjectFolderPermission { get; }
    internal static VersionControlLabel[] ZeroLengthArrayOfVersionControlLabel { get; }
    internal static VersionControlLink[] ZeroLengthArrayOfVersionControlLink { get; }
    internal static Warning[] ZeroLengthArrayOfWarning { get; }
    internal static WorkingFolder[] ZeroLengthArrayOfWorkingFolder { get; }
    internal static Workspace[] ZeroLengthArrayOfWorkspace { get; }
    internal static WorkspaceItem[] ZeroLengthArrayOfWorkspaceItem { get; }
    internal static WorkspaceItemSet[] ZeroLengthArrayOfWorkspaceItemSet { get; }
    internal static AccessEntry[] get_ZeroLengthArrayOfAccessEntry();
    internal static Annotation[] get_ZeroLengthArrayOfAnnotation();
    internal static BranchRelative[][] get_ZeroLengthArrayOfArrayOfBranchRelative();
    internal static ExtendedItem[][] get_ZeroLengthArrayOfArrayOfExtendedItem();
    internal static GetOperation[][] get_ZeroLengthArrayOfArrayOfGetOperation();
    internal static LocalVersion[][] get_ZeroLengthArrayOfArrayOfLocalVersion();
    internal static ArtifactPropertyValue[] get_ZeroLengthArrayOfArtifactPropertyValue();
    internal static BranchObject[] get_ZeroLengthArrayOfBranchObject();
    internal static BranchObjectOwnership[] get_ZeroLengthArrayOfBranchObjectOwnership();
    internal static BranchRelative[] get_ZeroLengthArrayOfBranchRelative();
    internal static Change[] get_ZeroLengthArrayOfChange();
    internal static ChangeRequest[] get_ZeroLengthArrayOfChangeRequest();
    internal static Changeset[] get_ZeroLengthArrayOfChangeset();
    internal static ChangesetMerge[] get_ZeroLengthArrayOfChangesetMerge();
    internal static CheckinNoteFieldDefinition[] get_ZeroLengthArrayOfCheckinNoteFieldDefinition();
    internal static CheckinNoteFieldValue[] get_ZeroLengthArrayOfCheckinNoteFieldValue();
    internal static CheckinNotificationWorkItemInfo[] get_ZeroLengthArrayOfCheckinNotificationWorkItemInfo();
    internal static Conflict[] get_ZeroLengthArrayOfConflict();
    internal static ExtendedItem[] get_ZeroLengthArrayOfExtendedItem();
    internal static ExtendedMerge[] get_ZeroLengthArrayOfExtendedMerge();
    internal static Failure[] get_ZeroLengthArrayOfFailure();
    internal static FileType[] get_ZeroLengthArrayOfFileType();
    internal static GetOperation[] get_ZeroLengthArrayOfGetOperation();
    internal static GetRequest[] get_ZeroLengthArrayOfGetRequest();
    internal static Int32[] get_ZeroLengthArrayOfInt32();
    internal static Item[] get_ZeroLengthArrayOfItem();
    internal static ItemIdentifier[] get_ZeroLengthArrayOfItemIdentifier();
    internal static ItemMerge[] get_ZeroLengthArrayOfItemMerge();
    internal static ItemSecurity[] get_ZeroLengthArrayOfItemSecurity();
    internal static ItemSet[] get_ZeroLengthArrayOfItemSet();
    internal static ItemSpec[] get_ZeroLengthArrayOfItemSpec();
    internal static LabelItemSpec[] get_ZeroLengthArrayOfLabelItemSpec();
    internal static LabelResult[] get_ZeroLengthArrayOfLabelResult();
    internal static LocalPendingChange[] get_ZeroLengthArrayOfLocalPendingChange();
    internal static LocalVersion[] get_ZeroLengthArrayOfLocalVersion();
    internal static LocalVersionUpdate[] get_ZeroLengthArrayOfLocalVersionUpdate();
    internal static Mapping[] get_ZeroLengthArrayOfMapping();
    internal static MergeCandidate[] get_ZeroLengthArrayOfMergeCandidate();
    internal static MergeSource[] get_ZeroLengthArrayOfMergeSource();
    internal static PendingChange[] get_ZeroLengthArrayOfPendingChange();
    internal static PendingSet[] get_ZeroLengthArrayOfPendingSet();
    internal static PendingState[] get_ZeroLengthArrayOfPendingState();
    internal static PermissionChange[] get_ZeroLengthArrayOfPermissionChange();
    internal static PolicyFailureInfo[] get_ZeroLengthArrayOfPolicyFailureInfo();
    internal static PropertyValue[] get_ZeroLengthArrayOfPropertyValue();
    internal static ProxyInfo[] get_ZeroLengthArrayOfProxyInfo();
    internal static SecurityChange[] get_ZeroLengthArrayOfSecurityChange();
    internal static ServerItemLocalVersionUpdate[] get_ZeroLengthArrayOfServerItemLocalVersionUpdate();
    internal static Shelveset[] get_ZeroLengthArrayOfShelveset();
    internal static String[] get_ZeroLengthArrayOfString();
    internal static TeamProjectFolderPermission[] get_ZeroLengthArrayOfTeamProjectFolderPermission();
    internal static VersionControlLabel[] get_ZeroLengthArrayOfVersionControlLabel();
    internal static VersionControlLink[] get_ZeroLengthArrayOfVersionControlLink();
    internal static Warning[] get_ZeroLengthArrayOfWarning();
    internal static WorkingFolder[] get_ZeroLengthArrayOfWorkingFolder();
    internal static Workspace[] get_ZeroLengthArrayOfWorkspace();
    internal static WorkspaceItem[] get_ZeroLengthArrayOfWorkspaceItem();
    internal static WorkspaceItemSet[] get_ZeroLengthArrayOfWorkspaceItemSet();
    internal static AccessEntry[] ArrayOfAccessEntryFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static Annotation[] ArrayOfAnnotationFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static BranchRelative[][] ArrayOfArrayOfBranchRelativeFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static ExtendedItem[][] ArrayOfArrayOfExtendedItemFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static GetOperation[][] ArrayOfArrayOfGetOperationFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static LocalVersion[][] ArrayOfArrayOfLocalVersionFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static ArtifactPropertyValue[] ArrayOfArtifactPropertyValueFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static BranchObject[] ArrayOfBranchObjectFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static BranchObjectOwnership[] ArrayOfBranchObjectOwnershipFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static BranchRelative[] ArrayOfBranchRelativeFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static BranchRelative[] ArrayOfBranchRelativeFromXml(IServiceProvider serviceProvider, XmlReader reader);
    internal static Change[] ArrayOfChangeFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static ChangeRequest[] ArrayOfChangeRequestFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static Changeset[] ArrayOfChangesetFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static ChangesetMerge[] ArrayOfChangesetMergeFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static CheckinNoteFieldDefinition[] ArrayOfCheckinNoteFieldDefinitionFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static CheckinNoteFieldValue[] ArrayOfCheckinNoteFieldValueFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static CheckinNotificationWorkItemInfo[] ArrayOfCheckinNotificationWorkItemInfoFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static Conflict[] ArrayOfConflictFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static ExtendedItem[] ArrayOfExtendedItemFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static ExtendedItem[] ArrayOfExtendedItemFromXml(IServiceProvider serviceProvider, XmlReader reader);
    internal static ExtendedMerge[] ArrayOfExtendedMergeFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static Failure[] ArrayOfFailureFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static FileType[] ArrayOfFileTypeFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static GetOperation[] ArrayOfGetOperationFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static GetOperation[] ArrayOfGetOperationFromXml(IServiceProvider serviceProvider, XmlReader reader);
    internal static GetRequest[] ArrayOfGetRequestFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static Int32[] ArrayOfInt32FromXml(XmlReader reader, bool inline);
    internal static Item[] ArrayOfItemFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static ItemIdentifier[] ArrayOfItemIdentifierFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static ItemMerge[] ArrayOfItemMergeFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static ItemSecurity[] ArrayOfItemSecurityFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static ItemSet[] ArrayOfItemSetFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static ItemSpec[] ArrayOfItemSpecFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static LabelItemSpec[] ArrayOfLabelItemSpecFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static LabelResult[] ArrayOfLabelResultFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static LocalPendingChange[] ArrayOfLocalPendingChangeFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static LocalVersion[] ArrayOfLocalVersionFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static LocalVersion[] ArrayOfLocalVersionFromXml(IServiceProvider serviceProvider, XmlReader reader);
    internal static LocalVersionUpdate[] ArrayOfLocalVersionUpdateFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static Mapping[] ArrayOfMappingFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static MergeCandidate[] ArrayOfMergeCandidateFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static MergeSource[] ArrayOfMergeSourceFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static PendingChange[] ArrayOfPendingChangeFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static PendingSet[] ArrayOfPendingSetFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static PendingState[] ArrayOfPendingStateFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static PermissionChange[] ArrayOfPermissionChangeFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static PolicyFailureInfo[] ArrayOfPolicyFailureInfoFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static PropertyValue[] ArrayOfPropertyValueFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static ProxyInfo[] ArrayOfProxyInfoFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static SecurityChange[] ArrayOfSecurityChangeFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static ServerItemLocalVersionUpdate[] ArrayOfServerItemLocalVersionUpdateFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static Shelveset[] ArrayOfShelvesetFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static String[] ArrayOfStringFromXml(XmlReader reader, bool inline);
    internal static TeamProjectFolderPermission[] ArrayOfTeamProjectFolderPermissionFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static VersionControlLabel[] ArrayOfVersionControlLabelFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static VersionControlLink[] ArrayOfVersionControlLinkFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static Warning[] ArrayOfWarningFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static WorkingFolder[] ArrayOfWorkingFolderFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static Workspace[] ArrayOfWorkspaceFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static WorkspaceItem[] ArrayOfWorkspaceItemFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static WorkspaceItemSet[] ArrayOfWorkspaceItemSetFromXml(IServiceProvider serviceProvider, XmlReader reader, bool inline);
    internal static string ArrayToString(T[] array);
    internal static void StringToXmlElement(XmlWriter writer, string element, string str);
    internal static void ToXml(XmlWriter writer, string arrayName, AccessEntry[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, AccessEntry[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, Annotation[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, Annotation[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, ArtifactPropertyValue[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, ArtifactPropertyValue[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, BranchObjectOwnership[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, BranchObjectOwnership[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, BranchObject[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, BranchObject[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, BranchRelative[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, BranchRelative[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, ChangeRequest[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, ChangeRequest[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, Change[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, Change[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, ChangesetMerge[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, ChangesetMerge[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, Changeset[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, Changeset[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, CheckinNoteFieldDefinition[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, CheckinNoteFieldDefinition[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, CheckinNoteFieldValue[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, CheckinNoteFieldValue[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, CheckinNotificationWorkItemInfo[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, CheckinNotificationWorkItemInfo[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, Conflict[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, Conflict[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, ExtendedItem[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, ExtendedItem[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, ExtendedMerge[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, ExtendedMerge[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, Failure[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, Failure[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, FileType[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, FileType[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, GetOperation[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, GetOperation[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, GetRequest[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, GetRequest[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, Int32[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, Int32[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, ItemIdentifier[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, ItemIdentifier[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, ItemMerge[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, ItemMerge[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, ItemSecurity[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, ItemSecurity[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, ItemSet[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, ItemSet[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, ItemSpec[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, ItemSpec[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, Item[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, Item[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, LabelItemSpec[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, LabelItemSpec[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, LabelResult[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, LabelResult[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, LocalPendingChange[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, LocalPendingChange[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, LocalVersionUpdate[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, LocalVersionUpdate[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, LocalVersion[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, LocalVersion[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, Mapping[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, Mapping[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, MergeCandidate[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, MergeCandidate[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, MergeSource[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, MergeSource[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, PendingChange[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, PendingChange[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, PendingSet[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, PendingSet[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, PendingState[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, PendingState[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, PermissionChange[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, PermissionChange[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, PolicyFailureInfo[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, PolicyFailureInfo[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, PropertyValue[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, PropertyValue[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, ProxyInfo[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, ProxyInfo[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, SecurityChange[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, SecurityChange[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, ServerItemLocalVersionUpdate[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, ServerItemLocalVersionUpdate[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, Shelveset[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, Shelveset[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, String[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, String[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, TeamProjectFolderPermission[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, TeamProjectFolderPermission[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, VersionControlLabel[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, VersionControlLabel[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, VersionControlLink[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, VersionControlLink[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, Warning[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, Warning[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, WorkingFolder[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, WorkingFolder[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, WorkspaceItemSet[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, WorkspaceItemSet[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, WorkspaceItem[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, WorkspaceItem[] array, bool inline, bool allowEmptyArrays);
    internal static void ToXml(XmlWriter writer, string arrayName, Workspace[] array);
    internal static void ToXml(XmlWriter writer, string arrayName, Workspace[] array, bool inline, bool allowEmptyArrays);
}
public class Microsoft.TeamFoundation.VersionControl.Client.IdentityDeletedException : VersionControlException {
    public IdentityDeletedException(string message);
    public IdentityDeletedException(string message, Exception ex);
    protected IdentityDeletedException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.IdentityNotFoundException : InvalidIdentityException {
    public IdentityNotFoundException(string message);
    public IdentityNotFoundException(string message, Exception ex);
    protected IdentityNotFoundException(SerializationInfo info, StreamingContext context);
}
public interface Microsoft.TeamFoundation.VersionControl.Client.IDiffItem {
    public bool IsTemporary { get; }
    public string Label { get; public set; }
    public string LabelTag { get; }
    public string LabelFile { get; public set; }
    public abstract virtual string GetFile();
    public abstract virtual int GetEncoding();
    public abstract virtual bool get_IsTemporary();
    public abstract virtual string get_Label();
    public abstract virtual void set_Label(string value);
    public abstract virtual string get_LabelTag();
    public abstract virtual string get_LabelFile();
    public abstract virtual void set_LabelFile(string value);
}
public class Microsoft.TeamFoundation.VersionControl.Client.IllegalCommentException : VersionControlException {
    public IllegalCommentException(string message);
    public IllegalCommentException(string message, Exception ex);
    protected IllegalCommentException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.IllegalComputerNameException : VersionControlException {
    public IllegalComputerNameException(string message);
    public IllegalComputerNameException(string message, Exception ex);
    protected IllegalComputerNameException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.IllegalFieldNameException : VersionControlException {
    public IllegalFieldNameException(string message);
    public IllegalFieldNameException(string message, Exception ex);
    protected IllegalFieldNameException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.IllegalIdentityException : VersionControlException {
    public IllegalIdentityException(string message);
    public IllegalIdentityException(string message, Exception ex);
    protected IllegalIdentityException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.IllegalLabelNameException : VersionControlException {
    public IllegalLabelNameException(string message);
    public IllegalLabelNameException(string message, Exception ex);
    protected IllegalLabelNameException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.IllegalPolicyNameException : VersionControlException {
    public IllegalPolicyNameException(string message);
    public IllegalPolicyNameException(string message, Exception ex);
    protected IllegalPolicyNameException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.IllegalServerItemException : ServerItemException {
    public IllegalServerItemException(string message);
    public IllegalServerItemException(string message, Exception ex);
    protected IllegalServerItemException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.IllegalShelvesetException : VersionControlException {
    public IllegalShelvesetException(string message);
    public IllegalShelvesetException(string message, Exception ex);
    protected IllegalShelvesetException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.IllegalShelvesetOwnerException : VersionControlException {
    public IllegalShelvesetOwnerException(string message);
    public IllegalShelvesetOwnerException(string message, Exception ex);
    protected IllegalShelvesetOwnerException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.IllegalUrlException : VersionControlException {
    public IllegalUrlException(string message);
    public IllegalUrlException(string message, Exception ex);
    protected IllegalUrlException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.IllegalVersionException : VersionControlException {
    public IllegalVersionException(string message);
    public IllegalVersionException(string message, Exception ex);
    protected IllegalVersionException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.IllegalWorkspaceException : VersionControlException {
    public IllegalWorkspaceException(string message);
    public IllegalWorkspaceException(string message, Exception ex);
    protected IllegalWorkspaceException(SerializationInfo info, StreamingContext context);
}
public interface Microsoft.TeamFoundation.VersionControl.Client.ILocalUpdateOperation {
    public ItemType ItemType { get; }
    public int ItemId { get; }
    public int DeletionId { get; }
    public ChangeType ChangeType { get; }
    public int PendingChangeId { get; }
    public string TargetLocalItem { get; }
    public string SourceLocalItem { get; }
    public string TargetServerItem { get; }
    public int VersionServer { get; }
    public int VersionLocal { get; }
    public bool IsDelete { get; }
    public bool IsConflict { get; }
    public bool Ignore { get; public set; }
    public abstract virtual ItemType get_ItemType();
    public abstract virtual int get_ItemId();
    public abstract virtual int get_DeletionId();
    public abstract virtual ChangeType get_ChangeType();
    public abstract virtual int get_PendingChangeId();
    public abstract virtual string get_TargetLocalItem();
    public abstract virtual string get_SourceLocalItem();
    public abstract virtual string get_TargetServerItem();
    public abstract virtual int get_VersionServer();
    public abstract virtual int get_VersionLocal();
    public abstract virtual bool get_IsDelete();
    public abstract virtual bool get_IsConflict();
    public abstract virtual bool get_Ignore();
    public abstract virtual void set_Ignore(bool value);
}
internal interface Microsoft.TeamFoundation.VersionControl.Client.ILocalVersionUpdate {
    public bool SendToServer { get; }
    public string SourceServerItem { get; }
    public int ItemId { get; }
    public string TargetLocalItem { get; }
    public int VersionLocal { get; }
    public bool IsCommitted { get; }
    public abstract virtual bool get_SendToServer();
    public abstract virtual string get_SourceServerItem();
    public abstract virtual int get_ItemId();
    public abstract virtual string get_TargetLocalItem();
    public abstract virtual int get_VersionLocal();
    public abstract virtual bool get_IsCommitted();
}
public class Microsoft.TeamFoundation.VersionControl.Client.IncompatibleChangeException : ServerItemException {
    public IncompatibleChangeException(string message);
    public IncompatibleChangeException(string message, Exception ex);
    protected IncompatibleChangeException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.IncompatibleCompressionFormatException : VersionControlException {
    public IncompatibleCompressionFormatException(string message);
    public IncompatibleCompressionFormatException(string message, Exception ex);
    protected IncompatibleCompressionFormatException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.IncompletePendingChangeException : VersionControlException {
    public IncompletePendingChangeException(string message);
    public IncompletePendingChangeException(string message, Exception ex);
    protected IncompletePendingChangeException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.IncompleteUploadException : VersionControlException {
    public IncompleteUploadException(string message);
    public IncompleteUploadException(string message, Exception ex);
    protected IncompleteUploadException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.InconsistentRequestTypesException : VersionControlException {
    public InconsistentRequestTypesException(string message);
    public InconsistentRequestTypesException(string message, Exception ex);
    protected InconsistentRequestTypesException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.IncorrectSizeException : VersionControlException {
    public IncorrectSizeException(string message);
    public IncorrectSizeException(string message, Exception ex);
    protected IncorrectSizeException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.InheritanceChange : SecurityChange {
    private bool m_inherit;
    public bool Inherit { get; public set; }
    public InheritanceChange(string item, bool inherit);
    public bool get_Inherit();
    public void set_Inherit(bool value);
    [EditorBrowsableAttribute("1")]
public static InheritanceChange FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public virtual void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, InheritanceChange obj);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.InitiallyDeletedLocalVersionUpdate : object {
    private string m_sourceServerItem;
    private int m_itemId;
    private int m_versionLocal;
    private int m_encoding;
    private long m_versionLocalDate;
    private Byte[] m_baselineHashValue;
    private long m_baselineFileLength;
    private Byte[] m_baselineFileGuid;
    private string m_pendingChangeTargetServerItem;
    private string m_downloadUrl;
    private QueryItemsFetchRequest m_queryItemsFetchRequest;
    public bool SendToServer { get; }
    public bool IsCommitted { get; }
    public string SourceServerItem { get; }
    public int ItemId { get; }
    public string TargetLocalItem { get; }
    public int VersionLocal { get; }
    public int Encoding { get; }
    public long VersionLocalDate { get; }
    public Byte[] BaselineHashValue { get; }
    public long BaselineFileLength { get; }
    public Byte[] BaselineFileGuid { get; }
    public string DownloadUrl { get; public set; }
    public string PendingChangeTargetServerItem { get; public set; }
    public QueryItemsFetchRequest QueryItemsFetchRequest { get; public set; }
    public InitiallyDeletedLocalVersionUpdate(string sourceServerItem, int itemId, int versionLocal, DateTime versionLocalDate, int encoding, string pendingChangeTargetServerItem);
    public sealed virtual bool get_SendToServer();
    public sealed virtual bool get_IsCommitted();
    public sealed virtual string get_SourceServerItem();
    public sealed virtual int get_ItemId();
    public sealed virtual string get_TargetLocalItem();
    public sealed virtual int get_VersionLocal();
    public int get_Encoding();
    public long get_VersionLocalDate();
    public sealed virtual Byte[] get_BaselineHashValue();
    public long get_BaselineFileLength();
    public sealed virtual Byte[] get_BaselineFileGuid();
    public sealed virtual string get_DownloadUrl();
    public sealed virtual void set_DownloadUrl(string value);
    public sealed virtual string get_PendingChangeTargetServerItem();
    public sealed virtual void set_PendingChangeTargetServerItem(string value);
    public sealed virtual QueryItemsFetchRequest get_QueryItemsFetchRequest();
    public sealed virtual void set_QueryItemsFetchRequest(QueryItemsFetchRequest value);
    public sealed virtual void Dispose();
    public sealed virtual bool IsFullyPopulated(bool requireVersionLocalDate);
    public sealed virtual void UpdateFrom(Item item);
    public sealed virtual void UpdateFrom(WorkspaceLocalItem lvExisting);
    public sealed virtual void UpdateFrom(PendingChange pendingChange);
    public sealed virtual void UpdateFromPendingAdd(LocalPendingChange pendingAdd);
    public void GenerateNewBaselineFileGuid();
}
internal class Microsoft.TeamFoundation.VersionControl.Client.InternalServerInfo : object {
    private Uri m_uri;
    private Guid m_guid;
    internal Uri Uri { get; internal set; }
    internal Guid ServerGuid { get; }
    internal InternalServerInfo(Uri uri, Guid guid);
    internal Uri get_Uri();
    internal void set_Uri(Uri value);
    internal Guid get_ServerGuid();
}
internal class Microsoft.TeamFoundation.VersionControl.Client.InternalWorkspaceConflictInfo : object {
    public WorkspaceInfo PrimaryWorkspace;
    public WorkspaceInfo SecondaryWorkspace;
    public string ConflictingPath;
    public InternalWorkspaceConflictInfo(WorkspaceInfo primary, WorkspaceInfo secondary, string conflictingPath);
    public string FormatWarning();
}
public class Microsoft.TeamFoundation.VersionControl.Client.InvalidAcceptYoursException : VersionControlException {
    public InvalidAcceptYoursException(string message);
    public InvalidAcceptYoursException(string message, Exception ex);
    protected InvalidAcceptYoursException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.InvalidAcceptYoursRenameTheirsException : VersionControlException {
    public InvalidAcceptYoursRenameTheirsException(string message);
    public InvalidAcceptYoursRenameTheirsException(string message, Exception ex);
    protected InvalidAcceptYoursRenameTheirsException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.InvalidBranchCheckinOptionException : VersionControlException {
    public InvalidBranchCheckinOptionException(string message);
    public InvalidBranchCheckinOptionException(string message, Exception ex);
    protected InvalidBranchCheckinOptionException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.InvalidCheckinDateException : VersionControlException {
    public InvalidCheckinDateException(string message);
    public InvalidCheckinDateException(string message, Exception ex);
    protected InvalidCheckinDateException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.InvalidCheckinTicketException : VersionControlException {
    public InvalidCheckinTicketException(string message);
    public InvalidCheckinTicketException(string message, Exception ex);
    protected InvalidCheckinTicketException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.InvalidConflictIdException : VersionControlException {
    public InvalidConflictIdException(string message);
    public InvalidConflictIdException(string message, Exception ex);
    protected InvalidConflictIdException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.InvalidExtensionException : VersionControlException {
    public InvalidExtensionException(string message);
    public InvalidExtensionException(string message, Exception ex);
    protected InvalidExtensionException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.InvalidFileIdException : VersionControlException {
    public InvalidFileIdException(string message);
    public InvalidFileIdException(string message, Exception ex);
    protected InvalidFileIdException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.InvalidFileTypeException : VersionControlException {
    public InvalidFileTypeException(string type);
    public InvalidFileTypeException(string type, Exception innerException);
    protected InvalidFileTypeException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.InvalidIdentityException : SecurityException {
    public InvalidIdentityException(string message);
    public InvalidIdentityException(string message, Exception ex);
    protected InvalidIdentityException(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.InvalidPendingChangeTableException : Exception {
    public InvalidPendingChangeTableException(Exception innerException);
}
public class Microsoft.TeamFoundation.VersionControl.Client.InvalidProjectPendingChangeException : ServerItemException {
    public InvalidProjectPendingChangeException(string message);
    public InvalidProjectPendingChangeException(string message, Exception ex);
    protected InvalidProjectPendingChangeException(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.InvalidQueuedEditsTableException : Exception {
    public InvalidQueuedEditsTableException(Exception innerException);
}
public class Microsoft.TeamFoundation.VersionControl.Client.InvalidResolutionException : VersionControlException {
    public InvalidResolutionException(string message);
    public InvalidResolutionException(string message, Exception ex);
    protected InvalidResolutionException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.InvalidSqlDateException : VersionControlException {
    public InvalidSqlDateException(string message);
    public InvalidSqlDateException(string message, Exception ex);
    protected InvalidSqlDateException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.InvalidVersionSpecException : VersionControlException {
    public InvalidVersionSpecException(string message);
    public InvalidVersionSpecException(string message, Exception ex);
    protected InvalidVersionSpecException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.InvalidVersionSpecForOperationException : VersionControlException {
    public InvalidVersionSpecForOperationException(string message);
    public InvalidVersionSpecForOperationException(string message, Exception ex);
    protected InvalidVersionSpecForOperationException(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.InvalidWorkspacePropertiesTableException : Exception {
    public InvalidWorkspacePropertiesTableException(Exception innerException);
}
internal interface Microsoft.TeamFoundation.VersionControl.Client.IPathChangedSink {
    public abstract virtual void PathChanged(PathWatcher sender);
}
public interface Microsoft.TeamFoundation.VersionControl.Client.IPendingChangeEventArgs {
    public Workspace Workspace { get; }
    public PendingChange PendingChange { get; }
    public bool IsLatest { get; }
    public OperationStatus Status { get; }
    public bool DiskUpdateAttempted { get; }
    public int OperationId { get; }
    public abstract virtual Workspace get_Workspace();
    public abstract virtual PendingChange get_PendingChange();
    public abstract virtual bool get_IsLatest();
    public abstract virtual OperationStatus get_Status();
    public abstract virtual bool get_DiskUpdateAttempted();
    public abstract virtual int get_OperationId();
}
public interface Microsoft.TeamFoundation.VersionControl.Client.IPendingCheckin {
    public IPendingCheckinPendingChanges PendingChanges { get; }
    public IPendingCheckinWorkItems WorkItems { get; }
    public IPendingCheckinNotes CheckinNotes { get; }
    public IPendingCheckinPolicies Policies { get; }
    public abstract virtual IPendingCheckinPendingChanges get_PendingChanges();
    public abstract virtual IPendingCheckinWorkItems get_WorkItems();
    public abstract virtual IPendingCheckinNotes get_CheckinNotes();
    public abstract virtual IPendingCheckinPolicies get_Policies();
}
public interface Microsoft.TeamFoundation.VersionControl.Client.IPendingCheckinNotes {
    public CheckinNote CheckinNotes { get; public set; }
    public CheckinNoteFieldDefinition[] FieldDefinitions { get; }
    public abstract virtual CheckinNoteFailure[] Evaluate();
    public abstract virtual CheckinNote get_CheckinNotes();
    public abstract virtual void set_CheckinNotes(CheckinNote value);
    public abstract virtual CheckinNoteFieldDefinition[] get_FieldDefinitions();
}
public interface Microsoft.TeamFoundation.VersionControl.Client.IPendingCheckinPendingChanges {
    public Workspace Workspace { get; }
    public string Comment { get; public set; }
    public PendingChange[] CheckedPendingChanges { get; public set; }
    public PendingChange[] AllPendingChanges { get; }
    public String[] AffectedTeamProjectPaths { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_CheckedPendingChangesChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CheckedPendingChangesChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_AffectedTeamProjectsChanged(AffectedTeamProjectsEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_AffectedTeamProjectsChanged(AffectedTeamProjectsEventHandler value);
    public abstract virtual Workspace get_Workspace();
    public abstract virtual string get_Comment();
    public abstract virtual void set_Comment(string value);
    public abstract virtual PendingChange[] get_CheckedPendingChanges();
    public abstract virtual void set_CheckedPendingChanges(PendingChange[] value);
    public abstract virtual PendingChange[] get_AllPendingChanges();
    public abstract virtual String[] get_AffectedTeamProjectPaths();
}
public interface Microsoft.TeamFoundation.VersionControl.Client.IPendingCheckinPolicies {
    public PolicyEvaluationState EvaluationState { get; }
    public abstract virtual PolicyFailure[] Evaluate();
    public abstract virtual PolicyEvaluationState get_EvaluationState();
}
public interface Microsoft.TeamFoundation.VersionControl.Client.IPendingCheckinWorkItems {
    public WorkItemCheckinInfo[] CheckedWorkItems { get; public set; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_CheckedWorkItemsChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CheckedWorkItemsChanged(EventHandler value);
    public abstract virtual WorkItemCheckinInfo[] get_CheckedWorkItems();
    public abstract virtual void set_CheckedWorkItems(WorkItemCheckinInfo[] value);
}
public interface Microsoft.TeamFoundation.VersionControl.Client.IPolicyCompatibility {
    public abstract virtual BinaryFormatter GetBinaryFormatter();
    public abstract virtual string GetAssemblyName();
}
public interface Microsoft.TeamFoundation.VersionControl.Client.IPolicyDefinition {
    public string Type { get; }
    public string TypeDescription { get; }
    public string Description { get; }
    public string InstallationInstructions { get; }
    public bool CanEdit { get; }
    public abstract virtual string get_Type();
    public abstract virtual string get_TypeDescription();
    public abstract virtual string get_Description();
    public abstract virtual string get_InstallationInstructions();
    public abstract virtual bool get_CanEdit();
    public abstract virtual bool Edit(IPolicyEditArgs policyEditArgs);
}
public interface Microsoft.TeamFoundation.VersionControl.Client.IPolicyEditArgs {
    public bool IsNew { get; }
    public TeamProject TeamProject { get; }
    public IWin32Window Parent { get; }
    public abstract virtual bool get_IsNew();
    public abstract virtual TeamProject get_TeamProject();
    public abstract virtual IWin32Window get_Parent();
}
public interface Microsoft.TeamFoundation.VersionControl.Client.IPolicyEvaluation {
    public abstract virtual void Initialize(IPendingCheckin pendingCheckin);
    public abstract virtual PolicyFailure[] Evaluate();
    public abstract virtual void Activate(PolicyFailure failure);
    public abstract virtual void DisplayHelp(PolicyFailure failure);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PolicyStateChanged(PolicyStateChangedHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PolicyStateChanged(PolicyStateChangedHandler value);
}
internal interface Microsoft.TeamFoundation.VersionControl.Client.IPopulatableLocalVersionUpdate {
    public Byte[] BaselineFileGuid { get; }
    public Byte[] BaselineHashValue { get; }
    public string DownloadUrl { get; public set; }
    public string PendingChangeTargetServerItem { get; public set; }
    public QueryItemsFetchRequest QueryItemsFetchRequest { get; public set; }
    public abstract virtual Byte[] get_BaselineFileGuid();
    public abstract virtual Byte[] get_BaselineHashValue();
    public abstract virtual string get_DownloadUrl();
    public abstract virtual void set_DownloadUrl(string value);
    public abstract virtual string get_PendingChangeTargetServerItem();
    public abstract virtual void set_PendingChangeTargetServerItem(string value);
    public abstract virtual QueryItemsFetchRequest get_QueryItemsFetchRequest();
    public abstract virtual void set_QueryItemsFetchRequest(QueryItemsFetchRequest value);
    public abstract virtual bool IsFullyPopulated(bool requireVersionLocalDate);
    public abstract virtual void UpdateFrom(Item item);
    public abstract virtual void UpdateFrom(WorkspaceLocalItem lvExisting);
    public abstract virtual void UpdateFrom(PendingChange pendingChange);
    public abstract virtual void UpdateFromPendingAdd(LocalPendingChange pendingAdd);
}
internal interface Microsoft.TeamFoundation.VersionControl.Client.ISourceControlSecurityNamespaceProvider {
    public int ValidPermissions { get; }
    public Type PermissionsEnumType { get; }
    public SecurityNamespaceDescription SecurityNamespaceDescription { get; }
    public abstract virtual int get_ValidPermissions();
    public abstract virtual Type get_PermissionsEnumType();
    public abstract virtual SecurityNamespaceDescription get_SecurityNamespaceDescription();
    public abstract virtual String[] GetEffectivePermissions(string identityName, string item);
    public abstract virtual ItemSecurity[] GetPermissions(String[] identities, String[] items, RecursionType recursionType);
    public abstract virtual void SetPermissions(SecurityChange[] securityChanges);
}
public class Microsoft.TeamFoundation.VersionControl.Client.Item : object {
    private VersionControlServer m_sourceControl;
    private DownloadUrl m_downloadUrlObj;
    private static ItemComparer m_comparer;
    protected int m_changesetId;
    protected DateTime m_checkinDate;
    protected long m_contentLength;
    protected int m_deletionId;
    protected string m_downloadUrl;
    protected int m_encoding;
    internal Byte[] m_hashValue;
    internal PropertyValue[] m_internalAttributes;
    internal PropertyValue[] m_internalPropertyValues;
    protected bool m_isBranch;
    protected int m_itemId;
    protected ItemType m_itemType;
    protected string m_serverItem;
    protected string m_timeZone;
    protected string m_timeZoneOffset;
    public Uri ArtifactUri { get; }
    public Uri ArtifactUriLatestItemVersion { get; }
    public VersionControlServer VersionControlServer { get; internal set; }
    public bool IsContentDestroyed { get; }
    public static IComparer Comparer { get; }
    [EditorBrowsableAttribute("1")]
public string DownloadUrl { get; }
    [XmlIgnoreAttribute]
[ObsoleteAttribute("Please use the Attributes property instead.")]
public ReadOnlyCollection`1<PropertyValue> Properties { get; }
    [XmlIgnoreAttribute]
public ReadOnlyCollection`1<PropertyValue> Attributes { get; }
    [XmlIgnoreAttribute]
public ReadOnlyCollection`1<PropertyValue> PropertyValues { get; }
    public int ChangesetId { get; }
    public DateTime CheckinDate { get; }
    public long ContentLength { get; }
    public int DeletionId { get; }
    public int Encoding { get; }
    public Byte[] HashValue { get; }
    internal PropertyValue[] InternalAttributes { get; internal set; }
    internal PropertyValue[] InternalPropertyValues { get; internal set; }
    public bool IsBranch { get; }
    public int ItemId { get; }
    public ItemType ItemType { get; }
    public string ServerItem { get; }
    [EditorBrowsableAttribute("1")]
public Item(VersionControlServer sourceControl, ItemType itemType, string serverItem);
    internal Item(VersionControlServer sourceControl, ItemType itemType, string serverItem, int encoding);
    public Stream DownloadFile();
    public void DownloadFile(string localFileName);
    public Uri get_ArtifactUri();
    public Uri get_ArtifactUriLatestItemVersion();
    public VersionControlServer get_VersionControlServer();
    internal void set_VersionControlServer(VersionControlServer value);
    public bool get_IsContentDestroyed();
    private void PrepareForDownload();
    public static IComparer get_Comparer();
    private void AfterDeserialize();
    public string get_DownloadUrl();
    private void CloneDownloadUrlFromItem(Item item);
    public ReadOnlyCollection`1<PropertyValue> get_Properties();
    public ReadOnlyCollection`1<PropertyValue> get_Attributes();
    public ReadOnlyCollection`1<PropertyValue> get_PropertyValues();
    public int get_ChangesetId();
    public DateTime get_CheckinDate();
    public long get_ContentLength();
    public int get_DeletionId();
    public int get_Encoding();
    public Byte[] get_HashValue();
    internal PropertyValue[] get_InternalAttributes();
    internal void set_InternalAttributes(PropertyValue[] value);
    internal PropertyValue[] get_InternalPropertyValues();
    internal void set_InternalPropertyValues(PropertyValue[] value);
    public bool get_IsBranch();
    public int get_ItemId();
    public ItemType get_ItemType();
    public string get_ServerItem();
    [EditorBrowsableAttribute("1")]
public static Item FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public virtual void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, Item obj);
}
public class Microsoft.TeamFoundation.VersionControl.Client.ItemCloakedException : MappingException {
    public ItemCloakedException(string message);
    public ItemCloakedException(string message, Exception ex);
    protected ItemCloakedException(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.ItemComparer : object {
    private sealed virtual override int System.Collections.IComparer.Compare(object x, object y);
}
public class Microsoft.TeamFoundation.VersionControl.Client.ItemDeletedException : ServerItemException {
    public ItemDeletedException(string message);
    public ItemDeletedException(string message, Exception ex);
    protected ItemDeletedException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.ItemExistsException : ServerItemException {
    public ItemExistsException(string message);
    public ItemExistsException(string message, Exception ex);
    protected ItemExistsException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.ItemIdentifier : object {
    private int m_changeTypeEx;
    private int m_deletionId;
    private string m_item;
    private VersionSpec m_version;
    public ChangeType ChangeType { get; }
    public int DeletionId { get; }
    public bool IsDeleted { get; }
    public string Item { get; public set; }
    public VersionSpec Version { get; public set; }
    public ItemIdentifier(string item);
    public ItemIdentifier(string item, VersionSpec version);
    public ItemIdentifier(string item, VersionSpec version, int deletionId);
    public ItemIdentifier(Change change);
    public bool Equals(ItemIdentifier id);
    public ChangeType get_ChangeType();
    public int get_DeletionId();
    public bool get_IsDeleted();
    public string get_Item();
    public void set_Item(string value);
    public VersionSpec get_Version();
    public void set_Version(VersionSpec value);
    [EditorBrowsableAttribute("1")]
public static ItemIdentifier FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, ItemIdentifier obj);
}
public class Microsoft.TeamFoundation.VersionControl.Client.ItemLockedException : ServerItemException {
    public ItemLockedException(string message);
    public ItemLockedException(string message, Exception ex);
    protected ItemLockedException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.ItemMerge : object {
    private int m_sourceItemId;
    private string m_sourceServerItem;
    private int m_sourceVersionFrom;
    private int m_targetItemId;
    private string m_targetServerItem;
    private int m_targetVersionFrom;
    public int SourceItemId { get; }
    public string SourceServerItem { get; }
    public int SourceVersionFrom { get; }
    public int TargetItemId { get; }
    public string TargetServerItem { get; }
    public int TargetVersionFrom { get; }
    public int get_SourceItemId();
    public string get_SourceServerItem();
    public int get_SourceVersionFrom();
    public int get_TargetItemId();
    public string get_TargetServerItem();
    public int get_TargetVersionFrom();
    [EditorBrowsableAttribute("1")]
public static ItemMerge FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, ItemMerge obj);
}
public class Microsoft.TeamFoundation.VersionControl.Client.ItemNotCheckedOutException : ServerItemException {
    public ItemNotCheckedOutException(string message);
    public ItemNotCheckedOutException(string message, Exception ex);
    protected ItemNotCheckedOutException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.ItemNotFoundException : ServerItemException {
    public ItemNotFoundException(string message);
    public ItemNotFoundException(string message, Exception ex);
    protected ItemNotFoundException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.ItemNotMappedException : MappingException {
    public ItemNotMappedException(string message);
    public ItemNotMappedException(string message, Exception ex);
    protected ItemNotMappedException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.ItemProperties : object {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyValue[] <Properties>k__BackingField;
    public string Path { get; public set; }
    public PropertyValue[] Properties { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public PropertyValue[] get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(PropertyValue[] value);
}
public class Microsoft.TeamFoundation.VersionControl.Client.ItemRequiredException : VersionControlException {
    public ItemRequiredException(string message);
    public ItemRequiredException(string message, Exception ex);
    protected ItemRequiredException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.ItemSecurity : object {
    internal AccessEntry[] m_entries;
    private bool m_inherit;
    private string m_serverItem;
    private bool m_writable;
    public AccessEntry[] Entries { get; public set; }
    public bool Inherit { get; public set; }
    public string ServerItem { get; public set; }
    public bool Writable { get; public set; }
    internal ItemSecurity(string serverItem, bool inherit, bool writable, AccessEntry[] accessEntries);
    public AccessEntry[] get_Entries();
    public void set_Entries(AccessEntry[] value);
    public bool get_Inherit();
    public void set_Inherit(bool value);
    public string get_ServerItem();
    public void set_ServerItem(string value);
    public bool get_Writable();
    public void set_Writable(bool value);
    [EditorBrowsableAttribute("1")]
public static ItemSecurity FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, ItemSecurity obj);
}
public class Microsoft.TeamFoundation.VersionControl.Client.ItemSet : object {
    internal Item[] m_items;
    private string m_pattern;
    private string m_queryPath;
    public Item[] Items { get; }
    public string Pattern { get; }
    public string QueryPath { get; }
    public Item[] get_Items();
    public string get_Pattern();
    public string get_QueryPath();
    [EditorBrowsableAttribute("1")]
public static ItemSet FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, ItemSet obj);
}
public class Microsoft.TeamFoundation.VersionControl.Client.ItemSpec : object {
    private int m_deletionId;
    private string m_item;
    private RecursionType m_recursionType;
    public int DeletionId { get; public set; }
    public string Item { get; public set; }
    public RecursionType RecursionType { get; public set; }
    public ItemSpec(string item, RecursionType recursionType);
    public ItemSpec(string item, RecursionType recursionType, int deletionId);
    public ItemSpec(PendingChange pendingChange);
    public static ItemSpec[] FromStrings(String[] paths, RecursionType recursion);
    public static String[] ToStrings(ItemSpec[] itemSpecs);
    public static ItemSpec[] FromPendingChanges(PendingChange[] pendingChanges);
    public int get_DeletionId();
    public void set_DeletionId(int value);
    public string get_Item();
    public void set_Item(string value);
    public RecursionType get_RecursionType();
    public void set_RecursionType(RecursionType value);
    [EditorBrowsableAttribute("1")]
public static ItemSpec FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, ItemSpec obj);
}
public enum Microsoft.TeamFoundation.VersionControl.Client.ItemType : Enum {
    public int value__;
    public static ItemType Any;
    public static ItemType File;
    public static ItemType Folder;
}
[EditorBrowsableAttribute("1")]
public interface Microsoft.TeamFoundation.VersionControl.Client.IToolExecutionFallBackResult {
    public ThirdPartyToolDefinition Tool { get; }
    public abstract virtual ThirdPartyToolDefinition get_Tool();
}
public interface Microsoft.TeamFoundation.VersionControl.Client.IToolExecutionResult {
    public int Id { get; }
    public string Name { get; }
    public bool HasExited { get; }
    public int ExitCode { get; }
    public string ExitMessage { get; }
    public bool PromptUserForMergeConfirmation { get; }
    public abstract virtual int get_Id();
    public abstract virtual string get_Name();
    public abstract virtual bool get_HasExited();
    public abstract virtual int get_ExitCode();
    public abstract virtual string get_ExitMessage();
    public abstract virtual bool get_PromptUserForMergeConfirmation();
    public abstract virtual void WaitForOperationEnd();
    public abstract virtual void Cancel();
}
public interface Microsoft.TeamFoundation.VersionControl.Client.IToolProvider {
    public string Extension { get; }
    public ToolOperations Operation { get; }
    public bool CanOperateOnInMemoryFiles { get; }
    public abstract virtual string get_Extension();
    public abstract virtual ToolOperations get_Operation();
    public abstract virtual bool get_CanOperateOnInMemoryFiles();
    public abstract virtual IToolExecutionResult Execute(EventHandler exitHandler, AdvancedToolParameters advancedParameters, String[] arguments);
}
internal interface Microsoft.TeamFoundation.VersionControl.Client.IWorkspaceDiffItem {
    public string LocalItem { get; }
    public int VersionLocal { get; }
    public ItemType ItemType { get; }
    public ChangeType ChangeType { get; }
    public long ContentLength { get; }
    public Byte[] HashValue { get; }
    public abstract virtual string get_LocalItem();
    public abstract virtual int get_VersionLocal();
    public abstract virtual ItemType get_ItemType();
    public abstract virtual ChangeType get_ChangeType();
    public abstract virtual long get_ContentLength();
    public abstract virtual Byte[] get_HashValue();
}
public enum Microsoft.TeamFoundation.VersionControl.Client.LabelChildOption : Enum {
    public int value__;
    public static LabelChildOption Fail;
    public static LabelChildOption Merge;
    public static LabelChildOption Replace;
}
public class Microsoft.TeamFoundation.VersionControl.Client.LabelDuplicateItemException : ServerItemException {
    public LabelDuplicateItemException(string message);
    public LabelDuplicateItemException(string message, Exception ex);
    protected LabelDuplicateItemException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.LabelExistsException : VersionControlException {
    public LabelExistsException(string message);
    public LabelExistsException(string message, Exception ex);
    protected LabelExistsException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.LabelHasChildrenException : VersionControlException {
    public LabelHasChildrenException(string message);
    public LabelHasChildrenException(string message, Exception ex);
    protected LabelHasChildrenException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.LabelItemSpec : object {
    private bool m_exclude;
    private ItemSpec m_itemSpec;
    private VersionSpec m_version;
    public bool Exclude { get; public set; }
    public ItemSpec ItemSpec { get; public set; }
    public VersionSpec Version { get; public set; }
    public LabelItemSpec(ItemSpec itemSpec, VersionSpec version, bool exclude);
    public bool get_Exclude();
    public void set_Exclude(bool value);
    public ItemSpec get_ItemSpec();
    public void set_ItemSpec(ItemSpec value);
    public VersionSpec get_Version();
    public void set_Version(VersionSpec value);
    [EditorBrowsableAttribute("1")]
public static LabelItemSpec FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, LabelItemSpec obj);
}
public class Microsoft.TeamFoundation.VersionControl.Client.LabelNotFoundException : VersionControlException {
    public LabelNotFoundException(string message);
    public LabelNotFoundException(string message, Exception ex);
    protected LabelNotFoundException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.LabelNotUniqueException : VersionControlException {
    public LabelNotUniqueException(string message);
    public LabelNotUniqueException(string message, Exception ex);
    protected LabelNotUniqueException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.LabelOwnerChangeException : VersionControlException {
    public LabelOwnerChangeException(string message);
    public LabelOwnerChangeException(string message, Exception ex);
    protected LabelOwnerChangeException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.LabelPendingAddException : ServerItemException {
    public LabelPendingAddException(string message);
    public LabelPendingAddException(string message, Exception ex);
    protected LabelPendingAddException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.LabelResult : object {
    private string m_label;
    private string m_scope;
    private LabelResultStatus m_status;
    public string Label { get; }
    public string Scope { get; }
    public LabelResultStatus Status { get; }
    public string get_Label();
    public string get_Scope();
    public LabelResultStatus get_Status();
    [EditorBrowsableAttribute("1")]
public static LabelResult FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, LabelResult obj);
}
public enum Microsoft.TeamFoundation.VersionControl.Client.LabelResultStatus : Enum {
    public int value__;
    public static LabelResultStatus Created;
    public static LabelResultStatus Deleted;
    public static LabelResultStatus Updated;
}
public class Microsoft.TeamFoundation.VersionControl.Client.LabelVersionSpec : VersionSpec {
    private string m_label;
    private string m_scope;
    public static char Identifier;
    public string Label { get; public set; }
    public string Scope { get; public set; }
    public LabelVersionSpec(string label);
    public LabelVersionSpec(string label, string scope);
    private static LabelVersionSpec();
    public string get_Label();
    public void set_Label(string value);
    public string get_Scope();
    public void set_Scope(string value);
    [EditorBrowsableAttribute("1")]
public static LabelVersionSpec FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public virtual void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, LabelVersionSpec obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public virtual string ComputeVersionString();
}
public class Microsoft.TeamFoundation.VersionControl.Client.LatestVersionDeletedException : ServerItemException {
    public LatestVersionDeletedException(string message);
    public LatestVersionDeletedException(string message, Exception ex);
    protected LatestVersionDeletedException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.LatestVersionSpec : VersionSpec {
    private static LatestVersionSpec m_instance;
    public static char Identifier;
    public static LatestVersionSpec Instance { get; }
    private static LatestVersionSpec();
    [EditorBrowsableAttribute("1")]
public static LatestVersionSpec FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public virtual void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, LatestVersionSpec obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public virtual string ComputeVersionString();
    public static LatestVersionSpec get_Instance();
}
public class Microsoft.TeamFoundation.VersionControl.Client.LoadFailurePolicyType : PolicyType {
    internal LoadFailurePolicyType(string name, string description);
    public virtual IPolicyDefinition New();
}
internal class Microsoft.TeamFoundation.VersionControl.Client.LocalBaselineAsyncOperation : AsyncOperation {
    private BaselineFolderCollection m_baselineFolderCollection;
    private LocalBaselineRequestProgressEventHandler m_callback;
    private List`1<BaselineRequest> m_failedRequests;
    public BaselineFolderCollection BaselineFolderCollection { get; }
    public LocalBaselineRequestProgressEventHandler Callback { get; }
    public IList`1<BaselineRequest> FailedRequests { get; }
    public LocalBaselineAsyncOperation(BaselineFolderCollection baselineFolderCollection, LocalBaselineRequestProgressEventHandler callback);
    public BaselineFolderCollection get_BaselineFolderCollection();
    public LocalBaselineRequestProgressEventHandler get_Callback();
    public IList`1<BaselineRequest> get_FailedRequests();
}
internal class Microsoft.TeamFoundation.VersionControl.Client.LocalBaselineRequestProgressEventArgs : EventArgs {
    private string m_fileName;
    public string FileName { get; }
    public LocalBaselineRequestProgressEventArgs(string fileName);
    public string get_FileName();
}
internal class Microsoft.TeamFoundation.VersionControl.Client.LocalBaselineRequestProgressEventHandler : MulticastDelegate {
    public LocalBaselineRequestProgressEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, LocalBaselineRequestProgressEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, LocalBaselineRequestProgressEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.LocalBaselineRequestState : object {
    private LocalBaselineAsyncOperation m_asyncOp;
    private BaselineRequest m_request;
    public LocalBaselineRequestState(LocalBaselineAsyncOperation asyncOp, BaselineRequest request);
    public static void CompleteRequest(object param);
    public void CompleteRequest();
}
[ExtensionAttribute]
internal static class Microsoft.TeamFoundation.VersionControl.Client.LocalDataAccessLayer : object {
    private static ChangeType c_pendDeleteConflictingChangeTypes;
    public static void SnapBackToCheckinDate(Workspace workspace, IEnumerable`1<GetRequest> requests);
    public static void AfterAdd(Workspace workspace, GetOperation[] getOperations);
    public static void AfterCheckin(Workspace workspace, int changesetId, DateTime checkinDate, GetOperation[] localVersionUpdates, PendingChange[] newPendingChanges, UploadedBaselinesCollection uploadedBaselinesCollection);
    public static GetOperation[] PendAdd(Workspace workspace, LocalWorkspaceProperties wp, WorkspaceVersionTable lv, LocalPendingChangesTable pc, ChangeRequest[] changeRequests, bool silent, Failure[]& failures);
    public static GetOperation[] PendDelete(Workspace workspace, LocalWorkspaceProperties wp, WorkspaceVersionTable lv, LocalPendingChangesTable pc, ChangeRequest[] changeRequests, bool silent, Failure[]& failures);
    [ExtensionAttribute]
private static IEnumerable`1<WorkspaceLocalItem> ExpandRootsFrom(ParsedItemSpec parsedItemSpec, WorkspaceVersionTable lv, LocalPendingChangesTable pc, ICollection`1<Failure> failuresAccumulator);
    public static GetOperation[] PendEdit(Workspace workspace, LocalWorkspaceProperties wp, WorkspaceVersionTable lv, LocalPendingChangesTable pc, ChangeRequest[] changeRequests, bool silent, Failure[]& failures);
    public static GetOperation[] PendRename(Workspace workspace, LocalWorkspaceProperties wp, WorkspaceVersionTable lv, LocalPendingChangesTable pc, ChangeRequest[] changeRequests, bool silent, Failure[]& failures, Boolean& onlineOperationRequired);
    private static string TryGetServerItem(string item, LocalWorkspaceProperties wp, WorkspaceVersionTable lv, LocalPendingChangesTable pc);
    private static string CalculateTargetServerItem(Workspace workspace, LocalWorkspaceProperties wp, string sourceServerRoot, string sourceServerItem, string targetServerRoot, bool targetIsFolder, bool rootIsRenamed);
    private static bool IsDirectory(WorkspaceVersionTable lv, LocalPendingChangesTable pc, string targetServerItem);
    private static bool IsMove(string committedTargetServerItem, ItemType specifiedType, WorkspaceVersionTable lv);
    private static void ProcessProjectRenames(Workspace workspace, WebServiceLayer webServiceLayer, IEnumerable`1<KeyValuePair`2<string, string>> serverRenames, int newProjectRevisionId);
    private static string CreateProjectName(int length, ISet`1<string> extantNames);
    private static string MapServerItem(string serverItem, IDictionary`2<string, string> projectRenames);
    [IteratorStateMachineAttribute("Microsoft.TeamFoundation.VersionControl.Client.LocalDataAccessLayer/<GetCurrentProjectNames>d__16")]
private static IEnumerable`1<string> GetCurrentProjectNames(LocalWorkspaceProperties wp, WorkspaceVersionTable lv, LocalPendingChangesTable pc);
    private static IEnumerable`1<string> GetCurrentServerItems(LocalWorkspaceProperties wp, WorkspaceVersionTable lv, LocalPendingChangesTable pc);
    public static ExtendedItem[][] QueryItemsExtended(Workspace workspace, ItemSpec[] items, DeletedState deletedState, ItemType itemType, GetItemsOptions options);
    public static LocalVersion[][] QueryLocalVersions(Workspace workspace, ItemSpec[] itemSpecs);
    public static PendingSet[] QueryPendingChanges(Workspace workspace, ItemSpec[] itemSpecs, Failure[]& failures, bool includeCandidates, string lastChange, int pageSize);
    private static IEnumerable`1<LocalPendingChange> QueryPendingChanges(Workspace workspace, LocalWorkspaceProperties wp, WorkspaceVersionTable lv, LocalPendingChangesTable pc, ItemSpec[] itemSpecs, ICollection`1<Failure> failuresAccumulator, bool includeCandidates);
    public static bool ReconcileLocalWorkspace(Workspace workspace, WebServiceLayer webServiceLayer, bool unscannedReconcile, bool reconcileMissingFromDisk, Failure[]& failures, Boolean& pendingChangesUpdatedByServer);
    private static bool ReconcileLocalWorkspaceHelper(Workspace workspace, WebServiceLayer webServiceLayer, bool unscannedReconcile, bool reconcileMissingFromDisk, Failure[]& failures, Boolean& pendingChangesUpdatedByServer);
    public static void SyncPendingChanges(Workspace workspace, GetOperation[] getOperations);
    public static void MarkReadOnlyBit(Workspace workspace, bool setReadOnly);
    public static String[] GetBaselineFolders(Workspace workspace);
    public static IList`1<BaselineRequest> PopulateLocalVersionTable(Workspace workspace, IEnumerable`1<WorkspaceItem> workspaceItems);
    public static void ProcessConversionBaselineRequests(Workspace workspace, LocalBaselineRequestProgressEventHandler callback, IEnumerable`1<BaselineRequest> requests);
    public static GetOperation[] UndoPendingChanges(Workspace workspace, LocalWorkspaceProperties wp, WorkspaceVersionTable lv, LocalPendingChangesTable pc, ItemSpec[] itemSpecs, Failure[]& failures, Boolean& onlineOperationRequired);
    public static GetOperation[] UndoPendingChanges(Workspace workspace, LocalWorkspaceProperties wp, WorkspaceVersionTable lv, LocalPendingChangesTable pc, IEnumerable`1<LocalPendingChange> pendingChanges, ChangeType selectiveUndo, Failure[]& failures, Boolean& onlineOperationRequired);
    public static void UpdateLocalVersion(Workspace workspace, LocalWorkspaceProperties wp, WorkspaceVersionTable lv, LocalPendingChangesTable pc, ILocalVersionUpdate[] localVersionUpdates, HashSet`1<Byte[]> persistedDisplacedBaselines, IPopulatableLocalVersionUpdate[]& updatesMissingBaselines);
    private static void HandleMoveUncommittedUpdate(LocalWorkspaceProperties wp, WorkspaceVersionTable lv, MoveUncommittedLocalVersionUpdate update);
    private static bool HandleInitiallyDeletedLocalVersionUpdate(LocalWorkspaceProperties wp, WorkspaceVersionTable lv, LocalPendingChangesTable pc, InitiallyDeletedLocalVersionUpdate update, bool setFileTimeToCheckin, HashSet`1<Byte[]> displacedBaselines);
    private static bool HandleClientLocalVersionUpdate(LocalWorkspaceProperties wp, WorkspaceVersionTable lv, LocalPendingChangesTable pc, ClientLocalVersionUpdate update, bool setFileTimeToCheckin, HashSet`1<Byte[]> displacedBaselines);
    public static void AcknowledgeUpdateLocalVersion(WorkspaceVersionTable lv, IEnumerable`1<ILocalVersionUpdate> updates);
    public static WorkingFolder[] QueryWorkingFolders(Workspace workspace);
    public static void SetWorkingFolders(Workspace workspace, WorkingFolder[] workingFolders);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.LocalItemEnumerator : object {
    private string m_startPath;
    private RecursionType m_recursion;
    private bool m_enumerateHiddenAndSystem;
    private HashSet`1<string> m_excludedFileNames;
    private HashSet`1<ParentPathChildItem> m_excludedPaths;
    private object m_tag;
    private bool m_enumeratedRoot;
    private IntPtr m_findData;
    private StringBuilder m_stringBuilder;
    private SafeFindHandle m_findHandle;
    private DirectoryFindState m_currentState;
    private EnumeratedLocalItem m_currentLocalItem;
    private Stack`1<DirectoryFindState> m_stateStack;
    private static string c_Dot;
    private static string c_DotDot;
    private static String[] s_excludedFileNames;
    private static UInt32 s_dwAdditionalFlags;
    private static FINDEX_INFO_LEVELS s_infoLevel;
    public object Current { get; }
    public string StartPath { get; }
    public object Tag { get; }
    private EnumeratedLocalItem System.Collections.Generic.IEnumerator<Microsoft.TeamFoundation.VersionControl.Client.EnumeratedLocalItem>.Current { get; }
    private static LocalItemEnumerator();
    public LocalItemEnumerator(string path, RecursionType recursion, bool enumerateHiddenAndSystem, ICollection`1<string> excludedPaths);
    public LocalItemEnumerator(string path, RecursionType recursion, bool enumerateHiddenAndSystem, ICollection`1<string> excludedPaths, ICollection`1<string> excludedFileNames, object tag);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<EnumeratedLocalItem> System.Collections.Generic.IEnumerable<Microsoft.TeamFoundation.VersionControl.Client.EnumeratedLocalItem>.GetEnumerator();
    public sealed virtual object get_Current();
    public string get_StartPath();
    public object get_Tag();
    public void AddExcludedPath(string localItem);
    private sealed virtual override EnumeratedLocalItem System.Collections.Generic.IEnumerator<Microsoft.TeamFoundation.VersionControl.Client.EnumeratedLocalItem>.get_Current();
    public sealed virtual void Dispose();
    public sealed virtual void Reset();
    public sealed virtual bool MoveNext();
    public static bool GetFileAttributes(string path, Int64& length, Int64& fileTime);
    public static IEnumerable`1<LocalItemEnumerator> GetEnumeratorsForWorkingFolders(WorkingFolder[] folders, bool enumerateHiddenAndSystem);
    private static SafeFindHandle FindFirstFileEx(StringBuilder lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, IntPtr lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, IntPtr lpSearchFilter, UInt32 dwAdditionalFlags);
    private static bool FindNextFile(SafeFindHandle hFindFile, IntPtr lpFindfileData);
    private static bool FindClose(IntPtr hFile);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.LocalItemExclusionCache : object {
    private bool m_cacheEnabled;
    private bool m_cacheLoaded;
    private ReaderWriterLock m_dataManagementLock;
    private Dictionary`2<InternalServerInfo, ExclusionSet> m_exclusions;
    private static string s_exclusionsRoot;
    private static string s_teamProjectCollection;
    private static string s_collectionId;
    private static string s_collectionUrl;
    private static string m_cacheFileName;
    public static string CacheFileName { get; }
    public static string CacheFilePath { get; }
    internal LocalItemExclusionCache(bool cacheEnabled);
    private static LocalItemExclusionCache();
    public static string get_CacheFileName();
    public static string get_CacheFilePath();
    public void RemoveExclusion(InternalServerInfo serverInfo, string exclusion);
    public void SetDefaultExclusions(InternalServerInfo serverInfo, String[] exclusions);
    public void SetDefaultExclusions(InternalServerInfo serverInfo, LocalItemExclusionSet localItemExclusionSet);
    public String[] GetExclusions(InternalServerInfo serverInfo);
    public DateTime GetLastDefaultExclusionUpdate(InternalServerInfo serverInfo);
    private void EnsureDiskCacheLoaded();
    public void Reload();
    private void Load(XmlNode rootExclusionNode);
    private void WriteCacheToDisk();
    private void Save(XmlNode inputXml, XmlNode outputXml);
    private void Merge(XmlNode xmlOnDisk);
    private void MarkClean();
}
public class Microsoft.TeamFoundation.VersionControl.Client.LocalItemExclusionEvaluator : object {
    private string m_startLocalItem;
    private int m_startLocalItemDepth;
    private WorkingFolder[] m_workingFolders;
    private string m_startLocalItemWorkspaceRoot;
    private List`1<IgnoreFile> m_ignoreFiles;
    private string m_currentDirectory;
    private bool m_useOnlyStartLocalItemExclusions;
    private static string s_ignoreFileName;
    private static string s_ignoreFileNameWithSeparatorPrefix;
    private static int s_ignoreFileEntryLimit;
    private static string c_defaultIgnoreFileName;
    private static int c_defaultIgnoreFileEntryLimit;
    public bool UseOnlyStartLocalItemExclusions { get; public set; }
    public string StartLocalItem { get; }
    internal static string IgnoreFileName { get; }
    internal static string IgnoreFileNameWithSeparatorPrefix { get; }
    private static LocalItemExclusionEvaluator();
    public LocalItemExclusionEvaluator(Workspace workspace, string startLocalItem);
    internal LocalItemExclusionEvaluator(LocalWorkspaceProperties wp, string startLocalItem);
    private void Initialize(String[] globalExclusions);
    public bool get_UseOnlyStartLocalItemExclusions();
    public void set_UseOnlyStartLocalItemExclusions(bool value);
    public string get_StartLocalItem();
    public bool IsExcluded(string localItem);
    public bool IsExcluded(string localItem, bool isFolder);
    public bool IsExcluded(string localItem, bool isFolder, String& appliedExclusion, String& ignoreFilePath);
    private void PrepareStackForLocalItem(string localItemToCheck);
    internal static string get_IgnoreFileName();
    internal static string get_IgnoreFileNameWithSeparatorPrefix();
}
internal class Microsoft.TeamFoundation.VersionControl.Client.LocalItemExclusionSet : object {
    internal String[] m_exclusions;
    private Guid m_watermark;
    public String[] Exclusions { get; public set; }
    public Guid Watermark { get; public set; }
    public String[] get_Exclusions();
    public void set_Exclusions(String[] value);
    public Guid get_Watermark();
    public void set_Watermark(Guid value);
    internal static LocalItemExclusionSet FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    internal void ToXml(XmlWriter writer, string element);
    internal static void ToXml(XmlWriter writer, string element, LocalItemExclusionSet obj);
}
public class Microsoft.TeamFoundation.VersionControl.Client.LocalItemOutOfDateException : ServerItemException {
    public LocalItemOutOfDateException(string message);
    public LocalItemOutOfDateException(string message, Exception ex);
    protected LocalItemOutOfDateException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.LocalItemRequiredException : ServerItemException {
    public LocalItemRequiredException(string message);
    public LocalItemRequiredException(string message, Exception ex);
    protected LocalItemRequiredException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.LocalPathTooLongException : VersionControlException {
    public LocalPathTooLongException(string message);
    public LocalPathTooLongException(string message, Exception ex);
    protected LocalPathTooLongException(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.LocalPendingChange : object {
    public static int LocalPendingChangeId;
    public static Byte[] EmptyHash;
    public static LocalPendingChangeComparer PathComparer;
    private string m_branchFromItem;
    private int m_branchFromVersion;
    private string m_committedServerItem;
    private DateTime m_creationDate;
    private int m_deletionId;
    private int m_encoding;
    private byte m_flags;
    internal Byte[] m_hashValue;
    private int m_itemId;
    private byte m_itemType;
    private byte m_lockStatus;
    private int m_pendingCommand;
    private string m_targetServerItem;
    private int m_version;
    public bool IsCommitted { get; }
    public ChangeType ChangeType { get; public set; }
    public ItemType ItemType { get; public set; }
    public bool IsAdd { get; }
    public bool IsEdit { get; }
    public bool IsRename { get; }
    public bool IsEncoding { get; }
    public bool IsDelete { get; }
    public bool IsUndelete { get; }
    public bool IsBranch { get; }
    public bool IsMerge { get; }
    public bool IsRollback { get; }
    public bool IsLock { get; }
    public bool IsRecursiveChange { get; }
    public bool HasMergeConflict { get; public set; }
    public bool IsCandidate { get; public set; }
    public string BranchFromItem { get; public set; }
    public int BranchFromVersion { get; public set; }
    public string CommittedServerItem { get; public set; }
    public DateTime CreationDate { get; public set; }
    public int DeletionId { get; public set; }
    public int Encoding { get; public set; }
    public byte Flags { get; public set; }
    public Byte[] HashValue { get; public set; }
    public int ItemId { get; public set; }
    public byte LockStatus { get; public set; }
    public string TargetServerItem { get; public set; }
    public int Version { get; public set; }
    internal LocalPendingChange(WorkspaceLocalItem lvEntry, string targetServerItem, ChangeType change);
    internal LocalPendingChange(string targetServerItem, string committedServerItem, int version, ItemType itemType, int encoding, Byte[] hashValue, int itemId, ChangeType change);
    private static LocalPendingChange();
    public bool get_IsCommitted();
    public ChangeType get_ChangeType();
    public void set_ChangeType(ChangeType value);
    public ItemType get_ItemType();
    public void set_ItemType(ItemType value);
    public LocalPendingChange Clone();
    public bool get_IsAdd();
    public bool get_IsEdit();
    public bool get_IsRename();
    public bool get_IsEncoding();
    public bool get_IsDelete();
    public bool get_IsUndelete();
    public bool get_IsBranch();
    public bool get_IsMerge();
    public bool get_IsRollback();
    public bool get_IsLock();
    public bool get_IsRecursiveChange();
    public bool get_HasMergeConflict();
    public void set_HasMergeConflict(bool value);
    public bool get_IsCandidate();
    public void set_IsCandidate(bool value);
    public PendingChange ToPendingChange(VersionControlServer sourceControl, string targetLocalItem);
    public static LocalPendingChange FromPendingChange(PendingChange pc);
    public string get_BranchFromItem();
    public void set_BranchFromItem(string value);
    public int get_BranchFromVersion();
    public void set_BranchFromVersion(int value);
    public string get_CommittedServerItem();
    public void set_CommittedServerItem(string value);
    public DateTime get_CreationDate();
    public void set_CreationDate(DateTime value);
    public int get_DeletionId();
    public void set_DeletionId(int value);
    public int get_Encoding();
    public void set_Encoding(int value);
    public byte get_Flags();
    public void set_Flags(byte value);
    public Byte[] get_HashValue();
    public void set_HashValue(Byte[] value);
    public int get_ItemId();
    public void set_ItemId(int value);
    public byte get_LockStatus();
    public void set_LockStatus(byte value);
    public string get_TargetServerItem();
    public void set_TargetServerItem(string value);
    public int get_Version();
    public void set_Version(int value);
    internal static LocalPendingChange FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    internal void ToXml(XmlWriter writer, string element);
    internal static void ToXml(XmlWriter writer, string element, LocalPendingChange obj);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.LocalPendingChangeComparer : object {
    public sealed virtual int Compare(LocalPendingChange x, LocalPendingChange y);
    public sealed virtual bool Equals(LocalPendingChange x, LocalPendingChange y);
    public sealed virtual int GetHashCode(LocalPendingChange obj);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.LocalPendingChangesTable : LocalMetadataTable {
    private Guid m_baseSignature;
    private Guid m_clientSignature;
    private bool m_hasRenames;
    private PathTable`1<LocalPendingChange> m_pendingChangesTarget;
    private PathTable`1<LocalPendingChange> m_pendingChangesCommitted;
    private PathTable`1<LocalPendingChange> m_pendingChangesCandidateTarget;
    private static short c_magic;
    private static ChangeType c_recursiveChangeTypeMask;
    protected String[] TraceKeywords { get; }
    public IEnumerable`1<string> KnownServerItems { get; }
    public bool HasRenames { get; }
    public int Count { get; }
    public Guid ClientSignature { get; public set; }
    public LocalPendingChangesTable(string fileName, LocalPendingChangesTable cachedLoadSource);
    public LocalPendingChangesTable(string fileName, bool loadFromBackup);
    protected virtual String[] get_TraceKeywords();
    protected virtual void Initialize(object initializeData);
    protected virtual void Load(SafeFileHandle fileHandle);
    private void LoadFromVersion(BinaryReader br, SchemaVersion schemaversion);
    protected virtual bool CachedLoad(LocalMetadataTable source);
    protected virtual bool Save(SafeFileHandle fileHandle);
    private void WriteToVersion1(BinaryWriter bw);
    private void WritePendingChangeToVersion1(BinaryWriter bw, LocalPendingChange pc);
    public bool HasSubItemOfLocalVersion(WorkspaceLocalItem lvEntry);
    public bool HasSubItemOfTargetServerItem(string targetServerItem);
    public LocalPendingChange GetByTargetServerItem(string targetServerItem);
    public LocalPendingChange GetByCommittedServerItem(string committedServerItem);
    public LocalPendingChange GetByLocalVersion(WorkspaceLocalItem lvEntry);
    public string GetCommittedServerItemForTargetServerItem(string targetServerItem);
    public string GetTargetServerItemForCommittedServerItem(string committedServerItem);
    public string GetTargetServerItemForLocalVersion(WorkspaceLocalItem lvEntry);
    public ChangeType GetRecursiveChangeTypeForLocalVersion(WorkspaceLocalItem lvEntry);
    public ChangeType GetRecursiveChangeTypeForTargetServerItem(string targetServerItem);
    public ChangeType GetInheritedChangeTypeForTargetServerItem(string targetServerItem);
    public IEnumerable`1<LocalPendingChange> QueryParentsOfTargetServerItem(string targetServerItem);
    [IteratorStateMachineAttribute("Microsoft.TeamFoundation.VersionControl.Client.LocalPendingChangesTable/<QueryByTargetServerItem>d__23")]
public IEnumerable`1<LocalPendingChange> QueryByTargetServerItem(string targetServerItem, RecursionType recursion, string pattern);
    [IteratorStateMachineAttribute("Microsoft.TeamFoundation.VersionControl.Client.LocalPendingChangesTable/<QueryByCommittedServerItem>d__24")]
public IEnumerable`1<LocalPendingChange> QueryByCommittedServerItem(string committedServerItem, RecursionType recursion, string pattern);
    public void PendChange(LocalPendingChange change);
    public void Remove(LocalPendingChange change);
    public bool RemoveByTargetServerItem(string targetServerItem);
    public void ReplacePendingChanges(IEnumerable`1<PendingChange> newPendingChanges);
    public void ReplacePendingChanges(PathTable`1<LocalPendingChange> pendingChangesTarget);
    [IteratorStateMachineAttribute("Microsoft.TeamFoundation.VersionControl.Client.LocalPendingChangesTable/<QueryCandidatesByTargetServerItem>d__30")]
public IEnumerable`1<LocalPendingChange> QueryCandidatesByTargetServerItem(string targetServerItem, RecursionType recursion, string pattern);
    public void AddCandidate(LocalPendingChange pendingChange);
    public bool RemoveCandidateByTargetServerItem(string targetServerItem);
    public bool RemoveCandidateByTargetServerItem(string targetServerItem, bool recursive);
    public LocalPendingChange GetCandidateByTargetServerItem(string targetServerItem);
    [IteratorStateMachineAttribute("Microsoft.TeamFoundation.VersionControl.Client.LocalPendingChangesTable/<get_KnownServerItems>d__36")]
public IEnumerable`1<string> get_KnownServerItems();
    public void RenameTeamProjects(Func`2<string, string> serverItemMapper);
    public bool get_HasRenames();
    public int get_Count();
    public Guid get_ClientSignature();
    public void set_ClientSignature(Guid value);
    private void UpdateClientSignatureIfNecessary();
}
internal class Microsoft.TeamFoundation.VersionControl.Client.LocalPendingChangesTableHeader : LocalMetadataTable {
    private int m_pendingChangeCount;
    private Guid m_clientSignature;
    private static short c_magic;
    protected String[] TraceKeywords { get; }
    public Guid ClientSignature { get; }
    public int Count { get; }
    public LocalPendingChangesTableHeader(string fileName, LocalMetadataTable cachedLoadSource);
    public LocalPendingChangesTableHeader(string fileName, bool loadFromBackup);
    protected virtual String[] get_TraceKeywords();
    protected virtual void Initialize(object initializeData);
    protected virtual void Load(SafeFileHandle fileHandle);
    private void LoadFromVersion1(BinaryReader br);
    protected virtual bool CachedLoad(LocalMetadataTable source);
    protected virtual bool Save(SafeFileHandle fileHandle);
    public Guid get_ClientSignature();
    public int get_Count();
}
public class Microsoft.TeamFoundation.VersionControl.Client.LocalVersion : object {
    private string m_item;
    private int m_version;
    public string Item { get; }
    public int Version { get; }
    internal LocalVersion(string item, int version);
    public string get_Item();
    public int get_Version();
    [EditorBrowsableAttribute("1")]
public static LocalVersion FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, LocalVersion obj);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.LocalVersionComparer : object {
    private static LocalVersionComparer m_instance;
    internal static LocalVersionComparer Instance { get; }
    private sealed virtual override int System.Collections.Generic.IComparer<Microsoft.TeamFoundation.VersionControl.Client.LocalVersion>.Compare(LocalVersion x, LocalVersion y);
    internal static LocalVersionComparer get_Instance();
}
public class Microsoft.TeamFoundation.VersionControl.Client.LocalVersionNotFoundException : ServerItemException {
    public LocalVersionNotFoundException(string message);
    public LocalVersionNotFoundException(string message, Exception ex);
    protected LocalVersionNotFoundException(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.LocalVersionUpdate : object {
    private int m_itemId;
    private int m_localVersion;
    private string m_targetLocalItem;
    public int ItemId { get; public set; }
    public int LocalVersion { get; public set; }
    public string TargetLocalItem { get; public set; }
    public LocalVersionUpdate(ILocalVersionUpdate sourceUpdate);
    public int get_ItemId();
    public void set_ItemId(int value);
    public int get_LocalVersion();
    public void set_LocalVersion(int value);
    public string get_TargetLocalItem();
    public void set_TargetLocalItem(string value);
    internal static LocalVersionUpdate FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    internal void ToXml(XmlWriter writer, string element);
    internal static void ToXml(XmlWriter writer, string element, LocalVersionUpdate obj);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.LocalWorkspaceCache : object {
    private ReaderWriterLockSlim m_rwLock;
    private Dictionary`2<CacheKey, CacheValue> m_wsInfos;
    private Dictionary`2<Uri, Guid> m_uriMap;
    private HashSet`1<CacheKey> m_removedWsInfos;
    private bool m_isDirty;
    private static InternalWorkspaceConflictInfo[] s_emptyConflictList;
    private static WorkspaceInfo[] s_emptyWsInfoList;
    private static string c_vcsString;
    private static string c_serversString;
    private static string c_serverInfoString;
    private static string c_uriString;
    private static string c_repositoryGuidString;
    private static string c_workspaceInfoString;
    private static string c_cacheFileName;
    public bool IsDirty { get; }
    public WorkspaceInfo[] AllWorkspaceInfos { get; }
    public static string CacheFileName { get; }
    private static LocalWorkspaceCache();
    public IEnumerable`1<InternalWorkspaceConflictInfo> Insert(WorkspaceInfo toInsert);
    private IEnumerable`1<InternalWorkspaceConflictInfo> InsertHelper(WorkspaceInfo toInsert);
    private static IEnumerable`1<InternalWorkspaceConflictInfo> InsertHelper(Dictionary`2<CacheKey, CacheValue> wsInfos, HashSet`1<CacheKey> removedWsInfos, Dictionary`2<Uri, Guid> uriMap, WorkspaceInfo toInsert);
    public void EnsureServerUriUnique(Uri serverUri, Guid newServerGuid);
    private void EnsureServerUriUniqueHelper(Uri serverUri, Guid newServerGuid);
    private static bool EnsureServerUriUniqueHelper(Dictionary`2<CacheKey, CacheValue> wsInfos, HashSet`1<CacheKey> removedWsInfos, Dictionary`2<Uri, Guid> uriMap, Uri serverUri, Guid newServerGuid);
    public void UpdateLastSavedCheckin(WorkspaceInfo updateSource);
    public IEnumerable`1<InternalWorkspaceConflictInfo> Update(Guid serverGuid, string workspaceName, string ownerName, WorkspaceInfo updated);
    public IEnumerable`1<InternalWorkspaceConflictInfo> Update(Guid serverGuid, string ownerName, IEnumerable`1<WorkspaceInfo> wsInfos);
    public bool Remove(WorkspaceInfo wsInfo);
    public bool Remove(Guid repositoryId, string workspaceName, string workspaceOwner);
    private bool RemoveHelper(WorkspaceInfo wsInfo);
    private bool RemoveHelper(Guid repositoryId, string workspaceName, string workspaceOwner);
    public WorkspaceInfo Lookup(Guid repositoryId, string workspaceName, string workspaceOwner);
    public WorkspaceInfo Lookup(string path);
    public WorkspaceInfo[] RecursiveLookup(string path);
    public WorkspaceInfo[] Matching(Guid repositoryId, Uri serverUri, string workspaceName, string workspaceOwner);
    private WorkspaceInfo LookupHelper(Guid repositoryId, string workspaceName, string workspaceOwner);
    private WorkspaceInfo LookupHelper(string localItem);
    public void CheckForMappingConflicts(WorkspaceInfo toCheck, WorkspaceInfo toIgnore);
    private static void CheckForConflicts(IEnumerable`1<WorkspaceInfo> toCheck);
    private static IEnumerable`1<InternalWorkspaceConflictInfo> FindConflictsHelper(Dictionary`2<CacheKey, CacheValue> wsInfos, WorkspaceInfo toCheck, WorkspaceInfo toIgnore);
    public bool get_IsDirty();
    private void MarkClean();
    public WorkspaceInfo[] get_AllWorkspaceInfos();
    public static string get_CacheFileName();
    public IEnumerable`1<InternalWorkspaceConflictInfo> LoadFromDirectory(string directory);
    public IEnumerable`1<InternalWorkspaceConflictInfo> LoadFromFile(string directory);
    private static IEnumerable`1<WorkspaceInfo> LoadFromDirectoryHelper(string directory);
    private static IEnumerable`1<WorkspaceInfo> LoadFromFileHelper(string path);
    public IEnumerable`1<InternalWorkspaceConflictInfo> SaveToFile(string directory);
    public IEnumerable`1<InternalWorkspaceConflictInfo> SaveToDirectory(string directory);
    public static IEnumerable`1<InternalWorkspaceConflictInfo> SaveToFileHelper(string path, IEnumerable`1<WorkspaceInfo> toSave);
    private static List`1<WorkspaceInfo> LoadFromXmlDocument(XmlDocument document);
    private static XmlDocument SaveToXmlDocument(IEnumerable`1<WorkspaceInfo> wsInfos);
    private IEnumerable`1<InternalWorkspaceConflictInfo> Merge(IEnumerable`1<WorkspaceInfo> input);
    private static void EnsureSuccess(bool result);
    private static string GetMapping(WorkspaceInfo wsInfo, string path);
    internal static Mutex WaitForMutex(string directory);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.LocalWorkspaceProperties : LocalMetadataTable {
    private Dictionary`2<string, BaselineFolder> m_metadataTableLocations;
    private List`1<BaselineFolder> m_baselineFolders;
    private List`1<WorkingFolder> m_workingFolders;
    private int m_newProjectRevisionId;
    private Workspace m_workspace;
    private int m_baselineFoldersWriteLockToken;
    private static string c_oneLevelMapping;
    private static short c_magicVersion1;
    private static short c_magicVersion2AndHigher;
    protected String[] TraceKeywords { get; }
    public int NewProjectRevisionId { get; public set; }
    public BaselineFolder[] BaselineFolders { get; }
    public WorkingFolder[] WorkingFolders { get; public set; }
    public LocalWorkspaceProperties(string tableLocation, LocalWorkspaceProperties cachedLoadSource);
    public LocalWorkspaceProperties(string tableLocation, bool loadFromBackup);
    protected virtual String[] get_TraceKeywords();
    protected virtual void Initialize(object initializeData);
    protected virtual void Load(SafeFileHandle fileHandle);
    private void LoadFromVersion3(BinaryReader br);
    private void LoadFromVersion2(BinaryReader br, bool isVersionTwo);
    protected virtual bool CachedLoad(LocalMetadataTable source);
    protected virtual bool Save(SafeFileHandle fileHandle);
    protected virtual void Dispose(bool disposing);
    protected virtual void SaveComplete();
    private void WriteToVersion2(BinaryWriter bw);
    public string GetMetadataTableLocation(string tableName);
    public void DeleteBaseline(Byte[] baselineFileGuid);
    public void UpdateBaselineLocation(Byte[] baselineFileGuid, string currentLocalItem);
    public void CopyBaselineToTarget(Byte[] baselineFileGuid, string targetLocalItem, long baselineFileLength, Byte[] baselineHashValue);
    public void RemoveBaselineFolder(BaselineFolder baselineFolder);
    private bool MoveBaselineFolderStructure(string rootBaselineFolderPath, BaselineFolder targetBaselineFolder);
    private bool MoveMetadataTable(string metadataTablePath, BaselineFolder targetBaselineFolder);
    public void ApplyAceToBaselineFolders(SecurityIdentifier sid, bool addOrRemove);
    public void ApplyPermissionsProfileToBaselineFolders(WorkspacePermissionProfile profile);
    public void DoBaselineFolderMaintenance();
    private bool IsMetadataTablePresentAtLocation(string fileName);
    public void InvalidateBaselineFolderCache();
    public int get_NewProjectRevisionId();
    public void set_NewProjectRevisionId(int value);
    public BaselineFolder[] get_BaselineFolders();
    public WorkingFolder[] get_WorkingFolders();
    public void set_WorkingFolders(WorkingFolder[] value);
}
public class Microsoft.TeamFoundation.VersionControl.Client.LocalWorkspaceRequiredException : WorkspaceException {
    public LocalWorkspaceRequiredException(string message);
    public LocalWorkspaceRequiredException(string message, Exception ex);
    protected LocalWorkspaceRequiredException(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.LocalWorkspaceScanner : object {
    private static int s_candidateAddsLimit;
    private static int c_defaultCandidateAddsLimit;
    private static int s_enumeratedItemsLimit;
    private static int c_defaultEnumeratedItemsLimit;
    private static int s_interruptPollFrequency;
    private static int c_defaultInterruptPollFrequency;
    private LocalWorkspaceProperties m_wp;
    private WorkspaceVersionTable m_lv;
    private LocalPendingChangesTable m_pc;
    private HashSet`1<string> m_skippedItems;
    private bool m_pendAndUndoEdits;
    private bool m_interruptible;
    private SparseTree`1<WorkspaceLocalItem> m_markForRemoval;
    private List`1<WorkspaceLocalItem> m_reappearedOnDisk;
    private List`1<UndoOp> m_toUndo;
    private Dictionary`2<string, LocalPendingChange> m_candidateChanges;
    public bool PendAndUndoEdits { get; public set; }
    private static LocalWorkspaceScanner();
    public LocalWorkspaceScanner(LocalWorkspaceProperties wp, WorkspaceVersionTable lv, LocalPendingChangesTable pc, IEnumerable`1<string> skippedItems, bool interruptible);
    public bool get_PendAndUndoEdits();
    public void set_PendAndUndoEdits(bool value);
    public bool FullScan();
    public bool PartialScan(IEnumerable`1<string> changedPaths);
    private void ScanPartTwo();
    private void PendCandidates();
    private void DiffItem(EnumeratedLocalItem fromDisk, WorkspaceLocalItem lvEntry);
    private void MarkForRemoval(WorkspaceLocalItem lvEntry);
    private void MarkMissingFromDisk(WorkspaceLocalItem lvEntry);
    private bool AddCandidateAdd(EnumeratedLocalItem item);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.LocalWorkspaceTransaction : object {
    [CompilerGeneratedAttribute]
private bool <RaisePendingChangesChanged>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RaisePendingChangeCandidatesChanged>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<bool> <SpinDelegate>k__BackingField;
    private Workspace m_workspace;
    private LocalWorkspaceProperties m_wp;
    private WorkspaceVersionTable m_lv;
    private LocalPendingChangesTable m_pc;
    private WorkspaceVersionTableHeader m_lvh;
    private LocalPendingChangesTableHeader m_pch;
    [ThreadStaticAttribute]
private static LocalWorkspaceTransaction ts_current;
    private bool m_transactionStarted;
    private bool m_setTsCurrent;
    private WorkspaceLock m_workspaceLock;
    private bool m_ownsWorkspaceLock;
    private bool m_requestYield;
    private int m_creationThreadId;
    private bool m_autoRecover;
    private Stopwatch m_stopwatch;
    private static bool s_allowCachedLoads;
    private static int s_backupFrequencySeconds;
    private static int c_defaultBackupFrequencySeconds;
    public bool RaisePendingChangesChanged { get; public set; }
    public bool RaisePendingChangeCandidatesChanged { get; public set; }
    public Workspace Workspace { get; }
    public static LocalWorkspaceTransaction Current { get; }
    public Tables OpenedTables { get; }
    public bool OwnsWorkspaceLock { get; }
    public WorkspaceLock WorkspaceLock { get; }
    public bool AutoRecover { get; public set; }
    public Func`1<bool> SpinDelegate { get; public set; }
    private static LocalWorkspaceTransaction();
    public LocalWorkspaceTransaction(Workspace workspace);
    public LocalWorkspaceTransaction(Workspace workspace, bool requestYield);
    public LocalWorkspaceTransaction(Workspace workspace, WorkspaceLock workspaceLock);
    public LocalWorkspaceTransaction(Workspace workspace, WorkspaceLock workspaceLock, bool requestYield);
    [CompilerGeneratedAttribute]
public bool get_RaisePendingChangesChanged();
    [CompilerGeneratedAttribute]
public void set_RaisePendingChangesChanged(bool value);
    [CompilerGeneratedAttribute]
public bool get_RaisePendingChangeCandidatesChanged();
    [CompilerGeneratedAttribute]
public void set_RaisePendingChangeCandidatesChanged(bool value);
    public Workspace get_Workspace();
    public static LocalWorkspaceTransaction get_Current();
    public Tables get_OpenedTables();
    public bool get_OwnsWorkspaceLock();
    public WorkspaceLock get_WorkspaceLock();
    public sealed virtual void Dispose();
    public void Abort();
    public void Execute(WorkspacePropertiesTransaction toExecute);
    public void Execute(LocalVersionTransaction toExecute);
    public void Execute(LocalVersionHeaderTransaction toExecute);
    public void Execute(PendingChangesTransaction toExecute);
    public void Execute(PendingChangesHeaderTransaction toExecute);
    public void Execute(WorkspacePropertiesLocalVersionTransaction toExecute);
    public void Execute(LocalVersionPendingChangesTransaction toExecute);
    public void Execute(LocalVersionPendingChangesHeadersTransaction toExecute);
    public void Execute(AllTablesTransaction toExecute);
    private void AcquireTables(Tables toAcquire);
    private void PrepareToLoadFromBackup();
    private static LocalMetadataTable GetBestCachedLoadSource(Workspace workspace);
    public bool get_AutoRecover();
    public void set_AutoRecover(bool value);
    private bool DoAutoRecover(string wpPathWithoutExtension);
    [CompilerGeneratedAttribute]
public Func`1<bool> get_SpinDelegate();
    [CompilerGeneratedAttribute]
public void set_SpinDelegate(Func`1<bool> value);
}
public class Microsoft.TeamFoundation.VersionControl.Client.LocalWorkspaceTransactionAlreadyRunningException : VersionControlException {
}
public enum Microsoft.TeamFoundation.VersionControl.Client.LockLevel : Enum {
    public int value__;
    public static LockLevel CheckOut;
    public static LockLevel Checkin;
    public static LockLevel None;
    public static LockLevel Unchanged;
}
public class Microsoft.TeamFoundation.VersionControl.Client.LongPathInWorkspaceRequires2012QU1Exception : VersionControlException {
    public LongPathInWorkspaceRequires2012QU1Exception(string message);
    public LongPathInWorkspaceRequires2012QU1Exception(string message, Exception ex);
    protected LongPathInWorkspaceRequires2012QU1Exception(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.Mapping : object {
    protected int m_depth;
    protected string m_serverItem;
    protected WorkingFolderType m_type;
    public string ServerItem { get; }
    public WorkingFolderType Type { get; }
    public string DisplayServerItem { get; }
    public RecursionType Depth { get; }
    public Mapping(string serverItem, WorkingFolderType type, RecursionType depth);
    public string get_ServerItem();
    public WorkingFolderType get_Type();
    [EditorBrowsableAttribute("1")]
public static Mapping FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public virtual void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, Mapping obj);
    private int GetDepthFromRecursion(RecursionType type);
    public string get_DisplayServerItem();
    [EditorBrowsableAttribute("1")]
public bool DoesMatchPattern(string serverItem);
    public RecursionType get_Depth();
    public static bool op_Equality(Mapping mapping1, Mapping mapping2);
    public static bool op_Inequality(Mapping mapping1, Mapping mapping2);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class Microsoft.TeamFoundation.VersionControl.Client.MappingConflictException : VersionControlException {
    public MappingConflictException(string message);
    public MappingConflictException(string message, Exception exception);
    protected MappingConflictException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.MappingException : ServerItemException {
    public MappingException(string message);
    public MappingException(string message, Exception ex);
    protected MappingException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.MaxRowsEvaluatedException : VersionControlException {
    public MaxRowsEvaluatedException(string message);
    public MaxRowsEvaluatedException(string message, Exception ex);
    protected MaxRowsEvaluatedException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.MergeCandidate : object {
    private Changeset m_changeset;
    private bool m_partial;
    public Changeset Changeset { get; }
    public bool Partial { get; }
    public Changeset get_Changeset();
    public bool get_Partial();
    [EditorBrowsableAttribute("1")]
public static MergeCandidate FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, MergeCandidate obj);
}
public class Microsoft.TeamFoundation.VersionControl.Client.MergeConflictExistsException : ServerItemException {
    public MergeConflictExistsException(string message);
    public MergeConflictExistsException(string message, Exception ex);
    protected MergeConflictExistsException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.MergeDoNotHaveTargetLocallyException : ServerItemException {
    public MergeDoNotHaveTargetLocallyException(string message);
    public MergeDoNotHaveTargetLocallyException(string message, Exception ex);
    protected MergeDoNotHaveTargetLocallyException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.MergeEditDeleteException : VersionControlException {
    public MergeEditDeleteException(string message);
    public MergeEditDeleteException(string message, Exception ex);
    protected MergeEditDeleteException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.MergeEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private int <OperationId>k__BackingField;
    private Conflict m_merge;
    private Workspace m_workspace;
    private PendingChange m_pendingChange;
    private OperationStatus m_status;
    private ChangeType m_targetLocalChangeType;
    private bool m_diskUpdateAttempted;
    private bool m_isLatest;
    private ReadOnlyCollection`1<PropertyValue> m_attributes;
    private ReadOnlyCollection`1<PropertyValue> m_propertyValues;
    public Workspace Workspace { get; }
    public PendingChange PendingChange { get; }
    public bool IsLatest { get; }
    public ChangeType ChangeType { get; }
    public string SourceServerItem { get; }
    public string SourceLocalItem { get; }
    public ChangesetVersionSpec SourceVersionFrom { get; }
    public ChangesetVersionSpec SourceVersionTo { get; }
    public string TargetServerItem { get; }
    public string TargetLocalItem { get; }
    public ChangesetVersionSpec TargetVersionPended { get; }
    public OperationStatus Status { get; }
    public ChangeType TargetLocalPendingChangeType { get; }
    public Resolution Resolution { get; }
    public bool IsConflict { get; }
    public bool DiskUpdateAttempted { get; }
    [ObsoleteAttribute("Please use the Attributes property instead.", "False")]
public ReadOnlyCollection`1<PropertyValue> Properties { get; }
    public ReadOnlyCollection`1<PropertyValue> Attributes { get; }
    public ReadOnlyCollection`1<PropertyValue> PropertyValues { get; }
    public int OperationId { get; private set; }
    internal MergeEventArgs(Conflict merge, Workspace workspace, bool isLatest, PendingChange pendingChange, OperationStatus status, ChangeType targetLocalChangeType, bool diskUpdateAttempted, PropertyValue[] attributes, PropertyValue[] propertyValues, int operationId);
    public string GetMessage(String& error);
    public sealed virtual Workspace get_Workspace();
    public sealed virtual PendingChange get_PendingChange();
    public sealed virtual bool get_IsLatest();
    public ChangeType get_ChangeType();
    public string get_SourceServerItem();
    public string get_SourceLocalItem();
    public ChangesetVersionSpec get_SourceVersionFrom();
    public ChangesetVersionSpec get_SourceVersionTo();
    public string get_TargetServerItem();
    public string get_TargetLocalItem();
    public ChangesetVersionSpec get_TargetVersionPended();
    public sealed virtual OperationStatus get_Status();
    public ChangeType get_TargetLocalPendingChangeType();
    public Resolution get_Resolution();
    public bool get_IsConflict();
    public sealed virtual bool get_DiskUpdateAttempted();
    public ReadOnlyCollection`1<PropertyValue> get_Properties();
    public ReadOnlyCollection`1<PropertyValue> get_Attributes();
    public ReadOnlyCollection`1<PropertyValue> get_PropertyValues();
    [CompilerGeneratedAttribute]
public sealed virtual int get_OperationId();
    [CompilerGeneratedAttribute]
private void set_OperationId(int value);
}
public class Microsoft.TeamFoundation.VersionControl.Client.MergeEventHandler : MulticastDelegate {
    public MergeEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, MergeEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, MergeEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[FlagsAttribute]
public enum Microsoft.TeamFoundation.VersionControl.Client.MergeOptions : Enum {
    public int value__;
    public static MergeOptions AlwaysAcceptMine;
    public static MergeOptions Baseless;
    public static MergeOptions ForceMerge;
    public static MergeOptions NoMerge;
    public static MergeOptions None;
}
public class Microsoft.TeamFoundation.VersionControl.Client.MergeSource : object {
    private bool m_isRename;
    private string m_serverItem;
    private int m_versionFrom;
    private int m_versionTo;
    public bool IsRename { get; }
    public string ServerItem { get; }
    public int VersionFrom { get; }
    public int VersionTo { get; }
    public bool get_IsRename();
    public string get_ServerItem();
    public int get_VersionFrom();
    public int get_VersionTo();
    [EditorBrowsableAttribute("1")]
public static MergeSource FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, MergeSource obj);
}
public class Microsoft.TeamFoundation.VersionControl.Client.MergeTargetCloakedException : ServerItemException {
    public MergeTargetCloakedException(string message);
    public MergeTargetCloakedException(string message, Exception ex);
    protected MergeTargetCloakedException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.MergeTargetFileSourceDirectoryException : VersionControlException {
    public MergeTargetFileSourceDirectoryException(string message);
    public MergeTargetFileSourceDirectoryException(string message, Exception ex);
    protected MergeTargetFileSourceDirectoryException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.MergeTargetNotMappedException : ServerItemException {
    public MergeTargetNotMappedException(string message);
    public MergeTargetNotMappedException(string message, Exception ex);
    protected MergeTargetNotMappedException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.MergeTargetPathAlreadyHasPendingMergeException : VersionControlException {
    public MergeTargetPathAlreadyHasPendingMergeException(string message);
    public MergeTargetPathAlreadyHasPendingMergeException(string message, Exception ex);
    protected MergeTargetPathAlreadyHasPendingMergeException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.MergeTargetPathHasIncompatiblePendingChangeException : VersionControlException {
    public MergeTargetPathHasIncompatiblePendingChangeException(string message);
    public MergeTargetPathHasIncompatiblePendingChangeException(string message, Exception ex);
    protected MergeTargetPathHasIncompatiblePendingChangeException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.MergeTargetPathHasNamespacePendingChangeConflictException : VersionControlException {
    public MergeTargetPathHasNamespacePendingChangeConflictException(string message);
    public MergeTargetPathHasNamespacePendingChangeConflictException(string message, Exception ex);
    protected MergeTargetPathHasNamespacePendingChangeConflictException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.MissingBaselineException : VersionControlException {
    [CompilerGeneratedAttribute]
private string <TargetLocalItem>k__BackingField;
    public string TargetLocalItem { get; private set; }
    public MissingBaselineException(string targetLocalItem);
    [CompilerGeneratedAttribute]
public string get_TargetLocalItem();
    [CompilerGeneratedAttribute]
private void set_TargetLocalItem(string value);
}
public class Microsoft.TeamFoundation.VersionControl.Client.MissingParentIsRenameOrUndeleteException : ServerItemException {
    public MissingParentIsRenameOrUndeleteException(string message);
    public MissingParentIsRenameOrUndeleteException(string message, Exception ex);
    protected MissingParentIsRenameOrUndeleteException(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.MoveUncommittedLocalVersionUpdate : object {
    private string m_newTargetServerItem;
    private string m_sourceLocalItem;
    public bool SendToServer { get; }
    public bool IsCommitted { get; }
    public string SourceServerItem { get; }
    public int ItemId { get; }
    public string TargetLocalItem { get; }
    public int VersionLocal { get; }
    public string SourceLocalItem { get; }
    public MoveUncommittedLocalVersionUpdate(string newTargetServerItem, string sourceLocalItem);
    public sealed virtual bool get_SendToServer();
    public sealed virtual bool get_IsCommitted();
    public sealed virtual string get_SourceServerItem();
    public sealed virtual int get_ItemId();
    public sealed virtual string get_TargetLocalItem();
    public sealed virtual int get_VersionLocal();
    public string get_SourceLocalItem();
    public sealed virtual void Dispose();
}
public class Microsoft.TeamFoundation.VersionControl.Client.MultipleWorkspacesFoundException : VersionControlException {
    public MultipleWorkspacesFoundException(string suppliedWorkspaceName, string suppliedOwnerName, List`1<string> matchingWorkspaceSpecs);
}
public class Microsoft.TeamFoundation.VersionControl.Client.MustUndeleteParentException : VersionControlException {
    public MustUndeleteParentException(string message);
    public MustUndeleteParentException(string message, Exception ex);
    protected MustUndeleteParentException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.NoChangesToShelveException : VersionControlException {
    public NoChangesToShelveException(string message);
    public NoChangesToShelveException(string message, Exception ex);
    protected NoChangesToShelveException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.NoLockExistsException : ServerItemException {
    public NoLockExistsException(string message);
    public NoLockExistsException(string message, Exception ex);
    protected NoLockExistsException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.NoMergeRelationshipException : VersionControlException {
    public NoMergeRelationshipException(string message);
    public NoMergeRelationshipException(string message, Exception ex);
    protected NoMergeRelationshipException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.NotAllowedOnFolderException : ServerItemException {
    public NotAllowedOnFolderException(string message);
    public NotAllowedOnFolderException(string message, Exception ex);
    protected NotAllowedOnFolderException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.NotPermittedForLocalWorkspaceException : WorkspaceException {
    public NotPermittedForLocalWorkspaceException(string message);
    public NotPermittedForLocalWorkspaceException(string message, Exception ex);
    protected NotPermittedForLocalWorkspaceException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.NotWorkspaceOwnerException : WorkspaceException {
    public NotWorkspaceOwnerException(string message);
    public NotWorkspaceOwnerException(string message, Exception ex);
    protected NotWorkspaceOwnerException(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.OfflineCacheData : object {
    [CompilerGeneratedAttribute]
private Guid <LastServerPendingChangeSignature>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastReconcileTime>k__BackingField;
    [CompilerGeneratedAttribute]
private WorkspaceLock <CurrentWorkspaceLock>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RaisedLocalWorkspaceTooLarge>k__BackingField;
    private Workspace m_workspace;
    private WIN32_FILE_ATTRIBUTE_DATA m_lastPendingChangesAttrs;
    private bool m_haveLastPendingChangesAttrs;
    private Dictionary`2<Type, WeakReference> m_metadataTableCache;
    private Dictionary`2<Type, LocalMetadataTable> m_strongMetadataTableCache;
    private bool m_stronglyRootMetadataTables;
    private int m_stronglyRootedMetadataTablesRefCount;
    private QueuedActionLimiter m_pendingChangesChangedLimiter;
    private QueuedActionLimiter m_pendingChangeCandidatesChangedLimiter;
    private static int s_changesChangedRateLimit;
    private static int c_defaultChangesChangedRateLimit;
    public QueuedActionLimiter PendingChangesChangedLimiter { get; }
    public QueuedActionLimiter PendingChangeCandidatesChangedLimiter { get; }
    public Guid LastServerPendingChangeSignature { get; public set; }
    public WIN32_FILE_ATTRIBUTE_DATA LastPendingChangesAttributes { get; public set; }
    public bool HaveLastPendingChangesAttributes { get; }
    public DateTime LastReconcileTime { get; public set; }
    public WorkspaceLock CurrentWorkspaceLock { get; public set; }
    public bool RaisedLocalWorkspaceTooLarge { get; public set; }
    private static OfflineCacheData();
    public OfflineCacheData(Workspace workspace);
    public QueuedActionLimiter get_PendingChangesChangedLimiter();
    public QueuedActionLimiter get_PendingChangeCandidatesChangedLimiter();
    [CompilerGeneratedAttribute]
public Guid get_LastServerPendingChangeSignature();
    [CompilerGeneratedAttribute]
public void set_LastServerPendingChangeSignature(Guid value);
    public WIN32_FILE_ATTRIBUTE_DATA get_LastPendingChangesAttributes();
    public void set_LastPendingChangesAttributes(WIN32_FILE_ATTRIBUTE_DATA value);
    public bool get_HaveLastPendingChangesAttributes();
    [CompilerGeneratedAttribute]
public DateTime get_LastReconcileTime();
    [CompilerGeneratedAttribute]
public void set_LastReconcileTime(DateTime value);
    [CompilerGeneratedAttribute]
public WorkspaceLock get_CurrentWorkspaceLock();
    [CompilerGeneratedAttribute]
public void set_CurrentWorkspaceLock(WorkspaceLock value);
    [CompilerGeneratedAttribute]
public bool get_RaisedLocalWorkspaceTooLarge();
    [CompilerGeneratedAttribute]
public void set_RaisedLocalWorkspaceTooLarge(bool value);
    public void RequestStronglyRootedMetadataTables();
    public void UnrequestStronglyRootedMetadataTables();
    public void CacheMetadataTable(LocalMetadataTable toCache);
    public T GetCachedMetadataTable();
    [CompilerGeneratedAttribute]
private void <.ctor>b__1_0(object state);
    [CompilerGeneratedAttribute]
private void <.ctor>b__1_1(object state);
}
public class Microsoft.TeamFoundation.VersionControl.Client.OnlyOneWorkspaceException : VersionControlException {
    public OnlyOneWorkspaceException(Workspace workspace, string dirName);
    public OnlyOneWorkspaceException(Workspace workspace, string dirName, Exception innerException);
    private OnlyOneWorkspaceException(string workspaceName, string dirName, Exception innerException);
    public OnlyOneWorkspaceException(string message);
    public OnlyOneWorkspaceException(string message, Exception exception);
    protected OnlyOneWorkspaceException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.OperationEventArgs : EventArgs {
    private OperationEventType m_type;
    private Workspace m_workspace;
    private int m_id;
    private static int m_nextId;
    public OperationEventType Type { get; }
    public Workspace Workspace { get; }
    public int Id { get; }
    private OperationEventArgs(OperationEventType type, Workspace workspace);
    internal static OperationEventArgs Starting(OperationEventType type, Workspace workspace);
    internal void Finished();
    public OperationEventType get_Type();
    public Workspace get_Workspace();
    public int get_Id();
}
internal class Microsoft.TeamFoundation.VersionControl.Client.OperationEventGenerator : object {
    private OperationEventArgs m_operationEventArgs;
    public int OperationId { get; }
    internal OperationEventGenerator(OperationEventType type, Workspace workspace);
    private sealed virtual override void System.IDisposable.Dispose();
    public int get_OperationId();
}
public class Microsoft.TeamFoundation.VersionControl.Client.OperationEventHandler : MulticastDelegate {
    public OperationEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, OperationEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, OperationEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum Microsoft.TeamFoundation.VersionControl.Client.OperationEventType : Enum {
    public int value__;
    public static OperationEventType Get;
    public static OperationEventType Merge;
    public static OperationEventType Pend;
    public static OperationEventType Undo;
    public static OperationEventType Checkin;
    public static OperationEventType Shelve;
    public static OperationEventType Unshelve;
    public static OperationEventType Resolve;
    public static OperationEventType Destroy;
    public static OperationEventType Rollback;
}
public enum Microsoft.TeamFoundation.VersionControl.Client.OperationStatus : Enum {
    public int value__;
    public static OperationStatus Conflict;
    public static OperationStatus SourceWritable;
    public static OperationStatus TargetLocalPending;
    public static OperationStatus TargetWritable;
    public static OperationStatus Getting;
    public static OperationStatus Replacing;
    public static OperationStatus Deleting;
    public static OperationStatus SourceDirectoryNotEmpty;
    public static OperationStatus TargetIsDirectory;
    public static OperationStatus UnableToRefresh;
}
public class Microsoft.TeamFoundation.VersionControl.Client.OwnerRequiredException : VersionControlException {
    public OwnerRequiredException(string message);
    public OwnerRequiredException(string message, Exception ex);
    protected OwnerRequiredException(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.ParentPathChildItem : ValueType {
    public string ParentPath;
    public string ChildItem;
    private static char s_separator;
    public ParentPathChildItem(string path);
    public ParentPathChildItem(string parentPath, string childItem);
    private static ParentPathChildItem();
    public bool Equals(string path);
    private static string Canonicalize(string path);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.ParentPathChildItemComparer : object {
    public static ParentPathChildItemComparer Instance;
    private static ParentPathChildItemComparer();
    public sealed virtual bool Equals(ParentPathChildItem x, ParentPathChildItem y);
    public sealed virtual int GetHashCode(ParentPathChildItem obj);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.ParsedItemSpec : object {
    [CompilerGeneratedAttribute]
private string <TargetItem>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Pattern>k__BackingField;
    [CompilerGeneratedAttribute]
private RecursionType <Recursion>k__BackingField;
    private ParsedItemSpecOptions m_options;
    public bool IsServerItem { get; }
    private string UnparsedItem { get; }
    public string TargetItem { get; private set; }
    public string Pattern { get; private set; }
    public RecursionType Recursion { get; private set; }
    private ParsedItemSpec(string targetItem, string targetItemPattern, RecursionType recursion, ParsedItemSpecOptions options);
    public bool get_IsServerItem();
    private string get_UnparsedItem();
    public bool Match(string itemToMatch);
    public IEnumerable`1<WorkspaceLocalItem> ExpandFrom(WorkspaceVersionTable lv, LocalPendingChangesTable pc, ICollection`1<Failure> failuresAccumulator);
    public IEnumerable`1<WorkspaceLocalItem> ExpandFrom(WorkspaceVersionTable lv, LocalPendingChangesTable pc, Failure& failure);
    public IEnumerable`1<WorkspaceLocalItem> ExpandFrom(WorkspaceVersionTable lv, LocalPendingChangesTable pc, ItemType itemType, ICollection`1<Failure> failuresAccumulator);
    public IEnumerable`1<WorkspaceLocalItem> ExpandFrom(WorkspaceVersionTable lv, LocalPendingChangesTable pc, ItemType itemType, Failure& failure);
    private IEnumerable`1<WorkspaceLocalItem> ExpandFromLocal(WorkspaceVersionTable lv, ItemType itemType, Failure& failure);
    private IEnumerable`1<WorkspaceLocalItem> ExpandFromServer(WorkspaceVersionTable lv, LocalPendingChangesTable pc, ItemType itemType, Failure& failure);
    public static ParsedItemSpec FromItemSpec(ItemSpec itemSpec, LocalWorkspaceProperties wp, WorkspaceVersionTable lv, LocalPendingChangesTable pc, ParsedItemSpecOptions options, ICollection`1<Failure> failuresAccumulator);
    public static ParsedItemSpec FromItemSpec(ItemSpec itemSpec, LocalWorkspaceProperties wp, WorkspaceVersionTable lv, LocalPendingChangesTable pc, ParsedItemSpecOptions options, Failure& failure);
    public static ParsedItemSpec FromLocalItemSpec(ItemSpec itemSpec, LocalWorkspaceProperties wp, WorkspaceVersionTable lv, LocalPendingChangesTable pc, ParsedItemSpecOptions options, ICollection`1<Failure> failuresAccumulator);
    public static ParsedItemSpec FromLocalItemSpec(ItemSpec itemSpec, LocalWorkspaceProperties wp, WorkspaceVersionTable lv, LocalPendingChangesTable pc, ParsedItemSpecOptions options, Failure& failure, bool checkLocalDiskIfNotFound);
    public static ParsedItemSpec FromServerItemSpec(ItemSpec itemSpec, LocalWorkspaceProperties wp, WorkspaceVersionTable lv, LocalPendingChangesTable pc, ParsedItemSpecOptions options, ICollection`1<Failure> failuresAccumulator);
    public static ParsedItemSpec FromServerItemSpec(ItemSpec itemSpec, LocalWorkspaceProperties wp, WorkspaceVersionTable lv, LocalPendingChangesTable pc, ParsedItemSpecOptions options, Failure& failure, bool checkLocalDiskIfNotFound);
    private static ExistenceCheckResult LocalItemExistsOnDisk(string localItem);
    private static ExistenceCheckResult LocalItemExists(LocalWorkspaceProperties wp, WorkspaceVersionTable lv, LocalPendingChangesTable pc, string localItem, ParsedItemSpecOptions options);
    private static ExistenceCheckResult TargetServerItemExists(WorkspaceVersionTable lv, LocalPendingChangesTable pc, string targetServerItem, ParsedItemSpecOptions options);
    internal static bool MatchItemType(WorkspaceLocalItem localItem, ItemType itemType);
    [CompilerGeneratedAttribute]
public string get_TargetItem();
    [CompilerGeneratedAttribute]
private void set_TargetItem(string value);
    [CompilerGeneratedAttribute]
public string get_Pattern();
    [CompilerGeneratedAttribute]
private void set_Pattern(string value);
    [CompilerGeneratedAttribute]
public RecursionType get_Recursion();
    [CompilerGeneratedAttribute]
private void set_Recursion(RecursionType value);
    public static IEnumerable`1<WorkspaceLocalItem> QueryLocalVersionsByTargetServerItem(WorkspaceVersionTable lv, LocalPendingChangesTable pc, string targetServerItem, RecursionType recursion, string pattern, ItemType itemType, ParsedItemSpecOptions options);
}
[FlagsAttribute]
internal enum Microsoft.TeamFoundation.VersionControl.Client.ParsedItemSpecOptions : Enum {
    public int value__;
    public static ParsedItemSpecOptions None;
    public static ParsedItemSpecOptions IncludeDeleted;
}
public class Microsoft.TeamFoundation.VersionControl.Client.PartialRenameConflictException : VersionControlException {
    public PartialRenameConflictException(string message);
    public PartialRenameConflictException(string message, Exception ex);
    protected PartialRenameConflictException(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.PathWatcher : object {
    private string m_path;
    private WeakReference m_owningObject;
    private QueuedActionLimiter m_pathChangedLimiter;
    private bool m_fileSystemWatcherAllowed;
    private object m_watcherLock;
    private RegisteredWaitWatcher m_watcher;
    private object m_reportLock;
    private PathWatcherReport m_report;
    private long m_lastUseTime;
    private static int s_pathChangedRateLimit;
    private static int c_bufferSize;
    private static int c_defaultPathChangedRateLimit;
    public string Path { get; }
    public object OwningObject { get; }
    public DateTime LastUseTime { get; }
    public bool IsWatching { get; }
    private static PathWatcher();
    public PathWatcher(string path, object owningObject);
    public sealed virtual void Dispose();
    public string get_Path();
    public object get_OwningObject();
    public DateTime get_LastUseTime();
    public PathWatcherReport Poll();
    public bool StartWatching();
    public bool get_IsWatching();
    public void StopWatching();
    private void m_watcher_Error(object sender, ErrorEventArgs e);
    private void m_watcher_Changed(object sender, FileSystemEventArgs e);
    private void m_watcher_Renamed(object sender, RenamedEventArgs e);
    private void m_watcher_Deleted(object sender, FileSystemEventArgs e);
    private void m_watcher_Created(object sender, FileSystemEventArgs e);
    private static bool PathMeetsFilterCriteria(string path);
    private void PathChangedCallback(object state);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.PathWatcherReport : object {
    private bool m_fullyInvalidated;
    private HashSet`1<string> m_changedPaths;
    private static int s_maxChangedPaths;
    private static int c_defaultMaxChangedPaths;
    public bool FullyInvalidated { get; }
    public bool NothingChanged { get; }
    public IEnumerable`1<string> ChangedPaths { get; }
    private static PathWatcherReport();
    public PathWatcherReport(bool initiallyInvalidated);
    public bool AddChangedPath(string path);
    public void FullyInvalidate();
    public void UnionWith(PathWatcherReport otherReport);
    public bool get_FullyInvalidated();
    public bool get_NothingChanged();
    public IEnumerable`1<string> get_ChangedPaths();
}
public class Microsoft.TeamFoundation.VersionControl.Client.PendingChange : object {
    [CompilerGeneratedAttribute]
private bool <IsCandidate>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PendingSetName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PendingSetOwner>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PendingSetOwnerDisplay>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInShelveset>k__BackingField;
    private static Dictionary`2<int, string> s_localizedChangeTypeStringCache;
    private static ReaderWriterLockSlim s_localizedChangeTypeStringCacheLock;
    private bool m_isUnshelvedChange;
    private VersionControlServer m_sourceControl;
    private bool m_undone;
    private bool m_isLocalItemDelete;
    private static String[] m_lockLevelNames;
    private static String[] m_lockLevelShortNames;
    private static PendingChangeComparer m_serverItemComparer;
    private static PendingChangeComparer m_localItemComparer;
    private ReadOnlyCollection`1<MergeSource> m_mergeCollection;
    internal static Byte[] EmptyHashValue;
    private int m_changeEx;
    private ChangeType m_changeType;
    private int m_conflictType;
    private DateTime m_creationDate;
    private int m_deletionId;
    private string m_downloadUrl;
    private int m_encoding;
    internal Byte[] m_hashValue;
    private int m_itemId;
    private ItemType m_itemType;
    private long m_length;
    private string m_localItem;
    private LockLevel m_lockLevel;
    internal MergeSource[] m_mergeSources;
    private int m_pendingChangeId;
    internal PropertyValue[] m_propertyValues;
    private string m_serverItem;
    private string m_shelvedDownloadUrl;
    private int m_sourceDeletionId;
    private string m_sourceLocalItem;
    private string m_sourceServerItem;
    private int m_sourceVersionFrom;
    internal Byte[] m_uploadHashValue;
    private int m_version;
    public string LocalOrServerItem { get; }
    public string LocalOrServerFolder { get; }
    public string FileName { get; }
    internal string DownloadUrl { get; }
    public bool Undone { get; }
    public bool IsLocalItemDelete { get; }
    public bool IsAdd { get; }
    public bool IsEdit { get; }
    public bool IsRename { get; }
    public bool IsEncoding { get; }
    public bool IsDelete { get; }
    public bool IsUndelete { get; }
    public bool IsBranch { get; }
    public bool IsMerge { get; }
    public bool IsRollback { get; }
    public bool IsLock { get; }
    public bool IsUnshelvedChange { get; }
    public bool IsImplicit { get; }
    public string ChangeTypeName { get; }
    public string LockLevelName { get; }
    public string LockLevelShortName { get; }
    public string EncodingName { get; }
    [XmlIgnoreAttribute]
public ReadOnlyCollection`1<PropertyValue> PropertyValues { get; }
    public VersionControlServer VersionControlServer { get; internal set; }
    public string ToolTipText { get; }
    public static IComparer ServerItemComparer { get; }
    public static IComparer LocalItemComparer { get; }
    public ChangeType ChangeType { get; internal set; }
    public bool IsCandidate { get; public set; }
    [EditorBrowsableAttribute("1")]
public string PendingSetName { get; internal set; }
    [EditorBrowsableAttribute("1")]
public string PendingSetOwner { get; internal set; }
    internal string PendingSetOwnerDisplay { get; internal set; }
    internal bool IsInShelveset { get; internal set; }
    public ReadOnlyCollection`1<MergeSource> MergeSources { get; }
    public ConflictType ConflictType { get; }
    internal bool HasUploadHashValue { get; }
    public static IEnumerable`1<PendingChange> EmptyIEnumerable { get; }
    public DateTime CreationDate { get; }
    public int DeletionId { get; }
    public int Encoding { get; }
    public Byte[] HashValue { get; }
    public int ItemId { get; }
    public ItemType ItemType { get; }
    public long Length { get; }
    public string LocalItem { get; }
    public LockLevel LockLevel { get; }
    public int PendingChangeId { get; }
    public string ServerItem { get; }
    public int SourceDeletionId { get; public set; }
    public string SourceLocalItem { get; }
    public string SourceServerItem { get; }
    public int SourceVersionFrom { get; public set; }
    public Byte[] UploadHashValue { get; }
    public int Version { get; }
    internal PendingChange(Workspace workspace, GetOperation getOp, ProcessType processType);
    [EditorBrowsableAttribute("1")]
public PendingChange(Change change);
    [EditorBrowsableAttribute("1")]
public PendingChange(VersionControlServer sourceControl, string localItem, string sourceLocalItem, string serverItem, ItemType itemType, int itemId, ChangeType changeType);
    internal PendingChange(VersionControlServer sourceControl, string serverItem, string sourceServerItem, int sourceVersionFrom, int sourceDeletionId, int deletionId, LockLevel lockLevel, string localItem, ItemType itemType, int itemId, DateTime creationDate, int version, ChangeType changeType, Byte[] hashValue, Byte[] uploadHashValue, int encoding, int pendingChangeId, bool isCandidate);
    private static PendingChange();
    public void DownloadShelvedFile(string localFileName);
    public Stream DownloadShelvedFile();
    public void DownloadBaseFile(string localFileName);
    public Stream DownloadBaseFile();
    public void RestoreCandidateDelete();
    internal void UpdateMissingProperties();
    private bool CopyLocalBaseline(string localFileName);
    public static string GetLocalizedStringForChangeType(ChangeType type);
    public static string GetLocalizedStringForChangeType(ChangeType type, bool showLock);
    private static string BuildLocalizedStringForChangeType(ChangeType type);
    private static void AppendIf(bool condition, StringBuilder sb, string resourceName);
    public static string GetLocalizedStringForLockLevel(LockLevel lockLevel);
    public static string GetLocalizedStringForItemType(ItemType type);
    public static String[] ToLocalItems(PendingChange[] pendingChanges);
    public static String[] ToServerItems(PendingChange[] pendingChanges);
    internal void UpdateUploadHashValue(Byte[] hash);
    [EditorBrowsableAttribute("1")]
public void UpdateSourceItems(string sourceLocalItem, string sourceServerItem);
    private static ChangeType RemoveNoneFlagIfNecessary(ChangeType changeType);
    public string get_LocalOrServerItem();
    public string get_LocalOrServerFolder();
    public string get_FileName();
    internal string get_DownloadUrl();
    public bool get_Undone();
    public bool get_IsLocalItemDelete();
    public bool get_IsAdd();
    public bool get_IsEdit();
    public bool get_IsRename();
    public bool get_IsEncoding();
    public bool get_IsDelete();
    public bool get_IsUndelete();
    public bool get_IsBranch();
    public bool get_IsMerge();
    public bool get_IsRollback();
    public bool get_IsLock();
    public bool get_IsUnshelvedChange();
    public bool get_IsImplicit();
    public string get_ChangeTypeName();
    public string get_LockLevelName();
    public string get_LockLevelShortName();
    public string get_EncodingName();
    public ReadOnlyCollection`1<PropertyValue> get_PropertyValues();
    public VersionControlServer get_VersionControlServer();
    internal void set_VersionControlServer(VersionControlServer value);
    public string get_ToolTipText();
    public static IComparer get_ServerItemComparer();
    public static IComparer get_LocalItemComparer();
    public ChangeType get_ChangeType();
    internal void set_ChangeType(ChangeType value);
    [EditorBrowsableAttribute("1")]
public void SetChangeType(ChangeType toSet);
    [CompilerGeneratedAttribute]
public bool get_IsCandidate();
    [CompilerGeneratedAttribute]
public void set_IsCandidate(bool value);
    [CompilerGeneratedAttribute]
public string get_PendingSetName();
    [CompilerGeneratedAttribute]
internal void set_PendingSetName(string value);
    [CompilerGeneratedAttribute]
public string get_PendingSetOwner();
    [CompilerGeneratedAttribute]
internal void set_PendingSetOwner(string value);
    [CompilerGeneratedAttribute]
internal string get_PendingSetOwnerDisplay();
    [CompilerGeneratedAttribute]
internal void set_PendingSetOwnerDisplay(string value);
    [CompilerGeneratedAttribute]
internal bool get_IsInShelveset();
    [CompilerGeneratedAttribute]
internal void set_IsInShelveset(bool value);
    public static ChangeType ConvertToChangeType(int flags);
    public static int ConvertToInt(ChangeType changeType);
    public ReadOnlyCollection`1<MergeSource> get_MergeSources();
    public ConflictType get_ConflictType();
    internal bool get_HasUploadHashValue();
    private void AfterDeserialize();
    public static bool IsSourceRename(ChangeType changeType);
    public static PendingChange[] MaterializeIEnumerable(IEnumerable`1<PendingChange> enumerable);
    internal static PendingChange[] MaterializeIEnumerable(IEnumerable`1<PendingChange> enumerable, int materializationCap);
    internal static PendingChange[] MaterializeIEnumerable(IEnumerable`1<PendingChange> enumerable, int materializationCap, bool nullOnOverflow);
    internal static String[] MaterializeIEnumerableServerItems(IEnumerable`1<PendingChange> enumerable);
    public static bool IsIEnumerableEmpty(IEnumerable`1<PendingChange> enumerable);
    public static IEnumerable`1<PendingChange> get_EmptyIEnumerable();
    public DateTime get_CreationDate();
    public int get_DeletionId();
    public int get_Encoding();
    public Byte[] get_HashValue();
    public int get_ItemId();
    public ItemType get_ItemType();
    public long get_Length();
    public string get_LocalItem();
    public LockLevel get_LockLevel();
    public int get_PendingChangeId();
    public string get_ServerItem();
    public int get_SourceDeletionId();
    public void set_SourceDeletionId(int value);
    public string get_SourceLocalItem();
    public string get_SourceServerItem();
    public int get_SourceVersionFrom();
    public void set_SourceVersionFrom(int value);
    public Byte[] get_UploadHashValue();
    public int get_Version();
    [EditorBrowsableAttribute("1")]
public static PendingChange FromXml(IServiceProvider serviceProvider, XmlReader reader);
    private void FromXmlAttributeHook(XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, PendingChange obj);
    private void ToXmlAttributeHook(XmlWriter writer);
}
public class Microsoft.TeamFoundation.VersionControl.Client.PendingChangeChangedException : VersionControlException {
    public PendingChangeChangedException(string message);
    public PendingChangeChangedException(string message, Exception ex);
    protected PendingChangeChangedException(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.PendingChangeComparer : object {
    private Compare m_compare;
    internal PendingChangeComparer(Compare compare);
    public sealed virtual bool Equals(PendingChange x, PendingChange y);
    public sealed virtual int GetHashCode(PendingChange obj);
    private sealed virtual override int System.Collections.IComparer.Compare(object x, object y);
    private sealed virtual override int System.Collections.Generic.IComparer<Microsoft.TeamFoundation.VersionControl.Client.PendingChange>.Compare(PendingChange x, PendingChange y);
    private static int CompareLocal(PendingChange pc1, PendingChange pc2, Compare order);
}
public class Microsoft.TeamFoundation.VersionControl.Client.PendingChangeContentNotFoundException : VersionControlException {
    public PendingChangeContentNotFoundException(string message);
    public PendingChangeContentNotFoundException(string message, Exception ex);
    protected PendingChangeContentNotFoundException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.PendingChangeEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private ChangePendedFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OperationId>k__BackingField;
    private Workspace m_workspace;
    private PendingChange m_change;
    private ChangeType m_targetChangeType;
    private OperationStatus m_status;
    private bool m_diskUpdateAttempted;
    private bool m_isLatest;
    private ReadOnlyCollection`1<PropertyValue> m_attributes;
    private ReadOnlyCollection`1<PropertyValue> m_propertyValues;
    public PendingChange PendingChange { get; }
    public Workspace Workspace { get; }
    public OperationStatus Status { get; }
    public bool IsLatest { get; }
    public ChangeType TargetPendingChangeType { get; }
    public bool DiskUpdateAttempted { get; }
    [ObsoleteAttribute("Please use the Attributes property instead.", "False")]
public ReadOnlyCollection`1<PropertyValue> Properties { get; }
    public ReadOnlyCollection`1<PropertyValue> Attributes { get; }
    public ReadOnlyCollection`1<PropertyValue> PropertyValues { get; }
    public ChangePendedFlags Flags { get; private set; }
    public int OperationId { get; private set; }
    internal PendingChangeEventArgs(Workspace workspace, bool isLatest, PendingChange change, OperationStatus status, ChangeType targetChangeType, bool diskUpdateAttempted, PropertyValue[] attributes, PropertyValue[] propertyValues, ChangePendedFlags flags, int operationId);
    public void UpdateServer(string currentLocalPath);
    public void UpdateServer(UpdateLocalVersionQueue queue, string currentLocalPath);
    public sealed virtual PendingChange get_PendingChange();
    public sealed virtual Workspace get_Workspace();
    public sealed virtual OperationStatus get_Status();
    public sealed virtual bool get_IsLatest();
    public ChangeType get_TargetPendingChangeType();
    public sealed virtual bool get_DiskUpdateAttempted();
    public ReadOnlyCollection`1<PropertyValue> get_Properties();
    public ReadOnlyCollection`1<PropertyValue> get_Attributes();
    public ReadOnlyCollection`1<PropertyValue> get_PropertyValues();
    [CompilerGeneratedAttribute]
public ChangePendedFlags get_Flags();
    [CompilerGeneratedAttribute]
private void set_Flags(ChangePendedFlags value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_OperationId();
    [CompilerGeneratedAttribute]
private void set_OperationId(int value);
}
public class Microsoft.TeamFoundation.VersionControl.Client.PendingChangeEventHandler : MulticastDelegate {
    public PendingChangeEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, PendingChangeEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, PendingChangeEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.TeamFoundation.VersionControl.Client.PendingChangeMergeConflictExistsException : ServerItemException {
    public PendingChangeMergeConflictExistsException(string message);
    public PendingChangeMergeConflictExistsException(string message, Exception ex);
    protected PendingChangeMergeConflictExistsException(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.PendingCheckin : object {
    private IPendingCheckinPendingChanges m_pendingChanges;
    private IPendingCheckinWorkItems m_workItems;
    private IPendingCheckinNotes m_checkinNotes;
    private IPendingCheckinPolicies m_policies;
    private IServiceProvider m_serviceProvider;
    internal IServiceProvider ServiceProvider { get; internal set; }
    public IPendingCheckinPendingChanges PendingChanges { get; }
    public IPendingCheckinWorkItems WorkItems { get; }
    public IPendingCheckinNotes CheckinNotes { get; }
    public IPendingCheckinPolicies Policies { get; }
    internal PendingCheckin(Workspace workspace, PendingChange[] allChanges, PendingChange[] checkedChanges, AffectedTeamProjects affectedTeamProjects, string comment, CheckinNote checkinNotes, WorkItemCheckinInfo[] checkedWorkItems);
    public virtual object GetService(Type serviceType);
    internal IServiceProvider get_ServiceProvider();
    internal void set_ServiceProvider(IServiceProvider value);
    public sealed virtual IPendingCheckinPendingChanges get_PendingChanges();
    public sealed virtual IPendingCheckinWorkItems get_WorkItems();
    public sealed virtual IPendingCheckinNotes get_CheckinNotes();
    public sealed virtual IPendingCheckinPolicies get_Policies();
}
public class Microsoft.TeamFoundation.VersionControl.Client.PendingChildException : ServerItemException {
    public PendingChildException(string message);
    public PendingChildException(string message, Exception ex);
    protected PendingChildException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.PendingDeleteConflictChangeException : ServerItemException {
    public PendingDeleteConflictChangeException(string message);
    public PendingDeleteConflictChangeException(string message, Exception ex);
    protected PendingDeleteConflictChangeException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.PendingLocalVersionMismatchException : ServerItemException {
    public PendingLocalVersionMismatchException(string message);
    public PendingLocalVersionMismatchException(string message, Exception ex);
    protected PendingLocalVersionMismatchException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.PendingParentDeleteException : ServerItemException {
    public PendingParentDeleteException(string message);
    public PendingParentDeleteException(string message, Exception ex);
    protected PendingParentDeleteException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.PendingSet : object {
    private static PendingSetComparer m_comparer;
    private List`1<PendingChange> m_candidatePendingChanges;
    private string m_computer;
    private string m_name;
    private string m_ownerDisplayName;
    private string m_ownerName;
    private string m_ownerUniqueName;
    private int m_ownershipValue;
    private Guid m_pendingChangeSignature;
    internal PendingChange[] m_pendingChanges;
    private PendingSetType m_type;
    public static IComparer Comparer { get; }
    public OwnershipState Ownership { get; internal set; }
    public ReadOnlyCollection`1<PendingChange> CandidatePendingChanges { get; }
    public string Computer { get; }
    public string Name { get; }
    public string OwnerDisplayName { get; }
    public string OwnerName { get; }
    public Guid PendingChangeSignature { get; }
    public PendingChange[] PendingChanges { get; }
    public PendingSetType Type { get; }
    internal PendingSet(string name, string owner, OwnershipState ownership, string computer, PendingSetType type, PendingChange[] changes);
    internal PendingSet(string name, string owner, string ownerDisplay, OwnershipState ownership, string computer, PendingSetType type, PendingChange[] changes, List`1<PendingChange> candidatePendingChanges);
    public static IComparer get_Comparer();
    public OwnershipState get_Ownership();
    internal void set_Ownership(OwnershipState value);
    private void AfterDeserialize();
    public ReadOnlyCollection`1<PendingChange> get_CandidatePendingChanges();
    internal void SetPendingSetDetails();
    public string get_Computer();
    public string get_Name();
    public string get_OwnerDisplayName();
    public string get_OwnerName();
    public Guid get_PendingChangeSignature();
    public PendingChange[] get_PendingChanges();
    public PendingSetType get_Type();
    [EditorBrowsableAttribute("1")]
public static PendingSet FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, PendingSet obj);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.PendingSetComparer : object {
    private sealed virtual override int System.Collections.IComparer.Compare(object x, object y);
}
public enum Microsoft.TeamFoundation.VersionControl.Client.PendingSetType : Enum {
    public int value__;
    public static PendingSetType Shelveset;
    public static PendingSetType Workspace;
}
internal class Microsoft.TeamFoundation.VersionControl.Client.PendingState : object {
    private ConflictInformation m_conflictInfo;
    private int m_itemId;
    private int m_revertToVersion;
    public ConflictInformation ConflictInfo { get; public set; }
    public int ItemId { get; public set; }
    public int RevertToVersion { get; public set; }
    public ConflictInformation get_ConflictInfo();
    public void set_ConflictInfo(ConflictInformation value);
    public int get_ItemId();
    public void set_ItemId(int value);
    public int get_RevertToVersion();
    public void set_RevertToVersion(int value);
    internal static PendingState FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    internal void ToXml(XmlWriter writer, string element);
    internal static void ToXml(XmlWriter writer, string element, PendingState obj);
}
public class Microsoft.TeamFoundation.VersionControl.Client.PermissionChange : SecurityChange {
    public static string GlobalPermissionCreateWorkspace;
    public static string GlobalPermissionAdminWorkspaces;
    public static string GlobalPermissionAdminShelvesets;
    public static string GlobalPermissionAdminConnections;
    public static string GlobalPermissionAdminConfiguration;
    public static string ItemPermissionRead;
    public static string ItemPermissionPendChange;
    public static string ItemPermissionCheckin;
    public static string ItemPermissionLabel;
    public static string ItemPermissionLock;
    public static string ItemPermissionReviseOther;
    public static string ItemPermissionUnlockOther;
    public static string ItemPermissionUndoOther;
    public static string ItemPermissionLabelOther;
    public static string ItemPermissionAdminProjectRights;
    public static string ItemPermissionMerge;
    public static string ItemPermissionManageBranch;
    public static string ItemPermissionCheckinOther;
    internal String[] m_allow;
    internal String[] m_deny;
    private string m_displayName;
    private string m_identityName;
    internal String[] m_remove;
    public static String[] AllGlobalPermissions { get; }
    public static String[] AllGlobalLocalizedPermissions { get; }
    public static String[] AllItemPermissions { get; }
    public static String[] AllLocalizedItemPermissions { get; }
    public String[] Allow { get; public set; }
    public String[] Deny { get; public set; }
    public string IdentityName { get; public set; }
    public String[] Remove { get; public set; }
    public PermissionChange(string item, string identity, String[] allows, String[] denies, String[] removes);
    private static PermissionChange();
    private void DetermineCorrectIdentityName();
    public static String[] get_AllGlobalPermissions();
    public static String[] get_AllGlobalLocalizedPermissions();
    public static String[] get_AllItemPermissions();
    public static String[] get_AllLocalizedItemPermissions();
    public String[] get_Allow();
    public void set_Allow(String[] value);
    public String[] get_Deny();
    public void set_Deny(String[] value);
    public string get_IdentityName();
    public void set_IdentityName(string value);
    public String[] get_Remove();
    public void set_Remove(String[] value);
    [EditorBrowsableAttribute("1")]
public static PermissionChange FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public virtual void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, PermissionChange obj);
}
public class Microsoft.TeamFoundation.VersionControl.Client.PluginHasMultipleInterfacesException : VersionControlException {
    public PluginHasMultipleInterfacesException(string message);
    public PluginHasMultipleInterfacesException(string message, Exception ex);
    protected PluginHasMultipleInterfacesException(SerializationInfo info, StreamingContext context);
}
public abstract class Microsoft.TeamFoundation.VersionControl.Client.PolicyBase : object {
    [CompilerGeneratedAttribute]
private PolicyStateChangedHandler PolicyStateChanged;
    private string m_installationInstructions;
    private IPendingCheckin m_pendingCheckin;
    private bool m_disposed;
    public string Type { get; }
    public string TypeDescription { get; }
    public string Description { get; }
    public string InstallationInstructions { get; public set; }
    public bool CanEdit { get; }
    protected IPendingCheckin PendingCheckin { get; }
    protected bool Disposed { get; }
    public abstract virtual string get_Type();
    public abstract virtual string get_TypeDescription();
    public abstract virtual string get_Description();
    public virtual string get_InstallationInstructions();
    public virtual void set_InstallationInstructions(string value);
    public virtual bool get_CanEdit();
    public abstract virtual bool Edit(IPolicyEditArgs policyEditArgs);
    public virtual void Initialize(IPendingCheckin pendingCheckin);
    public virtual void Dispose();
    public abstract virtual PolicyFailure[] Evaluate();
    public virtual void Activate(PolicyFailure failure);
    public virtual void DisplayHelp(PolicyFailure failure);
    [CompilerGeneratedAttribute]
public virtual void add_PolicyStateChanged(PolicyStateChangedHandler value);
    [CompilerGeneratedAttribute]
public virtual void remove_PolicyStateChanged(PolicyStateChangedHandler value);
    protected virtual void OnPolicyStateChanged(PolicyFailure[] failures);
    public virtual BinaryFormatter GetBinaryFormatter();
    public virtual string GetAssemblyName();
    protected IPendingCheckin get_PendingCheckin();
    protected bool get_Disposed();
}
public class Microsoft.TeamFoundation.VersionControl.Client.PolicyEnvelope : object {
    internal string m_type;
    private string m_installationInstructions;
    internal bool m_enabled;
    internal string m_className;
    internal string m_assemblyName;
    internal string m_assemblyFile;
    internal MemoryStream m_policyStream;
    public string Type { get; }
    public bool Enabled { get; public set; }
    public IPolicyDefinition Policy { get; public set; }
    public PolicyEnvelope(IPolicyDefinition policy, PolicyType policyType);
    internal PolicyEnvelope(BinaryReader rdr);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public string get_Type();
    public bool get_Enabled();
    public void set_Enabled(bool value);
    public IPolicyDefinition get_Policy();
    public void set_Policy(IPolicyDefinition value);
    private void CheckPolicy(object policy);
    internal void Save(BinaryWriter wtr);
}
public enum Microsoft.TeamFoundation.VersionControl.Client.PolicyEvaluationState : Enum {
    public int value__;
    public static PolicyEvaluationState PoliciesLoadError;
    public static PolicyEvaluationState Unevaluated;
    public static PolicyEvaluationState Evaluated;
}
internal class Microsoft.TeamFoundation.VersionControl.Client.PolicyExceptionFailure : PolicyFailure {
    internal Exception m_exception;
    internal PolicyExceptionFailure(PolicyStatus status, Exception ex);
    public virtual void Activate();
    public virtual void DisplayHelp();
}
public class Microsoft.TeamFoundation.VersionControl.Client.PolicyFailure : object {
    private string m_message;
    private IPolicyEvaluation m_policy;
    public string Message { get; protected set; }
    public IPolicyEvaluation Policy { get; }
    public PolicyFailure(string message, IPolicyEvaluation policy);
    [EditorBrowsableAttribute("1")]
public PolicyFailure(string message);
    public string get_Message();
    protected void set_Message(string value);
    public IPolicyEvaluation get_Policy();
    public virtual void Activate();
    public virtual void DisplayHelp();
}
public class Microsoft.TeamFoundation.VersionControl.Client.PolicyFailureInfo : object {
    private string m_message;
    private string m_policyName;
    public string Message { get; }
    public string PolicyName { get; }
    internal PolicyFailureInfo(string policyName, string message);
    public string get_Message();
    public string get_PolicyName();
    [EditorBrowsableAttribute("1")]
public static PolicyFailureInfo FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, PolicyFailureInfo obj);
}
public class Microsoft.TeamFoundation.VersionControl.Client.PolicyList : object {
    private VersionControlServer m_sourceControl;
    private IPendingCheckin m_pendingCheckin;
    private object m_lock;
    private PolicyStatus[] m_policiesStatus;
    private PolicyFailure[] m_failures;
    private PolicyEvaluationState m_evaluationState;
    private static PolicyStatus[] m_emptyStatusList;
    [CompilerGeneratedAttribute]
private PolicyStateChangedHandler PolicyStateChanged;
    [CompilerGeneratedAttribute]
private EventHandler PolicyEvaluationStateChanged;
    unknown IPendingCheckin PendingCheckin {public set; }
    public PolicyEvaluationState EvaluationState { get; }
    public PolicyFailure[] Failures { get; }
    public int PolicyCount { get; }
    public PolicyList(VersionControlServer sourceControl);
    private static PolicyList();
    public sealed virtual void Dispose();
    public void set_PendingCheckin(IPendingCheckin value);
    [CompilerGeneratedAttribute]
public void add_PolicyStateChanged(PolicyStateChangedHandler value);
    [CompilerGeneratedAttribute]
public void remove_PolicyStateChanged(PolicyStateChangedHandler value);
    [CompilerGeneratedAttribute]
public void add_PolicyEvaluationStateChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PolicyEvaluationStateChanged(EventHandler value);
    public PolicyEvaluationState get_EvaluationState();
    public PolicyFailure[] Evaluate();
    public PolicyFailure[] ReloadAndEvaluate();
    public PolicyFailure[] get_Failures();
    public int get_PolicyCount();
    public void LoadPolicies();
    private void DisposePolicies(IList list);
    private void PolicyStateChangedCallback(object sender, PolicyStateChangedEventArgs e);
    private void OnPolicyEvaluationStateChanged();
    private void OnPolicyStateChanged(PolicyStateChangedEventArgs e);
    private void PendingChanges_AffectedTeamProjectsChanged(object sender, AffectedTeamProjectsEventArgs e);
}
public class Microsoft.TeamFoundation.VersionControl.Client.PolicyOverrideInfo : object {
    private string m_comment;
    internal PolicyFailureInfo[] m_policyFailures;
    public string Comment { get; }
    public PolicyFailureInfo[] PolicyFailures { get; }
    public PolicyOverrideInfo(string overrideComment, PolicyFailure[] policyFailures);
    public string get_Comment();
    public PolicyFailureInfo[] get_PolicyFailures();
    [EditorBrowsableAttribute("1")]
public static PolicyOverrideInfo FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, PolicyOverrideInfo obj);
}
public class Microsoft.TeamFoundation.VersionControl.Client.PolicyStateChangedEventArgs : EventArgs {
    private PolicyFailure[] m_failures;
    private IPolicyEvaluation m_policy;
    public PolicyFailure[] Failures { get; }
    public IPolicyEvaluation Policy { get; }
    public PolicyStateChangedEventArgs(PolicyFailure[] failures, IPolicyEvaluation policy);
    public PolicyFailure[] get_Failures();
    public IPolicyEvaluation get_Policy();
}
public class Microsoft.TeamFoundation.VersionControl.Client.PolicyStateChangedHandler : MulticastDelegate {
    public PolicyStateChangedHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, PolicyStateChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, PolicyStateChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.PolicyStatus : object {
    internal PolicyEnvelope m_envelope;
    internal PolicyFailure[] m_failures;
    internal IPolicyEvaluation m_policy;
    internal PolicyStatus(PolicyEnvelope envelope);
    internal void Initialize(IPendingCheckin pendingCheckin);
    public sealed virtual void Dispose();
    internal void Evaluate();
    internal void add_PolicyStateChanged(PolicyStateChangedHandler value);
    internal void remove_PolicyStateChanged(PolicyStateChangedHandler value);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.PolicyStatusComparer : object {
    private static PolicyStatusComparer m_comparer;
    public static IComparer Comparer { get; }
    private sealed virtual override int System.Collections.IComparer.Compare(object x, object y);
    public static IComparer get_Comparer();
}
public class Microsoft.TeamFoundation.VersionControl.Client.PolicyType : object {
    private string m_name;
    private string m_description;
    internal string m_className;
    internal string m_assemblyName;
    internal string m_assemblyFile;
    public string Name { get; }
    public string Description { get; }
    internal PolicyType(string name, string description, string className, string assemblyName, string assemblyFile);
    public string get_Name();
    public string get_Description();
    public virtual IPolicyDefinition New();
}
internal static class Microsoft.TeamFoundation.VersionControl.Client.PreFrameworkSecurityNamespaceFactory : object {
    public static SecurityNamespace[] GetSecurityNamespaces(TfsTeamProjectCollection teamProjectCollection);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.PrivilegeSecurityProvier : object {
    private VersionControlServer m_sourceControl;
    private SecurityNamespaceDescription m_description;
    public int ValidPermissions { get; }
    public Type PermissionsEnumType { get; }
    public SecurityNamespaceDescription SecurityNamespaceDescription { get; }
    public PrivilegeSecurityProvier(VersionControlServer sourceControl);
    public sealed virtual int get_ValidPermissions();
    public sealed virtual Type get_PermissionsEnumType();
    public sealed virtual SecurityNamespaceDescription get_SecurityNamespaceDescription();
    public sealed virtual String[] GetEffectivePermissions(string identityName, string item);
    public sealed virtual ItemSecurity[] GetPermissions(String[] identities, String[] items, RecursionType recursionType);
    public sealed virtual void SetPermissions(SecurityChange[] securityChanges);
}
public class Microsoft.TeamFoundation.VersionControl.Client.ProcessingChangeEventArgs : EventArgs {
    private Workspace m_workspace;
    private PendingChange m_change;
    public PendingChange PendingChange { get; }
    public Workspace Workspace { get; }
    internal ProcessingChangeEventArgs(Workspace workspace, PendingChange change);
    public PendingChange get_PendingChange();
    public Workspace get_Workspace();
}
public class Microsoft.TeamFoundation.VersionControl.Client.ProcessingChangeEventHandler : MulticastDelegate {
    public ProcessingChangeEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ProcessingChangeEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ProcessingChangeEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal enum Microsoft.TeamFoundation.VersionControl.Client.ProcessType : Enum {
    public int value__;
    public static ProcessType None;
    public static ProcessType Undo;
    public static ProcessType Pend;
    public static ProcessType Get;
    public static ProcessType Merge;
    public static ProcessType Unshelve;
    public static ProcessType Rollback;
}
public class Microsoft.TeamFoundation.VersionControl.Client.PropertiesMergeSummary : object {
    [CompilerGeneratedAttribute]
private int <TotalYourChanges>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TotalTheirChanges>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TotalConflicts>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRedundant>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<PropertyValue> <MergedProperties>k__BackingField;
    public int TotalYourChanges { get; internal set; }
    public int TotalTheirChanges { get; internal set; }
    public int TotalConflicts { get; internal set; }
    public bool IsRedundant { get; internal set; }
    public ReadOnlyCollection`1<PropertyValue> MergedProperties { get; internal set; }
    [CompilerGeneratedAttribute]
public int get_TotalYourChanges();
    [CompilerGeneratedAttribute]
internal void set_TotalYourChanges(int value);
    [CompilerGeneratedAttribute]
public int get_TotalTheirChanges();
    [CompilerGeneratedAttribute]
internal void set_TotalTheirChanges(int value);
    [CompilerGeneratedAttribute]
public int get_TotalConflicts();
    [CompilerGeneratedAttribute]
internal void set_TotalConflicts(int value);
    [CompilerGeneratedAttribute]
public bool get_IsRedundant();
    [CompilerGeneratedAttribute]
internal void set_IsRedundant(bool value);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<PropertyValue> get_MergedProperties();
    [CompilerGeneratedAttribute]
internal void set_MergedProperties(ReadOnlyCollection`1<PropertyValue> value);
    public static PropertiesMergeSummary CalculateSummary(ReadOnlyCollection`1<PropertyValue> baseProperties, ReadOnlyCollection`1<PropertyValue> yourProperties, ReadOnlyCollection`1<PropertyValue> theirProperties);
}
public class Microsoft.TeamFoundation.VersionControl.Client.ProxyInfo : object {
    private string m_description;
    private int m_flags;
    private string m_friendlyName;
    private string m_site;
    private string m_url;
    public ProxyFlags Flags { get; }
    public string Description { get; }
    public string FriendlyName { get; }
    public string Site { get; }
    public string Url { get; }
    public ProxyInfo(string url, string friendlyName, string site, string description, ProxyFlags flags);
    public ProxyFlags get_Flags();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public string get_Description();
    public string get_FriendlyName();
    public string get_Site();
    public string get_Url();
    [EditorBrowsableAttribute("1")]
public static ProxyInfo FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, ProxyInfo obj);
}
public class Microsoft.TeamFoundation.VersionControl.Client.QueryHistoryParameters : object {
    [CompilerGeneratedAttribute]
private string <Item>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionSpec <ItemVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DeletionId>k__BackingField;
    [CompilerGeneratedAttribute]
private RecursionType <RecursionType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Author>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionSpec <VersionStart>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionSpec <VersionEnd>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxResults>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeChanges>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SlotMode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeDownloadInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SortAscending>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BatchSize>k__BackingField;
    public string Item { get; public set; }
    public VersionSpec ItemVersion { get; public set; }
    public int DeletionId { get; public set; }
    public RecursionType RecursionType { get; public set; }
    public string Author { get; public set; }
    public VersionSpec VersionStart { get; public set; }
    public VersionSpec VersionEnd { get; public set; }
    public int MaxResults { get; public set; }
    public bool IncludeChanges { get; public set; }
    public bool SlotMode { get; public set; }
    public bool IncludeDownloadInfo { get; public set; }
    public bool SortAscending { get; public set; }
    public int BatchSize { get; public set; }
    public QueryHistoryParameters(string item, RecursionType recursion);
    public QueryHistoryParameters(ItemSpec itemSpec);
    [CompilerGeneratedAttribute]
public string get_Item();
    [CompilerGeneratedAttribute]
public void set_Item(string value);
    [CompilerGeneratedAttribute]
public VersionSpec get_ItemVersion();
    [CompilerGeneratedAttribute]
public void set_ItemVersion(VersionSpec value);
    [CompilerGeneratedAttribute]
public int get_DeletionId();
    [CompilerGeneratedAttribute]
public void set_DeletionId(int value);
    [CompilerGeneratedAttribute]
public RecursionType get_RecursionType();
    [CompilerGeneratedAttribute]
public void set_RecursionType(RecursionType value);
    [CompilerGeneratedAttribute]
public string get_Author();
    [CompilerGeneratedAttribute]
public void set_Author(string value);
    [CompilerGeneratedAttribute]
public VersionSpec get_VersionStart();
    [CompilerGeneratedAttribute]
public void set_VersionStart(VersionSpec value);
    [CompilerGeneratedAttribute]
public VersionSpec get_VersionEnd();
    [CompilerGeneratedAttribute]
public void set_VersionEnd(VersionSpec value);
    [CompilerGeneratedAttribute]
public int get_MaxResults();
    [CompilerGeneratedAttribute]
public void set_MaxResults(int value);
    [CompilerGeneratedAttribute]
public bool get_IncludeChanges();
    [CompilerGeneratedAttribute]
public void set_IncludeChanges(bool value);
    [CompilerGeneratedAttribute]
public bool get_SlotMode();
    [CompilerGeneratedAttribute]
public void set_SlotMode(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeDownloadInfo();
    [CompilerGeneratedAttribute]
public void set_IncludeDownloadInfo(bool value);
    [CompilerGeneratedAttribute]
public bool get_SortAscending();
    [CompilerGeneratedAttribute]
public void set_SortAscending(bool value);
    [CompilerGeneratedAttribute]
public int get_BatchSize();
    [CompilerGeneratedAttribute]
public void set_BatchSize(int value);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.QueryItemsFetchRequest : object {
    public string ServerItem;
    public int Version;
    public IPopulatableLocalVersionUpdate ToUpdate;
    public QueryItemsFetchRequest(string serverItem, int version, IPopulatableLocalVersionUpdate toUpdate);
}
[EditorBrowsableAttribute("1")]
public class Microsoft.TeamFoundation.VersionControl.Client.QueuedActionLimiter : object {
    private bool m_firstActionQueued;
    private bool m_secondActionQueued;
    private object m_lock;
    private Stopwatch m_stopwatch;
    private int m_suppressionCount;
    private object m_timerLock;
    private Timer m_timer;
    private WaitCallback m_action;
    private bool m_allowRecursiveQueueing;
    private long m_rateLimitInMilliseconds;
    private int m_deliveringThreadId;
    private static int s_workQueuedCount;
    public bool IsWorkQueued { get; }
    public static bool IsAnyWorkQueued { get; }
    public QueuedActionLimiter(WaitCallback action, bool allowRecursiveQueueing, long rateLimitInMilliseconds);
    public bool get_IsWorkQueued();
    public static bool get_IsAnyWorkQueued();
    public void QueueAction();
    private void DeliverAction(object state);
    private void QueueWithDelay(long delay);
    private void TimerCallback(object state);
    public void Suppress();
    public void Unsuppress();
}
internal class Microsoft.TeamFoundation.VersionControl.Client.QueuedEditsTable : LocalMetadataTable {
    private HashSet`1<string> m_queuedEdits;
    private static short c_magic;
    private static String[] s_traceKeywords;
    protected String[] TraceKeywords { get; }
    public String[] QueuedEdits { get; }
    public QueuedEditsTable(string fileName);
    private static QueuedEditsTable();
    protected virtual void Load(SafeFileHandle fileHandle);
    protected virtual bool Save(SafeFileHandle fileHandle);
    protected virtual String[] get_TraceKeywords();
    private void LoadFromVersion1(BinaryReader br);
    private void WriteToVersion1(BinaryWriter bw);
    public bool AddQueuedEdit(string localItem);
    public bool RemoveQueuedEdit(string localItem);
    public void RemoveQueuedEdits(IEnumerable`1<string> localItems);
    public String[] get_QueuedEdits();
}
public class Microsoft.TeamFoundation.VersionControl.Client.ReconcileBlockedByProjectRenameException : VersionControlException {
    private String[] m_oldProjectNames;
    private String[] m_newProjectNames;
    public String[] OldProjectNames { get; }
    public String[] NewProjectNames { get; }
    public int NewProjectRevisionId { get; }
    public ReconcileBlockedByProjectRenameException(string message);
    public ReconcileBlockedByProjectRenameException(string message, Exception ex);
    protected ReconcileBlockedByProjectRenameException(SerializationInfo info, StreamingContext context);
    public String[] get_OldProjectNames();
    public String[] get_NewProjectNames();
    public int get_NewProjectRevisionId();
}
public class Microsoft.TeamFoundation.VersionControl.Client.ReconcileFailedException : VersionControlException {
    [CompilerGeneratedAttribute]
private Failure[] <Failures>k__BackingField;
    public Failure[] Failures { get; private set; }
    public ReconcileFailedException(Failure[] failures);
    [CompilerGeneratedAttribute]
public Failure[] get_Failures();
    [CompilerGeneratedAttribute]
private void set_Failures(Failure[] value);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.ReconcileResult : object {
    internal Failure[] m_failures;
    internal PendingChange[] m_newPendingChanges;
    private Guid m_newSignature;
    private bool m_pendingChangesUpdated;
    private bool m_replayLocalVersionsRequired;
    public Failure[] Failures { get; }
    public PendingChange[] NewPendingChanges { get; }
    public Guid NewSignature { get; }
    public bool PendingChangesUpdated { get; }
    public bool ReplayLocalVersionsRequired { get; }
    public Failure[] get_Failures();
    public PendingChange[] get_NewPendingChanges();
    public Guid get_NewSignature();
    public bool get_PendingChangesUpdated();
    public bool get_ReplayLocalVersionsRequired();
    internal static ReconcileResult FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    internal void ToXml(XmlWriter writer, string element);
    internal static void ToXml(XmlWriter writer, string element, ReconcileResult obj);
}
public enum Microsoft.TeamFoundation.VersionControl.Client.RecursionType : Enum {
    public int value__;
    public static RecursionType Full;
    public static RecursionType None;
    public static RecursionType OneLevel;
}
internal class Microsoft.TeamFoundation.VersionControl.Client.RegisteredWaitWatcher : object {
    [CompilerGeneratedAttribute]
private FileSystemEventHandler Changed;
    [CompilerGeneratedAttribute]
private FileSystemEventHandler Created;
    [CompilerGeneratedAttribute]
private FileSystemEventHandler Deleted;
    [CompilerGeneratedAttribute]
private RenamedEventHandler Renamed;
    [CompilerGeneratedAttribute]
private ErrorEventHandler Error;
    private string m_path;
    private object m_lock;
    private SafeFileHandle m_directory;
    private IntPtr m_overlapped;
    private IntPtr m_buffer;
    private ManualResetEvent m_event;
    private RegisteredWaitHandle m_registeredWait;
    private bool m_enableRaisingEvents;
    private bool m_shuttingDown;
    private bool m_signedUpForAppDomainEvents;
    private WaitOrTimerCallback m_callback;
    private static int c_overlappedSize;
    private static int c_bufferSize;
    private static int c_notifyFilter;
    private static int s_internalLowOffset;
    private static int s_internalHighOffset;
    private static int s_eventHandleOffset;
    private static int s_overlappedSize;
    public bool EnableRaisingEvents { get; public set; }
    private static RegisteredWaitWatcher();
    public RegisteredWaitWatcher(string path);
    protected virtual override void Finalize();
    public void Dispose();
    private void Dispose(bool disposing);
    private void DisposeWorker(SafeFileHandle directory, IntPtr overlapped, IntPtr buffer, ManualResetEvent overlappedEvent, bool finalizing);
    private void EnsureBuffersCreated();
    private void CurrentDomain_DomainUnload(object sender, EventArgs e);
    public bool get_EnableRaisingEvents();
    public void set_EnableRaisingEvents(bool value);
    private void RegisteredWaitCallback(object state, bool timedOut);
    private int Watch();
    private int Completed(List`1<EventArgs> eventsToRaise);
    [CompilerGeneratedAttribute]
public void add_Changed(FileSystemEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Changed(FileSystemEventHandler value);
    [CompilerGeneratedAttribute]
public void add_Created(FileSystemEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Created(FileSystemEventHandler value);
    [CompilerGeneratedAttribute]
public void add_Deleted(FileSystemEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Deleted(FileSystemEventHandler value);
    private void OnFileSystemEventArgs(FileSystemEventArgs toDeliver);
    [CompilerGeneratedAttribute]
public void add_Renamed(RenamedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Renamed(RenamedEventHandler value);
    private void OnRenamed(RenamedEventArgs toDeliver);
    [CompilerGeneratedAttribute]
public void add_Error(ErrorEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Error(ErrorEventHandler value);
    private void OnError(ErrorEventArgs toDeliver);
}
public class Microsoft.TeamFoundation.VersionControl.Client.RenameWorkingFolderException : ServerItemException {
    public RenameWorkingFolderException(string message);
    public RenameWorkingFolderException(string message, Exception ex);
    protected RenameWorkingFolderException(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.Repository : VersionControlClientProxy {
    private Lazy`1<Uri> m_downloadBaseUri;
    private Lazy`1<Uri> m_uploadUri;
    private FileRepository m_fileRepository;
    protected Guid CollectionServiceIdentifier { get; }
    protected string ServiceType { get; }
    public Repository(TfsTeamProjectCollection connection);
    internal Repository(VersionControlServer sourceControl);
    protected virtual Guid get_CollectionServiceIdentifier();
    protected virtual string get_ServiceType();
    public void AddConflict(string workspaceName, string ownerName, ConflictType conflictType, int itemId, int versionFrom, int pendingChangeId, string sourceLocalItem, string targetLocalItem, int reason);
    public string CheckAuthentication();
    public CheckinResult CheckIn(string workspaceName, string ownerName, String[] serverItems, Changeset info, CheckinNotificationInfo checkinNotificationInfo, CheckinOptions checkinOptions, Failure[]& failures, bool deferCheckIn, int checkInTicket);
    public Failure[] CheckPendingChanges(string workspaceName, string ownerName, String[] serverItems);
    protected virtual Exception ConvertException(SoapException exception);
    public void CreateAnnotation(string AnnotationName, string AnnotatedItem, int Version, string AnnotationValue, string Comment, bool Overwrite);
    public CheckinResult CreateBranch(string sourcePath, string targetPath, VersionSpec version, Changeset info, CheckinNotificationInfo checkinNotificationInfo, Mapping[] mappings);
    public void CreateCheckinNoteDefinition(string associatedServerItem, CheckinNoteFieldDefinition[] checkinNoteFields);
    public void CreateTeamProjectFolder(TeamProjectFolderOptions teamProjectOptions);
    public Workspace CreateWorkspace(Workspace workspace);
    public void DeleteAnnotation(string AnnotationName, string AnnotatedItem, int Version, string AnnotationValue);
    public LabelResult[] DeleteLabel(string labelName, string labelScope);
    public void DeleteShelveset(string shelvesetName, string ownerName);
    public void DeleteWorkspace(string workspaceName, string ownerName);
    public Item[] Destroy(ItemSpec item, VersionSpec versionSpec, VersionSpec stopAtSpec, int flags, Failure[]& failures, PendingSet[]& pendingChanges, PendingSet[]& shelvedChanges);
    public GetOperation[][] Get(string workspaceName, string ownerName, GetRequest[] requests, bool force, bool noGet, int maxResults, int options);
    public RepositoryProperties GetRepositoryProperties();
    public LabelResult[] LabelItem(string workspaceName, string workspaceOwner, VersionControlLabel label, LabelItemSpec[] labelSpecs, LabelChildOption children, Failure[]& failures);
    public GetOperation[] Merge(string workspaceName, string workspaceOwner, ItemSpec source, ItemSpec target, VersionSpec from, VersionSpec to, MergeOptions options, LockLevel lockLevel, int optionsEx, Failure[]& failures, Conflict[]& conflicts);
    public GetOperation[] PendChanges(string workspaceName, string ownerName, ChangeRequest[] changes, int pendChangesOptions, int supportedFeatures, Failure[]& failures);
    public Annotation[] QueryAnnotation(string annotationName, string annotatedItem, int version);
    public BranchRelative[][] QueryBranches(string workspaceName, string workspaceOwner, ItemSpec[] items, VersionSpec version);
    public Change[] QueryChangesForChangeset(int changesetId, bool generateDownloadUrls, int pageSize, ItemSpec lastItem);
    public Changeset QueryChangeset(int changesetId, bool includeChanges, bool generateDownloadUrls, bool includeSourceRenames);
    public CheckinNoteFieldDefinition[] QueryCheckinNoteDefinition(String[] associatedServerItem);
    public String[] QueryCheckinNoteFieldNames();
    public Conflict[] QueryConflicts(string workspaceName, string ownerName, ItemSpec[] items);
    public String[] QueryEffectiveGlobalPermissions(string identityName);
    public String[] QueryEffectiveItemPermissions(string workspaceName, string workspaceOwner, string item, string identityName);
    public FileType[] QueryFileTypes();
    public GlobalSecurity QueryGlobalPermissions(String[] identityNames);
    public Changeset[] QueryHistory(string workspaceName, string workspaceOwner, ItemSpec itemSpec, VersionSpec versionItem, string user, VersionSpec versionFrom, VersionSpec versionTo, int maxCount, bool includeFiles, bool generateDownloadUrls, bool slotMode, bool sortAscending);
    public ItemSecurity[] QueryItemPermissions(string workspaceName, string workspaceOwner, ItemSpec[] itemSpecs, String[] identityNames, Failure[]& failures);
    public ItemSet[] QueryItems(string workspaceName, string workspaceOwner, ItemSpec[] items, VersionSpec version, DeletedState deletedState, ItemType itemType, bool generateDownloadUrls, int options);
    public Item[] QueryItemsById(Int32[] itemIds, int changeSet, bool generateDownloadUrls, int options);
    public ExtendedItem[][] QueryItemsExtended(string workspaceName, string workspaceOwner, ItemSpec[] items, DeletedState deletedState, ItemType itemType, int options);
    public VersionControlLabel[] QueryLabels(string workspaceName, string workspaceOwner, string labelName, string labelScope, string owner, string filterItem, VersionSpec versionFilterItem, bool includeItems, bool generateDownloadUrls);
    public LocalVersion[][] QueryLocalVersions(string workspaceName, string workspaceOwner, ItemSpec[] itemSpecs);
    public MergeCandidate[] QueryMergeCandidates(string workspaceName, string workspaceOwner, ItemSpec source, ItemSpec target, int options);
    public ChangesetMerge[] QueryMerges(string workspaceName, string workspaceOwner, ItemSpec source, VersionSpec versionSource, ItemSpec target, VersionSpec versionTarget, VersionSpec versionFrom, VersionSpec versionTo, int maxChangesets, bool showAll, Changeset[]& changesets);
    public ChangesetMergeDetails QueryMergesWithDetails(string workspaceName, string workspaceOwner, ItemSpec source, VersionSpec versionSource, ItemSpec target, VersionSpec versionTarget, VersionSpec versionFrom, VersionSpec versionTo, int maxChangesets, bool showAll);
    public PendingChange[] QueryPendingChangesById(Int32[] pendingChangeIds, bool generateDownloadUrls);
    public PendingChange[] QueryPendingChangesForWorkspace(string workspaceName, string workspaceOwner, ItemSpec[] itemSpecs, bool generateDownloadUrls, int pageSize, string lastChange, Failure[]& failures);
    public PendingSet[] QueryPendingSets(string localWorkspaceName, string localWorkspaceOwner, string queryWorkspaceName, string ownerName, ItemSpec[] itemSpecs, bool generateDownloadUrls, Failure[]& failures);
    public PendingSet[] QueryShelvedChanges(string localWorkspaceName, string localWorkspaceOwner, string shelvesetName, string ownerName, ItemSpec[] itemSpecs, bool generateDownloadUrls, Failure[]& failures);
    public Shelveset[] QueryShelvesets(string shelvesetName, string ownerName);
    public Workspace QueryWorkspace(string workspaceName, string ownerName);
    public Workspace[] QueryWorkspaces(string ownerName, string computer, int permissionsFilter);
    public void RefreshIdentityDisplayName();
    public void RemoveLocalConflict(string workspaceName, string ownerName, int conflictId);
    public GetOperation[] Resolve(string workspaceName, string ownerName, int conflictId, Resolution resolution, string newPath, int encoding, LockLevel lockLevel, GetOperation[]& undoOperations, Conflict[]& resolvedConflicts);
    public void SetFileTypes(FileType[] fileTypes);
    public Failure[] Shelve(string workspaceName, string workspaceOwner, String[] serverItems, Shelveset shelveset, bool replace);
    public GetOperation[] UndoPendingChanges(string workspaceName, string ownerName, ItemSpec[] items, Failure[]& failures);
    public LabelResult[] UnlabelItem(string workspaceName, string workspaceOwner, string labelName, string labelScope, ItemSpec[] items, VersionSpec version, Failure[]& failures);
    public Shelveset Unshelve(string shelvesetName, string shelvesetOwner, string workspaceName, string workspaceOwner, ItemSpec[] items, Failure[]& failures, GetOperation[]& getOperations);
    public void UpdateChangeset(int changeset, string comment, CheckinNote checkinNote);
    public void UpdateCheckinNoteFieldName(string path, string existingFieldName, string newFieldName);
    public PermissionChange[] UpdateGlobalSecurity(PermissionChange[] changes, Failure[]& failures);
    public SecurityChange[] UpdateItemSecurity(string workspaceName, string workspaceOwner, SecurityChange[] changes, Failure[]& failures);
    public void UpdateLocalVersion(string workspaceName, string ownerName, LocalVersionUpdate[] updates);
    public void UpdatePendingState(string workspaceName, string workspaceOwner, PendingState[] updates);
    public Workspace UpdateWorkspace(string oldWorkspaceName, string ownerName, Workspace newWorkspace, int supportedFeatures);
    public Changeset ChangesetFromArtifactUri(Uri artifactUri);
    public Shelveset ShelvesetFromArtifactUri(Uri artifactUri);
    public VersionControlLabel LabelFromArtifactUri(Uri artifactUri);
    public Item ItemFromArtifactUri(Uri artifactUri);
    public XmlReader RetrieveArtifactUri(Uri artifactUri);
    private Uri WebUriFromArtifactUri(Uri artifactUri);
    internal HttpWebRequest CreateDownloadRequest(string downloadUrl, CredentialsType proxyCredentials, Boolean& isProxyUrl);
    internal HttpWebRequest CreateUploadRequest();
    [CompilerGeneratedAttribute]
private Uri <.ctor>b__136_0();
    [CompilerGeneratedAttribute]
private Uri <.ctor>b__136_1();
}
internal class Microsoft.TeamFoundation.VersionControl.Client.Repository4 : VersionControlClientProxy {
    protected Guid CollectionServiceIdentifier { get; }
    protected string ServiceType { get; }
    public Repository4(TfsTeamProjectCollection connection);
    public Repository4(VersionControlServer sourceControl);
    protected virtual Guid get_CollectionServiceIdentifier();
    protected virtual string get_ServiceType();
    public CheckinResult CheckIn(string workspaceName, string ownerName, String[] serverItems, Changeset info, CheckinNotificationInfo checkinNotificationInfo, int checkinOptions, Failure[]& conflicts, Failure[]& failures, bool deferCheckIn, int checkInTicket);
    public CheckinResult CheckInShelveset(string shelvesetName, string ownerName, string changesetOwner, CheckinNotificationInfo checkinNotificationInfo, int checkinOptions, Failure[]& conflicts, Failure[]& failures);
    public Changeset[] CompareLabels(string startLabelName, string startLabelScope, string endLabelName, string endLabelScope, int minChangeSet, int maxCount);
    protected virtual Exception ConvertException(SoapException exception);
    public CheckinResult CreateBranch(string sourcePath, string targetPath, VersionSpec version, Changeset info, CheckinNotificationInfo checkinNotificationInfo, Mapping[] mappings, Failure[]& failures);
    public GetOperation[][] Get(string workspaceName, string ownerName, GetRequest[] requests, int maxResults, int options, String[] itemPropertyFilters, String[] itemAttributeFilters);
    public ServerSettings GetServerSettings();
    public GetOperation[] Merge(string workspaceName, string workspaceOwner, ItemSpec source, ItemSpec target, VersionSpec from, VersionSpec to, LockLevel lockLevel, int optionsEx, String[] itemPropertyFilters, String[] itemAttributeFilters, Failure[]& failures, Conflict[]& conflicts, Int32& changePendedFlags);
    public GetOperation[] PendChanges(string workspaceName, string ownerName, ChangeRequest[] changes, int pendChangesOptions, int supportedFeatures, String[] itemPropertyFilters, String[] itemAttributeFilters, Failure[]& failures, Int32& changePendedFlags);
    public GetOperation[] PendChangesInLocalWorkspace(string workspaceName, string ownerName, ChangeRequest[] changes, int pendChangesOptions, int supportedFeatures, Failure[]& failures, String[] itemPropertyFilters, String[] itemAttributeFilters, Int32& changePendedFlags);
    public Change[] QueryChangesForChangeset(int changesetId, bool generateDownloadUrls, int pageSize, ItemSpec lastItem, String[] itemPropertyFilters, String[] itemAttributeFilters, bool includeMergeSourceInfo);
    public Changeset QueryChangesetExtended(int changesetId, bool includeChanges, bool generateDownloadUrls, String[] changesetPropertyFilters, String[] itemAttributeFilters, String[] itemPropertyFilters);
    public ItemSet[] QueryItems(string workspaceName, string workspaceOwner, ItemSpec[] items, VersionSpec version, DeletedState deletedState, ItemType itemType, bool generateDownloadUrls, int options, String[] itemPropertyFilters, String[] itemAttributeFilters);
    public ExtendedItem[][] QueryItemsExtended(string workspaceName, string workspaceOwner, ItemSpec[] items, DeletedState deletedState, ItemType itemType, int options, String[] itemPropertyFilters);
    public Guid QueryPendingChangeSignature(string workspaceName, string ownerName);
    public PendingChange[] QueryPendingChangesForWorkspace(string workspaceName, string workspaceOwner, ItemSpec[] itemSpecs, bool generateDownloadUrls, int pageSize, string lastChange, bool includeMergeInfo, String[] itemPropertyFilters, Failure[]& failures);
    public PendingSet[] QueryPendingSets(string localWorkspaceName, string localWorkspaceOwner, string queryWorkspaceName, string ownerName, ItemSpec[] itemSpecs, bool generateDownloadUrls, String[] itemPropertyFilters, Failure[]& failures);
    public PendingSet[] QueryPendingSetsWithLocalWorkspaces(string localWorkspaceName, string localWorkspaceOwner, string queryWorkspaceName, string ownerName, ItemSpec[] itemSpecs, bool generateDownloadUrls, String[] itemPropertyFilters, Failure[]& failures);
    public PendingSet[] QueryShelvedChanges(string localWorkspaceName, string localWorkspaceOwner, string shelvesetName, string ownerName, ItemSpec[] itemSpecs, bool generateDownloadUrls, String[] itemPropertyFilters, Failure[]& failures);
    public Shelveset[] QueryShelvesets(string shelvesetName, string ownerName, String[] propertyNameFilters);
    public Workspace QueryWorkspace(string workspaceName, string ownerName);
    public WorkspaceItemSet[] QueryWorkspaceItems(string workspaceName, string workspaceOwner, ItemSpec[] items, DeletedState deletedState, ItemType itemType, bool generateDownloadUrls, int options);
    public Workspace[] QueryWorkspaces(string ownerName, string computer, int permissionsFilter);
    public ReconcileResult ReconcileLocalWorkspace(string workspaceName, string ownerName, Guid pendingChangeSignature, LocalPendingChange[] pendingChanges, ServerItemLocalVersionUpdate[] localVersionUpdates, bool clearLocalVersionTable);
    public GetOperation[] Resolve(string workspaceName, string ownerName, int conflictId, Resolution resolution, string newPath, int encoding, LockLevel lockLevel, PropertyValue[] newProperties, GetOperation[]& undoOperations, Conflict[]& resolvedConflicts, String[] itemPropertyFilters, String[] itemAttributeFilters, Int32& changePendedFlags);
    public GetOperation[] Rollback(string workspaceName, string workspaceOwner, ItemSpec[] items, VersionSpec itemVersion, VersionSpec from, VersionSpec to, int rollbackOptions, LockLevel lockLevel, String[] itemPropertyFilters, String[] itemAttributeFilters, Conflict[]& conflicts, Failure[]& failures, Int32& changePendedFlags);
    public void SetServerSettings(ServerSettings settings);
    public GetOperation[] UndoPendingChanges(string workspaceName, string ownerName, ItemSpec[] items, String[] itemPropertyFilters, String[] itemAttributeFilters, Failure[]& failures, Int32& changePendedFlags);
    public GetOperation[] UndoPendingChangesInLocalWorkspace(string workspaceName, string ownerName, ItemSpec[] items, Failure[]& failures, String[] itemPropertyFilters, String[] itemAttributeFilters, Int32& changePendedFlags);
    public Shelveset Unshelve(string shelvesetName, string shelvesetOwner, string workspaceName, string workspaceOwner, ItemSpec[] items, String[] itemPropertyFilters, String[] itemAttrbuteFilters, String[] shelvesetPropertyNameFilters, bool merge, Failure[]& failures, GetOperation[]& getOperations, Conflict[]& conflicts, Int32& changePendedFlags);
    public void UpdateLocalVersion(string workspaceName, string ownerName, ServerItemLocalVersionUpdate[] updates);
    public void UpdateShelveset(string shelvesetName, string ownerName, Shelveset updatedShelveset);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.Repository5 : VersionControlClientProxy {
    protected Guid CollectionServiceIdentifier { get; }
    protected string ServiceType { get; }
    public Repository5(TfsTeamProjectCollection connection);
    public Repository5(VersionControlServer sourceControl);
    protected virtual Guid get_CollectionServiceIdentifier();
    protected virtual string get_ServiceType();
    public void AddConflict(string workspaceName, string ownerName, ConflictType conflictType, int itemId, int versionFrom, int pendingChangeId, string sourceLocalItem, string targetLocalItem, int reason, int maxClientPathLength);
    public CheckinResult CheckIn(string workspaceName, string ownerName, String[] serverItems, Changeset info, CheckinNotificationInfo checkinNotificationInfo, int checkinOptions, Failure[]& conflicts, Failure[]& failures, bool deferCheckIn, int checkInTicket, int maxClientPathLength);
    public CheckinResult CheckInShelveset(string shelvesetName, string ownerName, string changesetOwner, CheckinNotificationInfo checkinNotificationInfo, int checkinOptions, int maxClientPathLength, Failure[]& conflicts, Failure[]& failures);
    public Failure[] CheckPendingChanges(string workspaceName, string ownerName, String[] serverItems, int maxClientPathLength);
    protected virtual Exception ConvertException(SoapException exception);
    public CheckinResult CreateBranch(string sourcePath, string targetPath, VersionSpec version, Changeset info, CheckinNotificationInfo checkinNotificationInfo, Mapping[] mappings, int maxClientPathLength, Failure[]& failures);
    public void CreateCheckinNoteDefinition(string associatedServerItem, CheckinNoteFieldDefinition[] checkinNoteFields, int maxClientPathLength);
    public void CreateTeamProjectFolder(TeamProjectFolderOptions teamProjectOptions, int maxClientPathLength);
    public void DeleteBranchObject(ItemIdentifier rootItem, int maxClientPathLength);
    public Item[] Destroy(ItemSpec item, VersionSpec versionSpec, VersionSpec stopAtSpec, int flags, int maxClientPathLength, Failure[]& failures, PendingSet[]& pendingChanges, PendingSet[]& shelvedChanges);
    public GetOperation[][] Get(string workspaceName, string ownerName, GetRequest[] requests, int maxResults, int options, String[] itemPropertyFilters, String[] itemAttributeFilters, int maxClientPathLength);
    public LabelResult[] LabelItem(string workspaceName, string workspaceOwner, VersionControlLabel label, LabelItemSpec[] labelSpecs, LabelChildOption children, int maxClientPathLength, Failure[]& failures);
    public GetOperation[] Merge(string workspaceName, string workspaceOwner, ItemSpec source, ItemSpec target, VersionSpec from, VersionSpec to, LockLevel lockLevel, int optionsEx, String[] itemPropertyFilters, String[] itemAttributeFilters, int maxClientPathLength, Failure[]& failures, Conflict[]& conflicts, Int32& changePendedFlags);
    public GetOperation[] PendChanges(string workspaceName, string ownerName, ChangeRequest[] changes, int pendChangesOptions, int supportedFeatures, String[] itemPropertyFilters, String[] itemAttributeFilters, int maxClientPathLength, Failure[]& failures, Int32& changePendedFlags);
    public GetOperation[] PendChangesInLocalWorkspace(string workspaceName, string ownerName, ChangeRequest[] changes, int pendChangesOptions, int supportedFeatures, Failure[]& failures, String[] itemPropertyFilters, String[] itemAttributeFilters, int maxClientPathLength, Int32& changePendedFlags);
    public void PromotePendingWorkspaceMappings(string workspaceName, string ownerName, int projectNotificationId);
    public BranchObject[] QueryBranchObjects(ItemIdentifier item, RecursionType recursion, int maxClientPathLength);
    public VersionControlLabel[] QueryLabels(string workspaceName, string workspaceOwner, string labelName, string labelScope, string owner, string filterItem, VersionSpec versionFilterItem, bool includeItems, bool generateDownloadUrls, int maxClientPathLength);
    public MergeCandidate[] QueryMergeCandidates(string workspaceName, string workspaceOwner, ItemSpec source, ItemSpec target, int options, int maxClientPathLength);
    public PendingSet[] QueryPendingSets(string localWorkspaceName, string localWorkspaceOwner, string queryWorkspaceName, string ownerName, ItemSpec[] itemSpecs, bool generateDownloadUrls, String[] itemPropertyFilters, int maxClientPathLength, Failure[]& failures);
    public PendingSet[] QueryPendingSetsWithLocalWorkspaces(string localWorkspaceName, string localWorkspaceOwner, string queryWorkspaceName, string ownerName, ItemSpec[] itemSpecs, bool generateDownloadUrls, String[] itemPropertyFilters, int maxClientPathLength, Failure[]& failures);
    public ReconcileResult ReconcileLocalWorkspace(string workspaceName, string ownerName, Guid pendingChangeSignature, LocalPendingChange[] pendingChanges, ServerItemLocalVersionUpdate[] localVersionUpdates, bool clearLocalVersionTable, bool throwOnProjectRenamed, int maxClientPathLength);
    public GetOperation[] Resolve(string workspaceName, string ownerName, int conflictId, Resolution resolution, string newPath, int encoding, LockLevel lockLevel, PropertyValue[] newProperties, GetOperation[]& undoOperations, Conflict[]& resolvedConflicts, String[] itemPropertyFilters, String[] itemAttributeFilters, int maxClientPathLength, Int32& changePendedFlags);
    public GetOperation[] Rollback(string workspaceName, string workspaceOwner, ItemSpec[] items, VersionSpec itemVersion, VersionSpec from, VersionSpec to, int rollbackOptions, LockLevel lockLevel, String[] itemPropertyFilters, String[] itemAttributeFilters, int maxClientPathLength, Conflict[]& conflicts, Failure[]& failures, Int32& changePendedFlags);
    public Failure[] Shelve(string workspaceName, string workspaceOwner, String[] serverItems, Shelveset shelveset, bool replace, int maxClientPathLength);
    public GetOperation[] UndoPendingChanges(string workspaceName, string ownerName, ItemSpec[] items, String[] itemPropertyFilters, String[] itemAttributeFilters, int maxClientPathLength, Failure[]& failures, Int32& changePendedFlags);
    public GetOperation[] UndoPendingChangesInLocalWorkspace(string workspaceName, string ownerName, ItemSpec[] items, Failure[]& failures, String[] itemPropertyFilters, String[] itemAttributeFilters, Int32& changePendedFlags, int maxClientPathLength);
    public LabelResult[] UnlabelItem(string workspaceName, string workspaceOwner, string labelName, string labelScope, ItemSpec[] items, VersionSpec version, int maxClientPathLength, Failure[]& failures);
    public Shelveset Unshelve(string shelvesetName, string shelvesetOwner, string workspaceName, string workspaceOwner, ItemSpec[] items, String[] itemPropertyFilters, String[] itemAttrbuteFilters, String[] shelvesetPropertyNameFilters, bool merge, int maxClientPathLength, Failure[]& failures, GetOperation[]& getOperations, Conflict[]& conflicts, Int32& changePendedFlags);
    public void UpdateBranchObject(BranchProperties branchProperties, bool updateExisting, int maxClientPathLength);
    public void UpdateLocalVersion(string workspaceName, string ownerName, ServerItemLocalVersionUpdate[] updates, int maxClientPathLength);
    public void UpdatePendingState(string workspaceName, string workspaceOwner, PendingState[] updates, int maxClientPathLength);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.RepositoryExtensions : VersionControlClientProxy {
    protected Guid CollectionServiceIdentifier { get; }
    protected string ServiceType { get; }
    public RepositoryExtensions(TfsTeamProjectCollection connection);
    public RepositoryExtensions(VersionControlServer sourceControl);
    protected virtual Guid get_CollectionServiceIdentifier();
    protected virtual string get_ServiceType();
    public void AddProxy(ProxyInfo proxy);
    public CheckinResult CheckIn(string workspaceName, string ownerName, String[] serverItems, Changeset info, CheckinNotificationInfo checkinNotificationInfo, int checkinOptions, Failure[]& failures, bool deferCheckIn, int checkInTicket);
    public CheckinResult CheckInShelveset(string shelvesetName, string ownerName, string changesetOwner, CheckinNotificationInfo checkinNotificationInfo, int checkinOptions, Failure[]& failures);
    protected virtual Exception ConvertException(SoapException exception);
    public void DeleteBranchObject(ItemIdentifier rootItem);
    public void DeleteProxy(string proxyUrl);
    public GetOperation[][] Get(string workspaceName, string ownerName, GetRequest[] requests, int maxResults, int options, String[] propertyNameFilters);
    public ArtifactPropertyValue GetChangesetProperty(int changesetId, String[] propertyNameFilters);
    public ArtifactPropertyValue[] GetVersionedItemProperty(string workspaceName, string workspaceOwner, ItemSpec[] itemSpecs, VersionSpec versionSpec, DeletedState deletedState, ItemType itemType, String[] propertyNameFilters);
    public GetOperation[] Merge(string workspaceName, string workspaceOwner, ItemSpec source, ItemSpec target, VersionSpec from, VersionSpec to, LockLevel lockLevel, int optionsEx, Failure[]& failures, Conflict[]& conflicts, String[] propertyNameFilters, Int32& changePendedFlags);
    public GetOperation[] PendChanges(string workspaceName, string ownerName, ChangeRequest[] changes, int pendChangesOptions, int supportedFeatures, Failure[]& failures, String[] propertyNameFilters, Int32& changePendedFlags);
    public BranchObjectOwnership[] QueryBranchObjectOwnership(Int32[] changesets, ItemSpec pathFilter);
    public BranchObject[] QueryBranchObjects(ItemIdentifier item, RecursionType recursion);
    public Change[] QueryChangesForChangeset(int changesetId, bool generateDownloadUrls, int pageSize, ItemSpec lastItem, String[] propertyNameFilters, bool includeMergeSourceInfo);
    public Changeset QueryChangesetExtended(int changesetId, bool includeChanges, bool generateDownloadUrls, String[] propertyNameFilters);
    public ItemIdentifier[] QueryMergeRelationships(string serverItem);
    public ExtendedMerge[] QueryMergesExtended(string workspaceName, string workspaceOwner, ItemSpec target, VersionSpec versionTarget, VersionSpec versionFrom, VersionSpec versionTo, int options);
    public PendingChange[] QueryPendingChangesForWorkspace(string workspaceName, string workspaceOwner, ItemSpec[] itemSpecs, bool generateDownloadUrls, int pageSize, string lastChange, bool includeMergeInfo, Failure[]& failures);
    public ProxyInfo[] QueryProxies(String[] proxyUrls);
    public void ResetCheckinDates(DateTime lastCheckinDate);
    public GetOperation[] Resolve(string workspaceName, string ownerName, int conflictId, Resolution resolution, string newPath, int encoding, LockLevel lockLevel, GetOperation[]& undoOperations, Conflict[]& resolvedConflicts, String[] propertyNameFilters, Int32& changePendedFlags);
    public GetOperation[] Rollback(string workspaceName, string workspaceOwner, ItemSpec[] items, VersionSpec itemVersion, VersionSpec from, VersionSpec to, int rollbackOptions, LockLevel lockLevel, Conflict[]& conflicts, Failure[]& failures, String[] propertyNameFilters, Int32& changePendedFlags);
    public void SetChangesetProperty(int changesetId, PropertyValue[] propertyValues);
    public Failure[] SetPendingChangeProperty(string workspaceName, string workspaceOwner, ArtifactPropertyValue[] pendingChangePropertyValues);
    public void SetVersionedItemProperty(string workspaceName, string workspaceOwner, ItemSpec[] itemSpecs, VersionSpec versionSpec, DeletedState deletedState, ItemType itemType, PropertyValue[] propertyValues);
    public ExtendedMerge[] TrackMerges(Int32[] sourceChangesets, ItemIdentifier sourceItem, ItemIdentifier[] targetItems, ItemSpec pathFilter, String[]& partialTargetItems);
    public GetOperation[] UndoPendingChanges(string workspaceName, string ownerName, ItemSpec[] items, Failure[]& failures, String[] propertyNameFilters, Int32& changePendedFlags);
    public Shelveset Unshelve(string shelvesetName, string shelvesetOwner, string workspaceName, string workspaceOwner, ItemSpec[] items, Failure[]& failures, GetOperation[]& getOperations, String[] propertyNameFilters);
    public void UpdateBranchObject(BranchProperties branchProperties, bool updateExisting);
}
public class Microsoft.TeamFoundation.VersionControl.Client.RepositoryNotFoundException : VersionControlException {
    public RepositoryNotFoundException(string repositoryUrl, string info);
    public RepositoryNotFoundException(string repositoryUrl, Exception innerException);
    public RepositoryNotFoundException(string repositoryUrl, string info, Exception innerException);
    protected RepositoryNotFoundException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.RepositoryPathTooLongDetailedException : VersionControlException {
    public RepositoryPathTooLongDetailedException(string message);
    public RepositoryPathTooLongDetailedException(string message, Exception ex);
    protected RepositoryPathTooLongDetailedException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.RepositoryPathTooLongDueToDeletedItemsException : VersionControlException {
    public RepositoryPathTooLongDueToDeletedItemsException(string message);
    public RepositoryPathTooLongDueToDeletedItemsException(string message, Exception ex);
    protected RepositoryPathTooLongDueToDeletedItemsException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.RepositoryPathTooLongException : VersionControlException {
    public RepositoryPathTooLongException(string message);
    public RepositoryPathTooLongException(string message, Exception ex);
    protected RepositoryPathTooLongException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.RepositoryProperties : object {
    internal Byte[] m_downloadKey;
    private Guid m_id;
    private int m_latestChangesetId;
    private string m_name;
    private int m_supportedFeatures;
    private string m_version;
    public Byte[] DownloadKey { get; public set; }
    public Guid Id { get; public set; }
    public int LatestChangesetId { get; public set; }
    public string Name { get; public set; }
    public int SupportedFeatures { get; public set; }
    public string Version { get; public set; }
    public Byte[] get_DownloadKey();
    public void set_DownloadKey(Byte[] value);
    public Guid get_Id();
    public void set_Id(Guid value);
    public int get_LatestChangesetId();
    public void set_LatestChangesetId(int value);
    public string get_Name();
    public void set_Name(string value);
    public int get_SupportedFeatures();
    public void set_SupportedFeatures(int value);
    public string get_Version();
    public void set_Version(string value);
    [EditorBrowsableAttribute("1")]
public static RepositoryProperties FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, RepositoryProperties obj);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.RepositorySecurityProvider : object {
    private VersionControlServer m_sourceControl;
    private SecurityNamespaceDescription m_description;
    public int ValidPermissions { get; }
    public Type PermissionsEnumType { get; }
    public SecurityNamespaceDescription SecurityNamespaceDescription { get; }
    public RepositorySecurityProvider(VersionControlServer sourceControl);
    public sealed virtual int get_ValidPermissions();
    public sealed virtual Type get_PermissionsEnumType();
    public sealed virtual SecurityNamespaceDescription get_SecurityNamespaceDescription();
    public sealed virtual String[] GetEffectivePermissions(string identityName, string item);
    public sealed virtual ItemSecurity[] GetPermissions(String[] identities, String[] items, RecursionType recursionType);
    public sealed virtual void SetPermissions(SecurityChange[] securityChanges);
}
public enum Microsoft.TeamFoundation.VersionControl.Client.RequestType : Enum {
    public int value__;
    public static RequestType Add;
    public static RequestType Branch;
    public static RequestType Delete;
    public static RequestType Edit;
    public static RequestType Encoding;
    public static RequestType Lock;
    public static RequestType None;
    public static RequestType Property;
    public static RequestType Rename;
    public static RequestType Undelete;
}
public class Microsoft.TeamFoundation.VersionControl.Client.ReservedAnnotationException : VersionControlException {
    public ReservedAnnotationException(string message);
    public ReservedAnnotationException(string message, Exception ex);
    protected ReservedAnnotationException(SerializationInfo info, StreamingContext context);
}
public enum Microsoft.TeamFoundation.VersionControl.Client.Resolution : Enum {
    public int value__;
    public static Resolution AcceptMerge;
    public static Resolution AcceptTheirs;
    public static Resolution AcceptYours;
    public static Resolution AcceptYoursRenameTheirs;
    public static Resolution DeleteConflict;
    public static Resolution None;
    public static Resolution OverwriteLocal;
}
public class Microsoft.TeamFoundation.VersionControl.Client.ResolutionOptions : object {
    [CompilerGeneratedAttribute]
private PropertyValue[] <AcceptMergeProperties>k__BackingField;
    private bool m_isEncodingOverride;
    private bool m_isConvertToEncoding;
    private int m_encoding;
    private bool m_useInternalEngine;
    private int m_acceptMergeEncoding;
    private string m_newPath;
    private bool m_acceptMergeWithConflicts;
    public bool IsEncodingOverride { get; public set; }
    public bool IsConvertToEncoding { get; public set; }
    public int Encoding { get; public set; }
    public bool UseInternalEngine { get; public set; }
    public int AcceptMergeEncoding { get; public set; }
    public PropertyValue[] AcceptMergeProperties { get; public set; }
    public bool AcceptMergeWithConflicts { get; public set; }
    public string NewPath { get; public set; }
    public bool get_IsEncodingOverride();
    public void set_IsEncodingOverride(bool value);
    public bool get_IsConvertToEncoding();
    public void set_IsConvertToEncoding(bool value);
    public int get_Encoding();
    public void set_Encoding(int value);
    public bool get_UseInternalEngine();
    public void set_UseInternalEngine(bool value);
    public int get_AcceptMergeEncoding();
    public void set_AcceptMergeEncoding(int value);
    [CompilerGeneratedAttribute]
public PropertyValue[] get_AcceptMergeProperties();
    [CompilerGeneratedAttribute]
public void set_AcceptMergeProperties(PropertyValue[] value);
    public bool get_AcceptMergeWithConflicts();
    public void set_AcceptMergeWithConflicts(bool value);
    public string get_NewPath();
    public void set_NewPath(string value);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.ResolvedConflictDetails : object {
    [CompilerGeneratedAttribute]
private Conflict <Conflict>k__BackingField;
    [CompilerGeneratedAttribute]
private GetOperation[] <GetOps>k__BackingField;
    [CompilerGeneratedAttribute]
private GetOperation[] <UndoOps>k__BackingField;
    [CompilerGeneratedAttribute]
private Conflict[] <ResolvedConflicts>k__BackingField;
    [CompilerGeneratedAttribute]
private ChangePendedFlags <Flags>k__BackingField;
    public Conflict Conflict { get; public set; }
    public GetOperation[] GetOps { get; public set; }
    public GetOperation[] UndoOps { get; public set; }
    public Conflict[] ResolvedConflicts { get; public set; }
    public ChangePendedFlags Flags { get; public set; }
    [CompilerGeneratedAttribute]
public Conflict get_Conflict();
    [CompilerGeneratedAttribute]
public void set_Conflict(Conflict value);
    [CompilerGeneratedAttribute]
public GetOperation[] get_GetOps();
    [CompilerGeneratedAttribute]
public void set_GetOps(GetOperation[] value);
    [CompilerGeneratedAttribute]
public GetOperation[] get_UndoOps();
    [CompilerGeneratedAttribute]
public void set_UndoOps(GetOperation[] value);
    [CompilerGeneratedAttribute]
public Conflict[] get_ResolvedConflicts();
    [CompilerGeneratedAttribute]
public void set_ResolvedConflicts(Conflict[] value);
    [CompilerGeneratedAttribute]
public ChangePendedFlags get_Flags();
    [CompilerGeneratedAttribute]
public void set_Flags(ChangePendedFlags value);
}
public class Microsoft.TeamFoundation.VersionControl.Client.ResolvedConflictEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private ChangePendedFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OperationId>k__BackingField;
    private Conflict m_conflict;
    private Workspace m_workspace;
    public Conflict Conflict { get; }
    public Workspace Workspace { get; }
    public ChangePendedFlags Flags { get; private set; }
    public int OperationId { get; private set; }
    internal ResolvedConflictEventArgs(Conflict conflict, Workspace workspace, ChangePendedFlags flags, int operationId);
    public Conflict get_Conflict();
    public Workspace get_Workspace();
    [CompilerGeneratedAttribute]
public ChangePendedFlags get_Flags();
    [CompilerGeneratedAttribute]
private void set_Flags(ChangePendedFlags value);
    [CompilerGeneratedAttribute]
public int get_OperationId();
    [CompilerGeneratedAttribute]
private void set_OperationId(int value);
}
public class Microsoft.TeamFoundation.VersionControl.Client.ResolvedConflictEventHandler : MulticastDelegate {
    public ResolvedConflictEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ResolvedConflictEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ResolvedConflictEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.ResolveRequiresOneResolutionException : VersionConflictException {
}
public class Microsoft.TeamFoundation.VersionControl.Client.ResourceAccessException : SecurityException {
    public ResourceAccessException(string message);
    public ResourceAccessException(string message, Exception ex);
    protected ResourceAccessException(SerializationInfo info, StreamingContext context);
    public ResourceAccessException(string identityName, string permissionName, string resourceName);
    public ResourceAccessException(string identityName, string permissionName);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.RetryEntry : object {
    internal OperationStatus m_status;
    internal GetOperation m_retryOp;
    internal GetOperation m_targetAction;
    internal RetryEntry(OperationStatus status, GetOperation retryOp, GetOperation targetAction);
}
public class Microsoft.TeamFoundation.VersionControl.Client.RollbackInvalidOptionException : VersionControlException {
    public RollbackInvalidOptionException(string message);
    public RollbackInvalidOptionException(string message, Exception ex);
    protected RollbackInvalidOptionException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.RollbackInvalidVersionSpecException : VersionControlException {
    public RollbackInvalidVersionSpecException(string message);
    public RollbackInvalidVersionSpecException(string message, Exception ex);
    protected RollbackInvalidVersionSpecException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.RootInheritanceException : VersionControlException {
    public RootInheritanceException(string message);
    public RootInheritanceException(string message, Exception ex);
    protected RootInheritanceException(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.RuntimeWorkspaceCache : object {
    private Dictionary`2<string, WeakReference> m_cache;
    private ReaderWriterLockSlim m_rwLock;
    private VersionControlServer m_sourceControl;
    public List`1<Workspace> Workspaces { get; }
    public RuntimeWorkspaceCache(VersionControlServer sourceControl);
    public Workspace TryGetWorkspace(WorkspaceInfo workspaceInfo);
    public Workspace TryGetWorkspace(string workspaceName, string workspaceOwner);
    public Workspace GetWorkspace(WorkspaceInfo workspaceInfo);
    public Workspace CacheWorkspace(Workspace workspace);
    public Workspace[] CacheWorkspaces(Workspace[] workspaces);
    public void UpdateWorkspace(Workspace existingWorkspace, Workspace newWorkspace);
    private Workspace ConstructWorkspaceFromWorkspaceInfo(WorkspaceInfo workspaceInfo);
    private void CheckServerGuid(Guid toCheck, string propertyName);
    private void CheckVersionControlServer(VersionControlServer toCheck, string propertyName);
    private Workspace TryGetWorkspaceHelper(string workspaceName, string workspaceOwner);
    [IteratorStateMachineAttribute("Microsoft.TeamFoundation.VersionControl.Client.RuntimeWorkspaceCache/<TryGetWorkspacesHelper>d__11")]
private IEnumerable`1<Workspace> TryGetWorkspacesHelper(string workspaceName, string workspaceOwner);
    private void PruneDeadReferences();
    private static string GetCacheKey(Workspace workspace);
    private static string GetCacheKey(WorkspaceInfo workspaceInfo);
    public List`1<Workspace> get_Workspaces();
}
public class Microsoft.TeamFoundation.VersionControl.Client.SavedCheckin : object {
    private Dictionary`2<string, CheckinItem> m_excludedItems;
    private string m_comment;
    private CheckinNote m_checkinNotes;
    private WorkItemCheckedInfo[] m_persistentWorkItemsCheckedInfo;
    private string m_policyOverrideComment;
    private static string m_xmlSavedCheckin;
    private static string m_xmlSelectedItems;
    private static string m_xmlExcludedItems;
    private static string m_xmlComment;
    private static string m_xmlPolicyOverrideComment;
    private static string m_xmlItem;
    private static string m_xmlServerItem;
    private static string m_xmlItemId;
    private static string m_xmlWorkItemsCheckedInfo;
    public string Comment { get; public set; }
    public string PolicyOverrideComment { get; public set; }
    public CheckinNote CheckinNotes { get; public set; }
    public WorkItemCheckedInfo[] WorkItemsCheckedInfo { get; public set; }
    [ObsoleteAttribute("This property is no longer supported")]
public int Count { get; }
    [EditorBrowsableAttribute("1")]
public ICollection`1<string> ExcludedServerPaths { get; public set; }
    [ObsoleteAttribute("This constructor has been deprecated, use the constructor with excluded changes.")]
public SavedCheckin(PendingChange[] changes, string comment, CheckinNote checkinNotes, WorkItemCheckinInfo[] workItemCheckinInfo, string policyOverrideComment);
    [ObsoleteAttribute("This constructor has been deprecated, use the constructor with excluded changes.")]
public SavedCheckin(PendingChange[] changes, string comment, CheckinNote checkinNotes, WorkItemCheckedInfo[] workItemCheckedInfo, string policyOverrideComment);
    public SavedCheckin(string comment, PendingChange[] excludedChanges, CheckinNote checkinNotes, WorkItemCheckedInfo[] workItemCheckedInfo, string policyOverrideComment);
    internal SavedCheckin(ICollection`1<string> excludedServerPaths, string comment, CheckinNote checkinNotes, WorkItemCheckedInfo[] workItemCheckedInfo, string policyOverrideComment);
    private SavedCheckin(Dictionary`2<string, CheckinItem> excludedItems, string comment, CheckinNote checkinNotes, WorkItemCheckedInfo[] workItemsCheckedInfo, string policyOverrideComment);
    internal SavedCheckin(Shelveset shelveset);
    [EditorBrowsableAttribute("1")]
public SavedCheckin Clone();
    private void Initialize(string comment, CheckinNote checkinNotes, WorkItemCheckedInfo[] workItemsCheckedInfo, string policyOverrideComment, bool mergeWorkItems);
    [ObsoleteAttribute("This method has been deprecated, use IsExcluded instead.")]
public bool HasMatchingCheckinItem(PendingChange pc);
    public bool IsExcluded(string targetServerItem);
    internal void MergeShelvesetMetadata(Shelveset shelveset, PendingChange[] unshelvedChanges);
    internal void MergeWorkItems(WorkItemCheckedInfo[] workItems);
    public void UpdateCheckinItems(PendingChange[] checkedPendingChanges, PendingChange[] uncheckedPendingChanges);
    internal static SavedCheckin LoadFromXml(XmlNode attemptedCheckinNode);
    private static void LoadItemsFromXml(XmlNode child, Dictionary`2<string, CheckinItem> itemList);
    internal void SaveAsXml(XmlNode parent);
    private void SaveItemsAsXml(XmlDocument outputDoc, XmlNode attemptedCheckinNode, string tagName, Dictionary`2<string, CheckinItem> itemList);
    public string get_Comment();
    [EditorBrowsableAttribute("1")]
public void set_Comment(string value);
    public string get_PolicyOverrideComment();
    [EditorBrowsableAttribute("1")]
public void set_PolicyOverrideComment(string value);
    public CheckinNote get_CheckinNotes();
    [EditorBrowsableAttribute("1")]
public void set_CheckinNotes(CheckinNote value);
    public WorkItemCheckedInfo[] get_WorkItemsCheckedInfo();
    [EditorBrowsableAttribute("1")]
public void set_WorkItemsCheckedInfo(WorkItemCheckedInfo[] value);
    public int get_Count();
    public ICollection`1<string> get_ExcludedServerPaths();
    public void set_ExcludedServerPaths(ICollection`1<string> value);
}
public abstract class Microsoft.TeamFoundation.VersionControl.Client.SecurityChange : object {
    protected string m_item;
    public string Item { get; public set; }
    public string get_Item();
    public void set_Item(string value);
    [EditorBrowsableAttribute("1")]
public static SecurityChange FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public abstract virtual void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, SecurityChange obj);
}
public class Microsoft.TeamFoundation.VersionControl.Client.SecurityConfigurationException : VersionControlException {
    public SecurityConfigurationException(string message);
    public SecurityConfigurationException(string message, Exception ex);
    protected SecurityConfigurationException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.SecurityException : VersionControlException {
    public SecurityException(string message);
    public SecurityException(string message, Exception ex);
    protected SecurityException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.ServerItemException : VersionControlException {
    public ServerItemException(string message);
    public ServerItemException(string message, Exception ex);
    protected ServerItemException(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.ServerItemIsCommittedTuple : ValueType {
    public string CommittedServerItem;
    public bool IsCommitted;
    public ServerItemIsCommittedTuple(string committedServerItem, bool isCommitted);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.ServerItemIsCommittedTupleComparer : object {
    public sealed virtual bool Equals(ServerItemIsCommittedTuple x, ServerItemIsCommittedTuple y);
    public sealed virtual int GetHashCode(ServerItemIsCommittedTuple obj);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.ServerItemLocalVersionUpdate : object {
    private static ServerItemLocalVersionUpdateComparer s_comparer;
    private int m_itemId;
    private int m_localVersion;
    private string m_sourceServerItem;
    private string m_targetLocalItem;
    public bool IsCommitted { get; }
    public static IEqualityComparer`1<ServerItemLocalVersionUpdate> Comparer { get; }
    public int ItemId { get; public set; }
    public int LocalVersion { get; public set; }
    public string SourceServerItem { get; public set; }
    public string TargetLocalItem { get; public set; }
    public ServerItemLocalVersionUpdate(ILocalVersionUpdate sourceUpdate);
    public bool get_IsCommitted();
    public static IEqualityComparer`1<ServerItemLocalVersionUpdate> get_Comparer();
    public int get_ItemId();
    public void set_ItemId(int value);
    public int get_LocalVersion();
    public void set_LocalVersion(int value);
    public string get_SourceServerItem();
    public void set_SourceServerItem(string value);
    public string get_TargetLocalItem();
    public void set_TargetLocalItem(string value);
    internal static ServerItemLocalVersionUpdate FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    internal void ToXml(XmlWriter writer, string element);
    internal static void ToXml(XmlWriter writer, string element, ServerItemLocalVersionUpdate obj);
}
public class Microsoft.TeamFoundation.VersionControl.Client.ServerItemRequiredException : ServerItemException {
    public ServerItemRequiredException(string message);
    public ServerItemRequiredException(string message, Exception ex);
    protected ServerItemRequiredException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.ServerSettings : object {
    private bool m_allowAsynchronousCheckoutInServerWorkspaces;
    private LocalItemExclusionSet m_defaultLocalItemExclusionSet;
    private byte m_defaultWorkspaceLocation;
    private int m_maxAllowedServerPathLength;
    private string m_stableHashString;
    private bool m_isDefault;
    private static ServerSettings s_default;
    public bool AllowAsynchronousCheckoutInServerWorkspaces { get; public set; }
    internal LocalItemExclusionSet DefaultLocalItemExclusionSet { get; internal set; }
    internal string StableHashString { get; internal set; }
    public WorkspaceLocation DefaultWorkspaceLocation { get; public set; }
    public PathLength MaxServerPathLength { get; public set; }
    public static ServerSettings Default { get; }
    public bool IsDefault { get; }
    public ServerSettings(WorkspaceLocation workspaceLocation);
    public ServerSettings(ServerSettings settingsToCopy);
    public bool get_AllowAsynchronousCheckoutInServerWorkspaces();
    public void set_AllowAsynchronousCheckoutInServerWorkspaces(bool value);
    internal LocalItemExclusionSet get_DefaultLocalItemExclusionSet();
    internal void set_DefaultLocalItemExclusionSet(LocalItemExclusionSet value);
    internal string get_StableHashString();
    internal void set_StableHashString(string value);
    [EditorBrowsableAttribute("1")]
public static ServerSettings FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, ServerSettings obj);
    public WorkspaceLocation get_DefaultWorkspaceLocation();
    public void set_DefaultWorkspaceLocation(WorkspaceLocation value);
    public PathLength get_MaxServerPathLength();
    public void set_MaxServerPathLength(PathLength value);
    public static ServerSettings get_Default();
    public bool get_IsDefault();
}
internal class Microsoft.TeamFoundation.VersionControl.Client.ServerSettingsCache : object {
    private Guid m_serverGuid;
    private ServerSettings m_serverSettings;
    private object m_lock;
    private static int c_version;
    private static string c_versionString;
    private static string c_serverSettingsString;
    private static string c_serverCacheString;
    public ServerSettings Settings { get; }
    private string FileName { get; }
    public ServerSettingsCache(Guid serverGuid);
    public ServerSettings get_Settings();
    public void UpdateFrom(ServerSettings serverSettings);
    private ServerSettings Load();
    private string get_FileName();
    private static ServerSettings FromFile(string filename);
    private static void ToFile(ServerSettings settings, string filename);
}
public class Microsoft.TeamFoundation.VersionControl.Client.SetWorkspaceLocationProgressEventArgs : EventArgs {
    private Workspace m_workspace;
    private int m_progressIncrement;
    private int m_progressTotal;
    private bool m_cancelable;
    private string m_statusMessage;
    private string m_fileName;
    public Workspace Workspace { get; }
    public int ProgressIncrement { get; }
    public int ProgressTotal { get; }
    public bool Cancelable { get; }
    public string StatusMessage { get; }
    public string FileName { get; }
    internal SetWorkspaceLocationProgressEventArgs(Workspace workspace, int progressIncrement, int progressTotal, bool cancelable, string statusMessage);
    internal SetWorkspaceLocationProgressEventArgs(Workspace workspace, int progressIncrement, int progressTotal, bool cancelable, string statusMessage, string fileName);
    public Workspace get_Workspace();
    public int get_ProgressIncrement();
    public int get_ProgressTotal();
    public bool get_Cancelable();
    public string get_StatusMessage();
    public string get_FileName();
}
public class Microsoft.TeamFoundation.VersionControl.Client.SetWorkspaceLocationProgressEventHandler : MulticastDelegate {
    public SetWorkspaceLocationProgressEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, SetWorkspaceLocationProgressEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, SetWorkspaceLocationProgressEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum Microsoft.TeamFoundation.VersionControl.Client.SeverityType : Enum {
    public int value__;
    public static SeverityType Error;
    public static SeverityType Warning;
}
public class Microsoft.TeamFoundation.VersionControl.Client.ShelvedChangeNotFoundException : ServerItemException {
    public ShelvedChangeNotFoundException(string message);
    public ShelvedChangeNotFoundException(string message, Exception ex);
    protected ShelvedChangeNotFoundException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.ShelveException : VersionControlException {
    public ShelveException(string message);
    public ShelveException(string message, Exception exception);
    public ShelveException(Exception innerException);
    protected ShelveException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.ShelveMergeConflictExistsException : VersionControlException {
    public ShelveMergeConflictExistsException(string message);
    public ShelveMergeConflictExistsException(string message, Exception ex);
    protected ShelveMergeConflictExistsException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.Shelveset : object {
    private bool m_changesExcluded;
    private CheckinNote m_checkinNote;
    private string m_comment;
    private DateTime m_creationDate;
    internal PropertyValue[] m_internalProperties;
    internal VersionControlLink[] m_links;
    private string m_name;
    private string m_owner;
    private string m_ownerDisplayName;
    private string m_ownerUniqueName;
    private string m_policyOverrideComment;
    private VersionControlServer m_sourceControl;
    private WorkItemCheckinInfo[] m_workItemInfo;
    private Dictionary`2<string, PropertyValue> m_properties;
    private List`1<string> m_removedProperties;
    private static ShelvesetComparer m_nameComparer;
    public bool ChangesExcluded { get; public set; }
    public CheckinNote CheckinNote { get; public set; }
    public string Comment { get; public set; }
    public DateTime CreationDate { get; public set; }
    public string Name { get; public set; }
    public string PolicyOverrideComment { get; public set; }
    public WorkItemCheckinInfo[] WorkItemInfo { get; public set; }
    public WorkItemCheckedInfo[] BriefWorkItemInfo { get; }
    public Uri ArtifactUri { get; }
    public AssociatedWorkItemInfo[] AssociatedWorkItems { get; }
    public string DisplayName { get; }
    public string QualifiedName { get; }
    public string OwnerName { get; public set; }
    public string OwnerDisplayName { get; public set; }
    public static IComparer NameComparer { get; }
    public VersionControlServer VersionControlServer { get; internal set; }
    [XmlIgnoreAttribute]
public ReadOnlyCollection`1<PropertyValue> Properties { get; }
    private WorkItemStore WorkItemStore { get; }
    public Shelveset(VersionControlServer sourceControl, string name, string owner);
    public Shelveset(VersionControlServer sourceControl, string name, string owner, IEnumerable`1<PropertyValue> properties);
    public bool get_ChangesExcluded();
    public void set_ChangesExcluded(bool value);
    public CheckinNote get_CheckinNote();
    public void set_CheckinNote(CheckinNote value);
    public string get_Comment();
    public void set_Comment(string value);
    public DateTime get_CreationDate();
    public void set_CreationDate(DateTime value);
    public string get_Name();
    public void set_Name(string value);
    public string get_PolicyOverrideComment();
    public void set_PolicyOverrideComment(string value);
    [EditorBrowsableAttribute("1")]
public static Shelveset FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, Shelveset obj);
    public WorkItemCheckinInfo[] get_WorkItemInfo();
    public void set_WorkItemInfo(WorkItemCheckinInfo[] value);
    public WorkItemCheckedInfo[] get_BriefWorkItemInfo();
    public Uri get_ArtifactUri();
    public AssociatedWorkItemInfo[] get_AssociatedWorkItems();
    public string get_DisplayName();
    public string get_QualifiedName();
    public string get_OwnerName();
    public void set_OwnerName(string value);
    public string get_OwnerDisplayName();
    public void set_OwnerDisplayName(string value);
    public static IComparer get_NameComparer();
    public VersionControlServer get_VersionControlServer();
    internal void set_VersionControlServer(VersionControlServer value);
    public ReadOnlyCollection`1<PropertyValue> get_Properties();
    public void SetProperty(PropertyValue propertyValue);
    public void RemoveProperty(string propertyName);
    public Shelveset CreateCopy(string newName, string newOwner);
    public void LoadLastSavedCheckinMetadata(Workspace workspace);
    internal List`1<string> ShelvesetUpdatedSuccessfully();
    private WorkItemStore get_WorkItemStore();
    private void AfterDeserialize();
    private void BeforeSerialize();
}
public class Microsoft.TeamFoundation.VersionControl.Client.ShelvesetCheckInParameters : CheckInParameters {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OwnerName>k__BackingField;
    public string Name { get; public set; }
    public string OwnerName { get; public set; }
    public bool DeleteShelveset { get; public set; }
    public ShelvesetCheckInParameters(string shelvesetName, string shelvesetOwnerName);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_OwnerName();
    [CompilerGeneratedAttribute]
public void set_OwnerName(string value);
    public bool get_DeleteShelveset();
    public void set_DeleteShelveset(bool value);
    internal virtual void Validate();
}
internal class Microsoft.TeamFoundation.VersionControl.Client.ShelvesetComparer : object {
    private sealed virtual override int System.Collections.IComparer.Compare(object x, object y);
}
public class Microsoft.TeamFoundation.VersionControl.Client.ShelvesetExistsException : VersionControlException {
    public ShelvesetExistsException(string message);
    public ShelvesetExistsException(string message, Exception ex);
    protected ShelvesetExistsException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.ShelvesetNotFoundException : VersionControlException {
    public ShelvesetNotFoundException(string message);
    public ShelvesetNotFoundException(string message, Exception ex);
    protected ShelvesetNotFoundException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.ShelvesetUpdatedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Shelveset <Shelveset>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <RemovedProperties>k__BackingField;
    public Shelveset Shelveset { get; private set; }
    public List`1<string> RemovedProperties { get; private set; }
    internal ShelvesetUpdatedEventArgs(Shelveset shelveset, List`1<string> removedProperties);
    [CompilerGeneratedAttribute]
public Shelveset get_Shelveset();
    [CompilerGeneratedAttribute]
private void set_Shelveset(Shelveset value);
    [CompilerGeneratedAttribute]
public List`1<string> get_RemovedProperties();
    [CompilerGeneratedAttribute]
private void set_RemovedProperties(List`1<string> value);
}
public class Microsoft.TeamFoundation.VersionControl.Client.ShelvesetUpdatedEventHandler : MulticastDelegate {
    public ShelvesetUpdatedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ShelvesetUpdatedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ShelvesetUpdatedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[FlagsAttribute]
public enum Microsoft.TeamFoundation.VersionControl.Client.ShelvingOptions : Enum {
    public int value__;
    public static ShelvingOptions None;
    public static ShelvingOptions Move;
    public static ShelvingOptions Replace;
}
public class Microsoft.TeamFoundation.VersionControl.Client.ShelvingPartialRenameConflictException : VersionControlException {
    public ShelvingPartialRenameConflictException(string message);
    public ShelvingPartialRenameConflictException(string message, Exception ex);
    protected ShelvingPartialRenameConflictException(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.SourceControlSecurityNamespace : SecurityNamespace {
    private TfsTeamProjectCollection m_server;
    private ISourceControlSecurityNamespaceProvider m_securityProvider;
    private IIdentityManagementService m_identityService;
    public SecurityNamespaceDescription Description { get; }
    public SourceControlSecurityNamespace(TfsTeamProjectCollection server, ISourceControlSecurityNamespaceProvider securityProvider);
    public virtual SecurityNamespaceDescription get_Description();
    public virtual Collection`1<bool> HasPermission(string token, IdentityDescriptor descriptor, IEnumerable`1<int> requestedPermissions, bool alwaysAllowAdministrators);
    public virtual Collection`1<bool> HasPermission(string token, IEnumerable`1<IdentityDescriptor> descriptors, int requestedPermissions, bool alwaysAllowAdministrators);
    public virtual Collection`1<bool> HasPermission(IEnumerable`1<string> tokens, IdentityDescriptor descriptor, int requestedPermissions, bool alwaysAllowAdministrators);
    public virtual bool HasPermission(string token, IdentityDescriptor descriptor, int requestedPermissions, bool alwaysAllowAdministrators);
    public virtual Collection`1<bool> HasWritePermission(string token, IEnumerable`1<int> permissionsToChange);
    public virtual bool HasWritePermission(string token, int permissionsToChange);
    public virtual int QueryEffectivePermissions(string token, IdentityDescriptor descriptor);
    public virtual AccessControlList QueryAccessControlList(string token, IEnumerable`1<IdentityDescriptor> descriptors, bool includeExtendedInfo);
    public virtual Collection`1<AccessControlList> QueryAccessControlLists(string token, IEnumerable`1<IdentityDescriptor> descriptors, bool includeExtendedInfo, bool recurse);
    public virtual bool RemoveAccessControlLists(string token, bool recurse);
    public virtual bool RemoveAccessControlLists(IEnumerable`1<string> tokens, bool recurse);
    public virtual AccessControlEntry RemovePermissions(string token, IdentityDescriptor descriptor, int permissionsToRemove);
    public virtual bool RemoveAccessControlEntry(string token, IdentityDescriptor descriptor);
    public virtual bool RemoveAccessControlEntries(string token, IEnumerable`1<IdentityDescriptor> descriptors);
    public virtual void SetAccessControlList(AccessControlList accessControlList);
    public virtual void SetAccessControlLists(IEnumerable`1<AccessControlList> accessControlLists);
    public virtual void SetInheritFlag(string token, bool inherit);
    public virtual AccessControlEntry SetAccessControlEntry(string token, AccessControlEntry permission, bool merge);
    public virtual AccessControlEntry SetPermissions(string token, IdentityDescriptor descriptor, int allow, int deny, bool merge);
    public virtual Collection`1<AccessControlEntry> SetAccessControlEntries(string token, IEnumerable`1<AccessControlEntry> permissions, bool merge);
    private string ResolveIdentityName(IdentityDescriptor descriptor);
    private Dictionary`2<IdentityDescriptor, string> ResolveIdentityNames(IEnumerable`1<IdentityDescriptor> descriptors);
    private Dictionary`2<string, TeamFoundationIdentity> ResolveIdentities(IEnumerable`1<string> identityNames);
    private void RemovePermissionHelper(string token, IEnumerable`1<AccessControlEntry> permissionsToRemove);
}
public class Microsoft.TeamFoundation.VersionControl.Client.TargetCloakedException : ServerItemException {
    public TargetCloakedException(string message);
    public TargetCloakedException(string message, Exception ex);
    protected TargetCloakedException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.TargetHasPendingChangeException : ServerItemException {
    public TargetHasPendingChangeException(string message);
    public TargetHasPendingChangeException(string message, Exception ex);
    protected TargetHasPendingChangeException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.TargetIsChildException : VersionControlException {
    public TargetIsChildException(string message);
    public TargetIsChildException(string message, Exception ex);
    protected TargetIsChildException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.TeamFoundationVersionControlNotEnabledForTeamProject : VersionControlException {
    public TeamFoundationVersionControlNotEnabledForTeamProject(string message);
    public TeamFoundationVersionControlNotEnabledForTeamProject(string message, Exception ex);
    protected TeamFoundationVersionControlNotEnabledForTeamProject(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.TeamProject : object {
    private Item m_item;
    private Uri m_teamProjectUri;
    public string Name { get; }
    public string ServerItem { get; }
    public Uri ArtifactUri { get; }
    public bool ExclusiveCheckout { get; public set; }
    public bool GetLatestOnCheckout { get; public set; }
    public VersionControlServer VersionControlServer { get; }
    public TfsTeamProjectCollection TeamProjectCollection { get; }
    internal int ItemId { get; }
    private WebServiceLayer WebServiceLayer { get; }
    private TeamProject(Item item);
    internal static TeamProject[] FromItems(Item[] items);
    internal static String[] ToServerItems(TeamProject[] teamProjects);
    internal static bool ValidateChange(string serverItem, ItemType type, Failure& failure);
    public PolicyEnvelope[] GetCheckinPolicies();
    public void SetCheckinPolicies(PolicyEnvelope[] policies);
    public void SetCheckinNoteFields(CheckinNoteFieldDefinition[] checkinNoteFields);
    public CheckinNoteFieldDefinition[] GetCheckinNoteFields();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public string get_Name();
    public string get_ServerItem();
    public Uri get_ArtifactUri();
    public bool get_ExclusiveCheckout();
    public void set_ExclusiveCheckout(bool value);
    public bool get_GetLatestOnCheckout();
    public void set_GetLatestOnCheckout(bool value);
    public VersionControlServer get_VersionControlServer();
    public TfsTeamProjectCollection get_TeamProjectCollection();
    internal int get_ItemId();
    private WebServiceLayer get_WebServiceLayer();
}
public class Microsoft.TeamFoundation.VersionControl.Client.TeamProjectCannotDeleteException : VersionControlException {
    public TeamProjectCannotDeleteException(string message);
    public TeamProjectCannotDeleteException(string message, Exception ex);
    protected TeamProjectCannotDeleteException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.TeamProjectFolderCreatedEventArgs : EventArgs {
    private TeamProjectFolderOptions m_options;
    public TeamProjectFolderOptions Options { get; }
    public TeamProjectFolderCreatedEventArgs(TeamProjectFolderOptions options);
    public TeamProjectFolderOptions get_Options();
}
public class Microsoft.TeamFoundation.VersionControl.Client.TeamProjectFolderCreatedEventHandler : MulticastDelegate {
    public TeamProjectFolderCreatedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, TeamProjectFolderCreatedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, TeamProjectFolderCreatedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.TeamFoundation.VersionControl.Client.TeamProjectFolderOptions : object {
    internal CheckinNoteFieldDefinition[] m_checkinNoteDefinition;
    private string m_comment;
    private bool m_exclusiveCheckout;
    private bool m_getLatestOnCheckout;
    internal TeamProjectFolderPermission[] m_permissions;
    private string m_sourceProject;
    private string m_teamProject;
    public CheckinNoteFieldDefinition[] CheckinNoteDefinition { get; }
    public string Comment { get; }
    public bool ExclusiveCheckout { get; }
    public bool GetLatestOnCheckout { get; }
    public TeamProjectFolderPermission[] Permissions { get; }
    public string SourceProject { get; }
    public string TeamProject { get; }
    public TeamProjectFolderOptions(string teamProject);
    public TeamProjectFolderOptions(string teamProject, string sourceProject);
    public TeamProjectFolderOptions(string teamProject, string sourceProject, string comment, bool exclusiveCheckout, TeamProjectFolderPermission[] permissions, CheckinNoteFieldDefinition[] checkinNoteDefinition);
    public TeamProjectFolderOptions(string teamProject, string sourceProject, string comment, bool exclusiveCheckout, TeamProjectFolderPermission[] permissions, CheckinNoteFieldDefinition[] checkinNoteDefinition, bool getLatestOnCheckout);
    public CheckinNoteFieldDefinition[] get_CheckinNoteDefinition();
    public string get_Comment();
    public bool get_ExclusiveCheckout();
    public bool get_GetLatestOnCheckout();
    public TeamProjectFolderPermission[] get_Permissions();
    public string get_SourceProject();
    public string get_TeamProject();
    [EditorBrowsableAttribute("1")]
public static TeamProjectFolderOptions FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, TeamProjectFolderOptions obj);
}
public class Microsoft.TeamFoundation.VersionControl.Client.TeamProjectFolderPermission : object {
    internal String[] m_allowPermission;
    internal String[] m_denyPermission;
    private string m_identityName;
    public String[] AllowPermission { get; }
    public String[] DenyPermission { get; }
    public string IdentityName { get; }
    public TeamProjectFolderPermission(string identityName, String[] allowPermission, String[] denyPermission);
    public String[] get_AllowPermission();
    public String[] get_DenyPermission();
    public string get_IdentityName();
    [EditorBrowsableAttribute("1")]
public static TeamProjectFolderPermission FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, TeamProjectFolderPermission obj);
}
public class Microsoft.TeamFoundation.VersionControl.Client.TeamProjectNotEmptyException : VersionControlException {
    public TeamProjectNotEmptyException(string message);
    public TeamProjectNotEmptyException(string message, Exception ex);
    protected TeamProjectNotEmptyException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.TeamProjectNotFoundException : VersionControlException {
    public TeamProjectNotFoundException(string message);
    public TeamProjectNotFoundException(string message, Exception ex);
    protected TeamProjectNotFoundException(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.ThirdPartyAssemblyTool : object {
    private IToolProvider m_toolProxy;
    private ThirdPartyToolDefinition m_toolDefinition;
    private static string s_assemblyExtension;
    public string Extension { get; }
    public ToolOperations Operation { get; }
    public bool CanOperateOnInMemoryFiles { get; }
    private bool IsToolProxyLoaded { get; }
    public ThirdPartyAssemblyTool(ThirdPartyToolDefinition toolDefinition);
    private static ThirdPartyAssemblyTool();
    public sealed virtual string get_Extension();
    public sealed virtual ToolOperations get_Operation();
    public sealed virtual bool get_CanOperateOnInMemoryFiles();
    private bool get_IsToolProxyLoaded();
    public sealed virtual IToolExecutionResult Execute(EventHandler exitHandler, AdvancedToolParameters advancedParameters, String[] arguments);
    private void LoadToolProxy();
    public static bool IsToolThirdPartyAssemblyTool(ThirdPartyToolDefinition toolDefinition);
    private static IToolProvider LoadToolFromAssembly(Assembly assembly, string typeName, string extension, ToolOperations operation);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.ThirdPartyAssemblyToolException : VersionConflictException {
    public ThirdPartyAssemblyToolException(string message);
    public ThirdPartyAssemblyToolException(string message, Exception ex);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.ThirdPartyAutomergeToolException : VersionConflictException {
    public ThirdPartyAutomergeToolException(string message);
    public ThirdPartyAutomergeToolException(string message, Exception ex);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.ThirdPartyExecutableTool : object {
    private ThirdPartyToolDefinition m_toolDefinition;
    private Process m_process;
    private string m_processName;
    private int m_cookie;
    public string Extension { get; }
    public ToolOperations Operation { get; }
    public bool CanOperateOnInMemoryFiles { get; }
    private Process Process { get; private set; }
    public int Id { get; }
    public string Name { get; }
    public bool HasExited { get; }
    public int ExitCode { get; }
    public string ExitMessage { get; }
    public bool PromptUserForMergeConfirmation { get; }
    public ThirdPartyExecutableTool(ThirdPartyToolDefinition toolDefinition);
    public sealed virtual string get_Extension();
    public sealed virtual ToolOperations get_Operation();
    public sealed virtual bool get_CanOperateOnInMemoryFiles();
    public sealed virtual IToolExecutionResult Execute(EventHandler exitHandler, AdvancedToolParameters advancedParameters, String[] arguments);
    private IToolExecutionResult ExecuteCompare(EventHandler exitHandler, bool waitForExit, string originalFile, string modifiedFile, string originalLabel, string modifiedLabel, string options);
    private IToolExecutionResult ExecuteMerge(EventHandler exitHandler, bool waitForExit, string latestFile, string modifiedFile, string originalFile, string mergedFile, string latestFileLabel, string modifiedFileLabel, string originalFileLabel, string mergedFileLabel);
    private Process get_Process();
    private void set_Process(Process value);
    public sealed virtual int get_Id();
    public sealed virtual string get_Name();
    public sealed virtual bool get_HasExited();
    public sealed virtual int get_ExitCode();
    public sealed virtual string get_ExitMessage();
    public sealed virtual bool get_PromptUserForMergeConfirmation();
    public sealed virtual void WaitForOperationEnd();
    public sealed virtual void Cancel();
    private static string ReplaceArguments(string s, String[] arguments);
}
[EditorBrowsableAttribute("1")]
public static class Microsoft.TeamFoundation.VersionControl.Client.ThirdPartyRunner : object {
    public static void RunCompare(string originalFile, string modifiedFile, string commandLineOptions, string originalLabel, string modifiedLabel, string sourceLabelTag, string sourceLabelFile, string targetLabelTag, string targetLabelFile, bool isSourceFileTemp, bool isTargetFileTemp, EventHandler exitedHandler, bool wait, bool modalExperience);
    public static IToolExecutionResult BeginRunMerge(ThreeWayMerge threeWayMerge);
    public static bool EndRunMerge(IToolExecutionResult toolResult, string mergedFile);
    public static IToolExecutionResult BeginRunAutomerge(ThreeWayMerge threeWayMerge);
    public static bool EndRunAutomerge(IToolExecutionResult toolResult, string mergedFile);
    private static IToolExecutionResult BeginRunMergeTool(ThreeWayMerge threeWayMerge, IToolProvider tool);
    private static bool EndRunMergeTool(IToolExecutionResult toolResult, string mergedFile);
    public static bool IsCompareToolConfigured(string file);
    public static bool IsMergeToolConfigured(string file);
    public static bool IsAutomergeToolConfigured(string file);
    public static bool CheckMergedFile(string mergedFile);
    private static IToolProvider BuildFallBackTool(ThirdPartyToolDefinition toolDef);
}
[EditorBrowsableAttribute("1")]
public class Microsoft.TeamFoundation.VersionControl.Client.ThirdPartyToolDefinition : object {
    [CompilerGeneratedAttribute]
private EventHandler ExtensionChanged;
    [CompilerGeneratedAttribute]
private EventHandler OperationChanged;
    [CompilerGeneratedAttribute]
private EventHandler CommandChanged;
    [CompilerGeneratedAttribute]
private EventHandler ArgumentsChanged;
    private string m_extension;
    private string m_command;
    private string m_typeName;
    private string m_arguments;
    private ToolOperations m_operation;
    internal static string DefaultDiffMergeToolName;
    private static string CompareOperationLocalized;
    private static string MergeOperationLocalized;
    private static string DefaultDiffMergeToolBinary;
    private static String[] m_compareArgsMustContain;
    private static String[] m_compareArgsMustNotContain;
    private static String[] m_mergeArgsMustContain;
    private static String[] m_mergeArgsMustNotContain;
    public string Extension { get; public set; }
    public ToolOperations Operation { get; public set; }
    public string OperationDisplay { get; }
    public string Command { get; public set; }
    public string TypeName { get; }
    public string Arguments { get; public set; }
    public bool IsDefaultTool { get; }
    public ThirdPartyToolDefinition(string extension, ToolOperations operation, string command, string typeName, string arguments);
    private static ThirdPartyToolDefinition();
    [CompilerGeneratedAttribute]
public void add_ExtensionChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ExtensionChanged(EventHandler value);
    public string get_Extension();
    public void set_Extension(string value);
    [CompilerGeneratedAttribute]
public void add_OperationChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_OperationChanged(EventHandler value);
    public ToolOperations get_Operation();
    public void set_Operation(ToolOperations value);
    public string get_OperationDisplay();
    [CompilerGeneratedAttribute]
public void add_CommandChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_CommandChanged(EventHandler value);
    public string get_Command();
    public void set_Command(string value);
    public string get_TypeName();
    [CompilerGeneratedAttribute]
public void add_ArgumentsChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ArgumentsChanged(EventHandler value);
    public string get_Arguments();
    public void set_Arguments(string value);
    public bool get_IsDefaultTool();
    private sealed virtual override object System.ICloneable.Clone();
    public static string ValidateThirdPartyToolDefinition(ThirdPartyToolDefinition tool);
    [EditorBrowsableAttribute("1")]
public static ThirdPartyToolDefinition[] ExtensionSplit(ThirdPartyToolDefinition tool);
    public static String[] GetExtensionsFromString(string input);
    public static string CheckLegalExtension(string extension);
    public static string CheckLegalCommand(string command);
    public static string CheckLegalArguments(string arguments, ToolOperations operation);
    internal static string GetExtensionError(string extension);
    [EditorBrowsableAttribute("1")]
public static string GetExtensionError(string extension, bool allowMultipleExtensions);
    private static string CheckArgumentsForWeirdPatterns(string arguments);
    private static string CheckLegalCompareArguments(string arguments);
    private static string CheckLegalMergeArguments(string arguments);
}
[EditorBrowsableAttribute("1")]
public class Microsoft.TeamFoundation.VersionControl.Client.ThirdPartyToolDefinitionCollection : List`1<ThirdPartyToolDefinition> {
    private static ThirdPartyToolDefinitionCollection s_instance;
    public static ThirdPartyToolDefinitionCollection Instance { get; }
    public static ThirdPartyToolDefinitionCollection get_Instance();
    [EditorBrowsableAttribute("1")]
public void AddTool(ThirdPartyToolDefinition tool);
    [EditorBrowsableAttribute("1")]
public void LoadAllFromRegistry();
    public void PersistAllToRegistry();
    public ThirdPartyToolDefinition FindTool(string extension, ToolOperations operation);
}
[EditorBrowsableAttribute("1")]
public static class Microsoft.TeamFoundation.VersionControl.Client.ThirdPartyToolRegistryHelper : object {
    private static string s_topRegistryPath;
    private static string s_commandRegistryName;
    private static string s_argumentsRegistryName;
    private static string s_typeNameRegistryName;
    private static ThirdPartyToolRegistryHelper();
    internal static ThirdPartyToolDefinition[] LoadAllFromRegistry();
    internal static void PersistAllToRegistry(List`1<ThirdPartyToolDefinition> toolDefinitions);
    internal static void DeleteAllFromRegistry();
    [EditorBrowsableAttribute("1")]
public static IToolProvider GetBestCompareTool(string file);
    internal static IToolProvider GetBestMergeTool(string file);
    internal static IToolProvider GetBestAutomergeTool(string file);
    private static IToolProvider GetBestTool(string extension, ToolOperations operation);
    private static void PersistToolDefinitionToRegistry(ThirdPartyToolDefinition toolDef);
    private static ThirdPartyToolDefinition LoadUserToolDefinition(string extension, ToolOperations operation);
    private static ThirdPartyToolDefinition LoadMachToolDefinition(string extension, ToolOperations operation);
    private static ThirdPartyToolDefinition LoadToolDefinitionFromRegistryKey(RegistryKey registryKey, string extension, ToolOperations operation);
    private static string GetPath(string extension, ToolOperations operation);
    private static RegistryKey GetRegistryKey(string extension, ToolOperations operation);
    private static RegistryKey GetMachineRegistryKey(string extension, ToolOperations operation);
    private static RegistryKey GetBottomRegistryKey(RegistryHive hive);
    private static RegistryKey GetTopRegistryKey();
}
internal class Microsoft.TeamFoundation.VersionControl.Client.ThreadPoolFloorScope : object {
    private int m_floor;
    private int m_oldValue;
    private bool m_changedValue;
    public ThreadPoolFloorScope(int floor);
    public sealed virtual void Dispose();
}
public class Microsoft.TeamFoundation.VersionControl.Client.ThreeWayMerge : object {
    [CompilerGeneratedAttribute]
private string <LatestFileLabelTag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LatestFileLabelFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ModifiedFileLabelTag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ModifiedFileLabelFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OriginalFileLabelTag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OriginalFileLabelFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MergedFileLabelTag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MergedFileLabelFile>k__BackingField;
    [CompilerGeneratedAttribute]
private Encoding <PreferredMergedFileEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ModifiedFileSpec>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LatestFileSpec>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <VersionControlServerGuid>k__BackingField;
    private string m_latestFileName;
    private Encoding m_latestFileEncoding;
    private string m_latestFileLabel;
    private string m_modifiedFileName;
    private Encoding m_modifiedFileEncoding;
    private string m_modifiedFileLabel;
    private string m_originalFileName;
    private Encoding m_originalFileEncoding;
    private string m_originalFileLabel;
    private string m_mergedFileName;
    private Encoding m_mergedFileEncoding;
    private string m_mergedFileLabel;
    private Encoding m_intermediateMergeEncoding;
    private bool m_baseless;
    private bool m_useExternalMergeTool;
    private bool m_useExternalAutomergeTool;
    private MergeSummary m_contentMergeSummary;
    public string LatestFileName { get; public set; }
    public Encoding LatestFileEncoding { get; public set; }
    public string LatestFileLabel { get; public set; }
    public string LatestFileLabelTag { get; public set; }
    public string LatestFileLabelFile { get; public set; }
    public string ModifiedFileName { get; public set; }
    public Encoding ModifiedFileEncoding { get; public set; }
    public string ModifiedFileLabel { get; public set; }
    public string ModifiedFileLabelTag { get; public set; }
    public string ModifiedFileLabelFile { get; public set; }
    public string OriginalFileName { get; public set; }
    public Encoding OriginalFileEncoding { get; public set; }
    public string OriginalFileLabel { get; public set; }
    public string OriginalFileLabelTag { get; public set; }
    public string OriginalFileLabelFile { get; public set; }
    public string MergedFileName { get; public set; }
    public Encoding MergedFileEncoding { get; public set; }
    public string MergedFileLabel { get; public set; }
    public string MergedFileLabelTag { get; public set; }
    public string MergedFileLabelFile { get; public set; }
    public Encoding IntermediateMergeEncoding { get; public set; }
    public bool IsBaseless { get; public set; }
    public bool UseExternalMergeTool { get; public set; }
    public bool UseExternalAutomergeTool { get; public set; }
    public Encoding PreferredMergedFileEncoding { get; public set; }
    public MergeSummary ContentMergeSummary { get; internal set; }
    public string ModifiedFileSpec { get; public set; }
    public string LatestFileSpec { get; public set; }
    public Guid VersionControlServerGuid { get; public set; }
    public bool Run();
    public bool Run(IMergeChange[]& mergeList, bool writeOriginalForConflictingRange, bool ignoreLeadingAndTrailingWhiteSpace, bool ignoreEndOfLineDifferences, bool ignoreEndOfFileEndOfLineDifference);
    private MergeOptions SetupMergeOptions(bool writeOriginalForConflictingRange, bool ignoreLeadingAndTrailingWhiteSpace, bool ignoreEndOfLineDifferences, bool ignoreEndOfFileEndOfLineDifference);
    public bool RunEx(IMergeChange[]& mergeList, bool writeOriginalForConflictingRange, bool ignoreLeadingAndTrailingWhiteSpace, bool ignoreEndOfLineDifferences, bool ignoreEndOfFileEndOfLineDifference, bool exIgnoreLeadingAndTrailingWhiteSpace, bool exIgnoreEndOfLineDifferences, bool exIgnoreEndOfFileEndOfLineDifference);
    private bool WriteMergedFile(MergeOptions mergeOptions, Stream outputStream, Encoding outputEncoding, bool writePreamble, DiffFile original, DiffFile modified, DiffFile latest, IMergeChange[] mergeList, bool canThrow);
    [EditorBrowsableAttribute("1")]
public IToolExecutionResult BeginExternalMergeContent();
    [EditorBrowsableAttribute("1")]
public bool EndExternalMergeContent(IToolExecutionResult toolResult);
    internal IToolExecutionResult BeginExternalAutomergeContent();
    internal bool EndExternalAutomergeContent(IToolExecutionResult toolResult);
    private void GenerateFakeBase();
    internal void CreateConflictLabelsFromConflict(Conflict conflict, Workspace workspace);
    internal void CreateConflictFileSpecsFromConflict(Conflict conflict, Workspace workspace);
    private string FormatVersionedFileString(string fileName, string version);
    private static string CopyToTempFile(string fileToCopy);
    private static DiffFile CreateDiffFile(string path, Encoding encoding, MergeOptions mergeOptions, string fileName, string tag);
    public string get_LatestFileName();
    public void set_LatestFileName(string value);
    public Encoding get_LatestFileEncoding();
    public void set_LatestFileEncoding(Encoding value);
    public string get_LatestFileLabel();
    public void set_LatestFileLabel(string value);
    [CompilerGeneratedAttribute]
public string get_LatestFileLabelTag();
    [CompilerGeneratedAttribute]
public void set_LatestFileLabelTag(string value);
    [CompilerGeneratedAttribute]
public string get_LatestFileLabelFile();
    [CompilerGeneratedAttribute]
public void set_LatestFileLabelFile(string value);
    public string get_ModifiedFileName();
    public void set_ModifiedFileName(string value);
    public Encoding get_ModifiedFileEncoding();
    public void set_ModifiedFileEncoding(Encoding value);
    public string get_ModifiedFileLabel();
    public void set_ModifiedFileLabel(string value);
    [CompilerGeneratedAttribute]
public string get_ModifiedFileLabelTag();
    [CompilerGeneratedAttribute]
public void set_ModifiedFileLabelTag(string value);
    [CompilerGeneratedAttribute]
public string get_ModifiedFileLabelFile();
    [CompilerGeneratedAttribute]
public void set_ModifiedFileLabelFile(string value);
    public string get_OriginalFileName();
    public void set_OriginalFileName(string value);
    public Encoding get_OriginalFileEncoding();
    public void set_OriginalFileEncoding(Encoding value);
    public string get_OriginalFileLabel();
    public void set_OriginalFileLabel(string value);
    [CompilerGeneratedAttribute]
public string get_OriginalFileLabelTag();
    [CompilerGeneratedAttribute]
public void set_OriginalFileLabelTag(string value);
    [CompilerGeneratedAttribute]
public string get_OriginalFileLabelFile();
    [CompilerGeneratedAttribute]
public void set_OriginalFileLabelFile(string value);
    public string get_MergedFileName();
    public void set_MergedFileName(string value);
    public Encoding get_MergedFileEncoding();
    public void set_MergedFileEncoding(Encoding value);
    public string get_MergedFileLabel();
    public void set_MergedFileLabel(string value);
    [CompilerGeneratedAttribute]
public string get_MergedFileLabelTag();
    [CompilerGeneratedAttribute]
public void set_MergedFileLabelTag(string value);
    [CompilerGeneratedAttribute]
public string get_MergedFileLabelFile();
    [CompilerGeneratedAttribute]
public void set_MergedFileLabelFile(string value);
    public Encoding get_IntermediateMergeEncoding();
    public void set_IntermediateMergeEncoding(Encoding value);
    public bool get_IsBaseless();
    public void set_IsBaseless(bool value);
    public bool get_UseExternalMergeTool();
    public void set_UseExternalMergeTool(bool value);
    public bool get_UseExternalAutomergeTool();
    public void set_UseExternalAutomergeTool(bool value);
    [CompilerGeneratedAttribute]
public Encoding get_PreferredMergedFileEncoding();
    [CompilerGeneratedAttribute]
public void set_PreferredMergedFileEncoding(Encoding value);
    public MergeSummary get_ContentMergeSummary();
    internal void set_ContentMergeSummary(MergeSummary value);
    [CompilerGeneratedAttribute]
public string get_ModifiedFileSpec();
    [CompilerGeneratedAttribute]
public void set_ModifiedFileSpec(string value);
    [CompilerGeneratedAttribute]
public string get_LatestFileSpec();
    [CompilerGeneratedAttribute]
public void set_LatestFileSpec(string value);
    [CompilerGeneratedAttribute]
public Guid get_VersionControlServerGuid();
    [CompilerGeneratedAttribute]
public void set_VersionControlServerGuid(Guid value);
}
public enum Microsoft.TeamFoundation.VersionControl.Client.ToolOperations : Enum {
    public int value__;
    public static ToolOperations Undefined;
    public static ToolOperations Compare;
    public static ToolOperations Merge;
    public static ToolOperations Automerge;
}
public static class Microsoft.TeamFoundation.VersionControl.Client.ToolProviderConstants : object {
    public static string ExtensionFallback;
    private static ToolProviderConstants();
}
public static class Microsoft.TeamFoundation.VersionControl.Client.ToolProviderCookieGenerator : object {
    public static int GenerateNewCookie();
}
public class Microsoft.TeamFoundation.VersionControl.Client.TrackMergesExceededMaxBranchesLimitException : ServerItemException {
    public TrackMergesExceededMaxBranchesLimitException(string message);
    public TrackMergesExceededMaxBranchesLimitException(string message, Exception ex);
    protected TrackMergesExceededMaxBranchesLimitException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.UnableToLoadLocalPropertiesTableException : VersionControlException {
    public UnableToLoadLocalPropertiesTableException(string workspaceSpec, Exception innerException);
}
public class Microsoft.TeamFoundation.VersionControl.Client.UnableToLoadLocalVersionTableException : VersionControlException {
    public UnableToLoadLocalVersionTableException(string workspaceSpec, Exception innerException);
}
public class Microsoft.TeamFoundation.VersionControl.Client.UnableToLoadPendingChangesTableException : VersionControlException {
    public UnableToLoadPendingChangesTableException(string workspaceSpec, Exception innerException);
}
public class Microsoft.TeamFoundation.VersionControl.Client.UndeleteAboveUnrelatedItemException : VersionControlException {
    public UndeleteAboveUnrelatedItemException(string message);
    public UndeleteAboveUnrelatedItemException(string message, Exception ex);
    protected UndeleteAboveUnrelatedItemException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.UndeleteNewNameNotSupportedException : VersionControlException {
    public UndeleteNewNameNotSupportedException(string message);
    public UndeleteNewNameNotSupportedException(string message, Exception ex);
    protected UndeleteNewNameNotSupportedException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.UndonePendingChangeEventHandler : MulticastDelegate {
    public UndonePendingChangeEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, PendingChangeEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, PendingChangeEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.TeamFoundation.VersionControl.Client.UnshelveException : VersionControlException {
    public UnshelveException(string message);
    public UnshelveException(string message, Exception exception);
    public UnshelveException(Exception innerException);
    protected UnshelveException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.UnshelveShelvesetEventArgs : EventArgs {
    private PendingChange[] m_changes;
    private Workspace m_workspace;
    private Shelveset m_shelveset;
    public PendingChange[] Changes { get; }
    public Workspace Workspace { get; }
    public Shelveset Shelveset { get; }
    internal UnshelveShelvesetEventArgs(Shelveset shelveset, Workspace workspace, PendingChange[] changes);
    public PendingChange[] get_Changes();
    public Workspace get_Workspace();
    public Shelveset get_Shelveset();
}
public class Microsoft.TeamFoundation.VersionControl.Client.UnshelveShelvesetEventHandler : MulticastDelegate {
    public UnshelveShelvesetEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, UnshelveShelvesetEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, UnshelveShelvesetEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.TeamFoundation.VersionControl.Client.UnshelvingPartialRenameException : VersionControlException {
    public UnshelvingPartialRenameException(string message);
    public UnshelvingPartialRenameException(string message, Exception ex);
    protected UnshelvingPartialRenameException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.UpdateLocalVersionQueue : object {
    internal Stopwatch m_perfTimer;
    private Stopwatch m_timer;
    private object m_flushLock;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_flushing;
    private Workspace m_workspace;
    private WorkspaceLock m_wLock;
    private List`1<ILocalVersionUpdate> m_pendingUpdates;
    private UpdateLocalVersionQueueOptions m_options;
    private int m_flushTriggerLevel;
    private int m_maximumLevel;
    private int m_timeTriggerInMilliseconds;
    private bool m_disposed;
    private HashSet`1<Byte[]> m_persistedDisplacedBaselines;
    private List`1<ILocalVersionUpdate> m_pendingAcks;
    private static int c_sleepTimeInMilliseconds;
    private static int c_defaultFlushTriggerLevel;
    private static int c_defaultMaximumLevel;
    private static int c_defaultTimeTriggerInMilliseconds;
    public UpdateLocalVersionQueue(Workspace workspace);
    public UpdateLocalVersionQueue(Workspace workspace, UpdateLocalVersionQueueOptions options);
    internal UpdateLocalVersionQueue(Workspace workspace, UpdateLocalVersionQueueOptions options, WorkspaceLock wLock);
    internal UpdateLocalVersionQueue(Workspace workspace, UpdateLocalVersionQueueOptions options, WorkspaceLock wLock, int flushTriggerLevel, int maximumLevel, int timeTriggerInMilliseconds);
    [ObsoleteAttribute("Queuing local version updates solely by item ID is deprecated. Please use another overload of QueueUpdate.")]
public void QueueUpdate(int itemId, string targetLocalItem, int localVersion);
    public void QueueUpdate(string sourceServerItem, int itemId, string targetLocalItem, int localVersion);
    public void QueueUpdate(string sourceServerItem, int itemId, string targetLocalItem, int localVersion, DateTime localVersionCheckinDate, int encoding, Byte[] baselineHashValue, long baselineFileLength);
    internal void QueueUpdate(ILocalVersionUpdate update);
    public sealed virtual void Dispose();
    public void Flush();
    private void FlushNoAcks();
    private void EnsureUpdatesFullyPopulated(ILocalVersionUpdate[] updates);
    private void DownloadMissingBaselines(IPopulatableLocalVersionUpdate[] updates);
    private IPopulatableLocalVersionUpdate[] SendToServer(ILocalVersionUpdate[] updates);
    private void FlushAcks();
    [CompilerGeneratedAttribute]
private void <Dispose>b__8_0(LocalWorkspaceProperties wp);
}
[FlagsAttribute]
public enum Microsoft.TeamFoundation.VersionControl.Client.UpdateLocalVersionQueueOptions : Enum {
    public int value__;
    public static UpdateLocalVersionQueueOptions UpdateLocal;
    public static UpdateLocalVersionQueueOptions UpdateServer;
}
public class Microsoft.TeamFoundation.VersionControl.Client.UpdateWorkspaceParameters : object {
    [CompilerGeneratedAttribute]
private string <WorkspaceName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OwnerName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Comment>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Computer>k__BackingField;
    [CompilerGeneratedAttribute]
private WorkingFolder[] <Folders>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<WorkspaceLocation> <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RemoveUnparentedCloaks>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<WorkspaceOptions> <WorkspaceOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private WorkspacePermissionProfile <PermissionProfile>k__BackingField;
    public string WorkspaceName { get; public set; }
    public string OwnerName { get; public set; }
    public string Comment { get; public set; }
    public string Computer { get; public set; }
    public WorkingFolder[] Folders { get; public set; }
    public Nullable`1<WorkspaceLocation> Location { get; public set; }
    public bool RemoveUnparentedCloaks { get; public set; }
    public Nullable`1<WorkspaceOptions> WorkspaceOptions { get; public set; }
    public WorkspacePermissionProfile PermissionProfile { get; public set; }
    [CompilerGeneratedAttribute]
public string get_WorkspaceName();
    [CompilerGeneratedAttribute]
public void set_WorkspaceName(string value);
    [CompilerGeneratedAttribute]
public string get_OwnerName();
    [CompilerGeneratedAttribute]
public void set_OwnerName(string value);
    [CompilerGeneratedAttribute]
public string get_Comment();
    [CompilerGeneratedAttribute]
public void set_Comment(string value);
    [CompilerGeneratedAttribute]
public string get_Computer();
    [CompilerGeneratedAttribute]
public void set_Computer(string value);
    [CompilerGeneratedAttribute]
public WorkingFolder[] get_Folders();
    [CompilerGeneratedAttribute]
public void set_Folders(WorkingFolder[] value);
    [CompilerGeneratedAttribute]
public Nullable`1<WorkspaceLocation> get_Location();
    [CompilerGeneratedAttribute]
public void set_Location(Nullable`1<WorkspaceLocation> value);
    [CompilerGeneratedAttribute]
public bool get_RemoveUnparentedCloaks();
    [CompilerGeneratedAttribute]
public void set_RemoveUnparentedCloaks(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<WorkspaceOptions> get_WorkspaceOptions();
    [CompilerGeneratedAttribute]
public void set_WorkspaceOptions(Nullable`1<WorkspaceOptions> value);
    [CompilerGeneratedAttribute]
public WorkspacePermissionProfile get_PermissionProfile();
    [CompilerGeneratedAttribute]
public void set_PermissionProfile(WorkspacePermissionProfile value);
}
internal static class Microsoft.TeamFoundation.VersionControl.Client.UploadDownload : object {
    private static long s_downloadCounter;
    private static int s_activeDownloads;
    private static CredentialsType s_proxyCredentials;
    private static short m_maxRetryCount;
    private static long s_uploadCounter;
    private static int s_activeUploads;
    private static long s_uploadChunkCounter;
    private static int s_activeUploadChunks;
    private static string c_mimeContentType;
    private static string c_mimeBoundary;
    private static string c_mimeDelimiter;
    private static string c_mimeDisposition;
    private static string c_mimeDispositionWithFilename;
    private static string c_mimeOctetStreamType;
    private static string c_mimeGzipType;
    private static string s_processId;
    private static FILE_IO_PRIORITY_HINT_INFO s_lowPriorityHintInfo;
    private static UInt32 s_lowPriorityHintInfoSize;
    private static UInt32 s_eofInfoSize;
    private static UploadDownload();
    public static IAsyncResult BeginDownload(VersionControlServer sourceControl, string downloadUrl, string destinationLocalPath, Byte[] expectedHashValue, AsyncCallback completionCallback, object state);
    public static IAsyncResult BeginDownload(VersionControlServer sourceControl, string downloadUrl, string destinationLocalPath, BaselineFolderCollection baselineFolderCollection, Byte[] baselineFileGuid, Byte[] expectedHashValue, AsyncCallback completionCallback, object state);
    public static long EndDownload(IAsyncResult asyncResult);
    private static IAsyncResult BeginDownloadNoRetry(DownloadParameters parameters, AsyncCallback completionCallback, object state);
    private static long EndDownloadNoRetry(IAsyncResult asyncResult);
    private static void DownloadBeginGetResponseCallback(IAsyncResult ar);
    private static void DownloadBeginReadCallback(IAsyncResult ar);
    private static void DownloadWireBeginWriteCallback(IAsyncResult ar);
    private static void DownloadDestBeginWriteCallback(IAsyncResult ar);
    private static void DecompressAndWriteChunk(DownloadAsyncResult downloadAsyncResult);
    private static void PerformRetryToHandle503(DownloadAsyncResult downloadAsyncResult);
    private static void RestartDownload(DownloadAsyncResult downloadAsyncResult);
    private static void RaiseProxyFailoverNonFatalError(DownloadAsyncResult downloadAsyncResult, Exception ex);
    private static string BuildTemporaryFileLastPathPart(DownloadAsyncResult downloadAsyncResult);
    private static SafeFileHandle CreateTemporaryFile(DownloadAsyncResult asyncResult);
    private static void PlaceFile(DownloadAsyncResult asyncResult);
    private static void WaitForReadHandle(DownloadAsyncResult asyncResult);
    public static Stream CreateDownloadStream(VersionControlServer sourceControl, string downloadUrl);
    private static IAsyncResult BeginGetDownloadStream(VersionControlServer sourceControl, string downloadUrl, AsyncCallback completionCallback, object state);
    private static Stream EndGetDownloadStream(IAsyncResult asyncResult);
    public static IAsyncResult BeginUpload(Workspace workspace, PendingChange pendingChange, BaselineFolderCollection baselineFolderCollection, bool bufferWriteStream, AsyncCallback completionCallback, object state);
    public static void EndUpload(IAsyncResult asyncResult, PendingChange& pendingChange, Byte[]& baselineFileGuid, Int64& uncompressedLength, Boolean& retriedWithBufferingEnabled);
    private static IAsyncResult BeginUploadNoRetry(UploadParameters parameters, AsyncCallback completionCallback, object state);
    private static UploadResult EndUploadNoRetry(IAsyncResult asyncResult);
    private static void UploadPrepareContentStreamCallback(object ar);
    private static void UploadChunkCompletedCallback(IAsyncResult ar);
    private static UploadChunkRange GetInitialRange(UploadAsyncResult asyncResult);
    private static IAsyncResult IssueChunk(UploadAsyncResult asyncResult, bool seek);
    private static bool SetFileInformationByHandle(SafeFileHandle hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, FILE_DISPOSITION_INFO& lpFileInformation, UInt32 dwBufferSize);
    private static IAsyncResult BeginUploadChunk(Workspace workspace, string serverItem, long uncompressedLength, Byte[] hashValue, UploadChunkRange range, bool isCompressed, Stream contentStream, Byte[] memoryBuffer, bool bufferWriteStream, AsyncCallback completionCallback, object state);
    private static void EndUploadChunk(IAsyncResult asyncResult);
    private static void UploadBeginGetRequestStreamCallback(IAsyncResult ar);
    private static void UploadBeginWriteCallback(IAsyncResult ar);
    private static void UploadBeginGetResponseCallback(IAsyncResult ar);
    private static string GetMimeHeader(UploadChunkAsyncResult chunkAsyncResult);
    private static void CheckResponse(HttpWebResponse response);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.UploadedBaselinesCollection : object {
    private Dictionary`2<string, UploadedBaseline> m_uploadedBaselines;
    public IEnumerable`1<Byte[]> UploadedBaselineFileGuids { get; }
    public int Count { get; }
    public void AddUploadedBaseline(string targetLocalItem, Byte[] baselineFileGuid, long uncompressedLength);
    public Byte[] GetUploadedBaseline(string targetLocalItem, Int64& uncompressedLength);
    public void RemoveUploadedBaseline(string targetLocalItem);
    [IteratorStateMachineAttribute("Microsoft.TeamFoundation.VersionControl.Client.UploadedBaselinesCollection/<get_UploadedBaselineFileGuids>d__4")]
public IEnumerable`1<Byte[]> get_UploadedBaselineFileGuids();
    public int get_Count();
}
public class Microsoft.TeamFoundation.VersionControl.Client.UploadFileException : VersionControlException {
    [CompilerGeneratedAttribute]
private List`1<Exception> <Errors>k__BackingField;
    public List`1<Exception> Errors { get; public set; }
    public UploadFileException(Exception firstException);
    [CompilerGeneratedAttribute]
public List`1<Exception> get_Errors();
    [CompilerGeneratedAttribute]
public void set_Errors(List`1<Exception> value);
}
public class Microsoft.TeamFoundation.VersionControl.Client.VersionConflictException : ServerItemException {
    public VersionConflictException(string message);
    public VersionConflictException(string message, Exception ex);
    protected VersionConflictException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.VersionControlArtifactProvider : object {
    private VersionControlServer m_sourceControl;
    internal VersionControlArtifactProvider(VersionControlServer sourceControl);
    public sealed virtual XmlDocument GetArtifactDocument(Uri artifactUri);
    public VersionControlArtifactType GetArtifactType(Uri artifactUri);
    public Changeset GetChangeset(Uri artifactUri);
    public Shelveset GetShelveset(Uri artifactUri);
    public VersionControlLabel GetLabel(Uri artifactUri);
    public Item GetLatestItemVersion(Uri artifactUri);
    public Item GetVersionedItem(Uri artifactUri);
    internal AssociatedWorkItemInfo[] GetAssociatedWorkItemInfoForArtifact(Uri artifactUri);
}
public enum Microsoft.TeamFoundation.VersionControl.Client.VersionControlArtifactType : Enum {
    public int value__;
    public static VersionControlArtifactType None;
    public static VersionControlArtifactType VersionedItem;
    public static VersionControlArtifactType LatestItemVersion;
    public static VersionControlArtifactType Changeset;
    public static VersionControlArtifactType Label;
    public static VersionControlArtifactType Shelveset;
    public static VersionControlArtifactType ShelvedItem;
}
internal abstract class Microsoft.TeamFoundation.VersionControl.Client.VersionControlClientProxy : TfsHttpClient {
    private VersionControlServer m_sourceControl;
    private static int s_defaultVersionControlTimeout;
    protected string ComponentName { get; }
    public VersionControlServer VersionControlServer { get; }
    public Uri Uri { get; }
    public VersionControlClientProxy(VersionControlServer sourceControl);
    protected VersionControlClientProxy(TfsTeamProjectCollection tfs);
    private static VersionControlClientProxy();
    protected virtual string get_ComponentName();
    public VersionControlServer get_VersionControlServer();
    public Uri get_Uri();
    protected virtual TfsRequestSettings ApplyCustomSettings(TfsRequestSettings settings);
    protected void PrepareForLargeRequest();
    internal void ThrowIfCanceled();
    protected virtual void OnAfterReceiveReply(long requestId, string methodName, HttpWebResponse response);
    public static void TraceHeaders(HttpWebResponse response);
    public virtual object GetService(Type serviceType);
}
public class Microsoft.TeamFoundation.VersionControl.Client.VersionControlException : TeamFoundationServerException {
    public VersionControlException(string message);
    public VersionControlException(string message, Exception innerException);
    protected VersionControlException(SerializationInfo info, StreamingContext context);
    internal static Exception ConvertException(SoapException innerException);
    internal static Exception ConvertException(SoapException innerException, bool convertUnknown);
    internal static Exception ConvertException(string exceptionType, string exceptionMessage, Exception innerException, bool convertUnknown);
}
public class Microsoft.TeamFoundation.VersionControl.Client.VersionControlLabel : object {
    private string m_comment;
    internal Item[] m_items;
    private int m_labelId;
    private DateTime m_lastModifiedDate;
    private string m_name;
    private string m_ownerDisplayName;
    private string m_ownerName;
    private string m_ownerUniqueName;
    private string m_scope;
    private VersionControlServer m_sourceControl;
    public string Comment { get; }
    public Item[] Items { get; }
    public int LabelId { get; }
    public DateTime LastModifiedDate { get; }
    public string Name { get; }
    public string OwnerDisplayName { get; }
    public string OwnerName { get; }
    public string Scope { get; }
    public Uri ArtifactUri { get; }
    public VersionControlServer VersionControlServer { get; internal set; }
    public VersionControlLabel(VersionControlServer sourceControl, string name, string ownerName, string scope, string comment);
    public string get_Comment();
    public Item[] get_Items();
    public int get_LabelId();
    public DateTime get_LastModifiedDate();
    public string get_Name();
    public string get_OwnerDisplayName();
    public string get_OwnerName();
    public string get_Scope();
    [EditorBrowsableAttribute("1")]
public static VersionControlLabel FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, VersionControlLabel obj);
    public Uri get_ArtifactUri();
    public VersionControlServer get_VersionControlServer();
    internal void set_VersionControlServer(VersionControlServer value);
    private void AfterDeserialize();
}
internal class Microsoft.TeamFoundation.VersionControl.Client.VersionControlLink : object {
    private int m_linkType;
    private string m_url;
    public int LinkType { get; public set; }
    public string Url { get; public set; }
    internal VersionControlLink(int linkType, string url);
    public int get_LinkType();
    public void set_LinkType(int value);
    public string get_Url();
    public void set_Url(string value);
    internal static VersionControlLink FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    internal void ToXml(XmlWriter writer, string element);
    internal static void ToXml(XmlWriter writer, string element, VersionControlLink obj);
}
public class Microsoft.TeamFoundation.VersionControl.Client.VersionControlServer : object {
    private object m_fileTypeCacheLock;
    private Dictionary`2<string, FileType> m_cachedFileTypes;
    [CompilerGeneratedAttribute]
private DestroyedEventHandler Destroyed;
    [CompilerGeneratedAttribute]
private CommittedBranchCreatedEventHandler CommittedBranchCreated;
    [CompilerGeneratedAttribute]
private BranchObjectCreatedEventHandler BranchObjectCreated;
    [CompilerGeneratedAttribute]
private BranchObjectDeletedEventHandler BranchObjectDeleted;
    [CompilerGeneratedAttribute]
private BranchObjectUpdatedEventHandler BranchObjectUpdated;
    [CompilerGeneratedAttribute]
private OperationEventHandler OperationStarting;
    [CompilerGeneratedAttribute]
private OperationEventHandler OperationFinished;
    [CompilerGeneratedAttribute]
private TeamProjectFolderCreatedEventHandler TeamProjectFolderCreated;
    [CompilerGeneratedAttribute]
private ShelvesetUpdatedEventHandler ShelvesetUpdated;
    private SecurityNamespace m_workspaceSecurity;
    private ServerSettingsCache m_serverSettingsCache;
    private int m_serverSettingsAcquireCount;
    private Client m_client;
    private WebServiceLayer m_webServiceLayer;
    private Dictionary`2<string, TeamProject> m_teamProjectCacheLazilyInited;
    private object m_teamProjectCacheLock;
    private bool m_forceTeamProjectCacheRefresh;
    private TfsTeamProjectCollection m_tfs;
    private VersionControlArtifactProvider m_artifactProvider;
    private static int s_maxBackgroundThreads;
    private static int s_maxResults;
    private FrameworkSecurityProvider m_securityProvider;
    private string m_authenticatedUserDisplayName;
    internal BufferPool BufferPool;
    internal bool UploadBufferWriteStream;
    internal static string ClientDataDirectory;
    internal static string ClientConfigurationDirectory;
    internal static string ClientWebmethodTimeout;
    internal static bool m_isInDebugMode;
    internal static UpdateLocalState m_updateLocalState;
    public TfsTeamProjectCollection TeamProjectCollection { get; }
    [ObsoleteAttribute("This property has been deprecated. If you are looking for the 'active' user who the requests are being made on behalf of, 
                   the AuthorizedUser property should be used. If you actually need the authenticated user then use the TeamProjectCollection.GetAuthenticatedUser() method", "False")]
public string AuthenticatedUser { get; }
    public TeamFoundationIdentity AuthorizedIdentity { get; }
    public string AuthorizedUser { get; }
    public string CurrentCommand { get; public set; }
    public Guid ServerGuid { get; }
    public bool Canceled { get; public set; }
    public VersionControlArtifactProvider ArtifactProvider { get; }
    public static int MaxBackgroundThreads { get; public set; }
    public static int MaxResults { get; public set; }
    public static TraceSwitch ClientTracing { get; public set; }
    public static string BaselineFolderNamePrefix { get; }
    public static string IgnoreFileName { get; }
    internal Client Client { get; }
    internal WebServiceLayer WebServiceLayer { get; }
    private Dictionary`2<string, TeamProject> TeamProjectCache { get; }
    private FrameworkSecurityProvider SecurityProvider { get; }
    internal SecurityNamespace WorkspaceSecurity { get; }
    public int SupportedFeatures { get; }
    public WebServiceLevel WebServiceLevel { get; }
    internal IdentitySearchFactor IMSUserNameSearchFactor { get; }
    unknown string LatestSettingsHash {internal set; }
    private static VersionControlServer();
    public IEnumerable QueryHistory(string path, VersionSpec version, int deletionId, RecursionType recursion, string user, VersionSpec versionFrom, VersionSpec versionTo, int maxCount, bool includeChanges, bool slotMode);
    public IEnumerable QueryHistory(string path, VersionSpec version, int deletionId, RecursionType recursion, string user, VersionSpec versionFrom, VersionSpec versionTo, int maxCount, bool includeChanges, bool slotMode, bool includeDownloadInfo);
    public IEnumerable QueryHistory(string path, VersionSpec version, int deletionId, RecursionType recursion, string user, VersionSpec versionFrom, VersionSpec versionTo, int maxCount, bool includeChanges, bool slotMode, bool includeDownloadInfo, bool sortAscending);
    public IEnumerable`1<Changeset> QueryHistory(string item, RecursionType recursion);
    public IEnumerable`1<Changeset> QueryHistory(string item, RecursionType recursion, int maxResults);
    public IEnumerable`1<Changeset> QueryHistory(ItemSpec itemSpec);
    public IEnumerable`1<Changeset> QueryHistory(ItemSpec itemSpec, int maxResults);
    [IteratorStateMachineAttribute("Microsoft.TeamFoundation.VersionControl.Client.VersionControlServer/<QueryHistory>d__7")]
public IEnumerable`1<Changeset> QueryHistory(QueryHistoryParameters parameters);
    private sealed virtual override void Microsoft.TeamFoundation.Client.ITfsTeamProjectCollectionObject.Initialize(TfsTeamProjectCollection tfs);
    public void UpdateUserName();
    public Workspace CreateWorkspace(string name);
    public Workspace CreateWorkspace(string name, string owner);
    public Workspace CreateWorkspace(string name, string owner, string comment);
    public Workspace CreateWorkspace(string name, string owner, string comment, WorkingFolder[] mappings);
    public Workspace CreateWorkspace(string name, string owner, string comment, WorkingFolder[] mappings, string computer);
    public Workspace CreateWorkspace(string name, string owner, string comment, WorkingFolder[] mappings, string computer, bool removeUnparentedCloaks);
    public Workspace CreateWorkspace(string name, string owner, string comment, WorkingFolder[] mappings, string computer, WorkspacePermissionProfile permissionProfile, bool removeUnparentedCloaks);
    public Workspace CreateWorkspace(CreateWorkspaceParameters createWorkspaceParameters);
    public bool DeleteWorkspace(string workspaceName, string workspaceOwner);
    public Workspace GetWorkspace(string localPath);
    public Workspace TryGetWorkspace(string localPath);
    public Workspace GetWorkspace(WorkspaceInfo workspaceInfo);
    public Workspace GetWorkspace(string workspaceName, string workspaceOwner);
    public Workspace[] QueryWorkspaces(string workspaceName, string workspaceOwner, string computer);
    public Workspace[] QueryWorkspaces(string workspaceName, string workspaceOwner, string computer, WorkspacePermissions permissionsFilter);
    public void StripUnsupportedCheckinOptions(CheckInParameters checkInParameters);
    public int CheckInShelveset(string shelvesetName, string ownerName);
    public int CheckInShelveset(ShelvesetCheckInParameters checkinParameters);
    public String[] GetAllCheckinNoteFieldNames();
    public void RenameCheckinNoteFieldName(string path, string oldName, string newName);
    public CheckinNoteFieldDefinition[] GetCheckinNoteDefinitions(TeamProject[] teamProjects);
    public ItemSecurity[] GetPermissions(String[] items, RecursionType recursion);
    public ItemSecurity[] GetPermissions(String[] identityNames, String[] items, RecursionType recursion);
    public SecurityChange[] SetPermissions(SecurityChange[] securityChanges);
    public GlobalSecurity GetGlobalPermissions(String[] identityNames);
    public PermissionChange[] SetGlobalPermissions(PermissionChange[] permissionChanges);
    public String[] GetEffectivePermissions(string userName, string item);
    public String[] GetEffectiveGlobalPermissions(string userName);
    public FileType[] GetFileTypes();
    public void SetFileTypes(FileType[] fileTypes);
    internal FileType QueryCachedFileType(string extension);
    public bool ServerItemExists(string path, ItemType itemType);
    public bool ServerItemExists(string path, VersionSpec version, DeletedState deletedState, ItemType itemType);
    public Item GetItem(string path);
    public Item GetItem(string path, VersionSpec version);
    public Item GetItem(string path, VersionSpec version, int deletionId);
    public Item GetItem(string path, VersionSpec version, DeletedState deletedState);
    public Item GetItem(string path, VersionSpec version, int deletionId, bool includeDownloadInfo);
    public Item GetItem(string path, VersionSpec version, DeletedState deletedState, bool includeDownloadInfo);
    public Item GetItem(string path, VersionSpec version, int deletionId, GetItemsOptions options);
    public Item GetItem(string path, VersionSpec version, DeletedState deletedState, GetItemsOptions options);
    public ItemSet GetItems(string path);
    public ItemSet GetItems(string path, RecursionType recursion);
    public ItemSet GetItems(string path, VersionSpec version, RecursionType recursion);
    public ItemSet GetItems(string path, VersionSpec version, RecursionType recursion, DeletedState deletedState, ItemType itemType);
    public ItemSet GetItems(string path, VersionSpec version, RecursionType recursion, DeletedState deletedState, ItemType itemType, bool includeDownloadInfo);
    public ItemSet GetItems(ItemSpec itemSpec, VersionSpec version, DeletedState deletedState, ItemType itemType, bool includeDownloadInfo);
    public ItemSet GetItems(ItemSpec itemSpec, VersionSpec version, DeletedState deletedState, ItemType itemType, GetItemsOptions options);
    public ItemSet[] GetItems(ItemSpec[] itemSpecs, VersionSpec version, DeletedState deletedState, ItemType itemType);
    public ItemSet[] GetItems(ItemSpec[] itemSpecs, VersionSpec version, DeletedState deletedState, ItemType itemType, bool includeDownloadInfo);
    public ItemSet[] GetItems(ItemSpec[] itemSpecs, VersionSpec version, DeletedState deletedState, ItemType itemType, GetItemsOptions options);
    public ItemSet[] GetItems(ItemSpec[] itemSpecs, VersionSpec version, DeletedState deletedState, ItemType itemType, GetItemsOptions options, String[] itemPropertyFilters, String[] itemAttributeFilters);
    public ExtendedItem[] GetExtendedItems(string path, DeletedState deletedState, ItemType itemType);
    public ExtendedItem[][] GetExtendedItems(ItemSpec[] itemSpecs, DeletedState deletedState, ItemType itemType);
    public ExtendedItem[][] GetExtendedItems(ItemSpec[] itemSpecs, DeletedState deletedState, ItemType itemType, GetItemsOptions options);
    public ExtendedItem[][] GetExtendedItems(ItemSpec[] itemSpecs, DeletedState deletedState, ItemType itemType, GetItemsOptions options, String[] itemPropertyFilters);
    internal ExtendedItem[][] GetExtendedItemsInternal(string workspaceName, string workspaceOwner, ItemSpec[] itemSpecs, DeletedState deletedState, ItemType itemType, GetItemsOptions options, String[] itemPropertyFilters);
    public void AddProxy(string url);
    public void AddProxy(string url, string friendlyName);
    public void AddProxy(ProxyInfo proxy);
    public void DeleteProxy(string proxyUrl);
    public ProxyInfo GetProxy(string proxyUrl);
    public ProxyInfo[] GetProxies(String[] proxyUrls);
    public ProxyInfo[] GetProxies();
    public List`1<ProxyInfo> GetBestProxies(string site);
    private List`1<ProxyInfo> GetBestProxies(string site, ProxyInfo[] proxyList);
    public void ConfigureProxy(ProxyInfo proxy);
    public void ConfigureProxy(string proxyUrl);
    private void ConfigureProxy(string proxyUrl, bool proxyAutoConfigured);
    internal ProxyInfo AutomaticallyConfigureProxy();
    public string GetIdentityDisplayName(TeamFoundationIdentity identity);
    public Item GetItem(int itemId, int changesetNumber);
    public Item GetItem(int itemId, int changesetNumber, bool includeDownloadInfo);
    public Item GetItem(int itemId, int changesetNumber, GetItemsOptions options);
    public Item[] GetItems(Int32[] itemIds, int changesetNumber);
    public Item[] GetItems(Int32[] itemIds, int changesetNumber, bool includeDownloadInfo);
    public Item[] GetItems(Int32[] itemIds, int changesetNumber, GetItemsOptions options);
    public PendingSet[] GetPendingSets(String[] items, RecursionType recursion);
    public PendingSet[] QueryPendingSets(String[] items, RecursionType recursion, string queryWorkspaceName, string queryUserName);
    public PendingSet[] QueryPendingSets(ItemSpec[] itemSpecs, string queryWorkspaceName, string queryUserName);
    public PendingSet[] QueryPendingSets(ItemSpec[] itemSpecs, string queryWorkspaceName, string queryUserName, bool includeDownloadInfo);
    public PendingSet[] QueryPendingSets(ItemSpec[] itemSpecs, string queryWorkspaceName, string queryUserName, bool includeDownloadInfo, bool includeCandidates);
    public PendingSet[] QueryPendingSets(ItemSpec[] itemSpecs, string queryWorkspaceName, string queryUserName, bool includeDownloadInfo, bool includeCandidates, String[] itemPropertyFilters);
    internal PendingSet[] QueryPendingSets(string workspaceName, string workspaceOwner, ItemSpec[] itemSpecs, string queryWorkspaceName, string queryUserName, bool includeDownloadInfo, bool includeCandidates, String[] itemPropertyFilters);
    [ObsoleteAttribute("Method obsolete since TFS 2010. Please use VersionControlServer.QueryPendingSets, VersionControlServer.QueryShelvedChanges or Workspace.GetPendingChanges instead.")]
public PendingChange GetPendingChange(int pendingChangeId);
    [ObsoleteAttribute("Method obsolete since TFS 2010. Please use VersionControlServer.QueryPendingSets, VersionControlServer.QueryShelvedChanges or Workspace.GetPendingChanges instead.")]
public PendingChange GetPendingChange(int pendingChangeId, bool includeDownloadInfo);
    private PendingChange GetPendingChangePrivate(int pendingChangeId, bool includeDownloadInfo);
    [ObsoleteAttribute("Method obsolete since TFS 2010. Please use VersionControlServer.QueryPendingSets, VersionControlServer.QueryShelvedChanges or Workspace.GetPendingChanges instead.")]
public PendingChange[] GetPendingChanges(Int32[] pendingChangeIds);
    [ObsoleteAttribute("Method obsolete since TFS 2010. Please use VersionControlServer.QueryPendingSets, VersionControlServer.QueryShelvedChanges or Workspace.GetPendingChanges instead.")]
public PendingChange[] GetPendingChanges(Int32[] pendingChangeIds, bool includeDownloadInfo);
    private PendingChange[] GetPendingChangesPrivate(Int32[] pendingChangeIds, bool includeDownloadInfo);
    public int GetLatestChangesetId();
    public Changeset GetChangeset(int changesetId);
    public Changeset GetChangeset(int changesetId, bool includeChanges, bool includeDownloadInfo);
    public Changeset GetChangeset(int changesetId, bool includeChanges, bool includeDownloadInfo, bool includeSourceRenames);
    public Changeset GetChangeset(int changesetId, bool includeChanges, bool includeDownloadInfo, String[] changesetPropertyFilters);
    public Changeset GetChangeset(int changesetId, bool includeChanges, bool includeDownloadInfo, String[] changesetPropertyFilters, String[] itemAttributeFilters, String[] itemPropertyFilters);
    public Change[] GetChangesForChangeset(int changesetId, bool includeDownloadInfo, int pageSize, ItemSpec lastItem);
    public Change[] GetChangesForChangeset(int changesetId, bool includeDownloadInfo, int pageSize, ItemSpec lastItem, String[] propertyNameFilters);
    public Change[] GetChangesForChangeset(int changesetId, bool includeDownloadInfo, int pageSize, ItemSpec lastItem, String[] itemAttributeFilters, bool includeMergeSourceInfo);
    public Change[] GetChangesForChangeset(int changesetId, bool includeDownloadInfo, int pageSize, ItemSpec lastItem, String[] itemAttributeFilters, String[] itemPropertyFilters, bool includeMergeSourceInfo);
    public BranchHistoryTreeItem[][] GetBranchHistory(ItemSpec[] itemSpecs, VersionSpec version);
    public ChangesetMergeDetails QueryMergesWithDetails(string sourcePath, VersionSpec sourceVersion, int sourceDeletionId, string targetPath, VersionSpec targetVersion, int targetDeletionId, VersionSpec versionFrom, VersionSpec versionTo, RecursionType recursion);
    public ChangesetMergeDetails QueryMergesWithDetails(string sourcePath, VersionSpec sourceVersion, int sourceDeletionId, string targetPath, VersionSpec targetVersion, int targetDeletionId, VersionSpec versionFrom, VersionSpec versionTo, RecursionType recursion, bool showAll);
    public ChangesetMerge[] QueryMerges(string sourcePath, VersionSpec sourceVersion, string targetPath, VersionSpec targetVersion, VersionSpec versionFrom, VersionSpec versionTo, RecursionType recursion);
    public ChangesetMerge[] QueryMerges(string sourcePath, VersionSpec sourceVersion, string targetPath, VersionSpec targetVersion, VersionSpec versionFrom, VersionSpec versionTo, RecursionType recursion, bool showAll);
    public ChangesetMerge[] QueryMerges(ItemSpec sourceItemSpec, VersionSpec sourceVersion, ItemSpec targetItemSpec, VersionSpec targetVersion, VersionSpec versionFrom, VersionSpec versionTo);
    public ChangesetMerge[] QueryMerges(ItemSpec sourceItemSpec, VersionSpec sourceVersion, ItemSpec targetItemSpec, VersionSpec targetVersion, VersionSpec versionFrom, VersionSpec versionTo, bool showAll);
    public ExtendedMerge[] TrackMerges(Int32[] sourceChangesetIds, ItemIdentifier sourceItem, ItemIdentifier[] targetItems, ItemSpec pathFilter);
    public ExtendedMerge[] TrackMerges(Int32[] sourceChangesetIds, ItemIdentifier sourceItem, ItemIdentifier[] targetItems, ItemSpec pathFilter, String[]& partialTargetItems);
    public IEnumerable`1<ExtendedMerge> QueryMergesExtended(ItemSpec targetItemSpec, VersionSpec targetVersion, VersionSpec versionFrom, VersionSpec versionTo);
    public IEnumerable`1<ExtendedMerge> QueryMergesExtended(ItemSpec targetItemSpec, VersionSpec targetVersion, VersionSpec versionFrom, VersionSpec versionTo, QueryMergesExtendedOptions options);
    public ItemIdentifier[] QueryMergeRelationships(string serverItem);
    public MergeCandidate[] GetMergeCandidates(string sourcePath, string targetPath, RecursionType recursion);
    public MergeCandidate[] GetMergeCandidates(ItemSpec source, string targetPath);
    public MergeCandidate[] GetMergeCandidates(ItemSpec source, string targetPath, MergeOptionsEx options);
    public void DownloadFile(string serverPath, string localFileName);
    public void DownloadFile(string serverPath, int deletionId, VersionSpec version, string localFileName);
    [EditorBrowsableAttribute("1")]
public void DownloadFileByUrl(string downloadUrl, string localFileName);
    [EditorBrowsableAttribute("1")]
public Stream DownloadFileByUrl(string downloadUrl);
    public LabelResult[] CreateLabel(VersionControlLabel label, LabelItemSpec[] itemSpecs, LabelChildOption options);
    [EditorBrowsableAttribute("1")]
public LabelResult[] CreateLabel(VersionControlLabel label, LabelItemSpec[] itemSpecs, LabelChildOption options, Failure[]& failures);
    public LabelResult[] UnlabelItem(string labelName, string labelScope, ItemSpec[] itemSpecs, VersionSpec version);
    [EditorBrowsableAttribute("1")]
public LabelResult[] UnlabelItem(string labelName, string labelScope, ItemSpec[] itemSpecs, VersionSpec version, Predicate`1<Failure> failureFilter, Failure[]& filteredFailures);
    public LabelResult[] DeleteLabel(string labelName, string labelScope);
    public VersionControlLabel[] QueryLabels(string labelName, string labelScope, string owner, bool includeItems);
    public VersionControlLabel[] QueryLabels(string labelName, string labelScope, string owner, bool includeItems, string filterItem, VersionSpec versionFilterItem);
    public VersionControlLabel[] QueryLabels(string labelName, string labelScope, string owner, bool includeItems, string filterItem, VersionSpec versionFilterItem, bool includeDownloadInfo);
    public Changeset[] CompareLabels(string startLabelName, string startLabelScope, string endLabelName, string endLabelScope, int minChangeSet, int maxCount);
    public Shelveset[] QueryShelvesets(string shelvesetName, string shelvesetOwner);
    public Shelveset[] QueryShelvesets(string shelvesetName, string shelvesetOwner, String[] propertyNameFilters);
    public void DeleteShelveset(Shelveset shelveset);
    public void DeleteShelveset(string shelvesetName, string shelvesetOwner);
    public void UpdateShelveset(string shelvesetName, string shelvesetOwner, Shelveset updatedShelveset);
    public PendingSet[] QueryShelvedChanges(Shelveset shelveset);
    public PendingSet[] QueryShelvedChanges(Shelveset shelveset, ItemSpec[] itemSpecs);
    public PendingSet[] QueryShelvedChanges(string shelvesetName, string shelvesetOwner);
    public PendingSet[] QueryShelvedChanges(string shelvesetName, string shelvesetOwner, ItemSpec[] itemSpecs);
    public PendingSet[] QueryShelvedChanges(string shelvesetName, string shelvesetOwner, ItemSpec[] itemSpecs, bool includeDownloadInfo);
    public PendingSet[] QueryShelvedChanges(string shelvesetName, string shelvesetOwner, ItemSpec[] itemSpecs, bool includeDownloadInfo, String[] itemPropertyFilters);
    internal PendingSet[] QueryShelvedChanges(string workspaceName, string workspaceOwner, string shelvesetName, string shelvesetOwner, ItemSpec[] itemSpecs, bool includeDownloadInfo, String[] itemPropertyFilters);
    public TeamProject[] GetAllTeamProjects(bool refresh);
    public TeamProject GetTeamProjectForServerPath(string serverPath);
    public TeamProject TryGetTeamProjectForServerPath(string serverPath);
    public TeamProject[] GetTeamProjectsForServerPaths(String[] serverPaths);
    public TeamProject GetTeamProject(string name);
    public TeamProject TryGetTeamProject(string name);
    private TeamProject[] GetTeamProjects(String[] names);
    private void UpdateTeamProjectCache();
    internal void SetTeamProjectCacheRefreshFlagIfNecessary(IEnumerable`1<PendingChange> pendingChanges);
    public PolicyEnvelope[] GetCheckinPoliciesForServerPaths(String[] serverItems);
    public CheckinNoteFieldDefinition[] GetCheckinNoteDefinitionsForServerPaths(String[] serverItems);
    public void CreateTeamProjectFolder(TeamProjectFolderOptions options);
    public ArtifactPropertyValue GetChangesetProperty(int changesetId, string propertyNameFilter);
    public ArtifactPropertyValue GetChangesetProperty(int changesetId, String[] propertyNameFilters);
    public void SetChangesetProperty(int changesetId, string propertyName, Nullable`1<int> value);
    public void SetChangesetProperty(int changesetId, string propertyName, string value);
    public void SetChangesetProperty(int changesetId, string propertyName, Nullable`1<double> value);
    public void SetChangesetProperty(int changesetId, string propertyName, Byte[] value);
    public void SetChangesetProperty(int changesetId, string propertyName, Nullable`1<DateTime> value);
    public void SetChangesetProperty(int changesetId, List`1<PropertyValue> propertyValues);
    public void SetChangesetProperty(int changesetId, PropertyValue[] propertyValues);
    [ObsoleteAttribute("Please use GetItems to retrieve versioned item attributes.", "False")]
public ArtifactPropertyValue[] GetVersionedItemProperty(ItemSpec itemSpec, VersionSpec versionSpec, DeletedState deletedState, ItemType itemType, string propertyNameFilter);
    [ObsoleteAttribute("Please use GetItems to retrieve versioned item attributes.", "False")]
public ArtifactPropertyValue[] GetVersionedItemProperty(ItemSpec[] itemSpecs, VersionSpec versionSpec, DeletedState deletedState, ItemType itemType, String[] propertyNameFilters);
    [ObsoleteAttribute("Please use SetVersionedItemAttribute to set attributes on versioned items.", "False")]
public void SetVersionedItemProperty(ItemSpec itemSpec, VersionSpec versionSpec, DeletedState deletedState, ItemType itemType, string propertyName, Nullable`1<int> value);
    [ObsoleteAttribute("Please use SetVersionedItemAttribute to set attributes on versioned items.", "False")]
public void SetVersionedItemProperty(ItemSpec itemSpec, VersionSpec versionSpec, DeletedState deletedState, ItemType itemType, string propertyName, Nullable`1<double> value);
    [ObsoleteAttribute("Please use SetVersionedItemAttribute to set attributes on versioned items.", "False")]
public void SetVersionedItemProperty(ItemSpec itemSpec, VersionSpec versionSpec, DeletedState deletedState, ItemType itemType, string propertyName, Nullable`1<DateTime> value);
    [ObsoleteAttribute("Please use SetVersionedItemAttribute to set attributes on versioned items.", "False")]
public void SetVersionedItemProperty(ItemSpec itemSpec, VersionSpec versionSpec, DeletedState deletedState, ItemType itemType, string propertyName, string value);
    [ObsoleteAttribute("Please use SetVersionedItemAttribute to set attributes on versioned items.", "False")]
public void SetVersionedItemProperty(ItemSpec itemSpec, VersionSpec versionSpec, DeletedState deletedState, ItemType itemType, string propertyName, Byte[] value);
    [ObsoleteAttribute("Please use SetVersionedItemAttribute to set attributes on versioned items.", "False")]
public void SetVersionedItemProperty(ItemSpec[] itemSpecs, VersionSpec versionSpec, DeletedState deletedState, ItemType itemType, PropertyValue[] propertyValues);
    public void SetVersionedItemAttribute(ItemSpec itemSpec, VersionSpec versionSpec, DeletedState deletedState, ItemType itemType, string propertyName, Nullable`1<int> value);
    public void SetVersionedItemAttribute(ItemSpec itemSpec, VersionSpec versionSpec, DeletedState deletedState, ItemType itemType, string propertyName, Nullable`1<double> value);
    public void SetVersionedItemAttribute(ItemSpec itemSpec, VersionSpec versionSpec, DeletedState deletedState, ItemType itemType, string propertyName, Nullable`1<DateTime> value);
    public void SetVersionedItemAttribute(ItemSpec itemSpec, VersionSpec versionSpec, DeletedState deletedState, ItemType itemType, string propertyName, string value);
    public void SetVersionedItemAttribute(ItemSpec itemSpec, VersionSpec versionSpec, DeletedState deletedState, ItemType itemType, string propertyName, Byte[] value);
    public void SetVersionedItemAttribute(ItemSpec[] itemSpecs, VersionSpec versionSpec, DeletedState deletedState, ItemType itemType, PropertyValue[] propertyValues);
    private PropertyValue[] PreparePropertyValues(PropertyValue[] propertyValues, Boolean& isDirty);
    public Item[] Destroy(ItemSpec itemSpec, VersionSpec versionSpec, VersionSpec stopAt, DestroyFlags flags);
    public Item[] Destroy(ItemSpec itemSpec, VersionSpec versionSpec, VersionSpec stopAt, DestroyFlags flags, PendingSet[]& affectedPendingChanges, PendingSet[]& affectedShelvedChanges);
    internal void DetermineWorkspaceNameAndOwner(string path, String& workspaceName, String& workspaceOwner);
    internal void DetermineWorkspaceNameAndOwner(String[] paths, String& workspaceName, String& workspaceOwner);
    public void CreateBranchObject(BranchProperties properties);
    public void DeleteBranchObject(ItemIdentifier branch);
    public void UpdateBranchObject(BranchProperties properties);
    public BranchObject[] QueryBranchObjects(ItemIdentifier rootItem, RecursionType recursion);
    public BranchObject[] QueryRootBranchObjects(RecursionType recursion);
    public BranchObjectOwnership[] QueryBranchObjectOwnership(Int32[] changesetIds);
    public BranchObjectOwnership[] QueryBranchObjectOwnership(Int32[] changesetIds, ItemSpec pathFilter);
    public int CreateBranch(string sourcePath, string targetPath, VersionSpec version);
    public int CreateBranch(string sourcePath, string targetPath, VersionSpec version, string owner, string comment, CheckinNote checkinNote, PolicyOverrideInfo policyOverride, Mapping[] mappings);
    public void ResetCheckinDates(DateTime lastCheckinDate);
    public ServerSettings GetServerSettingsWithFallback(Boolean& fallbackUsed);
    private ServerSettings FetchServerSettings();
    public void SetServerSettings(ServerSettings settings);
    internal void DetermineWorkspaceNameAndOwner(LabelItemSpec[] labelItemSpecs, String& workspaceName, String& workspaceOwner);
    internal void DetermineWorkspaceNameAndOwner(SecurityChange[] securityChanges, String& workspaceName, String& workspaceOwner);
    internal void DetermineWorkspaceNameAndOwner(ItemSpec itemSpec, String& workspaceName, String& workspaceOwner);
    internal void DetermineWorkspaceNameAndOwner(ItemSpec[] itemSpecs, String& workspaceName, String& workspaceOwner);
    internal void ThrowIfCanceled();
    [EditorBrowsableAttribute("1")]
public void RaiseChangesetReconciled(int changesetId);
    public void add_BeforeCheckinPendingChange(ProcessingChangeEventHandler value);
    public void remove_BeforeCheckinPendingChange(ProcessingChangeEventHandler value);
    public void add_CommitCheckin(CommitCheckinEventHandler value);
    public void remove_CommitCheckin(CommitCheckinEventHandler value);
    public void add_ChangesetReconciled(ChangesetReconciledEventHandler value);
    public void remove_ChangesetReconciled(ChangesetReconciledEventHandler value);
    public void add_FolderContentChanged(FolderContentChangedEventHandler value);
    public void remove_FolderContentChanged(FolderContentChangedEventHandler value);
    public void add_BeforeShelvePendingChange(ProcessingChangeEventHandler value);
    public void remove_BeforeShelvePendingChange(ProcessingChangeEventHandler value);
    public void add_CommitShelveset(CommitShelvesetEventHandler value);
    public void remove_CommitShelveset(CommitShelvesetEventHandler value);
    public void add_DeletedShelveset(DeletedShelvesetEventHandler value);
    public void remove_DeletedShelveset(DeletedShelvesetEventHandler value);
    public void add_UnshelveShelveset(UnshelveShelvesetEventHandler value);
    public void remove_UnshelveShelveset(UnshelveShelvesetEventHandler value);
    public void add_Merging(MergeEventHandler value);
    public void remove_Merging(MergeEventHandler value);
    public void add_NewPendingChange(PendingChangeEventHandler value);
    public void remove_NewPendingChange(PendingChangeEventHandler value);
    public void add_UndonePendingChange(PendingChangeEventHandler value);
    public void remove_UndonePendingChange(PendingChangeEventHandler value);
    public void add_ResolvedConflict(ResolvedConflictEventHandler value);
    public void remove_ResolvedConflict(ResolvedConflictEventHandler value);
    public void add_Conflict(ConflictEventHandler value);
    public void remove_Conflict(ConflictEventHandler value);
    public void add_UnshelveConflict(ConflictEventHandler value);
    public void remove_UnshelveConflict(ConflictEventHandler value);
    public void add_NonFatalError(ExceptionEventHandler value);
    public void remove_NonFatalError(ExceptionEventHandler value);
    public void add_BeforeWorkItemsUpdate(BeforeWorkItemsUpdateEventHandler value);
    public void remove_BeforeWorkItemsUpdate(BeforeWorkItemsUpdateEventHandler value);
    public void add_AfterWorkItemsUpdated(AfterWorkItemsUpdatedEventHandler value);
    public void remove_AfterWorkItemsUpdated(AfterWorkItemsUpdatedEventHandler value);
    public void add_WorkItemUpdated(WorkItemUpdatedEventHandler value);
    public void remove_WorkItemUpdated(WorkItemUpdatedEventHandler value);
    public void add_Getting(GettingEventHandler value);
    public void remove_Getting(GettingEventHandler value);
    public void add_CreatedWorkspace(WorkspaceEventHandler value);
    public void remove_CreatedWorkspace(WorkspaceEventHandler value);
    public void add_UpdatedWorkspace(WorkspaceEventHandler value);
    public void remove_UpdatedWorkspace(WorkspaceEventHandler value);
    public void add_DeletedWorkspace(WorkspaceEventHandler value);
    public void remove_DeletedWorkspace(WorkspaceEventHandler value);
    public void add_GetCompleted(WorkspaceEventHandler value);
    public void remove_GetCompleted(WorkspaceEventHandler value);
    public void add_PendingChangesChanged(WorkspaceEventHandler value);
    public void remove_PendingChangesChanged(WorkspaceEventHandler value);
    public void add_PendingChangeCandidatesChanged(WorkspaceEventHandler value);
    public void remove_PendingChangeCandidatesChanged(WorkspaceEventHandler value);
    public void add_BeforeDeleteWorkspace(WorkspaceCancelEventHandler value);
    public void remove_BeforeDeleteWorkspace(WorkspaceCancelEventHandler value);
    public void add_SetWorkspaceLocationProgress(SetWorkspaceLocationProgressEventHandler value);
    public void remove_SetWorkspaceLocationProgress(SetWorkspaceLocationProgressEventHandler value);
    [CompilerGeneratedAttribute]
public void add_Destroyed(DestroyedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Destroyed(DestroyedEventHandler value);
    internal void OnDestroyed(DestroyEventArgs e);
    [CompilerGeneratedAttribute]
public void add_CommittedBranchCreated(CommittedBranchCreatedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_CommittedBranchCreated(CommittedBranchCreatedEventHandler value);
    internal void OnCommittedBranchCreated(CommittedBranchCreatedEventArgs e);
    [CompilerGeneratedAttribute]
public void add_BranchObjectCreated(BranchObjectCreatedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_BranchObjectCreated(BranchObjectCreatedEventHandler value);
    internal void OnBranchObjectCreated(BranchObjectCreatedEventArgs e);
    [CompilerGeneratedAttribute]
public void add_BranchObjectDeleted(BranchObjectDeletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_BranchObjectDeleted(BranchObjectDeletedEventHandler value);
    internal void OnBranchObjectDeleted(BranchObjectDeletedEventArgs e);
    [CompilerGeneratedAttribute]
public void add_BranchObjectUpdated(BranchObjectUpdatedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_BranchObjectUpdated(BranchObjectUpdatedEventHandler value);
    internal void OnBranchObjectUpdated(BranchObjectUpdatedEventArgs e);
    internal void OnDownloading(FileTransferEventArgs e);
    [CompilerGeneratedAttribute]
public void add_OperationStarting(OperationEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_OperationStarting(OperationEventHandler value);
    internal void OnOperationStarting(OperationEventArgs e);
    [CompilerGeneratedAttribute]
public void add_OperationFinished(OperationEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_OperationFinished(OperationEventHandler value);
    internal void OnOperationFinished(OperationEventArgs e);
    [CompilerGeneratedAttribute]
public void add_TeamProjectFolderCreated(TeamProjectFolderCreatedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_TeamProjectFolderCreated(TeamProjectFolderCreatedEventHandler value);
    internal void OnTeamProjectFolderCreated(TeamProjectFolderCreatedEventArgs e);
    [CompilerGeneratedAttribute]
public void add_ShelvesetUpdated(ShelvesetUpdatedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ShelvesetUpdated(ShelvesetUpdatedEventHandler value);
    internal void OnShelvesetUpdated(ShelvesetUpdatedEventArgs e);
    public TfsTeamProjectCollection get_TeamProjectCollection();
    public string get_AuthenticatedUser();
    public TeamFoundationIdentity get_AuthorizedIdentity();
    public string get_AuthorizedUser();
    internal bool IsAuthorizedUser(string name);
    public string get_CurrentCommand();
    public void set_CurrentCommand(string value);
    public Guid get_ServerGuid();
    public bool get_Canceled();
    public void set_Canceled(bool value);
    public VersionControlArtifactProvider get_ArtifactProvider();
    public static int get_MaxBackgroundThreads();
    public static void set_MaxBackgroundThreads(int value);
    public static int get_MaxResults();
    public static void set_MaxResults(int value);
    public static TraceSwitch get_ClientTracing();
    public static void set_ClientTracing(TraceSwitch value);
    public static string get_BaselineFolderNamePrefix();
    public static string get_IgnoreFileName();
    internal Client get_Client();
    internal WebServiceLayer get_WebServiceLayer();
    private Dictionary`2<string, TeamProject> get_TeamProjectCache();
    private FrameworkSecurityProvider get_SecurityProvider();
    internal SecurityNamespace get_WorkspaceSecurity();
    public int get_SupportedFeatures();
    public WebServiceLevel get_WebServiceLevel();
    internal IdentitySearchFactor get_IMSUserNameSearchFactor();
    internal TeamFoundationIdentity ResolveIdentity(string username);
    internal TeamFoundationIdentity ResolveIdentity(String& username);
    internal void set_LatestSettingsHash(string value);
    [CompilerGeneratedAttribute]
private void <set_LatestSettingsHash>b__382_0(object state);
}
[XmlIncludeAttribute("Microsoft.TeamFoundation.VersionControl.Client.ChangesetVersionSpec")]
[XmlIncludeAttribute("Microsoft.TeamFoundation.VersionControl.Client.DateVersionSpec")]
[XmlIncludeAttribute("Microsoft.TeamFoundation.VersionControl.Client.LabelVersionSpec")]
[XmlIncludeAttribute("Microsoft.TeamFoundation.VersionControl.Client.LatestVersionSpec")]
[XmlIncludeAttribute("Microsoft.TeamFoundation.VersionControl.Client.WorkspaceVersionSpec")]
public abstract class Microsoft.TeamFoundation.VersionControl.Client.VersionSpec : object {
    internal static VersionSpecFactory VersionSpecFactory;
    public static char RangeSeparator;
    public static char Separator;
    public static char DeletionModifier;
    private string m_userInputString;
    public string DisplayString { get; }
    public static VersionSpec Latest { get; }
    private static VersionSpec();
    [EditorBrowsableAttribute("1")]
public static VersionSpec FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public abstract virtual void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, VersionSpec obj);
    public static VersionSpec ParseSingleSpec(string versionSpec, string user);
    public static VersionSpec ParseSingleSpec(string versionSpec, string user, string userDisplay);
    public static VersionSpec[] Parse(string versionSpec, string user);
    public static VersionSpec[] Parse(string versionSpec, string user, string userDisplay);
    public static void ParseVersionedFileSpec(string spec, string user, String& fileName, VersionSpec[]& versions);
    public static void ParseVersionedFileSpec(string spec, string user, Int32& deletionId, String& fileName, VersionSpec[]& versions);
    public static void ParseVersionedFileSpec(string spec, string user, string userDisplay, Int32& deletionId, String& fileName, VersionSpec[]& versions);
    private static bool IsDeletionSpecifier(string spec);
    private static bool IsWorkspaceSpecifier(string spec);
    private static int ParseDeletionId(string spec);
    public string Format(string path);
    public static string FormatRange(string path, VersionSpec from, VersionSpec to);
    public static string AddDeletionModifierIfNecessary(string path, int deletionId);
    public static bool ReorderVersionSpecs(VersionSpec& start, VersionSpec& end);
    private static void Swap(T& x, T& y);
    [EditorBrowsableAttribute("1")]
public abstract virtual string ComputeVersionString();
    public string get_DisplayString();
    public static VersionSpec get_Latest();
    public static string AddDeletionModifierIfNecessary(Item item);
}
public class Microsoft.TeamFoundation.VersionControl.Client.Warning : object {
    private int m_changeEx;
    private ChangeType m_changeType;
    private string m_parentOrChildPath;
    private string m_user;
    private string m_userDisplayName;
    private WarningType m_warningType;
    private string m_workspace;
    public string ParentOrChildPath { get; }
    public string User { get; }
    public string UserDisplayName { get; }
    public WarningType WarningType { get; }
    public string Workspace { get; }
    public ChangeType ChangeType { get; }
    public string get_ParentOrChildPath();
    public string get_User();
    public string get_UserDisplayName();
    public WarningType get_WarningType();
    public string get_Workspace();
    [EditorBrowsableAttribute("1")]
public static Warning FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, Warning obj);
    public ChangeType get_ChangeType();
    private void AfterDeserialize();
}
public enum Microsoft.TeamFoundation.VersionControl.Client.WarningType : Enum {
    public int value__;
    public static WarningType Invalid;
    public static WarningType NamespacePendingChangeWarning;
    public static WarningType ResourcePendingChangeWarning;
    public static WarningType StaleVersionWarning;
}
public class Microsoft.TeamFoundation.VersionControl.Client.WebMethodNotSupportedException : VersionControlException {
    public WebMethodNotSupportedException(string message);
    public WebMethodNotSupportedException(string message, Exception ex);
    protected WebMethodNotSupportedException(SerializationInfo info, StreamingContext context);
}
internal abstract class Microsoft.TeamFoundation.VersionControl.Client.WebServiceLayer : object {
    [CompilerGeneratedAttribute]
private bool <Canceled>k__BackingField;
    private bool m_playingBackQueuedEdits;
    private VersionControlServer m_sourceControl;
    protected RuntimeWorkspaceCache m_runtimeWorkspaceCache;
    private WebServiceLevel m_serviceLevel;
    private Nullable`1<SupportedFeatures> m_supportedFeatures;
    private Repository m_repository;
    private Admin m_admin;
    private RepositoryExtensions m_repositoryExtensions;
    private Repository4 m_repository4;
    private Repository5 m_repository5;
    private Lazy`1<HashSet`1<ICancelableAsyncResult>> m_cancelableAsyncResults;
    public Repository Repository { get; }
    protected RepositoryExtensions RepositoryExtensions { get; }
    protected Repository4 Repository4 { get; }
    protected Repository5 Repository5 { get; }
    public WebServiceLevel ServiceLevel { get; }
    public SupportedFeatures SupportedFeatures { get; }
    protected VersionControlServer VersionControlServer { get; }
    internal bool Canceled { get; private set; }
    public WebServiceLayer(VersionControlServer sourceControl);
    public Repository get_Repository();
    protected RepositoryExtensions get_RepositoryExtensions();
    protected Repository4 get_Repository4();
    protected Repository5 get_Repository5();
    public WebServiceLevel get_ServiceLevel();
    public SupportedFeatures get_SupportedFeatures();
    protected VersionControlServer get_VersionControlServer();
    [CompilerGeneratedAttribute]
internal bool get_Canceled();
    [CompilerGeneratedAttribute]
private void set_Canceled(bool value);
    internal void Cancel();
    internal void AddCancelable(ICancelableAsyncResult asyncResult);
    internal void RemoveCancelable(ICancelableAsyncResult asyncResult);
    private void RequireSupportedFeature(SupportedFeatures requiredMask, string featureNotSupportedMessage);
    private void RequireServiceLevel(WebServiceLevel serviceLevel, string featureNotSupportedMessage);
    public XmlReader RetrieveArtifactUri(Uri artifactUri);
    public Changeset ChangesetFromArtifactUri(Uri artifactUri);
    public Shelveset ShelvesetFromArtifactUri(Uri artifactUri);
    public VersionControlLabel LabelFromArtifactUri(Uri artifactUri);
    public Item ItemFromArtifactUri(Uri artifactUri);
    public virtual void AddConflict(string workspaceName, string ownerName, ConflictType conflictType, int itemId, int versionFrom, int pendingChangeId, string sourceLocalItem, string targetLocalItem, int reason);
    public void AddProxy(ProxyInfo proxy);
    public string CheckAuthentication();
    public virtual CheckinResult CheckIn(string workspaceName, string ownerName, String[] serverItems, Changeset info, CheckinNotificationInfo checkinNotificationInfo, int checkinOptions, UploadedBaselinesCollection uploadedBaselinesCollection, Failure[]& conflicts, Failure[]& failures, bool deferCheckIn, int checkInTicket);
    public CheckinResult CheckInShelveset(string shelvesetName, string ownerName, string changesetOwner, CheckinNotificationInfo checkinNotificationInfo, int checkinOptions, Failure[]& conflicts, Failure[]& failures);
    public virtual Failure[] CheckPendingChanges(string workspaceName, string ownerName, String[] serverItems);
    public void CreateAnnotation(string annotationName, string annotatedItem, int version, string annotationValue, string comment, bool overwrite);
    public CheckinResult CreateBranch(string sourcePath, string targetPath, VersionSpec version, Changeset info, CheckinNotificationInfo checkinNotificationInfo, Mapping[] mappings, Failure[]& failures);
    public void CreateCheckinNoteDefinition(string associatedServerItem, CheckinNoteFieldDefinition[] checkinNoteFields);
    public void CreateTeamProjectFolder(TeamProjectFolderOptions teamProjectOptions);
    public virtual Workspace CreateWorkspace(Workspace workspace);
    public void DeleteAnnotation(string annotationName, string annotatedItem, int version, string annotationValue);
    public void DeleteBranchObject(ItemIdentifier rootItem);
    public LabelResult[] DeleteLabel(string labelName, string labelScope);
    public void DeleteProxy(string proxyUrl);
    public void DeleteShelveset(string shelvesetName, string ownerName);
    public void DeleteWorkspace(string workspaceName, string ownerName);
    public Item[] Destroy(ItemSpec item, VersionSpec versionSpec, VersionSpec stopAtSpec, int flags, Failure[]& failures, PendingSet[]& pendingChanges, PendingSet[]& shelvedChanges);
    public void GenerateRepositoryKey();
    public virtual GetOperation[][] Get(string workspaceName, string ownerName, GetRequest[] requests, int maxResults, int options, String[] itemAttributeFilters, String[] itemPropertyFilters, bool noGet);
    public ArtifactPropertyValue GetChangesetProperty(int changesetId, String[] propertyNameFilters);
    public RepositoryProperties GetRepositoryProperties();
    public ArtifactPropertyValue[] GetVersionedItemProperty(string workspaceName, string workspaceOwner, ItemSpec[] itemSpecs, VersionSpec versionSpec, DeletedState deletedState, ItemType itemType, String[] propertyNameFilters);
    public virtual LabelResult[] LabelItem(string workspaceName, string workspaceOwner, VersionControlLabel label, LabelItemSpec[] labelSpecs, LabelChildOption children, Failure[]& failures);
    public virtual GetOperation[] Merge(string workspaceName, string workspaceOwner, ItemSpec source, ItemSpec target, VersionSpec from, VersionSpec to, LockLevel lockLevel, int optionsEx, Failure[]& failures, Conflict[]& conflicts, String[] itemAttributeFilters, String[] itemPropertyFilters, Int32& flags);
    public void OptimizeDatabase(int optimizationFlags);
    public virtual GetOperation[] PendChanges(string workspaceName, string ownerName, ChangeRequest[] changes, int pendChangesOptions, int supportedFeatures, Failure[]& failures, String[] itemPropertyFilters, String[] itemAttributeFilters, bool updateDisk, Boolean& onlineOperation, Int32& flags);
    public virtual void PromotePendingWorkspaceMappings(string workspaceName, string ownerName, int projectNotificationId);
    public Annotation[] QueryAnnotation(string annotationName, string annotatedItem, int version);
    public virtual BranchRelative[][] QueryBranches(string workspaceName, string workspaceOwner, ItemSpec[] items, VersionSpec version);
    public BranchObjectOwnership[] QueryBranchObjectOwnership(Int32[] changesets, ItemSpec pathFilter);
    public BranchObject[] QueryBranchObjects(ItemIdentifier item, RecursionType recursion);
    public Changeset QueryChangeset(int changesetId, bool includeChanges, bool generateDownloadUrls, bool includeSourceRenames);
    public Changeset QueryChangesetExtended(int changesetId, bool includeChanges, bool generateDownloadUrls, String[] changesetPropertyFilters, String[] itemAttributeFilters, String[] itemPropertyFilters);
    public Change[] QueryChangesForChangeset(int changesetId, bool generateDownloadUrls, int pageSize, ItemSpec lastItem, String[] itemAttributeFilters, String[] itemPropertyFilters, bool includeMergeSourceInfo);
    public CheckinNoteFieldDefinition[] QueryCheckinNoteDefinition(String[] associatedServerItem);
    public String[] QueryCheckinNoteFieldNames();
    public virtual Conflict[] QueryConflicts(string workspaceName, string ownerName, ItemSpec[] items);
    public String[] QueryEffectiveGlobalPermissions(string identityName);
    public virtual String[] QueryEffectiveItemPermissions(string workspaceName, string workspaceOwner, string item, string identityName);
    public FileType[] QueryFileTypes();
    public GlobalSecurity QueryGlobalPermissions(String[] identityNames);
    public virtual Changeset[] QueryHistory(string workspaceName, string workspaceOwner, ItemSpec itemSpec, VersionSpec versionItem, string user, VersionSpec versionFrom, VersionSpec versionTo, int maxCount, bool includeFiles, bool generateDownloadUrls, bool slotMode, bool sortAscending);
    public virtual ItemSecurity[] QueryItemPermissions(string workspaceName, string workspaceOwner, ItemSpec[] itemSpecs, String[] identityNames, Failure[]& failures);
    public virtual ItemSet[] QueryItems(string workspaceName, string workspaceOwner, ItemSpec[] items, VersionSpec version, DeletedState deletedState, ItemType itemType, bool generateDownloadUrls, int options, String[] itemPropertyFilters, String[] itemAttributeFilters);
    public Item[] QueryItemsById(Int32[] itemIds, int changeSet, bool generateDownloadUrls, int options);
    public virtual ExtendedItem[][] QueryItemsExtended(string workspaceName, string workspaceOwner, ItemSpec[] items, DeletedState deletedState, ItemType itemType, int options, String[] itemPropertyFilters);
    public virtual VersionControlLabel[] QueryLabels(string workspaceName, string workspaceOwner, string labelName, string labelScope, string owner, string filterItem, VersionSpec versionFilterItem, bool includeItems, bool generateDownloadUrls);
    public virtual Changeset[] CompareLabels(string startLabelName, string startLabelScope, string endLabelName, string endLabelScope, int minChangeSet, int maxCount);
    public virtual LocalVersion[][] QueryLocalVersions(string workspaceName, string workspaceOwner, ItemSpec[] itemSpecs);
    public virtual MergeCandidate[] QueryMergeCandidates(string workspaceName, string workspaceOwner, ItemSpec source, ItemSpec target, int options);
    public ItemIdentifier[] QueryMergeRelationships(string serverItem);
    public virtual ChangesetMerge[] QueryMerges(string workspaceName, string workspaceOwner, ItemSpec source, VersionSpec versionSource, ItemSpec target, VersionSpec versionTarget, VersionSpec versionFrom, VersionSpec versionTo, int maxChangesets, bool showAll, Changeset[]& changesets);
    public virtual ExtendedMerge[] QueryMergesExtended(string workspaceName, string workspaceOwner, ItemSpec target, VersionSpec versionTarget, VersionSpec versionFrom, VersionSpec versionTo, int options);
    public virtual ChangesetMergeDetails QueryMergesWithDetails(string workspaceName, string workspaceOwner, ItemSpec source, VersionSpec versionSource, ItemSpec target, VersionSpec versionTarget, VersionSpec versionFrom, VersionSpec versionTo, int maxChangesets, bool showAll);
    public PendingChange[] QueryPendingChangesById(Int32[] pendingChangeIds, bool generateDownloadUrls);
    public virtual PendingChange[] QueryPendingChangesForWorkspace(string workspaceName, string workspaceOwner, ItemSpec[] itemSpecs, bool generateDownloadUrls, int pageSize, string lastChange, bool includeMergeInfo, Failure[]& failures, String[] itemPropertyFilters);
    public virtual PendingSet[] QueryPendingSets(string localWorkspaceName, string localWorkspaceOwner, string queryWorkspaceName, string ownerName, ItemSpec[] itemSpecs, bool generateDownloadUrls, Failure[]& failures, bool includeCandidates, String[] itemPropertyFilters);
    public virtual Guid QueryPendingChangeSignature(string workspaceName, string ownerName);
    public ProxyInfo[] QueryProxies(String[] proxyUrls);
    public AdminRepositoryInfo QueryRepositoryInformation();
    public virtual PendingSet[] QueryShelvedChanges(string localWorkspaceName, string localWorkspaceOwner, string shelvesetName, string ownerName, ItemSpec[] itemSpecs, bool generateDownloadUrls, Failure[]& failures, String[] itemPropertyFilters);
    public Shelveset[] QueryShelvesets(string shelvesetName, string ownerName, String[] propertyNameFilters);
    public virtual Workspace QueryWorkspace(string workspaceName, string ownerName);
    public Workspace[] QueryWorkspaces(string ownerName, string computer, int permissionsFilter);
    public virtual WorkspaceItemSet[] QueryWorkspaceItems(string workspaceName, string workspaceOwner, ItemSpec[] items, DeletedState deletedState, ItemType itemType, bool generateDownloadUrls, int options);
    public ReconcileResult ReconcileLocalWorkspace(string workspaceName, string ownerName, Guid pendingChangeSignature, LocalPendingChange[] pendingChanges, ServerItemLocalVersionUpdate[] localVersionUpdates, bool clearLocalVersionTable, bool throwOnProjectRenamed);
    public void RefreshIdentityDisplayName();
    public virtual void RemoveLocalConflicts(string workspaceName, string ownerName, IEnumerable`1<Conflict> conflicts, ResolveErrorOptions errorOptions, OnResolvedConflict onResolvedConflict, OnResolveError onResolveError);
    public virtual void Resolve(string workspaceName, string ownerName, IEnumerable`1<Conflict> conflicts, String[] itemAttributeFilters, String[] itemPropertyFilters, ResolveErrorOptions errorOptions, OnResolvedConflict onResolvedConflict, OnResolveError onResolveError);
    public void ResetCheckinDates(DateTime lastCheckinDate);
    public virtual GetOperation[] Rollback(string workspaceName, string workspaceOwner, ItemSpec[] items, VersionSpec itemVersion, VersionSpec from, VersionSpec to, int rollbackOptions, LockLevel lockLevel, Conflict[]& conflicts, Failure[]& failures, String[] itemAttributeFilters, String[] itemPropertyFilters, Int32& flags);
    public void SetChangesetProperty(int changesetId, PropertyValue[] propertyValues);
    public void SetFileTypes(FileType[] fileTypes);
    public virtual Failure[] SetPendingChangeProperty(string workspaceName, string workspaceOwner, ArtifactPropertyValue[] pendingChangePropertyValues);
    public virtual void SetVersionedItemProperty(string workspaceName, string workspaceOwner, ItemSpec[] itemSpecs, VersionSpec versionSpec, DeletedState deletedState, ItemType itemType, PropertyValue[] propertyValues);
    public virtual Failure[] Shelve(string workspaceName, string workspaceOwner, String[] serverItems, Shelveset shelveset, bool replace);
    public ExtendedMerge[] TrackMerges(Int32[] sourceChangesets, ItemIdentifier sourceItem, ItemIdentifier[] targetItems, ItemSpec pathFilter, String[]& partialTargetItems);
    public virtual GetOperation[] UndoPendingChanges(string workspaceName, string ownerName, ItemSpec[] items, Failure[]& failures, String[] itemAttributeFilters, String[] itemPropertyFilters, Boolean& onlineOperation, bool deleteAdds, Int32& flags, bool checkForExistingItems);
    public virtual LabelResult[] UnlabelItem(string workspaceName, string workspaceOwner, string labelName, string labelScope, ItemSpec[] items, VersionSpec version, Failure[]& failures);
    public virtual Shelveset Unshelve(string shelvesetName, string shelvesetOwner, string workspaceName, string workspaceOwner, ItemSpec[] items, String[] itemAttributeFilters, String[] itemPropertyFilters, String[] shelvesetPropertyNameFilters, bool merge, Failure[]& failures, GetOperation[]& getOperations, Conflict[]& conflicts, Int32& flags);
    public void UpdateShelveset(string shelvesetName, string shelvesetOwner, Shelveset updatedShelveset);
    public void UpdateBranchObject(BranchProperties branchProperties, bool updateExisting);
    public void UpdateChangeset(int changeset, string comment, CheckinNote checkinNote);
    public void UpdateCheckinNoteFieldName(string path, string existingFieldName, string newFieldName);
    public PermissionChange[] UpdateGlobalSecurity(PermissionChange[] changes, Failure[]& failures);
    public virtual SecurityChange[] UpdateItemSecurity(string workspaceName, string workspaceOwner, SecurityChange[] changes, Failure[]& failures);
    public void UpdateLocalVersion(string workspaceName, string ownerName, LocalVersionUpdate[] updates);
    public void UpdateLocalVersion(string workspaceName, string ownerName, ServerItemLocalVersionUpdate[] updates);
    public void UpdateLocalVersion(string workspaceName, string ownerName, ILocalVersionUpdate[] updates);
    public virtual void UpdatePendingState(string workspaceName, string workspaceOwner, PendingState[] updates);
    public virtual Workspace UpdateWorkspace(string oldWorkspaceName, string ownerName, Workspace newWorkspace, int supportedFeatures);
    public virtual ServerSettings GetServerSettings();
    public virtual void SetServerSettings(ServerSettings settings);
    public PendingChange[] QueryServerPendingChanges(Workspace workspace);
    public abstract virtual PendingChange[] QueryServerPendingChanges(Workspace workspace, ItemSpec[] itemSpecs, bool generateDownloadUrls);
    public abstract virtual PendingChange[] QueryServerPendingChanges(Workspace localWorkspace, Guid& serverPendingChangeSignature);
    public abstract virtual Workspace QueryServerWorkspace(string workspaceName, string ownerName);
    public abstract virtual Workspace UpdateWorkspaceNoReconcile(string oldWorkspaceName, string ownerName, Workspace newWorkspace, int supportedFeatures);
    protected Workspace TryGetWorkspace(string workspaceName, string ownerName);
    protected Workspace TryGetServerWorkspace(string workspaceName, string ownerName);
    private void PlaybackQueuedEdits(string workspaceName, string ownerName);
    private void PlaybackQueuedEdits(string workspaceName, string ownerName, ChangeRequest[] changeRequests);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.WebServiceLayerLocalWorkspaces : WebServiceLayer {
    public WebServiceLayerLocalWorkspaces(VersionControlServer sourceControl);
    protected bool TryGetLocalWorkspace(string workspaceName, string ownerName, Workspace& localWorkspace);
    protected Workspace ReconcileIfLocalItem(string workspaceName, string ownerName, string item, bool unscannedReconcile);
    protected Workspace ReconcileIfLocalItem(string workspaceName, string ownerName, string item);
    protected Workspace ReconcileIfLocalItemSpec(string workspaceName, string ownerName, ItemSpec itemSpec, bool unscannedReconcile);
    protected Workspace ReconcileIfLocalItemSpec(string workspaceName, string ownerName, ItemSpec itemSpec);
    protected Workspace ReconcileIfAnyLocalItems(string workspaceName, string ownerName, IEnumerable`1<string> items);
    protected Workspace ReconcileIfAnyLocalItems(string workspaceName, string ownerName, IEnumerable`1<string> items, bool unscannedReconcile);
    protected Workspace ReconcileIfAnyLocalItemSpecs(string workspaceName, string ownerName, IEnumerable`1<ItemSpec> itemSpecs);
    protected Workspace ReconcileIfAnyLocalItemSpecs(string workspaceName, string ownerName, IEnumerable`1<ItemSpec> itemSpecs, bool unscannedReconcile);
    protected Workspace ReconcileIfLocalVersionSpec(VersionSpec versionSpec);
    protected Workspace ReconcileIfLocalVersionSpec(VersionSpec versionSpec, bool unscannedReconcile);
    protected Workspace ReconcileIfLocal(string workspaceName, string ownerName);
    protected Workspace ReconcileIfLocal(string workspaceName, string ownerName, Boolean& reconciled);
    protected Workspace ReconcileIfLocal(string workspaceName, string ownerName, bool unscannedReconcile, bool reconcileMissingLocalItems, bool skipIfAccessDenied, Boolean& reconciled);
    protected void SyncPendingChangesIfLocal(Workspace workspace);
    protected void SyncPendingChangesIfLocal(Workspace workspace, GetOperation[] getOperations);
    protected IDisposable LockIfLocal(Workspace workspace);
    public virtual PendingChange[] QueryServerPendingChanges(Workspace localWorkspace, Guid& serverPendingChangeSignature);
    public virtual PendingChange[] QueryServerPendingChanges(Workspace workspace, ItemSpec[] itemSpecs, bool generateDownloadUrls);
    public void SyncWorkingFoldersIfNecessary(Workspace localWorkspace, ChangePendedFlags flags);
    public virtual void AddConflict(string workspaceName, string ownerName, ConflictType conflictType, int itemId, int versionFrom, int pendingChangeId, string sourceLocalItem, string targetLocalItem, int reason);
    public virtual CheckinResult CheckIn(string workspaceName, string ownerName, String[] serverItems, Changeset info, CheckinNotificationInfo checkinNotificationInfo, int checkinOptions, UploadedBaselinesCollection uploadedBaselinesCollection, Failure[]& conflicts, Failure[]& failures, bool deferCheckIn, int checkInTicket);
    public virtual Failure[] CheckPendingChanges(string workspaceName, string ownerName, String[] serverItems);
    public virtual GetOperation[][] Get(string workspaceName, string ownerName, GetRequest[] requests, int maxResults, int options, String[] itemAttributeFilters, String[] itemPropertyFilters, bool noGet);
    public virtual LabelResult[] LabelItem(string workspaceName, string workspaceOwner, VersionControlLabel label, LabelItemSpec[] labelSpecs, LabelChildOption children, Failure[]& failures);
    public virtual GetOperation[] Merge(string workspaceName, string workspaceOwner, ItemSpec source, ItemSpec target, VersionSpec from, VersionSpec to, LockLevel lockLevel, int optionsEx, Failure[]& failures, Conflict[]& conflicts, String[] itemAttributeFilters, String[] itemPropertyFilters, Int32& flags);
    public virtual GetOperation[] PendChanges(string workspaceName, string ownerName, ChangeRequest[] changes, int pendChangesOptions, int supportedFeatures, Failure[]& failures, String[] itemAttributeFilters, String[] itemPropertyFilters, bool updateDisk, Boolean& onlineOperation, Int32& flags);
    public virtual BranchRelative[][] QueryBranches(string workspaceName, string workspaceOwner, ItemSpec[] items, VersionSpec version);
    public virtual Conflict[] QueryConflicts(string workspaceName, string ownerName, ItemSpec[] items);
    public virtual String[] QueryEffectiveItemPermissions(string workspaceName, string workspaceOwner, string item, string identityName);
    public virtual Changeset[] QueryHistory(string workspaceName, string workspaceOwner, ItemSpec itemSpec, VersionSpec versionItem, string user, VersionSpec versionFrom, VersionSpec versionTo, int maxCount, bool includeFiles, bool generateDownloadUrls, bool slotMode, bool sortAscending);
    public virtual ItemSet[] QueryItems(string workspaceName, string workspaceOwner, ItemSpec[] items, VersionSpec version, DeletedState deletedState, ItemType itemType, bool generateDownloadUrls, int options, String[] itemPropertyFilters, String[] itemAttributeFilters);
    public virtual ExtendedItem[][] QueryItemsExtended(string workspaceName, string workspaceOwner, ItemSpec[] items, DeletedState deletedState, ItemType itemType, int options, String[] itemPropertyFilters);
    private ExtendedItem[][] RemoveNonLocalExtendedItems(ExtendedItem[][] extendedItems);
    private bool IsNonLocal(ExtendedItem item);
    public virtual ItemSecurity[] QueryItemPermissions(string workspaceName, string workspaceOwner, ItemSpec[] itemSpecs, String[] identityNames, Failure[]& failures);
    public virtual VersionControlLabel[] QueryLabels(string workspaceName, string workspaceOwner, string labelName, string labelScope, string owner, string filterItem, VersionSpec versionFilterItem, bool includeItems, bool generateDownloadUrls);
    public virtual LocalVersion[][] QueryLocalVersions(string workspaceName, string workspaceOwner, ItemSpec[] itemSpecs);
    public virtual MergeCandidate[] QueryMergeCandidates(string workspaceName, string workspaceOwner, ItemSpec source, ItemSpec target, int options);
    public virtual ChangesetMerge[] QueryMerges(string workspaceName, string workspaceOwner, ItemSpec source, VersionSpec versionSource, ItemSpec target, VersionSpec versionTarget, VersionSpec versionFrom, VersionSpec versionTo, int maxChangesets, bool showAll, Changeset[]& changesets);
    public virtual ExtendedMerge[] QueryMergesExtended(string workspaceName, string workspaceOwner, ItemSpec target, VersionSpec versionTarget, VersionSpec versionFrom, VersionSpec versionTo, int options);
    public virtual ChangesetMergeDetails QueryMergesWithDetails(string workspaceName, string workspaceOwner, ItemSpec source, VersionSpec versionSource, ItemSpec target, VersionSpec versionTarget, VersionSpec versionFrom, VersionSpec versionTo, int maxChangesets, bool showAll);
    public virtual PendingChange[] QueryPendingChangesForWorkspace(string workspaceName, string workspaceOwner, ItemSpec[] itemSpecs, bool generateDownloadUrls, int pageSize, string lastChange, bool includeMergeInfo, Failure[]& failures, String[] itemPropertyFilters);
    public virtual PendingSet[] QueryPendingSets(string localWorkspaceName, string localWorkspaceOwner, string queryWorkspaceName, string ownerName, ItemSpec[] itemSpecs, bool generateDownloadUrls, Failure[]& failures, bool includeCandidates, String[] itemPropertyFilters);
    public virtual PendingSet[] QueryShelvedChanges(string localWorkspaceName, string localWorkspaceOwner, string shelvesetName, string ownerName, ItemSpec[] itemSpecs, bool generateDownloadUrls, Failure[]& failures, String[] itemPropertyFilters);
    public virtual Workspace QueryServerWorkspace(string workspaceName, string ownerName);
    public virtual Workspace QueryWorkspace(string workspaceName, string ownerName);
    public virtual WorkspaceItemSet[] QueryWorkspaceItems(string workspaceName, string workspaceOwner, ItemSpec[] items, DeletedState deletedState, ItemType itemType, bool generateDownloadUrls, int options);
    public virtual void RemoveLocalConflicts(string workspaceName, string ownerName, IEnumerable`1<Conflict> conflicts, ResolveErrorOptions errorOptions, OnResolvedConflict onResolvedConflict, OnResolveError onResolveError);
    public virtual void Resolve(string workspaceName, string ownerName, IEnumerable`1<Conflict> conflicts, String[] itemAttributeFilters, String[] itemPropertyFilters, ResolveErrorOptions errorOptions, OnResolvedConflict onResolvedConflict, OnResolveError onResolveError);
    public virtual GetOperation[] Rollback(string workspaceName, string workspaceOwner, ItemSpec[] items, VersionSpec itemVersion, VersionSpec from, VersionSpec to, int rollbackOptions, LockLevel lockLevel, Conflict[]& conflicts, Failure[]& failures, String[] itemAttributeFilters, String[] itemPropertyFilters, Int32& flags);
    public virtual Failure[] SetPendingChangeProperty(string workspaceName, string workspaceOwner, ArtifactPropertyValue[] pendingChangePropertyValues);
    public virtual void SetVersionedItemProperty(string workspaceName, string workspaceOwner, ItemSpec[] itemSpecs, VersionSpec versionSpec, DeletedState deletedState, ItemType itemType, PropertyValue[] propertyValues);
    public virtual Failure[] Shelve(string workspaceName, string workspaceOwner, String[] serverItems, Shelveset shelveset, bool replace);
    public virtual GetOperation[] UndoPendingChanges(string workspaceName, string ownerName, ItemSpec[] items, Failure[]& failures, String[] itemAttributeFilters, String[] itemPropertyFilters, Boolean& onlineOperation, bool deleteAdds, Int32& flags, bool checkForExistingItems);
    private bool TryMoveAddLocation(GetOperation conflictingAdd, Dictionary`2<string, GetOperation> localItemDictionary);
    public virtual LabelResult[] UnlabelItem(string workspaceName, string workspaceOwner, string labelName, string labelScope, ItemSpec[] items, VersionSpec version, Failure[]& failures);
    public virtual Shelveset Unshelve(string shelvesetName, string shelvesetOwner, string workspaceName, string workspaceOwner, ItemSpec[] items, String[] itemAttributeFilters, String[] itemPropertyFilters, String[] shelvesetPropertyNameFilters, bool merge, Failure[]& failures, GetOperation[]& getOperations, Conflict[]& conflicts, Int32& flags);
    public virtual SecurityChange[] UpdateItemSecurity(string workspaceName, string workspaceOwner, SecurityChange[] changes, Failure[]& failures);
    public virtual Workspace UpdateWorkspace(string oldWorkspaceName, string ownerName, Workspace newWorkspace, int supportedFeatures);
    public virtual Workspace UpdateWorkspaceNoReconcile(string oldWorkspaceName, string ownerName, Workspace newWorkspace, int supportedFeatures);
}
public enum Microsoft.TeamFoundation.VersionControl.Client.WebServiceLevel : Enum {
    public int value__;
    public static WebServiceLevel Unknown;
    public static WebServiceLevel PreTfs2010;
    public static WebServiceLevel Tfs2010;
    public static WebServiceLevel Tfs2012;
    public static WebServiceLevel Tfs2012_1;
    public static WebServiceLevel Tfs2012_2;
    public static WebServiceLevel Tfs2012_3;
    public static WebServiceLevel Tfs2012_QU1;
    public static WebServiceLevel Tfs2012_QU1_1;
    public static WebServiceLevel Tfs2013;
}
public class Microsoft.TeamFoundation.VersionControl.Client.WildcardNotAllowedException : VersionControlException {
    public WildcardNotAllowedException(string message);
    public WildcardNotAllowedException(string message, Exception ex);
    protected WildcardNotAllowedException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.WorkingFolder : Mapping {
    private string m_localItem;
    public static string DepthOneString;
    private static WorkingFolderComparer m_localItemComparer;
    private static WorkingFolderComparer m_serverItemComparer;
    public string LocalItem { get; }
    public bool IsCloaked { get; }
    public static IComparer LocalItemComparer { get; }
    public static IComparer ServerItemComparer { get; }
    public WorkingFolder(string serverItem, string localItem);
    public WorkingFolder(string serverItem, string localItem, WorkingFolderType type);
    public WorkingFolder(string serverItem, string localItem, WorkingFolderType type, RecursionType depth);
    private static WorkingFolder();
    public string get_LocalItem();
    [EditorBrowsableAttribute("1")]
public static WorkingFolder FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public virtual void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, WorkingFolder obj);
    public virtual int GetHashCode();
    public static bool op_Equality(WorkingFolder workingFolder1, WorkingFolder workingFolder2);
    public static bool op_Inequality(WorkingFolder workingFolder1, WorkingFolder workingFolder2);
    public virtual bool Equals(object obj);
    internal static String[] ExtractMappedPaths(WorkingFolder[] workingFolders);
    public bool get_IsCloaked();
    public static IComparer get_LocalItemComparer();
    public static IComparer get_ServerItemComparer();
    public static bool AreSetsEqual(WorkingFolder[] set1, WorkingFolder[] set2);
    public static IEnumerable`1<string> GetWorkspaceRoots(WorkingFolder[] folders);
    public sealed virtual object Clone();
    internal string TranslateServerItemToLocalItem(string serverItem);
    internal string TranslateLocalItemToServerItem(string localItem);
    internal static string TryGetServerItemForLocalItem(string localItem, WorkingFolder[] folders);
    internal static string TryGetServerItemForLocalItem(string localItem, WorkingFolder[] folders, bool detectImplicitCloak);
    internal static string TranslateLocalItemToServerItem(string localItem, WorkingFolder[] folders, Boolean& isCloaked, RecursionType& depth);
    internal static string TryGetLocalItemForServerItem(string serverItem, WorkingFolder[] folders);
    internal static string TryGetLocalItemForServerItem(string serverItem, WorkingFolder[] folders, bool detectImplicitCloak);
    internal static string TranslateServerItemToLocalItem(string serverItem, WorkingFolder[] folders, bool matchPattern, Boolean& isCloaked, RecursionType& depth);
    [EditorBrowsableAttribute("1")]
public static WorkingFolder TryGetMatchingWorkingFolderForLocalItem(string localItem, WorkingFolder[] folders, RecursionType& depth);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.WorkingFolderComparer : object {
    private Compare m_compare;
    internal WorkingFolderComparer(Compare compare);
    private sealed virtual override int System.Collections.IComparer.Compare(object x, object y);
}
public class Microsoft.TeamFoundation.VersionControl.Client.WorkingFolderCreationException : ServerItemException {
    public WorkingFolderCreationException(string message);
    public WorkingFolderCreationException(string message, Exception ex);
    protected WorkingFolderCreationException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.WorkingFolderException : ServerItemException {
    public WorkingFolderException(string message);
    public WorkingFolderException(string message, Exception ex);
    protected WorkingFolderException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.WorkingFolderInUseException : VersionControlException {
    public WorkingFolderInUseException(string message);
    public WorkingFolderInUseException(string message, Exception ex);
    protected WorkingFolderInUseException(SerializationInfo info, StreamingContext context);
}
public enum Microsoft.TeamFoundation.VersionControl.Client.WorkingFolderType : Enum {
    public int value__;
    public static WorkingFolderType Cloak;
    public static WorkingFolderType Map;
}
public class Microsoft.TeamFoundation.VersionControl.Client.WorkItemCheckedInfo : object {
    private int m_id;
    private bool m_checked;
    private WorkItemCheckinAction m_action;
    private static string m_xmlTagWorkItemCheckedInfo;
    private static string m_xmlTagWorkItem;
    private static string m_xmlTagAttrID;
    private static string m_xmlTagAttrChecked;
    private static string m_xmlTagAttrAction;
    public int Id { get; }
    public bool Checked { get; public set; }
    public WorkItemCheckinAction CheckinAction { get; public set; }
    [EditorBrowsableAttribute("1")]
public static string XmlTagWorkItemCheckedInfo { get; }
    public WorkItemCheckedInfo(int id, bool checkedOnOff, WorkItemCheckinAction action);
    internal static WorkItemCheckedInfo[] FromCheckinInfo(WorkItemCheckinInfo[] checkinInfo);
    internal static WorkItemCheckedInfo[] LoadFromXml(XmlDocument doc);
    [EditorBrowsableAttribute("1")]
public static WorkItemCheckedInfo[] LoadFromXml(XmlNode listRoot);
    [EditorBrowsableAttribute("1")]
public static void SaveAsXml(XmlNode parentNode, WorkItemCheckedInfo[] list);
    [EditorBrowsableAttribute("1")]
public WorkItemCheckedInfo Clone();
    public bool Equals(WorkItemCheckedInfo source);
    public int get_Id();
    public bool get_Checked();
    public void set_Checked(bool value);
    public WorkItemCheckinAction get_CheckinAction();
    public void set_CheckinAction(WorkItemCheckinAction value);
    public static string get_XmlTagWorkItemCheckedInfo();
}
public enum Microsoft.TeamFoundation.VersionControl.Client.WorkItemCheckinAction : Enum {
    public int value__;
    public static WorkItemCheckinAction None;
    public static WorkItemCheckinAction Resolve;
    public static WorkItemCheckinAction Associate;
}
public class Microsoft.TeamFoundation.VersionControl.Client.WorkItemCheckinInfo : object {
    private WorkItem m_workItem;
    private WorkItemCheckinAction m_checkinAction;
    public WorkItem WorkItem { get; public set; }
    public WorkItemCheckinAction CheckinAction { get; public set; }
    public WorkItemCheckinInfo(WorkItem workItem, WorkItemCheckinAction checkinAction);
    public static WorkItemCheckinInfo[] FromWorkItemCheckedInfo(WorkItemCheckedInfo[] checkedInfo, WorkItemStore workItemStore);
    public static WorkItemCheckinInfo[] FromWorkItemCheckedInfo(WorkItemCheckedInfo[] checkedInfo, WorkItemStore workItemStore, bool filterDestroyed);
    public WorkItem get_WorkItem();
    public void set_WorkItem(WorkItem value);
    public WorkItemCheckinAction get_CheckinAction();
    public void set_CheckinAction(WorkItemCheckinAction value);
}
[EditorBrowsableAttribute("1")]
public static class Microsoft.TeamFoundation.VersionControl.Client.WorkItemHelper : object {
    internal static string ResolvedByReferenceName;
    internal static string ClosedByReferenceName;
    public static string WorkItemCheckinAction_Checkin;
    private static WorkItemHelper();
    internal static CheckinNotificationWorkItemInfo[] GetWorkItemInfoForCheckin(WorkItemCheckinInfo[] workItems);
    internal static CheckinNotificationWorkItemInfo[] GetWorkItemInfoForCheckin(WorkItemCheckedInfo[] workItems);
    private static CheckinNotificationWorkItemInfo ConvertToCheckinNotification(int id, WorkItemCheckinAction checkinAction);
    internal static void UpdateWorkItems(Client client, Workspace workspace, Changeset changeset, WorkItemCheckinInfo[] workItems, string author);
    private static string BuildWorkItemBatchedErrorMessage(List`1<WorkItemErrorInfo> errors);
}
public class Microsoft.TeamFoundation.VersionControl.Client.WorkItemsUpdateEventArgs : EventArgs {
    private WorkItemCheckinInfo[] m_workItemInfo;
    private Workspace m_workspace;
    public WorkItemCheckinInfo[] WorkItemInfo { get; }
    public Workspace Workspace { get; }
    internal WorkItemsUpdateEventArgs(Workspace workspace, WorkItemCheckinInfo[] workItemInfo);
    public WorkItemCheckinInfo[] get_WorkItemInfo();
    public Workspace get_Workspace();
}
public class Microsoft.TeamFoundation.VersionControl.Client.WorkItemUpdatedEventArgs : EventArgs {
    private WorkItemCheckinInfo m_workItemInfo;
    private Workspace m_workspace;
    private bool m_successful;
    private string m_errorMessage;
    public WorkItemCheckinInfo WorkItemInfo { get; }
    public Workspace Workspace { get; }
    public bool Successful { get; }
    public string ErrorMessage { get; }
    internal WorkItemUpdatedEventArgs(Workspace workspace, WorkItemCheckinInfo workItemInfo);
    internal WorkItemUpdatedEventArgs(Workspace workspace, WorkItemCheckinInfo workItemInfo, string errorMessage);
    public WorkItemCheckinInfo get_WorkItemInfo();
    public Workspace get_Workspace();
    public bool get_Successful();
    public string get_ErrorMessage();
}
public class Microsoft.TeamFoundation.VersionControl.Client.WorkItemUpdatedEventHandler : MulticastDelegate {
    public WorkItemUpdatedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, WorkItemUpdatedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, WorkItemUpdatedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.TeamFoundation.VersionControl.Client.WorkItemUpdateException : VersionControlException {
    public WorkItemUpdateException(string message);
    public WorkItemUpdateException(string message, Exception innerException);
    public WorkItemUpdateException(Exception innerException);
    protected WorkItemUpdateException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.Workspace : object {
    private string m_comment;
    private string m_computer;
    private int m_effectivePermissions;
    internal WorkingFolder[] m_folders;
    private bool m_isLocalWorkspace;
    private DateTime m_lastAccessDate;
    private string m_name;
    private int m_options;
    internal String[] m_ownerAliases;
    private string m_ownerDisplayName;
    private string m_ownerIdentifier;
    private string m_ownerIdentityType;
    private string m_ownerName;
    private string m_ownerUniqueName;
    private string m_securityToken;
    private bool m_uncachedPropertiesStale;
    private bool m_workingFoldersStale;
    private VersionControlServer m_sourceControl;
    private WorkspaceWatcher m_workspaceWatcher;
    private OfflineCacheData m_offlineCacheData;
    private bool m_isDeleted;
    private object m_lock;
    private string m_conflictTempModifiedFileName;
    private static WorkspaceComparer m_repositoryComparer;
    internal WorkspacePermissionProfile m_permissionsProfile;
    private IdentityDescriptor m_ownerDescriptor;
    private static int s_uploadYieldCount;
    private static bool s_disableLocalItemExclusionsForPendAdd;
    public DateTime LastAccessDate { get; }
    public string OwnerIdentifier { get; public set; }
    public string OwnerIdentityType { get; public set; }
    public string Name { get; }
    public string Computer { get; }
    public string Comment { get; }
    public string OwnerName { get; }
    public WorkspaceLocation Location { get; }
    public WorkspaceOptions WorkspaceOptions { get; }
    public WorkingFolder[] Folders { get; }
    public WorkspacePermissionProfile PermissionsProfile { get; }
    public bool MappingsAvailable { get; }
    public string OwnerDisplayName { get; }
    public IEnumerable`1<string> OwnerAliases { get; }
    public WorkspacePermissions EffectivePermissions { get; }
    public bool IsScannerAsynchronous { get; public set; }
    public string SecurityToken { get; }
    public IdentityDescriptor OwnerDescriptor { get; }
    public SavedCheckin LastSavedCheckin { get; public set; }
    public bool IsLocal { get; }
    internal string LocalMetadataDirectory { get; }
    public VersionControlServer VersionControlServer { get; internal set; }
    private WebServiceLayer WebServiceLayer { get; }
    internal WorkspaceWatcher WorkspaceWatcher { get; }
    internal OfflineCacheData OfflineCacheData { get; }
    public string DisplayName { get; }
    public string QualifiedName { get; }
    public string DisambiguatedDisplayName { get; }
    public bool IsDeleted { get; internal set; }
    internal TraceSwitch ClientTracing { get; }
    internal Client Client { get; }
    public static IComparer RepositoryComparer { get; }
    public bool HasReadPermission { get; }
    public bool HasUsePermission { get; }
    public bool HasCheckInPermission { get; }
    public bool HasAdministerPermission { get; }
    private static Workspace();
    internal Workspace(VersionControlServer sourceControl, string name, string owner, string comment, WorkingFolder[] workingFolders, string computer, WorkspaceLocation location);
    internal Workspace(VersionControlServer sourceControl, string name, string owner, string ownerDisplayName, String[] ownerAliases, string comment, WorkingFolder[] workingFolders, string computer, WorkspaceLocation location, WorkspacePermissions effectivePermissions);
    internal Workspace(VersionControlServer sourceControl, string name, string owner, string ownerDisplayName, String[] ownerAliases, string comment, string securityToken, WorkingFolder[] workingFolders, string computer, WorkspaceLocation location, WorkspacePermissions effectivePermissions, WorkspacePermissionProfile permissionsProfile, WorkspaceOptions options);
    public DateTime get_LastAccessDate();
    public string get_OwnerIdentifier();
    public void set_OwnerIdentifier(string value);
    public string get_OwnerIdentityType();
    public void set_OwnerIdentityType(string value);
    [EditorBrowsableAttribute("1")]
public static Workspace FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, Workspace obj);
    public CheckinEvaluationResult EvaluateCheckin(CheckinEvaluationOptions options, PendingChange[] allChanges, PendingChange[] changes, string comment, CheckinNote checkinNote, WorkItemCheckinInfo[] workItemChanges);
    public int CheckIn(PendingChange[] changes, string comment);
    public int CheckIn(PendingChange[] changes, string comment, CheckinNote checkinNote, WorkItemCheckinInfo[] workItemChanges, PolicyOverrideInfo policyOverride);
    public int CheckIn(PendingChange[] changes, string author, string comment, CheckinNote checkinNote, WorkItemCheckinInfo[] workItemChanges, PolicyOverrideInfo policyOverride);
    public int CheckIn(PendingChange[] changes, string author, string comment, CheckinNote checkinNote, WorkItemCheckinInfo[] workItemChanges, PolicyOverrideInfo policyOverride, CheckinOptions checkinOptions);
    public CheckinEvaluationResult EvaluateCheckin2(CheckinEvaluationOptions options, IEnumerable`1<PendingChange> changes, string comment, CheckinNote checkinNote, WorkItemCheckinInfo[] workItemChanges);
    public CheckinEvaluationResult EvaluateCheckin2(CheckinEvaluationOptions options, IEnumerable`1<PendingChange> allChanges, IEnumerable`1<PendingChange> changes, string comment, CheckinNote checkinNote, WorkItemCheckinInfo[] workItemChanges);
    public int CheckIn(WorkspaceCheckInParameters checkinParameters);
    private int CheckInInternal(WorkspaceCheckInParameters parameters, int operationId);
    private CheckinResult PagedCheckin(IEnumerable`1<PendingChange> changes, bool changesIsAllPendingChanges, Changeset changeset, CheckinNotificationInfo checkinNotificationInfo, CheckInOptions2 checkinOptions, UploadedBaselinesCollection uploadedBaselinesCollection, Failure[]& conflictsArray, Failure[]& failuresArray);
    private static CheckInOptions2 CheckInOptions2FromCheckinOptions(CheckinOptions checkInOptions);
    public IEnumerable`1<WorkspaceDifference> Diff(ItemSpec[] itemSpecs);
    [IteratorStateMachineAttribute("Microsoft.TeamFoundation.VersionControl.Client.Workspace/<Diff>d__42")]
public IEnumerable`1<WorkspaceDifference> Diff(ItemSpec[] itemSpecs, String[] exclusions, WorkspaceDifferenceFlags flags);
    private ItemSpec[] ToLocalItemSpecs(ItemSpec[] itemSpecs);
    [IteratorStateMachineAttribute("Microsoft.TeamFoundation.VersionControl.Client.Workspace/<DiffItemSet>d__44")]
private IEnumerable`1<WorkspaceDifference> DiffItemSet(ItemSpec itemSpec, IEnumerable`1<IWorkspaceDiffItem> wsDiffItems, string queryPath, string queryPattern, String[] exclusions, WorkspaceDifferenceFlags flags);
    private WorkspaceDifference DiffItem(EnumeratedLocalItem fromDisk, string fullPath, IWorkspaceDiffItem wsItem, bool hashContent);
    [IteratorStateMachineAttribute("Microsoft.TeamFoundation.VersionControl.Client.Workspace/<ExtendWorkingFolders>d__46")]
private IEnumerable`1<WorkingFolder> ExtendWorkingFolders(IEnumerable`1<WorkingFolder> wfList);
    private IEnumerable`1<WorkingFolder> GetWorkingFoldersForItemSpec(ItemSpec itemSpec);
    [IteratorStateMachineAttribute("Microsoft.TeamFoundation.VersionControl.Client.Workspace/<GetWorkingFoldersForServerItemSpec>d__48")]
private IEnumerable`1<WorkingFolder> GetWorkingFoldersForServerItemSpec(ItemSpec itemSpec);
    [IteratorStateMachineAttribute("Microsoft.TeamFoundation.VersionControl.Client.Workspace/<GetWorkingFoldersForLocalItemSpec>d__49")]
private IEnumerable`1<WorkingFolder> GetWorkingFoldersForLocalItemSpec(ItemSpec itemSpec);
    private static WorkingFolder MinRecursionTypeToWorkingFolder(WorkingFolder wf, RecursionType recursion);
    private static RecursionType RecursionTypeMin(RecursionType r1, RecursionType r2);
    private IEnumerable`1<WorkspaceDiffItemSet> GetDiffItemSets(IEnumerable`1<ItemSpec> itemSpecs);
    [IteratorStateMachineAttribute("Microsoft.TeamFoundation.VersionControl.Client.Workspace/<GetTfs2012DiffItemSets>d__56")]
private IEnumerable`1<WorkspaceDiffItemSet> GetTfs2012DiffItemSets(IEnumerable`1<ItemSpec> itemSpecs);
    [IteratorStateMachineAttribute("Microsoft.TeamFoundation.VersionControl.Client.Workspace/<GetTfs2010DiffItemSets>d__57")]
private IEnumerable`1<WorkspaceDiffItemSet> GetTfs2010DiffItemSets(IEnumerable`1<ItemSpec> itemSpecs);
    public bool IsLocalPathMapped(string localPath);
    public string GetServerItemForLocalItem(string localItem);
    public string TryGetServerItemForLocalItem(string localItem);
    public string TryGetServerItemForLocalItem(string localItem, bool detectImplicitCloak);
    public WorkingFolder GetWorkingFolderForLocalItem(string localItem);
    public WorkingFolder TryGetWorkingFolderForLocalItem(string localItem);
    public static string TryGetServerItemForLocalItem(string localItem, WorkingFolder[] folders);
    public static string TryGetServerItemForLocalItem(string localItem, WorkingFolder[] folders, bool detectImplicitCloak);
    public bool IsServerPathMapped(string serverPath);
    public bool IsServerPathMapped(string serverPath, bool detectImplicitCloak);
    public string GetLocalItemForServerItem(string serverItem);
    public string GetLocalItemForServerItem(string serverItem, bool detectImplicitCloak);
    public string TryGetLocalItemForServerItem(string serverItem);
    public string TryGetLocalItemForServerItem(string serverItem, bool detectImplicitCloak);
    public WorkingFolder GetWorkingFolderForServerItem(string serverItem);
    public WorkingFolder TryGetWorkingFolderForServerItem(string serverItem);
    public static WorkingFolder GetWorkingFolderForServerItem(string serverItem, WorkingFolder[] folders);
    public static WorkingFolder TryGetWorkingFolderForServerItem(string serverItem, WorkingFolder[] folders);
    public static WorkingFolder TryGetWorkingFolderForServerItem(string serverItem, WorkingFolder[] folders, bool matchPattern);
    public bool Delete();
    public void Update(string newName, string newComment, WorkingFolder[] newMappings);
    public void Update(string newName, string newComment, WorkingFolder[] newMappings, bool removeUnparentedCloaks);
    public void Update(string newName, string newOwner, string newComment, WorkingFolder[] newMappings, bool removeUnparentedCloaks);
    public void Update(string newName, string newOwner, string newComment, string newComputer, WorkingFolder[] newMappings, WorkspacePermissionProfile newPermissionProfile, bool removeUnparentedCloaks);
    public void Update(UpdateWorkspaceParameters updateWorkspaceParameters);
    public void UpdateComputerName();
    public void Map(string serverPath, string localPath);
    public void Cloak(string serverPath);
    public void CreateMapping(WorkingFolder mapping);
    public void DeleteMapping(WorkingFolder mapping);
    public PendingChange[] GetPendingChanges();
    public IEnumerable`1<PendingChange> GetPendingChangesEnumerable();
    public PendingChange[] GetPendingChanges(string item);
    public IEnumerable`1<PendingChange> GetPendingChangesEnumerable(string item);
    public PendingChange[] GetPendingChanges(string item, RecursionType recursion);
    public IEnumerable`1<PendingChange> GetPendingChangesEnumerable(string item, RecursionType recursion);
    public PendingChange[] GetPendingChanges(string item, RecursionType recursion, bool includeDownloadInfo);
    public PendingChange[] GetPendingChanges(String[] items);
    public PendingChange[] GetPendingChanges(String[] items, RecursionType recursion);
    public PendingChange[] GetPendingChanges(String[] items, RecursionType recursion, bool includeDownloadInfo);
    public PendingChange[] GetPendingChanges(ItemSpec[] itemSpecs);
    public IEnumerable`1<PendingChange> GetPendingChangesEnumerable(ItemSpec[] itemSpecs);
    public PendingChange[] GetPendingChanges(ItemSpec[] itemSpecs, bool includeDownloadInfo);
    public PendingChange[] GetPendingChanges(ItemSpec[] itemSpecs, bool includeDownloadInfo, int pageSize, string lastChange);
    public PendingChange[] GetPendingChanges(ItemSpec[] itemSpecs, bool includeDownloadInfo, int pageSize, string lastChange, bool includeMergeSourceInfo);
    public PendingChange[] GetPendingChanges(ItemSpec[] itemSpecs, bool includeDownloadInfo, int pageSize, string lastChange, bool includeMergeSourceInfo, String[] itemPropertyFilters);
    public PendingChange[] GetPendingChangesWithCandidates(ItemSpec[] itemSpecs, bool includeDownloadInfo, PendingChange[]& candidateChanges);
    public PendingChange[] GetPendingChangesWithCandidates(ItemSpec[] itemSpecs, bool includeDownloadInfo, String[] itemPropertyFilters, PendingChange[]& candidateChanges);
    public PendingSet[] QueryPendingSets(String[] items, RecursionType recursion, string queryWorkspaceName, string queryUserName, bool includeDownloadInfo);
    public PendingSet[] QueryPendingSets(String[] items, RecursionType recursion, string queryWorkspaceName, string queryUserName, bool includeDownloadInfo, String[] itemPropertyFilters);
    public PendingSet[] QueryPendingSets(ItemSpec[] itemSpecs, string queryWorkspaceName, string queryUserName, bool includeDownloadInfo);
    public PendingSet[] QueryPendingSets(ItemSpec[] itemSpecs, string queryWorkspaceName, string queryUserName, bool includeDownloadInfo, String[] itemPropertyFilters);
    public ExtendedItem[][] GetExtendedItems(ItemSpec[] itemSpecs, DeletedState deletedState, ItemType itemType);
    public ExtendedItem[][] GetExtendedItems(ItemSpec[] itemSpecs, DeletedState deletedState, ItemType itemType, GetItemsOptions getItemsOptions);
    public ExtendedItem[][] GetExtendedItems(ItemSpec[] itemSpecs, DeletedState deletedState, ItemType itemType, GetItemsOptions getItemsOptions, String[] itemPropertyFilters);
    public WorkspaceItemSet[] GetItems(ItemSpec[] itemSpecs, DeletedState deletedState, ItemType itemType, bool generateDownloadUrls, GetItemsOptions getItemsOptions);
    public Conflict[] QueryConflicts(String[] pathFilters, bool recursive);
    [EditorBrowsableAttribute("1")]
public Conflict[] QueryConflictsNoSorting(String[] pathFilters, bool recursive);
    public void ResolveConflict(Conflict conflict);
    public void ResolveConflict(Conflict conflict, Conflict[]& resolvedConflicts);
    public void ResolveConflict(Conflict conflict, Conflict[]& resolvedConflicts, String[] itemAttributeFilters);
    public void ResolveConflict(Conflict conflict, Conflict[]& resolvedConflicts, String[] itemAttributeFilters, String[] itemPropertyFilters);
    public void ResolveConflicts(IEnumerable`1<Conflict> conflicts, String[] itemAttributeFilters, Conflict[]& resolvedConflicts);
    public void ResolveConflicts(IEnumerable`1<Conflict> conflicts, String[] itemAttributeFilters, String[] itemPropertyFilters, Conflict[]& resolvedConflicts);
    internal void ResolveConflicts(IEnumerable`1<Conflict> conflicts, String[] itemAttributeFilters, String[] itemPropertyFilters, ResolveErrorOptions errorOptions, Conflict[]& resolvedConflicts);
    private void ResolveConflictsInternal(IEnumerable`1<Conflict> conflicts, String[] itemAttributeFilters, String[] itemPropertyFilters, ResolveErrorOptions errorOptions, Conflict[]& resolvedConflicts, int operationId);
    public void AutoResolveValidConflicts(IEnumerable`1<Conflict> conflicts, AutoResolveOptions resolveOptions);
    public GetStatus Rollback(VersionSpec versionFrom, VersionSpec versionTo, LockLevel lockLevel, RollbackOptions options);
    public GetStatus Rollback(String[] paths, RecursionType recursion, VersionSpec itemSpecVersion, VersionSpec versionFrom, VersionSpec versionTo, LockLevel lockLevel, RollbackOptions options, String[] itemAttributeFilters);
    public GetStatus Rollback(String[] paths, RecursionType recursion, VersionSpec itemSpecVersion, VersionSpec versionFrom, VersionSpec versionTo, LockLevel lockLevel, RollbackOptions options, String[] itemAttributeFilters, String[] itemPropertyFilters);
    public void Shelve(Shelveset shelveset, PendingChange[] changes, ShelvingOptions options);
    private void ShelveInternal(Shelveset shelveset, PendingChange[] changes, ShelvingOptions options, int operationId);
    [EditorBrowsableAttribute("1")]
public SavedCheckin BuildEmptyLastSavedCheckin();
    public Shelveset Unshelve(string shelvesetName, string shelvesetOwner);
    public Shelveset Unshelve(string shelvesetName, string shelvesetOwner, ItemSpec[] items);
    public Shelveset Unshelve(string shelvesetName, string shelvesetOwner, ItemSpec[] items, PendingChange[]& changes);
    public Shelveset Unshelve(string shelvesetName, string shelvesetOwner, ItemSpec[] items, PendingChange[]& changes, String[] itemAttributeFilters);
    public Shelveset Unshelve(string shelvesetName, string shelvesetOwner, ItemSpec[] items, String[] itemAttributeFilters, String[] itemPropertyFilters, String[] shelvesetPropertyNameFilters, bool merge, bool noAutoResolve, PendingChange[]& changes, Conflict[]& conflicts);
    public PendingSet[] QueryShelvedChanges(string shelvesetName, string shelvesetOwner, ItemSpec[] itemSpecs);
    public PendingSet[] QueryShelvedChanges(string shelvesetName, string shelvesetOwner, ItemSpec[] itemSpecs, bool includeDownloadInfo);
    public PendingSet[] QueryShelvedChanges(string shelvesetName, string shelvesetOwner, ItemSpec[] itemSpecs, bool includeDownloadInfo, String[] itemPropertyFilters);
    public void QueueForEdit(string localItem);
    public void UnqueueForEdit(string localItem);
    public void UpdateLastSavedCheckin(Shelveset shelveset);
    public void UpdateLastSavedCheckin(Shelveset shelveset, PendingChange[] unshelvedChanges);
    public int PendAdd(string path);
    public int PendAdd(string path, bool isRecursive);
    public int PendAdd(String[] paths);
    public int PendAdd(String[] paths, bool isRecursive);
    public int PendAdd(String[] paths, bool isRecursive, string fileType, LockLevel lockLevel);
    public int PendAdd(String[] paths, bool isRecursive, string fileType, LockLevel lockLevel, bool treatMissingItemsAsFiles);
    public int PendAdd(String[] paths, bool isRecursive, string fileType, LockLevel lockLevel, bool treatMissingItemsAsFiles, bool silent);
    public int PendAdd(String[] paths, bool isRecursive, string fileType, LockLevel lockLevel, bool treatMissingItemsAsFiles, bool silent, bool applyLocalItemExclusions);
    private void PendAdds(ChangeRequest[] changeRequests, AsyncPendAddOperation asyncOp, bool silent);
    public int PendDelete(string path);
    public int PendDelete(string path, RecursionType recursion);
    public int PendDelete(String[] paths);
    public int PendDelete(String[] paths, RecursionType recursion);
    public int PendDelete(String[] paths, RecursionType recursion, LockLevel lockLevel);
    public int PendDelete(String[] paths, RecursionType recursion, LockLevel lockLevel, bool updateDisk);
    public int PendDelete(String[] paths, RecursionType recursion, LockLevel lockLevel, bool updateDisk, bool silent);
    public int PendDelete(String[] paths, RecursionType recursion, LockLevel lockLevel, bool updateDisk, bool silent, String[] itemAttributeFilters);
    public int PendDelete(String[] paths, RecursionType recursion, LockLevel lockLevel, bool updateDisk, bool silent, String[] itemAttributeFilters, String[] itemPropertyFilters);
    public int PendUndelete(string path, int deletionId, string newPath);
    public int PendUndelete(string path, int deletionId, string newPath, LockLevel lockLevel, bool updateDisk);
    public int PendUndelete(string path, int deletionId, string newPath, LockLevel lockLevel, bool updateDisk, bool detectFolderAtTarget);
    public int PendUndelete(string path, int deletionId, string newPath, LockLevel lockLevel, bool updateDisk, bool detectFolderAtTarget, bool silent);
    public int PendUndelete(string path, int deletionId, string newPath, LockLevel lockLevel, bool updateDisk, bool detectFolderAtTarget, bool silent, String[] itemAttributeFilters);
    public int PendUndelete(string path, int deletionId, string newPath, LockLevel lockLevel, bool updateDisk, bool detectFolderAtTarget, bool silent, String[] itemAttributeFilters, String[] itemPropertyFilters);
    public int PendUndelete(string path, int deletionId);
    public int PendUndelete(ItemSpec[] itemSpecs, LockLevel lockLevel, bool updateDisk);
    public int PendUndelete(ItemSpec[] itemSpecs, LockLevel lockLevel, bool updateDisk, bool detectFolderAtTarget);
    public int PendUndelete(ItemSpec[] itemSpecs, LockLevel lockLevel, bool updateDisk, bool detectFolderAtTarget, bool silent);
    public int PendEdit(string path);
    public int PendEdit(string path, RecursionType recursion);
    public int PendEdit(String[] paths);
    public int PendEdit(String[] paths, RecursionType recursion);
    public int PendEdit(String[] paths, RecursionType recursion, string fileType, LockLevel lockLevel);
    public int PendEdit(String[] paths, RecursionType recursion, string fileType, LockLevel lockLevel, bool silent);
    public int PendEdit(String[] paths, RecursionType recursion, string fileType, LockLevel lockLevel, bool silent, PendChangesOptions options);
    public int PendEdit(String[] paths, RecursionType recursion, string fileType, LockLevel lockLevel, bool silent, PendChangesOptions options, String[] itemAttributeFilters);
    public int PendEdit(String[] paths, RecursionType recursion, string fileType, LockLevel lockLevel, bool silent, PendChangesOptions options, String[] itemAttributeFilters, String[] itemPropertyFilters);
    public int PendPropertyChange(string path, PropertyValue property);
    public int PendPropertyChange(string path, PropertyValue property, RecursionType recursion, LockLevel lockLevel);
    public int PendPropertyChange(string path, PropertyValue[] properties, RecursionType recursion, LockLevel lockLevel);
    public int PendPropertyChange(String[] paths, PropertyValue property, RecursionType recursion, LockLevel lockLevel);
    public int PendPropertyChange(String[] paths, PropertyValue[] properties, RecursionType recursion, LockLevel lockLevel, PendChangesOptions options, String[] itemAttributeFilters, String[] itemPropertyFilters);
    public int PendPropertyChange(ItemProperties[] specs, RecursionType recursion, LockLevel lockLevel, PendChangesOptions options, String[] itemAttributeFilters, String[] itemPropertyFilters);
    public int PendRename(string oldPath, string newPath);
    public int PendRename(string oldPath, string newPath, LockLevel lockLevel, bool updateDisk, bool detectFolderAtTarget);
    public int PendRename(string oldPath, string newPath, LockLevel lockLevel, bool updateDisk, bool detectFolderAtTarget, bool silent);
    public int PendRename(string oldPath, string newPath, LockLevel lockLevel, bool updateDisk, bool detectFolderAtTarget, bool silent, String[] itemAttributeFilters);
    public int PendRename(string oldPath, string newPath, LockLevel lockLevel, bool updateDisk, bool detectFolderAtTarget, PendChangesOptions options, String[] itemAttributeFilters);
    public int PendRename(string oldPath, string newPath, LockLevel lockLevel, bool updateDisk, bool detectFolderAtTarget, PendChangesOptions options, String[] itemAttributeFilters, String[] itemPropertyFilters);
    public int PendBranch(string sourcePath, string targetPath, VersionSpec version);
    public int PendBranch(string sourcePath, string targetPath, VersionSpec version, LockLevel lockLevel, bool updateDisk);
    public int PendBranch(string sourcePath, string targetPath, VersionSpec version, LockLevel lockLevel, bool updateDisk, bool detectFolderAtTarget);
    public int PendBranch(string sourcePath, string targetPath, VersionSpec version, LockLevel lockLevel, bool updateDisk, bool detectFolderAtTarget, bool silent);
    public int PendBranch(string sourcePath, string targetPath, VersionSpec version, LockLevel lockLevel, bool updateDisk, bool detectFolderAtTarget, bool silent, String[] itemPropertyFilters);
    private int PendChanges(ChangeRequest[] changeRequests, bool updateDisk, PendChangesOptions options, String[] itemAttributeFilters, String[] itemPropertyFilters);
    public GetStatus Merge(string sourcePath, string targetPath, VersionSpec versionFrom, VersionSpec versionTo);
    public GetStatus Merge(string sourcePath, string targetPath, VersionSpec versionFrom, VersionSpec versionTo, LockLevel lockLevel, RecursionType recursion, MergeOptions mergeOptions);
    public GetStatus Merge(string sourcePath, string targetPath, VersionSpec versionFrom, VersionSpec versionTo, LockLevel lockLevel, RecursionType recursion, MergeOptionsEx mergeOptions);
    public GetStatus Merge(ItemSpec source, string targetPath, VersionSpec versionFrom, VersionSpec versionTo, LockLevel lockLevel, MergeOptionsEx mergeOptions);
    public GetStatus Merge(ItemSpec source, string targetPath, VersionSpec versionFrom, VersionSpec versionTo, LockLevel lockLevel, MergeOptionsEx mergeOptions, String[] itemAttributeFilters);
    public GetStatus Merge(ItemSpec source, string targetPath, VersionSpec versionFrom, VersionSpec versionTo, LockLevel lockLevel, MergeOptionsEx mergeOptions, String[] itemAttributeFilters, String[] itemPropertyFilters);
    private MergeOptionsEx ConvertToNewOptions(MergeOptions options);
    public int Undo(string item);
    public int Undo(string item, RecursionType recursion);
    public int Undo(String[] items);
    public int Undo(String[] items, bool updateDisk);
    public int Undo(String[] items, RecursionType recursion);
    public int Undo(String[] items, RecursionType recursion, bool updateDisk);
    public int Undo(PendingChange[] pendingChanges);
    public int Undo(ItemSpec[] itemSpecs);
    public int Undo(ItemSpec[] itemSpecs, bool updateDisk);
    public int Undo(ItemSpec[] itemSpecs, bool updateDisk, String[] itemAttributeFilters);
    public int Undo(ItemSpec[] itemSpecs, bool updateDisk, String[] itemAttributeFilters, String[] itemPropertyFilters);
    public int Undo(ItemSpec[] itemSpecs, bool updateDisk, bool deleteAdds, String[] itemAttributeFilters, String[] itemPropertyFilters);
    public int SetLock(string path, LockLevel lockLevel);
    public int SetLock(string path, LockLevel lockLevel, RecursionType recursion);
    public int SetLock(String[] paths, LockLevel lockLevel);
    public int SetLock(String[] paths, LockLevel lockLevel, RecursionType recursion);
    public int SetLock(String[] paths, LockLevel lockLevel, RecursionType recursion, bool silent);
    public int SetLock(String[] paths, LockLevel lockLevel, RecursionType recursion, bool silent, String[] itemAttributeFilters);
    public int SetLock(String[] paths, LockLevel lockLevel, RecursionType recursion, bool silent, String[] itemAttributeFilters, String[] itemPropertyFilters);
    public LocalVersion[][] GetLocalVersions(ItemSpec[] itemSpecs, bool sortData);
    [ObsoleteAttribute("SetPendingChangeAttribute is no longer supported starting with TFS 2015.", "False")]
public void SetPendingChangeAttribute(List`1<ArtifactPropertyValue> pendingChangePropertyValues);
    public void AddIgnoreFileExclusion(string fileSpecToExclude, string ignoreFileDirectory);
    public GetStatus Get();
    public GetStatus Get(VersionSpec version, GetOptions options);
    public GetStatus Get(String[] items, VersionSpec version, RecursionType recursion, GetOptions options);
    public GetStatus Get(GetRequest request, GetOptions options);
    public GetStatus Get(GetRequest[] requests, GetOptions options);
    public GetStatus Get(GetRequest request, GetOptions options, GetFilterCallback filterCallback, object userData);
    public GetStatus Get(GetRequest[] requests, GetOptions options, GetFilterCallback filterCallback, object userData);
    public GetStatus Get(GetRequest[] requests, GetOptions options, GetFilterCallback filterCallback, object userData, String[] itemAttributeFilters);
    public GetStatus Get(GetRequest[] requests, GetOptions options, GetFilterCallback filterCallback, object userData, String[] itemAttributeFilters, Conflict[]& conflicts);
    public GetStatus Get(GetRequest[] requests, GetOptions options, GetFilterCallback filterCallback, object userData, String[] itemAttributeFilters, String[] itemPropertyFilters, Conflict[]& conflicts);
    private GetStatus Get(GetRequest[] requests, GetOptions options, GetFilterCallback filterCallback, object userData, String[] itemAttributeFilters, String[] itemPropertyFilters, bool alwaysQueryConflicts, Conflict[]& conflicts);
    private void DebugFilterCallback(Workspace workspace, ILocalUpdateOperation[] operations, object userData);
    internal void AddConflict(ConflictType conflictType, int itemId, int versionServer, int pendingChangeId, string sourceLocalItem, string targetLocalItem, int reason);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(Workspace x, Workspace y);
    public sealed virtual int GetHashCode(Workspace obj);
    public string get_Name();
    public string get_Computer();
    public string get_Comment();
    public string get_OwnerName();
    public WorkspaceLocation get_Location();
    public WorkspaceOptions get_WorkspaceOptions();
    public WorkingFolder[] get_Folders();
    public WorkspacePermissionProfile get_PermissionsProfile();
    public static bool MatchName(string workspaceName1, string workspaceName2);
    public static bool MatchOwnerName(string workspaceOwnerName1, string workspaceOwnerName2);
    public bool OwnerNameMatches(string ownerName);
    public void Reconcile(bool reconcileMissingLocalItems, Boolean& pendingChangesUpdatedByServer);
    [ObsoleteAttribute("This method has been deprecated. Please use the Refresh() method instead.", "False")]
public void RefreshMappings();
    public void Refresh();
    public void RefreshIfNeeded();
    public bool get_MappingsAvailable();
    private void RefreshMappingsIfNeeded();
    internal void UpdateFromWorkspace(Workspace updateSource);
    [EditorBrowsableAttribute("1")]
public void MarkPathChanged(string path);
    internal void UpdateLocationFromWorkspaceInfo(WorkspaceInfo wsInfo);
    internal WorkspaceLock Lock();
    public void RemoveLocalConflict(Conflict conflict);
    public void RemoveLocalConflicts(IEnumerable`1<Conflict> conflicts);
    private void RemoveLocalConflicts(IEnumerable`1<Conflict> conflicts, ResolveErrorOptions errorOptions);
    public bool MergeContent(Conflict conflict, bool useExternalMergeTool);
    [EditorBrowsableAttribute("1")]
public IToolExecutionResult BeginExternalMergeContent(Conflict conflict, ThreeWayMerge threeWayMerge);
    [EditorBrowsableAttribute("1")]
public bool EndExternalMergeContent(IToolExecutionResult toolResult, Conflict conflict, ThreeWayMerge threeWayMerge);
    internal IToolExecutionResult BeginExternalAutomergeContent(Conflict conflict, ThreeWayMerge threeWayMerge);
    internal bool EndExternalAutomergeContent(IToolExecutionResult toolResult, Conflict conflict, ThreeWayMerge threeWayMerge);
    private bool InternalMergeContent(Conflict conflict);
    private bool PreMerge(Conflict conflict, ThreeWayMerge threeWayMerge);
    private IEnumerable`1<PendingChange> EnsureUploadHashValuesCurrent(IEnumerable`1<PendingChange> changes);
    private void UploadChanges(IEnumerable`1<PendingChange> changes, bool saveUploadedContentAsBaselines, UploadedBaselinesCollection& uploadedBaselinesCollection, OnProcessingChangeDelegate onPendingMethod, int operationId);
    internal static WorkingFolder[] CheckForInternalMappingConflicts(string workspaceName, WorkingFolder[] folders, bool removeUnparentedCloaks);
    public string FormatWorkspaceNameForException(Workspace conflictingWorkspace);
    public TeamProject GetTeamProjectForLocalPath(string localPath);
    public TeamProject[] GetTeamProjectsForLocalPaths(String[] localPaths);
    [EditorBrowsableAttribute("1")]
public void Invalidate();
    internal void InvalidateMappings();
    internal void RequireLocal();
    internal void ThrowIfDeleted();
    private void AfterDeserialize();
    public string get_OwnerDisplayName();
    public IEnumerable`1<string> get_OwnerAliases();
    public WorkspacePermissions get_EffectivePermissions();
    public bool get_IsScannerAsynchronous();
    public void set_IsScannerAsynchronous(bool value);
    public string get_SecurityToken();
    public IdentityDescriptor get_OwnerDescriptor();
    private void RefreshPermissionsProfile();
    public SavedCheckin get_LastSavedCheckin();
    public void set_LastSavedCheckin(SavedCheckin value);
    public bool get_IsLocal();
    internal string get_LocalMetadataDirectory();
    internal string GetWorkspaceDirectory(string basePath);
    public VersionControlServer get_VersionControlServer();
    internal void set_VersionControlServer(VersionControlServer value);
    private WebServiceLayer get_WebServiceLayer();
    internal WorkspaceWatcher get_WorkspaceWatcher();
    internal OfflineCacheData get_OfflineCacheData();
    public string get_DisplayName();
    public string get_QualifiedName();
    public string get_DisambiguatedDisplayName();
    public bool get_IsDeleted();
    internal void set_IsDeleted(bool value);
    internal TraceSwitch get_ClientTracing();
    internal Client get_Client();
    public static IComparer get_RepositoryComparer();
    public bool get_HasReadPermission();
    public bool get_HasUsePermission();
    public bool get_HasCheckInPermission();
    public bool get_HasAdministerPermission();
    public bool HasWorkspacePermission(WorkspacePermissions toCheck);
}
public class Microsoft.TeamFoundation.VersionControl.Client.WorkspaceCancelEventArgs : WorkspaceEventArgs {
    private bool m_cancel;
    public bool Cancel { get; public set; }
    public WorkspaceCancelEventArgs(Workspace workspace);
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
public class Microsoft.TeamFoundation.VersionControl.Client.WorkspaceCancelEventHandler : MulticastDelegate {
    public WorkspaceCancelEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, WorkspaceCancelEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, WorkspaceCancelEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.TeamFoundation.VersionControl.Client.WorkspaceCheckInParameters : CheckInParameters {
    [CompilerGeneratedAttribute]
private IEnumerable`1<PendingChange> <PendingChanges>k__BackingField;
    [CompilerGeneratedAttribute]
private ItemSpec[] <ItemSpecs>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Comment>k__BackingField;
    [CompilerGeneratedAttribute]
private CheckinNote <CheckinNotes>k__BackingField;
    [CompilerGeneratedAttribute]
private WorkItemCheckinInfo[] <AssociatedWorkItems>k__BackingField;
    [CompilerGeneratedAttribute]
private PolicyOverrideInfo <PolicyOverride>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <CheckinDate>k__BackingField;
    public IEnumerable`1<PendingChange> PendingChanges { get; private set; }
    public ItemSpec[] ItemSpecs { get; private set; }
    public string Comment { get; public set; }
    public CheckinNote CheckinNotes { get; public set; }
    public WorkItemCheckinInfo[] AssociatedWorkItems { get; public set; }
    public PolicyOverrideInfo PolicyOverride { get; public set; }
    public DateTime CheckinDate { get; public set; }
    public bool NoConflictsCheckForGatedCheckin { get; public set; }
    private WorkspaceCheckInParameters(string comment);
    public WorkspaceCheckInParameters(IEnumerable`1<PendingChange> pendingChanges, string comment);
    public WorkspaceCheckInParameters(ItemSpec[] itemSpecs, string comment);
    [CompilerGeneratedAttribute]
public IEnumerable`1<PendingChange> get_PendingChanges();
    [CompilerGeneratedAttribute]
private void set_PendingChanges(IEnumerable`1<PendingChange> value);
    [CompilerGeneratedAttribute]
public ItemSpec[] get_ItemSpecs();
    [CompilerGeneratedAttribute]
private void set_ItemSpecs(ItemSpec[] value);
    [CompilerGeneratedAttribute]
public string get_Comment();
    [CompilerGeneratedAttribute]
public void set_Comment(string value);
    [CompilerGeneratedAttribute]
public CheckinNote get_CheckinNotes();
    [CompilerGeneratedAttribute]
public void set_CheckinNotes(CheckinNote value);
    [CompilerGeneratedAttribute]
public WorkItemCheckinInfo[] get_AssociatedWorkItems();
    [CompilerGeneratedAttribute]
public void set_AssociatedWorkItems(WorkItemCheckinInfo[] value);
    [CompilerGeneratedAttribute]
public PolicyOverrideInfo get_PolicyOverride();
    [CompilerGeneratedAttribute]
public void set_PolicyOverride(PolicyOverrideInfo value);
    [CompilerGeneratedAttribute]
public DateTime get_CheckinDate();
    [CompilerGeneratedAttribute]
public void set_CheckinDate(DateTime value);
    public bool get_NoConflictsCheckForGatedCheckin();
    public void set_NoConflictsCheckForGatedCheckin(bool value);
    internal virtual void Validate();
}
internal class Microsoft.TeamFoundation.VersionControl.Client.WorkspaceComparer : object {
    private sealed virtual override int System.Collections.IComparer.Compare(object x, object y);
}
public class Microsoft.TeamFoundation.VersionControl.Client.WorkspaceCreationException : WorkspaceException {
    public WorkspaceCreationException(string message);
    public WorkspaceCreationException(string message, Exception ex);
    protected WorkspaceCreationException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.WorkspaceDeletedException : VersionControlException {
    private Workspace m_workspace;
    public Workspace Workspace { get; }
    public WorkspaceDeletedException(Workspace workspace);
    public Workspace get_Workspace();
}
public class Microsoft.TeamFoundation.VersionControl.Client.WorkspaceDeletionException : WorkspaceException {
    public WorkspaceDeletionException(string message);
    public WorkspaceDeletionException(string message, Exception ex);
    protected WorkspaceDeletionException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.WorkspaceDifference : object {
    public WorkspaceDifferenceType DifferenceType;
    public string LocalItem;
    public int VersionLocal;
    public ItemType ItemType;
    public ChangeType RecursiveChangeType;
    public WorkspaceDifferenceModifiedReason ModifiedReason;
    internal WorkspaceDifference(WorkspaceDifferenceType diffType, string localItem, int versionLocal, ItemType itemType, ChangeType recursiveChangeType, WorkspaceDifferenceModifiedReason modifiedReason);
}
[FlagsAttribute]
public enum Microsoft.TeamFoundation.VersionControl.Client.WorkspaceDifferenceFlags : Enum {
    public int value__;
    public static WorkspaceDifferenceFlags None;
    public static WorkspaceDifferenceFlags HashContent;
    public static WorkspaceDifferenceFlags EnumerateUnmapped;
    public static WorkspaceDifferenceFlags NoIgnore;
    public static WorkspaceDifferenceFlags EnumerateHiddenAndSystem;
}
public enum Microsoft.TeamFoundation.VersionControl.Client.WorkspaceDifferenceModifiedReason : Enum {
    public int value__;
    public static WorkspaceDifferenceModifiedReason NotApplicable;
    public static WorkspaceDifferenceModifiedReason HashValue;
    public static WorkspaceDifferenceModifiedReason ReadOnlyBit;
    public static WorkspaceDifferenceModifiedReason TypeChange;
    public static WorkspaceDifferenceModifiedReason FileLength;
}
public enum Microsoft.TeamFoundation.VersionControl.Client.WorkspaceDifferenceType : Enum {
    public int value__;
    public static WorkspaceDifferenceType New;
    public static WorkspaceDifferenceType Modified;
    public static WorkspaceDifferenceType Missing;
}
public class Microsoft.TeamFoundation.VersionControl.Client.WorkspaceEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private int <Flags>k__BackingField;
    private Workspace m_workspace;
    private WorkspaceEventSource m_eventSource;
    public Workspace Workspace { get; }
    public WorkspaceEventSource EventSource { get; }
    public int Flags { get; public set; }
    public WorkspaceEventArgs(Workspace workspace);
    public WorkspaceEventArgs(Workspace workspace, WorkspaceEventSource eventSource);
    public Workspace get_Workspace();
    public WorkspaceEventSource get_EventSource();
    [CompilerGeneratedAttribute]
public int get_Flags();
    [CompilerGeneratedAttribute]
public void set_Flags(int value);
}
public class Microsoft.TeamFoundation.VersionControl.Client.WorkspaceEventHandler : MulticastDelegate {
    public WorkspaceEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, WorkspaceEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, WorkspaceEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum Microsoft.TeamFoundation.VersionControl.Client.WorkspaceEventSource : Enum {
    public int value__;
    public static WorkspaceEventSource Internal;
    public static WorkspaceEventSource External;
    public static WorkspaceEventSource ExternalScanned;
}
public class Microsoft.TeamFoundation.VersionControl.Client.WorkspaceException : VersionControlException {
    public WorkspaceException(string message);
    public WorkspaceException(string message, Exception ex);
    protected WorkspaceException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.WorkspaceExistsException : WorkspaceException {
    public WorkspaceExistsException(string message);
    public WorkspaceExistsException(string message, Exception ex);
    protected WorkspaceExistsException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.WorkspaceInfo : object {
    private Guid m_serverGuid;
    private Uri m_serverUri;
    private string m_name;
    private string m_ownerName;
    private string m_ownerDisplayName;
    private String[] m_ownerAliases;
    private string m_computer;
    private string m_comment;
    private bool m_isLocalWorkspace;
    private string m_securityToken;
    private String[] m_mappedPaths;
    private WorkspaceOptions m_options;
    private SavedCheckin m_lastSavedCheckin;
    private DateTime m_lastSavedCheckinTimeStamp;
    private static string m_xmlWorkspaceInfo;
    private static string m_xmlName;
    private static string m_xmlOwnerName;
    private static string m_xmlOwnerDisplayName;
    private static string m_xmlOwnerAliases;
    private static string m_xmlOwnerAlias;
    private static string m_xmlComputer;
    private static string m_xmlComment;
    private static string m_xmlIsLocalWorkspace;
    private static string m_xmlMappedPaths;
    private static string m_xmlMappedPath;
    private static string m_xmlPath;
    private static string m_xmlSecurityToken;
    private static string m_xmlLastSavedCheckin;
    private static string m_xmlLastSavedCheckinTimeStamp;
    private static string m_optionsName;
    public Uri ServerUri { get; }
    public Guid ServerGuid { get; }
    public string Name { get; }
    public string OwnerName { get; }
    public string OwnerDisplayName { get; }
    public IEnumerable`1<string> OwnerAliases { get; }
    public string DisplayName { get; }
    public string QualifiedName { get; }
    public string Computer { get; }
    public string Comment { get; }
    public WorkspaceLocation Location { get; }
    public String[] MappedPaths { get; }
    public string SecurityToken { get; }
    public WorkspaceOptions Options { get; }
    public SavedCheckin LastSavedCheckin { get; public set; }
    internal WorkspaceInfo(Workspace workspace);
    internal WorkspaceInfo(Guid serverGuid, Uri serverUri, XmlNode workspaceInfoNode);
    public Workspace GetWorkspace(TfsTeamProjectCollection teamProjectCollection);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public static bool op_Equality(WorkspaceInfo workspaceInfo1, WorkspaceInfo workspaceInfo2);
    public static bool op_Inequality(WorkspaceInfo workspaceInfo1, WorkspaceInfo workspaceInfo2);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    internal void SaveAsXml(XmlNode parent);
    public string FormatWorkspaceNameForException(WorkspaceInfo conflictingWorkspace);
    public virtual string ToString();
    public bool OwnerNameMatches(string ownerName);
    internal static bool AreMappedPathSetsEqual(String[] set1, String[] set2);
    public Uri get_ServerUri();
    public Guid get_ServerGuid();
    public string get_Name();
    public string get_OwnerName();
    public string get_OwnerDisplayName();
    public IEnumerable`1<string> get_OwnerAliases();
    public string get_DisplayName();
    public string get_QualifiedName();
    public string get_Computer();
    public string get_Comment();
    public WorkspaceLocation get_Location();
    public String[] get_MappedPaths();
    public string get_SecurityToken();
    public WorkspaceOptions get_Options();
    public SavedCheckin get_LastSavedCheckin();
    public void set_LastSavedCheckin(SavedCheckin value);
    internal void UpdateLastSavedCheckinFrom(WorkspaceInfo updateSource);
}
public class Microsoft.TeamFoundation.VersionControl.Client.WorkspaceItem : Item {
    private int m_changeType;
    private string m_committedServerItem;
    private string m_localItem;
    private int m_recursiveChangeType;
    public string CommittedServerItem { get; }
    public string LocalItem { get; }
    public ChangeType ChangeType { get; }
    public ChangeType RecursiveChangeType { get; }
    private string Microsoft.TeamFoundation.VersionControl.Client.IWorkspaceDiffItem.LocalItem { get; }
    private int Microsoft.TeamFoundation.VersionControl.Client.IWorkspaceDiffItem.VersionLocal { get; }
    private ItemType Microsoft.TeamFoundation.VersionControl.Client.IWorkspaceDiffItem.ItemType { get; }
    private ChangeType Microsoft.TeamFoundation.VersionControl.Client.IWorkspaceDiffItem.ChangeType { get; }
    private long Microsoft.TeamFoundation.VersionControl.Client.IWorkspaceDiffItem.ContentLength { get; }
    private Byte[] Microsoft.TeamFoundation.VersionControl.Client.IWorkspaceDiffItem.HashValue { get; }
    public string get_CommittedServerItem();
    public string get_LocalItem();
    [EditorBrowsableAttribute("1")]
public static WorkspaceItem FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public virtual void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, WorkspaceItem obj);
    public ChangeType get_ChangeType();
    public ChangeType get_RecursiveChangeType();
    private sealed virtual override string Microsoft.TeamFoundation.VersionControl.Client.IWorkspaceDiffItem.get_LocalItem();
    private sealed virtual override int Microsoft.TeamFoundation.VersionControl.Client.IWorkspaceDiffItem.get_VersionLocal();
    private sealed virtual override ItemType Microsoft.TeamFoundation.VersionControl.Client.IWorkspaceDiffItem.get_ItemType();
    private sealed virtual override ChangeType Microsoft.TeamFoundation.VersionControl.Client.IWorkspaceDiffItem.get_ChangeType();
    private sealed virtual override long Microsoft.TeamFoundation.VersionControl.Client.IWorkspaceDiffItem.get_ContentLength();
    private sealed virtual override Byte[] Microsoft.TeamFoundation.VersionControl.Client.IWorkspaceDiffItem.get_HashValue();
}
public class Microsoft.TeamFoundation.VersionControl.Client.WorkspaceItemSet : object {
    internal WorkspaceItem[] m_items;
    private string m_pattern;
    private string m_queryPath;
    public WorkspaceItem[] Items { get; }
    public string Pattern { get; }
    public string QueryPath { get; }
    public WorkspaceItem[] get_Items();
    public string get_Pattern();
    public string get_QueryPath();
    [EditorBrowsableAttribute("1")]
public static WorkspaceItemSet FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, WorkspaceItemSet obj);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.WorkspaceLocalItem : object {
    public byte Flags;
    public string ServerItem;
    public string LocalItem;
    public int Version;
    public int ItemId;
    public long LastModifiedTime;
    public int Encoding;
    public long CheckinDate;
    public long Length;
    public Byte[] HashValue;
    public Byte[] BaselineFileGuid;
    private static Byte[] s_emptyHash;
    public bool IsDirectory { get; }
    public ItemType ItemType { get; }
    public bool IsCommitted { get; }
    public bool PendingReconcile { get; public set; }
    public bool MissingOnDisk { get; public set; }
    public bool IsDeleted { get; public set; }
    public bool IsEditPushed { get; public set; }
    public bool HasHashValue { get; }
    public bool HasBaselineFileGuid { get; }
    public bool IsScanned { get; public set; }
    private static WorkspaceLocalItem();
    public void SaveToVersion2(BinaryWriter writer);
    public static WorkspaceLocalItem FromVersion1(BinaryReader reader);
    public static WorkspaceLocalItem FromVersion2(BinaryReader reader);
    public bool get_IsDirectory();
    public ItemType get_ItemType();
    public bool get_IsCommitted();
    public bool get_PendingReconcile();
    public void set_PendingReconcile(bool value);
    public bool get_MissingOnDisk();
    public void set_MissingOnDisk(bool value);
    public bool get_IsDeleted();
    public void set_IsDeleted(bool value);
    public bool get_IsEditPushed();
    public void set_IsEditPushed(bool value);
    public bool get_HasHashValue();
    public bool get_HasBaselineFileGuid();
    public bool get_IsScanned();
    public void set_IsScanned(bool value);
    public WorkspaceLocalItem Clone();
    public ServerItemLocalVersionUpdate GetLocalVersionUpdate();
    public ServerItemLocalVersionUpdate GetLocalVersionUpdate(bool reconcileMissingOnDisk);
    public ServerItemLocalVersionUpdate GetLocalVersionUpdate(bool reconcileMissingOnDisk, bool force);
    public GetOperation ToGetOperation();
    public GetOperation ToGetOperation(LocalPendingChange pcEntry);
    public virtual string ToString();
}
internal class Microsoft.TeamFoundation.VersionControl.Client.WorkspaceLock : object {
    [CompilerGeneratedAttribute]
private BaselineFolderCollection <BaselineFolders>k__BackingField;
    [ThreadStaticAttribute]
private static WorkspaceLock ts_current;
    private int m_creationThreadId;
    private WorkspaceLock m_prevWorkspaceLock;
    private LocalMetadataTableLock m_lock;
    private object m_transactionLock;
    private Workspace m_workspace;
    private bool m_reportStackTrace;
    private Stopwatch m_stopwatch;
    public static WorkspaceLock Current { get; }
    public BaselineFolderCollection BaselineFolders { get; public set; }
    public Workspace Workspace { get; }
    unknown bool ReportStackTrace {public set; }
    public WorkspaceLock(Workspace workspace);
    public WorkspaceLock(Workspace workspace, bool requestYield);
    public WorkspaceLock(Workspace workspace, bool requestYield, Func`1<bool> spinDelegate);
    public sealed virtual void Dispose();
    public bool IsYieldRequested();
    public void Yield();
    public void StartTransaction(Func`1<bool> spinDelegate);
    public void EndTransaction();
    public static WorkspaceLock get_Current();
    [CompilerGeneratedAttribute]
public BaselineFolderCollection get_BaselineFolders();
    [CompilerGeneratedAttribute]
public void set_BaselineFolders(BaselineFolderCollection value);
    public Workspace get_Workspace();
    public void set_ReportStackTrace(bool value);
    [CompilerGeneratedAttribute]
private void <Yield>b__5_0(LocalWorkspaceProperties wp);
}
public class Microsoft.TeamFoundation.VersionControl.Client.WorkspaceNotFoundException : WorkspaceException {
    public WorkspaceNotFoundException(string message);
    public WorkspaceNotFoundException(string message, Exception ex);
    protected WorkspaceNotFoundException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.WorkspacePermissionProfile : object {
    private string m_name;
    private int m_builtInIndex;
    private AccessControlEntry[] m_accessControlEntries;
    private static WorkspacePermissionProfile[] s_builtinProfiles;
    private static object s_lock;
    private static IdentityDescriptor s_everyoneGroup;
    public string Name { get; }
    public AccessControlEntry[] AccessControlEntries { get; }
    public int BuiltInIndex { get; internal set; }
    public static WorkspacePermissionProfile[] BuiltInProfiles { get; }
    public WorkspacePermissionProfile(string profileName, AccessControlEntry[] accessControlEntries);
    private static WorkspacePermissionProfile();
    public string get_Name();
    public AccessControlEntry[] get_AccessControlEntries();
    public int get_BuiltInIndex();
    internal void set_BuiltInIndex(int value);
    public static WorkspacePermissionProfile[] get_BuiltInProfiles();
}
[FlagsAttribute]
public enum Microsoft.TeamFoundation.VersionControl.Client.WorkspacePermissions : Enum {
    public int value__;
    public static WorkspacePermissions NoneOrNotSupported;
    public static WorkspacePermissions Read;
    public static WorkspacePermissions Use;
    public static WorkspacePermissions CheckIn;
    public static WorkspacePermissions Administer;
}
public class Microsoft.TeamFoundation.VersionControl.Client.WorkspacePersistedMetadataTables : object {
    private bool m_disposed;
    private Workspace m_workspace;
    public WorkspacePersistedMetadataTables(Workspace toPersist);
    public sealed virtual void Dispose();
}
public class Microsoft.TeamFoundation.VersionControl.Client.WorkspaceRequiresComputerNameException : ServerItemException {
    public WorkspaceRequiresComputerNameException(string message);
    public WorkspaceRequiresComputerNameException(string message, Exception ex);
    protected WorkspaceRequiresComputerNameException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.TeamFoundation.VersionControl.Client.WorkspaceSuppressAsynchronousScanner : object {
    private bool m_disposed;
    private Workspace m_workspace;
    public WorkspaceSuppressAsynchronousScanner(Workspace toSuppress);
    public sealed virtual void Dispose();
}
public class Microsoft.TeamFoundation.VersionControl.Client.WorkspaceVersionSpec : VersionSpec {
    private string m_name;
    private string m_ownerDisplayName;
    private string m_ownerName;
    private string m_ownerUniqueName;
    public static char Identifier;
    public string Name { get; public set; }
    public string OwnerDisplayName { get; public set; }
    public string OwnerName { get; public set; }
    internal WorkspaceVersionSpec(string ownerName);
    public WorkspaceVersionSpec(string name, string ownerName);
    public WorkspaceVersionSpec(string name, string ownerName, string ownerDisplayName);
    public WorkspaceVersionSpec(WorkspaceInfo wsInfo);
    public WorkspaceVersionSpec(Workspace workspace);
    private static WorkspaceVersionSpec();
    public string get_Name();
    public void set_Name(string value);
    public string get_OwnerDisplayName();
    public void set_OwnerDisplayName(string value);
    public string get_OwnerName();
    public void set_OwnerName(string value);
    [EditorBrowsableAttribute("1")]
public static WorkspaceVersionSpec FromXml(IServiceProvider serviceProvider, XmlReader reader);
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public virtual void ToXml(XmlWriter writer, string element);
    [EditorBrowsableAttribute("1")]
public static void ToXml(XmlWriter writer, string element, WorkspaceVersionSpec obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public virtual string ComputeVersionString();
    [EditorBrowsableAttribute("1")]
public string ComputeUniqueVersionString();
    private void AfterDeserialize();
}
internal class Microsoft.TeamFoundation.VersionControl.Client.WorkspaceVersionTable : LocalMetadataTable {
    private PathTable`1<WorkspaceLocalItemPair> m_server;
    private PathTable`1<WorkspaceLocalItem> m_local;
    private List`1<WorkspaceLocalItem> m_removedItems;
    private int m_pendingReconcileCount;
    private static short c_magicVersion;
    protected String[] TraceKeywords { get; }
    public IEnumerable`1<string> KnownServerItems { get; }
    public int LocalItemsCount { get; }
    public bool PendingReconcile { get; }
    public WorkspaceVersionTable(string tableLocation, WorkspaceVersionTable cachedLoadSource);
    public WorkspaceVersionTable(string tableLocation, bool loadFromBackup);
    protected virtual String[] get_TraceKeywords();
    protected virtual void Initialize(object initializeData);
    protected virtual void Load(SafeFileHandle fileHandle);
    protected virtual bool Save(SafeFileHandle fileHandle);
    private void LoadFromVersion2(BinaryReader br);
    protected virtual bool CachedLoad(LocalMetadataTable source);
    private void WriteToVersion2(BinaryWriter bw);
    public void Add(WorkspaceLocalItem lvEntry);
    public void MarkAsReconciled(LocalWorkspaceProperties wp, bool removeMissingFromDiskRows);
    public WorkspaceLocalItem GetByLocalItem(string localItem);
    public WorkspaceLocalItem GetByLocalItemWithIndex(string localItem, Int32& index);
    public WorkspaceLocalItem GetByLocalItemIndex(int index);
    public WorkspaceLocalItem GetByServerItem(string serverItem, bool isCommitted);
    public WorkspaceLocalItem GetByPendingChange(LocalPendingChange pcEntry);
    public WorkspaceLocalItem GetByPendingChange(PendingChange pc);
    public WorkspaceLocalItem GetByGetOperation(GetOperation getOp);
    public IEnumerable`1<WorkspaceLocalItem> QueryLocalItemRoots();
    public IEnumerable`1<WorkspaceLocalItem> QueryByLocalItem(string localItem, RecursionType recursion, string pattern);
    public IEnumerable`1<WorkspaceLocalItem> QueryByLocalItem(string localItem, RecursionType recursion, string pattern, ItemType itemType, bool includeDeleted);
    public IEnumerable`1<WorkspaceLocalItem> QueryByServerItem(string serverItem, RecursionType recursion, string pattern, IEnumerable`1<string> exclusions);
    public IEnumerable`1<WorkspaceLocalItem> QueryByServerItem(string serverItem, RecursionType recursion, string pattern, bool includeDeleted, IEnumerable`1<string> exclusions);
    public IEnumerable`1<WorkspaceLocalItem> QueryByServerItem(string serverItem, RecursionType recursion, string pattern, IEnumerable`1<string> exclusions, ItemType itemType, CommittedState committedState, bool includeDeleted);
    private static int DepthFromRecursionType(RecursionType recursion);
    public void RemoveByLocalItem(string localItem, bool queueForReconcile);
    public void RemoveByServerItem(string serverItem, bool isCommitted, bool queueForReconcile);
    private void QueueForReconcile(WorkspaceLocalItem lvEntry);
    private void RemoveFromServerIndex(string serverItem, bool isCommitted);
    public void MarkAsDeleted(string serverItem, bool isCommitted, bool pendingReconcile);
    public ServerItemLocalVersionUpdate[] GetUpdatesForReconcile(LocalPendingChange[] pendingChanges, bool reconcileMissingOnDisk, Boolean& clearLocalVersionTable);
    [IteratorStateMachineAttribute("Microsoft.TeamFoundation.VersionControl.Client.WorkspaceVersionTable/<get_KnownServerItems>d__34")]
public IEnumerable`1<string> get_KnownServerItems();
    public void RenameTeamProjects(Func`2<string, string> serverItemMapper);
    public int get_LocalItemsCount();
    public bool get_PendingReconcile();
}
public class Microsoft.TeamFoundation.VersionControl.Client.WorkspaceVersionTableException : VersionControlException {
    public WorkspaceVersionTableException(string message);
    public WorkspaceVersionTableException(Exception innerException);
    public WorkspaceVersionTableException(string message, Exception exception);
    protected WorkspaceVersionTableException(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.WorkspaceVersionTableHeader : LocalMetadataTable {
    private bool m_pendingReconcile;
    private static short c_magicVersion;
    protected String[] TraceKeywords { get; }
    public bool PendingReconcile { get; }
    public WorkspaceVersionTableHeader(string fileName, LocalMetadataTable cachedLoadSource);
    public WorkspaceVersionTableHeader(string fileName, bool loadFromBackup);
    protected virtual String[] get_TraceKeywords();
    protected virtual void Initialize(object initializeData);
    protected virtual void Load(SafeFileHandle fileHandle);
    private void LoadFromVersion2(BinaryReader br);
    protected virtual bool CachedLoad(LocalMetadataTable source);
    protected virtual bool Save(SafeFileHandle fileHandle);
    public bool get_PendingReconcile();
}
internal class Microsoft.TeamFoundation.VersionControl.Client.WorkspaceWatcher : object {
    private Workspace m_workspace;
    private bool m_isAsynchronous;
    private QueuedActionLimiter m_asyncScanLimiter;
    private object m_lock;
    private SparseTree`1<PathWatcher> m_pathWatchers;
    private PathWatcherReport m_report;
    private HashSet`1<string> m_skippedItems;
    private static bool s_enablePartialScans;
    private static int s_asyncScanRateLimit;
    private static int c_defaultAsyncScanRateLimit;
    public bool IsAsynchronous { get; public set; }
    private static WorkspaceWatcher();
    public WorkspaceWatcher(Workspace workspace);
    public bool get_IsAsynchronous();
    public void set_IsAsynchronous(bool value);
    public void SuppressAsynchronous();
    public void UnsuppressAsynchronous();
    public void LocationChanged();
    public void EnsureWatching();
    public void Shutdown();
    public void WorkingFoldersChanged(WorkingFolder[] workingFolders);
    public void MarkPathChanged(string path);
    public void Scan(LocalWorkspaceProperties wp, WorkspaceVersionTable lv, LocalPendingChangesTable pc);
    public bool Scan(LocalWorkspaceProperties wp, WorkspaceVersionTable lv, LocalPendingChangesTable pc, bool interruptible);
    public void EndTransactionScan(LocalWorkspaceProperties wp, WorkspaceVersionTable lv, LocalPendingChangesTable pc);
    public bool IsScanNecessary();
    public void AddSkippedItem(string localItem);
    public void RemoveSkippedItem(string localItem);
    private PathWatcherReport Poll();
    private void UpdatePathWatchers(LocalWorkspaceProperties wp, WorkspaceVersionTable lv);
    private sealed virtual override void Microsoft.TeamFoundation.VersionControl.Client.IPathChangedSink.PathChanged(PathWatcher sender);
    public void QueueAsynchronousScan();
    private void AsyncScanCallback(object state);
    [CompilerGeneratedAttribute]
private void <set_IsAsynchronous>b__4_0(LocalWorkspaceProperties wp, WorkspaceVersionTable lv);
}
public class Microsoft.TeamFoundation.VersionControl.Client.Workstation : object {
    private LocalWorkspaceCache m_cache;
    private Dictionary`2<ServerAndOwner, DateTime> m_ensureUpdateCache;
    private WorkstationType m_type;
    private LocalItemExclusionCache m_exclusionCache;
    private static bool s_cacheEnabled;
    private static bool s_configurationEnabled;
    private static Workstation m_currentWorkstation;
    internal static object m_mutex;
    private static object s_configurationMutex;
    private static string s_dataDir;
    private static string s_configDir;
    private static string s_dataDirEnvVar;
    private static string s_configDirEnvVar;
    private static string m_policiesRegistryKey;
    private static string m_sccTfsGlobalOptionsRegistryKey;
    private static string m_getLatestOnCheckOutRegistryValueName;
    private static string m_attemptToAutoResolveConflictsRegistryValueName;
    private int m_pagedCheckinPageSize;
    private static int s_defaultPagedCheckinPageSize;
    private static string s_pagedCheckinPageSizeRegistryValueName;
    private int m_pagedCheckinMaterializationCap;
    private static int s_defaultPagedCheckinMaterializationCap;
    private static string s_pagedCheckinMaterializationCapRegistryValueName;
    public PolicyType[] InstalledPolicyTypes { get; }
    public string Name { get; }
    public bool GetLatestOnCheckout { get; public set; }
    public bool AttemptToAutoResolveConflicts { get; public set; }
    public int PagedCheckinPageSize { get; public set; }
    public int PagedCheckinMaterializationCap { get; public set; }
    public static Workstation Current { get; }
    [EditorBrowsableAttribute("1")]
public static string DataDirectory { get; }
    public static bool CacheEnabled { get; public set; }
    internal static string ConfigurationDirectory { get; }
    public static bool ConfigurationEnabled { get; public set; }
    internal LocalItemExclusionCache LocalItemExclusionCache { get; }
    internal LocalWorkspaceCache Cache { get; }
    public static string OfflineMetadataFileRoot { get; }
    private Workstation(WorkstationType type);
    private static Workstation();
    public void ReloadCache();
    public WorkspaceInfo[] GetAllLocalWorkspaceInfo();
    public WorkspaceInfo GetLocalWorkspaceInfo(VersionControlServer sourceControl, string workspaceName, string workspaceOwner);
    public WorkspaceInfo GetLocalWorkspaceInfo(Guid repositoryGuid, string workspaceName, string workspaceOwner);
    public WorkspaceInfo GetLocalWorkspaceInfo(string path);
    public WorkspaceInfo[] GetLocalWorkspaceInfoRecursively(string path);
    public WorkspaceInfo[] QueryLocalWorkspaceInfo(VersionControlServer sourceControl, string workspaceName, string workspaceOwner);
    public bool IsMapped(string path);
    public bool IsExplicitlyMapped(string path);
    internal void InsertWorkspaceIntoCache(WorkspaceInfo localWorkspace);
    public WorkspaceInfo[] RemoveCachedWorkspaceInfo(Uri serverUri, string workspaceName, string workspaceOwner);
    public WorkspaceInfo[] RemoveCachedWorkspaceInfo(VersionControlServer sourceControl);
    public WorkspaceInfo[] RemoveCachedWorkspaceInfo(VersionControlServer sourceControl, string workspaceOwner);
    private WorkspaceInfo[] RemoveCachedWorkspaceInfoHelper(Guid serverGuid, Uri serverUri, string workspaceName, string workspaceOwner);
    private void OnCacheFileReloaded(EventArgs e);
    internal void SaveConfigIfDirty();
    public void EnsureUpdateWorkspaceInfoCache(VersionControlServer sourceControl, string ownerName);
    public void EnsureUpdateWorkspaceInfoCache(VersionControlServer sourceControl, string ownerName, TimeSpan maxAge);
    public void UpdateWorkspaceInfoCache(VersionControlServer sourceControl, string ownerName);
    public void UpdateWorkspaceInfoCache(VersionControlServer sourceControl, string ownerName, Workspace[]& workspaces);
    private WorkspaceInfo GetWorkspaceInfoForNotification(IntPtr serverHashCode, IntPtr workspaceHashCode);
    private Guid GetServerGuidForNotification(IntPtr serverHashCode);
    private void NotificationCallback(Notification notification, IntPtr param1, IntPtr param2);
    private void OnNonFatalError(IEnumerable`1<InternalWorkspaceConflictInfo> conflictingWorkspaces);
    private void OnNonFatalError(WorkstationExceptionEventArgs e);
    [ObsoleteAttribute("This method is no longer useful and performs no work.  You may safely omit your call to this method.", "False")]
public void UpdateServerUriReferences(VersionControlServer sourceControl, Uri uri);
    private void RequireFullyQualifiedUserName(string userName, string paramName);
    public PolicyType[] get_InstalledPolicyTypes();
    private void LoadPolicyTypes(RegistryKey key, List`1<PolicyType> list, List`1<AssemblyName> assemblyNames);
    private void LoadPolicyTypes(string assemblyName, string assemblyFilePath, List`1<PolicyType> list, List`1<AssemblyName> assemblyNames);
    private bool LoadTypesFromAssembly(Assembly assembly, string assemblyFile, List`1<PolicyType> list);
    public void RemoveLocalItemExclusion(VersionControlServer sourceControl, string exclusion);
    public String[] GetLocalItemExclusions(VersionControlServer sourceControl);
    public void SetLocalItemExclusions(VersionControlServer sourceControl, String[] exclusions);
    internal void CheckForLocalItemExclusionUpdates(VersionControlServer sourceControl, bool force);
    public string get_Name();
    public bool get_GetLatestOnCheckout();
    public void set_GetLatestOnCheckout(bool value);
    public bool get_AttemptToAutoResolveConflicts();
    public void set_AttemptToAutoResolveConflicts(bool value);
    public int get_PagedCheckinPageSize();
    public void set_PagedCheckinPageSize(int value);
    public int get_PagedCheckinMaterializationCap();
    public void set_PagedCheckinMaterializationCap(int value);
    public static Workstation get_Current();
    public static string get_DataDirectory();
    public static bool get_CacheEnabled();
    public static void set_CacheEnabled(bool value);
    internal static string get_ConfigurationDirectory();
    public static bool get_ConfigurationEnabled();
    public static void set_ConfigurationEnabled(bool value);
    internal void EnsureCreated();
    internal LocalItemExclusionCache get_LocalItemExclusionCache();
    internal LocalWorkspaceCache get_Cache();
    public static string get_OfflineMetadataFileRoot();
    private static string GetProperSettingsDirectory(string frameworkPath, string environmentVarOverride, string appSettingOverride);
    private bool EnsureLocalPathIsUsable(string directory, string fullFilePath);
    [CompilerGeneratedAttribute]
private void <.ctor>b__0_0(object sender, ConnectionUserChangedEventArgs e);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.WorkstationExceptionEventArgs : ExceptionEventArgs {
    [CompilerGeneratedAttribute]
private WorkspaceInfo <WorkspaceInfo>k__BackingField;
    public WorkspaceInfo WorkspaceInfo { get; public set; }
    public WorkstationExceptionEventArgs(InternalWorkspaceConflictInfo conflictingWorkspace);
    public WorkstationExceptionEventArgs(Exception exception, Workspace workspace);
    [CompilerGeneratedAttribute]
public WorkspaceInfo get_WorkspaceInfo();
    [CompilerGeneratedAttribute]
public void set_WorkspaceInfo(WorkspaceInfo value);
}
internal class Microsoft.TeamFoundation.VersionControl.Client.WorkstationExceptionEventHandler : MulticastDelegate {
    public WorkstationExceptionEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, WorkstationExceptionEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, WorkstationExceptionEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal enum Microsoft.TeamFoundation.VersionControl.Client.WorkstationType : Enum {
    public int value__;
    public static WorkstationType Current;
    public static WorkstationType Remote;
}
internal class Microsoft.TeamFoundation.VersionControl.Client.WritableConflictOnSourcePathListener : object {
    private List`1<string> m_writableConflictPaths;
    private VersionControlServer m_sourceControl;
    internal String[] MovedPaths { get; }
    internal WritableConflictOnSourcePathListener(VersionControlServer sourceControl);
    public sealed virtual void Dispose();
    private void OnGetting(object sender, GettingEventArgs e);
    internal String[] get_MovedPaths();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
