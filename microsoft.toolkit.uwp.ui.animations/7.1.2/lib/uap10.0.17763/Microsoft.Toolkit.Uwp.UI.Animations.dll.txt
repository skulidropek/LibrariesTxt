[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
public abstract class Microsoft.Toolkit.Uwp.UI.Animations.Activity : DependencyObject {
    public static DependencyProperty DelayProperty;
    public Nullable`1<TimeSpan> Delay { get; public set; }
    private static Activity();
    public Nullable`1<TimeSpan> get_Delay();
    public void set_Delay(Nullable`1<TimeSpan> value);
    public virtual Task InvokeAsync(UIElement element, CancellationToken token);
}
public class Microsoft.Toolkit.Uwp.UI.Animations.AnchorPointAnimation : ImplicitAnimation`2<string, Vector2> {
    protected string ExplicitTarget { get; }
    protected virtual string get_ExplicitTarget();
    protected virtual ValueTuple`2<Nullable`1<Vector2>, Nullable`1<Vector2>> GetParsedValues();
}
public abstract class Microsoft.Toolkit.Uwp.UI.Animations.Animation : DependencyObject {
    public static DependencyProperty DelayProperty;
    public static DependencyProperty DurationProperty;
    public static DependencyProperty EasingTypeProperty;
    public static DependencyProperty EasingModeProperty;
    public static DependencyProperty RepeatProperty;
    public static DependencyProperty DelayBehaviorProperty;
    public Nullable`1<TimeSpan> Delay { get; public set; }
    public Nullable`1<TimeSpan> Duration { get; public set; }
    public Nullable`1<EasingType> EasingType { get; public set; }
    public Nullable`1<EasingMode> EasingMode { get; public set; }
    public RepeatOption Repeat { get; public set; }
    public AnimationDelayBehavior DelayBehavior { get; public set; }
    private static Animation();
    public Nullable`1<TimeSpan> get_Delay();
    public void set_Delay(Nullable`1<TimeSpan> value);
    public Nullable`1<TimeSpan> get_Duration();
    public void set_Duration(Nullable`1<TimeSpan> value);
    public Nullable`1<EasingType> get_EasingType();
    public void set_EasingType(Nullable`1<EasingType> value);
    public Nullable`1<EasingMode> get_EasingMode();
    public void set_EasingMode(Nullable`1<EasingMode> value);
    public RepeatOption get_Repeat();
    public void set_Repeat(RepeatOption value);
    public AnimationDelayBehavior get_DelayBehavior();
    public void set_DelayBehavior(AnimationDelayBehavior value);
    public abstract virtual AnimationBuilder AppendToBuilder(AnimationBuilder builder, Nullable`1<TimeSpan> delayHint, Nullable`1<TimeSpan> durationHint, Nullable`1<EasingType> easingTypeHint, Nullable`1<EasingMode> easingModeHint);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ContentPropertyAttribute]
public abstract class Microsoft.Toolkit.Uwp.UI.Animations.Animation`2 : Animation {
    [NullableAttribute("1")]
public static DependencyProperty ToProperty;
    [NullableAttribute("1")]
public static DependencyProperty FromProperty;
    [NullableAttribute("1")]
public static DependencyProperty KeyFramesProperty;
    public TValue To { get; public set; }
    public TValue From { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IList`1<IKeyFrame`1<TKeyFrame>> KeyFrames { get; public set; }
    [NullableAttribute("1")]
protected string ExplicitTarget { get; }
    private static Animation`2();
    public TValue get_To();
    public void set_To(TValue value);
    public TValue get_From();
    public void set_From(TValue value);
    public IList`1<IKeyFrame`1<TKeyFrame>> get_KeyFrames();
    public void set_KeyFrames(IList`1<IKeyFrame`1<TKeyFrame>> value);
    [NullableContextAttribute("1")]
protected abstract virtual string get_ExplicitTarget();
    [NullableContextAttribute("1")]
public virtual AnimationBuilder AppendToBuilder(AnimationBuilder builder, Nullable`1<TimeSpan> delayHint, Nullable`1<TimeSpan> durationHint, Nullable`1<EasingType> easingTypeHint, Nullable`1<EasingMode> easingModeHint);
    [NullableContextAttribute("0")]
protected abstract virtual ValueTuple`2<Nullable`1<TKeyFrame>, Nullable`1<TKeyFrame>> GetParsedValues();
    protected INormalizedKeyFrameAnimationBuilder`1<TKeyFrame> AppendToBuilder(INormalizedKeyFrameAnimationBuilder`1<TKeyFrame> builder, Nullable`1<EasingType> easingTypeHint, Nullable`1<EasingMode> easingModeHint);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Toolkit.Uwp.UI.Animations.AnimationBuilder : object {
    [NullableAttribute("0")]
private List`1<ICompositionAnimationFactory> compositionAnimationFactories;
    [NullableAttribute("0")]
private List`1<IXamlAnimationFactory> xamlAnimationFactories;
    public static AnimationBuilder Create();
    public void Start(UIElement element);
    public void Start(UIElement element, Action callback);
    public void Start(UIElement element, CancellationToken token);
    public Task StartAsync(UIElement element);
    public Task StartAsync(UIElement element, CancellationToken token);
    public AnimationBuilder AnchorPoint(Axis axis, double to, Nullable`1<double> from, Nullable`1<TimeSpan> delay, Nullable`1<TimeSpan> duration, Nullable`1<RepeatOption> repeat, EasingType easingType, EasingMode easingMode);
    public AnimationBuilder AnchorPoint(Vector2 to, Nullable`1<Vector2> from, Nullable`1<TimeSpan> delay, Nullable`1<TimeSpan> duration, Nullable`1<RepeatOption> repeat, EasingType easingType, EasingMode easingMode);
    public AnimationBuilder Opacity(double to, Nullable`1<double> from, Nullable`1<TimeSpan> delay, Nullable`1<TimeSpan> duration, Nullable`1<RepeatOption> repeat, EasingType easingType, EasingMode easingMode, FrameworkLayer layer);
    public AnimationBuilder Translation(Axis axis, double to, Nullable`1<double> from, Nullable`1<TimeSpan> delay, Nullable`1<TimeSpan> duration, Nullable`1<RepeatOption> repeat, EasingType easingType, EasingMode easingMode, FrameworkLayer layer);
    public AnimationBuilder Translation(Vector2 to, Nullable`1<Vector2> from, Nullable`1<TimeSpan> delay, Nullable`1<TimeSpan> duration, Nullable`1<RepeatOption> repeat, EasingType easingType, EasingMode easingMode, FrameworkLayer layer);
    public AnimationBuilder Translation(Vector3 to, Nullable`1<Vector3> from, Nullable`1<TimeSpan> delay, Nullable`1<TimeSpan> duration, Nullable`1<RepeatOption> repeat, EasingType easingType, EasingMode easingMode);
    public AnimationBuilder Offset(Axis axis, double to, Nullable`1<double> from, Nullable`1<TimeSpan> delay, Nullable`1<TimeSpan> duration, Nullable`1<RepeatOption> repeat, EasingType easingType, EasingMode easingMode);
    public AnimationBuilder Offset(Vector2 to, Nullable`1<Vector2> from, Nullable`1<TimeSpan> delay, Nullable`1<TimeSpan> duration, Nullable`1<RepeatOption> repeat, EasingType easingType, EasingMode easingMode);
    public AnimationBuilder Offset(Vector3 to, Nullable`1<Vector3> from, Nullable`1<TimeSpan> delay, Nullable`1<TimeSpan> duration, Nullable`1<RepeatOption> repeat, EasingType easingType, EasingMode easingMode);
    public AnimationBuilder Scale(double to, Nullable`1<double> from, Nullable`1<TimeSpan> delay, Nullable`1<TimeSpan> duration, Nullable`1<RepeatOption> repeat, EasingType easingType, EasingMode easingMode, FrameworkLayer layer);
    public AnimationBuilder Scale(Axis axis, double to, Nullable`1<double> from, Nullable`1<TimeSpan> delay, Nullable`1<TimeSpan> duration, Nullable`1<RepeatOption> repeat, EasingType easingType, EasingMode easingMode, FrameworkLayer layer);
    public AnimationBuilder Scale(Vector2 to, Nullable`1<Vector2> from, Nullable`1<TimeSpan> delay, Nullable`1<TimeSpan> duration, Nullable`1<RepeatOption> repeat, EasingType easingType, EasingMode easingMode, FrameworkLayer layer);
    public AnimationBuilder Scale(Vector3 to, Nullable`1<Vector3> from, Nullable`1<TimeSpan> delay, Nullable`1<TimeSpan> duration, Nullable`1<RepeatOption> repeat, EasingType easingType, EasingMode easingMode);
    public AnimationBuilder CenterPoint(Axis axis, double to, Nullable`1<double> from, Nullable`1<TimeSpan> delay, Nullable`1<TimeSpan> duration, Nullable`1<RepeatOption> repeat, EasingType easingType, EasingMode easingMode, FrameworkLayer layer);
    public AnimationBuilder CenterPoint(Vector2 to, Nullable`1<Vector2> from, Nullable`1<TimeSpan> delay, Nullable`1<TimeSpan> duration, Nullable`1<RepeatOption> repeat, EasingType easingType, EasingMode easingMode, FrameworkLayer layer);
    public AnimationBuilder CenterPoint(Vector3 to, Nullable`1<Vector3> from, Nullable`1<TimeSpan> delay, Nullable`1<TimeSpan> duration, Nullable`1<RepeatOption> repeat, EasingType easingType, EasingMode easingMode);
    public AnimationBuilder Rotation(double to, Nullable`1<double> from, Nullable`1<TimeSpan> delay, Nullable`1<TimeSpan> duration, Nullable`1<RepeatOption> repeat, EasingType easingType, EasingMode easingMode, FrameworkLayer layer);
    public AnimationBuilder RotationInDegrees(double to, Nullable`1<double> from, Nullable`1<TimeSpan> delay, Nullable`1<TimeSpan> duration, Nullable`1<RepeatOption> repeat, EasingType easingType, EasingMode easingMode, FrameworkLayer layer);
    public AnimationBuilder RotationAxis(Vector3 to, Nullable`1<Vector3> from, Nullable`1<TimeSpan> delay, Nullable`1<TimeSpan> duration, Nullable`1<RepeatOption> repeat, EasingType easingType, EasingMode easingMode);
    public AnimationBuilder Orientation(Quaternion to, Nullable`1<Quaternion> from, Nullable`1<TimeSpan> delay, Nullable`1<TimeSpan> duration, Nullable`1<RepeatOption> repeat, EasingType easingType, EasingMode easingMode);
    public AnimationBuilder Transform(Matrix4x4 to, Nullable`1<Matrix4x4> from, Nullable`1<TimeSpan> delay, Nullable`1<TimeSpan> duration, Nullable`1<RepeatOption> repeat, EasingType easingType, EasingMode easingMode);
    public AnimationBuilder Clip(Side side, double to, Nullable`1<double> from, Nullable`1<TimeSpan> delay, Nullable`1<TimeSpan> duration, Nullable`1<RepeatOption> repeat, EasingType easingType, EasingMode easingMode);
    public AnimationBuilder Clip(Thickness to, Nullable`1<Thickness> from, Nullable`1<TimeSpan> delay, Nullable`1<TimeSpan> duration, Nullable`1<RepeatOption> repeat, EasingType easingType, EasingMode easingMode);
    public AnimationBuilder Size(Axis axis, double to, Nullable`1<double> from, Nullable`1<TimeSpan> delay, Nullable`1<TimeSpan> duration, Nullable`1<RepeatOption> repeat, EasingType easingType, EasingMode easingMode, FrameworkLayer layer);
    public AnimationBuilder Size(Vector2 to, Nullable`1<Vector2> from, Nullable`1<TimeSpan> delay, Nullable`1<TimeSpan> duration, Nullable`1<RepeatOption> repeat, EasingType easingType, EasingMode easingMode, FrameworkLayer layer);
    public AnimationBuilder ExternalAnimation(CompositionAnimation animation);
    public AnimationBuilder ExternalAnimation(CompositionObject target, CompositionAnimation animation);
    public AnimationBuilder ExternalAnimation(Timeline animation);
    public IPropertyAnimationBuilder`1<double> AnchorPoint(Axis axis);
    public IPropertyAnimationBuilder`1<Vector2> AnchorPoint();
    public IPropertyAnimationBuilder`1<double> Opacity(FrameworkLayer layer);
    public IPropertyAnimationBuilder`1<double> Translation(Axis axis, FrameworkLayer layer);
    public IPropertyAnimationBuilder`1<Vector3> Translation();
    public IPropertyAnimationBuilder`1<double> Offset(Axis axis);
    public IPropertyAnimationBuilder`1<Vector3> Offset();
    public IPropertyAnimationBuilder`1<double> Scale(Axis axis, FrameworkLayer layer);
    public IPropertyAnimationBuilder`1<Vector3> Scale();
    public IPropertyAnimationBuilder`1<double> CenterPoint(Axis axis, FrameworkLayer layer);
    public IPropertyAnimationBuilder`1<Vector3> CenterPoint();
    public IPropertyAnimationBuilder`1<double> Rotation();
    public IPropertyAnimationBuilder`1<double> RotationInDegrees(FrameworkLayer layer);
    public IPropertyAnimationBuilder`1<Vector3> RotationAxis();
    public IPropertyAnimationBuilder`1<Quaternion> Orientation();
    public IPropertyAnimationBuilder`1<double> Clip(Side side);
    public IPropertyAnimationBuilder`1<double> Size(Axis axis, FrameworkLayer layer);
    public IPropertyAnimationBuilder`1<Vector2> Size();
    public AnimationBuilder NormalizedKeyFrames(string property, Action`1<INormalizedKeyFrameAnimationBuilder`1<T>> build, Nullable`1<TimeSpan> delay, Nullable`1<TimeSpan> duration, Nullable`1<RepeatOption> repeatOption, Nullable`1<AnimationDelayBehavior> delayBehavior, FrameworkLayer layer);
    public AnimationBuilder NormalizedKeyFrames(string property, TState state, Action`2<INormalizedKeyFrameAnimationBuilder`1<T>, TState> build, Nullable`1<TimeSpan> delay, Nullable`1<TimeSpan> duration, Nullable`1<RepeatOption> repeatOption, Nullable`1<AnimationDelayBehavior> delayBehavior, FrameworkLayer layer);
    public AnimationBuilder TimedKeyFrames(string property, Action`1<ITimedKeyFrameAnimationBuilder`1<T>> build, Nullable`1<TimeSpan> delay, Nullable`1<RepeatOption> repeat, Nullable`1<AnimationDelayBehavior> delayBehavior, FrameworkLayer layer);
    public AnimationBuilder TimedKeyFrames(string property, TState state, Action`2<ITimedKeyFrameAnimationBuilder`1<T>, TState> build, Nullable`1<TimeSpan> delay, Nullable`1<RepeatOption> repeatOption, Nullable`1<AnimationDelayBehavior> delayBehavior, FrameworkLayer layer);
    [NullableContextAttribute("0")]
private AnimationBuilder AddCompositionAnimationFactory(string property, T to, Nullable`1<T> from, Nullable`1<TimeSpan> delay, Nullable`1<TimeSpan> duration, Nullable`1<RepeatOption> repeat, EasingType easingType, EasingMode easingMode);
    [NullableContextAttribute("0")]
private AnimationBuilder AddXamlAnimationFactory(string property, T to, Nullable`1<T> from, Nullable`1<TimeSpan> delay, Nullable`1<TimeSpan> duration, Nullable`1<RepeatOption> repeat, EasingType easingType, EasingMode easingMode);
    [NullableContextAttribute("0")]
private AnimationBuilder AddXamlTransformDoubleAnimationFactory(string property, double to, Nullable`1<double> from, Nullable`1<TimeSpan> delay, Nullable`1<TimeSpan> duration, Nullable`1<RepeatOption> repeat, EasingType easingType, EasingMode easingMode);
    [CompilerGeneratedAttribute]
internal static void <Start>g__Start|3_0(AnimationBuilder builder, UIElement element, Action callback);
    [CompilerGeneratedAttribute]
internal static void <Start>g__Start|3_1(AnimationBuilder builder, UIElement element, Action callback);
    [CompilerGeneratedAttribute]
internal static void <Start>g__Start|3_2(AnimationBuilder builder, UIElement element, Action callback);
    [CompilerGeneratedAttribute]
internal static void <Start>g__Stop|4_0(object state);
    [CompilerGeneratedAttribute]
internal static void <StartAsync>g__Stop|6_0(object state);
    [CompilerGeneratedAttribute]
internal static void <Transform>g__ThrowThrowArgumentExceptionForToDecompose|27_0();
    [CompilerGeneratedAttribute]
internal static void <Transform>g__ThrowThrowArgumentExceptionForFromDecompose|27_1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Microsoft.Toolkit.Uwp.UI.Animations.AnimationDictionary : DependencyObject {
    private List`1<AnimationSet> list;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private WeakReference`1<UIElement> parent;
    [NullableAttribute("2")]
unknown UIElement Parent {internal set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public AnimationSet Item { get; public set; }
    [NullableContextAttribute("2")]
internal void set_Parent(UIElement value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual AnimationSet get_Item(int index);
    public sealed virtual void set_Item(int index, AnimationSet value);
    public sealed virtual void Add(AnimationSet item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(AnimationSet item);
    public sealed virtual void CopyTo(AnimationSet[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<AnimationSet> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int IndexOf(AnimationSet item);
    public sealed virtual void Insert(int index, AnimationSet item);
    public sealed virtual bool Remove(AnimationSet item);
    public sealed virtual void RemoveAt(int index);
}
public static class Microsoft.Toolkit.Uwp.UI.Animations.AnimationExtensions : object {
    public static EasingType DefaultEasingType;
    public static EasingMode DefaultEasingMode;
    public static AnimationDelayBehavior DefaultDelayBehavior;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Dictionary`2<ValueTuple`2<EasingType, EasingMode>, ValueTuple`2<Vector2, Vector2>> EasingMaps;
    public static TimeSpan DefaultDelay { get; }
    public static TimeSpan DefaultDuration { get; }
    private static AnimationExtensions();
    public static TimeSpan get_DefaultDelay();
    public static TimeSpan get_DefaultDuration();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Toolkit.Uwp.UI.Animations.AnimationScope : DependencyObjectCollection {
    public static DependencyProperty DelayProperty;
    public static DependencyProperty DurationProperty;
    public static DependencyProperty EasingTypeProperty;
    public static DependencyProperty EasingModeProperty;
    public Nullable`1<TimeSpan> Delay { get; public set; }
    public Nullable`1<TimeSpan> Duration { get; public set; }
    public Nullable`1<EasingType> EasingType { get; public set; }
    public Nullable`1<EasingMode> EasingMode { get; public set; }
    private static AnimationScope();
    public Nullable`1<TimeSpan> get_Delay();
    public void set_Delay(Nullable`1<TimeSpan> value);
    public Nullable`1<TimeSpan> get_Duration();
    public void set_Duration(Nullable`1<TimeSpan> value);
    public Nullable`1<EasingType> get_EasingType();
    public void set_EasingType(Nullable`1<EasingType> value);
    public Nullable`1<EasingMode> get_EasingMode();
    public void set_EasingMode(Nullable`1<EasingMode> value);
    public sealed virtual AnimationBuilder AppendToBuilder(AnimationBuilder builder, Nullable`1<TimeSpan> delayHint, Nullable`1<TimeSpan> durationHint, Nullable`1<EasingType> easingTypeHint, Nullable`1<EasingMode> easingModeHint);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Toolkit.Uwp.UI.Animations.AnimationSet : DependencyObjectCollection {
    private ConditionalWeakTable`2<UIElement, CancellationTokenSource> cancellationTokenMap;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private EventHandler Started;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private EventHandler Completed;
    [CompilerGeneratedAttribute]
private bool <IsSequential>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private WeakReference`1<UIElement> <ParentReference>k__BackingField;
    public bool IsSequential { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal WeakReference`1<UIElement> ParentReference { get; internal set; }
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void add_Started(EventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void remove_Started(EventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void add_Completed(EventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void remove_Completed(EventHandler value);
    [CompilerGeneratedAttribute]
public bool get_IsSequential();
    [CompilerGeneratedAttribute]
public void set_IsSequential(bool value);
    [CompilerGeneratedAttribute]
internal WeakReference`1<UIElement> get_ParentReference();
    [CompilerGeneratedAttribute]
internal void set_ParentReference(WeakReference`1<UIElement> value);
    [AsyncStateMachineAttribute("Microsoft.Toolkit.Uwp.UI.Animations.AnimationSet/<Start>d__15")]
public void Start();
    [AsyncStateMachineAttribute("Microsoft.Toolkit.Uwp.UI.Animations.AnimationSet/<Start>d__16")]
public void Start(UIElement element);
    [AsyncStateMachineAttribute("Microsoft.Toolkit.Uwp.UI.Animations.AnimationSet/<Start>d__17")]
public void Start(CancellationToken token);
    public Task StartAsync();
    public Task StartAsync(UIElement element);
    public Task StartAsync(CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.Toolkit.Uwp.UI.Animations.AnimationSet/<StartAsync>d__21")]
public Task StartAsync(UIElement element, CancellationToken token);
    public void Stop();
    public void Stop(UIElement element);
    private UIElement GetParent();
    [CompilerGeneratedAttribute]
internal static void <StartAsync>g__ThrowArgumentException|21_0();
    [CompilerGeneratedAttribute]
internal static void <GetParent>g__ThrowInvalidOperationException|24_0();
}
public enum Microsoft.Toolkit.Uwp.UI.Animations.Axis : Enum {
    public int value__;
    public static Axis X;
    public static Axis Y;
    public static Axis Z;
}
public class Microsoft.Toolkit.Uwp.UI.Animations.BlurRadiusDropShadowAnimation : ShadowAnimation`2<Nullable`1<double>, double> {
    protected string ExplicitTarget { get; }
    protected virtual string get_ExplicitTarget();
    protected virtual ValueTuple`2<Nullable`1<double>, Nullable`1<double>> GetParsedValues();
}
internal class Microsoft.Toolkit.Uwp.UI.Animations.Builders.Helpers.ListBuilder`1 : ValueType {
    private T[] array;
    private int index;
    public static ListBuilder`1<T> Empty { get; }
    public static ListBuilder`1<T> get_Empty();
    public void Append(T item);
    public ArraySegment`1<T> GetArraySegment();
}
public class Microsoft.Toolkit.Uwp.UI.Animations.CenterPointAnimation : ImplicitAnimation`2<string, Vector3> {
    protected string ExplicitTarget { get; }
    protected virtual string get_ExplicitTarget();
    protected virtual ValueTuple`2<Nullable`1<Vector3>, Nullable`1<Vector3>> GetParsedValues();
}
public class Microsoft.Toolkit.Uwp.UI.Animations.ClipAnimation : Animation`2<Nullable`1<Thickness>, Thickness> {
    protected string ExplicitTarget { get; }
    protected virtual string get_ExplicitTarget();
    public virtual AnimationBuilder AppendToBuilder(AnimationBuilder builder, Nullable`1<TimeSpan> delayHint, Nullable`1<TimeSpan> durationHint, Nullable`1<EasingType> easingTypeHint, Nullable`1<EasingMode> easingModeHint);
    protected virtual ValueTuple`2<Nullable`1<Thickness>, Nullable`1<Thickness>> GetParsedValues();
}
public class Microsoft.Toolkit.Uwp.UI.Animations.ColorAnimation : CustomAnimation`2<Nullable`1<Color>, Color> {
    protected virtual ValueTuple`2<Nullable`1<Color>, Nullable`1<Color>> GetParsedValues();
}
public class Microsoft.Toolkit.Uwp.UI.Animations.ColorDropShadowAnimation : ShadowAnimation`2<Nullable`1<Color>, Color> {
    protected string ExplicitTarget { get; }
    protected virtual string get_ExplicitTarget();
    protected virtual ValueTuple`2<Nullable`1<Color>, Nullable`1<Color>> GetParsedValues();
}
public class Microsoft.Toolkit.Uwp.UI.Animations.ColorKeyFrame : KeyFrame`2<Nullable`1<Color>, Color> {
    protected virtual Color GetParsedValue();
}
[ExtensionAttribute]
public static class Microsoft.Toolkit.Uwp.UI.Animations.CompositionObjectExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void StartAnimation(CompositionObject compositionObject, CompositionAnimation animation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.Toolkit.Uwp.UI.Animations.CompositorExtensions : object {
    [ExtensionAttribute]
public static CompositionEasingFunction TryCreateEasingFunction(Compositor compositor, EasingType easingType, EasingMode easingMode);
    [ExtensionAttribute]
public static CubicBezierEasingFunction CreateCubicBezierEasingFunction(Compositor compositor, float x1, float y1, float x2, float y2);
    [ExtensionAttribute]
public static BooleanKeyFrameAnimation CreateBooleanKeyFrameAnimation(Compositor compositor, string target, bool to, Nullable`1<bool> from, Nullable`1<TimeSpan> delay, Nullable`1<TimeSpan> duration, AnimationDelayBehavior delayBehavior, AnimationDirection direction, AnimationIterationBehavior iterationBehavior, int iterationCount);
    [ExtensionAttribute]
public static ScalarKeyFrameAnimation CreateScalarKeyFrameAnimation(Compositor compositor, string target, float to, Nullable`1<float> from, Nullable`1<TimeSpan> delay, Nullable`1<TimeSpan> duration, CompositionEasingFunction easing, AnimationDelayBehavior delayBehavior, AnimationDirection direction, AnimationIterationBehavior iterationBehavior, int iterationCount);
    [ExtensionAttribute]
public static Vector2KeyFrameAnimation CreateVector2KeyFrameAnimation(Compositor compositor, string target, Vector2 to, Nullable`1<Vector2> from, Nullable`1<TimeSpan> delay, Nullable`1<TimeSpan> duration, CompositionEasingFunction easing, AnimationDelayBehavior delayBehavior, AnimationDirection direction, AnimationIterationBehavior iterationBehavior, int iterationCount);
    [ExtensionAttribute]
public static Vector3KeyFrameAnimation CreateVector3KeyFrameAnimation(Compositor compositor, string target, Vector3 to, Nullable`1<Vector3> from, Nullable`1<TimeSpan> delay, Nullable`1<TimeSpan> duration, CompositionEasingFunction easing, AnimationDelayBehavior delayBehavior, AnimationDirection direction, AnimationIterationBehavior iterationBehavior, int iterationCount);
    [ExtensionAttribute]
public static Vector4KeyFrameAnimation CreateVector4KeyFrameAnimation(Compositor compositor, string target, Vector4 to, Nullable`1<Vector4> from, Nullable`1<TimeSpan> delay, Nullable`1<TimeSpan> duration, CompositionEasingFunction easing, AnimationDelayBehavior delayBehavior, AnimationDirection direction, AnimationIterationBehavior iterationBehavior, int iterationCount);
    [ExtensionAttribute]
public static ColorKeyFrameAnimation CreateColorKeyFrameAnimation(Compositor compositor, string target, Color to, Nullable`1<Color> from, Nullable`1<TimeSpan> delay, Nullable`1<TimeSpan> duration, CompositionEasingFunction easing, AnimationDelayBehavior delayBehavior, AnimationDirection direction, AnimationIterationBehavior iterationBehavior, int iterationCount);
    [ExtensionAttribute]
public static QuaternionKeyFrameAnimation CreateQuaternionKeyFrameAnimation(Compositor compositor, string target, Quaternion to, Nullable`1<Quaternion> from, Nullable`1<TimeSpan> delay, Nullable`1<TimeSpan> duration, CompositionEasingFunction easing, AnimationDelayBehavior delayBehavior, AnimationDirection direction, AnimationIterationBehavior iterationBehavior, int iterationCount);
}
[ExtensionAttribute]
public static class Microsoft.Toolkit.Uwp.UI.Animations.Connected : object {
    public static DependencyProperty KeyProperty;
    public static DependencyProperty AnchorElementProperty;
    public static DependencyProperty ListItemKeyProperty;
    public static DependencyProperty ListItemElementNameProperty;
    private static DependencyProperty ConnectedAnimationHelperProperty;
    private static DependencyProperty PageConnectedAnimationPropertiesProperty;
    private static DependencyProperty PageCoordinatedAnimationElementsProperty;
    private static Connected();
    public static string GetKey(DependencyObject obj);
    public static void SetKey(DependencyObject obj, string value);
    public static UIElement GetAnchorElement(DependencyObject obj);
    public static void SetAnchorElement(DependencyObject obj, UIElement value);
    public static string GetListItemKey(DependencyObject obj);
    public static void SetListItemKey(DependencyObject obj, string value);
    public static string GetListItemElementName(DependencyObject obj);
    public static void SetListItemElementName(DependencyObject obj, string value);
    private static ConnectedAnimationHelper GetConnectedAnimationHelper(Frame frame);
    private static void SetConnectedAnimationHelper(Frame frame, ConnectedAnimationHelper value);
    internal static Dictionary`2<string, ConnectedAnimationProperties> GetPageConnectedAnimationProperties(Page page);
    internal static void SetPageConnectedAnimationProperties(Page page, Dictionary`2<string, ConnectedAnimationProperties> value);
    internal static Dictionary`2<UIElement, List`1<UIElement>> GetPageCoordinatedAnimationElements(Page page);
    internal static void SetPageCoordinatedAnimationElements(Page page, Dictionary`2<UIElement, List`1<UIElement>> value);
    [ExtensionAttribute]
public static void RegisterElementForConnectedAnimation(Page page, string key, UIElement element, IEnumerable`1<UIElement> anchors);
    [ExtensionAttribute]
public static void UnregisterElementForConnectedAnimation(Page page, string key);
    [ExtensionAttribute]
public static void AttachAnchorElementForConnectedAnimation(Page page, UIElement element, UIElement anchor);
    [ExtensionAttribute]
public static void RemoveAnchoredElementForConnectedAnimation(Page page, UIElement element, UIElement anchor);
    [ExtensionAttribute]
public static void RegisterListItemForConnectedAnimation(Page page, ListViewBase listViewBase, string key, string elementName);
    [ExtensionAttribute]
public static void UnregisterListItemForConnectedAnimation(Page page, ListViewBase listViewBase, string key);
    [ExtensionAttribute]
public static void SetListDataItemForNextConnectedAnimation(Frame frame, object item);
    private static void OnKeyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnAnchorElementChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnListItemKeyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnListItemElementNameChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void GetParentFrameAndExecuteAction(FrameworkElement element, Action`1<Frame> action);
    private static void AddListViewBaseItemAnimationDetails(Page page, ListViewBase listViewBase);
}
internal class Microsoft.Toolkit.Uwp.UI.Animations.ConnectedAnimationHelper : object {
    private Dictionary`2<string, ConnectedAnimationProperties> _previousPageConnectedAnimationProps;
    private object _nextParameter;
    public ConnectedAnimationHelper(Frame frame);
    internal void SetParameterForNextFrameNavigation(object parameter);
    private void Frame_Navigating(object sender, NavigatingCancelEventArgs e);
    private void Frame_Navigated(object sender, NavigationEventArgs e);
    private void UseDirectConnectedAnimationConfiguration(ConnectedAnimation animation);
}
internal class Microsoft.Toolkit.Uwp.UI.Animations.ConnectedAnimationListProperty : object {
    [CompilerGeneratedAttribute]
private string <ElementName>k__BackingField;
    [CompilerGeneratedAttribute]
private ListViewBase <ListViewBase>k__BackingField;
    public string ElementName { get; public set; }
    public ListViewBase ListViewBase { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ElementName();
    [CompilerGeneratedAttribute]
public void set_ElementName(string value);
    [CompilerGeneratedAttribute]
public ListViewBase get_ListViewBase();
    [CompilerGeneratedAttribute]
public void set_ListViewBase(ListViewBase value);
}
internal class Microsoft.Toolkit.Uwp.UI.Animations.ConnectedAnimationProperties : object {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private UIElement <Element>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ConnectedAnimationListProperty> <ListAnimProperties>k__BackingField;
    public string Key { get; public set; }
    public UIElement Element { get; public set; }
    public List`1<ConnectedAnimationListProperty> ListAnimProperties { get; public set; }
    public bool IsListAnimation { get; }
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(string value);
    [CompilerGeneratedAttribute]
public UIElement get_Element();
    [CompilerGeneratedAttribute]
public void set_Element(UIElement value);
    [CompilerGeneratedAttribute]
public List`1<ConnectedAnimationListProperty> get_ListAnimProperties();
    [CompilerGeneratedAttribute]
public void set_ListAnimProperties(List`1<ConnectedAnimationListProperty> value);
    public bool get_IsListAnimation();
}
[NullableContextAttribute("2")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class Microsoft.Toolkit.Uwp.UI.Animations.CustomAnimation`2 : ImplicitAnimation`2<TValue, TKeyFrame> {
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private FrameworkLayer <Layer>k__BackingField;
    public string Target { get; public set; }
    public FrameworkLayer Layer { get; public set; }
    [NullableAttribute("1")]
protected string ExplicitTarget { get; }
    [CompilerGeneratedAttribute]
public string get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(string value);
    [CompilerGeneratedAttribute]
public FrameworkLayer get_Layer();
    [CompilerGeneratedAttribute]
public void set_Layer(FrameworkLayer value);
    [NullableContextAttribute("1")]
protected virtual string get_ExplicitTarget();
    [NullableContextAttribute("1")]
public virtual AnimationBuilder AppendToBuilder(AnimationBuilder builder, Nullable`1<TimeSpan> delayHint, Nullable`1<TimeSpan> durationHint, Nullable`1<EasingType> easingTypeHint, Nullable`1<EasingMode> easingModeHint);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.Toolkit.Uwp.UI.Animations.DependencyObjectExtensions : object {
    [ExtensionAttribute]
public static DoubleAnimation CreateDoubleAnimation(DependencyObject target, string property, double to, Nullable`1<double> from, Nullable`1<TimeSpan> delay, TimeSpan duration, EasingFunctionBase easing, Nullable`1<RepeatBehavior> repeatBehavior, FillBehavior fillBehavior, bool autoReverse, bool enableDependecyAnimations);
    [ExtensionAttribute]
public static PointAnimation CreatePointAnimation(DependencyObject target, string property, Point to, Nullable`1<Point> from, Nullable`1<TimeSpan> delay, TimeSpan duration, EasingFunctionBase easing, Nullable`1<RepeatBehavior> repeatBehavior, FillBehavior fillBehavior, bool autoReverse, bool enableDependecyAnimations);
    [ExtensionAttribute]
public static ColorAnimation CreateColorAnimation(DependencyObject target, string property, Color to, Nullable`1<Color> from, Nullable`1<TimeSpan> delay, TimeSpan duration, EasingFunctionBase easing, Nullable`1<RepeatBehavior> repeatBehavior, FillBehavior fillBehavior, bool autoReverse);
}
public enum Microsoft.Toolkit.Uwp.UI.Animations.EasingType : Enum {
    public int value__;
    public static EasingType Default;
    public static EasingType Linear;
    public static EasingType Cubic;
    public static EasingType Back;
    public static EasingType Bounce;
    public static EasingType Elastic;
    public static EasingType Circle;
    public static EasingType Quadratic;
    public static EasingType Quartic;
    public static EasingType Quintic;
    public static EasingType Sine;
}
[ExtensionAttribute]
public static class Microsoft.Toolkit.Uwp.UI.Animations.EasingTypeExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static EasingFunctionBase ToEasingFunction(EasingType easingType, EasingMode easingMode);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static EasingFunctionBase <ToEasingFunction>g__ThrowArgumentException|0_0();
}
public static class Microsoft.Toolkit.Uwp.UI.Animations.Explicit : object {
    public static DependencyProperty AnimationsProperty;
    private static Explicit();
    public static AnimationDictionary GetAnimations(UIElement element);
    public static void SetAnimations(UIElement element, AnimationDictionary value);
    private static void OnAnimationsPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
}
public class Microsoft.Toolkit.Uwp.UI.Animations.Expressions.AmbientLightReferenceNode : ReferenceNode {
    public ColorNode Color { get; }
    internal AmbientLightReferenceNode(string paramName, AmbientLight light);
    internal static AmbientLightReferenceNode CreateTargetReference();
    public ColorNode get_Color();
}
public class Microsoft.Toolkit.Uwp.UI.Animations.Expressions.BooleanNode : ExpressionNode {
    private bool _value;
    internal BooleanNode(bool value);
    internal BooleanNode(string paramName);
    internal BooleanNode(string paramName, bool value);
    public static BooleanNode op_Implicit(bool value);
    public static BooleanNode op_Equality(BooleanNode left, BooleanNode right);
    public static BooleanNode op_Inequality(BooleanNode left, BooleanNode right);
    public static BooleanNode op_BitwiseAnd(BooleanNode left, BooleanNode right);
    public static BooleanNode op_BitwiseOr(BooleanNode left, BooleanNode right);
    public static BooleanNode op_LogicalNot(BooleanNode value);
    protected internal virtual string GetValue();
}
public class Microsoft.Toolkit.Uwp.UI.Animations.Expressions.ColorBrushReferenceNode : ReferenceNode {
    public ColorNode Color { get; }
    internal ColorBrushReferenceNode(string paramName, CompositionColorBrush brush);
    internal static ColorBrushReferenceNode CreateTargetReference();
    public ColorNode get_Color();
}
public class Microsoft.Toolkit.Uwp.UI.Animations.Expressions.ColorNode : ExpressionNode {
    private Color _value;
    internal ColorNode(Color value);
    internal ColorNode(string paramName);
    internal ColorNode(string paramName, Color value);
    public static ColorNode op_Implicit(Color value);
    public static BooleanNode op_Equality(ColorNode left, ColorNode right);
    public static BooleanNode op_Inequality(ColorNode left, ColorNode right);
    protected internal virtual string GetValue();
}
[ExtensionAttribute]
public static class Microsoft.Toolkit.Uwp.UI.Animations.Expressions.CompositionExtensions : object {
    [ExtensionAttribute]
public static AmbientLightReferenceNode GetReference(AmbientLight compObj);
    [ExtensionAttribute]
public static ColorBrushReferenceNode GetReference(CompositionColorBrush compObj);
    [ExtensionAttribute]
public static DistantLightReferenceNode GetReference(DistantLight compObj);
    [ExtensionAttribute]
public static DropShadowReferenceNode GetReference(DropShadow compObj);
    [ExtensionAttribute]
public static InsetClipReferenceNode GetReference(InsetClip compObj);
    [ExtensionAttribute]
public static InteractionTrackerReferenceNode GetReference(InteractionTracker compObj);
    [ExtensionAttribute]
public static NineGridBrushReferenceNode GetReference(CompositionNineGridBrush compObj);
    [ExtensionAttribute]
public static PointLightReferenceNode GetReference(PointLight compObj);
    [ExtensionAttribute]
public static PropertySetReferenceNode GetReference(CompositionPropertySet compObj);
    [ExtensionAttribute]
public static SpotLightReferenceNode GetReference(SpotLight compObj);
    [ExtensionAttribute]
public static SurfaceBrushReferenceNode GetReference(CompositionSurfaceBrush compObj);
    [ExtensionAttribute]
public static VisualReferenceNode GetReference(Visual compObj);
    [ExtensionAttribute]
public static T GetSpecializedReference(CompositionPropertySet ps);
    [ExtensionAttribute]
public static void StartAnimation(CompositionObject compObject, string propertyName, ExpressionNode expressionNode);
    [ExtensionAttribute]
public static void InsertExpressionKeyFrame(KeyFrameAnimation keyframeAnimation, float normalizedProgressKey, ExpressionNode expressionNode, CompositionEasingFunction easing);
    [ExtensionAttribute]
public static void SetCondition(InteractionTrackerInertiaRestingValue modifier, ExpressionNode expressionNode);
    [ExtensionAttribute]
public static void SetRestingValue(InteractionTrackerInertiaRestingValue modifier, ExpressionNode expressionNode);
    [ExtensionAttribute]
public static void SetCondition(InteractionTrackerInertiaMotion modifier, ExpressionNode expressionNode);
    [ExtensionAttribute]
public static void SetMotion(InteractionTrackerInertiaMotion modifier, ExpressionNode expressionNode);
    [ExtensionAttribute]
public static void SetCondition(CompositionConditionalValue modifier, ExpressionNode expressionNode);
    [ExtensionAttribute]
public static void SetValue(CompositionConditionalValue modifier, ExpressionNode expressionNode);
    private static ExpressionAnimation CreateExpressionAnimationFromNode(Compositor compositor, ExpressionNode expressionNode);
}
public class Microsoft.Toolkit.Uwp.UI.Animations.Expressions.DistantLightReferenceNode : ReferenceNode {
    public ColorNode Color { get; }
    public Vector3Node Direction { get; }
    internal DistantLightReferenceNode(string paramName, DistantLight light);
    internal static DistantLightReferenceNode CreateTargetReference();
    public ColorNode get_Color();
    public Vector3Node get_Direction();
}
public class Microsoft.Toolkit.Uwp.UI.Animations.Expressions.DropShadowReferenceNode : ReferenceNode {
    public ScalarNode BlurRadius { get; }
    public ScalarNode Opacity { get; }
    public Vector3Node Offset { get; }
    public ColorNode Color { get; }
    internal DropShadowReferenceNode(string paramName, DropShadow source);
    internal static DropShadowReferenceNode CreateTargetReference();
    public ScalarNode get_BlurRadius();
    public ScalarNode get_Opacity();
    public Vector3Node get_Offset();
    public ColorNode get_Color();
}
public static class Microsoft.Toolkit.Uwp.UI.Animations.Expressions.ExpressionFunctions : object {
    private static Dictionary`2<ExpressionNodeType, ExpressionNodeInfo> _expressionNodeInfo;
    private static ExpressionFunctions();
    public static ScalarNode ACos(ScalarNode val);
    public static ScalarNode ASin(ScalarNode val);
    public static ScalarNode ATan(ScalarNode val);
    public static ScalarNode Ceil(ScalarNode val);
    public static ScalarNode Cos(ScalarNode val);
    public static ScalarNode Floor(ScalarNode val);
    public static ScalarNode Ln(ScalarNode val);
    public static ScalarNode Log10(ScalarNode val);
    public static ScalarNode Pow(ScalarNode val1, ScalarNode val2);
    public static ScalarNode Round(ScalarNode val);
    public static ScalarNode Sin(ScalarNode val);
    public static ScalarNode Square(ScalarNode val);
    public static ScalarNode Sqrt(ScalarNode val);
    public static ScalarNode Tan(ScalarNode val);
    public static ScalarNode ToDegrees(ScalarNode val);
    public static ScalarNode ToRadians(ScalarNode val);
    public static ScalarNode Abs(ScalarNode val);
    public static Vector2Node Abs(Vector2Node val);
    public static Vector3Node Abs(Vector3Node val);
    public static Vector4Node Abs(Vector4Node val);
    public static ScalarNode Clamp(ScalarNode val, ScalarNode min, ScalarNode max);
    public static Vector2Node Clamp(Vector2Node val, Vector2Node min, Vector2Node max);
    public static Vector3Node Clamp(Vector3Node val, Vector3Node min, Vector3Node max);
    public static Vector4Node Clamp(Vector4Node val, Vector4Node min, Vector4Node max);
    public static ColorNode ColorLerp(ColorNode val1, ColorNode val2, ScalarNode progress);
    public static ColorNode ColorLerpHsl(ColorNode val1, ColorNode val2, ScalarNode progress);
    public static ColorNode ColorLerpRgb(ColorNode val1, ColorNode val2, ScalarNode progress);
    public static QuaternionNode Concatenate(QuaternionNode val1, QuaternionNode val2);
    public static ScalarNode Distance(ScalarNode val1, ScalarNode val2);
    public static ScalarNode Distance(Vector2Node val1, Vector2Node val2);
    public static ScalarNode Distance(Vector3Node val1, Vector3Node val2);
    public static ScalarNode Distance(Vector4Node val1, Vector4Node val2);
    public static ScalarNode DistanceSquared(ScalarNode val1, ScalarNode val2);
    public static ScalarNode DistanceSquared(Vector2Node val1, Vector2Node val2);
    public static ScalarNode DistanceSquared(Vector3Node val1, Vector3Node val2);
    public static ScalarNode DistanceSquared(Vector4Node val1, Vector4Node val2);
    public static Matrix3x2Node Inverse(Matrix3x2Node val);
    public static Matrix4x4Node Inverse(Matrix4x4Node val);
    public static ScalarNode Length(ScalarNode val);
    public static ScalarNode Length(Vector2Node val);
    public static ScalarNode Length(Vector3Node val);
    public static ScalarNode Length(Vector4Node val);
    public static ScalarNode Length(QuaternionNode val);
    public static ScalarNode LengthSquared(ScalarNode val);
    public static ScalarNode LengthSquared(Vector2Node val);
    public static ScalarNode LengthSquared(Vector3Node val);
    public static ScalarNode LengthSquared(Vector4Node val);
    public static ScalarNode LengthSquared(QuaternionNode val);
    public static ScalarNode Lerp(ScalarNode val1, ScalarNode val2, ScalarNode progress);
    public static Vector2Node Lerp(Vector2Node val1, Vector2Node val2, ScalarNode progress);
    public static Vector3Node Lerp(Vector3Node val1, Vector3Node val2, ScalarNode progress);
    public static Vector4Node Lerp(Vector4Node val1, Vector4Node val2, ScalarNode progress);
    public static ScalarNode Max(ScalarNode val1, ScalarNode val2);
    public static Vector2Node Max(Vector2Node val1, Vector2Node val2);
    public static Vector3Node Max(Vector3Node val1, Vector3Node val2);
    public static Vector4Node Max(Vector4Node val1, Vector4Node val2);
    public static ScalarNode Min(ScalarNode val1, ScalarNode val2);
    public static Vector2Node Min(Vector2Node val1, Vector2Node val2);
    public static Vector3Node Min(Vector3Node val1, Vector3Node val2);
    public static Vector4Node Min(Vector4Node val1, Vector4Node val2);
    public static ScalarNode Mod(ScalarNode val1, ScalarNode val2);
    public static Vector2Node Mod(Vector2Node val1, Vector2Node val2);
    public static Vector3Node Mod(Vector3Node val1, Vector3Node val2);
    public static Vector4Node Mod(Vector4Node val1, Vector4Node val2);
    public static Vector2Node Normalize(Vector2Node val);
    public static Vector3Node Normalize(Vector3Node val);
    public static Vector4Node Normalize(Vector4Node val);
    public static QuaternionNode Normalize(QuaternionNode val);
    public static ScalarNode Scale(ScalarNode val1, ScalarNode val2);
    public static Vector2Node Scale(Vector2Node val1, ScalarNode val2);
    public static Vector3Node Scale(Vector3Node val1, ScalarNode val2);
    public static Vector4Node Scale(Vector4Node val1, ScalarNode val2);
    public static Matrix3x2Node Scale(Matrix3x2Node val1, ScalarNode val2);
    public static Matrix4x4Node Scale(Matrix4x4Node val1, ScalarNode val2);
    public static QuaternionNode Slerp(QuaternionNode val1, QuaternionNode val2, ScalarNode progress);
    public static Vector2Node Transform(Vector2Node val1, Matrix3x2Node val2);
    public static Vector4Node Transform(Vector4Node val1, Matrix4x4Node val2);
    public static Vector2Node Vector2(ScalarNode x, ScalarNode y);
    public static Vector3Node Vector3(ScalarNode x, ScalarNode y, ScalarNode z);
    public static Vector4Node Vector4(ScalarNode x, ScalarNode y, ScalarNode z, ScalarNode w);
    public static ColorNode ColorHsl(ScalarNode h, ScalarNode s, ScalarNode l);
    public static ColorNode ColorRgb(ScalarNode alpha, ScalarNode red, ScalarNode green, ScalarNode blue);
    public static QuaternionNode Quaternion(ScalarNode x, ScalarNode y, ScalarNode z, ScalarNode w);
    public static Matrix3x2Node Matrix3x2(ScalarNode channel11, ScalarNode channel12, ScalarNode channel21, ScalarNode channel22, ScalarNode channel31, ScalarNode channel32);
    public static Matrix4x4Node Matrix4x4(ScalarNode channel11, ScalarNode channel12, ScalarNode channel13, ScalarNode channel14, ScalarNode channel21, ScalarNode channel22, ScalarNode channel23, ScalarNode channel24, ScalarNode channel31, ScalarNode channel32, ScalarNode channel33, ScalarNode channel34, ScalarNode channel41, ScalarNode channel42, ScalarNode channel43, ScalarNode channel44);
    public static Matrix4x4Node Matrix4x4(Matrix3x2Node val);
    public static Matrix3x2Node CreateTranslation(Vector2Node val);
    public static Matrix4x4Node CreateTranslation(Vector3Node val);
    public static Matrix3x2Node CreateScale(Vector2Node val);
    public static Matrix4x4Node CreateScale(Vector3Node val);
    public static Matrix3x2Node CreateSkew(ScalarNode xAngle, ScalarNode yAngle, Vector2Node centerPoint);
    public static Matrix3x2Node CreateRotation(ScalarNode angle);
    public static Matrix4x4Node CreateMatrix4x4FromAxisAngle(Vector3Node axis, ScalarNode angle);
    public static QuaternionNode CreateQuaternionFromAxisAngle(Vector3Node axis, ScalarNode angle);
    public static BooleanNode And(BooleanNode val1, BooleanNode val2);
    public static BooleanNode Or(BooleanNode val1, BooleanNode val2);
    public static BooleanNode Not(BooleanNode val);
    public static ScalarNode Conditional(BooleanNode condition, ScalarNode trueCase, ScalarNode falseCase);
    public static Vector2Node Conditional(BooleanNode condition, Vector2Node trueCase, Vector2Node falseCase);
    public static Vector3Node Conditional(BooleanNode condition, Vector3Node trueCase, Vector3Node falseCase);
    public static Vector4Node Conditional(BooleanNode condition, Vector4Node trueCase, Vector4Node falseCase);
    public static ColorNode Conditional(BooleanNode condition, ColorNode trueCase, ColorNode falseCase);
    public static QuaternionNode Conditional(BooleanNode condition, QuaternionNode trueCase, QuaternionNode falseCase);
    public static Matrix3x2Node Conditional(BooleanNode condition, Matrix3x2Node trueCase, Matrix3x2Node falseCase);
    public static Matrix4x4Node Conditional(BooleanNode condition, Matrix4x4Node trueCase, Matrix4x4Node falseCase);
    internal static T Function(ExpressionNodeType nodeType, ExpressionNode[] expressionFunctionParams);
    internal static ExpressionNodeInfo GetNodeInfoFromType(ExpressionNodeType type);
}
public abstract class Microsoft.Toolkit.Uwp.UI.Animations.Expressions.ExpressionNode : object {
    private List`1<ReferenceInfo> _objRefList;
    private Dictionary`2<CompositionObject, string> _compObjToParamNameMap;
    private Dictionary`2<string, object> _constParamMap;
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionNodeType <NodeType>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ExpressionNode> <Children>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ParamName>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionAnimation <ExpressionAnimation>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Subchannels>k__BackingField;
    internal string PropertyName { get; internal set; }
    internal ExpressionNodeType NodeType { get; internal set; }
    internal List`1<ExpressionNode> Children { get; internal set; }
    internal string ParamName { get; internal set; }
    internal ExpressionAnimation ExpressionAnimation { get; internal set; }
    protected internal String[] Subchannels { get; protected internal set; }
    public void SetReferenceParameter(string parameterName, CompositionObject compObj);
    public void SetBooleanParameter(string parameterName, bool value);
    public void SetScalarParameter(string parameterName, float value);
    public void SetVector2Parameter(string parameterName, Vector2 value);
    public void SetVector3Parameter(string parameterName, Vector3 value);
    public void SetVector4Parameter(string parameterName, Vector4 value);
    public void SetColorParameter(string parameterName, Color value);
    public void SetQuaternionParameter(string parameterName, Quaternion value);
    public void SetMatrix3x2Parameter(string parameterName, Matrix3x2 value);
    public void SetMatrix4x4Parameter(string parameterName, Matrix4x4 value);
    public sealed virtual void Dispose();
    internal static T CreateExpressionNode();
    internal static T CreateValueKeyword(ValueKeywordKind keywordKind);
    internal string ToExpressionString();
    internal void ClearReferenceInfo();
    internal void EnsureReferenceInfo();
    internal void SetAllParameters(CompositionAnimation animation);
    protected internal abstract virtual string GetValue();
    protected internal T SubchannelsInternal(String[] subchannels);
    protected internal void PopulateParameterNodes(Dictionary`2& constParamMap, HashSet`1& referenceNodes);
    private OperationType GetOperationKind();
    private string GetOperationString();
    private string ToExpressionStringInternal();
    [CompilerGeneratedAttribute]
internal string get_PropertyName();
    [CompilerGeneratedAttribute]
internal void set_PropertyName(string value);
    [CompilerGeneratedAttribute]
internal ExpressionNodeType get_NodeType();
    [CompilerGeneratedAttribute]
internal void set_NodeType(ExpressionNodeType value);
    [CompilerGeneratedAttribute]
internal List`1<ExpressionNode> get_Children();
    [CompilerGeneratedAttribute]
internal void set_Children(List`1<ExpressionNode> value);
    [CompilerGeneratedAttribute]
internal string get_ParamName();
    [CompilerGeneratedAttribute]
internal void set_ParamName(string value);
    [CompilerGeneratedAttribute]
internal ExpressionAnimation get_ExpressionAnimation();
    [CompilerGeneratedAttribute]
internal void set_ExpressionAnimation(ExpressionAnimation value);
    [CompilerGeneratedAttribute]
protected internal String[] get_Subchannels();
    [CompilerGeneratedAttribute]
protected internal void set_Subchannels(String[] value);
    [CompilerGeneratedAttribute]
[SkipLocalsInitAttribute]
internal static string <EnsureReferenceInfo>g__CreateUniqueParamNameFromIndex|19_0(UInt32 i);
}
internal enum Microsoft.Toolkit.Uwp.UI.Animations.Expressions.ExpressionNodeType : Enum {
    public int value__;
    public static ExpressionNodeType ConstantValue;
    public static ExpressionNodeType ConstantParameter;
    public static ExpressionNodeType CurrentValueProperty;
    public static ExpressionNodeType Reference;
    public static ExpressionNodeType ReferenceProperty;
    public static ExpressionNodeType StartingValueProperty;
    public static ExpressionNodeType TargetReference;
    public static ExpressionNodeType Conditional;
    public static ExpressionNodeType Swizzle;
    public static ExpressionNodeType Add;
    public static ExpressionNodeType And;
    public static ExpressionNodeType Divide;
    public static ExpressionNodeType Equals;
    public static ExpressionNodeType GreaterThan;
    public static ExpressionNodeType GreaterThanEquals;
    public static ExpressionNodeType LessThan;
    public static ExpressionNodeType LessThanEquals;
    public static ExpressionNodeType Multiply;
    public static ExpressionNodeType Not;
    public static ExpressionNodeType NotEquals;
    public static ExpressionNodeType Or;
    public static ExpressionNodeType Subtract;
    public static ExpressionNodeType Absolute;
    public static ExpressionNodeType Acos;
    public static ExpressionNodeType Asin;
    public static ExpressionNodeType Atan;
    public static ExpressionNodeType Cos;
    public static ExpressionNodeType Ceil;
    public static ExpressionNodeType Clamp;
    public static ExpressionNodeType ColorHsl;
    public static ExpressionNodeType ColorRgb;
    public static ExpressionNodeType ColorLerp;
    public static ExpressionNodeType ColorLerpHsl;
    public static ExpressionNodeType ColorLerpRgb;
    public static ExpressionNodeType Concatenate;
    public static ExpressionNodeType Distance;
    public static ExpressionNodeType DistanceSquared;
    public static ExpressionNodeType Floor;
    public static ExpressionNodeType Inverse;
    public static ExpressionNodeType Length;
    public static ExpressionNodeType LengthSquared;
    public static ExpressionNodeType Lerp;
    public static ExpressionNodeType Ln;
    public static ExpressionNodeType Log10;
    public static ExpressionNodeType Max;
    public static ExpressionNodeType Matrix3x2FromRotation;
    public static ExpressionNodeType Matrix3x2FromScale;
    public static ExpressionNodeType Matrix3x2FromSkew;
    public static ExpressionNodeType Matrix3x2FromTranslation;
    public static ExpressionNodeType Matrix3x2;
    public static ExpressionNodeType Matrix4x4FromAxisAngle;
    public static ExpressionNodeType Matrix4x4FromScale;
    public static ExpressionNodeType Matrix4x4FromTranslation;
    public static ExpressionNodeType Matrix4x4;
    public static ExpressionNodeType Min;
    public static ExpressionNodeType Modulus;
    public static ExpressionNodeType Negate;
    public static ExpressionNodeType Normalize;
    public static ExpressionNodeType Pow;
    public static ExpressionNodeType QuaternionFromAxisAngle;
    public static ExpressionNodeType Quaternion;
    public static ExpressionNodeType Round;
    public static ExpressionNodeType Scale;
    public static ExpressionNodeType Sin;
    public static ExpressionNodeType Slerp;
    public static ExpressionNodeType Sqrt;
    public static ExpressionNodeType Square;
    public static ExpressionNodeType Tan;
    public static ExpressionNodeType ToDegrees;
    public static ExpressionNodeType ToRadians;
    public static ExpressionNodeType Transform;
    public static ExpressionNodeType Vector2;
    public static ExpressionNodeType Vector3;
    public static ExpressionNodeType Vector4;
    public static ExpressionNodeType Count;
}
public static class Microsoft.Toolkit.Uwp.UI.Animations.Expressions.ExpressionValues : object {
}
public class Microsoft.Toolkit.Uwp.UI.Animations.Expressions.InsetClipReferenceNode : ReferenceNode {
    public ScalarNode BottomInset { get; }
    public ScalarNode LeftInset { get; }
    public ScalarNode RightInset { get; }
    public ScalarNode TopInset { get; }
    public ScalarNode RotationAngle { get; }
    public ScalarNode RotationAngleInDegrees { get; }
    public Vector2Node AnchorPoint { get; }
    public Vector2Node CenterPoint { get; }
    public Vector2Node Offset { get; }
    public Vector2Node Scale { get; }
    public Matrix3x2Node TransformMatrix { get; }
    internal InsetClipReferenceNode(string paramName, InsetClip ic);
    internal static InsetClipReferenceNode CreateTargetReference();
    public ScalarNode get_BottomInset();
    public ScalarNode get_LeftInset();
    public ScalarNode get_RightInset();
    public ScalarNode get_TopInset();
    public ScalarNode get_RotationAngle();
    public ScalarNode get_RotationAngleInDegrees();
    public Vector2Node get_AnchorPoint();
    public Vector2Node get_CenterPoint();
    public Vector2Node get_Offset();
    public Vector2Node get_Scale();
    public Matrix3x2Node get_TransformMatrix();
}
public class Microsoft.Toolkit.Uwp.UI.Animations.Expressions.InteractionTrackerReferenceNode : ReferenceNode {
    public BooleanNode IsPositionRoundingSuggested { get; }
    public ScalarNode MinScale { get; }
    public ScalarNode MaxScale { get; }
    public ScalarNode NaturalRestingScale { get; }
    public ScalarNode Scale { get; }
    public ScalarNode ScaleInertiaDecayRate { get; }
    public ScalarNode ScaleVelocityInPercentPerSecond { get; }
    public Vector3Node MinPosition { get; }
    public Vector3Node MaxPosition { get; }
    public Vector3Node NaturalRestingPosition { get; }
    public Vector3Node Position { get; }
    public Vector3Node PositionInertiaDecayRate { get; }
    public Vector3Node PositionVelocityInPixelsPerSecond { get; }
    internal InteractionTrackerReferenceNode(string paramName, InteractionTracker it);
    internal static InteractionTrackerReferenceNode CreateTargetReference();
    public BooleanNode get_IsPositionRoundingSuggested();
    public ScalarNode get_MinScale();
    public ScalarNode get_MaxScale();
    public ScalarNode get_NaturalRestingScale();
    public ScalarNode get_Scale();
    public ScalarNode get_ScaleInertiaDecayRate();
    public ScalarNode get_ScaleVelocityInPercentPerSecond();
    public Vector3Node get_MinPosition();
    public Vector3Node get_MaxPosition();
    public Vector3Node get_NaturalRestingPosition();
    public Vector3Node get_Position();
    public Vector3Node get_PositionInertiaDecayRate();
    public Vector3Node get_PositionVelocityInPixelsPerSecond();
}
public class Microsoft.Toolkit.Uwp.UI.Animations.Expressions.ManipulationPropertySetReferenceNode : PropertySetReferenceNode {
    public Vector3Node CenterPoint { get; }
    public Vector3Node Pan { get; }
    public Vector3Node Scale { get; }
    public Vector3Node Translation { get; }
    public Matrix4x4Node Matrix { get; }
    internal ManipulationPropertySetReferenceNode(string paramName, CompositionPropertySet ps);
    public Vector3Node get_CenterPoint();
    public Vector3Node get_Pan();
    public Vector3Node get_Scale();
    public Vector3Node get_Translation();
    public Matrix4x4Node get_Matrix();
}
public class Microsoft.Toolkit.Uwp.UI.Animations.Expressions.Matrix3x2Node : ExpressionNode {
    private Matrix3x2 _value;
    public ScalarNode Channel11 { get; }
    public ScalarNode Channel12 { get; }
    public ScalarNode Channel21 { get; }
    public ScalarNode Channel22 { get; }
    public ScalarNode Channel31 { get; }
    public ScalarNode Channel32 { get; }
    internal Matrix3x2Node(Matrix3x2 value);
    internal Matrix3x2Node(string paramName);
    internal Matrix3x2Node(string paramName, Matrix3x2 value);
    public static Matrix3x2Node op_Implicit(Matrix3x2 value);
    public static Matrix3x2Node op_Addition(Matrix3x2Node left, Matrix3x2Node right);
    public static Matrix3x2Node op_Subtraction(Matrix3x2Node left, Matrix3x2Node right);
    public static Matrix3x2Node op_UnaryNegation(Matrix3x2Node value);
    public static Matrix3x2Node op_Multiply(Matrix3x2Node left, ScalarNode right);
    public static Matrix3x2Node op_Multiply(Matrix3x2Node left, Matrix3x2Node right);
    public static BooleanNode op_Equality(Matrix3x2Node left, Matrix3x2Node right);
    public static BooleanNode op_Inequality(Matrix3x2Node left, Matrix3x2Node right);
    public ScalarNode get_Channel11();
    public ScalarNode get_Channel12();
    public ScalarNode get_Channel21();
    public ScalarNode get_Channel22();
    public ScalarNode get_Channel31();
    public ScalarNode get_Channel32();
    public ScalarNode GetSubchannels(Subchannel s);
    public Vector2Node GetSubchannels(Subchannel s1, Subchannel s2);
    public Vector3Node GetSubchannels(Subchannel s1, Subchannel s2, Subchannel s3);
    public Vector4Node GetSubchannels(Subchannel s1, Subchannel s2, Subchannel s3, Subchannel s4);
    public Matrix3x2Node GetSubchannels(Subchannel s1, Subchannel s2, Subchannel s3, Subchannel s4, Subchannel s5, Subchannel s6);
    public Matrix4x4Node GetSubchannels(Subchannel s1, Subchannel s2, Subchannel s3, Subchannel s4, Subchannel s5, Subchannel s6, Subchannel s7, Subchannel s8, Subchannel s9, Subchannel s10, Subchannel s11, Subchannel s12, Subchannel s13, Subchannel s14, Subchannel s15, Subchannel s16);
    protected internal virtual string GetValue();
}
public class Microsoft.Toolkit.Uwp.UI.Animations.Expressions.Matrix4x4Node : ExpressionNode {
    private Matrix4x4 _value;
    public ScalarNode Channel11 { get; }
    public ScalarNode Channel12 { get; }
    public ScalarNode Channel13 { get; }
    public ScalarNode Channel14 { get; }
    public ScalarNode Channel21 { get; }
    public ScalarNode Channel22 { get; }
    public ScalarNode Channel23 { get; }
    public ScalarNode Channel24 { get; }
    public ScalarNode Channel31 { get; }
    public ScalarNode Channel32 { get; }
    public ScalarNode Channel33 { get; }
    public ScalarNode Channel34 { get; }
    public ScalarNode Channel41 { get; }
    public ScalarNode Channel42 { get; }
    public ScalarNode Channel43 { get; }
    public ScalarNode Channel44 { get; }
    public Vector3Node Channel11Channel22Channel33 { get; }
    public Vector3Node Channel41Channel42Channel43 { get; }
    internal Matrix4x4Node(Matrix4x4 value);
    internal Matrix4x4Node(string paramName);
    internal Matrix4x4Node(string paramName, Matrix4x4 value);
    public static Matrix4x4Node op_Implicit(Matrix4x4 value);
    public static Matrix4x4Node op_Addition(Matrix4x4Node left, Matrix4x4Node right);
    public static Matrix4x4Node op_Subtraction(Matrix4x4Node left, Matrix4x4Node right);
    public static Matrix4x4Node op_UnaryNegation(Matrix4x4Node value);
    public static Matrix4x4Node op_Multiply(Matrix4x4Node left, ScalarNode right);
    public static Matrix4x4Node op_Multiply(Matrix4x4Node left, Matrix4x4Node right);
    public static BooleanNode op_Equality(Matrix4x4Node left, Matrix4x4Node right);
    public static BooleanNode op_Inequality(Matrix4x4Node left, Matrix4x4Node right);
    public ScalarNode get_Channel11();
    public ScalarNode get_Channel12();
    public ScalarNode get_Channel13();
    public ScalarNode get_Channel14();
    public ScalarNode get_Channel21();
    public ScalarNode get_Channel22();
    public ScalarNode get_Channel23();
    public ScalarNode get_Channel24();
    public ScalarNode get_Channel31();
    public ScalarNode get_Channel32();
    public ScalarNode get_Channel33();
    public ScalarNode get_Channel34();
    public ScalarNode get_Channel41();
    public ScalarNode get_Channel42();
    public ScalarNode get_Channel43();
    public ScalarNode get_Channel44();
    public Vector3Node get_Channel11Channel22Channel33();
    public Vector3Node get_Channel41Channel42Channel43();
    public ScalarNode GetSubchannels(Subchannel s);
    public Vector2Node GetSubchannels(Subchannel s1, Subchannel s2);
    public Vector3Node GetSubchannels(Subchannel s1, Subchannel s2, Subchannel s3);
    public Vector4Node GetSubchannels(Subchannel s1, Subchannel s2, Subchannel s3, Subchannel s4);
    public Matrix3x2Node GetSubchannels(Subchannel s1, Subchannel s2, Subchannel s3, Subchannel s4, Subchannel s5, Subchannel s6);
    public Matrix4x4Node GetSubchannels(Subchannel s1, Subchannel s2, Subchannel s3, Subchannel s4, Subchannel s5, Subchannel s6, Subchannel s7, Subchannel s8, Subchannel s9, Subchannel s10, Subchannel s11, Subchannel s12, Subchannel s13, Subchannel s14, Subchannel s15, Subchannel s16);
    protected internal virtual string GetValue();
}
public class Microsoft.Toolkit.Uwp.UI.Animations.Expressions.NineGridBrushReferenceNode : ReferenceNode {
    public ScalarNode BottomInset { get; }
    public ScalarNode BottomInsetScale { get; }
    public ScalarNode LeftInset { get; }
    public ScalarNode LeftInsetScale { get; }
    public ScalarNode RightInset { get; }
    public ScalarNode RightInsetScale { get; }
    public ScalarNode TopInset { get; }
    public ScalarNode TopInsetScale { get; }
    internal NineGridBrushReferenceNode(string paramName, CompositionNineGridBrush brush);
    internal static NineGridBrushReferenceNode CreateTargetReference();
    public ScalarNode get_BottomInset();
    public ScalarNode get_BottomInsetScale();
    public ScalarNode get_LeftInset();
    public ScalarNode get_LeftInsetScale();
    public ScalarNode get_RightInset();
    public ScalarNode get_RightInsetScale();
    public ScalarNode get_TopInset();
    public ScalarNode get_TopInsetScale();
}
internal enum Microsoft.Toolkit.Uwp.UI.Animations.Expressions.OperationType : Enum {
    public int value__;
    public static OperationType Function;
    public static OperationType Operator;
    public static OperationType UnaryOperator;
    public static OperationType Constant;
    public static OperationType Reference;
    public static OperationType Conditional;
    public static OperationType Swizzle;
}
public class Microsoft.Toolkit.Uwp.UI.Animations.Expressions.PointerPositionPropertySetReferenceNode : PropertySetReferenceNode {
    public Vector3Node Position { get; }
    internal PointerPositionPropertySetReferenceNode(string paramName, CompositionPropertySet ps);
    public Vector3Node get_Position();
}
public class Microsoft.Toolkit.Uwp.UI.Animations.Expressions.PointLightReferenceNode : ReferenceNode {
    public ScalarNode ConstantAttenuation { get; }
    public ScalarNode LinearAttenuation { get; }
    public ScalarNode QuadraticAttentuation { get; }
    public ColorNode Color { get; }
    public Vector3Node Direction { get; }
    public Vector3Node Offset { get; }
    internal PointLightReferenceNode(string paramName, PointLight light);
    internal static PointLightReferenceNode CreateTargetReference();
    public ScalarNode get_ConstantAttenuation();
    public ScalarNode get_LinearAttenuation();
    public ScalarNode get_QuadraticAttentuation();
    public ColorNode get_Color();
    public Vector3Node get_Direction();
    public Vector3Node get_Offset();
}
public class Microsoft.Toolkit.Uwp.UI.Animations.Expressions.PropertySetReferenceNode : ReferenceNode {
    [CompilerGeneratedAttribute]
private CompositionPropertySet <Source>k__BackingField;
    internal CompositionPropertySet Source { get; internal set; }
    internal PropertySetReferenceNode(string paramName, CompositionPropertySet ps);
    [CompilerGeneratedAttribute]
internal CompositionPropertySet get_Source();
    [CompilerGeneratedAttribute]
internal void set_Source(CompositionPropertySet value);
    internal static PropertySetReferenceNode CreateTargetReference();
}
public class Microsoft.Toolkit.Uwp.UI.Animations.Expressions.QuaternionNode : ExpressionNode {
    private Quaternion _value;
    internal QuaternionNode(Quaternion value);
    internal QuaternionNode(string paramName);
    internal QuaternionNode(string paramName, Quaternion value);
    public static QuaternionNode op_Implicit(Quaternion value);
    public static QuaternionNode op_Multiply(QuaternionNode left, ScalarNode right);
    public static QuaternionNode op_Multiply(QuaternionNode left, QuaternionNode right);
    public static QuaternionNode op_Division(QuaternionNode left, QuaternionNode right);
    public static BooleanNode op_Equality(QuaternionNode left, QuaternionNode right);
    public static BooleanNode op_Inequality(QuaternionNode left, QuaternionNode right);
    protected internal virtual string GetValue();
}
public abstract class Microsoft.Toolkit.Uwp.UI.Animations.Expressions.ReferenceNode : ExpressionNode {
    [CompilerGeneratedAttribute]
private CompositionObject <Reference>k__BackingField;
    public CompositionObject Reference { get; private set; }
    internal ReferenceNode(string paramName, CompositionObject compObj);
    [CompilerGeneratedAttribute]
public CompositionObject get_Reference();
    [CompilerGeneratedAttribute]
private void set_Reference(CompositionObject value);
    public BooleanNode GetBooleanProperty(string propertyName);
    public ScalarNode GetScalarProperty(string propertyName);
    public Vector2Node GetVector2Property(string propertyName);
    public Vector3Node GetVector3Property(string propertyName);
    public Vector4Node GetVector4Property(string propertyName);
    public ColorNode GetColorProperty(string propertyName);
    public QuaternionNode GetQuaternionProperty(string propertyName);
    public Matrix3x2Node GetMatrix3x2Property(string propertyName);
    public Matrix4x4Node GetMatrix4x4Property(string propertyName);
    internal string GetReferenceParamString();
    protected internal T ReferenceProperty(string propertyName);
    protected internal virtual string GetValue();
}
public class Microsoft.Toolkit.Uwp.UI.Animations.Expressions.ScalarNode : ExpressionNode {
    private float _value;
    internal ScalarNode(float value);
    internal ScalarNode(string paramName);
    internal ScalarNode(string paramName, float value);
    public static ScalarNode op_Implicit(float value);
    public static ScalarNode op_Implicit(int value);
    public static ScalarNode op_Addition(ScalarNode left, ScalarNode right);
    public static ScalarNode op_Subtraction(ScalarNode left, ScalarNode right);
    public static ScalarNode op_UnaryNegation(ScalarNode value);
    public static ScalarNode op_Multiply(ScalarNode left, ScalarNode right);
    public static Vector2Node op_Multiply(ScalarNode left, Vector2Node right);
    public static Vector3Node op_Multiply(ScalarNode left, Vector3Node right);
    public static Vector4Node op_Multiply(ScalarNode left, Vector4Node right);
    public static Matrix4x4Node op_Multiply(ScalarNode left, Matrix4x4Node right);
    public static ScalarNode op_Division(ScalarNode left, ScalarNode right);
    public static ScalarNode op_Modulus(ScalarNode left, ScalarNode right);
    public static BooleanNode op_Equality(ScalarNode left, ScalarNode right);
    public static BooleanNode op_Inequality(ScalarNode left, ScalarNode right);
    public static BooleanNode op_LessThanOrEqual(ScalarNode left, ScalarNode right);
    public static BooleanNode op_LessThan(ScalarNode left, ScalarNode right);
    public static BooleanNode op_GreaterThanOrEqual(ScalarNode left, ScalarNode right);
    public static BooleanNode op_GreaterThan(ScalarNode left, ScalarNode right);
    protected internal virtual string GetValue();
}
public class Microsoft.Toolkit.Uwp.UI.Animations.Expressions.SpotLightReferenceNode : ReferenceNode {
    public ScalarNode ConstantAttenuation { get; }
    public ScalarNode LinearAttenuation { get; }
    public ScalarNode QuadraticAttentuation { get; }
    public ScalarNode InnerConeAngle { get; }
    public ScalarNode InnerConeAngleInDegrees { get; }
    public ScalarNode OuterConeAngle { get; }
    public ScalarNode OuterConeAngleInDegrees { get; }
    public ColorNode Color { get; }
    public ColorNode InnerConeColor { get; }
    public ColorNode OuterConeColor { get; }
    public Vector3Node Direction { get; }
    public Vector3Node Offset { get; }
    internal SpotLightReferenceNode(string paramName, SpotLight light);
    internal static SpotLightReferenceNode CreateTargetReference();
    public ScalarNode get_ConstantAttenuation();
    public ScalarNode get_LinearAttenuation();
    public ScalarNode get_QuadraticAttentuation();
    public ScalarNode get_InnerConeAngle();
    public ScalarNode get_InnerConeAngleInDegrees();
    public ScalarNode get_OuterConeAngle();
    public ScalarNode get_OuterConeAngleInDegrees();
    public ColorNode get_Color();
    public ColorNode get_InnerConeColor();
    public ColorNode get_OuterConeColor();
    public Vector3Node get_Direction();
    public Vector3Node get_Offset();
}
public class Microsoft.Toolkit.Uwp.UI.Animations.Expressions.SurfaceBrushReferenceNode : ReferenceNode {
    public ScalarNode HorizontalAlignmentRatio { get; }
    public ScalarNode VerticalAlignmentRatio { get; }
    public ScalarNode BottomInset { get; }
    public ScalarNode LeftInset { get; }
    public ScalarNode RightInset { get; }
    public ScalarNode TopInset { get; }
    public ScalarNode RotationAngle { get; }
    public ScalarNode RotationAngleInDegrees { get; }
    public Vector2Node AnchorPoint { get; }
    public Vector2Node CenterPoint { get; }
    public Vector2Node Offset { get; }
    public Vector2Node Scale { get; }
    public Matrix3x2Node TransformMatrix { get; }
    internal SurfaceBrushReferenceNode(string paramName, CompositionSurfaceBrush brush);
    internal static SurfaceBrushReferenceNode CreateTargetReference();
    public ScalarNode get_HorizontalAlignmentRatio();
    public ScalarNode get_VerticalAlignmentRatio();
    public ScalarNode get_BottomInset();
    public ScalarNode get_LeftInset();
    public ScalarNode get_RightInset();
    public ScalarNode get_TopInset();
    public ScalarNode get_RotationAngle();
    public ScalarNode get_RotationAngleInDegrees();
    public Vector2Node get_AnchorPoint();
    public Vector2Node get_CenterPoint();
    public Vector2Node get_Offset();
    public Vector2Node get_Scale();
    public Matrix3x2Node get_TransformMatrix();
}
internal enum Microsoft.Toolkit.Uwp.UI.Animations.Expressions.ValueKeywordKind : Enum {
    public int value__;
    public static ValueKeywordKind CurrentValue;
    public static ValueKeywordKind StartingValue;
}
public class Microsoft.Toolkit.Uwp.UI.Animations.Expressions.Vector2Node : ExpressionNode {
    private Vector2 _value;
    public ScalarNode X { get; }
    public ScalarNode Y { get; }
    internal Vector2Node(Vector2 value);
    internal Vector2Node(string paramName);
    internal Vector2Node(string paramName, Vector2 value);
    public static Vector2Node op_Implicit(Vector2 value);
    public static Vector2Node op_Addition(Vector2Node left, Vector2Node right);
    public static Vector2Node op_Subtraction(Vector2Node left, Vector2Node right);
    public static Vector2Node op_UnaryNegation(Vector2Node value);
    public static Vector2Node op_Multiply(Vector2Node left, ScalarNode right);
    public static Vector2Node op_Multiply(Vector2Node left, Vector2Node right);
    public static Vector2Node op_Division(Vector2Node left, Vector2Node right);
    public static Vector2Node op_Modulus(Vector2Node left, Vector2Node right);
    public static BooleanNode op_Equality(Vector2Node left, Vector2Node right);
    public static BooleanNode op_Inequality(Vector2Node left, Vector2Node right);
    public ScalarNode get_X();
    public ScalarNode get_Y();
    public ScalarNode GetSubchannels(Subchannel s);
    public Vector2Node GetSubchannels(Subchannel s1, Subchannel s2);
    public Vector3Node GetSubchannels(Subchannel s1, Subchannel s2, Subchannel s3);
    public Vector4Node GetSubchannels(Subchannel s1, Subchannel s2, Subchannel s3, Subchannel s4);
    public Matrix3x2Node GetSubchannels(Subchannel s1, Subchannel s2, Subchannel s3, Subchannel s4, Subchannel s5, Subchannel s6);
    public Matrix4x4Node GetSubchannels(Subchannel s1, Subchannel s2, Subchannel s3, Subchannel s4, Subchannel s5, Subchannel s6, Subchannel s7, Subchannel s8, Subchannel s9, Subchannel s10, Subchannel s11, Subchannel s12, Subchannel s13, Subchannel s14, Subchannel s15, Subchannel s16);
    protected internal virtual string GetValue();
}
public class Microsoft.Toolkit.Uwp.UI.Animations.Expressions.Vector3Node : ExpressionNode {
    private Vector3 _value;
    public ScalarNode X { get; }
    public ScalarNode Y { get; }
    public ScalarNode Z { get; }
    public Vector2Node XY { get; }
    internal Vector3Node(Vector3 value);
    internal Vector3Node(string paramName);
    internal Vector3Node(string paramName, Vector3 value);
    public static Vector3Node op_Implicit(Vector3 value);
    public static Vector3Node op_Addition(Vector3Node left, Vector3Node right);
    public static Vector3Node op_Subtraction(Vector3Node left, Vector3Node right);
    public static Vector3Node op_UnaryNegation(Vector3Node value);
    public static Vector3Node op_Multiply(Vector3Node left, ScalarNode right);
    public static Vector3Node op_Multiply(Vector3Node left, Vector3Node right);
    public static Vector3Node op_Division(Vector3Node left, Vector3Node right);
    public static Vector3Node op_Modulus(Vector3Node left, Vector3Node right);
    public static BooleanNode op_Equality(Vector3Node left, Vector3Node right);
    public static BooleanNode op_Inequality(Vector3Node left, Vector3Node right);
    public ScalarNode get_X();
    public ScalarNode get_Y();
    public ScalarNode get_Z();
    public Vector2Node get_XY();
    public ScalarNode GetSubchannels(Subchannel s);
    public Vector2Node GetSubchannels(Subchannel s1, Subchannel s2);
    public Vector3Node GetSubchannels(Subchannel s1, Subchannel s2, Subchannel s3);
    public Vector4Node GetSubchannels(Subchannel s1, Subchannel s2, Subchannel s3, Subchannel s4);
    public Matrix3x2Node GetSubchannels(Subchannel s1, Subchannel s2, Subchannel s3, Subchannel s4, Subchannel s5, Subchannel s6);
    public Matrix4x4Node GetSubchannels(Subchannel s1, Subchannel s2, Subchannel s3, Subchannel s4, Subchannel s5, Subchannel s6, Subchannel s7, Subchannel s8, Subchannel s9, Subchannel s10, Subchannel s11, Subchannel s12, Subchannel s13, Subchannel s14, Subchannel s15, Subchannel s16);
    protected internal virtual string GetValue();
}
public class Microsoft.Toolkit.Uwp.UI.Animations.Expressions.Vector4Node : ExpressionNode {
    private Vector4 _value;
    public ScalarNode X { get; }
    public ScalarNode Y { get; }
    public ScalarNode Z { get; }
    public ScalarNode W { get; }
    public Vector2Node XY { get; }
    public Vector3Node XYZ { get; }
    internal Vector4Node(Vector4 value);
    internal Vector4Node(string paramName);
    internal Vector4Node(string paramName, Vector4 value);
    public static Vector4Node op_Implicit(Vector4 value);
    public static Vector4Node op_Addition(Vector4Node left, Vector4Node right);
    public static Vector4Node op_Subtraction(Vector4Node left, Vector4Node right);
    public static Vector4Node op_UnaryNegation(Vector4Node value);
    public static Vector4Node op_Multiply(Vector4Node left, ScalarNode right);
    public static Vector4Node op_Multiply(Vector4Node left, Vector4Node right);
    public static Vector4Node op_Division(Vector4Node left, Vector4Node right);
    public static Vector4Node op_Modulus(Vector4Node left, Vector4Node right);
    public static BooleanNode op_Equality(Vector4Node left, Vector4Node right);
    public static BooleanNode op_Inequality(Vector4Node left, Vector4Node right);
    public ScalarNode get_X();
    public ScalarNode get_Y();
    public ScalarNode get_Z();
    public ScalarNode get_W();
    public Vector2Node get_XY();
    public Vector3Node get_XYZ();
    public ScalarNode GetSubchannels(Subchannel s);
    public Vector2Node GetSubchannels(Subchannel s1, Subchannel s2);
    public Vector3Node GetSubchannels(Subchannel s1, Subchannel s2, Subchannel s3);
    public Vector4Node GetSubchannels(Subchannel s1, Subchannel s2, Subchannel s3, Subchannel s4);
    public Matrix3x2Node GetSubchannels(Subchannel s1, Subchannel s2, Subchannel s3, Subchannel s4, Subchannel s5, Subchannel s6);
    public Matrix4x4Node GetSubchannels(Subchannel s1, Subchannel s2, Subchannel s3, Subchannel s4, Subchannel s5, Subchannel s6, Subchannel s7, Subchannel s8, Subchannel s9, Subchannel s10, Subchannel s11, Subchannel s12, Subchannel s13, Subchannel s14, Subchannel s15, Subchannel s16);
    protected internal virtual string GetValue();
}
public class Microsoft.Toolkit.Uwp.UI.Animations.Expressions.VisualReferenceNode : ReferenceNode {
    public ScalarNode Opacity { get; }
    public ScalarNode RotationAngle { get; }
    public ScalarNode RotationAngleInDegrees { get; }
    public Vector2Node AnchorPoint { get; }
    public Vector2Node RelativeSize { get; }
    public Vector2Node Size { get; }
    public Vector3Node CenterPoint { get; }
    public Vector3Node Offset { get; }
    public Vector3Node RelativeOffset { get; }
    public Vector3Node RotationAxis { get; }
    public Vector3Node Scale { get; }
    public Vector3Node Translation { get; }
    public QuaternionNode Orientation { get; }
    public Matrix4x4Node TransformMatrix { get; }
    internal VisualReferenceNode(string paramName, Visual v);
    internal static VisualReferenceNode CreateTargetReference();
    public ScalarNode get_Opacity();
    public ScalarNode get_RotationAngle();
    public ScalarNode get_RotationAngleInDegrees();
    public Vector2Node get_AnchorPoint();
    public Vector2Node get_RelativeSize();
    public Vector2Node get_Size();
    public Vector3Node get_CenterPoint();
    public Vector3Node get_Offset();
    public Vector3Node get_RelativeOffset();
    public Vector3Node get_RotationAxis();
    public Vector3Node get_Scale();
    public Vector3Node get_Translation();
    public QuaternionNode get_Orientation();
    public Matrix4x4Node get_TransformMatrix();
}
[ExtensionAttribute]
internal static class Microsoft.Toolkit.Uwp.UI.Animations.FloatExtensions : object {
    [ExtensionAttribute]
public static string ToCompositionString(float number);
}
public enum Microsoft.Toolkit.Uwp.UI.Animations.FrameworkLayer : Enum {
    public int value__;
    public static FrameworkLayer Composition;
    public static FrameworkLayer Xaml;
}
[ExtensionAttribute]
internal static class Microsoft.Toolkit.Uwp.UI.Animations.GuidExtensions : object {
    [ExtensionAttribute]
public static string ToUppercaseAsciiLetters(Guid& guid);
}
public interface Microsoft.Toolkit.Uwp.UI.Animations.IActivity {
    public abstract virtual Task InvokeAsync(UIElement element, CancellationToken token);
}
public interface Microsoft.Toolkit.Uwp.UI.Animations.IAttachedTimeline {
    public abstract virtual AnimationBuilder AppendToBuilder(AnimationBuilder builder, UIElement parent, Nullable`1<TimeSpan> delayHint, Nullable`1<TimeSpan> durationHint, Nullable`1<EasingType> easingTypeHint, Nullable`1<EasingMode> easingModeHint);
}
[NullableContextAttribute("2")]
public interface Microsoft.Toolkit.Uwp.UI.Animations.IImplicitTimeline {
    [CompilerGeneratedAttribute]
public abstract virtual void add_AnimationPropertyChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_AnimationPropertyChanged(EventHandler value);
    [NullableContextAttribute("1")]
public abstract virtual CompositionAnimation GetAnimation(UIElement element, String& target);
}
public interface Microsoft.Toolkit.Uwp.UI.Animations.IKeyFrame`1 {
    public abstract virtual INormalizedKeyFrameAnimationBuilder`1<T> AppendToBuilder(INormalizedKeyFrameAnimationBuilder`1<T> builder);
}
internal interface Microsoft.Toolkit.Uwp.UI.Animations.IKeyFrameInfo {
    public EasingType EasingType { get; }
    public EasingMode EasingMode { get; }
    public abstract virtual EasingType get_EasingType();
    public abstract virtual EasingMode get_EasingMode();
    public abstract virtual T GetValueAs();
    public abstract virtual bool TryInsertExpressionKeyFrame(KeyFrameAnimation animation, TimeSpan duration);
    public abstract virtual float GetNormalizedProgress(TimeSpan duration);
    public abstract virtual TimeSpan GetTimedProgress(TimeSpan duration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Microsoft.Toolkit.Uwp.UI.Animations.Implicit : object {
    public static DependencyProperty ShowAnimationsProperty;
    public static DependencyProperty HideAnimationsProperty;
    public static DependencyProperty AnimationsProperty;
    private static Implicit();
    public static ImplicitAnimationSet GetShowAnimations(UIElement element);
    public static void SetShowAnimations(UIElement element, ImplicitAnimationSet value);
    public static ImplicitAnimationSet GetHideAnimations(UIElement element);
    public static void SetHideAnimations(UIElement element, ImplicitAnimationSet value);
    public static ImplicitAnimationSet GetAnimations(UIElement element);
    public static void SetAnimations(UIElement element, ImplicitAnimationSet value);
    private static void OnShowAnimationsPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnHideAnimationsPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnAnimationsPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    [CompilerGeneratedAttribute]
internal static void <OnShowAnimationsPropertyChanged>g__OnAnimationsChanged|9_0(object sender, EventArgs e);
    [CompilerGeneratedAttribute]
internal static void <OnHideAnimationsPropertyChanged>g__OnAnimationsChanged|10_0(object sender, EventArgs e);
    [CompilerGeneratedAttribute]
internal static void <OnAnimationsPropertyChanged>g__OnAnimationsChanged|11_0(object sender, EventArgs e);
}
[NullableContextAttribute("2")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class Microsoft.Toolkit.Uwp.UI.Animations.ImplicitAnimation`2 : Animation`2<TValue, TKeyFrame> {
    [CompilerGeneratedAttribute]
private EventHandler AnimationPropertyChanged;
    [CompilerGeneratedAttribute]
private string <ImplicitTarget>k__BackingField;
    public string ImplicitTarget { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual void add_AnimationPropertyChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_AnimationPropertyChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public string get_ImplicitTarget();
    [CompilerGeneratedAttribute]
public void set_ImplicitTarget(string value);
    [NullableContextAttribute("1")]
public sealed virtual CompositionAnimation GetAnimation(UIElement element, String& target);
    [NullableContextAttribute("1")]
private void RaiseAnimationPropertyChanged(DependencyObject sender, DependencyProperty property);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Toolkit.Uwp.UI.Animations.ImplicitAnimationSet : DependencyObjectCollection {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private EventHandler AnimationsChanged;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private WeakReference`1<UIElement> <ParentReference>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal WeakReference`1<UIElement> ParentReference { get; internal set; }
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void add_AnimationsChanged(EventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void remove_AnimationsChanged(EventHandler value);
    private void ImplicitAnimationSetVectorChanged(IObservableVector`1<DependencyObject> sender, IVectorChangedEventArgs event);
    private void RaiseAnimationsChanged(object sender, EventArgs e);
    [CompilerGeneratedAttribute]
internal WeakReference`1<UIElement> get_ParentReference();
    [CompilerGeneratedAttribute]
internal void set_ParentReference(WeakReference`1<UIElement> value);
    internal CompositionAnimationGroup GetCompositionAnimationGroup(UIElement parent);
    internal ImplicitAnimationCollection GetImplicitAnimationCollection(UIElement parent);
}
public interface Microsoft.Toolkit.Uwp.UI.Animations.INormalizedKeyFrameAnimationBuilder`1 {
    public abstract virtual INormalizedKeyFrameAnimationBuilder`1<T> KeyFrame(double progress, T value, EasingType easingType, EasingMode easingMode);
    public abstract virtual INormalizedKeyFrameAnimationBuilder`1<T> ExpressionKeyFrame(double progress, string expression, EasingType easingType, EasingMode easingMode);
}
public interface Microsoft.Toolkit.Uwp.UI.Animations.IPropertyAnimationBuilder`1 {
    public abstract virtual AnimationBuilder NormalizedKeyFrames(Action`1<INormalizedKeyFrameAnimationBuilder`1<T>> build, Nullable`1<TimeSpan> delay, Nullable`1<TimeSpan> duration, Nullable`1<RepeatOption> repeat, Nullable`1<AnimationDelayBehavior> delayBehavior);
    public abstract virtual AnimationBuilder NormalizedKeyFrames(TState state, Action`2<INormalizedKeyFrameAnimationBuilder`1<T>, TState> build, Nullable`1<TimeSpan> delay, Nullable`1<TimeSpan> duration, Nullable`1<RepeatOption> repeat, Nullable`1<AnimationDelayBehavior> delayBehavior);
    public abstract virtual AnimationBuilder TimedKeyFrames(Action`1<ITimedKeyFrameAnimationBuilder`1<T>> build, Nullable`1<TimeSpan> delay, Nullable`1<RepeatOption> repeat, Nullable`1<AnimationDelayBehavior> delayBehavior);
    public abstract virtual AnimationBuilder TimedKeyFrames(TState state, Action`2<ITimedKeyFrameAnimationBuilder`1<T>, TState> build, Nullable`1<TimeSpan> delay, Nullable`1<RepeatOption> repeat, Nullable`1<AnimationDelayBehavior> delayBehavior);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Microsoft.Toolkit.Uwp.UI.Animations.ItemsReorderAnimation : object {
    public static DependencyProperty DurationProperty;
    private static DependencyProperty ReorderAnimationProperty;
    private static ItemsReorderAnimation();
    public static TimeSpan GetDuration(ListViewBase listView);
    public static void SetDuration(ListViewBase listView, TimeSpan value);
    private static void OnDurationChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void AssignReorderAnimation(ListViewBase listView, TimeSpan duration);
    private static void OnContainerContentChanging(ListViewBase sender, ContainerContentChangingEventArgs args);
    private static void OnChoosingItemContainer(ListViewBase sender, ChoosingItemContainerEventArgs args);
    private static void PokeUIElementZIndex(UIElement element);
}
public interface Microsoft.Toolkit.Uwp.UI.Animations.ITimedKeyFrameAnimationBuilder`1 {
    public abstract virtual ITimedKeyFrameAnimationBuilder`1<T> KeyFrame(TimeSpan progress, T value, EasingType easingType, EasingMode easingMode);
    public abstract virtual ITimedKeyFrameAnimationBuilder`1<T> ExpressionKeyFrame(TimeSpan progress, string expression, EasingType easingType, EasingMode easingMode);
}
[ExtensionAttribute]
public static class Microsoft.Toolkit.Uwp.UI.Animations.ITimedKeyFrameAnimationBuilderExtensions : object {
    [ExtensionAttribute]
public static ITimedKeyFrameAnimationBuilder`1<T> KeyFrame(ITimedKeyFrameAnimationBuilder`1<T> builder, int progress, T value, EasingType easingType, EasingMode easingMode);
}
public interface Microsoft.Toolkit.Uwp.UI.Animations.ITimeline {
    public abstract virtual AnimationBuilder AppendToBuilder(AnimationBuilder builder, Nullable`1<TimeSpan> delayHint, Nullable`1<TimeSpan> durationHint, Nullable`1<EasingType> easingTypeHint, Nullable`1<EasingMode> easingModeHint);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class Microsoft.Toolkit.Uwp.UI.Animations.KeyFrame`2 : DependencyObject {
    [NullableAttribute("1")]
public static DependencyProperty KeyProperty;
    [NullableAttribute("1")]
public static DependencyProperty ValueProperty;
    [NullableAttribute("1")]
public static DependencyProperty ExpressionProperty;
    [NullableAttribute("1")]
public static DependencyProperty EasingTypeProperty;
    [NullableAttribute("1")]
public static DependencyProperty EasingModeProperty;
    public double Key { get; public set; }
    public TValue Value { get; public set; }
    public string Expression { get; public set; }
    public Nullable`1<EasingType> EasingType { get; public set; }
    public Nullable`1<EasingMode> EasingMode { get; public set; }
    private static KeyFrame`2();
    public double get_Key();
    public void set_Key(double value);
    public TValue get_Value();
    public void set_Value(TValue value);
    public string get_Expression();
    public void set_Expression(string value);
    public Nullable`1<EasingType> get_EasingType();
    public void set_EasingType(Nullable`1<EasingType> value);
    public Nullable`1<EasingMode> get_EasingMode();
    public void set_EasingMode(Nullable`1<EasingMode> value);
    [NullableContextAttribute("1")]
public sealed virtual INormalizedKeyFrameAnimationBuilder`1<TKeyFrame> AppendToBuilder(INormalizedKeyFrameAnimationBuilder`1<TKeyFrame> builder);
    protected abstract virtual TKeyFrame GetParsedValue();
}
internal abstract class Microsoft.Toolkit.Uwp.UI.Animations.NormalizedKeyFrameAnimationBuilder`1 : object {
    [NullableAttribute("1")]
private string property;
    private Nullable`1<TimeSpan> delay;
    private TimeSpan duration;
    private RepeatOption repeat;
    private ListBuilder`1<KeyFrameInfo<T>> keyFrames;
    [NullableContextAttribute("1")]
protected NormalizedKeyFrameAnimationBuilder`1(string property, Nullable`1<TimeSpan> delay, TimeSpan duration, RepeatOption repeat);
    [NullableContextAttribute("1")]
public static CompositionAnimation GetAnimation(CompositionObject target, string property, Nullable`1<TimeSpan> delay, TimeSpan duration, RepeatOption repeat, AnimationDelayBehavior delayBehavior, ArraySegment`1<TKeyFrame> keyFrames);
    public sealed virtual INormalizedKeyFrameAnimationBuilder`1<T> KeyFrame(double progress, T value, EasingType easingType, EasingMode easingMode);
    [NullableContextAttribute("1")]
public abstract virtual INormalizedKeyFrameAnimationBuilder`1<T> ExpressionKeyFrame(double progress, string expression, EasingType easingType, EasingMode easingMode);
}
public class Microsoft.Toolkit.Uwp.UI.Animations.OffsetAnimation : ImplicitAnimation`2<string, Vector3> {
    protected string ExplicitTarget { get; }
    protected virtual string get_ExplicitTarget();
    protected virtual ValueTuple`2<Nullable`1<Vector3>, Nullable`1<Vector3>> GetParsedValues();
}
public class Microsoft.Toolkit.Uwp.UI.Animations.OffsetDropShadowAnimation : ShadowAnimation`2<string, Vector3> {
    protected string ExplicitTarget { get; }
    protected virtual string get_ExplicitTarget();
    protected virtual ValueTuple`2<Nullable`1<Vector3>, Nullable`1<Vector3>> GetParsedValues();
}
public class Microsoft.Toolkit.Uwp.UI.Animations.OpacityAnimation : ImplicitAnimation`2<Nullable`1<double>, double> {
    protected string ExplicitTarget { get; }
    protected virtual string get_ExplicitTarget();
    protected virtual ValueTuple`2<Nullable`1<double>, Nullable`1<double>> GetParsedValues();
}
public class Microsoft.Toolkit.Uwp.UI.Animations.OpacityDropShadowAnimation : ShadowAnimation`2<Nullable`1<double>, double> {
    protected string ExplicitTarget { get; }
    protected virtual string get_ExplicitTarget();
    protected virtual ValueTuple`2<Nullable`1<double>, Nullable`1<double>> GetParsedValues();
}
public class Microsoft.Toolkit.Uwp.UI.Animations.OrientationAnimation : ImplicitAnimation`2<string, Quaternion> {
    protected string ExplicitTarget { get; }
    protected virtual string get_ExplicitTarget();
    protected virtual ValueTuple`2<Nullable`1<Quaternion>, Nullable`1<Quaternion>> GetParsedValues();
}
public class Microsoft.Toolkit.Uwp.UI.Animations.QuaternionAnimation : CustomAnimation`2<string, Quaternion> {
    protected virtual ValueTuple`2<Nullable`1<Quaternion>, Nullable`1<Quaternion>> GetParsedValues();
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.Toolkit.Uwp.UI.Animations.QuaternionKeyFrame : KeyFrame`2<string, Quaternion> {
    protected virtual Quaternion GetParsedValue();
}
[IsReadOnlyAttribute]
[CreateFromStringAttribute]
public class Microsoft.Toolkit.Uwp.UI.Animations.RepeatOption : ValueType {
    private int value;
    public static RepeatOption Once { get; }
    public static RepeatOption Forever { get; }
    private RepeatOption(int value);
    public static RepeatOption get_Once();
    public static RepeatOption get_Forever();
    public static RepeatOption Count(int count);
    public static RepeatOption Parse(string text);
    public RepeatBehavior ToRepeatBehavior();
    public ValueTuple`2<AnimationIterationBehavior, int> ToBehaviorAndCount();
    private static void ThrowArgumentOutOfRangeForCount();
    private static RepeatOption ThrowArgumentExceptionForText();
}
public class Microsoft.Toolkit.Uwp.UI.Animations.RotationAnimation : ImplicitAnimation`2<Nullable`1<double>, double> {
    protected string ExplicitTarget { get; }
    protected virtual string get_ExplicitTarget();
    protected virtual ValueTuple`2<Nullable`1<double>, Nullable`1<double>> GetParsedValues();
}
public class Microsoft.Toolkit.Uwp.UI.Animations.RotationAxisAnimation : ImplicitAnimation`2<string, Vector3> {
    protected string ExplicitTarget { get; }
    protected virtual string get_ExplicitTarget();
    protected virtual ValueTuple`2<Nullable`1<Vector3>, Nullable`1<Vector3>> GetParsedValues();
}
public class Microsoft.Toolkit.Uwp.UI.Animations.RotationInDegreesAnimation : ImplicitAnimation`2<Nullable`1<double>, double> {
    protected string ExplicitTarget { get; }
    protected virtual string get_ExplicitTarget();
    protected virtual ValueTuple`2<Nullable`1<double>, Nullable`1<double>> GetParsedValues();
}
public class Microsoft.Toolkit.Uwp.UI.Animations.ScalarAnimation : CustomAnimation`2<Nullable`1<double>, double> {
    protected virtual ValueTuple`2<Nullable`1<double>, Nullable`1<double>> GetParsedValues();
}
public class Microsoft.Toolkit.Uwp.UI.Animations.ScalarKeyFrame : KeyFrame`2<Nullable`1<double>, double> {
    protected virtual double GetParsedValue();
}
public class Microsoft.Toolkit.Uwp.UI.Animations.ScaleAnimation : ImplicitAnimation`2<string, Vector3> {
    protected string ExplicitTarget { get; }
    protected virtual string get_ExplicitTarget();
    protected virtual ValueTuple`2<Nullable`1<Vector3>, Nullable`1<Vector3>> GetParsedValues();
}
[ExtensionAttribute]
public static class Microsoft.Toolkit.Uwp.UI.Animations.ScrollViewerExtensions : object {
    [ExtensionAttribute]
public static ExpressionAnimation StartExpressionAnimation(ScrollViewer scroller, UIElement target, Axis axis, VisualProperty property);
    [ExtensionAttribute]
public static ExpressionAnimation StartExpressionAnimation(ScrollViewer scroller, UIElement target, Axis sourceAxis, Axis targetAxis, VisualProperty property);
    [CompilerGeneratedAttribute]
internal static ExpressionAnimation <StartExpressionAnimation>g__ThrowArgumentException|1_0();
}
[NullableContextAttribute("2")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class Microsoft.Toolkit.Uwp.UI.Animations.ShadowAnimation`2 : Animation`2<TValue, TKeyFrame> {
    [NullableAttribute("1")]
public static DependencyProperty TargetProperty;
    public IAttachedShadow Target { get; public set; }
    private static ShadowAnimation`2();
    public IAttachedShadow get_Target();
    public void set_Target(IAttachedShadow value);
    [NullableContextAttribute("1")]
public virtual AnimationBuilder AppendToBuilder(AnimationBuilder builder, Nullable`1<TimeSpan> delayHint, Nullable`1<TimeSpan> durationHint, Nullable`1<EasingType> easingTypeHint, Nullable`1<EasingMode> easingModeHint);
    [NullableContextAttribute("1")]
public sealed virtual AnimationBuilder AppendToBuilder(AnimationBuilder builder, UIElement parent, Nullable`1<TimeSpan> delayHint, Nullable`1<TimeSpan> durationHint, Nullable`1<EasingType> easingTypeHint, Nullable`1<EasingMode> easingModeHint);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static AnimationBuilder <AppendToBuilder>g__ThrowArgumentNullException|5_0();
}
public enum Microsoft.Toolkit.Uwp.UI.Animations.Side : Enum {
    public int value__;
    public static Side Top;
    public static Side Bottom;
    public static Side Left;
    public static Side Right;
}
public class Microsoft.Toolkit.Uwp.UI.Animations.SizeAnimation : ImplicitAnimation`2<string, Vector2> {
    protected string ExplicitTarget { get; }
    protected virtual string get_ExplicitTarget();
    protected virtual ValueTuple`2<Nullable`1<Vector2>, Nullable`1<Vector2>> GetParsedValues();
}
public class Microsoft.Toolkit.Uwp.UI.Animations.StartAnimationActivity : Activity {
    public static DependencyProperty AnimationProperty;
    public static DependencyProperty TargetObjectProperty;
    public AnimationSet Animation { get; public set; }
    public UIElement TargetObject { get; public set; }
    private static StartAnimationActivity();
    public AnimationSet get_Animation();
    public void set_Animation(AnimationSet value);
    public UIElement get_TargetObject();
    public void set_TargetObject(UIElement value);
    [AsyncStateMachineAttribute("Microsoft.Toolkit.Uwp.UI.Animations.StartAnimationActivity/<InvokeAsync>d__8")]
public virtual Task InvokeAsync(UIElement element, CancellationToken token);
    [CompilerGeneratedAttribute]
internal static void <InvokeAsync>g__ThrowArgumentNullException|8_0();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(UIElement element, CancellationToken token);
}
public class Microsoft.Toolkit.Uwp.UI.Animations.StopAnimationActivity : Activity {
    public static DependencyProperty AnimationProperty;
    public static DependencyProperty TargetObjectProperty;
    public AnimationSet Animation { get; public set; }
    public UIElement TargetObject { get; public set; }
    private static StopAnimationActivity();
    public AnimationSet get_Animation();
    public void set_Animation(AnimationSet value);
    public UIElement get_TargetObject();
    public void set_TargetObject(UIElement value);
    [AsyncStateMachineAttribute("Microsoft.Toolkit.Uwp.UI.Animations.StopAnimationActivity/<InvokeAsync>d__8")]
public virtual Task InvokeAsync(UIElement element, CancellationToken token);
    [CompilerGeneratedAttribute]
internal static void <InvokeAsync>g__ThrowArgumentNullException|8_0();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(UIElement element, CancellationToken token);
}
[ExtensionAttribute]
public static class Microsoft.Toolkit.Uwp.UI.Animations.StoryboardAnimations : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Task BeginAsync(Storyboard storyboard);
}
internal abstract class Microsoft.Toolkit.Uwp.UI.Animations.TimedKeyFrameAnimationBuilder`1 : object {
    [NullableAttribute("1")]
private string property;
    private Nullable`1<TimeSpan> delay;
    private RepeatOption repeat;
    private ListBuilder`1<KeyFrameInfo<T>> keyFrames;
    [NullableContextAttribute("1")]
protected TimedKeyFrameAnimationBuilder`1(string property, Nullable`1<TimeSpan> delay, RepeatOption repeat);
    public sealed virtual ITimedKeyFrameAnimationBuilder`1<T> KeyFrame(TimeSpan progress, T value, EasingType easingType, EasingMode easingMode);
    [NullableContextAttribute("1")]
public abstract virtual ITimedKeyFrameAnimationBuilder`1<T> ExpressionKeyFrame(TimeSpan progress, string expression, EasingType easingType, EasingMode easingMode);
    public static Timeline GetAnimation(DependencyObject target, string property, Nullable`1<TimeSpan> delay, TimeSpan duration, RepeatOption repeat, ArraySegment`1<TKeyFrame> keyFrames);
    [CompilerGeneratedAttribute]
internal static Timeline <GetAnimation>g__ThrowInvalidOperationException|9_0();
}
public class Microsoft.Toolkit.Uwp.UI.Animations.TranslationAnimation : ImplicitAnimation`2<string, Vector3> {
    protected string ExplicitTarget { get; }
    protected virtual string get_ExplicitTarget();
    protected virtual ValueTuple`2<Nullable`1<Vector3>, Nullable`1<Vector3>> GetParsedValues();
}
public class Microsoft.Toolkit.Uwp.UI.Animations.Vector2Animation : CustomAnimation`2<string, Vector2> {
    protected virtual ValueTuple`2<Nullable`1<Vector2>, Nullable`1<Vector2>> GetParsedValues();
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.Toolkit.Uwp.UI.Animations.Vector2KeyFrame : KeyFrame`2<string, Vector2> {
    protected virtual Vector2 GetParsedValue();
}
public class Microsoft.Toolkit.Uwp.UI.Animations.Vector3Animation : CustomAnimation`2<string, Vector3> {
    protected virtual ValueTuple`2<Nullable`1<Vector3>, Nullable`1<Vector3>> GetParsedValues();
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.Toolkit.Uwp.UI.Animations.Vector3KeyFrame : KeyFrame`2<string, Vector3> {
    protected virtual Vector3 GetParsedValue();
}
public class Microsoft.Toolkit.Uwp.UI.Animations.Vector4Animation : CustomAnimation`2<string, Vector4> {
    protected virtual ValueTuple`2<Nullable`1<Vector4>, Nullable`1<Vector4>> GetParsedValues();
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.Toolkit.Uwp.UI.Animations.Vector4KeyFrame : KeyFrame`2<string, Vector4> {
    protected virtual Vector4 GetParsedValue();
}
public enum Microsoft.Toolkit.Uwp.UI.Animations.VisualProperty : Enum {
    public int value__;
    public static VisualProperty Offset;
    public static VisualProperty Translation;
}
[EditorBrowsableAttribute("1")]
internal static class System.Runtime.CompilerServices.IsExternalInit : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsUnmanagedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[AttributeUsageAttribute("1774")]
internal class System.Runtime.CompilerServices.SkipLocalsInitAttribute : Attribute {
}
internal static class ThisAssembly : object {
    internal static string AssemblyVersion;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyConfiguration;
    internal static string GitCommitId;
    internal static bool IsPublicRelease;
    internal static bool IsPrerelease;
    internal static DateTime GitCommitDate;
    internal static string RootNamespace;
    private static ThisAssembly();
}
