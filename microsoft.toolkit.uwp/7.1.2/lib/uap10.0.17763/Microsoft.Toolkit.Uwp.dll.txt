[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[ExtensionAttribute]
public static class Microsoft.Toolkit.Uwp.Deferred.TypedEventHandlerExtensions : object {
    [ExtensionAttribute]
public static Task InvokeAsync(TypedEventHandler`2<S, R> eventHandler, S sender, R eventArgs);
    [ExtensionAttribute]
public static Task InvokeAsync(TypedEventHandler`2<S, R> eventHandler, S sender, R eventArgs, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.Toolkit.Uwp.DispatcherQueueExtensions : object {
    private static bool IsHasThreadAccessPropertyAvailable;
    private static DispatcherQueueExtensions();
    [ExtensionAttribute]
public static Task EnqueueAsync(DispatcherQueue dispatcher, Action function, DispatcherQueuePriority priority);
    [ExtensionAttribute]
public static Task`1<T> EnqueueAsync(DispatcherQueue dispatcher, Func`1<T> function, DispatcherQueuePriority priority);
    [ExtensionAttribute]
public static Task EnqueueAsync(DispatcherQueue dispatcher, Func`1<Task> function, DispatcherQueuePriority priority);
    [ExtensionAttribute]
public static Task`1<T> EnqueueAsync(DispatcherQueue dispatcher, Func`1<Task`1<T>> function, DispatcherQueuePriority priority);
    private static InvalidOperationException GetEnqueueException(string message);
    [CompilerGeneratedAttribute]
internal static Task <EnqueueAsync>g__TryEnqueueAsync|1_0(DispatcherQueue dispatcher, Action function, DispatcherQueuePriority priority);
    [CompilerGeneratedAttribute]
internal static Task`1<T> <EnqueueAsync>g__TryEnqueueAsync|2_0(DispatcherQueue dispatcher, Func`1<T> function, DispatcherQueuePriority priority);
    [CompilerGeneratedAttribute]
internal static Task <EnqueueAsync>g__TryEnqueueAsync|3_0(DispatcherQueue dispatcher, Func`1<Task> function, DispatcherQueuePriority priority);
    [CompilerGeneratedAttribute]
internal static Task`1<T> <EnqueueAsync>g__TryEnqueueAsync|4_0(DispatcherQueue dispatcher, Func`1<Task`1<T>> function, DispatcherQueuePriority priority);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Toolkit.Uwp.Helpers.ApplicationDataStorageHelper : object {
    [CompilerGeneratedAttribute]
private ApplicationData <AppData>k__BackingField;
    [CompilerGeneratedAttribute]
private IObjectSerializer <Serializer>k__BackingField;
    [NullableAttribute("0")]
public StorageFolder CacheFolder { get; }
    public ApplicationDataContainer Settings { get; }
    public StorageFolder Folder { get; }
    protected ApplicationData AppData { get; }
    protected IObjectSerializer Serializer { get; }
    public ApplicationDataStorageHelper(ApplicationData appData, IObjectSerializer objectSerializer);
    [NullableContextAttribute("0")]
public StorageFolder get_CacheFolder();
    [NullableContextAttribute("0")]
public Task`1<T> ReadCacheFileAsync(string filePath, T default);
    [NullableContextAttribute("0")]
public Task`1<IEnumerable`1<ValueTuple`2<DirectoryItemType, string>>> ReadCacheFolderAsync(string folderPath);
    [NullableContextAttribute("0")]
public Task CreateCacheFileAsync(string filePath, T value);
    [NullableContextAttribute("0")]
public Task CreateCacheFolderAsync(string folderPath);
    [NullableContextAttribute("0")]
public Task`1<bool> TryDeleteCacheItemAsync(string itemPath);
    [NullableContextAttribute("0")]
public Task`1<bool> TryRenameCacheItemAsync(string itemPath, string newName);
    public ApplicationDataContainer get_Settings();
    public StorageFolder get_Folder();
    [CompilerGeneratedAttribute]
protected ApplicationData get_AppData();
    [CompilerGeneratedAttribute]
protected IObjectSerializer get_Serializer();
    public static ApplicationDataStorageHelper GetCurrent(IObjectSerializer objectSerializer);
    [AsyncStateMachineAttribute("Microsoft.Toolkit.Uwp.Helpers.ApplicationDataStorageHelper/<GetForUserAsync>d__20")]
public static Task`1<ApplicationDataStorageHelper> GetForUserAsync(User user, IObjectSerializer objectSerializer);
    public bool KeyExists(string key);
    [NullableContextAttribute("2")]
public T Read(string key, T default);
    [NullableContextAttribute("2")]
public sealed virtual bool TryRead(string key, T& value);
    public sealed virtual void Save(string key, T value);
    public sealed virtual bool TryDelete(string key);
    public sealed virtual void Clear();
    public bool KeyExists(string compositeKey, string key);
    public bool TryRead(string compositeKey, string key, T& value);
    [NullableContextAttribute("2")]
public T Read(string compositeKey, string key, T default);
    public void Save(string compositeKey, IDictionary`2<string, T> values);
    public bool TryDelete(string compositeKey, string key);
    [NullableContextAttribute("2")]
public sealed virtual Task`1<T> ReadFileAsync(string filePath, T default);
    public sealed virtual Task`1<IEnumerable`1<ValueTuple`2<DirectoryItemType, string>>> ReadFolderAsync(string folderPath);
    public sealed virtual Task CreateFileAsync(string filePath, T value);
    public sealed virtual Task CreateFolderAsync(string folderPath);
    public sealed virtual Task`1<bool> TryDeleteItemAsync(string itemPath);
    public sealed virtual Task`1<bool> TryRenameItemAsync(string itemPath, string newName);
    [AsyncStateMachineAttribute("Microsoft.Toolkit.Uwp.Helpers.ApplicationDataStorageHelper/<ReadFileAsync>d__38`1")]
private Task`1<T> ReadFileAsync(StorageFolder folder, string filePath, T default);
    [AsyncStateMachineAttribute("Microsoft.Toolkit.Uwp.Helpers.ApplicationDataStorageHelper/<ReadFolderAsync>d__39")]
private Task`1<IEnumerable`1<ValueTuple`2<DirectoryItemType, string>>> ReadFolderAsync(StorageFolder folder, string folderPath);
    [AsyncStateMachineAttribute("Microsoft.Toolkit.Uwp.Helpers.ApplicationDataStorageHelper/<CreateFileAsync>d__40`1")]
private Task`1<StorageFile> CreateFileAsync(StorageFolder folder, string filePath, T value);
    [AsyncStateMachineAttribute("Microsoft.Toolkit.Uwp.Helpers.ApplicationDataStorageHelper/<CreateFolderAsync>d__41")]
private Task CreateFolderAsync(StorageFolder folder, string folderPath);
    [AsyncStateMachineAttribute("Microsoft.Toolkit.Uwp.Helpers.ApplicationDataStorageHelper/<TryDeleteItemAsync>d__42")]
private Task`1<bool> TryDeleteItemAsync(StorageFolder folder, string itemPath);
    [AsyncStateMachineAttribute("Microsoft.Toolkit.Uwp.Helpers.ApplicationDataStorageHelper/<TryRenameItemAsync>d__43")]
private Task`1<bool> TryRenameItemAsync(StorageFolder folder, string itemPath, string newName);
    private string NormalizePath(string path);
}
public static class Microsoft.Toolkit.Uwp.Helpers.BackgroundTaskHelper : object {
    public static bool IsBackgroundTaskRegistered(string backgroundTaskName);
    public static bool IsBackgroundTaskRegistered(Type backgroundTaskType);
    public static BackgroundTaskRegistration Register(string backgroundTaskName, string backgroundTaskEntryPoint, IBackgroundTrigger trigger, bool forceRegister, bool enforceConditions, IBackgroundCondition[] conditions);
    public static BackgroundTaskRegistration Register(Type backgroundTaskType, IBackgroundTrigger trigger, bool forceRegister, bool enforceConditions, IBackgroundCondition[] conditions);
    public static BackgroundTaskRegistration Register(string backgroundTaskName, IBackgroundTrigger trigger, bool forceRegister, bool enforceConditions, IBackgroundCondition[] conditions);
    public static void Unregister(Type backgroundTaskType, bool forceExit);
    public static void Unregister(string backgroundTaskName, bool forceExit);
    public static void Unregister(IBackgroundTaskRegistration backgroundTask, bool forceExit);
    public static IBackgroundTaskRegistration GetBackgroundTask(Type backgroundTaskType);
    public static IBackgroundTaskRegistration GetBackgroundTask(string backgroundTaskName);
}
[ObsoleteAttribute("BaseObjectStorageHelper is deprecated and has been superceded by ApplicationDataStorageHelper.")]
public abstract class Microsoft.Toolkit.Uwp.Helpers.BaseObjectStorageHelper : object {
    private IObjectSerializer serializer;
    [CompilerGeneratedAttribute]
private ApplicationDataContainer <Settings>k__BackingField;
    [CompilerGeneratedAttribute]
private StorageFolder <Folder>k__BackingField;
    protected ApplicationDataContainer Settings { get; protected set; }
    protected StorageFolder Folder { get; protected set; }
    public BaseObjectStorageHelper(IObjectSerializer objectSerializer);
    [CompilerGeneratedAttribute]
protected ApplicationDataContainer get_Settings();
    [CompilerGeneratedAttribute]
protected void set_Settings(ApplicationDataContainer value);
    [CompilerGeneratedAttribute]
protected StorageFolder get_Folder();
    [CompilerGeneratedAttribute]
protected void set_Folder(StorageFolder value);
    public sealed virtual bool KeyExists(string key);
    public sealed virtual bool KeyExists(string compositeKey, string key);
    public sealed virtual T Read(string key, T default);
    public sealed virtual T Read(string compositeKey, string key, T default);
    public sealed virtual void Save(string key, T value);
    public sealed virtual void Save(string compositeKey, IDictionary`2<string, T> values);
    public sealed virtual Task`1<bool> FileExistsAsync(string filePath);
    [AsyncStateMachineAttribute("Microsoft.Toolkit.Uwp.Helpers.BaseObjectStorageHelper/<ReadFileAsync>d__17`1")]
public sealed virtual Task`1<T> ReadFileAsync(string filePath, T default);
    public sealed virtual Task`1<StorageFile> SaveFileAsync(string filePath, T value);
}
public class Microsoft.Toolkit.Uwp.Helpers.CameraHelper : object {
    private static IReadOnlyList`1<MediaFrameSourceGroup> _frameSourceGroups;
    private SemaphoreSlim _semaphoreSlim;
    private MediaCapture _mediaCapture;
    private MediaFrameReader _frameReader;
    private MediaFrameSourceGroup _group;
    private bool groupChanged;
    private bool _initialized;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<MediaFrameFormat> <FrameFormatsAvailable>k__BackingField;
    [CompilerGeneratedAttribute]
private MediaFrameSource <PreviewFrameSource>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<FrameEventArgs> FrameArrived;
    private bool disposedValue;
    public IReadOnlyList`1<MediaFrameFormat> FrameFormatsAvailable { get; private set; }
    public MediaFrameSourceGroup FrameSourceGroup { get; public set; }
    public MediaFrameSource PreviewFrameSource { get; private set; }
    [AsyncStateMachineAttribute("Microsoft.Toolkit.Uwp.Helpers.CameraHelper/<GetFrameSourceGroupsAsync>d__7")]
public static Task`1<IReadOnlyList`1<MediaFrameSourceGroup>> GetFrameSourceGroupsAsync();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<MediaFrameFormat> get_FrameFormatsAvailable();
    [CompilerGeneratedAttribute]
private void set_FrameFormatsAvailable(IReadOnlyList`1<MediaFrameFormat> value);
    public MediaFrameSourceGroup get_FrameSourceGroup();
    public void set_FrameSourceGroup(MediaFrameSourceGroup value);
    [CompilerGeneratedAttribute]
public MediaFrameSource get_PreviewFrameSource();
    [CompilerGeneratedAttribute]
private void set_PreviewFrameSource(MediaFrameSource value);
    [CompilerGeneratedAttribute]
public void add_FrameArrived(EventHandler`1<FrameEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_FrameArrived(EventHandler`1<FrameEventArgs> value);
    [AsyncStateMachineAttribute("Microsoft.Toolkit.Uwp.Helpers.CameraHelper/<InitializeAndStartCaptureAsync>d__22")]
public Task`1<CameraHelperResult> InitializeAndStartCaptureAsync();
    [AsyncStateMachineAttribute("Microsoft.Toolkit.Uwp.Helpers.CameraHelper/<CleanUpAsync>d__23")]
public Task CleanUpAsync();
    [AsyncStateMachineAttribute("Microsoft.Toolkit.Uwp.Helpers.CameraHelper/<InitializeMediaCaptureAsync>d__24")]
private Task`1<CameraHelperResult> InitializeMediaCaptureAsync();
    [AsyncStateMachineAttribute("Microsoft.Toolkit.Uwp.Helpers.CameraHelper/<StopReaderAsync>d__25")]
private Task StopReaderAsync();
    private void Reader_FrameArrived(MediaFrameReader sender, MediaFrameArrivedEventArgs args);
    [AsyncStateMachineAttribute("Microsoft.Toolkit.Uwp.Helpers.CameraHelper/<Dispose>d__28")]
public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private bool <InitializeAndStartCaptureAsync>b__22_0(MediaFrameSourceGroup g);
}
public enum Microsoft.Toolkit.Uwp.Helpers.CameraHelperResult : Enum {
    public int value__;
    public static CameraHelperResult Success;
    public static CameraHelperResult CreateFrameReaderFailed;
    public static CameraHelperResult StartFrameReaderFailed;
    public static CameraHelperResult NoFrameSourceGroupAvailable;
    public static CameraHelperResult NoFrameSourceAvailable;
    public static CameraHelperResult CameraAccessDenied;
    public static CameraHelperResult InitializationFailed_UnknownError;
    public static CameraHelperResult NoCompatibleFrameFormatAvailable;
}
public class Microsoft.Toolkit.Uwp.Helpers.CollectionFormingDeepLinkParser : DeepLinkParser {
    protected CollectionFormingDeepLinkParser(IActivatedEventArgs args);
    protected CollectionFormingDeepLinkParser(Uri uri);
    protected CollectionFormingDeepLinkParser(string uri);
    protected virtual void ParseUriString(string uri);
}
[ExtensionAttribute]
public static class Microsoft.Toolkit.Uwp.Helpers.ColorHelper : object {
    [ExtensionAttribute]
public static Color ToColor(string colorString);
    [ExtensionAttribute]
public static string ToHex(Color color);
    [ExtensionAttribute]
public static int ToInt(Color color);
    [ExtensionAttribute]
public static HslColor ToHsl(Color color);
    [ExtensionAttribute]
public static HsvColor ToHsv(Color color);
    public static Color FromHsl(double hue, double saturation, double lightness, double alpha);
    public static Color FromHsv(double hue, double saturation, double value, double alpha);
    [CompilerGeneratedAttribute]
internal static void <ToColor>g__ThrowArgumentException|0_0();
    [CompilerGeneratedAttribute]
internal static Color <ToColor>g__ThrowFormatException|0_1();
}
public class Microsoft.Toolkit.Uwp.Helpers.DeepLinkParser : Dictionary`2<string, string> {
    [CompilerGeneratedAttribute]
private string <Root>k__BackingField;
    public string Root { get; protected set; }
    protected DeepLinkParser(IActivatedEventArgs args);
    protected DeepLinkParser(Uri uri);
    protected DeepLinkParser(string uri);
    public static DeepLinkParser Create(IActivatedEventArgs args);
    public static DeepLinkParser Create(Uri uri);
    public static DeepLinkParser Create(string uri);
    protected static Uri ValidateSourceUri(string uri);
    protected virtual void ParseUriString(string uri);
    protected virtual void SetRoot(Uri validatedUri);
    [CompilerGeneratedAttribute]
public string get_Root();
    [CompilerGeneratedAttribute]
protected void set_Root(string value);
}
[ExtensionAttribute]
[ObsoleteAttribute("Replace calls to APIs in this class with extensions for the Windows.System.DispatcherQueue type (see https://docs.microsoft.com/uwp/api/windows.system.dispatcherqueue).")]
public static class Microsoft.Toolkit.Uwp.Helpers.DispatcherHelper : object {
    [ObsoleteAttribute("This method should be replaced with dispatcherQueue.EnqueueAsync(function, priority), where dispatcherQueue is a DispatcherQueue instance that was retrieved from the UI thread and stored for later use.")]
public static Task ExecuteOnUIThreadAsync(Action function, CoreDispatcherPriority priority);
    [ObsoleteAttribute("This method should be replaced with dispatcherQueue.EnqueueAsync(function, priority), where dispatcherQueue is a DispatcherQueue instance that was retrieved from the UI thread and stored for later use.")]
public static Task`1<T> ExecuteOnUIThreadAsync(Func`1<T> function, CoreDispatcherPriority priority);
    [ObsoleteAttribute("This method should be replaced with dispatcherQueue.EnqueueAsync(function, priority), where dispatcherQueue is a DispatcherQueue instance that was retrieved from the UI thread and stored for later use.")]
public static Task ExecuteOnUIThreadAsync(Func`1<Task> function, CoreDispatcherPriority priority);
    [ObsoleteAttribute("This method should be replaced with dispatcherQueue.EnqueueAsync(function, priority), where dispatcherQueue is a DispatcherQueue instance that was retrieved from the UI thread and stored for later use.")]
public static Task`1<T> ExecuteOnUIThreadAsync(Func`1<Task`1<T>> function, CoreDispatcherPriority priority);
    [ExtensionAttribute]
[ObsoleteAttribute("This method should be replaced with viewToExecuteOn.DispatcherQueue.EnqueueAsync(function, priority).")]
public static Task ExecuteOnUIThreadAsync(CoreApplicationView viewToExecuteOn, Action function, CoreDispatcherPriority priority);
    [ExtensionAttribute]
[ObsoleteAttribute("This method should be replaced with viewToExecuteOn.DispatcherQueue.EnqueueAsync(function, priority).")]
public static Task`1<T> ExecuteOnUIThreadAsync(CoreApplicationView viewToExecuteOn, Func`1<T> function, CoreDispatcherPriority priority);
    [ExtensionAttribute]
[ObsoleteAttribute("This method should be replaced with viewToExecuteOn.DispatcherQueue.EnqueueAsync(function, priority).")]
public static Task ExecuteOnUIThreadAsync(CoreApplicationView viewToExecuteOn, Func`1<Task> function, CoreDispatcherPriority priority);
    [ExtensionAttribute]
[ObsoleteAttribute("This method should be replaced with viewToExecuteOn.DispatcherQueue.EnqueueAsync(function, priority).")]
public static Task`1<T> ExecuteOnUIThreadAsync(CoreApplicationView viewToExecuteOn, Func`1<Task`1<T>> function, CoreDispatcherPriority priority);
    [ExtensionAttribute]
[ObsoleteAttribute("This method should be replaced with dispatcherQueue.EnqueueAsync(function, priority). A queue can be retrieved with DispatcherQueue.GetForCurrentThread().")]
public static Task AwaitableRunAsync(CoreDispatcher dispatcher, Action function, CoreDispatcherPriority priority);
    [ExtensionAttribute]
[ObsoleteAttribute("This method should be replaced with dispatcherQueue.EnqueueAsync(function, priority). A queue can be retrieved with DispatcherQueue.GetForCurrentThread().")]
public static Task`1<T> AwaitableRunAsync(CoreDispatcher dispatcher, Func`1<T> function, CoreDispatcherPriority priority);
    [ExtensionAttribute]
[ObsoleteAttribute("This method should be replaced with dispatcherQueue.EnqueueAsync(function, priority). A queue can be retrieved with DispatcherQueue.GetForCurrentThread().")]
public static Task AwaitableRunAsync(CoreDispatcher dispatcher, Func`1<Task> function, CoreDispatcherPriority priority);
    [ExtensionAttribute]
[ObsoleteAttribute("This method should be replaced with dispatcherQueue.EnqueueAsync(function, priority). A queue can be retrieved with DispatcherQueue.GetForCurrentThread().")]
public static Task`1<T> AwaitableRunAsync(CoreDispatcher dispatcher, Func`1<Task`1<T>> function, CoreDispatcherPriority priority);
}
public class Microsoft.Toolkit.Uwp.Helpers.FrameEventArgs : EventArgs {
    private SemaphoreSlim _semaphore;
    private VideoFrame _videoFrame;
    private VideoFrame _videoFrameCopy;
    public VideoFrame VideoFrame { get; internal set; }
    public VideoFrame get_VideoFrame();
    internal void set_VideoFrame(VideoFrame value);
}
[ObsoleteAttribute("IObjectSerializer has been migrated to the Microsoft.Toolkit (CommunityToolkit.Common) package.")]
public interface Microsoft.Toolkit.Uwp.Helpers.IObjectSerializer {
    public abstract virtual object Serialize(T value);
    public abstract virtual T Deserialize(object value);
}
[ObsoleteAttribute("IObjectStorageHelper is deprecated. Please use ISettingsStorageHelper and IFileStorageHelper interfaces instead.")]
public interface Microsoft.Toolkit.Uwp.Helpers.IObjectStorageHelper {
    public abstract virtual bool KeyExists(string key);
    public abstract virtual bool KeyExists(string compositeKey, string key);
    public abstract virtual T Read(string key, T default);
    public abstract virtual T Read(string compositeKey, string key, T default);
    public abstract virtual void Save(string key, T value);
    public abstract virtual void Save(string compositeKey, IDictionary`2<string, T> values);
    public abstract virtual Task`1<bool> FileExistsAsync(string filePath);
    public abstract virtual Task`1<T> ReadFileAsync(string filePath, T default);
    public abstract virtual Task`1<StorageFile> SaveFileAsync(string filePath, T value);
}
[ObsoleteAttribute("LocalObjectStorageHelper is deprecated and has been superceded by the ApplicationDataStorageHelper. To upgrade, simply swap any LocalObjectStorageHelper instances with ApplicationDataStorageHelper.GetCurrent(serializer). The underlying interfaces are nearly identical but now with even more features available, such as deletion and access to user specific data stores!")]
public class Microsoft.Toolkit.Uwp.Helpers.LocalObjectStorageHelper : BaseObjectStorageHelper {
    public LocalObjectStorageHelper(IObjectSerializer objectSerializer);
}
public class Microsoft.Toolkit.Uwp.Helpers.OSVersion : ValueType {
    public ushort Major;
    public ushort Minor;
    public ushort Build;
    public ushort Revision;
    public virtual string ToString();
}
[ExtensionAttribute]
public static class Microsoft.Toolkit.Uwp.Helpers.PackageVersionHelper : object {
    [ExtensionAttribute]
public static string ToFormattedString(PackageVersion packageVersion, int significance);
    [ExtensionAttribute]
public static PackageVersion ToPackageVersion(string formattedVersionNumber);
    [CompilerGeneratedAttribute]
internal static string <ToFormattedString>g__ThrowArgumentOutOfRangeException|0_0();
}
public class Microsoft.Toolkit.Uwp.Helpers.PrintHelper : object {
    [CompilerGeneratedAttribute]
private Action OnPrintSucceeded;
    [CompilerGeneratedAttribute]
private Action OnPrintFailed;
    [CompilerGeneratedAttribute]
private Action OnPrintCanceled;
    [CompilerGeneratedAttribute]
private Action`1<List`1<FrameworkElement>> OnPreviewPagesCreated;
    [CompilerGeneratedAttribute]
private double <ApplicationContentMarginLeft>k__BackingField;
    [CompilerGeneratedAttribute]
private double <ApplicationContentMarginTop>k__BackingField;
    private PrintDocument _printDocument;
    private IPrintDocumentSource _printDocumentSource;
    private List`1<FrameworkElement> _printPreviewPages;
    private Canvas _printCanvas;
    private Panel _canvasContainer;
    private string _printTaskName;
    private Dictionary`2<FrameworkElement, PrintHelperStateBag> _stateBags;
    private bool _directPrint;
    private List`1<FrameworkElement> _elementsToPrint;
    private PrintHelperOptions _printHelperOptions;
    private PrintHelperOptions _defaultPrintHelperOptions;
    [CompilerGeneratedAttribute]
private DispatcherQueue <DispatcherQueue>k__BackingField;
    public double ApplicationContentMarginLeft { get; public set; }
    public double ApplicationContentMarginTop { get; public set; }
    public DispatcherQueue DispatcherQueue { get; public set; }
    public PrintHelper(Panel canvasContainer, PrintHelperOptions defaultPrintHelperOptions, DispatcherQueue dispatcherQueue);
    [CompilerGeneratedAttribute]
public void add_OnPrintSucceeded(Action value);
    [CompilerGeneratedAttribute]
public void remove_OnPrintSucceeded(Action value);
    [CompilerGeneratedAttribute]
public void add_OnPrintFailed(Action value);
    [CompilerGeneratedAttribute]
public void remove_OnPrintFailed(Action value);
    [CompilerGeneratedAttribute]
public void add_OnPrintCanceled(Action value);
    [CompilerGeneratedAttribute]
public void remove_OnPrintCanceled(Action value);
    [CompilerGeneratedAttribute]
public void add_OnPreviewPagesCreated(Action`1<List`1<FrameworkElement>> value);
    [CompilerGeneratedAttribute]
public void remove_OnPreviewPagesCreated(Action`1<List`1<FrameworkElement>> value);
    [CompilerGeneratedAttribute]
public double get_ApplicationContentMarginLeft();
    [CompilerGeneratedAttribute]
public void set_ApplicationContentMarginLeft(double value);
    [CompilerGeneratedAttribute]
public double get_ApplicationContentMarginTop();
    [CompilerGeneratedAttribute]
public void set_ApplicationContentMarginTop(double value);
    [CompilerGeneratedAttribute]
public DispatcherQueue get_DispatcherQueue();
    [CompilerGeneratedAttribute]
public void set_DispatcherQueue(DispatcherQueue value);
    public void AddFrameworkElementToPrint(FrameworkElement element);
    public void RemoveFrameworkElementToPrint(FrameworkElement element);
    public void ClearListOfPrintableFrameworkElements();
    [AsyncStateMachineAttribute("Microsoft.Toolkit.Uwp.Helpers.PrintHelper/<ShowPrintUIAsync>d__39")]
public Task ShowPrintUIAsync(string printTaskName, bool directPrint);
    public Task ShowPrintUIAsync(string printTaskName, PrintHelperOptions printHelperOptions, bool directPrint);
    public sealed virtual void Dispose();
    private void RegisterForPrinting();
    [AsyncStateMachineAttribute("Microsoft.Toolkit.Uwp.Helpers.PrintHelper/<DetachCanvas>d__43")]
private Task DetachCanvas();
    private void PrintTaskRequested(PrintManager sender, PrintTaskRequestedEventArgs e);
    private void ApplyPrintSettings(PrintTask printTask);
    [AsyncStateMachineAttribute("Microsoft.Toolkit.Uwp.Helpers.PrintHelper/<CreatePrintPreviewPages>d__46")]
private void CreatePrintPreviewPages(object sender, PaginateEventArgs e);
    private void GetPrintPreviewPage(object sender, GetPreviewPageEventArgs e);
    private void AddPrintPages(object sender, AddPagesEventArgs e);
    private Task AddOnePrintPreviewPage(FrameworkElement element, PrintPageDescription printPageDescription);
    private Task ClearPageCache();
    [CompilerGeneratedAttribute]
private void <Dispose>b__41_0();
    [CompilerGeneratedAttribute]
private void <DetachCanvas>b__43_0();
    [CompilerGeneratedAttribute]
private void <ClearPageCache>b__50_0();
}
public class Microsoft.Toolkit.Uwp.Helpers.PrintHelperOptions : object {
    [CompilerGeneratedAttribute]
private PrintBordering <Bordering>k__BackingField;
    [CompilerGeneratedAttribute]
private PrintMediaType <MediaType>k__BackingField;
    [CompilerGeneratedAttribute]
private PrintMediaSize <MediaSize>k__BackingField;
    [CompilerGeneratedAttribute]
private PrintHolePunch <HolePunch>k__BackingField;
    [CompilerGeneratedAttribute]
private PrintBinding <Binding>k__BackingField;
    [CompilerGeneratedAttribute]
private PrintDuplex <Duplex>k__BackingField;
    [CompilerGeneratedAttribute]
private PrintColorMode <ColorMode>k__BackingField;
    [CompilerGeneratedAttribute]
private PrintCollation <Collation>k__BackingField;
    [CompilerGeneratedAttribute]
private PrintQuality <PrintQuality>k__BackingField;
    [CompilerGeneratedAttribute]
private PrintStaple <Staple>k__BackingField;
    [CompilerGeneratedAttribute]
private PrintOrientation <Orientation>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <DisplayedOptions>k__BackingField;
    private IEnumerable`1<string> _possibleDisplayOptions;
    [CompilerGeneratedAttribute]
private bool <ExtendDisplayedOptions>k__BackingField;
    public PrintBordering Bordering { get; public set; }
    public PrintMediaType MediaType { get; public set; }
    public PrintMediaSize MediaSize { get; public set; }
    public PrintHolePunch HolePunch { get; public set; }
    public PrintBinding Binding { get; public set; }
    public PrintDuplex Duplex { get; public set; }
    public PrintColorMode ColorMode { get; public set; }
    public PrintCollation Collation { get; public set; }
    public PrintQuality PrintQuality { get; public set; }
    public PrintStaple Staple { get; public set; }
    public PrintOrientation Orientation { get; public set; }
    public IList`1<string> DisplayedOptions { get; private set; }
    public bool ExtendDisplayedOptions { get; public set; }
    public PrintHelperOptions(bool extendDisplayedOptions);
    [CompilerGeneratedAttribute]
public PrintBordering get_Bordering();
    [CompilerGeneratedAttribute]
public void set_Bordering(PrintBordering value);
    [CompilerGeneratedAttribute]
public PrintMediaType get_MediaType();
    [CompilerGeneratedAttribute]
public void set_MediaType(PrintMediaType value);
    [CompilerGeneratedAttribute]
public PrintMediaSize get_MediaSize();
    [CompilerGeneratedAttribute]
public void set_MediaSize(PrintMediaSize value);
    [CompilerGeneratedAttribute]
public PrintHolePunch get_HolePunch();
    [CompilerGeneratedAttribute]
public void set_HolePunch(PrintHolePunch value);
    [CompilerGeneratedAttribute]
public PrintBinding get_Binding();
    [CompilerGeneratedAttribute]
public void set_Binding(PrintBinding value);
    [CompilerGeneratedAttribute]
public PrintDuplex get_Duplex();
    [CompilerGeneratedAttribute]
public void set_Duplex(PrintDuplex value);
    [CompilerGeneratedAttribute]
public PrintColorMode get_ColorMode();
    [CompilerGeneratedAttribute]
public void set_ColorMode(PrintColorMode value);
    [CompilerGeneratedAttribute]
public PrintCollation get_Collation();
    [CompilerGeneratedAttribute]
public void set_Collation(PrintCollation value);
    [CompilerGeneratedAttribute]
public PrintQuality get_PrintQuality();
    [CompilerGeneratedAttribute]
public void set_PrintQuality(PrintQuality value);
    [CompilerGeneratedAttribute]
public PrintStaple get_Staple();
    [CompilerGeneratedAttribute]
public void set_Staple(PrintStaple value);
    [CompilerGeneratedAttribute]
public PrintOrientation get_Orientation();
    [CompilerGeneratedAttribute]
public void set_Orientation(PrintOrientation value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_DisplayedOptions();
    [CompilerGeneratedAttribute]
private void set_DisplayedOptions(IList`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_ExtendDisplayedOptions();
    [CompilerGeneratedAttribute]
public void set_ExtendDisplayedOptions(bool value);
    public void AddDisplayOption(string displayOption);
    public void RemoveDisplayOption(string displayOption);
    private void InitializePossibleDisplayOptions();
}
internal class Microsoft.Toolkit.Uwp.Helpers.PrintHelperStateBag : object {
    private DispatcherQueue _dispatcherQueue;
    [CompilerGeneratedAttribute]
private HorizontalAlignment <HorizontalAlignment>k__BackingField;
    [CompilerGeneratedAttribute]
private VerticalAlignment <VerticalAlignment>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private Thickness <Margin>k__BackingField;
    public HorizontalAlignment HorizontalAlignment { get; public set; }
    public VerticalAlignment VerticalAlignment { get; public set; }
    public double Width { get; public set; }
    public double Height { get; public set; }
    public Thickness Margin { get; public set; }
    internal PrintHelperStateBag(DispatcherQueue dispatcherQueue);
    [CompilerGeneratedAttribute]
public HorizontalAlignment get_HorizontalAlignment();
    [CompilerGeneratedAttribute]
public void set_HorizontalAlignment(HorizontalAlignment value);
    [CompilerGeneratedAttribute]
public VerticalAlignment get_VerticalAlignment();
    [CompilerGeneratedAttribute]
public void set_VerticalAlignment(VerticalAlignment value);
    [CompilerGeneratedAttribute]
public double get_Width();
    [CompilerGeneratedAttribute]
public void set_Width(double value);
    [CompilerGeneratedAttribute]
public double get_Height();
    [CompilerGeneratedAttribute]
public void set_Height(double value);
    [CompilerGeneratedAttribute]
public Thickness get_Margin();
    [CompilerGeneratedAttribute]
public void set_Margin(Thickness value);
    public void Capture(FrameworkElement element);
    public void Restore(FrameworkElement element);
}
public class Microsoft.Toolkit.Uwp.Helpers.QueryParameterCollection : Collection`1<KeyValuePair`2<string, string>> {
    public QueryParameterCollection(Uri uri);
    public QueryParameterCollection(string uri);
    private static IList`1<KeyValuePair`2<string, string>> CreatePairsFromUri(string uri);
}
public class Microsoft.Toolkit.Uwp.Helpers.RemoteDeviceHelper : object {
    [CompilerGeneratedAttribute]
private ObservableCollection`1<RemoteSystem> <RemoteSystems>k__BackingField;
    private RemoteSystemWatcher _remoteSystemWatcher;
    [CompilerGeneratedAttribute]
private DispatcherQueue <DispatcherQueue>k__BackingField;
    public ObservableCollection`1<RemoteSystem> RemoteSystems { get; private set; }
    public DispatcherQueue DispatcherQueue { get; public set; }
    public RemoteDeviceHelper(DispatcherQueue dispatcherQueue);
    public RemoteDeviceHelper(List`1<IRemoteSystemFilter> filter, DispatcherQueue dispatcherQueue);
    [CompilerGeneratedAttribute]
public ObservableCollection`1<RemoteSystem> get_RemoteSystems();
    [CompilerGeneratedAttribute]
private void set_RemoteSystems(ObservableCollection`1<RemoteSystem> value);
    [CompilerGeneratedAttribute]
public DispatcherQueue get_DispatcherQueue();
    [CompilerGeneratedAttribute]
public void set_DispatcherQueue(DispatcherQueue value);
    public void GenerateSystems();
    [AsyncStateMachineAttribute("Microsoft.Toolkit.Uwp.Helpers.RemoteDeviceHelper/<GenerateSystemsWithFilterAsync>d__12")]
private void GenerateSystemsWithFilterAsync(List`1<IRemoteSystemFilter> filter);
    private void RemoteSystemWatcher_EnumerationCompleted(RemoteSystemWatcher sender, RemoteSystemEnumerationCompletedEventArgs args);
    [AsyncStateMachineAttribute("Microsoft.Toolkit.Uwp.Helpers.RemoteDeviceHelper/<RemoteSystemWatcher_RemoteSystemUpdated>d__14")]
private void RemoteSystemWatcher_RemoteSystemUpdated(RemoteSystemWatcher sender, RemoteSystemUpdatedEventArgs args);
    [AsyncStateMachineAttribute("Microsoft.Toolkit.Uwp.Helpers.RemoteDeviceHelper/<RemoteSystemWatcher_RemoteSystemRemoved>d__15")]
private void RemoteSystemWatcher_RemoteSystemRemoved(RemoteSystemWatcher sender, RemoteSystemRemovedEventArgs args);
    [AsyncStateMachineAttribute("Microsoft.Toolkit.Uwp.Helpers.RemoteDeviceHelper/<RemoteSystemWatcher_RemoteSystemAdded>d__16")]
private void RemoteSystemWatcher_RemoteSystemAdded(RemoteSystemWatcher sender, RemoteSystemAddedEventArgs args);
}
[ObsoleteAttribute("Package State Roaming will be removed in a futures Windows Update, see https://docs.microsoft.com/windows/deployment/planning/windows-10-deprecated-features for more information.")]
public class Microsoft.Toolkit.Uwp.Helpers.RoamingObjectStorageHelper : BaseObjectStorageHelper {
    public RoamingObjectStorageHelper(IObjectSerializer objectSerializer);
}
public enum Microsoft.Toolkit.Uwp.Helpers.ScreenUnit : Enum {
    public int value__;
    public static ScreenUnit Pixel;
    public static ScreenUnit Centimeter;
    public static ScreenUnit Inch;
    public static ScreenUnit EffectivePixel;
}
public static class Microsoft.Toolkit.Uwp.Helpers.ScreenUnitHelper : object {
    private static float PixelToCentimeterRatio;
    private static float PixelToInchRatio;
    private static float CentimeterToInchRatio;
    public static float Convert(ScreenUnit from, ScreenUnit to, float value, XamlRoot xamlRoot);
    private static float GetScale(XamlRoot xamlRoot);
}
[ExtensionAttribute]
public static class Microsoft.Toolkit.Uwp.Helpers.StorageFileHelper : object {
    public static Task`1<StorageFile> WriteTextToLocalFileAsync(string text, string fileName, CreationCollisionOption options);
    public static Task`1<StorageFile> WriteTextToLocalCacheFileAsync(string text, string fileName, CreationCollisionOption options);
    public static Task`1<StorageFile> WriteTextToKnownFolderFileAsync(KnownFolderId knownFolderId, string text, string fileName, CreationCollisionOption options);
    [AsyncStateMachineAttribute("Microsoft.Toolkit.Uwp.Helpers.StorageFileHelper/<WriteTextToFileAsync>d__3")]
[ExtensionAttribute]
public static Task`1<StorageFile> WriteTextToFileAsync(StorageFolder fileLocation, string text, string fileName, CreationCollisionOption options);
    public static Task`1<StorageFile> WriteBytesToLocalFileAsync(Byte[] bytes, string fileName, CreationCollisionOption options);
    public static Task`1<StorageFile> WriteBytesToLocalCacheFileAsync(Byte[] bytes, string fileName, CreationCollisionOption options);
    public static Task`1<StorageFile> WriteBytesToKnownFolderFileAsync(KnownFolderId knownFolderId, Byte[] bytes, string fileName, CreationCollisionOption options);
    [AsyncStateMachineAttribute("Microsoft.Toolkit.Uwp.Helpers.StorageFileHelper/<WriteBytesToFileAsync>d__7")]
[ExtensionAttribute]
public static Task`1<StorageFile> WriteBytesToFileAsync(StorageFolder fileLocation, Byte[] bytes, string fileName, CreationCollisionOption options);
    public static Task`1<string> ReadTextFromPackagedFileAsync(string fileName);
    public static Task`1<string> ReadTextFromLocalCacheFileAsync(string fileName);
    public static Task`1<string> ReadTextFromLocalFileAsync(string fileName);
    public static Task`1<string> ReadTextFromKnownFoldersFileAsync(KnownFolderId knownFolderId, string fileName);
    [AsyncStateMachineAttribute("Microsoft.Toolkit.Uwp.Helpers.StorageFileHelper/<ReadTextFromFileAsync>d__12")]
[ExtensionAttribute]
public static Task`1<string> ReadTextFromFileAsync(StorageFolder fileLocation, string fileName);
    public static Task`1<Byte[]> ReadBytesFromPackagedFileAsync(string fileName);
    public static Task`1<Byte[]> ReadBytesFromLocalCacheFileAsync(string fileName);
    public static Task`1<Byte[]> ReadBytesFromLocalFileAsync(string fileName);
    public static Task`1<Byte[]> ReadBytesFromKnownFoldersFileAsync(KnownFolderId knownFolderId, string fileName);
    [AsyncStateMachineAttribute("Microsoft.Toolkit.Uwp.Helpers.StorageFileHelper/<ReadBytesFromFileAsync>d__17")]
[ExtensionAttribute]
public static Task`1<Byte[]> ReadBytesFromFileAsync(StorageFolder fileLocation, string fileName);
    [AsyncStateMachineAttribute("Microsoft.Toolkit.Uwp.Helpers.StorageFileHelper/<ReadBytesAsync>d__18")]
[ExtensionAttribute]
public static Task`1<Byte[]> ReadBytesAsync(StorageFile file);
    [ExtensionAttribute]
public static Task`1<bool> FileExistsAsync(StorageFolder folder, string fileName, bool isRecursive);
    public static bool IsFileNameValid(string fileName);
    public static bool IsFilePathValid(string filePath);
    [AsyncStateMachineAttribute("Microsoft.Toolkit.Uwp.Helpers.StorageFileHelper/<FileExistsInFolderAsync>d__22")]
internal static Task`1<bool> FileExistsInFolderAsync(StorageFolder folder, string fileName);
    [AsyncStateMachineAttribute("Microsoft.Toolkit.Uwp.Helpers.StorageFileHelper/<FileExistsInSubtreeAsync>d__23")]
internal static Task`1<bool> FileExistsInSubtreeAsync(StorageFolder rootFolder, string fileName);
    internal static StorageFolder GetFolderFromKnownFolderId(KnownFolderId knownFolderId);
}
[ExtensionAttribute]
public static class Microsoft.Toolkit.Uwp.Helpers.StreamHelper : object {
    private static HttpClient client;
    private static StreamHelper();
    [AsyncStateMachineAttribute("Microsoft.Toolkit.Uwp.Helpers.StreamHelper/<GetHttpStreamAsync>d__1")]
[ExtensionAttribute]
public static Task`1<IRandomAccessStream> GetHttpStreamAsync(Uri uri, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Toolkit.Uwp.Helpers.StreamHelper/<GetHttpStreamToStorageFileAsync>d__2")]
[ExtensionAttribute]
public static Task GetHttpStreamToStorageFileAsync(Uri uri, StorageFile targetFile);
    public static Task`1<IRandomAccessStream> GetPackagedFileStreamAsync(string fileName, FileAccessMode accessMode);
    public static Task`1<IRandomAccessStream> GetLocalFileStreamAsync(string fileName, FileAccessMode accessMode);
    public static Task`1<IRandomAccessStream> GetLocalCacheFileStreamAsync(string fileName, FileAccessMode accessMode);
    public static Task`1<IRandomAccessStream> GetKnowFoldersFileStreamAsync(KnownFolderId knownFolderId, string fileName, FileAccessMode accessMode);
    [AsyncStateMachineAttribute("Microsoft.Toolkit.Uwp.Helpers.StreamHelper/<ReadTextAsync>d__7")]
[ExtensionAttribute]
public static Task`1<string> ReadTextAsync(IRandomAccessStream stream, Encoding encoding);
    [AsyncStateMachineAttribute("Microsoft.Toolkit.Uwp.Helpers.StreamHelper/<GetFileStreamAsync>d__8")]
private static Task`1<IRandomAccessStream> GetFileStreamAsync(string fullFileName, FileAccessMode accessMode, StorageFolder workingFolder);
    [AsyncStateMachineAttribute("Microsoft.Toolkit.Uwp.Helpers.StreamHelper/<GetSubFolderAsync>d__9")]
private static Task`1<StorageFolder> GetSubFolderAsync(string fullFileName, StorageFolder workingFolder);
}
public class Microsoft.Toolkit.Uwp.Helpers.SystemInformation : object {
    private ApplicationDataStorageHelper _settingsStorage;
    private DateTime _sessionStart;
    [CompilerGeneratedAttribute]
private static SystemInformation <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ApplicationName>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageVersion <ApplicationVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureInfo <Culture>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeviceFamily>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OperatingSystem>k__BackingField;
    [CompilerGeneratedAttribute]
private OSVersion <OperatingSystemVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ProcessorArchitecture <OperatingSystemArchitecture>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeviceModel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeviceManufacturer>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFirstRun>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAppUpdated>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageVersion <FirstVersionInstalled>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageVersion <PreviousVersionInstalled>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <FirstUseTime>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastLaunchTime>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LaunchCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalLaunchCount>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LaunchTime>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastResetTime>k__BackingField;
    public static SystemInformation Instance { get; }
    public string ApplicationName { get; }
    public PackageVersion ApplicationVersion { get; }
    public CultureInfo Culture { get; }
    public string DeviceFamily { get; }
    public string OperatingSystem { get; }
    public OSVersion OperatingSystemVersion { get; }
    public ProcessorArchitecture OperatingSystemArchitecture { get; }
    public float AvailableMemory { get; }
    public string DeviceModel { get; }
    public string DeviceManufacturer { get; }
    public bool IsFirstRun { get; }
    public bool IsAppUpdated { get; }
    public PackageVersion FirstVersionInstalled { get; }
    public PackageVersion PreviousVersionInstalled { get; }
    public DateTime FirstUseTime { get; }
    public DateTime LastLaunchTime { get; private set; }
    public long LaunchCount { get; private set; }
    public long TotalLaunchCount { get; private set; }
    public DateTime LaunchTime { get; private set; }
    public DateTime LastResetTime { get; private set; }
    public TimeSpan AppUptime { get; }
    private static SystemInformation();
    [CompilerGeneratedAttribute]
public static SystemInformation get_Instance();
    [CompilerGeneratedAttribute]
public string get_ApplicationName();
    [CompilerGeneratedAttribute]
public PackageVersion get_ApplicationVersion();
    [CompilerGeneratedAttribute]
public CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
public string get_DeviceFamily();
    [CompilerGeneratedAttribute]
public string get_OperatingSystem();
    [CompilerGeneratedAttribute]
public OSVersion get_OperatingSystemVersion();
    [CompilerGeneratedAttribute]
public ProcessorArchitecture get_OperatingSystemArchitecture();
    public float get_AvailableMemory();
    [CompilerGeneratedAttribute]
public string get_DeviceModel();
    [CompilerGeneratedAttribute]
public string get_DeviceManufacturer();
    [CompilerGeneratedAttribute]
public bool get_IsFirstRun();
    [CompilerGeneratedAttribute]
public bool get_IsAppUpdated();
    [CompilerGeneratedAttribute]
public PackageVersion get_FirstVersionInstalled();
    [CompilerGeneratedAttribute]
public PackageVersion get_PreviousVersionInstalled();
    [CompilerGeneratedAttribute]
public DateTime get_FirstUseTime();
    [CompilerGeneratedAttribute]
public DateTime get_LastLaunchTime();
    [CompilerGeneratedAttribute]
private void set_LastLaunchTime(DateTime value);
    [CompilerGeneratedAttribute]
public long get_LaunchCount();
    [CompilerGeneratedAttribute]
private void set_LaunchCount(long value);
    [CompilerGeneratedAttribute]
public long get_TotalLaunchCount();
    [CompilerGeneratedAttribute]
private void set_TotalLaunchCount(long value);
    [CompilerGeneratedAttribute]
public DateTime get_LaunchTime();
    [CompilerGeneratedAttribute]
private void set_LaunchTime(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_LastResetTime();
    [CompilerGeneratedAttribute]
private void set_LastResetTime(DateTime value);
    public TimeSpan get_AppUptime();
    public void AddToAppUptime(TimeSpan duration);
    public void ResetLaunchCount();
    public void TrackAppUse(IActivatedEventArgs args, XamlRoot xamlRoot);
    private void UpdateVisibility(bool visible);
    private bool DetectIfFirstUse();
    private ValueTuple`2<bool, PackageVersion> DetectIfAppUpdated();
    private DateTime DetectFirstUseTime();
    private PackageVersion DetectFirstVersionInstalled();
    private void InitializeValuesSetWithTrackAppUse();
    public static Task LaunchStoreForReviewAsync();
    [CompilerGeneratedAttribute]
private void <TrackAppUse>g__XamlRoot_Changed|74_0(XamlRoot sender, XamlRootChangedEventArgs e);
    [CompilerGeneratedAttribute]
private void <TrackAppUse>g__App_VisibilityChanged|74_1(CoreWindow sender, VisibilityChangedEventArgs e);
}
[ObsoleteAttribute("SystemSerializer has been migrated to the Microsoft.Toolkit (CommunityToolkit.Common) package.")]
public class Microsoft.Toolkit.Uwp.Helpers.SystemSerializer : object {
    public sealed virtual T Deserialize(object value);
    public sealed virtual object Serialize(T value);
    [CompilerGeneratedAttribute]
internal static T <Deserialize>g__ThrowNotSupportedException|0_0();
}
[EditorBrowsableAttribute("1")]
public class Microsoft.Toolkit.Uwp.Helpers.WeakEventListener`3 : object {
    private WeakReference _weakInstance;
    [CompilerGeneratedAttribute]
private Action`3<TInstance, TSource, TEventArgs> <OnEventAction>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<WeakEventListener`3<TInstance, TSource, TEventArgs>> <OnDetachAction>k__BackingField;
    public Action`3<TInstance, TSource, TEventArgs> OnEventAction { get; public set; }
    public Action`1<WeakEventListener`3<TInstance, TSource, TEventArgs>> OnDetachAction { get; public set; }
    public WeakEventListener`3(TInstance instance);
    [CompilerGeneratedAttribute]
public Action`3<TInstance, TSource, TEventArgs> get_OnEventAction();
    [CompilerGeneratedAttribute]
public void set_OnEventAction(Action`3<TInstance, TSource, TEventArgs> value);
    [CompilerGeneratedAttribute]
public Action`1<WeakEventListener`3<TInstance, TSource, TEventArgs>> get_OnDetachAction();
    [CompilerGeneratedAttribute]
public void set_OnDetachAction(Action`1<WeakEventListener`3<TInstance, TSource, TEventArgs>> value);
    public void OnEvent(TSource source, TEventArgs eventArgs);
    public void Detach();
}
public class Microsoft.Toolkit.Uwp.HslColor : ValueType {
    public double H;
    public double S;
    public double L;
    public double A;
}
public class Microsoft.Toolkit.Uwp.HsvColor : ValueType {
    public double H;
    public double S;
    public double V;
    public double A;
}
public class Microsoft.Toolkit.Uwp.IncrementalLoadingCollection`2 : ObservableCollection`1<IType> {
    private SemaphoreSlim _mutex;
    [CompilerGeneratedAttribute]
private Action <OnStartLoading>k__BackingField;
    [CompilerGeneratedAttribute]
private Action <OnEndLoading>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<Exception> <OnError>k__BackingField;
    [CompilerGeneratedAttribute]
private TSource <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ItemsPerPage>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentPageIndex>k__BackingField;
    private bool _isLoading;
    private bool _hasMoreItems;
    private CancellationToken _cancellationToken;
    private bool _refreshOnLoad;
    public Action OnStartLoading { get; public set; }
    public Action OnEndLoading { get; public set; }
    public Action`1<Exception> OnError { get; public set; }
    protected TSource Source { get; }
    protected int ItemsPerPage { get; }
    protected int CurrentPageIndex { get; protected set; }
    public bool IsLoading { get; private set; }
    public bool HasMoreItems { get; private set; }
    public IncrementalLoadingCollection`2(int itemsPerPage, Action onStartLoading, Action onEndLoading, Action`1<Exception> onError);
    public IncrementalLoadingCollection`2(TSource source, int itemsPerPage, Action onStartLoading, Action onEndLoading, Action`1<Exception> onError);
    [CompilerGeneratedAttribute]
public Action get_OnStartLoading();
    [CompilerGeneratedAttribute]
public void set_OnStartLoading(Action value);
    [CompilerGeneratedAttribute]
public Action get_OnEndLoading();
    [CompilerGeneratedAttribute]
public void set_OnEndLoading(Action value);
    [CompilerGeneratedAttribute]
public Action`1<Exception> get_OnError();
    [CompilerGeneratedAttribute]
public void set_OnError(Action`1<Exception> value);
    [CompilerGeneratedAttribute]
protected TSource get_Source();
    [CompilerGeneratedAttribute]
protected int get_ItemsPerPage();
    [CompilerGeneratedAttribute]
protected int get_CurrentPageIndex();
    [CompilerGeneratedAttribute]
protected void set_CurrentPageIndex(int value);
    public bool get_IsLoading();
    private void set_IsLoading(bool value);
    public sealed virtual bool get_HasMoreItems();
    private void set_HasMoreItems(bool value);
    public sealed virtual IAsyncOperation`1<LoadMoreItemsResult> LoadMoreItemsAsync(UInt32 count);
    public Task RefreshAsync();
    [AsyncStateMachineAttribute("Microsoft.Toolkit.Uwp.IncrementalLoadingCollection`2/<LoadDataAsync>d__37")]
protected virtual Task`1<IEnumerable`1<IType>> LoadDataAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Toolkit.Uwp.IncrementalLoadingCollection`2/<LoadMoreItemsAsync>d__38")]
private Task`1<LoadMoreItemsResult> LoadMoreItemsAsync(UInt32 count, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private IEnumerable`1<IType> <LoadDataAsync>b__37_0(Task`1<IEnumerable`1<IType>> t);
}
[ExtensionAttribute]
public static class Microsoft.Toolkit.Uwp.PointExtensions : object {
    [ExtensionAttribute]
public static Rect ToRect(Point point, double width, double height);
    [ExtensionAttribute]
public static Rect ToRect(Point point, Point end);
    [ExtensionAttribute]
public static Rect ToRect(Point point, Size size);
    [ExtensionAttribute]
public static Vector3 ToVector3(Point point);
}
[ExtensionAttribute]
public static class Microsoft.Toolkit.Uwp.RectExtensions : object {
    [ExtensionAttribute]
public static bool IntersectsWith(Rect rect1, Rect rect2);
    [ExtensionAttribute]
public static Size ToSize(Rect rect);
}
[ExtensionAttribute]
public static class Microsoft.Toolkit.Uwp.SizeExtensions : object {
    [ExtensionAttribute]
public static Rect ToRect(Size size);
    [ExtensionAttribute]
public static Rect ToRect(Size size, double x, double y);
    [ExtensionAttribute]
public static Rect ToRect(Size size, Point point);
}
[ExtensionAttribute]
public static class Microsoft.Toolkit.Uwp.StringExtensions : object {
    private static ResourceLoader IndependentLoader;
    private static StringExtensions();
    [ExtensionAttribute]
public static string GetViewLocalized(string resourceKey, UIContext uiContext);
    [ExtensionAttribute]
public static string GetLocalized(string resourceKey, UIContext uiContext);
    [ExtensionAttribute]
public static string GetLocalized(string resourceKey, string resourcePath);
}
[ExtensionAttribute]
public static class Microsoft.Toolkit.Uwp.UI.DispatcherQueueTimerExtensions : object {
    private static ConcurrentDictionary`2<DispatcherQueueTimer, Action> _debounceInstances;
    private static DispatcherQueueTimerExtensions();
    [ExtensionAttribute]
public static void Debounce(DispatcherQueueTimer timer, Action action, TimeSpan interval, bool immediate);
    private static void Timer_Tick(object sender, object e);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
internal static class ThisAssembly : object {
    internal static string AssemblyVersion;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyConfiguration;
    internal static string GitCommitId;
    internal static bool IsPublicRelease;
    internal static bool IsPrerelease;
    internal static DateTime GitCommitDate;
    internal static string RootNamespace;
    private static ThisAssembly();
}
