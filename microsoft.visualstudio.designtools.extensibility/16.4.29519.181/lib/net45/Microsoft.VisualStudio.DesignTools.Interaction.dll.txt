internal class Microsoft.Internal.Performance.CodeMarkerExStartEnd : ValueType {
    private int _end;
    private Byte[] _aBuff;
    internal CodeMarkerExStartEnd(int begin, int end, Byte[] aBuff, bool correlated);
    internal CodeMarkerExStartEnd(int begin, int end, Guid guidData, bool correlated);
    internal CodeMarkerExStartEnd(int begin, int end, string stringData, bool correlated);
    internal CodeMarkerExStartEnd(int begin, int end, UInt32 uintData, bool correlated);
    internal CodeMarkerExStartEnd(int begin, int end, ulong ulongData, bool correlated);
    public sealed virtual void Dispose();
}
internal class Microsoft.Internal.Performance.CodeMarkers : object {
    public static CodeMarkers Instance;
    private static string AtomName;
    private static string TestDllName;
    private static string ProductDllName;
    private State state;
    private RegistryView registryView;
    private string regroot;
    private Nullable`1<bool> shouldUseTestDll;
    private static Byte[] CorrelationMarkBytes;
    public bool IsEnabled { get; }
    public bool ShouldUseTestDll { get; }
    private static CodeMarkers();
    public bool get_IsEnabled();
    public bool get_ShouldUseTestDll();
    public bool CodeMarker(int nTimerID);
    public bool CodeMarkerEx(int nTimerID, Byte[] aBuff);
    public void SetStateDLLException();
    public bool CodeMarkerEx(int nTimerID, Guid guidData);
    public bool CodeMarkerEx(int nTimerID, string stringData);
    internal static Byte[] StringToBytesZeroTerminated(string stringData);
    public static Byte[] AttachCorrelationId(Byte[] buffer, Guid correlationId);
    public bool CodeMarkerEx(int nTimerID, UInt32 uintData);
    public bool CodeMarkerEx(int nTimerID, ulong ulongData);
    private static bool UsePrivateCodeMarkers(string regRoot, RegistryView registryView);
}
internal class Microsoft.Internal.Performance.CodeMarkerStartEnd : ValueType {
    private int _end;
    private Byte[] _buffer;
    internal CodeMarkerStartEnd(int begin, int end, bool correlated);
    public sealed virtual void Dispose();
    private void CodeMarker(int id);
}
[AttributeUsageAttribute("128")]
public class Microsoft.VisualStudio.DesignTools.Extensibility.DataContextValueSourceAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <DataContextValueSourceProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCollectionItem>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AncestorPath>k__BackingField;
    public string DataContextValueSourceProperty { get; private set; }
    public bool IsCollectionItem { get; private set; }
    public string AncestorPath { get; private set; }
    public DataContextValueSourceAttribute(string dataContextValueSourceProperty, bool isCollectionItem);
    public DataContextValueSourceAttribute(string dataContextValueSourceProperty, string ancestorPath, bool isCollectionItem);
    [CompilerGeneratedAttribute]
public string get_DataContextValueSourceProperty();
    [CompilerGeneratedAttribute]
private void set_DataContextValueSourceProperty(string value);
    [CompilerGeneratedAttribute]
public bool get_IsCollectionItem();
    [CompilerGeneratedAttribute]
private void set_IsCollectionItem(bool value);
    [CompilerGeneratedAttribute]
public string get_AncestorPath();
    [CompilerGeneratedAttribute]
private void set_AncestorPath(string value);
}
[AttributeUsageAttribute("4")]
public class Microsoft.VisualStudio.DesignTools.Extensibility.DefaultSizeAttribute : Attribute {
    public static int DefaultWidth;
    public static int DefaultHeight;
    [CompilerGeneratedAttribute]
private Size <DefaultSize>k__BackingField;
    [CompilerGeneratedAttribute]
private DefaultSizeMode <Mode>k__BackingField;
    public Size DefaultSize { get; private set; }
    public DefaultSizeMode Mode { get; private set; }
    public DefaultSizeAttribute(Size defaultSize);
    public DefaultSizeAttribute(DefaultSizeMode mode);
    [CompilerGeneratedAttribute]
public Size get_DefaultSize();
    [CompilerGeneratedAttribute]
private void set_DefaultSize(Size value);
    [CompilerGeneratedAttribute]
public DefaultSizeMode get_Mode();
    [CompilerGeneratedAttribute]
private void set_Mode(DefaultSizeMode value);
}
public enum Microsoft.VisualStudio.DesignTools.Extensibility.DefaultSizeMode : Enum {
    public int value__;
    public static DefaultSizeMode Size;
    public static DefaultSizeMode Fill;
    public static DefaultSizeMode None;
}
internal static class Microsoft.VisualStudio.DesignTools.Extensibility.EnumValidator : object {
    public static bool IsValid(OrderTokenConflictResolution value);
    public static bool IsValid(OrderTokenPrecedence value);
}
public enum Microsoft.VisualStudio.DesignTools.Extensibility.HostKind : Enum {
    public int value__;
    public static HostKind VisualStudio;
    public static HostKind Blend;
}
[FeatureConnectorAttribute("MS.Internal.Features.AdapterFeatureConnector")]
public abstract class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.Adapter : FeatureProvider {
    public Type AdapterType { get; }
    public abstract virtual Type get_AdapterType();
}
public static class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.AdornerColors : object {
    private static ResourceKey _alignmentMarkBrushKey;
    private static ResourceKey _alignmentMarkColorKey;
    private static ResourceKey _elementBorderBrushKey;
    private static ResourceKey _elementBorderColorKey;
    private static ResourceKey _glyphFillBrushKey;
    private static ResourceKey _glyphFillColorKey;
    private static ResourceKey _handleBorderColorKey;
    private static ResourceKey _handleBorderBrushKey;
    private static ResourceKey _handleFillColorKey;
    private static ResourceKey _handleFillBrushKey;
    private static ResourceKey _handleFillHoverColorKey;
    private static ResourceKey _handleEmptyFillColorKey;
    private static ResourceKey _handleEmptyFillBrushKey;
    private static ResourceKey _handleFillHoverBrushKey;
    private static ResourceKey _handleFillPressedColorKey;
    private static ResourceKey _handleFillPressedBrushKey;
    private static ResourceKey _moveHandleContentBrushKey;
    private static ResourceKey _moveHandleContentColorKey;
    private static ResourceKey _moveHandleFillBrushKey;
    private static ResourceKey _moveHandleFillColorKey;
    private static ResourceKey _moveHandleFillHoverBrushKey;
    private static ResourceKey _moveHandleFillHoverColorKey;
    private static ResourceKey _railFillBrushKey;
    private static ResourceKey _railFillColorKey;
    private static ResourceKey _selectionFrameBorderBrushKey;
    private static ResourceKey _selectionFrameBorderColorKey;
    private static ResourceKey _selectionFrameFillBrushKey;
    private static ResourceKey _selectionFrameFillColorKey;
    private static ResourceKey _simpleWashBrushKey;
    private static ResourceKey _simpleWashColorKey;
    private static ResourceKey _toggledGlyphFillBrushKey;
    private static ResourceKey _toggledGlyphFillColorKey;
    public static Brush AlignmentMarkBrush { get; }
    public static ResourceKey AlignmentMarkBrushKey { get; }
    public static Color AlignmentMarkColor { get; }
    public static ResourceKey AlignmentMarkColorKey { get; }
    public static Brush ElementBorderBrush { get; }
    public static ResourceKey ElementBorderBrushKey { get; }
    public static Color ElementBorderColor { get; }
    public static ResourceKey ElementBorderColorKey { get; }
    public static Brush GlyphFillBrush { get; }
    public static ResourceKey GlyphFillBrushKey { get; }
    public static Color GlyphFillColor { get; }
    public static ResourceKey GlyphFillColorKey { get; }
    public static Brush HandleBorderBrush { get; }
    public static ResourceKey HandleBorderBrushKey { get; }
    public static Color HandleBorderColor { get; }
    public static ResourceKey HandleBorderColorKey { get; }
    public static Brush HandleFillBrush { get; }
    public static ResourceKey HandleFillBrushKey { get; }
    public static Color HandleFillColor { get; }
    public static ResourceKey HandleFillColorKey { get; }
    public static Brush HandleEmptyFillBrush { get; }
    public static ResourceKey HandleEmptyFillBrushKey { get; }
    public static Color HandleEmptyFillColor { get; }
    public static ResourceKey HandleEmptyFillColorKey { get; }
    public static Brush HandleFillHoverBrush { get; }
    public static ResourceKey HandleFillHoverBrushKey { get; }
    public static Color HandleFillHoverColor { get; }
    public static ResourceKey HandleFillHoverColorKey { get; }
    public static Brush HandleFillPressedBrush { get; }
    public static ResourceKey HandleFillPressedBrushKey { get; }
    public static Color HandleFillPressedColor { get; }
    public static ResourceKey HandleFillPressedColorKey { get; }
    public static Brush MoveHandleContentBrush { get; }
    public static ResourceKey MoveHandleContentBrushKey { get; }
    public static Color MoveHandleContentColor { get; }
    public static ResourceKey MoveHandleContentColorKey { get; }
    public static Brush MoveHandleFillBrush { get; }
    public static ResourceKey MoveHandleFillBrushKey { get; }
    public static Color MoveHandleFillColor { get; }
    public static ResourceKey MoveHandleFillColorKey { get; }
    public static Brush MoveHandleFillHoverBrush { get; }
    public static ResourceKey MoveHandleFillHoverBrushKey { get; }
    public static Color MoveHandleFillHoverColor { get; }
    public static ResourceKey MoveHandleFillHoverColorKey { get; }
    public static Brush RailFillBrush { get; }
    public static ResourceKey RailFillBrushKey { get; }
    public static Color RailFillColor { get; }
    public static ResourceKey RailFillColorKey { get; }
    public static Brush SelectionFrameBorderBrush { get; }
    public static ResourceKey SelectionFrameBorderBrushKey { get; }
    public static Color SelectionFrameBorderColor { get; }
    public static ResourceKey SelectionFrameBorderColorKey { get; }
    public static Brush SelectionFrameFillBrush { get; }
    public static ResourceKey SelectionFrameFillBrushKey { get; }
    public static Color SelectionFrameFillColor { get; }
    public static ResourceKey SelectionFrameFillColorKey { get; }
    public static Brush SimpleWashBrush { get; }
    public static ResourceKey SimpleWashBrushKey { get; }
    public static Color SimpleWashColor { get; }
    public static ResourceKey SimpleWashColorKey { get; }
    public static Brush ToggledGlyphFillBrush { get; }
    public static ResourceKey ToggledGlyphFillBrushKey { get; }
    public static Color ToggledGlyphFillColor { get; }
    public static ResourceKey ToggledGlyphFillColorKey { get; }
    private static AdornerColors();
    public static Brush get_AlignmentMarkBrush();
    public static ResourceKey get_AlignmentMarkBrushKey();
    public static Color get_AlignmentMarkColor();
    public static ResourceKey get_AlignmentMarkColorKey();
    public static Brush get_ElementBorderBrush();
    public static ResourceKey get_ElementBorderBrushKey();
    public static Color get_ElementBorderColor();
    public static ResourceKey get_ElementBorderColorKey();
    public static Brush get_GlyphFillBrush();
    public static ResourceKey get_GlyphFillBrushKey();
    public static Color get_GlyphFillColor();
    public static ResourceKey get_GlyphFillColorKey();
    public static Brush get_HandleBorderBrush();
    public static ResourceKey get_HandleBorderBrushKey();
    public static Color get_HandleBorderColor();
    public static ResourceKey get_HandleBorderColorKey();
    public static Brush get_HandleFillBrush();
    public static ResourceKey get_HandleFillBrushKey();
    public static Color get_HandleFillColor();
    public static ResourceKey get_HandleFillColorKey();
    public static Brush get_HandleEmptyFillBrush();
    public static ResourceKey get_HandleEmptyFillBrushKey();
    public static Color get_HandleEmptyFillColor();
    public static ResourceKey get_HandleEmptyFillColorKey();
    public static Brush get_HandleFillHoverBrush();
    public static ResourceKey get_HandleFillHoverBrushKey();
    public static Color get_HandleFillHoverColor();
    public static ResourceKey get_HandleFillHoverColorKey();
    public static Brush get_HandleFillPressedBrush();
    public static ResourceKey get_HandleFillPressedBrushKey();
    public static Color get_HandleFillPressedColor();
    public static ResourceKey get_HandleFillPressedColorKey();
    public static Brush get_MoveHandleContentBrush();
    public static ResourceKey get_MoveHandleContentBrushKey();
    public static Color get_MoveHandleContentColor();
    public static ResourceKey get_MoveHandleContentColorKey();
    public static Brush get_MoveHandleFillBrush();
    public static ResourceKey get_MoveHandleFillBrushKey();
    public static Color get_MoveHandleFillColor();
    public static ResourceKey get_MoveHandleFillColorKey();
    public static Brush get_MoveHandleFillHoverBrush();
    public static ResourceKey get_MoveHandleFillHoverBrushKey();
    public static Color get_MoveHandleFillHoverColor();
    public static ResourceKey get_MoveHandleFillHoverColorKey();
    public static Brush get_RailFillBrush();
    public static ResourceKey get_RailFillBrushKey();
    public static Color get_RailFillColor();
    public static ResourceKey get_RailFillColorKey();
    public static Brush get_SelectionFrameBorderBrush();
    public static ResourceKey get_SelectionFrameBorderBrushKey();
    public static Color get_SelectionFrameBorderColor();
    public static ResourceKey get_SelectionFrameBorderColorKey();
    public static Brush get_SelectionFrameFillBrush();
    public static ResourceKey get_SelectionFrameFillBrushKey();
    public static Color get_SelectionFrameFillColor();
    public static ResourceKey get_SelectionFrameFillColorKey();
    public static Brush get_SimpleWashBrush();
    public static ResourceKey get_SimpleWashBrushKey();
    public static Color get_SimpleWashColor();
    public static ResourceKey get_SimpleWashColorKey();
    public static Brush get_ToggledGlyphFillBrush();
    public static ResourceKey get_ToggledGlyphFillBrushKey();
    public static Color get_ToggledGlyphFillColor();
    public static ResourceKey get_ToggledGlyphFillColorKey();
    private static ResourceKey CreateKey(string name);
    private static Brush GetBrush(ResourceKey key);
    private static Color GetColor(ResourceKey key);
}
public abstract class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.AdornerCoordinateSpace : object {
    internal abstract virtual Rect GetBoundingBox(ViewItem element);
    internal abstract virtual FlowDirection GetFlowDirection(ViewItem element);
    internal abstract virtual Transform GetLayoutTransform(ViewItem element);
    internal abstract virtual Transform GetAncestorTransform(ViewItem element, UIElement ancestor);
    internal abstract virtual Vector GetOrigin(ViewItem element);
}
public static class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.AdornerCoordinateSpaces : object {
    private static AdornerCoordinateSpace _transform;
    [ThreadStaticAttribute]
private static Transform _ltr;
    [ThreadStaticAttribute]
private static Transform _rtl;
    private static Transform LTR { get; }
    public static AdornerCoordinateSpace Default { get; }
    private static Transform RTL { get; }
    private static Transform get_LTR();
    public static AdornerCoordinateSpace get_Default();
    private static Transform get_RTL();
}
public static class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.AdornerFonts : object {
    private static ResourceKey _fontFamilyKey;
    private static ResourceKey _fontSizeKey;
    public static ResourceKey FontFamilyKey { get; }
    public static ResourceKey FontSizeKey { get; }
    public static FontFamily FontFamily { get; }
    public static double FontSize { get; }
    private static AdornerFonts();
    public static ResourceKey get_FontFamilyKey();
    public static ResourceKey get_FontSizeKey();
    public static FontFamily get_FontFamily();
    public static double get_FontSize();
    private static ResourceKey CreateKey(string name);
    private static double GetFontSize(ResourceKey key);
    private static FontFamily GetFontFamily(ResourceKey key);
}
public enum Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.AdornerHorizontalAlignment : Enum {
    public int value__;
    public static AdornerHorizontalAlignment Left;
    public static AdornerHorizontalAlignment Center;
    public static AdornerHorizontalAlignment Right;
    public static AdornerHorizontalAlignment Stretch;
    public static AdornerHorizontalAlignment OutsideLeft;
    public static AdornerHorizontalAlignment OutsideRight;
}
public abstract class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.AdornerLayout : object {
    public abstract virtual void AdornerPropertyChanged(DependencyObject adorner, DependencyPropertyChangedEventArgs args);
    public abstract virtual bool EvaluateLayout(DesignerView view, UIElement adorner);
    public abstract virtual void Measure(UIElement adorner, Size constraint);
    public abstract virtual void Arrange(UIElement adorner);
    public abstract virtual bool IsAssociated(UIElement adorner, ModelItem item);
    public virtual Size ArrangeChildren(FrameworkElement parent, UIElementCollection internalChildren, Size finalSize);
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.AdornerOrder : OrderToken {
    private static AdornerOrder _foreground;
    private static AdornerOrder _content;
    private static AdornerOrder _background;
    public static AdornerOrder Background { get; }
    public static AdornerOrder Content { get; }
    public static AdornerOrder Foreground { get; }
    private AdornerOrder(OrderTokenPrecedence precedence, OrderToken reference, OrderTokenConflictResolution conflictResolution);
    public static AdornerOrder get_Background();
    public static AdornerOrder get_Content();
    public static AdornerOrder get_Foreground();
    public static AdornerOrder CreateAbove(AdornerOrder reference);
    public static AdornerOrder CreateBelow(AdornerOrder reference);
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.AdornerPanel : Panel {
    private Rect _offsetRect;
    private bool _isMirroredTransform;
    public static DependencyProperty IsContentFocusableProperty;
    public static DependencyProperty ModelProperty;
    public static DependencyProperty OrderProperty;
    public static DependencyProperty PlacementsProperty;
    public static DependencyProperty HorizontalStretchProperty;
    public static DependencyProperty VerticalStretchProperty;
    public static DependencyProperty AdornerHorizontalAlignmentProperty;
    public static DependencyProperty AdornerVerticalAlignmentProperty;
    public static DependencyProperty AdornerMarginProperty;
    private static DependencyProperty SyntaticSugarPlacementsProperty;
    public bool IsContentFocusable { get; public set; }
    protected internal bool UseMirrorTransform { get; }
    internal bool IsMirroredTransform { get; internal set; }
    public ViewItem View { get; }
    public ModelItem Model { get; public set; }
    public AdornerOrder Order { get; public set; }
    protected internal Rect OffsetRect { get; protected internal set; }
    private static AdornerPanel();
    public bool get_IsContentFocusable();
    public void set_IsContentFocusable(bool value);
    protected internal virtual bool get_UseMirrorTransform();
    internal bool get_IsMirroredTransform();
    internal void set_IsMirroredTransform(bool value);
    public ViewItem get_View();
    public ModelItem get_Model();
    public void set_Model(ModelItem value);
    public AdornerOrder get_Order();
    public void set_Order(AdornerOrder value);
    internal static AdornerPlacementCollection GetCurrentPlacements(UIElement adorner);
    public static AdornerPlacementCollection GetPlacements(UIElement adorner);
    public static void SetPlacements(UIElement adorner, AdornerPlacementCollection value);
    public static AdornerStretch GetHorizontalStretch(UIElement adorner);
    public static void SetHorizontalStretch(UIElement adorner, AdornerStretch value);
    public static AdornerStretch GetVerticalStretch(UIElement adorner);
    public static void SetVerticalStretch(UIElement adorner, AdornerStretch value);
    public static AdornerHorizontalAlignment GetAdornerHorizontalAlignment(DependencyObject obj);
    public static void SetAdornerHorizontalAlignment(DependencyObject obj, AdornerHorizontalAlignment value);
    public static AdornerVerticalAlignment GetAdornerVerticalAlignment(DependencyObject obj);
    public static void SetAdornerVerticalAlignment(DependencyObject obj, AdornerVerticalAlignment value);
    public static Thickness GetAdornerMargin(DependencyObject obj);
    public static void SetAdornerMargin(DependencyObject obj, Thickness value);
    private static void OnAdornerAlignmentChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static SyntaticSugarPlacementCollection GetSyntaticSugarPlacements(DependencyObject obj);
    private static void SetSyntaticSugarPlacements(DependencyObject obj, SyntaticSugarPlacementCollection value);
    public static Task GetTask(UIElement adorner);
    public static void SetTask(UIElement adorner, Task value);
    protected internal Rect get_OffsetRect();
    protected internal void set_OffsetRect(Rect value);
    public static AdornerPanel FromVisual(DependencyObject visual);
    protected virtual Size MeasureOverride(Size availableSize);
    protected virtual Geometry GetLayoutClip(Size layoutSlotSize);
    protected virtual Size ArrangeOverride(Size finalSize);
    protected virtual void OnPreviewGotKeyboardFocus(KeyboardFocusChangedEventArgs e);
    [ConditionalAttribute("DEBUG")]
internal static void Trace(string format, Object[] data);
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.AdornerPlacementCollection : ObservableCollection`1<IAdornerPlacement> {
    private Vector _topLeft;
    private Vector _size;
    internal Vector TopLeft { get; internal set; }
    internal Vector Size { get; internal set; }
    internal Vector get_TopLeft();
    internal void set_TopLeft(Vector value);
    internal Vector get_Size();
    internal void set_Size(Vector value);
    internal virtual void ComputePlacement(AdornerCoordinateSpace space, UIElement adorner, ViewItem adornedElement, Vector zoom, Size finalSize);
    public void PositionRelativeToAdornerHeight(double factor, double offset);
    public void PositionRelativeToAdornerHeight(double factor, double offset, DependencyObject relativeTo);
    public void PositionRelativeToAdornerWidth(double factor, double offset);
    public void PositionRelativeToAdornerWidth(double factor, double offset, DependencyObject relativeTo);
    public void PositionRelativeToContentHeight(double factor, double offset);
    public void PositionRelativeToContentHeight(double factor, double offset, ViewItem relativeTo);
    public void PositionRelativeToContentWidth(double factor, double offset);
    public void PositionRelativeToContentWidth(double factor, double offset, ViewItem relativeTo);
    public void SizeRelativeToAdornerDesiredHeight(double factor, double offset);
    public void SizeRelativeToAdornerDesiredHeight(double factor, double offset, DependencyObject relativeTo);
    public void SizeRelativeToAdornerDesiredWidth(double factor, double offset);
    public void SizeRelativeToAdornerDesiredWidth(double factor, double offset, DependencyObject relativeTo);
    public void SizeRelativeToContentHeight(double factor, double offset);
    public void SizeRelativeToContentHeight(double factor, double offset, ViewItem relativeTo);
    public void SizeRelativeToContentWidth(double factor, double offset);
    public void SizeRelativeToContentWidth(double factor, double offset, ViewItem relativeTo);
}
public enum Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.AdornerPlacementDimension : Enum {
    public int value__;
    public static AdornerPlacementDimension Left;
    public static AdornerPlacementDimension Top;
    public static AdornerPlacementDimension Right;
    public static AdornerPlacementDimension Bottom;
    public static AdornerPlacementDimension Width;
    public static AdornerPlacementDimension Height;
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.AdornerPlacementValue : ValueType {
    private AdornerPlacementDimension _term;
    private double _contribution;
    public AdornerPlacementDimension Term { get; public set; }
    public double Contribution { get; public set; }
    public AdornerPlacementValue(AdornerPlacementDimension term, double contribution);
    public AdornerPlacementDimension get_Term();
    public void set_Term(AdornerPlacementDimension value);
    public double get_Contribution();
    public void set_Contribution(double value);
    public virtual bool Equals(object obj);
    public bool Equals(AdornerPlacementValue value);
    public virtual int GetHashCode();
    public static bool op_Equality(AdornerPlacementValue placementValue1, AdornerPlacementValue placementValue2);
    public static bool op_Inequality(AdornerPlacementValue placementValue1, AdornerPlacementValue placementValue2);
}
public static class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.AdornerProperties : object {
    public static DependencyProperty LayoutProperty;
    public static DependencyProperty ModelProperty;
    public static DependencyProperty OrderProperty;
    public static DependencyProperty RenderTransformProperty;
    public static DependencyProperty TaskProperty;
    private static AdornerProperties();
    public static AdornerLayout GetLayout(DependencyObject adorner);
    public static void SetLayout(DependencyObject adorner, AdornerLayout value);
    public static ModelItem GetModel(DependencyObject adorner);
    public static void SetModel(DependencyObject adorner, ModelItem value);
    public static AdornerOrder GetOrder(DependencyObject adorner);
    public static void SetOrder(DependencyObject adorner, AdornerOrder value);
    public static Task GetTask(DependencyObject adorner);
    public static void SetTask(DependencyObject adorner, Task value);
    public static ViewItem GetView(DependencyObject adorner);
    public static Transform GetRenderTransform(DependencyObject adorner);
    public static void SetRenderTransform(DependencyObject adorner, Transform value);
    private static void OnOrderChanged(DependencyObject sender, DependencyPropertyChangedEventArgs args);
    private static void OnModelChanged(DependencyObject sender, DependencyPropertyChangedEventArgs args);
    private static void OnPropertyChanged(DependencyObject sender, DependencyPropertyChangedEventArgs args);
    private static bool OnValidateNonNull(object value);
}
[FeatureConnectorAttribute("MS.Internal.Features.AdornerProviderFeatureConnector")]
public abstract class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.AdornerProvider : FeatureProvider {
    private Collection`1<UIElement> _adorners;
    private EditingContext _context;
    private bool _adornersVisible;
    private bool _firstActivate;
    private bool _canClearAdorners;
    public Collection`1<UIElement> Adorners { get; }
    public bool AdornersVisible { get; public set; }
    protected EditingContext Context { get; }
    public Collection`1<UIElement> get_Adorners();
    public bool get_AdornersVisible();
    public void set_AdornersVisible(bool value);
    protected EditingContext get_Context();
    public virtual bool IsToolSupported(Tool tool);
    protected virtual void Activate(ModelItem item);
    protected virtual void Deactivate();
    internal void InvokeActivate(EditingContext context, ModelItem item);
    internal void InvokeDeactivate();
}
public static class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.AdornerResources : object {
    private static object _syncLock;
    private static List`1<LoadResourcesCallback> _callbacks;
    private static ResourceDictionary _resources;
    private static int _loadIndex;
    private static bool _themeInUse;
    private static Nullable`1<bool> _highContrast;
    [ThreadStaticAttribute]
private static FrameworkElement _queryElement;
    internal static ResourceDictionary ThemeResources { get; }
    private static AdornerResources();
    internal static ResourceDictionary get_ThemeResources();
    private static void EnsureResources(bool forceUpdate);
    public static object FindResource(ResourceKey key);
    public static object TryFindResource(ResourceKey key);
    private static bool FindResourceHelper(ResourceKey key, Object& resource);
    private static bool IsResourceCategory(UserPreferenceCategory category);
    public static ResourceKey CreateResourceKey(Type owningType, string publicMember);
    public static void RegisterResources(LoadResourcesCallback callback);
    public static void Refresh();
}
public enum Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.AdornerStretch : Enum {
    public int value__;
    public static AdornerStretch None;
    public static AdornerStretch Stretch;
}
public enum Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.AdornerVerticalAlignment : Enum {
    public int value__;
    public static AdornerVerticalAlignment Top;
    public static AdornerVerticalAlignment Center;
    public static AdornerVerticalAlignment Bottom;
    public static AdornerVerticalAlignment Stretch;
    public static AdornerVerticalAlignment OutsideTop;
    public static AdornerVerticalAlignment OutsideBottom;
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.CanExecuteToolEventArgs : EventArgs {
    private ICommand _command;
    private object _parameter;
    private bool _canExecute;
    public bool CanExecute { get; public set; }
    public ICommand Command { get; }
    public object Parameter { get; }
    internal CanExecuteToolEventArgs(ICommand command, object parameter);
    public bool get_CanExecute();
    public void set_CanExecute(bool value);
    public ICommand get_Command();
    public object get_Parameter();
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.CanExecuteToolEventHandler : MulticastDelegate {
    public CanExecuteToolEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, CanExecuteToolEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, CanExecuteToolEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.CommandExceptionEventArgs : EventArgs {
    private ICommand _command;
    private Exception _exception;
    public ICommand Command { get; }
    public Exception Exception { get; }
    public CommandExceptionEventArgs(ICommand command, Exception exception);
    public ICommand get_Command();
    public Exception get_Exception();
}
[FeatureConnectorAttribute("MS.Internal.Features.ContextMenuFeatureConnector")]
public abstract class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.ContextMenuProvider : FeatureProvider {
    private ObservableCollection`1<MenuBase> _items;
    [CompilerGeneratedAttribute]
private EventHandler`1<MenuActionEventArgs> UpdateItemStatus;
    public ObservableCollection`1<MenuBase> Items { get; }
    public ObservableCollection`1<MenuBase> get_Items();
    public void Update(EditingContext context);
    private void AssignContext(EditingContext context, ObservableCollection`1<MenuBase> items);
    [CompilerGeneratedAttribute]
public void add_UpdateItemStatus(EventHandler`1<MenuActionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_UpdateItemStatus(EventHandler`1<MenuActionEventArgs> value);
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.CreationTool : Tool {
    [CompilerGeneratedAttribute]
private string <CreationType>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler CreationComplete;
    public string CreationType { get; public set; }
    private void OnCancel(object sender, ExecutedRoutedEventArgs e);
    [CompilerGeneratedAttribute]
public string get_CreationType();
    [CompilerGeneratedAttribute]
public void set_CreationType(string value);
    [CompilerGeneratedAttribute]
public void add_CreationComplete(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_CreationComplete(EventHandler value);
    protected virtual void OnCreationComplete(EventArgs e);
    public void PerformCreationComplete();
}
[AttributeUsageAttribute("4")]
public class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.CreationToolAttribute : Attribute {
    private Type _toolType;
    public Type ToolType { get; }
    public CreationToolAttribute(Type toolType);
    public Type get_ToolType();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.CurrentDesignerView : ContextItem {
    private DesignerView _view;
    private bool _allowNullView;
    public DesignerView View { get; }
    public Type ItemType { get; }
    internal CurrentDesignerView(DesignerView view);
    public DesignerView get_View();
    public virtual Type get_ItemType();
    protected virtual void OnItemChanged(EditingContext context, ContextItem previousItem);
}
public static class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.DesignerCommands : object {
    private static RoutedCommand _cancel;
    public static RoutedCommand Cancel { get; }
    public static RoutedCommand get_Cancel();
    private static RoutedCommand EnsureCommand(RoutedCommand& command, string name);
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.DesignerView : Decorator {
    private int _doubleClickSizeX;
    private int _doubleClickSizeY;
    private int _hoverSizeX;
    private int _hoverSizeY;
    private long _hoverTimeout;
    private double _minimumHorizontalDragDistance;
    private double _minimumVerticalDragDistance;
    private EditingContext _context;
    private AdornerLayer _adornerLayer;
    private OpaqueElement _hitTestLayer;
    private ViewService _viewService;
    private ModelService _modelService;
    private bool _inCall;
    private bool _pendingClearCapture;
    private bool _clearingCapture;
    private bool _abortCapture;
    private EventArgs _secondaryHitTestArgs;
    private Point _clickPoint;
    private int _clickCount;
    private ModelItem _clickModel;
    private DependencyObject _clickAdorner;
    private bool _capturingMouse;
    private UIElement _captureOwner;
    private DependencyObject _captureAdorner;
    private ModelItem _captureModel;
    private Point _capturePointInRootElementCoords;
    private DependencyObject _hitRawAdornerVisual;
    private ViewItem _hitRawModelVisual;
    private DependencyObject _hitAdorner;
    private ModelItem _hitModel;
    private ViewHitTestFilterCallback _modelHitTestFilter;
    private MouseState[] _mouseState;
    private DragDropEffects _dragAllowedEffects;
    private Point _lastCurrentPoint;
    private IDataObject _dragData;
    private DispatcherTimer _hoverTimer;
    private Point _hoverPoint;
    private DesignerViewAutomationPeer _designerViewAutomationPeer;
    private Task _focusedTask;
    private static Style _defaultFocusVisualStyle;
    private bool _protectReEntrantCode;
    private Point _lastPointInParentCoordinates;
    private static DependencyPropertyKey DesignerViewPropertyKey;
    public static DependencyProperty DesignerViewProperty;
    public static DependencyProperty AdornersVisibleProperty;
    [CompilerGeneratedAttribute]
private EventHandler`1<CommandExceptionEventArgs> CommandException;
    [CompilerGeneratedAttribute]
private EventHandler`1<MatchGestureEventArgs> MatchGesture;
    public static DependencyProperty ZoomLevelProperty;
    [CompilerGeneratedAttribute]
private EventHandler ZoomLevelChanged;
    private static TraceSwitch _disableCatchAll;
    private static Style DefaultFocusVisualStyle { get; }
    public ICollection`1<UIElement> Adorners { get; }
    public UIElement AdornerLayer { get; }
    public EditingContext Context { get; public set; }
    public bool IsContentHitTestVisible { get; public set; }
    public ViewItem RootView { get; }
    public bool AdornersVisible { get; public set; }
    private ViewService ViewService { get; }
    private double MinHorizontalDragDistance { get; }
    private double MinVerticalDragDistance { get; }
    private ModelService ModelService { get; }
    public UIElement Child { get; public set; }
    protected int VisualChildrenCount { get; }
    public double ZoomLevel { get; public set; }
    private static DesignerView();
    protected DesignerView(bool shouldAttachEvents);
    private static Style get_DefaultFocusVisualStyle();
    public sealed virtual void Dispose();
    public virtual void Dispose(bool disposing);
    public ICollection`1<UIElement> get_Adorners();
    public UIElement get_AdornerLayer();
    public EditingContext get_Context();
    public void set_Context(EditingContext value);
    public bool get_IsContentHitTestVisible();
    public void set_IsContentHitTestVisible(bool value);
    public ViewItem get_RootView();
    [CompilerGeneratedAttribute]
public void add_CommandException(EventHandler`1<CommandExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_CommandException(EventHandler`1<CommandExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_MatchGesture(EventHandler`1<MatchGestureEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_MatchGesture(EventHandler`1<MatchGestureEventArgs> value);
    public static DesignerView FromContext(EditingContext context);
    public static DesignerView GetDesignerView(DependencyObject element);
    public bool get_AdornersVisible();
    public void set_AdornersVisible(bool value);
    private static void AddHandler(UIElement element, RoutedEvent id, Delegate handler);
    private ViewService get_ViewService();
    private double get_MinHorizontalDragDistance();
    private double get_MinVerticalDragDistance();
    private ModelService get_ModelService();
    private void OnFocusedTaskChanged(FocusedTask focusedTask);
    private void OnContextDisposing(object sender, EventArgs e);
    private void OnToolChanged(Tool currentTool);
    protected void AbortCapture();
    private bool BeginCall();
    private void ClearCapture();
    private void ClearMouseState();
    private void ClearAdornerHitTestInfo();
    private void ClearAllHitTestInfo();
    private void ClearModelHitTestInfo();
    private void EndCall(bool nestedCall);
    private HitTestFilterBehavior ModelHitTestFilter(ViewItem hit);
    protected bool HasInputBindings(EventArgs eventArgs);
    private static bool HasInputBindings(DependencyObject adorner);
    private void PerformHitTest(EventArgs eventArgs);
    private void PerformAdornerHitTest(Point mouse);
    private void PerformModelHitTest(EventArgs eventArgs);
    private Point GetCapturePoint();
    private void SetCapturePoint(ViewItem rootElementOnSurface);
    private void SetCapture(UIElement captureOwner);
    protected virtual void SetCapture();
    private Point GetMousePosition(EventArgs inputArgs, IInputElement relativeTo);
    private GestureData CreateGestureData(Task sourceTask, EventArgs inputArgs);
    private void ExecuteCommand(MatchGestureEventArgs command, DragEventArgs args, bool updateHitTest);
    private void ExecuteCommand(MatchGestureEventArgs command, bool updateHitTest);
    private MatchGestureEventArgs FindCommand(InputEventArgs eventArgs, FindCommandScope scope);
    private InputBinding FindInputBinding(InputEventArgs args, FindCommandScope scope, Task& sourceTask);
    private static InputBinding FindInputBindingForAdorner(InputEventArgs args, DependencyObject adorner, Task& sourceTask);
    private static InputBinding FindInputBindingForTask(InputEventArgs args, Task task);
    private static void OnAdornersVisibleChanged(DependencyObject sender, DependencyPropertyChangedEventArgs args);
    protected virtual void OnCommandException(CommandExceptionEventArgs e);
    protected virtual void OnMatchGesture(MatchGestureEventArgs e);
    protected void HandleCanExecuteCommand(CanExecuteRoutedEventArgs args);
    private void OnCanExecuteCommand(object sender, CanExecuteRoutedEventArgs args);
    protected void HandleExecutedCommand(ExecutedRoutedEventArgs args);
    private void OnExecutedCommand(object sender, ExecutedRoutedEventArgs args);
    public virtual UIElement get_Child();
    public virtual void set_Child(UIElement value);
    protected virtual int get_VisualChildrenCount();
    protected virtual Visual GetVisualChild(int index);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    protected virtual Size MeasureOverride(Size constraint);
    protected void HandleDragEnter(DragEventArgs args);
    private void OnDecoratorDragEnter(object sender, DragEventArgs args);
    protected void HandleDragLeave(DragEventArgs args);
    private void OnDecoratorDragLeave(object sender, DragEventArgs args);
    protected void HandleDragOver(DragEventArgs args);
    private void OnDecoratorDragOver(object sender, DragEventArgs args);
    protected void HandleDrop(DragEventArgs args);
    private void OnDecoratorDrop(object sender, DragEventArgs args);
    protected void HandleGiveFeedback(GiveFeedbackEventArgs args);
    private void OnDecoratorGiveFeedback(object sender, GiveFeedbackEventArgs args);
    private void PerformDragEnterLeave(DragEventArgs args, ModelItem priorModelHit, DependencyObject priorAdornerHit);
    protected void HandleMouseEnter(MouseEventArgs args);
    private void OnMouseEnter(object sender, MouseEventArgs args);
    protected void HandleMouseLeave(MouseEventArgs args);
    private void OnMouseLeave(object sender, MouseEventArgs args);
    protected void HandleMouseMove(MouseEventArgs args);
    private void OnMouseMove(object sender, MouseEventArgs args);
    protected void HandleMouseDown(MouseButtonEventArgs args);
    private void OnMouseDown(object sender, MouseButtonEventArgs args);
    protected void HandleMouseUp(MouseButtonEventArgs args);
    private void OnMouseUp(object sender, MouseButtonEventArgs args);
    protected void HandleMouseWheel(MouseWheelEventArgs args);
    private void OnMouseWheel(object sender, MouseWheelEventArgs args);
    private void OnHoverTimeout(object sender, EventArgs args);
    private void PerformMouseEnterLeave(InputEventArgs args, ModelItem priorModelHit, DependencyObject priorAdornerHit, bool usePreviousModelForEnter);
    private void PerformMouseDragIntent(MouseEventArgs args);
    private void PerformMouseMove(MouseEventArgs args);
    private void SetMouseDownState(MouseButtonEventArgs args);
    private void StartHoverCountdown();
    private void StopHoverCountdown();
    protected void HandleQueryCursor(QueryCursorEventArgs args);
    private void OnHitTestQueryCursor(object sender, QueryCursorEventArgs args);
    protected void HandleKeyDown(KeyEventArgs args);
    private void OnDecoratorKeyDown(object sender, KeyEventArgs args);
    private void OnLostMouseCapture(object sender, MouseEventArgs args);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected IDisposable SuspendAutomationPeer();
    public double get_ZoomLevel();
    public void set_ZoomLevel(double value);
    private static bool IsZoomLevelValid(object value);
    private static void HandleZoomLevelChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public virtual Transform GetZoomTransform();
    protected virtual void SetZoomTransform();
    [CompilerGeneratedAttribute]
public void add_ZoomLevelChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ZoomLevelChanged(EventHandler value);
    [CompilerGeneratedAttribute]
private GestureData <FindCommand>b__109_0(Task localTask, InputEventArgs localArgs);
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.DragGestureData : MouseGestureData {
    private DragDropEffects _effects;
    private DragDropEffects _allowedEffects;
    private IDataObject _data;
    public DragDropEffects Effects { get; public set; }
    public DragDropEffects AllowedEffects { get; }
    public IDataObject Data { get; }
    public DragGestureData(EditingContext context, ModelItem sourceModel, ModelItem targetModel, Visual coordinateReference, Point startPosition, Point currentPosition, DragDropEffects allowedEffects, IDataObject data);
    public DragGestureData(EditingContext context, ModelItem sourceModel, ModelItem targetModel, Visual coordinateReference, Point startPosition, Point currentPosition, DragDropEffects allowedEffects, IDataObject data, DependencyObject sourceAdorner, DependencyObject targetAdorner);
    public DragDropEffects get_Effects();
    public void set_Effects(DragDropEffects value);
    public DragDropEffects get_AllowedEffects();
    public IDataObject get_Data();
    public static DragGestureData FromEventArgs(ExecutedToolEventArgs e);
    public static DragGestureData FromEventArgs(CanExecuteToolEventArgs e);
}
internal static class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.EnumValidator : object {
    public static bool IsValid(AdornerPlacementDimension value);
    public static bool IsValid(AdornerStretch value);
    public static bool IsValid(NudgeIntent value);
    public static bool IsValid(ToolAction value);
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.ExecutedToolEventArgs : EventArgs {
    private ICommand _command;
    private object _parameter;
    public ICommand Command { get; }
    public object Parameter { get; }
    internal ExecutedToolEventArgs(ICommand command, object parameter);
    public ICommand get_Command();
    public object get_Parameter();
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.ExecutedToolEventHandler : MulticastDelegate {
    public ExecutedToolEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ExecutedToolEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ExecutedToolEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.FocusedTask : ContextItem {
    private Task _task;
    public Type ItemType { get; }
    public Task Task { get; }
    internal FocusedTask(Task task);
    public virtual Type get_ItemType();
    public Task get_Task();
    protected virtual void OnItemChanged(EditingContext context, ContextItem previousItem);
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.GestureData : object {
    private EditingContext _context;
    private ModelItem _sourceModel;
    private ModelItem _targetModel;
    private ModelItem _impliedSource;
    private ModelItem _impliedTarget;
    private DependencyObject _sourceAdorner;
    private DependencyObject _targetAdorner;
    private Task _sourceTask;
    public EditingContext Context { get; }
    public ModelItem ImpliedSource { get; }
    public ModelItem ImpliedTarget { get; }
    public DependencyObject SourceAdorner { get; }
    public ModelItem SourceModel { get; }
    internal Task SourceTask { get; internal set; }
    public DependencyObject TargetAdorner { get; }
    public ModelItem TargetModel { get; }
    public ICollection`1<UIElement> Adorners { get; }
    public GestureData(EditingContext context, ModelItem sourceModel, ModelItem targetModel);
    public GestureData(EditingContext context, ModelItem sourceModel, ModelItem targetModel, DependencyObject sourceAdorner, DependencyObject targetAdorner);
    public EditingContext get_Context();
    public ModelItem get_ImpliedSource();
    public ModelItem get_ImpliedTarget();
    public DependencyObject get_SourceAdorner();
    public ModelItem get_SourceModel();
    internal Task get_SourceTask();
    internal void set_SourceTask(Task value);
    public DependencyObject get_TargetAdorner();
    public ModelItem get_TargetModel();
    public ICollection`1<UIElement> get_Adorners();
    public static GestureData FromEventArgs(ExecutedToolEventArgs e);
    public static GestureData FromEventArgs(CanExecuteToolEventArgs e);
    internal static GestureDataType FromParameter(object parameter);
    private static ModelItem GetImpliedModel(DependencyObject adorner, ModelItem model);
}
public interface Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.IAdornerPlacement {
    public abstract virtual IEnumerable`1<AdornerPlacementValue> GetSizeTerms(AdornerCoordinateSpace space, UIElement adorner, ViewItem view, Vector zoom, Size viewFinalSize);
    public abstract virtual IEnumerable`1<AdornerPlacementValue> GetPositionTerms(AdornerCoordinateSpace space, UIElement adorner, ViewItem view, Vector zoom, Size computedAdornerSize);
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.LoadResourcesCallback : MulticastDelegate {
    public LoadResourcesCallback(object object, IntPtr method);
    public virtual ResourceDictionary Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual ResourceDictionary EndInvoke(IAsyncResult result);
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.MatchGestureEventArgs : EventArgs {
    private InputEventArgs _inputEvent;
    private InputBinding _binding;
    private GestureData _data;
    private Task _sourceTask;
    private GetGestureData _dataCallback;
    public InputEventArgs InputEvent { get; }
    public InputBinding Binding { get; public set; }
    public GestureData Data { get; public set; }
    internal MatchGestureEventArgs(InputEventArgs inputEvent, InputBinding binding, Task sourceTask, GetGestureData dataCallback);
    public InputEventArgs get_InputEvent();
    public InputBinding get_Binding();
    public void set_Binding(InputBinding value);
    public GestureData get_Data();
    public void set_Data(GestureData value);
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.MenuAction : MenuBase {
    private static int stateIsCheckable;
    private static int stateIsChecked;
    private static int stateIsEnabled;
    private static int stateIsVisible;
    private BitVector32 _state;
    private Uri _imageUri;
    private MenuActionCommand _command;
    [CompilerGeneratedAttribute]
private EventHandler`1<MenuActionEventArgs> Execute;
    public ICommand Command { get; }
    public bool Checkable { get; public set; }
    public bool Checked { get; public set; }
    public bool Enabled { get; public set; }
    public bool Visible { get; public set; }
    public Uri ImageUri { get; public set; }
    public MenuAction(string displayName);
    private static MenuAction();
    public ICommand get_Command();
    public bool get_Checkable();
    public void set_Checkable(bool value);
    public bool get_Checked();
    public void set_Checked(bool value);
    public bool get_Enabled();
    public void set_Enabled(bool value);
    public bool get_Visible();
    public void set_Visible(bool value);
    public Uri get_ImageUri();
    public void set_ImageUri(Uri value);
    [CompilerGeneratedAttribute]
public void add_Execute(EventHandler`1<MenuActionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Execute(EventHandler`1<MenuActionEventArgs> value);
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.MenuActionEventArgs : EventArgs {
    private EditingContext _context;
    private Selection _selection;
    public EditingContext Context { get; }
    public Selection Selection { get; }
    public MenuActionEventArgs(EditingContext context);
    public EditingContext get_Context();
    public Selection get_Selection();
}
public abstract class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.MenuBase : object {
    private string _name;
    private string _displayName;
    private EditingContext _context;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public EditingContext Context { get; internal set; }
    public string Name { get; public set; }
    public string DisplayName { get; public set; }
    public EditingContext get_Context();
    internal void set_Context(EditingContext value);
    public string get_Name();
    public void set_Name(string value);
    public string get_DisplayName();
    public void set_DisplayName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    protected virtual void OnPropertyChanged(string propertyName);
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.MenuGroup : MenuBase {
    private ObservableCollection`1<MenuBase> _items;
    private bool _hasDropDown;
    public ObservableCollection`1<MenuBase> Items { get; }
    public bool HasDropDown { get; public set; }
    public MenuGroup(string groupName);
    public MenuGroup(string groupName, string displayName);
    public ObservableCollection`1<MenuBase> get_Items();
    public bool get_HasDropDown();
    public void set_HasDropDown(bool value);
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.ModelHitTestFilterCallback : MulticastDelegate {
    public ModelHitTestFilterCallback(object object, IntPtr method);
    public virtual HitTestFilterBehavior Invoke(ModelItem potentialHitTestTarget);
    public virtual IAsyncResult BeginInvoke(ModelItem potentialHitTestTarget, AsyncCallback callback, object object);
    public virtual HitTestFilterBehavior EndInvoke(IAsyncResult result);
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.MouseGestureData : GestureData {
    private Visual _coordinateReference;
    private Point _currentPosition;
    private Point _startPosition;
    public Point CurrentPosition { get; }
    public Point StartPosition { get; }
    public Vector PositionDelta { get; }
    public MouseGestureData(EditingContext context, ModelItem sourceModel, ModelItem targetModel, Visual coordinateReference, Point startPosition, Point currentPosition);
    public MouseGestureData(EditingContext context, ModelItem sourceModel, ModelItem targetModel, Visual coordinateReference, Point startPosition, Point currentPosition, DependencyObject sourceAdorner, DependencyObject targetAdorner);
    public Point get_CurrentPosition();
    public Point get_StartPosition();
    public Vector get_PositionDelta();
    public Point TranslatePoint(Point pt, ModelItem referenceTo);
    public static MouseGestureData FromEventArgs(ExecutedToolEventArgs e);
    public static MouseGestureData FromEventArgs(CanExecuteToolEventArgs e);
}
public enum Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.NudgeIntent : Enum {
    public int value__;
    public static NudgeIntent Left;
    public static NudgeIntent Right;
    public static NudgeIntent Up;
    public static NudgeIntent Down;
}
[FeatureConnectorAttribute("MS.Internal.Features.ParentAdapterFeatureConnector")]
public abstract class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.ParentAdapter : Adapter {
    public Type AdapterType { get; }
    public virtual Type get_AdapterType();
    public virtual bool CanParent(ModelItem parent, TypeIdentifier childType);
    public virtual bool IsParent(ModelItem parent, ModelItem child);
    public virtual ModelItem RedirectParent(ModelItem parent, TypeIdentifier childType);
    public virtual void Parent(ModelItem newParent, ModelItem child, int insertionIndex);
    public abstract virtual void Parent(ModelItem newParent, ModelItem child);
    public abstract virtual void RemoveParent(ModelItem currentParent, ModelItem newParent, ModelItem child);
}
public abstract class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.PlacementAdapter : Adapter {
    public Type AdapterType { get; }
    public virtual Type get_AdapterType();
    public virtual void BeginPlacement(ModelItem item);
    public virtual void EndPlacement();
    public abstract virtual bool CanSetPosition(PlacementIntent intent, RelativePosition position);
    public abstract virtual RelativeValueCollection GetPlacement(ModelItem item, RelativePosition[] positions);
    public abstract virtual void SetPlacements(ModelItem item, PlacementIntent intent, RelativeValue[] positions);
    public abstract virtual void SetPlacements(ModelItem item, PlacementIntent intent, RelativeValueCollection placement);
    public virtual void SetNudgePlacements(ModelItem item, NudgeIntent intent, RelativeValueCollection placement);
    public virtual void SetNudgePlacements(ModelItem item, NudgeIntent intent, RelativeValue[] positions);
    public abstract virtual Rect GetPlacementBoundary(ModelItem item);
    public abstract virtual Rect GetPlacementBoundary(ModelItem item, PlacementIntent intent, RelativeValue[] positions);
}
public enum Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.PlacementIntent : Enum {
    public int value__;
    public static PlacementIntent Move;
    public static PlacementIntent Size;
}
[UsesItemPolicyAttribute("Microsoft.VisualStudio.DesignTools.Extensibility.Policies.PrimarySelectionPolicy")]
public class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.PrimarySelectionAdornerProvider : AdornerProvider {
}
[UsesItemPolicyAttribute("Microsoft.VisualStudio.DesignTools.Extensibility.Policies.PrimarySelectionPolicy")]
public abstract class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.PrimarySelectionContextMenuProvider : ContextMenuProvider {
}
[UsesItemPolicyAttribute("Microsoft.VisualStudio.DesignTools.Extensibility.Policies.PrimarySelectionPolicy")]
public class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.PrimarySelectionTaskProvider : TaskProvider {
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.RelativePoint : ValueType {
    private RelativePosition _position;
    private double _x;
    private double _y;
    public RelativePosition Position { get; public set; }
    public double X { get; public set; }
    public double Y { get; public set; }
    public RelativePoint(RelativePosition position, double x, double y);
    public RelativePoint(RelativePosition position, Point point);
    public RelativePosition get_Position();
    public void set_Position(RelativePosition value);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public virtual bool Equals(object obj);
    public bool Equals(RelativePoint value);
    public static RelativePoint FromPoint(Point point);
    public virtual int GetHashCode();
    public static bool op_Equality(RelativePoint point1, RelativePoint point2);
    public static bool op_Inequality(RelativePoint point1, RelativePoint point2);
    public static RelativePoint op_Implicit(Point point);
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.RelativePosition : object {
    private RelativePosition[] _values;
    private string _name;
    public RelativePosition(RelativePosition[] values);
    public RelativePosition(string name, RelativePosition[] values);
    public bool Contains(RelativePosition value);
    private static int CountValues(RelativePosition[] values);
    public virtual bool Equals(object obj);
    public bool Equals(RelativePosition position);
    private static int FillValues(RelativePosition[] array, RelativePosition[] values, int startingIndex);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(RelativePosition point1, RelativePosition point2);
    public static bool op_Inequality(RelativePosition point1, RelativePosition point2);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public static class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.RelativePositions : object {
    private static RelativePosition _topLeft;
    private static RelativePosition _topSide;
    private static RelativePosition _topRight;
    private static RelativePosition _rightSide;
    private static RelativePosition _bottomRight;
    private static RelativePosition _bottomSide;
    private static RelativePosition _bottomLeft;
    private static RelativePosition _leftSide;
    private static RelativePosition _center;
    private static RelativePosition[] _bounds;
    private static RelativePosition _internalLeftSide;
    private static RelativePosition _internalTopSide;
    private static RelativePosition _internalBottomSide;
    private static RelativePosition _internalRightSide;
    private static RelativePosition _internalTopLeft;
    private static RelativePosition _internalTopRight;
    private static RelativePosition _internalBottomLeft;
    private static RelativePosition _internalBottomRight;
    private static RelativePosition _externalLeftSide;
    private static RelativePosition _externalTopSide;
    private static RelativePosition _externalBottomSide;
    private static RelativePosition _externalRightSide;
    private static RelativePosition _externalTopLeft;
    private static RelativePosition _externalTopRight;
    private static RelativePosition _externalBottomLeft;
    private static RelativePosition _externalBottomRight;
    public static RelativePosition InternalLeftSide { get; }
    public static RelativePosition InternalTopSide { get; }
    public static RelativePosition InternalBottomSide { get; }
    public static RelativePosition InternalRightSide { get; }
    public static RelativePosition InternalBottomLeft { get; }
    public static RelativePosition InternalBottomRight { get; }
    public static RelativePosition InternalTopLeft { get; }
    public static RelativePosition InternalTopRight { get; }
    public static RelativePosition ExternalLeftSide { get; }
    public static RelativePosition ExternalTopSide { get; }
    public static RelativePosition ExternalBottomSide { get; }
    public static RelativePosition ExternalRightSide { get; }
    public static RelativePosition ExternalBottomLeft { get; }
    public static RelativePosition ExternalBottomRight { get; }
    public static RelativePosition ExternalTopLeft { get; }
    public static RelativePosition ExternalTopRight { get; }
    public static RelativePosition[] Bounds { get; }
    public static RelativePosition BottomLeft { get; }
    public static RelativePosition BottomRight { get; }
    public static RelativePosition BottomSide { get; }
    public static RelativePosition Center { get; }
    public static RelativePosition LeftSide { get; }
    public static RelativePosition RightSide { get; }
    public static RelativePosition TopLeft { get; }
    public static RelativePosition TopRight { get; }
    public static RelativePosition TopSide { get; }
    public static RelativePosition get_InternalLeftSide();
    public static RelativePosition get_InternalTopSide();
    public static RelativePosition get_InternalBottomSide();
    public static RelativePosition get_InternalRightSide();
    public static RelativePosition get_InternalBottomLeft();
    public static RelativePosition get_InternalBottomRight();
    public static RelativePosition get_InternalTopLeft();
    public static RelativePosition get_InternalTopRight();
    public static RelativePosition get_ExternalLeftSide();
    public static RelativePosition get_ExternalTopSide();
    public static RelativePosition get_ExternalBottomSide();
    public static RelativePosition get_ExternalRightSide();
    public static RelativePosition get_ExternalBottomLeft();
    public static RelativePosition get_ExternalBottomRight();
    public static RelativePosition get_ExternalTopLeft();
    public static RelativePosition get_ExternalTopRight();
    public static RelativePosition[] get_Bounds();
    public static RelativePosition get_BottomLeft();
    public static RelativePosition get_BottomRight();
    public static RelativePosition get_BottomSide();
    public static RelativePosition get_Center();
    public static RelativePosition get_LeftSide();
    public static RelativePosition get_RightSide();
    public static RelativePosition get_TopLeft();
    public static RelativePosition get_TopRight();
    public static RelativePosition get_TopSide();
    private static RelativePosition GetPosition(RelativePosition& pos, string name, RelativePosition[] values);
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.RelativeValue : ValueType {
    private RelativePosition _reference;
    private double _value;
    public RelativePosition Position { get; public set; }
    public double Value { get; public set; }
    public RelativeValue(RelativePosition reference, double value);
    public RelativePosition get_Position();
    public void set_Position(RelativePosition value);
    public double get_Value();
    public void set_Value(double value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(RelativeValue first, RelativeValue second);
    public static bool op_Inequality(RelativeValue first, RelativeValue second);
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.RelativeValueCollection : Collection`1<RelativeValue> {
    public RelativeValue Find(RelativePosition position);
}
public abstract class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.RootPlacementAdapter : PlacementAdapter {
    public Type AdapterType { get; }
    public virtual Type get_AdapterType();
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.Selection : ContextItem {
    private ICollection`1<ModelItem> _selectedObjects;
    private Selection _viewSelection;
    private static TypeIdentifier CollectionViewSourceType;
    public Selection ViewSelection { get; }
    public ModelItem PrimarySelection { get; }
    public IEnumerable`1<ModelItem> SelectedObjects { get; }
    public int SelectionCount { get; }
    public Type ItemType { get; }
    public Selection(IEnumerable`1<ModelItem> selectedObjects);
    public Selection(IEnumerable`1<ModelItem> selectedObjects, Predicate`1<ModelItem> match);
    public Selection(IEnumerable selectedObjects);
    public Selection(IEnumerable selectedObjects, Predicate`1<ModelItem> match);
    public Selection(ModelItem[] selectedObjects);
    private static Selection();
    private bool HasView(ModelItem modelItem);
    public Selection get_ViewSelection();
    public ModelItem get_PrimarySelection();
    public IEnumerable`1<ModelItem> get_SelectedObjects();
    public int get_SelectionCount();
    public sealed virtual Type get_ItemType();
}
public static class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.SelectionCommands : object {
    private static RoutedCommand _clear;
    private static RoutedCommand _selectNext;
    private static RoutedCommand _selectPrevious;
    private static ToolCommand _selectTarget;
    private static ToolCommand _onlySelectTarget;
    private static ToolCommand _toggleSelectTarget;
    private static ToolCommand _unionSelectTarget;
    private static ToolCommand _showEvent;
    public static RoutedCommand Clear { get; }
    public static RoutedCommand SelectAll { get; }
    public static RoutedCommand SelectNext { get; }
    public static RoutedCommand SelectPrevious { get; }
    public static ToolCommand SelectTarget { get; }
    public static ToolCommand SelectOnlyTarget { get; }
    public static ToolCommand ToggleSelectTarget { get; }
    public static ToolCommand UnionSelectTarget { get; }
    public static ToolCommand ShowEvent { get; }
    public static RoutedCommand get_Clear();
    public static RoutedCommand get_SelectAll();
    public static RoutedCommand get_SelectNext();
    public static RoutedCommand get_SelectPrevious();
    public static ToolCommand get_SelectTarget();
    public static ToolCommand get_SelectOnlyTarget();
    public static ToolCommand get_ToggleSelectTarget();
    public static ToolCommand get_UnionSelectTarget();
    public static ToolCommand get_ShowEvent();
    private static ToolCommand EnsureCommand(ToolCommand& command, string name);
    private static RoutedCommand EnsureCommand(RoutedCommand& command, string name);
}
public static class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.SelectionOperations : object {
    public static Selection Select(EditingContext context, ModelItem itemToSelect);
    public static Selection SelectOnly(EditingContext context, ModelItem itemToSelect);
    public static void Subscribe(EditingContext context, SubscribeContextCallback`1<Selection> handler);
    public static Selection Toggle(EditingContext context, ModelItem itemToToggle);
    public static Selection Union(EditingContext context, ModelItem itemToAdd);
    public static void Unsubscribe(EditingContext context, SubscribeContextCallback`1<Selection> handler);
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.SelectionTool : Tool {
    private bool isLocalSelectAll;
    protected virtual void OnActivate(Tool previousTool);
    protected virtual void OnDeactivate();
    private void OnSelectParent(object sender, ExecutedRoutedEventArgs e);
    private void OnSelectAll(object sender, ExecutedRoutedEventArgs e);
    private void OnSelectNext(object sender, ExecutedRoutedEventArgs e);
    private void OnSelectPrevious(object sender, ExecutedRoutedEventArgs e);
    private void OnSelectionChanged(Selection s);
    private void OnSelectObject(object sender, ExecutedToolEventArgs e);
    private void OnSelectOnlyObject(object sender, ExecutedToolEventArgs e);
    private void OnToggleSelectObject(object sender, ExecutedToolEventArgs e);
    private void OnUnionSelectObject(object sender, ExecutedToolEventArgs e);
    private void OnShowEvent(object sender, ExecutedToolEventArgs e);
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.Task : object {
    private InputBindingCollection _inputBindings;
    private CommandBindingCollection _commandBindings;
    private ToolCommandBindingCollection _toolCommandBindings;
    private Cursor _cursor;
    private string _description;
    private ModelEditingScope _editingScope;
    private Tool _activeTool;
    private HitTestFilterCallback _adornerFilter;
    private ModelHitTestFilterCallback _modelFilter;
    [CompilerGeneratedAttribute]
private EventHandler FocusDeactivated;
    [CompilerGeneratedAttribute]
private EventHandler Reverted;
    [CompilerGeneratedAttribute]
private EventHandler Completed;
    public HitTestFilterCallback AdornerFilter { get; public set; }
    public CommandBindingCollection CommandBindings { get; }
    public Cursor Cursor { get; public set; }
    public string Description { get; public set; }
    public InputBindingCollection InputBindings { get; }
    public bool IsFocused { get; }
    public ModelHitTestFilterCallback ModelFilter { get; public set; }
    public ToolCommandBindingCollection ToolCommandBindings { get; }
    public HitTestFilterCallback get_AdornerFilter();
    public void set_AdornerFilter(HitTestFilterCallback value);
    public CommandBindingCollection get_CommandBindings();
    public Cursor get_Cursor();
    public void set_Cursor(Cursor value);
    public string get_Description();
    public void set_Description(string value);
    public InputBindingCollection get_InputBindings();
    public bool get_IsFocused();
    public ModelHitTestFilterCallback get_ModelFilter();
    public void set_ModelFilter(ModelHitTestFilterCallback value);
    public ToolCommandBindingCollection get_ToolCommandBindings();
    [CompilerGeneratedAttribute]
public void add_FocusDeactivated(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_FocusDeactivated(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_Reverted(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Reverted(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_Completed(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Completed(EventHandler value);
    public void BeginFocus(GestureData data);
    public void Complete();
    public void Revert();
    protected virtual void OnCompleted(EventArgs e);
    protected virtual void OnFocusDeactivated(EventArgs e);
    protected virtual void OnReverted(EventArgs e);
}
[FeatureConnectorAttribute("MS.Internal.Features.TaskProviderFeatureConnector")]
public abstract class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.TaskProvider : FeatureProvider {
    private ICollection`1<Task> _tasks;
    private EditingContext _context;
    public ICollection`1<Task> Tasks { get; }
    protected EditingContext Context { get; }
    public ICollection`1<Task> get_Tasks();
    protected EditingContext get_Context();
    public virtual bool IsToolSupported(Tool tool);
    protected virtual void Activate(ModelItem item);
    protected virtual void Deactivate();
    internal void InvokeActivate(EditingContext context, ModelItem item);
    internal void InvokeDeactivate();
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.Tool : ContextItem {
    private EditingContext _context;
    private Cursor _cursor;
    private Collection`1<Task> _tasks;
    private Task _focusedTask;
    private bool _isUpdatingTaskItem;
    public Task FocusedTask { get; }
    protected EditingContext Context { get; }
    public Cursor Cursor { get; public set; }
    internal bool IsUpdatingTaskItem { get; }
    public Type ItemType { get; }
    public Collection`1<Task> Tasks { get; }
    public Task get_FocusedTask();
    protected EditingContext get_Context();
    public Cursor get_Cursor();
    public void set_Cursor(Cursor value);
    internal bool get_IsUpdatingTaskItem();
    public sealed virtual Type get_ItemType();
    public Collection`1<Task> get_Tasks();
    internal void ClearFocusedTask();
    internal CommandBinding GetCommandBinding(ICommand command, DependencyObject sourceAdorner, DependencyObject targetAdorner);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.Tool/<GetTaskRoute>d__21")]
private IEnumerable`1<Task> GetTaskRoute(Task sourceTask, DependencyObject sourceAdorner, DependencyObject targetAdorner);
    internal ToolCommandBinding GetToolCommandBinding(ICommand command, GestureData data);
    protected virtual void OnActivate(Tool previousTool);
    protected virtual void OnDeactivate();
    protected sealed virtual void OnItemChanged(EditingContext context, ContextItem previousItem);
    internal void SetFocusedTask(Task task);
    private void UpdateTaskItem();
}
public enum Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.ToolAction : Enum {
    public int value__;
    public static ToolAction None;
    public static ToolAction Down;
    public static ToolAction Up;
    public static ToolAction Move;
    public static ToolAction Wheel;
    public static ToolAction Click;
    public static ToolAction DoubleClick;
    public static ToolAction Enter;
    public static ToolAction Leave;
    public static ToolAction Hover;
    public static ToolAction DragIntent;
    public static ToolAction DragEnter;
    public static ToolAction DragOver;
    public static ToolAction DragLeave;
    public static ToolAction DragDrop;
    public static ToolAction DragFeedback;
    public static ToolAction DragComplete;
    public static ToolAction DragOutside;
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.ToolActionEventArgs : InputEventArgs {
    private ToolAction _toolAction;
    private EventArgs _sourceEvent;
    public ToolAction ToolAction { get; }
    public EventArgs SourceEvent { get; }
    public ToolActionEventArgs(ToolAction toolAction, InputEventArgs sourceEvent);
    public ToolActionEventArgs(ToolAction toolAction, EventArgs sourceEvent, InputDevice inputDevice, int timestamp);
    public ToolAction get_ToolAction();
    public EventArgs get_SourceEvent();
    public virtual string ToString();
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.ToolCommand : object {
    private string _name;
    public string Name { get; }
    public ToolCommand(string commandName);
    public string get_Name();
    public sealed virtual void add_CanExecuteChanged(EventHandler value);
    public sealed virtual void remove_CanExecuteChanged(EventHandler value);
    public void Execute(GestureData data);
    private ToolCommandBinding GetCommandBinding(GestureData data);
    public bool CanExecute(GestureData data);
    private static GestureData GetGestureData(object parameter, bool throwIfMissing);
    public virtual string ToString();
    private sealed virtual override void System.Windows.Input.ICommand.Execute(object parameter);
    private sealed virtual override bool System.Windows.Input.ICommand.CanExecute(object parameter);
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.ToolCommandBinding : object {
    private ToolCommand _command;
    [CompilerGeneratedAttribute]
private ExecutedToolEventHandler Execute;
    [CompilerGeneratedAttribute]
private CanExecuteToolEventHandler CanExecute;
    public ToolCommand Command { get; public set; }
    public ToolCommandBinding(ToolCommand command);
    public ToolCommandBinding(ToolCommand command, ExecutedToolEventHandler executedToolEventHandler);
    public ToolCommandBinding(ToolCommand command, ExecutedToolEventHandler executedToolEventHandler, CanExecuteToolEventHandler canExecuteToolEventHandler);
    public ToolCommand get_Command();
    public void set_Command(ToolCommand value);
    [CompilerGeneratedAttribute]
public void add_Execute(ExecutedToolEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Execute(ExecutedToolEventHandler value);
    [CompilerGeneratedAttribute]
public void add_CanExecute(CanExecuteToolEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_CanExecute(CanExecuteToolEventHandler value);
    internal bool OnCanExecute(EditingContext sender, CanExecuteToolEventArgs e);
    internal bool OnExecute(EditingContext sender, ExecutedToolEventArgs e);
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.ToolCommandBindingCollection : Collection`1<ToolCommandBinding> {
    public void AddRange(ICollection`1<ToolCommandBinding> bindings);
    protected virtual void InsertItem(int index, ToolCommandBinding item);
    protected virtual void SetItem(int index, ToolCommandBinding item);
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.ToolGesture : InputGesture {
    private ToolAction _toolAction;
    private MouseButtonState[] _buttons;
    private ModifierKeys _modifiers;
    public ToolAction ToolAction { get; public set; }
    public MouseButtonState LeftButton { get; public set; }
    public MouseButtonState RightButton { get; public set; }
    public MouseButtonState MiddleButton { get; public set; }
    public MouseButtonState XButton1 { get; public set; }
    public MouseButtonState XButton2 { get; public set; }
    public ModifierKeys Modifiers { get; public set; }
    public ToolGesture(ToolAction action);
    public ToolGesture(ToolAction action, MouseButton button);
    public ToolGesture(ToolAction action, MouseButton button, ModifierKeys modifiers);
    public ToolAction get_ToolAction();
    public void set_ToolAction(ToolAction value);
    public MouseButtonState get_LeftButton();
    public void set_LeftButton(MouseButtonState value);
    public MouseButtonState get_RightButton();
    public void set_RightButton(MouseButtonState value);
    public MouseButtonState get_MiddleButton();
    public void set_MiddleButton(MouseButtonState value);
    public MouseButtonState get_XButton1();
    public void set_XButton1(MouseButtonState value);
    public MouseButtonState get_XButton2();
    public void set_XButton2(MouseButtonState value);
    public ModifierKeys get_Modifiers();
    public void set_Modifiers(ModifierKeys value);
    private static ToolAction GetToolAction(InputEventArgs inputEventArgs);
    private static ModifierKeys GetModifiers(InputEventArgs inputEventArgs);
    private static MouseButtonState[] GetButtons(InputEventArgs inputEventArgs);
    public virtual bool Matches(object targetElement, InputEventArgs inputEventArgs);
    public virtual string ToString();
    private void ValidateButton(MouseButton button);
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.ViewHitTestFilterCallback : MulticastDelegate {
    public ViewHitTestFilterCallback(object object, IntPtr method);
    public virtual HitTestFilterBehavior Invoke(ViewItem potentialHitTestTarget);
    public virtual IAsyncResult BeginInvoke(ViewItem potentialHitTestTarget, AsyncCallback callback, object object);
    public virtual HitTestFilterBehavior EndInvoke(IAsyncResult result);
}
public abstract class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.ViewHitTestResult : object {
    public ViewItem ViewHit { get; }
    public abstract virtual ViewItem get_ViewHit();
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.ViewHitTestResultCallback : MulticastDelegate {
    public ViewHitTestResultCallback(object object, IntPtr method);
    public virtual HitTestResultBehavior Invoke(ViewHitTestResult result);
    public virtual IAsyncResult BeginInvoke(ViewHitTestResult result, AsyncCallback callback, object object);
    public virtual HitTestResultBehavior EndInvoke(IAsyncResult result);
}
public abstract class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.ViewItem : object {
    public TypeDefinition ItemType { get; }
    public FlowDirection FlowDirection { get; }
    public bool IsOffscreen { get; }
    public bool IsVisible { get; }
    public Transform LayoutTransform { get; }
    public IEnumerable`1<ViewItem> LogicalChildren { get; }
    public ViewItem LogicalParent { get; }
    public Vector Offset { get; }
    public Size RenderSize { get; }
    public Rect RenderSizeBounds { get; }
    public Rect SelectionFrameBounds { get; }
    public Transform Transform { get; }
    public Visibility Visibility { get; }
    public IEnumerable`1<ViewItem> VisualChildren { get; }
    public ViewItem VisualParent { get; }
    public abstract virtual TypeDefinition get_ItemType();
    public abstract virtual FlowDirection get_FlowDirection();
    public abstract virtual bool get_IsOffscreen();
    public abstract virtual bool get_IsVisible();
    public abstract virtual Transform get_LayoutTransform();
    public abstract virtual IEnumerable`1<ViewItem> get_LogicalChildren();
    public abstract virtual ViewItem get_LogicalParent();
    public abstract virtual Vector get_Offset();
    public abstract virtual Size get_RenderSize();
    public abstract virtual Rect get_RenderSizeBounds();
    public abstract virtual Rect get_SelectionFrameBounds();
    public abstract virtual Transform get_Transform();
    public abstract virtual Visibility get_Visibility();
    public abstract virtual IEnumerable`1<ViewItem> get_VisualChildren();
    public abstract virtual ViewItem get_VisualParent();
    public abstract virtual bool IsDescendantOf(Visual ancestor);
    public abstract virtual bool IsDescendantOf(ViewItem ancestor);
    public abstract virtual ViewHitTestResult HitTest(ViewHitTestFilterCallback filterCallback, ViewHitTestResultCallback resultCallback, HitTestParameters hitTestParameters);
    public abstract virtual Point PointToScreen(Point point);
    public abstract virtual GeneralTransform TransformFromVisual(Visual visual);
    public abstract virtual GeneralTransform TransformToView(ViewItem view);
    public abstract virtual GeneralTransform TransformToVisual(Visual visual);
    public abstract virtual void UpdateLayout();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ViewItem obj1, ViewItem obj2);
    public static bool op_Inequality(ViewItem obj1, ViewItem obj2);
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.WheelGestureData : GestureData {
    private int _delta;
    public int Delta { get; }
    public WheelGestureData(EditingContext context, ModelItem sourceModel, ModelItem targetModel, int delta);
    public WheelGestureData(EditingContext context, ModelItem sourceModel, ModelItem targetModel, int delta, DependencyObject sourceAdorner, DependencyObject targetAdorner);
    public int get_Delta();
    public static WheelGestureData FromEventArgs(ExecutedToolEventArgs e);
    public static WheelGestureData FromEventArgs(CanExecuteToolEventArgs e);
}
public interface Microsoft.VisualStudio.DesignTools.Extensibility.IToolboxExample {
    public string DisplayName { get; }
    public abstract virtual string get_DisplayName();
    public abstract virtual ModelItem CreateExample(EditingContext context);
    public abstract virtual Stream GetImageStream(Size desiredSize);
}
public interface Microsoft.VisualStudio.DesignTools.Extensibility.IToolboxExampleFactory {
    public IEnumerable`1<IToolboxExample> Examples { get; }
    public abstract virtual IEnumerable`1<IToolboxExample> get_Examples();
}
[AttributeUsageAttribute("132")]
public class Microsoft.VisualStudio.DesignTools.Extensibility.Metadata.NewItemTypesAttribute : Attribute {
    private Type factoryType;
    private String[] types;
    public IEnumerable`1<string> Types { get; }
    public Type FactoryType { get; public set; }
    public NewItemTypesAttribute(string type);
    public NewItemTypesAttribute(String[] types);
    public IEnumerable`1<string> get_Types();
    public Type get_FactoryType();
    public void set_FactoryType(Type value);
}
[FlagsAttribute]
public enum Microsoft.VisualStudio.DesignTools.Extensibility.Model.CreateOptions : Enum {
    public int value__;
    public static CreateOptions None;
    public static CreateOptions InitializeDefaults;
}
public abstract class Microsoft.VisualStudio.DesignTools.Extensibility.Model.DefaultInitializer : FeatureProvider {
    [CompilerGeneratedAttribute]
private bool <SkipDesignerInitialization>k__BackingField;
    public bool SkipDesignerInitialization { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_SkipDesignerInitialization();
    [CompilerGeneratedAttribute]
public void set_SkipDesignerInitialization(bool value);
    public virtual void InitializeDefaults(ModelItem item);
    public virtual void InitializeDefaults(ModelItem item, EditingContext context);
}
[FeatureConnectorAttribute("MS.Internal.Features.DesignModeValueProviderConnector")]
public class Microsoft.VisualStudio.DesignTools.Extensibility.Model.DesignModeValueProvider : FeatureProvider {
    private PropertyIdentifierCollection _properties;
    public PropertyIdentifierCollection Properties { get; }
    public PropertyIdentifierCollection get_Properties();
    public virtual object TranslatePropertyValue(ModelItem item, PropertyIdentifier identifier, object value);
    protected void InvalidateProperty(ModelItem item, PropertyIdentifier property);
}
internal static class Microsoft.VisualStudio.DesignTools.Extensibility.Model.EnumValidator : object {
    public static bool IsValid(CreateOptions value);
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.DesignTools.Extensibility.Model.FeatureExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<FeatureProvider> CreateFeatureProviders(FeatureManager source, Type featureProviderType, ModelItem item);
    [ExtensionAttribute]
public static IEnumerable`1<FeatureProvider> CreateFeatureProviders(FeatureManager source, Type featureProviderType, ModelItem item, Predicate`1<Type> match);
}
public abstract class Microsoft.VisualStudio.DesignTools.Extensibility.Model.ModelEditingScope : object {
    private string _description;
    private bool _completed;
    private bool _reverted;
    public string Description { get; public set; }
    protected virtual override void Finalize();
    public string get_Description();
    public void set_Description(string value);
    public void Complete();
    public void Revert();
    public virtual void Update();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected abstract virtual void OnComplete();
    protected abstract virtual bool CanComplete();
    protected abstract virtual void OnRevert(bool finalizing);
}
public abstract class Microsoft.VisualStudio.DesignTools.Extensibility.Model.ModelEvent : object {
    public TypeDefinition EventType { get; }
    public ICollection`1<string> Handlers { get; }
    public bool IsBrowsable { get; }
    public string Name { get; }
    public ModelItem Parent { get; }
    public abstract virtual TypeDefinition get_EventType();
    public abstract virtual ICollection`1<string> get_Handlers();
    public abstract virtual bool get_IsBrowsable();
    public abstract virtual string get_Name();
    public abstract virtual ModelItem get_Parent();
    public abstract virtual IEnumerable`1<object> GetAttributes(Type attributeType);
    public abstract virtual bool IsEventOfType(TypeIdentifier typeIdentifier);
}
public abstract class Microsoft.VisualStudio.DesignTools.Extensibility.Model.ModelEventCollection : ModelMemberCollection`2<ModelEvent, EventIdentifier> {
}
public static class Microsoft.VisualStudio.DesignTools.Extensibility.Model.ModelFactory : object {
    public static ModelItem CreateItem(EditingContext context, TypeIdentifier typeIdentifier);
    public static ModelItem CreateItem(EditingContext context, TypeIdentifier typeIdentifier, CreateOptions options);
    public static ModelItem CreateStaticMemberItem(EditingContext context, TypeIdentifier typeIdentifier, string memberName);
    public static string AssignUniqueName(EditingContext context, ModelItem scope, ModelItem item);
    public static string CreateValidName(EditingContext context, string proposal);
    public static bool IsExistingName(EditingContext context, ModelItem scope, string name);
}
public abstract class Microsoft.VisualStudio.DesignTools.Extensibility.Model.ModelItem : object {
    public bool IsDisposed { get; }
    public ModelProperty Content { get; }
    public EditingContext Context { get; }
    public ModelEventCollection Events { get; }
    public TypeDefinition ItemType { get; }
    public string Name { get; public set; }
    public ModelItem Parent { get; }
    public ModelItem Root { get; }
    public ModelPropertyCollection Properties { get; }
    public ModelProperty Source { get; }
    public ViewItem View { get; }
    public abstract virtual bool get_IsDisposed();
    public abstract virtual ModelProperty get_Content();
    public abstract virtual EditingContext get_Context();
    public abstract virtual ModelEventCollection get_Events();
    public abstract virtual TypeDefinition get_ItemType();
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
    public abstract virtual ModelItem get_Parent();
    public abstract virtual ModelItem get_Root();
    public abstract virtual ModelPropertyCollection get_Properties();
    public abstract virtual ModelProperty get_Source();
    public abstract virtual ViewItem get_View();
    [CompilerGeneratedAttribute]
public abstract virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public abstract virtual ModelEditingScope BeginEdit();
    public abstract virtual ModelEditingScope BeginEdit(string description);
    public abstract virtual IEnumerable`1<object> GetAttributes(Type attributeType);
    public abstract virtual object GetCurrentValue();
    public abstract virtual bool IsItemOfType(TypeIdentifier typeIdentifier);
}
[DefaultMemberAttribute("Item")]
public abstract class Microsoft.VisualStudio.DesignTools.Extensibility.Model.ModelItemCollection : ModelItem {
    public static PropertyIdentifier ItemProperty;
    public ModelItem Item { get; public set; }
    public int Count { get; }
    protected bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    protected bool IsSynchronized { get; }
    protected object SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private static ModelItemCollection();
    public abstract virtual ModelItem get_Item(int index);
    public abstract virtual void set_Item(int index, ModelItem value);
    public abstract virtual int get_Count();
    protected virtual bool get_IsFixedSize();
    public abstract virtual bool get_IsReadOnly();
    protected virtual bool get_IsSynchronized();
    protected virtual object get_SyncRoot();
    [CompilerGeneratedAttribute]
public abstract virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    public abstract virtual void Add(ModelItem item);
    public abstract virtual ModelItem Add(object value);
    public abstract virtual void Clear();
    public abstract virtual bool Contains(ModelItem item);
    public abstract virtual bool Contains(object value);
    private static ModelItem ConvertType(object value);
    public abstract virtual void CopyTo(ModelItem[] array, int arrayIndex);
    public abstract virtual IEnumerator`1<ModelItem> GetEnumerator();
    public abstract virtual int IndexOf(ModelItem item);
    public abstract virtual void Insert(int index, ModelItem item);
    public abstract virtual ModelItem Insert(int index, object value);
    public abstract virtual void Move(int fromIndex, int toIndex);
    public abstract virtual bool Remove(ModelItem item);
    public abstract virtual bool Remove(object value);
    public abstract virtual void RemoveAt(int index);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.DesignTools.Extensibility.Model.ModelItemCollection/<System-Collections-IEnumerable-GetEnumerator>d__54")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
public abstract class Microsoft.VisualStudio.DesignTools.Extensibility.Model.ModelItemDictionary : ModelItem {
    public static PropertyIdentifier KeyProperty;
    public ModelItem Item { get; public set; }
    public ModelItem Item { get; public set; }
    public int Count { get; }
    protected bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    protected bool IsSynchronized { get; }
    public ICollection`1<ModelItem> Keys { get; }
    protected object SyncRoot { get; }
    public ICollection`1<ModelItem> Values { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private static ModelItemDictionary();
    public abstract virtual ModelItem get_Item(ModelItem key);
    public abstract virtual void set_Item(ModelItem key, ModelItem value);
    public abstract virtual ModelItem get_Item(object key);
    public abstract virtual void set_Item(object key, ModelItem value);
    public abstract virtual int get_Count();
    protected virtual bool get_IsFixedSize();
    public abstract virtual bool get_IsReadOnly();
    protected virtual bool get_IsSynchronized();
    public abstract virtual ICollection`1<ModelItem> get_Keys();
    protected virtual object get_SyncRoot();
    public abstract virtual ICollection`1<ModelItem> get_Values();
    [CompilerGeneratedAttribute]
public abstract virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    public abstract virtual void Add(ModelItem key, ModelItem value);
    public abstract virtual ModelItem Add(object key, object value);
    public abstract virtual void Clear();
    protected virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    protected virtual bool Contains(KeyValuePair`2<ModelItem, ModelItem> item);
    public abstract virtual bool ContainsKey(ModelItem key);
    public abstract virtual bool ContainsKey(object key);
    private static ModelItem ConvertType(object value);
    public abstract virtual IEnumerator`1<KeyValuePair`2<ModelItem, ModelItem>> GetEnumerator();
    public abstract virtual bool Remove(ModelItem key);
    public abstract virtual bool Remove(object key);
    public abstract virtual bool TryGetValue(ModelItem key, ModelItem& value);
    public abstract virtual bool TryGetValue(object key, ModelItem& value);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override void System.Collections.IDictionary.Clear();
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.DesignTools.Extensibility.Model.ModelItemDictionary/<System-Collections-IEnumerable-GetEnumerator>d__61")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<Microsoft.VisualStudio.DesignTools.Extensibility.Model.ModelItem,Microsoft.VisualStudio.DesignTools.Extensibility.Model.ModelItem>>.Add(KeyValuePair`2<ModelItem, ModelItem> item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<Microsoft.VisualStudio.DesignTools.Extensibility.Model.ModelItem,Microsoft.VisualStudio.DesignTools.Extensibility.Model.ModelItem>>.Contains(KeyValuePair`2<ModelItem, ModelItem> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<Microsoft.VisualStudio.DesignTools.Extensibility.Model.ModelItem,Microsoft.VisualStudio.DesignTools.Extensibility.Model.ModelItem>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<Microsoft.VisualStudio.DesignTools.Extensibility.Model.ModelItem,Microsoft.VisualStudio.DesignTools.Extensibility.Model.ModelItem>>.Remove(KeyValuePair`2<ModelItem, ModelItem> item);
}
[DefaultMemberAttribute("Item")]
public abstract class Microsoft.VisualStudio.DesignTools.Extensibility.Model.ModelMemberCollection`2 : object {
    public TItemType Item { get; }
    public TItemType Item { get; }
    public TItemType get_Item(string name);
    public TItemType get_Item(TKeyType value);
    public TItemType Find(string name);
    protected abstract virtual TItemType Find(string name, bool throwOnError);
    public TItemType Find(TKeyType value);
    protected abstract virtual TItemType Find(TKeyType value, bool throwOnError);
    public abstract virtual IEnumerator`1<TItemType> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private static void Validate(TKeyType value);
}
public static class Microsoft.VisualStudio.DesignTools.Extensibility.Model.ModelParent : object {
    public static bool CanParent(EditingContext context, ModelItem parent, TypeIdentifier childType);
    public static ModelItem FindParent(EditingContext context, ModelItem childItem, ModelItem startingItem);
    public static ModelItem FindParent(EditingContext context, TypeIdentifier childType, ModelItem startingItem);
    internal static ModelItem FindParent(EditingContext context, TypeIdentifier childType, ModelItem startingItem, ModelItem childItem);
    public static ModelItem FindParent(TypeIdentifier childType, GestureData gestureData);
    public static void Parent(EditingContext context, ModelItem parentItem, ModelItem childItem);
    public static void Parent(EditingContext context, ModelItem parentItem, ModelItem childItem, int index);
}
public abstract class Microsoft.VisualStudio.DesignTools.Extensibility.Model.ModelProperty : object {
    public ModelItemCollection Collection { get; }
    public object ComputedValue { get; public set; }
    public TypeDefinition AttachedOwnerType { get; }
    public ModelItemDictionary Dictionary { get; }
    public bool IsBrowsable { get; }
    public bool IsCollection { get; }
    public bool IsDictionary { get; }
    public bool IsReadOnly { get; }
    public bool IsSet { get; }
    public bool IsAttached { get; }
    public ModelItem Value { get; }
    public string Name { get; }
    public ModelItem Parent { get; }
    public TypeDefinition PropertyType { get; }
    public abstract virtual ModelItemCollection get_Collection();
    public abstract virtual object get_ComputedValue();
    public abstract virtual void set_ComputedValue(object value);
    public abstract virtual TypeDefinition get_AttachedOwnerType();
    public abstract virtual ModelItemDictionary get_Dictionary();
    public abstract virtual bool get_IsBrowsable();
    public abstract virtual bool get_IsCollection();
    public abstract virtual bool get_IsDictionary();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual bool get_IsSet();
    public abstract virtual bool get_IsAttached();
    public abstract virtual ModelItem get_Value();
    public abstract virtual string get_Name();
    public abstract virtual ModelItem get_Parent();
    public abstract virtual TypeDefinition get_PropertyType();
    public abstract virtual void ClearValue();
    public abstract virtual IEnumerable`1<object> GetAttributes(Type attributeType);
    public abstract virtual bool IsPropertyOfType(TypeIdentifier typeIdentifier);
    public abstract virtual ModelItem SetValue(object value);
    public static bool op_Equality(ModelProperty first, ModelProperty second);
    public static bool op_Inequality(ModelProperty first, ModelProperty second);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public abstract class Microsoft.VisualStudio.DesignTools.Extensibility.Model.ModelPropertyCollection : ModelMemberCollection`2<ModelProperty, PropertyIdentifier> {
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.Model.PropertyIdentifierCollection : Collection`1<PropertyIdentifier> {
    public void Add(TypeIdentifier typeIdentifier, string name);
    public void Add(TypeDefinition ownerType, string name);
    protected virtual void InsertItem(int index, PropertyIdentifier item);
    protected virtual void SetItem(int index, PropertyIdentifier item);
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.Model.PropertyInvalidatedEventArgs : EventArgs {
    private ModelItem _item;
    private PropertyIdentifier _property;
    public ModelItem Item { get; }
    public PropertyIdentifier InvalidatedProperty { get; }
    public PropertyInvalidatedEventArgs(ModelItem item, PropertyIdentifier property);
    public ModelItem get_Item();
    public PropertyIdentifier get_InvalidatedProperty();
}
public abstract class Microsoft.VisualStudio.DesignTools.Extensibility.OrderToken : object {
    private OrderToken _reference;
    private OrderTokenPrecedence _precedence;
    private OrderTokenConflictResolution _conflictResolution;
    private int _depth;
    private int _index;
    private int _nextChildIndex;
    protected OrderToken(OrderTokenPrecedence precedence, OrderToken reference, OrderTokenConflictResolution conflictResolution);
    public virtual int CompareTo(OrderToken other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(OrderToken first, OrderToken second);
    public static bool op_Inequality(OrderToken first, OrderToken second);
    public static bool op_LessThan(OrderToken first, OrderToken second);
    public static bool op_GreaterThan(OrderToken first, OrderToken second);
    protected virtual int ResolveConflict(OrderToken left, OrderToken right);
}
public enum Microsoft.VisualStudio.DesignTools.Extensibility.OrderTokenConflictResolution : Enum {
    public int value__;
    public static OrderTokenConflictResolution Win;
    public static OrderTokenConflictResolution Lose;
}
public enum Microsoft.VisualStudio.DesignTools.Extensibility.OrderTokenPrecedence : Enum {
    public int value__;
    public static OrderTokenPrecedence Before;
    public static OrderTokenPrecedence After;
}
public abstract class Microsoft.VisualStudio.DesignTools.Extensibility.Policies.ItemPolicy : object {
    private EditingContext _context;
    private static ModelItem[] _emptyItems;
    [CompilerGeneratedAttribute]
private EventHandler`1<PolicyItemsChangedEventArgs> PolicyItemsChanged;
    protected EditingContext Context { get; }
    public bool IsSurrogate { get; }
    public IEnumerable`1<ModelItem> PolicyItems { get; }
    private static ItemPolicy();
    protected EditingContext get_Context();
    public virtual bool get_IsSurrogate();
    public abstract virtual IEnumerable`1<ModelItem> get_PolicyItems();
    public virtual IEnumerable`1<ModelItem> GetSurrogateItems(ModelItem item);
    [CompilerGeneratedAttribute]
public void add_PolicyItemsChanged(EventHandler`1<PolicyItemsChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_PolicyItemsChanged(EventHandler`1<PolicyItemsChangedEventArgs> value);
    internal void Activate(EditingContext context);
    protected abstract virtual void OnActivated();
    internal void Deactivate();
    protected virtual void OnDeactivated();
    protected virtual void OnPolicyItemsChanged(PolicyItemsChangedEventArgs e);
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.Policies.PolicyAddedEventArgs : EventArgs {
    private ItemPolicy _policy;
    public ItemPolicy Policy { get; }
    public PolicyAddedEventArgs(ItemPolicy policy);
    public ItemPolicy get_Policy();
}
public abstract class Microsoft.VisualStudio.DesignTools.Extensibility.Policies.PolicyDrivenFeatureConnector`1 : FeatureConnector`1<TFeatureProviderType> {
    private ItemPolicyConnector _policyServer;
    private ItemPolicyService _policyService;
    private Dictionary`2<ModelItem, List`1<ProviderData<TFeatureProviderType>>> _featureProviders;
    private Dictionary`2<ModelItem, List`1<ProviderData<TFeatureProviderType>>> _removes;
    private Dictionary`2<ModelItem, List`1<ProviderData<TFeatureProviderType>>> _adds;
    protected IEnumerable`1<ItemFeatureProvider<TFeatureProviderType>> FeatureProviders { get; }
    protected PolicyDrivenFeatureConnector`1(FeatureManager manager);
    protected virtual void Dispose(bool disposing);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.DesignTools.Extensibility.Policies.PolicyDrivenFeatureConnector`1/<get_FeatureProviders>d__8")]
protected IEnumerable`1<ItemFeatureProvider<TFeatureProviderType>> get_FeatureProviders();
    private void OnPolicyAdded(object sender, PolicyAddedEventArgs e);
    private void OnPolicyItemsChanged(object sender, PolicyItemsChangedEventArgs e);
    protected void UpdateFeatureProviders();
    protected virtual bool IsValidProvider(FeatureProvider featureProvider);
    protected abstract virtual void FeatureProvidersAdded(ModelItem item, IEnumerable`1<TFeatureProviderType> featureProviders);
    protected abstract virtual void FeatureProvidersRemoved(ModelItem item, IEnumerable`1<TFeatureProviderType> featureProviders);
    private IList`1<TFeatureProviderType> CreateFeatureProviders(ModelItem item, ItemPolicy policy, List`1<ProviderData<TFeatureProviderType>> dataList);
    [CompilerGeneratedAttribute]
private bool <.ctor>b__5_0(Type featureProviderType);
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.Policies.PolicyItemsChangedEventArgs : EventArgs {
    private ItemPolicy _policy;
    private IEnumerable`1<ModelItem> _itemsAdded;
    private IEnumerable`1<ModelItem> _itemsRemoved;
    public IEnumerable`1<ModelItem> ItemsAdded { get; }
    public IEnumerable`1<ModelItem> ItemsRemoved { get; }
    public ItemPolicy Policy { get; }
    public PolicyItemsChangedEventArgs(ItemPolicy policy, IEnumerable`1<ModelItem> itemsAdded, IEnumerable`1<ModelItem> itemsRemoved);
    public IEnumerable`1<ModelItem> get_ItemsAdded();
    public IEnumerable`1<ModelItem> get_ItemsRemoved();
    public ItemPolicy get_Policy();
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.Policies.PrimarySelectionPolicy : SelectionPolicy {
    protected virtual IEnumerable`1<ModelItem> GetPolicyItems(Selection selection);
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.Policies.SecondarySelectionPolicy : SelectionPolicy {
    protected virtual bool IsInPolicy(Selection selection, ModelItem item);
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.Policies.SelectionParentPolicy : SelectionPolicy {
    private Dictionary`2<ModelItem, ModelItem> _lastParents;
    private Selection _lastSelection;
    protected virtual IEnumerable`1<ModelItem> GetPolicyItems(Selection selection);
    protected virtual bool IsInPolicy(Selection selection, ModelItem item, ModelItem parent);
}
[RequiresContextItemAttribute("Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.Selection")]
[RequiresContextItemAttribute("Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.Tool")]
public class Microsoft.VisualStudio.DesignTools.Extensibility.Policies.SelectionPolicy : ItemPolicy {
    private List`1<ModelItem> _currentItems;
    public IEnumerable`1<ModelItem> PolicyItems { get; }
    public virtual IEnumerable`1<ModelItem> get_PolicyItems();
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.DesignTools.Extensibility.Policies.SelectionPolicy/<GetPolicyItems>d__4")]
protected virtual IEnumerable`1<ModelItem> GetPolicyItems(Selection selection);
    protected virtual bool IsInPolicy(Selection selection, ModelItem item);
    protected virtual void OnActivated();
    protected virtual void OnDeactivated();
    private void OnSelectionChanged(Selection newSelection);
}
[AttributeUsageAttribute("4")]
public class Microsoft.VisualStudio.DesignTools.Extensibility.Policies.UsesItemPolicyAttribute : RequirementAttribute {
    private Type _itemPolicyType;
    public bool AllRequired { get; }
    public Type ItemPolicyType { get; }
    public object TypeId { get; }
    public UsesItemPolicyAttribute(Type itemPolicyType);
    public virtual bool get_AllRequired();
    public Type get_ItemPolicyType();
    public virtual object get_TypeId();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual RequirementSubscription CreateSubscription(EditingContext context);
    public virtual bool MeetsRequirement(EditingContext context);
}
[AttributeUsageAttribute("128")]
public class Microsoft.VisualStudio.DesignTools.Extensibility.PropertyEditing.AlternateContentPropertyAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class Microsoft.VisualStudio.DesignTools.Extensibility.PropertyEditing.AttachedPropertyBrowsableForTypeIdentifierAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <TargetType>k__BackingField;
    public string TargetType { get; }
    public AttachedPropertyBrowsableForTypeIdentifierAttribute(string targetType);
    [CompilerGeneratedAttribute]
public string get_TargetType();
}
[AttributeUsageAttribute("128")]
[CLSCompliantAttribute("False")]
public class Microsoft.VisualStudio.DesignTools.Extensibility.PropertyEditing.CanBeEmptyAttribute : Attribute {
    private bool canBeEmpty;
    public bool Value { get; }
    public CanBeEmptyAttribute(bool value);
    public bool get_Value();
}
public abstract class Microsoft.VisualStudio.DesignTools.Extensibility.PropertyEditing.CategoryEditor : object {
    public string TargetCategory { get; }
    public DataTemplate EditorTemplate { get; }
    public abstract virtual bool ConsumesProperty(PropertyEntry propertyEntry);
    public abstract virtual string get_TargetCategory();
    public abstract virtual DataTemplate get_EditorTemplate();
    public abstract virtual object GetImage(Size desiredSize);
    public static EditorAttribute CreateEditorAttribute(CategoryEditor editor);
    public static EditorAttribute CreateEditorAttribute(Type categoryEditorType);
}
[DefaultMemberAttribute("Item")]
public abstract class Microsoft.VisualStudio.DesignTools.Extensibility.PropertyEditing.CategoryEntry : object {
    private string _name;
    private bool _matchesFilter;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [CompilerGeneratedAttribute]
private EventHandler`1<PropertyFilterAppliedEventArgs> FilterApplied;
    public string CategoryName { get; }
    public IEnumerable`1<PropertyEntry> Properties { get; }
    public PropertyEntry Item { get; }
    public bool MatchesFilter { get; protected set; }
    protected CategoryEntry(string name);
    public string get_CategoryName();
    public abstract virtual IEnumerable`1<PropertyEntry> get_Properties();
    public abstract virtual PropertyEntry get_Item(string propertyName);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    protected void OnPropertyChanged(string propertyName);
    [CompilerGeneratedAttribute]
public sealed virtual void add_FilterApplied(EventHandler`1<PropertyFilterAppliedEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_FilterApplied(EventHandler`1<PropertyFilterAppliedEventArgs> value);
    protected virtual void OnFilterApplied(PropertyFilter filter);
    public virtual void ApplyFilter(PropertyFilter filter);
    public virtual bool get_MatchesFilter();
    protected virtual void set_MatchesFilter(bool value);
    public abstract virtual bool MatchesPredicate(IPropertyFilterPredicate predicate);
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.PropertyEditing.CultureInfoNamesConverter : TypeConverter {
    private static StandardValuesCollection CultureInfoNames;
    private static CultureInfoNamesConverter();
    public virtual StandardValuesCollection GetStandardValues(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context);
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.PropertyEditing.DependencyPropertyValueSource : PropertyValueSource {
    private static DependencyPropertyValueSource _binding;
    private static DependencyPropertyValueSource _templateBinding;
    private static DependencyPropertyValueSource _static;
    private static DependencyPropertyValueSource _staticResource;
    private static DependencyPropertyValueSource _dynamicResource;
    private static DependencyPropertyValueSource _customMarkupExtension;
    private static DependencyPropertyValueSource _defaultValue;
    private static DependencyPropertyValueSource _localValue;
    private static DependencyPropertyValueSource _inheritedValue;
    private static DependencyPropertyValueSource _null;
    private static DependencyPropertyValueSource _ambient;
    private static DependencyPropertyValueSource _liveValue;
    private static DependencyPropertyValueSource _unparsedValue;
    private static DependencyPropertyValueSource _liveUnparsedValue;
    private ValueSource _source;
    public static DependencyPropertyValueSource Binding { get; }
    public static DependencyPropertyValueSource TemplateBinding { get; }
    public static DependencyPropertyValueSource Static { get; }
    public static DependencyPropertyValueSource StaticResource { get; }
    public static DependencyPropertyValueSource DynamicResource { get; }
    public static DependencyPropertyValueSource CustomMarkupExtension { get; }
    public static DependencyPropertyValueSource DefaultValue { get; }
    public static DependencyPropertyValueSource LocalValue { get; }
    public static DependencyPropertyValueSource LiveValue { get; }
    public static DependencyPropertyValueSource UnparsedValue { get; }
    public static DependencyPropertyValueSource LiveUnparsedValue { get; }
    public static DependencyPropertyValueSource InheritedValue { get; }
    public static DependencyPropertyValueSource Null { get; }
    public static DependencyPropertyValueSource Ambient { get; }
    public bool IsBinding { get; }
    public bool IsTemplateBinding { get; }
    public bool IsStatic { get; }
    public bool IsStaticResource { get; }
    public bool IsDynamicResource { get; }
    public bool IsCustomMarkupExtension { get; }
    public bool IsDefaultValue { get; }
    public bool IsLocalValue { get; }
    public bool IsLiveValue { get; }
    public bool IsUnparsedValue { get; }
    public bool IsInheritedValue { get; }
    public bool IsResource { get; }
    public bool IsMarkupExtension { get; }
    public bool IsNull { get; }
    public bool IsAmbient { get; }
    [ObsoleteAttribute("Use DependencyPropertyValueSource.Binding instead")]
[EditorBrowsableAttribute("1")]
public static DependencyPropertyValueSource DataBound { get; }
    [ObsoleteAttribute("Use DependencyPropertyValueSource.Static instead")]
[EditorBrowsableAttribute("1")]
public static DependencyPropertyValueSource SystemResource { get; }
    [ObsoleteAttribute("Use DependencyPropertyValueSource.StaticResource instead")]
[EditorBrowsableAttribute("1")]
public static DependencyPropertyValueSource LocalStaticResource { get; }
    [ObsoleteAttribute("Use DependencyPropertyValueSource.DynamicResource instead")]
[EditorBrowsableAttribute("1")]
public static DependencyPropertyValueSource LocalDynamicResource { get; }
    [ObsoleteAttribute("Use DependencyPropertyValueSource.LocalValue instead")]
[EditorBrowsableAttribute("1")]
public static DependencyPropertyValueSource Local { get; }
    [ObsoleteAttribute("Use DependencyPropertyValueSource.InheritedValue instead")]
[EditorBrowsableAttribute("1")]
public static DependencyPropertyValueSource Inherited { get; }
    [ObsoleteAttribute("Use DependencyPropertyValueSource.IsMarkupExtension instead")]
[EditorBrowsableAttribute("1")]
public bool IsExpression { get; }
    [ObsoleteAttribute("Use DependencyPropertyValueSource.IsBinding instead")]
[EditorBrowsableAttribute("1")]
public bool IsDataBound { get; }
    [ObsoleteAttribute("Use DependencyPropertyValueSource.IsStatic instead")]
[EditorBrowsableAttribute("1")]
public bool IsSystemResource { get; }
    [ObsoleteAttribute("Use DependencyPropertyValueSource.IsResource instead")]
[EditorBrowsableAttribute("1")]
public bool IsLocalResource { get; }
    [ObsoleteAttribute("Use DependencyPropertyValueSource.IsLocalValue instead")]
[EditorBrowsableAttribute("1")]
public bool IsLocal { get; }
    [ObsoleteAttribute("Use DependencyPropertyValueSource.IsInheritedValue instead")]
[EditorBrowsableAttribute("1")]
public bool IsInherited { get; }
    private DependencyPropertyValueSource(ValueSource source);
    public static DependencyPropertyValueSource get_Binding();
    public static DependencyPropertyValueSource get_TemplateBinding();
    public static DependencyPropertyValueSource get_Static();
    public static DependencyPropertyValueSource get_StaticResource();
    public static DependencyPropertyValueSource get_DynamicResource();
    public static DependencyPropertyValueSource get_CustomMarkupExtension();
    public static DependencyPropertyValueSource get_DefaultValue();
    public static DependencyPropertyValueSource get_LocalValue();
    public static DependencyPropertyValueSource get_LiveValue();
    public static DependencyPropertyValueSource get_UnparsedValue();
    public static DependencyPropertyValueSource get_LiveUnparsedValue();
    public static DependencyPropertyValueSource get_InheritedValue();
    public static DependencyPropertyValueSource get_Null();
    public static DependencyPropertyValueSource get_Ambient();
    public bool get_IsBinding();
    public bool get_IsTemplateBinding();
    public bool get_IsStatic();
    public bool get_IsStaticResource();
    public bool get_IsDynamicResource();
    public bool get_IsCustomMarkupExtension();
    public bool get_IsDefaultValue();
    public bool get_IsLocalValue();
    public bool get_IsLiveValue();
    public bool get_IsUnparsedValue();
    public bool get_IsInheritedValue();
    public bool get_IsResource();
    public bool get_IsMarkupExtension();
    public bool get_IsNull();
    public bool get_IsAmbient();
    public static DependencyPropertyValueSource get_DataBound();
    public static DependencyPropertyValueSource get_SystemResource();
    public static DependencyPropertyValueSource get_LocalStaticResource();
    public static DependencyPropertyValueSource get_LocalDynamicResource();
    public static DependencyPropertyValueSource get_Local();
    public static DependencyPropertyValueSource get_Inherited();
    public bool get_IsExpression();
    public bool get_IsDataBound();
    public bool get_IsSystemResource();
    public bool get_IsLocalResource();
    public bool get_IsLocal();
    public bool get_IsInherited();
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.PropertyEditing.DialogPropertyValueEditor : PropertyValueEditor {
    private DataTemplate _dialogEditorTemplate;
    public DataTemplate DialogEditorTemplate { get; public set; }
    public DialogPropertyValueEditor(DataTemplate dialogEditorTemplate, DataTemplate inlineEditorTemplate);
    public DataTemplate get_DialogEditorTemplate();
    public void set_DialogEditorTemplate(DataTemplate value);
    public virtual void ShowDialog(PropertyValue propertyValue, IInputElement commandSource);
    internal virtual DataTemplate GetPropertyValueEditor(PropertyContainerEditMode mode);
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.PropertyEditing.EditModeSwitchButton : Button {
    private PropertyContainer owningContainer;
    private bool isAttachedToContainerEvents;
    public static DependencyProperty TargetEditModeProperty;
    public static DependencyProperty SyncModeToOwningContainerProperty;
    public PropertyContainerEditMode TargetEditMode { get; public set; }
    public bool SyncModeToOwningContainer { get; public set; }
    private static EditModeSwitchButton();
    public PropertyContainerEditMode get_TargetEditMode();
    public void set_TargetEditMode(PropertyContainerEditMode value);
    private static object OnCoerceEditModeProperty(DependencyObject obj, object value);
    public bool get_SyncModeToOwningContainer();
    public void set_SyncModeToOwningContainer(bool value);
    private static void OnSyncModeToOwningContainerChanged(DependencyObject obj, DependencyPropertyChangedEventArgs e);
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    private void OnPropertyContainerDependencyPropertyChanged(object sender, DependencyPropertyChangedEventArgs e);
    private void AssociateContainerEventHandlers(PropertyContainer container);
    private void DisassociateContainerEventHandlers(PropertyContainer container);
    private void OnUnloaded(object sender, RoutedEventArgs e);
    private void OnLoaded(object sender, RoutedEventArgs e);
    protected virtual void OnMouseDown(MouseButtonEventArgs e);
    protected virtual void OnKeyDown(KeyEventArgs e);
    private void InvokePropertyValueEditorCommand();
    protected virtual AutomationPeer OnCreateAutomationPeer();
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.PropertyEditing.Editors.ElementBindingPickerPropertyValueEditor : PropertyValueEditor {
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.PropertyEditing.Editors.EventPickerPropertyValueEditor : PropertyValueEditor {
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.PropertyEditing.Editors.PagePickerPropertyValueEditor : PropertyValueEditor {
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.PropertyEditing.Editors.PropertyBindingPickerPropertyValueEditor : PropertyValueEditor {
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.PropertyEditing.Editors.PropertyPickerPropertyValueEditor : PropertyValueEditor {
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.PropertyEditing.Editors.StatePickerPropertyValueEditor : PropertyValueEditor {
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.PropertyEditing.Editors.StoryboardPickerPropertyValueEditor : PropertyValueEditor {
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.PropertyEditing.Editors.UriPropertyValueEditor : PropertyValueEditor {
}
internal static class Microsoft.VisualStudio.DesignTools.Extensibility.PropertyEditing.EnumValidator : object {
    public static bool IsValid(PropertyValueExceptionSource value);
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.PropertyEditing.ExtendedPropertyValueEditor : PropertyValueEditor {
    private DataTemplate _extendedEditorTemplate;
    public DataTemplate ExtendedEditorTemplate { get; public set; }
    public ExtendedPropertyValueEditor(DataTemplate extendedEditorTemplate, DataTemplate inlineEditorTemplate);
    public DataTemplate get_ExtendedEditorTemplate();
    public void set_ExtendedEditorTemplate(DataTemplate value);
    internal virtual DataTemplate GetPropertyValueEditor(PropertyContainerEditMode mode);
}
[DefaultMemberAttribute("Item")]
public interface Microsoft.VisualStudio.DesignTools.Extensibility.PropertyEditing.IIndexableAttribute {
    public Attribute Item { get; }
    public IEnumerable`1<string> Keys { get; }
    public abstract virtual Attribute get_Item(string key);
    public abstract virtual IEnumerable`1<string> get_Keys();
}
public interface Microsoft.VisualStudio.DesignTools.Extensibility.PropertyEditing.IPropertyFilterPredicate {
    public abstract virtual bool Match(string target);
}
public interface Microsoft.VisualStudio.DesignTools.Extensibility.PropertyEditing.IPropertyFilterTarget {
    public bool MatchesFilter { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_FilterApplied(EventHandler`1<PropertyFilterAppliedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_FilterApplied(EventHandler`1<PropertyFilterAppliedEventArgs> value);
    public abstract virtual bool get_MatchesFilter();
    public abstract virtual void ApplyFilter(PropertyFilter filter);
    public abstract virtual bool MatchesPredicate(IPropertyFilterPredicate predicate);
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.PropertyEditing.KeyAttributePair`1 : ValueType {
    private string key;
    private T value;
    public string Key { get; }
    public T Value { get; }
    public KeyAttributePair`1(string key, T value);
    public string get_Key();
    public T get_Value();
    public static bool op_Equality(KeyAttributePair`1<T> pair1, KeyAttributePair`1<T> pair2);
    public static bool op_Inequality(KeyAttributePair`1<T> pair1, KeyAttributePair`1<T> pair2);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.PropertyEditing.LinkedResourceValueEditor : PropertyValueEditor {
    public bool IsValueResource { get; }
    public LinkedResourceValueEditor(DataTemplate inlineEditorTemplate);
    public bool get_IsValueResource();
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.PropertyEditing.NewItemFactory : object {
    private Type[] NoTypes;
    public virtual Stream GetImageStream(Type type, Size desiredSize, String& imageName);
    public virtual string GetDisplayName(Type type);
    public virtual object CreateInstance(Type type);
}
[DefaultMemberAttribute("Item")]
[AttributeUsageAttribute("384")]
public class Microsoft.VisualStudio.DesignTools.Extensibility.PropertyEditing.NumberFormatAttribute : Attribute {
    private string formatString;
    private Nullable`1<int> maxPrecision;
    private Nullable`1<double> scale;
    private KeyAttributeMap`1<NumberFormatAttribute> map;
    public string FormatString { get; }
    public Nullable`1<int> MaxPrecision { get; }
    public Nullable`1<double> Scale { get; }
    public Attribute Item { get; }
    public IEnumerable`1<string> Keys { get; }
    public NumberFormatAttribute(string formatString, Nullable`1<int> maxPrecision, Nullable`1<double> scale);
    public NumberFormatAttribute(KeyAttributePair`1[] mapArray);
    public NumberFormatAttribute(string formatString, Nullable`1<int> maxPrecision, Nullable`1<double> scale, KeyAttributePair`1[] mapArray);
    public string get_FormatString();
    public Nullable`1<int> get_MaxPrecision();
    public Nullable`1<double> get_Scale();
    public sealed virtual Attribute get_Item(string key);
    public sealed virtual IEnumerable`1<string> get_Keys();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[DefaultMemberAttribute("Item")]
[AttributeUsageAttribute("384")]
public class Microsoft.VisualStudio.DesignTools.Extensibility.PropertyEditing.NumberIncrementsAttribute : Attribute {
    private Nullable`1<double> smallChange;
    private Nullable`1<double> defaultChange;
    private Nullable`1<double> largeChange;
    private KeyAttributeMap`1<NumberIncrementsAttribute> map;
    public Nullable`1<double> SmallChange { get; }
    public Nullable`1<double> DefaultChange { get; }
    public Nullable`1<double> LargeChange { get; }
    public Attribute Item { get; }
    public IEnumerable`1<string> Keys { get; }
    public NumberIncrementsAttribute(Nullable`1<double> smallChange, Nullable`1<double> defaultChange, Nullable`1<double> largeChange);
    public NumberIncrementsAttribute(KeyAttributePair`1[] mapArray);
    public NumberIncrementsAttribute(Nullable`1<double> smallChange, Nullable`1<double> defaultChange, Nullable`1<double> largeChange, KeyAttributePair`1[] mapArray);
    public Nullable`1<double> get_SmallChange();
    public Nullable`1<double> get_DefaultChange();
    public Nullable`1<double> get_LargeChange();
    public sealed virtual Attribute get_Item(string key);
    public sealed virtual IEnumerable`1<string> get_Keys();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[DefaultMemberAttribute("Item")]
[AttributeUsageAttribute("384")]
public class Microsoft.VisualStudio.DesignTools.Extensibility.PropertyEditing.NumberRangesAttribute : Attribute {
    private Nullable`1<double> hardMinimum;
    private Nullable`1<double> minimum;
    private Nullable`1<double> maximum;
    private Nullable`1<double> hardMaximum;
    private Nullable`1<bool> canBeAuto;
    private KeyAttributeMap`1<NumberRangesAttribute> map;
    public Nullable`1<double> HardMinimum { get; }
    public Nullable`1<double> Minimum { get; }
    public Nullable`1<double> Maximum { get; }
    public Nullable`1<double> HardMaximum { get; }
    public Nullable`1<bool> CanBeAuto { get; }
    public Attribute Item { get; }
    public IEnumerable`1<string> Keys { get; }
    public NumberRangesAttribute(Nullable`1<double> hardMinimum, Nullable`1<double> minimum, Nullable`1<double> maximum, Nullable`1<double> hardMaximum, Nullable`1<bool> canBeAuto);
    public NumberRangesAttribute(KeyAttributePair`1[] mapArray);
    public NumberRangesAttribute(Nullable`1<double> hardMinimum, Nullable`1<double> minimum, Nullable`1<double> maximum, Nullable`1<double> hardMaximum, Nullable`1<bool> canBeAuto, KeyAttributePair`1[] mapArray);
    public Nullable`1<double> get_HardMinimum();
    public Nullable`1<double> get_Minimum();
    public Nullable`1<double> get_Maximum();
    public Nullable`1<double> get_HardMaximum();
    public Nullable`1<bool> get_CanBeAuto();
    public sealed virtual Attribute get_Item(string key);
    public sealed virtual IEnumerable`1<string> get_Keys();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.PropertyEditing.PropertyContainer : Control {
    private static RoutedCommand _openDialogWindow;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [CompilerGeneratedAttribute]
private DependencyPropertyChangedEventHandler DependencyPropertyChanged;
    private bool _attachedToPropertyEntryEvents;
    public bool ShouldRegainKeyboardFocus;
    public static DependencyProperty PropertyEntryProperty;
    [CompilerGeneratedAttribute]
private EventHandler PropertyEntryChanged;
    public static DependencyProperty ActiveEditModeProperty;
    [CompilerGeneratedAttribute]
private EventHandler ActiveEditModeChanged;
    public static DependencyProperty IsExpandedProperty;
    public static DependencyProperty DialogCommandSourceProperty;
    public static DependencyProperty OwningPropertyContainerProperty;
    public static DependencyProperty InlineRowTemplateProperty;
    public static DependencyProperty ExtendedPopupRowTemplateProperty;
    public static DependencyProperty ExtendedPinnedRowTemplateProperty;
    public static DependencyProperty DefaultStandardValuesPropertyValueEditorProperty;
    public static DependencyProperty DefaultPropertyValueEditorProperty;
    public PropertyEntry PropertyEntry { get; public set; }
    public PropertyContainerEditMode ActiveEditMode { get; public set; }
    public bool IsExpanded { get; public set; }
    public IInputElement DialogCommandSource { get; public set; }
    public ControlTemplate InlineRowTemplate { get; public set; }
    public ControlTemplate ExtendedPopupRowTemplate { get; public set; }
    public ControlTemplate ExtendedPinnedRowTemplate { get; public set; }
    public PropertyValueEditor DefaultStandardValuesPropertyValueEditor { get; public set; }
    public PropertyValueEditor DefaultPropertyValueEditor { get; public set; }
    public DataTemplate InlineEditorTemplate { get; }
    public DataTemplate ExtendedEditorTemplate { get; }
    public DataTemplate DialogEditorTemplate { get; }
    public bool MatchesFilter { get; }
    public static RoutedCommand OpenDialogWindow { get; }
    private static PropertyContainer();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
internal void add_DependencyPropertyChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_DependencyPropertyChanged(DependencyPropertyChangedEventHandler value);
    public PropertyEntry get_PropertyEntry();
    public void set_PropertyEntry(PropertyEntry value);
    [CompilerGeneratedAttribute]
public void add_PropertyEntryChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PropertyEntryChanged(EventHandler value);
    private static void PropertyEntryPropertyChanged(DependencyObject obj, DependencyPropertyChangedEventArgs e);
    public PropertyContainerEditMode get_ActiveEditMode();
    public void set_ActiveEditMode(PropertyContainerEditMode value);
    [CompilerGeneratedAttribute]
public void add_ActiveEditModeChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ActiveEditModeChanged(EventHandler value);
    private static void OnActiveEditModePropertyChanged(DependencyObject obj, DependencyPropertyChangedEventArgs e);
    public bool get_IsExpanded();
    public void set_IsExpanded(bool value);
    public IInputElement get_DialogCommandSource();
    public void set_DialogCommandSource(IInputElement value);
    public static void SetOwningPropertyContainer(DependencyObject dependencyObject, PropertyContainer value);
    public static PropertyContainer GetOwningPropertyContainer(DependencyObject dependencyObject);
    public ControlTemplate get_InlineRowTemplate();
    public void set_InlineRowTemplate(ControlTemplate value);
    private static void RowTemplateChanged(DependencyObject obj, DependencyPropertyChangedEventArgs e);
    public ControlTemplate get_ExtendedPopupRowTemplate();
    public void set_ExtendedPopupRowTemplate(ControlTemplate value);
    public ControlTemplate get_ExtendedPinnedRowTemplate();
    public void set_ExtendedPinnedRowTemplate(ControlTemplate value);
    public PropertyValueEditor get_DefaultStandardValuesPropertyValueEditor();
    public void set_DefaultStandardValuesPropertyValueEditor(PropertyValueEditor value);
    private static void DefaultPropertyValueEditorChanged(DependencyObject obj, DependencyPropertyChangedEventArgs e);
    public PropertyValueEditor get_DefaultPropertyValueEditor();
    public void set_DefaultPropertyValueEditor(PropertyValueEditor value);
    public DataTemplate get_InlineEditorTemplate();
    public DataTemplate get_ExtendedEditorTemplate();
    public DataTemplate get_DialogEditorTemplate();
    public bool get_MatchesFilter();
    public static RoutedCommand get_OpenDialogWindow();
    internal bool SupportsEditMode(PropertyContainerEditMode mode);
    private void OnUnloaded(object sender, RoutedEventArgs e);
    private void OnLoaded(object sender, RoutedEventArgs e);
    internal void AssociatePropertyEventHandlers(PropertyEntry property);
    private void DisassociatePropertyEventHandlers(PropertyEntry property);
    private void OnPropertyPropertyChanged(object sender, PropertyChangedEventArgs e);
    private DataTemplate FindPropertyValueEditorTemplate(PropertyContainerEditMode editMode);
    private DialogPropertyValueEditor FindDialogPropertyValueEditor();
    private static void UpdateControlTemplate(PropertyContainer container);
    private void NotifyTemplatesChanged();
    private void OnDataTemplateChanged(object sender, EventArgs e);
    protected virtual void OnPropertyChanged(string propertyName);
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    private void OnShowPropertyMarkerMenu(object sender, ExecutedRoutedEventArgs e);
    private void CanShowPropertyMarkerMenu(object sender, CanExecuteRoutedEventArgs e);
    private IInputElement GetPropertyMarker(PropertyContainer container);
    protected virtual void OnPreviewKeyDown(KeyEventArgs e);
    [CompilerGeneratedAttribute]
private void <OnDataTemplateChanged>b__79_0();
    [CompilerGeneratedAttribute]
private void <OnDataTemplateChanged>b__79_1();
}
public enum Microsoft.VisualStudio.DesignTools.Extensibility.PropertyEditing.PropertyContainerEditMode : Enum {
    public int value__;
    public static PropertyContainerEditMode Inline;
    public static PropertyContainerEditMode ExtendedPopup;
    public static PropertyContainerEditMode ExtendedPinned;
    public static PropertyContainerEditMode Dialog;
}
public abstract class Microsoft.VisualStudio.DesignTools.Extensibility.PropertyEditing.PropertyEntry : object {
    private PropertyValue _parentValue;
    private bool _matchesFilter;
    private PropertyValue _value;
    [CompilerGeneratedAttribute]
private EventHandler`1<PropertyFilterAppliedEventArgs> FilterApplied;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public string PropertyName { get; }
    public string DisplayName { get; }
    public TypeDefinition PropertyType { get; }
    public string CategoryName { get; }
    public string Description { get; }
    public bool HasStandardValues { get; }
    internal bool HasStandardValuesInternal { get; }
    public bool IsReadOnly { get; }
    public bool IsAdvanced { get; }
    public ICollection StandardValues { get; }
    public PropertyValueEditor PropertyValueEditor { get; }
    public PropertyValue ParentValue { get; }
    public PropertyValue PropertyValue { get; }
    public EditingContext Context { get; }
    public IEnumerable`1<ModelProperty> ModelProperties { get; }
    public bool MatchesFilter { get; protected set; }
    protected PropertyEntry(PropertyValue parentValue);
    public abstract virtual string get_PropertyName();
    public virtual string get_DisplayName();
    public abstract virtual TypeDefinition get_PropertyType();
    public abstract virtual string get_CategoryName();
    public abstract virtual string get_Description();
    public virtual bool get_HasStandardValues();
    internal bool get_HasStandardValuesInternal();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual bool get_IsAdvanced();
    public abstract virtual ICollection get_StandardValues();
    public abstract virtual PropertyValueEditor get_PropertyValueEditor();
    public PropertyValue get_ParentValue();
    public virtual PropertyValue get_PropertyValue();
    public abstract virtual EditingContext get_Context();
    public abstract virtual IEnumerable`1<ModelProperty> get_ModelProperties();
    protected abstract virtual PropertyValue CreatePropertyValueInstance();
    [CompilerGeneratedAttribute]
public sealed virtual void add_FilterApplied(EventHandler`1<PropertyFilterAppliedEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_FilterApplied(EventHandler`1<PropertyFilterAppliedEventArgs> value);
    public sealed virtual bool get_MatchesFilter();
    protected void set_MatchesFilter(bool value);
    public virtual bool MatchesPredicate(IPropertyFilterPredicate predicate);
    public virtual void ApplyFilter(PropertyFilter filter);
    protected virtual void OnFilterApplied(PropertyFilter filter);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    protected virtual void OnPropertyChanged(PropertyChangedEventArgs e);
    protected virtual void OnPropertyChanged(string propertyName);
}
[DefaultMemberAttribute("Item")]
public abstract class Microsoft.VisualStudio.DesignTools.Extensibility.PropertyEditing.PropertyEntryCollection : object {
    private PropertyValue _parentValue;
    public PropertyValue ParentValue { get; }
    public PropertyEntry Item { get; }
    public int Count { get; }
    protected PropertyEntryCollection(PropertyValue parentValue);
    public PropertyValue get_ParentValue();
    public abstract virtual PropertyEntry get_Item(string propertyName);
    public abstract virtual int get_Count();
    public abstract virtual IEnumerator`1<PropertyEntry> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.PropertyEditing.PropertyFilter : object {
    private List`1<IPropertyFilterPredicate> textSearchPredicates;
    private List`1<IPropertyFilterPredicate> additionalPredicates;
    private ICollection`1<PropertyEntry> addedProperties;
    [CompilerGeneratedAttribute]
private bool <ShowSetPropertiesOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOrMode>k__BackingField;
    public bool ShowSetPropertiesOnly { get; private set; }
    public bool IsOrMode { get; public set; }
    public bool IsFiltering { get; }
    public bool HasTextSearchPredicates { get; }
    private bool IsTextSearchPredicatesEmpty { get; }
    private bool IsAdditionalPredicatesEmpty { get; }
    public bool IsEmpty { get; }
    public PropertyFilter(string filterText, bool showSetPropertiesOnly, ICollection`1<PropertyEntry> addedProperties);
    public PropertyFilter(IEnumerable`1<IPropertyFilterPredicate> predicates);
    [CompilerGeneratedAttribute]
public bool get_ShowSetPropertiesOnly();
    [CompilerGeneratedAttribute]
private void set_ShowSetPropertiesOnly(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsOrMode();
    [CompilerGeneratedAttribute]
public void set_IsOrMode(bool value);
    public bool get_IsFiltering();
    public bool get_HasTextSearchPredicates();
    private bool get_IsTextSearchPredicatesEmpty();
    private bool get_IsAdditionalPredicatesEmpty();
    public bool get_IsEmpty();
    public bool IsAddedProperty(PropertyEntry entry);
    public void AddDelegateFilter(Func`2<string, bool> filter);
    protected virtual void SetPredicates(string filterText);
    protected void SetPredicates(IEnumerable`1<IPropertyFilterPredicate> predicates);
    public bool Match(IPropertyFilterTarget target);
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.PropertyEditing.PropertyFilterAppliedEventArgs : EventArgs {
    private PropertyFilter _filter;
    public PropertyFilter Filter { get; }
    public PropertyFilterAppliedEventArgs(PropertyFilter filter);
    public PropertyFilter get_Filter();
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.PropertyEditing.PropertyFilterDelegatePredicate : object {
    private Func`2<string, bool> filter;
    public PropertyFilterDelegatePredicate(Func`2<string, bool> filter);
    public sealed virtual bool Match(string target);
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.PropertyEditing.PropertyFilterTextSearchPredicate : object {
    private string matchText;
    private bool isLiteralMatch;
    protected string MatchText { get; }
    private bool IsLiteralMatch { get; }
    public PropertyFilterTextSearchPredicate(string matchText, bool isLiteralMatch);
    protected string get_MatchText();
    private bool get_IsLiteralMatch();
    public sealed virtual bool Match(string target);
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.PropertyEditing.PropertyMarker : Control {
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.PropertyEditing.PropertyOrder : OrderToken {
    private static PropertyOrder _early;
    private static PropertyOrder _default;
    private static PropertyOrder _late;
    public static PropertyOrder Early { get; }
    public static PropertyOrder Default { get; }
    public static PropertyOrder Late { get; }
    private PropertyOrder(OrderTokenPrecedence precedence, OrderToken reference, OrderTokenConflictResolution conflictResolution);
    public static PropertyOrder CreateBefore(PropertyOrder reference);
    public static PropertyOrder CreateAfter(PropertyOrder reference);
    protected virtual int ResolveConflict(OrderToken left, OrderToken right);
    public static PropertyOrder get_Early();
    public static PropertyOrder get_Default();
    public static PropertyOrder get_Late();
}
[AttributeUsageAttribute("128")]
[CLSCompliantAttribute("False")]
public class Microsoft.VisualStudio.DesignTools.Extensibility.PropertyEditing.PropertyOrderAttribute : Attribute {
    private PropertyOrder _order;
    public PropertyOrder Order { get; }
    public PropertyOrderAttribute(PropertyOrder order);
    public PropertyOrder get_Order();
}
public abstract class Microsoft.VisualStudio.DesignTools.Extensibility.PropertyEditing.PropertyValue : object {
    private PropertyEntry _parentProperty;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [CompilerGeneratedAttribute]
private EventHandler RootValueChanged;
    [CompilerGeneratedAttribute]
private EventHandler SubPropertyChanged;
    [CompilerGeneratedAttribute]
private EventHandler`1<PropertyValueExceptionEventArgs> PropertyValueException;
    public PropertyEntry ParentProperty { get; }
    public PropertyValueSource Source { get; }
    public bool IsDefaultValue { get; }
    public bool IsMixedValue { get; }
    public bool CanConvertFromString { get; }
    public object Value { get; public set; }
    public string StringValue { get; public set; }
    public bool SupportsSubProperties { get; }
    public bool HasSubProperties { get; }
    public PropertyEntryCollection SubProperties { get; }
    public bool IsCollection { get; }
    public bool IsCollectionReadOnly { get; }
    public PropertyValueCollection Collection { get; }
    protected bool CatchExceptions { get; }
    protected PropertyValue(PropertyEntry parentProperty);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_RootValueChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_RootValueChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_SubPropertyChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_SubPropertyChanged(EventHandler value);
    public virtual PropertyEntry get_ParentProperty();
    public abstract virtual PropertyValueSource get_Source();
    public abstract virtual bool get_IsDefaultValue();
    public abstract virtual bool get_IsMixedValue();
    protected abstract virtual void ValidateValue(object valueToValidate);
    public abstract virtual bool get_CanConvertFromString();
    protected abstract virtual object ConvertStringToValue(string value);
    protected abstract virtual string ConvertValueToString(object value);
    protected abstract virtual object GetValueCore();
    protected abstract virtual void SetValueCore(object value);
    public abstract virtual void ClearValue();
    public object get_Value();
    public void set_Value(object value);
    private void SetValueImpl(object value);
    public string get_StringValue();
    public void set_StringValue(string value);
    public abstract virtual bool get_SupportsSubProperties();
    public abstract virtual bool get_HasSubProperties();
    public abstract virtual PropertyEntryCollection get_SubProperties();
    public abstract virtual bool get_IsCollection();
    public abstract virtual bool get_IsCollectionReadOnly();
    public abstract virtual PropertyValueCollection get_Collection();
    [CompilerGeneratedAttribute]
public void add_PropertyValueException(EventHandler`1<PropertyValueExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_PropertyValueException(EventHandler`1<PropertyValueExceptionEventArgs> value);
    protected virtual bool get_CatchExceptions();
    protected virtual void OnPropertyValueException(PropertyValueExceptionEventArgs e);
    protected virtual void NotifyRootValueChanged();
    protected void NotifySubPropertyChanged();
    private void NotifyValueChanged();
    private void NotifyStringValueChanged();
    private void OnRootValueChanged();
    private void OnSubPropertyChanged();
    protected virtual void OnPropertyChanged(PropertyChangedEventArgs e);
    protected virtual void OnPropertyChanged(string propertyName);
}
[DefaultMemberAttribute("Item")]
public abstract class Microsoft.VisualStudio.DesignTools.Extensibility.PropertyEditing.PropertyValueCollection : object {
    [CompilerGeneratedAttribute]
private NotifyCollectionChangedEventHandler CollectionChanged;
    private PropertyValue _parentValue;
    public PropertyValue ParentValue { get; }
    public PropertyValue Item { get; }
    public int Count { get; }
    protected PropertyValueCollection(PropertyValue parentValue);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    public PropertyValue get_ParentValue();
    public abstract virtual PropertyValue get_Item(int index);
    public abstract virtual PropertyValue Add(object value);
    public abstract virtual PropertyValue Insert(object value, int index);
    public abstract virtual bool Remove(PropertyValue propertyValue);
    public abstract virtual void RemoveAt(int index);
    public abstract virtual int get_Count();
    public abstract virtual void SetIndex(int currentIndex, int newIndex);
    public abstract virtual IEnumerator`1<PropertyValue> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    protected virtual void OnCollectionChanged(NotifyCollectionChangedEventArgs e);
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.PropertyEditing.PropertyValueEditor : object {
    private DataTemplate _inlineEditorTemplate;
    public DataTemplate InlineEditorTemplate { get; public set; }
    public bool SuppressValueAreaWrapper { get; }
    public PropertyValueEditor(DataTemplate inlineEditorTemplate);
    public DataTemplate get_InlineEditorTemplate();
    public void set_InlineEditorTemplate(DataTemplate value);
    public virtual bool get_SuppressValueAreaWrapper();
    internal virtual DataTemplate GetPropertyValueEditor(PropertyContainerEditMode mode);
    public static EditorAttribute CreateEditorAttribute(PropertyValueEditor editor);
    public static EditorAttribute CreateEditorAttribute(Type propertyValueEditorType);
}
public static class Microsoft.VisualStudio.DesignTools.Extensibility.PropertyEditing.PropertyValueEditorCommands : object {
    private static RoutedCommand _showInlineEditor;
    private static RoutedCommand _showExtendedPopupEditor;
    private static RoutedCommand _showExtendedPinnedEditor;
    private static RoutedCommand _expandSubPropertyEditor;
    private static RoutedCommand _collapseSubPropertyEditor;
    private static RoutedCommand _showDialogEditor;
    private static RoutedCommand _beginTransaction;
    private static RoutedCommand _commitTransaction;
    private static RoutedCommand _abortTransaction;
    private static RoutedCommand _finishEditing;
    private static RoutedCommand _showErrorMessage;
    private static RoutedCommand _showContextMenu;
    private static RoutedCommand _PrepareSourceData;
    private static RoutedCommand _showPropertyMarkerMenu;
    private static RoutedCommand _goToResource;
    public static RoutedCommand ShowErrorMessage { get; }
    public static RoutedCommand ShowInlineEditor { get; }
    public static RoutedCommand ShowExtendedPopupEditor { get; }
    public static RoutedCommand ShowExtendedPinnedEditor { get; }
    public static RoutedCommand ExpandSubPropertyEditor { get; }
    public static RoutedCommand CollapseSubPropertyEditor { get; }
    public static RoutedCommand ShowDialogEditor { get; }
    public static RoutedCommand BeginTransaction { get; }
    public static RoutedCommand CommitTransaction { get; }
    public static RoutedCommand AbortTransaction { get; }
    public static RoutedCommand FinishEditing { get; }
    public static RoutedCommand PrepareSourceData { get; }
    public static RoutedCommand ShowPropertyMarkerMenu { get; }
    public static RoutedCommand ShowContextMenu { get; }
    public static RoutedCommand GoToResource { get; }
    public static RoutedCommand get_ShowErrorMessage();
    public static RoutedCommand get_ShowInlineEditor();
    public static RoutedCommand get_ShowExtendedPopupEditor();
    public static RoutedCommand get_ShowExtendedPinnedEditor();
    public static RoutedCommand get_ExpandSubPropertyEditor();
    public static RoutedCommand get_CollapseSubPropertyEditor();
    public static RoutedCommand get_ShowDialogEditor();
    public static RoutedCommand get_BeginTransaction();
    public static RoutedCommand get_CommitTransaction();
    public static RoutedCommand get_AbortTransaction();
    public static RoutedCommand get_FinishEditing();
    public static RoutedCommand get_PrepareSourceData();
    public static RoutedCommand get_ShowPropertyMarkerMenu();
    public static RoutedCommand get_ShowContextMenu();
    public static RoutedCommand get_GoToResource();
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.PropertyEditing.PropertyValueExceptionEventArgs : EventArgs {
    private string _message;
    private PropertyValue _value;
    private PropertyValueExceptionSource _source;
    private Exception _exception;
    public string Message { get; }
    public PropertyValue PropertyValue { get; }
    public PropertyValueExceptionSource Source { get; }
    public Exception Exception { get; }
    public PropertyValueExceptionEventArgs(string message, PropertyValue value, PropertyValueExceptionSource source, Exception exception);
    public string get_Message();
    public PropertyValue get_PropertyValue();
    public PropertyValueExceptionSource get_Source();
    public Exception get_Exception();
}
public enum Microsoft.VisualStudio.DesignTools.Extensibility.PropertyEditing.PropertyValueExceptionSource : Enum {
    public int value__;
    public static PropertyValueExceptionSource Get;
    public static PropertyValueExceptionSource Set;
}
public abstract class Microsoft.VisualStudio.DesignTools.Extensibility.PropertyEditing.PropertyValueSource : object {
}
[AttributeUsageAttribute("4")]
public class Microsoft.VisualStudio.DesignTools.Extensibility.RequiresHostAttribute : RequirementAttribute {
    private HostKind hostKind;
    public HostKind HostKind { get; }
    public object TypeId { get; }
    public RequiresHostAttribute(HostKind hostKind);
    public HostKind get_HostKind();
    public virtual object get_TypeId();
    public virtual RequirementSubscription CreateSubscription(EditingContext context);
    public virtual bool MeetsRequirement(EditingContext context);
}
public abstract class Microsoft.VisualStudio.DesignTools.Extensibility.Services.AdapterService : object {
    public TAdapterType GetAdapter(TypeDefinition itemType);
    public abstract virtual Adapter GetAdapter(Type adapterType, TypeDefinition itemType);
}
public abstract class Microsoft.VisualStudio.DesignTools.Extensibility.Services.BinaryResource : object {
    public Uri FileUri { get; }
    public Uri StreamUri { get; }
    public bool IsResourceValid { get; }
    public abstract virtual Uri get_FileUri();
    public abstract virtual Uri get_StreamUri();
    public abstract virtual bool get_IsResourceValid();
    [CompilerGeneratedAttribute]
public abstract virtual void add_Changed(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Changed(EventHandler value);
    public abstract virtual Stream OpenStream(FileAccess access);
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.Services.ContextMenuService : object {
    private ContextMenuFeatureConnector _contextMenuExtensionServer;
    internal ContextMenuService(ContextMenuFeatureConnector contextMenuExtensionServer);
    public IEnumerable`1<MenuBase> GetItems();
}
public abstract class Microsoft.VisualStudio.DesignTools.Extensibility.Services.DocumentResourceItem : object {
    public ModelItem Key { get; }
    public ModelItem Value { get; }
    public abstract virtual ModelItem get_Key();
    public abstract virtual ModelItem get_Value();
}
public abstract class Microsoft.VisualStudio.DesignTools.Extensibility.Services.DocumentResourceService : object {
    public abstract virtual IEnumerable`1<DocumentResourceItem> GetResourcesInScope(ModelItem item, ResourceSearchType searchType, Predicate`1<DocumentResourceItem> filter);
}
public abstract class Microsoft.VisualStudio.DesignTools.Extensibility.Services.EventBindingService : object {
    [CompilerGeneratedAttribute]
private EventHandler`1<EventHandlerGeneratedEventArgs> EventHandlerGenerated;
    [CompilerGeneratedAttribute]
public void add_EventHandlerGenerated(EventHandler`1<EventHandlerGeneratedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_EventHandlerGenerated(EventHandler`1<EventHandlerGeneratedEventArgs> value);
    public abstract virtual void SetClassName(string className);
    public abstract virtual bool CreateMethod(ModelEvent modelEvent, string methodName);
    public abstract virtual void AppendStatements(ModelEvent modelEvent, string methodName, CodeStatementCollection statements);
    public abstract virtual string CreateUniqueMethodName(ModelEvent modelEvent);
    public abstract virtual bool AllowClassNameForMethodName();
    public abstract virtual IEnumerable`1<string> GetCompatibleMethods(ModelEvent modelEvent);
    public abstract virtual bool IsExistingMethodName(ModelEvent modelEvent, string methodName);
    public abstract virtual void ValidateMethodName(ModelEvent modelEvent, string methodName);
    public abstract virtual bool RemoveMethod(ModelEvent modelEvent, string methodName);
    public abstract virtual bool ShowMethod(ModelEvent modelEvent, string methodName);
    public abstract virtual IEnumerable`1<string> GetMethodHandlers(ModelEvent modelEvent);
    public abstract virtual bool AddEventHandler(ModelEvent modelEvent, string methodName);
    public abstract virtual bool RemoveHandle(ModelEvent modelEvent, string methodName);
    public virtual bool RemoveHandlesForName(string elementName);
    protected virtual void OnEventHandlerGenerated(ModelEvent modelEvent, string methodName);
}
public class Microsoft.VisualStudio.DesignTools.Extensibility.Services.EventHandlerGeneratedEventArgs : EventArgs {
    private ModelEvent _modelEvent;
    private string _methodName;
    public ModelEvent ModelEvent { get; }
    public string MethodName { get; }
    public EventHandlerGeneratedEventArgs(ModelEvent modelEvent, string methodName);
    public ModelEvent get_ModelEvent();
    public string get_MethodName();
}
public abstract class Microsoft.VisualStudio.DesignTools.Extensibility.Services.ExternalMarkupService : object {
    public abstract virtual ModelItem Load(string markup, IEnumerable`1<AssemblyIdentifier> additionalReferences);
    public abstract virtual string Save(ModelItem root, IEnumerable`1& requiredAssemblies);
}
public abstract class Microsoft.VisualStudio.DesignTools.Extensibility.Services.ExternalResourceService : object {
    public ModelResource ApplicationModel { get; }
    public IEnumerable`1<Uri> ResourceUris { get; }
    public abstract virtual ModelResource get_ApplicationModel();
    public abstract virtual IEnumerable`1<Uri> get_ResourceUris();
    public abstract virtual ModelResource GetModelResource(Uri uri);
    public abstract virtual BinaryResource GetBinaryResource(Uri uri);
    public abstract virtual Uri TranslateStreamUri(Uri streamUri);
}
public interface Microsoft.VisualStudio.DesignTools.Extensibility.Services.ICodeInjectionService {
    public abstract virtual bool CreateMethod(CodeMemberMethod method);
    public abstract virtual void AppendStatements(CodeMemberMethod method, CodeStatementCollection statements, int relativePosition);
}
public abstract class Microsoft.VisualStudio.DesignTools.Extensibility.Services.InformationService : object {
    public HostKind HostKind { get; }
    public abstract virtual HostKind get_HostKind();
}
internal abstract class Microsoft.VisualStudio.DesignTools.Extensibility.Services.ItemPolicyService : object {
    public IEnumerable`1<ItemPolicy> Policies { get; }
    public abstract virtual IEnumerable`1<ItemPolicy> get_Policies();
    [CompilerGeneratedAttribute]
public abstract virtual void add_PolicyAdded(EventHandler`1<PolicyAddedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PolicyAdded(EventHandler`1<PolicyAddedEventArgs> value);
}
public abstract class Microsoft.VisualStudio.DesignTools.Extensibility.Services.ModelChangedEventArgs : EventArgs {
    public IEnumerable`1<ModelItem> ItemsAdded { get; }
    public IEnumerable`1<ModelItem> ItemsRemoved { get; }
    public IEnumerable`1<ModelProperty> PropertiesChanged { get; }
    public IEnumerable`1<string> PropertyNamesChanged { get; }
    public abstract virtual IEnumerable`1<ModelItem> get_ItemsAdded();
    public abstract virtual IEnumerable`1<ModelItem> get_ItemsRemoved();
    public abstract virtual IEnumerable`1<ModelProperty> get_PropertiesChanged();
    public abstract virtual IEnumerable`1<string> get_PropertyNamesChanged();
}
public abstract class Microsoft.VisualStudio.DesignTools.Extensibility.Services.ModelResource : object {
    public ModelItem ModelItem { get; }
    public abstract virtual ModelItem get_ModelItem();
    [CompilerGeneratedAttribute]
public abstract virtual void add_Changed(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Changed(EventHandler value);
}
public abstract class Microsoft.VisualStudio.DesignTools.Extensibility.Services.ModelService : object {
    public ModelItem Scope { get; }
    public ModelItem Root { get; }
    public virtual ModelItem get_Scope();
    public abstract virtual ModelItem get_Root();
    [CompilerGeneratedAttribute]
public abstract virtual void add_ModelChanged(EventHandler`1<ModelChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ModelChanged(EventHandler`1<ModelChangedEventArgs> value);
    public abstract virtual ModelItem ConvertItem(ModelItem item);
    protected abstract virtual ModelItem CreateItem(TypeIdentifier typeIdentifier, CreateOptions options);
    protected abstract virtual ModelItem CreateStaticMemberItem(TypeIdentifier typeIdentifier, string memberName);
    public abstract virtual IEnumerable`1<ModelItem> Find(ModelItem startingItem, TypeDefinition typeDefinition);
    public abstract virtual IEnumerable`1<ModelItem> Find(ModelItem startingItem, TypeIdentifier typeIdentifier);
    public abstract virtual IEnumerable`1<ModelItem> Find(ModelItem startingItem, Predicate`1<TypeDefinition> match);
    public ModelItem FromName(ModelItem scope, string name);
    public abstract virtual ModelItem FromName(ModelItem scope, string name, StringComparison comparison);
    internal ModelItem InvokeCreateItem(TypeIdentifier typeIdentifier, CreateOptions options);
    internal ModelItem InvokeCreateStaticMemberItem(TypeIdentifier typeIdentifier, string memberName);
    protected virtual string AssignUniqueName(ModelItem scope, ModelItem item);
    internal string InvokeAssignUniqueName(ModelItem scope, ModelItem item);
    protected virtual string CreateValidName(string proposal);
    internal string InvokeCreateValidName(string proposal);
    protected virtual bool IsExistingName(ModelItem scope, string name);
    internal bool InvokeIsExistingName(ModelItem scope, string name);
}
public enum Microsoft.VisualStudio.DesignTools.Extensibility.Services.ResourceSearchType : Enum {
    public int value__;
    public static ResourceSearchType Static;
    public static ResourceSearchType Dynamic;
}
public abstract class Microsoft.VisualStudio.DesignTools.Extensibility.Services.ValueTranslationService : object {
    public abstract virtual IEnumerable`1<PropertyIdentifier> GetProperties(TypeDefinition itemType);
    public abstract virtual bool HasValueTranslation(TypeDefinition itemType, PropertyIdentifier identifier);
    public abstract virtual object TranslatePropertyValue(TypeDefinition itemType, ModelItem item, PropertyIdentifier identifier, object value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PropertyInvalidated(EventHandler`1<PropertyInvalidatedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PropertyInvalidated(EventHandler`1<PropertyInvalidatedEventArgs> value);
    public abstract virtual void InvalidateProperty(ModelItem item, PropertyIdentifier identifier);
}
public abstract class Microsoft.VisualStudio.DesignTools.Extensibility.Services.ViewService : object {
    [CompilerGeneratedAttribute]
public abstract virtual void add_LayoutUpdated(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_LayoutUpdated(EventHandler value);
    public abstract virtual ModelItem GetModel(ViewItem view);
}
[AttributeUsageAttribute("4")]
public class Microsoft.VisualStudio.DesignTools.Extensibility.ToolboxBrowsableAttribute : Attribute {
    private static ToolboxBrowsableAttribute _yes;
    private static ToolboxBrowsableAttribute _no;
    private static ToolboxBrowsableAttribute _addedByDefault;
    private static ToolboxBrowsableAttribute _canBeAdded;
    private static ToolboxBrowsableAttribute _disabled;
    private bool _browsable;
    private ToolboxBrowsableBehavior _behavior;
    public bool Browsable { get; }
    public ToolboxBrowsableBehavior Behavior { get; }
    public static ToolboxBrowsableAttribute Yes { get; }
    public static ToolboxBrowsableAttribute No { get; }
    public static ToolboxBrowsableAttribute AddedByDefault { get; }
    public static ToolboxBrowsableAttribute CanBeAdded { get; }
    public static ToolboxBrowsableAttribute Disabled { get; }
    public ToolboxBrowsableAttribute(bool browsable);
    public ToolboxBrowsableAttribute(ToolboxBrowsableBehavior behavior);
    public bool get_Browsable();
    public ToolboxBrowsableBehavior get_Behavior();
    public static ToolboxBrowsableAttribute get_Yes();
    public static ToolboxBrowsableAttribute get_No();
    public static ToolboxBrowsableAttribute get_AddedByDefault();
    public static ToolboxBrowsableAttribute get_CanBeAdded();
    public static ToolboxBrowsableAttribute get_Disabled();
}
public enum Microsoft.VisualStudio.DesignTools.Extensibility.ToolboxBrowsableBehavior : Enum {
    public int value__;
    public static ToolboxBrowsableBehavior AddedByDefault;
    public static ToolboxBrowsableBehavior CanBeAdded;
    public static ToolboxBrowsableBehavior Disabled;
}
[AttributeUsageAttribute("4")]
public class Microsoft.VisualStudio.DesignTools.Extensibility.ToolboxCategoryAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <CategoryPath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeParentAttributes>k__BackingField;
    public string CategoryPath { get; private set; }
    public bool IncludeParentAttributes { get; private set; }
    public ToolboxCategoryAttribute(string categoryPath);
    public ToolboxCategoryAttribute(string categoryPath, bool includeParentAttributes);
    [CompilerGeneratedAttribute]
public string get_CategoryPath();
    [CompilerGeneratedAttribute]
private void set_CategoryPath(string value);
    [CompilerGeneratedAttribute]
public bool get_IncludeParentAttributes();
    [CompilerGeneratedAttribute]
private void set_IncludeParentAttributes(bool value);
}
[AttributeUsageAttribute("4")]
public class Microsoft.VisualStudio.DesignTools.Extensibility.ToolboxExampleAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <ToolboxExampleFactoryType>k__BackingField;
    public Type ToolboxExampleFactoryType { get; private set; }
    public ToolboxExampleAttribute(Type toolboxExampleFactoryType);
    [CompilerGeneratedAttribute]
public Type get_ToolboxExampleFactoryType();
    [CompilerGeneratedAttribute]
private void set_ToolboxExampleFactoryType(Type value);
}
[AttributeUsageAttribute("4")]
public class Microsoft.VisualStudio.DesignTools.Extensibility.ToolboxTabNameAttribute : Attribute {
    public static string CommonTab;
    [CompilerGeneratedAttribute]
private string <TabName>k__BackingField;
    public string TabName { get; private set; }
    public ToolboxTabNameAttribute(string tabName);
    [CompilerGeneratedAttribute]
public string get_TabName();
    [CompilerGeneratedAttribute]
private void set_TabName(string value);
}
internal static class Microsoft.VisualStudio.DesignTools.Utility.BrandNames : object {
    public static string VSGeneralBrand;
    public static string VSGeneralBrandMicrosoft;
    public static string VSGeneralBrandName;
    public static string VSGeneralBrandRelease;
    public static string VSGeneralBrandVersion;
    public static string VSGeneralVersion;
    public static string VSGeneralUserFilesFolderName;
}
internal static class Microsoft.VisualStudio.Internal.BrandNames : object {
    public static string VSGeneralAssemblyVersionPrevious;
    public static string Manufacturer;
    public static string EnterpriseGeneralBrandVersionRelease;
    public static string EnterpriseBrandVersionRelease;
    public static string EnterpriseGeneralBrandVersionReleaseLanguage;
    public static string EnterpriseName;
    public static string SSEnterpriseGeneralBrandVersionRelease;
    public static string SSEditionEnterpriseName;
    public static string EditionEnterpriseName;
    public static string EnterpriseBrandName;
    public static string EnterpriseBrandNameM;
    public static string EnterpriseBrandNameVersion;
    public static string EnterpriseBrandNameVersionM;
    public static string EnterpriseBrandNameVersionReleaseM;
    public static string EnterpriseBrandNameVersionReleaseMNoLoc;
    public static string EnterpriseBrandNameVersionReleaseMsiResource;
    public static string EnterpriseBrandNameShort;
    public static string EnterpriseNameA;
    public static string EnterpriseEditionNameA;
    public static string EnterpriseBrandNameA;
    public static string EnterpriseBrandNameMA;
    public static string EnterpriseBrandNameVersionA;
    public static string EnterpriseBrandNameVersionMA;
    public static string EnterpriseBrandNameVersionReleaseA;
    public static string EnterpriseBrandNameVersionReleaseMA;
    public static string EnterpriseBrandNameShortA;
    public static string VSTDBrandNameVersionReleaseM;
    public static string VSTDBrandNameVersionReleaseResourceMsi;
    public static string TeamExplorerGeneralBrandVersionRelease;
    public static string TeamExplorerBrandVersionRelease;
    public static string TeamExplorerGeneralBrandVersionReleaseLanguage;
    public static string TeamExplorerName;
    public static string SSTeamExplorerGeneralBrandVersionRelease;
    public static string SSEditionTeamExplorerName;
    public static string EditionTeamExplorerName;
    public static string TeamExplorerBrandName;
    public static string TeamExplorerBrandNameM;
    public static string TeamExplorerBrandNameVersion;
    public static string TeamExplorerBrandNameVersionM;
    public static string TeamExplorerBrandNameVersionReleaseM;
    public static string TeamExplorerBrandNameVersionReleaseMNoLoc;
    public static string TeamExplorerBrandNameVersionReleaseMsiResource;
    public static string TeamExplorerBrandNameShort;
    public static string TeamExplorerNameA;
    public static string TeamExplorerEditionNameA;
    public static string TeamExplorerBrandNameA;
    public static string TeamExplorerBrandNameMA;
    public static string TeamExplorerBrandNameVersionA;
    public static string TeamExplorerBrandNameVersionMA;
    public static string TeamExplorerBrandNameVersionReleaseA;
    public static string TeamExplorerBrandNameVersionReleaseMA;
    public static string TeamExplorerBrandNameShortA;
    public static string ProfessionalGeneralBrandVersionRelease;
    public static string ProfessionalBrandVersionRelease;
    public static string ProfessionalGeneralBrandVersionReleaseLanguage;
    public static string SSEditionProName;
    public static string EditionProName;
    public static string ProBrandName;
    public static string ProBrandNameM;
    public static string ProBrandNameVersionM;
    public static string ProBrandNameVersionReleaseM;
    public static string ProBrandNameVersionReleaseMNoLoc;
    public static string ProBrandNameVersionReleaseResourceMsi;
    public static string ProBrandNameShort;
    public static string ProNameA;
    public static string ProEditionNameA;
    public static string ProBrandNameA;
    public static string ProBrandNameMA;
    public static string ProBrandNameVersionA;
    public static string ProBrandNameVersionMA;
    public static string ProBrandNameVersionReleaseA;
    public static string ProBrandNameVersionReleaseMA;
    public static string ProBrandNameShortA;
    public static string CommunityGeneralBrandVersionRelease;
    public static string CommunityBrandVersionRelease;
    public static string CommunityBrandNameVersionM;
    public static string EditionCommunityName;
    public static string SSEditionCommunityName;
    public static string CommunityEditionNameA;
    public static string CommunityBrandNameShortA;
    public static string CommunityBrandNameVersionReleaseMA;
    public static string CommunityBrandNameVersionReleaseM;
    public static string CommunityBrandNameVersionReleaseA;
    public static string CommunityBrandNameVersionReleaseResourceMsi;
    public static string TestProfessionalGeneralBrandVersionRelease;
    public static string TestProfessionalBrandVersionRelease;
    public static string TestProfessionalGeneralBrandVersionReleaseLanguage;
    public static string FeedbackClientGeneralBrandVersionRelease;
    public static string FeedbackClientBrandVersionRelease;
    public static string FeedbackClientGeneralBrandVersionReleaseLanguage;
    public static string AgentsGeneralBrandVersionRelease;
    public static string AgentsBrandVersionRelease;
    public static string AgentsGeneralBrandVersionReleaseLanguage;
    public static string TestControllerGeneralBrandVersionRelease;
    public static string TestControllerBrandVersionRelease;
    public static string TestControllerGeneralBrandVersionReleaseLanguage;
    public static string TestToolsGeneralBrandVersionRelease;
    public static string TestToolsBrandVersionRelease;
    public static string TestToolsGeneralBrandVersionReleaseLanguage;
    public static string TestToolsLanguagePackGeneralBrandVersionReleaseLanguage;
    public static string TestToolsLanguagePackBrandVersionReleaseLanguage;
    public static string IsoShellGeneralBrandVersionRelease;
    public static string IsoShellBrandVersionRelease;
    public static string IsoShellGeneralBrandVersionReleaseLanguage;
    public static string IsoShellLanguagePackGeneralBrandVersionReleaseLanguage;
    public static string IsoShellLanguagePackBrandVersionReleaseLanguage;
    public static string IntShellGeneralBrandVersionRelease;
    public static string IntShellBrandVersionRelease;
    public static string IntShellGeneralBrandVersionReleaseLanguage;
    public static string IntShellLanguagePackGeneralBrandVersionReleaseLanguage;
    public static string IntShellLanguagePackBrandVersionReleaseLanguage;
    public static string VSSDKGeneralVersionReleaseBrand;
    public static string VSSDKVersionReleaseBrand;
    public static string VSSDKGeneralVersionReleaseBrandLanguage;
    public static string VSSDKExpInstanceLaunchShortcutName;
    public static string VSSDKExpInstanceRecreateShortcutName;
    public static string VSSDKGettingStartedShortcutName;
    public static string VSSDKLanguagePackVersionReleaseBrandLanguage;
    public static string VSSDKLanguagePackGeneralVersionReleaseBrandLanguage;
    public static string TestHostLongProductName;
    public static string TestHostShortProductName;
    public static string GeneralBrandVersionRelease;
    public static string GeneralBrandShortcutName;
    public static string VSToolsFolderGeneralBrandShortcutName;
    public static string VSToolsFolderGeneralBrandDescription;
    public static string VisualStudioLanguagePackGeneralBrandVersionRelease;
    public static string VisualStudioLanguagePackBrandVersionReleaseLanguage;
    public static string TestProfessionalLanguagePackGeneralBrandVersionRelease;
    public static string TestProfessionalLanguagePackBrandVersionReleaseLanguage;
    public static string FeedbackClientLanguagePackGeneralBrandVersionRelease;
    public static string FeedbackClientLanguagePackBrandVersionReleaseLanguage;
    public static string AgentsLanguagePackGeneralBrandVersionRelease;
    public static string AgentsLanguagePackBrandVersionReleaseLanguage;
    public static string TestControllerLanguagePackGeneralBrandVersionRelease;
    public static string TestControllerLanguagePackBrandVersionReleaseLanguage;
    public static string WindowsExpressGeneralBrandVersionRelease;
    public static string WindowsExpressBrandVersionRelease;
    public static string WindowsGeneralBrandVersionReleaseLanguage;
    public static string WindowsExpressBrandShortcutName;
    public static string WindowsExpressLanguagePackGeneralBrandVersionReleaseLanguage;
    public static string WindowsExpressLanguagePackBrandVersionReleaseLanguage;
    public static string PhoneAddonGeneralBrandVersionReleaseLanguage;
    public static string PhoneAddonBrandNoRelease;
    public static string PhoneAddonBrandVersionRelease;
    public static string PhoneAddonWindowsExpressCoreGeneralBrandVersionRelease;
    public static string PhoneAddonWindowsExpressCoreGeneralBrandVersionReleaseLanguage;
    public static string PhoneAddonProfessionalCoreGeneralBrandVersionRelease;
    public static string PhoneAddonProfessionalCoreGeneralBrandVersionReleaseLanguage;
    public static string PhoneAddonSharedCoreGeneralBrandVersionRelease;
    public static string PhoneAddonSharedCoreGeneralBrandVersionReleaseLanguage;
    public static string VSTemplatesGeneralBrandVersionReleaseLanguage;
    public static string VSTemplatesBrandNoRelease;
    public static string VSTemplatesBrandVersionRelease;
    public static string VSTemplatesWindowsExpressCoreGeneralBrandVersionRelease;
    public static string VSTemplatesWindowsExpressCoreGeneralBrandVersionReleaseLanguage;
    public static string VSTemplatesProfessionalCoreGeneralBrandVersionRelease;
    public static string VSTemplatesProfessionalCoreGeneralBrandVersionReleaseLanguage;
    public static string VSTemplatesSharedCoreGeneralBrandVersionRelease;
    public static string VSTemplatesSharedCoreGeneralBrandVersionReleaseLanguage;
    public static string VSTemplates_Win81WP81_CommunityCoreGeneralBrandVersionReleaseLanguage;
    public static string WindowsBuildCoreMSI;
    public static string WindowsBuildCoreResMSI;
    public static string WindowsToolsCoreMSI;
    public static string WindowsToolsCoreResMSI;
    public static string WindowsTestCoreMSI;
    public static string WindowsMobileEmulatorsMSI;
    public static string WindowsMobileEmSaveStateMSI;
    public static string WindowsOneCoreDesktopMSI;
    public static string Windows10Tools_BundleName;
    public static string WindowsSimulatorMSI;
    public static string WindowsSimulatorResMSI;
    public static string WindowsPhoneEmulators80GeneralBrandVersionReleaseLanguage;
    public static string WindowsPhoneEmulators80BrandNoRelease;
    public static string WindowsPhoneEmulators80BrandVersionRelease;
    public static string WindowsPhoneEmulators81GeneralBrandVersionReleaseLanguage;
    public static string WindowsPhoneEmulators81BrandNoRelease;
    public static string WindowsPhoneEmulators81BrandVersionRelease;
    public static string WindowsPhoneEmulators81GDR1GeneralBrandVersionReleaseLanguage;
    public static string WindowsPhoneEmulators81GDR1BrandNoRelease;
    public static string WebExpressGeneralBrandVersionRelease;
    public static string WebExpressBrandVersionRelease;
    public static string WebExpressGeneralBrandVersionReleaseLanguage;
    public static string WebExpressBrandShortcutName;
    public static string WebExpressLanguagePackGeneralBrandVersionReleaseLanguage;
    public static string WebExpressLanguagePackBrandVersionReleaseLanguage;
    public static string DesktopExpressGeneralBrandVersionRelease;
    public static string DesktopExpressBrandVersionRelease;
    public static string DesktopExpressGeneralBrandVersionReleaseLanguage;
    public static string DesktopExpressBrandShortcutName;
    public static string DesktopExpressLanguagePackGeneralBrandVersionReleaseLanguage;
    public static string DesktopExpressLanguagePackBrandVersionReleaseLanguage;
    public static string FSharpToolsForVWDExpressBrand;
    public static string LightSwitchLanguagePackGeneralBrandVersionReleaseLanguage;
    public static string DevenvLanguagePackGeneralBrandVersionRelease;
    public static string AppInsightsVSBrandVersionRelease;
    public static string AppInsightsVWDExpressBrandVersionRelease;
    public static string AppInsightsVSWinExpressBrandVersionRelease;
    public static string IntelliTraceFrontEndGeneralBrandVersionRelease;
    public static string PerfDebuggerWebViews;
    public static string PerfDebuggerWebViewsLoc;
    public static string IntelliTraceFrontEndLanguagePackGeneralBrandVersionReleaseLanguage;
    public static string IntelliTraceGeneralBrandVersionReleasex86;
    public static string IntelliTraceGeneralBrandVersionReleasex64;
    public static string IntellitraceLanguagePackGeneralBrandVersionRelease;
    public static string IntelliTraceLanguagePackGeneralBrandVersionReleaseLanguagex86;
    public static string IntelliTraceLanguagePackGeneralBrandVersionReleaseLanguagex64;
    public static string DiagnosticToolsGeneralBrandVersionX86;
    public static string DiagnosticToolsGeneralBrandVersionAMD64;
    public static string DiagnosticToolsGeneralBrandVersionARM;
    public static string DiagnosticToolsGeneralBrandVersionARM64;
    public static string DiagnosticToolsResourcesGeneralBrandVersion;
    public static string DynamicanalysisCollectionbitsGeneralBrandVersionRelease;
    public static string DynamicanalysisCollectionbitsLanguagePackGeneralBrandVersionRelease;
    public static string FinalizerGeneralBrandVersionRelease;
    public static string SpToolsLangPackGeneralBrandVersionRelease;
    public static string MinShellLangPackGeneralBrandVersionRelease;
    public static string BuildToolsProductName;
    public static string BuildToolsResProductName;
    public static string VSVmSdkFullBrandName;
    public static string VSVmSdkShortBrandName;
    public static string VisualCppCompilerBrandName;
    public static string VSMBCSMFCBrandName;
    public static string VS2012VerificationSDK;
    public static string UnitTestCppForWinExpress;
    public static string CodedUITestUAPSDK;
    public static string CodedUITest81SDK;
    public static string CppRestSDKBrandName;
    public static string CppRestSDKInstallerBrandName;
    public static string CppAzureMobileSDKBrandName;
    public static string CppAzureMobileSDKInstallerBrandName;
    public static string VSUpdateCore;
    public static string SSProfessionalGeneralBrandVersionRelease;
    public static string SSCommunityGeneralBrandVersionRelease;
    public static string SSVnsExpressGeneralBrandVersionRelease;
    public static string SSDesktopExpressGeneralBrandVersionRelease;
    public static string SSWindowsExpressGeneralBrandVersionRelease;
    public static string VSGraphicsAnalyzerBrandName;
    public static string VSGraphicsAnalyzerBrandNameVersionRelease;
    public static string VstaLanguages;
    public static string VstaLpLanguages;
    public static string TestBundleGeneralBrandVersionRelease;
    public static string TestBundleGeneralBrandVersion;
    public static string VSGeneralBrandMicrosoft;
    public static string VSGeneralBrandName;
    public static string VSGeneralBrandNameShort;
    public static string VSGeneralBrandLanguagePack;
    public static string IsoShellName;
    public static string IntShellName;
    public static string IntShellNameShort;
    public static string ShellsRedistName;
    public static string ProName;
    public static string LSName;
    public static string AgentsName;
    public static string TestControllerName;
    public static string TestElementsName;
    public static string TestProfessionalName;
    public static string FeedbackClientName;
    public static string SkuFlavorExpress;
    public static string VWDGeneralPurpose;
    public static string VWDGeneralPurposeShort;
    public static string VW8GeneralPurpose;
    public static string VW8GeneralPurposeShort;
    public static string BlendBrandNoRelease;
    public static string BlendGeneralBrandNameA;
    public static string BlendGeneralBrandNameM;
    public static string BlendGeneralBrandNameMA;
    public static string BlendGeneralBrandNameShortA;
    public static string BlendVW8ExpressBrandNameVersionReleaseA;
    public static string BlendVW8ExpressBrandNameVersionReleaseMA;
    public static string BlendVW8ExpressBrandNameShortA;
    public static string BlendCommunityBrandNameVersionReleaseA;
    public static string BlendCommunityBrandNameVersionReleaseMA;
    public static string BlendCommunityBrandNameShortA;
    public static string BlendProBrandNameVersionReleaseA;
    public static string BlendProBrandNameVersionReleaseMA;
    public static string BlendProBrandNameShortA;
    public static string BlendTSBrandNameVersionReleaseA;
    public static string BlendTSBrandNameVersionReleaseMA;
    public static string BlendTSBrandNameShortA;
    public static string BlendBrandNameShortcutName;
    public static string VSBlendBrandName;
    public static string VSBlendBrandNameA;
    public static string VSBlendBrandNameM;
    public static string VSBlendBrandNameShortA;
    public static string VSBlendBrandNameVersionA;
    public static string VSBlendBrandNameVersionM;
    public static string VSBlendBrandNameVersionMA;
    public static string VSBlendBrandNameVersionReleaseM;
    public static string VSBlendBrandNameVersionReleaseMLanguage;
    public static string VSBlendBrandNameShortcutName;
    public static string HelpViewerVersion;
    public static string HelpCatalogName;
    public static string HelpEndPointVersion;
    public static string HelpAppID;
    public static string HelpQueryBase;
    public static string HelpSettingFilePath;
    public static string HelpLocProductNameAndLanguage;
    public static string HelpLocProductNameAndDescription;
    public static string WindowsPhoneSDK80BrandNameShort;
    public static string WindowsPhoneSDK80EditionName;
    public static string AddinForWindowsPhone;
    public static string LanguagePack;
    public static string Emulator80Configurator;
    public static string WP80ManagedSdkProfiler;
    public static string PlatformX86;
    public static string PlatformARM;
    public static string SdkToolsFinalizer;
    public static string XDEHost;
    public static string WDGeneralPurpose;
    public static string WDGeneralPurposeShort;
    public static string RemoteDebuggerBrandName;
    public static string RemoteToolsBrandNameVersion;
    public static string RemoteToolsRegistrationBrandNameVersion;
    public static string RemoteToolsBrandNameVersionLangPack;
    public static string RemoteDebuggerDiscoveryFirewallConfig_Name;
    public static string RemoteDebuggerDiscoveryFirewallConfig_Description;
    public static string PerformanceToolsName;
    public static string UpdateName;
    public static string SDKName;
    public static string ClusterToolsName;
    public static string ConcViStandaloneToolsName;
    public static string CodeMetricsPowerToolBrandNameVersion;
    public static string LANGLocName;
    public static string ProfilingTool;
    public static string SLDRT;
    public static string MDDCPlusPlusBreadcrumbResName;
    public static string MDDCSharpBreadcrumbResName;
    public static string MDDJSBreadcrumbResName;
    public static string MDDCPlusPlusCoreName;
    public static string MDDCPlusPlusCoreResName;
    public static string MDDCPlusPlusCoreName_iOS;
    public static string MDDCPlusPlusCoreResName_iOS;
    public static string MDDCSharpCoreName;
    public static string MDDCSharpCoreResName;
    public static string MDDJSCoreName;
    public static string MDDJSCoreResName;
    public static string MDDCPlusPlusBundle_iOS;
    public static string MDDCPlusPlusBundle;
    public static string VCLinuxCoreName;
    public static string VCLinuxBundle;
    public static string SecondaryInstallerName;
    public static string SecondaryInstallerNameRes;
    public static string SecondaryInstallerExePackage;
    public static string BlissGeneralBrandVersionRelease;
    public static string BlissGeneralBrandVersionReleaseLanguage;
    public static string ClientDiagnosticsGeneralBrandVersionRelease;
    public static string ClientDiagnosticsGeneralBrandVersionReleaseLanguage;
    public static string ClientDiagnosticsARGeneralBrandVersionRelease;
    public static string ClientDiagnosticsARGeneralBrandVersionReleaseLanguage;
    public static string ClientDiagnosticsXDGeneralBrandVersionRelease;
    public static string ClientDiagnosticsWindowsXDGeneralBrandVersionRelease;
    public static string ClientDiagnosticsXDGeneralBrandVersionReleaseLanguage;
    public static string ClientDiagnosticsAAGeneralBrandVersionRelease;
    public static string ClientDiagnosticsAAGeneralBrandVersionReleaseLanguage;
    public static string LaunchConditionMessage;
    public static string FilesInUseText;
    public static string DowngradeErrorMessage;
    public static string GeneralBrandRelease;
    public static string GeneralBrandVersion;
    public static string GeneralVersion;
    public static string GeneralVersionShort;
    public static string VSGeneralCopyrightYear;
    public static string VSWindowsSDKVersion;
    public static string VSGeneralBrandMicrosoftNoLoc;
    public static string VSGeneralBrandNameNoLoc;
    public static string VSGeneralBrandVersion;
    public static string VSGeneralVersion;
    public static string VSGeneralUserFilesFolderName;
    public static string VSGeneralBrandNameMNoLoc;
    public static string VSGeneralInstallFolderName;
    public static string WinJSName;
    public static string VSUpdateGeneralBrandRelease;
    public static string IRUpdateGeneralBrandRelease;
    public static string VSUpdateGeneralVersion;
    public static string IRUpdateGeneralVersion;
    public static string VSUpdateBrandNameNoLoc;
    public static string VSUpdateBrandNameVersionRelease;
    public static string VSUpdateExeNameNoLoc;
    public static string IRServerGeneralBrandNameNoLoc;
    public static string IRClientGeneralBrandNameNoLoc;
    public static string IRDeployerGeneralBrandNameNoLoc;
    public static string IRProductFolderName;
    public static string VSGeneralBrandRelease;
    public static string VSGeneralBrandVersionRelease;
    public static string VSGeneralBrandNameM;
    public static string VSGeneralBrandNoRelease;
    public static string VSGeneralBrand;
    public static string VSGeneralBrandNoMNoRelease;
    public static string VSGeneralBrandNoM;
    public static string VSGeneralVersionShort;
    public static string IsoShellBrandName;
    public static string IsoShellBrandNameM;
    public static string IsoShellBrandNameVersion;
    public static string IsoShellBrandNameVersionM;
    public static string IsoShellResBrandNameVersionM;
    public static string IsoShellBrandNameVersionReleaseM;
    public static string IsoShellResourceMsi;
    public static string IntShellBrandName;
    public static string IntShellBrandNameM;
    public static string IntShellBrandNameVersion;
    public static string IntShellBrandNameVersionM;
    public static string IntShellBrandNameVersionReleaseM;
    public static string IntShellBrandNameShort;
    public static string IntShellResourceMsi;
    public static string VSSDKShortName;
    public static string VSSDKLongName;
    public static string VSSDKBrandName;
    public static string VSSDKLangPackBrandName;
    public static string MinShellName;
    public static string MinShellBrandNameVersionM;
    public static string MinShellResBrandNameVersionM;
    public static string MinShellInteropBrandNameVersionM;
    public static string DevenvName;
    public static string DevenvBrandNameVersionM;
    public static string DevenvResBrandNameVersionM;
    public static string ShellsRedistBrandName;
    public static string ShellsRedistBrandNameM;
    public static string ShellsRedistBrandNameVersion;
    public static string ShellsRedistBrandNameVersionM;
    public static string ShellsRedistResBrandNameVersionM;
    public static string ShellsRedistBrandNameVersionReleaseM;
    public static string VSGeneralBrandShortcutName;
    public static string LSBrandName;
    public static string LSBrandNameM;
    public static string LSBrandNameVersionM;
    public static string LSBrandNameVersionReleaseM;
    public static string LSLanguagePackGeneralBrandVersionReleaseLanguage;
    public static string AgentsBrandName;
    public static string AgentsBrandNameM;
    public static string AgentsBrandNameVersion;
    public static string AgentsBrandNameVersionReleaseMsiResource;
    public static string AgentsBrandNameVersionM;
    public static string AgentsBrandNameVersionReleaseM;
    public static string TestControllerBrandName;
    public static string TestControllerBrandNameM;
    public static string TestControllerBrandNameVersion;
    public static string TestControllerBrandNameVersionReleaseMsiResource;
    public static string TestControllerBrandNameVersionM;
    public static string TestControllerBrandNameVersionReleaseM;
    public static string TestElementsBrandName;
    public static string TestElementsBrandNameM;
    public static string TestElementsBrandNameVersion;
    public static string TestElementsBrandNameVersionM;
    public static string TestElementsBrandNameVersionReleaseM;
    public static string TestProfessionalBrandName;
    public static string TestProfessionalBrandNameM;
    public static string TestProfessionalBrandNameVersion;
    public static string TestProfessionalBrandNameVersionReleaseMsiResource;
    public static string TestProfessionalBrandNameVersionM;
    public static string TestProfessionalBrandNameVersionReleaseM;
    public static string FeedbackClientBrandName;
    public static string FeedbackClientBrandNameM;
    public static string FeedbackClientBrandNameVersion;
    public static string FeedbackClientBrandNameVersionReleaseMsiResource;
    public static string FeedbackClientBrandNameVersionM;
    public static string FeedbackClientBrandNameVersionReleaseM;
    public static string VWDGeneralBrandName;
    public static string VWDGeneralBrandNameM;
    public static string VWDGeneralBrandNameVersion;
    public static string VWDExpressBrandNoRelease;
    public static string VWDExpressBrand;
    public static string VWDExpressBrandShort;
    public static string VWDExpressBrandShortcutName;
    public static string VWDExpressResourceMsi;
    public static string VW8GeneralBrandName;
    public static string VW8GeneralBrandNameM;
    public static string VW8GeneralBrandNameVersion;
    public static string VW8ExpressBrandNoRelease;
    public static string VW8ExpressBrand;
    public static string VW8ExpressBrandShort;
    public static string VW8ExpressBrandShortcutName;
    public static string VW8ExpressResourceMsi;
    public static string WDGeneralBrandName;
    public static string WDGeneralBrandNameM;
    public static string WDGeneralBrandNameVersion;
    public static string WDExpressBrandNoRelease;
    public static string WDExpressBrand;
    public static string WDExpressBrandShort;
    public static string WDExpressBrandShortcutName;
    public static string WDExpressResourceMsi;
    public static string WPSDK80ShortBrandName;
    public static string WPSdk80ProductNameBrandNameVersionRelease;
    public static string WPSdk80ProductNameBrandNameVersionReleaseLanguage;
    public static string WP80ManagedSdkProfilerX86;
    public static string WP80ManagedSdkProfilerARM;
    public static string WP80ToolsFinalizer;
    public static string WP80EmulationImagesBrandNameVersionRelease;
    public static string WP80EmulationImagesBrandNameVersionReleaseLanguage;
    public static string WPEmulator80Configurator;
    public static string WPAddinForWindowsPhone;
    public static string WPAddinForWindowsPhoneLanguagePack;
    public static string WPXDEHost;
    public static string MBCSMFCBrandName;
    public static string EditionVisualStudioLanguagePack;
    public static string VisualStudioLanguagePack;
    public static string EditionLanguagePack;
    public static string EditionUpdate;
    public static string EditionWin8Express;
    public static string Win8Express;
    public static string EditionWin8ExpressLangpack;
    public static string Win8ExpressLangpack;
    public static string EditionWinPhoneExpress;
    public static string EditionWinPhoneExpressLangpack;
    public static string WinPhoneExpressLangpack;
    public static string EditionTeamExplorerLangpack;
    public static string EditionTestProfessional;
    public static string EditionTestProfessionalLangpack;
    public static string EditionTestProfessionalLanguagePack;
    public static string TestProfessionalLanguagePack;
    public static string EditionTestController;
    public static string EditionTestControllerLangpack;
    public static string EditionTestControllerLanguagePack;
    public static string TestControllerLanguagePack;
    public static string EditionAgents;
    public static string EditionAgentsLangpack;
    public static string EditionAgentsLanguagePack;
    public static string AgentsLanguagePack;
    public static string EditionFeedbackClient;
    public static string EditionFeedbackClientLangpack;
    public static string EditionFeedbackClientLanguagePack;
    public static string FeedbackClientLanguagePack;
    public static string EditionShellsRedist;
    public static string EditionShellsRedistLangpack;
    public static string EditionSDK;
    public static string EditionSDKLangpack;
    public static string EditionClusterTools;
    public static string EditionClusterToolsLangpack;
    public static string EditionVnsExpress;
    public static string VnsExpress;
    public static string EditionVnsExpressLangpack;
    public static string VnsExpressLangpack;
    public static string EditionDesktopExpress;
    public static string DesktopExpress;
    public static string EditionDesktopExpressLangpack;
    public static string DesktopExpressLangpack;
    public static string EditionIntShell;
    public static string IntShell;
    public static string EditionIntShellLangpack;
    public static string IntShellLangpack;
    public static string EditionIsoShell;
    public static string IsoShell;
    public static string EditionIsoShellLangpack;
    public static string IsoShellLangpack;
    public static string PerformanceToolsBrandNameVersion;
    public static string PerformanceToolsBrandNameVersionLangPack;
    public static string ProfilingToolNameM;
    public static string VBPowerPacksName;
    public static string SilverlightVersion;
    public static string SilverlightDRTBrandName;
    public static string CppRestSDKNameNoLoc;
    public static string CppRestSDKFolderName;
    public static string CppAzureMobileSDKNameNoLoc;
    public static string CppAzureMobileSDKFolderName;
    public static string IRServerGeneralBrandName;
    public static string IRServerGeneralBrandVersion;
    public static string IRServerGeneralBrand;
    public static string IRClientGeneralBrandName;
    public static string IRClientGeneralBrandVersion;
    public static string IRClientGeneralBrand;
    public static string IRDeployerGeneralBrandName;
    public static string IRDeployerGeneralBrandVersion;
    public static string IRDeployerGeneralBrand;
    public static string IRUpdateVersion;
    public static string MDDToolsBrand;
    public static string VSInternalBrand;
    public static string VSGeneralVersionMajor;
    public static string VSGeneralVersionMinor;
    public static string IsoShellNameNoLoc;
    public static string IsoShellBrandNameVersionReleaseNoMNoLoc;
    public static string IsoShellBrandNameVersionReleaseMNoLoc;
    public static string ProBrandNameVersion;
    public static string LSBrandNameVersion;
    public static string VSWindowsSDKVersionMinMaj;
    public static string WinSDK_Reg_Version;
    public static string WinSDK_Version_Major_And_Minor;
    public static string WinSDK_IntellisenseRefAssys_ShortName;
    public static string WinSDK_VSHeadersLibs_ShortName;
    public static string WinSDK_VSTools_ShortName;
    public static string WinSDK_VSWin32Tools_ShortName;
    public static string WinSDK_VSExpressTools_ShortName;
    public static string WinSDK_Reg_ProductName;
    public static string WinSDK_Reg_ComponentName;
    public static string VSRegVer;
    public static string VSProgidVer;
    public static string VSRegHelpTopkenVersion;
    public static string VSRegHelpDataInstallVersion;
    public static string VSRegDexploreInstallLocation;
    public static string VSRegHelpContentVersion;
    public static string HelpVersion;
    public static string VSGeneralAssemblyVersion;
    public static string LSBrandNameVersionRelease;
    public static string BuildGeneralBrandName;
    public static string VSGeneralBrandShort;
    public static string VSGeneralBrandMicrosoftA;
    public static string VSGeneralBrandNameA;
    public static string VSGeneralBrandNameShortA;
    public static string VSGeneralBrandVersionA;
    public static string VSGeneralBrandEditionVersion;
    public static string VSGeneralCopyrightYearA;
    public static string VSGeneralBrandReleaseA;
    public static string VSGeneralBrandVersionReleaseA;
    public static string VSGeneralBrandEditionVersionReleaseA;
    public static string VSGeneralBrandNameMA;
    public static string VSGeneralBrandNoReleaseA;
    public static string VSGeneralBrandNoReleaseMA;
    public static string VSGeneralBrandA;
    public static string VSGeneralBrandMA;
    public static string VSGeneralBrandShortA;
    public static string SkuFlavorShellA;
    public static string SkuFlavorShellIsolatedA;
    public static string VSShellIsolatedEditionNameA;
    public static string VSShellIsolatedBrandNameMA;
    public static string VSShellIsolatedBrandNoReleaseA;
    public static string VSShellIsolatedBrandA;
    public static string SkuFlavorShellIntegratedA;
    public static string VSShellIntegratedEditionNameA;
    public static string VSShellIntegratedBrandNameMA;
    public static string VSShellIntegratedBrandNoReleaseA;
    public static string VSShellIntegratedBrandA;
    public static string VSShellIntegratedBrandShortA;
    public static string ShellsRedistA;
    public static string ShellsRedistBrandNameMA;
    public static string ShellsRedistBrandNoReleaseA;
    public static string ShellsRedistBrandA;
    public static string SkuFlavorExpressA;
    public static string VWDGeneralPurposeA;
    public static string VWDGeneralPurposeShortA;
    public static string VWDEditionNameA;
    public static string VWDGeneralBrandNameA;
    public static string VWDExpressBrandNoReleaseA;
    public static string VWDExpressBrandA;
    public static string VWDExpressBrandShortA;
    public static string VW8GeneralPurposeA;
    public static string VW8GeneralPurposeShortA;
    public static string VW8EditionNameA;
    public static string VW8GeneralBrandNameA;
    public static string VW8ExpressBrandNoReleaseA;
    public static string VW8ExpressBrandA;
    public static string VW8ExpressBrandShortA;
    public static string WDGeneralPurposeA;
    public static string WDGeneralPurposeShortA;
    public static string WDEditionNameA;
    public static string WDGeneralBrandNameA;
    public static string WDExpressBrandNoReleaseA;
    public static string WDExpressBrandA;
    public static string WDExpressBrandShortA;
    public static string VBGeneralBrandNameA;
    public static string VBGeneralBrandNameMA;
    public static string VBGeneralBrandNoReleaseA;
    public static string VBGeneralBrandNoReleaseMA;
    public static string VBGeneralBrandA;
    public static string VBGeneralBrandMA;
    public static string VCGeneralBrandNameA;
    public static string VCGeneralBrandNameMA;
    public static string VCGeneralBrandNoReleaseA;
    public static string VCGeneralBrandNoReleaseMA;
    public static string VCGeneralBrandA;
    public static string VCGeneralBrandMA;
    public static string VCSGeneralBrandNameA;
    public static string VCSGeneralBrandNameMA;
    public static string VCSGeneralBrandNoReleaseA;
    public static string VCSGeneralBrandNoReleaseMA;
    public static string VCSGeneralBrandA;
    public static string VCSGeneralBrandMA;
    public static string VLSGeneralBrandNameA;
    public static string VLSEditionNameA;
    public static string VLSGeneralBrandNoReleaseA;
    public static string VLSGeneralBrandA;
    public static string VLSGeneralBrandMA;
    public static string VLSGeneralBrandShortA;
    public static string VSReleaseDescription;
}
internal class MS.Internal.Automation.AdornerAutomationPeer : UIElementAutomationPeer {
    private UIElement _adorner;
    public AdornerAutomationPeer(UIElement adorner);
    protected virtual string GetAutomationIdCore();
    protected virtual string GetNameCore();
    protected virtual string GetItemTypeCore();
    protected virtual string GetClassNameCore();
    protected virtual bool IsContentElementCore();
    protected virtual bool IsControlElementCore();
    protected virtual Point GetClickablePointCore();
    protected virtual Rect GetBoundingRectangleCore();
}
internal class MS.Internal.Automation.AdornerNodeAutomationPeer : AutomationPeer {
    private List`1<UIElement> _list;
    public AdornerNodeAutomationPeer(List`1<UIElement> list);
    protected virtual string GetAcceleratorKeyCore();
    protected virtual string GetAccessKeyCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetAutomationIdCore();
    protected virtual Rect GetBoundingRectangleCore();
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    private static void AddAdornerAutomationPeer(List`1<AutomationPeer> list, UIElement adorner);
    protected virtual string GetClassNameCore();
    protected virtual Point GetClickablePointCore();
    protected virtual string GetHelpTextCore();
    protected virtual string GetItemStatusCore();
    protected virtual string GetItemTypeCore();
    protected virtual AutomationPeer GetLabeledByCore();
    protected virtual string GetNameCore();
    protected virtual AutomationOrientation GetOrientationCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual bool HasKeyboardFocusCore();
    protected virtual bool IsContentElementCore();
    protected virtual bool IsControlElementCore();
    protected virtual bool IsEnabledCore();
    protected virtual bool IsKeyboardFocusableCore();
    protected virtual bool IsOffscreenCore();
    protected virtual bool IsPasswordCore();
    protected virtual bool IsRequiredForFormCore();
    protected virtual void SetFocusCore();
}
internal class MS.Internal.Automation.DesignerItemAutomationPeer : AutomationPeer {
    private ModelItem _item;
    private DesignerView _view;
    private ModelService _modelService;
    private Hashtable _dataChildren;
    private DesignerViewAutomationPeer _viewPeer;
    private bool _disposed;
    private static int MAX_CLICK_POINTS_TESTS;
    private static string _xmlns;
    private static TypeIdentifier Type;
    private static PropertyIdentifier AutomationIdProperty;
    private static PropertyIdentifier HelpTextProperty;
    private static PropertyIdentifier NameProperty;
    private ModelService ModelService { get; }
    private ViewItem ViewItem { get; }
    public bool IsSelected { get; }
    public IRawElementProviderSimple SelectionContainer { get; }
    private bool IsDisposed { get; }
    public DesignerItemAutomationPeer(ModelItem item, DesignerViewAutomationPeer peer);
    private static DesignerItemAutomationPeer();
    private ModelService get_ModelService();
    private ViewItem get_ViewItem();
    private string GetModelProperty(PropertyIdentifier property);
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    [IteratorStateMachineAttribute("MS.Internal.Automation.DesignerItemAutomationPeer/<GetChildren>d__19")]
private IEnumerable`1<ModelItem> GetChildren(ModelItem parent);
    private void PopulateDataChildren(List`1<AutomationPeer> list);
    public IRawElementProviderSimple GetProviderFromPeer(AutomationPeer peer);
    public List`1<IRawElementProviderSimple> GetSelection(object selectedObj);
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetLocalizedControlTypeCore();
    protected virtual string GetAutomationIdCore();
    protected virtual Rect GetBoundingRectangleCore();
    protected virtual string GetClassNameCore();
    protected virtual string GetAcceleratorKeyCore();
    protected virtual string GetAccessKeyCore();
    protected virtual Point GetClickablePointCore();
    protected virtual string GetHelpTextCore();
    protected virtual string GetItemStatusCore();
    protected virtual string GetItemTypeCore();
    protected virtual AutomationPeer GetLabeledByCore();
    protected virtual AutomationOrientation GetOrientationCore();
    protected virtual bool HasKeyboardFocusCore();
    protected virtual bool IsEnabledCore();
    protected virtual bool IsKeyboardFocusableCore();
    protected virtual bool IsOffscreenCore();
    protected virtual bool IsPasswordCore();
    protected virtual bool IsRequiredForFormCore();
    protected virtual void SetFocusCore();
    protected virtual string GetNameCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual bool IsContentElementCore();
    protected virtual bool IsControlElementCore();
    private static bool IsPartOfTemplate(ViewItem parent, ViewItem childToCheck);
    public List`1<DesignerItemAutomationPeer> GetSelectedAutomationPeers(object selectedObj);
    public sealed virtual void AddToSelection();
    public sealed virtual bool get_IsSelected();
    public sealed virtual void RemoveFromSelection();
    public sealed virtual void Select();
    public sealed virtual IRawElementProviderSimple get_SelectionContainer();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private bool get_IsDisposed();
}
internal class MS.Internal.Automation.DesignerViewAutomationPeer : UIElementAutomationPeer {
    private DesignerView _owner;
    private ModelService _modelService;
    private Hashtable _dataChildren;
    private List`1<DesignerItemAutomationPeer> _oldSelectionList;
    private bool _fromContext;
    private ModelItem _scope;
    private bool _disposed;
    private EditingContext _context;
    private int _suspensionCount;
    public DesignerView View { get; }
    public EditingContext Context { get; public set; }
    private ModelService ModelService { get; }
    private bool IsSuspended { get; }
    public bool CanSelectMultiple { get; }
    public bool IsSelectionRequired { get; }
    public DesignerViewAutomationPeer(DesignerView view);
    private void OnModelChanged(object sender, ModelChangedEventArgs e);
    public DesignerView get_View();
    public EditingContext get_Context();
    public void set_Context(EditingContext value);
    private ModelService get_ModelService();
    private bool get_IsSuspended();
    private void OnContextDisposing(object sender, EventArgs e);
    internal IDisposable Suspend();
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    protected virtual string GetAutomationIdCore();
    protected virtual string GetNameCore();
    protected virtual string GetHelpTextCore();
    protected virtual string GetItemTypeCore();
    protected virtual string GetClassNameCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual bool IsEnabledCore();
    private void OnSelectionChanged(Selection newSelection);
    private static DependencyObject GetVisualAncestor(DependencyObject descendant, int depth);
    public sealed virtual bool get_CanSelectMultiple();
    private void PopulateDataChildren();
    public IRawElementProviderSimple GetProviderFromPeer(AutomationPeer peer);
    public sealed virtual IRawElementProviderSimple[] GetSelection();
    public sealed virtual bool get_IsSelectionRequired();
    private List`1<DesignerItemAutomationPeer> GetSelectedAutomationPeers(Selection newSel);
    public sealed virtual void Dispose();
    private void SuspendInternal();
    private void Resume();
}
internal static class MS.Internal.AutomationPeerCache : object {
    private static DependencyObject _objThatIsBinding;
    public static DependencyProperty AutomationPeerProperty;
    public static DependencyProperty IsAutomationFocusedProperty;
    private static AutomationPeerCache();
    public static AutomationPeer GetAutomationPeer(DependencyObject obj);
    public static void SetAutomationPeer(DependencyObject obj, AutomationPeer value);
    public static void RegisterFocusEvents(DependencyObject obj);
    public static void RegisterFocusEvents(DependencyObject obj, AutomationPeer associatedPeer);
    public static void RegisterFocusEvents(DependencyObject obj, string propertyName);
    public static bool GetIsAutomationFocused(DependencyObject obj);
    public static void SetIsAutomationFocused(DependencyObject obj, bool value);
    private static void OnIsAutomationFocusedChanged(DependencyObject dobj, DependencyPropertyChangedEventArgs e);
    public static T Create(UIElement element, Object[] args);
}
internal static class MS.Internal.DesignerUtilities : object {
    private static int _designerRoundingPrecision;
    private static int DOUBLEPRECISION;
    internal static int ROUNDINGPRECISION;
    private static DateTime _toolboxTextDropTimeStamp;
    private static int s_dpi;
    internal static DateTime ToolboxTextDropTimeStamp { get; internal set; }
    internal static int DesignerRoundingPrecision { get; internal set; }
    public static int CapsDpi { get; }
    private static DesignerUtilities();
    internal static DateTime get_ToolboxTextDropTimeStamp();
    internal static void set_ToolboxTextDropTimeStamp(DateTime value);
    internal static void SetUseLayoutRounding(ModelItem selectedItem);
    private static bool UseRounding(ModelItem selectedItem, Dictionary`2<ModelItem, bool> cache);
    internal static void SetUseLayoutRounding(IEnumerable`1<ModelItem> selectedItems);
    internal static int get_DesignerRoundingPrecision();
    internal static void set_DesignerRoundingPrecision(int value);
    internal static double GetInvertZoom(EditingContext context);
    internal static double GetInvertZoom(DesignerView dview);
    internal static Vector GetZoomFactor(EditingContext context);
    internal static Vector GetInvertZoomFactor(DesignerView dview);
    internal static Vector GetZoomRounding(EditingContext context);
    internal static double Round(double dimension);
    internal static Vector GetZoomRounding(DesignerView dview);
    public static int get_CapsDpi();
    public static Popup FindPopupRoot(DependencyObject element);
}
internal static class MS.Internal.ElementUtilities : object {
    public static IEnumerable GetElementTree(FrameworkElement rootElement);
    public static IEnumerable GetVisualTree(Visual rootVisual);
    public static FrameworkElement FindElement(FrameworkElement element, string id);
    public static FrameworkElement FindElementInVisualTree(Visual root, string id);
    public static bool HasAncestorOfType(FrameworkElement rootElement, FrameworkElement element, Type type);
    internal static FrameworkElement GetAncestorOfType(FrameworkElement rootElement, FrameworkElement element, Type type);
    public static bool IsDescendant(DependencyObject parent, DependencyObject descendant);
    public static bool IsDescendant(ViewItem parent, ViewItem descendant);
    public static DependencyObject GetLeastCommonAncestor(DependencyObject firstDescendant, DependencyObject secondDescendant, DependencyObject root);
    public static Rect GetTransformedBounds(Visual visual, Visual ancestor);
    public static Rect GetLayoutRect(DependencyObject element);
    public static Rect GetElementRelativeSelectionFrameBounds(DependencyObject element);
    public static Rect GetActualBounds(FrameworkElement element);
    private static Rect GetActualBoundsInParent(FrameworkElement element);
    private static Rect GetActualBoundsCore(FrameworkElement element, bool inParent);
    public static Rect GetRenderSizeBounds(DependencyObject element);
    public static Rect GetRenderSizeBounds(ViewItem view);
    public static Rect GetSelectionFrameBounds(DependencyObject element);
    public static Rect GetSelectionFrameBounds(ViewItem view);
    public static Vector ComputePositionDeltaInTarget(DesignerView dview, ViewItem target, Point startPosition, Point currentPosition);
}
internal class MS.Internal.EqualityArray : object {
    private Object[] _values;
    internal EqualityArray(Object[] values);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
internal class MS.Internal.ExtensibleIconLookup : object {
    private string fullName;
    private int requestedWidth;
    private int requestedHeight;
    private Nullable`1<int> bestDistance;
    private int priority;
    private string resourceName;
    private Stream stream;
    private static string VisualStudio;
    public string ResourceName { get; }
    public Stream Stream { get; }
    public ExtensibleIconLookup(Type type, int requestedWidth, int requestedHeight);
    public string get_ResourceName();
    public Stream get_Stream();
    [IteratorStateMachineAttribute("MS.Internal.ExtensibleIconLookup/<GetDesignAssemblies>d__13")]
private static IEnumerable`1<Assembly> GetDesignAssemblies(Assembly original);
    private void ScanAssembly(Assembly assembly);
}
internal static class MS.Internal.ExternDll : object {
    internal static string Advapi32;
    internal static string Gdi32;
    internal static string Kernel32;
    internal static string Mscoree;
    internal static string Ntdll;
    internal static string User32;
}
internal class MS.Internal.Features.AdapterFeatureConnector : FeatureConnector`1<Adapter> {
    public AdapterFeatureConnector(FeatureManager manager);
    [CompilerGeneratedAttribute]
private AdapterService <.ctor>b__0_0();
}
[RequiresContextItemAttribute("Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.CurrentDesignerView")]
[RequiresServiceAttribute("Microsoft.VisualStudio.DesignTools.Extensibility.Services.ViewService")]
internal class MS.Internal.Features.AdornerProviderFeatureConnector : PolicyDrivenToolFeatureConnector`1<AdornerProvider> {
    private ICollection`1<UIElement> adorners;
    private static DependencyProperty OwningProviderProperty;
    private ICollection`1<UIElement> Adorners { get; }
    public AdornerProviderFeatureConnector(FeatureManager manager);
    private static AdornerProviderFeatureConnector();
    private ICollection`1<UIElement> get_Adorners();
    protected virtual bool IsValidProvider(FeatureProvider featureProvider);
    protected virtual void FeatureProvidersAdded(ModelItem item, IEnumerable`1<AdornerProvider> extensions);
    protected virtual void FeatureProvidersRemoved(ModelItem item, IEnumerable`1<AdornerProvider> extensions);
    private static bool IsItemDesignable(ModelItem item);
}
internal class MS.Internal.Features.ContextMenuFeatureConnector : PolicyDrivenFeatureConnector`1<ContextMenuProvider> {
    public ContextMenuFeatureConnector(FeatureManager manager);
    public IEnumerable`1<MenuBase> GetItems();
    [IteratorStateMachineAttribute("MS.Internal.Features.ContextMenuFeatureConnector/<EnumerateRootMenuItems>d__2")]
private IEnumerable`1<MenuBase> EnumerateRootMenuItems();
    protected virtual void FeatureProvidersAdded(ModelItem item, IEnumerable`1<ContextMenuProvider> featureProviders);
    protected virtual void FeatureProvidersRemoved(ModelItem item, IEnumerable`1<ContextMenuProvider> featureProviders);
}
internal class MS.Internal.Features.DesignModeValueProviderConnector : FeatureConnector`1<DesignModeValueProvider> {
    private ValueTranslationServiceImpl _service;
    public DesignModeValueProviderConnector(FeatureManager manager);
    private void TypeDescriptor_Refreshed(RefreshEventArgs e);
    protected virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
private ValueTranslationService <.ctor>b__1_0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__1_1(AssemblyReferences newReferences);
}
internal class MS.Internal.Features.ItemPolicyConnector : object {
    private FeatureManager _manager;
    private Dictionary`2<Type, PolicyData> _policies;
    private HashSet`1<Type> _seenFeatureProviderTypes;
    private EventHandler`1<PolicyAddedEventArgs> _policyAdded;
    public ItemPolicyConnector(FeatureManager manager);
    private void AttemptActivatePolicy(ItemPolicy policy);
    private void ActivatePolicy(PolicyData policyData);
    private void Dispose(bool disposing);
    public void OnExtensionAvailable(Type featureProviderType);
    private void OnFeatureAvailable(object sender, FeatureAvailableEventArgs e);
    private void OnPolicyRequirementsChanged(object sender, EventArgs e);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private ItemPolicyService <.ctor>b__4_0();
}
internal class MS.Internal.Features.ParentAdapterFeatureConnector : FeatureConnector`1<ParentAdapter> {
    public ParentAdapterFeatureConnector(FeatureManager manager);
}
internal abstract class MS.Internal.Features.PolicyDrivenToolFeatureConnector`1 : PolicyDrivenFeatureConnector`1<FeatureProviderType> {
    private Tool _currentTool;
    protected Tool CurrentTool { get; }
    protected PolicyDrivenToolFeatureConnector`1(FeatureManager manager);
    protected Tool get_CurrentTool();
    protected virtual void UpdateCurrentTool(Tool newTool);
    [CompilerGeneratedAttribute]
private void <.ctor>b__3_0(Tool newTool);
}
[RequiresContextItemAttribute("Microsoft.VisualStudio.DesignTools.Extensibility.Interaction.Tool")]
internal class MS.Internal.Features.TaskProviderFeatureConnector : PolicyDrivenToolFeatureConnector`1<TaskProvider> {
    private List`1<Task> _currentTasks;
    public TaskProviderFeatureConnector(FeatureManager manager);
    protected virtual bool IsValidProvider(FeatureProvider featureProvider);
    protected virtual void FeatureProvidersAdded(ModelItem item, IEnumerable`1<TaskProvider> extensions);
    protected virtual void FeatureProvidersRemoved(ModelItem item, IEnumerable`1<TaskProvider> extensions);
    protected virtual void UpdateCurrentTool(Tool newTool);
}
internal class MS.Internal.FloatingPointArithmetic : object {
    private static double doubleTolerance;
    private static double singleTolerance;
    private static double distanceTolerance;
    private static double squaredDistanceTolerance;
    public static double DoubleTolerance { get; }
    public static double SingleTolerance { get; }
    public static double DistanceTolerance { get; }
    public static double SquaredDistanceTolerance { get; }
    private static FloatingPointArithmetic();
    public static double get_DoubleTolerance();
    public static double get_SingleTolerance();
    public static double get_DistanceTolerance();
    public static double get_SquaredDistanceTolerance();
    public static bool IsVerySmall(double k);
    public static bool IsVerySmall(float k);
    public static bool IsInClosedInterval(double x, double a, double b);
    public static float ToSingle(double d);
    public static double Hypotenuse(double x, double y);
    public static double DoubleFromMantissaAndExponent(double x, int exp);
    public static bool IsFiniteDouble(double x);
}
internal static class MS.Internal.HitTestHelper : object {
    internal static ViewHitTestResult HitTest(ViewItem reference, Point point, ViewHitTestFilterCallback filterCallback);
    internal static HitTestResult HitTest(Visual reference, Point point, bool ignoreDisabled, HitTestFilterCallback filterCallback);
    public static HitTestResult HitTest(Visual reference, HitTestParameters hitTestParameters, bool ignoreDisabled, HitTestFilterCallback filterCallback);
}
internal class MS.Internal.Interaction.AdornerColorResourceDictionary : ResourceDictionary {
    private bool _contentLoaded;
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("PresentationBuildTasks", "4.0.0.0")]
public sealed virtual void InitializeComponent();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("PresentationBuildTasks", "4.0.0.0")]
[EditorBrowsableAttribute("1")]
private sealed virtual override void System.Windows.Markup.IComponentConnector.Connect(int connectionId, object target);
}
internal class MS.Internal.Interaction.AdornerFontResourceDictionary : ResourceDictionary {
    private bool _contentLoaded;
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("PresentationBuildTasks", "4.0.0.0")]
public sealed virtual void InitializeComponent();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("PresentationBuildTasks", "4.0.0.0")]
[EditorBrowsableAttribute("1")]
private sealed virtual override void System.Windows.Markup.IComponentConnector.Connect(int connectionId, object target);
}
internal class MS.Internal.Interaction.AdornerLayer : Panel {
    private AdornerCollection _adornerCollectionWrapper;
    private ViewService _viewService;
    private EditingContext _context;
    private DesignerView _currentDesignerView;
    private List`1<UIElement> _evaluateLayoutList;
    private bool _needEvaluateLayout;
    private bool _hasRendered;
    private Visibility _savedVisibility;
    private ProcessZoomCallback _processZoomCallback;
    private static Type TransformType;
    internal ICollection`1<UIElement> Adorners { get; }
    public DesignerView CurrentDesignerView { get; public set; }
    internal AdornerLayer(DesignerView designerView);
    private static AdornerLayer();
    internal ICollection`1<UIElement> get_Adorners();
    private void Add(UIElement adorner);
    public DesignerView get_CurrentDesignerView();
    public void set_CurrentDesignerView(DesignerView value);
    private void EvaluateLayout();
    private void InsertAdornerIntoVisualTree(UIElement adorner);
    internal void OnOrderChanged(UIElement adorner);
    internal void OnLayoutChanged(UIElement adorner);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    protected virtual void OnRender(DrawingContext dc);
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    private void Clear();
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual void OnRenderSizeChanged(SizeChangedInfo sizeInfo);
    private void OnLayoutUpdated(object sender, EventArgs args);
    private void OnViewServiceAvailable(ViewService vs);
    private void OnZoomLevelChanged(object sender, EventArgs e);
    private void ProcessZoom();
    private bool Remove(UIElement adorner);
    internal void SetContext(EditingContext context);
}
[TypeConverterAttribute("MS.Internal.Interaction.AdornerResourceKey/AdornerResourceKeyConverter")]
internal class MS.Internal.Interaction.AdornerResourceKey : ResourceKey {
    private Type _type;
    private string _member;
    public Assembly Assembly { get; }
    private AdornerResourceKey(SerializationInfo info, StreamingContext cxt);
    internal AdornerResourceKey(Type type, string member);
    public virtual Assembly get_Assembly();
    public virtual string ToString();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
internal abstract class MS.Internal.Interaction.BaseAdornerLayout : AdornerLayout {
    private static DependencyProperty CachedVisibilityProperty;
    private static DependencyProperty OriginalVisibilityProperty;
    private static string RenderTransformProperty;
    protected static DependencyProperty CacheProperty;
    private static BaseAdornerLayout();
    public virtual void AdornerPropertyChanged(DependencyObject adorner, DependencyPropertyChangedEventArgs args);
    public virtual bool EvaluateLayout(DesignerView view, UIElement adorner);
    private static void CheckAndInvalidateAdorner(DesignerView view, ViewItem element, UIElement adorner);
    protected static LayoutCache GetCache(DependencyObject element);
    private static bool IsAdornableElement(DesignerView view, ViewItem element);
    public virtual void Measure(UIElement adorner, Size constraint);
    public virtual bool IsAssociated(UIElement adorner, ModelItem item);
    private static void EnsureActualValues(DependencyObject adorner);
    private static void OnModelItemPropertyChanged(object sender, PropertyChangedEventArgs e);
    internal static double ValidateDouble(double requested, double fallback);
}
internal class MS.Internal.Interaction.ContainerHitTestProvider : HitTestProvider {
    public virtual PointHitTestResult HitTestPoint(VisualHitTestArgs args);
    public virtual GeometryHitTestResult HitTestGeometry(VisualHitTestArgs args);
}
internal class MS.Internal.Interaction.HitTestProvider : object {
    public virtual PointHitTestResult HitTestPoint(VisualHitTestArgs args);
    public virtual GeometryHitTestResult HitTestGeometry(VisualHitTestArgs args);
}
internal class MS.Internal.Interaction.ItemParentImplementationService : object {
    [CompilerGeneratedAttribute]
private FeatureManager <FeatureManager>k__BackingField;
    private FeatureManager FeatureManager { get; public set; }
    public static ItemParentImplementationService GetImplementation(EditingContext context);
    [CompilerGeneratedAttribute]
public void set_FeatureManager(FeatureManager value);
    [CompilerGeneratedAttribute]
private FeatureManager get_FeatureManager();
    public bool CanParent(ModelItem parent, TypeIdentifier childType, ModelItem childItem, ModelItem& redirectedParent);
    internal ModelItem FindParent(TypeIdentifier childType, ModelItem startingItem, ModelItem childItem);
    public void Parent(ModelItem parent, ModelItem child, int index);
    private static ViewItem GetLogicalParent(ModelItem item);
}
internal static class MS.Internal.Interaction.ModelHitTestHelper : object {
    [ThreadStaticAttribute]
private static Dictionary`2<Type, HitTestProvider> _hitTestProviders;
    private static Dictionary`2<Type, HitTestProvider> HitTestProviders { get; }
    public static HitTestProvider GetSingletonProvider(DependencyObject d);
    private static Dictionary`2<Type, HitTestProvider> get_HitTestProviders();
    public static HitTestResult HitTest(Visual reference, Point point, HitTestFilterCallback filterCallback);
    public static ViewHitTestResult HitTest(ViewItem reference, Point point, ViewHitTestFilterCallback filterCallback, ViewHitTestFilterCallback modelCallback);
    public static HitTestResult HitTest(Visual root, HitTestFilterCallback filterCallback, HitTestResultCallback resultCallback, HitTestParameters hitTestParameters, HitTestFilterCallback modelCallback);
    [IteratorStateMachineAttribute("MS.Internal.Interaction.ModelHitTestHelper/<GetDescendantsInZOrder>d__9")]
private static IEnumerable`1<DependencyObject> GetDescendantsInZOrder(DependencyObject root);
}
internal class MS.Internal.Interaction.PositionRelativeToAdornerHeight : object {
    private DependencyObject _relativeTo;
    private double _factor;
    private double _offset;
    internal PositionRelativeToAdornerHeight(double factor, double offset, DependencyObject relativeTo);
    [IteratorStateMachineAttribute("MS.Internal.Interaction.PositionRelativeToAdornerHeight/<GetSizeTerms>d__4")]
public sealed virtual IEnumerable`1<AdornerPlacementValue> GetSizeTerms(AdornerCoordinateSpace space, UIElement adorner, ViewItem adornedElement, Vector zoom, Size adornedElementFinalSize);
    [IteratorStateMachineAttribute("MS.Internal.Interaction.PositionRelativeToAdornerHeight/<GetPositionTerms>d__5")]
public sealed virtual IEnumerable`1<AdornerPlacementValue> GetPositionTerms(AdornerCoordinateSpace space, UIElement adorner, ViewItem adornedElement, Vector zoom, Size computedAdornerSize);
    public virtual string ToString();
}
internal class MS.Internal.Interaction.PositionRelativeToAdornerWidth : object {
    private DependencyObject _relativeTo;
    private double _factor;
    private double _offset;
    internal PositionRelativeToAdornerWidth(double factor, double offset, DependencyObject relativeTo);
    [IteratorStateMachineAttribute("MS.Internal.Interaction.PositionRelativeToAdornerWidth/<GetSizeTerms>d__4")]
public sealed virtual IEnumerable`1<AdornerPlacementValue> GetSizeTerms(AdornerCoordinateSpace space, UIElement adorner, ViewItem adornedElement, Vector zoom, Size adornedElementFinalSize);
    [IteratorStateMachineAttribute("MS.Internal.Interaction.PositionRelativeToAdornerWidth/<GetPositionTerms>d__5")]
public sealed virtual IEnumerable`1<AdornerPlacementValue> GetPositionTerms(AdornerCoordinateSpace space, UIElement adorner, ViewItem adornedElement, Vector zoom, Size computedAdornerSize);
    public virtual string ToString();
}
internal class MS.Internal.Interaction.PositionRelativeToContentHeight : object {
    private ViewItem _relativeTo;
    private double _factor;
    private double _offset;
    internal PositionRelativeToContentHeight(double factor, double offset, ViewItem relativeTo);
    [IteratorStateMachineAttribute("MS.Internal.Interaction.PositionRelativeToContentHeight/<GetSizeTerms>d__4")]
public sealed virtual IEnumerable`1<AdornerPlacementValue> GetSizeTerms(AdornerCoordinateSpace space, UIElement adorner, ViewItem adornedElement, Vector zoom, Size adornedElementFinalSize);
    [IteratorStateMachineAttribute("MS.Internal.Interaction.PositionRelativeToContentHeight/<GetPositionTerms>d__5")]
public sealed virtual IEnumerable`1<AdornerPlacementValue> GetPositionTerms(AdornerCoordinateSpace space, UIElement adorner, ViewItem adornedElement, Vector zoom, Size computedAdornerSize);
    public virtual string ToString();
}
internal class MS.Internal.Interaction.PositionRelativeToContentWidth : object {
    private ViewItem _relativeTo;
    private double _factor;
    private double _offset;
    internal PositionRelativeToContentWidth(double factor, double offset, ViewItem relativeTo);
    [IteratorStateMachineAttribute("MS.Internal.Interaction.PositionRelativeToContentWidth/<GetSizeTerms>d__4")]
public sealed virtual IEnumerable`1<AdornerPlacementValue> GetSizeTerms(AdornerCoordinateSpace space, UIElement adorner, ViewItem adornedElement, Vector zoom, Size adornedElementFinalSize);
    [IteratorStateMachineAttribute("MS.Internal.Interaction.PositionRelativeToContentWidth/<GetPositionTerms>d__5")]
public sealed virtual IEnumerable`1<AdornerPlacementValue> GetPositionTerms(AdornerCoordinateSpace space, UIElement adorner, ViewItem adornedElement, Vector zoom, Size computedAdornerSize);
    public virtual string ToString();
}
internal static class MS.Internal.Interaction.ScaledSpace : object {
    internal static Vector GetTargetSizeScale(UIElement adorner, Vector scaleFactor);
    internal static Vector GetTargetPositionScale(UIElement adorner);
    internal static Vector GetAdornerSizeScale(UIElement adorner);
    internal static Vector GetAdornerPositionScale(UIElement adorner, Vector scaleFactor);
}
internal class MS.Internal.Interaction.SizeRelativeToAdornerDesiredHeight : object {
    private DependencyObject _relativeTo;
    private double _factor;
    private double _offset;
    internal SizeRelativeToAdornerDesiredHeight(double factor, double offset, DependencyObject relativeTo);
    [IteratorStateMachineAttribute("MS.Internal.Interaction.SizeRelativeToAdornerDesiredHeight/<GetSizeTerms>d__4")]
public sealed virtual IEnumerable`1<AdornerPlacementValue> GetSizeTerms(AdornerCoordinateSpace space, UIElement adorner, ViewItem adornedElement, Vector zoom, Size adornedElementFinalSize);
    [IteratorStateMachineAttribute("MS.Internal.Interaction.SizeRelativeToAdornerDesiredHeight/<GetPositionTerms>d__5")]
public sealed virtual IEnumerable`1<AdornerPlacementValue> GetPositionTerms(AdornerCoordinateSpace space, UIElement adorner, ViewItem adornedElement, Vector zoom, Size computedAdornerSize);
    public virtual string ToString();
}
internal class MS.Internal.Interaction.SizeRelativeToAdornerDesiredWidth : object {
    private DependencyObject _relativeTo;
    private double _factor;
    private double _offset;
    internal SizeRelativeToAdornerDesiredWidth(double factor, double offset, DependencyObject relativeTo);
    [IteratorStateMachineAttribute("MS.Internal.Interaction.SizeRelativeToAdornerDesiredWidth/<GetSizeTerms>d__4")]
public sealed virtual IEnumerable`1<AdornerPlacementValue> GetSizeTerms(AdornerCoordinateSpace space, UIElement adorner, ViewItem adornedElement, Vector zoom, Size adornedElementFinalSize);
    [IteratorStateMachineAttribute("MS.Internal.Interaction.SizeRelativeToAdornerDesiredWidth/<GetPositionTerms>d__5")]
public sealed virtual IEnumerable`1<AdornerPlacementValue> GetPositionTerms(AdornerCoordinateSpace space, UIElement adorner, ViewItem adornedElement, Vector zoom, Size computedAdornerSize);
    public virtual string ToString();
}
internal class MS.Internal.Interaction.SizeRelativeToContentHeight : object {
    private ViewItem _relativeTo;
    private double _factor;
    private double _offset;
    internal SizeRelativeToContentHeight(double factor, double offset, ViewItem relativeTo);
    [IteratorStateMachineAttribute("MS.Internal.Interaction.SizeRelativeToContentHeight/<GetSizeTerms>d__4")]
public sealed virtual IEnumerable`1<AdornerPlacementValue> GetSizeTerms(AdornerCoordinateSpace space, UIElement adorner, ViewItem adornedElement, Vector zoom, Size adornedElementFinalSize);
    [IteratorStateMachineAttribute("MS.Internal.Interaction.SizeRelativeToContentHeight/<GetPositionTerms>d__5")]
public sealed virtual IEnumerable`1<AdornerPlacementValue> GetPositionTerms(AdornerCoordinateSpace space, UIElement adorner, ViewItem adornedElement, Vector zoom, Size computedAdornerSize);
    public virtual string ToString();
}
internal class MS.Internal.Interaction.SizeRelativeToContentWidth : object {
    private ViewItem _relativeTo;
    private double _factor;
    private double _offset;
    internal SizeRelativeToContentWidth(double factor, double offset, ViewItem relativeTo);
    [IteratorStateMachineAttribute("MS.Internal.Interaction.SizeRelativeToContentWidth/<GetSizeTerms>d__4")]
public sealed virtual IEnumerable`1<AdornerPlacementValue> GetSizeTerms(AdornerCoordinateSpace space, UIElement adorner, ViewItem adornedElement, Vector zoom, Size adornedElementFinalSize);
    [IteratorStateMachineAttribute("MS.Internal.Interaction.SizeRelativeToContentWidth/<GetPositionTerms>d__5")]
public sealed virtual IEnumerable`1<AdornerPlacementValue> GetPositionTerms(AdornerCoordinateSpace space, UIElement adorner, ViewItem adornedElement, Vector zoom, Size computedAdornerSize);
    public virtual string ToString();
}
internal class MS.Internal.Interaction.TransformAwareAdornerLayout : BaseAdornerLayout {
    internal static TransformAwareAdornerLayout Instance;
    internal static DependencyProperty DesignerElementScalingFactorWithZoom;
    private static TransformAwareAdornerLayout();
    internal static object MakeZoomPositive(DependencyObject d, object baseValue);
    private void SetupTransform(UIElement adorner);
    public virtual void Arrange(UIElement adorner);
    public virtual Size ArrangeChildren(FrameworkElement parent, UIElementCollection internalChildren, Size finalSize);
    public virtual bool EvaluateLayout(DesignerView view, UIElement adorner);
    private void SetAdornerBounds(UIElement childAdorner, ViewItem adornedElement, Point location, Vector scale);
}
internal class MS.Internal.Interaction.VisualHitTestArgs : object {
    private Visual _sourceAncestor;
    private Visual _child;
    private HitTestParameters _hitTestParameters;
    private Nullable`1<Point> _childPoint;
    public Visual ChildVisual { get; }
    public Visual SourceAncestor { get; }
    public Point ChildPoint { get; }
    public HitTestParameters HitTestParameters { get; }
    public Rect ChildLayoutBounds { get; }
    public Geometry SourceHitGeometry { get; }
    public VisualHitTestArgs(Visual sourceAncestor, Visual child, Point parentPoint);
    public VisualHitTestArgs(Visual sourceAncestor, Visual child, HitTestParameters parameters);
    public Visual get_ChildVisual();
    public Visual get_SourceAncestor();
    public Point get_ChildPoint();
    public HitTestParameters get_HitTestParameters();
    public Rect get_ChildLayoutBounds();
    public Geometry get_SourceHitGeometry();
    internal void UpdateChild(DependencyObject child);
}
internal class MS.Internal.KeyboardHelper : object {
    internal static ModifierKeys Modifiers { get; }
    internal static ModifierKeys get_Modifiers();
}
internal static class MS.Internal.MathUtilities : object {
    private static double DBL_EPSILON;
    private static MathUtilities();
    internal static bool AreClose(Size s1, Size s2);
    internal static bool AreClose(Vector s1, Vector s2);
    internal static bool AreClose(double value1, double value2);
    internal static bool AreClose(Point value1, Point value2);
    internal static bool AreClose(Rect value1, Rect value2);
    internal static bool AreClose(Matrix m1, Matrix m2);
    internal static double Round(double value, double rounding);
    internal static double Round(double value);
}
internal static class MS.Internal.MenuUtilities : object {
    public static int CompareProviders(T provider1, T provider2);
    public static int CompareContextMenuProviders(ContextMenuProvider provider1, ContextMenuProvider provider2);
    [IteratorStateMachineAttribute("MS.Internal.MenuUtilities/<ExpandMenuGroups>d__4")]
public static IEnumerable`1<MenuBase> ExpandMenuGroups(IEnumerable`1<MenuBase> items, MenuBaseExpander groupExpander);
    public static IEnumerable`1<MenuBase> MergeMenuGroups(MenuBaseEnumerator rootItemEnumerator);
    private static MenuGroup MergeGroups(MenuGroup existingGroup, MenuGroup groupToMergeIn);
}
internal static class MS.Internal.NativeMethods : object {
    internal static int SM_CXDOUBLECLK;
    internal static int SM_CYDOUBLECLK;
    internal static int SPI_GETMOUSEHOVERWIDTH;
    internal static int SPI_GETMOUSEHOVERHEIGHT;
    internal static int SPI_GETMOUSEHOVERTIME;
    internal static int GWL_STYLE;
    internal static int GWL_EXSTYLE;
    internal static int WS_EX_LAYOUTRTL;
}
internal class MS.Internal.ObservableCollectionAggregate`1 : object {
    private List`1<ICollection`1<T>> _collections;
    [CompilerGeneratedAttribute]
private NotifyCollectionChangedEventHandler CollectionChanged;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public void AddCollection(ICollection`1<T> collection);
    public void Reset();
    private void ConsumeCollection(ICollection`1<T> collection);
    private void OnIndividualCollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    private void OnCollectionChanged(NotifyCollectionChangedEventArgs e);
    public sealed virtual void Add(T item);
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(T item);
    public sealed virtual void Clear();
    [IteratorStateMachineAttribute("MS.Internal.ObservableCollectionAggregate`1/<GetEnumerator>d__18")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class MS.Internal.Properties.Resources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string AdornerNodeAutomationPeer_HelpText { get; }
    internal static string AdornerNodeAutomationPeer_ItemType { get; }
    internal static string AdornerNodeAutomationPeer_Name { get; }
    internal static string AdornerPlacement_ToString { get; }
    internal static string DesignerItemAutomationPeer_LocalizedControlType { get; }
    internal static string DesignerViewAutomationPeer_HelpText { get; }
    internal static string DesignerViewAutomationPeer_ItemType { get; }
    internal static string DesignerViewAutomationPeer_Name { get; }
    internal static string Error_AdornerHasParent { get; }
    internal static string Error_AdornerNotParentedToThisAdornerLayer { get; }
    internal static string Error_ArgIncorrectType { get; }
    internal static string Error_ArgIncorrectTypeValue { get; }
    internal static string Error_CannotConvertValueToString { get; }
    internal static string Error_CannotUpdateValueFromStringValue { get; }
    internal static string Error_CantDeactivateActiveTransactedTask { get; }
    internal static string Error_ContextHasView { get; }
    internal static string Error_DerivedContextItem { get; }
    internal static string Error_DesignerActionItemSharing { get; }
    internal static string Error_DisposingDuringCall { get; }
    internal static string Error_DuplicateItem { get; }
    internal static string Error_DuplicateService { get; }
    internal static string Error_EditingScopeReverted { get; }
    internal static string Error_EdtingScopeCompleted { get; }
    internal static string Error_EffectsNotAllowed { get; }
    internal static string Error_EnumerationNotReady { get; }
    internal static string Error_IncompatibleGestureData { get; }
    internal static string Error_IncompatiblePositionReference { get; }
    internal static string Error_IncorrectFocusedTask { get; }
    internal static string Error_IncorrectServiceType { get; }
    internal static string Error_IncorrectTypePassed { get; }
    internal static string Error_InvalidArrayIndex { get; }
    internal static string Error_InvalidFactoryType { get; }
    internal static string Error_InvalidRedirectParent { get; }
    internal static string Error_InvalidToolboxExampleFactoryType { get; }
    internal static string Error_LocalAssemblyNameChanged { get; }
    internal static string Error_MissingContext { get; }
    internal static string Error_NoCreationType { get; }
    internal static string Error_NoDesignerView { get; }
    internal static string Error_NoGestureData { get; }
    internal static string Error_NoPropertyValue { get; }
    internal static string Error_NullImplementation { get; }
    internal static string Error_NullService { get; }
    internal static string Error_ObjectAlreadyActive { get; }
    internal static string Error_ObjectNotActive { get; }
    internal static string Error_ParentNotSupported { get; }
    internal static string Error_PropertyIsReadOnly { get; }
    internal static string Error_PropertyNotFound { get; }
    internal static string Error_PropertyValueEditor_InvalidDialogValueEditorCommandInvocation { get; }
    internal static string Error_PropertyValueEditor_InvalidDialogValueEditorEditorValue { get; }
    internal static string Error_RecursionResolvingService { get; }
    internal static string Error_RequiredService { get; }
    internal static string Error_TableValidationFailed { get; }
    internal static string Error_TaskAlreadyFocused { get; }
    internal static string Error_ToolAlreadyActive { get; }
    internal static string Error_UnknownMemberDescriptor { get; }
    internal static string Error_ValidationAmbiguousMember { get; }
    internal static string Error_ValidationNoMatchingMember { get; }
    internal static string Error_ValueGetFailed { get; }
    internal static string Error_ValueSetFailed { get; }
    internal static string Error_VisualNotInDesigner { get; }
    internal static string ToolDescription_CreateInstance { get; }
    internal static string Error_SizeConstructor { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_AdornerNodeAutomationPeer_HelpText();
    internal static string get_AdornerNodeAutomationPeer_ItemType();
    internal static string get_AdornerNodeAutomationPeer_Name();
    internal static string get_AdornerPlacement_ToString();
    internal static string get_DesignerItemAutomationPeer_LocalizedControlType();
    internal static string get_DesignerViewAutomationPeer_HelpText();
    internal static string get_DesignerViewAutomationPeer_ItemType();
    internal static string get_DesignerViewAutomationPeer_Name();
    internal static string get_Error_AdornerHasParent();
    internal static string get_Error_AdornerNotParentedToThisAdornerLayer();
    internal static string get_Error_ArgIncorrectType();
    internal static string get_Error_ArgIncorrectTypeValue();
    internal static string get_Error_CannotConvertValueToString();
    internal static string get_Error_CannotUpdateValueFromStringValue();
    internal static string get_Error_CantDeactivateActiveTransactedTask();
    internal static string get_Error_ContextHasView();
    internal static string get_Error_DerivedContextItem();
    internal static string get_Error_DesignerActionItemSharing();
    internal static string get_Error_DisposingDuringCall();
    internal static string get_Error_DuplicateItem();
    internal static string get_Error_DuplicateService();
    internal static string get_Error_EditingScopeReverted();
    internal static string get_Error_EdtingScopeCompleted();
    internal static string get_Error_EffectsNotAllowed();
    internal static string get_Error_EnumerationNotReady();
    internal static string get_Error_IncompatibleGestureData();
    internal static string get_Error_IncompatiblePositionReference();
    internal static string get_Error_IncorrectFocusedTask();
    internal static string get_Error_IncorrectServiceType();
    internal static string get_Error_IncorrectTypePassed();
    internal static string get_Error_InvalidArrayIndex();
    internal static string get_Error_InvalidFactoryType();
    internal static string get_Error_InvalidRedirectParent();
    internal static string get_Error_InvalidToolboxExampleFactoryType();
    internal static string get_Error_LocalAssemblyNameChanged();
    internal static string get_Error_MissingContext();
    internal static string get_Error_NoCreationType();
    internal static string get_Error_NoDesignerView();
    internal static string get_Error_NoGestureData();
    internal static string get_Error_NoPropertyValue();
    internal static string get_Error_NullImplementation();
    internal static string get_Error_NullService();
    internal static string get_Error_ObjectAlreadyActive();
    internal static string get_Error_ObjectNotActive();
    internal static string get_Error_ParentNotSupported();
    internal static string get_Error_PropertyIsReadOnly();
    internal static string get_Error_PropertyNotFound();
    internal static string get_Error_PropertyValueEditor_InvalidDialogValueEditorCommandInvocation();
    internal static string get_Error_PropertyValueEditor_InvalidDialogValueEditorEditorValue();
    internal static string get_Error_RecursionResolvingService();
    internal static string get_Error_RequiredService();
    internal static string get_Error_TableValidationFailed();
    internal static string get_Error_TaskAlreadyFocused();
    internal static string get_Error_ToolAlreadyActive();
    internal static string get_Error_UnknownMemberDescriptor();
    internal static string get_Error_ValidationAmbiguousMember();
    internal static string get_Error_ValidationNoMatchingMember();
    internal static string get_Error_ValueGetFailed();
    internal static string get_Error_ValueSetFailed();
    internal static string get_Error_VisualNotInDesigner();
    internal static string get_ToolDescription_CreateInstance();
    internal static string get_Error_SizeConstructor();
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.PropertyEditing.KeyAttributeMap`1 : object {
    private KeyAttributePair`1[] mapArray;
    public T Item { get; }
    public IEnumerable`1<string> Keys { get; }
    internal KeyAttributeMap`1(KeyAttributePair`1[] mapArray);
    public T get_Item(string key);
    public IEnumerable`1<string> get_Keys();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[SuppressUnmanagedCodeSecurityAttribute]
internal static class MS.Internal.SafeNativeMethods : object {
    internal static int GetSystemMetrics(int nIndex);
    internal static bool SystemParametersInfo(int nAction, int nParam, Int32& value, int ignore);
}
internal static class MS.Internal.SelectionImplementation : object {
    internal static Selection SelectParent(EditingContext context);
    [IteratorStateMachineAttribute("MS.Internal.SelectionImplementation/<EnumerateContents>d__1")]
private static IEnumerable`1<ModelItem> EnumerateContents(ModelItem start);
    internal static Selection SelectAll(EditingContext context, bool local);
    internal static void SelectNext(EditingContext context);
    internal static void SelectPrevious(EditingContext context);
    private static ModelItem GetFirstChild(ModelItem modelItem, ViewService viewService);
    private static ModelItem GetLastChild(ModelItem modelItem, ViewService viewService);
    private static ModelItem GetNextSibling(ModelItem modelItem, ViewService viewService);
    private static ModelItem GetPreviousSibling(ModelItem modelItem, ViewService viewService);
    private static bool AreSiblings(Selection s);
    private static bool IsMultiSelection(Selection s);
    private static Selection SelectContent(ModelItem parent);
    private static bool IsSelectable(ModelItem item);
    internal static void ShowDefaultEvent(EditingContext context);
}
internal static class MS.Internal.SelectionUtilities : object {
    internal static Selection ReduceSelection(Selection selection);
    internal static ModelItem GetNextSelectableChild(ModelItem parent, int startIndex, CollectionTraversalDirection direction);
    private static bool IsSelectable(ModelItem item);
}
[SuppressUnmanagedCodeSecurityAttribute]
internal static class MS.Internal.SharedUnsafeNativeMethods : object {
    public static IntPtr GetDC(IntPtr hwnd);
    public static int GetDeviceCaps(IntPtr hdc, int index);
}
internal class MS.Internal.Themes.GenericTheme : ResourceDictionary {
    private bool _contentLoaded;
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("PresentationBuildTasks", "4.0.0.0")]
public sealed virtual void InitializeComponent();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("PresentationBuildTasks", "4.0.0.0")]
[EditorBrowsableAttribute("1")]
private sealed virtual override void System.Windows.Markup.IComponentConnector.Connect(int connectionId, object target);
}
internal class MS.Internal.Transforms.CanonicalDecomposition : object {
    private static double tolerance;
    private Point center;
    private Vector scale;
    private Vector skew;
    private double rotationAngle;
    private Vector translation;
    private Matrix value;
    private bool needsUpdate;
    public Point Center { get; public set; }
    public Vector Scale { get; public set; }
    public double ScaleX { get; public set; }
    public double ScaleY { get; public set; }
    public Vector Skew { get; public set; }
    public double SkewX { get; public set; }
    public double SkewY { get; public set; }
    public double RotationAngle { get; public set; }
    public Vector Translation { get; public set; }
    public double TranslationX { get; public set; }
    public double TranslationY { get; public set; }
    public Matrix Value { get; public set; }
    public CanonicalDecomposition(CanonicalDecomposition sourceDecomposition);
    public CanonicalDecomposition(Matrix sourceMatrix);
    private static CanonicalDecomposition();
    public Point get_Center();
    public void set_Center(Point value);
    public Vector get_Scale();
    public void set_Scale(Vector value);
    public double get_ScaleX();
    public void set_ScaleX(double value);
    public double get_ScaleY();
    public void set_ScaleY(double value);
    public Vector get_Skew();
    public void set_Skew(Vector value);
    public double get_SkewX();
    public void set_SkewX(double value);
    public double get_SkewY();
    public void set_SkewY(double value);
    public double get_RotationAngle();
    public void set_RotationAngle(double value);
    public Vector get_Translation();
    public void set_Translation(Vector value);
    public double get_TranslationX();
    public void set_TranslationX(double value);
    public double get_TranslationY();
    public void set_TranslationY(double value);
    public Matrix get_Value();
    public void set_Value(Matrix value);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public static bool op_Equality(CanonicalDecomposition cd1, CanonicalDecomposition cd2);
    public static bool op_Inequality(CanonicalDecomposition cd1, CanonicalDecomposition cd2);
    public void ApplyScale(Vector scale, Point origin, Point fixedPoint);
    public void ApplySkewScale(Vector basisX, Vector basisY, Point origin, Point fixedPoint, Vector newBasisX, Vector newBasisY);
    public void ApplySkewScale(Vector appliedSkew, Vector appliedScale, Point origin, Point fixedPoint);
    private void ApplySkewScaleInternal(Vector appliedSkew, Vector appliedScale);
    public void ApplyRotation(double angle, Point fixedPoint);
    private void UpdateValue();
    private void ConvertGenericTransform(Matrix transform);
    private double GetAngle(Vector v1, Vector v2);
    public sealed virtual object Clone();
}
internal class MS.Internal.Transforms.CanonicalTransform : object {
    internal static int scaleIndex;
    internal static int skewIndex;
    internal static int rotateIndex;
    internal static int translateIndex;
    internal static int transformCount;
    private TransformGroup transformGroup;
    private CanonicalDecomposition decomposition;
    internal CanonicalDecomposition Decomposition { get; }
    public Point Center { get; public set; }
    public double CenterX { get; public set; }
    public double CenterY { get; public set; }
    public Vector Scale { get; public set; }
    public ScaleTransform ScaleTransform { get; public set; }
    public double ScaleX { get; public set; }
    public double ScaleY { get; public set; }
    public Vector Skew { get; public set; }
    public SkewTransform SkewTransform { get; public set; }
    public double SkewX { get; public set; }
    public double SkewY { get; public set; }
    public double RotationAngle { get; public set; }
    public RotateTransform RotateTransform { get; public set; }
    public Vector Translation { get; public set; }
    public TranslateTransform TranslateTransform { get; public set; }
    public double TranslationX { get; public set; }
    public double TranslationY { get; public set; }
    public CanonicalTransform(CanonicalTransform canonicalTransform);
    public CanonicalTransform(Transform transform);
    public CanonicalTransform(Matrix transform);
    private CanonicalTransform(Transform transform, bool useIfChangeable);
    internal CanonicalDecomposition get_Decomposition();
    public Point get_Center();
    public void set_Center(Point value);
    public double get_CenterX();
    public void set_CenterX(double value);
    public double get_CenterY();
    public void set_CenterY(double value);
    public Vector get_Scale();
    public void set_Scale(Vector value);
    public ScaleTransform get_ScaleTransform();
    public void set_ScaleTransform(ScaleTransform value);
    public double get_ScaleX();
    public void set_ScaleX(double value);
    public double get_ScaleY();
    public void set_ScaleY(double value);
    public Vector get_Skew();
    public void set_Skew(Vector value);
    public SkewTransform get_SkewTransform();
    public void set_SkewTransform(SkewTransform value);
    public double get_SkewX();
    public void set_SkewX(double value);
    public double get_SkewY();
    public void set_SkewY(double value);
    public double get_RotationAngle();
    public void set_RotationAngle(double value);
    public RotateTransform get_RotateTransform();
    public void set_RotateTransform(RotateTransform value);
    public Vector get_Translation();
    public void set_Translation(Vector value);
    public TranslateTransform get_TranslateTransform();
    public void set_TranslateTransform(TranslateTransform value);
    public double get_TranslationX();
    public void set_TranslationX(double value);
    public double get_TranslationY();
    public void set_TranslationY(double value);
    public static bool IsCanonical(Transform transform);
    public static Transform op_Explicit(CanonicalTransform value);
    public static CanonicalTransform op_Explicit(Transform value);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public static bool Compare(CanonicalTransform ct1, CanonicalTransform ct2);
    public static bool op_Equality(CanonicalTransform ct1, CanonicalTransform ct2);
    public static bool op_Inequality(CanonicalTransform ct1, CanonicalTransform ct2);
    public TransformGroup ToTransform();
    public sealed virtual object Clone();
    public void UpdateForNewOrigin(Point oldOrigin, Point newOrigin);
    public void UpdateCenter(Point center);
    public void ApplyScale(Vector scale, Point origin, Point fixedPoint);
    public void ApplySkewScale(Vector basisX, Vector basisY, Point origin, Point fixedPoint, Vector newBasisX, Vector newBasisY);
    public void ApplySkewScale(Vector appliedSkew, Vector appliedScale, Point origin, Point fixedPoint);
    public void ApplyRotation(double angle, Point fixedPoint);
    private void Initialize();
    private void UpdateTransformGroup();
    private void InitializeTransformGroup();
    private void ReadTransform(Transform transform, bool useIfChangeable);
    private bool ReadCanonicalForm(Transform transform, bool useIfChangeable);
}
internal static class MS.Internal.Transforms.Tolerances : object {
    private static double ZeroThreshold;
    private static Tolerances();
    public static bool NearZero(double d);
    public static bool NearZero(Vector vector);
}
internal static class MS.Internal.Transforms.TransformUtil : object {
    public static CanonicalTransform GetCanonicalTransformToAncestor(DependencyObject childOrDescendant, Visual root);
    internal static Transform GetTransformToAncestor(DependencyObject childOrDescendant, Visual ancestor);
    internal static Transform GetTransformToAncestor(ViewItem childOrDescendant, Visual ancestor);
    internal static Transform GetTransformToAncestor(ViewItem childOrDescendant, ViewItem ancestor);
    internal static Transform GetParentTransformToAncestor(ViewItem item, Visual ancestor);
    public static Transform GetTransformToDescendant(Visual parentVisual, Visual toVisual);
    public static Transform GetTransformToImmediateParent(DependencyObject child);
    public static Transform GetTransformToImmediateParent(ViewItem child);
    public static CanonicalTransform GetCanonicalTransformToImmediateParent(DependencyObject child);
    public static Vector GetScaleFromTransform(Transform transform);
    public static Vector GetScaleFromMatrix(Matrix transformMatrix);
    internal static Transform GetTransformToChild(Visual root, DependencyObject childOrDescendant);
    internal static Transform GetTransformToChild(Visual root, ViewItem childOrDescendant);
    internal static Transform GetRenderSizeTransformToDesignerView(DependencyObject itemView);
    internal static Transform GetRenderSizeTransformToDesignerView(ModelItem item);
    internal static DesignerView GetDesignerView(ModelItem item);
    internal static DesignerView GetDesignerView(DependencyObject visual);
    internal static Transform GetTransformFromDesignerView(DependencyObject visualObject);
    internal static Transform GetTransformFromDesignerView(ModelItem item);
    public static Transform SafeInvert(Transform transform);
    public static Matrix SafeInvert(Matrix m);
    public static Vector TranslateDesignerViewDelta(DependencyObject itemView, Vector delta);
    public static Vector TranslateDesignerViewDelta(ModelItem item, Vector delta);
    internal static CanonicalTransform GetCanonicalTransformToDesignerView(Visual visual);
    internal static CanonicalTransform GetCanonicalTransformToDesignerView(EditingContext context, ViewItem view);
    internal static Transform GetSelectionFrameTransformToDesignerView(DependencyObject view);
    internal static Transform GetSelectionFrameTransformToDesignerView(EditingContext context, ViewItem view);
    internal static Transform GetSelectionFrameTransformToParentVisual(DependencyObject view, Visual ancestorView);
    internal static Transform GetSelectionFrameTransformToParentView(ViewItem view, ViewItem ancestorView);
    internal static Transform GetSelectionFrameTransformToParentVisual(ViewItem view, Visual ancestorView);
    internal static bool IsNotRotateSkew(Transform transform);
}
[SuppressUnmanagedCodeSecurityAttribute]
internal static class MS.Internal.UnsafeNativeMethods : object {
    public static short GetKeyState(int keyCode);
    public static IntPtr GetDC(IntPtr hwnd);
    public static int GetDeviceCaps(IntPtr hdc, int index);
}
internal static class MS.Internal.VectorUtilities : object {
    public static Matrix GetMatrixFromTransform(GeneralTransform generalTransform);
    public static bool AngleIsGreaterThan(Vector a, Vector b, double angleInRadian);
    public static Point Midpoint(Point a, Point b);
    public static Point WeightedAverage(Point a, Point b, double t);
    public static bool AreVeryClose(Point a, Point b);
    public static Vector Unscale(Vector start, Vector scale);
    public static bool ComputeClosestPointOnTransformedLineSegment(Point point, Point a, Point b, Matrix matrix, double toleranceSquared, Double& resultParameter, Point& resultPoint, Double& resultDistanceSquared);
    public static double Dot(Vector a, Vector b);
    public static double Distance(Point a, Point b);
    public static double SquaredDistance(Point a, Point b);
    internal static bool ArePolylinesClose(List`1<Point> p, Double[] lengthP, int firstP, int lastP, List`1<Point> q, Double[] lengthQ, int firstQ, int lastQ, double distanceTolerance, Int32& firstBadVertexInQ);
    public static Double[] GetCumulatedChordLength(List`1<Point> points, int firstIndex, int lastIndex);
    public static Vector UnitNormal(Vector v);
    public static bool HaveOppositeDirections(Vector a, Vector b);
    public static bool ComputeClosestPointOnLineSegment(Point point, Point a, Point b, double toleranceSquared, Double& resultParameter, Point& resultPoint, Double& resultDistanceSquared);
    public static bool IsZero(Vector a);
    internal static Vector Scale(Vector start, Vector scale);
    internal static Vector InvertScale(Vector scale);
    internal static Vector RemoveMirror(Vector currentScale);
    internal static Rect Scale(Vector vector, Rect rect);
}
[CompilerGeneratedAttribute]
internal static class MS.Internal.VisualStudioVersionInfo : object {
    public static string MajorVersion;
    public static string MinorVersion;
    public static string ProductVersion;
    public static string VSAssemblyVersion;
}
