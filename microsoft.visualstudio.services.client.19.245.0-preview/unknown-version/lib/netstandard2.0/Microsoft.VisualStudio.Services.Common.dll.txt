[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
public class Microsoft.VisualStudio.Services.CircuitBreaker.AtomicBoolean : object {
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) booleanValue;
    public bool Value { get; public set; }
    public AtomicBoolean(bool initialValue);
    public bool get_Value();
    public void set_Value(bool value);
    public bool CompareAndSet(bool expect, bool update);
    public bool Exchange(bool newValue);
    public sealed virtual bool Equals(AtomicBoolean other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(IFormatProvider formatProvider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public static bool op_Equality(AtomicBoolean left, AtomicBoolean right);
    public static bool op_Inequality(AtomicBoolean left, AtomicBoolean right);
    public static bool op_Implicit(AtomicBoolean atomic);
}
public class Microsoft.VisualStudio.Services.CircuitBreaker.AtomicLong : object {
    private long longValue;
    public long Value { get; public set; }
    public AtomicLong(long initialValue);
    public long get_Value();
    public void set_Value(long value);
    public long AddAndGet(long delta);
    public bool CompareAndSet(long expect, long update);
    public long DecrementAndGet();
    public long GetAndDecrement();
    public long GetAndIncrement();
    public long GetAndSet(long newValue);
    public long IncrementAndGet();
    public bool WeakCompareAndSet(long expect, long update);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(IFormatProvider formatProvider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public static bool op_Equality(AtomicLong left, AtomicLong right);
    public static bool op_Inequality(AtomicLong left, AtomicLong right);
    public static long op_Implicit(AtomicLong atomic);
}
public static class Microsoft.VisualStudio.Services.CircuitBreaker.CircuitBreaker : object {
    public static void Reset();
}
[ExceptionMappingAttribute("0.0", "3.0", "CircuitBreakerExceededConcurrencyException", "Microsoft.VisualStudio.Services.CircuitBreaker.CircuitBreakerExceededConcurrencyException, Microsoft.VisualStudio.Services.Common, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class Microsoft.VisualStudio.Services.CircuitBreaker.CircuitBreakerExceededConcurrencyException : CircuitBreakerException {
    public CircuitBreakerExceededConcurrencyException(string message, Exception innerException);
    protected CircuitBreakerExceededConcurrencyException(SerializationInfo info, StreamingContext context);
}
[ExceptionMappingAttribute("0.0", "3.0", "CircuitBreakerExceededExecutionLimitException", "Microsoft.VisualStudio.Services.CircuitBreaker.CircuitBreakerExceededExecutionLimitException, Microsoft.VisualStudio.Services.Common, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class Microsoft.VisualStudio.Services.CircuitBreaker.CircuitBreakerExceededExecutionLimitException : CircuitBreakerException {
    public CircuitBreakerExceededExecutionLimitException(string message, Exception innerException);
    protected CircuitBreakerExceededExecutionLimitException(SerializationInfo info, StreamingContext context);
}
[ExceptionMappingAttribute("0.0", "3.0", "CircuitBreakerException", "Microsoft.VisualStudio.Services.CircuitBreaker.CircuitBreakerException, Microsoft.VisualStudio.Services.Common, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public abstract class Microsoft.VisualStudio.Services.CircuitBreaker.CircuitBreakerException : VssException {
    public CircuitBreakerException(string message, Exception innerException);
    protected CircuitBreakerException(SerializationInfo info, StreamingContext context);
}
public static class Microsoft.VisualStudio.Services.CircuitBreaker.CircuitBreakerFactory : object {
    internal static ConcurrentDictionary`2<CommandKey, ICircuitBreaker> Instances;
    private static CircuitBreakerFactory();
    public static ICircuitBreaker GetInstance(CommandKey commandKey, ICommandProperties properties, CommandMetrics metrics, ITime time);
    internal static void SetInstance(CommandKey commandKey, ICircuitBreaker circuitBreaker);
    public static ICircuitBreaker GetInstance(CommandKey commandKey);
    public static void RemoveOlderThan(TimeSpan time);
    internal static void Reset();
}
internal class Microsoft.VisualStudio.Services.CircuitBreaker.CircuitBreakerImpl : object {
    private CommandMetrics m_metrics;
    private ITime m_time;
    private AtomicBoolean m_circuitOpen;
    private AtomicLong m_circuitOpenedOrLastTestedTime;
    private AtomicLong m_circuitAccessedTime;
    private AtomicLong m_attempt;
    internal AtomicLong m_backoffInMilliseconds;
    [CompilerGeneratedAttribute]
private ITryableSemaphore <ExecutionSemaphore>k__BackingField;
    [CompilerGeneratedAttribute]
private ITryableSemaphore <FallbackSemaphore>k__BackingField;
    [CompilerGeneratedAttribute]
private IRollingNumber <ExecutionRequests>k__BackingField;
    [CompilerGeneratedAttribute]
private IRollingNumber <FallbackRequests>k__BackingField;
    public ITryableSemaphore ExecutionSemaphore { get; private set; }
    public ITryableSemaphore FallbackSemaphore { get; private set; }
    public IRollingNumber ExecutionRequests { get; private set; }
    public IRollingNumber FallbackRequests { get; private set; }
    internal CircuitBreakerImpl(ICommandProperties properties, CommandMetrics metrics, ITime time);
    public sealed virtual bool AllowRequest(ICommandProperties properties);
    public sealed virtual bool IsOpen(ICommandProperties properties);
    public sealed virtual CircuitBreakerStatus GetCircuitBreakerState(ICommandProperties properties);
    private bool AllowSingleTest(ICommandProperties properties);
    [CompilerGeneratedAttribute]
public sealed virtual ITryableSemaphore get_ExecutionSemaphore();
    [CompilerGeneratedAttribute]
private void set_ExecutionSemaphore(ITryableSemaphore value);
    [CompilerGeneratedAttribute]
public sealed virtual ITryableSemaphore get_FallbackSemaphore();
    [CompilerGeneratedAttribute]
private void set_FallbackSemaphore(ITryableSemaphore value);
    [CompilerGeneratedAttribute]
public sealed virtual IRollingNumber get_ExecutionRequests();
    [CompilerGeneratedAttribute]
private void set_ExecutionRequests(IRollingNumber value);
    [CompilerGeneratedAttribute]
public sealed virtual IRollingNumber get_FallbackRequests();
    [CompilerGeneratedAttribute]
private void set_FallbackRequests(IRollingNumber value);
    internal void Reset();
    public sealed virtual void MarkSuccess();
    public sealed virtual bool IsOlderThan(TimeSpan time);
}
internal class Microsoft.VisualStudio.Services.CircuitBreaker.CircuitBreakerNoOpImpl : object {
    [CompilerGeneratedAttribute]
private ITryableSemaphore <ExecutionSemaphore>k__BackingField;
    [CompilerGeneratedAttribute]
private ITryableSemaphore <FallbackSemaphore>k__BackingField;
    [CompilerGeneratedAttribute]
private IRollingNumber <ExecutionRequests>k__BackingField;
    [CompilerGeneratedAttribute]
private IRollingNumber <FallbackRequests>k__BackingField;
    public ITryableSemaphore ExecutionSemaphore { get; private set; }
    public ITryableSemaphore FallbackSemaphore { get; private set; }
    public IRollingNumber ExecutionRequests { get; private set; }
    public IRollingNumber FallbackRequests { get; private set; }
    public sealed virtual bool AllowRequest(ICommandProperties properties);
    public sealed virtual bool IsOpen(ICommandProperties properties);
    public sealed virtual CircuitBreakerStatus GetCircuitBreakerState(ICommandProperties properties);
    public sealed virtual void MarkSuccess();
    public sealed virtual bool IsOlderThan(TimeSpan time);
    [CompilerGeneratedAttribute]
public sealed virtual ITryableSemaphore get_ExecutionSemaphore();
    [CompilerGeneratedAttribute]
private void set_ExecutionSemaphore(ITryableSemaphore value);
    [CompilerGeneratedAttribute]
public sealed virtual ITryableSemaphore get_FallbackSemaphore();
    [CompilerGeneratedAttribute]
private void set_FallbackSemaphore(ITryableSemaphore value);
    [CompilerGeneratedAttribute]
public sealed virtual IRollingNumber get_ExecutionRequests();
    [CompilerGeneratedAttribute]
private void set_ExecutionRequests(IRollingNumber value);
    [CompilerGeneratedAttribute]
public sealed virtual IRollingNumber get_FallbackRequests();
    [CompilerGeneratedAttribute]
private void set_FallbackRequests(IRollingNumber value);
}
[ExceptionMappingAttribute("0.0", "3.0", "CircuitBreakerShortCircuitException", "Microsoft.VisualStudio.Services.CircuitBreaker.CircuitBreakerShortCircuitException, Microsoft.VisualStudio.Services.Common, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class Microsoft.VisualStudio.Services.CircuitBreaker.CircuitBreakerShortCircuitException : CircuitBreakerException {
    public CircuitBreakerShortCircuitException(string message, Exception innerException);
    protected CircuitBreakerShortCircuitException(SerializationInfo info, StreamingContext context);
}
public enum Microsoft.VisualStudio.Services.CircuitBreaker.CircuitBreakerStatus : Enum {
    public byte value__;
    public static CircuitBreakerStatus Closed;
    public static CircuitBreakerStatus HalfOpen;
    public static CircuitBreakerStatus Open;
}
public static class Microsoft.VisualStudio.Services.CircuitBreaker.CircuitBreakerTracePoints : object {
    public static int ExecutionFailure;
    public static int ExecutionConcurrencyRejection;
    public static int ExecutionLimitRejection;
    public static int ShortCircuited;
    public static int FallbackMissingDelegate;
    public static int FallbackFailure;
    public static int FallbackConcurrencyRejection;
    public static int FallbackLimitRejection;
    public static int FallbackDisabled;
}
public class Microsoft.VisualStudio.Services.CircuitBreaker.Command : CommandAsync {
    private Action m_Run;
    private Action m_Fallback;
    private static Task DummyTask;
    public Command(CommandGroupKey group, Action run, Action fallback);
    public Command(CommandSetter setter, Action run, Action fallback);
    protected internal Command(CommandGroupKey group, CommandKey key, ICircuitBreaker circuitBreaker, ICommandProperties properties, CommandMetrics metrics, IEventNotifier eventNotifier, Action run, Action fallback, ITime time);
    private static Command();
    public void Execute();
    protected void Execute(Action run, Action fallback);
}
public class Microsoft.VisualStudio.Services.CircuitBreaker.Command`1 : Command {
    private Func`1<TResult> m_Run;
    private Func`1<TResult> m_Fallback;
    public Command`1(CommandGroupKey group, Func`1<TResult> run, Func`1<TResult> fallback);
    public Command`1(CommandSetter setter, Func`1<TResult> run, Func`1<TResult> fallback);
    protected internal Command`1(CommandGroupKey group, CommandKey key, ICircuitBreaker circuitBreaker, ICommandProperties properties, CommandMetrics metrics, IEventNotifier eventNotifier, Func`1<TResult> run, Func`1<TResult> fallback, ITime time);
    public TResult Execute();
}
public class Microsoft.VisualStudio.Services.CircuitBreaker.CommandAsync : object {
    public static string DontTriggerCircuitBreaker;
    protected internal ITime m_time;
    protected internal IEventNotifier m_eventNotifier;
    protected internal ICircuitBreaker m_circuitBreaker;
    protected internal ICommandProperties m_properties;
    protected internal CommandMetrics m_metrics;
    protected internal CommandKey m_CommandKey;
    protected internal CommandGroupKey m_CommandGroup;
    private Func`1<Task> m_Run;
    private Func`1<Task> m_Fallback;
    protected bool m_ContinueOnCapturedContext;
    protected internal long invocationStartTime;
    private static string s_classname;
    private static string s_featurearea;
    public CommandGroupKey CommandGroup { get; }
    public CommandKey CommandKey { get; }
    internal ICircuitBreaker CircuitBreaker { get; }
    public CommandMetrics Metrics { get; }
    public ICommandProperties Properties { get; }
    public bool IsCircuitBreakerOpen { get; }
    public CircuitBreakerStatus CircuitBreakerState { get; }
    public CommandAsync(CommandGroupKey group, Func`1<Task> run, Func`1<Task> fallback, bool continueOnCapturedContext);
    public CommandAsync(CommandSetter setter, Func`1<Task> run, Func`1<Task> fallback, bool continueOnCapturedContext);
    protected CommandAsync(CommandGroupKey group, CommandKey key, ICircuitBreaker circuitBreaker, ICommandProperties properties, CommandMetrics metrics, IEventNotifier eventNotifier, Func`1<Task> run, Func`1<Task> fallback, bool continueOnCapturedContext, ITime time);
    private static CommandAsync();
    public CommandGroupKey get_CommandGroup();
    public CommandKey get_CommandKey();
    internal ICircuitBreaker get_CircuitBreaker();
    public CommandMetrics get_Metrics();
    public ICommandProperties get_Properties();
    public bool get_IsCircuitBreakerOpen();
    public CircuitBreakerStatus get_CircuitBreakerState();
    public Task Execute();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Services.CircuitBreaker.CommandAsync/<Execute>d__30")]
protected Task Execute(Func`1<Task> run, Func`1<Task> fallback, bool continueOnCapturedContext);
    protected virtual void Trace(int tracepoint, TraceLevel level, string featurearea, string classname, string message);
    protected virtual void TraceConditionally(int tracepoint, TraceLevel level, string featurearea, string classname, Func`1<string> message);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Services.CircuitBreaker.CommandAsync/<TryFallbackAsync>d__33")]
private Task`1<bool> TryFallbackAsync(string message, Func`1<Task> fallback, bool continueOnCapturedContext);
    private string CircuitBreakerErrorMessage(string message, Exception e);
}
public class Microsoft.VisualStudio.Services.CircuitBreaker.CommandAsync`1 : CommandAsync {
    private Func`1<Task`1<TResult>> m_Run;
    private Func`1<Task`1<TResult>> m_Fallback;
    public CommandAsync`1(CommandGroupKey group, Func`1<Task`1<TResult>> run, Func`1<Task`1<TResult>> fallback, bool continueOnCapturedContext);
    public CommandAsync`1(CommandSetter setter, Func`1<Task`1<TResult>> run, Func`1<Task`1<TResult>> fallback, bool continueOnCapturedContext);
    protected internal CommandAsync`1(CommandGroupKey group, CommandKey key, ICircuitBreaker circuitBreaker, ICommandProperties properties, CommandMetrics metrics, IEventNotifier eventNotifier, Func`1<Task`1<TResult>> run, Func`1<Task`1<TResult>> fallback, bool continueOnCapturedContext, ITime time);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Services.CircuitBreaker.CommandAsync`1/<Execute>d__5")]
public Task`1<TResult> Execute();
}
public class Microsoft.VisualStudio.Services.CircuitBreaker.CommandGroupKey : ImmutableKey {
    public CommandGroupKey(string name);
    public static CommandGroupKey op_Implicit(string name);
}
public class Microsoft.VisualStudio.Services.CircuitBreaker.CommandKey : ImmutableKey {
    public CommandKey(string name);
    public CommandKey(Type commandType);
    public static CommandKey op_Implicit(string name);
    private static string GetDefaultNameForCommandType(Type commandType);
}
public class Microsoft.VisualStudio.Services.CircuitBreaker.CommandMetrics : object {
    private static ConcurrentDictionary`2<string, CommandMetrics> metrics;
    private CommandKey key;
    private CommandGroupKey group;
    private ICommandProperties properties;
    private IEventNotifier eventNotifier;
    private ITime time;
    internal RollingNumber success;
    internal RollingNumber failure;
    internal RollingNumber timeout;
    internal RollingNumber shortCircuited;
    internal RollingNumber concurrencyRejected;
    internal RollingNumber limitRejected;
    internal RollingNumber fallbackSuccess;
    internal RollingNumber fallbackFailure;
    internal RollingNumber fallbackConcurrencyRejected;
    internal RollingNumber fallbackLimitRejected;
    internal long maxConcurrency;
    private HealthCounts modreq(System.Runtime.CompilerServices.IsVolatile) healthCountsSnapshot;
    private long lastHealthCountsSnapshot;
    [CompilerGeneratedAttribute]
private Exception <LastException>k__BackingField;
    public static IEnumerable`1<CommandMetrics> Instances { get; }
    public CommandKey CommandKey { get; }
    public CommandGroupKey CommandGroup { get; }
    public ICommandProperties Properties { get; }
    public Exception LastException { get; public set; }
    internal CommandMetrics(CommandKey key, CommandGroupKey commandGroup, ICommandProperties properties, IEventNotifier eventNotifier, ITime time);
    private static CommandMetrics();
    public static CommandMetrics GetInstance(CommandKey key, CommandGroupKey commandGroup, ICommandProperties properties, IEventNotifier eventNotifier, ITime time);
    public static CommandMetrics GetInstance(CommandKey key);
    public static IEnumerable`1<CommandMetrics> get_Instances();
    internal static void Reset();
    public CommandKey get_CommandKey();
    public CommandGroupKey get_CommandGroup();
    public ICommandProperties get_Properties();
    internal void ResetCounter();
    internal void MarkSuccess();
    internal void MarkFailure();
    internal void MarkTimeout();
    internal void MarkShortCircuited();
    internal void MarkConcurrencyRejected();
    internal void MarkLimitRejected();
    internal void MarkFallbackSuccess();
    internal void MarkFallbackFailure();
    internal void MarkFallbackConcurrencyRejected();
    internal void MarkFallbackLimitRejected();
    public HealthCounts GetHealthCounts();
    [CompilerGeneratedAttribute]
public Exception get_LastException();
    [CompilerGeneratedAttribute]
public void set_LastException(Exception value);
}
public class Microsoft.VisualStudio.Services.CircuitBreaker.CommandPropertiesDefault : object {
    private static bool DefaultCircuitBreakerDisabled;
    private static int DefaultCircuitBreakerErrorThresholdPercentage;
    private static bool DefaultCircuitBreakerForceClosed;
    private static bool DefaultCircuitBreakerForceOpen;
    private static int DefaultCircuitBreakerRequestVolumeThreshold;
    private static TimeSpan DefaultCircuitBreakerMinBackoff;
    private static TimeSpan DefaultCircuitBreakerMaxBackoff;
    private static TimeSpan DefaultCircuitBreakerDeltaBackoff;
    private static TimeSpan DefaultExecutionTimeout;
    private static int DefaultExecutionMaxConcurrentRequests;
    private static int DefaultFallbackMaxConcurrentRequests;
    private static int DefaultExecutionMaxRequests;
    private static int DefaultFallbackMaxRequests;
    private static bool DefaultFallbackDisabled;
    private static TimeSpan DefaultMetricsHealthSnapshotInterval;
    private static int DefaultMetricsRollingStatisticalWindowInMilliseconds;
    private static int DefaultMetricsRollingStatisticalWindowBuckets;
    [CompilerGeneratedAttribute]
private bool <CircuitBreakerDisabled>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CircuitBreakerErrorThresholdPercentage>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CircuitBreakerForceClosed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CircuitBreakerForceOpen>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CircuitBreakerRequestVolumeThreshold>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <CircuitBreakerMinBackoff>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <CircuitBreakerMaxBackoff>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <CircuitBreakerDeltaBackoff>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <ExecutionTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ExecutionMaxConcurrentRequests>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FallbackMaxConcurrentRequests>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ExecutionMaxRequests>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FallbackMaxRequests>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FallbackDisabled>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <MetricsHealthSnapshotInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MetricsRollingStatisticalWindowInMilliseconds>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MetricsRollingStatisticalWindowBuckets>k__BackingField;
    public bool CircuitBreakerDisabled { get; protected set; }
    public int CircuitBreakerErrorThresholdPercentage { get; protected set; }
    public bool CircuitBreakerForceClosed { get; protected set; }
    public bool CircuitBreakerForceOpen { get; protected set; }
    public int CircuitBreakerRequestVolumeThreshold { get; protected set; }
    public TimeSpan CircuitBreakerMinBackoff { get; protected set; }
    public TimeSpan CircuitBreakerMaxBackoff { get; protected set; }
    public TimeSpan CircuitBreakerDeltaBackoff { get; protected set; }
    public TimeSpan ExecutionTimeout { get; protected set; }
    public int ExecutionMaxConcurrentRequests { get; protected set; }
    public int FallbackMaxConcurrentRequests { get; protected set; }
    public int ExecutionMaxRequests { get; protected set; }
    public int FallbackMaxRequests { get; protected set; }
    public bool FallbackDisabled { get; protected set; }
    public TimeSpan MetricsHealthSnapshotInterval { get; protected set; }
    public int MetricsRollingStatisticalWindowInMilliseconds { get; protected set; }
    public int MetricsRollingStatisticalWindowBuckets { get; protected set; }
    public CommandPropertiesDefault(CommandPropertiesSetter setter);
    private static CommandPropertiesDefault();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CircuitBreakerDisabled();
    [CompilerGeneratedAttribute]
protected void set_CircuitBreakerDisabled(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_CircuitBreakerErrorThresholdPercentage();
    [CompilerGeneratedAttribute]
protected void set_CircuitBreakerErrorThresholdPercentage(int value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CircuitBreakerForceClosed();
    [CompilerGeneratedAttribute]
protected void set_CircuitBreakerForceClosed(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CircuitBreakerForceOpen();
    [CompilerGeneratedAttribute]
protected void set_CircuitBreakerForceOpen(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_CircuitBreakerRequestVolumeThreshold();
    [CompilerGeneratedAttribute]
protected void set_CircuitBreakerRequestVolumeThreshold(int value);
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_CircuitBreakerMinBackoff();
    [CompilerGeneratedAttribute]
protected void set_CircuitBreakerMinBackoff(TimeSpan value);
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_CircuitBreakerMaxBackoff();
    [CompilerGeneratedAttribute]
protected void set_CircuitBreakerMaxBackoff(TimeSpan value);
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_CircuitBreakerDeltaBackoff();
    [CompilerGeneratedAttribute]
protected void set_CircuitBreakerDeltaBackoff(TimeSpan value);
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_ExecutionTimeout();
    [CompilerGeneratedAttribute]
protected void set_ExecutionTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_ExecutionMaxConcurrentRequests();
    [CompilerGeneratedAttribute]
protected void set_ExecutionMaxConcurrentRequests(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_FallbackMaxConcurrentRequests();
    [CompilerGeneratedAttribute]
protected void set_FallbackMaxConcurrentRequests(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_ExecutionMaxRequests();
    [CompilerGeneratedAttribute]
protected void set_ExecutionMaxRequests(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_FallbackMaxRequests();
    [CompilerGeneratedAttribute]
protected void set_FallbackMaxRequests(int value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_FallbackDisabled();
    [CompilerGeneratedAttribute]
protected void set_FallbackDisabled(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_MetricsHealthSnapshotInterval();
    [CompilerGeneratedAttribute]
protected void set_MetricsHealthSnapshotInterval(TimeSpan value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_MetricsRollingStatisticalWindowInMilliseconds();
    [CompilerGeneratedAttribute]
protected void set_MetricsRollingStatisticalWindowInMilliseconds(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_MetricsRollingStatisticalWindowBuckets();
    [CompilerGeneratedAttribute]
protected void set_MetricsRollingStatisticalWindowBuckets(int value);
}
public class Microsoft.VisualStudio.Services.CircuitBreaker.CommandPropertiesSetter : object {
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <CircuitBreakerDisabled>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <CircuitBreakerErrorThresholdPercentage>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <CircuitBreakerForceClosed>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <CircuitBreakerForceOpen>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <CircuitBreakerRequestVolumeThreshold>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <CircuitBreakerMinBackoff>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <CircuitBreakerMaxBackoff>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <CircuitBreakerDeltaBackoff>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <ExecutionTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ExecutionMaxConcurrentRequests>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <FallbackMaxConcurrentRequests>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ExecutionMaxRequests>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <FallbackMaxRequests>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <FallbackDisabled>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <MetricsHealthSnapshotInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MetricsRollingStatisticalWindowInMilliseconds>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MetricsRollingStatisticalWindowBuckets>k__BackingField;
    public Nullable`1<bool> CircuitBreakerDisabled { get; private set; }
    public Nullable`1<int> CircuitBreakerErrorThresholdPercentage { get; private set; }
    public Nullable`1<bool> CircuitBreakerForceClosed { get; private set; }
    public Nullable`1<bool> CircuitBreakerForceOpen { get; private set; }
    public Nullable`1<int> CircuitBreakerRequestVolumeThreshold { get; private set; }
    public Nullable`1<TimeSpan> CircuitBreakerMinBackoff { get; private set; }
    public Nullable`1<TimeSpan> CircuitBreakerMaxBackoff { get; private set; }
    public Nullable`1<TimeSpan> CircuitBreakerDeltaBackoff { get; private set; }
    public Nullable`1<TimeSpan> ExecutionTimeout { get; private set; }
    public Nullable`1<int> ExecutionMaxConcurrentRequests { get; private set; }
    public Nullable`1<int> FallbackMaxConcurrentRequests { get; private set; }
    public Nullable`1<int> ExecutionMaxRequests { get; private set; }
    public Nullable`1<int> FallbackMaxRequests { get; private set; }
    public Nullable`1<bool> FallbackDisabled { get; private set; }
    public Nullable`1<TimeSpan> MetricsHealthSnapshotInterval { get; private set; }
    public Nullable`1<int> MetricsRollingStatisticalWindowInMilliseconds { get; private set; }
    public Nullable`1<int> MetricsRollingStatisticalWindowBuckets { get; private set; }
    public CommandPropertiesSetter(ICommandProperties values);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_CircuitBreakerDisabled();
    [CompilerGeneratedAttribute]
private void set_CircuitBreakerDisabled(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_CircuitBreakerErrorThresholdPercentage();
    [CompilerGeneratedAttribute]
private void set_CircuitBreakerErrorThresholdPercentage(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_CircuitBreakerForceClosed();
    [CompilerGeneratedAttribute]
private void set_CircuitBreakerForceClosed(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_CircuitBreakerForceOpen();
    [CompilerGeneratedAttribute]
private void set_CircuitBreakerForceOpen(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_CircuitBreakerRequestVolumeThreshold();
    [CompilerGeneratedAttribute]
private void set_CircuitBreakerRequestVolumeThreshold(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_CircuitBreakerMinBackoff();
    [CompilerGeneratedAttribute]
private void set_CircuitBreakerMinBackoff(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_CircuitBreakerMaxBackoff();
    [CompilerGeneratedAttribute]
private void set_CircuitBreakerMaxBackoff(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_CircuitBreakerDeltaBackoff();
    [CompilerGeneratedAttribute]
private void set_CircuitBreakerDeltaBackoff(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_ExecutionTimeout();
    [CompilerGeneratedAttribute]
private void set_ExecutionTimeout(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ExecutionMaxConcurrentRequests();
    [CompilerGeneratedAttribute]
private void set_ExecutionMaxConcurrentRequests(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_FallbackMaxConcurrentRequests();
    [CompilerGeneratedAttribute]
private void set_FallbackMaxConcurrentRequests(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ExecutionMaxRequests();
    [CompilerGeneratedAttribute]
private void set_ExecutionMaxRequests(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_FallbackMaxRequests();
    [CompilerGeneratedAttribute]
private void set_FallbackMaxRequests(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_FallbackDisabled();
    [CompilerGeneratedAttribute]
private void set_FallbackDisabled(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_MetricsHealthSnapshotInterval();
    [CompilerGeneratedAttribute]
private void set_MetricsHealthSnapshotInterval(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MetricsRollingStatisticalWindowInMilliseconds();
    [CompilerGeneratedAttribute]
private void set_MetricsRollingStatisticalWindowInMilliseconds(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MetricsRollingStatisticalWindowBuckets();
    [CompilerGeneratedAttribute]
private void set_MetricsRollingStatisticalWindowBuckets(Nullable`1<int> value);
    public CommandPropertiesSetter WithCircuitBreakerDisabled(bool value);
    public CommandPropertiesSetter WithCircuitBreakerErrorThresholdPercentage(int value);
    public CommandPropertiesSetter WithCircuitBreakerForceClosed(bool value);
    public CommandPropertiesSetter WithCircuitBreakerForceOpen(bool value);
    public CommandPropertiesSetter WithCircuitBreakerRequestVolumeThreshold(int value);
    public CommandPropertiesSetter WithCircuitBreakerMinBackoff(TimeSpan value);
    public CommandPropertiesSetter WithCircuitBreakerMaxBackoff(TimeSpan value);
    public CommandPropertiesSetter WithCircuitBreakerDeltaBackoff(TimeSpan value);
    public CommandPropertiesSetter WithExecutionTimeoutInMilliseconds(int milliseconds);
    public CommandPropertiesSetter WithExecutionTimeout(TimeSpan value);
    public CommandPropertiesSetter WithExecutionMaxConcurrentRequests(int value);
    public CommandPropertiesSetter WithFallbackMaxConcurrentRequests(int value);
    public CommandPropertiesSetter WithExecutionMaxRequests(int value);
    public CommandPropertiesSetter WithFallbackMaxRequests(int value);
    public CommandPropertiesSetter WithFallbackDisabled(bool value);
    public CommandPropertiesSetter WithMetricsHealthSnapshotInterval(TimeSpan value);
    public CommandPropertiesSetter WithMetricsRollingStatisticalWindowInMilliseconds(int value);
    public CommandPropertiesSetter WithMetricsRollingStatisticalWindow(TimeSpan value);
    public CommandPropertiesSetter WithMetricsRollingStatisticalWindowBuckets(int value);
}
public class Microsoft.VisualStudio.Services.CircuitBreaker.CommandSetter : object {
    [CompilerGeneratedAttribute]
private CommandGroupKey <GroupKey>k__BackingField;
    [CompilerGeneratedAttribute]
private CommandKey <CommandKey>k__BackingField;
    [CompilerGeneratedAttribute]
private CommandPropertiesSetter <CommandPropertiesDefaults>k__BackingField;
    public CommandGroupKey GroupKey { get; }
    public CommandKey CommandKey { get; private set; }
    public CommandPropertiesSetter CommandPropertiesDefaults { get; private set; }
    public CommandSetter(CommandGroupKey groupKey);
    [CompilerGeneratedAttribute]
public CommandGroupKey get_GroupKey();
    [CompilerGeneratedAttribute]
public CommandKey get_CommandKey();
    [CompilerGeneratedAttribute]
private void set_CommandKey(CommandKey value);
    [CompilerGeneratedAttribute]
public CommandPropertiesSetter get_CommandPropertiesDefaults();
    [CompilerGeneratedAttribute]
private void set_CommandPropertiesDefaults(CommandPropertiesSetter value);
    public static CommandSetter WithGroupKey(CommandGroupKey groupKey);
    public CommandSetter AndCommandKey(CommandKey commandKey);
    public CommandSetter AndCommandPropertiesDefaults(CommandPropertiesSetter commandPropertiesDefaults);
}
public class Microsoft.VisualStudio.Services.CircuitBreaker.EventNotifierDefault : object {
    private static EventNotifierDefault instance;
    public static EventNotifierDefault Instance { get; }
    private static EventNotifierDefault();
    public static EventNotifierDefault get_Instance();
    public virtual void MarkEvent(CommandGroupKey group, CommandKey key, EventType eventType);
    public virtual void MarkCommandExecution(CommandGroupKey group, CommandKey key, long elapsedTimeInMilliseconds);
    public virtual void MarkExecutionConcurrency(CommandGroupKey group, CommandKey key, long executionSemaphoreNumberOfPermitsUsed);
    public virtual void MarkFallbackConcurrency(CommandGroupKey group, CommandKey key, long fallbackSemaphoreNumberOfPermitsUsed);
    public sealed virtual void MarkExecutionCount(CommandGroupKey group, CommandKey key, long executionCount);
    public sealed virtual void MarkFallbackCount(CommandGroupKey group, CommandKey key, long fallbackCount);
    public virtual void TraceRaw(int tracepoint, TraceLevel level, string featurearea, string classname, string message);
    public virtual void TraceRawConditionally(int tracepoint, TraceLevel level, string featurearea, string classname, Func`1<string> message);
}
public enum Microsoft.VisualStudio.Services.CircuitBreaker.EventType : Enum {
    public int value__;
    public static EventType Success;
    public static EventType Failure;
    public static EventType Timeout;
    public static EventType ShortCircuited;
    public static EventType ConcurrencyRejected;
    public static EventType LimitRejected;
    public static EventType FallbackSuccess;
    public static EventType FallbackFailure;
    public static EventType FallbackConcurrencyRejected;
    public static EventType FallbackLimitRejected;
}
public class Microsoft.VisualStudio.Services.CircuitBreaker.HealthCounts : object {
    private long totalCount;
    private long errorCount;
    private int errorPercentage;
    private long semaphoreRejectedCount;
    public long TotalRequests { get; }
    public long ErrorCount { get; }
    public long SemaphoreRejected { get; }
    public int ErrorPercentage { get; }
    public HealthCounts(long total, long error, long semaphoreRejected);
    public long get_TotalRequests();
    public long get_ErrorCount();
    public long get_SemaphoreRejected();
    public int get_ErrorPercentage();
}
public interface Microsoft.VisualStudio.Services.CircuitBreaker.ICircuitBreaker {
    public ITryableSemaphore ExecutionSemaphore { get; }
    public ITryableSemaphore FallbackSemaphore { get; }
    public IRollingNumber ExecutionRequests { get; }
    public IRollingNumber FallbackRequests { get; }
    public abstract virtual bool AllowRequest(ICommandProperties properties);
    public abstract virtual bool IsOpen(ICommandProperties properties);
    public abstract virtual void MarkSuccess();
    public abstract virtual bool IsOlderThan(TimeSpan time);
    public abstract virtual ITryableSemaphore get_ExecutionSemaphore();
    public abstract virtual ITryableSemaphore get_FallbackSemaphore();
    public abstract virtual IRollingNumber get_ExecutionRequests();
    public abstract virtual IRollingNumber get_FallbackRequests();
    public abstract virtual CircuitBreakerStatus GetCircuitBreakerState(ICommandProperties properties);
}
public interface Microsoft.VisualStudio.Services.CircuitBreaker.ICommandFactory {
    public CommandKey CommandKey { get; }
    public abstract virtual CommandKey get_CommandKey();
    public abstract virtual CommandAsync CreateCommandAsync(CommandSetter commandSetter, Func`1<Task> run, Func`1<Task> fallback, bool continueOnCapturedContext);
    public abstract virtual CommandAsync`1<TResult> CreateCommandAsync(CommandSetter commandSetter, Func`1<Task`1<TResult>> run, Func`1<Task`1<TResult>> fallback, bool continueOnCapturedContext);
}
public interface Microsoft.VisualStudio.Services.CircuitBreaker.ICommandProperties {
    public bool CircuitBreakerDisabled { get; }
    public int CircuitBreakerErrorThresholdPercentage { get; }
    public bool CircuitBreakerForceClosed { get; }
    public bool CircuitBreakerForceOpen { get; }
    public int CircuitBreakerRequestVolumeThreshold { get; }
    public TimeSpan CircuitBreakerMinBackoff { get; }
    public TimeSpan CircuitBreakerMaxBackoff { get; }
    public TimeSpan CircuitBreakerDeltaBackoff { get; }
    public TimeSpan ExecutionTimeout { get; }
    public int ExecutionMaxConcurrentRequests { get; }
    public int FallbackMaxConcurrentRequests { get; }
    public int ExecutionMaxRequests { get; }
    public int FallbackMaxRequests { get; }
    public bool FallbackDisabled { get; }
    public TimeSpan MetricsHealthSnapshotInterval { get; }
    public int MetricsRollingStatisticalWindowInMilliseconds { get; }
    public int MetricsRollingStatisticalWindowBuckets { get; }
    public abstract virtual bool get_CircuitBreakerDisabled();
    public abstract virtual int get_CircuitBreakerErrorThresholdPercentage();
    public abstract virtual bool get_CircuitBreakerForceClosed();
    public abstract virtual bool get_CircuitBreakerForceOpen();
    public abstract virtual int get_CircuitBreakerRequestVolumeThreshold();
    public abstract virtual TimeSpan get_CircuitBreakerMinBackoff();
    public abstract virtual TimeSpan get_CircuitBreakerMaxBackoff();
    public abstract virtual TimeSpan get_CircuitBreakerDeltaBackoff();
    public abstract virtual TimeSpan get_ExecutionTimeout();
    public abstract virtual int get_ExecutionMaxConcurrentRequests();
    public abstract virtual int get_FallbackMaxConcurrentRequests();
    public abstract virtual int get_ExecutionMaxRequests();
    public abstract virtual int get_FallbackMaxRequests();
    public abstract virtual bool get_FallbackDisabled();
    public abstract virtual TimeSpan get_MetricsHealthSnapshotInterval();
    public abstract virtual int get_MetricsRollingStatisticalWindowInMilliseconds();
    public abstract virtual int get_MetricsRollingStatisticalWindowBuckets();
}
public interface Microsoft.VisualStudio.Services.CircuitBreaker.IEventNotifier {
    public abstract virtual void MarkEvent(CommandGroupKey group, CommandKey key, EventType eventType);
    public abstract virtual void MarkCommandExecution(CommandGroupKey group, CommandKey key, long elapsedTimeInMilliseconds);
    public abstract virtual void MarkExecutionConcurrency(CommandGroupKey group, CommandKey key, long executionSemaphoreNumberOfPermitsUsed);
    public abstract virtual void MarkFallbackConcurrency(CommandGroupKey group, CommandKey key, long fallbackSemaphoreNumberOfPermitsUsed);
    public abstract virtual void MarkExecutionCount(CommandGroupKey group, CommandKey key, long executionCount);
    public abstract virtual void MarkFallbackCount(CommandGroupKey group, CommandKey key, long fallbackCount);
    public abstract virtual void TraceRaw(int tracepoint, TraceLevel level, string featurearea, string classname, string message);
    public abstract virtual void TraceRawConditionally(int tracepoint, TraceLevel level, string featurearea, string classname, Func`1<string> message);
}
public abstract class Microsoft.VisualStudio.Services.CircuitBreaker.ImmutableKey : object {
    private string name;
    public string Name { get; }
    protected ImmutableKey(string name);
    public string get_Name();
    public static bool op_Equality(ImmutableKey left, ImmutableKey right);
    public static bool op_Inequality(ImmutableKey left, ImmutableKey right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual bool Equals(ImmutableKey other);
}
public interface Microsoft.VisualStudio.Services.CircuitBreaker.IRollingNumber {
    public abstract virtual int GetTotalWindowTimeInMilliseconds();
    public abstract virtual int GetNumberOfBuckets();
    public abstract virtual int GetBucketSizeInMilliseconds();
    public abstract virtual void Reset();
    public abstract virtual long GetRollingSum();
    public abstract virtual void Increment();
}
public interface Microsoft.VisualStudio.Services.CircuitBreaker.ITime {
    public abstract virtual long GetCurrentTimeInMillis();
}
internal class Microsoft.VisualStudio.Services.CircuitBreaker.ITimeDefault : object {
    public static ITimeDefault Instance;
    private Stopwatch stopwatch;
    private static ITimeDefault();
    public sealed virtual long GetCurrentTimeInMillis();
}
public interface Microsoft.VisualStudio.Services.CircuitBreaker.ITryableSemaphore {
    public abstract virtual bool TryAcquire(int numberOfPermits);
    public abstract virtual void Release();
    public abstract virtual int GetNumberOfPermitsUsed();
}
public class Microsoft.VisualStudio.Services.CircuitBreaker.RollingNumber : object {
    private object newBucketLock;
    private ITime time;
    private int bucketSizeInMilliseconds;
    private int numberOfBuckets;
    private Bucket[] buckets;
    private int CurrentBucketIndex;
    internal Bucket[] Buckets { get; }
    internal RollingNumber(ITime time, int timeInMilliseconds, int numberOfBuckets);
    public sealed virtual int GetTotalWindowTimeInMilliseconds();
    public sealed virtual int GetNumberOfBuckets();
    public sealed virtual int GetBucketSizeInMilliseconds();
    internal Bucket[] get_Buckets();
    public sealed virtual void Reset();
    public sealed virtual long GetRollingSum();
    public sealed virtual void Increment();
    internal int GetCurrentBucketIndex();
}
public class Microsoft.VisualStudio.Services.CircuitBreaker.RollingNumberNoOpImpl : object {
    public sealed virtual int GetTotalWindowTimeInMilliseconds();
    public sealed virtual int GetNumberOfBuckets();
    public sealed virtual int GetBucketSizeInMilliseconds();
    public sealed virtual void Reset();
    public sealed virtual long GetRollingSum();
    public sealed virtual void Increment();
}
public class Microsoft.VisualStudio.Services.CircuitBreaker.TryableSemaphore : object {
    private AtomicLong count;
    public sealed virtual bool TryAcquire(int numberOfPermits);
    public sealed virtual void Release();
    public sealed virtual int GetNumberOfPermitsUsed();
}
public class Microsoft.VisualStudio.Services.CircuitBreaker.TryableSemaphoreNoOpImpl : object {
    public sealed virtual bool TryAcquire(int numberOfPermits);
    public sealed virtual void Release();
    public sealed virtual int GetNumberOfPermitsUsed();
}
public static class Microsoft.VisualStudio.Services.Common.AdminConstants : object {
    public static string ServerProcessID;
    public static string ApplicationName;
}
[EditorBrowsableAttribute("1")]
public static class Microsoft.VisualStudio.Services.Common.ArgumentUtility : object {
    private static Regex s_emailPattern;
    private static ArgumentUtility();
    public static void CheckForNull(T var, string varName);
    public static void CheckForNull(Nullable`1<T> var, string varName);
    public static void CheckGenericForNull(object var, string varName);
    public static void CheckForNull(T var, string varName, string expectedServiceArea);
    public static void CheckForNull(Nullable`1<T> var, string varName, string expectedServiceArea);
    public static void CheckGenericForNull(object var, string varName, string expectedServiceArea);
    public static void CheckStringForNullOrEmpty(string stringVar, string stringVarName);
    public static void CheckStringForNullOrEmpty(string stringVar, string stringVarName, string expectedServiceArea);
    public static void CheckForNonnegativeInt(int var, string varName);
    public static void CheckForNonnegativeInt(int var, string varName, string expectedServiceArea);
    public static void CheckForNonPositiveInt(int var, string varName);
    public static void CheckForNonPositiveInt(int var, string varName, string expectedServiceArea);
    public static void CheckStringForNullOrWhiteSpace(string stringVar, string stringVarName);
    public static void CheckStringForNullOrWhiteSpace(string stringVar, string stringVarName, string expectedServiceArea);
    public static void CheckStringLength(string stringVar, string stringVarName, int maxLength, int minLength, string expectedServiceArea);
    public static void CheckCollectionForMaxLength(ICollection`1<T> collection, string collectionName, int maxLength);
    public static void CheckCollectionForOutOfRange(ICollection`1<T> collection, string collectionName, int minLength, int maxLength);
    public static void CheckEnumerableForNullOrEmpty(IEnumerable enumerable, string enumerableName);
    public static void CheckEnumerableForNullOrEmpty(IEnumerable enumerable, string enumerableName, string expectedServiceArea);
    public static void CheckEnumerableForNullElement(IEnumerable enumerable, string enumerableName);
    public static void CheckEnumerableForNullElement(IEnumerable enumerable, string enumerableName, string expectedServiceArea);
    public static void CheckForEmptyGuid(Guid guid, string varName);
    public static void CheckForEmptyGuid(Nullable`1<Guid> guid, string varName);
    public static void CheckForEmptyGuid(Guid guid, string varName, string expectedServiceArea);
    public static void CheckForEmptyGuid(Nullable`1<Guid> guid, string varName, string expectedServiceArea);
    public static void CheckForMultipleBits(int value, string varName);
    public static void CheckForMultipleBits(int value, string varName, string expectedServiceArea);
    public static void CheckForDefault(T value, string varName);
    public static void CheckForDefault(T value, string varName, string expectedServiceArea);
    public static bool IsIllegalInputCharacter(char c, bool allowCrLf);
    public static bool IsIllegalInputCharacter(char c, bool allowCrLf, bool allowGB18030);
    public static string ReplaceIllegalCharacters(string str, char replaceWith, bool allowCrLf);
    public static void CheckStringForInvalidCharacters(string stringVar, string stringVarName);
    public static void CheckStringForInvalidCharacters(string stringVar, string stringVarName, string expectedServiceArea);
    public static void CheckStringForInvalidCharacters(string stringVar, string stringVarName, bool allowCrLf);
    public static void CheckStringForInvalidCharacters(string stringVar, string stringVarName, bool allowCrLf, string expectedServiceArea);
    public static void CheckStringForInvalidCharacters(string stringVar, string stringVarName, bool allowCrLf, bool allowGB18030, string expectedServiceArea);
    public static void CheckStringForInvalidCharacters(string stringVar, string stringVarName, Char[] invalidCharacters);
    public static void CheckStringForInvalidCharacters(string stringVar, string stringVarName, Char[] invalidCharacters, string expectedServiceArea);
    public static void CheckStringForInvalidSqlEscapeCharacters(string stringVar, string stringVarName, string expectedServiceArea);
    public static void CheckBoundsInclusive(int value, int minValue, int maxValue, string varName);
    public static void CheckBoundsInclusive(int value, int minValue, int maxValue, string varName, string expectedServiceArea);
    public static void CheckForOutOfRange(T var, string varName, T minimum);
    public static void CheckForOutOfRange(T var, string varName, T minimum, string expectedServiceArea);
    public static void CheckForOutOfRange(T var, string varName, T minimum, T maximum);
    public static void CheckForOutOfRange(T var, string varName, T minimum, T maximum, string expectedServiceArea);
    public static void CheckForOutOfRange(int var, string varName, int minimum);
    public static void CheckForOutOfRange(int var, string varName, int minimum, string expectedServiceArea);
    public static void CheckForOutOfRange(int var, string varName, int minimum, int maximum);
    public static void CheckForOutOfRange(int var, string varName, int minimum, int maximum, string expectedServiceArea);
    public static void CheckForOutOfRange(long var, string varName, long minimum);
    public static void CheckForOutOfRange(long var, string varName, long minimum, string expectedServiceArea);
    public static void CheckForOutOfRange(long var, string varName, long minimum, long maximum);
    public static void CheckForOutOfRange(long var, string varName, long minimum, long maximum, string expectedServiceArea);
    public static void CheckForDateTimeRange(DateTime var, string varName, DateTime minimum, DateTime maximum);
    public static void CheckForDateTimeRange(DateTime var, string varName, DateTime minimum, DateTime maximum, string expectedServiceArea);
    public static void CheckGreaterThanOrEqualToZero(float value, string valueName);
    public static void CheckGreaterThanOrEqualToZero(float value, string valueName, string expectedServiceArea);
    public static void CheckGreaterThanZero(float value, string valueName);
    public static void CheckGreaterThanZero(float value, string valueName, string expectedServiceArea);
    public static void EnsureIsNull(object var, string varName);
    public static void EnsureIsNull(object var, string varName, string expectedServiceArea);
    public static void CheckStringCasing(string stringVar, string varName, bool checkForLowercase);
    public static void CheckStringCasing(string stringVar, string varName, bool checkForLowercase, string expectedServiceArea);
    public static void CheckEnumerableForEmpty(IEnumerable enumerable, string enumerableName);
    public static void CheckEnumerableForEmpty(IEnumerable enumerable, string enumerableName, string expectedServiceArea);
    public static void CheckStringExactLength(string stringVar, int length, string stringVarName);
    public static void CheckStringExactLength(string stringVar, int length, string stringVarName, string expectedServiceArea);
    public static void CheckForBothStringsNullOrEmpty(string var1, string varName1, string var2, string varName2);
    public static void CheckForBothStringsNullOrEmpty(string var1, string varName1, string var2, string varName2, string expectedServiceArea);
    public static void CheckStringForAnyWhiteSpace(string stringVar, string stringVarName);
    public static void CheckStringForAnyWhiteSpace(string stringVar, string stringVarName, string expectedServiceArea);
    public static void CheckType(object var, string varName, string typeName);
    public static void CheckType(object var, string varName, string typeName, string expectedServiceArea);
    public static void CheckExactType(object var, string varName, string message);
    public static void CheckExactType(object var, string varName, string message, string expectedServiceArea);
    public static void CheckForDefinedEnum(TEnum value, string enumVarName);
    public static void CheckForDefinedEnum(TEnum value, string enumVarName, string expectedServiceArea);
    public static bool IsValidEmailAddress(string emailAddress);
    public static void CheckEmailAddress(string stringVar, string stringVarName);
    public static void CheckEmailAddress(string stringVar, string stringVarName, string expectedServiceArea);
    public static void CheckIsValidURI(string uriString, UriKind uriKind, string stringVarName);
    public static void CheckValueEqualsToInfinity(float value, string valueName);
    public static void CheckBool(bool actualValue, bool expectedValue, string varName);
    public static void CheckValueEqualsToInfinity(float value, string valueName, string expectedServiceArea);
    public static bool IsInvalidString(string strIn);
    public static bool IsInvalidString(string strIn, bool allowCrLf);
    public static bool IsInvalidString(string strIn, bool allowCrLf, bool allowGB18030);
    public static bool HasSurrogates(string strIn);
    public static bool HasMismatchedSurrogates(string strIn);
    public static void ThrowArgumentNullException(string paramName);
    public static void ThrowArgumentNullException(string paramName, string expectedServiceArea);
    private static void ThrowEmptyStringNotAllowedException(string paramName);
    private static void ThrowEmptyStringNotAllowedException(string paramName, string expectedServiceArea);
    private static void ThrowEmptyOrWhiteSpaceStringNotAllowedException(string paramName);
    private static void ThrowEmptyOrWhiteSpaceStringNotAllowedException(string paramName, string expectedServiceArea);
    private static void ThrowEmptyGuidNotAllowedException(string paramName);
    private static void ThrowEmptyGuidNotAllowedException(string paramName, string expectedServiceArea);
}
public static class Microsoft.VisualStudio.Services.Common.ArrayUtility : object {
    public static bool Equals(Byte[] a1, Byte[] a2);
    public static int GetHashCode(Byte[] array);
    public static bool Equals(Byte[] a1, Byte[] a2, int length);
    public static string StringFromByteArray(Byte[] bytes);
}
public class Microsoft.VisualStudio.Services.Common.Artifact : object {
    private string m_Uri;
    private string m_ArtifactTitle;
    private string m_ExternalId;
    private ExtendedAttribute[] m_ExtendedAttributes;
    private OutboundLink[] m_OutboundLinks;
    public string Uri { get; public set; }
    public string ArtifactTitle { get; public set; }
    public string ExternalId { get; public set; }
    public ExtendedAttribute[] ExtendedAttributes { get; public set; }
    public OutboundLink[] OutboundLinks { get; public set; }
    public string get_Uri();
    public void set_Uri(string value);
    public string get_ArtifactTitle();
    public void set_ArtifactTitle(string value);
    public string get_ExternalId();
    public void set_ExternalId(string value);
    public ExtendedAttribute[] get_ExtendedAttributes();
    public void set_ExtendedAttributes(ExtendedAttribute[] value);
    public OutboundLink[] get_OutboundLinks();
    public void set_OutboundLinks(OutboundLink[] value);
    internal static Artifact FromXml(XmlReader reader);
    internal void ToXml(XmlWriter writer, string element);
    public static Artifact[] ArtifactArrayFromXml(XmlReader reader);
    internal static void ArtifactArrayToXml(XmlWriter writer, string element, Artifact[] array);
}
public class Microsoft.VisualStudio.Services.Common.ArtifactId : object {
    private string m_VisualStudioServerNamespace;
    private string m_Tool;
    private string m_ArtifactType;
    private string m_ToolSpecificId;
    public string VisualStudioServerNamespace { get; public set; }
    public string Tool { get; public set; }
    public string ArtifactType { get; public set; }
    public string ToolSpecificId { get; public set; }
    public ArtifactId(string tool, string artifactType, string specificId);
    public string get_VisualStudioServerNamespace();
    public void set_VisualStudioServerNamespace(string value);
    public string get_Tool();
    public void set_Tool(string value);
    public string get_ArtifactType();
    public void set_ArtifactType(string value);
    public string get_ToolSpecificId();
    public void set_ToolSpecificId(string value);
    public string ToString();
}
public class Microsoft.VisualStudio.Services.Common.ArtifactLink : object {
    private string m_ReferringUri;
    private string m_LinkType;
    private string m_ReferencedUri;
    public string ReferringUri { get; public set; }
    public string LinkType { get; public set; }
    public string ReferencedUri { get; public set; }
    public string get_ReferringUri();
    public void set_ReferringUri(string value);
    public string get_LinkType();
    public void set_LinkType(string value);
    public string get_ReferencedUri();
    public void set_ReferencedUri(string value);
}
[GenerateSpecificConstantsAttribute("")]
public static class Microsoft.VisualStudio.Services.Common.ArtifactTypeNames : object {
    public static string Project;
    public static string Node;
    public static string Collector;
    public static string TestResult;
    [GenerateConstantAttribute("")]
public static string TcmResult;
    [GenerateConstantAttribute("")]
public static string TcmResultAttachment;
    [GenerateConstantAttribute("")]
public static string TcmTest;
    [GenerateConstantAttribute("")]
public static string Build;
    public static string BuildAgent;
    public static string BuildDefinition;
    public static string BuildController;
    public static string BuildGroup;
    public static string BuildRequest;
    public static string BuildServiceHost;
    [GenerateConstantAttribute("")]
public static string VersionedItem;
    [GenerateConstantAttribute("")]
public static string LatestItemVersion;
    [GenerateConstantAttribute("")]
public static string Changeset;
    public static string Label;
    [GenerateConstantAttribute("")]
public static string Shelveset;
    public static string ShelvedItem;
    [GenerateConstantAttribute("")]
public static string WorkItem;
    public static string Query;
    public static string Results;
    public static string LabEnvironment;
    public static string LabTemplate;
    public static string LabSystem;
    public static string TeamProjectHostGroup;
    public static string TeamProjectLibraryShare;
    public static string TeamProjectCollectionLibraryShare;
    public static string TeamProjectCollectionHostGroup;
    public static string TestMachine;
    [GenerateConstantAttribute("")]
public static string Storyboard;
    [GenerateConstantAttribute("")]
public static string Commit;
    public static string LaunchLatestVersionedItem;
    [GenerateConstantAttribute("")]
public static string CodeReviewId;
    [GenerateConstantAttribute("")]
public static string CodeReviewSdkId;
    [GenerateConstantAttribute("")]
public static string PullRequestId;
    [GenerateConstantAttribute("")]
public static string ProjectDownloadProject;
    [GenerateConstantAttribute("")]
public static string Ref;
    public static string TaskAgentPoolMaintenance;
    [GenerateConstantAttribute("")]
public static string WikiPage;
    [GenerateConstantAttribute("")]
public static string PullRequest;
    [GenerateConstantAttribute("")]
public static string Issue;
    [GenerateConstantAttribute("")]
public static string Branch;
}
[EditorBrowsableAttribute("1")]
public static class Microsoft.VisualStudio.Services.Common.BackoffTimerHelper : object {
    private static ThreadLocal`1<Random> s_rnd;
    private static BackoffTimerHelper();
    public static TimeSpan GetRandomBackoff(TimeSpan minBackoff, TimeSpan maxBackoff, Nullable`1<TimeSpan> previousBackoff);
    public static TimeSpan GetExponentialBackoff(int attempt, TimeSpan minBackoff, TimeSpan maxBackoff, TimeSpan deltaBackoff, double radix);
    public static TimeSpan GetExponentialBackoff(int attempt, TimeSpan minBackoff, TimeSpan maxBackoff, TimeSpan deltaBackoff);
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Services.Common.Base32Encoder : object {
    private static byte m_padNdx;
    private static byte m_bitmask;
    private static Char[] m_rgEncodingChars;
    private static Base32Encoder();
    [ExtensionAttribute]
public static string ToBase32String(Byte[] rgbData);
    [ExtensionAttribute]
public static Byte[] FromBase32String(string base32String);
    public static string Encode(Byte[] rgbData);
    public static Byte[] Decode(string base32String);
    private static int GetTokenCount(Byte[] rgbData);
    private static int GetByteCount(string szEncoded);
    private static char GetToken(Byte[] rgbData, int index);
}
internal class Microsoft.VisualStudio.Services.Common.BasicAuthTokenProvider : IssuedTokenProvider {
    protected string AuthenticationScheme { get; }
    public VssBasicCredential Credential { get; }
    public bool GetTokenIsInteractive { get; }
    public BasicAuthTokenProvider(VssBasicCredential credential, Uri serverUrl);
    protected virtual string get_AuthenticationScheme();
    public VssBasicCredential get_Credential();
    public virtual bool get_GetTokenIsInteractive();
}
[EditorBrowsableAttribute("1")]
public enum Microsoft.VisualStudio.Services.Common.CachedCredentialsType : Enum {
    public int value__;
    public static CachedCredentialsType Windows;
    public static CachedCredentialsType ServiceIdentity;
    public static CachedCredentialsType Basic;
    public static CachedCredentialsType Other;
    public static CachedCredentialsType OAuth;
}
[EditorBrowsableAttribute("1")]
public interface Microsoft.VisualStudio.Services.Common.ClientStorage.IVssClientStorage {
    public char PathSeparator { get; }
    public abstract virtual string PathKeyCombine(String[] paths);
    public abstract virtual char get_PathSeparator();
}
public interface Microsoft.VisualStudio.Services.Common.ClientStorage.IVssClientStorageReader {
    public abstract virtual T ReadEntry(string path);
    public abstract virtual T ReadEntry(string path, T defaultValue);
    public abstract virtual IDictionary`2<string, T> ReadEntries(string path);
}
public interface Microsoft.VisualStudio.Services.Common.ClientStorage.IVssClientStorageWriter {
    public abstract virtual void WriteEntry(string path, object value);
    public abstract virtual void WriteEntries(IEnumerable`1<KeyValuePair`2<string, object>> entries);
}
[EditorBrowsableAttribute("1")]
public class Microsoft.VisualStudio.Services.Common.ClientStorage.VssClientStorage : object {
    public static IVssClientStorage CurrentUserSettings { get; }
    public static IVssClientStorage VersionedCurrentUserSettings { get; }
    public static IVssClientStorage get_CurrentUserSettings();
    public static IVssClientStorage get_VersionedCurrentUserSettings();
}
[EditorBrowsableAttribute("1")]
public class Microsoft.VisualStudio.Services.Common.ClientStorage.VssFileStorage : object {
    private string m_filePath;
    private VssFileStorageReader m_reader;
    private IVssClientStorageWriter m_writer;
    private static char c_defaultPathSeparator;
    private static bool c_defaultIgnoreCaseInPaths;
    [CompilerGeneratedAttribute]
private char <PathSeparator>k__BackingField;
    [CompilerGeneratedAttribute]
private StringComparer <PathComparer>k__BackingField;
    private static ConcurrentDictionary`2<string, VssFileStorage> s_storages;
    public char PathSeparator { get; }
    public StringComparer PathComparer { get; }
    internal static string ClientSettingsDirectoryByVersion { get; }
    internal static string ClientSettingsDirectory { get; }
    private VssFileStorage(string filePath, char pathSeparatorForKeys, bool ignoreCaseInPaths);
    private static VssFileStorage();
    [CompilerGeneratedAttribute]
public sealed virtual char get_PathSeparator();
    [CompilerGeneratedAttribute]
public StringComparer get_PathComparer();
    public sealed virtual T ReadEntry(string path);
    public sealed virtual T ReadEntry(string path, T defaultValue);
    public sealed virtual IDictionary`2<string, T> ReadEntries(string pathPrefix);
    public sealed virtual void WriteEntries(IEnumerable`1<KeyValuePair`2<string, object>> entries);
    public sealed virtual void WriteEntry(string key, object value);
    public sealed virtual void Dispose();
    public sealed virtual string PathKeyCombine(String[] paths);
    public static IVssClientStorage GetVssLocalFileStorage(string fullPath, char pathSeparatorForKeys, bool ignoreCaseInPaths);
    private static StringComparer GetAppropriateStringComparer(bool ignoreCase);
    public static IVssClientStorage GetCurrentUserVssFileStorage(string pathSuffix, bool storeByVssVersion, char pathSeparatorForKeys, bool ignoreCaseInPaths);
    internal static string get_ClientSettingsDirectoryByVersion();
    internal static string get_ClientSettingsDirectory();
    private static string SafeGetFolderPath(SpecialFolder specialFolder);
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Services.Common.CollectionsExtensions : object {
    [ExtensionAttribute]
public static TCollection AddRange(TCollection collection, IEnumerable`1<T> values);
    [ExtensionAttribute]
public static TCollection AddRangeIfRangeNotNull(TCollection collection, IEnumerable`1<T> values);
    [ExtensionAttribute]
public static TCollection Add(TCollection destination, IEnumerable`1<TItem> source);
}
[DebuggerDisplayAttribute("{Option != null ? /Option.Name + ":" : "(positional)",nq}{Value != null ? Value.ToString() : "",nq}")]
public class Microsoft.VisualStudio.Services.Common.CommandLine.Argument : object {
    [CompilerGeneratedAttribute]
private Option <Option>k__BackingField;
    [CompilerGeneratedAttribute]
private OptionMetadata <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public Option Option { get; private set; }
    public OptionMetadata Metadata { get; internal set; }
    public object Value { get; public set; }
    public Argument(object value);
    public Argument(Option description);
    public Argument(object value, OptionMetadata metadata);
    public Argument(Option description, OptionMetadata metadata);
    public Argument(Option description, object value);
    public Argument(Option description, object value, OptionMetadata metadata);
    [CompilerGeneratedAttribute]
public Option get_Option();
    [CompilerGeneratedAttribute]
private void set_Option(Option value);
    [CompilerGeneratedAttribute]
public OptionMetadata get_Metadata();
    [CompilerGeneratedAttribute]
internal void set_Metadata(OptionMetadata value);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(object value);
}
public class Microsoft.VisualStudio.Services.Common.CommandLine.AttributeBasedOperationModeHandlerFactory : OperationHandlerFactory {
    private static ICollection`1<KeyValuePair`2<OperationModeAttribute, Type>> handlerTypes;
    private static object staticSyncRoot;
    private IEnumerable`1<Assembly> operationHandlerAssemblies;
    public AttributeBasedOperationModeHandlerFactory(Assembly assembly);
    public AttributeBasedOperationModeHandlerFactory(IEnumerable`1<Assembly> assemblies);
    private static AttributeBasedOperationModeHandlerFactory();
    public virtual OperationHandler CreateHandler(IEnumerable`1<string> args);
    public virtual OperationHandler CreateHandler(IEnumerable`1<string> args, Object[] constructorArgs);
    protected Type GetHandler(IEnumerable`1<string> args, ICollection`1<KeyValuePair`2<OperationModeAttribute, Type>> attributedHandlerTypes);
    protected virtual Type GetDefaultHandler(ICollection`1<KeyValuePair`2<OperationModeAttribute, Type>> attributedHandlerTypes);
    private ICollection`1<KeyValuePair`2<OperationModeAttribute, Type>> GetAttributedHandlerTypes();
    private static OperationHandler CreateOperationHandler(Type handlerType, Object[] constructorArgs);
    private static OperationModeAttribute GetOperationModeAttribute(Type assemblyType);
    private static bool IsMatch(OperationModeAttribute modeAttribute, IEnumerable`1<string> args);
}
public class Microsoft.VisualStudio.Services.Common.CommandLine.AttributeBasedOptionParserAdapter : object {
    public static BindingFlags SupportedMemberBindings;
    private static Type defaultConversionType;
    private OptionParser optionParser;
    public AttributeBasedOptionParserAdapter(OptionParser parser);
    private static AttributeBasedOptionParserAdapter();
    public T Parse(IEnumerable`1<string> commandLine);
    public T Parse(IEnumerable`1<string> commandLine, IEnumerable`1<IOptionValidation> optionValidators);
    public object Parse(object attributedTypeInstance, IEnumerable`1<string> commandLine);
    public object Parse(object attributedTypeInstance, IEnumerable`1<string> commandLine, IEnumerable`1<IOptionValidation> optionValidators);
    protected static ICollection`1<KeyValuePair`2<MemberInfo, Option>> CreateOptionsFromMembersWithAttributes(ICollection`1<KeyValuePair`2<MemberInfo, OptionAttributeBase>> attributedMembers);
    protected static ICollection`1<KeyValuePair`2<MemberInfo, OptionAttributeBase>> GetMembersWithAttributes(Type type);
    private static void AddCollectionMemberValue(MemberInfo member, Argument argument, object classInstance);
    private static OptionAttributeBase GetOptionAttribute(MemberInfo member);
    private static Type GetConversionType(MemberInfo member, OptionAttributeBase attribute);
    private static void SetMemberValue(MemberInfo member, Argument argument, object classInstance);
    private static void ValidateCollectionMemberRequirements(ICollection`1<KeyValuePair`2<MemberInfo, OptionAttributeBase>> attributedMembers, object classInstance);
    private static void ValidateNoDuplicatePositionalAttributes(ICollection`1<KeyValuePair`2<MemberInfo, OptionAttributeBase>> attributedMembers);
}
public class Microsoft.VisualStudio.Services.Common.CommandLine.BasicParser : OptionParser {
    private PositionalOption positionalOption;
    private Argument lastOptionArgument;
    private OptionReader responseFileReader;
    private Collection`1<Argument> parsedArguments;
    protected OptionReader ResponseFileReader { get; }
    public BasicParser(OptionReader responseFileRetriever);
    protected OptionReader get_ResponseFileReader();
    public virtual IEnumerable`1<Argument> Parse(IEnumerable`1<string> commandLine, IEnumerable`1<Option> options);
    public virtual IEnumerable`1<Argument> Parse(IEnumerable`1<string> commandLine, IEnumerable`1<Option> options, IEnumerable`1<IOptionValidation> optionValidators);
    private bool ArePositionalArgumentsSupported(IEnumerable`1<Option> options, PositionalOption& positionalOption);
    private bool DeriveOption(string value, IEnumerable`1<Option> options);
    private bool DeriveOptionRun(string value, IEnumerable`1<Option> options);
    protected virtual bool DerivePositionalOption(string value);
    private void ExpandInlineOption(string commandLineValue, Collection`1<string> expandedOptions, IEnumerable`1<Option> options);
    private IEnumerable`1<string> ExpandOptions(IEnumerable`1<string> commandLine, IEnumerable`1<Option> options);
    private void ExpandResponseFileOption(string commandLineValue, Collection`1<string> expandedOptions, IEnumerable`1<Option> options);
    private bool SetLastOptionValue(string value);
    private bool SetLastOptionDefaultValue();
    private static string TrimValue(string value);
}
public class Microsoft.VisualStudio.Services.Common.CommandLine.BooleanConverter : ValueConverter {
    protected Type ResultType { get; }
    protected virtual Type get_ResultType();
    protected virtual object ConvertValue(string value);
}
public class Microsoft.VisualStudio.Services.Common.CommandLine.ByteConverter : ValueConverter {
    protected Type ResultType { get; }
    protected virtual Type get_ResultType();
    protected virtual object ConvertValue(string value);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.Services.Common.CommandLine.CommandLineLexer : object {
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Services.Common.CommandLine.CommandLineLexer/<Lex>d__2")]
[ExtensionAttribute]
public static IEnumerable`1<string> Lex(string commandLine);
    public static IEnumerable`1<string> Lex();
    public static string Escape(IEnumerable`1<string> arguments);
}
public class Microsoft.VisualStudio.Services.Common.CommandLine.CsvCollectionConverter`1 : ValueConverter {
    protected Type ResultType { get; }
    protected virtual Type get_ResultType();
    protected virtual object ConvertValue(string value);
}
public class Microsoft.VisualStudio.Services.Common.CommandLine.DateTimeConverter : ValueConverter {
    protected Type ResultType { get; }
    protected virtual Type get_ResultType();
    protected virtual object ConvertValue(string value);
}
public class Microsoft.VisualStudio.Services.Common.CommandLine.DateTimeOffsetConverter : ValueConverter {
    protected Type ResultType { get; }
    protected virtual Type get_ResultType();
    protected virtual object ConvertValue(string value);
}
public class Microsoft.VisualStudio.Services.Common.CommandLine.DecimalConverter : ValueConverter {
    protected Type ResultType { get; }
    protected virtual Type get_ResultType();
    protected virtual object ConvertValue(string value);
}
[ExceptionMappingAttribute("0.0", "3.0", "DefaultValueConverterNotFoundException", "Microsoft.VisualStudio.Services.Common.CommandLine.DefaultValueConverterNotFoundException, Microsoft.VisualStudio.Services.Common, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class Microsoft.VisualStudio.Services.Common.CommandLine.DefaultValueConverterNotFoundException : OptionValidationException {
    public DefaultValueConverterNotFoundException(string message);
    public DefaultValueConverterNotFoundException(string message, Exception innerException);
    protected DefaultValueConverterNotFoundException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.VisualStudio.Services.Common.CommandLine.DoubleConverter : ValueConverter {
    protected Type ResultType { get; }
    protected virtual Type get_ResultType();
    protected virtual object ConvertValue(string value);
}
[ExceptionMappingAttribute("0.0", "3.0", "DuplicateOperationHandlerException", "Microsoft.VisualStudio.Services.Common.CommandLine.DuplicateOperationHandlerException, Microsoft.VisualStudio.Services.Common, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class Microsoft.VisualStudio.Services.Common.CommandLine.DuplicateOperationHandlerException : Exception {
    public DuplicateOperationHandlerException(string message);
    public DuplicateOperationHandlerException(string message, Exception innerException);
    protected DuplicateOperationHandlerException(SerializationInfo info, StreamingContext context);
}
[ExceptionMappingAttribute("0.0", "3.0", "DuplicatePositionalOptionAttributeException", "Microsoft.VisualStudio.Services.Common.CommandLine.DuplicatePositionalOptionAttributeException, Microsoft.VisualStudio.Services.Common, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class Microsoft.VisualStudio.Services.Common.CommandLine.DuplicatePositionalOptionAttributeException : OptionValidationException {
    public DuplicatePositionalOptionAttributeException(string message);
    public DuplicatePositionalOptionAttributeException(string message, Exception innerException);
    protected DuplicatePositionalOptionAttributeException(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.VisualStudio.Services.Common.CommandLine.EnumConverter : ValueConverter {
    private Type enumValueType;
    protected Type ResultType { get; }
    public EnumConverter(Type enumType);
    protected virtual Type get_ResultType();
    protected virtual object ConvertValue(string value);
}
public class Microsoft.VisualStudio.Services.Common.CommandLine.EnumConverter`1 : ValueConverter {
    private EnumConverter internalConverter;
    protected Type ResultType { get; }
    protected virtual Type get_ResultType();
    protected virtual object ConvertValue(string value);
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Services.Common.CommandLine.ExtensionsMethods : object {
    [ExtensionAttribute]
public static bool Contains(IEnumerable`1<Option> options, String[] optionNames);
    [ExtensionAttribute]
public static bool Contains(IEnumerable`1<Argument> arguments, String[] optionNames);
    [ExtensionAttribute]
public static bool Contains(IEnumerable`1<Argument> arguments, Option[] options);
    [ExtensionAttribute]
public static bool ContainsAny(IEnumerable`1<Argument> arguments, String[] optionNames);
    [ExtensionAttribute]
public static bool ContainsAny(IEnumerable`1<Argument> arguments, Option[] options);
    [ExtensionAttribute]
public static bool ContainsHelp(IEnumerable`1<Argument> arguments);
    [ExtensionAttribute]
public static Option Get(IEnumerable`1<Option> options, string optionName);
    [ExtensionAttribute]
public static Option GetByShortName(IEnumerable`1<Option> options, string shortName);
    [ExtensionAttribute]
public static Option GetByShortName(IEnumerable`1<Option> options, char shortName);
    [ExtensionAttribute]
public static Argument Get(IEnumerable`1<Argument> arguments, string optionName);
    [ExtensionAttribute]
public static Argument Get(IEnumerable`1<Argument> arguments, Option option);
    [ExtensionAttribute]
public static IEnumerable`1<Argument> GetAll(IEnumerable`1<Argument> arguments, string optionName);
    [ExtensionAttribute]
public static IEnumerable`1<Argument> GetAll(IEnumerable`1<Argument> arguments, Option option);
    [ExtensionAttribute]
public static IEnumerable`1<Argument> GetPositionalArguments(IEnumerable`1<Argument> arguments);
    [ExtensionAttribute]
public static string GetUsage(IEnumerable`1<Option> options, string applicationName, Version applicationVersion);
    [ExtensionAttribute]
public static void Validate(IEnumerable`1<Option> options, IEnumerable`1<Argument> arguments);
    [ExtensionAttribute]
public static void Validate(IEnumerable`1<Option> options, IEnumerable`1<Argument> arguments, IEnumerable`1<IOptionValidation> dependencies);
    [ExtensionAttribute]
public static object ValueOf(IEnumerable`1<Argument> arguments, string optionName);
    [ExtensionAttribute]
public static object ValueOf(IEnumerable`1<Argument> arguments, Option option);
    [ExtensionAttribute]
public static T ValueOf(IEnumerable`1<Argument> arguments, string optionName);
    [ExtensionAttribute]
public static T ValueOf(IEnumerable`1<Argument> arguments, Option option);
    [ExtensionAttribute]
public static IEnumerable`1<object> ValueOfAll(IEnumerable`1<Argument> arguments, string optionName);
    [ExtensionAttribute]
public static IEnumerable`1<object> ValueOfAll(IEnumerable`1<Argument> arguments, Option option);
    [ExtensionAttribute]
public static IEnumerable`1<T> ValueOfAll(IEnumerable`1<Argument> arguments, string optionName);
    [ExtensionAttribute]
public static IEnumerable`1<T> ValueOfAll(IEnumerable`1<Argument> arguments, Option option);
    private static string GetSeparatorLine(int length);
    private static string GetUsageHeader(IEnumerable`1<Option> options, string applicationName, Version applicationVersion);
    private static string GetUsageBody(IEnumerable`1<Option> options);
}
public class Microsoft.VisualStudio.Services.Common.CommandLine.GuidConverter : ValueConverter {
    protected Type ResultType { get; }
    protected virtual Type get_ResultType();
    protected virtual object ConvertValue(string value);
}
internal interface Microsoft.VisualStudio.Services.Common.CommandLine.IEnumerable`2 {
}
public class Microsoft.VisualStudio.Services.Common.CommandLine.Int16Converter : ValueConverter {
    protected Type ResultType { get; }
    protected virtual Type get_ResultType();
    protected virtual object ConvertValue(string value);
}
public class Microsoft.VisualStudio.Services.Common.CommandLine.Int32Converter : ValueConverter {
    protected Type ResultType { get; }
    protected virtual Type get_ResultType();
    protected virtual object ConvertValue(string value);
}
public class Microsoft.VisualStudio.Services.Common.CommandLine.Int64Converter : ValueConverter {
    protected Type ResultType { get; }
    protected virtual Type get_ResultType();
    protected virtual object ConvertValue(string value);
}
public interface Microsoft.VisualStudio.Services.Common.CommandLine.IPositionalValueConvertor {
}
public interface Microsoft.VisualStudio.Services.Common.CommandLine.IValueConvertible {
    public abstract virtual object Convert(string value);
}
public class Microsoft.VisualStudio.Services.Common.CommandLine.NoValueConverter : ValueConverter {
    protected Type ResultType { get; }
    protected virtual Type get_ResultType();
    protected virtual object ConvertValue(string value);
}
public class Microsoft.VisualStudio.Services.Common.CommandLine.NullableBooleanConverter : ValueConverter {
    protected Type ResultType { get; }
    protected virtual Type get_ResultType();
    protected virtual object ConvertValue(string value);
}
public class Microsoft.VisualStudio.Services.Common.CommandLine.NullableByteConverter : ValueConverter {
    protected Type ResultType { get; }
    protected virtual Type get_ResultType();
    protected virtual object ConvertValue(string value);
}
public class Microsoft.VisualStudio.Services.Common.CommandLine.NullableDateTimeConverter : ValueConverter {
    protected Type ResultType { get; }
    protected virtual Type get_ResultType();
    protected virtual object ConvertValue(string value);
}
public class Microsoft.VisualStudio.Services.Common.CommandLine.NullableDateTimeOffsetConverter : ValueConverter {
    protected Type ResultType { get; }
    protected virtual Type get_ResultType();
    protected virtual object ConvertValue(string value);
}
public class Microsoft.VisualStudio.Services.Common.CommandLine.NullableInt16Converter : ValueConverter {
    protected Type ResultType { get; }
    protected virtual Type get_ResultType();
    protected virtual object ConvertValue(string value);
}
public class Microsoft.VisualStudio.Services.Common.CommandLine.NullableInt32Converter : ValueConverter {
    protected Type ResultType { get; }
    protected virtual Type get_ResultType();
    protected virtual object ConvertValue(string value);
}
public class Microsoft.VisualStudio.Services.Common.CommandLine.NullableInt64Converter : ValueConverter {
    protected Type ResultType { get; }
    protected virtual Type get_ResultType();
    protected virtual object ConvertValue(string value);
}
public class Microsoft.VisualStudio.Services.Common.CommandLine.NullableTimeSpanConverter : ValueConverter {
    protected Type ResultType { get; }
    protected virtual Type get_ResultType();
    protected virtual object ConvertValue(string value);
}
public class Microsoft.VisualStudio.Services.Common.CommandLine.NullableUInt16Converter : ValueConverter {
    protected Type ResultType { get; }
    protected virtual Type get_ResultType();
    protected virtual object ConvertValue(string value);
}
public class Microsoft.VisualStudio.Services.Common.CommandLine.NullableUInt32Converter : ValueConverter {
    protected Type ResultType { get; }
    protected virtual Type get_ResultType();
    protected virtual object ConvertValue(string value);
}
public class Microsoft.VisualStudio.Services.Common.CommandLine.NullableUInt64Converter : ValueConverter {
    protected Type ResultType { get; }
    protected virtual Type get_ResultType();
    protected virtual object ConvertValue(string value);
}
public abstract class Microsoft.VisualStudio.Services.Common.CommandLine.OperationHandler : object {
    public sealed virtual void Dispose();
    public abstract virtual void Execute(IEnumerable`1<string> args);
    protected virtual void Dispose(bool disposing);
}
public abstract class Microsoft.VisualStudio.Services.Common.CommandLine.OperationHandlerFactory : object {
    public abstract virtual OperationHandler CreateHandler(IEnumerable`1<string> args);
    public abstract virtual OperationHandler CreateHandler(IEnumerable`1<string> args, Object[] constructorArgs);
}
[ExceptionMappingAttribute("0.0", "3.0", "OperationHandlerNotFoundException", "Microsoft.VisualStudio.Services.Common.CommandLine.OperationHandlerNotFoundException, Microsoft.VisualStudio.Services.Common, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class Microsoft.VisualStudio.Services.Common.CommandLine.OperationHandlerNotFoundException : Exception {
    public OperationHandlerNotFoundException(string message);
    public OperationHandlerNotFoundException(string message, Exception innerException);
    protected OperationHandlerNotFoundException(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("4")]
public class Microsoft.VisualStudio.Services.Common.CommandLine.OperationModeAttribute : Attribute {
    public static StringComparison DefaultCaseSensitivity;
    [CompilerGeneratedAttribute]
private StringComparison <CaseSensitivity>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDefault>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public StringComparison CaseSensitivity { get; public set; }
    public bool IsDefault { get; public set; }
    public string Name { get; public set; }
    public OperationModeAttribute(string name);
    public OperationModeAttribute(string name, StringComparison caseSensitivity);
    private static OperationModeAttribute();
    [CompilerGeneratedAttribute]
public StringComparison get_CaseSensitivity();
    [CompilerGeneratedAttribute]
public void set_CaseSensitivity(StringComparison value);
    [CompilerGeneratedAttribute]
public bool get_IsDefault();
    [CompilerGeneratedAttribute]
public void set_IsDefault(bool value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public IEnumerable`1<string> Split();
}
[DebuggerDisplayAttribute("{Name,nq}")]
public class Microsoft.VisualStudio.Services.Common.CommandLine.Option : object {
    internal static string DoubleDashSwitch;
    internal static string SingleDashSwitch;
    internal static string SlashSwitch;
    public static OptionArgumentType DefaultArgumentType;
    public static StringComparison DefaultCaseSensitivity;
    public static OptionType DefaultOptionType;
    public static string HelpOptionName;
    public static String[] StandardSwitches;
    public static String[] StandardHelpOptions;
    public static Char[] StandardArgumentDelimiters;
    private static string hasStandardSwitchPattern;
    [CompilerGeneratedAttribute]
private bool <AllowMultiple>k__BackingField;
    [CompilerGeneratedAttribute]
private OptionArgumentType <ArgumentType>k__BackingField;
    [CompilerGeneratedAttribute]
private StringComparison <CaseSensitivity>k__BackingField;
    [CompilerGeneratedAttribute]
private IValueConvertible <Converter>k__BackingField;
    [CompilerGeneratedAttribute]
private object <DefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private OptionType <OptionType>k__BackingField;
    [CompilerGeneratedAttribute]
private char <ShortName>k__BackingField;
    public bool AllowMultiple { get; public set; }
    public OptionArgumentType ArgumentType { get; public set; }
    public StringComparison CaseSensitivity { get; public set; }
    public IValueConvertible Converter { get; public set; }
    public object DefaultValue { get; public set; }
    public string Description { get; public set; }
    public bool HasShortName { get; }
    public bool IsHelp { get; }
    public string Name { get; public set; }
    public OptionType OptionType { get; public set; }
    public char ShortName { get; public set; }
    public string ShortNameString { get; }
    private static Option();
    public Option(string name);
    public Option(string name, char shortName);
    [CompilerGeneratedAttribute]
public bool get_AllowMultiple();
    [CompilerGeneratedAttribute]
public void set_AllowMultiple(bool value);
    [CompilerGeneratedAttribute]
public OptionArgumentType get_ArgumentType();
    [CompilerGeneratedAttribute]
public void set_ArgumentType(OptionArgumentType value);
    [CompilerGeneratedAttribute]
public StringComparison get_CaseSensitivity();
    [CompilerGeneratedAttribute]
public void set_CaseSensitivity(StringComparison value);
    [CompilerGeneratedAttribute]
public IValueConvertible get_Converter();
    [CompilerGeneratedAttribute]
public void set_Converter(IValueConvertible value);
    [CompilerGeneratedAttribute]
public object get_DefaultValue();
    [CompilerGeneratedAttribute]
public void set_DefaultValue(object value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    public bool get_HasShortName();
    public bool get_IsHelp();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public OptionType get_OptionType();
    [CompilerGeneratedAttribute]
public void set_OptionType(OptionType value);
    [CompilerGeneratedAttribute]
public char get_ShortName();
    [CompilerGeneratedAttribute]
public void set_ShortName(char value);
    public string get_ShortNameString();
    public static Option CreateHelpOption();
    public static bool HasHelpOption(IEnumerable`1<string> args);
    public static bool HasOption(IEnumerable`1<string> args, string option);
    public static bool HasOption(IEnumerable`1<string> args, string option, StringComparison comparisonType);
    public static bool HasSwitch(string value);
    public static bool IsHelpOption(string option);
    public static string RemoveSwitch(string option);
}
public enum Microsoft.VisualStudio.Services.Common.CommandLine.OptionArgumentType : Enum {
    public int value__;
    public static OptionArgumentType None;
    public static OptionArgumentType Optional;
    public static OptionArgumentType Required;
}
[DebuggerDisplayAttribute("{Name,nq}")]
public class Microsoft.VisualStudio.Services.Common.CommandLine.OptionAttribute : OptionAttributeBase {
    [CompilerGeneratedAttribute]
private bool <AllowMultiple>k__BackingField;
    [CompilerGeneratedAttribute]
private OptionArgumentType <ArgumentType>k__BackingField;
    [CompilerGeneratedAttribute]
private StringComparison <CaseSensitivity>k__BackingField;
    [CompilerGeneratedAttribute]
private object <DefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private OptionType <OptionType>k__BackingField;
    [CompilerGeneratedAttribute]
private char <ShortName>k__BackingField;
    public bool AllowMultiple { get; public set; }
    public OptionArgumentType ArgumentType { get; public set; }
    public StringComparison CaseSensitivity { get; public set; }
    public object DefaultValue { get; public set; }
    public string Description { get; public set; }
    public OptionType OptionType { get; public set; }
    public char ShortName { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_AllowMultiple();
    [CompilerGeneratedAttribute]
public void set_AllowMultiple(bool value);
    [CompilerGeneratedAttribute]
public OptionArgumentType get_ArgumentType();
    [CompilerGeneratedAttribute]
public void set_ArgumentType(OptionArgumentType value);
    [CompilerGeneratedAttribute]
public StringComparison get_CaseSensitivity();
    [CompilerGeneratedAttribute]
public void set_CaseSensitivity(StringComparison value);
    [CompilerGeneratedAttribute]
public object get_DefaultValue();
    [CompilerGeneratedAttribute]
public void set_DefaultValue(object value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public OptionType get_OptionType();
    [CompilerGeneratedAttribute]
public void set_OptionType(OptionType value);
    [CompilerGeneratedAttribute]
public char get_ShortName();
    [CompilerGeneratedAttribute]
public void set_ShortName(char value);
    public virtual Option ToOption(IValueConvertible valueConverter);
}
[DebuggerDisplayAttribute("{Name,nq}")]
[AttributeUsageAttribute("384")]
public abstract class Microsoft.VisualStudio.Services.Common.CommandLine.OptionAttributeBase : Attribute {
    public static Type DefaultValueConverterType;
    private Type valueConverterType;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public Type ConverterType { get; public set; }
    public string Name { get; public set; }
    private static OptionAttributeBase();
    public Type get_ConverterType();
    public void set_ConverterType(Type value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public abstract virtual Option ToOption(IValueConvertible valueConverter);
    internal static bool RequiresCollectionMember(OptionAttributeBase attribute);
}
[ExceptionMappingAttribute("0.0", "3.0", "OptionException", "Microsoft.VisualStudio.Services.Common.CommandLine.OptionException, Microsoft.VisualStudio.Services.Common, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class Microsoft.VisualStudio.Services.Common.CommandLine.OptionException : ArgumentException {
    public OptionException(string message);
    public OptionException(string message, Exception innerException);
    protected OptionException(SerializationInfo info, StreamingContext context);
}
[FlagsAttribute]
public enum Microsoft.VisualStudio.Services.Common.CommandLine.OptionMetadata : Enum {
    public int value__;
    public static OptionMetadata None;
    public static OptionMetadata DefaultValue;
    public static OptionMetadata OptionRun;
    public static OptionMetadata Positional;
}
[ExceptionMappingAttribute("0.0", "3.0", "OptionNotFoundException", "Microsoft.VisualStudio.Services.Common.CommandLine.OptionNotFoundException, Microsoft.VisualStudio.Services.Common, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class Microsoft.VisualStudio.Services.Common.CommandLine.OptionNotFoundException : ArgumentException {
    public OptionNotFoundException(string message);
    public OptionNotFoundException(string message, Exception innerException);
    protected OptionNotFoundException(SerializationInfo info, StreamingContext context);
}
public abstract class Microsoft.VisualStudio.Services.Common.CommandLine.OptionParser : object {
    public abstract virtual IEnumerable`1<Argument> Parse(IEnumerable`1<string> commandLine, IEnumerable`1<Option> options);
    public abstract virtual IEnumerable`1<Argument> Parse(IEnumerable`1<string> commandLine, IEnumerable`1<Option> options, IEnumerable`1<IOptionValidation> optionValidators);
    public static OptionParser CreateParser();
    public static OptionParser CreateParser(OptionReader responseFileRetriever);
    protected static HashSet`1<string> GetOptionNames(IEnumerable`1<Option> options);
    protected bool IsOptionRun(string value, IEnumerable`1<Option> options, Collection`1& optionRun);
    protected bool IsOption(string value, IEnumerable`1<Option> options);
    protected bool IsResponseFileOption(string value);
    protected string ParseOption(string value, bool includeSwitch);
    protected string ParseOptionArgument(string value);
}
public abstract class Microsoft.VisualStudio.Services.Common.CommandLine.OptionReader : object {
    public static OptionReader DefaultResponseFileOptionRetriever { get; }
    public static OptionReader get_DefaultResponseFileOptionRetriever();
    public abstract virtual IEnumerable`1<string> GetOptions(string value);
}
public enum Microsoft.VisualStudio.Services.Common.CommandLine.OptionType : Enum {
    public int value__;
    public static OptionType Optional;
    public static OptionType Required;
}
[ExceptionMappingAttribute("0.0", "3.0", "OptionValidationException", "Microsoft.VisualStudio.Services.Common.CommandLine.OptionValidationException, Microsoft.VisualStudio.Services.Common, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class Microsoft.VisualStudio.Services.Common.CommandLine.OptionValidationException : OptionException {
    public OptionValidationException(string message);
    public OptionValidationException(string message, Exception innerException);
    protected OptionValidationException(SerializationInfo info, StreamingContext context);
}
[ExceptionMappingAttribute("0.0", "3.0", "OptionValueConversionException", "Microsoft.VisualStudio.Services.Common.CommandLine.OptionValueConversionException, Microsoft.VisualStudio.Services.Common, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class Microsoft.VisualStudio.Services.Common.CommandLine.OptionValueConversionException : OptionValidationException {
    public OptionValueConversionException(string message);
    public OptionValueConversionException(string value, Type valueType);
    public OptionValueConversionException(string message, Exception innerException);
    public OptionValueConversionException(string value, Type valueType, Exception innerException);
    protected OptionValueConversionException(SerializationInfo info, StreamingContext context);
    private static string CreateMessage(string value, Type valueType);
}
public class Microsoft.VisualStudio.Services.Common.CommandLine.PositionalOption : Option {
    public PositionalOption(IValueConvertible valueConverter);
}
public class Microsoft.VisualStudio.Services.Common.CommandLine.PositionalOptionAttribute : OptionAttributeBase {
    public PositionalOptionAttribute(Type converterType);
    public virtual Option ToOption(IValueConvertible valueConverter);
}
public class Microsoft.VisualStudio.Services.Common.CommandLine.ResponseFileOptionReader : OptionReader {
    private static Char[] trimChars;
    private static ResponseFileOptionReader();
    public virtual IEnumerable`1<string> GetOptions(string value);
    protected virtual string ExpandFilePath(string filePath);
    protected virtual IEnumerable`1<string> ReadResponseFileLines(string filePath);
    private static Collection`1<string> ParseResponseFileLines(IEnumerable`1<string> responseFileLines);
    private static void ValidateResponseFileOption(string value, String& validPath);
}
public class Microsoft.VisualStudio.Services.Common.CommandLine.SByteConverter : ValueConverter {
    protected Type ResultType { get; }
    protected virtual Type get_ResultType();
    protected virtual object ConvertValue(string value);
}
public class Microsoft.VisualStudio.Services.Common.CommandLine.SingleConverter : ValueConverter {
    protected Type ResultType { get; }
    protected virtual Type get_ResultType();
    protected virtual object ConvertValue(string value);
}
public class Microsoft.VisualStudio.Services.Common.CommandLine.TimeSpanConverter : ValueConverter {
    protected Type ResultType { get; }
    protected virtual Type get_ResultType();
    protected virtual object ConvertValue(string value);
}
public class Microsoft.VisualStudio.Services.Common.CommandLine.UInt16Converter : ValueConverter {
    protected Type ResultType { get; }
    protected virtual Type get_ResultType();
    protected virtual object ConvertValue(string value);
}
public class Microsoft.VisualStudio.Services.Common.CommandLine.UInt32Converter : ValueConverter {
    protected Type ResultType { get; }
    protected virtual Type get_ResultType();
    protected virtual object ConvertValue(string value);
}
public class Microsoft.VisualStudio.Services.Common.CommandLine.UInt64Converter : ValueConverter {
    protected Type ResultType { get; }
    protected virtual Type get_ResultType();
    protected virtual object ConvertValue(string value);
}
public class Microsoft.VisualStudio.Services.Common.CommandLine.UriConverter : ValueConverter {
    protected Type ResultType { get; }
    protected virtual Type get_ResultType();
    protected virtual object ConvertValue(string value);
}
public class Microsoft.VisualStudio.Services.Common.CommandLine.Validation.DefaultValidation : OptionValidation {
    private static DefaultValidation singletonInstance;
    public static DefaultValidation Instance { get; }
    private static DefaultValidation();
    public static DefaultValidation get_Instance();
    public virtual void Validate(IEnumerable`1<Option> options, IEnumerable`1<Argument> arguments);
    private static void ValidateMultiplesValidIfDefined(IEnumerable`1<Option> options, IEnumerable`1<Argument> arguments);
    private static void ValidateOptionsRequiringValuesHaveValues(IEnumerable`1<Option> options, IEnumerable`1<Argument> arguments);
    private static void ValidateOptionsThatDoNotAllowValues(IEnumerable`1<Option> options, IEnumerable`1<Argument> arguments);
    private static void ValidateRequiredOptionsExist(IEnumerable`1<Option> options, IEnumerable`1<Argument> arguments);
}
public interface Microsoft.VisualStudio.Services.Common.CommandLine.Validation.IOptionValidation {
    public abstract virtual void Validate(IEnumerable`1<Option> options, IEnumerable`1<Argument> arguments);
}
public class Microsoft.VisualStudio.Services.Common.CommandLine.Validation.OptionExistsFilter : OptionValidationFilter {
    public OptionExistsFilter(string dependentOption, OptionValidation dependency);
    public virtual bool ShouldValidate(IEnumerable`1<Option> options, IEnumerable`1<Argument> arguments);
}
public class Microsoft.VisualStudio.Services.Common.CommandLine.Validation.OptionMustExist : OptionValidation {
    public OptionMustExist(string dependentOption);
    public OptionMustExist(string dependentOption, Action`1<OptionValidation> dependencyFailedAction);
    public virtual void Validate(IEnumerable`1<Option> options, IEnumerable`1<Argument> arguments);
    [CompilerGeneratedAttribute]
private void <.ctor>b__0_0(OptionValidation dependency);
}
public class Microsoft.VisualStudio.Services.Common.CommandLine.Validation.OptionRequiresSpecificValue : OptionValidation {
    private Collection`1<IComparable> optionValues;
    public OptionRequiresSpecificValue(string dependentOption, IEnumerable`1<IComparable> values);
    public OptionRequiresSpecificValue(string dependentOption, IEnumerable`1<IComparable> values, Action`1<OptionValidation> dependencyFailedAction);
    public virtual void Validate(IEnumerable`1<Option> options, IEnumerable`1<Argument> arguments);
    private void SetOptionValues(IEnumerable`1<IComparable> values);
    [CompilerGeneratedAttribute]
private void <.ctor>b__1_0(OptionValidation dependency);
}
public class Microsoft.VisualStudio.Services.Common.CommandLine.Validation.OptionsAreMutuallyExclusive : OptionValidation {
    private Collection`1<string> dependencyOptions;
    public OptionsAreMutuallyExclusive(IEnumerable`1<string> dependencyOptions);
    public OptionsAreMutuallyExclusive(IEnumerable`1<string> dependencyOptions, Action`1<OptionValidation> dependencyFailedAction);
    public virtual void Validate(IEnumerable`1<Option> options, IEnumerable`1<Argument> arguments);
    private void SetDependencyOptions(IEnumerable`1<string> options);
    private static bool IsOptionDefined(Option option, IEnumerable`1<Argument> arguments);
    [CompilerGeneratedAttribute]
private void <.ctor>b__1_0(OptionValidation dependency);
}
public class Microsoft.VisualStudio.Services.Common.CommandLine.Validation.OptionsAreMutuallyInclusive : OptionValidation {
    private Collection`1<string> dependencyOptions;
    public OptionsAreMutuallyInclusive(IEnumerable`1<string> dependencyOptions);
    public OptionsAreMutuallyInclusive(IEnumerable`1<string> dependencyOptions, Action`1<OptionValidation> dependencyFailedAction);
    public virtual void Validate(IEnumerable`1<Option> options, IEnumerable`1<Argument> arguments);
    private void SetDependencyOptions(IEnumerable`1<string> options);
    private static bool IsOptionDefined(Option option, IEnumerable`1<Argument> arguments);
    [CompilerGeneratedAttribute]
private void <.ctor>b__1_0(OptionValidation dependency);
}
public abstract class Microsoft.VisualStudio.Services.Common.CommandLine.Validation.OptionValidation : object {
    [CompilerGeneratedAttribute]
private string <DependentOption>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<OptionValidation> <DependencyFailedAction>k__BackingField;
    public string DependentOption { get; public set; }
    public Action`1<OptionValidation> DependencyFailedAction { get; public set; }
    public static OptionValidation Default { get; }
    protected OptionValidation(string dependentOption);
    protected OptionValidation(string dependentOption, Action`1<OptionValidation> dependencyFailedAction);
    [CompilerGeneratedAttribute]
public string get_DependentOption();
    [CompilerGeneratedAttribute]
public void set_DependentOption(string value);
    [CompilerGeneratedAttribute]
public Action`1<OptionValidation> get_DependencyFailedAction();
    [CompilerGeneratedAttribute]
public void set_DependencyFailedAction(Action`1<OptionValidation> value);
    public static OptionValidation get_Default();
    public abstract virtual void Validate(IEnumerable`1<Option> options, IEnumerable`1<Argument> arguments);
}
public abstract class Microsoft.VisualStudio.Services.Common.CommandLine.Validation.OptionValidationFilter : OptionValidation {
    [CompilerGeneratedAttribute]
private IOptionValidation <Dependency>k__BackingField;
    protected IOptionValidation Dependency { get; private set; }
    protected OptionValidationFilter(OptionValidation dependency);
    protected OptionValidationFilter(string dependentOption, OptionValidation dependency);
    [CompilerGeneratedAttribute]
protected IOptionValidation get_Dependency();
    [CompilerGeneratedAttribute]
private void set_Dependency(IOptionValidation value);
    public abstract virtual bool ShouldValidate(IEnumerable`1<Option> options, IEnumerable`1<Argument> arguments);
    public virtual void Validate(IEnumerable`1<Option> options, IEnumerable`1<Argument> arguments);
}
public class Microsoft.VisualStudio.Services.Common.CommandLine.Validation.OptionValueFilter : OptionValidationFilter {
    private Collection`1<IComparable> valueConstraints;
    public OptionValueFilter(string dependentOption, OptionValidation dependency, IEnumerable`1<IComparable> values);
    public virtual bool ShouldValidate(IEnumerable`1<Option> options, IEnumerable`1<Argument> arguments);
    private void SetValueConstraints(IEnumerable`1<IComparable> values);
}
public abstract class Microsoft.VisualStudio.Services.Common.CommandLine.ValueConverter : object {
    public static Type ValueConverterAssignableType;
    private static ValueConverter defaultValueConverter;
    private static Collection`1<ValueConverter> defaultConverters;
    protected Type ResultType { get; }
    public static IValueConvertible None { get; }
    private static ValueConverter();
    protected abstract virtual Type get_ResultType();
    public static IValueConvertible get_None();
    public sealed virtual object Convert(string value);
    public static IValueConvertible GetDefaultConverter(Type memberType);
    public static void ValidateConverterType(Type converterType);
    protected abstract virtual object ConvertValue(string value);
}
[EditorBrowsableAttribute("1")]
public static class Microsoft.VisualStudio.Services.Common.CommonPropertyConstants : object {
    public static string Account;
    public static string BeingSerialized;
    public static string CodeReviewItemPath;
    public static string CollectionName;
    public static string Description;
    public static string IdentityFavoritesPrefix;
    public static string ScopeName;
    public static string SystemWiki;
    public static string PropertyValue;
}
public class Microsoft.VisualStudio.Services.Common.ConcurrencyConsolidator`2 : object {
    private ConcurrentDictionary`2[] taskDictionaries;
    private bool consolidateExceptions;
    public ConcurrencyConsolidator`2(bool consolidateExceptions, int boundedConcurrency);
    public ConcurrencyConsolidator`2(bool consolidateExceptions, int boundedConcurrency, IEqualityComparer`1<TKey> comparer);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Services.Common.ConcurrencyConsolidator`2/<RunOnceAsync>d__4")]
public sealed virtual Task`1<TResult> RunOnceAsync(TKey key, Func`1<Task`1<TResult>> taskFunc);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Services.Common.ConcurrencyConsolidator`2/<TryRunInternalAsync>d__5")]
private Task`1<ValueTuple`2<bool, TResult>> TryRunInternalAsync(SynchronizationContext expectedContext, TKey key, Func`1<Task`1<TResult>> taskFunc);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Services.Common.ConcurrencyConsolidator`2/<ExecuteAsync>d__6")]
private static Task`1<TResult> ExecuteAsync(SynchronizationContext expectedContext, ConcurrentDictionary`2<TKey, Task`1<TResult>> taskDictionary, TKey key, Func`1<Task`1<TResult>> taskFunc, SafeTaskCompletionSource`1<TResult> tcs);
    private static void Remove(ConcurrentDictionary`2<TKey, Task`1<TResult>> taskDictionary, TKey key, Task`1<TResult> task);
}
[ExceptionMappingAttribute("0.0", "3.0", "ConfigFileException", "Microsoft.VisualStudio.Services.Common.ConfigFileException, Microsoft.VisualStudio.Services.Common, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class Microsoft.VisualStudio.Services.Common.ConfigFileException : VssException {
    public ConfigFileException(string message);
    public ConfigFileException(string message, Exception innerException);
    protected ConfigFileException(SerializationInfo info, StreamingContext context);
}
[EditorBrowsableAttribute("1")]
public class Microsoft.VisualStudio.Services.Common.ContentIdentification : object {
    private static int m_pagesPerBlock;
    private static int m_bytesPerPage;
    private Byte[] m_blockBuffer;
    private Byte[] m_pageBuffer;
    [CompilerGeneratedAttribute]
private int <PageSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PagesPerBlock>k__BackingField;
    private Byte[] m_startingConstant;
    private SHA256CryptoServiceProvider m_hashProvider;
    public int PageSize { get; private set; }
    public int PagesPerBlock { get; private set; }
    public int BlockSize { get; }
    public ContentIdentification(int pageSize, int pagesPerBlock);
    public ContentIdentification(Byte[] blockBuffer, Byte[] pageBuffer, int pageSize, int pagesPerBlock);
    [CompilerGeneratedAttribute]
public int get_PageSize();
    [CompilerGeneratedAttribute]
private void set_PageSize(int value);
    [CompilerGeneratedAttribute]
public int get_PagesPerBlock();
    [CompilerGeneratedAttribute]
private void set_PagesPerBlock(int value);
    public int get_BlockSize();
    public Byte[] CalculateContentIdentifier(Stream blocks, bool includesFinalBlock, Byte[] startingContentIdentifier);
    [EditorBrowsableAttribute("1")]
public Byte[] CalculateContentIdentifier(Byte[] block, bool isFinalBlock, Byte[] startingContentIdentifier);
    private Byte[] CalculateRollingBlockIdentifier(Byte[] currentBlockIdentifier, Byte[] previousRollingIdentifier, bool isFinalBlock);
    private Byte[] CalculateSingleBlockIdentifier(Byte[] block, int blockLength);
    private Byte[] CalculateHash(Byte[] buffer, int count);
    private Byte[] CalculateHash(List`1<byte> buffer);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
[EditorBrowsableAttribute("1")]
public static class Microsoft.VisualStudio.Services.Common.ContentValidationSecurityConstants : object {
    public static Guid NamespaceId;
    public static string ViolationsToken;
    public static int Read;
    public static int Write;
    private static ContentValidationSecurityConstants();
}
public class Microsoft.VisualStudio.Services.Common.Contracts.ErrorData : object {
    [CompilerGeneratedAttribute]
private Uri <Uri>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StatusCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Details>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Identity>k__BackingField;
    public Uri Uri { get; public set; }
    public int StatusCode { get; public set; }
    public string Message { get; public set; }
    public string Details { get; public set; }
    public string Content { get; public set; }
    public string Identity { get; public set; }
    [CompilerGeneratedAttribute]
public Uri get_Uri();
    [CompilerGeneratedAttribute]
public void set_Uri(Uri value);
    [CompilerGeneratedAttribute]
public int get_StatusCode();
    [CompilerGeneratedAttribute]
public void set_StatusCode(int value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public string get_Details();
    [CompilerGeneratedAttribute]
public void set_Details(string value);
    [CompilerGeneratedAttribute]
public string get_Content();
    [CompilerGeneratedAttribute]
public void set_Content(string value);
    [CompilerGeneratedAttribute]
public string get_Identity();
    [CompilerGeneratedAttribute]
public void set_Identity(string value);
}
public class Microsoft.VisualStudio.Services.Common.Contracts.PageHandler : object {
    [CompilerGeneratedAttribute]
private string <UrlPattern>k__BackingField;
    [CompilerGeneratedAttribute]
private string <JavaScript>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NavigationJavaScript>k__BackingField;
    [CompilerGeneratedAttribute]
private PageHandlerStyle[] <Styles>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <SiteDependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Terminate>k__BackingField;
    public string UrlPattern { get; public set; }
    public string JavaScript { get; public set; }
    public string NavigationJavaScript { get; public set; }
    public PageHandlerStyle[] Styles { get; public set; }
    public String[] SiteDependencies { get; public set; }
    public Nullable`1<bool> Terminate { get; public set; }
    [CompilerGeneratedAttribute]
public string get_UrlPattern();
    [CompilerGeneratedAttribute]
public void set_UrlPattern(string value);
    [CompilerGeneratedAttribute]
public string get_JavaScript();
    [CompilerGeneratedAttribute]
public void set_JavaScript(string value);
    [CompilerGeneratedAttribute]
public string get_NavigationJavaScript();
    [CompilerGeneratedAttribute]
public void set_NavigationJavaScript(string value);
    [CompilerGeneratedAttribute]
public PageHandlerStyle[] get_Styles();
    [CompilerGeneratedAttribute]
public void set_Styles(PageHandlerStyle[] value);
    [CompilerGeneratedAttribute]
public String[] get_SiteDependencies();
    [CompilerGeneratedAttribute]
public void set_SiteDependencies(String[] value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Terminate();
    [CompilerGeneratedAttribute]
public void set_Terminate(Nullable`1<bool> value);
}
public class Microsoft.VisualStudio.Services.Common.Contracts.PageHandlerStyle : object {
    [CompilerGeneratedAttribute]
private string <Selector>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StyleRule>k__BackingField;
    public string Selector { get; public set; }
    public string StyleRule { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Selector();
    [CompilerGeneratedAttribute]
public void set_Selector(string value);
    [CompilerGeneratedAttribute]
public string get_StyleRule();
    [CompilerGeneratedAttribute]
public void set_StyleRule(string value);
}
public class Microsoft.VisualStudio.Services.Common.ConvertUtility : object {
    public static object ChangeType(object value, Type type);
    public static object ChangeType(object value, Type type, IFormatProvider provider);
}
public enum Microsoft.VisualStudio.Services.Common.CredentialPromptType : Enum {
    public int value__;
    public static CredentialPromptType PromptIfNeeded;
    public static CredentialPromptType DoNotPrompt;
}
[EditorBrowsableAttribute("1")]
public static class Microsoft.VisualStudio.Services.Common.CredentialsCacheConstants : object {
    public static string CredentialsTypeKeyword;
    public static string NonInteractiveKeyword;
    public static string UserNameKeyword;
    public static string UserPasswordKeyword;
    public static string OAuthClientIdKeyword;
    public static string OAuthorizationUrlKeyword;
    public static string RegisteredProviderKeyName;
    private static CredentialsCacheConstants();
}
[EditorBrowsableAttribute("1")]
public class Microsoft.VisualStudio.Services.Common.CredentialsCacheManager : object {
    private CredentialsProviderRegistryHelper m_credentialsProviderRegistryHelper;
    public CredentialsCacheManager(string registryRootPath, bool useWOW6432Hive);
    public TfsCredentialCacheEntry GetCredentials(Uri uri);
    public TfsCredentialCacheEntry GetCredentials(Uri uri, bool requireExactUriMatch);
    public TfsCredentialCacheEntry GetCredentials(Uri uri, bool requireExactUriMatch, Nullable`1<bool> nonInteractive);
    public TfsCredentialCacheEntry GetCredentials(string featureRegistryKeyword, Uri uri);
    public TfsCredentialCacheEntry GetCredentials(string featureRegistryKeyword, Uri uri, bool requireExactUriMatch);
    public TfsCredentialCacheEntry GetCredentials(string featureRegistryKeyword, Uri uri, bool requireExactUriMatch, Nullable`1<bool> nonInteractive);
    public bool ContainsCredentials(Uri uri);
    public bool ContainsCredentials(string featureRegistryKeyword, Uri uri);
    private TfsCredentialCacheEntry GetCredentials(string featureRegistryKeyword, string targetName);
    private static TfsCredentialCacheEntry GetCredentialsFromStore(string targetName);
    [EditorBrowsableAttribute("1")]
public static SecureString CreateSecureString(string str);
    private TfsCredentialCacheEntry GetCredentialsFromRegistry(string featureRegistryKeyword, string targetName);
    public int StoreCredentials(Uri uri, string userName, string password);
    public int StoreCredentials(Uri uri, string userName, string password, CachedCredentialsType type, bool nonInteractive);
    public int StoreCredentials(Uri uri, string userName, SecureString password, CachedCredentialsType type, bool nonInteractive);
    public int StoreCredentials(Uri uri, string userName, SecureString password, CachedCredentialsType type, bool nonInteractive, Dictionary`2<string, string> additionalAttributes);
    public int StoreCredentials(string targetName, string userName, SecureString password, string comment, Dictionary`2<string, string> attributes);
    public int StoreCredentials(string featureRegistryKeyword, Uri uri, string userName, string password);
    public int StoreCredentials(string featureRegistryKeyword, Uri uri, string userName, string password, CachedCredentialsType type, bool nonInteractive);
    public int StoreCredentials(string featureRegistryKeyword, Uri uri, string userName, SecureString password, CachedCredentialsType type, bool nonInteractive);
    public int StoreCredentials(string featureRegistryKeyword, Uri uri, string userName, SecureString password, CachedCredentialsType type, bool nonInteractive, Dictionary`2<string, string> additionalAttributes);
    public int StoreCredentials(string featureRegistryKeyword, string targetName, string userName, SecureString password, string comment, Dictionary`2<string, string> attributes);
    public int StoreWindowsCredentials(string host, string userName, string password);
    private static int StoreCredentialsToStore(int credType, string targetName, string userName, SecureString password, string comment, Dictionary`2<string, string> attributes);
    private int StoreCredentialsToRegistry(string featureRegistryKeyword, string targetName, string userName, SecureString password, string comment, Dictionary`2<string, string> attributes);
    public bool DeleteCredentials(Uri uri);
    public bool DeleteCredentials(string featureRegistryKeyword, Uri uri);
    public bool DeleteCredentialsHive(string featureRegistryKeyword);
    public bool DeleteWindowsCredentials(string host);
    public bool SetHiveAccessRights(string featureRegistryKeyword, string owningAccountName);
    private static bool IsMatch(TfsCredentialCacheEntry entry, Nullable`1<bool> nonInteractive);
    private string GetTargetKey(string targetName);
    private static string GetTargetKey(Uri targetUrl);
    private static RegistryKey CreateSubKey(RegistryKey hive, string path);
}
[EditorBrowsableAttribute("1")]
public static class Microsoft.VisualStudio.Services.Common.CredentialsProviderHelper : object {
    public static string FailedUserName(Uri uri, ICredentials failedCredentials);
    public static NetworkCredential GetNetworkCredential(string username, StringBuilder password);
    public static void ZeroStringBuilder(StringBuilder toZero);
    public static void ZeroString(string toZero);
}
internal class Microsoft.VisualStudio.Services.Common.CredentialsProviderRegistryHelper : object {
    private RegistryView m_registryView;
    private string m_accountsRoot;
    public RegistryView RegistryView { get; }
    internal CredentialsProviderRegistryHelper(string registryRootPath, RegistryView registryView);
    public RegistryKey OpenLocalMachineHive();
    internal static void ClearTestEnvironment(string testRoot);
    internal static void LoadCachedVssCredentialProviders(ConcurrentDictionary`2& providers);
    public RegistrySecurity BuildSecurityDescriptor(string owningAccountName);
    public string BuildRegistryPath(string featureRegistryKeyword, string targetName);
    public string BuildRegistryPath(string featureRegistryKeyword);
    public string BuildRegistryPath();
    public string EncryptPassword(SecureString password);
    public string DecryptPassword(string cipherText);
    private static void ZeroArray(Byte[] b);
    public RegistryView get_RegistryView();
}
public class Microsoft.VisualStudio.Services.Common.CsvConfiguration`1 : object {
    [CompilerGeneratedAttribute]
private bool <UseHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <QuoteAllFields>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Trim>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseInvariantCulture>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<int, PropertyInfo> <IndexToProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<int, string> <IndexToColumnName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ColumnCount>k__BackingField;
    [CompilerGeneratedAttribute]
private BindingFlags <IncludedColumnTypes>k__BackingField;
    private HashSet`1<string> m_ignoredProperties;
    private static char c_comma;
    private static char c_quote;
    private static char c_newLine;
    private static char c_return;
    private static string c_doubleQuoteString;
    private static string c_CRLF;
    public bool UseHeader { get; public set; }
    public bool QuoteAllFields { get; public set; }
    public bool Trim { get; public set; }
    public bool UseInvariantCulture { get; public set; }
    public char Delimiter { get; }
    public string DelimiterString { get; }
    public string QuoteString { get; }
    public string DoubleQuoteString { get; }
    public string NewLineString { get; }
    public string CRLFString { get; }
    public Char[] QuoteRequiredChars { get; }
    public IReadOnlyDictionary`2<int, PropertyInfo> IndexToProperty { get; private set; }
    public IReadOnlyDictionary`2<int, string> IndexToColumnName { get; private set; }
    public int ColumnCount { get; private set; }
    public BindingFlags IncludedColumnTypes { get; public set; }
    public CsvConfiguration`1(HashSet`1<string> ignoredProperties);
    [CompilerGeneratedAttribute]
public bool get_UseHeader();
    [CompilerGeneratedAttribute]
public void set_UseHeader(bool value);
    [CompilerGeneratedAttribute]
public bool get_QuoteAllFields();
    [CompilerGeneratedAttribute]
public void set_QuoteAllFields(bool value);
    [CompilerGeneratedAttribute]
public bool get_Trim();
    [CompilerGeneratedAttribute]
public void set_Trim(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseInvariantCulture();
    [CompilerGeneratedAttribute]
public void set_UseInvariantCulture(bool value);
    public char get_Delimiter();
    public string get_DelimiterString();
    public string get_QuoteString();
    public string get_DoubleQuoteString();
    public string get_NewLineString();
    public string get_CRLFString();
    public Char[] get_QuoteRequiredChars();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<int, PropertyInfo> get_IndexToProperty();
    [CompilerGeneratedAttribute]
private void set_IndexToProperty(IReadOnlyDictionary`2<int, PropertyInfo> value);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<int, string> get_IndexToColumnName();
    [CompilerGeneratedAttribute]
private void set_IndexToColumnName(IReadOnlyDictionary`2<int, string> value);
    [CompilerGeneratedAttribute]
public int get_ColumnCount();
    [CompilerGeneratedAttribute]
private void set_ColumnCount(int value);
    [CompilerGeneratedAttribute]
public BindingFlags get_IncludedColumnTypes();
    [CompilerGeneratedAttribute]
public void set_IncludedColumnTypes(BindingFlags value);
    private bool IsPropertyIgnored(string propertyName);
    private void ValidateTypeConfiguration();
}
public class Microsoft.VisualStudio.Services.Common.CsvException : Exception {
    public CsvException(string message, Exception inner);
}
public class Microsoft.VisualStudio.Services.Common.CsvIoException : CsvException {
    public CsvIoException(string message, Exception inner);
}
public class Microsoft.VisualStudio.Services.Common.CsvWriter`1 : object {
    [CompilerGeneratedAttribute]
private CsvConfiguration`1<T> <Configuration>k__BackingField;
    private TextWriter m_writer;
    private bool m_hasRowBeenWritten;
    private static string c_invalidStartingChars;
    public CsvConfiguration`1<T> Configuration { get; }
    public CsvWriter`1(TextWriter writer, CsvConfiguration`1<T> configuration);
    [CompilerGeneratedAttribute]
public CsvConfiguration`1<T> get_Configuration();
    public void WriteRecords(IEnumerable`1<T> records);
    private void WriteHeader();
    private void WriteRecord(T record);
    private string SerializeHeader();
    private string SerializeRecord(T record);
    private string SerializeField(string field);
    private string SerializeField(string field, bool shouldQuote);
    private void BlockHarmfulStartingCharacters(String& input);
}
public static class Microsoft.VisualStudio.Services.Common.CultureResolution : object {
    public static CultureInfo GetBestCultureMatch(IList`1<CultureInfo> orderedAcceptableCultures, ISet`1<CultureInfo> availableCultures);
    public static int GetCultureRelationshipDistance(CultureInfo cultureA, CultureInfo cultureB);
    [CompilerGeneratedAttribute]
internal static int <GetCultureRelationshipDistance>g__DistanceToParentCulture|1_0(CultureInfo childCulture, CultureInfo parentCulture);
}
public enum Microsoft.VisualStudio.Services.Common.CurlErrorCode : Enum {
    public int value__;
    public static CurlErrorCode CURLE_OK;
    public static CurlErrorCode CURLE_UNSUPPORTED_PROTOCOL;
    public static CurlErrorCode CURLE_FAILED_INIT;
    public static CurlErrorCode CURLE_URL_MALFORMAT;
    public static CurlErrorCode CURLE_NOT_BUILT_IN;
    public static CurlErrorCode CURLE_COULDNT_RESOLVE_PROXY;
    public static CurlErrorCode CURLE_COULDNT_RESOLVE_HOST;
    public static CurlErrorCode CURLE_COULDNT_CONNECT;
    public static CurlErrorCode CURLE_FTP_WEIRD_SERVER_REPLY;
    public static CurlErrorCode CURLE_REMOTE_ACCESS_DENIED;
    public static CurlErrorCode CURLE_FTP_ACCEPT_FAILED;
    public static CurlErrorCode CURLE_FTP_WEIRD_PASS_REPLY;
    public static CurlErrorCode CURLE_FTP_ACCEPT_TIMEOUT;
    public static CurlErrorCode CURLE_FTP_WEIRD_PASV_REPLY;
    public static CurlErrorCode CURLE_FTP_WEIRD_227_FORMAT;
    public static CurlErrorCode CURLE_FTP_CANT_GET_HOST;
    public static CurlErrorCode CURLE_HTTP2;
    public static CurlErrorCode CURLE_FTP_COULDNT_SET_TYPE;
    public static CurlErrorCode CURLE_PARTIAL_FILE;
    public static CurlErrorCode CURLE_FTP_COULDNT_RETR_FILE;
    public static CurlErrorCode CURLE_QUOTE_ERROR;
    public static CurlErrorCode CURLE_HTTP_RETURNED_ERROR;
    public static CurlErrorCode CURLE_WRITE_ERROR;
    public static CurlErrorCode CURLE_UPLOAD_FAILED;
    public static CurlErrorCode CURLE_READ_ERROR;
    public static CurlErrorCode CURLE_OUT_OF_MEMORY;
    public static CurlErrorCode CURLE_OPERATION_TIMEDOUT;
    public static CurlErrorCode CURLE_FTP_PORT_FAILED;
    public static CurlErrorCode CURLE_FTP_COULDNT_USE_REST;
    public static CurlErrorCode CURLE_RANGE_ERROR;
    public static CurlErrorCode CURLE_HTTP_POST_ERROR;
    public static CurlErrorCode CURLE_SSL_CONNECT_ERROR;
    public static CurlErrorCode CURLE_BAD_DOWNLOAD_RESUME;
    public static CurlErrorCode CURLE_FILE_COULDNT_READ_FILE;
    public static CurlErrorCode CURLE_LDAP_CANNOT_BIND;
    public static CurlErrorCode CURLE_LDAP_SEARCH_FAILED;
    public static CurlErrorCode CURLE_FUNCTION_NOT_FOUND;
    public static CurlErrorCode CURLE_ABORTED_BY_CALLBACK;
    public static CurlErrorCode CURLE_BAD_FUNCTION_ARGUMENT;
    public static CurlErrorCode CURLE_INTERFACE_FAILED;
    public static CurlErrorCode CURLE_TOO_MANY_REDIRECTS;
    public static CurlErrorCode CURLE_UNKNOWN_OPTION;
    public static CurlErrorCode CURLE_TELNET_OPTION_SYNTAX;
    public static CurlErrorCode CURLE_PEER_FAILED_VERIFICATION;
    public static CurlErrorCode CURLE_GOT_NOTHING;
    public static CurlErrorCode CURLE_SSL_ENGINE_NOTFOUND;
    public static CurlErrorCode CURLE_SSL_ENGINE_SETFAILED;
    public static CurlErrorCode CURLE_SEND_ERROR;
    public static CurlErrorCode CURLE_RECV_ERROR;
    public static CurlErrorCode CURLE_SSL_CERTPROBLEM;
    public static CurlErrorCode CURLE_SSL_CIPHER;
    public static CurlErrorCode CURLE_SSL_CACERT;
    public static CurlErrorCode CURLE_BAD_CONTENT_ENCODING;
    public static CurlErrorCode CURLE_LDAP_INVALID_URL;
    public static CurlErrorCode CURLE_FILESIZE_EXCEEDED;
    public static CurlErrorCode CURLE_USE_SSL_FAILED;
    public static CurlErrorCode CURLE_SEND_FAIL_REWIND;
    public static CurlErrorCode CURLE_SSL_ENGINE_INITFAILED;
    public static CurlErrorCode CURLE_LOGIN_DENIED;
    public static CurlErrorCode CURLE_TFTP_NOTFOUND;
    public static CurlErrorCode CURLE_TFTP_PERM;
    public static CurlErrorCode CURLE_REMOTE_DISK_FULL;
    public static CurlErrorCode CURLE_TFTP_ILLEGAL;
    public static CurlErrorCode CURLE_TFTP_UNKNOWNID;
    public static CurlErrorCode CURLE_REMOTE_FILE_EXISTS;
    public static CurlErrorCode CURLE_TFTP_NOSUCHUSER;
    public static CurlErrorCode CURLE_CONV_FAILED;
    public static CurlErrorCode CURLE_CONV_REQD;
    public static CurlErrorCode CURLE_SSL_CACERT_BADFILE;
    public static CurlErrorCode CURLE_REMOTE_FILE_NOT_FOUND;
    public static CurlErrorCode CURLE_SSH;
    public static CurlErrorCode CURLE_SSL_SHUTDOWN_FAILED;
    public static CurlErrorCode CURLE_AGAIN;
    public static CurlErrorCode CURLE_SSL_CRL_BADFILE;
    public static CurlErrorCode CURLE_SSL_ISSUER_ERROR;
    public static CurlErrorCode CURLE_FTP_PRET_FAILED;
    public static CurlErrorCode CURLE_RTSP_CSEQ_ERROR;
    public static CurlErrorCode CURLE_RTSP_SESSION_ERROR;
    public static CurlErrorCode CURLE_FTP_BAD_FILE_LIST;
    public static CurlErrorCode CURLE_CHUNK_FAILED;
    public static CurlErrorCode CURLE_NO_CONNECTION_AVAILABLE;
    public static CurlErrorCode CURLE_SSL_PINNEDPUBKEYNOTMATCH;
    public static CurlErrorCode CURLE_SSL_INVALIDCERTSTATUS;
    public static CurlErrorCode CURLE_HTTP2_STREAM;
    public static CurlErrorCode CURLE_RECURSIVE_API_CALL;
}
public static class Microsoft.VisualStudio.Services.Common.DateTimeUtility : object {
    private static bool isEntryPointNotFound;
    private static void GetSystemTimePreciseAsFileTime(Int64& filetime);
    public static DateTime GetHighResolutionUtcNow();
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
internal static class Microsoft.VisualStudio.Services.Common.Diagnostics.HttpRequestMessageExtensions : object {
    [ExtensionAttribute]
public static VssHttpMethod GetHttpMethod(HttpRequestMessage message);
    [ExtensionAttribute]
public static VssTraceActivity GetActivity(HttpRequestMessage message);
}
public static class Microsoft.VisualStudio.Services.Common.Diagnostics.VssEventSources : object {
    public static string Http;
}
[EventSourceAttribute]
internal class Microsoft.VisualStudio.Services.Common.Diagnostics.VssHttpEventSource : EventSource {
    private static Lazy`1<VssHttpEventSource> m_log;
    internal static VssHttpEventSource Log { get; }
    private static VssHttpEventSource();
    internal static VssHttpEventSource get_Log();
    [NonEventAttribute]
public void AuthenticationStart(VssTraceActivity activity);
    [NonEventAttribute]
public void AuthenticationStop(VssTraceActivity activity);
    [NonEventAttribute]
public void AuthenticationError(VssTraceActivity activity, IssuedTokenProvider provider, string message);
    [NonEventAttribute]
public void AuthenticationError(VssTraceActivity activity, IssuedTokenProvider provider, Exception exception);
    [NonEventAttribute]
public void HttpOperationStart(VssTraceActivity activity, string area, string operation);
    [NonEventAttribute]
public void HttpOperationStop(VssTraceActivity activity, string area, string operation);
    [NonEventAttribute]
public void HttpRequestStart(VssTraceActivity activity, HttpRequestMessage request);
    [NonEventAttribute]
public Exception HttpRequestFailed(VssTraceActivity activity, HttpRequestMessage request, Exception exception);
    [NonEventAttribute]
public void HttpRequestFailed(VssTraceActivity activity, HttpRequestMessage request, string message);
    [NonEventAttribute]
public void HttpRequestFailed(VssTraceActivity activity, HttpRequestMessage request, HttpStatusCode statusCode, string afdRefInfo);
    [NonEventAttribute]
public void HttpRequestUnauthorized(VssTraceActivity activity, HttpRequestMessage request, string message);
    [NonEventAttribute]
public void HttpRequestSucceeded(VssTraceActivity activity, HttpResponseMessage response);
    [NonEventAttribute]
public void HttpRequestRetrying(VssTraceActivity activity, HttpRequestMessage request, int attempt, TimeSpan backoffDuration, Nullable`1<HttpStatusCode> httpStatusCode, Nullable`1<WebExceptionStatus> webExceptionStatus, Nullable`1<SocketError> socketErrorCode, Nullable`1<WinHttpErrorCode> winHttpErrorCode, Nullable`1<CurlErrorCode> curlErrorCode, string afdRefInfo);
    [NonEventAttribute]
public void HttpRequestFailedMaxAttempts(VssTraceActivity activity, HttpRequestMessage request, int attempt, Nullable`1<HttpStatusCode> httpStatusCode, Nullable`1<WebExceptionStatus> webExceptionStatus, Nullable`1<SocketError> socketErrorCode, Nullable`1<WinHttpErrorCode> winHttpErrorCode, Nullable`1<CurlErrorCode> curlErrorCode, string afdRefInfo);
    [NonEventAttribute]
public void HttpRequestSucceededWithRetry(VssTraceActivity activity, HttpResponseMessage response, int attempt);
    [NonEventAttribute]
public void HttpRequestCancelled(VssTraceActivity activity, HttpRequestMessage request);
    [NonEventAttribute]
public void HttpRequestTimedOut(VssTraceActivity activity, HttpRequestMessage request, TimeSpan timeout);
    [NonEventAttribute]
public void HttpRequestStop(VssTraceActivity activity, HttpResponseMessage response);
    [NonEventAttribute]
public void AuthenticationFailed(VssTraceActivity activity, HttpResponseMessage response);
    [NonEventAttribute]
public void IssuedTokenProviderCreated(VssTraceActivity activity, IssuedTokenProvider provider);
    [NonEventAttribute]
public void IssuedTokenProviderRemoved(VssTraceActivity activity, IssuedTokenProvider provider);
    [NonEventAttribute]
internal void IssuedTokenProviderNotFound(VssTraceActivity activity);
    [NonEventAttribute]
internal void IssuedTokenProviderPromptRequired(VssTraceActivity activity, IssuedTokenProvider provider);
    [NonEventAttribute]
public void IssuedTokenAcquiring(VssTraceActivity activity, IssuedTokenProvider provider);
    [NonEventAttribute]
public void IssuedTokenWaitStart(VssTraceActivity activity, IssuedTokenProvider provider, Guid waitForActivityId);
    [NonEventAttribute]
public void IssuedTokenWaitStop(VssTraceActivity activity, IssuedTokenProvider provider, IssuedToken token);
    [NonEventAttribute]
public void IssuedTokenAcquired(VssTraceActivity activity, IssuedTokenProvider provider, IssuedToken token);
    [NonEventAttribute]
public void IssuedTokenInvalidated(VssTraceActivity activity, IssuedTokenProvider provider, IssuedToken token);
    [NonEventAttribute]
public void IssuedTokenValidated(VssTraceActivity activity, IssuedTokenProvider provider, IssuedToken token);
    [NonEventAttribute]
public void IssuedTokenRetrievedFromCache(VssTraceActivity activity, IssuedTokenProvider provider, IssuedToken token);
    [NonEventAttribute]
public void HandlerOperationStart(VssTraceActivity activity, string handler, string e2eId);
    [NonEventAttribute]
public void HandlerOperationStop(VssTraceActivity activity, string handler, string e2eId);
    [NonEventAttribute]
public void HandlerOperationDispose(VssTraceActivity activity, string handler, string e2eId);
    [NonEventAttribute]
public static string SanitizeUrl(Uri url);
    [EventAttribute("1")]
private void HttpRequestStart(VssHttpMethod method, string url);
    [EventAttribute("2")]
private void HttpRequestFailed(VssHttpMethod method, string url, string message);
    [EventAttribute("3")]
private void HttpRequestSucceeded(VssHttpMethod method, string url, int statusCode);
    [EventAttribute("4")]
private void HttpRequestRetrying(VssHttpMethod method, string url, int attempt, string reason, double backoffDurationInSeconds);
    [EventAttribute("5")]
private void HttpRequestFailedMaxAttempts(VssHttpMethod method, string url, int attempt, string reason);
    [EventAttribute("6")]
private void HttpRequestSucceededWithRetry(VssHttpMethod method, string url, int attempt);
    [EventAttribute("7")]
private void HttpRequestCancelled(VssHttpMethod method, string url);
    [EventAttribute("8")]
private void HttpRequestTimedOut(VssHttpMethod method, string url, int timeoutInSeconds);
    [EventAttribute("9")]
private void HttpRequestUnauthorized(VssHttpMethod method, string url, string message);
    [EventAttribute("10")]
private void AuthenticationFailed(int statusCode, string headers);
    [EventAttribute("11")]
private void AuthenticationSucceeded(VssCredentialsType credentialsType);
    [EventAttribute("12")]
private void AuthenticationStart();
    [EventAttribute("13")]
private void IssuedTokenProviderCreated(VssCredentialsType credentialsType, int providerId, string parameters);
    [EventAttribute("14")]
private void IssuedTokenProviderRemoved(VssCredentialsType credentialsType, int providerId, string parameters);
    [EventAttribute("15")]
private void IssuedTokenAcquiring(VssCredentialsType credentialsType, int providerId);
    [EventAttribute("16")]
private void IssuedTokenWaitStart(VssCredentialsType credentialsType, int providerId, Guid waitForActivityId);
    [EventAttribute("17")]
private void IssuedTokenWaitStop(VssCredentialsType credentialsType, int providerId, int issuedTokenId);
    [EventAttribute("18")]
private void IssuedTokenAcquired(VssCredentialsType credentialsType, int providerId, int issuedTokenId);
    [EventAttribute("20")]
private void IssuedTokenInvalidated(VssCredentialsType credentialsType, int providerId, int issuedTokenId);
    [EventAttribute("21")]
private void IssuedTokenValidated(VssCredentialsType credentialsType, int providerId, int issuedTokenId);
    [EventAttribute("22")]
private void IssuedTokenRetrievedFromCache(VssCredentialsType credentialsType, int providerId, int issuedTokenId);
    [EventAttribute("23")]
private void AuthenticationStop();
    [EventAttribute("24")]
private void HttpRequestStop(VssHttpMethod method, string url, int statusCode);
    [EventAttribute("25")]
private void HttpOperationStart(string area, string operation);
    [EventAttribute("26")]
private void HttpOperationStop(string area, string operation);
    [EventAttribute("27")]
private void AuthenticationError(VssCredentialsType credentialsType, int providerId, string message);
    [EventAttribute("28")]
private void IssuedTokenProviderNotFound();
    [EventAttribute("29")]
private void IssuedTokenProviderPromptRequired(VssCredentialsType credentialsType, int providerId);
    [EventAttribute("30")]
public void TokenSourceNotCompleted();
    [EventAttribute("31")]
public void AuthorizationDelayed(string timespan);
    [EventAttribute("32")]
public void AADCorrelationID(string aadCorrelationId);
    [EventAttribute("33")]
private void HandlerOperationStart(string handler, string e2eId);
    [EventAttribute("34")]
private void HandlerOperationStop(string handler, string e2eId);
    [EventAttribute("35")]
private void HandlerOperationDispose(string handler, string e2eId);
    [NonEventAttribute]
private void SetActivityId(VssTraceActivity activity);
    [NonEventAttribute]
private static IList`1<string> SplitMessage(string message);
    [NonEventAttribute]
private void WriteMessageEvent(int param0, string message, Action`2<int, string> writeEvent);
    [NonEventAttribute]
private void WriteMessageEvent(VssCredentialsType param0, int param1, string message, Action`3<VssCredentialsType, int, string> writeEvent);
    [NonEventAttribute]
private void WriteMessageEvent(VssHttpMethod param0, string param1, string message, Action`3<VssHttpMethod, string, string> writeEvent);
    [NonEventAttribute]
private void WriteEvent(int eventId, int param0, string param1);
    [NonEventAttribute]
private void WriteEvent(int eventId, int param0, string param1, string param2);
    [NonEventAttribute]
private void WriteEvent(int eventId, int param0, int param1, Guid param2);
    [NonEventAttribute]
private void WriteEvent(int eventId, int param0, int param1, string param2);
    [NonEventAttribute]
private void WriteEvent(int eventId, int param0, string param1, int param2);
    [NonEventAttribute]
private void WriteEvent(int eventId, int param0, int param1, int param2, Guid param3);
    [NonEventAttribute]
private void WriteEvent(int eventId, int param0, int param1, Guid param2, Guid param3);
    [NonEventAttribute]
private void WriteEvent(int eventId, int param0, string param1, int param2, string param3);
    [NonEventAttribute]
private void WriteEvent(int eventId, int param0, string param1, int param2, string param3, double param4);
}
internal enum Microsoft.VisualStudio.Services.Common.Diagnostics.VssHttpMethod : Enum {
    public int value__;
    public static VssHttpMethod UNKNOWN;
    public static VssHttpMethod DELETE;
    public static VssHttpMethod HEAD;
    public static VssHttpMethod GET;
    public static VssHttpMethod OPTIONS;
    public static VssHttpMethod PATCH;
    public static VssHttpMethod POST;
    public static VssHttpMethod PUT;
}
[DataContractAttribute]
public class Microsoft.VisualStudio.Services.Common.Diagnostics.VssTraceActivity : object {
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    public static string PropertyName;
    private static Lazy`1<VssTraceActivity> s_empty;
    [DataMemberAttribute]
public Guid Id { get; private set; }
    public static VssTraceActivity Current { get; public set; }
    public static VssTraceActivity Empty { get; }
    private VssTraceActivity(Guid activityId);
    private static VssTraceActivity();
    [CompilerGeneratedAttribute]
public Guid get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(Guid value);
    public static VssTraceActivity get_Current();
    public static void set_Current(VssTraceActivity value);
    public static VssTraceActivity get_Empty();
    public IDisposable EnterCorrelationScope();
    public static VssTraceActivity GetOrCreate();
    public static VssTraceActivity New(Guid activityId);
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Services.Common.DictionaryExtensions : object {
    [ExtensionAttribute]
public static V AddOrUpdate(IDictionary`2<K, V> dictionary, K key, V addValue, Func`3<V, V, V> updateValueFactory);
    [ExtensionAttribute]
public static V AddOrUpdate(IDictionary`2<K, V> dictionary, K key, V addValue, Func`3<K, V, V> updateValueFactory);
    [ExtensionAttribute]
public static V GetValueOrDefault(IDictionary`2<K, V> dictionary, K key, V default);
    [ExtensionAttribute]
public static V GetValueOrDefault(IReadOnlyDictionary`2<K, V> dictionary, K key, V default);
    [ExtensionAttribute]
public static V GetValueOrDefault(Dictionary`2<K, V> dictionary, K key, V default);
    [ExtensionAttribute]
public static Nullable`1<V> GetNullableValueOrDefault(IDictionary`2<K, V> dictionary, K key, Nullable`1<V> default);
    [ExtensionAttribute]
public static Nullable`1<V> GetNullableValueOrDefault(IReadOnlyDictionary`2<K, V> dictionary, K key, Nullable`1<V> default);
    [ExtensionAttribute]
public static Nullable`1<V> GetNullableValueOrDefault(Dictionary`2<K, V> dictionary, K key, Nullable`1<V> default);
    [ExtensionAttribute]
public static V GetCastedValueOrDefault(IReadOnlyDictionary`2<K, object> dictionary, K key, V default);
    [ExtensionAttribute]
public static V GetCastedValueOrDefault(IDictionary`2<K, object> dictionary, K key, V default);
    [ExtensionAttribute]
public static V GetCastedValueOrDefault(Dictionary`2<K, object> dictionary, K key, V default);
    [ExtensionAttribute]
public static V GetOrAddValue(IDictionary`2<K, V> dictionary, K key);
    [ExtensionAttribute]
public static V GetOrAddValue(IDictionary`2<K, V> dictionary, K key, Func`1<V> createValueToAdd);
    [ExtensionAttribute]
public static TDictionary SetRange(TDictionary dictionary, IEnumerable`1<KeyValuePair`2<K, V>> keyValuePairs);
    [ExtensionAttribute]
public static TDictionary SetRangeIfRangeNotNull(TDictionary dictionary, IEnumerable`1<KeyValuePair`2<K, V>> keyValuePairs);
    [ExtensionAttribute]
public static Lazy`1<TDictionary> SetRangeIfRangeNotNullOrEmpty(Lazy`1<TDictionary> lazyDictionary, IEnumerable`1<KeyValuePair`2<K, V>> keyValuePairs);
    [ExtensionAttribute]
public static bool TryAdd(IDictionary`2<TKey, TValue> dictionary, TKey key, TValue value);
    [ExtensionAttribute]
public static bool TryAddRange(TDictionary dictionary, IEnumerable`1<KeyValuePair`2<TKey, TValue>> keyValuePairs);
    [ExtensionAttribute]
public static bool TryGetValue(IDictionary`2<string, object> dictionary, string key, T& value);
    [ExtensionAttribute]
public static bool TryGetValidatedValue(IDictionary`2<string, object> dictionary, string key, T& value, bool allowNull);
    [ExtensionAttribute]
public static bool TryGetEnum(IDictionary`2<string, object> dictionary, string key, T& value);
    [ExtensionAttribute]
public static bool TryGetGuid(IDictionary`2<string, object> dictionary, string key, Guid& value);
    [ExtensionAttribute]
public static IDictionary`2<TKey, TValue> Copy(IDictionary`2<TKey, TValue> source, IDictionary`2<TKey, TValue> dest, Predicate`1<TKey> filter);
    [ExtensionAttribute]
public static IDictionary`2<TKey, TValue> Copy(IDictionary`2<TKey, TValue> source, IDictionary`2<TKey, TValue> dest);
    [ExtensionAttribute]
public static IDictionary`2<TKey, TValue> SetIfNotNull(IDictionary`2<TKey, TValue> dictionary, TKey key, TValue value);
    [ExtensionAttribute]
public static Lazy`1<IDictionary`2<TKey, TValue>> SetIfNotNull(Lazy`1<IDictionary`2<TKey, TValue>> dictionary, TKey key, TValue value);
    [ExtensionAttribute]
public static IDictionary`2<TKey, TValue> SetIfNotNullAndNotConflicting(IDictionary`2<TKey, TValue> dictionary, TKey key, TValue value, string valuePropertyName, string dictionaryName);
    [ExtensionAttribute]
public static IDictionary`2<TKey, TValue> SetIfNotConflicting(IDictionary`2<TKey, TValue> dictionary, TKey key, TValue value, string valuePropertyName, string dictionaryName);
    [ExtensionAttribute]
public static void CheckForConflict(IDictionary`2<TKey, TValue> dictionary, TKey key, TValue value, string valuePropertyName, string dictionaryName, bool ignoreDefaultValue);
    [ExtensionAttribute]
public static void CheckForConflict(IReadOnlyDictionary`2<TKey, TValue> dictionary, TKey key, TValue value, string valuePropertyName, string dictionaryName, bool ignoreDefaultValue);
}
public static class Microsoft.VisualStudio.Services.Common.DirectoryRoleConstants : object {
    public static string CompanyAdministrator;
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Services.Common.EncryptionUtility : object {
    public static AlgorithmIdentifier Aes256Algorithm;
    public static AlgorithmIdentifier TripleDesAlgorithm;
    private static EncryptionUtility();
    public static string EncryptSecret(string secret, X509Certificate2 cert);
    public static string EncryptSecret(string secret, X509Certificate2 cert, AlgorithmIdentifier algorithm);
    public static SecureString DecryptSecret(string encryptedSecret);
    public static bool TryDecryptSecret(string encryptedSecret, SecureString& secureSecret);
    [ObsoleteAttribute("Use DecryptSecret which returns a SecureString instead.", "False")]
public static string DecryptSecretInsecure(string encryptedSecret);
    [ObsoleteAttribute("Use TryDecryptSecret which returns a SecureString instead.", "False")]
public static string TryDecryptSecretInsecure(string encryptedSecret);
    private static Byte[] DecryptSecretHelper(string encryptedSecret);
    [ExtensionAttribute]
public static SecureString ToSecureString(Byte[] bytes);
    [ExtensionAttribute]
public static SecureString ToSecureString(string s);
    [ExtensionAttribute]
public static SecureString ToSecureString(Char[] chars);
    [ExtensionAttribute]
public static Byte[] ToByteArray(SecureString secureString);
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Services.Common.EnumerableExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<T> AsEmptyIfNull(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static TEnumerable AsEmptyIfNull(TEnumerable source);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Services.Common.EnumerableExtensions/<Batch>d__2`1")]
[ExtensionAttribute]
public static IEnumerable`1<IList`1<T>> Batch(IEnumerable`1<T> source, int batchSize);
    [ExtensionAttribute]
public static PartitionResults`1<T> Partition(IEnumerable`1<T> source, Predicate`1<T> predicate);
    [ExtensionAttribute]
public static MultiPartitionResults`1<T> Partition(IEnumerable`1<T> source, Predicate`1[] predicates);
    [ExtensionAttribute]
public static IEnumerable`1<T> Merge(IEnumerable`1<T> first, IEnumerable`1<T> second, IComparer`1<T> comparer);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Services.Common.EnumerableExtensions/<Merge>d__6`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> Merge(IEnumerable`1<T> first, IEnumerable`1<T> second, Func`3<T, T, int> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<T> MergeDistinct(IEnumerable`1<T> first, IEnumerable`1<T> second, IComparer`1<T> comparer);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Services.Common.EnumerableExtensions/<MergeDistinct>d__8`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> MergeDistinct(IEnumerable`1<T> first, IEnumerable`1<T> second, Func`3<T, T, int> comparer);
    public static HashSet`1<T> ToHashSet(IEnumerable`1<T> source);
    public static HashSet`1<T> ToHashSet(IEnumerable`1<T> source, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static HashSet`1<TOut> ToHashSet(IEnumerable`1<TIn> source, Func`2<TIn, TOut> selector);
    [ExtensionAttribute]
public static HashSet`1<TOut> ToHashSet(IEnumerable`1<TIn> source, Func`2<TIn, TOut> selector, IEqualityComparer`1<TOut> comparer);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> collection, Action`1<T> action);
    [ExtensionAttribute]
public static void AddIf(List`1<T> list, bool condition, T element);
    [ExtensionAttribute]
public static NameValueCollection ToNameValueCollection(IEnumerable`1<KeyValuePair`2<string, string>> pairs);
    [ExtensionAttribute]
public static IList`1<P> PartitionSolveAndMergeBack(IList`1<T> source, Predicate`1<T> predicate, Func`2<IList`1<T>, IList`1<P>> matchingPartitionSolver, Func`2<IList`1<T>, IList`1<P>> nonMatchingPartitionSolver);
}
public static class Microsoft.VisualStudio.Services.Common.EnumerableUtility : object {
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Services.Common.EnumerableUtility/<AsEnumerable>d__0`1")]
public static IEnumerable`1<T> AsEnumerable(Func`3<int, int, IEnumerable`1<T>> pagingExpression, int take);
}
public static class Microsoft.VisualStudio.Services.Common.EnumUtility : object {
    public static string ToString(T value);
    public static bool TryParse(string s, T& result);
    public static bool TryParse(string s, bool ignoreCase, T& result);
    public static T Parse(string s);
    public static bool IsDefined(T value);
    public static T Parse(string s, bool ignoreCase);
}
public static class Microsoft.VisualStudio.Services.Common.EnvironmentWrapper : object {
    public static string ToReadableStackTrace();
}
public class Microsoft.VisualStudio.Services.Common.EUIILeakException : VssException {
    public EUIILeakException(string message);
    public EUIILeakException(SerializationInfo info, StreamingContext context);
}
public static class Microsoft.VisualStudio.Services.Common.EuiiUtility : object {
    private static Regex s_emailRegex;
    private static string c_emailPattern;
    private static Regex c_emailMaskRegex;
    private static string c_emailMaskPattern;
    private static Regex s_ipAddressRegex;
    private static string c_ipAddressPattern;
    private static string c_euiiMask;
    private static EuiiUtility();
    public static bool ContainsEmail(string message, bool assertOnDetection);
    public static bool ContainsIpAddress(string message, bool assertOnDetection);
    public static string MaskEmail(string message);
    private static bool PatternMatch(string message, Regex pattern, bool assertOnDetection);
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Services.Common.ExceptionExtentions : object {
    [ExtensionAttribute]
public static string ToReadableStackTrace(Exception exception);
}
[EditorBrowsableAttribute("1")]
[AttributeUsageAttribute("4")]
public class Microsoft.VisualStudio.Services.Common.ExceptionMappingAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Version <MinApiVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <ExclusiveMaxApiVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    public Version MinApiVersion { get; private set; }
    public Version ExclusiveMaxApiVersion { get; private set; }
    public string TypeKey { get; private set; }
    public string TypeName { get; private set; }
    public ExceptionMappingAttribute(string minApiVersion, string exclusiveMaxApiVersion, string typeKey, string typeName);
    [CompilerGeneratedAttribute]
public Version get_MinApiVersion();
    [CompilerGeneratedAttribute]
private void set_MinApiVersion(Version value);
    [CompilerGeneratedAttribute]
public Version get_ExclusiveMaxApiVersion();
    [CompilerGeneratedAttribute]
private void set_ExclusiveMaxApiVersion(Version value);
    [CompilerGeneratedAttribute]
public string get_TypeKey();
    [CompilerGeneratedAttribute]
private void set_TypeKey(string value);
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
private void set_TypeName(string value);
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Services.Common.ExpectedExceptionExtensions : object {
    private static string c_expectedKey;
    [ExtensionAttribute]
public static Exception Expected(Exception ex, string area);
    [ExtensionAttribute]
public static bool ExpectedExceptionFilter(Exception ex, string area);
    [ExtensionAttribute]
public static bool IsExpected(Exception ex, string area);
}
public abstract class Microsoft.VisualStudio.Services.Common.ExpiringIssuedToken : IssuedToken {
    public DateTime ValidTo { get; }
    public string Value { get; }
    public abstract virtual DateTime get_ValidTo();
    public abstract virtual string get_Value();
}
public class Microsoft.VisualStudio.Services.Common.ExtendedAttribute : object {
    private string m_Name;
    private string m_Value;
    private string m_FormatString;
    public string Name { get; public set; }
    public string Value { get; public set; }
    public string FormatString { get; public set; }
    public string get_Name();
    public void set_Name(string value);
    public string get_Value();
    public void set_Value(string value);
    public string get_FormatString();
    public void set_FormatString(string value);
    internal static ExtendedAttribute FromXml(XmlReader reader);
    internal void ToXml(XmlWriter writer, string element);
    internal static ExtendedAttribute[] ExtendedAttributeArrayFromXml(XmlReader reader);
    internal static void ExtendedAttributeArrayToXml(XmlWriter writer, string element, ExtendedAttribute[] array);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.Services.Common.Extensions : object {
    [ExtensionAttribute]
internal static bool GetOrAdd(ConcurrentDictionary`2<TKey, TValue> dict, TKey key, TValue value, TValue& finalValue);
}
public abstract class Microsoft.VisualStudio.Services.Common.FederatedCredential : IssuedTokenCredential {
    protected FederatedCredential(IssuedToken initialToken);
    public virtual bool IsAuthenticationChallenge(IHttpResponse webResponse);
}
public enum Microsoft.VisualStudio.Services.Common.FilterType : Enum {
    public int value__;
    public static FilterType ToolType;
    public static FilterType ArtifactType;
    public static FilterType LinkType;
}
[AttributeUsageAttribute("28")]
[EditorBrowsableAttribute("1")]
public class Microsoft.VisualStudio.Services.Common.GenerateAllConstantsAttribute : GenerateConstantAttribute {
    public GenerateAllConstantsAttribute(string alternateName);
}
[AttributeUsageAttribute("256")]
[EditorBrowsableAttribute("1")]
public class Microsoft.VisualStudio.Services.Common.GenerateConstantAttribute : GenerateConstantAttributeBase {
    public GenerateConstantAttribute(string alternateName);
}
[EditorBrowsableAttribute("1")]
public abstract class Microsoft.VisualStudio.Services.Common.GenerateConstantAttributeBase : Attribute {
    [CompilerGeneratedAttribute]
private string <AlternateName>k__BackingField;
    public string AlternateName { get; private set; }
    protected GenerateConstantAttributeBase(string alternateName);
    [CompilerGeneratedAttribute]
public string get_AlternateName();
    [CompilerGeneratedAttribute]
private void set_AlternateName(string value);
}
[CompilerGeneratedAttribute]
internal static class Microsoft.VisualStudio.Services.Common.GeneratedVersionInfo : object {
    public static string MajorVersion;
    public static string MinorVersion;
    public static string BuildVersion;
    public static string PatchVersion;
    public static string ProductVersion;
    public static string AssemblyMajorVersion;
    public static string AssemblyMinorVersion;
    public static string AssemblyBuildVersion;
    public static string AssemblyPatchVersion;
    public static string AssemblyVersion;
    public static string FileMajorVersion;
    public static string FileMinorVersion;
    public static string FileBuildVersion;
    public static string FilePatchVersion;
    public static string FileVersion;
    public static string VisualStudioMajorVersion;
    public static string VisualStudioVersion;
    public static string TfsMajorVersion;
    public static string TfsMinorVersion;
    public static string TfsProductVersion;
    public static int TfsUpdateNumber;
    public static string TfsInstallDirectory;
}
[AttributeUsageAttribute("1052")]
[EditorBrowsableAttribute("1")]
public class Microsoft.VisualStudio.Services.Common.GenerateInterfaceAttribute : GenerateConstantAttributeBase {
    [CompilerGeneratedAttribute]
private bool <GenerateInterface>k__BackingField;
    public bool GenerateInterface { get; public set; }
    public GenerateInterfaceAttribute(string alternateName);
    public GenerateInterfaceAttribute(bool generateInterface);
    [CompilerGeneratedAttribute]
public bool get_GenerateInterface();
    [CompilerGeneratedAttribute]
public void set_GenerateInterface(bool value);
}
[AttributeUsageAttribute("28")]
[EditorBrowsableAttribute("1")]
public class Microsoft.VisualStudio.Services.Common.GenerateSpecificConstantsAttribute : GenerateConstantAttribute {
    public GenerateSpecificConstantsAttribute(string alternateName);
}
[EditorBrowsableAttribute("1")]
public class Microsoft.VisualStudio.Services.Common.GraphSecurityConstants : object {
    public static Guid NamespaceId;
    public static string RefsToken;
    public static string SubjectsToken;
    public static int ReadByPublicIdentifier;
    public static int ReadByPersonalIdentifier;
    private static GraphSecurityConstants();
}
public static class Microsoft.VisualStudio.Services.Common.HexConverter : object {
    public static string ToString(Byte[] data);
    public static string ToString(Byte[] data, int startIndex, int length);
    public static string ToStringLowerCase(Byte[] data);
    public static string ToStringLowerCase(Byte[] data, int startIndex, int length);
    public static Byte[] ToByteArray(string hexString);
    public static Byte[] ToByteArray(string hexString, int startIndex, int length);
    public static bool TryToByteArray(string hexString, Byte[]& bytes);
    public static bool TryToByteArray(string hexString, int startIndex, int length, Byte[]& bytes);
    private static string ToString(Byte[] data, int startIndex, int length, Casing casing);
    private static void ToCharsBuffer(byte value, Char[] buffer, int startingIndex, Casing casing);
}
public abstract class Microsoft.VisualStudio.Services.Common.HMACHash`1 : object {
    private string m_content;
    private Byte[] m_hash;
    private string m_hashBase32Encoded;
    private string m_hashBase64Encoded;
    private THMAC m_hashAlgorithm;
    public Byte[] Hash { get; }
    public string HashBase32Encoded { get; }
    public string HashBase64Encoded { get; }
    public HMACHash`1(string content, Byte[] key);
    public sealed virtual void Dispose();
    public Byte[] get_Hash();
    public string get_HashBase32Encoded();
    public string get_HashBase64Encoded();
    private void ComputeHash();
}
public class Microsoft.VisualStudio.Services.Common.HMACSHA256Hash : HMACHash`1<HMACSHA256> {
    public HMACSHA256Hash(string content, Byte[] key);
}
public class Microsoft.VisualStudio.Services.Common.HMACSHA512Hash : HMACHash`1<HMACSHA512> {
    public HMACSHA512Hash(string content, Byte[] key);
}
internal class Microsoft.VisualStudio.Services.Common.HttpRequestMessageWrapper : ValueType {
    private HttpRequestMessage m_request;
    public IHttpHeaders Headers { get; }
    public Uri RequestUri { get; }
    public IDictionary`2<string, object> Properties { get; }
    public HttpRequestMessageWrapper(HttpRequestMessage request);
    public sealed virtual IHttpHeaders get_Headers();
    public sealed virtual Uri get_RequestUri();
    public sealed virtual IDictionary`2<string, object> get_Properties();
    private sealed virtual override IEnumerable`1<string> Microsoft.VisualStudio.Services.Common.IHttpHeaders.GetValues(string name);
    private sealed virtual override void Microsoft.VisualStudio.Services.Common.IHttpHeaders.SetValue(string name, string value);
    private sealed virtual override bool Microsoft.VisualStudio.Services.Common.IHttpHeaders.TryGetValues(string name, IEnumerable`1& values);
}
public class Microsoft.VisualStudio.Services.Common.HttpRequestResult : object {
    [CompilerGeneratedAttribute]
private bool <Success>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpResponseMessage <Response>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpStatusCode <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorMessage>k__BackingField;
    public bool Success { get; public set; }
    public HttpResponseMessage Response { get; public set; }
    public HttpStatusCode Code { get; public set; }
    public string ErrorMessage { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Success();
    [CompilerGeneratedAttribute]
public void set_Success(bool value);
    [CompilerGeneratedAttribute]
public HttpResponseMessage get_Response();
    [CompilerGeneratedAttribute]
public void set_Response(HttpResponseMessage value);
    [CompilerGeneratedAttribute]
public HttpStatusCode get_Code();
    [CompilerGeneratedAttribute]
public void set_Code(HttpStatusCode value);
    [CompilerGeneratedAttribute]
public string get_ErrorMessage();
    [CompilerGeneratedAttribute]
public void set_ErrorMessage(string value);
}
internal class Microsoft.VisualStudio.Services.Common.HttpResponseMessageWrapper : ValueType {
    private HttpResponseMessage m_response;
    public IHttpHeaders Headers { get; }
    public HttpStatusCode StatusCode { get; }
    public HttpResponseMessageWrapper(HttpResponseMessage response);
    public sealed virtual IHttpHeaders get_Headers();
    public sealed virtual HttpStatusCode get_StatusCode();
    private sealed virtual override IEnumerable`1<string> Microsoft.VisualStudio.Services.Common.IHttpHeaders.GetValues(string name);
    private sealed virtual override void Microsoft.VisualStudio.Services.Common.IHttpHeaders.SetValue(string name, string value);
    private sealed virtual override bool Microsoft.VisualStudio.Services.Common.IHttpHeaders.TryGetValues(string name, IEnumerable`1& values);
}
public interface Microsoft.VisualStudio.Services.Common.ICachedVssCredentialProvider {
    public abstract virtual VssCredentials GetCachedCredentials(Uri uri, Boolean& knownUri);
}
public interface Microsoft.VisualStudio.Services.Common.IConcurrencyConsolidator`2 {
    public abstract virtual Task`1<TResult> RunOnceAsync(TKey key, Func`1<Task`1<TResult>> taskFunc);
}
public static class Microsoft.VisualStudio.Services.Common.IdentityAttributeTags : object {
    public static string WildCard;
    public static string AccountName;
    public static string Alias;
    public static string CrossProject;
    public static string Description;
    public static string Disambiguation;
    public static string DistinguishedName;
    public static string Domain;
    public static string GlobalScope;
    public static string MailAddress;
    public static string RestrictedVisible;
    public static string SchemaClassName;
    public static string ScopeName;
    public static string SecurityGroup;
    public static string SpecialType;
    public static string ScopeId;
    public static string ScopeType;
    public static string LocalScopeId;
    public static string SecuringHostId;
    public static string VirtualPlugin;
    public static string ProviderDisplayName;
    public static string IsGroupDeleted;
    public static string Cuid;
    public static string CuidState;
    public static string Puid;
    public static string Oid;
    public static string ConsumerPuid;
    public static string ComplianceValidated;
    public static string AuthenticationCredentialValidFrom;
    public static string MetadataUpdateDate;
    public static string DirectoryAlias;
    public static string CacheMaxAge;
    public static string ServiceStorageKey;
    public static string ProvData;
    public static string AadRefreshToken;
    public static string AadRefreshTokenUpdated;
    public static string AadUserPrincipalName;
    public static string AcsIdentityProvider;
    public static string AadIdentityProvider;
    public static string IdentityProviderClaim;
    public static string NameIdentifierClaim;
    public static string TenantIdentifierClaim;
    public static string AadTenantDisambiguationClaim;
    public static string AadMsaPassthroughClaim;
    public static string AppidClaim;
    public static string ServicePrincipalMetaTypeClaim;
    public static string IdentityTypeClaim;
    public static string IsClientClaim;
    public static string ConfirmedNotificationAddress;
    public static string CustomNotificationAddresses;
    public static string IsDeletedInOrigin;
    public static string ApplicationId;
    public static string ImageId;
    public static string ImageData;
    public static string ImageType;
    public static string ImageUploadDate;
    public static string CandidateImageData;
    public static string CandidateImageUploadDate;
    public static string LastAccessedTime;
    public static string UserId;
    [ObsoleteAttribute]
public static string EmailConfirmationSendDates;
    [ObsoleteAttribute]
public static string MsdnLicense;
    [ObsoleteAttribute]
public static string BasicAuthPwdKey;
    [ObsoleteAttribute]
public static string BasicAuthSaltKey;
    [ObsoleteAttribute]
public static string BasicAuthAlgorithm;
    [ObsoleteAttribute]
public static string BasicAuthFailures;
    [ObsoleteAttribute]
public static string BasicAuthDisabled;
    [ObsoleteAttribute]
public static string BasicAuthPasswordChanges;
    public static HashSet`1<string> ReadOnlyProperties;
    public static HashSet`1<string> GroupReadOnlyProperties;
    [ObsoleteAttribute]
public static ISet`1<string> WhiteListedProperties;
    private static IdentityAttributeTags();
}
[GenerateSpecificConstantsAttribute("")]
public static class Microsoft.VisualStudio.Services.Common.IdentityConstants : object {
    public static string WindowsType;
    public static string TeamFoundationType;
    public static string ClaimsType;
    [EditorBrowsableAttribute("1")]
public static string Wif45ClaimsIdentityType;
    public static string AlternateLoginType;
    public static string BindPendingIdentityType;
    public static string ServerTestIdentity;
    public static string UnauthenticatedIdentityType;
    public static string ServiceIdentityType;
    public static string AggregateIdentityType;
    public static string ImportedIdentityType;
    public static string UnknownIdentityType;
    public static string CspPartnerIdentityType;
    public static string PermissionLevelDefinitionType;
    public static string AadServicePrincipalType;
    public static string GroupScopeType;
    public static string SystemPrefix;
    public static string System_ServicePrincipal;
    public static string System_WellKnownGroup;
    public static string System_License;
    public static string System_Scope;
    public static string System_CspPartner;
    public static string System_PublicAccess;
    public static string System_AccessControl;
    public static int MaxIdLength;
    public static int MaxTypeLength;
    public static byte UnknownIdentityTypeId;
    public static byte UnknownSocialTypeId;
    public static int ActiveUniqueId;
    public static string SchemaClassGroup;
    public static string SchemaClassUser;
    public static string BindPendingSidPrefix;
    [GenerateConstantAttribute("")]
public static string MsaDomain;
    [GenerateConstantAttribute("")]
public static string GitHubDomain;
    public static string DomainQualifiedAccountNameFormat;
    public static string DomainQualifiedAadServicePrincipalFormat;
    public static string MsaSidSuffix;
    public static string AadOidPrefix;
    public static string FrameworkIdentityIdentifierDelimiter;
    public static string IdentityDescriptorPartsSeparator;
    public static string IdentityMinimumResourceVersion;
    public static int DefaultMinimumResourceVersion;
    public static char DomainAccountNameSeparator;
    public static bool DefaultUseAccountNameAsDirectoryAlias;
    public static TimeSpan AuthenticationCredentialValidFromBackDate;
    public static string SwitchHintQueryKey;
    public static char SwitchToPersonal;
    public static char SwitchToWork;
    public static string AllowNonServiceIdentitiesInDeploymentAdminsGroup;
    public static byte DefaultResourceVersion;
    [ObsoleteAttribute]
public static byte ScopeManifestIssuance;
    [ObsoleteAttribute]
public static byte ScopeManifestEnforcementWithInitialGrace;
    [ObsoleteAttribute]
public static byte ScopeManifestEnforcementWithoutInitialGrace;
    public static string GlobalScope;
    public static Guid LinkedId;
    public static IReadOnlyDictionary`2<string, string> IdentityTypeMap;
    public static string SearchingForServicePrincipalsEnabled;
    public static string UserHubSupportServicePrincipalsEnabled;
    public static string OrgGroupMembershipSupportServicePrincipalsEnabled;
    public static string SPSyncGroupMembershipsConfig;
    public static string GroupRulesSupportForServicePrincipalEnabled;
    public static string FixServicePrincipalsWithUnknownMetaType;
    public static string RestrictionOfCertainApisForServicePrincipalsEnabled;
    public static string RequireAadBackedOrgAttributeEnalbed;
    public static string SPPermissionsOperationsInUIEnabled;
    public static string MergeUserAndSPPermissionsInUIEnabled;
    public static string DisableServicePrincipalOrgOwners;
    public static string ObjectLevelSecurityMembersSupportServicePrincipalsEnabled;
    public static string BranchPolicyStatusChecksSupportServicePrincipalsEnabled;
    public static string ArtifactsPermissionsSupportServicePrincipalsEnabled;
    public static string EmsPermissionsSupportServicePrincipalsEnabled;
    public static string AllowedSubjectTypesEnabled;
    public static string AadServicePrincipalRestrictionWhiteList;
    public static string AadServicePrincipalRestrictionWhiteListCategorySessionToken;
    public static string UseIPagedScopedIdentityReaderInterfaceEnabled;
    public static string UseMemberEntitlementDataBuilderEnabled;
    public static string ResolveDisconnectedUsersApiEnabled;
    private static IdentityConstants();
}
[EditorBrowsableAttribute("1")]
public interface Microsoft.VisualStudio.Services.Common.IExternalProviderHttpRequester {
    public abstract virtual bool SendRequest(HttpRequestMessage message, HttpCompletionOption option, HttpResponseMessage& response, HttpStatusCode& code, String& errorMessage);
    public abstract virtual Task`1<HttpRequestResult> SendRequestAsync(HttpRequestMessage message, HttpCompletionOption option);
}
public interface Microsoft.VisualStudio.Services.Common.IExternalProviderHttpRequesterFactory {
    public string ProviderType { get; }
    public abstract virtual string get_ProviderType();
    public abstract virtual void Initialize(object requestContext);
    public abstract virtual IExternalProviderHttpRequester GetRequester(HttpMessageHandler httpMessageHandler);
}
public interface Microsoft.VisualStudio.Services.Common.IHttpHeaders {
    public abstract virtual IEnumerable`1<string> GetValues(string name);
    public abstract virtual void SetValue(string name, string value);
    public abstract virtual bool TryGetValues(string name, IEnumerable`1& values);
}
public interface Microsoft.VisualStudio.Services.Common.IHttpRequest {
    public IHttpHeaders Headers { get; }
    public Uri RequestUri { get; }
    public IDictionary`2<string, object> Properties { get; }
    public abstract virtual IHttpHeaders get_Headers();
    public abstract virtual Uri get_RequestUri();
    public abstract virtual IDictionary`2<string, object> get_Properties();
}
public interface Microsoft.VisualStudio.Services.Common.IHttpResponse {
    public IHttpHeaders Headers { get; }
    public HttpStatusCode StatusCode { get; }
    public abstract virtual IHttpHeaders get_Headers();
    public abstract virtual HttpStatusCode get_StatusCode();
}
[EditorBrowsableAttribute("1")]
public static class Microsoft.VisualStudio.Services.Common.Internal.CommonResources : object {
    private static ResourceManager s_resMgr;
    public static ResourceManager Manager { get; }
    private static CommonResources();
    public static ResourceManager get_Manager();
    private static string Get(string resourceName);
    private static string Get(string resourceName, CultureInfo culture);
    public static int GetInt(string resourceName);
    public static int GetInt(string resourceName, CultureInfo culture);
    public static bool GetBool(string resourceName);
    public static bool GetBool(string resourceName, CultureInfo culture);
    private static string Format(string resourceName, Object[] args);
    private static string Format(string resourceName, CultureInfo culture, Object[] args);
    public static string EmptyCollectionNotAllowed();
    public static string EmptyCollectionNotAllowed(CultureInfo culture);
    public static string EmptyStringNotAllowed();
    public static string EmptyStringNotAllowed(CultureInfo culture);
    public static string StringLengthNotAllowed(object arg0, object arg1, object arg2);
    public static string StringLengthNotAllowed(object arg0, object arg1, object arg2, CultureInfo culture);
    public static string EmptyGuidNotAllowed(object arg0);
    public static string EmptyGuidNotAllowed(object arg0, CultureInfo culture);
    public static string InvalidPropertyName(object arg0);
    public static string InvalidPropertyName(object arg0, CultureInfo culture);
    public static string InvalidPropertyValueSize(object arg0, object arg1, object arg2);
    public static string InvalidPropertyValueSize(object arg0, object arg1, object arg2, CultureInfo culture);
    public static string DateTimeKindMustBeSpecified();
    public static string DateTimeKindMustBeSpecified(CultureInfo culture);
    public static string PropertyArgumentExceededMaximumSizeAllowed(object arg0, object arg1);
    public static string PropertyArgumentExceededMaximumSizeAllowed(object arg0, object arg1, CultureInfo culture);
    public static string InvalidStringPropertyValueNullAllowed(object arg0, object arg1, object arg2, object arg3, object arg4);
    public static string InvalidStringPropertyValueNullAllowed(object arg0, object arg1, object arg2, object arg3, object arg4, CultureInfo culture);
    public static string InvalidStringPropertyValueNullForbidden(object arg0, object arg1, object arg2, object arg3, object arg4);
    public static string InvalidStringPropertyValueNullForbidden(object arg0, object arg1, object arg2, object arg3, object arg4, CultureInfo culture);
    public static string ValueTypeOutOfRange(object arg0, object arg1, object arg2, object arg3, object arg4);
    public static string ValueTypeOutOfRange(object arg0, object arg1, object arg2, object arg3, object arg4, CultureInfo culture);
    public static string VssPropertyValueOutOfRange(object arg0, object arg1, object arg2, object arg3);
    public static string VssPropertyValueOutOfRange(object arg0, object arg1, object arg2, object arg3, CultureInfo culture);
    public static string VssInvalidUnicodeCharacter(object arg0);
    public static string VssInvalidUnicodeCharacter(object arg0, CultureInfo culture);
    public static string ErrorReadingFile(object arg0, object arg1);
    public static string ErrorReadingFile(object arg0, object arg1, CultureInfo culture);
    public static string IllegalBase64String();
    public static string IllegalBase64String(CultureInfo culture);
    public static string CannotPromptIfNonInteractive();
    public static string CannotPromptIfNonInteractive(CultureInfo culture);
    public static string StringContainsInvalidCharacters(object arg0);
    public static string StringContainsInvalidCharacters(object arg0, CultureInfo culture);
    public static string DoubleValueOutOfRange(object arg0, object arg1);
    public static string DoubleValueOutOfRange(object arg0, object arg1, CultureInfo culture);
    public static string HttpRequestTimeout(object arg0);
    public static string HttpRequestTimeout(object arg0, CultureInfo culture);
    public static string VssUnauthorized(object arg0);
    public static string VssUnauthorized(object arg0, CultureInfo culture);
    public static string VssUnauthorizedUnknownServer();
    public static string VssUnauthorizedUnknownServer(CultureInfo culture);
    public static string XmlAttributeEmpty(object arg0, object arg1);
    public static string XmlAttributeEmpty(object arg0, object arg1, CultureInfo culture);
    public static string XmlAttributeNull(object arg0, object arg1);
    public static string XmlAttributeNull(object arg0, object arg1, CultureInfo culture);
    public static string XmlNodeEmpty(object arg0, object arg1);
    public static string XmlNodeEmpty(object arg0, object arg1, CultureInfo culture);
    public static string XmlNodeMissing(object arg0, object arg1);
    public static string XmlNodeMissing(object arg0, object arg1, CultureInfo culture);
    public static string VssUnsupportedPropertyValueType(object arg0, object arg1);
    public static string VssUnsupportedPropertyValueType(object arg0, object arg1, CultureInfo culture);
    public static string ErrorDependencyOptionNotProvided(object arg0, object arg1);
    public static string ErrorDependencyOptionNotProvided(object arg0, object arg1, CultureInfo culture);
    public static string ErrorInvalidEnumValueTypeConversion(object arg0);
    public static string ErrorInvalidEnumValueTypeConversion(object arg0, CultureInfo culture);
    public static string ErrorInvalidResponseFileOption(object arg0);
    public static string ErrorInvalidResponseFileOption(object arg0, CultureInfo culture);
    public static string ErrorInvalidValueTypeConversion(object arg0, object arg1);
    public static string ErrorInvalidValueTypeConversion(object arg0, object arg1, CultureInfo culture);
    public static string ErrorOptionArgumentsNotDefined();
    public static string ErrorOptionArgumentsNotDefined(CultureInfo culture);
    public static string ErrorOptionMultiplesNotAllowed(object arg0);
    public static string ErrorOptionMultiplesNotAllowed(object arg0, CultureInfo culture);
    public static string ErrorOptionMustExist(object arg0);
    public static string ErrorOptionMustExist(object arg0, CultureInfo culture);
    public static string ErrorOptionNotRecognized(object arg0);
    public static string ErrorOptionNotRecognized(object arg0, CultureInfo culture);
    public static string ErrorOptionRequired(object arg0);
    public static string ErrorOptionRequired(object arg0, CultureInfo culture);
    public static string ErrorOptionRequiresValue(object arg0);
    public static string ErrorOptionRequiresValue(object arg0, CultureInfo culture);
    public static string ErrorOptionRunsDoNotSupportValues();
    public static string ErrorOptionRunsDoNotSupportValues(CultureInfo culture);
    public static string ErrorOptionsAreMutuallyExclusive(object arg0);
    public static string ErrorOptionsAreMutuallyExclusive(object arg0, CultureInfo culture);
    public static string ErrorOptionsAreMutuallyInclusive(object arg0);
    public static string ErrorOptionsAreMutuallyInclusive(object arg0, CultureInfo culture);
    public static string ErrorOptionValueConverterNotFound(object arg0);
    public static string ErrorOptionValueConverterNotFound(object arg0, CultureInfo culture);
    public static string ErrorOptionValueNotAllowed(object arg0);
    public static string ErrorOptionValueNotAllowed(object arg0, CultureInfo culture);
    public static string ErrorOptionValuesDoNotMatchExpected(object arg0, object arg1);
    public static string ErrorOptionValuesDoNotMatchExpected(object arg0, object arg1, CultureInfo culture);
    public static string ErrorPositionalArgumentsNotAllowed();
    public static string ErrorPositionalArgumentsNotAllowed(CultureInfo culture);
    public static string ErrorRequiredOptionDoesNotExist(object arg0);
    public static string ErrorRequiredOptionDoesNotExist(object arg0, CultureInfo culture);
    public static string ErrorResponseFileNotFound(object arg0);
    public static string ErrorResponseFileNotFound(object arg0, CultureInfo culture);
    public static string ErrorResponseFileOptionNotSupported();
    public static string ErrorResponseFileOptionNotSupported(CultureInfo culture);
    public static string ErrorValueCannotBeConvertedToEnum(object arg0, object arg1);
    public static string ErrorValueCannotBeConvertedToEnum(object arg0, object arg1, CultureInfo culture);
    public static string OperationHandlerNotFound(object arg0);
    public static string OperationHandlerNotFound(object arg0, CultureInfo culture);
    public static string ErrorInvalidValueConverterOrNoDefaultFound(object arg0);
    public static string ErrorInvalidValueConverterOrNoDefaultFound(object arg0, CultureInfo culture);
    public static string ErrorOperationHandlerConstructorNotFound(object arg0);
    public static string ErrorOperationHandlerConstructorNotFound(object arg0, CultureInfo culture);
    public static string ErrorOperationHandlerNotFound();
    public static string ErrorOperationHandlerNotFound(CultureInfo culture);
    public static string ErrorDuplicateDefaultOperationModeHandlerFound();
    public static string ErrorDuplicateDefaultOperationModeHandlerFound(CultureInfo culture);
    public static string ErrorDuplicateOperationModeHandlerFound();
    public static string ErrorDuplicateOperationModeHandlerFound(CultureInfo culture);
    public static string ErrorInvalidValueConverterDataType(object arg0, object arg1);
    public static string ErrorInvalidValueConverterDataType(object arg0, object arg1, CultureInfo culture);
    public static string ErrorMembersContainingPositionalsRequireCollection();
    public static string ErrorMembersContainingPositionalsRequireCollection(CultureInfo culture);
    public static string ErrorDuplicatePositionalOptionAttributes(object arg0);
    public static string ErrorDuplicatePositionalOptionAttributes(object arg0, CultureInfo culture);
    public static string ErrorOptionsAllowingMultiplesRequireCollection(object arg0);
    public static string ErrorOptionsAllowingMultiplesRequireCollection(object arg0, CultureInfo culture);
    public static string ErrorOptionNotFound(object arg0);
    public static string ErrorOptionNotFound(object arg0, CultureInfo culture);
    public static string ErrorOptionFlagRequiresBooleanMember(object arg0);
    public static string ErrorOptionFlagRequiresBooleanMember(object arg0, CultureInfo culture);
    public static string ContentIdCalculationBlockSizeError(object arg0);
    public static string ContentIdCalculationBlockSizeError(object arg0, CultureInfo culture);
    public static string BasicAuthenticationRequiresSsl();
    public static string BasicAuthenticationRequiresSsl(CultureInfo culture);
    public static string ValueOutOfRange(object arg0, object arg1, object arg2, object arg3);
    public static string ValueOutOfRange(object arg0, object arg1, object arg2, object arg3, CultureInfo culture);
    public static string OutOfRange(object arg0);
    public static string OutOfRange(object arg0, CultureInfo culture);
    public static string ValueMustBeGreaterThanZero();
    public static string ValueMustBeGreaterThanZero(CultureInfo culture);
    public static string NullValueNecessary(object arg0);
    public static string NullValueNecessary(object arg0, CultureInfo culture);
    public static string LowercaseStringRequired(object arg0);
    public static string LowercaseStringRequired(object arg0, CultureInfo culture);
    public static string UppercaseStringRequired(object arg0);
    public static string UppercaseStringRequired(object arg0, CultureInfo culture);
    public static string EmptyArrayNotAllowed();
    public static string EmptyArrayNotAllowed(CultureInfo culture);
    public static string EmptyOrWhiteSpaceStringNotAllowed();
    public static string EmptyOrWhiteSpaceStringNotAllowed(CultureInfo culture);
    public static string StringLengthNotMatch(object arg0);
    public static string StringLengthNotMatch(object arg0, CultureInfo culture);
    public static string BothStringsCannotBeNull(object arg0, object arg1);
    public static string BothStringsCannotBeNull(object arg0, object arg1, CultureInfo culture);
    public static string WhiteSpaceNotAllowed();
    public static string WhiteSpaceNotAllowed(CultureInfo culture);
    public static string UnexpectedType(object arg0, object arg1);
    public static string UnexpectedType(object arg0, object arg1, CultureInfo culture);
    public static string InvalidEmailAddressError();
    public static string InvalidEmailAddressError(CultureInfo culture);
    public static string AbsoluteVirtualPathNotAllowed(object arg0);
    public static string AbsoluteVirtualPathNotAllowed(object arg0, CultureInfo culture);
    public static string UriUtility_AbsoluteUriRequired(object arg0);
    public static string UriUtility_AbsoluteUriRequired(object arg0, CultureInfo culture);
    public static string UriUtility_RelativePathInvalid(object arg0);
    public static string UriUtility_RelativePathInvalid(object arg0, CultureInfo culture);
    public static string UriUtility_UriNotAllowed(object arg0);
    public static string UriUtility_UriNotAllowed(object arg0, CultureInfo culture);
    public static string UriUtility_MustBeAuthorityOnlyUri(object arg0, object arg1);
    public static string UriUtility_MustBeAuthorityOnlyUri(object arg0, object arg1, CultureInfo culture);
    public static string UrlNotValid();
    public static string UrlNotValid(CultureInfo culture);
    public static string MalformedArtifactId(object arg0);
    public static string MalformedArtifactId(object arg0, CultureInfo culture);
    public static string MalformedUri(object arg0);
    public static string MalformedUri(object arg0, CultureInfo culture);
    public static string MalformedUrl(object arg0);
    public static string MalformedUrl(object arg0, CultureInfo culture);
    public static string NullArtifactUrl();
    public static string NullArtifactUrl(CultureInfo culture);
    public static string FailureGetArtifact();
    public static string FailureGetArtifact(CultureInfo culture);
    public static string NullArtifactUriRoot();
    public static string NullArtifactUriRoot(CultureInfo culture);
    public static string UnknownTypeForSerialization(object arg0);
    public static string UnknownTypeForSerialization(object arg0, CultureInfo culture);
    public static string StringContainsIllegalChars();
    public static string StringContainsIllegalChars(CultureInfo culture);
    public static string ValueEqualsToInfinity();
    public static string ValueEqualsToInfinity(CultureInfo culture);
    public static string SingleBitRequired(object arg0);
    public static string SingleBitRequired(object arg0, CultureInfo culture);
    public static string InvalidEnumArgument(object arg0, object arg1, object arg2);
    public static string InvalidEnumArgument(object arg0, object arg1, object arg2, CultureInfo culture);
    public static string ConflictingPathSeparatorForVssFileStorage(object arg0, object arg1, object arg2);
    public static string ConflictingPathSeparatorForVssFileStorage(object arg0, object arg1, object arg2, CultureInfo culture);
    public static string ConflictingStringComparerForVssFileStorage(object arg0, object arg1, object arg2);
    public static string ConflictingStringComparerForVssFileStorage(object arg0, object arg1, object arg2, CultureInfo culture);
    public static string InvalidClientStoragePath(object arg0, object arg1);
    public static string InvalidClientStoragePath(object arg0, object arg1, CultureInfo culture);
    public static string CollectionSizeLimitExceeded(object arg0, object arg1);
    public static string CollectionSizeLimitExceeded(object arg0, object arg1, CultureInfo culture);
    public static string DefaultValueNotAllowed(object arg0);
    public static string DefaultValueNotAllowed(object arg0, CultureInfo culture);
    public static string NullElementNotAllowedInCollection();
    public static string NullElementNotAllowedInCollection(CultureInfo culture);
    public static string InvalidUriError(object arg0);
    public static string InvalidUriError(object arg0, CultureInfo culture);
    public static string SubjectDescriptorEmpty(object arg0);
    public static string SubjectDescriptorEmpty(object arg0, CultureInfo culture);
    public static string EUIILeakException(object arg0);
    public static string EUIILeakException(object arg0, CultureInfo culture);
    public static string UnexpectedBoolValue(object arg0, object arg1, object arg2);
    public static string UnexpectedBoolValue(object arg0, object arg1, object arg2, CultureInfo culture);
    public static string AvatarUtils_ContentMissingMessage();
    public static string AvatarUtils_ContentMissingMessage(CultureInfo culture);
    public static string AvatarUtils_ImageParseError();
    public static string AvatarUtils_ImageParseError(CultureInfo culture);
    public static string AvatarUtils_ImageTooLargeMessage(object arg0);
    public static string AvatarUtils_ImageTooLargeMessage(object arg0, CultureInfo culture);
    public static string AvatarUtils_ImageZeroBytesMessage();
    public static string AvatarUtils_ImageZeroBytesMessage(CultureInfo culture);
}
public class Microsoft.VisualStudio.Services.Common.Internal.DeviceJoinInfomation : object {
    [CompilerGeneratedAttribute]
private DeviceJoinType <JoinType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeviceId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IdpDomain>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <JoinUserEmail>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TenantDisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MdmEnrollmentUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MdmTermsOfUseUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MdmComplianceUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserSettingSyncUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserEmail>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserKeyId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserKeyName>k__BackingField;
    public DeviceJoinType JoinType { get; }
    public string DeviceId { get; }
    public string IdpDomain { get; }
    public string TenantId { get; }
    public string JoinUserEmail { get; }
    public string TenantDisplayName { get; }
    public string MdmEnrollmentUrl { get; }
    public string MdmTermsOfUseUrl { get; }
    public string MdmComplianceUrl { get; }
    public string UserSettingSyncUrl { get; }
    public string UserEmail { get; }
    public string UserKeyId { get; }
    public string UserKeyName { get; }
    internal DeviceJoinInfomation(DSREG_JOIN_INFO& joinInfo);
    [CompilerGeneratedAttribute]
public DeviceJoinType get_JoinType();
    [CompilerGeneratedAttribute]
public string get_DeviceId();
    [CompilerGeneratedAttribute]
public string get_IdpDomain();
    [CompilerGeneratedAttribute]
public string get_TenantId();
    [CompilerGeneratedAttribute]
public string get_JoinUserEmail();
    [CompilerGeneratedAttribute]
public string get_TenantDisplayName();
    [CompilerGeneratedAttribute]
public string get_MdmEnrollmentUrl();
    [CompilerGeneratedAttribute]
public string get_MdmTermsOfUseUrl();
    [CompilerGeneratedAttribute]
public string get_MdmComplianceUrl();
    [CompilerGeneratedAttribute]
public string get_UserSettingSyncUrl();
    [CompilerGeneratedAttribute]
public string get_UserEmail();
    [CompilerGeneratedAttribute]
public string get_UserKeyId();
    [CompilerGeneratedAttribute]
public string get_UserKeyName();
    public virtual string ToString();
}
public enum Microsoft.VisualStudio.Services.Common.Internal.DeviceJoinType : Enum {
    public int value__;
    public static DeviceJoinType Unknown;
    public static DeviceJoinType DeviceJoin;
    public static DeviceJoinType WorkplaceJoin;
}
[EditorBrowsableAttribute("1")]
public static class Microsoft.VisualStudio.Services.Common.Internal.HtmlUtility : object {
    public static string CreateAutoSubmitForm(string uriString, IDictionary`2<string, string> inputs, string title);
}
[EditorBrowsableAttribute("1")]
public static class Microsoft.VisualStudio.Services.Common.Internal.HttpHeaders : object {
    public static string ActivityId;
    public static string ETag;
    public static string Referrer;
    public static string TfsVersion;
    public static string TfsRedirect;
    public static string TfsException;
    public static string TfsServiceError;
    public static string TfsSessionHeader;
    public static string TfsSoapException;
    public static string TfsFedAuthRealm;
    public static string TfsFedAuthIssuer;
    public static string TfsFedAuthRedirect;
    public static string VssAuthorizationEndpoint;
    public static string VssPageHandlers;
    public static string VssE2EID;
    public static string VssOrchestrationId;
    public static string AuditCorrelationId;
    public static string VssOriginUserAgent;
    public static string VssSenderDeploymentId;
    public static string TfsInstanceHeader;
    public static string TfsVersionOneHeader;
    public static string TfsImpersonate;
    public static string TfsSubjectDescriptorImpersonate;
    public static string MsContinuationToken;
    public static string VssUserData;
    public static string VssAgentHeader;
    public static string VssAuthenticateError;
    public static string RequestedWith;
    public static string VssRateLimitResource;
    public static string VssRateLimitDelay;
    public static string VssRateLimitLimit;
    public static string VssRateLimitRemaining;
    public static string VssRateLimitReset;
    public static string RetryAfter;
    public static string VssGlobalMessage;
    public static string VssRequestRouted;
    public static string VssUseRequestRouting;
    public static string VssResourceTenant;
    public static string VssOverridePrompt;
    public static string VssOAuthS2STargetService;
    public static string VssHostOfflineError;
    public static string VssForceMsaPassThrough;
    public static string VssRequestPriority;
    public static string VssClientAccessMapping;
    public static string VssReadConsistencyLevel;
    public static string VssDownloadTicket;
    public static string IfModifiedSince;
    public static string Authorization;
    public static string Location;
    public static string ProxyAuthenticate;
    public static string WwwAuthenticate;
    public static string AfdIncomingRouteKey;
    public static string AfdOutgoingRouteKey;
    public static string AfdIncomingEndpointList;
    public static string AfdOutgoingEndpointList;
    public static string AfdResponseRef;
    public static string AfdIncomingClientIp;
    public static string AfdIncomingSocketIp;
    public static string ArrForwardedFor;
    public static string ArrAuthorization;
    public static string AfdIncomingRef;
    public static string AfdIncomingEventId;
    public static string AfdIncomingEdgeEnvironment;
    public static string AfdOutgoingQualityOfResponse;
    public static string AfdOutgoingClientIp;
    public static string SmartRouterForwardedFor;
}
internal class Microsoft.VisualStudio.Services.Common.Internal.NativeMethods : object {
    public static int ERROR_SUCCESS;
    public static int ERROR_FILE_NOT_FOUND;
    public static int ERROR_ACCESS_DENIED;
    public static int ERROR_INVALID_HANDLE;
    public static int ERROR_CANNOT_MAKE;
    public static int MAX_PATH;
    private static int FORMAT_MESSAGE_FROM_SYSTEM;
    public static UInt32 CRED_TYPE_GENERIC;
    public static UInt32 CRED_TYPE_DOMAIN_PASSWORD;
    public static int CREDUI_FLAGS_INCORRECT_PASSWORD;
    public static int CREDUI_FLAGS_DO_NOT_PERSIST;
    public static int CREDUI_FLAGS_REQUEST_ADMINISTRATOR;
    public static int CREDUI_FLAGS_EXCLUDE_CERTIFICATES;
    public static int CREDUI_FLAGS_REQUIRE_CERTIFICATE;
    public static int CREDUI_FLAGS_SHOW_SAVE_CHECK_BOX;
    public static int CREDUI_FLAGS_ALWAYS_SHOW_UI;
    public static int CREDUI_FLAGS_REQUIRE_SMARTCARD;
    public static int CREDUI_FLAGS_PASSWORD_ONLY_OK;
    public static int CREDUI_FLAGS_VALIDATE_USERNAME;
    public static int CREDUI_FLAGS_COMPLETE_USERNAME;
    public static int CREDUI_FLAGS_PERSIST;
    public static int CREDUI_FLAGS_SERVER_CREDENTIAL;
    public static int CREDUI_FLAGS_EXPECT_CONFIRMATION;
    public static int CREDUI_FLAGS_GENERIC_CREDENTIALS;
    public static int CREDUI_FLAGS_USERNAME_TARGET_CREDENTIALS;
    public static int CREDUI_FLAGS_KEEP_USERNAME;
    public static int CRED_PACK_PROTECTED_CREDENTIALS;
    public static int NO_ERROR;
    public static int CREDUI_MAX_USERNAME_LENGTH;
    public static int CREDUI_MAX_PASSWORD_LENGTH;
    public static int CREDUI_MAX_CAPTION_LENGTH;
    public static int CREDUI_MAX_MESSAGE_LENGTH;
    public static int CREDUIWIN_CHECKBOX;
    public static int CREDUIWIN_AUTHPACKAGE_ONLY;
    public static int CRED_PERSIST_LOCAL_MACHINE;
    public static bool IsWow64 { get; }
    public static bool IsWow64Process(IntPtr hProcess, Boolean& lpSystemInfo);
    public static bool get_IsWow64();
    private static int GetModuleFileName(IntPtr hModule, StringBuilder lpFilename, int nSize);
    public static string GetModuleFileName();
    public static string GetModuleFileName(IntPtr hModule);
    private static int FormatMessage(UInt32 dwFlags, IntPtr lpSource, UInt32 dwMessageId, int dwLanguageId, StringBuilder lpBuffer, int nSize, IntPtr Arguments);
    public static string FormatError(int number);
    private static bool GetVersionEx(OSVersionInfoEx ver);
    public static bool GetProductInfo(int osMajorVersion, int osMinorVersion, int spMajorVersion, int spMinorVersion, Int32& edition);
    private static int NetGetJoinInformation(string server, IntPtr& domain, NetJoinStatus& status);
    public static void NetGetJoinInformation(string server, String& domain, NetJoinStatus& joinStatus);
    public static void NetFreeAadJoinInformation(IntPtr pJoinInfo);
    public static int NetGetAadJoinInformation(string pcszTenantId, IntPtr& ppJoinInfo);
    public static bool IsAadJoined(DeviceJoinInfomation& deviceJoinInfomation);
    public static int NetApiBufferFree(IntPtr bufferPtr);
    public static bool CredRead(string targetName, UInt32 type, UInt32 flags, IntPtr& credential);
    public static bool CredWrite(CREDENTIAL& credential, UInt32 flags);
    public static bool CredDelete(string targetName, UInt32 type, UInt32 flags);
    public static void CredFree(IntPtr buffer);
    public static int CredUIParseUserName(string pszUserName, StringBuilder pszUser, UInt32 ulUserMaxChars, StringBuilder pszDomain, UInt32 ulDomainMaxChars);
    public static void ZeroMemory(IntPtr address, UInt32 byteCount);
    public static void GetNativeSystemInfo(SYSTEM_INFO& lpSystemInfo);
}
public static class Microsoft.VisualStudio.Services.Common.Internal.PasswordUtility : object {
    private static Char[] punctuations;
    private static Char[] startingChars;
    private static PasswordUtility();
    public static string GeneratePassword(int length, int numberOfNonAlphanumericCharacters);
    internal static bool IsDangerousString(string s, Int32& matchIndex);
    private static bool IsAtoZ(char c);
}
[EditorBrowsableAttribute("1")]
public class Microsoft.VisualStudio.Services.Common.Internal.PropertyValidation : object {
    private static int c_maxPropertyNameLengthInChars;
    private static int c_maxByteValueSize;
    private static int c_maxStringValueLength;
    private static DateTime s_minAllowedDateTime;
    private static DateTime s_maxAllowedDateTime;
    private static double s_minNegative;
    private static double s_maxNegative;
    private static double s_minPositive;
    private static double s_maxPositive;
    private static Dictionary`2<string, Type> s_validPropertyTypeStrings;
    private static PropertyValidation();
    public static void ValidateDictionary(IDictionary`2<string, object> source);
    public static bool IsValidConvertibleType(Type type);
    public static bool IsValidTypeString(string type);
    public static bool TryGetValidType(string type, Type& result);
    public static void ValidatePropertyName(string propertyName);
    public static void ValidatePropertyValue(string propertyName, object value);
    private static void ValidateStringValue(string propertyName, string propertyValue);
    private static void ValidateByteArray(string propertyName, Byte[] propertyValue);
    private static void ValidateDateTime(string propertyName, DateTime propertyValue);
    private static void ValidateDouble(string propertyName, double propertyValue);
    private static void ValidateInt32(string propertyName, int propertyValue);
    private static void ValidatePropertyString(string propertyString, int maxSize, string argumentName);
    public static void CheckPropertyLength(string propertyValue, bool allowNull, int minLength, int maxLength, string propertyName, Type containerType, string topLevelParamName);
    public static void CheckRange(T propertyValue, T minValue, T maxValue, string propertyName, Type containerType, string topLevelParamName);
    private static void CheckRange(T propertyValue, T minValue, T maxValue, string propertyName, string topLevelParamName);
    public static void ValidatePropertyFilter(string propertyNameFilter);
}
[FlagsAttribute]
[EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public enum Microsoft.VisualStudio.Services.Common.Internal.RegistryAccessMask : Enum {
    public UInt32 value__;
    public static RegistryAccessMask AllAccess;
    public static RegistryAccessMask CreateLink;
    public static RegistryAccessMask CreateSubKey;
    public static RegistryAccessMask EnumerateSubKeys;
    public static RegistryAccessMask Execute;
    public static RegistryAccessMask Notify;
    public static RegistryAccessMask QueryValue;
    public static RegistryAccessMask Read;
    public static RegistryAccessMask SetValue;
    public static RegistryAccessMask Wow6432Key;
    public static RegistryAccessMask Wow6464Key;
    public static RegistryAccessMask Write;
    public static RegistryAccessMask WriteDac;
}
[EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public enum Microsoft.VisualStudio.Services.Common.Internal.RegistryChangeNotificationFilter : Enum {
    public UInt32 value__;
    public static RegistryChangeNotificationFilter NameChange;
    public static RegistryChangeNotificationFilter AttributeChange;
    public static RegistryChangeNotificationFilter ValueChange;
    public static RegistryChangeNotificationFilter SecurityChange;
}
[EditorBrowsableAttribute("1")]
[CLSCompliantAttribute("False")]
public static class Microsoft.VisualStudio.Services.Common.Internal.RegistryHelper : object {
    private static UInt32 MAX_KEY_LENGTH;
    private static UInt32 MAX_VALUE_NAME;
    private static int ERROR_FILE_NOT_FOUND;
    private static IntPtr HKEY_CLASSES_ROOT;
    private static IntPtr HKEY_CURRENT_USER;
    private static IntPtr HKEY_LOCAL_MACHINE;
    private static IntPtr HKEY_USERS;
    private static IntPtr HKEY_CURRENT_CONFIG;
    private static RegistryHelper();
    public static SafeHandle CreateSubKey(RegistryHive hive, string subKey, RegistryAccessMask accessMask);
    public static SafeHandle CreateSubKey(SafeHandle key, string subKey, RegistryAccessMask accessMask);
    public static SafeHandle CreateSubKey(SafeHandle key, string subKey, RegistryAccessMask accessMask, Boolean& createdNew);
    public static SafeHandle CreateSubKey(RegistryHive hive, string subKey, RegistryAccessMask accessMask, RegistrySecurity security);
    public static SafeHandle CreateSubKey(SafeHandle key, string subKey, RegistryAccessMask accessMask, RegistrySecurity security);
    public static void DeleteSubKeyTree(RegistryHive hive, string subKey, RegistryAccessMask accessMask);
    public static void DeleteKeyTree(SafeHandle registryKey);
    public static void DeleteKeyValue(SafeHandle registryKey, string valueName);
    public static void NotifyChangeKeyValue(SafeHandle hKey, bool watchSubtree, RegistryChangeNotificationFilter dwNotifyFilter, SafeHandle hEvent, bool fAsynchronous);
    public static SafeHandle OpenSubKey(RegistryHive hive, string subKey, RegistryAccessMask accessMask);
    public static object GetValue(SafeHandle registryKey, string name, object defaultValue);
    public static void SetValue(SafeHandle registryKey, string name, string value);
    public static void SetValue(SafeHandle registryKey, string name, int value);
    public static void SetValue(SafeHandle registryKey, string name, SecureString value);
    public static String[] GetSubKeyNames(SafeHandle registryKey);
    public static String[] GetValueNames(SafeHandle registryKey);
    public static void QueryInfoKey(SafeHandle hKey, StringBuilder& lpClass, UInt32& lpcbClass, UInt32& lpcSubKeys, UInt32& lpcbMaxSubKeyLen, UInt32& lpcbMaxClassLen, UInt32& lpcValues, UInt32& lpcbMaxValueNameLen, UInt32& lpcbMaxValueLen, UInt32& lpcbSecurityDescriptor, IntPtr lpftLastWriteTime);
    private static IntPtr Convert(RegistryHive hive);
    public static bool SetKeySecurity(SafeHandle registryKey, RegistrySecurity security);
    private static bool TryExtractValue(SafeHandle registryKey, string name, UInt32 valueSize, Object& value);
    private static bool IsWin2k3OrGreater();
    public static string Get32BitRegistryKeyPath(string keyPath);
    public static bool CheckRegistryFlag(RegistryAccessMask wowKind, RegistryHive hive, string keyPath, string valueName, int value);
    public static bool CheckRegistryFlag(RegistryAccessMask wowKind, RegistryHive hive, string keyPath, string valueName, string value);
    public static bool CheckRegistryFlag(RegistryAccessMask wowKind, RegistryHive hive, string keyPath, string valueName);
    public static bool CheckRegistryFlag(RegistryAccessMask wowKind, RegistryHive hive, string keyPath);
    private static bool TestRegistryFlag(RegistryAccessMask wowKind, RegistryHive hive, string keyPath, string valueName, object value);
    private static int RegCreateKeyEx(SafeHandle registryKey, string lpSubKey, UInt32 dwReserved, string lpClass, RegistryOptions dwOptions, RegistryAccessMask samDesired, IntPtr lpSecurityAttributes, SafeRegistryHandle& phkResult, RegistryDispositionValue& lpdwDisposition);
    private static int RegDeleteKey(IntPtr hKey, string lpSubKey);
    private static int RegDeleteKey(SafeHandle hKey, string lpSubKey);
    private static int RegDeleteTree(SafeHandle hKey, string lpSubKey);
    private static int RegDeleteKeyEx(IntPtr hKey, string lpSubKey, RegistryAccessMask samDesired, UInt32 Reserved);
    private static int RegDeleteValue(SafeHandle hKey, string lpValueName);
    private static int RegGetValue(SafeHandle hKey, string lpSubKey, string lpValue, RegistryValueRestrictions dwFlags, RegistryValueKind& pdwType, IntPtr pvData, UInt32& pcbData);
    private static int RegQueryValueEx(SafeHandle registryKey, string lpValueName, IntPtr lpReserved, RegistryValueKind& lpType, IntPtr lpData, UInt32& lpcbData);
    private static int RegNotifyChangeKeyValue(SafeHandle hKey, bool watchSubtree, RegistryChangeNotificationFilter dwNotifyFilter, SafeHandle hEvent, bool fAsynchronous);
    private static int RegOpenKeyEx(IntPtr hKey, string lpSubKey, int ulOptions, RegistryAccessMask samDesired, SafeRegistryHandle& hkResult);
    private static int RegSetValueEx(SafeHandle hKey, string lpValueName, UInt32 Reserved, RegistryValueKind dwType, Int32& lpData, UInt32 cbData);
    private static int RegSetValueEx(SafeHandle hKey, string lpValueName, UInt32 Reserved, RegistryValueKind dwType, string lpData, UInt32 cbData);
    private static int RegSetValueEx(SafeHandle hKey, string lpValueName, UInt32 Reserved, RegistryValueKind dwType, IntPtr lpData, UInt32 cbData);
    private static int RegQueryInfoKey(SafeHandle hKey, StringBuilder& lpClass, UInt32& lpcbClass, IntPtr lpReserved, UInt32& lpcSubKeys, UInt32& lpcbMaxSubKeyLen, UInt32& lpcbMaxClassLen, UInt32& lpcValues, UInt32& lpcbMaxValueNameLen, UInt32& lpcbMaxValueLen, UInt32& lpcbSecurityDescriptor, IntPtr lpftLastWriteTime);
    private static int RegEnumKeyEx(SafeHandle hkey, UInt32 index, StringBuilder lpName, UInt32& lpcbName, IntPtr reserved, IntPtr lpClass, IntPtr lpcbClass, Int64& lpftLastWriteTime);
    private static UInt32 RegEnumValue(SafeHandle hKey, UInt32 dwIndex, StringBuilder lpValueName, UInt32& lpcValueName, IntPtr lpReserved, IntPtr lpType, IntPtr lpData, IntPtr lpcbData);
    private static int RegSetKeySecurity(SafeHandle registryKey, RegistrySecurityInformation securityInformation, IntPtr lpSecurityDescriptor);
}
[FlagsAttribute]
internal enum Microsoft.VisualStudio.Services.Common.Internal.RegistrySecurityInformation : Enum {
    public UInt32 value__;
    public static RegistrySecurityInformation Owner;
    public static RegistrySecurityInformation Group;
    public static RegistrySecurityInformation Dacl;
    public static RegistrySecurityInformation Sacl;
    public static RegistrySecurityInformation ProtectedDacl;
    public static RegistrySecurityInformation ProtectedSacl;
    public static RegistrySecurityInformation UnprotectedDacl;
    public static RegistrySecurityInformation UnprotectedSacl;
}
[EditorBrowsableAttribute("1")]
public static class Microsoft.VisualStudio.Services.Common.Internal.UriUtility : object {
    private static string c_uriSchemeHttp;
    private static string c_uriSchemeHttps;
    private static ICollection`1<string> UnsafeUriSchemeList;
    private static ICollection`1<string> SafeUriSchemeList;
    private static char PathSeparatorChar;
    private static string PathSeparator;
    public static IEqualityComparer`1<Uri> AbsoluteUriStringComparer;
    public static IEqualityComparer`1<string> UrlPathIgnoreSeparatorsComparer;
    private static Char[] _htmlEntityEndingChars;
    private static UriUtility();
    public static bool IsUriUnsafe(Uri uri);
    public static bool IsUriSafe(Uri uri);
    public static bool IsUriLocalFile(Uri uri);
    public static string GetInvariantAbsoluteUri(Uri uri);
    public static Uri Combine(string baseUri, string relativePath, bool treatAbsolutePathAsRelative);
    public static Uri Combine(Uri baseUri, string relativePath, bool treatAbsolutePathAsRelative);
    public static bool Equals(Uri uri1, Uri uri2);
    public static string CombinePath(string part1, string part2);
    public static bool IsUriHttp(Uri uri);
    public static void CheckUriIsHttp(Uri uri);
    public static void CheckUriIsHttp(Uri uri, bool allowPathAndQuery);
    public static void CheckUriIsAbsoluteAndHttp(Uri uri);
    public static void CheckUriIsAbsoluteAndHttp(Uri uri, bool allowPathAndQuery);
    public static void CheckRelativePath(string relativePath);
    public static string GetDavUncFromHttpPath(string httppath);
    public static Uri TryGetHttpUriFromDavUncPath(string uncPath);
    public static bool IsSameMachine(string hostname1, string hostname2);
    public static bool IsSubdomainOf(string domain, string parentDomain);
    public static Uri GetAbsoluteUriFromString(string uriString);
    public static Uri GetUriFromString(string val);
    public static bool TryCreateAbsoluteUri(string val, bool requireHttpScheme, Uri& uri);
    public static string EnsureStartsWithPathSeparator(string relativePath);
    public static string EnsureEndsWithPathSeparator(string relativePath);
    public static string TrimStartingPathSeparator(string relativePath);
    public static string TrimEndingPathSeparator(string relativePath);
    public static string TrimPathSeparators(string relativePath);
    public static string AppendSlashToPathIfNeeded(string path);
    public static Uri NormalizePathSeparators(Uri uri);
    public static NameValueCollection ParseFragmentString(string fragment);
    public static NameValueCollection ParseFragmentString(string fragment, Encoding encoding);
    public static NameValueCollection ParseFragmentString(string fragment, Encoding encoding, bool urlEncoded);
    public static NameValueCollection ParseQueryString(string query);
    public static NameValueCollection ParseQueryString(string query, Encoding encoding);
    public static NameValueCollection ParseQueryString(string query, Encoding encoding, bool urlEncoded);
    private static Byte[] UrlEncode(Byte[] bytes, int offset, int count, bool alwaysCreateNewReturnValue);
    private static Byte[] UrlEncode(Byte[] bytes, int offset, int count);
    private static string UrlEncodeNonAscii(string str, Encoding e);
    private static Byte[] UrlEncodeNonAscii(Byte[] bytes, int offset, int count, bool alwaysCreateNewReturnValue);
    public static string UrlEncode(string str);
    public static string Base64Encode(string str);
    public static string UrlEncode(string str, Encoding e);
    public static string UrlEncode(Byte[] bytes);
    public static Byte[] UrlEncodeToBytes(string str);
    public static Byte[] UrlEncodeToBytes(Byte[] bytes);
    public static Byte[] UrlEncodeToBytes(string str, Encoding e);
    public static Byte[] UrlEncodeToBytes(Byte[] bytes, int offset, int count);
    public static string UrlPathEncode(string str);
    public static string UrlEncodeUnicode(string value);
    public static string HtmlEncode(string value);
    public static void HtmlEncode(string value, TextWriter output);
    private static int IndexOfHtmlEncodingChars(string s, int startPos);
    private static string UrlDecodeInternal(string value, Encoding encoding);
    private static Byte[] UrlDecodeInternal(Byte[] bytes, int offset, int count);
    private static string UrlDecodeInternal(Byte[] bytes, int offset, int count, Encoding encoding);
    public static string UrlDecode(string str);
    public static string Base64Decode(string str);
    public static string UrlDecode(string str, Encoding e);
    public static string UrlDecode(Byte[] bytes, Encoding e);
    public static string UrlDecode(Byte[] bytes, int offset, int count, Encoding e);
    public static Byte[] UrlDecodeToBytes(string str);
    public static Byte[] UrlDecodeToBytes(string str, Encoding e);
    public static Byte[] UrlDecodeToBytes(Byte[] bytes);
    public static Byte[] UrlDecodeToBytes(Byte[] bytes, int offset, int count);
    public static int HexToInt(char h);
    public static char IntToHex(int n);
    public static bool IsUrlSafeChar(char ch);
    internal static string UrlEncodeSpaces(string str);
    private static bool ValidateUrlEncodingParameters(Byte[] bytes, int offset, int count);
    private static bool IsNonAsciiByte(byte b);
    public static string HtmlDecode(string value);
    public static void HtmlDecode(string value, TextWriter output);
}
[EditorBrowsableAttribute("1")]
public class Microsoft.VisualStudio.Services.Common.Internal.XmlElementWriterUtility : object {
    private XmlWriter m_xmlWriter;
    public XmlElementWriterUtility(string elementName, XmlWriter xmlWriter);
    public sealed virtual void Dispose();
}
[EditorBrowsableAttribute("1")]
public static class Microsoft.VisualStudio.Services.Common.Internal.XmlUtility : object {
    private static XmlReaderSettings s_safeSettings;
    [ThreadStaticAttribute]
private static String[] ts_stringList;
    private static int c_stringCacheSize;
    private static Byte[] s_zeroLengthArrayOfByte;
    private static AttributeComparer s_xmlAttributeComparer;
    private static ElementComparer s_xmlElementComparer;
    public static XmlReaderSettings SecureReaderSettings { get; }
    public static Byte[] ZeroLengthArrayOfByte { get; }
    private static XmlUtility();
    internal static FileStream OpenFile(string path, FileShare sharing, bool saveFile);
    internal static XmlDocument OpenXmlFile(FileStream& file, string path, FileShare sharing, bool saveFile);
    private static FileStream OpenFileHelper(string path, FileShare sharing, bool saveFile, bool loadAsXmlDocument, XmlDocument& xmlDocument);
    internal static void AddXmlAttribute(XmlNode node, string attrName, string value);
    public static XmlReaderSettings get_SecureReaderSettings();
    public static XmlDocument GetDocument(Stream input);
    public static XmlDocument GetDocument(string xml);
    public static XmlDocument GetDocumentFromPath(string path);
    public static DateTime ToDateTime(string s);
    public static DateTime ToDateOnly(string s);
    public static string ToStringDateOnly(DateTime d);
    public static string ToString(DateTime d);
    public static void ObjectToXmlElement(XmlWriter writer, string element, object o);
    public static object ObjectFromXmlElement(XmlReader reader);
    public static void ToXml(XmlWriter writer, string element, Object[] array);
    public static Object[] ArrayOfObjectFromXml(XmlReader reader);
    public static void ToXmlElement(XmlWriter writer, string elementName, XmlNode node);
    public static XmlNode XmlNodeFromXmlElement(XmlReader reader);
    public static DateTime DateFromXmlAttribute(XmlReader reader);
    public static DateTime DateFromXmlElement(XmlReader reader);
    public static void DateToXmlAttribute(XmlWriter writer, string name, DateTime value);
    public static void DateToXmlElement(XmlWriter writer, string name, DateTime value);
    public static bool BooleanFromXmlAttribute(XmlReader reader);
    public static DateTime DateTimeFromXmlAttribute(XmlReader reader);
    public static DateTime DateTimeFromXmlElement(XmlReader reader);
    public static void ToXmlAttribute(XmlWriter writer, string name, DateTime value);
    public static void ToXmlElement(XmlWriter writer, string name, DateTime value);
    public static void ToXml(XmlWriter writer, string element, Byte[] array);
    public static void ToXmlAttribute(XmlWriter writer, string attr, Byte[] array);
    public static string ToString(Uri uri);
    public static Uri ToUri(string s);
    public static void EnumToXmlAttribute(XmlWriter writer, string attr, T value);
    public static T EnumFromXmlAttribute(XmlReader reader);
    public static void EnumToXmlElement(XmlWriter writer, string element, T value);
    public static T EnumFromXmlElement(XmlReader reader);
    public static T[] ArrayOfObjectFromXml(XmlReader reader, string arrayElementName, bool inline, Func`2<XmlReader, T> objectFromXmlElement);
    public static T[] ArrayOfObjectFromXml(IServiceProvider serviceProvider, XmlReader reader, string arrayElementName, bool inline, Func`3<IServiceProvider, XmlReader, T> objectFromXmlElement);
    public static void ArrayOfObjectToXml(XmlWriter writer, T[] array, string arrayName, string arrayElementName, bool inline, bool allowEmptyArrays, Action`3<XmlWriter, string, T> objectToXmlElement);
    public static void EnumerableOfObjectToXml(XmlWriter writer, IEnumerable`1<T> enumerable, string arrayName, string arrayElementName, bool inline, bool allowEmptyArrays, Action`3<XmlWriter, string, T> objectToXmlElement);
    public static bool BooleanFromXmlElement(XmlReader reader);
    public static byte ByteFromXmlAttribute(XmlReader reader);
    public static byte ByteFromXmlElement(XmlReader reader);
    public static char CharFromXmlAttribute(XmlReader reader);
    public static char CharFromXmlElement(XmlReader reader);
    public static double DoubleFromXmlAttribute(XmlReader reader);
    public static double DoubleFromXmlElement(XmlReader reader);
    public static Guid GuidFromXmlAttribute(XmlReader reader);
    public static Guid GuidFromXmlElement(XmlReader reader);
    public static short Int16FromXmlAttribute(XmlReader reader);
    public static short Int16FromXmlElement(XmlReader reader);
    public static int Int32FromXmlAttribute(XmlReader reader);
    public static int Int32FromXmlElement(XmlReader reader);
    public static long Int64FromXmlAttribute(XmlReader reader);
    public static long Int64FromXmlElement(XmlReader reader);
    public static float SingleFromXmlAttribute(XmlReader reader);
    public static float SingleFromXmlElement(XmlReader reader);
    public static string StringFromXmlAttribute(XmlReader reader);
    public static string StringFromXmlElement(XmlReader reader);
    public static string StringFromXmlText(XmlReader reader);
    public static TimeSpan TimeSpanFromXmlAttribute(XmlReader reader);
    public static TimeSpan TimeSpanFromXmlElement(XmlReader reader);
    public static ushort UInt16FromXmlAttribute(XmlReader reader);
    public static ushort UInt16FromXmlElement(XmlReader reader);
    public static UInt32 UInt32FromXmlAttribute(XmlReader reader);
    public static UInt32 UInt32FromXmlElement(XmlReader reader);
    public static ulong UInt64FromXmlAttribute(XmlReader reader);
    public static ulong UInt64FromXmlElement(XmlReader reader);
    public static Uri UriFromXmlAttribute(XmlReader reader);
    public static Uri UriFromXmlElement(XmlReader reader);
    public static void ToXmlAttribute(XmlWriter writer, string name, bool value);
    public static void ToXmlAttribute(XmlWriter writer, string name, byte value);
    public static void ToXmlAttribute(XmlWriter writer, string name, char value);
    public static void ToXmlAttribute(XmlWriter writer, string name, double value);
    public static void ToXmlAttribute(XmlWriter writer, string name, Guid value);
    public static void ToXmlAttribute(XmlWriter writer, string name, short value);
    public static void ToXmlAttribute(XmlWriter writer, string name, int value);
    public static void ToXmlAttribute(XmlWriter writer, string name, long value);
    public static void ToXmlAttribute(XmlWriter writer, string name, float value);
    public static void ToXmlAttribute(XmlWriter writer, string name, string value);
    public static void ToXmlAttribute(XmlWriter writer, string name, TimeSpan value);
    public static void ToXmlAttribute(XmlWriter writer, string name, ushort value);
    public static void ToXmlAttribute(XmlWriter writer, string name, UInt32 value);
    public static void ToXmlAttribute(XmlWriter writer, string name, ulong value);
    public static void ToXmlAttribute(XmlWriter writer, string name, Uri value);
    public static void ToXmlElement(XmlWriter writer, string name, bool value);
    public static void ToXmlElement(XmlWriter writer, string name, byte value);
    public static void ToXmlElement(XmlWriter writer, string name, char value);
    public static void ToXmlElement(XmlWriter writer, string name, double value);
    public static void ToXmlElement(XmlWriter writer, string name, Guid value);
    public static void ToXmlElement(XmlWriter writer, string element, short value);
    public static void ToXmlElement(XmlWriter writer, string element, int value);
    public static void ToXmlElement(XmlWriter writer, string element, long value);
    public static void ToXmlElement(XmlWriter writer, string name, float value);
    public static void ToXmlElement(XmlWriter writer, string name, string value);
    public static void ToXmlElement(XmlWriter writer, string name, TimeSpan value);
    public static void ToXmlElement(XmlWriter writer, string element, ushort value);
    public static void ToXmlElement(XmlWriter writer, string element, UInt32 value);
    public static void ToXmlElement(XmlWriter writer, string element, ulong value);
    public static void ToXmlElement(XmlWriter writer, string name, Uri value);
    public static void StringToXmlAttribute(XmlWriter writer, string name, string value);
    public static void StringToXmlElement(XmlWriter writer, string name, string value);
    public static void StringToXmlText(XmlWriter writer, string str);
    public static Byte[] ArrayOfByteFromXml(XmlReader reader);
    public static Byte[] ArrayOfByteFromXmlAttribute(XmlReader reader);
    public static Byte[] get_ZeroLengthArrayOfByte();
    public static bool CompareXmlDocuments(string xml1, string xml2);
    private static bool Compare(XContainer x1, XContainer x2);
    private static string GetCachedString(string fromXml);
}
public abstract class Microsoft.VisualStudio.Services.Common.IssuedToken : object {
    [CompilerGeneratedAttribute]
private bool <FromStorage>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <UserId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserName>k__BackingField;
    private int m_authenticated;
    public bool IsAuthenticated { get; }
    protected internal VssCredentialsType CredentialType { get; }
    internal bool FromStorage { get; internal set; }
    public IDictionary`2<string, string> Properties { get; public set; }
    internal Guid UserId { get; internal set; }
    internal string UserName { get; internal set; }
    public bool get_IsAuthenticated();
    protected internal abstract virtual VssCredentialsType get_CredentialType();
    [CompilerGeneratedAttribute]
internal bool get_FromStorage();
    [CompilerGeneratedAttribute]
internal void set_FromStorage(bool value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
internal Guid get_UserId();
    [CompilerGeneratedAttribute]
internal void set_UserId(Guid value);
    [CompilerGeneratedAttribute]
internal string get_UserName();
    [CompilerGeneratedAttribute]
internal void set_UserName(string value);
    internal bool Authenticated();
    internal void GetUserData(IHttpResponse response);
    internal abstract virtual void ApplyTo(IHttpRequest request);
}
public abstract class Microsoft.VisualStudio.Services.Common.IssuedTokenCredential : object {
    [CompilerGeneratedAttribute]
private IssuedToken <InitialToken>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <TokenStorageUrl>k__BackingField;
    private TaskScheduler m_scheduler;
    private IVssCredentialPrompt m_prompt;
    private IVssCredentialStorage m_storage;
    public VssCredentialsType CredentialType { get; }
    internal IssuedToken InitialToken { get; internal set; }
    internal TaskScheduler Scheduler { get; internal set; }
    internal IVssCredentialPrompt Prompt { get; internal set; }
    internal IVssCredentialStorage Storage { get; internal set; }
    internal Uri TokenStorageUrl { get; internal set; }
    protected IssuedTokenCredential(IssuedToken initialToken);
    public abstract virtual VssCredentialsType get_CredentialType();
    [CompilerGeneratedAttribute]
internal IssuedToken get_InitialToken();
    [CompilerGeneratedAttribute]
internal void set_InitialToken(IssuedToken value);
    internal TaskScheduler get_Scheduler();
    internal void set_Scheduler(TaskScheduler value);
    internal IVssCredentialPrompt get_Prompt();
    internal void set_Prompt(IVssCredentialPrompt value);
    internal IVssCredentialStorage get_Storage();
    internal void set_Storage(IVssCredentialStorage value);
    [CompilerGeneratedAttribute]
internal Uri get_TokenStorageUrl();
    [CompilerGeneratedAttribute]
internal void set_TokenStorageUrl(Uri value);
    internal IssuedTokenProvider CreateTokenProvider(Uri serverUrl, IHttpResponse response, IssuedToken failedToken);
    internal virtual string GetAuthenticationChallenge(IHttpResponse webResponse);
    public abstract virtual bool IsAuthenticationChallenge(IHttpResponse webResponse);
    protected abstract virtual IssuedTokenProvider OnCreateTokenProvider(Uri serverUrl, IHttpResponse response);
}
[EditorBrowsableAttribute("1")]
public abstract class Microsoft.VisualStudio.Services.Common.IssuedTokenProvider : object {
    private static double c_slowTokenAcquisitionTimeInSeconds;
    [CompilerGeneratedAttribute]
private IssuedTokenCredential <Credential>k__BackingField;
    [CompilerGeneratedAttribute]
private IssuedToken <CurrentToken>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <SignInUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ServerUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <TokenStorageUrl>k__BackingField;
    private object m_thisLock;
    private List`1<GetTokenOperation> m_operations;
    protected string AuthenticationScheme { get; }
    protected string AuthenticationParameter { get; }
    protected internal IssuedTokenCredential Credential { get; }
    internal VssCredentialsType CredentialType { get; }
    public IssuedToken CurrentToken { get; internal set; }
    public bool GetTokenIsInteractive { get; }
    private bool InvokeRequired { get; }
    public Uri SignInUrl { get; private set; }
    protected Uri ServerUrl { get; }
    internal Uri TokenStorageUrl { get; internal set; }
    protected IssuedTokenProvider(IssuedTokenCredential credential, Uri serverUrl, Uri signInUrl);
    protected virtual string get_AuthenticationScheme();
    protected virtual string get_AuthenticationParameter();
    [CompilerGeneratedAttribute]
protected internal IssuedTokenCredential get_Credential();
    internal VssCredentialsType get_CredentialType();
    [CompilerGeneratedAttribute]
public IssuedToken get_CurrentToken();
    [CompilerGeneratedAttribute]
internal void set_CurrentToken(IssuedToken value);
    public abstract virtual bool get_GetTokenIsInteractive();
    private bool get_InvokeRequired();
    [CompilerGeneratedAttribute]
public Uri get_SignInUrl();
    [CompilerGeneratedAttribute]
private void set_SignInUrl(Uri value);
    [CompilerGeneratedAttribute]
protected Uri get_ServerUrl();
    [CompilerGeneratedAttribute]
internal Uri get_TokenStorageUrl();
    [CompilerGeneratedAttribute]
internal void set_TokenStorageUrl(Uri value);
    protected internal virtual bool IsAuthenticationChallenge(IHttpResponse webResponse);
    internal string GetAuthenticationParameters();
    internal void ValidateToken(IssuedToken token, IHttpResponse webResponse);
    internal void InvalidateToken(IssuedToken token);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Services.Common.IssuedTokenProvider/<GetTokenAsync>d__34")]
public Task`1<IssuedToken> GetTokenAsync(IssuedToken failedToken, CancellationToken cancellationToken);
    protected virtual Task`1<IssuedToken> OnGetTokenAsync(IssuedToken failedToken, CancellationToken cancellationToken);
    protected virtual IssuedToken OnValidatingToken(IssuedToken token, IHttpResponse webResponse);
    protected virtual void OnTokenValidated(IssuedToken token);
    protected virtual void OnTokenInvalidated(IssuedToken token);
    private GetTokenOperation CreateOperation(VssTraceActivity traceActivity, IssuedToken failedToken, CancellationToken cancellationToken, GetTokenOperation& operationInProgress);
}
internal interface Microsoft.VisualStudio.Services.Common.ISupportSignOut {
    public abstract virtual void SignOut(Uri serverUrl, Uri replyToUrl, string identityProvider);
}
public interface Microsoft.VisualStudio.Services.Common.IVssClientCertificateManager {
    public X509Certificate2Collection ClientCertificates { get; }
    public abstract virtual X509Certificate2Collection get_ClientCertificates();
}
public interface Microsoft.VisualStudio.Services.Common.IVssCredentialPrompt {
    public IDictionary`2<string, string> Parameters { get; public set; }
    public abstract virtual Task`1<IssuedToken> GetTokenAsync(IssuedTokenProvider provider, IssuedToken failedToken);
    public abstract virtual IDictionary`2<string, string> get_Parameters();
    public abstract virtual void set_Parameters(IDictionary`2<string, string> value);
}
public interface Microsoft.VisualStudio.Services.Common.IVssCredentialPrompts {
    public IVssCredentialPrompt FederatedPrompt { get; }
    public abstract virtual IVssCredentialPrompt get_FederatedPrompt();
}
public interface Microsoft.VisualStudio.Services.Common.IVssCredentialStorage {
    public abstract virtual IssuedToken RetrieveToken(Uri serverUrl, VssCredentialsType credentialsType);
    public abstract virtual void StoreToken(Uri serverUrl, IssuedToken token);
    public abstract virtual void RemoveToken(Uri serverUrl, IssuedToken token);
    public abstract virtual bool RemoveTokenValue(Uri serverUrl, IssuedToken token);
}
public interface Microsoft.VisualStudio.Services.Common.IVssDateTimeProvider {
    public string Name { get; }
    public DateTime Now { get; }
    public DateTime UtcNow { get; }
    public abstract virtual string get_Name();
    public abstract virtual DateTime get_Now();
    public abstract virtual DateTime get_UtcNow();
    public abstract virtual DateTime Convert(DateTime time);
}
public interface Microsoft.VisualStudio.Services.Common.IVssHttpRetryInfo {
    public abstract virtual void InitialAttempt(HttpRequestMessage request);
    public abstract virtual void Retry(TimeSpan sleep);
    public abstract virtual void Reset();
}
public class Microsoft.VisualStudio.Services.Common.LinkFilter : object {
    private FilterType m_FilterType;
    private String[] m_FilterValues;
    public FilterType FilterType { get; public set; }
    public String[] FilterValues { get; public set; }
    public FilterType get_FilterType();
    public void set_FilterType(FilterType value);
    public String[] get_FilterValues();
    public void set_FilterValues(String[] value);
    internal static LinkFilter FromXml(XmlReader reader);
    internal void ToXml(XmlWriter writer, string element);
    private static String[] StringArrayFromXml(XmlReader reader);
    private static void StringArrayToXmlElement(XmlWriter writer, string element, String[] array);
    public static LinkFilter[] LinkFilterArrayFromXml(XmlReader reader);
    public static void LinkFilterArrayToXml(XmlWriter writer, string element, LinkFilter[] array);
}
public static class Microsoft.VisualStudio.Services.Common.LinkingUtilities : object {
    [EditorBrowsableAttribute("1")]
public static string VSTFS;
    [EditorBrowsableAttribute("1")]
public static string URISEPARATOR;
    [EditorBrowsableAttribute("1")]
public static string TOOLARTIFACTMONIKER;
    [EditorBrowsableAttribute("1")]
public static string SERVICE;
    private static Char[] s_delimiters;
    private static LinkingUtilities();
    public static bool IsToolTypeWellFormed(string tool);
    public static bool IsUriWellFormed(string artifactUri);
    private static bool IsUriWellFormed(string artifactUri, String& serverName, String& tool, String& artifactType, String& artifactMoniker);
    public static bool IsArtifactTypeWellFormed(string artifactType);
    public static bool IsArtifactToolSpecificIdWellFormed(string toolSpecificId);
    public static bool IsArtifactIdWellFormed(ArtifactId artifactId);
    public static string EncodeUri(ArtifactId artifactId);
    public static ArtifactId DecodeUri(string uri);
    public static ArrayList RemoveDuplicateArtifacts(ArrayList artifactList);
    public static string GetArtifactUri(string artifactUrl);
    [EditorBrowsableAttribute("1")]
public static string GetArtifactUrl(string artifactDisplayUrl, ArtifactId artId, string serverUrl);
    [EditorBrowsableAttribute("1")]
public static string GetServerUrl(Uri serverUri);
}
[EditorBrowsableAttribute("1")]
public class Microsoft.VisualStudio.Services.Common.LocationSecurityConstants : object {
    public static Guid NamespaceId;
    public static char PathSeparator;
    public static string NamespaceRootToken;
    public static string ServiceDefinitionsToken;
    public static string AccessMappingsToken;
    public static int Read;
    public static int Write;
    public static int AllPermissions;
    private static LocationSecurityConstants();
}
public static class Microsoft.VisualStudio.Services.Common.LongPathUtility : object {
    private static Regex AbsolutePathRegEx;
    private static int ERROR_FILE_NOT_FOUND;
    private static LongPathUtility();
    public static IEnumerable`1<string> EnumerateDirectories(string path, bool recursiveSearch);
    public static IEnumerable`1<string> EnumerateFiles(string path, bool recursiveSearch);
    public static IEnumerable`1<string> EnumerateFiles(string path, string matchPattern, bool recursiveSearch);
    public static bool FileExists(string filePath);
    public static bool DirectoryExists(string directoryPath);
    private static bool FileOrDirectoryExists(string filePath, bool isDirectory);
    public static string GetFullNormalizedPath(string path);
    public static bool IsAbsolutePath(string path);
    public static string RemoveExtendedLengthPathPrefix(string inPath);
    private static string CombinePaths(string pathA, string pathB);
    private static string ConvertToExtendedLengthPath(string path);
    private static IEnumerable`1<string> EnumerateDirectoriesInPath(string path);
    private static IEnumerable`1<string> EnumerateFilesInPath(string path, string matchPattern);
    private static void EnumerateFilesInternal(List`1<string> filePaths, string path, string matchPattern, bool recursiveSearch);
    public static void EnumerateDirectoriesInternal(List`1<string> directoryPaths, string path, bool recursiveSearch);
}
[EditorBrowsableAttribute("1")]
internal static class Microsoft.VisualStudio.Services.Common.MD5Utility : object {
    private static int s_fipsAlgorithmPolicyEnabled;
    private static int c_enabled;
    private static int c_disabled;
    private static int c_unknown;
    private static MD5Utility();
    public static MD5 TryCreateMD5Provider();
}
public static class Microsoft.VisualStudio.Services.Common.MsalUtility : object {
    private static ConcurrentDictionary`2<string, String[]> s_scopeDictionary;
    private static MsalUtility();
    public static String[] GetScopes(string resource);
}
public class Microsoft.VisualStudio.Services.Common.MultiPartitionResults`1 : object {
    [CompilerGeneratedAttribute]
private List`1<List`1<T>> <MatchingPartitions>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<T> <NonMatchingPartition>k__BackingField;
    public List`1<List`1<T>> MatchingPartitions { get; }
    public List`1<T> NonMatchingPartition { get; }
    [CompilerGeneratedAttribute]
public List`1<List`1<T>> get_MatchingPartitions();
    [CompilerGeneratedAttribute]
public List`1<T> get_NonMatchingPartition();
}
public static class Microsoft.VisualStudio.Services.Common.NotificationConstants : object {
    [ObsoleteAttribute("Moved to Microsoft.VisualStudio.Services.Notifications.Common.NotificationFrameworkConstants.MyProjectNameMacro in assembly MS.VS.Services.Notifications.WebApi")]
public static string MyProjectNameMacro;
    [ObsoleteAttribute("Moved to Microsoft.VisualStudio.Services.Notifications.Common.NotificationFrameworkConstants.MyDisplayNameMacro in assembly MS.VS.Services.Notifications.WebApi")]
public static string MyDisplayNameMacro;
    [ObsoleteAttribute("Moved to Microsoft.VisualStudio.Services.Notifications.Common.NotificationFrameworkConstants.MyUniqueNameMacro in assembly MS.VS.Services.Notifications.WebApi")]
public static string MyUniqueNameMacro;
    [ObsoleteAttribute("Moved to Microsoft.VisualStudio.Services.Notifications.Common.NotificationFrameworkConstants.SingleQuoteNameMacro in assembly MS.VS.Services.Notifications.WebApi")]
public static string SingleQuoteNameMacro;
    [ObsoleteAttribute]
public static string SingleQuoteValue;
    [ObsoleteAttribute("Moved to Microsoft.VisualStudio.Services.Notifications.Common.NotificationFrameworkConstants.DoubleQuoteNameMacro in assembly MS.VS.Services.Notifications.WebApi")]
public static string DoubleQuoteNameMacro;
    [ObsoleteAttribute]
public static string DoubleQuoteValue;
    [ObsoleteAttribute("Moved to Microsoft.VisualStudio.Services.Notifications.Common.NotificationFrameworkConstants.SingleQuoteCharMacro in assembly MS.VS.Services.Notifications.WebApi")]
public static string SingleQuoteCharMacro;
    [ObsoleteAttribute]
public static string SingleQuoteCharValue;
    [ObsoleteAttribute("Moved to Microsoft.VisualStudio.Services.Notifications.Common.NotificationFrameworkConstants.DoubleQuoteCharMacro in assembly MS.VS.Services.Notifications.WebApi")]
public static string DoubleQuoteCharMacro;
    [ObsoleteAttribute("Moved to Microsoft.VisualStudio.Services.Notifications.Common.NotificationFrameworkConstants.DoubleQuoteCharValue in assembly MS.VS.Services.Notifications.WebApi")]
public static string DoubleQuoteCharValue;
    [ObsoleteAttribute("Moved to Microsoft.VisualStudio.Services.Notifications.Common.NotificationFrameworkConstants.DynamicTargetsToken in assembly MS.VS.Services.Notifications.WebApi")]
public static string DynamicTargetsToken;
    public static string CustomNotificationAddressesIdentityProperty;
    public static string ConfirmedNotificationAddressIdentityProperty;
    [ObsoleteAttribute("Moved to Microsoft.VisualStudio.Services.Notifications.Common.LegacyNames.WorkItemChangedEvent in assembly MS.VS.Services.Notifications.WebApi")]
public static string WorkItemChangedEventTypeName;
    [ObsoleteAttribute("Moved to Microsoft.VisualStudio.Services.Notifications.Common.LegacyNames.BuildStatusChangeEvent in assembly MS.VS.Services.Notifications.WebApi")]
public static string BuildStatusChangeEventName;
    [ObsoleteAttribute("Moved to Microsoft.VisualStudio.Services.Notifications.Common.LegacyNames.BuildCompletedEvent in assembly MS.VS.Services.Notifications.WebApi")]
public static string BuildCompletedEventName;
    [ObsoleteAttribute("Moved to Microsoft.VisualStudio.Services.Notifications.Common.LegacyNames.CheckinEvent in assembly MS.VS.Services.Notifications.WebApi")]
public static string CheckinEventName;
    [ObsoleteAttribute("Moved to Microsoft.VisualStudio.Services.Notifications.Common.LegacyNames.CodeReviewChangedEvent in assembly MS.VS.Services.Notifications.WebApi")]
public static string CodeReviewChangedEventName;
    [ObsoleteAttribute("Moved to Microsoft.VisualStudio.Services.Notifications.Common.LegacyNames.GitPushEvent in assembly MS.VS.Services.Notifications.WebApi")]
public static string GitPushEventName;
    [ObsoleteAttribute("Moved to Microsoft.VisualStudio.Services.Notifications.Common.LegacyNames.GitPullRequestEvent in assembly MS.VS.Services.Notifications.WebApi")]
public static string GitPullRequestEventName;
    [ObsoleteAttribute("Moved to Microsoft.VisualStudio.Services.Notifications.Common.NotificationUrlConstants.AlertsPageRelativePath in assembly MS.VS.Services.Notifications.WebApi")]
public static string AlertsPageRelativePath;
    [ObsoleteAttribute("Moved to Microsoft.VisualStudio.Services.Notifications.Common.NotificationUrlConstants.AlertsPage in assembly MS.VS.Services.Notifications.WebApi")]
public static string AlertsPage;
    [ObsoleteAttribute("Moved to Microsoft.VisualStudio.Services.Notifications.Common.NotificationUrlConstants.AlertsAdminPage in assembly MS.VS.Services.Notifications.WebApi")]
public static string AlertsAdminPage;
    public static string EmailConfirmationSendDates;
    [ObsoleteAttribute("Moved to Microsoft.VisualStudio.Services.Notifications.Common.NotificationFrameworkConstants.ProcessedFlagCharacter in assembly MS.VS.Services.Notifications.WebApi")]
public static char ProcessedFlagCharacter;
    public static char ProcessedTfIdFlagCharacter;
    [ObsoleteAttribute("Moved to Microsoft.VisualStudio.Services.Notifications.Common.NotificationFrameworkConstants.DisplayNameFlagCharacter in assembly MS.VS.Services.Notifications.WebApi")]
public static char DisplayNameFlagCharacter;
    [ObsoleteAttribute("Moved to Microsoft.VisualStudio.Services.Notifications.Common.NotificationFrameworkConstants.TfIdFlagCharacter in assembly MS.VS.Services.Notifications.WebApi")]
public static char TfIdFlagCharacter;
    [ObsoleteAttribute("Moved to Microsoft.VisualStudio.Services.Notifications.Common.FeatureFlags.AllowUserRegexInMatchConditionFeatureFlag in assembly MS.VS.Services.Notifications.WebApi")]
public static string AllowUserRegexInMatchConditionFeatureFlag;
    [ObsoleteAttribute("Moved to Microsoft.VisualStudio.Services.Notifications.Common.MDMConstants.MDMNotificationJobScope in assembly MS.VS.Services.Notifications.WebApi")]
public static string MDMNotificationJobScope;
    [ObsoleteAttribute("Moved to Microsoft.VisualStudio.Services.Notifications.Common.MDMConstants.EventProcessingDelayKPI in assembly MS.VS.Services.Notifications.WebApi")]
public static string EventProcessingDelayKPI;
    [ObsoleteAttribute("Moved to Microsoft.VisualStudio.Services.Notifications.Common.MDMConstants.EventProcessingDelayKPIDesc in assembly MS.VS.Services.Notifications.WebApi")]
public static string EventProcessingDelayKPIDesc;
    [ObsoleteAttribute("Moved to Microsoft.VisualStudio.Services.Notifications.Common.MDMConstants.MDMDeliveryJobscope in assembly MS.VS.Services.Notifications.WebApi")]
public static string MDMDeliveryJobscope;
    [ObsoleteAttribute("Moved to Microsoft.VisualStudio.Services.Notifications.Common.MDMConstants.DeliveryDelayKPI in assembly MS.VS.Services.Notifications.WebApi")]
public static string DeliveryDelayKPI;
    [ObsoleteAttribute("Moved to Microsoft.VisualStudio.Services.Notifications.Common.MDMConstants.DeliveryDelayWithRetriesKPI in assembly MS.VS.Services.Notifications.WebApi")]
public static string DeliveryDelayWithRetriesKPI;
    [ObsoleteAttribute("Moved to Microsoft.VisualStudio.Services.Notifications.Common.MDMConstants.TotalProcessingTimeKPI in assembly MS.VS.Services.Notifications.WebApi")]
public static string TotalProcessingTimeKPI;
    [ObsoleteAttribute("Moved to Microsoft.VisualStudio.Services.Notifications.Common.MDMConstants.TotalProcessingTimeWithRetriesKPI in assembly MS.VS.Services.Notifications.WebApi")]
public static string TotalProcessingTimeWithRetriesKPI;
    [ObsoleteAttribute("Moved to Microsoft.VisualStudio.Services.Notifications.Common.MDMConstants.DeliveryDelayKPIDesc in assembly MS.VS.Services.Notifications.WebApi")]
public static string DeliveryDelayKPIDesc;
    [ObsoleteAttribute("Moved to Microsoft.VisualStudio.Services.Notifications.Common.NotificationFrameworkConstants.BridgeKey in assembly MS.VS.Services.Notifications.WebApi")]
public static string BridgeKey;
    [ObsoleteAttribute("Moved to Microsoft.VisualStudio.Services.Notifications.Common.NotificationFrameworkConstants.RetryCountRegistryKey in assembly MS.VS.Services.Notifications.WebApi")]
public static string RetryCountRegistryKey;
    [ObsoleteAttribute("Moved to Microsoft.VisualStudio.Services.Notifications.Common.NotificationFrameworkConstants.RetryCountDefaultValue in assembly MS.VS.Services.Notifications.WebApi")]
public static int RetryCountDefaultValue;
    [ObsoleteAttribute("Moved to Microsoft.VisualStudio.Services.Notifications.Common.NotificationFrameworkConstants.CollectionScope in assembly MS.VS.Services.Notifications.WebApi")]
public static Guid CollectionScope;
    private static NotificationConstants();
}
public static class Microsoft.VisualStudio.Services.Common.OSDetails : object {
    private static OSVersionInfoEx s_versionInfo;
    private static Nullable`1<bool> s_isComputerJoinedToWorkgroup;
    private static Nullable`1<bool> s_isComputerAadJoined;
    private static Nullable`1<bool> s_isChineseOS;
    private static Stopwatch s_isChineseOSStopwatch;
    public static bool IsClient { get; }
    public static bool IsChineseOS { get; }
    public static bool IsDomainController { get; }
    public static bool IsHomeEdition { get; }
    public static bool IsServer { get; }
    public static bool IsServerCore { get; }
    public static bool Is64BitOperatingSystem { get; }
    public static bool IsWow64 { get; }
    public static bool Is64BitNotWow64 { get; }
    public static WindowsVersion Version { get; }
    public static int MajorVersion { get; }
    public static int MinorVersion { get; }
    public static int ServicePackMajor { get; }
    public static int ServicePackMinor { get; }
    public static WindowsEdition Edition { get; }
    public static bool IsUnsupportedEdition { get; }
    public static bool IsExplorerInstalled { get; }
    private static OSVersionInfoEx OSVersionInfo { get; }
    private static OSDetails();
    public static bool get_IsClient();
    public static bool get_IsChineseOS();
    public static bool get_IsDomainController();
    public static bool get_IsHomeEdition();
    public static bool IsMachineInWorkgroup();
    public static bool IsMachineAadJoined();
    public static bool IsMachineAadJoined(DeviceJoinInfomation& deviceJoinInfomation);
    public static bool get_IsServer();
    public static bool get_IsServerCore();
    public static bool get_Is64BitOperatingSystem();
    public static bool get_IsWow64();
    public static bool get_Is64BitNotWow64();
    public static WindowsVersion get_Version();
    private static int GetVersionDetail(string var, int defaultVersion);
    public static int get_MajorVersion();
    public static int get_MinorVersion();
    public static int get_ServicePackMajor();
    public static int get_ServicePackMinor();
    public static WindowsEdition get_Edition();
    public static bool get_IsUnsupportedEdition();
    public static bool get_IsExplorerInstalled();
    private static OSVersionInfoEx get_OSVersionInfo();
}
public class Microsoft.VisualStudio.Services.Common.OutboundLink : object {
    private string m_LinkType;
    private string m_ReferencedUri;
    public string LinkType { get; public set; }
    public string ReferencedUri { get; public set; }
    public string get_LinkType();
    public void set_LinkType(string value);
    public string get_ReferencedUri();
    public void set_ReferencedUri(string value);
    internal static OutboundLink FromXml(XmlReader reader);
    internal void ToXml(XmlWriter writer, string element);
    internal static OutboundLink[] OutboundLinkArrayFromXml(XmlReader reader);
    internal static void OutboundLinkArrayToXml(XmlWriter writer, string element, OutboundLink[] array);
}
public class Microsoft.VisualStudio.Services.Common.PartitionResults`1 : object {
    [CompilerGeneratedAttribute]
private List`1<T> <MatchingPartition>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<T> <NonMatchingPartition>k__BackingField;
    public List`1<T> MatchingPartition { get; }
    public List`1<T> NonMatchingPartition { get; }
    [CompilerGeneratedAttribute]
public List`1<T> get_MatchingPartition();
    [CompilerGeneratedAttribute]
public List`1<T> get_NonMatchingPartition();
}
[EditorBrowsableAttribute("1")]
internal static class Microsoft.VisualStudio.Services.Common.PathUtility : object {
    public static string Combine(string path1, string path2);
}
public class Microsoft.VisualStudio.Services.Common.Performance.PerformanceNativeMethods : object {
    internal static int GetCurrentThreadId();
    internal static SafeThreadHandle OpenThread(int access, bool inherit, int threadId);
    internal static bool QueryThreadCycleTime(SafeThreadHandle threadHandle, UInt64& cycleTime);
    public static long GetCPUTime();
}
public static class Microsoft.VisualStudio.Services.Common.PerformanceTimerConstants : object {
    public static string Header;
    public static string PerfTimingKey;
    [ObsoleteAttribute]
public static string Aad;
    public static string AadToken;
    public static string AadGraph;
    public static string BlobStorage;
    public static string FinalSqlCommand;
    public static string Redis;
    public static string ServiceBus;
    public static string Sql;
    public static string SqlReadOnly;
    public static string SqlRetries;
    public static string TableStorage;
    public static string VssClient;
    public static string DocumentDB;
}
[DataContractAttribute]
public class Microsoft.VisualStudio.Services.Common.PerformanceTimingEntry : ValueType {
    [CompilerGeneratedAttribute]
private long <ElapsedTicks>k__BackingField;
    [CompilerGeneratedAttribute]
private long <StartOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Properties>k__BackingField;
    [DataMemberAttribute]
public long ElapsedTicks { get; public set; }
    [DataMemberAttribute]
public long StartOffset { get; public set; }
    [DataMemberAttribute]
public IDictionary`2<string, object> Properties { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_ElapsedTicks();
    [CompilerGeneratedAttribute]
public void set_ElapsedTicks(long value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_StartOffset();
    [CompilerGeneratedAttribute]
public void set_StartOffset(long value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(IDictionary`2<string, object> value);
}
[DataContractAttribute]
public class Microsoft.VisualStudio.Services.Common.PerformanceTimingGroup : object {
    [CompilerGeneratedAttribute]
private long <ElapsedTicks>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<PerformanceTimingEntry> <Timings>k__BackingField;
    [DataMemberAttribute]
public long ElapsedTicks { get; public set; }
    [DataMemberAttribute]
public int Count { get; public set; }
    [DataMemberAttribute]
public List`1<PerformanceTimingEntry> Timings { get; private set; }
    [CompilerGeneratedAttribute]
public long get_ElapsedTicks();
    [CompilerGeneratedAttribute]
public void set_ElapsedTicks(long value);
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
public void set_Count(int value);
    [CompilerGeneratedAttribute]
public List`1<PerformanceTimingEntry> get_Timings();
    [CompilerGeneratedAttribute]
private void set_Timings(List`1<PerformanceTimingEntry> value);
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Services.Common.PrimitiveExtensions : object {
    public static DateTime UnixEpoch;
    private static long maxSecondsSinceUnixEpoch;
    private static PrimitiveExtensions();
    [ExtensionAttribute]
public static long ToUnixEpochTime(DateTime dateTime);
    [ExtensionAttribute]
public static DateTime FromUnixEpochTime(long unixTime);
    public static string ToBase64StringNoPaddingFromString(string utf8String);
    public static string FromBase64StringNoPaddingToString(string base64String);
    [ExtensionAttribute]
public static string ToBase64StringNoPadding(Byte[] bytes);
    [ExtensionAttribute]
public static Byte[] FromBase64StringNoPadding(string base64String);
    public static string ConvertToHex(string base64String);
}
public static class Microsoft.VisualStudio.Services.Common.ProcessUtility : object {
    public static Guid UniqueProcessId;
    private static ProcessUtility();
}
[ExceptionMappingAttribute("0.0", "3.0", "PropertyTypeNotSupportedException", "Microsoft.VisualStudio.Services.Common.PropertyTypeNotSupportedException, Microsoft.VisualStudio.Services.Common, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class Microsoft.VisualStudio.Services.Common.PropertyTypeNotSupportedException : VssPropertyValidationException {
    public PropertyTypeNotSupportedException(string propertyName, Type type);
    protected PropertyTypeNotSupportedException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.VisualStudio.Services.Common.ReadOnlyDictionaryComparer`2 : object {
    public static bool Equals(IReadOnlyDictionary`2<K, V> thisDictionary, IReadOnlyDictionary`2<K, V> thatDictionary, IEqualityComparer`1<V> valueComparer, Action`2<int, int> whenCountsNotEqual, Action`2<K, V> whenCorrespondingValueNotFound, Action`3<K, V, V> whenCorrespondingValueNotEqual);
    public static bool IsSubset(IReadOnlyDictionary`2<K, V> candidateSubsetDictionary, IReadOnlyDictionary`2<K, V> candidateSupersetDictionary, IEqualityComparer`1<V> valueComparer, Action`2<K, V> whenCorrespondingValueNotFound, Action`3<K, V, V> whenCorrespondingValueNotEqual);
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<System.Collections.Generic.IReadOnlyDictionary<K,V>>.Equals(IReadOnlyDictionary`2<K, V> thisDictionary, IReadOnlyDictionary`2<K, V> thatDictionary);
    public sealed virtual int GetHashCode(IReadOnlyDictionary`2<K, V> dictionary);
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class Microsoft.VisualStudio.Services.Common.RSAParametersExtensions : object {
    public static RSAParameters FromJsonString(string parameterString);
    [ExtensionAttribute]
public static string ToJsonString(RSAParameters rsaParameters);
}
public class Microsoft.VisualStudio.Services.Common.SafeTaskCompletionSource`1 : object {
    private TaskCompletionSource`1<T> inner;
    public Task`1<T> Task { get; }
    public SafeTaskCompletionSource`1(object state);
    public SafeTaskCompletionSource`1(TaskCreationOptions options);
    public SafeTaskCompletionSource`1(object state, TaskCreationOptions options);
    public Task`1<T> get_Task();
    public void SetCanceled();
    public void SetException(Exception exception);
    public void SetException(IEnumerable`1<Exception> exceptions);
    public void SetResult(T result);
    public bool TrySetCanceled();
    public bool TrySetException(Exception exception);
    public bool TrySetException(IEnumerable`1<Exception> exceptions);
    public bool TrySetResult(T result);
    public void MarkTaskAsUnused();
    protected virtual override void Finalize();
}
[EditorBrowsableAttribute("1")]
public static class Microsoft.VisualStudio.Services.Common.SecretUtility : object {
    internal static string PasswordMask;
    internal static string SecretMask;
    internal static string SignatureMask;
    internal static string PasswordRemovedMask;
    internal static string PwdRemovedMask;
    internal static string PasswordSpaceRemovedMask;
    internal static string PwdSpaceRemovedMask;
    internal static string AccountKeyRemovedMask;
    internal static string CodeKeyRemovedMask;
    private static string c_passwordToken;
    private static string c_passwordTokenSpaced;
    private static string c_pwdToken;
    private static string c_pwdTokenSpaced;
    private static string c_accountKeyToken;
    private static string c_codeKeyToken;
    private static string c_authBearerToken;
    private static string c_jwtTypToken;
    private static string c_jwtAlgToken;
    private static string c_jwtX5tToken;
    private static string c_jwtKidToken;
    private static string c_urlSignatureAssignment;
    private static Char[] s_validPasswordEnding;
    private static String[] s_codeKeyFalsePositives;
    private static SecretUtility();
    public static bool ContainsUnmaskedSecret(string message);
    public static bool ContainsUnmaskedSecret(string message, Boolean& onlyJwtsFound);
    public static string ScrubSecrets(string message, bool assertOnDetection);
    public static string ScrubUrlSignatures(string message, bool assertOnDetection);
    private static string ScrubTraditionalSecrets(string message, bool assertOnDetection);
    private static string ScrubJwts(string message, bool assertOnDetection);
    private static string ScrubSecret(string message, string token, string mask, bool assertOnDetection, bool maskToken, String[] falsePositives);
}
public static class Microsoft.VisualStudio.Services.Common.SecureCompare : object {
    public static bool TimeInvariantEquals(Byte[] lhs, Byte[] rhs);
    [EditorBrowsableAttribute("1")]
public static bool Equals(object lhs, object rhs);
}
[EditorBrowsableAttribute("1")]
public class Microsoft.VisualStudio.Services.Common.SecuritySecurityConstants : object {
    public static Guid NamespaceId;
    public static char Separator;
    public static string RootToken;
    public static int Read;
    private static SecuritySecurityConstants();
}
public static class Microsoft.VisualStudio.Services.Common.SerializationHelper : object {
    private static XmlReaderSettings s_defaultXmlReaderSettings;
    private static SerializationHelper();
    public static T DeserializeDataContract(string value);
    public static T DeserializeDataContract(string value, XmlReaderSettings settings);
    public static T DeserializeDataContract(string value, string rootName, string rootNamespace, XmlReaderSettings settings);
    public static T DeserializeXml(string xmlText);
    public static T DeserializeXml(string xmlText, XmlReaderSettings settings);
    public static string Serialize(T item, XmlWriterSettings settings, XmlObjectSerializer serializer);
    public static string SerializeDataContract(T item);
    public static string SerializeDataContract(T item, XmlWriterSettings settings);
    public static string SerializeDataContract(T item, string rootName, string rootNamespace, XmlWriterSettings settings);
    public static string SerializeXml(T item);
    public static string SerializeXml(T item, XmlWriterSettings settings);
    public static string SerializeXml(T item, XmlWriterSettings settings, XmlSerializerNamespaces namespaces);
    private static string ConvertToString(Stream stream);
}
[EditorBrowsableAttribute("1")]
public class Microsoft.VisualStudio.Services.Common.StreamParser : object {
    private Stream m_stream;
    private int m_chunkSize;
    public long Length { get; }
    public StreamParser(Stream fileStream, int chunkSize);
    public long get_Length();
    public SubStream GetNextStream();
}
public static class Microsoft.VisualStudio.Services.Common.StreamUtility : object {
    public static void Copy(IDataReader reader, TextWriter output, string delimiter, bool includeHeader, string headerPrefix, string rowPrefix, Nullable`1<int> max);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.Services.Common.StringExtensions : object {
    [ExtensionAttribute]
public static string Replace(string input, string oldValue, string newValue, StringComparison comparison);
    [ExtensionAttribute]
public static string UnescapeXml(string source);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Services.Common.StringExtensions/<SplitByNumberOfChars>d__2")]
[ExtensionAttribute]
public static IEnumerable`1<string> SplitByNumberOfChars(string input, int chunkSize);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static bool IsSubdomainOf(string domain, string parentDomain);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static Uri AsUri(string uri);
}
[EditorBrowsableAttribute("1")]
public class Microsoft.VisualStudio.Services.Common.SubStream : Stream {
    private long m_length;
    private long m_startingPosition;
    private Stream m_stream;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public long StartingPostionOnOuterStream { get; }
    public long EndingPostionOnOuterStream { get; }
    public SubStream(Stream stream, int maxStreamSize);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public long get_StartingPostionOnOuterStream();
    public long get_EndingPostionOnOuterStream();
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    private int EnsureLessThanOrEqualToRemainingBytes(int numBytes);
}
[ExceptionMappingAttribute("0.0", "3.0", "TagNotFoundException", "Microsoft.VisualStudio.Services.Common.TagNotFoundException, Microsoft.VisualStudio.Services.Common, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class Microsoft.VisualStudio.Services.Common.TagNotFoundException : VssServiceException {
    public TagNotFoundException(string message);
    public TagNotFoundException(string message, Exception innerException);
    protected TagNotFoundException(SerializationInfo info, StreamingContext context);
}
[ExceptionMappingAttribute("0.0", "3.0", "TagOperationFailed", "Microsoft.VisualStudio.Services.Common.TagOperationFailed, Microsoft.VisualStudio.Services.Common, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class Microsoft.VisualStudio.Services.Common.TagOperationFailed : VssServiceException {
    public TagOperationFailed(string message);
    public TagOperationFailed(string message, Exception innerException);
    protected TagOperationFailed(SerializationInfo info, StreamingContext context);
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Services.Common.TaskCancellationExtensions : object {
    private static int RUN_CONTINUATIONS_ASYNCHRONOUSLY;
    [ExtensionAttribute]
public static Task EnforceCancellation(Task task, CancellationToken cancellationToken, Func`1<string> makeMessage, string file, string member, int line);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Services.Common.TaskCancellationExtensions/<EnforceCancellation>d__2`1")]
[ExtensionAttribute]
public static Task`1<TResult> EnforceCancellation(Task`1<TResult> task, CancellationToken cancellationToken, Func`1<string> makeMessage, string file, string member, int line);
    private static void ObserveExceptionIfNeeded(Task task);
}
[EditorBrowsableAttribute("1")]
public static class Microsoft.VisualStudio.Services.Common.TeamProjectSecurityConstants : object {
    public static Guid NamespaceId;
    public static int GenericRead;
    public static int GenericWrite;
    public static int Delete;
    public static int PublishTestResults;
    public static int AdministerBuild;
    public static int StartBuild;
    public static int EditBuildStatus;
    public static int UpdateBuild;
    public static int DeleteTestResults;
    public static int ViewTestResults;
    public static int ManageTestEnvironments;
    public static int ManageTestConfigurations;
    public static int WorkItemDelete;
    public static int WorkItemMove;
    public static int WorkItemPermanentlyDelete;
    public static int Rename;
    public static int ManageProperties;
    public static int ManageSystemProperties;
    public static int BypassPropertyCache;
    public static int BypassRules;
    public static int SuppressNotifications;
    public static int UpdateVisibility;
    public static int ChangeProjectsProcess;
    public static int AgileToolsBacklogManagement;
    public static int AgileToolsPlans;
    public static int AllPermissions;
    public static string ProjectTokenPrefix;
    private static TeamProjectSecurityConstants();
    public static string GetToken(string projectUri);
}
[EditorBrowsableAttribute("1")]
public class Microsoft.VisualStudio.Services.Common.TfsCredentialCacheEntry : object {
    private string m_targetName;
    private NetworkCredential m_credentials;
    private string m_comment;
    private Dictionary`2<string, string> m_attributes;
    public string TargetName { get; public set; }
    public NetworkCredential Credentials { get; public set; }
    public string Comment { get; public set; }
    public CachedCredentialsType Type { get; public set; }
    public bool NonInteractive { get; public set; }
    public Dictionary`2<string, string> Attributes { get; }
    public TfsCredentialCacheEntry(Uri uri, string userName, string password);
    public TfsCredentialCacheEntry(Uri uri, string userName, string password, string comment, CachedCredentialsType type, bool nonInteractive);
    public TfsCredentialCacheEntry(string targetName, NetworkCredential credentials, string comment, CachedCredentialsType type, bool nonInteractive);
    public string get_TargetName();
    public void set_TargetName(string value);
    public NetworkCredential get_Credentials();
    public void set_Credentials(NetworkCredential value);
    public string get_Comment();
    public void set_Comment(string value);
    public CachedCredentialsType get_Type();
    public void set_Type(CachedCredentialsType value);
    public bool get_NonInteractive();
    public void set_NonInteractive(bool value);
    public Dictionary`2<string, string> get_Attributes();
    private T ParseAttributeEnum(string keyword, T defaultValue);
}
internal class Microsoft.VisualStudio.Services.Common.TokenStorage.RegistryToken : VssToken {
    private VssTokenStorage _storage;
    public RegistryToken(VssTokenStorage storage, VssTokenKey tokenKey, string tokenValue);
    public RegistryToken(VssTokenStorage storage, string kind, string resource, string userName, string type, string token);
    public virtual string GetProperty(string name);
    public virtual IEnumerable`1<string> GetPropertyNames();
    public virtual bool SetProperty(string name, string value);
    protected virtual string RetrieveValue();
    protected virtual bool SetValue(string token);
    protected virtual bool RemoveValue();
}
internal class Microsoft.VisualStudio.Services.Common.TokenStorage.RegistryTokenStorage : VssTokenStorage {
    private string m_subkeyName;
    public RegistryTokenStorage(string subkeyName);
    internal static void DeleteTokenStorage(string registryRootPath, string storageNamespace);
    public virtual IEnumerable`1<VssToken> RetrieveAll(string kind);
    public virtual string RetrieveTokenSecret(VssToken token);
    public virtual bool SetTokenSecret(VssToken token, string tokenValue);
    public virtual bool RemoveTokenSecret(VssToken token);
    public virtual string GetProperty(VssToken token, string name);
    public virtual IEnumerable`1<string> GetPropertyNames(VssToken token);
    public virtual bool SetProperty(VssToken token, string name, string value);
    public virtual bool RemoveAll();
    protected virtual VssToken RetrieveToken(VssTokenKey tokenKey);
    protected virtual VssToken AddToken(VssTokenKey tokenKey, string tokenValue);
    protected virtual bool RemoveToken(VssTokenKey tokenKey);
    private VssToken UpdateToken(VssToken token, string tokenValue, bool updateValueOnly);
    private RegistryKey GetRootKey();
}
internal static class Microsoft.VisualStudio.Services.Common.TokenStorage.RegistryTokenStorageHelper : object {
    private static string KindValue;
    private static string UrlValue;
    private static string UserNameValue;
    private static string TypeValue;
    private static string TokenValue;
    private static string PropertiesKeyName;
    private static RegistryTokenStorageHelper();
    internal static void ThrowExceptionCouldNotCreateSubKey(string parentKey, string subkey);
    internal static bool WriteNewToken(VssTokenKey tokenKey, string tokenValue, RegistryKey kindRegKey);
    internal static void WriteToken(VssTokenKey tokenKey, string tokenValue, RegistryKey tokenRegKey);
    internal static bool UpdateToken(VssToken token, string tokenValue, RegistryKey kindRegKey, bool updateValueOnly);
    internal static void DeleteTokenStorage(string registryRootPath, string storageNamespace);
    internal static RegistryKey GetRootKey(string subkeyName);
    internal static RegistryToken ReadTokenData(RegistryKey subkey, RegistryTokenStorage storage);
    internal static string CreateTokenIdentity(VssTokenKey tokenKey);
    internal static string CreateTokenIdentity(string kind, string resource, string userName, string type);
    internal static RegistryToken CreateTokenFromDataIfMatch(RegistryKey subkey, RegistryTokenStorage storage, string identityToMatch);
    internal static string ReadTokenPropertyValue(RegistryKey subkey, string name);
    internal static IEnumerable`1<string> ReadTokenPropertyNames(RegistryKey subkey);
    internal static void WriteNonSecretTokenData(RegistryKey subkey, VssTokenKey tokenKey);
    internal static bool WriteTokenPropertyValue(RegistryKey subkey, string name, string value);
    internal static void WriteSecretTokenValue(RegistryKey subkey, string tokenValue);
    internal static string ReadTokenValue(RegistryKey subkey);
    internal static string ProtectTokenValue(string secret);
    internal static string UnprotectTokenValue(string cipherText);
    internal static RegistryKey FindTokenKey(RegistryKey root, VssToken token);
}
public abstract class Microsoft.VisualStudio.Services.Common.TokenStorage.VssToken : VssTokenKey {
    [CompilerGeneratedAttribute]
private string <TokenValue>k__BackingField;
    public string TokenValue { get; protected set; }
    protected VssToken(string kind, string resource, string userName, string type, string tokenValue);
    [CompilerGeneratedAttribute]
public string get_TokenValue();
    [CompilerGeneratedAttribute]
protected void set_TokenValue(string value);
    public bool RefreshTokenValue();
    public bool SetTokenValue(string token);
    public bool RemoveTokenValue();
    public virtual IEnumerable`1<string> GetPropertyNames();
    public abstract virtual string GetProperty(string name);
    public abstract virtual bool SetProperty(string name, string value);
    protected abstract virtual string RetrieveValue();
    protected abstract virtual bool SetValue(string token);
    protected abstract virtual bool RemoveValue();
}
public class Microsoft.VisualStudio.Services.Common.TokenStorage.VssTokenKey : object {
    private string m_kind;
    private string m_resource;
    private string m_userName;
    private string m_type;
    private static Char[] s_invalidKindCharacters;
    public string Kind { get; public set; }
    public string Resource { get; public set; }
    public string UserName { get; public set; }
    public string Type { get; public set; }
    public VssTokenKey(string kind, string resource, string userName, string type);
    private static VssTokenKey();
    public string get_Kind();
    public void set_Kind(string value);
    public string get_Resource();
    public void set_Resource(string value);
    public string get_UserName();
    public void set_UserName(string value);
    public string get_Type();
    public void set_Type(string value);
}
public abstract class Microsoft.VisualStudio.Services.Common.TokenStorage.VssTokenStorage : object {
    public VssToken Add(VssTokenKey tokenKey, string tokenValue);
    public VssToken Retrieve(VssTokenKey tokenKey);
    public bool Remove(VssTokenKey tokenKey);
    public virtual IEnumerable`1<string> GetPropertyNames(VssToken token);
    public abstract virtual IEnumerable`1<VssToken> RetrieveAll(string kind);
    public abstract virtual string GetProperty(VssToken token, string name);
    public abstract virtual bool SetProperty(VssToken token, string name, string value);
    public abstract virtual bool SetTokenSecret(VssToken token, string tokenValue);
    public abstract virtual string RetrieveTokenSecret(VssToken token);
    public abstract virtual bool RemoveTokenSecret(VssToken token);
    public abstract virtual bool RemoveAll();
    protected abstract virtual VssToken AddToken(VssTokenKey tokenKey, string tokenValue);
    protected abstract virtual VssToken RetrieveToken(VssTokenKey tokenKey);
    protected abstract virtual bool RemoveToken(VssTokenKey tokenKey);
}
[ExceptionMappingAttribute("0.0", "3.0", "VssTokenStorageException", "Microsoft.VisualStudio.Services.Common.TokenStorage.VssTokenStorageException, Microsoft.VisualStudio.Services.Common, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class Microsoft.VisualStudio.Services.Common.TokenStorage.VssTokenStorageException : Exception {
    public VssTokenStorageException(string message);
    public VssTokenStorageException(string message, Exception innerException);
    protected VssTokenStorageException(SerializationInfo info, StreamingContext context);
}
public static class Microsoft.VisualStudio.Services.Common.TokenStorage.VssTokenStorageFactory : object {
    private static string c_tokenStorageKeyPostFix;
    private static string c_registryRoot;
    private static string RegistryRootPath;
    public static VssTokenStorage GetTokenStorageNamespace(string storageNamespace);
    internal static void DeleteTokenStorage(string storageNamespace);
}
[GenerateSpecificConstantsAttribute("")]
public static class Microsoft.VisualStudio.Services.Common.ToolNames : object {
    public static string Framework;
    [GenerateConstantAttribute("")]
public static string VersionControl;
    [GenerateConstantAttribute("")]
public static string WorkItemTracking;
    [GenerateConstantAttribute("")]
public static string RemoteWorkItemTracking;
    public static string CoreServices;
    public static string Warehouse;
    [GenerateConstantAttribute("")]
public static string TeamBuild;
    public static string ProxyServer;
    public static string TeamFoundation;
    public static string SharePoint;
    [GenerateConstantAttribute("")]
public static string TestManagement;
    public static string LabManagement;
    public static string ReleaseManagement;
    public static string SyncService;
    public static string TestRig;
    public static string TSWebAccess;
    public static string ProjectServer;
    public static string DeploymentRig;
    public static string TeamProjects;
    public static string Discussion;
    [GenerateConstantAttribute("")]
public static string Requirements;
    [GenerateConstantAttribute("")]
public static string Hyperlink;
    public static string Classification;
    [GenerateConstantAttribute("")]
public static string Legacy;
    [GenerateConstantAttribute("")]
public static string CodeSense;
    [GenerateConstantAttribute("")]
public static string Git;
    [GenerateConstantAttribute("")]
public static string CodeReview;
    [GenerateConstantAttribute("")]
public static string ProjectDownload;
    public static string DistributedTask;
    [GenerateConstantAttribute("")]
public static string Wiki;
    public static string Search;
    [GenerateConstantAttribute("")]
public static string GitHub;
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Services.Common.TypeExtensionMethods : object {
    [ExtensionAttribute]
public static bool IsAssignableOrConvertibleFrom(Type type, object value);
    [ExtensionAttribute]
public static bool IsOfType(Type type, Type t);
    [ExtensionAttribute]
public static bool IsDictionary(Type type);
    [ExtensionAttribute]
public static bool IsList(Type type);
    [ExtensionAttribute]
public static Type GetMemberType(Type type, string name);
    [ExtensionAttribute]
public static object GetMemberValue(Type type, string name, object obj);
    [ExtensionAttribute]
public static void SetMemberValue(Type type, string name, object obj, object value);
    [ExtensionAttribute]
public static ConstructorInfo GetFirstMatchingConstructor(Type type, Type[] parameterTypes);
    [ExtensionAttribute]
public static ConstructorInfo GetFirstMatchingConstructor(IEnumerable`1<ConstructorInfo> constructors, Type[] parameterTypes);
    private static PropertyInfo GetPublicInstancePropertyInfo(Type type, string name);
    private static FieldInfo GetPublicInstanceFieldInfo(Type type, string name);
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Services.Common.UriBuilderExtensions : object {
    [ExtensionAttribute]
public static UriBuilder AppendPathSegments(UriBuilder uriBuilder, String[] segments);
    [ExtensionAttribute]
public static UriBuilder AppendQuery(UriBuilder uriBuilder, string name, string value);
    [ExtensionAttribute]
public static UriBuilder AppendQueryEscapeUriString(UriBuilder uriBuilder, string name, string value);
    [ExtensionAttribute]
public static UriBuilder AppendQueryValueOnly(UriBuilder uriBuilder, string value);
    [ExtensionAttribute]
public static string AbsoluteUri(UriBuilder uriBuilder);
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Services.Common.UriExtensions : object {
    [ExtensionAttribute]
public static Uri AppendQuery(Uri uri, string name, string value);
    [ExtensionAttribute]
public static Uri AppendQuery(Uri uri, IEnumerable`1<KeyValuePair`2<string, string>> queryValues);
    [ExtensionAttribute]
public static Uri AppendQuery(Uri uri, NameValueCollection queryValues);
    [ExtensionAttribute]
public static void Add(IList`1<KeyValuePair`2<string, string>> collection, string key, T value, Func`2<T, string> convert);
    [ExtensionAttribute]
public static void AddMultiple(IList`1<KeyValuePair`2<string, string>> collection, string key, IEnumerable`1<T> values, Func`2<T, string> convert);
    [ExtensionAttribute]
public static void Add(IList`1<KeyValuePair`2<string, string>> collection, string key, string value);
    [ExtensionAttribute]
public static void AddMultiple(IList`1<KeyValuePair`2<string, string>> collection, string key, IEnumerable`1<string> values);
    [ExtensionAttribute]
public static void AddMultiple(NameValueCollection collection, string name, IEnumerable`1<T> values, Func`2<T, string> convert);
    [ExtensionAttribute]
public static void AddMultiple(NameValueCollection collection, string name, IEnumerable`1<string> values);
    [ExtensionAttribute]
public static string AbsoluteUri(Uri uri);
    private static void AppendSingleQueryValue(StringBuilder builder, string name, string value);
}
public static class Microsoft.VisualStudio.Services.Common.Utility.ByteConverterUtility : object {
    private static int s_conversionFactor;
    public static double ConvertUnits(long amount, ByteConverterUtilityUnit fromUnit, ByteConverterUtilityUnit toUnit);
    public static double ConvertUnits(int amount, ByteConverterUtilityUnit fromUnit, ByteConverterUtilityUnit toUnit);
    public static double ConvertUnits(double amount, ByteConverterUtilityUnit fromUnit, ByteConverterUtilityUnit toUnit);
    public static string ConvertBytesToString(long amount, ByteConverterUtilityUnit fromUnit, int decimalPlaces);
    public static string ConvertBytesToString(int amount, ByteConverterUtilityUnit fromUnit, int decimalPlaces);
    public static string ConvertBytesToString(double amount, ByteConverterUtilityUnit fromUnit, int decimalPlaces);
}
public enum Microsoft.VisualStudio.Services.Common.Utility.ByteConverterUtilityUnit : Enum {
    public int value__;
    public static ByteConverterUtilityUnit B;
    public static ByteConverterUtilityUnit KB;
    public static ByteConverterUtilityUnit MB;
    public static ByteConverterUtilityUnit GB;
    public static ByteConverterUtilityUnit TB;
    public static ByteConverterUtilityUnit PB;
}
public class Microsoft.VisualStudio.Services.Common.Utility.IdentityDisplayName : object {
    private static Regex s_scopeRegex;
    private static Regex s_vsidRegex;
    private static Regex s_domainAccountRegex;
    private static Regex s_accountNameRegex;
    private static Regex s_displayNameRegex;
    public static string VstsGroupDisambiguatedPartPrefix;
    [CompilerGeneratedAttribute]
private Guid <ScopeId>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Vsid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Domain>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AccountName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private SearchTermType <Type>k__BackingField;
    public Guid ScopeId { get; internal set; }
    public Guid Vsid { get; internal set; }
    public string Domain { get; internal set; }
    public string AccountName { get; internal set; }
    public string DisplayName { get; internal set; }
    public SearchTermType Type { get; internal set; }
    private static IdentityDisplayName();
    [CompilerGeneratedAttribute]
public Guid get_ScopeId();
    [CompilerGeneratedAttribute]
internal void set_ScopeId(Guid value);
    [CompilerGeneratedAttribute]
public Guid get_Vsid();
    [CompilerGeneratedAttribute]
internal void set_Vsid(Guid value);
    [CompilerGeneratedAttribute]
public string get_Domain();
    [CompilerGeneratedAttribute]
internal void set_Domain(string value);
    [CompilerGeneratedAttribute]
public string get_AccountName();
    [CompilerGeneratedAttribute]
internal void set_AccountName(string value);
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    [CompilerGeneratedAttribute]
internal void set_DisplayName(string value);
    [CompilerGeneratedAttribute]
public SearchTermType get_Type();
    [CompilerGeneratedAttribute]
internal void set_Type(SearchTermType value);
    public static IdentityDisplayName GetDisambiguatedSearchTerm(string search);
    private static bool TryGetScope(string search, Guid& scopeId, String& displayName);
    private static bool TryGetVsid(string search, Guid& vsid, String& displayName);
    private static bool TryGetDomainAndAccountName(string search, String& domainAndAcccountName);
    private static bool TryGetAccountName(string search, String& acccountName);
    private static bool TryGetDisplayName(string search, String& displayName);
}
public static class Microsoft.VisualStudio.Services.Common.Utility.LookupGenerator : object {
    public static Func`2<T, TOut> CreateLookupWithDefault(TOut default, KeyValuePair`2[] values);
    public static Func`2<T, TOut> CreateLookupWithDefault(IEqualityComparer`1<T> comparer, TOut default, KeyValuePair`2[] values);
    public static Func`2<T, TOut> CreateLookupWithDefault(TOut default, IReadOnlyDictionary`2<T, TOut> dictionary);
}
public enum Microsoft.VisualStudio.Services.Common.Utility.SearchTermType : Enum {
    public int value__;
    public static SearchTermType Unknown;
    public static SearchTermType Scope;
    public static SearchTermType DomainAndAccountName;
    public static SearchTermType AccoutName;
    public static SearchTermType DisplayName;
    public static SearchTermType Vsid;
}
public class Microsoft.VisualStudio.Services.Common.Utility.UrlEncodingUtility : object {
    public static string UrlTokenDecodeToString(string input);
    public static Byte[] UrlTokenDecode(string input);
    public static string UrlTokenEncode(string input);
    public static string UrlTokenEncode(Byte[] input);
}
public static class Microsoft.VisualStudio.Services.Common.VariantUtil : object {
    public static int SizeInBytes();
}
[ExceptionMappingAttribute("0.0", "3.0", "VssAuthenticationException", "Microsoft.VisualStudio.Services.Common.VssAuthenticationException, Microsoft.VisualStudio.Services.Common, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class Microsoft.VisualStudio.Services.Common.VssAuthenticationException : VssException {
    public VssAuthenticationException(string message);
    public VssAuthenticationException(string message, Exception innerException);
    protected VssAuthenticationException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.VisualStudio.Services.Common.VssBasicCredential : FederatedCredential {
    public VssCredentialsType CredentialType { get; }
    public VssBasicCredential(string userName, string password);
    public VssBasicCredential(ICredentials initialToken);
    public VssBasicCredential(VssBasicToken initialToken);
    public virtual VssCredentialsType get_CredentialType();
    public virtual bool IsAuthenticationChallenge(IHttpResponse webResponse);
    protected virtual IssuedTokenProvider OnCreateTokenProvider(Uri serverUrl, IHttpResponse response);
}
public class Microsoft.VisualStudio.Services.Common.VssBasicToken : IssuedToken {
    private ICredentials m_credentials;
    internal ICredentials Credentials { get; }
    protected internal VssCredentialsType CredentialType { get; }
    public VssBasicToken(ICredentials credentials);
    internal ICredentials get_Credentials();
    protected internal virtual VssCredentialsType get_CredentialType();
    internal virtual void ApplyTo(IHttpRequest request);
    private static string FormatBasicAuthHeader(NetworkCredential credential);
}
public class Microsoft.VisualStudio.Services.Common.VssCredentials : object {
    private object m_thisLock;
    private CredentialPromptType m_promptType;
    private IssuedTokenProvider m_currentProvider;
    protected WindowsCredential m_windowsCredential;
    protected FederatedCredential m_federatedCredential;
    private IVssCredentialStorage m_credentialStorage;
    public CredentialPromptType PromptType { get; public set; }
    public FederatedCredential Federated { get; }
    public WindowsCredential Windows { get; }
    public IVssCredentialStorage Storage { get; public set; }
    protected static bool EnvironmentUserInteractive { get; }
    public VssCredentials(bool useDefaultCredentials);
    public VssCredentials(WindowsCredential windowsCredential);
    public VssCredentials(WindowsCredential windowsCredential, CredentialPromptType promptType);
    public VssCredentials(FederatedCredential federatedCredential);
    public VssCredentials(WindowsCredential windowsCredential, FederatedCredential federatedCredential);
    public VssCredentials(WindowsCredential windowsCredential, FederatedCredential federatedCredential, CredentialPromptType promptType);
    public VssCredentials(WindowsCredential windowsCredential, FederatedCredential federatedCredential, CredentialPromptType promptType, TaskScheduler scheduler);
    public VssCredentials(WindowsCredential windowsCredential, FederatedCredential federatedCredential, CredentialPromptType promptType, TaskScheduler scheduler, IVssCredentialPrompt credentialPrompt);
    public static VssCredentials op_Implicit(FederatedCredential credential);
    public static VssCredentials op_Implicit(WindowsCredential credential);
    public CredentialPromptType get_PromptType();
    public void set_PromptType(CredentialPromptType value);
    public FederatedCredential get_Federated();
    public WindowsCredential get_Windows();
    public IVssCredentialStorage get_Storage();
    public void set_Storage(IVssCredentialStorage value);
    internal virtual bool TryGetValidToken(IVssCredentialPrompt prompt);
    internal IssuedTokenProvider CreateTokenProvider(Uri serverUrl, IHttpResponse webResponse, IssuedToken failedToken);
    public bool TryGetTokenProvider(Uri serverUrl, IssuedTokenProvider& provider);
    internal bool IsAuthenticationChallenge(IHttpResponse webResponse);
    internal void SignOut(Uri serverUrl, Uri serviceLocation, string identityProvider);
    [EditorBrowsableAttribute("1")]
public static void WriteAuthorizationToken(string token, IDictionary`2<string, string> attributes);
    protected static string ReadAuthorizationToken(IDictionary`2<string, string> attributes);
    protected static bool get_EnvironmentUserInteractive();
}
public enum Microsoft.VisualStudio.Services.Common.VssCredentialsType : Enum {
    public int value__;
    public static VssCredentialsType Windows;
    public static VssCredentialsType Federated;
    public static VssCredentialsType Basic;
    public static VssCredentialsType ServiceIdentity;
    public static VssCredentialsType OAuth;
    public static VssCredentialsType S2S;
    public static VssCredentialsType Other;
    public static VssCredentialsType Aad;
}
public class Microsoft.VisualStudio.Services.Common.VssDateTimeProvider : object {
    public static IVssDateTimeProvider DefaultProvider;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeTransform <Transform>k__BackingField;
    public string Name { get; }
    public DateTime Now { get; }
    public DateTime UtcNow { get; }
    private DateTimeTransform Transform { get; private set; }
    public VssDateTimeProvider(string name);
    private static VssDateTimeProvider();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    public sealed virtual DateTime get_Now();
    public sealed virtual DateTime get_UtcNow();
    public sealed virtual DateTime Convert(DateTime time);
    public IDisposable SetOffset(TimeSpan offset);
    public IDisposable SetNow(DateTime now);
    private IDisposable SetTransform(DateTimeTransform transform);
    [CompilerGeneratedAttribute]
private DateTimeTransform get_Transform();
    [CompilerGeneratedAttribute]
private void set_Transform(DateTimeTransform value);
}
public static class Microsoft.VisualStudio.Services.Common.VssEnvironment : object {
    private static string VssClassicInstallPath;
    private static string VssCommonFilesPath;
    private static string VssPrivateFilesPath;
    private static string VssSharedFilesPath;
    private static string VssBaseInstallPath;
    public static string GetTfsSharedFilesPath();
    public static string GetVssCommonFilesPath();
    public static string GetVssSharedFilesPath();
    public static string GetVssPrivateFilesPath();
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Services.Common.VssEnvironment/<EnumerateAllPaths>d__4")]
[ObsoleteAttribute("This method will be deleted in TFS 2018.")]
public static IEnumerable`1<string> EnumerateAllPaths();
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Services.Common.VssEnvironment/<EnumerateTfsPaths>d__5")]
[ObsoleteAttribute("This method will be deleted in TFS 2018.")]
public static IEnumerable`1<string> EnumerateTfsPaths();
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Services.Common.VssEnvironment/<EnumerateVssPaths>d__6")]
public static IEnumerable`1<string> EnumerateVssPaths();
    private static string GetCommonProgramsPath();
    private static string GetVssBaseInstallPath();
}
[ExceptionMappingAttribute("0.0", "3.0", "VssException", "Microsoft.VisualStudio.Services.Common.VssException, Microsoft.VisualStudio.Services.Common, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public abstract class Microsoft.VisualStudio.Services.Common.VssException : ApplicationException {
    private static string c_currentAssemblyMajorVersionString;
    private static string c_backCompatVersionString;
    private static int c_backCompatVersion;
    private static Version s_backCompatExclusiveMaxVersion;
    private bool m_logException;
    private bool m_reportException;
    private int m_errorCode;
    private int m_eventId;
    public static int DefaultExceptionEventId;
    public bool LogException { get; public set; }
    public int ErrorCode { get; public set; }
    public int EventId { get; public set; }
    public bool ReportException { get; public set; }
    public VssException(int errorCode);
    public VssException(int errorCode, bool logException);
    public VssException(string message);
    public VssException(string message, Exception innerException);
    public VssException(string message, int errorCode, Exception innerException);
    public VssException(string message, int errorCode);
    public VssException(string message, int errorCode, bool logException);
    public VssException(string message, int errorCode, bool logException, Exception innerException);
    protected VssException(SerializationInfo info, StreamingContext context);
    private static VssException();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public bool get_LogException();
    public void set_LogException(bool value);
    public int get_ErrorCode();
    public void set_ErrorCode(int value);
    public int get_EventId();
    public void set_EventId(int value);
    public bool get_ReportException();
    public void set_ReportException(bool value);
    internal static void GetTypeNameAndKeyForExceptionType(Type exceptionType, Version restApiVersion, String& typeName, String& typeKey);
    internal static string GetBackCompatAssemblyQualifiedName(Type type);
}
public class Microsoft.VisualStudio.Services.Common.VssHttpMessageHandler : HttpMessageHandler {
    [CompilerGeneratedAttribute]
private VssCredentials <Credentials>k__BackingField;
    [CompilerGeneratedAttribute]
private VssHttpRequestSettings <Settings>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExpectContinue>k__BackingField;
    internal static string PropertyName;
    private static IWebProxy s_defaultWebProxy;
    internal static string CredentialsType;
    private static int m_maxAuthRetries;
    private HttpMessageInvoker m_messageInvoker;
    private CredentialWrapper m_credentialWrapper;
    private bool m_appliedClientCertificatesToTransportHandler;
    private bool m_appliedServerCertificateValidationCallbackToTransportHandler;
    private HttpMessageHandler m_transportHandler;
    public VssCredentials Credentials { get; private set; }
    public VssHttpRequestSettings Settings { get; private set; }
    private bool ExpectContinue { get; private set; }
    public static IWebProxy DefaultWebProxy { get; public set; }
    public VssHttpMessageHandler(VssCredentials credentials, VssHttpRequestSettings settings);
    public VssHttpMessageHandler(VssCredentials credentials, VssHttpRequestSettings settings, HttpMessageHandler innerHandler);
    private static VssHttpMessageHandler();
    [CompilerGeneratedAttribute]
public VssCredentials get_Credentials();
    [CompilerGeneratedAttribute]
private void set_Credentials(VssCredentials value);
    [CompilerGeneratedAttribute]
public VssHttpRequestSettings get_Settings();
    [CompilerGeneratedAttribute]
private void set_Settings(VssHttpRequestSettings value);
    [CompilerGeneratedAttribute]
private bool get_ExpectContinue();
    [CompilerGeneratedAttribute]
private void set_ExpectContinue(bool value);
    protected virtual void Dispose(bool disposing);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Services.Common.VssHttpMessageHandler/<SendAsync>d__17")]
protected virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Services.Common.VssHttpMessageHandler/<BufferRequestContentAsync>d__18")]
private static Task BufferRequestContentAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Services.Common.VssHttpMessageHandler/<BufferResponseContentAsync>d__19")]
protected virtual Task BufferResponseContentAsync(HttpRequestMessage request, HttpResponseMessage response, Func`1<string> makeErrorMessage, CancellationToken cancellationToken);
    private void ApplyHeaders(HttpRequestMessage request);
    private void ApplyToken(HttpRequestMessage request, IssuedToken token, bool applyICredentialsToWebProxy);
    private static void ApplySettings(HttpMessageHandler handler, ICredentials defaultCredentials, VssHttpRequestSettings settings);
    public static IWebProxy get_DefaultWebProxy();
    public static void set_DefaultWebProxy(IWebProxy value);
}
public class Microsoft.VisualStudio.Services.Common.VssHttpMessageHandlerTraceInfo : object {
    private DateTime _lastTime;
    private static string TfsTraceInfoKey;
    [CompilerGeneratedAttribute]
private int <TokenRetries>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <HandlerStartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <BufferedRequestTime>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <RequestSendTime>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <ResponseContentTime>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <GetTokenTime>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <TrailingTime>k__BackingField;
    public int TokenRetries { get; internal set; }
    public TimeSpan HandlerStartTime { get; private set; }
    public TimeSpan BufferedRequestTime { get; private set; }
    public TimeSpan RequestSendTime { get; private set; }
    public TimeSpan ResponseContentTime { get; private set; }
    public TimeSpan GetTokenTime { get; private set; }
    public TimeSpan TrailingTime { get; private set; }
    private static VssHttpMessageHandlerTraceInfo();
    [CompilerGeneratedAttribute]
public int get_TokenRetries();
    [CompilerGeneratedAttribute]
internal void set_TokenRetries(int value);
    [CompilerGeneratedAttribute]
public TimeSpan get_HandlerStartTime();
    [CompilerGeneratedAttribute]
private void set_HandlerStartTime(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_BufferedRequestTime();
    [CompilerGeneratedAttribute]
private void set_BufferedRequestTime(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_RequestSendTime();
    [CompilerGeneratedAttribute]
private void set_RequestSendTime(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_ResponseContentTime();
    [CompilerGeneratedAttribute]
private void set_ResponseContentTime(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_GetTokenTime();
    [CompilerGeneratedAttribute]
private void set_GetTokenTime(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_TrailingTime();
    [CompilerGeneratedAttribute]
private void set_TrailingTime(TimeSpan value);
    internal void TraceHandlerStartTime();
    internal void TraceBufferedRequestTime();
    internal void TraceRequestSendTime();
    internal void TraceResponseContentTime();
    internal void TraceGetTokenTime();
    internal void TraceTrailingTime();
    public static void SetTraceInfo(HttpRequestMessage message, VssHttpMessageHandlerTraceInfo traceInfo);
    public static VssHttpMessageHandlerTraceInfo GetTraceInfo(HttpRequestMessage message);
    public virtual string ToString();
}
public class Microsoft.VisualStudio.Services.Common.VssHttpRequestSettings : object {
    [CompilerGeneratedAttribute]
private bool <AllowAutoRedirect>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CompressionEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExpectContinue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <BypassProxyOnLocal>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseHttp11>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <SendTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SuppressFedAuthRedirects>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ProductInfoHeaderValue> <UserAgent>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <SessionId>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <E2EId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AgentId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OperationName>k__BackingField;
    [CompilerGeneratedAttribute]
private IVssClientCertificateManager <ClientCertificateManager>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`5<HttpRequestMessage, X509Certificate2, X509Chain, SslPolicyErrors, bool> <ServerCertificateValidationCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxRetryRequest>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<VssReadConsistencyLevel> <ReadConsistencyLevel>k__BackingField;
    public static string PropertyName;
    public static string HttpCompletionOptionPropertyName;
    public static string LightweightHeader;
    public static string ExcludeUrlsHeader;
    private int m_maxContentBufferSize;
    private ICollection`1<CultureInfo> m_acceptLanguages;
    private static Lazy`1<Encoding> s_encoding;
    private static TimeSpan s_defaultTimeout;
    private static int c_defaultMaxRetry;
    private static int c_maxAllowedContentBufferSize;
    private static int c_defaultContentBufferSize;
    public bool AllowAutoRedirect { get; public set; }
    [DefaultValueAttribute("True")]
public bool CompressionEnabled { get; public set; }
    [DefaultValueAttribute("True")]
public bool ExpectContinue { get; public set; }
    public bool BypassProxyOnLocal { get; public set; }
    public bool UseHttp11 { get; public set; }
    [DefaultValueAttribute("536870912")]
public int MaxContentBufferSize { get; public set; }
    public TimeSpan SendTimeout { get; public set; }
    [DefaultValueAttribute("True")]
public bool SuppressFedAuthRedirects { get; public set; }
    public List`1<ProductInfoHeaderValue> UserAgent { get; public set; }
    public ICollection`1<CultureInfo> AcceptLanguages { get; }
    public Guid SessionId { get; public set; }
    public Guid E2EId { get; public set; }
    public string AgentId { get; public set; }
    public string OperationName { get; public set; }
    public IVssClientCertificateManager ClientCertificateManager { get; public set; }
    public Func`5<HttpRequestMessage, X509Certificate2, X509Chain, SslPolicyErrors, bool> ServerCertificateValidationCallback { get; public set; }
    [DefaultValueAttribute("3")]
public int MaxRetryRequest { get; public set; }
    [EditorBrowsableAttribute("1")]
public Nullable`1<VssReadConsistencyLevel> ReadConsistencyLevel { get; public set; }
    public static Encoding Encoding { get; }
    public VssHttpRequestSettings(Guid sessionId);
    [ObsoleteAttribute]
[EditorBrowsableAttribute("1")]
public VssHttpRequestSettings(Guid sessionId, Guid e2eId);
    protected VssHttpRequestSettings(VssHttpRequestSettings copy);
    private static VssHttpRequestSettings();
    [CompilerGeneratedAttribute]
public bool get_AllowAutoRedirect();
    [CompilerGeneratedAttribute]
public void set_AllowAutoRedirect(bool value);
    [CompilerGeneratedAttribute]
public bool get_CompressionEnabled();
    [CompilerGeneratedAttribute]
public void set_CompressionEnabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_ExpectContinue();
    [CompilerGeneratedAttribute]
public void set_ExpectContinue(bool value);
    [CompilerGeneratedAttribute]
public bool get_BypassProxyOnLocal();
    [CompilerGeneratedAttribute]
public void set_BypassProxyOnLocal(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseHttp11();
    [CompilerGeneratedAttribute]
public void set_UseHttp11(bool value);
    public int get_MaxContentBufferSize();
    public void set_MaxContentBufferSize(int value);
    [CompilerGeneratedAttribute]
public TimeSpan get_SendTimeout();
    [CompilerGeneratedAttribute]
public void set_SendTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public bool get_SuppressFedAuthRedirects();
    [CompilerGeneratedAttribute]
public void set_SuppressFedAuthRedirects(bool value);
    [CompilerGeneratedAttribute]
public List`1<ProductInfoHeaderValue> get_UserAgent();
    [CompilerGeneratedAttribute]
public void set_UserAgent(List`1<ProductInfoHeaderValue> value);
    public ICollection`1<CultureInfo> get_AcceptLanguages();
    [CompilerGeneratedAttribute]
public Guid get_SessionId();
    [CompilerGeneratedAttribute]
public void set_SessionId(Guid value);
    [CompilerGeneratedAttribute]
public Guid get_E2EId();
    [CompilerGeneratedAttribute]
public void set_E2EId(Guid value);
    [CompilerGeneratedAttribute]
public string get_AgentId();
    [CompilerGeneratedAttribute]
public void set_AgentId(string value);
    [CompilerGeneratedAttribute]
public string get_OperationName();
    [CompilerGeneratedAttribute]
public void set_OperationName(string value);
    [CompilerGeneratedAttribute]
public IVssClientCertificateManager get_ClientCertificateManager();
    [CompilerGeneratedAttribute]
public void set_ClientCertificateManager(IVssClientCertificateManager value);
    [CompilerGeneratedAttribute]
public Func`5<HttpRequestMessage, X509Certificate2, X509Chain, SslPolicyErrors, bool> get_ServerCertificateValidationCallback();
    [CompilerGeneratedAttribute]
public void set_ServerCertificateValidationCallback(Func`5<HttpRequestMessage, X509Certificate2, X509Chain, SslPolicyErrors, bool> value);
    [CompilerGeneratedAttribute]
public int get_MaxRetryRequest();
    [CompilerGeneratedAttribute]
public void set_MaxRetryRequest(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<VssReadConsistencyLevel> get_ReadConsistencyLevel();
    [CompilerGeneratedAttribute]
public void set_ReadConsistencyLevel(Nullable`1<VssReadConsistencyLevel> value);
    protected internal virtual bool IsHostLocal(string hostName);
    protected internal virtual bool ApplyTo(HttpRequestMessage request);
    public static Encoding get_Encoding();
}
[EditorBrowsableAttribute("1")]
public class Microsoft.VisualStudio.Services.Common.VssHttpRetryMessageHandler : DelegatingHandler {
    [CompilerGeneratedAttribute]
private string <ClientName>k__BackingField;
    private VssHttpRetryOptions m_retryOptions;
    public static string HttpRetryInfoKey;
    public static string HttpRetryOptionsKey;
    public string ClientName { get; public set; }
    public VssHttpRetryMessageHandler(int maxRetries);
    public VssHttpRetryMessageHandler(int maxRetries, string clientName);
    public VssHttpRetryMessageHandler(VssHttpRetryOptions options);
    public VssHttpRetryMessageHandler(VssHttpRetryOptions options, HttpMessageHandler innerHandler);
    [CompilerGeneratedAttribute]
public string get_ClientName();
    [CompilerGeneratedAttribute]
public void set_ClientName(string value);
    public virtual bool IsCustomTransientException(Exception ex);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Services.Common.VssHttpRetryMessageHandler/<SendAsync>d__9")]
protected virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    protected virtual void TraceRaw(HttpRequestMessage request, int tracepoint, TraceLevel level, string message, Object[] args);
    protected virtual void TraceHttpRequestFailed(VssTraceActivity activity, HttpRequestMessage request, HttpStatusCode statusCode, string afdRefInfo);
    protected virtual void TraceHttpRequestFailed(VssTraceActivity activity, HttpRequestMessage request, Exception exception);
    protected virtual void TraceHttpRequestFailedMaxAttempts(VssTraceActivity activity, HttpRequestMessage request, int attempt, Nullable`1<HttpStatusCode> httpStatusCode, Nullable`1<WebExceptionStatus> webExceptionStatus, Nullable`1<SocketError> socketErrorCode, Nullable`1<WinHttpErrorCode> winHttpErrorCode, Nullable`1<CurlErrorCode> curlErrorCode, string afdRefInfo);
    protected virtual void TraceHttpRequestSucceededWithRetry(VssTraceActivity activity, HttpResponseMessage response, int attempt);
    protected virtual void TraceHttpRequestRetrying(VssTraceActivity activity, HttpRequestMessage request, int attempt, TimeSpan backoffDuration, Nullable`1<HttpStatusCode> httpStatusCode, Nullable`1<WebExceptionStatus> webExceptionStatus, Nullable`1<SocketError> socketErrorCode, Nullable`1<WinHttpErrorCode> winHttpErrorCode, Nullable`1<CurlErrorCode> curlErrorCode, string afdRefInfo);
    private static bool IsLowPriority(HttpRequestMessage request);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<HttpResponseMessage> <>n__0(HttpRequestMessage request, CancellationToken cancellationToken);
}
public class Microsoft.VisualStudio.Services.Common.VssHttpRetryOptions : object {
    private int m_isReadOnly;
    private int m_maxRetries;
    private TimeSpan m_minBackoff;
    private TimeSpan m_maxBackoff;
    private TimeSpan m_backoffCoefficient;
    private ICollection`1<HttpStatusCode> m_retryableStatusCodes;
    private ICollection`1<VssHttpRetryableStatusCodeFilter> m_retryFilters;
    private static TimeSpan s_minBackoff;
    private static TimeSpan s_maxBackoff;
    private static TimeSpan s_backoffCoefficient;
    private static Lazy`1<VssHttpRetryOptions> s_defaultOptions;
    private static VssHttpRetryableStatusCodeFilter s_hostShutdownFilter;
    public static VssHttpRetryOptions Default { get; }
    public TimeSpan BackoffCoefficient { get; public set; }
    public TimeSpan MinBackoff { get; public set; }
    public TimeSpan MaxBackoff { get; public set; }
    public int MaxRetries { get; public set; }
    public ICollection`1<HttpStatusCode> RetryableStatusCodes { get; private set; }
    public VssHttpRetryOptions(IEnumerable`1<VssHttpRetryableStatusCodeFilter> filters);
    private static VssHttpRetryOptions();
    public static VssHttpRetryOptions get_Default();
    public TimeSpan get_BackoffCoefficient();
    public void set_BackoffCoefficient(TimeSpan value);
    public TimeSpan get_MinBackoff();
    public void set_MinBackoff(TimeSpan value);
    public TimeSpan get_MaxBackoff();
    public void set_MaxBackoff(TimeSpan value);
    public int get_MaxRetries();
    public void set_MaxRetries(int value);
    public ICollection`1<HttpStatusCode> get_RetryableStatusCodes();
    private void set_RetryableStatusCodes(ICollection`1<HttpStatusCode> value);
    public bool IsRetryableResponse(HttpResponseMessage response);
    public VssHttpRetryOptions MakeReadonly();
    private void ThrowIfReadonly();
}
[EditorBrowsableAttribute("1")]
public static class Microsoft.VisualStudio.Services.Common.VssNetworkHelper : object {
    public static HttpStatusCode TooManyRequests;
    public static bool IsTransientNetworkException(Exception ex);
    public static bool IsTransientNetworkException(Exception ex, VssHttpRetryOptions options);
    public static bool IsTransientNetworkException(Exception ex, Nullable`1& httpStatusCode, Nullable`1& webExceptionStatus, Nullable`1& socketErrorCode, Nullable`1& winHttpErrorCode, Nullable`1& curlErrorCode);
    public static bool IsTransientNetworkException(Exception ex, VssHttpRetryOptions options, Nullable`1& httpStatusCode, Nullable`1& webExceptionStatus, Nullable`1& socketErrorCode, Nullable`1& winHttpErrorCode, Nullable`1& curlErrorCode);
    private static bool IsTransientNetworkExceptionHelper(Exception ex, VssHttpRetryOptions options, Nullable`1& httpStatusCode, Nullable`1& webExceptionStatus, Nullable`1& socketErrorCode, Nullable`1& winHttpErrorCode, Nullable`1& curlErrorCode);
}
public class Microsoft.VisualStudio.Services.Common.VssPerformanceEventSource : EventSource {
    public static VssPerformanceEventSource Log;
    private static VssPerformanceEventSource();
    [NonEventAttribute]
public void WriteEvent(int eventId, Guid u1, Guid u2, string st);
    [NonEventAttribute]
public void WriteEvent(int eventId, Guid u1, Guid u2, string st, long duration);
    [NonEventAttribute]
public void WriteEvent(int eventId, Guid u, string st);
    [NonEventAttribute]
public void WriteEvent(int eventId, Guid u, string st, long duration);
    [NonEventAttribute]
public void WriteEvent(int eventId, Guid u);
    [NonEventAttribute]
public void WriteEvent(int eventId, Guid u, long duration);
    [NonEventAttribute]
public void WriteEvent(int eventId, Guid u1, string st1, DateTime dt1, DateTime dt2, Guid u2);
    [NonEventAttribute]
public void WriteEvent(int eventId, Guid u1, string st1, string st2, string st3, Guid u2, long duration);
    [NonEventAttribute]
public void WriteEvent(int eventId, Guid uniqueIdentifier, string st1, string st2, string st3);
    [NonEventAttribute]
public void WriteEvent(int eventId, Guid uniqueIdentifier, string st1, string st2, string st3, long duration);
    [NonEventAttribute]
public void WriteEvent(int eventId, Guid uniqueIdentifier, string st1, string st2);
    [NonEventAttribute]
public void WriteEvent(int eventId, Guid uniqueIdentifier, string st1, string st2, long duration);
    [NonEventAttribute]
public void WriteEvent(int eventId, string st, int i1, long duration);
    public void MethodStart(Guid uniqueIdentifier, Guid hostId, string methodName);
    public void MethodStop(Guid uniqueIdentifier, Guid hostId, string methodName, long duration);
    public void NotificationCallbackStart(Guid hostId, string callback);
    public void NotificationCallbackStop(Guid hostId, string callback, long duration);
    public void TaskCallbackStart(Guid hostId, string callback);
    public void TaskCallbackStop(Guid hostId, string callback, long duration);
    public void StopHostTaskStart(Guid hostId);
    public void StopHostTaskStop(Guid hostId, long duration);
    public void RefreshSecurityTokenStart(Guid uniqueIdentifier, string name);
    public void RefreshSecurityTokenStop(Guid uniqueIdentifier, string name, DateTime validFrom, DateTime validTo, Guid contextId, long duration);
    public void SQLStart(Guid uniqueIdentifier, string query, string server, string databaseName);
    public void SQLStop(Guid uniqueIdentifier, string query, string server, string databaseName, long duration);
    public void RESTStart(Guid uniqueIdentifier, string message);
    public void RESTStop(Guid uniqueIdentifier, Guid originalActivityId, string message, long duration);
    public void WindowsAzureStorageStart(Guid uniqueIdentifier, string accountName, string methodName);
    public void WindowsAzureStorageStop(Guid uniqueIdentifier, string accountName, string methodName, long duration);
    public void LoadHostStart(Guid hostId);
    public void LoadHostStop(Guid hostId, long duration);
    public void CreateServiceInstanceBegin(Guid uniqueIdentifier, Guid hostId, string serviceType);
    public void CreateServiceInstanceEnd(Guid uniqueIdentifier, Guid hostId, string serviceType, long duration);
    public void DetectedLockReentryViolation(string lockName);
    public void DetectedLockUsageViolation(string lockName, string locksHeld);
    public void RedisStart(Guid uniqueIdentifier, string operation, string ciArea, string cacheArea);
    public void RedisStop(Guid uniqueIdentifier, string operation, string ciArea, string cacheArea, long duration);
    public void MessageBusSendBatchStart(Guid uniqueIdentifier, string messageBusName, int numberOfMessages);
    public void MessageBusSendBatchStop(Guid uniqueIdentifier, string messageBusName, int numberOfMessages, long duration);
    public void ValidateJWTokenStart(Guid e2eid, string issuer, string name);
    public void ValidateJWTokenStop(Guid e2eid, string issuer, string name, long duration);
    public void TFFileServiceAsCacheStart(Guid uniqueIdentifier, string operation, string ciArea, string cacheArea);
    public void TFFileServiceAsCacheStop(Guid uniqueIdentifier, string operation, string ciArea, string cacheArea, long duration);
}
[ExceptionMappingAttribute("0.0", "3.0", "VssPropertyValidationException", "Microsoft.VisualStudio.Services.Common.VssPropertyValidationException, Microsoft.VisualStudio.Services.Common, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class Microsoft.VisualStudio.Services.Common.VssPropertyValidationException : VssServiceException {
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    public string PropertyName { get; public set; }
    public VssPropertyValidationException(string propertyName, string message);
    public VssPropertyValidationException(string propertyName, string message, Exception innerException);
    protected VssPropertyValidationException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public string get_PropertyName();
    [CompilerGeneratedAttribute]
public void set_PropertyName(string value);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public enum Microsoft.VisualStudio.Services.Common.VssReadConsistencyLevel : Enum {
    public int value__;
    public static VssReadConsistencyLevel Strict;
    public static VssReadConsistencyLevel Eventual;
}
[ExceptionMappingAttribute("0.0", "3.0", "VssServiceException", "Microsoft.VisualStudio.Services.Common.VssServiceException, Microsoft.VisualStudio.Services.Common, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class Microsoft.VisualStudio.Services.Common.VssServiceException : VssException {
    public VssServiceException(string message, Exception innerException);
    public VssServiceException(string message);
    protected VssServiceException(SerializationInfo info, StreamingContext context);
    public virtual void GetTypeNameAndKey(Version restApiVersion, String& typeName, String& typeKey);
}
public class Microsoft.VisualStudio.Services.Common.VssServiceIdentityCredential : FederatedCredential {
    private string m_userName;
    private string m_password;
    private DelegatingHandler m_innerHandler;
    public VssCredentialsType CredentialType { get; }
    public string UserName { get; }
    internal string Password { get; }
    public VssServiceIdentityCredential(string userName, string password);
    public VssServiceIdentityCredential(string userName, string password, VssServiceIdentityToken initialToken);
    public VssServiceIdentityCredential(VssServiceIdentityToken token);
    public VssServiceIdentityCredential(string userName, string password, VssServiceIdentityToken initialToken, DelegatingHandler innerHandler);
    public virtual VssCredentialsType get_CredentialType();
    public string get_UserName();
    internal string get_Password();
    public virtual bool IsAuthenticationChallenge(IHttpResponse webResponse);
    internal virtual string GetAuthenticationChallenge(IHttpResponse webResponse);
    protected virtual IssuedTokenProvider OnCreateTokenProvider(Uri serverUrl, IHttpResponse response);
}
public class Microsoft.VisualStudio.Services.Common.VssServiceIdentityToken : IssuedToken {
    private string m_token;
    private static string c_expiresName;
    public string Token { get; }
    protected internal VssCredentialsType CredentialType { get; }
    public VssServiceIdentityToken(string token);
    public string get_Token();
    protected internal virtual VssCredentialsType get_CredentialType();
    internal virtual void ApplyTo(IHttpRequest request);
    internal static VssServiceIdentityToken ExtractToken(string responseValue);
    internal static bool TryGetNameValues(string token, Dictionary`2& tokenValues);
}
internal class Microsoft.VisualStudio.Services.Common.VssServiceIdentityTokenProvider : IssuedTokenProvider {
    [CompilerGeneratedAttribute]
private string <Realm>k__BackingField;
    private DelegatingHandler m_innerHandler;
    protected string AuthenticationParameter { get; }
    protected string AuthenticationScheme { get; }
    public VssServiceIdentityCredential Credential { get; }
    public bool GetTokenIsInteractive { get; }
    public string Realm { get; }
    public VssServiceIdentityTokenProvider(VssServiceIdentityCredential credential, Uri serverUrl, Uri signInUrl, string realm, DelegatingHandler innerHandler);
    public VssServiceIdentityTokenProvider(VssServiceIdentityCredential credential, Uri serverUrl, Uri signInUrl, string realm);
    protected virtual string get_AuthenticationParameter();
    protected virtual string get_AuthenticationScheme();
    public VssServiceIdentityCredential get_Credential();
    public virtual bool get_GetTokenIsInteractive();
    [CompilerGeneratedAttribute]
public string get_Realm();
    protected internal virtual bool IsAuthenticationChallenge(IHttpResponse webResponse);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Services.Common.VssServiceIdentityTokenProvider/<OnGetTokenAsync>d__14")]
protected virtual Task`1<IssuedToken> OnGetTokenAsync(IssuedToken failedToken, CancellationToken cancellationToken);
    private HttpMessageHandler CreateMessageHandler();
}
public class Microsoft.VisualStudio.Services.Common.VssSignInContextModel : object {
    [CompilerGeneratedAttribute]
private List`1<string> <SignInCookieDomains>k__BackingField;
    public List`1<string> SignInCookieDomains { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<string> get_SignInCookieDomains();
    [CompilerGeneratedAttribute]
public void set_SignInCookieDomains(List`1<string> value);
}
public class Microsoft.VisualStudio.Services.Common.VssStringComparer : StringComparer {
    private StringComparison m_stringComparison;
    private StringComparer m_stringComparer;
    protected static VssStringComparer s_ordinal;
    protected static VssStringComparer s_ordinalIgnoreCase;
    protected static VssStringComparer s_currentCulture;
    protected static VssStringComparer s_currentCultureIgnoreCase;
    private static VssStringComparer s_dataSourceIgnoreProtocol;
    private StringComparer MatchingStringComparer { get; }
    public static VssStringComparer ActiveDirectoryEntityIdComparer { get; }
    public static VssStringComparer ArtifactType { get; }
    public static VssStringComparer ArtifactTool { get; }
    public static VssStringComparer AssemblyName { get; }
    public static VssStringComparer ContentType { get; }
    public static VssStringComparer DomainName { get; }
    public static VssStringComparer DomainNameUI { get; }
    public static VssStringComparer DatabaseCategory { get; }
    public static VssStringComparer DatabaseName { get; }
    public static VssStringComparer DatabasePool { get; }
    public static VssStringComparer DataSource { get; }
    public static VssStringComparer DataSourceIgnoreProtocol { get; }
    public static VssStringComparer DirectoryName { get; }
    public static VssStringComparer DirectoryEntityIdentifierConstants { get; }
    public static VssStringComparer DirectoryEntityPropertyComparer { get; }
    public static VssStringComparer DirectoryEntityTypeComparer { get; }
    public static VssStringComparer DirectoryEntryNameComparer { get; }
    public static VssStringComparer DirectoryKeyStringComparer { get; }
    public static VssStringComparer EncodingName { get; }
    public static VssStringComparer EnvVar { get; }
    public static VssStringComparer ExceptionSource { get; }
    public static VssStringComparer FilePath { get; }
    public static VssStringComparer FilePathUI { get; }
    public static VssStringComparer Guid { get; }
    public static VssStringComparer Hostname { get; }
    public static VssStringComparer HostnameUI { get; }
    public static VssStringComparer HttpRequestMethod { get; }
    public static VssStringComparer IdentityDescriptor { get; }
    public static VssStringComparer IdentityDomain { get; }
    public static VssStringComparer IdentityOriginId { get; }
    public static VssStringComparer IdentityType { get; }
    public static VssStringComparer LinkName { get; }
    public static VssStringComparer MachineName { get; }
    public static VssStringComparer MailAddress { get; }
    public static VssStringComparer PropertyName { get; }
    public static VssStringComparer RegistrationAttributeName { get; }
    public static VssStringComparer ReservedGroupName { get; }
    public static VssStringComparer WMDSchemaClassName { get; }
    public static VssStringComparer SamAccountName { get; }
    public static VssStringComparer AccountName { get; }
    public static VssStringComparer SocialType { get; }
    public static VssStringComparer ServerUrl { get; }
    public static VssStringComparer ServerUrlUI { get; }
    public static VssStringComparer ServiceInterface { get; }
    public static VssStringComparer ServicingOperation { get; }
    public static VssStringComparer ToolId { get; }
    public static VssStringComparer Url { get; }
    public static VssStringComparer UrlPath { get; }
    public static VssStringComparer UriScheme { get; }
    public static VssStringComparer UriAuthority { get; }
    public static VssStringComparer UserId { get; }
    public static VssStringComparer UserName { get; }
    public static VssStringComparer UserNameUI { get; }
    public static VssStringComparer XmlAttributeName { get; }
    public static VssStringComparer XmlNodeName { get; }
    public static VssStringComparer XmlElement { get; }
    public static VssStringComparer XmlAttributeValue { get; }
    public static VssStringComparer RegistryPath { get; }
    public static VssStringComparer ServiceType { get; }
    public static VssStringComparer AccessMappingMoniker { get; }
    public static VssStringComparer CatalogNodePath { get; }
    public static VssStringComparer CatalogServiceReference { get; }
    public static VssStringComparer CatalogNodeDependency { get; }
    public static VssStringComparer ServicingTokenName { get; }
    public static VssStringComparer IdentityPropertyName { get; }
    public static VssStringComparer Collation { get; }
    public static VssStringComparer FeatureAvailabilityName { get; }
    public static VssStringComparer TagName { get; }
    public static VssStringComparer HostingAccountPropertyName { get; }
    public static VssStringComparer MessageBusName { get; }
    public static VssStringComparer MessageBusSubscriptionName { get; }
    public static VssStringComparer NamespaceName { get; }
    public static VssStringComparer SID { get; }
    public static VssStringComparer FieldName { get; }
    public static VssStringComparer FieldNameUI { get; }
    public static VssStringComparer FieldType { get; }
    public static VssStringComparer EventType { get; }
    public static VssStringComparer EventTypeIgnoreCase { get; }
    public static VssStringComparer RegistrationEntryName { get; }
    public static VssStringComparer ServerName { get; }
    public static VssStringComparer GroupName { get; }
    public static VssStringComparer RegistrationUtilities { get; }
    public static VssStringComparer RegistrationUtilitiesCaseInsensitive { get; }
    public static VssStringComparer IdentityName { get; }
    public static VssStringComparer IdentityNameOrdinal { get; }
    public static VssStringComparer PlugInId { get; }
    public static VssStringComparer ExtensionName { get; }
    public static VssStringComparer ExtensionType { get; }
    public static VssStringComparer DomainUrl { get; }
    public static VssStringComparer AccountInfoAccount { get; }
    public static VssStringComparer AccountInfoPassword { get; }
    public static VssStringComparer AttributesDescriptor { get; }
    public static VssStringComparer NetworkSecurityGroupName { get; }
    public static VssStringComparer VSSServerPath { get; }
    public static VssStringComparer VSSItemName { get; }
    public static VssStringComparer HtmlElementName { get; }
    public static VssStringComparer HtmlAttributeName { get; }
    public static VssStringComparer HtmlAttributeValue { get; }
    public static VssStringComparer StringFieldConditionEquality { get; }
    public static VssStringComparer StringFieldConditionOrdinal { get; }
    public static VssStringComparer ServiceEndpointTypeCompararer { get; }
    protected VssStringComparer(StringComparison stringComparison);
    private static VssStringComparer();
    public virtual int Compare(string x, string y);
    public virtual bool Equals(string x, string y);
    public virtual int GetHashCode(string x);
    public int Compare(string x, int indexX, string y, int indexY, int length);
    public bool Contains(string main, string pattern);
    public int IndexOf(string main, string pattern);
    public bool StartsWith(string main, string pattern);
    public bool EndsWith(string main, string pattern);
    private StringComparer get_MatchingStringComparer();
    public static VssStringComparer get_ActiveDirectoryEntityIdComparer();
    public static VssStringComparer get_ArtifactType();
    public static VssStringComparer get_ArtifactTool();
    public static VssStringComparer get_AssemblyName();
    public static VssStringComparer get_ContentType();
    public static VssStringComparer get_DomainName();
    public static VssStringComparer get_DomainNameUI();
    public static VssStringComparer get_DatabaseCategory();
    public static VssStringComparer get_DatabaseName();
    public static VssStringComparer get_DatabasePool();
    public static VssStringComparer get_DataSource();
    public static VssStringComparer get_DataSourceIgnoreProtocol();
    public static VssStringComparer get_DirectoryName();
    public static VssStringComparer get_DirectoryEntityIdentifierConstants();
    public static VssStringComparer get_DirectoryEntityPropertyComparer();
    public static VssStringComparer get_DirectoryEntityTypeComparer();
    public static VssStringComparer get_DirectoryEntryNameComparer();
    public static VssStringComparer get_DirectoryKeyStringComparer();
    public static VssStringComparer get_EncodingName();
    public static VssStringComparer get_EnvVar();
    public static VssStringComparer get_ExceptionSource();
    public static VssStringComparer get_FilePath();
    public static VssStringComparer get_FilePathUI();
    public static VssStringComparer get_Guid();
    public static VssStringComparer get_Hostname();
    public static VssStringComparer get_HostnameUI();
    public static VssStringComparer get_HttpRequestMethod();
    public static VssStringComparer get_IdentityDescriptor();
    public static VssStringComparer get_IdentityDomain();
    public static VssStringComparer get_IdentityOriginId();
    public static VssStringComparer get_IdentityType();
    public static VssStringComparer get_LinkName();
    public static VssStringComparer get_MachineName();
    public static VssStringComparer get_MailAddress();
    public static VssStringComparer get_PropertyName();
    public static VssStringComparer get_RegistrationAttributeName();
    public static VssStringComparer get_ReservedGroupName();
    public static VssStringComparer get_WMDSchemaClassName();
    public static VssStringComparer get_SamAccountName();
    public static VssStringComparer get_AccountName();
    public static VssStringComparer get_SocialType();
    public static VssStringComparer get_ServerUrl();
    public static VssStringComparer get_ServerUrlUI();
    public static VssStringComparer get_ServiceInterface();
    public static VssStringComparer get_ServicingOperation();
    public static VssStringComparer get_ToolId();
    public static VssStringComparer get_Url();
    public static VssStringComparer get_UrlPath();
    public static VssStringComparer get_UriScheme();
    public static VssStringComparer get_UriAuthority();
    public static VssStringComparer get_UserId();
    public static VssStringComparer get_UserName();
    public static VssStringComparer get_UserNameUI();
    public static VssStringComparer get_XmlAttributeName();
    public static VssStringComparer get_XmlNodeName();
    public static VssStringComparer get_XmlElement();
    public static VssStringComparer get_XmlAttributeValue();
    public static VssStringComparer get_RegistryPath();
    public static VssStringComparer get_ServiceType();
    public static VssStringComparer get_AccessMappingMoniker();
    public static VssStringComparer get_CatalogNodePath();
    public static VssStringComparer get_CatalogServiceReference();
    public static VssStringComparer get_CatalogNodeDependency();
    public static VssStringComparer get_ServicingTokenName();
    public static VssStringComparer get_IdentityPropertyName();
    public static VssStringComparer get_Collation();
    public static VssStringComparer get_FeatureAvailabilityName();
    public static VssStringComparer get_TagName();
    public static VssStringComparer get_HostingAccountPropertyName();
    public static VssStringComparer get_MessageBusName();
    public static VssStringComparer get_MessageBusSubscriptionName();
    public static VssStringComparer get_NamespaceName();
    public static VssStringComparer get_SID();
    public static VssStringComparer get_FieldName();
    public static VssStringComparer get_FieldNameUI();
    public static VssStringComparer get_FieldType();
    public static VssStringComparer get_EventType();
    public static VssStringComparer get_EventTypeIgnoreCase();
    public static VssStringComparer get_RegistrationEntryName();
    public static VssStringComparer get_ServerName();
    public static VssStringComparer get_GroupName();
    public static VssStringComparer get_RegistrationUtilities();
    public static VssStringComparer get_RegistrationUtilitiesCaseInsensitive();
    public static VssStringComparer get_IdentityName();
    public static VssStringComparer get_IdentityNameOrdinal();
    public static VssStringComparer get_PlugInId();
    public static VssStringComparer get_ExtensionName();
    public static VssStringComparer get_ExtensionType();
    public static VssStringComparer get_DomainUrl();
    public static VssStringComparer get_AccountInfoAccount();
    public static VssStringComparer get_AccountInfoPassword();
    public static VssStringComparer get_AttributesDescriptor();
    public static VssStringComparer get_NetworkSecurityGroupName();
    public static VssStringComparer get_VSSServerPath();
    public static VssStringComparer get_VSSItemName();
    public static VssStringComparer get_HtmlElementName();
    public static VssStringComparer get_HtmlAttributeName();
    public static VssStringComparer get_HtmlAttributeValue();
    public static VssStringComparer get_StringFieldConditionEquality();
    public static VssStringComparer get_StringFieldConditionOrdinal();
    public static VssStringComparer get_ServiceEndpointTypeCompararer();
}
public static class Microsoft.VisualStudio.Services.Common.VssThreadSafeRandom : object {
    [ThreadStaticAttribute]
private static Random ts_random;
    private static RandomNumberGenerator s_randomNumberGenerator;
    private static Random Instance { get; }
    public static int Next();
    public static int Next(int maxValue);
    public static int Next(int minValue, int maxValue);
    public static void NextBytes(Byte[] buffer);
    public static Byte[] NextBytes(int size);
    public static double NextDouble();
    private static Random get_Instance();
}
[ExceptionMappingAttribute("0.0", "3.0", "VssUnauthorizedException", "Microsoft.VisualStudio.Services.Common.VssUnauthorizedException, Microsoft.VisualStudio.Services.Common, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class Microsoft.VisualStudio.Services.Common.VssUnauthorizedException : VssException {
    public VssUnauthorizedException(string message);
    public VssUnauthorizedException(string message, Exception innerException);
    protected VssUnauthorizedException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.VisualStudio.Services.Common.WindowsCredential : IssuedTokenCredential {
    [CompilerGeneratedAttribute]
private bool <UseDefaultCredentials>k__BackingField;
    private ICredentials m_credentials;
    public ICredentials Credentials { get; public set; }
    public VssCredentialsType CredentialType { get; }
    public bool UseDefaultCredentials { get; private set; }
    public WindowsCredential(bool useDefaultCredentials);
    public WindowsCredential(ICredentials credentials);
    public WindowsCredential(WindowsToken initialToken);
    public ICredentials get_Credentials();
    public void set_Credentials(ICredentials value);
    public virtual VssCredentialsType get_CredentialType();
    [CompilerGeneratedAttribute]
public bool get_UseDefaultCredentials();
    [CompilerGeneratedAttribute]
private void set_UseDefaultCredentials(bool value);
    public virtual bool IsAuthenticationChallenge(IHttpResponse webResponse);
    protected virtual IssuedTokenProvider OnCreateTokenProvider(Uri serverUrl, IHttpResponse response);
    private static bool AuthenticationSchemeValid(string authenticateHeader);
}
public enum Microsoft.VisualStudio.Services.Common.WindowsEdition : Enum {
    public int value__;
    public static WindowsEdition Other;
    public static WindowsEdition Starter;
    public static WindowsEdition Basic;
    public static WindowsEdition Premium;
    public static WindowsEdition Ultimate;
    public static WindowsEdition Business;
    public static WindowsEdition Enterprise;
    public static WindowsEdition Undefined;
    public static WindowsEdition Professional;
    public static WindowsEdition DataCenter;
    public static WindowsEdition Essentials;
    public static WindowsEdition Standard;
}
public class Microsoft.VisualStudio.Services.Common.WindowsToken : IssuedToken {
    [CompilerGeneratedAttribute]
private ICredentials <Credentials>k__BackingField;
    public ICredentials Credentials { get; }
    protected internal VssCredentialsType CredentialType { get; }
    internal WindowsToken(ICredentials credentials);
    [CompilerGeneratedAttribute]
public ICredentials get_Credentials();
    protected internal virtual VssCredentialsType get_CredentialType();
    internal virtual void ApplyTo(IHttpRequest request);
    private sealed virtual override NetworkCredential System.Net.ICredentials.GetCredential(Uri uri, string authType);
}
internal class Microsoft.VisualStudio.Services.Common.WindowsTokenProvider : IssuedTokenProvider {
    protected string AuthenticationScheme { get; }
    public WindowsCredential Credential { get; }
    public bool GetTokenIsInteractive { get; }
    public WindowsTokenProvider(WindowsCredential credential, Uri serverUrl);
    protected virtual string get_AuthenticationScheme();
    public WindowsCredential get_Credential();
    public virtual bool get_GetTokenIsInteractive();
}
public enum Microsoft.VisualStudio.Services.Common.WindowsVersion : Enum {
    public int value__;
    public static WindowsVersion Unknown;
    public static WindowsVersion Server2003;
    public static WindowsVersion Server2008;
    public static WindowsVersion Vista;
    public static WindowsVersion Windows7;
    public static WindowsVersion Future;
    public static WindowsVersion Server2008R2;
    public static WindowsVersion XP;
    public static WindowsVersion Windows8Client;
    public static WindowsVersion Windows8Server;
    public static WindowsVersion WinBlueClient;
    public static WindowsVersion WinBlueServer;
    public static WindowsVersion Windows10Client;
    public static WindowsVersion Server2016;
    public static WindowsVersion Server2019;
    public static WindowsVersion Server2022;
    public static WindowsVersion Windows11Client;
}
public enum Microsoft.VisualStudio.Services.Common.WinHttpErrorCode : Enum {
    public int value__;
    public static WinHttpErrorCode WINHTTP_ERROR_BASE;
    public static WinHttpErrorCode WINHTTP_ERROR_LAST;
    public static WinHttpErrorCode ERROR_WINHTTP_OUT_OF_HANDLES;
    public static WinHttpErrorCode ERROR_WINHTTP_TIMEOUT;
    public static WinHttpErrorCode ERROR_WINHTTP_INTERNAL_ERROR;
    public static WinHttpErrorCode ERROR_WINHTTP_INVALID_URL;
    public static WinHttpErrorCode ERROR_WINHTTP_UNRECOGNIZED_SCHEME;
    public static WinHttpErrorCode ERROR_WINHTTP_NAME_NOT_RESOLVED;
    public static WinHttpErrorCode ERROR_WINHTTP_INVALID_OPTION;
    public static WinHttpErrorCode ERROR_WINHTTP_OPTION_NOT_SETTABLE;
    public static WinHttpErrorCode ERROR_WINHTTP_SHUTDOWN;
    public static WinHttpErrorCode ERROR_WINHTTP_LOGIN_FAILURE;
    public static WinHttpErrorCode ERROR_WINHTTP_OPERATION_CANCELLED;
    public static WinHttpErrorCode ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
    public static WinHttpErrorCode ERROR_WINHTTP_INCORRECT_HANDLE_STATE;
    public static WinHttpErrorCode ERROR_WINHTTP_CANNOT_CONNECT;
    public static WinHttpErrorCode ERROR_WINHTTP_CONNECTION_ERROR;
    public static WinHttpErrorCode ERROR_WINHTTP_RESEND_REQUEST;
    public static WinHttpErrorCode ERROR_WINHTTP_SECURE_CERT_DATE_INVALID;
    public static WinHttpErrorCode ERROR_WINHTTP_SECURE_CERT_CN_INVALID;
    public static WinHttpErrorCode ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED;
    public static WinHttpErrorCode ERROR_WINHTTP_SECURE_INVALID_CA;
    public static WinHttpErrorCode ERROR_WINHTTP_SECURE_CERT_REV_FAILED;
    public static WinHttpErrorCode ERROR_WINHTTP_CANNOT_CALL_BEFORE_OPEN;
    public static WinHttpErrorCode ERROR_WINHTTP_CANNOT_CALL_BEFORE_SEND;
    public static WinHttpErrorCode ERROR_WINHTTP_CANNOT_CALL_AFTER_SEND;
    public static WinHttpErrorCode ERROR_WINHTTP_CANNOT_CALL_AFTER_OPEN;
    public static WinHttpErrorCode ERROR_WINHTTP_HEADER_NOT_FOUND;
    public static WinHttpErrorCode ERROR_WINHTTP_INVALID_SERVER_RESPONSE;
    public static WinHttpErrorCode ERROR_WINHTTP_INVALID_HEADER;
    public static WinHttpErrorCode ERROR_WINHTTP_INVALID_QUERY_REQUEST;
    public static WinHttpErrorCode ERROR_WINHTTP_HEADER_ALREADY_EXISTS;
    public static WinHttpErrorCode ERROR_WINHTTP_REDIRECT_FAILED;
    public static WinHttpErrorCode ERROR_WINHTTP_SECURE_CHANNEL_ERROR;
    public static WinHttpErrorCode ERROR_WINHTTP_BAD_AUTO_PROXY_SCRIPT;
    public static WinHttpErrorCode ERROR_WINHTTP_UNABLE_TO_DOWNLOAD_SCRIPT;
    public static WinHttpErrorCode ERROR_WINHTTP_SECURE_INVALID_CERT;
    public static WinHttpErrorCode ERROR_WINHTTP_SECURE_CERT_REVOKED;
    public static WinHttpErrorCode ERROR_WINHTTP_NOT_INITIALIZED;
    public static WinHttpErrorCode ERROR_WINHTTP_SECURE_FAILURE;
    public static WinHttpErrorCode ERROR_WINHTTP_UNHANDLED_SCRIPT_TYPE;
    public static WinHttpErrorCode ERROR_WINHTTP_SCRIPT_EXECUTION_ERROR;
    public static WinHttpErrorCode ERROR_WINHTTP_AUTO_PROXY_SERVICE_ERROR;
    public static WinHttpErrorCode ERROR_WINHTTP_SECURE_CERT_WRONG_USAGE;
    public static WinHttpErrorCode ERROR_WINHTTP_AUTODETECTION_FAILED;
    public static WinHttpErrorCode ERROR_WINHTTP_HEADER_COUNT_EXCEEDED;
    public static WinHttpErrorCode ERROR_WINHTTP_HEADER_SIZE_OVERFLOW;
    public static WinHttpErrorCode ERROR_WINHTTP_CHUNKED_ENCODING_HEADER_SIZE_OVERFLOW;
    public static WinHttpErrorCode ERROR_WINHTTP_RESPONSE_DRAIN_OVERFLOW;
    public static WinHttpErrorCode ERROR_WINHTTP_CLIENT_CERT_NO_PRIVATE_KEY;
    public static WinHttpErrorCode ERROR_WINHTTP_CLIENT_CERT_NO_ACCESS_PRIVATE_KEY;
    public static WinHttpErrorCode ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED_PROXY;
    public static WinHttpErrorCode ERROR_WINHTTP_SECURE_FAILURE_PROXY;
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
