[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
public class Microsoft.VisualStudio.Services.Client.AccountManagement.Account : AccountKey {
    public static AccountMemberComparer AccountMemberComparer;
    [CompilerGeneratedAttribute]
private string <Authenticator>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Guid> <SupportedAccountProviders>k__BackingField;
    [CompilerGeneratedAttribute]
private AccountDisplayInfo <DisplayInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, string> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NeedsReauthentication>k__BackingField;
    public string Authenticator { get; private set; }
    public IReadOnlyList`1<Guid> SupportedAccountProviders { get; private set; }
    public AccountDisplayInfo DisplayInfo { get; private set; }
    public IReadOnlyDictionary`2<string, string> Properties { get; private set; }
    public bool NeedsReauthentication { get; private set; }
    public Account(AccountInitializationData initializationData);
    private static Account();
    [CompilerGeneratedAttribute]
public string get_Authenticator();
    [CompilerGeneratedAttribute]
private void set_Authenticator(string value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<Guid> get_SupportedAccountProviders();
    [CompilerGeneratedAttribute]
private void set_SupportedAccountProviders(IReadOnlyList`1<Guid> value);
    [CompilerGeneratedAttribute]
public AccountDisplayInfo get_DisplayInfo();
    [CompilerGeneratedAttribute]
private void set_DisplayInfo(AccountDisplayInfo value);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, string> get_Properties();
    [CompilerGeneratedAttribute]
private void set_Properties(IReadOnlyDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public bool get_NeedsReauthentication();
    [CompilerGeneratedAttribute]
private void set_NeedsReauthentication(bool value);
    internal AccountInitializationData InitializationDataFromAccount();
}
internal class Microsoft.VisualStudio.Services.Client.AccountManagement.AccountCache : object {
    private Storage m_storage;
    private IPublicClientApplication m_application;
    private string m_lockfilePath;
    private string m_authorityBase;
    private bool m_validateAuthority;
    public AccountCache(IAccountCacheConfiguration cacheConfig, IAadProviderConfiguration aadConfig, string tenantId, string queryParameters);
    public sealed virtual IEnumerable`1<IAccountCacheItem> GetItems();
    public sealed virtual Task`1<IEnumerable`1<IAccountCacheItem>> GetItemsAsync();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Services.Client.AccountManagement.AccountCache/<AcquireTokenSilentAsync>d__3")]
public sealed virtual Task`1<IAccountCacheItem> AcquireTokenSilentAsync(String[] scopes, string userIdentifier, string tenantId);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Services.Client.AccountManagement.AccountCache/<DeleteItemAsync>d__4")]
public sealed virtual Task DeleteItemAsync(IAccountCacheItem token);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Services.Client.AccountManagement.AccountCache/<AcquireTokenInteractiveAsync>d__5")]
public sealed virtual Task`1<IAccountCacheItem> AcquireTokenInteractiveAsync(String[] scopes, Prompt prompt, string userIdentifier, string tenantId);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Services.Client.AccountManagement.AccountCache/<GetAnyUserIdentifierAsync>d__6")]
public sealed virtual Task`1<string> GetAnyUserIdentifierAsync();
    public sealed virtual IEnumerable`1<IAccountCacheItem> GetVsoEndpointToken(IAccountCacheItem tokenCacheItem);
    public sealed virtual Task`1<IEnumerable`1<IAccountCacheItem>> GetVsoEndpointTokenAsync(IAccountCacheItem tokenCacheItem);
}
internal class Microsoft.VisualStudio.Services.Client.AccountManagement.AccountCacheConfiguration : object {
    private string path;
    internal static string DefaultBaseCachePath;
    [CompilerGeneratedAttribute]
private string <InstanceName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MacKeyChainService>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MacKeyChainAccount>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LinuxKeyRingSchema>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LinuxKeyRingCollection>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LinuxKeyRingLabel>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyValuePair`2<string, string> <LinuxKeyRingAttr1>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyValuePair`2<string, string> <LinuxKeyRingAttr2>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LockfileName>k__BackingField;
    public string InstanceName { get; public set; }
    public string FileName { get; public set; }
    public string DirectoryPath { get; public set; }
    public string FilePath { get; }
    public string MacKeyChainService { get; public set; }
    public string MacKeyChainAccount { get; public set; }
    public string LinuxKeyRingSchema { get; public set; }
    public string LinuxKeyRingCollection { get; public set; }
    public string LinuxKeyRingLabel { get; public set; }
    public KeyValuePair`2<string, string> LinuxKeyRingAttr1 { get; public set; }
    public KeyValuePair`2<string, string> LinuxKeyRingAttr2 { get; public set; }
    public string LockfileName { get; public set; }
    public string LockfilePath { get; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_InstanceName();
    [CompilerGeneratedAttribute]
public sealed virtual void set_InstanceName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FileName();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FileName(string value);
    public sealed virtual string get_DirectoryPath();
    public sealed virtual void set_DirectoryPath(string value);
    public sealed virtual string get_FilePath();
    [CompilerGeneratedAttribute]
public sealed virtual string get_MacKeyChainService();
    [CompilerGeneratedAttribute]
public sealed virtual void set_MacKeyChainService(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MacKeyChainAccount();
    [CompilerGeneratedAttribute]
public sealed virtual void set_MacKeyChainAccount(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_LinuxKeyRingSchema();
    [CompilerGeneratedAttribute]
public sealed virtual void set_LinuxKeyRingSchema(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_LinuxKeyRingCollection();
    [CompilerGeneratedAttribute]
public sealed virtual void set_LinuxKeyRingCollection(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_LinuxKeyRingLabel();
    [CompilerGeneratedAttribute]
public sealed virtual void set_LinuxKeyRingLabel(string value);
    [CompilerGeneratedAttribute]
public sealed virtual KeyValuePair`2<string, string> get_LinuxKeyRingAttr1();
    [CompilerGeneratedAttribute]
public sealed virtual void set_LinuxKeyRingAttr1(KeyValuePair`2<string, string> value);
    [CompilerGeneratedAttribute]
public sealed virtual KeyValuePair`2<string, string> get_LinuxKeyRingAttr2();
    [CompilerGeneratedAttribute]
public sealed virtual void set_LinuxKeyRingAttr2(KeyValuePair`2<string, string> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_LockfileName();
    [CompilerGeneratedAttribute]
public sealed virtual void set_LockfileName(string value);
    public sealed virtual string get_LockfilePath();
}
internal class Microsoft.VisualStudio.Services.Client.AccountManagement.AccountCacheItem : object {
    private AuthenticationResult authenticationResult;
    public string UniqueId { get; }
    public string TenantId { get; }
    public string Username { get; }
    public string Environment { get; }
    public string IdToken { get; }
    public DateTimeOffset ExpiresOn { get; }
    public string AccessToken { get; }
    public AuthenticationResult InnerResult { get; }
    public string GivenName { get; }
    public string FamilyName { get; }
    public AccountCacheItem(AuthenticationResult authenticationResult);
    public sealed virtual string get_UniqueId();
    public sealed virtual string get_TenantId();
    public sealed virtual string get_Username();
    public sealed virtual string get_Environment();
    public sealed virtual string get_IdToken();
    public sealed virtual DateTimeOffset get_ExpiresOn();
    public sealed virtual string get_AccessToken();
    public sealed virtual AuthenticationResult get_InnerResult();
    public sealed virtual string get_GivenName();
    public sealed virtual string get_FamilyName();
}
public class Microsoft.VisualStudio.Services.Client.AccountManagement.AccountDisplayInfo : object {
    public static AccountDisplayInfoNoLogoComparer DisplayInfoNoLogoComparer;
    [CompilerGeneratedAttribute]
private string <AccountDisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProviderDisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserName>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <AccountLogo>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <ProviderLogo>k__BackingField;
    public string AccountDisplayName { get; private set; }
    public string ProviderDisplayName { get; private set; }
    public string UserName { get; private set; }
    public Byte[] AccountLogo { get; private set; }
    public Byte[] ProviderLogo { get; private set; }
    public AccountDisplayInfo(string accountDisplayName, string providerDisplayName, string userName, Byte[] accountLogo, Byte[] providerLogo);
    private static AccountDisplayInfo();
    [CompilerGeneratedAttribute]
public string get_AccountDisplayName();
    [CompilerGeneratedAttribute]
private void set_AccountDisplayName(string value);
    [CompilerGeneratedAttribute]
public string get_ProviderDisplayName();
    [CompilerGeneratedAttribute]
private void set_ProviderDisplayName(string value);
    [CompilerGeneratedAttribute]
public string get_UserName();
    [CompilerGeneratedAttribute]
private void set_UserName(string value);
    [CompilerGeneratedAttribute]
public Byte[] get_AccountLogo();
    [CompilerGeneratedAttribute]
private void set_AccountLogo(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_ProviderLogo();
    [CompilerGeneratedAttribute]
private void set_ProviderLogo(Byte[] value);
}
public class Microsoft.VisualStudio.Services.Client.AccountManagement.AccountDisplayInfoNoLogoComparer : object {
    public sealed virtual bool Equals(AccountDisplayInfo x, AccountDisplayInfo y);
    public sealed virtual int GetHashCode(AccountDisplayInfo obj);
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Services.Client.AccountManagement.AccountExtensions : object {
    private static void VerifyVSAccountProviderAccount(Account account);
    [ExtensionAttribute]
public static string GetIdentityProviderProperty(Account account);
    [ExtensionAttribute]
public static Account SetPersonalizationAccount(Account account, IAccountStore store);
    [ExtensionAttribute]
public static bool IsPersonalizationAccount(Account account);
    [ExtensionAttribute]
public static string GetIdTokenPayload(Account account);
    [ExtensionAttribute]
public static string GetHomeTenantId(Account account);
}
public class Microsoft.VisualStudio.Services.Client.AccountManagement.AccountInitializationData : ValueType {
    [CompilerGeneratedAttribute]
private AccountDisplayInfo <DisplayInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UniqueId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Authenticator>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <ParentProviderId>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, string> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Guid> <SupportedAccountProviders>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NeedsReauthentication>k__BackingField;
    public AccountDisplayInfo DisplayInfo { get; public set; }
    public string UniqueId { get; public set; }
    public string Authenticator { get; public set; }
    public Guid ParentProviderId { get; public set; }
    public IReadOnlyDictionary`2<string, string> Properties { get; public set; }
    public IReadOnlyList`1<Guid> SupportedAccountProviders { get; public set; }
    public bool NeedsReauthentication { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public AccountDisplayInfo get_DisplayInfo();
    [CompilerGeneratedAttribute]
public void set_DisplayInfo(AccountDisplayInfo value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_UniqueId();
    [CompilerGeneratedAttribute]
public void set_UniqueId(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Authenticator();
    [CompilerGeneratedAttribute]
public void set_Authenticator(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Guid get_ParentProviderId();
    [CompilerGeneratedAttribute]
public void set_ParentProviderId(Guid value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, string> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(IReadOnlyDictionary`2<string, string> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IReadOnlyList`1<Guid> get_SupportedAccountProviders();
    [CompilerGeneratedAttribute]
public void set_SupportedAccountProviders(IReadOnlyList`1<Guid> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_NeedsReauthentication();
    [CompilerGeneratedAttribute]
public void set_NeedsReauthentication(bool value);
}
public class Microsoft.VisualStudio.Services.Client.AccountManagement.AccountKey : object {
    public static AccountKeyComparer KeyComparer;
    [CompilerGeneratedAttribute]
private string <UniqueId>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <ProviderId>k__BackingField;
    public string UniqueId { get; private set; }
    public Guid ProviderId { get; private set; }
    public AccountKey(string uniqueId, Guid providerId);
    private static AccountKey();
    [CompilerGeneratedAttribute]
public string get_UniqueId();
    [CompilerGeneratedAttribute]
private void set_UniqueId(string value);
    [CompilerGeneratedAttribute]
public Guid get_ProviderId();
    [CompilerGeneratedAttribute]
private void set_ProviderId(Guid value);
}
public class Microsoft.VisualStudio.Services.Client.AccountManagement.AccountKeyComparer : object {
    public sealed virtual bool Equals(AccountKey x, AccountKey y);
    public sealed virtual int GetHashCode(AccountKey obj);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.Services.Client.AccountManagement.AccountManagementUtilities : object {
    internal static int DefaultCacheVersion;
    internal static string DefaultRegistryRoot;
    internal static string EndpointRegistryOverrideName;
    internal static string VSOEndpointRegistryOverrideName;
    internal static string ExtraParametersRegistryOverrideName;
    public static Task`1<bool> TrueTask;
    public static Task`1<bool> FalseTask;
    private static AccountManagementUtilities();
    [ExtensionAttribute]
internal static bool RemoveMidQueue(Queue`1<T> queue, T valueToRemove);
    internal static Uri CreateAzureRMUri(Uri baseUri, string apiVersion, Uri relativeUri);
    internal static void ExecuteActionInGlobalMutex(string globalMutexName, Action action);
    internal static string SerializeDictionaryAccountProperty(IDictionary`2<string, string> map);
    internal static int IncrementRegistryValue(RegistryKey rootKey, string registrySentinelValue);
    internal static Uri CheckUri(string uriName);
    internal static bool IsFwlink(Uri url);
    internal static TResult ExecuteInGlobalMutex(string globalMutexName, Func`1<TResult> func);
    internal static Uri ResolveFWLinkIfRequired(Uri vsoEndPoint);
    [ExtensionAttribute]
internal static bool EqualsOrdinalIgnoreCase(string string1, string string2);
    [ExtensionAttribute]
internal static IEnumerable`1<T> ExceptNull(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static bool AreSetsEqual(IEnumerable`1<T> first, IEnumerable`1<T> second, IEqualityComparer`1<T> equalityComparer);
    internal static Uri GetVSOEndpointRegistryOverride();
    internal static Uri GetEndpointRegistryOverride();
    internal static string GetExtraParametersRegistryOverride();
    internal static Byte[] GetDefaultProviderImage();
    internal static Byte[] GetMSAImage();
    [ExtensionAttribute]
internal static Account GetAccountFromKey(IAccountStore store, AccountKey key);
}
public class Microsoft.VisualStudio.Services.Client.AccountManagement.AccountManager : object {
    private static Lazy`1<IAccountManager> accountManagerInstance;
    private VssTokenStorage VssTokenStorageInstance;
    private IAccountCache AccountCacheInstance;
    private VSAccountProvider vsAccountProvider;
    private IVSAccountProviderShim vsAccountProviderShim;
    private static object syncLock;
    private string instanceName;
    private static Uri ResolvedVsoEndpoint;
    internal static Uri DefaultVsoEndpoint;
    private static AggregateLogger logger;
    [CompilerGeneratedAttribute]
private IAccountStore <Store>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`1<Uri> <GetVSOEndpointCallback>k__BackingField;
    internal static ILogger Logger { get; }
    public static IAccountManager DefaultInstance { get; }
    public IAccountStore Store { get; private set; }
    public static Uri VsoEndpoint { get; public set; }
    public static Func`1<Uri> GetVSOEndpointCallback { get; public set; }
    public AccountManager(IAccountStore store, string instanceName);
    internal AccountManager(IAccountStore store, string instanceName, IVSAccountProviderShim vsAccountProviderShim);
    private static AccountManager();
    internal static ILogger get_Logger();
    public static void AddLogger(ILogger logger);
    public static void RemoveLogger(ILogger logger);
    public static IAccountManager get_DefaultInstance();
    [CompilerGeneratedAttribute]
public sealed virtual IAccountStore get_Store();
    [CompilerGeneratedAttribute]
private void set_Store(IAccountStore value);
    public static Uri get_VsoEndpoint();
    public static void set_VsoEndpoint(Uri value);
    [CompilerGeneratedAttribute]
public static Func`1<Uri> get_GetVSOEndpointCallback();
    [CompilerGeneratedAttribute]
public static void set_GetVSOEndpointCallback(Func`1<Uri> value);
    public sealed virtual T GetCache();
    private object TryGetAccountManagerCache(Type t);
    private void SetApplicationCore();
    private object TryGetVssTokenStorage(Type t);
    public sealed virtual IAccountProvider GetAccountProvider(Guid accountProviderId);
    public static void SetDefaultInstanceWithName(string instanceName, IAccountStore store, IVSAccountProviderShim vsAccountProviderShim);
    internal static void SetDefaultInstance(IAccountManager manager);
    internal void SetVssTokenStorageInstance(VssTokenStorage store);
    internal void SetAccountManagerAccountCacheInstance(IAccountCache accountCache);
    internal static Uri GetVsoEndpoint();
    internal void SignInTelemetryEventHandler(InteractiveAuthenticationEvent e);
}
public class Microsoft.VisualStudio.Services.Client.AccountManagement.AccountMemberComparer : object {
    public sealed virtual bool Equals(Account accountA, Account accountB);
    public sealed virtual int GetHashCode(Account obj);
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Services.Client.AccountManagement.AccountProviderExtensions : object {
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Services.Client.AccountManagement.AccountProviderExtensions/<RefreshAuthenticationStateAsync>d__0")]
[ExtensionAttribute]
public static Task RefreshAuthenticationStateAsync(IAccountProvider provider, CancellationToken cancellationToken);
}
internal class Microsoft.VisualStudio.Services.Client.AccountManagement.AccountRegistryWatcher : object {
    [CompilerGeneratedAttribute]
private RegistryHive <Hive>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KeyPath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WatchSubtree>k__BackingField;
    [CompilerGeneratedAttribute]
private RegistryChangeNotificationFilter <Filter>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<Exception> <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private Action <KeyChanged>k__BackingField;
    private Thread m_monitorThread;
    private SafeHandle m_registryHandle;
    private AutoResetEvent m_shutdownEvent;
    private AutoResetEvent m_registryChangedEvent;
    private static int ERROR_FILE_NOT_FOUND;
    private static int ERROR_SUCCESS;
    private static IntPtr HKEY_CLASSES_ROOT;
    private static IntPtr HKEY_CURRENT_USER;
    private static IntPtr HKEY_LOCAL_MACHINE;
    private static IntPtr HKEY_USERS;
    private static IntPtr HKEY_CURRENT_CONFIG;
    public RegistryHive Hive { get; private set; }
    public string KeyPath { get; private set; }
    public bool WatchSubtree { get; private set; }
    public RegistryChangeNotificationFilter Filter { get; private set; }
    public Action`1<Exception> Error { get; public set; }
    public Action KeyChanged { get; public set; }
    public AccountRegistryWatcher(RegistryHive hive, string keyPath);
    public AccountRegistryWatcher(RegistryHive hive, string keyPath, bool watchSubtree);
    public AccountRegistryWatcher(RegistryHive hive, string keyPath, bool watchSubtree, RegistryChangeNotificationFilter filter);
    private static AccountRegistryWatcher();
    [CompilerGeneratedAttribute]
public RegistryHive get_Hive();
    [CompilerGeneratedAttribute]
private void set_Hive(RegistryHive value);
    [CompilerGeneratedAttribute]
public string get_KeyPath();
    [CompilerGeneratedAttribute]
private void set_KeyPath(string value);
    [CompilerGeneratedAttribute]
public bool get_WatchSubtree();
    [CompilerGeneratedAttribute]
private void set_WatchSubtree(bool value);
    [CompilerGeneratedAttribute]
public RegistryChangeNotificationFilter get_Filter();
    [CompilerGeneratedAttribute]
private void set_Filter(RegistryChangeNotificationFilter value);
    [CompilerGeneratedAttribute]
public Action`1<Exception> get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(Action`1<Exception> value);
    [CompilerGeneratedAttribute]
public Action get_KeyChanged();
    [CompilerGeneratedAttribute]
public void set_KeyChanged(Action value);
    public sealed virtual void Dispose();
    public void Stop();
    public void Start();
    private void OnError(Exception ex);
    private void OnKeyChanged();
    private void StopInternal();
    private bool StartKeyMonitor();
    private void MonitorRegistryKey();
    public static int RegNotifyChangeKeyValue(SafeHandle hKey, bool watchSubtree, RegistryChangeNotificationFilter dwNotifyFilter, SafeHandle hEvent, bool fAsynchronous);
    private static int RegOpenKeyEx(IntPtr hKey, string lpSubKey, int ulOptions, RegistryAccessMask samDesired, SafeRegistryHandle& hkResult);
    public static SafeHandle OpenSubKey(RegistryHive hive, string subKey, RegistryAccessMask accessMask);
    private static IntPtr Convert(RegistryHive hive);
}
public class Microsoft.VisualStudio.Services.Client.AccountManagement.AccountsProcessedEventArgs : object {
    [CompilerGeneratedAttribute]
private bool <Skipped>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<Exception> <Exceptions>k__BackingField;
    public bool Skipped { get; public set; }
    public IList`1<Exception> Exceptions { get; public set; }
    public AccountsProcessedEventArgs(IList`1<Exception> exceptions);
    public AccountsProcessedEventArgs(bool skipped, IList`1<Exception> exceptions);
    [CompilerGeneratedAttribute]
public bool get_Skipped();
    [CompilerGeneratedAttribute]
public void set_Skipped(bool value);
    [CompilerGeneratedAttribute]
public IList`1<Exception> get_Exceptions();
    [CompilerGeneratedAttribute]
public void set_Exceptions(IList`1<Exception> value);
}
[ExceptionMappingAttribute("0.0", "3.0", "AccountStorageException", "Microsoft.VisualStudio.Services.Client.AccountManagement.AccountStorageException, Microsoft.VisualStudio.Services.Client, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class Microsoft.VisualStudio.Services.Client.AccountManagement.AccountStorageException : Exception {
    public AccountStorageException(string message);
    public AccountStorageException(string message, Exception innerException);
    protected AccountStorageException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.VisualStudio.Services.Client.AccountManagement.AccountStoreChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Account> <Added>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Account> <Removed>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Tuple`2<Account, Account>> <Modified>k__BackingField;
    public IReadOnlyList`1<Account> Added { get; private set; }
    public IReadOnlyList`1<Account> Removed { get; private set; }
    public IReadOnlyList`1<Tuple`2<Account, Account>> Modified { get; private set; }
    public AccountStoreChangedEventArgs(IReadOnlyList`1<Account> added, IReadOnlyList`1<Account> removed, IReadOnlyList`1<Tuple`2<Account, Account>> modified);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<Account> get_Added();
    [CompilerGeneratedAttribute]
private void set_Added(IReadOnlyList`1<Account> value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<Account> get_Removed();
    [CompilerGeneratedAttribute]
private void set_Removed(IReadOnlyList`1<Account> value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<Tuple`2<Account, Account>> get_Modified();
    [CompilerGeneratedAttribute]
private void set_Modified(IReadOnlyList`1<Tuple`2<Account, Account>> value);
    private static IReadOnlyList`1<Account> GetReadOnlyCollection(Account account);
    internal static AccountStoreChangedEventArgs CreateForAddingAccount(Account account);
    internal static AccountStoreChangedEventArgs CreateForRemovingAccount(Account account);
    internal static AccountStoreChangedEventArgs CreateForModifyingAccount(Account afterAccount);
}
public interface Microsoft.VisualStudio.Services.Client.AccountManagement.IAccountCache {
    public abstract virtual IEnumerable`1<IAccountCacheItem> GetItems();
    public abstract virtual Task`1<IEnumerable`1<IAccountCacheItem>> GetItemsAsync();
    public abstract virtual Task`1<IAccountCacheItem> AcquireTokenSilentAsync(String[] scopes, string userIdentifier, string tenantId);
    public abstract virtual Task DeleteItemAsync(IAccountCacheItem token);
    public abstract virtual Task`1<IAccountCacheItem> AcquireTokenInteractiveAsync(String[] scopes, Prompt prompt, string userIdentifier, string tenantId);
    public abstract virtual Task`1<string> GetAnyUserIdentifierAsync();
    public abstract virtual IEnumerable`1<IAccountCacheItem> GetVsoEndpointToken(IAccountCacheItem tokenCacheItem);
    public abstract virtual Task`1<IEnumerable`1<IAccountCacheItem>> GetVsoEndpointTokenAsync(IAccountCacheItem tokenCacheItem);
}
public interface Microsoft.VisualStudio.Services.Client.AccountManagement.IAccountCacheConfiguration {
    public string InstanceName { get; public set; }
    public string FileName { get; public set; }
    public string DirectoryPath { get; public set; }
    public string FilePath { get; }
    public string MacKeyChainService { get; public set; }
    public string MacKeyChainAccount { get; public set; }
    public string LinuxKeyRingSchema { get; public set; }
    public string LinuxKeyRingCollection { get; public set; }
    public string LinuxKeyRingLabel { get; public set; }
    public KeyValuePair`2<string, string> LinuxKeyRingAttr1 { get; public set; }
    public KeyValuePair`2<string, string> LinuxKeyRingAttr2 { get; public set; }
    public string LockfilePath { get; }
    public string LockfileName { get; public set; }
    public abstract virtual string get_InstanceName();
    public abstract virtual void set_InstanceName(string value);
    public abstract virtual string get_FileName();
    public abstract virtual void set_FileName(string value);
    public abstract virtual string get_DirectoryPath();
    public abstract virtual void set_DirectoryPath(string value);
    public abstract virtual string get_FilePath();
    public abstract virtual string get_MacKeyChainService();
    public abstract virtual void set_MacKeyChainService(string value);
    public abstract virtual string get_MacKeyChainAccount();
    public abstract virtual void set_MacKeyChainAccount(string value);
    public abstract virtual string get_LinuxKeyRingSchema();
    public abstract virtual void set_LinuxKeyRingSchema(string value);
    public abstract virtual string get_LinuxKeyRingCollection();
    public abstract virtual void set_LinuxKeyRingCollection(string value);
    public abstract virtual string get_LinuxKeyRingLabel();
    public abstract virtual void set_LinuxKeyRingLabel(string value);
    public abstract virtual KeyValuePair`2<string, string> get_LinuxKeyRingAttr1();
    public abstract virtual void set_LinuxKeyRingAttr1(KeyValuePair`2<string, string> value);
    public abstract virtual KeyValuePair`2<string, string> get_LinuxKeyRingAttr2();
    public abstract virtual void set_LinuxKeyRingAttr2(KeyValuePair`2<string, string> value);
    public abstract virtual string get_LockfilePath();
    public abstract virtual string get_LockfileName();
    public abstract virtual void set_LockfileName(string value);
}
public interface Microsoft.VisualStudio.Services.Client.AccountManagement.IAccountCacheItem {
    public string UniqueId { get; }
    public string TenantId { get; }
    public string Username { get; }
    public string Environment { get; }
    public string IdToken { get; }
    public DateTimeOffset ExpiresOn { get; }
    public string AccessToken { get; }
    public AuthenticationResult InnerResult { get; }
    public string GivenName { get; }
    public string FamilyName { get; }
    public abstract virtual string get_UniqueId();
    public abstract virtual string get_TenantId();
    public abstract virtual string get_Username();
    public abstract virtual string get_Environment();
    public abstract virtual string get_IdToken();
    public abstract virtual DateTimeOffset get_ExpiresOn();
    public abstract virtual string get_AccessToken();
    public abstract virtual AuthenticationResult get_InnerResult();
    public abstract virtual string get_GivenName();
    public abstract virtual string get_FamilyName();
}
public interface Microsoft.VisualStudio.Services.Client.AccountManagement.IAccountManager {
    public IAccountStore Store { get; }
    public abstract virtual IAccountStore get_Store();
    public abstract virtual T GetCache();
    public abstract virtual IAccountProvider GetAccountProvider(Guid accountProviderId);
}
public interface Microsoft.VisualStudio.Services.Client.AccountManagement.IAccountProvider {
    public Guid AccountProviderId { get; }
    public IAccountStore AccountStore { get; }
    public abstract virtual Guid get_AccountProviderId();
    public abstract virtual IAccountStore get_AccountStore();
    public abstract virtual void ClearTokensForAccount(Account account);
    public abstract virtual void Initialize(IAccountStore store);
    public abstract virtual Task`1<Account> RefreshAuthenticationStateAsync(AccountKey accountKey, CancellationToken cancellationToken);
    public abstract virtual Task`1<Account> AuthenticateAccountWithUIAsync(AccountKey accountKey, IntPtr parentWindowHandle, CancellationToken cancellationToken);
    public abstract virtual Task`1<Account> CreateAccountWithUIAsync(IntPtr parentWindowHandle, CancellationToken cancellationToken);
    public abstract virtual Task`1<Account> RefreshDisplayInfoAsync(AccountKey accountKey, CancellationToken cancellationToken);
}
public interface Microsoft.VisualStudio.Services.Client.AccountManagement.IAccountStore {
    [CompilerGeneratedAttribute]
public abstract virtual void add_KeychainAccountStoreChanged(EventHandler`1<AccountStoreChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_KeychainAccountStoreChanged(EventHandler`1<AccountStoreChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_KeychainAccountStoreChanging(EventHandler`1<AccountStoreChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_KeychainAccountStoreChanging(EventHandler`1<AccountStoreChangedEventArgs> value);
    public abstract virtual Account AddOrUpdateAccount(Account account);
    public abstract virtual Account SetDisplayInfo(AccountKey account, AccountDisplayInfo info);
    public abstract virtual Account SetProperty(AccountKey account, string key, string value);
    public abstract virtual Account SetNeedsReauthentication(AccountKey account, bool value);
    public abstract virtual Account SetProperties(AccountKey account, IDictionary`2<string, string> properties);
    public abstract virtual void RemoveAccount(AccountKey key);
    public abstract virtual IReadOnlyCollection`1<Account> GetAllAccounts();
}
public interface Microsoft.VisualStudio.Services.Client.AccountManagement.IVSAccountProviderShim {
    public string ExtraQueryParameters { get; public set; }
    public Action`2<bool, List`1<Exception>> RaiseAccountProcessingDoneEvent { get; public set; }
    public abstract virtual string get_ExtraQueryParameters();
    public abstract virtual void set_ExtraQueryParameters(string value);
    public abstract virtual IAadProviderConfiguration GetConfiguration();
    public abstract virtual Guid GetMsaHomeTenantId();
    public abstract virtual Task`1<string> ProcessAuthenticationResultAsync(AuthenticationResult authenticationResult);
    public abstract virtual void ClearTokensForAccount(Account account);
    public abstract virtual Task`1<AuthenticationResult> AcquireTokenAsync(String[] scopes, string tenantId, string userIdentifier, IntPtr parentWindowHandle, AccountKey accountKeyForReAuthentication, bool prompt, CancellationToken cancellationToken);
    public abstract virtual Task`1<AuthenticationResult> AcquireTokenAsyncWithContextAsync(String[] scopes, IAccountCache accountCache, string userIdentifier, AccountKey accountForReauthentication, bool prompt, string extraQueryParameters, CancellationToken cancellationToken);
    public abstract virtual Task`1<string> GetSessionTokenFromAccountAsync(Account account, string scope, bool forceRefresh, CancellationToken cancellationToken);
    public abstract virtual string GetExtraQueryParameters(string authority);
    public abstract virtual Task`1<Account> RefreshAuthenticationStateAsync(AccountKey account, CancellationToken cancellationToken);
    public abstract virtual Task`1<Account> CreateAccountWithUIAsync(IntPtr parentWindowHandle, CancellationToken cancellationToken);
    public abstract virtual Task`1<Account> AuthenticateAccountWithUIAsync(AccountKey accountKey, IntPtr parentWindowHandle, CancellationToken cancellationToken);
    public abstract virtual Task`1<Account> AuthenticateAndApplyScopeWithUIAsync(AccountKey accountKey, IntPtr parentWindowHandle, IEnumerable`1<ScopeInfo> scopes, CancellationToken cancellationToken);
    public abstract virtual Account ClearScopes(AccountKey accountKey);
    public abstract virtual IEnumerable`1<ScopeInfo> GetScopesForAccount(AccountKey accountKey);
    public abstract virtual TenantInformation GetHomeTenantInfo(AccountKey accountKey);
    public abstract virtual IEnumerable`1<TenantInformation> GetTenantsInScope(AccountKey accountKey);
    public abstract virtual Task`1<Account> RefreshDisplayInfoAsync(AccountKey accountKey, CancellationToken cancellationToken);
    public abstract virtual Action`2<bool, List`1<Exception>> get_RaiseAccountProcessingDoneEvent();
    public abstract virtual void set_RaiseAccountProcessingDoneEvent(Action`2<bool, List`1<Exception>> value);
}
internal class Microsoft.VisualStudio.Services.Client.AccountManagement.Logging.AggregateLogger : object {
    private ReaderWriterLockSlim loggersLock;
    private IList`1<ILogger> loggers;
    protected virtual override void Finalize();
    public sealed virtual void LogEvent(string name, IDictionary`2<string, object> properties);
    public void Add(ILogger logger);
    public void Remove(ILogger logger);
    internal void ClearLoggers();
    private void ModifyLoggers(ILogger logger, Action action);
    private void ModifyLoggers(Action action);
    [CompilerGeneratedAttribute]
private void <ClearLoggers>b__6_0();
}
public interface Microsoft.VisualStudio.Services.Client.AccountManagement.Logging.ILogger {
    public abstract virtual void LogEvent(string name, IDictionary`2<string, object> properties);
}
internal class Microsoft.VisualStudio.Services.Client.AccountManagement.PartialCacheItem : object {
    private IAccount account;
    public string UniqueId { get; }
    public string TenantId { get; }
    public string Username { get; }
    public string Environment { get; }
    public string IdToken { get; }
    public DateTimeOffset ExpiresOn { get; }
    public string AccessToken { get; }
    public AuthenticationResult InnerResult { get; }
    public string GivenName { get; }
    public string FamilyName { get; }
    public PartialCacheItem(IAccount account);
    public sealed virtual string get_UniqueId();
    public sealed virtual string get_TenantId();
    public sealed virtual string get_Username();
    public sealed virtual string get_Environment();
    public sealed virtual string get_IdToken();
    public sealed virtual DateTimeOffset get_ExpiresOn();
    public sealed virtual string get_AccessToken();
    public sealed virtual AuthenticationResult get_InnerResult();
    public sealed virtual string get_GivenName();
    public sealed virtual string get_FamilyName();
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Services.Client.AccountManagement.PublicClientApplicationExtensions : object {
    [ExtensionAttribute]
public static AbstractAcquireTokenParameterBuilder`1<T> WithOptionalCorrelationId(AbstractAcquireTokenParameterBuilder`1<T> builder, Nullable`1<Guid> correlationId);
}
public enum Microsoft.VisualStudio.Services.Client.AccountManagement.RegistryAccessMask : Enum {
    public UInt32 value__;
    public static RegistryAccessMask AllAccess;
    public static RegistryAccessMask CreateLink;
    public static RegistryAccessMask CreateSubKey;
    public static RegistryAccessMask EnumerateSubKeys;
    public static RegistryAccessMask Execute;
    public static RegistryAccessMask Notify;
    public static RegistryAccessMask QueryValue;
    public static RegistryAccessMask Read;
    public static RegistryAccessMask SetValue;
    public static RegistryAccessMask Wow6432Key;
    public static RegistryAccessMask Wow6464Key;
    public static RegistryAccessMask Write;
    public static RegistryAccessMask WriteDac;
}
internal class Microsoft.VisualStudio.Services.Client.AccountManagement.RegistryAccountStore : object {
    internal static string KeychainKeyName;
    internal static string AccountsKeyName;
    internal static string DefaultGlobalMutexName;
    private static string RegistryChangedSentinel;
    private static string PropertiesKeyName;
    private static string ProviderIdKeyName;
    private static string UniqueIdKeyName;
    private static string ListOfSupportedProvidersName;
    private static string AuthenticatorName;
    private static string DisplayInfoDisplayName;
    private static string DisplayInfoAccountLogoName;
    private static string DisplayInfoProviderDisplayName;
    private static string DisplayInfoUserName;
    private static string DisplayInfoProviderLogoName;
    private static string NeedsReauthenticationName;
    private static int DefaultAccountVersion;
    private IReadOnlyCollection`1<Account> originalMemoryStore;
    private IReadOnlyCollection`1 modreq(System.Runtime.CompilerServices.IsVolatile) memoryStore;
    private AccountRegistryWatcher watcher;
    private int currentAccountVersion;
    private object syncObj;
    private object watcherLock;
    private bool disposed;
    [CompilerGeneratedAttribute]
private EventHandler`1<AccountStoreChangedEventArgs> KeychainAccountStoreChanged;
    [CompilerGeneratedAttribute]
private EventHandler`1<AccountStoreChangedEventArgs> KeychainAccountStoreChanging;
    [CompilerGeneratedAttribute]
private string <RegistryRoot>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GlobalMutexName>k__BackingField;
    internal string RegistryRoot { get; private set; }
    internal string GlobalMutexName { get; private set; }
    internal RegistryAccountStore(string instanceName);
    internal RegistryAccountStore(string registryRoot, string globalMutexName, string instanceName);
    [CompilerGeneratedAttribute]
public sealed virtual void add_KeychainAccountStoreChanged(EventHandler`1<AccountStoreChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_KeychainAccountStoreChanged(EventHandler`1<AccountStoreChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_KeychainAccountStoreChanging(EventHandler`1<AccountStoreChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_KeychainAccountStoreChanging(EventHandler`1<AccountStoreChangedEventArgs> value);
    [CompilerGeneratedAttribute]
internal string get_RegistryRoot();
    [CompilerGeneratedAttribute]
private void set_RegistryRoot(string value);
    [CompilerGeneratedAttribute]
internal string get_GlobalMutexName();
    [CompilerGeneratedAttribute]
private void set_GlobalMutexName(string value);
    private void OnKeyChanged();
    private bool OnKeyChangedCore();
    private void OnWatcherError(Exception ex);
    public sealed virtual IReadOnlyCollection`1<Account> GetAllAccounts();
    public sealed virtual Account AddOrUpdateAccount(Account account);
    private void AddOrUpdateAccountCore(Account account);
    private void RefreshCurrentMemoryStore(RegistryKey rootKey);
    public sealed virtual Account SetDisplayInfo(AccountKey account, AccountDisplayInfo info);
    private Account SetDisplayInfoCore(AccountKey account, AccountDisplayInfo info);
    public sealed virtual Account SetProperty(AccountKey account, string key, string value);
    public sealed virtual Account SetProperties(AccountKey account, IDictionary`2<string, string> properties);
    private bool SetPropertiesCore(AccountKey account, IDictionary`2<string, string> properties);
    private void RaiseChangingEvent(AccountStoreChangedEventArgs args);
    private void RaiseChangedEvent();
    public sealed virtual void RemoveAccount(AccountKey key);
    private static void ThrowExceptionCouldNotCreateSubKey(string parentKey, string subkey);
    private Account GetAccount(AccountKey accountToFind);
    private static void WriteProperties(RegistryKey accountKey, IEnumerable`1<KeyValuePair`2<string, string>> properties);
    private static IReadOnlyDictionary`2<string, string> ReadProperties(RegistryKey accountKey);
    private static Account ReadAccountInformation(RegistryKey accountKey);
    private static void ThrowMemberNotValid(bool memberValid, string memberName, string registryLocation);
    private static void WriteAccountInformation(RegistryKey accountKey, Account account, Account existingAccount);
    private static void WriteDisplayInfo(RegistryKey accountKey, AccountDisplayInfo displayInfo);
    private static AccountDisplayInfo ReadDisplayInfo(RegistryKey accountKey);
    private static void WriteAccountPropertyValue(RegistryKey propertyKey, string name, string value);
    private static string ReadAccountPropertyValue(RegistryKey propertyKey, string propertyName);
    internal static RegistryKey GetOrCreateRootKey(string subKey);
    private static RegistryKey GetPropertyKey(RegistryKey accountKey, bool createIfNotFound);
    private static string GetAccountSubKeyName(RegistryKey root, AccountKey account);
    private static RegistryKey GetAccountKey(RegistryKey root, AccountKey account, bool createIfNotFound);
    private static IReadOnlyCollection`1<Account> GetKeychainAcccounts(RegistryKey root);
    public sealed virtual Account SetNeedsReauthentication(AccountKey account, bool value);
    private Account SetNeedsReAuthenticationCore(AccountKey account, bool value);
    private static void WriteNeedsReauthentication(RegistryKey accountKey, bool value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
private void <.ctor>b__30_0();
}
public enum Microsoft.VisualStudio.Services.Client.AccountManagement.RegistryChangeNotificationFilter : Enum {
    public UInt32 value__;
    public static RegistryChangeNotificationFilter NameChange;
    public static RegistryChangeNotificationFilter AttributeChange;
    public static RegistryChangeNotificationFilter ValueChange;
    public static RegistryChangeNotificationFilter SecurityChange;
}
public class Microsoft.VisualStudio.Services.Client.AccountManagement.ScopeInfo : object {
    [CompilerGeneratedAttribute]
private string <Domain>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <TenantId>k__BackingField;
    public string Domain { get; private set; }
    public Guid TenantId { get; private set; }
    public ScopeInfo(Guid tenantId);
    public ScopeInfo(string domain);
    [JsonConstructorAttribute]
[DebuggerStepThroughAttribute]
public ScopeInfo(Guid tenantId, string domain);
    [CompilerGeneratedAttribute]
public string get_Domain();
    [CompilerGeneratedAttribute]
private void set_Domain(string value);
    [CompilerGeneratedAttribute]
public Guid get_TenantId();
    [CompilerGeneratedAttribute]
private void set_TenantId(Guid value);
    public void UpdateTenantIdForDomain(Guid tenantId);
}
public class Microsoft.VisualStudio.Services.Client.AccountManagement.SignInHelper : object {
    public static void PrepareSignInState();
}
public class Microsoft.VisualStudio.Services.Client.AccountManagement.TenantInformation : object {
    [CompilerGeneratedAttribute]
private String[] <UniqueIds>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FriendlyName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOwned>k__BackingField;
    public String[] UniqueIds { get; private set; }
    public string TenantId { get; private set; }
    public string FriendlyName { get; private set; }
    public bool IsOwned { get; private set; }
    [JsonConstructorAttribute]
public TenantInformation(HashSet`1<string> uniqueIds, string tenantId, string friendlyName, bool isOwned);
    [CompilerGeneratedAttribute]
public String[] get_UniqueIds();
    [CompilerGeneratedAttribute]
private void set_UniqueIds(String[] value);
    [CompilerGeneratedAttribute]
public string get_TenantId();
    [CompilerGeneratedAttribute]
private void set_TenantId(string value);
    [CompilerGeneratedAttribute]
public string get_FriendlyName();
    [CompilerGeneratedAttribute]
private void set_FriendlyName(string value);
    [CompilerGeneratedAttribute]
public bool get_IsOwned();
    [CompilerGeneratedAttribute]
private void set_IsOwned(bool value);
}
public class Microsoft.VisualStudio.Services.Client.AccountManagement.VSAccountProvider : object {
    private static string EmailAddressKeyName;
    public static Guid AccountProviderIdentifier;
    public static string PersonalizationAccountPropertyName;
    public static string IsMSAPropertyName;
    public static string SigninExtraQueryParameters;
    internal static string AccountHomeTenantPropertyName;
    internal static string AccountIdentityProviderProperty;
    internal static string AccountTenantInformationPropertyName;
    internal static string IdTokenPayloadPropertyName;
    internal static string ScopesPropertyName;
    private static string DisableMsaFedQueryParameter;
    private static string LiveDomainHintQueryParameter;
    private static string AzureRMAPIVersion;
    private static int SilentRetryCount;
    private static IReadOnlyList`1<Guid> EmptyGuidList;
    private static string ExtraQueryParametersRegistryOverride;
    private IAccountCache accountCache;
    private SessionTokenStorage sessionTokenStore;
    private IAccountStore accountStore;
    private static Byte[] defaultProviderImage;
    private static Byte[] msaAccountLogo;
    private TryGetSelfAsync vsoSelf;
    private TryGetSelfAsync azureRMSelf;
    private IVSAccountProviderShim vsAccountProviderShim;
    [CompilerGeneratedAttribute]
private EventHandler`1<AccountsProcessedEventArgs> AccountProcessingEnd;
    private IAadProviderConfiguration aadConfiguration;
    private IAccountCacheConfiguration cacheConfiguration;
    [CompilerGeneratedAttribute]
private GetWrappedItemsFromCache <GetCacheWrappedItems>k__BackingField;
    [CompilerGeneratedAttribute]
private AcquireTokenSilently <AcquireTokenNoPrompt>k__BackingField;
    [CompilerGeneratedAttribute]
private AcquireTokenSilentlyAsync <AcquireTokenNoPromptAsync>k__BackingField;
    [CompilerGeneratedAttribute]
private AcquireTokenWithUI <AcquireTokenWithPrompt>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`1<CultureInfo> <GetQueryParameterCultureInfoFunc>k__BackingField;
    private string extraQueryParametersOverride;
    private Guid msaHomeTenant;
    public IAadProviderConfiguration Configuration { get; }
    public IAccountCacheConfiguration CacheConfiguration { get; }
    [ObsoleteAttribute("Use the Configuration.ResourceEndpoint property on this class instead. Note the new property is not settable", "False")]
public Uri Endpoint { get; public set; }
    internal TryGetSelfAsync GetSelfIdentity { get; }
    internal GetWrappedItemsFromCache GetCacheWrappedItems { get; internal set; }
    internal AcquireTokenSilently AcquireTokenNoPrompt { get; internal set; }
    internal AcquireTokenSilentlyAsync AcquireTokenNoPromptAsync { get; internal set; }
    internal AcquireTokenWithUI AcquireTokenWithPrompt { get; internal set; }
    internal static Func`1<CultureInfo> GetQueryParameterCultureInfoFunc { get; internal set; }
    public string ExtraQueryParametersOverride { get; public set; }
    public Guid MsaHomeTenantId { get; }
    public Guid AccountProviderId { get; }
    public IAccountStore AccountStore { get; internal set; }
    private static VSAccountProvider();
    public VSAccountProvider(string instanceName, IVSAccountProviderShim vsAccountProviderShim);
    internal VSAccountProvider(TryGetSelfAsync self, TryGetSelfAsync azureRMSelf, GetWrappedItemsFromCache cacheLists, AcquireTokenSilently acquireTokenSilently, AcquireTokenWithUI acquireTokenWithUI, SessionTokenStorage sessionTokenStorage);
    [CompilerGeneratedAttribute]
public void add_AccountProcessingEnd(EventHandler`1<AccountsProcessedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_AccountProcessingEnd(EventHandler`1<AccountsProcessedEventArgs> value);
    public IAadProviderConfiguration get_Configuration();
    public IAccountCacheConfiguration get_CacheConfiguration();
    public Uri get_Endpoint();
    public void set_Endpoint(Uri value);
    internal TryGetSelfAsync get_GetSelfIdentity();
    [CompilerGeneratedAttribute]
internal GetWrappedItemsFromCache get_GetCacheWrappedItems();
    [CompilerGeneratedAttribute]
internal void set_GetCacheWrappedItems(GetWrappedItemsFromCache value);
    [CompilerGeneratedAttribute]
internal AcquireTokenSilently get_AcquireTokenNoPrompt();
    [CompilerGeneratedAttribute]
internal void set_AcquireTokenNoPrompt(AcquireTokenSilently value);
    [CompilerGeneratedAttribute]
internal AcquireTokenSilentlyAsync get_AcquireTokenNoPromptAsync();
    [CompilerGeneratedAttribute]
internal void set_AcquireTokenNoPromptAsync(AcquireTokenSilentlyAsync value);
    [CompilerGeneratedAttribute]
internal AcquireTokenWithUI get_AcquireTokenWithPrompt();
    [CompilerGeneratedAttribute]
internal void set_AcquireTokenWithPrompt(AcquireTokenWithUI value);
    [CompilerGeneratedAttribute]
internal static Func`1<CultureInfo> get_GetQueryParameterCultureInfoFunc();
    [CompilerGeneratedAttribute]
internal static void set_GetQueryParameterCultureInfoFunc(Func`1<CultureInfo> value);
    public string get_ExtraQueryParametersOverride();
    public void set_ExtraQueryParametersOverride(string value);
    public Guid get_MsaHomeTenantId();
    public sealed virtual Guid get_AccountProviderId();
    public sealed virtual IAccountStore get_AccountStore();
    internal void set_AccountStore(IAccountStore value);
    public void SetAccountCache(IAccountCache cache);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Services.Client.AccountManagement.VSAccountProvider/<ProcessAuthenticationResult>d__80")]
public Task`1<string> ProcessAuthenticationResult(AuthenticationResult authenticationResult);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Services.Client.AccountManagement.VSAccountProvider/<ProcessAuthenticationResult>d__81")]
internal Task`1<string> ProcessAuthenticationResult(IAccountCacheItem authenticationResult);
    private List`1<IAccountCacheItem> GetWrappedCacheItems(IAccountCache cache);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Services.Client.AccountManagement.VSAccountProvider/<AddPossibleNewAccount>d__83")]
private Task`1<Account> AddPossibleNewAccount(List`1<Exception> errors, IAccountCacheItem newCacheItem, CancellationToken cancellationToken);
    private IList`1<KeyValuePair`2<string, string>> GetUniqueIdTenantIdForMissingOrExpiredTokens(IEnumerable`1<TenantInformation> tenantInformation);
    private static IList`1<KeyValuePair`2<string, string>> GetUniqueIdTenantIdForMissingOrExpiredTokens(IEnumerable`1<TenantInformation> tenantInformation, List`1<IAccountCacheItem> currentItems);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Services.Client.AccountManagement.VSAccountProvider/<GetAccountNeedsReauthenticationAsync>d__86")]
private Task`1<Nullable`1<bool>> GetAccountNeedsReauthenticationAsync(Account account, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Services.Client.AccountManagement.VSAccountProvider/<AcquireTokenSilentAsync>d__87")]
private static Task`1<IAccountCacheItem> AcquireTokenSilentAsync(IAadProviderConfiguration config, IAccountCache accountCache, string tenantId, string userIdentifier, String[] scopes);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Services.Client.AccountManagement.VSAccountProvider/<AcquireTokenSilentAsync>d__88")]
private static Task`1<bool> AcquireTokenSilentAsync(IAadProviderConfiguration config, IAccountCache accountCache, KeyValuePair`2<string, string> userIdTenantIdPair, String[] scopes);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Services.Client.AccountManagement.VSAccountProvider/<AddNewAccountToStoreAsync>d__89")]
internal static Task`1<Account> AddNewAccountToStoreAsync(IAadProviderConfiguration config, List`1<Exception> errors, AcquireTokenSilently acquireTokenSilently, IAccountCache accountCache, IAccountStore store, TryGetSelfAsync getSelfAsync, string userName, string tenantId, string identityProvider, string uniqueId, CancellationToken cancellationToken, string idToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Services.Client.AccountManagement.VSAccountProvider/<GetIdentityAsync>d__90")]
private Task`1<IdentitySelf> GetIdentityAsync(List`1<Exception> errors, string tenantId, string uniqueId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Services.Client.AccountManagement.VSAccountProvider/<GetIdentityAzureRM>d__91")]
private Task`1<IdentitySelf> GetIdentityAzureRM(List`1<Exception> errors, string homeTenantId, string homeUniqueId, CancellationToken cancellationToken);
    internal void RaiseAccountProcessingEnd(bool skipped, List`1<Exception> errors);
    internal static bool IsPossibleNewAccount(AuthenticationResult account, HashSet`1<string> accountUniqueIds);
    internal static bool IsPossibleNewAccount(IAccountCacheItem item, HashSet`1<string> accountUniqueIds);
    internal static HashSet`1<string> GetAccountUniqueIds(List`1<Exception> errors, IEnumerable`1<Account> accountsForProvider);
    internal static Account GetAccountfromUniqueIdTenantId(List`1<Exception> errors, IEnumerable`1<Account> accountsForProvider, string uniqueID, string tenantID);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Services.Client.AccountManagement.VSAccountProvider/<AddOrUpdateAccountToStoreAsync>d__97")]
internal static Task`1<Account> AddOrUpdateAccountToStoreAsync(IAadProviderConfiguration config, List`1<Exception> errors, AcquireTokenSilently acquireTokenSilently, IAccountCache accountCache, TryGetSelfAsync getSelfAsync, string userName, string tenantId, string identityProvider, string uniqueId, IAccountStore store, Account account, IEnumerable`1<ScopeInfo> scopes, CancellationToken cancellationToken, string idToken);
    public IEnumerable`1<ScopeInfo> GetScopesForAccount(AccountKey accountKey);
    internal static IEnumerable`1<ScopeInfo> GetScopesForAccountInternal(Account account);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Services.Client.AccountManagement.VSAccountProvider/<GetTokensForTenants>d__100")]
internal static Task`1<List`1<TenantInformation>> GetTokensForTenants(IAadProviderConfiguration config, IAccountCache accountCache, AcquireTokenSilently acquireTokenSilently, List`1<TenantInfo> tenantInfos, IEnumerable`1<ScopeInfo> scopes, string authenticatorUniqueId, string authenticator, string userName, bool isMSA);
    internal static bool IsMSAAccount(string identityProvider);
    internal static string FormatGuid(Guid guidToFormat);
    public sealed virtual void ClearTokensForAccount(Account account);
    internal static void ClearTokensInternal(DeleteTokenCacheItem deleteAction, Account account, IEnumerable`1<IAccountCacheItem> tokens);
    private Task DeleteTokenCacheEntry(IAccountCacheItem token);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Services.Client.AccountManagement.VSAccountProvider/<AcquireTokenAsync>d__106")]
public Task`1<AuthenticationResult> AcquireTokenAsync(String[] scopes, string tenantId, string userIdentifier, IntPtr parentWindowHandle, AccountKey accountKeyForReAuthentication, bool prompt, CancellationToken cancellationToken);
    public Task`1<AuthenticationResult> AcquireTokenAsync(String[] scopes, IAccountCache cache, string userIdentifier, AccountKey accountForReauthentication, bool prompt, string extraQueryParameters, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Services.Client.AccountManagement.VSAccountProvider/<AcquireTokenInternalAsync>d__108")]
private Task`1<AuthenticationResult> AcquireTokenInternalAsync(String[] scopes, IAccountCache cache, string tenantId, string userIdentifier, AccountKey accountForReauthentication, bool prompt, string extraQueryParameters, CancellationToken cancellationToken);
    internal void TrySetNeedsReauthentication(string userIdentifier, bool flag);
    public Task`1<string> GetSessionTokenFromAccountAsync(Account account, string scope, bool forceRefresh, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Services.Client.AccountManagement.VSAccountProvider/<AuthenticateAgainstTenantWithUI>d__111")]
private Task`1<IAccountCacheItem> AuthenticateAgainstTenantWithUI(IntPtr parentWindowHandle, string userIdentifier, string tenantId, string queryParameters);
    public string GetExtraQueryParameters(string authority);
    internal string GetExtraQueryParameters(Account account);
    internal static string GetExtraQueryParameters(string extraQueryParametersOverride, string registryOverride, Account account);
    private static string TryAppendLocaleParameter(string queryParameters);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Services.Client.AccountManagement.VSAccountProvider/<ReauthenticateWithUIInternal>d__116")]
internal Task`1<IAccountCacheItem> ReauthenticateWithUIInternal(IntPtr parentWindowHandle, Account account, string extraQueryParameters);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Services.Client.AccountManagement.VSAccountProvider/<RefreshAuthenticationStateAsync>d__117")]
public sealed virtual Task`1<Account> RefreshAuthenticationStateAsync(AccountKey account, CancellationToken cancellationToken);
    private Account SetAccountNeedsReauthentication(Account account, Nullable`1<bool> needsReauthentication);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Services.Client.AccountManagement.VSAccountProvider/<CreateAccountWithUIAsync>d__119")]
public sealed virtual Task`1<Account> CreateAccountWithUIAsync(IntPtr parentWindowHandle, CancellationToken cancellationToken);
    internal Account FindAccount(string userIdentifier);
    public sealed virtual void Initialize(IAccountStore store);
    private void AccountStore_KeychainAccountStoreChanging(object sender, AccountStoreChangedEventArgs e);
    public sealed virtual Task`1<Account> AuthenticateAccountWithUIAsync(AccountKey accountKey, IntPtr parentWindowHandle, CancellationToken cancellationToken);
    internal Account FindAccount(AccountKey accountKey, bool throwOnAccountNotFound);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Services.Client.AccountManagement.VSAccountProvider/<AuthenticateAccountWithUIAsyncInternal>d__125")]
internal Task`1<Account> AuthenticateAccountWithUIAsyncInternal(AccountKey accountKey, IntPtr parentWindowHandle, IEnumerable`1<ScopeInfo> scopes, string extraQueryParameters, CancellationToken cancellationToken);
    public Task`1<Account> AuthenticateAndApplyScopeWithUIAsync(AccountKey accountKey, IntPtr parentWindowHandle, List`1<ScopeInfo> scopes, CancellationToken cancellationToken);
    public Account ClearScopes(AccountKey accountKey);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Services.Client.AccountManagement.VSAccountProvider/<RefreshDisplayInfoAsync>d__128")]
public sealed virtual Task`1<Account> RefreshDisplayInfoAsync(AccountKey accountKey, CancellationToken cancellationToken);
    private static List`1<TenantInformation> GetTenantInformation(Account account);
    internal static IEnumerable`1<TenantInformation> GetTenantsInScopeInternal(Account account);
    public IEnumerable`1<TenantInformation> GetTenantsInScope(AccountKey accountKey);
    public TenantInformation GetHomeTenantInfo(AccountKey accountKey);
    private void AddDatatoException(Exception ex, object key, object value);
}
public static class Microsoft.VisualStudio.Services.Client.AccountManagement.VSAccountProviderConstants : object {
    public static Guid AccountProviderIdentifier;
    public static string PersonalizationAccountPropertyName;
    public static string IsMSAPropertyName;
    public static string AdalSigninExtraQueryParameters;
    private static VSAccountProviderConstants();
}
internal class Microsoft.VisualStudio.Services.Client.ClientNativeMethods : object {
    public static int ERROR_SUCCESS;
    public static int ERROR_INSUFFICIENT_BUFFER;
    public static int ERROR_NOT_CAPABLE;
    public static int SPI_GETFOREGROUNDFLASHCOUNT;
    public static int FLASHW_CAPTION;
    public static int FLASHW_TRAY;
    public static int FLASHW_ALL;
    public static int LOGPIXELSX;
    public static int CRED_PACK_PROTECTED_CREDENTIALS;
    public static int CREDUI_MAX_USERNAME_LENGTH;
    public static int CREDUI_MAX_PASSWORD_LENGTH;
    public static int CREDUI_MAX_CAPTION_LENGTH;
    public static int CREDUI_MAX_MESSAGE_LENGTH;
    public static int CREDUIWIN_CHECKBOX;
    public static int CREDUIWIN_AUTHPACKAGE_ONLY;
    public static IntPtr GetDefaultParentWindow();
    public static int FlashWindowEx(FLASHWINFO& fwi);
    public static bool SystemParametersInfo(int nAction, int nParam, Int32& value, int ignore);
    public static IntPtr GetForegroundWindow();
    public static int GetCurrentThreadId();
    public static bool IsWindowVisible(IntPtr hwnd);
    public static bool GetGUIThreadInfo(UInt32 idThread, GUITHREADINFO& lpgui);
    internal static IntPtr GetDC(IntPtr hWnd);
    internal static int ReleaseDC(IntPtr hWnd, IntPtr hDC);
    internal static int GetDeviceCaps(IntPtr hdc, int nIndex);
    internal static int SetQueryNetSessionCount(SessionOp sessionOp);
    public static int CredUIPromptForWindowsCredentials(CREDUI_INFO& pUiInfo, int dwAuthError, UInt32& pulAuthPackage, Byte[] pvInAuthBuffer, UInt32 ulInAuthBufferSize, IntPtr& ppvOutAuthBuffer, UInt32& pulOutAuthBufferSize, Boolean& pfSave, int dwFlags);
    public static bool CredPackAuthenticationBuffer(int dwFlags, string pszUserName, string pszPassword, Byte[] pPackedCredentials, UInt32& pcbPackedCredentials);
    public static bool CredUnPackAuthenticationBuffer(int dwFlags, IntPtr pAuthBuffer, UInt32 cbAuthBuffer, StringBuilder pszUserName, UInt32& pcchMaxUserName, StringBuilder pszDomainName, UInt32& pcchMaxDomainName, StringBuilder pszPassword, UInt32& pcchMaxPassword);
    public static void ZeroMemory(IntPtr address, UInt32 byteCount);
}
internal static class Microsoft.VisualStudio.Services.Client.ClientResources : object {
    private static ResourceManager s_resMgr;
    public static ResourceManager Manager { get; }
    private static ClientResources();
    public static ResourceManager get_Manager();
    private static string Get(string resourceName);
    private static string Get(string resourceName, CultureInfo culture);
    public static int GetInt(string resourceName);
    public static int GetInt(string resourceName, CultureInfo culture);
    public static bool GetBool(string resourceName);
    public static bool GetBool(string resourceName, CultureInfo culture);
    private static string Format(string resourceName, Object[] args);
    private static string Format(string resourceName, CultureInfo culture, Object[] args);
    public static string UnexpectedNavigation();
    public static string UnexpectedNavigation(CultureInfo culture);
    public static string UnexpectedNavigationToUrl();
    public static string UnexpectedNavigationToUrl(CultureInfo culture);
    public static string STAThreadRequired();
    public static string STAThreadRequired(CultureInfo culture);
    public static string BrowserNavigationFailed();
    public static string BrowserNavigationFailed(CultureInfo culture);
    public static string BrowserNavigationToUrlFailed();
    public static string BrowserNavigationToUrlFailed(CultureInfo culture);
    public static string None();
    public static string None(CultureInfo culture);
    public static string BrowserScriptDisabled();
    public static string BrowserScriptDisabled(CultureInfo culture);
    public static string ErrorDeserializeFailed();
    public static string ErrorDeserializeFailed(CultureInfo culture);
    public static string SignInCancelled();
    public static string SignInCancelled(CultureInfo culture);
    public static string TokenDeserializeFailed();
    public static string TokenDeserializeFailed(CultureInfo culture);
    public static string ExplicitTrustRequired();
    public static string ExplicitTrustRequired(CultureInfo culture);
    public static string NavigationBadGateway();
    public static string NavigationBadGateway(CultureInfo culture);
    public static string NavigationBadRequest();
    public static string NavigationBadRequest(CultureInfo culture);
    public static string NavigationForbidden();
    public static string NavigationForbidden(CultureInfo culture);
    public static string NavigationGatewayTimeout();
    public static string NavigationGatewayTimeout(CultureInfo culture);
    public static string NavigationInternalServerError();
    public static string NavigationInternalServerError(CultureInfo culture);
    public static string NavigationNotFound();
    public static string NavigationNotFound(CultureInfo culture);
    public static string NavigationServiceUnavailable();
    public static string NavigationServiceUnavailable(CultureInfo culture);
    public static string NavigationUnauthorized();
    public static string NavigationUnauthorized(CultureInfo culture);
    public static string ServerBadRequest();
    public static string ServerBadRequest(CultureInfo culture);
    public static string ServerForbidden();
    public static string ServerForbidden(CultureInfo culture);
    public static string ServerInternalServerError();
    public static string ServerInternalServerError(CultureInfo culture);
    public static string ServerNotFound();
    public static string ServerNotFound(CultureInfo culture);
    public static string ServerServiceUnavailable();
    public static string ServerServiceUnavailable(CultureInfo culture);
    public static string ServerUnauthorized();
    public static string ServerUnauthorized(CultureInfo culture);
    public static string ServerUnknownError();
    public static string ServerUnknownError(CultureInfo culture);
    public static string UnknownClientError();
    public static string UnknownClientError(CultureInfo culture);
    public static string UnknownError();
    public static string UnknownError(CultureInfo culture);
    public static string AccountManagerProblemExecutingInGlobalMutex(object arg0);
    public static string AccountManagerProblemExecutingInGlobalMutex(object arg0, CultureInfo culture);
    public static string RegistryAccountStoreCannotCreateSubKey(object arg0, object arg1);
    public static string RegistryAccountStoreCannotCreateSubKey(object arg0, object arg1, CultureInfo culture);
    public static string RegistryAccountStoreMemberNotValid(object arg0, object arg1);
    public static string RegistryAccountStoreMemberNotValid(object arg0, object arg1, CultureInfo culture);
    public static string BlueBadgeAccountImage192192();
    public static string BlueBadgeAccountImage192192(CultureInfo culture);
    public static string VsAccountProviderName();
    public static string VsAccountProviderName(CultureInfo culture);
    public static string MicrosoftLogo_128xLG();
    public static string MicrosoftLogo_128xLG(CultureInfo culture);
    public static string VsAccountProviderWorkOrSchool();
    public static string VsAccountProviderWorkOrSchool(CultureInfo culture);
    public static string VsAccountProviderUserNameCannotBeEmpty();
    public static string VsAccountProviderUserNameCannotBeEmpty(CultureInfo culture);
    public static string VsAccountProviderUnsupportedAccount();
    public static string VsAccountProviderUnsupportedAccount(CultureInfo culture);
    public static string VsAccountProviderSetCacheInvalidOperation();
    public static string VsAccountProviderSetCacheInvalidOperation(CultureInfo culture);
    public static string VsAccountProviderAccountNotFoundFromKey();
    public static string VsAccountProviderAccountNotFoundFromKey(CultureInfo culture);
    public static string UICredProvider_MessageText();
    public static string UICredProvider_MessageText(CultureInfo culture);
    public static string UICredProvider_TitleText(object arg0);
    public static string UICredProvider_TitleText(object arg0, CultureInfo culture);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Microsoft.VisualStudio.Services.Client.Controls.AccountPicker.AccountPickerResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string AddNewAccount { get; }
    internal static string CancelButton { get; }
    internal static string DialogHeader { get; }
    internal static string DialogTitle { get; }
    internal static string OkButton { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_AddNewAccount();
    internal static string get_CancelButton();
    internal static string get_DialogHeader();
    internal static string get_DialogTitle();
    internal static string get_OkButton();
}
public class Microsoft.VisualStudio.Services.Client.Controls.AccountPicker.AccountPickerWindow : Window {
    [CompilerGeneratedAttribute]
private List`1<IAccountPickerItem> <Accounts>k__BackingField;
    internal TextBlock Header;
    internal ComboBox AccountComboBox;
    internal Button OkButton;
    internal Button CancelButton;
    private bool _contentLoaded;
    public List`1<IAccountPickerItem> Accounts { get; public set; }
    public CachedAccount SelectedAccount { get; }
    internal AccountPickerWindow(IEnumerable`1<IAccountCacheItem> cachedTokens);
    [CompilerGeneratedAttribute]
public List`1<IAccountPickerItem> get_Accounts();
    [CompilerGeneratedAttribute]
public void set_Accounts(List`1<IAccountPickerItem> value);
    public CachedAccount get_SelectedAccount();
    private void ApplyResources();
    private void OkButton_Click(object sender, RoutedEventArgs e);
    private void CancelButton_Click(object sender, RoutedEventArgs e);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("PresentationBuildTasks", "4.0.0.0")]
public sealed virtual void InitializeComponent();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("PresentationBuildTasks", "4.0.0.0")]
[EditorBrowsableAttribute("1")]
private sealed virtual override void System.Windows.Markup.IComponentConnector.Connect(int connectionId, object target);
}
public class Microsoft.VisualStudio.Services.Client.Controls.AccountPicker.CachedAccount : object {
    [CompilerGeneratedAttribute]
private IAccountCacheItem <CachedToken>k__BackingField;
    public string DisplayableId { get; }
    public string AccountName { get; }
    public string DisplayName { get; }
    internal IAccountCacheItem CachedToken { get; }
    internal CachedAccount(IAccountCacheItem token);
    public string get_DisplayableId();
    public string get_AccountName();
    public sealed virtual string get_DisplayName();
    [CompilerGeneratedAttribute]
internal IAccountCacheItem get_CachedToken();
}
public interface Microsoft.VisualStudio.Services.Client.Controls.AccountPicker.IAccountPickerItem {
    public string DisplayName { get; }
    public abstract virtual string get_DisplayName();
}
internal static class Microsoft.VisualStudio.Services.Client.Controls.BrowserEmulationVersion : object {
    private static string IERootKey;
    private static string BrowserEmulationKey;
    public static void TrySetBrowserVersion(BrowserVersion version);
    private static string GetAppName();
    private static int GetIEVersion();
    private static RegistryKey OpenOrCreateRegistryKey(string registryPath);
    private static BrowserVersion GetEmulationVersionByBrowserVersion(int browserVersion);
}
[ExceptionMappingAttribute("0.0", "3.0", "BrowserFlowException", "Microsoft.VisualStudio.Services.Client.Controls.BrowserFlowException, Microsoft.VisualStudio.Services.Client, Version=14.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class Microsoft.VisualStudio.Services.Client.Controls.BrowserFlowException : VssException {
    [CompilerGeneratedAttribute]
private BrowserFlowLayer <Layer>k__BackingField;
    [CompilerGeneratedAttribute]
private ErrorData <Error>k__BackingField;
    internal static int BrowserScriptDisabledHelpLinkId;
    internal static int NavigationServiceUnavailableHelpLinkId;
    internal static int NavigationUnauthorizedHelpLinkId;
    internal static int NavigationForbiddenHelpLinkId;
    internal static int NavigationNotFoundHelpLinkId;
    internal static int NavigationBadRequestHelpLinkId;
    internal static int NavigationBadGatewayHelpLinkId;
    internal static int NavigationGatewayTimeoutHelpLinkId;
    internal static int NavigationInternalServerErrorHelpLinkId;
    internal static int ServerServiceUnavailableHelpLinkId;
    internal static int ServerUnauthorizedHelpLinkId;
    internal static int ServerForbiddenHelpLinkId;
    internal static int ServerNotFoundHelpLinkId;
    internal static int ServerBadRequestHelpLinkId;
    internal static int ServerInternalServerErrorHelpLinkId;
    internal static int ServerUnknownErrorHelpLinkId;
    internal static int UnknownClientErrorHelpLinkId;
    internal static int UnknownErrorHelpLinkId;
    public BrowserFlowLayer Layer { get; private set; }
    public ErrorData Error { get; private set; }
    public BrowserFlowException(BrowserFlowLayer layer, ErrorData error, string message);
    public BrowserFlowException(BrowserFlowLayer layer, ErrorData error, string message, Exception innerException);
    [CompilerGeneratedAttribute]
public BrowserFlowLayer get_Layer();
    [CompilerGeneratedAttribute]
private void set_Layer(BrowserFlowLayer value);
    [CompilerGeneratedAttribute]
public ErrorData get_Error();
    [CompilerGeneratedAttribute]
private void set_Error(ErrorData value);
    internal static string FormatHelpLink(int helpLinkId);
    internal static int GetNavigationHelpLinkId(HttpStatusCode code);
    internal static string GetNavigationExceptionMessage(HttpStatusCode code);
    internal static int GetServerHelpLinkId(HttpStatusCode code);
    internal static string GetServerExceptionMessage(HttpStatusCode code);
}
public enum Microsoft.VisualStudio.Services.Client.Controls.BrowserFlowLayer : Enum {
    public int value__;
    public static BrowserFlowLayer Unspecified;
    public static BrowserFlowLayer Navigation;
    public static BrowserFlowLayer Server;
    public static BrowserFlowLayer Client;
}
public enum Microsoft.VisualStudio.Services.Client.Controls.BrowserVersion : Enum {
    public int value__;
    public static BrowserVersion Default;
    public static BrowserVersion IE7;
    public static BrowserVersion IE8;
    public static BrowserVersion IE8Force;
    public static BrowserVersion IE9;
    public static BrowserVersion IE9Force;
    public static BrowserVersion IE10;
    public static BrowserVersion IE10Force;
    public static BrowserVersion IE11;
    public static BrowserVersion IE11Edge;
}
public class Microsoft.VisualStudio.Services.Client.Controls.BrowserWindow : Window {
    public static Size CompactSize;
    public static Size FullSize;
    public static Size MaxResize;
    public static Size MaxResizeCheckSize;
    [CompilerGeneratedAttribute]
private ComBrowserHandler <BrowserHandler>k__BackingField;
    private static Key[] BlockedKeys;
    private static Key[] BlockedAltKeys;
    private static Key[] BlockedControlKeys;
    internal WebBrowser WebBrowser;
    private bool _contentLoaded;
    internal ComBrowserHandler BrowserHandler { get; private set; }
    public BrowserWindow(object external, Size desiredSize);
    private static BrowserWindow();
    [CompilerGeneratedAttribute]
internal ComBrowserHandler get_BrowserHandler();
    [CompilerGeneratedAttribute]
private void set_BrowserHandler(ComBrowserHandler value);
    protected virtual void OnClosed(EventArgs e);
    protected virtual void OnMouseLeftButtonDown(MouseButtonEventArgs e);
    protected virtual void OnPreviewKeyDown(KeyEventArgs e);
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("PresentationBuildTasks", "4.0.0.0")]
public sealed virtual void InitializeComponent();
    [DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("PresentationBuildTasks", "4.0.0.0")]
[EditorBrowsableAttribute("1")]
private sealed virtual override void System.Windows.Markup.IComponentConnector.Connect(int connectionId, object target);
}
internal class Microsoft.VisualStudio.Services.Client.Controls.ClientTokenData : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <TokenProperties>k__BackingField;
    public IDictionary`2<string, string> TokenProperties { get; public set; }
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_TokenProperties();
    [CompilerGeneratedAttribute]
public void set_TokenProperties(IDictionary`2<string, string> value);
}
internal class Microsoft.VisualStudio.Services.Client.Controls.ComBrowserHandler : object {
    private static UInt32 INET_E_DEFAULT_ACTION;
    private static UInt32 INET_E_USE_DEFAULT_PROTOCOLHANDLER;
    private static UInt32 E_NOINTERFACE;
    private static UInt32 CLASS_E_NOAGGREGATION;
    private static UInt32 INET_E_REDIRECT_FAILED;
    private static UInt32 E_FAIL;
    private ComEventSink`2<DWebBrowserEvents2, ComBrowserEvents> browserEvents;
    private IWebBrowser2 comBrowser;
    private bool confirmedExplicitTrust;
    private ComDocumentHostHandler documentHostHandler;
    private Lazy`1<IInternetSecurityManager> securityManager;
    private Lazy`1<HashSet`1<string>> trustedUrlPatterns;
    private AsyncPluggableProtocolSession urnProtocolSession;
    [CompilerGeneratedAttribute]
private HtmlContextMenuEventHandler ContextMenu;
    [CompilerGeneratedAttribute]
private NavigationFailedEventHandler Failed;
    [CompilerGeneratedAttribute]
private NavigatedEventHandler Initialized;
    [CompilerGeneratedAttribute]
private NavigatedEventHandler LoadCompleted;
    [CompilerGeneratedAttribute]
private NavigatedEventHandler Navigated;
    [CompilerGeneratedAttribute]
private NavigatingCancelEventHandler Navigating;
    [CompilerGeneratedAttribute]
private CustomNavigationEventHandler CustomNavigation;
    [CompilerGeneratedAttribute]
private bool <BlockDragDrop>k__BackingField;
    [CompilerGeneratedAttribute]
private WebBrowser <Browser>k__BackingField;
    [CompilerGeneratedAttribute]
private object <External>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireScript>k__BackingField;
    private static int PUAF_NOUI;
    private static int PUAF_NOUIIFLOCKED;
    private static int URLACTION_SCRIPT_RUN;
    private static int URLPOLICY_ALLOW;
    private static int URLPOLICY_DISALLOW;
    private static int OLECMDID_OPTICAL_ZOOM;
    private static int OLECMDEXECOPT_DONTPROMPTUSER;
    private static int S_OK;
    private static int S_FALSE;
    private static int URLZONE_TRUSTED;
    private static int URLZONE_ESC_FLAG;
    private static int SZM_CREATE;
    private static int E_INVALIDARG;
    private static int E_NOTIMPLEMENTED;
    private static string EmptyContent;
    private static Guid CLSID_InternetSecurityManager;
    private static Guid SID_WebBrowser;
    public bool BlockDragDrop { get; private set; }
    public WebBrowser Browser { get; private set; }
    public object External { get; private set; }
    public bool RequireScript { get; private set; }
    public string BodyInnerHtml { get; }
    public string DocumentInnerHtml { get; }
    public bool HasDocument { get; }
    public string Url { get; }
    private IInternetSecurityManager SecurityManager { get; }
    private HashSet`1<string> TrustedUrlPatterns { get; }
    public ComBrowserHandler(WebBrowser browser, bool blockDragDrop, bool requireScript, object external);
    private static ComBrowserHandler();
    private static void CoInternetGetSession(UInt32 dwSessionMode, IInternetSession& ppIInternetSession, UInt32 dwReserved);
    private static IInternetSecurityManager CreateInternetSecurityManager();
    [CompilerGeneratedAttribute]
public void add_ContextMenu(HtmlContextMenuEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ContextMenu(HtmlContextMenuEventHandler value);
    [CompilerGeneratedAttribute]
public void add_Failed(NavigationFailedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Failed(NavigationFailedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_Initialized(NavigatedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Initialized(NavigatedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_LoadCompleted(NavigatedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_LoadCompleted(NavigatedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_Navigated(NavigatedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Navigated(NavigatedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_Navigating(NavigatingCancelEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Navigating(NavigatingCancelEventHandler value);
    [CompilerGeneratedAttribute]
public void add_CustomNavigation(CustomNavigationEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_CustomNavigation(CustomNavigationEventHandler value);
    [CompilerGeneratedAttribute]
public bool get_BlockDragDrop();
    [CompilerGeneratedAttribute]
private void set_BlockDragDrop(bool value);
    [CompilerGeneratedAttribute]
public WebBrowser get_Browser();
    [CompilerGeneratedAttribute]
private void set_Browser(WebBrowser value);
    [CompilerGeneratedAttribute]
public object get_External();
    [CompilerGeneratedAttribute]
private void set_External(object value);
    [CompilerGeneratedAttribute]
public bool get_RequireScript();
    [CompilerGeneratedAttribute]
private void set_RequireScript(bool value);
    public string get_BodyInnerHtml();
    public string get_DocumentInnerHtml();
    public bool get_HasDocument();
    public string get_Url();
    private IInternetSecurityManager get_SecurityManager();
    private HashSet`1<string> get_TrustedUrlPatterns();
    public sealed virtual void Dispose();
    public object Evaluate(string script);
    public bool EnsureExplicitTrust(Uri uri, string urlPattern, bool otherwiseFail);
    private bool ConfirmExplicitTrust(Uri uri, string urlPattern);
    private bool HasFullTrust(string urlPattern, UInt32 urlAction);
    public string GetElementInnerHtmlById(string id);
    public void Initialize();
    public void InjectStyle(string style);
    public void InsertLocalStyleSheet(IEnumerable`1<PageHandlerStyle> styles);
    public bool IsActiveElementTextInput();
    protected virtual void Dispose(bool disposing);
    protected virtual void OnInitialized(object sender, NavigationEventArgs e);
    protected virtual void OnLoadCompleted(object sender, NavigationEventArgs e);
    protected virtual void OnNavigated(object sender, NavigationEventArgs e);
    protected virtual void OnNavigating(object sender, NavigatingCancelEventArgs e);
    protected virtual void OnCustomNavigation(string uriValue);
    protected virtual void OnNewWindow(Object& ppDisp, Boolean& Cancel, UInt32 dwFlags, string bstrUrlContext, string bstrUrl);
    private IWebBrowser2 GetComWebBrowser();
    private object GetHtmlElementFromPoint(Point point);
    private void documentHostHandler_ContextMenu(ComDocumentHostHandler sender, ContextMenuEventArgs e);
}
internal class Microsoft.VisualStudio.Services.Client.Controls.CustomNavigationEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Uri <Uri>k__BackingField;
    public Uri Uri { get; private set; }
    public CustomNavigationEventArgs(Uri uri);
    [CompilerGeneratedAttribute]
public Uri get_Uri();
    [CompilerGeneratedAttribute]
private void set_Uri(Uri value);
}
internal class Microsoft.VisualStudio.Services.Client.Controls.CustomNavigationEventHandler : MulticastDelegate {
    public CustomNavigationEventHandler(object object, IntPtr method);
    public virtual void Invoke(ComBrowserHandler sender, CustomNavigationEventArgs e);
    public virtual IAsyncResult BeginInvoke(ComBrowserHandler sender, CustomNavigationEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
internal class Microsoft.VisualStudio.Services.Client.Controls.DialogHost : object {
    public sealed virtual Task`1<Nullable`1<bool>> InvokeDialogAsync(InvokeDialogFunc showDialog, object state);
}
internal static class Microsoft.VisualStudio.Services.Client.Controls.DpiHelper : object {
    [CompilerGeneratedAttribute]
private static double <DeviceDpiX>k__BackingField;
    internal static double LogicalDpi;
    internal static double DeviceDpiX { get; internal set; }
    private static DpiHelper();
    [CompilerGeneratedAttribute]
internal static double get_DeviceDpiX();
    [CompilerGeneratedAttribute]
internal static void set_DeviceDpiX(double value);
}
internal class Microsoft.VisualStudio.Services.Client.Controls.HtmlContextMenuEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Point <Point>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Element>k__BackingField;
    public Point Point { get; private set; }
    public object Element { get; private set; }
    public HtmlContextMenuEventArgs(Point point, object element);
    [CompilerGeneratedAttribute]
public Point get_Point();
    [CompilerGeneratedAttribute]
private void set_Point(Point value);
    [CompilerGeneratedAttribute]
public object get_Element();
    [CompilerGeneratedAttribute]
private void set_Element(object value);
}
internal class Microsoft.VisualStudio.Services.Client.Controls.HtmlContextMenuEventHandler : MulticastDelegate {
    public HtmlContextMenuEventHandler(object object, IntPtr method);
    public virtual void Invoke(ComBrowserHandler sender, HtmlContextMenuEventArgs e);
    public virtual IAsyncResult BeginInvoke(ComBrowserHandler sender, HtmlContextMenuEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public interface Microsoft.VisualStudio.Services.Client.Controls.IDialogHost {
    public abstract virtual Task`1<Nullable`1<bool>> InvokeDialogAsync(InvokeDialogFunc showDialog, object state);
}
internal class Microsoft.VisualStudio.Services.Client.Controls.InteractiveAuthenticationEvent : object {
    public bool IsReauthenticating;
    public VssConnectMode ConnectMode;
}
[EditorBrowsableAttribute("1")]
public class Microsoft.VisualStudio.Services.Client.Controls.InvokeDialogFunc : MulticastDelegate {
    public InvokeDialogFunc(object object, IntPtr method);
    public virtual Nullable`1<bool> Invoke(IntPtr owner, object state);
    public virtual IAsyncResult BeginInvoke(IntPtr owner, object state, AsyncCallback callback, object object);
    public virtual Nullable`1<bool> EndInvoke(IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
[ComVisibleAttribute("True")]
public class Microsoft.VisualStudio.Services.Client.Controls.JavascriptNotifyInterop : object {
    [CompilerGeneratedAttribute]
private EventHandler`1<ErrorData> ProcessingFailed;
    [CompilerGeneratedAttribute]
private EventHandler`1<TokenData> TokenDataReceived;
    [CompilerGeneratedAttribute]
private EventHandler WindowResizing;
    [CompilerGeneratedAttribute]
internal void add_ProcessingFailed(EventHandler`1<ErrorData> value);
    [CompilerGeneratedAttribute]
internal void remove_ProcessingFailed(EventHandler`1<ErrorData> value);
    [CompilerGeneratedAttribute]
internal void add_TokenDataReceived(EventHandler`1<TokenData> value);
    [CompilerGeneratedAttribute]
internal void remove_TokenDataReceived(EventHandler`1<TokenData> value);
    [CompilerGeneratedAttribute]
internal void add_WindowResizing(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_WindowResizing(EventHandler value);
    public bool notifyError(string value);
    public bool notifyScriptError(string url, string message, string details, string statusCodeValue, string content);
    public bool resizeWindow(string value);
    public bool notifyToken(string value);
    private static ErrorData DeserializeError(string value);
    private static T DeserializeToken(string value);
}
internal class Microsoft.VisualStudio.Services.Client.Controls.NavigationFailedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Uri <Uri>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public Uri Uri { get; private set; }
    public Exception Exception { get; private set; }
    public NavigationFailedEventArgs(Uri uri, Exception exception);
    [CompilerGeneratedAttribute]
public Uri get_Uri();
    [CompilerGeneratedAttribute]
private void set_Uri(Uri value);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
private void set_Exception(Exception value);
}
internal class Microsoft.VisualStudio.Services.Client.Controls.NavigationFailedEventHandler : MulticastDelegate {
    public NavigationFailedEventHandler(object object, IntPtr method);
    public virtual void Invoke(ComBrowserHandler sender, NavigationFailedEventArgs e);
    public virtual IAsyncResult BeginInvoke(ComBrowserHandler sender, NavigationFailedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[DataContractAttribute]
internal class Microsoft.VisualStudio.Services.Client.Controls.TokenData : object {
    [CompilerGeneratedAttribute]
private String[] <SecurityToken>k__BackingField;
    [DataMemberAttribute]
public String[] SecurityToken { get; public set; }
    [CompilerGeneratedAttribute]
public String[] get_SecurityToken();
    [CompilerGeneratedAttribute]
public void set_SecurityToken(String[] value);
}
[EditorBrowsableAttribute("1")]
public class Microsoft.VisualStudio.Services.Client.Controls.VssCredentialPromptContext : object {
    [CompilerGeneratedAttribute]
private IDialogHost <DialogHost>k__BackingField;
    public IDialogHost DialogHost { get; private set; }
    public VssCredentialPromptContext(IDialogHost dialogHost);
    [CompilerGeneratedAttribute]
public IDialogHost get_DialogHost();
    [CompilerGeneratedAttribute]
private void set_DialogHost(IDialogHost value);
}
[EditorBrowsableAttribute("1")]
public class Microsoft.VisualStudio.Services.Client.Controls.VssCredentialPrompts : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private IVssCredentialPrompt <FederatedPrompt>k__BackingField;
    [CompilerGeneratedAttribute]
private IVssCredentialPrompt <WindowsPrompt>k__BackingField;
    public IDictionary`2<string, string> Parameters { get; public set; }
    public IVssCredentialPrompt FederatedPrompt { get; private set; }
    public IVssCredentialPrompt WindowsPrompt { get; private set; }
    public VssCredentialPrompts(VssCredentialPromptContext context);
    public VssCredentialPrompts(IVssCredentialPrompt federatedCredentialPrompt, IVssCredentialPrompt windowsCredentialPrompt);
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, string> get_Parameters();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Parameters(IDictionary`2<string, string> value);
    private sealed virtual override Task`1<IssuedToken> Microsoft.VisualStudio.Services.Common.IVssCredentialPrompt.GetTokenAsync(IssuedTokenProvider provider, IssuedToken failedToken);
    [CompilerGeneratedAttribute]
public sealed virtual IVssCredentialPrompt get_FederatedPrompt();
    [CompilerGeneratedAttribute]
private void set_FederatedPrompt(IVssCredentialPrompt value);
    [CompilerGeneratedAttribute]
public IVssCredentialPrompt get_WindowsPrompt();
    [CompilerGeneratedAttribute]
private void set_WindowsPrompt(IVssCredentialPrompt value);
    public static VssCredentialPrompts CreateDefault(WindowsCredential windowsCredential, FederatedCredential federatedCredential);
    public static VssCredentialPrompts CreatePromptsWithHost(WindowsCredential windowsCredential, FederatedCredential federatedCredential, IDialogHost host);
}
[EditorBrowsableAttribute("1")]
public class Microsoft.VisualStudio.Services.Client.Controls.VssFederatedCredentialPrompt : object {
    [CompilerGeneratedAttribute]
private VssCredentialPromptContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CompactSize>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <TokenProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private static Action`1<Window> DialogShowing;
    [CompilerGeneratedAttribute]
private static Action`1<InteractiveAuthenticationEvent> InteractiveAuthentication;
    public VssCredentialPromptContext Context { get; public set; }
    public bool CompactSize { get; public set; }
    public VssConnectMode ConnectMode { get; public set; }
    public IDictionary`2<string, string> TokenProperties { get; public set; }
    public IDictionary`2<string, string> Parameters { get; public set; }
    private static VssFederatedCredentialPrompt();
    public VssFederatedCredentialPrompt(IDialogHost host);
    public VssFederatedCredentialPrompt(VssCredentialPromptContext context);
    [CompilerGeneratedAttribute]
public VssCredentialPromptContext get_Context();
    [CompilerGeneratedAttribute]
public void set_Context(VssCredentialPromptContext value);
    [CompilerGeneratedAttribute]
public bool get_CompactSize();
    [CompilerGeneratedAttribute]
public void set_CompactSize(bool value);
    public VssConnectMode get_ConnectMode();
    public void set_ConnectMode(VssConnectMode value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_TokenProperties();
    [CompilerGeneratedAttribute]
public void set_TokenProperties(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, string> get_Parameters();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Parameters(IDictionary`2<string, string> value);
    private sealed virtual override Task`1<IssuedToken> Microsoft.VisualStudio.Services.Common.IVssCredentialPrompt.GetTokenAsync(IssuedTokenProvider provider, IssuedToken failedToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Services.Client.Controls.VssFederatedCredentialPrompt/<GetCookieAsync>d__24")]
public Task`1<CookieCollection> GetCookieAsync(Uri signInUrl);
    private static Nullable`1<bool> InvokeDialog(IntPtr owner, object state);
    private static void BlinkHandler(object sender, EventArgs e);
    private static IEnumerable`1<string> GetSignInCookieDomains(string urlFragment);
    private static Uri RemoveFragmentFromUri(Uri existingUri);
    private static void OnShowingDialog(Window window);
    [CompilerGeneratedAttribute]
public static void add_DialogShowing(Action`1<Window> value);
    [CompilerGeneratedAttribute]
public static void remove_DialogShowing(Action`1<Window> value);
    [CompilerGeneratedAttribute]
internal static void add_InteractiveAuthentication(Action`1<InteractiveAuthenticationEvent> value);
    [CompilerGeneratedAttribute]
internal static void remove_InteractiveAuthentication(Action`1<InteractiveAuthenticationEvent> value);
    [CompilerGeneratedAttribute]
private IssuedToken <Microsoft.VisualStudio.Services.Common.IVssCredentialPrompt.GetTokenAsync>b__23_0(Task`1<CookieCollection> t);
}
internal class Microsoft.VisualStudio.Services.Client.Controls.VssFederatedSignInWindow : object {
    [CompilerGeneratedAttribute]
private Uri <SignInUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AdditionalHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSilentSignInFlow>k__BackingField;
    [CompilerGeneratedAttribute]
private NavigationFailedEventHandler NavigationFailed;
    [CompilerGeneratedAttribute]
private EventHandler ProcessingFailed;
    [CompilerGeneratedAttribute]
private EventHandler TokenReceived;
    [CompilerGeneratedAttribute]
private EventHandler WindowResizing;
    [CompilerGeneratedAttribute]
private ClientTokenData <ClientTokenData>k__BackingField;
    [CompilerGeneratedAttribute]
private ErrorData <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private TokenData <TokenData>k__BackingField;
    private PageHandler[] pageHandlers;
    private static Regex StatusCodePattern;
    private static string StatusCodeGroupName;
    public Uri SignInUrl { get; }
    public string AdditionalHeaders { get; public set; }
    public bool IsSilentSignInFlow { get; public set; }
    public ClientTokenData ClientTokenData { get; private set; }
    public ErrorData Error { get; private set; }
    public TokenData TokenData { get; private set; }
    public VssFederatedSignInWindow(BrowserWindow browserWindow, Uri signInUrl, JavascriptNotifyInterop javascriptInterop);
    private static VssFederatedSignInWindow();
    [CompilerGeneratedAttribute]
public Uri get_SignInUrl();
    [CompilerGeneratedAttribute]
public string get_AdditionalHeaders();
    [CompilerGeneratedAttribute]
public void set_AdditionalHeaders(string value);
    [CompilerGeneratedAttribute]
public bool get_IsSilentSignInFlow();
    [CompilerGeneratedAttribute]
public void set_IsSilentSignInFlow(bool value);
    private void OnInitialized(object sender, NavigationEventArgs e);
    private void OnNavigationFailed(ComBrowserHandler sender, NavigationFailedEventArgs e);
    private void OnLoadCompleted(object sender, NavigationEventArgs e);
    private void OnFirstNavigated(object sender, NavigationEventArgs e);
    private void OnNavigated(object sender, NavigationEventArgs e);
    private void ApplyNavigationPageHandler(Uri uri, ComBrowserHandler browserHandler, PageHandler pageHandler);
    private void ApplyPageHandler(Uri uri, ComBrowserHandler browserHandler, PageHandler pageHandler);
    private void MatchPageHandlers(object sender, NavigationEventArgs e, PageHandlerApplicator applicator);
    private static bool EnsureExplicitTrustOfSiteDependencies(Uri uri, ComBrowserHandler browserHandler, PageHandler pageHandler);
    [CompilerGeneratedAttribute]
public void add_NavigationFailed(NavigationFailedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_NavigationFailed(NavigationFailedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_ProcessingFailed(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ProcessingFailed(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_TokenReceived(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_TokenReceived(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_WindowResizing(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_WindowResizing(EventHandler value);
    [CompilerGeneratedAttribute]
public ClientTokenData get_ClientTokenData();
    [CompilerGeneratedAttribute]
private void set_ClientTokenData(ClientTokenData value);
    [CompilerGeneratedAttribute]
public ErrorData get_Error();
    [CompilerGeneratedAttribute]
private void set_Error(ErrorData value);
    [CompilerGeneratedAttribute]
public TokenData get_TokenData();
    [CompilerGeneratedAttribute]
private void set_TokenData(TokenData value);
    private void OnProcessingFailed(object sender, ErrorData error);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Services.Client.Controls.VssFederatedSignInWindow/<OnTokenDataReceived>d__47")]
private void OnTokenDataReceived(object sender, TokenData data);
    private void OnWindowResizing(object sender, EventArgs e);
    private void OnClosing(object sender, EventArgs e);
}
[EditorBrowsableAttribute("1")]
public class Microsoft.VisualStudio.Services.Client.Controls.WindowsCredentialPrompt : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Parameters>k__BackingField;
    private IntPtr m_parentWindow;
    private CachedCredentialsType m_credentialsType;
    public IDictionary`2<string, string> Parameters { get; public set; }
    public WindowsCredentialPrompt(CachedCredentialsType credentialsType);
    public WindowsCredentialPrompt(CachedCredentialsType credentialsType, IntPtr parentWindowHandle);
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, string> get_Parameters();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Parameters(IDictionary`2<string, string> value);
    private sealed virtual override Task`1<IssuedToken> Microsoft.VisualStudio.Services.Common.IVssCredentialPrompt.GetTokenAsync(IssuedTokenProvider provider, IssuedToken failedToken);
    public ICredentials GetToken(Uri uri, ICredentials failedCredentials);
    private Byte[] GetPrimerCredentialsBlob(string userName);
    private string GetFullyQualifiedDnsName(string hostName);
    private IssuedToken ToToken(ICredentials credential);
    private ICredentials ToCredential(IssuedToken token);
}
internal static class Microsoft.VisualStudio.Services.Client.CookieUtility : object {
    public static string AcsMetadataRetrievalExceptionText;
    public static string FedAuthCookieName;
    public static string WindowsLiveSignOutUrl;
    public static Uri WindowsLiveCookieDomain;
    public static UInt32 INTERNET_COOKIE_HTTPONLY;
    private static CookieUtility();
    public static CookieCollection GetFederatedCookies(Uri cookieDomainAndPath);
    public static CookieCollection GetFederatedCookies(String[] token);
    public static CookieCollection GetFederatedCookies(IHttpResponse webResponse);
    public static CookieCollection GetAllCookies(Uri cookieDomainAndPath);
    public static void DeleteFederatedCookies(Uri cookieDomainAndPath);
    public static void DeleteWindowsLiveCookies();
    public static void DeleteAllCookies(Uri cookieDomainAndPath);
    private static bool InternetGetCookieEx(string url, string cookieName, StringBuilder cookieData, Int32& size, UInt32 flags, IntPtr reserved);
    private static bool InternetSetCookieEx(string url, string cookieName, string cookieData, UInt32 flags, IntPtr reserved);
    public static bool DeleteCookieEx(Uri cookiePath, string cookieName);
    public static bool SetCookiesEx(Uri cookiePath, CookieCollection cookies);
    public static List`1<Cookie> GetCookieEx(Uri cookiePath, string cookieName);
}
[EditorBrowsableAttribute("1")]
public static class Microsoft.VisualStudio.Services.Client.CredentialStorageConstants : object {
    public static string DefaultNamespace;
    public static string DefaultTokenKind;
    public static string DefaultTokenUser;
    public static string UserIdProperty;
    public static string UserNameProperty;
    public static string AuthorityProperty;
    public static string ClientProperty;
    public static string RefreshTokenProperty;
    public static string TenantProperty;
}
[EditorBrowsableAttribute("1")]
public static class Microsoft.VisualStudio.Services.Client.CredentialStorageUtility : object {
    public static VssClientCredentials GetCredentials(VssToken token);
    public static IssuedToken GetTokenFromString(VssCredentialsType credentialsType, string tokenValue);
    public static string GetTokenAsString(IssuedToken token);
    public static Dictionary`2<string, string> GetDictionaryFromString(string tokenValue);
    public static string GetStringFromDictionary(Dictionary`2<string, string> keyValueCollection);
    public static bool IsUserDataMatched(VssToken token, Guid userId);
    private static VssCredentialsType ToCredentialsType(string type);
}
[CompilerGeneratedAttribute]
internal static class Microsoft.VisualStudio.Services.Client.GeneratedVersionInfo : object {
    public static string MajorVersion;
    public static string MinorVersion;
    public static string BuildVersion;
    public static string PatchVersion;
    public static string ProductVersion;
    public static string AssemblyMajorVersion;
    public static string AssemblyMinorVersion;
    public static string AssemblyBuildVersion;
    public static string AssemblyPatchVersion;
    public static string AssemblyVersion;
    public static string FileMajorVersion;
    public static string FileMinorVersion;
    public static string FileBuildVersion;
    public static string FilePatchVersion;
    public static string FileVersion;
    public static string VisualStudioMajorVersion;
    public static string VisualStudioVersion;
    public static string TfsMajorVersion;
    public static string TfsMinorVersion;
    public static string TfsProductVersion;
    public static int TfsUpdateNumber;
    public static string TfsInstallDirectory;
}
internal class Microsoft.VisualStudio.Services.Client.HttpClientFactoryWithUserAgent : object {
    private static string UserAgentPrefix;
    private static Lazy`1<HttpClient> httpClient;
    private static HttpClientFactoryWithUserAgent();
    private static HttpClient CreateClientWithCustomUserAgent();
    public sealed virtual HttpClient GetHttpClient();
}
public static class Microsoft.VisualStudio.Services.Client.Internal.AdminConstants : object {
    public static string ServerProcessID;
    public static string ApplicationName;
}
internal static class Microsoft.VisualStudio.Services.Client.Keychain.Logging.AccountManagementLoggingAuthType : object {
    internal static string Unknown;
    internal static string Create;
    internal static string Reauth;
}
public static class Microsoft.VisualStudio.Services.Client.Keychain.Logging.AccountManagementLoggingEventNames : object {
    public static string AcquireTokenLogEventName;
    public static string VssFederatedSignInWindowOnTokenDataReceived;
    public static string SessionTokenRequiresRefreshLoggingEventName;
    public static string RetreiveAndStoreSessionTokensFromVSO;
    public static string Prompt;
}
internal static class Microsoft.VisualStudio.Services.Client.Keychain.Logging.AccountManagementLoggingEventProperties : object {
    internal static string AuthType;
    internal static string Source;
}
internal static class Microsoft.VisualStudio.Services.Client.Keychain.Logging.AccountManagementLoggingSource : object {
    internal static string ASAP;
    internal static string Wrapper;
    internal static string TFS;
    internal static string NonTFS;
}
public static class Microsoft.VisualStudio.Services.Client.Keychain.Logging.DiagnosticsLogging : object {
    public static string EventTypeProperty;
    public static string DiagnosticsLoggingEventType;
    public static string MessagePropertyName;
    public static string ExceptionPropertyName;
    public static string SeverityPropertyName;
    public static void LogInformationEvent(ILogger logger, string eventName, string message, IDictionary`2<string, object> additionalMetadata, Exception exception);
    public static void LogErrorEvent(ILogger logger, string eventName, string message, IDictionary`2<string, object> additionalMetadata, Exception exception);
    private static void LogEvent(ILogger logger, DiagnosticsLoggingMessageSeverity severity, string eventName, string message, IDictionary`2<string, object> additionalMetadata, Exception e);
}
public enum Microsoft.VisualStudio.Services.Client.Keychain.Logging.DiagnosticsLoggingMessageSeverity : Enum {
    public int value__;
    public static DiagnosticsLoggingMessageSeverity Information;
    public static DiagnosticsLoggingMessageSeverity Error;
}
internal class Microsoft.VisualStudio.Services.Client.Keychain.SessionCounterManager : object {
    private static SessionCounterManager instance;
    private static object syncLock;
    private static SessionCounterManager();
    internal static void EnsureSessionCounterSet();
    protected virtual override void Finalize();
}
public class Microsoft.VisualStudio.Services.Client.Keychain.SessionToken : object {
    [CompilerGeneratedAttribute]
private DateTime <DateToRefresh>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <ValidFrom>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <ValidTo>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <RefreshedOn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasCompact>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Guid> <TargetAccounts>k__BackingField;
    public DateTime DateToRefresh { get; public set; }
    public DateTime ValidFrom { get; public set; }
    public DateTime ValidTo { get; public set; }
    public DateTime RefreshedOn { get; public set; }
    public string UserId { get; public set; }
    public string Scope { get; public set; }
    public bool HasCompact { get; public set; }
    public IEnumerable`1<Guid> TargetAccounts { get; public set; }
    [CompilerGeneratedAttribute]
public DateTime get_DateToRefresh();
    [CompilerGeneratedAttribute]
public void set_DateToRefresh(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_ValidFrom();
    [CompilerGeneratedAttribute]
public void set_ValidFrom(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_ValidTo();
    [CompilerGeneratedAttribute]
public void set_ValidTo(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_RefreshedOn();
    [CompilerGeneratedAttribute]
public void set_RefreshedOn(DateTime value);
    [CompilerGeneratedAttribute]
public string get_UserId();
    [CompilerGeneratedAttribute]
public void set_UserId(string value);
    [CompilerGeneratedAttribute]
public string get_Scope();
    [CompilerGeneratedAttribute]
public void set_Scope(string value);
    [CompilerGeneratedAttribute]
public bool get_HasCompact();
    [CompilerGeneratedAttribute]
public void set_HasCompact(bool value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<Guid> get_TargetAccounts();
    [CompilerGeneratedAttribute]
public void set_TargetAccounts(IEnumerable`1<Guid> value);
}
public class Microsoft.VisualStudio.Services.Client.Keychain.SessionTokenDescriptor : object {
    private string scope;
    private string lifeTime;
    private IList`1<Guid> targetAccounts;
    private SessionTokenType tokenType;
    private static string TokenStorageScopePrefix;
    private static string TokenStorageTargetAccountsPrefix;
    public string Scope { get; }
    public string LifeTime { get; }
    public IList`1<Guid> TargetAccounts { get; }
    public SessionTokenType TokenType { get; }
    public SessionTokenDescriptor(string scope, SessionTokenType tokenType, string lifeTime, IList`1<Guid> targetAccounts);
    public string get_Scope();
    public string get_LifeTime();
    public IList`1<Guid> get_TargetAccounts();
    public SessionTokenType get_TokenType();
    public static SessionTokenDescriptor FromKey(VssToken token, SessionTokenType tokenType);
    private static string CleanString(string orjString, string prefix);
    public string ToKey();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
internal class Microsoft.VisualStudio.Services.Client.Keychain.SessionTokenPair : object {
    [CompilerGeneratedAttribute]
private string <SelfDescribing>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Compact>k__BackingField;
    public string SelfDescribing { get; private set; }
    public string Compact { get; private set; }
    [JsonConstructorAttribute]
public SessionTokenPair(string selfDescribing, string compact);
    public string GetToken(SessionTokenType tokenType);
    [CompilerGeneratedAttribute]
public string get_SelfDescribing();
    [CompilerGeneratedAttribute]
private void set_SelfDescribing(string value);
    [CompilerGeneratedAttribute]
public string get_Compact();
    [CompilerGeneratedAttribute]
private void set_Compact(string value);
    public string Serialize();
    public static SessionTokenPair GetTokenPair(string tokenValue);
    private static SessionTokenPair TryDeserialize(string tokenValue);
}
public class Microsoft.VisualStudio.Services.Client.Keychain.SessionTokenStorage : object {
    private ILogger logger;
    private VssTokenStorage tokenStorage;
    internal static string SessionTokenKind;
    internal static string DateToRefreshSessionTokenPropertyName;
    internal static string SessionTokenValidToPropertyName;
    internal static string SessionTokenValidFromPropertyName;
    internal static string TokenType;
    internal static string SessionTokenUserIdPropertyName;
    internal static string RefreshedOnPropertyName;
    private static int maxRetries;
    private static int retryDelay;
    [CompilerGeneratedAttribute]
private GetSessionTokenFromVSO <GetSessionTokenFromServer>k__BackingField;
    internal GetSessionTokenFromVSO GetSessionTokenFromServer { get; internal set; }
    internal SessionTokenStorage(ILogger logger, VssTokenStorage tokenStorage, GetSessionTokenFromVSO getSessionTokenFromServer);
    public SessionTokenStorage(ILogger logger, VssTokenStorage tokenStorage);
    [CompilerGeneratedAttribute]
internal GetSessionTokenFromVSO get_GetSessionTokenFromServer();
    [CompilerGeneratedAttribute]
internal void set_GetSessionTokenFromServer(GetSessionTokenFromVSO value);
    public void ClearSessionTokensForAccount(Account account);
    public IEnumerable`1<SessionToken> GetAllSessionTokens(Account account);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Services.Client.Keychain.SessionTokenStorage/<GetSessionTokenFromAccountAsync>d__20")]
public Task`1<string> GetSessionTokenFromAccountAsync(Account account, SessionTokenDescriptor tokenParameter, bool forceRefresh, CancellationToken cancellationToken);
    internal bool DoesSessionTokenRequireRefresh(DateTime now, VssToken token, string lifeTime, Boolean& expired);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Services.Client.Keychain.SessionTokenStorage/<RefreshSessionTokensForAccountAsync>d__22")]
internal Task RefreshSessionTokensForAccountAsync(Account account, bool forceRefresh, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Services.Client.Keychain.SessionTokenStorage/<GetSessionTokenFromAccountImplAsync>d__23")]
internal Task`1<IDictionary`2<SessionTokenDescriptor, string>> GetSessionTokenFromAccountImplAsync(Account account, IEnumerable`1<SessionTokenDescriptor> tokenParameters, bool forceRefresh, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Services.Client.Keychain.SessionTokenStorage/<RetreiveAndStoreSessionTokensFromVSO>d__24")]
private Task RetreiveAndStoreSessionTokensFromVSO(Account account, IDictionary`2<SessionTokenDescriptor, string> tokensToReturn, HashSet`1<SessionTokenDescriptor> tokensNeedingRefresh, CancellationToken cancellationToken);
    private static Dictionary`2<string, object> GetMetadataFromSessionToken(SessionToken token);
    internal void GetScopesFromTokenStorage(Account account, IEnumerable`1<SessionTokenDescriptor> tokenParameters, bool forceRefresh, IDictionary`2<SessionTokenDescriptor, string> tokensToReturn, HashSet`1<SessionTokenDescriptor> tokensNeedingRefresh);
    private bool IsValidToken(VssToken token, SessionTokenDescriptor tokenParameter, Boolean& needsRefresh, String& tokenValue);
    internal static DateTime CalculateDateToRefreshSessionToken(DateTime validFrom, DateTime validTo);
}
internal class Microsoft.VisualStudio.Services.Client.Keychain.VSProvider.AadProviderConfiguration : object {
    private static string ValidateAadAuthorityName;
    private static string EnableAzureRMIdentityName;
    private static string AzureRMEndpointName;
    private static string AzureRMAudienceEndpointName;
    private static string ScopesName;
    private static string AzureRMAudienceScopesName;
    private static Uri DefaultAzureResourceManagementEndpoint;
    private static Uri DefaultResourceEndpoint;
    private static String[] DefaultScopes;
    private static String[] DefaultAzureRMAudienceScopes;
    private Uri resourceEndpoint;
    public string AadAuthorityBase { get; }
    public bool ValidateAadAuthority { get; }
    public bool AzureRMIdentityEnabled { get; }
    public string ClientIdentifier { get; }
    public Uri NativeClientRedirect { get; }
    public Uri ResourceEndpoint { get; internal set; }
    public Uri AzureResourceManagementEndpoint { get; }
    public Uri AzureRMAudienceEndpoint { get; }
    public String[] Scopes { get; }
    public String[] AzureRMAudienceScopes { get; }
    private static AadProviderConfiguration();
    public sealed virtual string get_AadAuthorityBase();
    public sealed virtual bool get_ValidateAadAuthority();
    public sealed virtual bool get_AzureRMIdentityEnabled();
    public sealed virtual string get_ClientIdentifier();
    public sealed virtual Uri get_NativeClientRedirect();
    public sealed virtual Uri get_ResourceEndpoint();
    internal void set_ResourceEndpoint(Uri value);
    public sealed virtual Uri get_AzureResourceManagementEndpoint();
    public sealed virtual Uri get_AzureRMAudienceEndpoint();
    public sealed virtual String[] get_Scopes();
    public sealed virtual String[] get_AzureRMAudienceScopes();
}
public interface Microsoft.VisualStudio.Services.Client.Keychain.VSProvider.IAadProviderConfiguration {
    public bool AzureRMIdentityEnabled { get; }
    public string AadAuthorityBase { get; }
    public bool ValidateAadAuthority { get; }
    public string ClientIdentifier { get; }
    public Uri NativeClientRedirect { get; }
    [ObsoleteAttribute("Use Scopes instead.")]
public Uri ResourceEndpoint { get; }
    public String[] Scopes { get; }
    public Uri AzureResourceManagementEndpoint { get; }
    [ObsoleteAttribute("Use AzureRMAudienceScopes instead.")]
public Uri AzureRMAudienceEndpoint { get; }
    public String[] AzureRMAudienceScopes { get; }
    public abstract virtual bool get_AzureRMIdentityEnabled();
    public abstract virtual string get_AadAuthorityBase();
    public abstract virtual bool get_ValidateAadAuthority();
    public abstract virtual string get_ClientIdentifier();
    public abstract virtual Uri get_NativeClientRedirect();
    public abstract virtual Uri get_ResourceEndpoint();
    public abstract virtual String[] get_Scopes();
    public abstract virtual Uri get_AzureResourceManagementEndpoint();
    public abstract virtual Uri get_AzureRMAudienceEndpoint();
    public abstract virtual String[] get_AzureRMAudienceScopes();
}
internal enum Microsoft.VisualStudio.Services.Client.SessionOp : Enum {
    public int value__;
    public static SessionOp SESSION_QUERY;
    public static SessionOp SESSION_INCREMENT;
    public static SessionOp SESSION_DECREMENT;
}
public class Microsoft.VisualStudio.Services.Client.VSAccountProviderParameters : object {
    [CompilerGeneratedAttribute]
private VSAccountProvider <KeychainAccountProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VSTSEndpointResource>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserUniqueId>k__BackingField;
    public VSAccountProvider KeychainAccountProvider { get; public set; }
    public string VSTSEndpointResource { get; public set; }
    public string TenantId { get; public set; }
    public string UserUniqueId { get; public set; }
    [CompilerGeneratedAttribute]
public VSAccountProvider get_KeychainAccountProvider();
    [CompilerGeneratedAttribute]
public void set_KeychainAccountProvider(VSAccountProvider value);
    [CompilerGeneratedAttribute]
public string get_VSTSEndpointResource();
    [CompilerGeneratedAttribute]
public void set_VSTSEndpointResource(string value);
    [CompilerGeneratedAttribute]
public string get_TenantId();
    [CompilerGeneratedAttribute]
public void set_TenantId(string value);
    [CompilerGeneratedAttribute]
public string get_UserUniqueId();
    [CompilerGeneratedAttribute]
public void set_UserUniqueId(string value);
}
public class Microsoft.VisualStudio.Services.Client.VssAadCredential : FederatedCredential {
    [CompilerGeneratedAttribute]
private string <Username>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    public VssCredentialsType CredentialType { get; }
    public string Username { get; }
    [EditorBrowsableAttribute("1")]
public string Password { get; }
    public VssAadCredential(VssAadToken initialToken);
    public VssAadCredential(string username, string password);
    public virtual VssCredentialsType get_CredentialType();
    [CompilerGeneratedAttribute]
public string get_Username();
    [CompilerGeneratedAttribute]
public string get_Password();
    public virtual bool IsAuthenticationChallenge(IHttpResponse webResponse);
    protected virtual IssuedTokenProvider OnCreateTokenProvider(Uri serverUrl, IHttpResponse response);
}
public static class Microsoft.VisualStudio.Services.Client.VssAadSettings : object {
    public static string DefaultAadInstance;
    public static string CommonTenant;
    public static string Resource;
    public static string Client;
    private static string ApplicationTenantId;
    public static String[] DefaultScopes;
    public static Uri NativeClientRedirectUri { get; }
    public static string ClientId { get; }
    public static string AadInstance { get; }
    public static string ApplicationTenant { get; }
    private static VssAadSettings();
    public static Uri get_NativeClientRedirectUri();
    public static string get_ClientId();
    public static string get_AadInstance();
    public static string get_ApplicationTenant();
}
public class Microsoft.VisualStudio.Services.Client.VssAadToken : IssuedToken {
    private bool allowDialog;
    private string accessToken;
    private string accessTokenType;
    private IPublicClientApplication app;
    private VssAadCredential userCredential;
    private Func`2<String[], AuthenticationResult> tokenAcquisitionDelegate;
    protected internal VssCredentialsType CredentialType { get; }
    public VssAadToken(string accessTokenType, string accessToken);
    public VssAadToken(PublicClientApplicationBuilder clientBuilder, VssAadCredential userCredential, bool allowDialog);
    public VssAadToken(Func`2<String[], AuthenticationResult> tokenAcquisitionDelegate);
    protected internal virtual VssCredentialsType get_CredentialType();
    public AuthenticationResult AcquireToken(String[] scopes);
    internal virtual void ApplyTo(IHttpRequest request);
}
internal class Microsoft.VisualStudio.Services.Client.VssAadTokenProvider : IssuedTokenProvider {
    public bool GetTokenIsInteractive { get; }
    public VssAadTokenProvider(VssAadCredential credential);
    public virtual bool get_GetTokenIsInteractive();
    private VssAadToken GetVssAadToken();
    protected virtual Task`1<IssuedToken> OnGetTokenAsync(IssuedToken failedToken, CancellationToken cancellationToken);
}
public class Microsoft.VisualStudio.Services.Client.VssAadVSAccountProviderToken : IssuedToken {
    private AuthenticationResult m_authResult;
    protected internal VssCredentialsType CredentialType { get; }
    public VssAadVSAccountProviderToken(AuthenticationResult result);
    protected internal virtual VssCredentialsType get_CredentialType();
    internal virtual void ApplyTo(IHttpRequest request);
}
public class Microsoft.VisualStudio.Services.Client.VssAadVSAccountProviderTokenProvider : IssuedTokenProvider {
    private Action`3<string, string, Guid> m_raiseSilentFailureEvent;
    private Func`7<VSAccountProvider, string, string, string, IntPtr, CancellationToken, AuthenticationResult> m_acquireTokenDelegate;
    private VSAccountProviderParameters m_parameters;
    public bool GetTokenIsInteractive { get; }
    public VssAadVSAccountProviderTokenProvider(FederatedCredential credential, VSAccountProviderParameters parameters, Action`3<string, string, Guid> raiseSilentFailureEventAction, Func`7<VSAccountProvider, string, string, string, IntPtr, CancellationToken, AuthenticationResult> acquireTokenDelegate);
    public virtual bool get_GetTokenIsInteractive();
    protected virtual Task`1<IssuedToken> OnGetTokenAsync(IssuedToken failedToken, CancellationToken cancellationToken);
}
public static class Microsoft.VisualStudio.Services.Client.VssAuthenticationHelper : object {
    private static IAccountCache AccountCache { get; }
    private static string ApplicationTenantId { get; }
    private static IAccountCache get_AccountCache();
    private static string GetTenantIdFromAccountStore(string user);
    private static string get_ApplicationTenantId();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Services.Client.VssAuthenticationHelper/<CheckForValidTokenByTenantAsync>d__5")]
public static Task`1<bool> CheckForValidTokenByTenantAsync(VssFederatedCredentialPrompt federatedPrompt, string tenant);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Services.Client.VssAuthenticationHelper/<CheckForValidTokenByUserAndTenantAsync>d__6")]
public static Task`1<bool> CheckForValidTokenByUserAndTenantAsync(VssFederatedCredentialPrompt federatedPrompt, string user, string tenant);
    private static IAccountCacheItem ShowAccountPicker(IEnumerable`1<IAccountCacheItem> cacheItemList);
    private static Nullable`1<bool> InvokeDialog(IntPtr owner, object state);
    private static bool TrySetTokenForAuth(VssFederatedCredentialPrompt federatedPrompt, IAccountCacheItem tokenCacheItem);
    private static string VerifyAuthWithToken(IAccountCacheItem tokenCacheItem);
    private static void CleanupAccessTokenInPromptParameters(VssFederatedCredentialPrompt federatedPrompt);
    private static void CleanupUserInfoInPromptParameters(VssFederatedCredentialPrompt federatedPrompt);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Services.Client.VssAuthenticationHelper/<FilterForDistinctTenantUserAsync>d__13")]
private static Task`1<IEnumerable`1<IAccountCacheItem>> FilterForDistinctTenantUserAsync(List`1<IAccountCacheItem> list, string tenantId);
}
public class Microsoft.VisualStudio.Services.Client.VssAzureIdentityCredential : FederatedCredential {
    private TokenCredential tokenCredential;
    public VssCredentialsType CredentialType { get; }
    public VssAzureIdentityCredential(TokenCredential tokenCredential);
    public virtual VssCredentialsType get_CredentialType();
    public virtual bool IsAuthenticationChallenge(IHttpResponse webResponse);
    protected virtual IssuedTokenProvider OnCreateTokenProvider(Uri serverUrl, IHttpResponse response);
}
internal class Microsoft.VisualStudio.Services.Client.VssAzureIdentityTokenProvider : IssuedTokenProvider {
    private TokenCredential tokenCredential;
    public bool GetTokenIsInteractive { get; }
    public VssAzureIdentityTokenProvider(VssAzureIdentityCredential credential, TokenCredential tokenCredential);
    public virtual bool get_GetTokenIsInteractive();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Services.Client.VssAzureIdentityTokenProvider/<OnGetTokenAsync>d__4")]
protected virtual Task`1<IssuedToken> OnGetTokenAsync(IssuedToken failedToken, CancellationToken cancellationToken);
}
internal static class Microsoft.VisualStudio.Services.Client.VssClaimsConstants : object {
    internal static string GivenNameClaimType;
    internal static string FamilyNameClaimType;
    internal static string ProfileExtraScope;
}
public class Microsoft.VisualStudio.Services.Client.VssClientCredentials : VssCredentials {
    public VssClientCredentials(WindowsCredential windowsCredential, FederatedCredential federatedCredential, Nullable`1<CredentialPromptType> promptType, TaskScheduler scheduler, IVssCredentialPrompt credentialPrompt);
    public VssClientCredentials(bool useDefaultCredentials);
    private VssClientCredentials(WindowsCredential windowsCredential, FederatedCredential federatedCredential, TaskScheduler scheduler, Nullable`1<CredentialPromptType> promptType, IVssCredentialPrompt credentialPrompt);
    public VssClientCredentials(WindowsCredential windowsCredential, FederatedCredential federatedCredential, IDialogHost dialogHost);
    private VssClientCredentials(WindowsCredential windowsCredential, FederatedCredential federatedCredential, CredentialPromptType promptType, TaskScheduler scheduler, IVssCredentialPrompt credentialPrompt);
    public static VssClientCredentials op_Implicit(FederatedCredential credential);
    public static VssClientCredentials op_Implicit(WindowsCredential credential);
    internal virtual bool TryGetValidToken(IVssCredentialPrompt prompt);
    public static VssCredentials LoadCachedCredentials(Uri serverUrl, bool requireExactMatch);
    public static VssCredentials LoadCachedCredentials(Uri serverUrl, bool requireExactMatch, CredentialPromptType promptType);
    [EditorBrowsableAttribute("1")]
public static VssCredentials LoadCachedCredentials(string featureRegistryKeyword, Uri serverUrl, bool requireExactMatch);
    [EditorBrowsableAttribute("1")]
public static VssCredentials LoadCachedCredentials(string featureRegistryKeyword, Uri serverUrl, bool requireExactMatch, CredentialPromptType promptType);
    private static FederatedCredential CreateDefaultFederatedCredential(bool useDefaultCredentials);
    private static CredentialPromptType CreateDefaultPromptType(FederatedCredential federatedCredential);
}
public class Microsoft.VisualStudio.Services.Client.VssClientCredentialStorage : object {
    private string m_tokenKind;
    private VssTokenStorage m_tokenStorage;
    private Dictionary`2<string, VssTokenKey> m_tokenKeyMap;
    protected VssTokenStorage TokenStorage { get; }
    protected string TokenKind { get; }
    public VssClientCredentialStorage(string storageKind, string storageNamespace);
    public VssClientCredentialStorage(string storageKind, VssTokenStorage tokenStorage);
    protected VssTokenStorage get_TokenStorage();
    protected string get_TokenKind();
    public string GetTokenProperty(Uri serverUrl, string propertyName);
    public String[] GetTokenProperty(Uri[] serverUrls, string propertyName);
    public virtual IssuedToken RetrieveToken(Uri serverUrl, VssCredentialsType credentialsType);
    public virtual void StoreToken(Uri serverUrl, IssuedToken token);
    public void RemoveToken(Uri serverUrl);
    public virtual void RemoveToken(Uri serverUrl, IssuedToken token);
    public virtual bool RemoveTokenValue(Uri serverUrl, IssuedToken token);
    public void RemoveTokenValues(Guid userId);
    protected virtual VssTokenKey BuildTokenKey(Uri serverUrl, VssCredentialsType credentialType);
    private string ConvertUriForStorage(Uri serverUri);
}
public class Microsoft.VisualStudio.Services.Client.VssFederatedCredential : FederatedCredential {
    public VssCredentialsType CredentialType { get; }
    public VssFederatedCredential(bool useCache, VssFederatedToken initialToken);
    public virtual VssCredentialsType get_CredentialType();
    public virtual bool IsAuthenticationChallenge(IHttpResponse webResponse);
    protected virtual IssuedTokenProvider OnCreateTokenProvider(Uri serverUrl, IHttpResponse response);
    internal static void GetRealmAndIssuer(IHttpResponse response, String& realm, String& issuer);
    internal static Nullable`1<bool> IsVssFederatedAuthenticationChallenge(IHttpResponse webResponse, Boolean& isNonAuthenticationChallenge);
    private static void AddParameter(Uri& uri, string name, string value);
}
public class Microsoft.VisualStudio.Services.Client.VssFederatedToken : IssuedToken {
    private CookieCollection m_cookies;
    private static string c_cookieHeader;
    [EditorBrowsableAttribute("1")]
public CookieCollection CookieCollection { get; }
    protected internal VssCredentialsType CredentialType { get; }
    public VssFederatedToken(CookieCollection cookies);
    public CookieCollection get_CookieCollection();
    protected internal virtual VssCredentialsType get_CredentialType();
    internal virtual void ApplyTo(IHttpRequest request);
    private string GetHeaderValue(IEnumerable`1<string> cookieHeaders);
}
internal class Microsoft.VisualStudio.Services.Client.VssFederatedTokenProvider : IssuedTokenProvider {
    [CompilerGeneratedAttribute]
private string <Issuer>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Realm>k__BackingField;
    protected string AuthenticationScheme { get; }
    protected string AuthenticationParameter { get; }
    public VssFederatedCredential Credential { get; }
    public bool GetTokenIsInteractive { get; }
    public string Issuer { get; private set; }
    public string Realm { get; private set; }
    public VssFederatedTokenProvider(VssFederatedCredential credential, Uri serverUrl, Uri signInUrl, string issuer, string realm);
    protected virtual string get_AuthenticationScheme();
    protected virtual string get_AuthenticationParameter();
    public VssFederatedCredential get_Credential();
    public virtual bool get_GetTokenIsInteractive();
    [CompilerGeneratedAttribute]
public string get_Issuer();
    [CompilerGeneratedAttribute]
private void set_Issuer(string value);
    [CompilerGeneratedAttribute]
public string get_Realm();
    [CompilerGeneratedAttribute]
private void set_Realm(string value);
    protected internal virtual bool IsAuthenticationChallenge(IHttpResponse webResponse);
    protected virtual IssuedToken OnValidatingToken(IssuedToken token, IHttpResponse webResponse);
    public sealed virtual void SignOut(Uri signOutUrl, Uri replyToUrl, string identityProvider);
}
public class Microsoft.VisualStudio.Services.Client.VssOAuthCredential : FederatedCredential {
    private string m_clientId;
    private string m_clientSecret;
    private Uri m_authorizationUri;
    private Action`1<VssOAuthTokenContainer> m_callback;
    public VssCredentialsType CredentialType { get; }
    public string ClientId { get; }
    internal string ClientSecret { get; }
    internal Action`1<VssOAuthTokenContainer> TokensReceived { get; }
    public VssOAuthCredential(Uri authorizationUri, string clientId, string clientSecret, VssOAuthTokenContainer initialToken, Action`1<VssOAuthTokenContainer> tokensReceived);
    public virtual VssCredentialsType get_CredentialType();
    public string get_ClientId();
    internal string get_ClientSecret();
    internal Action`1<VssOAuthTokenContainer> get_TokensReceived();
    public virtual bool IsAuthenticationChallenge(IHttpResponse webResponse);
    protected virtual IssuedTokenProvider OnCreateTokenProvider(Uri serverUrl, IHttpResponse response);
}
public class Microsoft.VisualStudio.Services.Client.VssOAuthToken : IssuedToken {
    private string m_token;
    private DateTime m_expiration;
    private VssOAuthTokenType m_tokenType;
    public string Token { get; }
    public VssOAuthTokenType TokenType { get; }
    public DateTime Expiration { get; }
    protected internal VssCredentialsType CredentialType { get; }
    public VssOAuthToken(string token);
    internal VssOAuthToken(string token, VssOAuthTokenType tokenType);
    internal VssOAuthToken(string token, VssOAuthTokenType tokenType, DateTime expiration);
    public string get_Token();
    public VssOAuthTokenType get_TokenType();
    public DateTime get_Expiration();
    protected internal virtual VssCredentialsType get_CredentialType();
    internal virtual void ApplyTo(IHttpRequest request);
}
public class Microsoft.VisualStudio.Services.Client.VssOAuthTokenContainer : IssuedToken {
    private VssOAuthToken m_accessToken;
    private VssOAuthToken m_refreshToken;
    private static Lazy`1<DataContractJsonSerializer> s_serializer;
    public VssOAuthToken AccessToken { get; }
    public VssOAuthToken RefreshToken { get; }
    protected internal VssCredentialsType CredentialType { get; }
    internal VssOAuthTokenContainer(VssOAuthToken accessToken, VssOAuthToken refreshToken);
    private static VssOAuthTokenContainer();
    public VssOAuthToken get_AccessToken();
    public VssOAuthToken get_RefreshToken();
    protected internal virtual VssCredentialsType get_CredentialType();
    internal virtual void ApplyTo(IHttpRequest message);
    internal static VssOAuthTokenContainer ExtractTokens(Stream stream);
    internal static VssOAuthTokenContainer FromAccessToken(string accessToken);
    internal static VssOAuthTokenContainer FromAuthCodeOrRefreshToken(string authCodeOrRefreshToken);
}
internal class Microsoft.VisualStudio.Services.Client.VssOAuthTokenProvider : IssuedTokenProvider {
    protected string AuthenticationScheme { get; }
    public VssOAuthCredential Credential { get; }
    public bool GetTokenIsInteractive { get; }
    public VssOAuthTokenProvider(VssOAuthCredential credential, Uri serverUrl, Uri signInUrl);
    protected virtual string get_AuthenticationScheme();
    public VssOAuthCredential get_Credential();
    public virtual bool get_GetTokenIsInteractive();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Services.Client.VssOAuthTokenProvider/<OnGetTokenAsync>d__7")]
protected virtual Task`1<IssuedToken> OnGetTokenAsync(IssuedToken failedToken, CancellationToken cancellationToken);
    private HttpMessageHandler CreateMessageHandler();
}
public enum Microsoft.VisualStudio.Services.Client.VssOAuthTokenType : Enum {
    public int value__;
    public static VssOAuthTokenType AuthenticationCode;
    public static VssOAuthTokenType AccessToken;
    public static VssOAuthTokenType RefreshToken;
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
