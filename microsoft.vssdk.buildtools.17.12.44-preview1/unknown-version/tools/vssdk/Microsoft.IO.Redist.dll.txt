internal static class FxResources.Microsoft.IO.Redist.SR : object {
}
internal static class Interop : object {
    internal static void GetRandomBytes(Byte* buffer, int length);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Microsoft.IO.Directory : object {
    public static DirectoryInfo GetParent(string path);
    public static DirectoryInfo CreateDirectory(string path);
    [NullableContextAttribute("2")]
public static bool Exists(string path);
    public static void SetCreationTime(string path, DateTime creationTime);
    public static void SetCreationTimeUtc(string path, DateTime creationTimeUtc);
    public static DateTime GetCreationTime(string path);
    public static DateTime GetCreationTimeUtc(string path);
    public static void SetLastWriteTime(string path, DateTime lastWriteTime);
    public static void SetLastWriteTimeUtc(string path, DateTime lastWriteTimeUtc);
    public static DateTime GetLastWriteTime(string path);
    public static DateTime GetLastWriteTimeUtc(string path);
    public static void SetLastAccessTime(string path, DateTime lastAccessTime);
    public static void SetLastAccessTimeUtc(string path, DateTime lastAccessTimeUtc);
    public static DateTime GetLastAccessTime(string path);
    public static DateTime GetLastAccessTimeUtc(string path);
    public static String[] GetFiles(string path);
    public static String[] GetFiles(string path, string searchPattern);
    public static String[] GetFiles(string path, string searchPattern, SearchOption searchOption);
    public static String[] GetFiles(string path, string searchPattern, EnumerationOptions enumerationOptions);
    public static String[] GetDirectories(string path);
    public static String[] GetDirectories(string path, string searchPattern);
    public static String[] GetDirectories(string path, string searchPattern, SearchOption searchOption);
    public static String[] GetDirectories(string path, string searchPattern, EnumerationOptions enumerationOptions);
    public static String[] GetFileSystemEntries(string path);
    public static String[] GetFileSystemEntries(string path, string searchPattern);
    public static String[] GetFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    public static String[] GetFileSystemEntries(string path, string searchPattern, EnumerationOptions enumerationOptions);
    internal static IEnumerable`1<string> InternalEnumeratePaths(string path, string searchPattern, SearchTarget searchTarget, EnumerationOptions options);
    public static IEnumerable`1<string> EnumerateDirectories(string path);
    public static IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern);
    public static IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption);
    public static IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern, EnumerationOptions enumerationOptions);
    public static IEnumerable`1<string> EnumerateFiles(string path);
    public static IEnumerable`1<string> EnumerateFiles(string path, string searchPattern);
    public static IEnumerable`1<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption);
    public static IEnumerable`1<string> EnumerateFiles(string path, string searchPattern, EnumerationOptions enumerationOptions);
    public static IEnumerable`1<string> EnumerateFileSystemEntries(string path);
    public static IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern);
    public static IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    public static IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern, EnumerationOptions enumerationOptions);
    public static string GetDirectoryRoot(string path);
    public static string GetCurrentDirectory();
    public static void SetCurrentDirectory(string path);
    public static void Move(string sourceDirName, string destDirName);
    public static void Delete(string path);
    public static void Delete(string path, bool recursive);
    public static String[] GetLogicalDrives();
    public static FileSystemInfo CreateSymbolicLink(string path, string pathToTarget);
    public static FileSystemInfo ResolveLinkTarget(string linkPath, bool returnFinalTarget);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.IO.DirectoryInfo : FileSystemInfo {
    private bool _isNormalized;
    [NullableAttribute("2")]
public DirectoryInfo Parent { get; }
    public DirectoryInfo Root { get; }
    public DirectoryInfo(string path);
    internal DirectoryInfo(string originalPath, string fullPath, string fileName, bool isNormalized);
    private void Init(string originalPath, string fullPath, string fileName, bool isNormalized);
    [NullableContextAttribute("2")]
public DirectoryInfo get_Parent();
    public DirectoryInfo CreateSubdirectory(string path);
    public void Create();
    public FileInfo[] GetFiles();
    public FileInfo[] GetFiles(string searchPattern);
    public FileInfo[] GetFiles(string searchPattern, SearchOption searchOption);
    public FileInfo[] GetFiles(string searchPattern, EnumerationOptions enumerationOptions);
    public FileSystemInfo[] GetFileSystemInfos();
    public FileSystemInfo[] GetFileSystemInfos(string searchPattern);
    public FileSystemInfo[] GetFileSystemInfos(string searchPattern, SearchOption searchOption);
    public FileSystemInfo[] GetFileSystemInfos(string searchPattern, EnumerationOptions enumerationOptions);
    public DirectoryInfo[] GetDirectories();
    public DirectoryInfo[] GetDirectories(string searchPattern);
    public DirectoryInfo[] GetDirectories(string searchPattern, SearchOption searchOption);
    public DirectoryInfo[] GetDirectories(string searchPattern, EnumerationOptions enumerationOptions);
    public IEnumerable`1<DirectoryInfo> EnumerateDirectories();
    public IEnumerable`1<DirectoryInfo> EnumerateDirectories(string searchPattern);
    public IEnumerable`1<DirectoryInfo> EnumerateDirectories(string searchPattern, SearchOption searchOption);
    public IEnumerable`1<DirectoryInfo> EnumerateDirectories(string searchPattern, EnumerationOptions enumerationOptions);
    public IEnumerable`1<FileInfo> EnumerateFiles();
    public IEnumerable`1<FileInfo> EnumerateFiles(string searchPattern);
    public IEnumerable`1<FileInfo> EnumerateFiles(string searchPattern, SearchOption searchOption);
    public IEnumerable`1<FileInfo> EnumerateFiles(string searchPattern, EnumerationOptions enumerationOptions);
    public IEnumerable`1<FileSystemInfo> EnumerateFileSystemInfos();
    public IEnumerable`1<FileSystemInfo> EnumerateFileSystemInfos(string searchPattern);
    public IEnumerable`1<FileSystemInfo> EnumerateFileSystemInfos(string searchPattern, SearchOption searchOption);
    public IEnumerable`1<FileSystemInfo> EnumerateFileSystemInfos(string searchPattern, EnumerationOptions enumerationOptions);
    private IEnumerable`1<FileSystemInfo> InternalEnumerateInfos(string path, string searchPattern, SearchTarget searchTarget, EnumerationOptions options);
    public DirectoryInfo get_Root();
    public void MoveTo(string destDirName);
    public virtual void Delete();
    public void Delete(bool recursive);
}
internal class Microsoft.IO.DisableMediaInsertionPrompt : ValueType {
    private bool _disableSuccess;
    private UInt32 _oldMode;
    public static DisableMediaInsertionPrompt Create();
    public sealed virtual void Dispose();
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
public class Microsoft.IO.Enumeration.FileSystemEntry : ValueType {
    internal FILE_FULL_DIR_INFORMATION* _info;
    [CompilerGeneratedAttribute]
private ReadOnlySpan`1<char> <Directory>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlySpan`1<char> <RootDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlySpan`1<char> <OriginalRootDirectory>k__BackingField;
    public ReadOnlySpan`1<char> Directory { get; private set; }
    public ReadOnlySpan`1<char> RootDirectory { get; private set; }
    public ReadOnlySpan`1<char> OriginalRootDirectory { get; private set; }
    public ReadOnlySpan`1<char> FileName { get; }
    public FileAttributes Attributes { get; }
    public long Length { get; }
    public DateTimeOffset CreationTimeUtc { get; }
    public DateTimeOffset LastAccessTimeUtc { get; }
    public DateTimeOffset LastWriteTimeUtc { get; }
    public bool IsDirectory { get; }
    public bool IsHidden { get; }
    [NullableContextAttribute("1")]
public string ToSpecifiedFullPath();
    internal static void Initialize(FileSystemEntry& entry, FILE_FULL_DIR_INFORMATION* info, ReadOnlySpan`1<char> directory, ReadOnlySpan`1<char> rootDirectory, ReadOnlySpan`1<char> originalRootDirectory);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ReadOnlySpan`1<char> get_Directory();
    [CompilerGeneratedAttribute]
private void set_Directory(ReadOnlySpan`1<char> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ReadOnlySpan`1<char> get_RootDirectory();
    [CompilerGeneratedAttribute]
private void set_RootDirectory(ReadOnlySpan`1<char> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ReadOnlySpan`1<char> get_OriginalRootDirectory();
    [CompilerGeneratedAttribute]
private void set_OriginalRootDirectory(ReadOnlySpan`1<char> value);
    public ReadOnlySpan`1<char> get_FileName();
    public FileAttributes get_Attributes();
    public long get_Length();
    public DateTimeOffset get_CreationTimeUtc();
    public DateTimeOffset get_LastAccessTimeUtc();
    public DateTimeOffset get_LastWriteTimeUtc();
    public bool get_IsDirectory();
    public bool get_IsHidden();
    [NullableContextAttribute("1")]
public FileSystemInfo ToFileSystemInfo();
    [NullableContextAttribute("1")]
public string ToFullPath();
}
public class Microsoft.IO.Enumeration.FileSystemEnumerable`1 : object {
    private DelegateEnumerator<TResult> _enumerator;
    private FindTransform<TResult> _transform;
    private EnumerationOptions _options;
    private string _directory;
    [CompilerGeneratedAttribute]
private FindPredicate<TResult> <ShouldIncludePredicate>k__BackingField;
    [CompilerGeneratedAttribute]
private FindPredicate<TResult> <ShouldRecursePredicate>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public FindPredicate<TResult> ShouldIncludePredicate { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public FindPredicate<TResult> ShouldRecursePredicate { get; public set; }
    [NullableContextAttribute("1")]
public FileSystemEnumerable`1(string directory, FindTransform<TResult> transform, EnumerationOptions options);
    internal FileSystemEnumerable`1(string directory, FindTransform<TResult> transform, EnumerationOptions options, bool isNormalized);
    [CompilerGeneratedAttribute]
public FindPredicate<TResult> get_ShouldIncludePredicate();
    [CompilerGeneratedAttribute]
public void set_ShouldIncludePredicate(FindPredicate<TResult> value);
    [CompilerGeneratedAttribute]
public FindPredicate<TResult> get_ShouldRecursePredicate();
    [CompilerGeneratedAttribute]
public void set_ShouldRecursePredicate(FindPredicate<TResult> value);
    [NullableContextAttribute("1")]
public sealed virtual IEnumerator`1<TResult> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal static class Microsoft.IO.Enumeration.FileSystemEnumerableFactory : object {
    private static Char[] s_unixEscapeChars;
    private static FileSystemEnumerableFactory();
    internal static bool NormalizeInputs(String& directory, String& expression, MatchType matchType);
    private static bool MatchesPattern(string expression, ReadOnlySpan`1<char> name, EnumerationOptions options);
    internal static IEnumerable`1<string> UserFiles(string directory, string expression, EnumerationOptions options);
    internal static IEnumerable`1<string> UserDirectories(string directory, string expression, EnumerationOptions options);
    internal static IEnumerable`1<string> UserEntries(string directory, string expression, EnumerationOptions options);
    internal static IEnumerable`1<FileInfo> FileInfos(string directory, string expression, EnumerationOptions options, bool isNormalized);
    internal static IEnumerable`1<DirectoryInfo> DirectoryInfos(string directory, string expression, EnumerationOptions options, bool isNormalized);
    internal static IEnumerable`1<FileSystemInfo> FileSystemInfos(string directory, string expression, EnumerationOptions options, bool isNormalized);
}
public abstract class Microsoft.IO.Enumeration.FileSystemEnumerator`1 : CriticalFinalizerObject {
    private int _remainingRecursionDepth;
    private static int StandardBufferSize;
    private static int MinimumBufferSize;
    private string _originalRootDirectory;
    private string _rootDirectory;
    private EnumerationOptions _options;
    private object _lock;
    private FILE_FULL_DIR_INFORMATION* _entry;
    private TResult _current;
    private IntPtr _buffer;
    private int _bufferLength;
    private IntPtr _directoryHandle;
    private string _currentPath;
    private bool _lastEntryFound;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Queue`1<ValueTuple`3<IntPtr, string, int>> _pending;
    [NullableAttribute("1")]
public TResult Current { get; }
    [NullableAttribute("2")]
private object System.Collections.IEnumerator.Current { get; }
    [NullableContextAttribute("1")]
public FileSystemEnumerator`1(string directory, EnumerationOptions options);
    internal FileSystemEnumerator`1(string directory, bool isNormalized, EnumerationOptions options);
    protected virtual bool ShouldIncludeEntry(FileSystemEntry& entry);
    protected virtual bool ShouldRecurseIntoEntry(FileSystemEntry& entry);
    [NullableContextAttribute("1")]
protected abstract virtual TResult TransformEntry(FileSystemEntry& entry);
    protected virtual void OnDirectoryFinished(ReadOnlySpan`1<char> directory);
    protected virtual bool ContinueOnError(int error);
    [NullableContextAttribute("1")]
public sealed virtual TResult get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    private void DirectoryFinished();
    public sealed virtual void Reset();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    private void Init();
    private bool GetData();
    private IntPtr CreateRelativeDirectoryHandle(ReadOnlySpan`1<char> relativePath, string fullPath);
    private void CloseDirectoryHandle();
    private IntPtr CreateDirectoryHandle(string path, bool ignoreNotFound);
    private bool ContinueOnDirectoryError(int error, bool ignoreNotFound);
    public sealed virtual bool MoveNext();
    private void FindNextEntry();
    private bool DequeueNextDirectory();
    private void InternalDispose(bool disposing);
}
public static class Microsoft.IO.Enumeration.FileSystemName : object {
    private static Char[] s_wildcardChars;
    private static Char[] s_simpleWildcardChars;
    private static FileSystemName();
    [NullableContextAttribute("1")]
public static string TranslateWin32Expression(string expression);
    public static bool MatchesWin32Expression(ReadOnlySpan`1<char> expression, ReadOnlySpan`1<char> name, bool ignoreCase);
    public static bool MatchesSimpleExpression(ReadOnlySpan`1<char> expression, ReadOnlySpan`1<char> name, bool ignoreCase);
    private static bool MatchPattern(ReadOnlySpan`1<char> expression, ReadOnlySpan`1<char> name, bool ignoreCase, bool useExtendedWildcards);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.IO.EnumerationOptions : object {
    private int _maxRecursionDepth;
    internal static int DefaultMaxRecursionDepth;
    [CompilerGeneratedAttribute]
private static EnumerationOptions <Compatible>k__BackingField;
    [CompilerGeneratedAttribute]
private static EnumerationOptions <CompatibleRecursive>k__BackingField;
    [CompilerGeneratedAttribute]
private static EnumerationOptions <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RecurseSubdirectories>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreInaccessible>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BufferSize>k__BackingField;
    [CompilerGeneratedAttribute]
private FileAttributes <AttributesToSkip>k__BackingField;
    [CompilerGeneratedAttribute]
private MatchType <MatchType>k__BackingField;
    [CompilerGeneratedAttribute]
private MatchCasing <MatchCasing>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReturnSpecialDirectories>k__BackingField;
    internal static EnumerationOptions Compatible { get; }
    private static EnumerationOptions CompatibleRecursive { get; }
    internal static EnumerationOptions Default { get; }
    public bool RecurseSubdirectories { get; public set; }
    public bool IgnoreInaccessible { get; public set; }
    public int BufferSize { get; public set; }
    public FileAttributes AttributesToSkip { get; public set; }
    public MatchType MatchType { get; public set; }
    public MatchCasing MatchCasing { get; public set; }
    public int MaxRecursionDepth { get; public set; }
    public bool ReturnSpecialDirectories { get; public set; }
    private static EnumerationOptions();
    [CompilerGeneratedAttribute]
internal static EnumerationOptions get_Compatible();
    [CompilerGeneratedAttribute]
private static EnumerationOptions get_CompatibleRecursive();
    [CompilerGeneratedAttribute]
internal static EnumerationOptions get_Default();
    internal static EnumerationOptions FromSearchOption(SearchOption searchOption);
    [CompilerGeneratedAttribute]
public bool get_RecurseSubdirectories();
    [CompilerGeneratedAttribute]
public void set_RecurseSubdirectories(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreInaccessible();
    [CompilerGeneratedAttribute]
public void set_IgnoreInaccessible(bool value);
    [CompilerGeneratedAttribute]
public int get_BufferSize();
    [CompilerGeneratedAttribute]
public void set_BufferSize(int value);
    [CompilerGeneratedAttribute]
public FileAttributes get_AttributesToSkip();
    [CompilerGeneratedAttribute]
public void set_AttributesToSkip(FileAttributes value);
    [CompilerGeneratedAttribute]
public MatchType get_MatchType();
    [CompilerGeneratedAttribute]
public void set_MatchType(MatchType value);
    [CompilerGeneratedAttribute]
public MatchCasing get_MatchCasing();
    [CompilerGeneratedAttribute]
public void set_MatchCasing(MatchCasing value);
    public int get_MaxRecursionDepth();
    public void set_MaxRecursionDepth(int value);
    [CompilerGeneratedAttribute]
public bool get_ReturnSpecialDirectories();
    [CompilerGeneratedAttribute]
public void set_ReturnSpecialDirectories(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Microsoft.IO.File : object {
    private static int MaxByteArrayLength;
    private static Encoding s_UTF8NoBOM;
    internal static int DefaultBufferSize;
    private static Encoding UTF8NoBOM { get; }
    public static StreamReader OpenText(string path);
    public static StreamWriter CreateText(string path);
    public static StreamWriter AppendText(string path);
    public static void Copy(string sourceFileName, string destFileName);
    public static void Copy(string sourceFileName, string destFileName, bool overwrite);
    public static FileStream Create(string path);
    public static FileStream Create(string path, int bufferSize);
    public static FileStream Create(string path, int bufferSize, FileOptions options);
    public static void Delete(string path);
    [NullableContextAttribute("2")]
public static bool Exists(string path);
    public static FileStream Open(string path, FileMode mode);
    public static FileStream Open(string path, FileMode mode, FileAccess access);
    public static FileStream Open(string path, FileMode mode, FileAccess access, FileShare share);
    internal static DateTimeOffset GetUtcDateTimeOffset(DateTime dateTime);
    public static void SetCreationTime(string path, DateTime creationTime);
    public static void SetCreationTimeUtc(string path, DateTime creationTimeUtc);
    public static DateTime GetCreationTime(string path);
    public static DateTime GetCreationTimeUtc(string path);
    public static void SetLastAccessTime(string path, DateTime lastAccessTime);
    public static void SetLastAccessTimeUtc(string path, DateTime lastAccessTimeUtc);
    public static DateTime GetLastAccessTime(string path);
    public static DateTime GetLastAccessTimeUtc(string path);
    public static void SetLastWriteTime(string path, DateTime lastWriteTime);
    public static void SetLastWriteTimeUtc(string path, DateTime lastWriteTimeUtc);
    public static DateTime GetLastWriteTime(string path);
    public static DateTime GetLastWriteTimeUtc(string path);
    public static FileAttributes GetAttributes(string path);
    public static void SetAttributes(string path, FileAttributes fileAttributes);
    public static FileStream OpenRead(string path);
    public static FileStream OpenWrite(string path);
    public static string ReadAllText(string path);
    public static string ReadAllText(string path, Encoding encoding);
    private static string InternalReadAllText(string path, Encoding encoding);
    public static void WriteAllText(string path, string contents);
    public static void WriteAllText(string path, string contents, Encoding encoding);
    public static Byte[] ReadAllBytes(string path);
    public static void WriteAllBytes(string path, Byte[] bytes);
    public static String[] ReadAllLines(string path);
    public static String[] ReadAllLines(string path, Encoding encoding);
    private static String[] InternalReadAllLines(string path, Encoding encoding);
    public static IEnumerable`1<string> ReadLines(string path);
    public static IEnumerable`1<string> ReadLines(string path, Encoding encoding);
    public static void WriteAllLines(string path, String[] contents);
    public static void WriteAllLines(string path, IEnumerable`1<string> contents);
    public static void WriteAllLines(string path, String[] contents, Encoding encoding);
    public static void WriteAllLines(string path, IEnumerable`1<string> contents, Encoding encoding);
    private static void InternalWriteAllLines(TextWriter writer, IEnumerable`1<string> contents);
    public static void AppendAllText(string path, string contents);
    public static void AppendAllText(string path, string contents, Encoding encoding);
    public static void AppendAllLines(string path, IEnumerable`1<string> contents);
    public static void AppendAllLines(string path, IEnumerable`1<string> contents, Encoding encoding);
    public static void Replace(string sourceFileName, string destinationFileName, string destinationBackupFileName);
    public static void Replace(string sourceFileName, string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors);
    public static void Move(string sourceFileName, string destFileName);
    public static void Move(string sourceFileName, string destFileName, bool overwrite);
    [SupportedOSPlatformAttribute("windows")]
public static void Encrypt(string path);
    [SupportedOSPlatformAttribute("windows")]
public static void Decrypt(string path);
    private static Encoding get_UTF8NoBOM();
    private static StreamReader AsyncStreamReader(string path, Encoding encoding);
    private static StreamWriter AsyncStreamWriter(string path, Encoding encoding, bool append);
    public static Task`1<string> ReadAllTextAsync(string path, CancellationToken cancellationToken);
    public static Task`1<string> ReadAllTextAsync(string path, Encoding encoding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.IO.File/<InternalReadAllTextAsync>d__66")]
private static Task`1<string> InternalReadAllTextAsync(string path, Encoding encoding, CancellationToken cancellationToken);
    public static Task WriteAllTextAsync(string path, string contents, CancellationToken cancellationToken);
    public static Task WriteAllTextAsync(string path, string contents, Encoding encoding, CancellationToken cancellationToken);
    public static Task`1<Byte[]> ReadAllBytesAsync(string path, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.IO.File/<InternalReadAllBytesAsync>d__70")]
private static Task`1<Byte[]> InternalReadAllBytesAsync(FileStream fs, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.IO.File/<InternalReadAllBytesUnknownLengthAsync>d__71")]
private static Task`1<Byte[]> InternalReadAllBytesUnknownLengthAsync(FileStream fs, CancellationToken cancellationToken);
    public static Task WriteAllBytesAsync(string path, Byte[] bytes, CancellationToken cancellationToken);
    public static Task`1<String[]> ReadAllLinesAsync(string path, CancellationToken cancellationToken);
    public static Task`1<String[]> ReadAllLinesAsync(string path, Encoding encoding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.IO.File/<InternalReadAllLinesAsync>d__75")]
private static Task`1<String[]> InternalReadAllLinesAsync(string path, Encoding encoding, CancellationToken cancellationToken);
    public static Task WriteAllLinesAsync(string path, IEnumerable`1<string> contents, CancellationToken cancellationToken);
    public static Task WriteAllLinesAsync(string path, IEnumerable`1<string> contents, Encoding encoding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.IO.File/<InternalWriteAllLinesAsync>d__78")]
private static Task InternalWriteAllLinesAsync(TextWriter writer, IEnumerable`1<string> contents, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.IO.File/<InternalWriteAllTextAsync>d__79")]
private static Task InternalWriteAllTextAsync(StreamWriter sw, string contents, CancellationToken cancellationToken);
    public static Task AppendAllTextAsync(string path, string contents, CancellationToken cancellationToken);
    public static Task AppendAllTextAsync(string path, string contents, Encoding encoding, CancellationToken cancellationToken);
    public static Task AppendAllLinesAsync(string path, IEnumerable`1<string> contents, CancellationToken cancellationToken);
    public static Task AppendAllLinesAsync(string path, IEnumerable`1<string> contents, Encoding encoding, CancellationToken cancellationToken);
    public static FileSystemInfo CreateSymbolicLink(string path, string pathToTarget);
    public static FileSystemInfo ResolveLinkTarget(string linkPath, bool returnFinalTarget);
    [AsyncStateMachineAttribute("Microsoft.IO.File/<<WriteAllBytesAsync>g__Core|72_0>d")]
[CompilerGeneratedAttribute]
internal static Task <WriteAllBytesAsync>g__Core|72_0(string path, Byte[] bytes, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.IO.FileInfo : FileSystemInfo {
    public long Length { get; }
    [NullableAttribute("2")]
public string DirectoryName { get; }
    [NullableAttribute("2")]
public DirectoryInfo Directory { get; }
    public bool IsReadOnly { get; public set; }
    public FileInfo(string fileName);
    internal FileInfo(string originalPath, string fullPath, string fileName, bool isNormalized);
    public long get_Length();
    [NullableContextAttribute("2")]
public string get_DirectoryName();
    [NullableContextAttribute("2")]
public DirectoryInfo get_Directory();
    public bool get_IsReadOnly();
    public void set_IsReadOnly(bool value);
    public StreamReader OpenText();
    public StreamWriter CreateText();
    public StreamWriter AppendText();
    public FileInfo CopyTo(string destFileName);
    public FileInfo CopyTo(string destFileName, bool overwrite);
    public FileStream Create();
    public virtual void Delete();
    public FileStream Open(FileMode mode);
    public FileStream Open(FileMode mode, FileAccess access);
    public FileStream Open(FileMode mode, FileAccess access, FileShare share);
    public FileStream OpenRead();
    public FileStream OpenWrite();
    public void MoveTo(string destFileName);
    public void MoveTo(string destFileName, bool overwrite);
    public FileInfo Replace(string destinationFileName, string destinationBackupFileName);
    public FileInfo Replace(string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors);
    [SupportedOSPlatformAttribute("windows")]
public void Decrypt();
    [SupportedOSPlatformAttribute("windows")]
public void Encrypt();
}
internal static class Microsoft.IO.FileSystem : object {
    internal static void VerifyValidPath(string path, string argName);
    public static void Encrypt(string path);
    public static void Decrypt(string path);
    private static void ThrowExceptionEncryptDecryptFail(string fullPath);
    public static void CopyFile(string sourceFullPath, string destFullPath, bool overwrite);
    public static void ReplaceFile(string sourceFullPath, string destFullPath, string destBackupFullPath, bool ignoreMetadataErrors);
    public static void DeleteFile(string fullPath);
    public static FileAttributes GetAttributes(string fullPath);
    public static DateTimeOffset GetCreationTime(string fullPath);
    public static FileSystemInfo GetFileSystemInfo(string fullPath, bool asDirectory);
    public static DateTimeOffset GetLastAccessTime(string fullPath);
    public static DateTimeOffset GetLastWriteTime(string fullPath);
    public static void MoveDirectory(string sourceFullPath, string destFullPath);
    public static void MoveFile(string sourceFullPath, string destFullPath, bool overwrite);
    private static SafeFileHandle OpenHandleToWriteAttributes(string fullPath, bool asDirectory);
    public static void RemoveDirectory(string fullPath, bool recursive);
    private static void GetFindData(string fullPath, bool isDirectory, bool ignoreAccessDenied, WIN32_FIND_DATA& findData);
    private static bool IsNameSurrogateReparsePoint(WIN32_FIND_DATA& data);
    private static void RemoveDirectoryRecursive(string fullPath, WIN32_FIND_DATA& findData, bool topLevel);
    private static void RemoveDirectoryInternal(string fullPath, bool topLevel, bool allowDirectoryNotEmpty);
    public static void SetAttributes(string fullPath, FileAttributes attributes);
    private static void SetFileTime(string fullPath, bool asDirectory, long creationTime, long lastAccessTime, long lastWriteTime, long changeTime, UInt32 fileAttributes);
    public static void SetCreationTime(string fullPath, DateTimeOffset time, bool asDirectory);
    public static void SetLastAccessTime(string fullPath, DateTimeOffset time, bool asDirectory);
    public static void SetLastWriteTime(string fullPath, DateTimeOffset time, bool asDirectory);
    public static String[] GetLogicalDrives();
    internal static void CreateSymbolicLink(string path, string pathToTarget, bool isDirectory);
    internal static FileSystemInfo ResolveLinkTarget(string linkPath, bool returnFinalTarget, bool isDirectory);
    internal static string GetLinkTarget(string linkPath, bool isDirectory);
    internal static string GetImmediateLinkTarget(string linkPath, bool isDirectory, bool throwOnError, bool returnFullPath);
    private static string GetFinalLinkTarget(string linkPath, bool isDirectory);
    private static SafeFileHandle OpenSafeFileHandle(string path, int flags);
    public static bool DirectoryExists(string fullPath);
    private static bool DirectoryExists(string path, Int32& lastError);
    public static bool FileExists(string fullPath);
    internal static int FillAttributeInfo(string path, WIN32_FILE_ATTRIBUTE_DATA& data, bool returnErrorOnNotFound);
    internal static bool IsPathUnreachableError(int errorCode);
    public static void CreateDirectory(string fullPath, Byte[] securityDescriptor);
    [CompilerGeneratedAttribute]
internal static string <GetImmediateLinkTarget>g__GetTargetPathWithoutNTPrefix|29_0(ReadOnlySpan`1<char> targetPath);
    [CompilerGeneratedAttribute]
internal static UInt32 <GetFinalLinkTarget>g__GetFinalPathNameByHandle|30_0(SafeFileHandle handle, Char[] buffer);
    [CompilerGeneratedAttribute]
internal static string <GetFinalLinkTarget>g__GetFinalLinkTargetSlow|30_1(string linkPath, <>c__DisplayClass30_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.IO.FileSystemInfo : MarshalByRefObject {
    protected string FullPath;
    protected string OriginalPath;
    internal string _name;
    private string _linkTarget;
    private bool _linkTargetIsValid;
    private WIN32_FILE_ATTRIBUTE_DATA _data;
    private int _dataInitialized;
    public string FullName { get; }
    public string Extension { get; }
    public string Name { get; }
    public bool Exists { get; }
    public DateTime CreationTime { get; public set; }
    public DateTime CreationTimeUtc { get; public set; }
    public DateTime LastAccessTime { get; public set; }
    public DateTime LastAccessTimeUtc { get; public set; }
    public DateTime LastWriteTime { get; public set; }
    public DateTime LastWriteTimeUtc { get; public set; }
    [NullableAttribute("2")]
public string LinkTarget { get; }
    public FileAttributes Attributes { get; public set; }
    internal bool ExistsCore { get; }
    internal DateTimeOffset CreationTimeCore { get; internal set; }
    internal DateTimeOffset LastAccessTimeCore { get; internal set; }
    internal DateTimeOffset LastWriteTimeCore { get; internal set; }
    internal long LengthCore { get; }
    internal string NormalizedPath { get; }
    protected FileSystemInfo(SerializationInfo info, StreamingContext context);
    internal void Invalidate();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string get_FullName();
    public string get_Extension();
    public virtual string get_Name();
    public virtual bool get_Exists();
    public abstract virtual void Delete();
    public DateTime get_CreationTime();
    public void set_CreationTime(DateTime value);
    public DateTime get_CreationTimeUtc();
    public void set_CreationTimeUtc(DateTime value);
    public DateTime get_LastAccessTime();
    public void set_LastAccessTime(DateTime value);
    public DateTime get_LastAccessTimeUtc();
    public void set_LastAccessTimeUtc(DateTime value);
    public DateTime get_LastWriteTime();
    public void set_LastWriteTime(DateTime value);
    public DateTime get_LastWriteTimeUtc();
    public void set_LastWriteTimeUtc(DateTime value);
    [NullableContextAttribute("2")]
public string get_LinkTarget();
    public void CreateAsSymbolicLink(string pathToTarget);
    [NullableContextAttribute("2")]
public FileSystemInfo ResolveLinkTarget(bool returnFinalTarget);
    public virtual string ToString();
    internal static FileSystemInfo Create(string fullPath, FileSystemEntry& findData);
    internal void InvalidateCore();
    internal void Init(FILE_FULL_DIR_INFORMATION* info);
    public FileAttributes get_Attributes();
    public void set_Attributes(FileAttributes value);
    internal bool get_ExistsCore();
    internal DateTimeOffset get_CreationTimeCore();
    internal void set_CreationTimeCore(DateTimeOffset value);
    internal DateTimeOffset get_LastAccessTimeCore();
    internal void set_LastAccessTimeCore(DateTimeOffset value);
    internal DateTimeOffset get_LastWriteTimeCore();
    internal void set_LastWriteTimeCore(DateTimeOffset value);
    internal long get_LengthCore();
    private void EnsureDataInitialized();
    public void Refresh();
    private void RefreshCore();
    internal string get_NormalizedPath();
}
public enum Microsoft.IO.MatchCasing : Enum {
    public int value__;
    public static MatchCasing PlatformDefault;
    public static MatchCasing CaseSensitive;
    public static MatchCasing CaseInsensitive;
}
public enum Microsoft.IO.MatchType : Enum {
    public int value__;
    public static MatchType Simple;
    public static MatchType Win32;
}
public static class Microsoft.IO.Path : object {
    public static char DirectorySeparatorChar;
    public static char AltDirectorySeparatorChar;
    public static char VolumeSeparatorChar;
    public static char PathSeparator;
    private static int KeyLength;
    [NullableAttribute("1")]
[ObsoleteAttribute("Path.InvalidPathChars has been deprecated. Use GetInvalidPathChars or GetInvalidFileNameChars instead.")]
public static Char[] InvalidPathChars;
    private static Int32 modreq(System.Runtime.CompilerServices.IsVolatile) s_GetTempPathVersion;
    private static ReadOnlySpan`1<byte> Base32Char { get; }
    private static Path();
    [NullableContextAttribute("2")]
public static string ChangeExtension(string path, string extension);
    [NullableContextAttribute("2")]
public static string GetDirectoryName(string path);
    public static ReadOnlySpan`1<char> GetDirectoryName(ReadOnlySpan`1<char> path);
    internal static int GetDirectoryNameOffset(ReadOnlySpan`1<char> path);
    [NullableContextAttribute("2")]
public static string GetExtension(string path);
    public static ReadOnlySpan`1<char> GetExtension(ReadOnlySpan`1<char> path);
    [NullableContextAttribute("2")]
public static string GetFileName(string path);
    public static ReadOnlySpan`1<char> GetFileName(ReadOnlySpan`1<char> path);
    [NullableContextAttribute("2")]
public static string GetFileNameWithoutExtension(string path);
    public static ReadOnlySpan`1<char> GetFileNameWithoutExtension(ReadOnlySpan`1<char> path);
    [NullableContextAttribute("1")]
public static string GetRandomFileName();
    [NullableContextAttribute("1")]
public static bool IsPathFullyQualified(string path);
    public static bool IsPathFullyQualified(ReadOnlySpan`1<char> path);
    [NullableContextAttribute("2")]
public static bool HasExtension(string path);
    public static bool HasExtension(ReadOnlySpan`1<char> path);
    [NullableContextAttribute("1")]
public static string Combine(string path1, string path2);
    [NullableContextAttribute("1")]
public static string Combine(string path1, string path2, string path3);
    [NullableContextAttribute("1")]
public static string Combine(string path1, string path2, string path3, string path4);
    [NullableContextAttribute("1")]
public static string Combine(String[] paths);
    public static string Join(ReadOnlySpan`1<char> path1, ReadOnlySpan`1<char> path2);
    public static string Join(ReadOnlySpan`1<char> path1, ReadOnlySpan`1<char> path2, ReadOnlySpan`1<char> path3);
    public static string Join(ReadOnlySpan`1<char> path1, ReadOnlySpan`1<char> path2, ReadOnlySpan`1<char> path3, ReadOnlySpan`1<char> path4);
    [NullableContextAttribute("2")]
public static string Join(string path1, string path2);
    [NullableContextAttribute("2")]
public static string Join(string path1, string path2, string path3);
    [NullableContextAttribute("2")]
public static string Join(string path1, string path2, string path3, string path4);
    [NullableContextAttribute("1")]
public static string Join(String[] paths);
    public static bool TryJoin(ReadOnlySpan`1<char> path1, ReadOnlySpan`1<char> path2, Span`1<char> destination, Int32& charsWritten);
    public static bool TryJoin(ReadOnlySpan`1<char> path1, ReadOnlySpan`1<char> path2, ReadOnlySpan`1<char> path3, Span`1<char> destination, Int32& charsWritten);
    private static string CombineInternal(string first, string second);
    private static string CombineInternal(string first, string second, string third);
    private static string CombineInternal(string first, string second, string third, string fourth);
    private static string JoinInternal(ReadOnlySpan`1<char> first, ReadOnlySpan`1<char> second);
    private static string JoinInternal(ReadOnlySpan`1<char> first, ReadOnlySpan`1<char> second, ReadOnlySpan`1<char> third);
    private static string JoinInternal(ReadOnlySpan`1<char> first, ReadOnlySpan`1<char> second, ReadOnlySpan`1<char> third, ReadOnlySpan`1<char> fourth);
    private static ReadOnlySpan`1<byte> get_Base32Char();
    private static void Populate83FileNameFromRandomBytes(Byte* bytes, int byteCount, Span`1<char> chars);
    [NullableContextAttribute("1")]
public static string GetRelativePath(string relativeTo, string path);
    private static string GetRelativePath(string relativeTo, string path, StringComparison comparisonType);
    [NullableContextAttribute("1")]
public static string TrimEndingDirectorySeparator(string path);
    public static ReadOnlySpan`1<char> TrimEndingDirectorySeparator(ReadOnlySpan`1<char> path);
    public static bool EndsInDirectorySeparator(ReadOnlySpan`1<char> path);
    [NullableContextAttribute("1")]
public static bool EndsInDirectorySeparator(string path);
    [NullableContextAttribute("1")]
public static Char[] GetInvalidFileNameChars();
    [NullableContextAttribute("1")]
public static Char[] GetInvalidPathChars();
    [NullableContextAttribute("1")]
public static string GetFullPath(string path);
    [NullableContextAttribute("1")]
public static string GetFullPath(string path, string basePath);
    private static string GetFullPathInternal(string path);
    [NullableContextAttribute("1")]
public static string GetTempPath();
    private static int GetGetTempPathVersion();
    internal static void GetTempPath(ValueStringBuilder& builder);
    [NullableContextAttribute("1")]
public static string GetTempFileName();
    [NullableContextAttribute("2")]
public static bool IsPathRooted(string path);
    public static bool IsPathRooted(ReadOnlySpan`1<char> path);
    [NullableContextAttribute("2")]
public static string GetPathRoot(string path);
    public static ReadOnlySpan`1<char> GetPathRoot(ReadOnlySpan`1<char> path);
    internal static ReadOnlySpan`1<char> GetVolumeName(ReadOnlySpan`1<char> path);
    internal static int GetUncRootLength(ReadOnlySpan`1<char> path);
    [CompilerGeneratedAttribute]
internal static UInt32 <GetTempPath>g__GetTempPathW|59_0(int bufferLen, Char& buffer);
}
public enum Microsoft.IO.SearchOption : Enum {
    public int value__;
    public static SearchOption TopDirectoryOnly;
    public static SearchOption AllDirectories;
}
internal enum Microsoft.IO.SearchTarget : Enum {
    public int value__;
    public static SearchTarget Files;
    public static SearchTarget Directories;
    public static SearchTarget Both;
}
[ExtensionAttribute]
public static class Microsoft.IO.StringExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool Contains(string s, char value);
    [ExtensionAttribute]
internal static bool EqualsOrdinal(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value);
    [NullableContextAttribute("1")]
public static string Create(int length, TState state, SpanAction`2<char, TState> action);
    internal static string Concat(ReadOnlySpan`1<char> str0, ReadOnlySpan`1<char> str1);
    internal static string Concat(ReadOnlySpan`1<char> str0, ReadOnlySpan`1<char> str1, ReadOnlySpan`1<char> str2);
}
internal static class Microsoft.IO.ThrowHelper : object {
    internal static void ThrowEndOfFileException();
}
internal class Microsoft.Win32.SafeHandles.SafeFindHandle : SafeHandle {
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[ExtensionAttribute]
internal static class System.FixedBufferExtensions : object {
    [ExtensionAttribute]
internal static string GetStringFromFixedBuffer(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
internal static int GetFixedBufferStringLength(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
internal static bool FixedBufferEqualsString(ReadOnlySpan`1<char> span, string value);
}
internal static class System.IO.DriveInfoInternal : object {
    public static String[] GetLogicalDrives();
    public static string NormalizeDriveName(string driveName);
}
internal abstract class System.IO.Iterator`1 : object {
    private int _threadId;
    internal int state;
    internal TSource current;
    public TSource Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public sealed virtual TSource get_Current();
    protected abstract virtual Iterator`1<TSource> Clone();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public sealed virtual IEnumerator`1<TSource> GetEnumerator();
    public abstract virtual bool MoveNext();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
}
internal static class System.IO.PathHelper : object {
    internal static string Normalize(string path);
    internal static string Normalize(ValueStringBuilder& path);
    private static void GetFullPathName(ReadOnlySpan`1<char> path, ValueStringBuilder& builder);
    internal static int PrependDevicePathChars(ValueStringBuilder& content, bool isDosUnc, ValueStringBuilder& buffer);
    internal static string TryExpandShortFileName(ValueStringBuilder& outputBuilder, string originalPath);
}
internal static class System.IO.PathInternal : object {
    internal static char DirectorySeparatorChar;
    internal static char AltDirectorySeparatorChar;
    internal static char VolumeSeparatorChar;
    internal static char PathSeparator;
    internal static string DirectorySeparatorCharAsString;
    internal static string NTPathPrefix;
    internal static string ExtendedPathPrefix;
    internal static string UncPathPrefix;
    internal static string UncExtendedPrefixToInsert;
    internal static string UncExtendedPathPrefix;
    internal static string UncNTPathPrefix;
    internal static string DevicePathPrefix;
    internal static string ParentDirectoryPrefix;
    internal static int MaxShortPath;
    internal static int MaxShortDirectoryPath;
    internal static int DevicePrefixLength;
    internal static int UncPrefixLength;
    internal static int UncExtendedPrefixLength;
    internal static StringComparison StringComparison { get; }
    internal static bool IsCaseSensitive { get; }
    internal static bool StartsWithDirectorySeparator(ReadOnlySpan`1<char> path);
    internal static string EnsureTrailingSeparator(string path);
    internal static bool IsRoot(ReadOnlySpan`1<char> path);
    internal static int GetCommonPathLength(string first, string second, bool ignoreCase);
    internal static int EqualStartingCharacterCount(string first, string second, bool ignoreCase);
    internal static bool AreRootsEqual(string first, string second, StringComparison comparisonType);
    internal static string RemoveRelativeSegments(string path, int rootLength);
    internal static bool RemoveRelativeSegments(ReadOnlySpan`1<char> path, int rootLength, ValueStringBuilder& sb);
    internal static string TrimEndingDirectorySeparator(string path);
    internal static bool EndsInDirectorySeparator(string path);
    internal static ReadOnlySpan`1<char> TrimEndingDirectorySeparator(ReadOnlySpan`1<char> path);
    internal static bool EndsInDirectorySeparator(ReadOnlySpan`1<char> path);
    internal static string GetLinkTargetFullPath(string path, string pathToTarget);
    internal static bool IsValidDriveChar(char value);
    internal static bool EndsWithPeriodOrSpace(string path);
    internal static string EnsureExtendedPrefixIfNeeded(string path);
    internal static string EnsureExtendedPrefix(string path);
    internal static bool IsDevice(ReadOnlySpan`1<char> path);
    internal static bool IsDeviceUNC(ReadOnlySpan`1<char> path);
    internal static bool IsExtended(ReadOnlySpan`1<char> path);
    internal static int GetRootLength(ReadOnlySpan`1<char> path);
    internal static bool IsPartiallyQualified(ReadOnlySpan`1<char> path);
    internal static bool IsDirectorySeparator(char c);
    internal static string NormalizeDirectorySeparators(string path);
    internal static bool IsEffectivelyEmpty(ReadOnlySpan`1<char> path);
    internal static StringComparison get_StringComparison();
    internal static bool get_IsCaseSensitive();
}
internal class System.IO.ReadLinesIterator : Iterator`1<string> {
    private string _path;
    private Encoding _encoding;
    private StreamReader _reader;
    private ReadLinesIterator(string path, Encoding encoding, StreamReader reader);
    public virtual bool MoveNext();
    protected virtual Iterator`1<string> Clone();
    protected virtual void Dispose(bool disposing);
    internal static ReadLinesIterator CreateIterator(string path, Encoding encoding);
    private static ReadLinesIterator CreateIterator(string path, Encoding encoding, StreamReader reader);
}
internal static class System.IO.Win32Marshal : object {
    internal static Exception GetExceptionForLastWin32Error(string path);
    internal static Exception GetExceptionForWin32Error(int errorCode, string path);
    internal static int MakeHRFromErrorCode(int errorCode);
    internal static int TryMakeWin32ErrorCodeFromHR(int hr);
    internal static string GetMessage(int errorCode);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.NullablePublicOnlyAttribute : Attribute {
    public bool IncludesInternals;
    public NullablePublicOnlyAttribute(bool );
}
[AttributeUsageAttribute("64")]
internal class System.Runtime.InteropServices.SuppressGCTransitionAttribute : Attribute {
}
internal abstract class System.Runtime.Versioning.OSPlatformAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <PlatformName>k__BackingField;
    public string PlatformName { get; }
    private protected OSPlatformAttribute(string platformName);
    [CompilerGeneratedAttribute]
public string get_PlatformName();
}
[AttributeUsageAttribute("2047")]
internal class System.Runtime.Versioning.SupportedOSPlatformAttribute : OSPlatformAttribute {
    public SupportedOSPlatformAttribute(string platformName);
}
[AttributeUsageAttribute("448")]
internal class System.Runtime.Versioning.SupportedOSPlatformGuardAttribute : OSPlatformAttribute {
    public SupportedOSPlatformGuardAttribute(string platformName);
}
[AttributeUsageAttribute("1")]
internal class System.Runtime.Versioning.TargetPlatformAttribute : OSPlatformAttribute {
    public TargetPlatformAttribute(string platformName);
}
[AttributeUsageAttribute("2047")]
internal class System.Runtime.Versioning.UnsupportedOSPlatformAttribute : OSPlatformAttribute {
    public UnsupportedOSPlatformAttribute(string platformName);
}
[AttributeUsageAttribute("448")]
internal class System.Runtime.Versioning.UnsupportedOSPlatformGuardAttribute : OSPlatformAttribute {
    public UnsupportedOSPlatformGuardAttribute(string platformName);
}
internal static class System.SR : object {
    private static bool s_usingResourceKeys;
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string Arg_FileIsDirectory_Name { get; }
    internal static string Arg_InvalidFileAttrs { get; }
    internal static string Arg_Path2IsRooted { get; }
    internal static string Arg_PathIsVolume { get; }
    internal static string ArgumentNull_FileName { get; }
    internal static string ArgumentNull_Path { get; }
    internal static string ArgumentOutOfRange_Enum { get; }
    internal static string Argument_EmptyFileName { get; }
    internal static string Argument_EmptyPath { get; }
    internal static string Argument_InvalidPathChars { get; }
    internal static string Argument_InvalidSeekOrigin { get; }
    internal static string Argument_InvalidSubPath { get; }
    internal static string Argument_PathEmpty { get; }
    internal static string IO_AlreadyExists_Name { get; }
    internal static string IO_CannotCreateDirectory { get; }
    internal static string IO_EOF_ReadBeyondEOF { get; }
    internal static string IO_FileExists_Name { get; }
    internal static string IO_FileNotFound { get; }
    internal static string IO_FileNotFound_FileName { get; }
    internal static string IO_FileTooLong2GB { get; }
    internal static string IO_InconsistentLinkType { get; }
    internal static string IO_PathNotFound_NoPathName { get; }
    internal static string IO_PathNotFound_Path { get; }
    internal static string IO_PathTooLong { get; }
    internal static string IO_SharingViolation_File { get; }
    internal static string IO_SharingViolation_NoFileName { get; }
    internal static string IO_SourceDestMustBeDifferent { get; }
    internal static string IO_SourceDestMustHaveSameRoot { get; }
    internal static string IO_UnknownFileName { get; }
    internal static string UnauthorizedAccess_IODenied_NoPathName { get; }
    internal static string UnauthorizedAccess_IODenied_Path { get; }
    internal static string PlatformNotSupported_FileEncryption { get; }
    internal static string IO_PathTooLong_Path { get; }
    internal static string Arg_BasePathNotFullyQualified { get; }
    internal static string Arg_PathEmpty { get; }
    internal static string Arg_MustBeDriveLetterOrRootDir { get; }
    internal static string ArgumentOutOfRange_NeedNonNegNum { get; }
    private static SR();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey);
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2, object p3);
    internal static string Format(IFormatProvider provider, string resourceFormat, Object[] args);
    internal static ResourceManager get_ResourceManager();
    internal static string get_Arg_FileIsDirectory_Name();
    internal static string get_Arg_InvalidFileAttrs();
    internal static string get_Arg_Path2IsRooted();
    internal static string get_Arg_PathIsVolume();
    internal static string get_ArgumentNull_FileName();
    internal static string get_ArgumentNull_Path();
    internal static string get_ArgumentOutOfRange_Enum();
    internal static string get_Argument_EmptyFileName();
    internal static string get_Argument_EmptyPath();
    internal static string get_Argument_InvalidPathChars();
    internal static string get_Argument_InvalidSeekOrigin();
    internal static string get_Argument_InvalidSubPath();
    internal static string get_Argument_PathEmpty();
    internal static string get_IO_AlreadyExists_Name();
    internal static string get_IO_CannotCreateDirectory();
    internal static string get_IO_EOF_ReadBeyondEOF();
    internal static string get_IO_FileExists_Name();
    internal static string get_IO_FileNotFound();
    internal static string get_IO_FileNotFound_FileName();
    internal static string get_IO_FileTooLong2GB();
    internal static string get_IO_InconsistentLinkType();
    internal static string get_IO_PathNotFound_NoPathName();
    internal static string get_IO_PathNotFound_Path();
    internal static string get_IO_PathTooLong();
    internal static string get_IO_SharingViolation_File();
    internal static string get_IO_SharingViolation_NoFileName();
    internal static string get_IO_SourceDestMustBeDifferent();
    internal static string get_IO_SourceDestMustHaveSameRoot();
    internal static string get_IO_UnknownFileName();
    internal static string get_UnauthorizedAccess_IODenied_NoPathName();
    internal static string get_UnauthorizedAccess_IODenied_Path();
    internal static string get_PlatformNotSupported_FileEncryption();
    internal static string get_IO_PathTooLong_Path();
    internal static string get_Arg_BasePathNotFullyQualified();
    internal static string get_Arg_PathEmpty();
    internal static string get_Arg_MustBeDriveLetterOrRootDir();
    internal static string get_ArgumentOutOfRange_NeedNonNegNum();
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[DefaultMemberAttribute("Item")]
internal class System.Text.ValueStringBuilder : ValueType {
    private Char[] _arrayToReturnToPool;
    private Span`1<char> _chars;
    private int _pos;
    public int Length { get; public set; }
    public int Capacity { get; }
    public Char& Item { get; }
    public Span`1<char> RawChars { get; }
    public ValueStringBuilder(Span`1<char> initialBuffer);
    public ValueStringBuilder(int initialCapacity);
    public int get_Length();
    public void set_Length(int value);
    public int get_Capacity();
    public void EnsureCapacity(int capacity);
    public Char& GetPinnableReference();
    public Char& GetPinnableReference(bool terminate);
    public Char& get_Item(int index);
    public virtual string ToString();
    public Span`1<char> get_RawChars();
    public ReadOnlySpan`1<char> AsSpan(bool terminate);
    public ReadOnlySpan`1<char> AsSpan();
    public ReadOnlySpan`1<char> AsSpan(int start);
    public ReadOnlySpan`1<char> AsSpan(int start, int length);
    public bool TryCopyTo(Span`1<char> destination, Int32& charsWritten);
    public void Insert(int index, char value, int count);
    public void Insert(int index, string s);
    public void Append(char c);
    public void Append(string s);
    private void AppendSlow(string s);
    public void Append(char c, int count);
    public void Append(Char* value, int length);
    public void Append(ReadOnlySpan`1<char> value);
    public Span`1<char> AppendSpan(int length);
    private void GrowAndAppend(char c);
    private void Grow(int additionalCapacityBeyondPos);
    public void Dispose();
}
