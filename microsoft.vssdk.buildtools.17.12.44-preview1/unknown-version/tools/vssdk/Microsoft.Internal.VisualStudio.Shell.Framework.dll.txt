[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
public interface Microsoft.Internal.VisualStudio.Services.RoamingSettings.IRoamingSettingsService {
    public Stream RpcChannelStream { get; }
    public abstract virtual Stream get_RpcChannelStream();
}
[NullableContextAttribute("1")]
public interface Microsoft.Internal.VisualStudio.Services.RoamingSettings.IRoamingSettingsServiceProvider {
    public abstract virtual Task`1<IRoamingSettingsService> GetServiceAsync(string clientName, CancellationToken cancellationToken);
}
[GuidAttribute("8dfe293d-461c-4416-ab7a-d993d15c1524")]
public class Microsoft.Internal.VisualStudio.Services.RoamingSettings.SVsRoamingSettingsServiceProvider : object {
}
[NullableContextAttribute("1")]
public interface Microsoft.Internal.VisualStudio.Services.UnifiedSettings.IUnifiedSettingsMetadata {
    public abstract virtual IEnumerable`1<string> GetMonikersMatchingPattern(string monikerPattern);
    public abstract virtual IEnumerable`1<string> GetMonikersMatchingPatterns(String[] monikerPatterns);
}
[AttributeUsageAttribute("128")]
public class Microsoft.Internal.VisualStudio.Services.UnifiedSettings.UnifiedSettingsAlternateAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("128")]
public class Microsoft.Internal.VisualStudio.Services.UnifiedSettings.UnifiedSettingsMonikerAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Moniker>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLegacyValue>k__BackingField;
    public string Moniker { get; }
    public bool IsLegacyValue { get; public set; }
    public UnifiedSettingsMonikerAttribute(string moniker);
    [CompilerGeneratedAttribute]
public string get_Moniker();
    [CompilerGeneratedAttribute]
public bool get_IsLegacyValue();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsLegacyValue(bool value);
}
public class Microsoft.Internal.VisualStudio.Shell.Embeddable.Feedback.FilesToUpload : object {
    public IReadOnlyCollection`1<string> FilePaths;
    public bool DeleteAfterUpload;
    public FilesToUpload(IReadOnlyCollection`1<string> filePaths, bool deleteAfterUpload);
}
[GuidAttribute("5F67C426-4C63-4CDB-917B-45B400B96C31")]
public interface Microsoft.Internal.VisualStudio.Shell.Embeddable.Feedback.IFeedbackDiagnosticFileProvider {
    public abstract virtual IReadOnlyCollection`1<string> GetFiles();
}
[GuidAttribute("086B4DF6-379C-4C7F-9420-A3FF55507079")]
public interface Microsoft.Internal.VisualStudio.Shell.Embeddable.Feedback.IFeedbackDiagnosticFileProvider2 {
    public abstract virtual bool GetDeleteAfterUpload();
}
public static class Microsoft.Internal.VisualStudio.Shell.FeatureCondition : object {
    [NullableAttribute("1")]
public static string DevBox;
    public static Guid DevBoxId;
    private static FeatureCondition();
}
public static class Microsoft.Internal.VisualStudio.Shell.Framework.BrokeredServices.Descriptors : object {
    [NullableAttribute("1")]
public static ServiceRpcDescriptor TokenServiceHelper;
    private static Descriptors();
}
[NullableContextAttribute("1")]
public interface Microsoft.Internal.VisualStudio.Shell.Framework.BrokeredServices.ITokenServiceHelper {
    public abstract virtual Task`1<AccessToken> GetTokenAsync(TokenRequestContext requestContext, CancellationToken cancellationToken);
}
public class Microsoft.Internal.VisualStudio.Shell.Framework.BrokeredServices.TokenServiceHelperCredential : TokenCredential {
    [NullableAttribute("1")]
private ServiceBrokerClient serviceBrokerClient;
    [NullableAttribute("1")]
private string callerInformation;
    [NullableContextAttribute("1")]
public TokenServiceHelperCredential(IServiceBroker serviceBroker, string callerInformation, JoinableTaskFactory joinableTaskFactory);
    public sealed virtual void Dispose();
    public virtual AccessToken GetToken(TokenRequestContext requestContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Internal.VisualStudio.Shell.Framework.BrokeredServices.TokenServiceHelperCredential/<GetTokenAsync>d__5")]
public virtual ValueTask`1<AccessToken> GetTokenAsync(TokenRequestContext requestContext, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Microsoft.Internal.VisualStudio.Shell.Framework.FileDialogHelper : object {
    private static Char[] InvalidPathChars;
    private static Char[] InvalidFileNameChars;
    private static FileDialogHelper();
    public static bool IsValidRootedDirectoryPath(string path, bool throwIfInvalid, string paramName);
    public static bool IsValidFileName(string fileName, bool throwIfInvalid, string paramName);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Microsoft.Internal.VisualStudio.Shell.Framework.Resources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string IntellisenseInitializing { get; }
    internal static string IntellisenseSubmessage { get; }
    internal static string Reg_NotifyConditionalFeature { get; }
    internal static string RunContextNotSafeForJoinableTasks { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_IntellisenseInitializing();
    internal static string get_IntellisenseSubmessage();
    internal static string get_Reg_NotifyConditionalFeature();
    internal static string get_RunContextNotSafeForJoinableTasks();
}
internal class Microsoft.Internal.VisualStudio.Shell.Framework.VsManagedTaskBody : object {
    private VsTaskBodyCallback taskBody;
    public VsManagedTaskBody(VsTaskBodyCallback action);
    public sealed virtual void DoWork(IVsTask pTask, UInt32 dwCount, IVsTask[] pParentTasks, Object& pResult);
}
[ExtensionAttribute]
internal static class Microsoft.Internal.VisualStudio.Shell.Framework.VsTaskLibraryHelper : object {
    private static TimeSpan DefaultWaitDialogDelay;
    public static IVsTaskSchedulerService ServiceInstance { get; }
    private static VsTaskLibraryHelper();
    public static IVsTaskSchedulerService get_ServiceInstance();
    public static IVsTaskBody CreateTaskBody(VsTaskBodyCallback action);
    public static IVsTaskBody CreateTaskBody(Action`1<T> action);
    public static IVsTaskBody CreateTaskBody(Func`2<T, object> action);
    public static IVsTaskBody CreateTaskBody(Func`1<object> action);
    public static IVsTaskBody CreateTaskBody(Action action);
    public static IVsTask CreateAndStartTask(IVsTaskSchedulerService scheduler, VsTaskRunContext context, Action action);
    public static IVsTask CreateAndStartTask(IVsTaskSchedulerService scheduler, VsTaskRunContext context, VsTaskBodyCallback action);
    public static IVsTask CreateAndStartTask(IVsTaskSchedulerService scheduler, VsTaskRunContext context, IVsTaskBody pTaskBody);
    public static IVsTask CreateAndStartTaskEx(IVsTaskSchedulerService scheduler, VsTaskRunContext context, VsTaskCreationOptions options, IVsTaskBody pTaskBody, object pAsyncState);
    private static IVsTask GetSingleParent(IVsTask[] parentTasks);
    private static T GetParentResult(IVsTask[] parentTasks);
    public static IVsTask Delay(IVsTaskSchedulerService scheduler, TimeSpan delay);
    [ExtensionAttribute]
public static YieldAwaiter Yield(IVsTaskSchedulerService scheduler, VsTaskRunContext context, IVsTaskCompletionSource taskCompletionSource);
    public static YieldAwaiter Yield(VsTaskRunContext context, IVsTaskCompletionSource taskCompletionSource);
    [ExtensionAttribute]
public static void CompleteAfterTask(IVsTaskCompletionSource taskCompletionSource, Task`1<T> task);
    private static bool CopyTaskResultIfCompleted(Task`1<T> task, IVsTaskCompletionSource taskCompletionSource);
    [ExtensionAttribute]
public static IVsTask InvokeAsync(IVsTaskSchedulerService scheduler, VsInvokableAsyncFunction`1<T> asyncFunction);
    public static IVsTask Delay(IVsTaskSchedulerService scheduler, double delayMilliseconds);
    [ExtensionAttribute]
public static JoinableTask`1<T> RunAsync(JoinableTaskFactory joinableTaskFactory, VsTaskRunContext priority, Func`1<Task`1<T>> asyncMethod);
    [ExtensionAttribute]
public static JoinableTask RunAsync(JoinableTaskFactory joinableTaskFactory, VsTaskRunContext priority, Func`1<Task> asyncMethod);
    [ExtensionAttribute]
public static IVsTask RunAsyncAsVsTask(JoinableTaskFactory joinableTaskFactory, VsTaskRunContext priority, Func`2<CancellationToken, Task`1<T>> asyncMethod);
    [ExtensionAttribute]
public static void Run(JoinableTaskFactory joinableTaskFactory, string waitCaption, Func`3<IProgress`1<ThreadedWaitDialogProgressData>, CancellationToken, Task> asyncMethod, Nullable`1<TimeSpan> delayToShowDialog);
    [ExtensionAttribute]
public static T Run(JoinableTaskFactory joinableTaskFactory, string waitCaption, Func`3<IProgress`1<ThreadedWaitDialogProgressData>, CancellationToken, Task`1<T>> asyncMethod, Nullable`1<TimeSpan> delayToShowDialog);
    [ExtensionAttribute]
public static void Run(JoinableTaskFactory joinableTaskFactory, string waitCaption, Func`2<IProgress`1<ThreadedWaitDialogProgressData>, Task> asyncMethod, Nullable`1<TimeSpan> delayToShowDialog);
    [ExtensionAttribute]
public static T Run(JoinableTaskFactory joinableTaskFactory, string waitCaption, Func`2<IProgress`1<ThreadedWaitDialogProgressData>, Task`1<T>> asyncMethod, Nullable`1<TimeSpan> delayToShowDialog);
    [ExtensionAttribute]
public static void Run(JoinableTaskFactory joinableTaskFactory, string waitCaption, string waitMessage, Func`3<IProgress`1<ThreadedWaitDialogProgressData>, CancellationToken, Task> asyncMethod, Nullable`1<TimeSpan> delayToShowDialog);
    [ExtensionAttribute]
public static T Run(JoinableTaskFactory joinableTaskFactory, string waitCaption, string waitMessage, Func`3<IProgress`1<ThreadedWaitDialogProgressData>, CancellationToken, Task`1<T>> asyncMethod, Nullable`1<TimeSpan> delayToShowDialog);
    [ExtensionAttribute]
public static void Run(JoinableTaskFactory joinableTaskFactory, string waitCaption, string waitMessage, Func`2<IProgress`1<ThreadedWaitDialogProgressData>, Task> asyncMethod, Nullable`1<TimeSpan> delayToShowDialog);
    [ExtensionAttribute]
public static T Run(JoinableTaskFactory joinableTaskFactory, string waitCaption, string waitMessage, Func`2<IProgress`1<ThreadedWaitDialogProgressData>, Task`1<T>> asyncMethod, Nullable`1<TimeSpan> delayToShowDialog);
    [ExtensionAttribute]
public static JoinableTask StartOnIdle(JoinableTaskFactory joinableTaskFactory, Func`1<Task> asyncMethod, VsTaskRunContext priority);
    [ExtensionAttribute]
public static JoinableTask StartOnIdle(JoinableTaskFactory joinableTaskFactory, Action action, VsTaskRunContext priority);
    [ExtensionAttribute]
public static void FileAndForget(JoinableTask joinableTask, string faultEventName, string faultDescription, Func`2<Exception, bool> fileOnlyIf);
    [ExtensionAttribute]
public static void FileAndForget(Task task, string faultEventName, string faultDescription, Func`2<Exception, bool> fileOnlyIf);
    [ExtensionAttribute]
public static IVsTask AsVsTask(JoinableTask`1<T> joinableTask);
    [ExtensionAttribute]
public static JoinableTaskFactory WithPriority(JoinableTaskFactory joinableTaskFactory, VsTaskRunContext priority);
    [ExtensionAttribute]
public static VsTaskAwaiter GetAwaiter(IVsTask task);
    [ExtensionAttribute]
public static VsTaskAwaiter GetAwaiter(VsTaskAwaiter awaiter);
    [ExtensionAttribute]
public static TaskSchedulerAwaiter GetAwaiter(VsTaskRunContext context);
    public static TaskScheduler GetTaskScheduler(VsTaskRunContext context);
    [ExtensionAttribute]
public static VsTaskAwaiter ResumeWith(IVsTask task, VsTaskRunContext context);
    [ExtensionAttribute]
public static IVsTask ContinueWith(IVsTask task, VsTaskRunContext context, IVsTaskBody body);
    [ExtensionAttribute]
public static IVsTask ContinueWith(IVsTask task, VsTaskRunContext context, VsTaskContinuationOptions options, IVsTaskBody taskBody, object asyncState);
    [ExtensionAttribute]
public static bool Wait(IVsTask task, int millisecondsTimeout, VsTaskWaitOptions options);
    [ExtensionAttribute]
public static bool Wait(IVsTask task, int millisecondsTimeout);
    [ExtensionAttribute]
public static IVsTask CreateTask(IVsTaskSchedulerService service, VsTaskRunContext context, IVsTaskBody taskBody);
    [ExtensionAttribute]
public static IVsTask CreateTask(IVsTaskSchedulerService service, VsTaskRunContext context, VsTaskCreationOptions options, IVsTaskBody taskBody, object asyncState);
    [ExtensionAttribute]
public static IVsTaskCompletionSource CreateTaskCompletionSource(IVsTaskSchedulerService service, VsTaskCreationOptions options, object asyncState);
    [ExtensionAttribute]
public static IVsTask ContinueWhenAllCompleted(IVsTaskSchedulerService service, VsTaskRunContext context, IVsTask[] dependentTasks, IVsTaskBody taskBody);
    [ExtensionAttribute]
public static IVsTask ContinueWhenAllCompleted(IVsTaskSchedulerService service, VsTaskRunContext context, IVsTask[] dependentTasks, VsTaskContinuationOptions options, IVsTaskBody taskBody, object asyncState);
    [ExtensionAttribute]
public static void ApplyCancellationToken(IVsTask task, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void CancelWhenCancellationRequested(IVsTask task, JoinableTaskFactory jtf, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsUIThreadContext(VsTaskRunContext context);
    [ExtensionAttribute]
private static bool IsUIThreadJoinableTaskSafeContext(VsTaskRunContext context);
}
[NullableContextAttribute("1")]
[GuidAttribute("75a9f7c7-5cb0-4972-90e9-ef5acd0d5079")]
public interface Microsoft.Internal.VisualStudio.Shell.IFeatureRegistry {
    public abstract virtual UIContext GetFeatureContext(Guid featureId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("4")]
public class Microsoft.Internal.VisualStudio.Shell.ProvideConditionalFeatureAttribute : RegistrationAttribute {
    [CompilerGeneratedAttribute]
private Guid <FeatureId>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid[] <FeatureConditions>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RegistryKey>k__BackingField;
    public Guid FeatureId { get; }
    public Guid[] FeatureConditions { get; }
    private string RegistryKey { get; }
    public ProvideConditionalFeatureAttribute(string featureId, String[] featureConditions);
    [CompilerGeneratedAttribute]
public Guid get_FeatureId();
    [CompilerGeneratedAttribute]
public Guid[] get_FeatureConditions();
    [CompilerGeneratedAttribute]
private string get_RegistryKey();
    public virtual void Register(RegistrationContext context);
    public virtual void Unregister(RegistrationContext context);
}
[GuidAttribute("00fb6599-f8d0-46b0-8287-9a50413f0868")]
public interface Microsoft.Internal.VisualStudio.Shell.SFeatureRegistry {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Shell.AsyncDocView : object {
    [CompilerGeneratedAttribute]
private Func`4<IProgress`1<LoadDocViewProgress>, LoadDocumentViewContext, CancellationToken, Task`1<LoadDocViewResult>> <LoadDocViewFactoryAsync>k__BackingField;
    [CompilerGeneratedAttribute]
private IAsyncServiceProvider <ServiceProvider>k__BackingField;
    private Func`4<IProgress`1<LoadDocViewProgress>, LoadDocumentViewContext, CancellationToken, Task`1<LoadDocViewResult>> LoadDocViewFactoryAsync { get; }
    private IAsyncServiceProvider ServiceProvider { get; }
    public AsyncDocView(Func`4<IProgress`1<LoadDocViewProgress>, LoadDocumentViewContext, CancellationToken, Task`1<LoadDocViewResult>> asyncDocViewFactory, IAsyncServiceProvider serviceProvider);
    [CompilerGeneratedAttribute]
private Func`4<IProgress`1<LoadDocViewProgress>, LoadDocumentViewContext, CancellationToken, Task`1<LoadDocViewResult>> get_LoadDocViewFactoryAsync();
    [CompilerGeneratedAttribute]
private IAsyncServiceProvider get_ServiceProvider();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Shell.AsyncDocView/<LoadDocViewAsync>d__7")]
public sealed virtual Task`1<LoadDocViewResult> LoadDocViewAsync(IProgress`1<LoadDocViewProgress> progress, LoadDocumentViewContext context, CancellationToken cancellationToken);
}
[DefaultMemberAttribute("Item")]
[GuidAttribute("c6dbf4d4-77ca-482d-9e0e-5ad675fb5d60")]
public interface Microsoft.VisualStudio.Shell.IClientContextCategory {
    public object Item { get; public set; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_RefreshRequested(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_RefreshRequested(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ClientContextChanged(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ClientContextChanged(EventHandler`1<EventArgs> value);
    public abstract virtual object get_Item(string propertyName);
    public abstract virtual void set_Item(string propertyName, object value);
    public abstract virtual bool TryGetProperty(string propertyName, Object& value);
    public abstract virtual bool RemoveProperty(string propertyName);
}
[NullableContextAttribute("1")]
[GuidAttribute("a58822e5-7948-4e92-8b28-8a3b28ef7f17")]
public interface Microsoft.VisualStudio.Shell.IClientContextService {
    [CompilerGeneratedAttribute]
public abstract virtual void add_ClientContextChanged(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ClientContextChanged(EventHandler`1<EventArgs> value);
    public abstract virtual IReadOnlyDictionary`2<string, string> GetCurrentContext(String[] categoryNames);
    public abstract virtual IClientContextCategory RegisterCategory(string categoryName);
    public abstract virtual void UnregisterCategory(IClientContextCategory category);
    public abstract virtual object GetValue(string categoryName, string propertyName);
    public abstract virtual IDisposable SubscribeForChanges(string categoryName, string propertyName, Action`1<object> callback);
}
public class Microsoft.VisualStudio.Shell.Internal.AsyncDisposableObject : object {
    [NullableAttribute("1")]
private CancellationTokenSource disposeToken;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private DisposingAsyncEventHandler Disposing;
    public CancellationToken DisposeToken { get; }
    public bool IsDisposed { get; }
    public CancellationToken get_DisposeToken();
    public bool get_IsDisposed();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void add_Disposing(DisposingAsyncEventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void remove_Disposing(DisposingAsyncEventHandler value);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Shell.Internal.AsyncDisposableObject/<DisposeAsync>d__9")]
public sealed virtual ValueTask DisposeAsync();
    protected void ThrowIfDisposed();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Shell.Internal.AsyncDisposableObject/<DisposeCoreAsync>d__11")]
protected virtual ValueTask DisposeCoreAsync();
}
public class Microsoft.VisualStudio.Shell.Internal.DeviceChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private DeviceChangeKind <ChangeKind>k__BackingField;
    public DeviceChangeKind ChangeKind { get; }
    public DeviceChangedEventArgs(DeviceChangeKind changeKind);
    [CompilerGeneratedAttribute]
public DeviceChangeKind get_ChangeKind();
}
public class Microsoft.VisualStudio.Shell.Internal.DeviceChangedEventHandler : MulticastDelegate {
    public DeviceChangedEventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender, DeviceChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DeviceChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum Microsoft.VisualStudio.Shell.Internal.DeviceChangeKind : Enum {
    public int value__;
    public static DeviceChangeKind Unknown;
    public static DeviceChangeKind Mount;
    public static DeviceChangeKind Dismount;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class Microsoft.VisualStudio.Shell.Internal.DeviceUtilityMethods : object {
    [NullableAttribute("1")]
private static PCM_NOTIFY_CALLBACK deviceInterfaceChangeCallback;
    private static HCMNOTIFICATION deviceChangeNotifyHandle;
    private static DeviceChangedEventHandler deviceChangedHandler;
    [NullableAttribute("1")]
private static object deviceChangeSubscriptionSyncObj;
    private static Nullable`1<bool> isDevDriveAvailable;
    public static bool IsDevDriveAvailable { get; }
    private static DeviceUtilityMethods();
    public static void add_DeviceChanged(DeviceChangedEventHandler value);
    public static void remove_DeviceChanged(DeviceChangedEventHandler value);
    public static bool get_IsDevDriveAvailable();
    public static string GetDevDriveRoot();
    [NullableContextAttribute("1")]
public static bool IsDevDrive(string path);
    public static int GetDevDriveCount();
    private static bool IsValidDriveType(DriveType driveType);
    private static HCMNOTIFICATION RegisterForDeviceChangeNotifications();
    [NullableContextAttribute("0")]
private static UInt32 DeviceInterfaceChangeCallback(HCMNOTIFICATION hNotify, Void* Context, CM_NOTIFY_ACTION Action, CM_NOTIFY_EVENT_DATA* EventData, UInt32 EventDataSize);
    private static void UnregisterForDeviceChangeNotifications(HCMNOTIFICATION hNotify);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Shell.Internal.ExtensibilityDiagnosticAddedExtensionItemMetadata : ExtensibilityDiagnosticExtensionItemMetadata {
    [CompilerGeneratedAttribute]
private string <ExtensionId>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, string> <Metadata>k__BackingField;
    public string ExtensionId { get; }
    public IReadOnlyDictionary`2<string, string> Metadata { get; }
    public ExtensibilityDiagnosticAddedExtensionItemMetadata(string featureArea, string subcategory, string extensionId, string extensionItemId, IReadOnlyDictionary`2<string, string> metadata);
    [CompilerGeneratedAttribute]
public string get_ExtensionId();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, string> get_Metadata();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.VisualStudio.Shell.Internal.ExtensibilityDiagnosticConfiguration : object {
    [CompilerGeneratedAttribute]
private string <FeatureArea>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ExtensibilityDiagnosticsProperty> <MetadataProperties>k__BackingField;
    public string FeatureArea { get; }
    public IEnumerable`1<ExtensibilityDiagnosticsProperty> MetadataProperties { get; }
    public ExtensibilityDiagnosticConfiguration(string featureArea, IEnumerable`1<ExtensibilityDiagnosticsProperty> metadataProperties);
    [CompilerGeneratedAttribute]
public string get_FeatureArea();
    [CompilerGeneratedAttribute]
public IEnumerable`1<ExtensibilityDiagnosticsProperty> get_MetadataProperties();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Shell.Internal.ExtensibilityDiagnosticErrorInfo : ValueType {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExtensionId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExtensionItemId>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [NullableAttribute("1")]
public string Message { get; }
    public string ExtensionId { get; public set; }
    public string ExtensionItemId { get; public set; }
    public Exception Exception { get; public set; }
    [NullableContextAttribute("1")]
public ExtensibilityDiagnosticErrorInfo(string message);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_Message();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_ExtensionId();
    [CompilerGeneratedAttribute]
public void set_ExtensionId(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_ExtensionItemId();
    [CompilerGeneratedAttribute]
public void set_ExtensionItemId(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(Exception value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Shell.Internal.ExtensibilityDiagnosticErrorMetadata : ExtensibilityDiagnosticMessageMetadata {
    [CompilerGeneratedAttribute]
private string <Subcategory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExtensionId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExtensionItemId>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public string Subcategory { get; }
    public string ExtensionId { get; public set; }
    public string ExtensionItemId { get; public set; }
    public Exception Exception { get; public set; }
    [NullableContextAttribute("1")]
public ExtensibilityDiagnosticErrorMetadata(string featureArea, string subcategory, string message);
    [NullableContextAttribute("1")]
public ExtensibilityDiagnosticErrorMetadata(string featureArea, string subcategory, ExtensibilityDiagnosticErrorInfo errorInfo);
    [CompilerGeneratedAttribute]
public string get_Subcategory();
    [CompilerGeneratedAttribute]
public string get_ExtensionId();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ExtensionId(string value);
    [CompilerGeneratedAttribute]
public string get_ExtensionItemId();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ExtensionItemId(string value);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Exception(Exception value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Shell.Internal.ExtensibilityDiagnosticEventManager : DisposableObject {
    private IReadOnlyDictionary`2<string, IExtensibilityDiagnosticEventReporter> reporters;
    [CompilerGeneratedAttribute]
private ExtensibilityDiagnosticsLoggerConfiguration <DiagnosticsLogger>k__BackingField;
    protected ExtensibilityDiagnosticsLoggerConfiguration DiagnosticsLogger { get; }
    public bool DiagnosticsEnabled { get; }
    protected ExtensibilityDiagnosticEventManager(IReadOnlyList`1<IExtensibilityDiagnosticEventReporter> reporters, ExtensibilityDiagnosticsLoggerConfiguration diagnosticsLogger);
    [CompilerGeneratedAttribute]
protected ExtensibilityDiagnosticsLoggerConfiguration get_DiagnosticsLogger();
    public sealed virtual bool get_DiagnosticsEnabled();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Shell.Internal.ExtensibilityDiagnosticEventManager/<CreateAsync>d__7")]
public static Task`1<ExtensibilityDiagnosticEventManager> CreateAsync(IReadOnlyList`1<IExtensibilityDiagnosticEventReporter> reporters, ExtensibilityDiagnosticsLoggerConfiguration diagnosticsLogger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Shell.Internal.ExtensibilityDiagnosticEventManager/<InitializeAsync>d__8")]
protected virtual Task InitializeAsync(CancellationToken cancellationToken);
    public sealed virtual Task ReportEventAsync(IExtensibilityDiagnosticEventContext eventContext, CancellationToken cancellationToken);
    public sealed virtual Task ReportErrorAsync(ExtensibilityDiagnosticErrorInfo errorInfo, CancellationToken cancellationToken);
    private bool ShouldLogDiagnostics();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Shell.Internal.ExtensibilityDiagnosticEventMetadata : ExtensibilityDiagnosticMetadata {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <EventName>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, string> <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ItemId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExtensionId>k__BackingField;
    [NullableAttribute("1")]
public string EventName { get; }
    [NullableAttribute("1")]
public IReadOnlyDictionary`2<string, string> Metadata { get; }
    public string ItemId { get; public set; }
    public string ExtensionId { get; public set; }
    [NullableContextAttribute("1")]
public ExtensibilityDiagnosticEventMetadata(string featureArea, string eventName, IReadOnlyDictionary`2<string, string> metadata);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_EventName();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, string> get_Metadata();
    [CompilerGeneratedAttribute]
public string get_ItemId();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ItemId(string value);
    [CompilerGeneratedAttribute]
public string get_ExtensionId();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ExtensionId(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class Microsoft.VisualStudio.Shell.Internal.ExtensibilityDiagnosticEventReporter`1 : ExtensibilityDiagnosticReporter`2<T, ExtensibilityEventDiagnosticConfiguration> {
    [CompilerGeneratedAttribute]
private ExtensibilityEventDiagnosticConfiguration <Configuration>k__BackingField;
    public string EventName { get; }
    public ExtensibilityEventDiagnosticConfiguration Configuration { get; }
    protected ExtensibilityDiagnosticEventReporter`1(ExtensibilityDiagnosticsLoggerConfiguration diagnosticsLogger);
    public abstract virtual string get_EventName();
    protected virtual string GetItemName(T item);
    [CompilerGeneratedAttribute]
public virtual ExtensibilityEventDiagnosticConfiguration get_Configuration();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Shell.Internal.ExtensibilityDiagnosticEventReporter`1/<ReportEventAsync>d__7")]
public sealed virtual Task ReportEventAsync(IExtensibilityDiagnosticEventContext eventContext, CancellationToken cancellationToken);
    public sealed virtual Task ReportErrorAsync(ExtensibilityDiagnosticErrorInfo errorInfo, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.VisualStudio.Shell.Internal.ExtensibilityDiagnosticExtensionItemMetadata : ExtensibilityDiagnosticMetadata {
    [CompilerGeneratedAttribute]
private string <Subcategory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExtensionItemId>k__BackingField;
    public string Subcategory { get; }
    public string ExtensionItemId { get; }
    public ExtensibilityDiagnosticExtensionItemMetadata(string featureArea, string subcategory, string extensionItemId);
    [CompilerGeneratedAttribute]
public string get_Subcategory();
    [CompilerGeneratedAttribute]
public string get_ExtensionItemId();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Shell.Internal.ExtensibilityDiagnosticExtensionItemPropertyUpdatedMetadata : ExtensibilityDiagnosticExtensionItemMetadata {
    [CompilerGeneratedAttribute]
private string <PropertyDisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string PropertyDisplayName { get; }
    public string Value { get; }
    public ExtensibilityDiagnosticExtensionItemPropertyUpdatedMetadata(string featureArea, string subcategory, string extensionItemId, string propertyDisplayName, string value);
    [CompilerGeneratedAttribute]
public string get_PropertyDisplayName();
    [CompilerGeneratedAttribute]
public string get_Value();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class Microsoft.VisualStudio.Shell.Internal.ExtensibilityDiagnosticManager`1 : ExtensibilityDiagnosticReporter`2<T, ExtensibilityPointDiagnosticConfiguration> {
    private CancellationTokenSource disposeToken;
    [NullableAttribute("2")]
private ExtensibilityDiagnosticEventManager diagnosticEventManager;
    [CompilerGeneratedAttribute]
private ExtensibilityPointDiagnosticConfiguration <Configuration>k__BackingField;
    protected string DiagnosticsSubcategory { get; }
    public ExtensibilityPointDiagnosticConfiguration Configuration { get; }
    protected ExtensibilityDiagnosticManager`1(ExtensibilityDiagnosticsLoggerConfiguration diagnosticsConfiguration);
    protected abstract virtual string get_DiagnosticsSubcategory();
    [CompilerGeneratedAttribute]
public virtual ExtensibilityPointDiagnosticConfiguration get_Configuration();
    protected virtual void DisposeManagedResources();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Shell.Internal.ExtensibilityDiagnosticManager`1/<InitializeAsync>d__9")]
protected virtual Task InitializeAsync(CancellationToken cancellationToken);
    protected virtual IReadOnlyList`1<IExtensibilityDiagnosticEventReporter> InitializeDiagnosticEvents();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Shell.Internal.ExtensibilityDiagnosticManager`1/<ReportExtensionItemDiscoveredCoreAsync>d__11")]
protected virtual Task ReportExtensionItemDiscoveredCoreAsync(T item, string extensionIdentifier, CancellationToken cancellationToken);
    protected virtual Task ReportExtensionItemRemovedCoreAsync(T item, CancellationToken cancellationToken);
    protected virtual Task ReportExtensionItemPropertyUpdatedCoreAsync(T item, string property, string value, CancellationToken cancellationToken);
    public sealed virtual Task ReportEventAsync(IExtensibilityDiagnosticEventContext eventContext, CancellationToken cancellationToken);
    public sealed virtual Task ReportErrorAsync(ExtensibilityDiagnosticErrorInfo errorInfo, CancellationToken cancellationToken);
    [ObsoleteAttribute("Use ReportExtensionItemDiscoveredAsync(object, string, CancellationToken) instead", "True")]
public sealed virtual Task ReportExtensionItemDiscoveredAsync(object item, ExtensionIdentificationToken token, CancellationToken cancellationToken);
    public sealed virtual Task ReportExtensionItemDiscoveredAsync(object item, string extensionIdentifier, CancellationToken cancellationToken);
    public virtual Task ReportExtensionItemPropertyUpdatedAsync(object item, string property, string value, CancellationToken cancellationToken);
    public sealed virtual Task ReportExtensionItemRemovedAsync(object item, CancellationToken cancellationToken);
    private bool ShouldLogDiagnostics();
    private void NotifyPropertyChanged_PropertyChanged(object sender, PropertyChangedEventArgs e);
    private void Disposable_Disposing(object sender, EventArgs e);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("Microsoft.VisualStudio.Shell.Internal.ExtensibilityDiagnosticManager`1/<AsyncDisposable_DisposingAsync>d__23")]
private ValueTask AsyncDisposable_DisposingAsync(object sender);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Shell.Internal.ExtensibilityDiagnosticManager`1/<TryGetPropertyValueForUpdateAsync>d__24")]
private Task`1<DisplayableDiagnosticsProperty<T>> TryGetPropertyValueForUpdateAsync(T model, string propertyName, CancellationToken cancellationToken);
    private bool TryGetItemAsT(object item, T& castedItem);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Shell.Internal.ExtensibilityDiagnosticMessageMetadata : ExtensibilityDiagnosticMetadata {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public string Message { get; }
    public ExtensibilityDiagnosticMessageMetadata(string featureArea, string message);
    [CompilerGeneratedAttribute]
public string get_Message();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.VisualStudio.Shell.Internal.ExtensibilityDiagnosticMetadata : object {
    [CompilerGeneratedAttribute]
private DateTime <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FeatureArea>k__BackingField;
    public DateTime Timestamp { get; public set; }
    public string FeatureArea { get; }
    public ExtensibilityDiagnosticMetadata(string featureArea);
    [CompilerGeneratedAttribute]
public DateTime get_Timestamp();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Timestamp(DateTime value);
    [CompilerGeneratedAttribute]
public string get_FeatureArea();
}
public class Microsoft.VisualStudio.Shell.Internal.ExtensibilityDiagnosticRemovedExtensionItemMetadata : ExtensibilityDiagnosticExtensionItemMetadata {
    [NullableContextAttribute("1")]
public ExtensibilityDiagnosticRemovedExtensionItemMetadata(string featureArea, string subcategory, string extensionItemId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.VisualStudio.Shell.Internal.ExtensibilityDiagnosticReporter`2 : DisposableObject {
    private Lazy`1<IReadOnlyList`1<ExtensibilityMetadataPropertySelector`1<TItem>>> propertySelectors;
    [CompilerGeneratedAttribute]
private ExtensibilityDiagnosticsLoggerConfiguration <DiagnosticsLogger>k__BackingField;
    protected ExtensibilityDiagnosticsLoggerConfiguration DiagnosticsLogger { get; }
    protected IReadOnlyList`1<ExtensibilityMetadataPropertySelector`1<TItem>> PropertySelectors { get; }
    public bool DiagnosticsEnabled { get; }
    public VConfiguration Configuration { get; }
    protected ExtensibilityDiagnosticReporter`2(ExtensibilityDiagnosticsLoggerConfiguration diagnosticsLogger);
    [CompilerGeneratedAttribute]
protected ExtensibilityDiagnosticsLoggerConfiguration get_DiagnosticsLogger();
    protected IReadOnlyList`1<ExtensibilityMetadataPropertySelector`1<TItem>> get_PropertySelectors();
    public sealed virtual bool get_DiagnosticsEnabled();
    public abstract virtual VConfiguration get_Configuration();
    protected abstract virtual string GetItemName(TItem item);
    protected abstract virtual IReadOnlyList`1<ExtensibilityMetadataPropertySelector`1<TItem>> InitializeProperties();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Shell.Internal.ExtensibilityDiagnosticReporter`2/<GetMetadataForItemAsync>d__13")]
protected Task`1<IReadOnlyDictionary`2<string, string>> GetMetadataForItemAsync(TItem item, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ExtensibilityMetadataPropertySelector`1<TItem>> <.ctor>b__1_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Shell.Internal.ExtensibilityDiagnosticsLoggerConfiguration : object {
    [NullableAttribute("2")]
private IExtensibilityDiagnosticsService extensibilityDiagnosticsService;
    private CancellationTokenSource disposalToken;
    [CompilerGeneratedAttribute]
private bool <DiagnosticsEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private JoinableTaskFactory <JoinableTaskFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FeatureArea>k__BackingField;
    [CompilerGeneratedAttribute]
private TraceSource <TraceSource>k__BackingField;
    public bool DiagnosticsEnabled { get; }
    public JoinableTaskFactory JoinableTaskFactory { get; }
    public string FeatureArea { get; }
    public TraceSource TraceSource { get; }
    private ExtensibilityDiagnosticsLoggerConfiguration(string featureArea, bool diagnosticsEnabled, JoinableTaskFactory jtf, TraceSource traceSource, IExtensibilityDiagnosticsService extensibilityDiagnosticsService);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Shell.Internal.ExtensibilityDiagnosticsLoggerConfiguration/<CreateAsync>d__3")]
public static Task`1<ExtensibilityDiagnosticsLoggerConfiguration> CreateAsync(string logId, string featureArea, IServiceBroker serviceBroker, JoinableTaskFactory jtf, TraceSource traceSource, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public bool get_DiagnosticsEnabled();
    [CompilerGeneratedAttribute]
public JoinableTaskFactory get_JoinableTaskFactory();
    [CompilerGeneratedAttribute]
public string get_FeatureArea();
    [CompilerGeneratedAttribute]
public TraceSource get_TraceSource();
    public sealed virtual void Dispose();
    public Task RegisterExtensibilityPointAsync(ExtensibilityPointDiagnosticConfiguration configuration, CancellationToken cancellationToken);
    public Task RegisterEventAsync(ExtensibilityEventDiagnosticConfiguration configuration, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Shell.Internal.ExtensibilityDiagnosticsLoggerConfiguration/<ReportEventAsync>d__19")]
public Task ReportEventAsync(ExtensibilityDiagnosticEventMetadata metadata, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Shell.Internal.ExtensibilityDiagnosticsLoggerConfiguration/<ReportExtensionItemDiscoveredAsync>d__20")]
public Task ReportExtensionItemDiscoveredAsync(ExtensibilityDiagnosticAddedExtensionItemMetadata metadata, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Shell.Internal.ExtensibilityDiagnosticsLoggerConfiguration/<ReportExtensionItemPropertyUpdatedAsync>d__21")]
public Task ReportExtensionItemPropertyUpdatedAsync(ExtensibilityDiagnosticExtensionItemPropertyUpdatedMetadata metadata, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Shell.Internal.ExtensibilityDiagnosticsLoggerConfiguration/<ReportExtensionItemRemovedAsync>d__22")]
public Task ReportExtensionItemRemovedAsync(ExtensibilityDiagnosticRemovedExtensionItemMetadata metadata, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Shell.Internal.ExtensibilityDiagnosticsLoggerConfiguration/<ReportErrorAsync>d__23")]
public Task ReportErrorAsync(ExtensibilityDiagnosticErrorMetadata metadata, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Shell.Internal.ExtensibilityDiagnosticsLoggerConfiguration/<InitializeLogHubTraceSourceAsync>d__24")]
private static Task`1<TraceSource> InitializeLogHubTraceSourceAsync(string logId, IServiceBroker serviceBroker, TraceSource traceSource, bool diagnosticsEnabled, CancellationToken cancellationToken);
    private void LogInternalError(Exception ex, string caller);
    private static string GetStringWithInnerExceptions(Exception exception, string prefix);
    private static string FormatException(Exception exception);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Shell.Internal.ExtensibilityDiagnosticsProperty : object {
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Expandable>k__BackingField;
    public string DisplayName { get; }
    public string PropertyName { get; }
    public bool Expandable { get; public set; }
    public ExtensibilityDiagnosticsProperty(string displayName);
    public ExtensibilityDiagnosticsProperty(string displayName, string propertyName);
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    [CompilerGeneratedAttribute]
public string get_PropertyName();
    [CompilerGeneratedAttribute]
public bool get_Expandable();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Expandable(bool value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(ExtensibilityDiagnosticsProperty other);
}
public static class Microsoft.VisualStudio.Shell.Internal.ExtensibilityDiagnosticsServiceDescriptor : object {
    [CompilerGeneratedAttribute]
private static ServiceRpcDescriptor <ExtensibilityDiagnosticsService>k__BackingField;
    public static ServiceRpcDescriptor ExtensibilityDiagnosticsService { get; }
    private static ExtensibilityDiagnosticsServiceDescriptor();
    [CompilerGeneratedAttribute]
public static ServiceRpcDescriptor get_ExtensibilityDiagnosticsService();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Shell.Internal.ExtensibilityDiagnosticsTraceListener : TraceListener {
    private string featureArea;
    private JoinableTaskFactory jtf;
    private CancellationToken shutdownToken;
    private IExtensibilityDiagnosticsService extensibilityDiagnosticsService;
    [NullableAttribute("2")]
private string pendingMessage;
    public ExtensibilityDiagnosticsTraceListener(string featureArea, JoinableTaskFactory jtf, IExtensibilityDiagnosticsService extensibilityDiagnosticsService, CancellationToken shutdownToken);
    [NullableContextAttribute("2")]
public virtual void Write(string message);
    [NullableContextAttribute("2")]
public virtual void WriteLine(string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Shell.Internal.ExtensibilityEventDiagnosticConfiguration : ExtensibilityDiagnosticConfiguration {
    [CompilerGeneratedAttribute]
private string <EventName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShowIdColumn>k__BackingField;
    public string EventName { get; }
    public bool ShowIdColumn { get; public set; }
    public ExtensibilityEventDiagnosticConfiguration(string featureArea, string eventName, IEnumerable`1<ExtensibilityDiagnosticsProperty> metadataProperties);
    [CompilerGeneratedAttribute]
public string get_EventName();
    [CompilerGeneratedAttribute]
public bool get_ShowIdColumn();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ShowIdColumn(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Shell.Internal.ExtensibilityMetadataPropertySelector`1 : object {
    public static string NullValue;
    [CompilerGeneratedAttribute]
private ExtensibilityDiagnosticsProperty <Property>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<T, CancellationToken, Task`1<string>> <SelectorAsync>k__BackingField;
    public ExtensibilityDiagnosticsProperty Property { get; }
    public Func`3<T, CancellationToken, Task`1<string>> SelectorAsync { get; }
    public ExtensibilityMetadataPropertySelector`1(ExtensibilityDiagnosticsProperty property, Func`3<T, CancellationToken, Task`1<string>> selectorAsync);
    public ExtensibilityMetadataPropertySelector`1(ExtensibilityDiagnosticsProperty property, Func`2<T, string> selector);
    [CompilerGeneratedAttribute]
public ExtensibilityDiagnosticsProperty get_Property();
    [CompilerGeneratedAttribute]
public Func`3<T, CancellationToken, Task`1<string>> get_SelectorAsync();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Shell.Internal.ExtensibilityPointDiagnosticConfiguration : ExtensibilityDiagnosticConfiguration {
    [CompilerGeneratedAttribute]
private string <Subcategory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShowNameColumn>k__BackingField;
    public string Subcategory { get; }
    public bool ShowNameColumn { get; public set; }
    public ExtensibilityPointDiagnosticConfiguration(string featureArea, string subcategory, IEnumerable`1<ExtensibilityDiagnosticsProperty> metadataProperties);
    [CompilerGeneratedAttribute]
public string get_Subcategory();
    [CompilerGeneratedAttribute]
public bool get_ShowNameColumn();
    [CompilerGeneratedAttribute]
public void set_ShowNameColumn(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Shell.Internal.ExtensionImageAddedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <ExtensionId>k__BackingField;
    public string ExtensionId { get; }
    public ExtensionImageAddedEventArgs(string extensionId);
    [CompilerGeneratedAttribute]
public string get_ExtensionId();
}
[GuidAttribute("3D54130F-9CBA-4FBE-801F-B8898D554551")]
public interface Microsoft.VisualStudio.Shell.Internal.IClientRightsAdditionalMetadata2 {
    public IReadOnlyDictionary`2<string, object> ClientRightsMetadata { get; }
    public abstract virtual IReadOnlyDictionary`2<string, object> get_ClientRightsMetadata();
}
[GuidAttribute("D42B7902-CE8E-42FB-92CF-B901A1BCD1C3")]
public interface Microsoft.VisualStudio.Shell.Internal.ICloudEnvironmentInformation {
    public abstract virtual Task`1<string> GetNameAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<string> GetWorkspaceIdAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<Guid> GetIdAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<string> GetRootPathAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<string> GetPlanIdAsync(CancellationToken cancellationToken);
}
public interface Microsoft.VisualStudio.Shell.Internal.ICustomImage {
    public string Id { get; }
    public IEnumerable`1<string> SourcePaths { get; }
    public bool CanTheme { get; }
    public abstract virtual string get_Id();
    public abstract virtual IEnumerable`1<string> get_SourcePaths();
    public abstract virtual bool get_CanTheme();
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.Shell.Internal.IExtensibilityDiagnosticEventContext {
    public string EventName { get; }
    public string ItemId { get; }
    [NullableAttribute("2")]
public string ExtensionId { get; }
    public abstract virtual string get_EventName();
    public abstract virtual string get_ItemId();
    [NullableContextAttribute("2")]
public abstract virtual string get_ExtensionId();
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.Shell.Internal.IExtensibilityDiagnosticEventManager {
    public bool DiagnosticsEnabled { get; }
    public abstract virtual bool get_DiagnosticsEnabled();
    public abstract virtual Task ReportEventAsync(IExtensibilityDiagnosticEventContext eventContext, CancellationToken cancellationToken);
    public abstract virtual Task ReportErrorAsync(ExtensibilityDiagnosticErrorInfo errorInfo, CancellationToken cancellationToken);
}
public interface Microsoft.VisualStudio.Shell.Internal.IExtensibilityDiagnosticEventReporter {
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.Shell.Internal.IExtensibilityDiagnosticManager {
    [ObsoleteAttribute("Use ReportExtensionItemDiscoveredAsync(object, string, CancellationToken) instead", "True")]
public abstract virtual Task ReportExtensionItemDiscoveredAsync(object item, ExtensionIdentificationToken token, CancellationToken cancellationToken);
    public abstract virtual Task ReportExtensionItemDiscoveredAsync(object item, string extensionIdentifier, CancellationToken cancellationToken);
    public abstract virtual Task ReportExtensionItemPropertyUpdatedAsync(object item, string property, string value, CancellationToken cancellationToken);
    public abstract virtual Task ReportExtensionItemRemovedAsync(object item, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.Shell.Internal.IExtensibilityDiagnosticReporter`1 {
    public T Configuration { get; }
    public abstract virtual T get_Configuration();
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.Shell.Internal.IExtensibilityDiagnosticsService {
    public abstract virtual Task`1<bool> GetDiagnosticsEnabledStateAsync(CancellationToken cancellationToken);
    public abstract virtual Task RegisterExtensibilityPointAsync(ExtensibilityPointDiagnosticConfiguration configuration, CancellationToken cancellationToken);
    public abstract virtual Task RegisterEventAsync(ExtensibilityEventDiagnosticConfiguration configuration, CancellationToken cancellationToken);
    public abstract virtual Task ReportDiagnosticMessageAsync(ExtensibilityDiagnosticMessageMetadata metadata, CancellationToken cancellationToken);
    public abstract virtual Task ReportExtensionItemDiscoveredAsync(ExtensibilityDiagnosticAddedExtensionItemMetadata metadata, CancellationToken cancellationToken);
    public abstract virtual Task ReportEventAsync(ExtensibilityDiagnosticEventMetadata metadata, CancellationToken cancellationToken);
    public abstract virtual Task ReportExtensionItemRemovedAsync(ExtensibilityDiagnosticRemovedExtensionItemMetadata metadata, CancellationToken cancellationToken);
    public abstract virtual Task ReportExtensionItemPropertyUpdatedAsync(ExtensibilityDiagnosticExtensionItemPropertyUpdatedMetadata metadata, CancellationToken cancellationToken);
    public abstract virtual Task ReportErrorAsync(ExtensibilityDiagnosticErrorMetadata metadata, CancellationToken cancellationToken);
}
[GuidAttribute("DB822876-FC7F-4B3E-BB49-1B6EFD3A2502")]
public interface Microsoft.VisualStudio.Shell.Internal.IFileFolderPicker {
    public abstract virtual Task`1<object> SelectItemsAsync(StorageItemType type, string title, bool allowMultiSelect, bool showAll, string path, string okButtonText, bool overwriteWarning, bool allowNonExistingItem, CancellationToken cancellationToken);
}
[GuidAttribute("56C4EFC4-1D54-4C22-BFE2-4080A99A593A")]
public interface Microsoft.VisualStudio.Shell.Internal.IFileFolderPickerResult {
    public bool DialogResult { get; }
    public IReadOnlyList`1<string> SelectedItems { get; }
    public abstract virtual bool get_DialogResult();
    public abstract virtual IReadOnlyList`1<string> get_SelectedItems();
}
[GuidAttribute("265A780F-069A-4C37-AAF0-C39DC89373D6")]
public interface Microsoft.VisualStudio.Shell.Internal.INewProjectWorkflowAdapter {
    public ICommand GoBack { get; }
    public ICommand GoNext { get; }
    public string GoNextText { get; }
    public object SelectedViewModel { get; }
    public bool ProjectCreationSucceeded { get; }
    public bool IsOnFirstPage { get; }
    public abstract virtual ICommand get_GoBack();
    public abstract virtual ICommand get_GoNext();
    public abstract virtual string get_GoNextText();
    public abstract virtual object get_SelectedViewModel();
    [CompilerGeneratedAttribute]
public abstract virtual void add_ProjectCreationCompleted(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ProjectCreationCompleted(EventHandler value);
    public abstract virtual bool get_ProjectCreationSucceeded();
    public abstract virtual bool get_IsOnFirstPage();
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.Shell.Internal.IRemoteUIService {
    [ObsoleteAttribute("Use the CreateRemoteUserControlProxyAsync override with additional parameters", "True")]
public abstract virtual Task`1<IDisposable> CreateRemoteUserControlProxyAsync(IRemoteUserControl remoteUserControl, JoinableTaskFactory joinableTaskFactory, CancellationToken cancellationToken);
    public abstract virtual Task`1<IDisposable> CreateRemoteUserControlProxyAsync(IRemoteUserControl remoteUserControl, JoinableTaskFactory joinableTaskFactory, IExtensibilityDiagnosticEventManager extensibilityDiagnosticEventManager, string controlId, string extensionId, CancellationToken cancellationToken);
}
[GuidAttribute("AFD88F3B-8E0A-4F3C-AA22-17D808687763")]
public interface Microsoft.VisualStudio.Shell.Internal.IVsAccountConfigurationValidator {
    public abstract virtual Task`1<bool> VerifyAccountTargetsApprovedConfigurationAsync(object account, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> VerifyAccountTargetsApprovedConfigurationAsync(Guid accountProviderId, object configuration, CancellationToken cancellationToken);
}
[GuidAttribute("d67b212c-49ae-4ae1-9434-12deb619566d")]
public interface Microsoft.VisualStudio.Shell.Internal.IVsExecutionContextTrackerEvents {
    public abstract virtual void Register(Guid contextValueType, IVsExecutionContextTrackerListener listener);
    public abstract virtual void Unregister(Guid contextValueType, IVsExecutionContextTrackerListener listener);
}
[GuidAttribute("48c423ff-0ea6-426c-8285-67ab8ec89344")]
public interface Microsoft.VisualStudio.Shell.Internal.IVsExecutionContextTrackerListener {
    public abstract virtual void OnExecutionContextValueChanged(Guid contextValueType, Guid previousValue, Guid newValue);
}
public interface Microsoft.VisualStudio.Shell.Internal.IVsExtensionImageService {
    public abstract virtual IDictionary`2<string, ImageMoniker> AddImagesFromExtension(string extensionId, IEnumerable`1<ICustomImage> customImages);
    public abstract virtual void RemoveImagesForExtension(string extensionId);
    public abstract virtual bool TryGetImageForExtension(string extensionId, string imageId, ImageMoniker& imageMoniker);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ExtensionImagesAdded(EventHandler`1<ExtensionImageAddedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ExtensionImagesAdded(EventHandler`1<ExtensionImageAddedEventArgs> value);
}
public interface Microsoft.VisualStudio.Shell.Internal.IVsExtensionMetadataService {
    public ExtensibilityDiagnosticsLoggerConfiguration Diagnostics { get; }
    public abstract virtual ExtensibilityDiagnosticsLoggerConfiguration get_Diagnostics();
}
[GuidAttribute("fce6b991-fc42-48e5-a32c-701b1153c3ab")]
public interface Microsoft.VisualStudio.Shell.Internal.IVsRoamingManagerFirstLaunchSupport2 {
    public RoamingProfileDownloadStatus ProfileDownloadStatus { get; }
    public abstract virtual RoamingProfileDownloadStatus get_ProfileDownloadStatus();
}
[GuidAttribute("a664f677-37cd-46d2-926c-1e296b3d183f")]
public interface Microsoft.VisualStudio.Shell.Internal.IVsRunAsDetection {
    public abstract virtual bool RunningAsADifferentUser();
}
[GuidAttribute("4e60170d-cc0d-410c-a80a-a9325a9a6ae4")]
public interface Microsoft.VisualStudio.Shell.Internal.IVsScenarioDiagnosticsManager {
    public abstract virtual void ReportScenarioDurationData(string scenarioIdentifier, string componentIdentifier, double totalScenarioDuration, IEnumerable`1<KeyValuePair`2<string, double>> data);
}
[GuidAttribute("E3E5D567-8C98-4293-A7FA-8AB25D5C1DA1")]
public interface Microsoft.VisualStudio.Shell.Internal.IVsSetupCompositionServiceInternal {
    public abstract virtual Task`1<bool> RefreshManifestAsync(CancellationToken cancellationToken);
    public abstract virtual Task NotifyManifestChangedAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<VsSetupCompositionHotloadResult> HotloadExtensionAsync(string vsixFilePath, CancellationToken cancellationToken);
}
[GuidAttribute("F4E45495-910F-41ED-B567-0DD871860FD5")]
public interface Microsoft.VisualStudio.Shell.Internal.IVsSolutionCacheContributor {
    public abstract virtual Task UpdateSolutionCacheAsync(CancellationToken cancellationToken);
}
[GuidAttribute("29C5E8F9-8F34-46D3-8F25-1E4E07220EF5")]
public interface Microsoft.VisualStudio.Shell.Internal.IVsSolutionCacheOperationContextProvider {
    public bool BuildRequested { get; }
    public bool BuildSucceeded { get; }
    public bool LocalCacheRequested { get; }
    public abstract virtual bool get_BuildRequested();
    public abstract virtual bool get_BuildSucceeded();
    public abstract virtual bool get_LocalCacheRequested();
}
[GuidAttribute("CE80CC48-1007-4BA2-B289-EF3C98338543")]
public interface Microsoft.VisualStudio.Shell.Internal.IVsWorkflowDialogService {
    public abstract virtual void ShowNewProjectDialog(VSNEWPROJECTDLGINFO dialogInfo);
    public abstract virtual void CloseNewProjectDialog();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.VisualStudio.Shell.Internal.RemoteUIDiagnosticEventDispose : ExtensibilityDiagnosticEventReporter`1<Context> {
    public static string RemoteUIEventName;
    public string EventName { get; }
    internal RemoteUIDiagnosticEventDispose(ExtensibilityDiagnosticsLoggerConfiguration diagnosticsLogger);
    public virtual string get_EventName();
    protected virtual IReadOnlyList`1<ExtensibilityMetadataPropertySelector`1<Context>> InitializeProperties();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.VisualStudio.Shell.Internal.RemoteUIDiagnosticEventGetObject : ExtensibilityDiagnosticEventReporter`1<Context> {
    public static string RemoteUIEventName;
    public string EventName { get; }
    internal RemoteUIDiagnosticEventGetObject(ExtensibilityDiagnosticsLoggerConfiguration diagnosticsLogger);
    public virtual string get_EventName();
    protected virtual IReadOnlyList`1<ExtensibilityMetadataPropertySelector`1<Context>> InitializeProperties();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.VisualStudio.Shell.Internal.RemoteUIDiagnosticEventInitialize : ExtensibilityDiagnosticEventReporter`1<Context> {
    public static string RemoteUIEventName;
    public string EventName { get; }
    internal RemoteUIDiagnosticEventInitialize(ExtensibilityDiagnosticsLoggerConfiguration diagnosticsLogger);
    public virtual string get_EventName();
    protected virtual IReadOnlyList`1<ExtensibilityMetadataPropertySelector`1<Context>> InitializeProperties();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.VisualStudio.Shell.Internal.RemoteUIDiagnosticEventInvoke : ExtensibilityDiagnosticEventReporter`1<Context> {
    public static string RemoteUIEventName;
    public string EventName { get; }
    internal RemoteUIDiagnosticEventInvoke(ExtensibilityDiagnosticsLoggerConfiguration diagnosticsLogger);
    public virtual string get_EventName();
    protected virtual IReadOnlyList`1<ExtensibilityMetadataPropertySelector`1<Context>> InitializeProperties();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.VisualStudio.Shell.Internal.RemoteUIDiagnosticEventLoaded : ExtensibilityDiagnosticEventReporter`1<Context> {
    public static string RemoteUIEventName;
    public string EventName { get; }
    internal RemoteUIDiagnosticEventLoaded(ExtensibilityDiagnosticsLoggerConfiguration diagnosticsLogger);
    public virtual string get_EventName();
    protected virtual IReadOnlyList`1<ExtensibilityMetadataPropertySelector`1<Context>> InitializeProperties();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.VisualStudio.Shell.Internal.RemoteUIDiagnosticEventObjectValueNotification : ExtensibilityDiagnosticEventReporter`1<Context> {
    public static string RemoteUIEventName;
    public string EventName { get; }
    internal RemoteUIDiagnosticEventObjectValueNotification(ExtensibilityDiagnosticsLoggerConfiguration diagnosticsLogger);
    public virtual string get_EventName();
    protected virtual IReadOnlyList`1<ExtensibilityMetadataPropertySelector`1<Context>> InitializeProperties();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.VisualStudio.Shell.Internal.RemoteUIDiagnosticEventSetCollectionEntry : ExtensibilityDiagnosticEventReporter`1<Context> {
    public static string RemoteUIEventName;
    public string EventName { get; }
    internal RemoteUIDiagnosticEventSetCollectionEntry(ExtensibilityDiagnosticsLoggerConfiguration diagnosticsLogger);
    public virtual string get_EventName();
    protected virtual IReadOnlyList`1<ExtensibilityMetadataPropertySelector`1<Context>> InitializeProperties();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.VisualStudio.Shell.Internal.RemoteUIDiagnosticEventSetDataContext : ExtensibilityDiagnosticEventReporter`1<Context> {
    public static string RemoteUIEventName;
    public string EventName { get; }
    internal RemoteUIDiagnosticEventSetDataContext(ExtensibilityDiagnosticsLoggerConfiguration diagnosticsLogger);
    public virtual string get_EventName();
    protected virtual IReadOnlyList`1<ExtensibilityMetadataPropertySelector`1<Context>> InitializeProperties();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.VisualStudio.Shell.Internal.RemoteUIDiagnosticEventSetObjectProperty : ExtensibilityDiagnosticEventReporter`1<Context> {
    public static string RemoteUIEventName;
    public string EventName { get; }
    internal RemoteUIDiagnosticEventSetObjectProperty(ExtensibilityDiagnosticsLoggerConfiguration diagnosticsLogger);
    public virtual string get_EventName();
    protected virtual IReadOnlyList`1<ExtensibilityMetadataPropertySelector`1<Context>> InitializeProperties();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Microsoft.VisualStudio.Shell.Internal.RemoteUIDiagnosticsHelper : object {
    public static string EventNamePrefix;
    public static IReadOnlyList`1<IExtensibilityDiagnosticEventReporter> InitializeDiagnosticEvents(ExtensibilityDiagnosticsLoggerConfiguration diagnosticsLogger);
}
public enum Microsoft.VisualStudio.Shell.Internal.RoamingProfileDownloadStatus : Enum {
    public int value__;
    public static RoamingProfileDownloadStatus NotAttempted;
    public static RoamingProfileDownloadStatus InProgress;
    public static RoamingProfileDownloadStatus Failed;
    public static RoamingProfileDownloadStatus Succeeded;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Shell.Internal.ServiceBroker.ServiceActivationOptionsExtensionMethods : object {
    public static string CallerExtensionIdActivationArgument;
    public static string InterfaceTypeNameActivationArgument;
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static string GetCallerExtensionId(ServiceActivationOptions options);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static string GetInterfaceTypeName(ServiceActivationOptions options);
}
[GuidAttribute("8D8D52A3-2139-41AD-98CC-B0CF22D99118")]
public interface Microsoft.VisualStudio.Shell.Internal.SolutionView.IVsSolutionViewWorkspaceProvider {
    public abstract virtual Task`1<Object[]> GetWorkspaceProvidersAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> AreProvidersActiveAsync(CancellationToken cancellationToken);
}
[GuidAttribute("3285BF32-D1B8-4033-8ED6-079A8A49AB81")]
public interface Microsoft.VisualStudio.Shell.Internal.SolutionView.SVsSolutionViewWorkspaceProvider {
}
public enum Microsoft.VisualStudio.Shell.Internal.StorageItemType : Enum {
    public int value__;
    public static StorageItemType Folder;
    public static StorageItemType File;
    public static StorageItemType Solution;
}
[GuidAttribute("E4AEFFD9-A187-4AE9-A985-D873F026BBB0")]
public interface Microsoft.VisualStudio.Shell.Internal.SVsCloudEnvironmentInformation {
}
[GuidAttribute("17215FC9-C7E7-4E82-8FFC-C107086C9B1F")]
public interface Microsoft.VisualStudio.Shell.Internal.SVsFileFolderPicker {
}
[GuidAttribute("b24f9cf1-99cc-4b85-adcb-466a7028fc21")]
public interface Microsoft.VisualStudio.Shell.Internal.SVsScenarioDiagnosticsManager {
}
[GuidAttribute("F09E59BD-F7B6-4DA8-BD74-91C989759B7F")]
public interface Microsoft.VisualStudio.Shell.Internal.SVsWorkflowDialogService {
}
[GuidAttribute("39ED3B05-E1BE-4E6A-BD53-3405009A2AED")]
public interface Microsoft.VisualStudio.Shell.Internal.ToastNotifications.IVsToast {
    public Guid Id { get; }
    public VsToastStatus Status { get; }
    public object Context { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_Dismissed(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Dismissed(EventHandler value);
    public abstract virtual Guid get_Id();
    public abstract virtual VsToastStatus get_Status();
    public abstract virtual object get_Context();
    public abstract virtual Task CloseToastAsync(CancellationToken cancellationToken);
}
[GuidAttribute("BC9E1AC2-098D-4016-8F4C-B4CCF345388E")]
public interface Microsoft.VisualStudio.Shell.Internal.ToastNotifications.IVsToastConfiguration {
    public Guid SourceId { get; }
    public string Name { get; }
    public abstract virtual Guid get_SourceId();
    public abstract virtual string get_Name();
}
[GuidAttribute("BC9E1AC2-098D-4016-8F4C-B4CCF345388E")]
public interface Microsoft.VisualStudio.Shell.Internal.ToastNotifications.IVsToastConfigurationBuilder {
    public abstract virtual IVsToastConfiguration Build();
    public abstract virtual IVsToastConfigurationBuilder SetAction(UInt32 index, string text, Guid commandSet, int commandId, bool shouldCloseOnInvoke);
    public abstract virtual IVsToastConfigurationBuilder SetAction(UInt32 index, string text, VsToastKnownAction knownAction);
    public abstract virtual IVsToastConfigurationBuilder SetIsSticky(bool isSticky);
}
[GuidAttribute("CB060526-125C-4FAB-9671-FE2815EB2F2E")]
public interface Microsoft.VisualStudio.Shell.Internal.ToastNotifications.IVsToastService {
    public abstract virtual VsToastSourceCapabilities GetSourceCapability(Guid sourceId);
    public abstract virtual IVsToastConfigurationBuilder GetConfigurationBuilder(Guid sourceId, string configurationName);
    public abstract virtual IVsToast ShowToast(IVsToastConfiguration toastConfiguration, string detail, string title, object context, String[] actionArguments);
    public abstract virtual IEnumerable`1<IVsToast> GetToasts(Guid sourceId);
}
[GuidAttribute("7EB3DA8F-C65B-4699-A33A-B48560CC4F1C")]
public interface Microsoft.VisualStudio.Shell.Internal.ToastNotifications.SVsToastService {
}
[GuidAttribute("A7EB92D3-BC56-49D0-B300-51A8B6E9757A")]
public enum Microsoft.VisualStudio.Shell.Internal.ToastNotifications.VsToastKnownAction : Enum {
    public int value__;
    public static VsToastKnownAction Unknown;
    public static VsToastKnownAction OpenSystemBrowser;
}
[FlagsAttribute]
public enum Microsoft.VisualStudio.Shell.Internal.ToastNotifications.VsToastSourceCapabilities : Enum {
    public int value__;
    public static VsToastSourceCapabilities None;
    public static VsToastSourceCapabilities Default;
    public static VsToastSourceCapabilities Informational;
    public static VsToastSourceCapabilities VsCommandAction;
    public static VsToastSourceCapabilities Sticky;
}
[FlagsAttribute]
public enum Microsoft.VisualStudio.Shell.Internal.ToastNotifications.VsToastStatus : Enum {
    public int value__;
    public static VsToastStatus Unknown;
    public static VsToastStatus UnknownSource;
    public static VsToastStatus Fail;
    public static VsToastStatus Pending;
    public static VsToastStatus Visible;
    public static VsToastStatus Expired;
    public static VsToastStatus Dismissed;
    public static VsToastStatus Invoked;
    public static VsToastStatus ForceClosed;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Shell.Internal.VsExtensionMetadataService : object {
    private IInternalExtensionMetadataService extensionMetadataService;
    [CompilerGeneratedAttribute]
private ExtensibilityDiagnosticsLoggerConfiguration <Diagnostics>k__BackingField;
    public ExtensibilityDiagnosticsLoggerConfiguration Diagnostics { get; }
    private VsExtensionMetadataService(IInternalExtensionMetadataService extensionMetadataService, ExtensibilityDiagnosticsLoggerConfiguration diagnostics);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Shell.Internal.VsExtensionMetadataService/<CreateAsync>d__2")]
public static Task`1<IVsExtensionMetadataService> CreateAsync(string logId, string featureArea, IServiceBroker serviceBroker, JoinableTaskFactory jtf, TraceSource traceSource, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public sealed virtual ExtensibilityDiagnosticsLoggerConfiguration get_Diagnostics();
    public sealed virtual void Dispose();
    public sealed virtual Task`1<IDisposable> SubscribeForMetadataEventsAsync(IEnumerable`1<string> sectionNames, IObserver`1<ExtensionMetadata> observer, CancellationToken cancellationToken);
    public Task`1<IDisposable> SubscribeAsync(IReadOnlyList`1<string> sectionNames, IExtensionMetadataObserver observer, IReadOnlyList`1<string> dependentSections, CancellationToken cancellationToken);
    private sealed virtual override Task`1<IDisposable> Microsoft.Internal.VisualStudio.Extensibility.Framework.IInternalExtensionMetadataService.SubscribeAsync(IReadOnlyList`1<string> sectionNames, IExtensionMetadataObserver observer, IReadOnlyList`1<string> dependentSections, CancellationToken cancellationToken);
}
public enum Microsoft.VisualStudio.Shell.Internal.VsSetupCompositionHotloadResult : Enum {
    public int value__;
    public static VsSetupCompositionHotloadResult Success;
    public static VsSetupCompositionHotloadResult ExtensionNotSupported;
    public static VsSetupCompositionHotloadResult UserCancelled;
    public static VsSetupCompositionHotloadResult AnotherInstallationRunning;
    public static VsSetupCompositionHotloadResult GeneralError;
}
public enum Microsoft.VisualStudio.Shell.KnownClientContextNames.Categories : Enum {
    public int value__;
    public static Categories Shell;
    public static Categories Editor;
}
public enum Microsoft.VisualStudio.Shell.KnownClientContextNames.ShellProperties : Enum {
    public int value__;
    public static ShellProperties ActiveSelectionFileName;
    public static ShellProperties ActiveSelectionPath;
    public static ShellProperties ActiveSelectionUri;
    public static ShellProperties ActiveEditorContentType;
    public static ShellProperties ActiveEditorFileName;
    public static ShellProperties ActiveProjectIdentifier;
    public static ShellProperties SelectedItemCount;
    public static ShellProperties SelectedFileItemCount;
}
[GuidAttribute("4edf80a3-7817-4ccd-b3c9-8c393ee9bd7b")]
public interface Microsoft.VisualStudio.Shell.SVsClientContextService {
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("2240")]
internal class System.Diagnostics.CodeAnalysis.UnscopedRefAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Runtime.CompilerServices.CallerArgumentExpressionAttribute : Attribute {
    internal CallerArgumentExpressionAttribute(string parameterName);
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal static class System.Runtime.CompilerServices.IsExternalInit : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NativeIntegerAttribute : Attribute {
    public Boolean[] TransformFlags;
    public NativeIntegerAttribute(Boolean[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[GeneratedCodeAttribute("Nerdbank.GitVersioning.Tasks", "3.6.133.12845")]
[ExcludeFromCodeCoverageAttribute]
internal static class ThisAssembly : object {
    internal static string AssemblyConfiguration;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyVersion;
    internal static DateTime GitCommitDate;
    internal static string GitCommitId;
    internal static bool IsPrerelease;
    internal static bool IsPublicRelease;
    internal static string RootNamespace;
    private static ThisAssembly();
}
[DefaultMemberAttribute("Item")]
internal class Windows.Win32.__byte_1 : ValueType {
    private static int SpanLength;
    [FixedBufferAttribute("System.Byte", "1")]
internal <Value>e__FixedBuffer Value;
    internal int Length { get; }
    [UnscopedRefAttribute]
internal Byte& Item { get; }
    [IsReadOnlyAttribute]
internal int get_Length();
    internal Byte& get_Item(int index);
    [IsReadOnlyAttribute]
internal void CopyTo(Span`1<byte> target, int length);
    [IsReadOnlyAttribute]
internal Byte[] ToArray(int length);
    [IsReadOnlyAttribute]
internal bool Equals(ReadOnlySpan`1<byte> value);
    public static __byte_1 op_Implicit(ReadOnlySpan`1<byte> value);
}
[DefaultMemberAttribute("Item")]
internal class Windows.Win32.__char_1 : ValueType {
    private static int SpanLength;
    [FixedBufferAttribute("System.Char", "1")]
internal <Value>e__FixedBuffer Value;
    internal int Length { get; }
    [UnscopedRefAttribute]
internal Char& Item { get; }
    [IsReadOnlyAttribute]
internal int get_Length();
    internal Char& get_Item(int index);
    [IsReadOnlyAttribute]
internal void CopyTo(Span`1<char> target, int length);
    [IsReadOnlyAttribute]
internal Char[] ToArray(int length);
    [IsReadOnlyAttribute]
internal bool Equals(ReadOnlySpan`1<char> value);
    [IsReadOnlyAttribute]
internal bool Equals(string value);
    [IsReadOnlyAttribute]
internal string ToString(int length);
    [IsReadOnlyAttribute]
public virtual string ToString();
    public static __char_1 op_Implicit(string value);
    public static __char_1 op_Implicit(ReadOnlySpan`1<char> value);
}
[DefaultMemberAttribute("Item")]
internal class Windows.Win32.__char_200 : ValueType {
    private static int SpanLength;
    [FixedBufferAttribute("System.Char", "200")]
internal <Value>e__FixedBuffer Value;
    internal int Length { get; }
    [UnscopedRefAttribute]
internal Char& Item { get; }
    [IsReadOnlyAttribute]
internal int get_Length();
    internal Char& get_Item(int index);
    [IsReadOnlyAttribute]
internal void CopyTo(Span`1<char> target, int length);
    [IsReadOnlyAttribute]
internal Char[] ToArray(int length);
    [IsReadOnlyAttribute]
internal bool Equals(ReadOnlySpan`1<char> value);
    [IsReadOnlyAttribute]
internal bool Equals(string value);
    [IsReadOnlyAttribute]
internal string ToString(int length);
    [IsReadOnlyAttribute]
public virtual string ToString();
    public static __char_200 op_Implicit(string value);
    public static __char_200 op_Implicit(ReadOnlySpan`1<char> value);
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
internal enum Windows.Win32.Devices.DeviceAndDriverInstallation.CM_NOTIFY_ACTION : Enum {
    public int value__;
    public static CM_NOTIFY_ACTION CM_NOTIFY_ACTION_DEVICEINTERFACEARRIVAL;
    public static CM_NOTIFY_ACTION CM_NOTIFY_ACTION_DEVICEINTERFACEREMOVAL;
    public static CM_NOTIFY_ACTION CM_NOTIFY_ACTION_DEVICEQUERYREMOVE;
    public static CM_NOTIFY_ACTION CM_NOTIFY_ACTION_DEVICEQUERYREMOVEFAILED;
    public static CM_NOTIFY_ACTION CM_NOTIFY_ACTION_DEVICEREMOVEPENDING;
    public static CM_NOTIFY_ACTION CM_NOTIFY_ACTION_DEVICEREMOVECOMPLETE;
    public static CM_NOTIFY_ACTION CM_NOTIFY_ACTION_DEVICECUSTOMEVENT;
    public static CM_NOTIFY_ACTION CM_NOTIFY_ACTION_DEVICEINSTANCEENUMERATED;
    public static CM_NOTIFY_ACTION CM_NOTIFY_ACTION_DEVICEINSTANCESTARTED;
    public static CM_NOTIFY_ACTION CM_NOTIFY_ACTION_DEVICEINSTANCEREMOVED;
    public static CM_NOTIFY_ACTION CM_NOTIFY_ACTION_MAX;
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
internal class Windows.Win32.Devices.DeviceAndDriverInstallation.CM_NOTIFY_EVENT_DATA : ValueType {
    internal CM_NOTIFY_FILTER_TYPE FilterType;
    internal UInt32 Reserved;
    internal _u_e__Union u;
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
internal class Windows.Win32.Devices.DeviceAndDriverInstallation.CM_NOTIFY_FILTER : ValueType {
    internal UInt32 cbSize;
    internal UInt32 Flags;
    internal CM_NOTIFY_FILTER_TYPE FilterType;
    internal UInt32 Reserved;
    internal _u_e__Union u;
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
internal enum Windows.Win32.Devices.DeviceAndDriverInstallation.CM_NOTIFY_FILTER_TYPE : Enum {
    public int value__;
    public static CM_NOTIFY_FILTER_TYPE CM_NOTIFY_FILTER_TYPE_DEVICEINTERFACE;
    public static CM_NOTIFY_FILTER_TYPE CM_NOTIFY_FILTER_TYPE_DEVICEHANDLE;
    public static CM_NOTIFY_FILTER_TYPE CM_NOTIFY_FILTER_TYPE_DEVICEINSTANCE;
    public static CM_NOTIFY_FILTER_TYPE CM_NOTIFY_FILTER_TYPE_MAX;
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
internal enum Windows.Win32.Devices.DeviceAndDriverInstallation.CONFIGRET : Enum {
    public UInt32 value__;
    public static CONFIGRET CR_SUCCESS;
    public static CONFIGRET CR_DEFAULT;
    public static CONFIGRET CR_OUT_OF_MEMORY;
    public static CONFIGRET CR_INVALID_POINTER;
    public static CONFIGRET CR_INVALID_FLAG;
    public static CONFIGRET CR_INVALID_DEVNODE;
    public static CONFIGRET CR_INVALID_DEVINST;
    public static CONFIGRET CR_INVALID_RES_DES;
    public static CONFIGRET CR_INVALID_LOG_CONF;
    public static CONFIGRET CR_INVALID_ARBITRATOR;
    public static CONFIGRET CR_INVALID_NODELIST;
    public static CONFIGRET CR_DEVNODE_HAS_REQS;
    public static CONFIGRET CR_DEVINST_HAS_REQS;
    public static CONFIGRET CR_INVALID_RESOURCEID;
    public static CONFIGRET CR_DLVXD_NOT_FOUND;
    public static CONFIGRET CR_NO_SUCH_DEVNODE;
    public static CONFIGRET CR_NO_SUCH_DEVINST;
    public static CONFIGRET CR_NO_MORE_LOG_CONF;
    public static CONFIGRET CR_NO_MORE_RES_DES;
    public static CONFIGRET CR_ALREADY_SUCH_DEVNODE;
    public static CONFIGRET CR_ALREADY_SUCH_DEVINST;
    public static CONFIGRET CR_INVALID_RANGE_LIST;
    public static CONFIGRET CR_INVALID_RANGE;
    public static CONFIGRET CR_FAILURE;
    public static CONFIGRET CR_NO_SUCH_LOGICAL_DEV;
    public static CONFIGRET CR_CREATE_BLOCKED;
    public static CONFIGRET CR_NOT_SYSTEM_VM;
    public static CONFIGRET CR_REMOVE_VETOED;
    public static CONFIGRET CR_APM_VETOED;
    public static CONFIGRET CR_INVALID_LOAD_TYPE;
    public static CONFIGRET CR_BUFFER_SMALL;
    public static CONFIGRET CR_NO_ARBITRATOR;
    public static CONFIGRET CR_NO_REGISTRY_HANDLE;
    public static CONFIGRET CR_REGISTRY_ERROR;
    public static CONFIGRET CR_INVALID_DEVICE_ID;
    public static CONFIGRET CR_INVALID_DATA;
    public static CONFIGRET CR_INVALID_API;
    public static CONFIGRET CR_DEVLOADER_NOT_READY;
    public static CONFIGRET CR_NEED_RESTART;
    public static CONFIGRET CR_NO_MORE_HW_PROFILES;
    public static CONFIGRET CR_DEVICE_NOT_THERE;
    public static CONFIGRET CR_NO_SUCH_VALUE;
    public static CONFIGRET CR_WRONG_TYPE;
    public static CONFIGRET CR_INVALID_PRIORITY;
    public static CONFIGRET CR_NOT_DISABLEABLE;
    public static CONFIGRET CR_FREE_RESOURCES;
    public static CONFIGRET CR_QUERY_VETOED;
    public static CONFIGRET CR_CANT_SHARE_IRQ;
    public static CONFIGRET CR_NO_DEPENDENT;
    public static CONFIGRET CR_SAME_RESOURCES;
    public static CONFIGRET CR_NO_SUCH_REGISTRY_KEY;
    public static CONFIGRET CR_INVALID_MACHINENAME;
    public static CONFIGRET CR_REMOTE_COMM_FAILURE;
    public static CONFIGRET CR_MACHINE_UNAVAILABLE;
    public static CONFIGRET CR_NO_CM_SERVICES;
    public static CONFIGRET CR_ACCESS_DENIED;
    public static CONFIGRET CR_CALL_NOT_IMPLEMENTED;
    public static CONFIGRET CR_INVALID_PROPERTY;
    public static CONFIGRET CR_DEVICE_INTERFACE_ACTIVE;
    public static CONFIGRET CR_NO_SUCH_DEVICE_INTERFACE;
    public static CONFIGRET CR_INVALID_REFERENCE_STRING;
    public static CONFIGRET CR_INVALID_CONFLICT_LIST;
    public static CONFIGRET CR_INVALID_INDEX;
    public static CONFIGRET CR_INVALID_STRUCTURE_SIZE;
    public static CONFIGRET NUM_CR_RESULTS;
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{Value}")]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
internal class Windows.Win32.Devices.DeviceAndDriverInstallation.HCMNOTIFICATION : ValueType {
    [NativeIntegerAttribute]
internal IntPtr Value;
    internal HCMNOTIFICATION(IntPtr value);
    public static IntPtr op_Implicit(HCMNOTIFICATION value);
    public static HCMNOTIFICATION op_Explicit(IntPtr value);
    public static bool op_Equality(HCMNOTIFICATION left, HCMNOTIFICATION right);
    public static bool op_Inequality(HCMNOTIFICATION left, HCMNOTIFICATION right);
    public sealed virtual bool Equals(HCMNOTIFICATION other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[UnmanagedFunctionPointerAttribute("1")]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
internal class Windows.Win32.Devices.DeviceAndDriverInstallation.PCM_NOTIFY_CALLBACK : MulticastDelegate {
    public PCM_NOTIFY_CALLBACK(object object, IntPtr method);
    public virtual UInt32 Invoke(HCMNOTIFICATION hNotify, Void* Context, CM_NOTIFY_ACTION Action, CM_NOTIFY_EVENT_DATA* EventData, UInt32 EventDataSize);
    public virtual IAsyncResult BeginInvoke(HCMNOTIFICATION hNotify, Void* Context, CM_NOTIFY_ACTION Action, CM_NOTIFY_EVENT_DATA* EventData, UInt32 EventDataSize, AsyncCallback callback, object object);
    public virtual UInt32 EndInvoke(IAsyncResult result);
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{Value}")]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
internal class Windows.Win32.Foundation.BOOL : ValueType {
    internal int Value;
    internal BOOL(int value);
    internal BOOL(bool value);
    public static int op_Implicit(BOOL value);
    public static BOOL op_Explicit(int value);
    public static bool op_Equality(BOOL left, BOOL right);
    public static bool op_Inequality(BOOL left, BOOL right);
    public sealed virtual bool Equals(BOOL other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Implicit(BOOL value);
    public static BOOL op_Implicit(bool value);
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
internal class Windows.Win32.Foundation.FARPROC : ValueType {
    internal IntPtr Value;
    internal static FARPROC Null { get; }
    internal bool IsNull { get; }
    internal FARPROC(IntPtr value);
    internal static FARPROC get_Null();
    internal bool get_IsNull();
    public static IntPtr op_Implicit(FARPROC value);
    public static FARPROC op_Explicit(IntPtr value);
    public static bool op_Equality(FARPROC left, FARPROC right);
    public static bool op_Inequality(FARPROC left, FARPROC right);
    public bool Equals(FARPROC other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    internal TDelegate CreateDelegate();
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{Value}")]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
internal class Windows.Win32.Foundation.HANDLE : ValueType {
    internal IntPtr Value;
    internal static HANDLE Null { get; }
    internal bool IsNull { get; }
    internal HANDLE(IntPtr value);
    internal static HANDLE get_Null();
    internal bool get_IsNull();
    public static IntPtr op_Implicit(HANDLE value);
    public static HANDLE op_Explicit(IntPtr value);
    public static bool op_Equality(HANDLE left, HANDLE right);
    public static bool op_Inequality(HANDLE left, HANDLE right);
    public sealed virtual bool Equals(HANDLE other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{Value}")]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
internal class Windows.Win32.Foundation.HINSTANCE : ValueType {
    internal IntPtr Value;
    internal static HINSTANCE Null { get; }
    internal bool IsNull { get; }
    internal HINSTANCE(IntPtr value);
    internal static HINSTANCE get_Null();
    internal bool get_IsNull();
    public static IntPtr op_Implicit(HINSTANCE value);
    public static HINSTANCE op_Explicit(IntPtr value);
    public static bool op_Equality(HINSTANCE left, HINSTANCE right);
    public static bool op_Inequality(HINSTANCE left, HINSTANCE right);
    public sealed virtual bool Equals(HINSTANCE other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static HMODULE op_Implicit(HINSTANCE value);
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{Value}")]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
internal class Windows.Win32.Foundation.HMODULE : ValueType {
    internal IntPtr Value;
    internal static HMODULE Null { get; }
    internal bool IsNull { get; }
    internal HMODULE(IntPtr value);
    internal static HMODULE get_Null();
    internal bool get_IsNull();
    public static IntPtr op_Implicit(HMODULE value);
    public static HMODULE op_Explicit(IntPtr value);
    public static bool op_Equality(HMODULE left, HMODULE right);
    public static bool op_Inequality(HMODULE left, HMODULE right);
    public sealed virtual bool Equals(HMODULE other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static HINSTANCE op_Implicit(HMODULE value);
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
internal class Windows.Win32.Foundation.PCSTR : ValueType {
    internal Byte* Value;
    internal int Length { get; }
    private string DebuggerDisplay { get; }
    internal PCSTR(Byte* value);
    public static Byte* op_Implicit(PCSTR value);
    public static PCSTR op_Explicit(Byte* value);
    public sealed virtual bool Equals(PCSTR other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal int get_Length();
    public virtual string ToString();
    internal ReadOnlySpan`1<byte> AsSpan();
    private string get_DebuggerDisplay();
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
internal class Windows.Win32.Foundation.PCWSTR : ValueType {
    internal Char* Value;
    internal int Length { get; }
    private string DebuggerDisplay { get; }
    internal PCWSTR(Char* value);
    public static Char* op_Explicit(PCWSTR value);
    public static PCWSTR op_Implicit(Char* value);
    public sealed virtual bool Equals(PCWSTR other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal int get_Length();
    public virtual string ToString();
    internal ReadOnlySpan`1<char> AsSpan();
    private string get_DebuggerDisplay();
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
internal class Windows.Win32.FreeLibrarySafeHandle : SafeHandle {
    private static IntPtr INVALID_HANDLE_VALUE;
    public bool IsInvalid { get; }
    internal FreeLibrarySafeHandle(IntPtr preexistingHandle, bool ownsHandle);
    private static FreeLibrarySafeHandle();
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
[ExtensionAttribute]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
internal static class Windows.Win32.InlineArrayIndexerExtensions : object {
    [ExtensionAttribute]
internal static ReadOnlySpan`1<char> SliceAtNull(ReadOnlySpan`1<char> value);
    [ExtensionAttribute]
internal static Char& modreq(System.Runtime.InteropServices.InAttribute) ReadOnlyItemRef(__char_1& this, int index);
    [ExtensionAttribute]
internal static Byte& modreq(System.Runtime.InteropServices.InAttribute) ReadOnlyItemRef(__byte_1& this, int index);
    [ExtensionAttribute]
internal static Char& modreq(System.Runtime.InteropServices.InAttribute) ReadOnlyItemRef(__char_200& this, int index);
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
internal static class Windows.Win32.PInvoke : object {
    internal static UInt32 FSCTL_QUERY_PERSISTENT_VOLUME_STATE;
    internal static Guid GUID_DEVINTERFACE_VOLUME;
    private static PInvoke();
    internal static CONFIGRET CM_Register_Notification(CM_NOTIFY_FILTER& pFilter, Void* pContext, PCM_NOTIFY_CALLBACK pCallback, HCMNOTIFICATION& pNotifyContext);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static CONFIGRET CM_Register_Notification(CM_NOTIFY_FILTER* pFilter, Void* pContext, PCM_NOTIFY_CALLBACK pCallback, HCMNOTIFICATION* pNotifyContext);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static CONFIGRET CM_Unregister_Notification(HCMNOTIFICATION NotifyContext);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static BOOL CloseHandle(HANDLE hObject);
    internal static SafeFileHandle CreateFile(string lpFileName, UInt32 dwDesiredAccess, FILE_SHARE_MODE dwShareMode, Nullable`1<SECURITY_ATTRIBUTES> lpSecurityAttributes, FILE_CREATION_DISPOSITION dwCreationDisposition, FILE_FLAGS_AND_ATTRIBUTES dwFlagsAndAttributes, SafeHandle hTemplateFile);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static HANDLE CreateFile(PCWSTR lpFileName, UInt32 dwDesiredAccess, FILE_SHARE_MODE dwShareMode, SECURITY_ATTRIBUTES* lpSecurityAttributes, FILE_CREATION_DISPOSITION dwCreationDisposition, FILE_FLAGS_AND_ATTRIBUTES dwFlagsAndAttributes, HANDLE hTemplateFile);
    internal static BOOL DeviceIoControl(SafeHandle hDevice, UInt32 dwIoControlCode, Void* lpInBuffer, UInt32 nInBufferSize, Void* lpOutBuffer, UInt32 nOutBufferSize, UInt32* lpBytesReturned, NativeOverlapped* lpOverlapped);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static BOOL DeviceIoControl(HANDLE hDevice, UInt32 dwIoControlCode, Void* lpInBuffer, UInt32 nInBufferSize, Void* lpOutBuffer, UInt32 nOutBufferSize, UInt32* lpBytesReturned, NativeOverlapped* lpOverlapped);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static BOOL FreeLibrary(HMODULE hLibModule);
    internal static FARPROC GetProcAddress(SafeHandle hModule, string lpProcName);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static FARPROC GetProcAddress(HMODULE hModule, PCSTR lpProcName);
    internal static FreeLibrarySafeHandle LoadLibrary(string lpLibFileName);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static HMODULE LoadLibrary(PCWSTR lpLibFileName);
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
internal class Windows.Win32.Security.SECURITY_ATTRIBUTES : ValueType {
    internal UInt32 nLength;
    internal Void* lpSecurityDescriptor;
    internal BOOL bInheritHandle;
}
[FlagsAttribute]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
internal enum Windows.Win32.Storage.FileSystem.FILE_ACCESS_RIGHTS : Enum {
    public UInt32 value__;
    public static FILE_ACCESS_RIGHTS FILE_READ_DATA;
    public static FILE_ACCESS_RIGHTS FILE_LIST_DIRECTORY;
    public static FILE_ACCESS_RIGHTS FILE_WRITE_DATA;
    public static FILE_ACCESS_RIGHTS FILE_ADD_FILE;
    public static FILE_ACCESS_RIGHTS FILE_APPEND_DATA;
    public static FILE_ACCESS_RIGHTS FILE_ADD_SUBDIRECTORY;
    public static FILE_ACCESS_RIGHTS FILE_CREATE_PIPE_INSTANCE;
    public static FILE_ACCESS_RIGHTS FILE_READ_EA;
    public static FILE_ACCESS_RIGHTS FILE_WRITE_EA;
    public static FILE_ACCESS_RIGHTS FILE_EXECUTE;
    public static FILE_ACCESS_RIGHTS FILE_TRAVERSE;
    public static FILE_ACCESS_RIGHTS FILE_DELETE_CHILD;
    public static FILE_ACCESS_RIGHTS FILE_READ_ATTRIBUTES;
    public static FILE_ACCESS_RIGHTS FILE_WRITE_ATTRIBUTES;
    public static FILE_ACCESS_RIGHTS DELETE;
    public static FILE_ACCESS_RIGHTS READ_CONTROL;
    public static FILE_ACCESS_RIGHTS WRITE_DAC;
    public static FILE_ACCESS_RIGHTS WRITE_OWNER;
    public static FILE_ACCESS_RIGHTS SYNCHRONIZE;
    public static FILE_ACCESS_RIGHTS STANDARD_RIGHTS_REQUIRED;
    public static FILE_ACCESS_RIGHTS STANDARD_RIGHTS_READ;
    public static FILE_ACCESS_RIGHTS STANDARD_RIGHTS_WRITE;
    public static FILE_ACCESS_RIGHTS STANDARD_RIGHTS_EXECUTE;
    public static FILE_ACCESS_RIGHTS STANDARD_RIGHTS_ALL;
    public static FILE_ACCESS_RIGHTS SPECIFIC_RIGHTS_ALL;
    public static FILE_ACCESS_RIGHTS FILE_ALL_ACCESS;
    public static FILE_ACCESS_RIGHTS FILE_GENERIC_READ;
    public static FILE_ACCESS_RIGHTS FILE_GENERIC_WRITE;
    public static FILE_ACCESS_RIGHTS FILE_GENERIC_EXECUTE;
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
internal enum Windows.Win32.Storage.FileSystem.FILE_CREATION_DISPOSITION : Enum {
    public UInt32 value__;
    public static FILE_CREATION_DISPOSITION CREATE_NEW;
    public static FILE_CREATION_DISPOSITION CREATE_ALWAYS;
    public static FILE_CREATION_DISPOSITION OPEN_EXISTING;
    public static FILE_CREATION_DISPOSITION OPEN_ALWAYS;
    public static FILE_CREATION_DISPOSITION TRUNCATE_EXISTING;
}
[FlagsAttribute]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
internal enum Windows.Win32.Storage.FileSystem.FILE_FLAGS_AND_ATTRIBUTES : Enum {
    public UInt32 value__;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_READONLY;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_HIDDEN;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_SYSTEM;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_DIRECTORY;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_ARCHIVE;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_DEVICE;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_NORMAL;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_TEMPORARY;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_SPARSE_FILE;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_REPARSE_POINT;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_COMPRESSED;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_OFFLINE;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_NOT_CONTENT_INDEXED;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_ENCRYPTED;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_INTEGRITY_STREAM;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_VIRTUAL;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_NO_SCRUB_DATA;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_EA;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_PINNED;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_UNPINNED;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_RECALL_ON_OPEN;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_RECALL_ON_DATA_ACCESS;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_WRITE_THROUGH;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_OVERLAPPED;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_NO_BUFFERING;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_RANDOM_ACCESS;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_SEQUENTIAL_SCAN;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_DELETE_ON_CLOSE;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_BACKUP_SEMANTICS;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_POSIX_SEMANTICS;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_SESSION_AWARE;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_OPEN_REPARSE_POINT;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_OPEN_NO_RECALL;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_FIRST_PIPE_INSTANCE;
    public static FILE_FLAGS_AND_ATTRIBUTES PIPE_ACCESS_DUPLEX;
    public static FILE_FLAGS_AND_ATTRIBUTES PIPE_ACCESS_INBOUND;
    public static FILE_FLAGS_AND_ATTRIBUTES PIPE_ACCESS_OUTBOUND;
    public static FILE_FLAGS_AND_ATTRIBUTES SECURITY_ANONYMOUS;
    public static FILE_FLAGS_AND_ATTRIBUTES SECURITY_IDENTIFICATION;
    public static FILE_FLAGS_AND_ATTRIBUTES SECURITY_IMPERSONATION;
    public static FILE_FLAGS_AND_ATTRIBUTES SECURITY_DELEGATION;
    public static FILE_FLAGS_AND_ATTRIBUTES SECURITY_CONTEXT_TRACKING;
    public static FILE_FLAGS_AND_ATTRIBUTES SECURITY_EFFECTIVE_ONLY;
    public static FILE_FLAGS_AND_ATTRIBUTES SECURITY_SQOS_PRESENT;
    public static FILE_FLAGS_AND_ATTRIBUTES SECURITY_VALID_SQOS_FLAGS;
}
[FlagsAttribute]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
internal enum Windows.Win32.Storage.FileSystem.FILE_SHARE_MODE : Enum {
    public UInt32 value__;
    public static FILE_SHARE_MODE FILE_SHARE_NONE;
    public static FILE_SHARE_MODE FILE_SHARE_DELETE;
    public static FILE_SHARE_MODE FILE_SHARE_READ;
    public static FILE_SHARE_MODE FILE_SHARE_WRITE;
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.49-beta+91f5c15987")]
internal class Windows.Win32.System.Ioctl.FILE_FS_PERSISTENT_VOLUME_INFORMATION : ValueType {
    internal UInt32 VolumeFlags;
    internal UInt32 FlagMask;
    internal UInt32 Version;
    internal UInt32 Reserved;
}
