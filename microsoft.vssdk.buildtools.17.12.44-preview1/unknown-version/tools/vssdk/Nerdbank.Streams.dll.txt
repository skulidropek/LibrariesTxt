[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class MessagePack.BufferWriter : ValueType {
    private IBufferWriter`1<byte> _output;
    private Span`1<byte> _span;
    private ArraySegment`1<byte> _segment;
    private int _buffered;
    private long _bytesCommitted;
    private SequencePool _sequencePool;
    private Rental _rental;
    public Span`1<byte> Span { get; }
    public long BytesCommitted { get; }
    internal IBufferWriter`1<byte> UnderlyingWriter { get; }
    internal Rental SequenceRental { get; }
    public BufferWriter(IBufferWriter`1<byte> output);
    internal BufferWriter(SequencePool sequencePool, Byte[] array);
    public Span`1<byte> get_Span();
    public long get_BytesCommitted();
    internal IBufferWriter`1<byte> get_UnderlyingWriter();
    internal Rental get_SequenceRental();
    public Span`1<byte> GetSpan(int sizeHint);
    public Byte& GetPointer(int sizeHint);
    public void Commit();
    public void Advance(int count);
    public void Write(ReadOnlySpan`1<byte> source);
    public void Ensure(int count);
    internal bool TryGetUncommittedSpan(ReadOnlySpan`1& span);
    private void EnsureMore(int count);
    private void WriteMultiBuffer(ReadOnlySpan`1<byte> source);
    private void MigrateToSequence();
}
internal class MessagePack.ExtensionHeader : ValueType {
    [CompilerGeneratedAttribute]
private sbyte <TypeCode>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Length>k__BackingField;
    public sbyte TypeCode { get; private set; }
    public UInt32 Length { get; private set; }
    public ExtensionHeader(sbyte typeCode, UInt32 length);
    public ExtensionHeader(sbyte typeCode, int length);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sbyte get_TypeCode();
    [CompilerGeneratedAttribute]
private void set_TypeCode(sbyte value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_Length();
    [CompilerGeneratedAttribute]
private void set_Length(UInt32 value);
    public sealed virtual bool Equals(ExtensionHeader other);
}
internal class MessagePack.ExtensionResult : ValueType {
    [CompilerGeneratedAttribute]
private sbyte <TypeCode>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlySequence`1<byte> <Data>k__BackingField;
    public sbyte TypeCode { get; private set; }
    public ReadOnlySequence`1<byte> Data { get; private set; }
    public ExtensionHeader Header { get; }
    public ExtensionResult(sbyte typeCode, Memory`1<byte> data);
    public ExtensionResult(sbyte typeCode, ReadOnlySequence`1<byte> data);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sbyte get_TypeCode();
    [CompilerGeneratedAttribute]
private void set_TypeCode(sbyte value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ReadOnlySequence`1<byte> get_Data();
    [CompilerGeneratedAttribute]
private void set_Data(ReadOnlySequence`1<byte> value);
    public ExtensionHeader get_Header();
}
internal static class MessagePack.Internal.DateTimeConstants : object {
    internal static long BclSecondsAtUnixEpoch;
    internal static int NanosecondsPerTick;
    internal static DateTime UnixEpoch;
    private static DateTimeConstants();
}
internal class MessagePack.Internal.GuidBits : ValueType {
    public Guid Value;
    public byte Byte0;
    public byte Byte1;
    public byte Byte2;
    public byte Byte3;
    public byte Byte4;
    public byte Byte5;
    public byte Byte6;
    public byte Byte7;
    public byte Byte8;
    public byte Byte9;
    public byte Byte10;
    public byte Byte11;
    public byte Byte12;
    public byte Byte13;
    public byte Byte14;
    public byte Byte15;
    public GuidBits(Guid& value);
    public GuidBits(ReadOnlySpan`1<byte> utf8string);
    private static ReadOnlySpan`1<byte> GetByteToHexStringHigh();
    private static ReadOnlySpan`1<byte> GetByteToHexStringLow();
    private static byte Parse(ReadOnlySpan`1<byte> bytes, int highOffset);
    private static byte SwitchParse(byte b);
    public void Write(Span`1<byte> buffer);
}
internal static class MessagePack.MessagePackCode : object {
    public static byte MinFixInt;
    public static byte MaxFixInt;
    public static byte MinFixMap;
    public static byte MaxFixMap;
    public static byte MinFixArray;
    public static byte MaxFixArray;
    public static byte MinFixStr;
    public static byte MaxFixStr;
    public static byte Nil;
    public static byte NeverUsed;
    public static byte False;
    public static byte True;
    public static byte Bin8;
    public static byte Bin16;
    public static byte Bin32;
    public static byte Ext8;
    public static byte Ext16;
    public static byte Ext32;
    public static byte Float32;
    public static byte Float64;
    public static byte UInt8;
    public static byte UInt16;
    public static byte UInt32;
    public static byte UInt64;
    public static byte Int8;
    public static byte Int16;
    public static byte Int32;
    public static byte Int64;
    public static byte FixExt1;
    public static byte FixExt2;
    public static byte FixExt4;
    public static byte FixExt8;
    public static byte FixExt16;
    public static byte Str8;
    public static byte Str16;
    public static byte Str32;
    public static byte Array16;
    public static byte Array32;
    public static byte Map16;
    public static byte Map32;
    public static byte MinNegativeFixInt;
    public static byte MaxNegativeFixInt;
    private static MessagePackType[] TypeLookupTable;
    private static String[] FormatNameTable;
    private static MessagePackCode();
    public static MessagePackType ToMessagePackType(byte code);
    public static string ToFormatName(byte code);
    internal static bool IsSignedInteger(byte code);
}
internal static class MessagePack.MessagePackRange : object {
    public static int MinFixNegativeInt;
    public static int MaxFixNegativeInt;
    public static int MaxFixPositiveInt;
    public static int MinFixStringLength;
    public static int MaxFixStringLength;
    public static int MaxFixMapCount;
    public static int MaxFixArrayCount;
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class MessagePack.MessagePackReader : ValueType {
    private SequenceReader`1<byte> reader;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Depth>k__BackingField;
    public CancellationToken CancellationToken { get; public set; }
    public int Depth { get; public set; }
    public ReadOnlySequence`1<byte> Sequence { get; }
    public SequencePosition Position { get; }
    public long Consumed { get; }
    public bool End { get; }
    public bool IsNil { get; }
    public MessagePackType NextMessagePackType { get; }
    public byte NextCode { get; }
    public MessagePackReader(ReadOnlyMemory`1<byte> memory);
    public MessagePackReader(ReadOnlySequence`1& readOnlySequence);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
public void set_CancellationToken(CancellationToken value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Depth();
    [CompilerGeneratedAttribute]
public void set_Depth(int value);
    public ReadOnlySequence`1<byte> get_Sequence();
    public SequencePosition get_Position();
    public long get_Consumed();
    public bool get_End();
    public bool get_IsNil();
    public MessagePackType get_NextMessagePackType();
    public byte get_NextCode();
    public MessagePackReader Clone(ReadOnlySequence`1& readOnlySequence);
    public MessagePackReader CreatePeekReader();
    public void Skip();
    internal bool TrySkip();
    public Nil ReadNil();
    public bool TryReadNil();
    public ReadOnlySequence`1<byte> ReadRaw(long length);
    public ReadOnlySequence`1<byte> ReadRaw();
    public int ReadArrayHeader();
    public bool TryReadArrayHeader(Int32& count);
    public int ReadMapHeader();
    public bool TryReadMapHeader(Int32& count);
    public bool ReadBoolean();
    public char ReadChar();
    public float ReadSingle();
    public double ReadDouble();
    public DateTime ReadDateTime();
    public DateTime ReadDateTime(ExtensionHeader header);
    public Nullable`1<ReadOnlySequence`1<byte>> ReadBytes();
    public Nullable`1<ReadOnlySequence`1<byte>> ReadStringSequence();
    public bool TryReadStringSpan(ReadOnlySpan`1& span);
    public string ReadString();
    public ExtensionHeader ReadExtensionFormatHeader();
    public bool TryReadExtensionFormatHeader(ExtensionHeader& extensionHeader);
    public ExtensionResult ReadExtensionFormat();
    private static EndOfStreamException ThrowNotEnoughBytesException();
    private static EndOfStreamException ThrowNotEnoughBytesException(Exception innerException);
    private static Exception ThrowInvalidCode(byte code);
    private static void ThrowInsufficientBufferUnless(bool condition);
    private int GetBytesLength();
    private bool TryGetBytesLength(Int32& length);
    private bool TryGetStringLengthInBytes(Int32& length);
    private int GetStringLengthInBytes();
    private bool TryGetStringLengthInBytesSlow(byte code, Int32& length);
    private string ReadStringSlow(int byteLength);
    private bool TrySkipNextArray();
    private bool TrySkipNextMap();
    private bool TrySkip(int count);
    public byte ReadByte();
    public ushort ReadUInt16();
    public UInt32 ReadUInt32();
    public ulong ReadUInt64();
    public sbyte ReadSByte();
    public short ReadInt16();
    public int ReadInt32();
    public long ReadInt64();
}
internal class MessagePack.MessagePackSerializationException : Exception {
    public MessagePackSerializationException(string message);
    public MessagePackSerializationException(string message, Exception inner);
    protected MessagePackSerializationException(SerializationInfo info, StreamingContext context);
}
internal class MessagePack.MessagePackStreamReader : object {
    private Stream stream;
    private bool leaveOpen;
    private Rental sequenceRental;
    private Nullable`1<SequencePosition> endOfLastMessage;
    public ReadOnlySequence`1<byte> RemainingBytes { get; }
    private Sequence`1<byte> ReadData { get; }
    public MessagePackStreamReader(Stream stream);
    public MessagePackStreamReader(Stream stream, bool leaveOpen);
    public ReadOnlySequence`1<byte> get_RemainingBytes();
    private Sequence`1<byte> get_ReadData();
    [AsyncStateMachineAttribute("MessagePack.MessagePackStreamReader/<ReadAsync>d__10")]
public ValueTask`1<Nullable`1<ReadOnlySequence`1<byte>>> ReadAsync(CancellationToken cancellationToken);
    public void DiscardBufferedData();
    public sealed virtual void Dispose();
    private void RecycleLastMessage();
    [AsyncStateMachineAttribute("MessagePack.MessagePackStreamReader/<TryReadMoreDataAsync>d__14")]
private Task`1<bool> TryReadMoreDataAsync(CancellationToken cancellationToken);
    private bool TryReadNextMessage(ReadOnlySequence`1& completeMessage);
}
internal enum MessagePack.MessagePackType : Enum {
    public byte value__;
    public static MessagePackType Unknown;
    public static MessagePackType Integer;
    public static MessagePackType Nil;
    public static MessagePackType Boolean;
    public static MessagePackType Float;
    public static MessagePackType String;
    public static MessagePackType Binary;
    public static MessagePackType Array;
    public static MessagePackType Map;
    public static MessagePackType Extension;
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class MessagePack.MessagePackWriter : ValueType {
    private BufferWriter writer;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OldSpec>k__BackingField;
    public CancellationToken CancellationToken { get; public set; }
    public bool OldSpec { get; public set; }
    public MessagePackWriter(IBufferWriter`1<byte> writer);
    internal MessagePackWriter(SequencePool sequencePool, Byte[] array);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
public void set_CancellationToken(CancellationToken value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_OldSpec();
    [CompilerGeneratedAttribute]
public void set_OldSpec(bool value);
    public MessagePackWriter Clone(IBufferWriter`1<byte> writer);
    public void Flush();
    public void WriteNil();
    public void WriteRaw(ReadOnlySpan`1<byte> rawMessagePackBlock);
    public void WriteRaw(ReadOnlySequence`1& rawMessagePackBlock);
    public void WriteArrayHeader(int count);
    public void WriteArrayHeader(UInt32 count);
    public void WriteMapHeader(int count);
    public void WriteMapHeader(UInt32 count);
    public void Write(byte value);
    public void WriteUInt8(byte value);
    public void Write(sbyte value);
    public void WriteInt8(sbyte value);
    public void Write(ushort value);
    public void WriteUInt16(ushort value);
    public void Write(short value);
    public void WriteInt16(short value);
    public void Write(UInt32 value);
    public void WriteUInt32(UInt32 value);
    public void Write(int value);
    public void WriteInt32(int value);
    public void Write(ulong value);
    public void WriteUInt64(ulong value);
    public void Write(long value);
    public void WriteInt64(long value);
    public void Write(bool value);
    public void Write(char value);
    public void Write(float value);
    public void Write(double value);
    public void Write(DateTime dateTime);
    public void Write(Byte[] src);
    public void Write(ReadOnlySpan`1<byte> src);
    public void Write(ReadOnlySequence`1& src);
    public void WriteBinHeader(int length);
    public void WriteString(ReadOnlySequence`1& utf8stringBytes);
    public void WriteString(ReadOnlySpan`1<byte> utf8stringBytes);
    public void WriteStringHeader(int byteCount);
    public void Write(string value);
    public void Write(ReadOnlySpan`1<char> value);
    public void WriteExtensionFormatHeader(ExtensionHeader extensionHeader);
    public void WriteExtensionFormat(ExtensionResult extensionData);
    public Span`1<byte> GetSpan(int length);
    public void Advance(int length);
    internal void WriteBigEndian(ushort value);
    internal void WriteBigEndian(UInt32 value);
    internal void WriteBigEndian(ulong value);
    internal Byte[] FlushAndGetArray();
    private static void WriteBigEndian(short value, Span`1<byte> span);
    private static void WriteBigEndian(int value, Span`1<byte> span);
    private static void WriteBigEndian(long value, Span`1<byte> span);
    private static void WriteBigEndian(ushort value, Span`1<byte> span);
    private static void WriteBigEndian(ushort value, Byte* span);
    private static void WriteBigEndian(UInt32 value, Span`1<byte> span);
    private static void WriteBigEndian(UInt32 value, Byte* span);
    private static void WriteBigEndian(ulong value, Span`1<byte> span);
    private static void WriteBigEndian(float value, Span`1<byte> span);
    private static void WriteBigEndian(double value, Span`1<byte> span);
    private Byte& WriteString_PrepareSpan(int characterLength, Int32& bufferSize, Int32& encodedBytesOffset);
    private void WriteString_PostEncoding(Byte* pBuffer, int estimatedOffset, int byteCount);
    private static void MemoryCopy(Void* source, Void* destination, long destinationSizeInBytes, long sourceBytesToCopy);
}
internal class MessagePack.Nil : ValueType {
    public static Nil Default;
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Nil other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal static class MessagePack.ReservedMessagePackExtensionTypeCode : object {
    public static sbyte DateTime;
}
internal class MessagePack.SequencePool : object {
    internal static SequencePool Shared;
    private static int MinimumSpanLength;
    private int maxSize;
    private Stack`1<Sequence`1<byte>> pool;
    private ArrayPool`1<byte> arrayPool;
    internal SequencePool(int maxSize);
    private static SequencePool();
    internal Rental Rent();
    private void Return(Sequence`1<byte> value);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class MessagePack.SequenceReader`1 : ValueType {
    private bool usingSequence;
    private ReadOnlySequence`1<T> sequence;
    private SequencePosition currentPosition;
    private SequencePosition nextPosition;
    private ReadOnlyMemory`1<T> memory;
    private bool moreData;
    private long length;
    [CompilerGeneratedAttribute]
private ReadOnlySpan`1<T> <CurrentSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentSpanIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Consumed>k__BackingField;
    public bool End { get; }
    public ReadOnlySequence`1<T> Sequence { get; }
    public SequencePosition Position { get; }
    public ReadOnlySpan`1<T> CurrentSpan { get; private set; }
    public int CurrentSpanIndex { get; private set; }
    public ReadOnlySpan`1<T> UnreadSpan { get; }
    public long Consumed { get; private set; }
    public long Remaining { get; }
    public long Length { get; }
    public SequenceReader`1(ReadOnlySequence`1& sequence);
    public SequenceReader`1(ReadOnlyMemory`1<T> memory);
    public bool get_End();
    public ReadOnlySequence`1<T> get_Sequence();
    public SequencePosition get_Position();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ReadOnlySpan`1<T> get_CurrentSpan();
    [CompilerGeneratedAttribute]
private void set_CurrentSpan(ReadOnlySpan`1<T> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_CurrentSpanIndex();
    [CompilerGeneratedAttribute]
private void set_CurrentSpanIndex(int value);
    public ReadOnlySpan`1<T> get_UnreadSpan();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_Consumed();
    [CompilerGeneratedAttribute]
private void set_Consumed(long value);
    public long get_Remaining();
    public long get_Length();
    public bool TryPeek(T& value);
    public bool TryRead(T& value);
    public void Rewind(long count);
    private void RetreatToPreviousSpan(long consumed);
    private void ResetReader();
    private void GetNextSpan();
    public void Advance(long count);
    internal void AdvanceCurrentSpan(long count);
    internal void AdvanceWithinSpan(long count);
    internal bool TryAdvance(long count);
    private void AdvanceToNextSpan(long count);
    public bool TryCopyTo(Span`1<T> destination);
    internal bool TryCopyMultisegment(Span`1<T> destination);
}
[ExtensionAttribute]
internal static class MessagePack.SequenceReaderExtensions : object {
    [ExtensionAttribute]
internal static bool TryRead(SequenceReader`1& reader, T& value);
    private static bool TryReadMultisegment(SequenceReader`1& reader, T& value);
    [ExtensionAttribute]
public static bool TryRead(SequenceReader`1& reader, SByte& value);
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, Int16& value);
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, UInt16& value);
    private static bool TryReadReverseEndianness(SequenceReader`1& reader, Int16& value);
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, Int32& value);
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, UInt32& value);
    private static bool TryReadReverseEndianness(SequenceReader`1& reader, Int32& value);
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, Int64& value);
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, UInt64& value);
    private static bool TryReadReverseEndianness(SequenceReader`1& reader, Int64& value);
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, Single& value);
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, Double& value);
}
[ExtensionAttribute]
internal static class MessagePack.StringEncoding : object {
    internal static Encoding UTF8;
    private static StringEncoding();
    [ExtensionAttribute]
internal static string GetString(Encoding encoding, ReadOnlySpan`1<byte> bytes);
}
[ExtensionAttribute]
internal static class MessagePack.Utilities : object {
    internal static bool IsMono;
    private static Utilities();
    internal static Byte[] GetWriterBytes(TArg arg, GetWriterBytesAction`1<TArg> action);
    [ExtensionAttribute]
internal static Memory`1<T> GetMemoryCheckResult(IBufferWriter`1<T> bufferWriter, int size);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Nerdbank.Streams.BufferTextWriter : TextWriter {
    private Char[] charBuffer;
    [NullableAttribute("2")]
private IBufferWriter`1<byte> bufferWriter;
    [NullableAttribute("0")]
private Memory`1<byte> memory;
    private int memoryPosition;
    private int charBufferPosition;
    private bool preambleWritten;
    [NullableAttribute("2")]
private Encoding encoding;
    [NullableAttribute("0")]
private ReadOnlyMemory`1<byte> encodingPreamble;
    [NullableAttribute("2")]
private Encoder encoder;
    public Encoding Encoding { get; }
    private int CharBufferSlack { get; }
    public BufferTextWriter(IBufferWriter`1<byte> bufferWriter, Encoding encoding);
    public virtual Encoding get_Encoding();
    private int get_CharBufferSlack();
    public void Initialize(IBufferWriter`1<byte> bufferWriter, Encoding encoding);
    public void Reset();
    public virtual void Flush();
    public virtual Task FlushAsync();
    public virtual void Write(char value);
    [NullableContextAttribute("2")]
public virtual void Write(string value);
    public virtual void Write(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual void Write(ReadOnlySpan`1<char> buffer);
    [NullableContextAttribute("0")]
public virtual void WriteLine(ReadOnlySpan`1<char> buffer);
    protected virtual void Dispose(bool disposing);
    private void EncodeCharactersIfBufferFull();
    private void EncodeCharacters(bool flushEncoder);
    private void CommitBytes();
    private void ThrowIfNotInitialized();
}
[ExtensionAttribute]
public static class Nerdbank.Streams.BufferWriterExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void Write(IBufferWriter`1<T> writer, ReadOnlySequence`1<T> sequence);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Nerdbank.Streams.BufferWriterStream : Stream {
    private IBufferWriter`1<byte> writer;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public bool IsDisposed { get; private set; }
    internal BufferWriterStream(IBufferWriter`1<byte> writer);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
    protected virtual void Dispose(bool disposing);
    private T ReturnOrThrowDisposed(T value);
    private Exception ThrowDisposedOr(Exception ex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Nerdbank.Streams.DuplexPipe : object {
    [CompilerGeneratedAttribute]
private PipeReader <Input>k__BackingField;
    [CompilerGeneratedAttribute]
private PipeWriter <Output>k__BackingField;
    public PipeReader Input { get; }
    public PipeWriter Output { get; }
    [NullableContextAttribute("2")]
public DuplexPipe(PipeReader input, PipeWriter output);
    public DuplexPipe(PipeReader input);
    public DuplexPipe(PipeWriter output);
    [CompilerGeneratedAttribute]
public sealed virtual PipeReader get_Input();
    [CompilerGeneratedAttribute]
public sealed virtual PipeWriter get_Output();
    internal static bool IsDefinitelyCompleted(PipeReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Nerdbank.Streams.FullDuplexStream : object {
    [NullableContextAttribute("2")]
public static ValueTuple`2<Stream, Stream> CreatePair(PipeOptions pipeOptions);
    [NullableContextAttribute("2")]
public static ValueTuple`2<IDuplexPipe, IDuplexPipe> CreatePipePair(PipeOptions pipeOptions);
    public static Stream Splice(Stream readableStream, Stream writableStream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute("Use SimplexStream instead.")]
public class Nerdbank.Streams.HalfDuplexStream : Stream {
    private Pipe pipe;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    public bool IsDisposed { get; private set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public HalfDuplexStream(int resumeWriterThreshold, int pauseWriterThreshold);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public void CompleteWriting();
    [AsyncStateMachineAttribute("Nerdbank.Streams.HalfDuplexStream/<FlushAsync>d__19")]
public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    [AsyncStateMachineAttribute("Nerdbank.Streams.HalfDuplexStream/<ReadAsync>d__22")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    private sealed virtual override void System.Buffers.IBufferWriter<System.Byte>.Advance(int count);
    [NullableContextAttribute("0")]
private sealed virtual override Memory`1<byte> System.Buffers.IBufferWriter<System.Byte>.GetMemory(int sizeHint);
    [NullableContextAttribute("0")]
private sealed virtual override Span`1<byte> System.Buffers.IBufferWriter<System.Byte>.GetSpan(int sizeHint);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    protected virtual void Dispose(bool disposing);
    private Exception ThrowDisposedOr(Exception ex);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Nerdbank.Streams.MonitoringStream : Stream {
    [NullableAttribute("1")]
private Stream inner;
    private bool endOfStreamRaised;
    [CompilerGeneratedAttribute]
private EventHandler EndOfStream;
    [CompilerGeneratedAttribute]
private EventHandler`1<long> DidSeek;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<ArraySegment`1<byte>> WillRead;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<ArraySegment`1<byte>> DidRead;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<Memory`1<byte>> WillReadMemory;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<Memory`1<byte>> DidReadMemory;
    [CompilerGeneratedAttribute]
private SpanEventHandler WillReadSpan;
    [CompilerGeneratedAttribute]
private SpanEventHandler DidReadSpan;
    [CompilerGeneratedAttribute]
private ReadOnlySpanEventHandler WillWriteSpan;
    [CompilerGeneratedAttribute]
private ReadOnlySpanEventHandler DidWriteSpan;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<ReadOnlyMemory`1<byte>> WillWriteMemory;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<ReadOnlyMemory`1<byte>> DidWriteMemory;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<ArraySegment`1<byte>> WillWrite;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<ArraySegment`1<byte>> DidWrite;
    [CompilerGeneratedAttribute]
private EventHandler`1<long> WillSetLength;
    [CompilerGeneratedAttribute]
private EventHandler`1<long> DidSetLength;
    [CompilerGeneratedAttribute]
private EventHandler WillReadByte;
    [CompilerGeneratedAttribute]
private EventHandler`1<int> DidReadByte;
    [CompilerGeneratedAttribute]
private EventHandler`1<byte> WillWriteByte;
    [CompilerGeneratedAttribute]
private EventHandler`1<byte> DidWriteByte;
    [CompilerGeneratedAttribute]
private EventHandler DidFlush;
    [CompilerGeneratedAttribute]
private EventHandler Disposed;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    public bool IsDisposed { get; private set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public bool CanTimeout { get; }
    [NullableContextAttribute("1")]
public MonitoringStream(Stream inner);
    [CompilerGeneratedAttribute]
public void add_EndOfStream(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_EndOfStream(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_DidSeek(EventHandler`1<long> value);
    [CompilerGeneratedAttribute]
public void remove_DidSeek(EventHandler`1<long> value);
    [CompilerGeneratedAttribute]
public void add_WillRead(EventHandler`1<ArraySegment`1<byte>> value);
    [CompilerGeneratedAttribute]
public void remove_WillRead(EventHandler`1<ArraySegment`1<byte>> value);
    [CompilerGeneratedAttribute]
public void add_DidRead(EventHandler`1<ArraySegment`1<byte>> value);
    [CompilerGeneratedAttribute]
public void remove_DidRead(EventHandler`1<ArraySegment`1<byte>> value);
    [CompilerGeneratedAttribute]
public void add_WillReadMemory(EventHandler`1<Memory`1<byte>> value);
    [CompilerGeneratedAttribute]
public void remove_WillReadMemory(EventHandler`1<Memory`1<byte>> value);
    [CompilerGeneratedAttribute]
public void add_DidReadMemory(EventHandler`1<Memory`1<byte>> value);
    [CompilerGeneratedAttribute]
public void remove_DidReadMemory(EventHandler`1<Memory`1<byte>> value);
    [CompilerGeneratedAttribute]
public void add_WillReadSpan(SpanEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_WillReadSpan(SpanEventHandler value);
    [CompilerGeneratedAttribute]
public void add_DidReadSpan(SpanEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_DidReadSpan(SpanEventHandler value);
    [CompilerGeneratedAttribute]
public void add_WillWriteSpan(ReadOnlySpanEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_WillWriteSpan(ReadOnlySpanEventHandler value);
    [CompilerGeneratedAttribute]
public void add_DidWriteSpan(ReadOnlySpanEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_DidWriteSpan(ReadOnlySpanEventHandler value);
    [CompilerGeneratedAttribute]
public void add_WillWriteMemory(EventHandler`1<ReadOnlyMemory`1<byte>> value);
    [CompilerGeneratedAttribute]
public void remove_WillWriteMemory(EventHandler`1<ReadOnlyMemory`1<byte>> value);
    [CompilerGeneratedAttribute]
public void add_DidWriteMemory(EventHandler`1<ReadOnlyMemory`1<byte>> value);
    [CompilerGeneratedAttribute]
public void remove_DidWriteMemory(EventHandler`1<ReadOnlyMemory`1<byte>> value);
    [CompilerGeneratedAttribute]
public void add_WillWrite(EventHandler`1<ArraySegment`1<byte>> value);
    [CompilerGeneratedAttribute]
public void remove_WillWrite(EventHandler`1<ArraySegment`1<byte>> value);
    [CompilerGeneratedAttribute]
public void add_DidWrite(EventHandler`1<ArraySegment`1<byte>> value);
    [CompilerGeneratedAttribute]
public void remove_DidWrite(EventHandler`1<ArraySegment`1<byte>> value);
    [CompilerGeneratedAttribute]
public void add_WillSetLength(EventHandler`1<long> value);
    [CompilerGeneratedAttribute]
public void remove_WillSetLength(EventHandler`1<long> value);
    [CompilerGeneratedAttribute]
public void add_DidSetLength(EventHandler`1<long> value);
    [CompilerGeneratedAttribute]
public void remove_DidSetLength(EventHandler`1<long> value);
    [CompilerGeneratedAttribute]
public void add_WillReadByte(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_WillReadByte(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_DidReadByte(EventHandler`1<int> value);
    [CompilerGeneratedAttribute]
public void remove_DidReadByte(EventHandler`1<int> value);
    [CompilerGeneratedAttribute]
public void add_WillWriteByte(EventHandler`1<byte> value);
    [CompilerGeneratedAttribute]
public void remove_WillWriteByte(EventHandler`1<byte> value);
    [CompilerGeneratedAttribute]
public void add_DidWriteByte(EventHandler`1<byte> value);
    [CompilerGeneratedAttribute]
public void remove_DidWriteByte(EventHandler`1<byte> value);
    [CompilerGeneratedAttribute]
public void add_DidFlush(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_DidFlush(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_Disposed(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Disposed(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual bool get_CanTimeout();
    public virtual void Flush();
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Nerdbank.Streams.MonitoringStream/<FlushAsync>d__95")]
public virtual Task FlushAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public virtual int Read(Byte[] buffer, int offset, int count);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Nerdbank.Streams.MonitoringStream/<ReadAsync>d__97")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    [NullableContextAttribute("1")]
public virtual void Write(Byte[] buffer, int offset, int count);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Nerdbank.Streams.MonitoringStream/<WriteAsync>d__101")]
public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual void WriteByte(byte value);
    protected virtual void Dispose(bool disposing);
    private void RaiseEndOfStreamIfNecessary(int bytesRead);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Nerdbank.Streams.MultiplexingProtocolException : Exception {
    public MultiplexingProtocolException(string message);
    public MultiplexingProtocolException(string message, Exception inner);
    [NullableContextAttribute("1")]
protected MultiplexingProtocolException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Nerdbank.Streams.MultiplexingStream : object {
    private static int ControlChannelId;
    private static int FramePayloadMaxLength;
    private static Encoding ControlFrameEncoding;
    private static ChannelOptions DefaultChannelOptions;
    private Nullable`1<bool> isOdd;
    private Formatter formatter;
    private object syncObject;
    private Dictionary`2<string, Queue`1<Channel>> channelsOfferedByThemByName;
    private Dictionary`2<string, Queue`1<TaskCompletionSource`1<Channel>>> acceptingChannels;
    private Dictionary`2<QualifiedChannelId, Channel> openChannels;
    private HashSet`1<QualifiedChannelId> channelsPendingTermination;
    private SemaphoreSlim sendingSemaphore;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private TaskCompletionSource`1<object> completionSource;
    private CancellationTokenSource disposalTokenSource;
    private int protocolMajorVersion;
    private bool faultOpenChannelsOnStreamDisposal;
    private long lastOfferedChannelId;
    private bool listeningStarted;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<ChannelOfferEventArgs> ChannelOffered;
    [CompilerGeneratedAttribute]
private TraceSource <TraceSource>k__BackingField;
    [CompilerGeneratedAttribute]
private long <DefaultChannelReceivingWindowSize>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`3<QualifiedChannelId, string, TraceSource> <DefaultChannelTraceSourceFactory>k__BackingField;
    public Task Completion { get; }
    public TraceSource TraceSource { get; }
    public long DefaultChannelReceivingWindowSize { get; }
    private bool Microsoft.IDisposableObservable.IsDisposed { get; }
    internal CancellationToken DisposalToken { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`3<QualifiedChannelId, string, TraceSource> DefaultChannelTraceSourceFactory { get; }
    private MultiplexingStream(Formatter formatter, Nullable`1<bool> isOdd, Options options);
    private static MultiplexingStream();
    [CompilerGeneratedAttribute]
public void add_ChannelOffered(EventHandler`1<ChannelOfferEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ChannelOffered(EventHandler`1<ChannelOfferEventArgs> value);
    public Task get_Completion();
    [CompilerGeneratedAttribute]
public TraceSource get_TraceSource();
    [CompilerGeneratedAttribute]
public long get_DefaultChannelReceivingWindowSize();
    private sealed virtual override bool Microsoft.IDisposableObservable.get_IsDisposed();
    internal CancellationToken get_DisposalToken();
    [CompilerGeneratedAttribute]
private Func`3<QualifiedChannelId, string, TraceSource> get_DefaultChannelTraceSourceFactory();
    public static MultiplexingStream Create(Stream stream, Options options);
    public static Task`1<MultiplexingStream> CreateAsync(Stream stream, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Nerdbank.Streams.MultiplexingStream/<CreateAsync>d__44")]
public static Task`1<MultiplexingStream> CreateAsync(Stream stream, Options options, CancellationToken cancellationToken);
    public void StartListening();
    public Channel CreateChannel(ChannelOptions options);
    public Channel AcceptChannel(int id, ChannelOptions options);
    public Channel AcceptChannel(ulong id, ChannelOptions options);
    public void RejectChannel(int id);
    public void RejectChannel(ulong id);
    public Task`1<Channel> OfferChannelAsync(string name, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Nerdbank.Streams.MultiplexingStream/<OfferChannelAsync>d__52")]
public Task`1<Channel> OfferChannelAsync(string name, ChannelOptions options, CancellationToken cancellationToken);
    public Task`1<Channel> AcceptChannelAsync(string name, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Nerdbank.Streams.MultiplexingStream/<AcceptChannelAsync>d__54")]
public Task`1<Channel> AcceptChannelAsync(string name, ChannelOptions options, CancellationToken cancellationToken);
    [ObsoleteAttribute("Use DisposeAsync instead.")]
public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("Nerdbank.Streams.MultiplexingStream/<DisposeAsync>d__56")]
public sealed virtual ValueTask DisposeAsync();
    protected virtual void OnChannelOffered(ChannelOfferEventArgs args);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Nerdbank.Streams.MultiplexingStream/<ReadToFillAsync>d__58")]
private static ValueTask`1<bool> ReadToFillAsync(Stream stream, Memory`1<byte> buffer, bool throwOnEmpty, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Nerdbank.Streams.MultiplexingStream/<ReadAndDiscardAsync>d__59")]
private static Task ReadAndDiscardAsync(Stream stream, int length, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private static ReadOnlyMemory`1<T> AsMemory(ReadOnlySequence`1<T> sequence, Memory`1<T> backupBuffer);
    [AsyncStateMachineAttribute("Nerdbank.Streams.MultiplexingStream/<ReadStreamAsync>d__61")]
private Task ReadStreamAsync();
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Nerdbank.Streams.MultiplexingStream/<OnChannelTerminatedAsync>d__62")]
private Task OnChannelTerminatedAsync(QualifiedChannelId channelId, ReadOnlySequence`1<byte> payload);
    private void OnContentWritingCompleted(QualifiedChannelId channelId);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Nerdbank.Streams.MultiplexingStream/<OnContentAsync>d__64")]
private ValueTask OnContentAsync(FrameHeader header, ReadOnlySequence`1<byte> payload, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
private void OnOfferAccepted(FrameHeader header, ReadOnlySequence`1<byte> payloadBuffer);
    [NullableContextAttribute("0")]
private void OnContentProcessed(FrameHeader header, ReadOnlySequence`1<byte> payloadBuffer);
    [NullableContextAttribute("0")]
private void OnOffer(QualifiedChannelId channelId, ReadOnlySequence`1<byte> payloadBuffer);
    private bool TryAcceptChannel(Channel channel, ChannelOptions options);
    private void AcceptChannelOrThrow(Channel channel, ChannelOptions options);
    private void OnChannelDisposed(Channel channel, Exception exception);
    private void OnChannelWritingCompleted(Channel channel);
    private void SendFrame(ControlCode code, QualifiedChannelId channelId);
    [NullableContextAttribute("0")]
private void SendFrame(FrameHeader header, ReadOnlySequence`1<byte> payload, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Nerdbank.Streams.MultiplexingStream/<SendFrameAsync>d__74")]
private Task SendFrameAsync(FrameHeader header, ReadOnlySequence`1<byte> payload, CancellationToken cancellationToken);
    private ulong GetUnusedChannelId();
    private void OfferChannelCanceled(object state);
    private void AcceptChannelCanceled(object state);
    private void DisposeSelfOnFailure(Task task);
    private void Fault(Exception exception);
    private void ThrowIfNotListening();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Nerdbank.Streams.NestedPipeReader : PipeReader {
    private PipeReader pipeReader;
    private long length;
    private long consumedLength;
    private ReadResult resultOfPriorRead;
    private bool completed;
    private long RemainingLength { get; }
    public NestedPipeReader(PipeReader pipeReader, long length);
    private long get_RemainingLength();
    public virtual void AdvanceTo(SequencePosition consumed);
    public virtual void AdvanceTo(SequencePosition consumed, SequencePosition examined);
    public virtual void CancelPendingRead();
    [NullableContextAttribute("2")]
public virtual void Complete(Exception exception);
    [ObsoleteAttribute]
public virtual void OnWriterCompleted(Action`2<Exception, object> callback, object state);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Nerdbank.Streams.NestedPipeReader/<ReadAsync>d__13")]
public virtual ValueTask`1<ReadResult> ReadAsync(CancellationToken cancellationToken);
    public virtual bool TryRead(ReadResult& result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Nerdbank.Streams.NestedStream : Stream {
    private Stream underlyingStream;
    private long length;
    private long remainingBytes;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    public bool IsDisposed { get; private set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public NestedStream(Stream underlyingStream, long length);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Nerdbank.Streams.NestedStream/<ReadAsync>d__21")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void Write(Byte[] buffer, int offset, int count);
    protected virtual void Dispose(bool disposing);
    private Exception ThrowDisposedOr(Exception ex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Nerdbank.Streams.PipeExtensions : object {
    private static int DefaultReadBufferSize;
    [ExtensionAttribute]
public static Stream AsStream(IDuplexPipe pipe);
    [ExtensionAttribute]
public static Stream AsStream(IDuplexPipe pipe, bool ownsPipe);
    [ExtensionAttribute]
[ObsoleteAttribute("Use PipeReader.AsStream instead.")]
public static Stream AsStream(PipeReader pipeReader);
    [AsyncStateMachineAttribute("Nerdbank.Streams.PipeExtensions/<AsPrebufferedStreamAsync>d__4")]
[ExtensionAttribute]
public static Task`1<Stream> AsPrebufferedStreamAsync(PipeReader pipeReader, CancellationToken cancellationToken);
    [ExtensionAttribute]
[ObsoleteAttribute("Use PipeWriter.AsStream instead.")]
public static Stream AsStream(PipeWriter pipeWriter);
    [ExtensionAttribute]
public static PipeReader UsePipeReader(Stream stream, int sizeHint, PipeOptions pipeOptions, CancellationToken cancellationToken);
    [ExtensionAttribute]
[ObsoleteAttribute("Use PipeReader.Create instead.")]
public static PipeReader UseStrictPipeReader(Stream stream, int sizeHint);
    [ExtensionAttribute]
public static PipeWriter UsePipeWriter(Stream stream, PipeOptions pipeOptions, CancellationToken cancellationToken);
    [ExtensionAttribute]
[ObsoleteAttribute("Use PipeWriter.Create instead.")]
public static PipeWriter UseStrictPipeWriter(Stream stream);
    [ExtensionAttribute]
public static IDuplexPipe UsePipe(Stream stream, int sizeHint, PipeOptions pipeOptions, CancellationToken cancellationToken);
    [ExtensionAttribute]
[ObsoleteAttribute("Use the UsePipe overload that doesn't take an allowUnwrap parameter instead.")]
public static IDuplexPipe UsePipe(Stream stream, bool allowUnwrap, int sizeHint, PipeOptions pipeOptions, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static PipeReader UsePipeReader(WebSocket webSocket, int sizeHint, PipeOptions pipeOptions, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static PipeWriter UsePipeWriter(WebSocket webSocket, PipeOptions pipeOptions, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static PipeWriter UseUtf8TextPipeWriter(WebSocket webSocket, PipeOptions pipeOptions, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IDuplexPipe UsePipe(WebSocket webSocket, int sizeHint, PipeOptions pipeOptions, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IDuplexPipe UseUtf8TextPipe(WebSocket webSocket, int sizeHint, PipeOptions pipeOptions, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static PipeReader ReadSlice(PipeReader reader, long length);
    [ExtensionAttribute]
public static PipeReader OnCompleted(PipeReader reader, Action`2<Exception, object> callback, object state);
    [ExtensionAttribute]
public static PipeWriter OnCompleted(PipeWriter reader, Action`2<Exception, object> callback, object state);
    [ExtensionAttribute]
internal static Task LinkToAsync(PipeReader reader, PipeWriter writer, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static Task LinkToAsync(IDuplexPipe pipe1, IDuplexPipe pipe2, CancellationToken cancellationToken);
    [ExtensionAttribute]
private static PipeReader UsePipeReader(Stream stream, int sizeHint, PipeOptions pipeOptions, Task disposeWhenReaderCompleted, CancellationToken cancellationToken);
    private static PipeWriter UsePipeWriter(WebSocket webSocket, PipeOptions pipeOptions, WebSocketMessageType messageType, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
private static void Write(PipeWriter writer, ReadOnlySequence`1<byte> sequence);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Nerdbank.Streams.PipeReaderCompletionWatcher : PipeReader {
    [NullableAttribute("1")]
private PipeReader inner;
    private Action`2<Exception, object> callback;
    private object state;
    [NullableContextAttribute("1")]
internal PipeReaderCompletionWatcher(PipeReader inner, Action`2<Exception, object> callback, object state);
    public virtual void AdvanceTo(SequencePosition consumed);
    public virtual void AdvanceTo(SequencePosition consumed, SequencePosition examined);
    public virtual void CancelPendingRead();
    public virtual void Complete(Exception exception);
    [ObsoleteAttribute]
public virtual void OnWriterCompleted(Action`2<Exception, object> callback, object state);
    [NullableContextAttribute("0")]
public virtual ValueTask`1<ReadResult> ReadAsync(CancellationToken cancellationToken);
    public virtual bool TryRead(ReadResult& result);
}
internal class Nerdbank.Streams.PipeWriterCompletionWatcher : PipeWriter {
    [NullableAttribute("1")]
private PipeWriter inner;
    [NullableAttribute("2")]
private Action`2<Exception, object> callback;
    [NullableAttribute("2")]
private object state;
    [NullableContextAttribute("1")]
public PipeWriterCompletionWatcher(PipeWriter inner, Action`2<Exception, object> callback, object state);
    public virtual void Advance(int bytes);
    public virtual void CancelPendingFlush();
    [NullableContextAttribute("2")]
public virtual void Complete(Exception exception);
    public virtual ValueTask`1<FlushResult> FlushAsync(CancellationToken cancellationToken);
    public virtual Memory`1<byte> GetMemory(int sizeHint);
    public virtual Span`1<byte> GetSpan(int sizeHint);
    [NullableContextAttribute("2")]
[ObsoleteAttribute]
public virtual void OnReaderCompleted(Action`2<Exception, object> callback, object state);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Nerdbank.Streams.PrefixingBufferWriter`1 : object {
    private static int PayloadSizeGuess;
    private IBufferWriter`1<T> innerWriter;
    private int expectedPrefixSize;
    private int payloadSizeHint;
    private MemoryPool`1<T> memoryPool;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Sequence`1<T> excessSequence;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Memory`1<T> prefixMemory;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Memory`1<T> realMemory;
    private int advanced;
    private bool usingExcessMemory;
    public long Length { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Memory`1<T> Prefix { get; }
    public PrefixingBufferWriter`1(IBufferWriter`1<T> innerWriter, int prefixSize, int payloadSizeHint, MemoryPool`1<T> memoryPool);
    public long get_Length();
    public Memory`1<T> get_Prefix();
    public sealed virtual void Advance(int count);
    public sealed virtual Memory`1<T> GetMemory(int sizeHint);
    public sealed virtual Span`1<T> GetSpan(int sizeHint);
    public void Commit();
    private void EnsureInitialized(int sizeHint);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Nerdbank.Streams.ReadOnlySequenceExtensions : object {
    [ExtensionAttribute]
public static ReadOnlySequence`1<T> Clone(ReadOnlySequence`1<T> template);
    [ExtensionAttribute]
internal static void GetFirstSpan(ReadOnlySequence`1<T> sequence, ReadOnlySpan`1& first, SequencePosition& next);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Nerdbank.Streams.ReadOnlySequenceStream : Stream {
    private static Task`1<int> TaskOfZero;
    [NullableAttribute("2")]
private Action`1<object> disposeAction;
    [NullableAttribute("2")]
private object disposeActionArg;
    [NullableAttribute("2")]
private Task`1<int> lastReadTask;
    [NullableAttribute("0")]
private ReadOnlySequence`1<byte> readOnlySequence;
    private SequencePosition position;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public bool IsDisposed { get; private set; }
    [NullableContextAttribute("2")]
internal ReadOnlySequenceStream(ReadOnlySequence`1<byte> readOnlySequence, Action`1<object> disposeAction, object disposeActionArg);
    private static ReadOnlySequenceStream();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Nerdbank.Streams.ReadOnlySequenceStream/<CopyToAsync>d__32")]
public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    private T ReturnOrThrowDisposed(T value);
    private Exception ThrowDisposedOr(Exception ex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class Nerdbank.Streams.Sequence`1 : object {
    private static int MaximumAutoGrowSize;
    private static int DefaultLengthFromArrayPool;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ReadOnlySequence`1<T> Empty;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Stack`1<SequenceSegment<T>> segmentPool;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private MemoryPool`1<T> memoryPool;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ArrayPool`1<T> arrayPool;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private SequenceSegment<T> first;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private SequenceSegment<T> last;
    [CompilerGeneratedAttribute]
private int <MinimumSpanLength>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AutoIncreaseMinimumSpanLength>k__BackingField;
    public int MinimumSpanLength { get; public set; }
    public bool AutoIncreaseMinimumSpanLength { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlySequence`1<T> AsReadOnlySequence { get; }
    public long Length { get; }
    private string DebuggerDisplay { get; }
    public Sequence`1(MemoryPool`1<T> memoryPool);
    public Sequence`1(ArrayPool`1<T> arrayPool);
    private static Sequence`1();
    [CompilerGeneratedAttribute]
public int get_MinimumSpanLength();
    [CompilerGeneratedAttribute]
public void set_MinimumSpanLength(int value);
    [CompilerGeneratedAttribute]
public bool get_AutoIncreaseMinimumSpanLength();
    [CompilerGeneratedAttribute]
public void set_AutoIncreaseMinimumSpanLength(bool value);
    public ReadOnlySequence`1<T> get_AsReadOnlySequence();
    public long get_Length();
    private string get_DebuggerDisplay();
    public static ReadOnlySequence`1<T> op_Implicit(Sequence`1<T> sequence);
    public void AdvanceTo(SequencePosition position);
    public sealed virtual void Advance(int count);
    public sealed virtual Memory`1<T> GetMemory(int sizeHint);
    public sealed virtual Span`1<T> GetSpan(int sizeHint);
    public void Append(ReadOnlyMemory`1<T> memory);
    [EditorBrowsableAttribute("1")]
public sealed virtual void Dispose();
    public void Reset();
    private SequenceSegment<T> GetSegment(int sizeHint);
    private void Append(SequenceSegment<T> segment);
    private SequenceSegment<T> RecycleAndGetNext(SequenceSegment<T> segment);
    private void ConsiderMinimumSizeIncrease();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Nerdbank.Streams.SequenceTextReader : TextReader {
    private Char[] charBuffer;
    private int charBufferPosition;
    private int charBufferLength;
    [NullableAttribute("0")]
private ReadOnlySequence`1<byte> sequence;
    private SequencePosition sequencePosition;
    [NullableAttribute("2")]
private Encoding encoding;
    [NullableAttribute("2")]
private Decoder decoder;
    [NullableAttribute("2")]
private Byte[] encodingPreamble;
    [NullableContextAttribute("0")]
public SequenceTextReader(ReadOnlySequence`1<byte> sequence, Encoding encoding);
    [NullableContextAttribute("0")]
public void Initialize(ReadOnlySequence`1<byte> sequence, Encoding encoding);
    public void Reset();
    public virtual int Peek();
    public virtual int Read();
    public virtual int Read(Char[] buffer, int index, int count);
    public virtual Task`1<int> ReadAsync(Char[] buffer, int index, int count);
    public virtual Task`1<int> ReadBlockAsync(Char[] buffer, int index, int count);
    public virtual Task`1<string> ReadToEndAsync();
    public virtual Task`1<string> ReadLineAsync();
    private void DecodeCharsIfNecessary();
    private void DecodeChars();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Nerdbank.Streams.SimplexStream : Stream {
    private Pipe pipe;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    public bool IsDisposed { get; private set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public SimplexStream(int resumeWriterThreshold, int pauseWriterThreshold);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public void CompleteWriting();
    [AsyncStateMachineAttribute("Nerdbank.Streams.SimplexStream/<FlushAsync>d__19")]
public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    [AsyncStateMachineAttribute("Nerdbank.Streams.SimplexStream/<ReadAsync>d__22")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    private sealed virtual override void System.Buffers.IBufferWriter<System.Byte>.Advance(int count);
    [NullableContextAttribute("0")]
private sealed virtual override Memory`1<byte> System.Buffers.IBufferWriter<System.Byte>.GetMemory(int sizeHint);
    [NullableContextAttribute("0")]
private sealed virtual override Span`1<byte> System.Buffers.IBufferWriter<System.Byte>.GetSpan(int sizeHint);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    protected virtual void Dispose(bool disposing);
    private Exception ThrowDisposedOr(Exception ex);
}
[ExtensionAttribute]
internal static class Nerdbank.Streams.SpanPolyfillExtensions : object {
    [ExtensionAttribute]
internal static ValueTask`1<int> ReadAsync(Stream stream, Memory`1<byte> buffer, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static int Read(Stream stream, Span`1<byte> buffer);
    [ExtensionAttribute]
internal static ValueTask WriteAsync(Stream stream, ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static ValueTask`1<WebSocketReceiveResult> ReceiveAsync(WebSocket webSocket, Memory`1<byte> buffer, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static ValueTask SendAsync(WebSocket webSocket, ReadOnlyMemory`1<byte> buffer, WebSocketMessageType messageType, bool endOfMessage, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Nerdbank.Streams.SpanPolyfillExtensions/<<ReadAsync>g__FinishReadAsync|0_0>d")]
[CompilerGeneratedAttribute]
internal static ValueTask`1<int> <ReadAsync>g__FinishReadAsync|0_0(Task`1<int> readTask, Byte[] localBuffer, Memory`1<byte> localDestination);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Nerdbank.Streams.SpanPolyfillExtensions/<<WriteAsync>g__FinishWriteAsync|2_0>d")]
[CompilerGeneratedAttribute]
internal static Task <WriteAsync>g__FinishWriteAsync|2_0(Task writeTask, Byte[] localBuffer);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Nerdbank.Streams.SpanPolyfillExtensions/<<ReceiveAsync>g__FinishReadAsync|3_0>d")]
[CompilerGeneratedAttribute]
internal static ValueTask`1<WebSocketReceiveResult> <ReceiveAsync>g__FinishReadAsync|3_0(Task`1<WebSocketReceiveResult> readTask, Byte[] localBuffer, Memory`1<byte> localDestination);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Nerdbank.Streams.SpanPolyfillExtensions/<<SendAsync>g__FinishWriteAsync|4_0>d")]
[CompilerGeneratedAttribute]
internal static Task <SendAsync>g__FinishWriteAsync|4_0(Task writeTask, Byte[] localBuffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Nerdbank.Streams.StreamExtensions : object {
    [ExtensionAttribute]
public static Stream ReadSlice(Stream stream, long length);
    [ExtensionAttribute]
public static Stream AsStream(WebSocket webSocket);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static Stream AsStream(ReadOnlySequence`1<byte> readOnlySequence);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Stream AsStream(ReadOnlySequence`1<byte> readOnlySequence, Action`1<object> disposeAction, object disposeActionArg);
    [ExtensionAttribute]
public static Stream AsStream(IBufferWriter`1<byte> writer);
    [ExtensionAttribute]
public static Substream WriteSubstream(Stream stream, int minimumBufferSize);
    [ExtensionAttribute]
public static Stream ReadSubstream(Stream stream);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Nerdbank.Streams.StreamExtensions/<ReadBlockAsync>d__7")]
[ExtensionAttribute]
public static ValueTask`1<int> ReadBlockAsync(Stream stream, Memory`1<byte> buffer, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Nerdbank.Streams.StreamExtensions/<ReadBlockOrThrowAsync>d__8")]
[ExtensionAttribute]
public static ValueTask ReadBlockOrThrowAsync(Stream stream, Memory`1<byte> buffer, CancellationToken cancellationToken);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Nerdbank.Streams.StreamPipeReader : PipeReader {
    [NullableAttribute("1")]
private object syncObject;
    [NullableAttribute("1")]
private Stream stream;
    private int bufferSize;
    private bool leaveOpen;
    [NullableAttribute("1")]
private Sequence`1<byte> buffer;
    private SequencePosition examined;
    private CancellationTokenSource readCancellationSource;
    private bool isReaderCompleted;
    private Exception readerException;
    private bool isWriterCompleted;
    private Exception writerException;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ValueTuple`2<Action`2<Exception, object>, object>> writerCompletedCallbacks;
    [NullableContextAttribute("1")]
public StreamPipeReader(Stream stream);
    [NullableContextAttribute("1")]
public StreamPipeReader(Stream stream, int bufferSize, bool leaveOpen);
    public virtual void AdvanceTo(SequencePosition consumed);
    public virtual void AdvanceTo(SequencePosition consumed, SequencePosition examined);
    public virtual void CancelPendingRead();
    public virtual void Complete(Exception exception);
    [ObsoleteAttribute]
public virtual void OnWriterCompleted(Action`2<Exception, object> callback, object state);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Nerdbank.Streams.StreamPipeReader/<ReadAsync>d__19")]
public virtual ValueTask`1<ReadResult> ReadAsync(CancellationToken cancellationToken);
    public ReadResult Read();
    public virtual bool TryRead(ReadResult& result);
    private void CompleteWriting(Exception writerException);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ObsoleteAttribute("Use PipeWriter.Create instead.")]
internal class Nerdbank.Streams.StreamPipeWriter : PipeWriter {
    [NullableAttribute("1")]
private object syncObject;
    [NullableAttribute("1")]
private Stream stream;
    [NullableAttribute("1")]
private Sequence`1<byte> buffer;
    [NullableAttribute("1")]
private AsyncSemaphore flushingSemaphore;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ValueTuple`2<Action`2<Exception, object>, object>> readerCompletedCallbacks;
    private CancellationTokenSource flushCancellationSource;
    private bool isReaderCompleted;
    private Exception readerException;
    private bool isWriterCompleted;
    private Exception writerException;
    [NullableContextAttribute("1")]
internal StreamPipeWriter(Stream stream);
    public virtual void Advance(int bytes);
    public virtual void CancelPendingFlush();
    public virtual void Complete(Exception exception);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Nerdbank.Streams.StreamPipeWriter/<FlushAsync>d__14")]
public virtual ValueTask`1<FlushResult> FlushAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual Memory`1<byte> GetMemory(int sizeHint);
    [NullableContextAttribute("0")]
public virtual Span`1<byte> GetSpan(int sizeHint);
    [ObsoleteAttribute]
public virtual void OnReaderCompleted(Action`2<Exception, object> callback, object state);
    private void CompleteReading(Exception readerException);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "16.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Nerdbank.Streams.Strings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ExistingPipeOutputHasPauseThresholdSetTooLow { get; }
    internal static string Frozen { get; }
    internal static string InvalidSeekOrigin { get; }
    internal static string ListeningHasAlreadyStarted { get; }
    internal static string ListeningHasNotStarted { get; }
    internal static string NoChannelFoundById { get; }
    internal static string NotAllowedOnSeededChannel { get; }
    internal static string NotSupportedWhenExistingPipeSpecified { get; }
    internal static string PipeReaderCanceled { get; }
    internal static string PipeWriterFlushCanceled { get; }
    internal static string ReadingAfterCompletionNotAllowed { get; }
    internal static string SeededChannelsRequireV3Protocol { get; }
    internal static string SeekBeforeBegin { get; }
    internal static string SeekingNotSupported { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ExistingPipeOutputHasPauseThresholdSetTooLow();
    internal static string get_Frozen();
    internal static string get_InvalidSeekOrigin();
    internal static string get_ListeningHasAlreadyStarted();
    internal static string get_ListeningHasNotStarted();
    internal static string get_NoChannelFoundById();
    internal static string get_NotAllowedOnSeededChannel();
    internal static string get_NotSupportedWhenExistingPipeSpecified();
    internal static string get_PipeReaderCanceled();
    internal static string get_PipeWriterFlushCanceled();
    internal static string get_ReadingAfterCompletionNotAllowed();
    internal static string get_SeededChannelsRequireV3Protocol();
    internal static string get_SeekBeforeBegin();
    internal static string get_SeekingNotSupported();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Nerdbank.Streams.Substream : Stream {
    internal static int DefaultBufferSize;
    private Stream underlyingStream;
    private Byte[] buffer;
    private int count;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    public bool IsDisposed { get; private set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public bool CanTimeout { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal Substream(Stream underlyingStream, int minimumBufferSize);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual bool get_CanTimeout();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public sealed virtual Task DisposeAsync();
    private sealed virtual override ValueTask System.IAsyncDisposable.DisposeAsync();
    [AsyncStateMachineAttribute("Nerdbank.Streams.Substream/<DisposeAsync>d__24")]
public ValueTask DisposeAsync(CancellationToken cancellationToken);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Nerdbank.Streams.Substream/<WriteAsync>d__32")]
public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    private void Flush(bool flushUnderlyingStream);
    [AsyncStateMachineAttribute("Nerdbank.Streams.Substream/<FlushAsync>d__35")]
private Task FlushAsync(bool flushUnderlyingStream, CancellationToken cancellationToken);
    private void WriteLengthHeader(int length);
    [AsyncStateMachineAttribute("Nerdbank.Streams.Substream/<WriteLengthHeaderAsync>d__37")]
private ValueTask WriteLengthHeaderAsync(int length, CancellationToken cancellationToken);
    private Exception ThrowDisposedOr(Exception ex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Nerdbank.Streams.SubstreamReader : Stream {
    private Stream underlyingStream;
    private Byte[] intBuffer;
    private int count;
    private bool eof;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public bool CanTimeout { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public bool IsDisposed { get; private set; }
    internal SubstreamReader(Stream underlyingStream);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual bool get_CanTimeout();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Nerdbank.Streams.SubstreamReader/<ReadAsync>d__25")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    private Exception ThrowDisposedOr(Exception ex);
}
internal static class Nerdbank.Streams.ThrowHelper : object {
    [NullableContextAttribute("1")]
internal static void ThrowArgumentOutOfRangeException(string paramName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Nerdbank.Streams.UnownedPipeReader : PipeReader {
    internal static string UnownedObject;
    private PipeReader underlyingReader;
    internal UnownedPipeReader(PipeReader underlyingReader);
    public virtual void CancelPendingRead();
    public virtual void AdvanceTo(SequencePosition consumed);
    public virtual void AdvanceTo(SequencePosition consumed, SequencePosition examined);
    [NullableContextAttribute("2")]
public virtual void Complete(Exception exception);
    [NullableContextAttribute("2")]
public virtual ValueTask CompleteAsync(Exception exception);
    [NullableContextAttribute("0")]
public virtual ValueTask`1<ReadResult> ReadAsync(CancellationToken cancellationToken);
    public virtual bool TryRead(ReadResult& result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Nerdbank.Streams.Utilities : object {
    internal static Task CompletedTask;
    private static Utilities();
    internal static void ValidateBufferIndexAndCount(T[] buffer, int index, int count);
    [ExtensionAttribute]
internal static bool RemoveMidQueue(Queue`1<T> queue, T valueToRemove);
    [ExtensionAttribute]
[ObsoleteAttribute("Relies on the obsolete OnReaderCompleted API.")]
internal static Task WaitForReaderCompletionAsync(PipeWriter writer);
    [ExtensionAttribute]
[ObsoleteAttribute("Relies on the obsolete OnWriterCompleted API.")]
internal static Task WaitForWriterCompletionAsync(PipeReader reader);
    [ExtensionAttribute]
internal static Task FlushIfNecessaryAsync(Stream stream, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
internal static int ReadInt(ReadOnlySpan`1<byte> buffer);
    [NullableContextAttribute("0")]
internal static void Write(Span`1<byte> buffer, int value);
    [NullableContextAttribute("0")]
internal static void Write(Span`1<byte> buffer, ushort value);
    [ExtensionAttribute]
internal static void ScrubAfterAdvanceTo(ReadResult& readResult);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Nerdbank.Streams.WebSocketStream : Stream {
    private static Task CompletedTask;
    private WebSocket webSocket;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    public bool IsDisposed { get; private set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public WebSocketStream(WebSocket webSocket);
    private static WebSocketStream();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Nerdbank.Streams.WebSocketStream/<ReadAsync>d__20")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    protected virtual void Dispose(bool disposing);
    private Exception ThrowDisposedOr(Exception ex);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
public class System.Buffers.SequenceReader`1 : ValueType {
    private SequencePosition _currentPosition;
    private SequencePosition _nextPosition;
    private bool _moreData;
    private long _length;
    [CompilerGeneratedAttribute]
private ReadOnlySequence`1<T> <Sequence>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlySpan`1<T> <CurrentSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentSpanIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Consumed>k__BackingField;
    public bool End { get; }
    public ReadOnlySequence`1<T> Sequence { get; }
    public SequencePosition Position { get; }
    public ReadOnlySpan`1<T> CurrentSpan { get; private set; }
    public int CurrentSpanIndex { get; private set; }
    public ReadOnlySpan`1<T> UnreadSpan { get; }
    public long Consumed { get; private set; }
    public long Remaining { get; }
    public long Length { get; }
    public SequenceReader`1(ReadOnlySequence`1<T> sequence);
    [IsReadOnlyAttribute]
public bool get_End();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ReadOnlySequence`1<T> get_Sequence();
    [IsReadOnlyAttribute]
public SequencePosition get_Position();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ReadOnlySpan`1<T> get_CurrentSpan();
    [CompilerGeneratedAttribute]
private void set_CurrentSpan(ReadOnlySpan`1<T> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_CurrentSpanIndex();
    [CompilerGeneratedAttribute]
private void set_CurrentSpanIndex(int value);
    [IsReadOnlyAttribute]
public ReadOnlySpan`1<T> get_UnreadSpan();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_Consumed();
    [CompilerGeneratedAttribute]
private void set_Consumed(long value);
    [IsReadOnlyAttribute]
public long get_Remaining();
    [IsReadOnlyAttribute]
public long get_Length();
    [IsReadOnlyAttribute]
public bool TryPeek(T& value);
    public bool TryRead(T& value);
    public void Rewind(long count);
    private void RetreatToPreviousSpan(long consumed);
    private void ResetReader();
    private void GetNextSpan();
    public void Advance(long count);
    internal void AdvanceCurrentSpan(long count);
    internal void AdvanceWithinSpan(long count);
    private void AdvanceToNextSpan(long count);
    [IsReadOnlyAttribute]
public bool TryCopyTo(Span`1<T> destination);
    [IsReadOnlyAttribute]
internal bool TryCopyMultisegment(Span`1<T> destination);
    public bool TryReadTo(ReadOnlySpan`1& span, T delimiter, bool advancePastDelimiter);
    private bool TryReadToSlow(ReadOnlySpan`1& span, T delimiter, bool advancePastDelimiter);
    public bool TryReadTo(ReadOnlySpan`1& span, T delimiter, T delimiterEscape, bool advancePastDelimiter);
    private bool TryReadToSlow(ReadOnlySpan`1& span, T delimiter, T delimiterEscape, int index, bool advancePastDelimiter);
    private bool TryReadToSlow(ReadOnlySequence`1& sequence, T delimiter, T delimiterEscape, int index, bool advancePastDelimiter);
    public bool TryReadTo(ReadOnlySequence`1& sequence, T delimiter, bool advancePastDelimiter);
    private bool TryReadToInternal(ReadOnlySequence`1& sequence, T delimiter, bool advancePastDelimiter, int skip);
    public bool TryReadTo(ReadOnlySequence`1& sequence, T delimiter, T delimiterEscape, bool advancePastDelimiter);
    public bool TryReadToAny(ReadOnlySpan`1& span, ReadOnlySpan`1<T> delimiters, bool advancePastDelimiter);
    private bool TryReadToAnySlow(ReadOnlySpan`1& span, ReadOnlySpan`1<T> delimiters, bool advancePastDelimiter);
    public bool TryReadToAny(ReadOnlySequence`1& sequence, ReadOnlySpan`1<T> delimiters, bool advancePastDelimiter);
    private bool TryReadToAnyInternal(ReadOnlySequence`1& sequence, ReadOnlySpan`1<T> delimiters, bool advancePastDelimiter, int skip);
    public bool TryReadTo(ReadOnlySequence`1& sequence, ReadOnlySpan`1<T> delimiter, bool advancePastDelimiter);
    public bool TryReadExact(int count, ReadOnlySequence`1& sequence);
    public bool TryAdvanceTo(T delimiter, bool advancePastDelimiter);
    public bool TryAdvanceToAny(ReadOnlySpan`1<T> delimiters, bool advancePastDelimiter);
    public long AdvancePast(T value);
    public long AdvancePastAny(ReadOnlySpan`1<T> values);
    public long AdvancePastAny(T value0, T value1, T value2, T value3);
    public long AdvancePastAny(T value0, T value1, T value2);
    public long AdvancePastAny(T value0, T value1);
    public bool IsNext(T next, bool advancePast);
    public bool IsNext(ReadOnlySpan`1<T> next, bool advancePast);
    private bool IsNextSlow(ReadOnlySpan`1<T> next, bool advancePast);
}
[ExtensionAttribute]
public static class System.Buffers.SequenceReaderExtensions : object {
    [ExtensionAttribute]
internal static bool TryRead(SequenceReader`1& reader, T& value);
    private static bool TryReadMultisegment(SequenceReader`1& reader, T& value);
    [ExtensionAttribute]
public static bool TryReadLittleEndian(SequenceReader`1& reader, Int16& value);
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, Int16& value);
    private static bool TryReadReverseEndianness(SequenceReader`1& reader, Int16& value);
    [ExtensionAttribute]
public static bool TryReadLittleEndian(SequenceReader`1& reader, Int32& value);
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, Int32& value);
    private static bool TryReadReverseEndianness(SequenceReader`1& reader, Int32& value);
    [ExtensionAttribute]
public static bool TryReadLittleEndian(SequenceReader`1& reader, Int64& value);
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, Int64& value);
    private static bool TryReadReverseEndianness(SequenceReader`1& reader, Int64& value);
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsByRefLikeAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsUnmanagedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[GeneratedCodeAttribute("Nerdbank.GitVersioning.Tasks", "3.6.133.12845")]
[ExcludeFromCodeCoverageAttribute]
internal static class ThisAssembly : object {
    internal static string AssemblyConfiguration;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyVersion;
    internal static DateTime GitCommitDate;
    internal static string GitCommitId;
    internal static bool IsPrerelease;
    internal static bool IsPublicRelease;
    internal static string PublicKey;
    internal static string PublicKeyToken;
    internal static string RootNamespace;
    private static ThisAssembly();
}
