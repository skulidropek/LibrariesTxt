[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal static class Microsoft.VisualStudio.Composition.ArrayRental`1 : object {
    [NullableAttribute("1")]
private static ThreadLocal`1<Dictionary`2<int, Stack`1<T[]>>> Arrays;
    private static ArrayRental`1();
    internal static Rental`1<T[]> Get(int length);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Composition.AttributedPartDiscovery : PartDiscovery {
    [CompilerGeneratedAttribute]
private bool <IsNonPublicSupported>k__BackingField;
    public bool IsNonPublicSupported { get; }
    protected BindingFlags PublicVsNonPublicFlags { get; }
    public AttributedPartDiscovery(Resolver resolver, bool isNonPublicSupported);
    [CompilerGeneratedAttribute]
public bool get_IsNonPublicSupported();
    protected BindingFlags get_PublicVsNonPublicFlags();
    protected virtual ComposablePartDefinition CreatePart(Type partType, bool typeExplicitlyRequested);
    public virtual bool IsExportFactoryType(Type type);
    protected virtual IEnumerable`1<Type> GetTypes(Assembly assembly);
    private ImmutableDictionary`2<string, object> GetExportMetadata(ICustomAttributeProvider member);
    private static void UpdateMetadataDictionary(IDictionary`2<string, object> result, HashSet`1<string> namesOfMetadataWithMultipleValues, string name, object value, Type elementType);
    private bool TryCreateImportDefinition(Type importingType, ICustomAttributeProvider member, ImmutableHashSet`1<IImportSatisfiabilityConstraint> importConstraints, ImportDefinition& importDefinition);
    private ImportDefinitionBinding CreateImport(ParameterInfo parameter, ImmutableHashSet`1<IImportSatisfiabilityConstraint> importConstraints);
    private static ImmutableHashSet`1<IImportSatisfiabilityConstraint> GetImportConstraints(ICustomAttributeProvider importSite);
    private static ExportDefinition CreateExportDefinition(ImmutableDictionary`2<string, object> memberExportMetadata, ExportAttribute exportAttribute, Type exportedType);
    [CompilerGeneratedAttribute]
internal static Exception <CreatePart>g__ThrowErrorScanningMember|6_10(MemberInfo member, Exception ex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Composition.AttributedPartDiscoveryV1 : PartDiscovery {
    private static MethodInfo OnImportsSatisfiedMethodInfo;
    public AttributedPartDiscoveryV1(Resolver resolver);
    private static AttributedPartDiscoveryV1();
    protected virtual ComposablePartDefinition CreatePart(Type partType, bool typeExplicitlyRequested);
    private void AddImportsFromMembers(PropertyInfo[] declaredProperties, FieldInfo[] declaredFields, TypeRef partTypeRef, IList`1<ImportDefinitionBinding> imports);
    public virtual bool IsExportFactoryType(Type type);
    protected virtual IEnumerable`1<Type> GetTypes(Assembly assembly);
    private bool TryCreateImportDefinition(Type importingType, ICustomAttributeProvider member, ImportDefinition& importDefinition);
    private ImportDefinitionBinding CreateImport(ParameterInfo parameter);
    private static IReadOnlyDictionary`2<string, object> GetExportMetadata(MemberInfo member);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.Composition.AttributeServices : object {
    [ExtensionAttribute]
public static T[] GetAttributes(ICustomAttributeProvider attributeProvider);
    [ExtensionAttribute]
public static T[] GetAttributes(ICustomAttributeProvider attributeProvider, bool inherit);
    [ExtensionAttribute]
public static T GetFirstAttribute(ICustomAttributeProvider attributeProvider);
    [ExtensionAttribute]
public static T GetFirstAttribute(ICustomAttributeProvider attributeProvider, bool inherit);
    [ExtensionAttribute]
public static bool IsAttributeDefined(ICustomAttributeProvider attributeProvider);
    [ExtensionAttribute]
public static bool IsAttributeDefined(ICustomAttributeProvider attributeProvider, bool inherit);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.VisualStudio.Composition.ByValueEquality : object {
    internal static IEqualityComparer`1<AssemblyName> AssemblyName { get; }
    internal static IEqualityComparer`1<AssemblyName> AssemblyNameNoFastCheck { get; }
    internal static IEqualityComparer`1<Byte[]> Buffer { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static IEqualityComparer`1<IReadOnlyDictionary`2<string, object>> Metadata { get; }
    internal static IEqualityComparer`1<AssemblyName> get_AssemblyName();
    internal static IEqualityComparer`1<AssemblyName> get_AssemblyNameNoFastCheck();
    internal static IEqualityComparer`1<Byte[]> get_Buffer();
    internal static IEqualityComparer`1<IReadOnlyDictionary`2<string, object>> get_Metadata();
    internal static IEqualityComparer`1<IReadOnlyDictionary`2<TKey, TValue>> Dictionary(IEqualityComparer`1<TValue> valueComparer);
    internal static IEqualityComparer`1<IReadOnlyDictionary`2<TKey, ImmutableHashSet`1<TValue>>> DictionaryOfImmutableHashSet();
    internal static IEqualityComparer`1<IReadOnlyCollection`1<T>> EquivalentIgnoreOrder();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Composition.CachedCatalog : object {
    protected static Encoding TextEncoding;
    private static CachedCatalog();
    public Task SaveAsync(ComposableCatalog catalog, Stream cacheStream, CancellationToken cancellationToken);
    public Task`1<ComposableCatalog> LoadAsync(Stream cacheStream, Resolver resolver, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Composition.CachedComposition : object {
    private static Encoding TextEncoding;
    private static CachedComposition();
    public sealed virtual Task SaveAsync(CompositionConfiguration configuration, Stream cacheStream, CancellationToken cancellationToken);
    public sealed virtual Task SaveAsync(RuntimeComposition composition, Stream cacheStream, CancellationToken cancellationToken);
    public sealed virtual Task`1<RuntimeComposition> LoadRuntimeCompositionAsync(Stream cacheStream, Resolver resolver, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Composition.CachedComposition/<LoadExportProviderFactoryAsync>d__4")]
public sealed virtual Task`1<IExportProviderFactory> LoadExportProviderFactoryAsync(Stream cacheStream, Resolver resolver, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.VisualStudio.Composition.CollectionServices : object {
    private static Type[] CollectionOfObjectCtorArgTypes;
    private static ConstructorInfo CollectionOfObjectCtor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Dictionary`2<Type, Func`2<object, ICollection`1<object>>> CachedCollectionWrapperFactories;
    private static CollectionServices();
    internal static ICollection`1<object> GetCollectionWrapper(Type itemType, object collectionObject);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Composition.ComposableCatalog : object {
    private ImmutableHashSet`1<ComposablePartDefinition> parts;
    private ImmutableDictionary`2<string, ImmutableList`1<ExportDefinitionBinding>> exportsByContract;
    private ImmutableHashSet`1<TypeRef> typesBackingParts;
    [CompilerGeneratedAttribute]
private DiscoveredParts <DiscoveredParts>k__BackingField;
    [CompilerGeneratedAttribute]
private Resolver <Resolver>k__BackingField;
    public IImmutableSet`1<ComposablePartDefinition> Parts { get; }
    public DiscoveredParts DiscoveredParts { get; private set; }
    internal Resolver Resolver { get; }
    private ComposableCatalog(ImmutableHashSet`1<ComposablePartDefinition> parts, ImmutableDictionary`2<string, ImmutableList`1<ExportDefinitionBinding>> exportsByContract, ImmutableHashSet`1<TypeRef> typesBackingParts, DiscoveredParts discoveredParts, Resolver resolver);
    public IImmutableSet`1<ComposablePartDefinition> get_Parts();
    [CompilerGeneratedAttribute]
public DiscoveredParts get_DiscoveredParts();
    [CompilerGeneratedAttribute]
private void set_DiscoveredParts(DiscoveredParts value);
    [CompilerGeneratedAttribute]
internal Resolver get_Resolver();
    public static ComposableCatalog Create(Resolver resolver);
    public ComposableCatalog AddPart(ComposablePartDefinition partDefinition);
    public ComposableCatalog AddParts(IEnumerable`1<ComposablePartDefinition> parts);
    public ComposableCatalog AddParts(DiscoveredParts parts);
    public ComposableCatalog AddCatalog(ComposableCatalog catalogToMerge);
    public ComposableCatalog AddCatalogs(IEnumerable`1<ComposableCatalog> catalogsToMerge);
    public IReadOnlyCollection`1<AssemblyName> GetInputAssemblies();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(ComposableCatalog other);
    public virtual int GetHashCode();
    public void ToString(TextWriter writer);
    public IReadOnlyList`1<ExportDefinitionBinding> GetExports(ImportDefinition importDefinition);
    internal static bool TryGetOpenGenericExport(ImportDefinition importDefinition, String& contractName, Type[]& typeArguments);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{Type.Name}")]
public class Microsoft.VisualStudio.Composition.ComposablePartDefinition : object {
    [CompilerGeneratedAttribute]
private TypeRef <TypeRef>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <SharingBoundary>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSharingBoundaryInferred>k__BackingField;
    [CompilerGeneratedAttribute]
private CreationPolicy <CreationPolicy>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, object> <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<MethodRef> <OnImportsSatisfiedMethodRefs>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<ExportDefinition> <ExportedTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<MemberRef, IReadOnlyCollection`1<ExportDefinition>> <ExportingMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<AssemblyName> <ExtraInputAssemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<ImportDefinitionBinding> <ImportingMembers>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyList`1<ImportDefinitionBinding> <ImportingConstructorImports>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private MethodRef <ImportingConstructorOrFactoryRef>k__BackingField;
    public Type Type { get; }
    public TypeRef TypeRef { get; private set; }
    public string Id { get; }
    [NullableAttribute("2")]
public string SharingBoundary { get; private set; }
    public bool IsSharingBoundaryInferred { get; private set; }
    public CreationPolicy CreationPolicy { get; private set; }
    public bool IsShared { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyDictionary`2<string, object> Metadata { get; private set; }
    public IEnumerable`1<MethodInfo> OnImportsSatisfiedMethods { get; }
    public IReadOnlyList`1<MethodRef> OnImportsSatisfiedMethodRefs { get; private set; }
    public IReadOnlyCollection`1<ExportDefinition> ExportedTypes { get; private set; }
    public IReadOnlyDictionary`2<MemberRef, IReadOnlyCollection`1<ExportDefinition>> ExportingMembers { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<MemberRef, ExportDefinition>> ExportDefinitions { get; }
    public IEnumerable`1<AssemblyName> ExtraInputAssemblies { get; }
    public ImmutableHashSet`1<ImportDefinitionBinding> ImportingMembers { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyList`1<ImportDefinitionBinding> ImportingConstructorImports { get; private set; }
    public bool IsInstantiable { get; }
    [NullableAttribute("2")]
public MethodRef ImportingConstructorOrFactoryRef { get; }
    [NullableAttribute("2")]
public MethodBase ImportingConstructorOrFactory { get; }
    public IEnumerable`1<ImportDefinitionBinding> Imports { get; }
    public ComposablePartDefinition(TypeRef partType, IReadOnlyDictionary`2<string, object> metadata, IReadOnlyCollection`1<ExportDefinition> exportedTypes, IReadOnlyDictionary`2<MemberRef, IReadOnlyCollection`1<ExportDefinition>> exportingMembers, IEnumerable`1<ImportDefinitionBinding> importingMembers, string sharingBoundary, IReadOnlyList`1<MethodRef> onImportsSatisfiedMethods, MethodRef importingConstructorRef, IReadOnlyList`1<ImportDefinitionBinding> importingConstructorImports, CreationPolicy partCreationPolicy);
    public ComposablePartDefinition(TypeRef partType, IReadOnlyDictionary`2<string, object> metadata, IReadOnlyCollection`1<ExportDefinition> exportedTypes, IReadOnlyDictionary`2<MemberRef, IReadOnlyCollection`1<ExportDefinition>> exportingMembers, IEnumerable`1<ImportDefinitionBinding> importingMembers, string sharingBoundary, IReadOnlyList`1<MethodRef> onImportsSatisfiedMethods, MethodRef importingConstructorRef, IReadOnlyList`1<ImportDefinitionBinding> importingConstructorImports, CreationPolicy partCreationPolicy, bool isSharingBoundaryInferred);
    public ComposablePartDefinition(TypeRef partType, IReadOnlyDictionary`2<string, object> metadata, IReadOnlyCollection`1<ExportDefinition> exportedTypes, IReadOnlyDictionary`2<MemberRef, IReadOnlyCollection`1<ExportDefinition>> exportingMembers, IEnumerable`1<ImportDefinitionBinding> importingMembers, string sharingBoundary, IReadOnlyList`1<MethodRef> onImportsSatisfiedMethods, MethodRef importingConstructorRef, IReadOnlyList`1<ImportDefinitionBinding> importingConstructorImports, CreationPolicy partCreationPolicy, bool isSharingBoundaryInferred, IEnumerable`1<AssemblyName> extraInputAssemblies);
    public Type get_Type();
    [CompilerGeneratedAttribute]
public TypeRef get_TypeRef();
    [CompilerGeneratedAttribute]
private void set_TypeRef(TypeRef value);
    public string get_Id();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_SharingBoundary();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_SharingBoundary(string value);
    [CompilerGeneratedAttribute]
public bool get_IsSharingBoundaryInferred();
    [CompilerGeneratedAttribute]
private void set_IsSharingBoundaryInferred(bool value);
    [CompilerGeneratedAttribute]
public CreationPolicy get_CreationPolicy();
    [CompilerGeneratedAttribute]
private void set_CreationPolicy(CreationPolicy value);
    public bool get_IsShared();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, object> get_Metadata();
    [CompilerGeneratedAttribute]
private void set_Metadata(IReadOnlyDictionary`2<string, object> value);
    public IEnumerable`1<MethodInfo> get_OnImportsSatisfiedMethods();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<MethodRef> get_OnImportsSatisfiedMethodRefs();
    [CompilerGeneratedAttribute]
private void set_OnImportsSatisfiedMethodRefs(IReadOnlyList`1<MethodRef> value);
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<ExportDefinition> get_ExportedTypes();
    [CompilerGeneratedAttribute]
private void set_ExportedTypes(IReadOnlyCollection`1<ExportDefinition> value);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<MemberRef, IReadOnlyCollection`1<ExportDefinition>> get_ExportingMembers();
    [CompilerGeneratedAttribute]
private void set_ExportingMembers(IReadOnlyDictionary`2<MemberRef, IReadOnlyCollection`1<ExportDefinition>> value);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Composition.ComposablePartDefinition/<get_ExportDefinitions>d__44")]
public IEnumerable`1<KeyValuePair`2<MemberRef, ExportDefinition>> get_ExportDefinitions();
    [CompilerGeneratedAttribute]
public IEnumerable`1<AssemblyName> get_ExtraInputAssemblies();
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<ImportDefinitionBinding> get_ImportingMembers();
    [CompilerGeneratedAttribute]
private void set_ImportingMembers(ImmutableHashSet`1<ImportDefinitionBinding> value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<ImportDefinitionBinding> get_ImportingConstructorImports();
    [CompilerGeneratedAttribute]
private void set_ImportingConstructorImports(IReadOnlyList`1<ImportDefinitionBinding> value);
    public bool get_IsInstantiable();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public MethodRef get_ImportingConstructorOrFactoryRef();
    [NullableContextAttribute("2")]
public MethodBase get_ImportingConstructorOrFactory();
    public IEnumerable`1<ImportDefinitionBinding> get_Imports();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(ComposablePartDefinition other);
    public void ToString(TextWriter writer);
    internal void GetInputAssemblies(ISet`1<AssemblyName> assemblies, Func`2<Assembly, AssemblyName> nameRetriever);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Microsoft.VisualStudio.Composition.ComposedLazy`1 : Lazy`1<T> {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private AssemblyName <assemblyName>P;
    [NullableAttribute("2")]
public AssemblyName AssemblyName { get; }
    private string DebuggerDisplay { get; }
    public ComposedLazy`1(AssemblyName assemblyName, Func`1<T> valueFactory);
    [NullableContextAttribute("2")]
public sealed virtual AssemblyName get_AssemblyName();
    internal static string GetDebuggerDisplay(Lazy`1<T> lazy);
    private string get_DebuggerDisplay();
}
[NullableContextAttribute("2")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Microsoft.VisualStudio.Composition.ComposedLazy`2 : Lazy`2<T, TMetadata> {
    [CompilerGeneratedAttribute]
private AssemblyName <assemblyName>P;
    public AssemblyName AssemblyName { get; }
    [NullableAttribute("1")]
private string DebuggerDisplay { get; }
    [NullableContextAttribute("1")]
public ComposedLazy`2(AssemblyName assemblyName, Func`1<T> valueFactory, TMetadata metadata);
    public sealed virtual AssemblyName get_AssemblyName();
    [NullableContextAttribute("1")]
private string get_DebuggerDisplay();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{Definition.Type.Name}")]
public class Microsoft.VisualStudio.Composition.ComposedPart : object {
    private ImmutableDictionary`2<ImportDefinitionBinding, IReadOnlyList`1<ExportDefinitionBinding>> satisfyingExports;
    [CompilerGeneratedAttribute]
private ComposablePartDefinition <Definition>k__BackingField;
    [CompilerGeneratedAttribute]
private IImmutableSet`1<string> <RequiredSharingBoundaries>k__BackingField;
    public ComposablePartDefinition Definition { get; private set; }
    public IReadOnlyDictionary`2<ImportDefinitionBinding, IReadOnlyList`1<ExportDefinitionBinding>> SatisfyingExports { get; }
    public IImmutableSet`1<string> RequiredSharingBoundaries { get; private set; }
    internal Resolver Resolver { get; }
    public ComposedPart(ComposablePartDefinition definition, IReadOnlyDictionary`2<ImportDefinitionBinding, IReadOnlyList`1<ExportDefinitionBinding>> satisfyingExports, IImmutableSet`1<string> requiredSharingBoundaries);
    [CompilerGeneratedAttribute]
public ComposablePartDefinition get_Definition();
    [CompilerGeneratedAttribute]
private void set_Definition(ComposablePartDefinition value);
    public IReadOnlyDictionary`2<ImportDefinitionBinding, IReadOnlyList`1<ExportDefinitionBinding>> get_SatisfyingExports();
    [CompilerGeneratedAttribute]
public IImmutableSet`1<string> get_RequiredSharingBoundaries();
    [CompilerGeneratedAttribute]
private void set_RequiredSharingBoundaries(IImmutableSet`1<string> value);
    internal Resolver get_Resolver();
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Composition.ComposedPart/<GetImportingConstructorImports>d__14")]
public IEnumerable`1<KeyValuePair`2<ImportDefinitionBinding, IReadOnlyList`1<ExportDefinitionBinding>>> GetImportingConstructorImports();
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Composition.ComposedPart/<Validate>d__15")]
public IEnumerable`1<ComposedPartDiagnostic> Validate(IReadOnlyDictionary`2<Type, ExportDefinitionBinding> metadataViews);
    internal ComposedPartDiagnostic[] RemoveSatisfyingExports(ICollection`1<ComposablePartDefinition> parts);
    private static string GetImportConstraints(ImportDefinition importDefinition);
    private static string GetDiagnosticLocation(ImportDefinitionBinding import);
    private static string GetDiagnosticLocation(ExportDefinitionBinding export);
    private static string GetExportsList(IEnumerable`1<ExportDefinitionBinding> exports);
    private static bool IsAllowedImportManyParameterType(Type importSiteType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Composition.ComposedPartDiagnostic : object {
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<ComposedPart> <Parts>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public IReadOnlyCollection`1<ComposedPart> Parts { get; private set; }
    public string Message { get; private set; }
    public ComposedPartDiagnostic(ComposedPart part, string formattedMessage);
    public ComposedPartDiagnostic(ComposedPart part, string unformattedMessage, Object[] args);
    public ComposedPartDiagnostic(IEnumerable`1<ComposedPart> parts, string formattedMessage);
    public ComposedPartDiagnostic(IEnumerable`1<ComposedPart> parts, string unformattedMessage, Object[] args);
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<ComposedPart> get_Parts();
    [CompilerGeneratedAttribute]
private void set_Parts(IReadOnlyCollection`1<ComposedPart> value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
private void set_Message(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Composition.CompositionConfiguration : object {
    private static ImmutableHashSet`1<ComposablePartDefinition> AlwaysBundledParts;
    private ImmutableDictionary`2<ComposablePartDefinition, string> effectiveSharingBoundaryOverrides;
    [CompilerGeneratedAttribute]
private ComposableCatalog <Catalog>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<ComposedPart> <Parts>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<Type, ExportDefinitionBinding> <MetadataViewsAndProviders>k__BackingField;
    [CompilerGeneratedAttribute]
private IImmutableStack`1<IReadOnlyCollection`1<ComposedPartDiagnostic>> <CompositionErrors>k__BackingField;
    public ComposableCatalog Catalog { get; private set; }
    public ISet`1<ComposedPart> Parts { get; private set; }
    public IReadOnlyDictionary`2<Type, ExportDefinitionBinding> MetadataViewsAndProviders { get; private set; }
    public IImmutableStack`1<IReadOnlyCollection`1<ComposedPartDiagnostic>> CompositionErrors { get; private set; }
    internal Resolver Resolver { get; }
    private CompositionConfiguration(ComposableCatalog catalog, ISet`1<ComposedPart> parts, IReadOnlyDictionary`2<Type, ExportDefinitionBinding> metadataViewsAndProviders, IImmutableStack`1<IReadOnlyCollection`1<ComposedPartDiagnostic>> compositionErrors, ImmutableDictionary`2<ComposablePartDefinition, string> effectiveSharingBoundaryOverrides);
    private static CompositionConfiguration();
    [CompilerGeneratedAttribute]
public ComposableCatalog get_Catalog();
    [CompilerGeneratedAttribute]
private void set_Catalog(ComposableCatalog value);
    [CompilerGeneratedAttribute]
public ISet`1<ComposedPart> get_Parts();
    [CompilerGeneratedAttribute]
private void set_Parts(ISet`1<ComposedPart> value);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<Type, ExportDefinitionBinding> get_MetadataViewsAndProviders();
    [CompilerGeneratedAttribute]
private void set_MetadataViewsAndProviders(IReadOnlyDictionary`2<Type, ExportDefinitionBinding> value);
    [CompilerGeneratedAttribute]
public IImmutableStack`1<IReadOnlyCollection`1<ComposedPartDiagnostic>> get_CompositionErrors();
    [CompilerGeneratedAttribute]
private void set_CompositionErrors(IImmutableStack`1<IReadOnlyCollection`1<ComposedPartDiagnostic>> value);
    internal Resolver get_Resolver();
    public static CompositionConfiguration Create(ComposableCatalog catalog);
    private static ImmutableDictionary`2<Type, ExportDefinitionBinding> GetMetadataViewProvidersMap(ComposableCatalog customizedCatalog);
    public IExportProviderFactory CreateExportProviderFactory();
    public string GetEffectiveSharingBoundary(ComposablePartDefinition partDefinition);
    public CompositionConfiguration ThrowOnErrors();
    private static ImmutableStack`1<T> PathExistsBetween(T origin, T target, Func`2<T, IEnumerable`1<T>> getDirectLinks, HashSet`1<T> visited);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Composition.CompositionConfiguration/<FindLoops>d__27")]
private static IEnumerable`1<ComposedPartDiagnostic> FindLoops(IEnumerable`1<ComposedPart> parts);
    private static ImmutableDictionary`2<ComposablePartDefinition, string> ComputeInferredSharingBoundaries(IEnumerable`1<PartBuilder> partBuilders);
    private static ImmutableDictionary`2<string, SharingBoundaryMetadata> ComputeSharingBoundaryMetadata(IEnumerable`1<PartBuilder> partBuilders);
    public XDocument CreateDgml();
    private static XDocument CreateDgml(ISet`1<ComposedPart> parts);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Microsoft.VisualStudio.Composition.CompositionConstants : object {
    internal static string DgmlCategoryPartMetadataName;
    internal static string PartCreationPolicyMetadataName;
    internal static string GenericContractMetadataName;
    public static string GenericParametersMetadataName;
    internal static string ExportTypeIdentityMetadataName;
    internal static string IsOpenGenericExport;
    internal static string ExportFactoryProductImportDefinition;
    internal static string ExportFactoryTypeMetadataName;
    internal static string ProductDefinitionMetadataName;
    internal static string PartCreatorContractName;
    private static string MefV1CompositionNamespace;
    private static string MefV3CompositionNamespace;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Composition.CompositionFailedException : Exception {
    private string errorsAsString;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IImmutableStack`1<IReadOnlyCollection`1<ComposedPartDiagnostic>> <Errors>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IImmutableStack`1<IReadOnlyCollection`1<ComposedPartDiagnostic>> Errors { get; private set; }
    public string ErrorsAsString { get; }
    public CompositionFailedException(string message);
    public CompositionFailedException(string message, Exception innerException);
    [NullableContextAttribute("1")]
public CompositionFailedException(string message, IImmutableStack`1<IReadOnlyCollection`1<ComposedPartDiagnostic>> errors);
    [NullableContextAttribute("1")]
protected CompositionFailedException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public IImmutableStack`1<IReadOnlyCollection`1<ComposedPartDiagnostic>> get_Errors();
    [CompilerGeneratedAttribute]
private void set_Errors(IImmutableStack`1<IReadOnlyCollection`1<ComposedPartDiagnostic>> value);
    public string get_ErrorsAsString();
    [NullableContextAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.VisualStudio.Composition.CompressedUInt : object {
    internal static void WriteCompressedUInt(BinaryWriter writer, UInt32 value);
    internal static UInt32 ReadCompressedUInt(BinaryReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.Composition.ContractNameServices : object {
    private static char NamespaceSeparator;
    private static char ArrayOpeningBracket;
    private static char ArrayClosingBracket;
    private static char ArraySeparator;
    private static char PointerSymbol;
    private static char ReferenceSymbol;
    private static char GenericArityBackQuote;
    private static char NestedClassSeparator;
    private static char ContractNameGenericOpeningBracket;
    private static char ContractNameGenericClosingBracket;
    private static char ContractNameGenericArgumentSeparator;
    private static char CustomModifiersSeparator;
    private static char GenericFormatOpeningBracket;
    private static char GenericFormatClosingBracket;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ThreadStaticAttribute]
private static Dictionary`2<Type, string> typeIdentityCache;
    private static Dictionary`2<Type, string> TypeIdentityCache { get; }
    private static Dictionary`2<Type, string> get_TypeIdentityCache();
    internal static string GetTypeIdentity(Type type);
    internal static string GetTypeIdentity(Type type, bool formatGenericName);
    internal static string GetTypeIdentityFromMethod(MethodInfo method);
    internal static string GetTypeIdentityFromMethod(MethodInfo method, bool formatGenericName);
    private static void WriteTypeWithNamespace(StringBuilder typeName, Type type, bool formatGenericName);
    private static void WriteType(StringBuilder typeName, Type type, bool formatGenericName);
    private static void WriteNonGenericType(StringBuilder typeName, Type type, bool formatGenericName);
    private static void WriteArrayType(StringBuilder typeName, Type type, bool formatGenericName);
    private static void WritePointerType(StringBuilder typeName, Type type, bool formatGenericName);
    private static void WriteByRefType(StringBuilder typeName, Type type, bool formatGenericName);
    private static void WriteArrayTypeDimensions(StringBuilder typeName, Type type);
    private static void WriteGenericType(StringBuilder typeName, Type type, bool isDefinition, Queue`1<Type> genericTypeArguments, bool formatGenericName);
    private static void WriteGenericTypeName(StringBuilder typeName, Type type, bool isDefinition, Queue`1<Type> genericTypeArguments, bool formatGenericName);
    private static void WriteTypeArgumentsString(StringBuilder typeName, int argumentsCount, bool isDefinition, Queue`1<Type> genericTypeArguments, bool formatGenericName);
    private static void WriteTypeArgument(StringBuilder typeName, bool isDefinition, Type genericTypeArgument, bool formatGenericName);
    private static Type FindArrayElementType(Type type);
    private static string FindGenericTypeName(string genericName);
    private static int GetGenericArity(Type type);
    [ExtensionAttribute]
private static Type[] GetGenericArguments(Type type);
}
public enum Microsoft.VisualStudio.Composition.CreationPolicy : Enum {
    public int value__;
    public static CreationPolicy Any;
    public static CreationPolicy Shared;
    public static CreationPolicy NonShared;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.Composition.DelegateServices : object {
    private static MethodInfo CastAsFuncMethodInfo;
    private static DelegateServices();
    internal static Func`1<T> FromValue(T value);
    [ExtensionAttribute]
internal static Func`1<T> As(Func`1<object> valueFactory);
    [ExtensionAttribute]
internal static Func`1<object> As(Func`1<object> func, Type typeArg);
    [ExtensionAttribute]
private static Func`1<T> AsFunc(T value);
    [ExtensionAttribute]
private static T Return(T value);
    [ExtensionAttribute]
private static T AsHelper(Func`1<object> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.VisualStudio.Composition.DelegatingExportProvider : ExportProvider {
    private ExportProvider inner;
    protected DelegatingExportProvider(ExportProvider inner);
    public virtual IEnumerable`1<Export> GetExports(ImportDefinition importDefinition);
    internal virtual IMetadataViewProvider GetMetadataViewProvider(Type metadataView);
    private protected sealed virtual IEnumerable`1<ExportInfo> GetExportsCore(ImportDefinition importDefinition);
    internal virtual PartLifecycleTracker CreatePartLifecycleTracker(TypeRef partType, IReadOnlyDictionary`2<string, object> importMetadata, PartLifecycleTracker nonSharedPartOwner);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.Composition.Dgml : object {
    internal static string Namespace;
    private static XName NodeName;
    private static XName NodesName;
    private static XName LinkName;
    private static XName LinksName;
    private static XName StylesName;
    private static XName StyleName;
    private static Dgml();
    internal static XDocument Create(XElement& nodes, XElement& links, string layout, string direction);
    [ExtensionAttribute]
private static XElement GetRootElement(XDocument document, XName name);
    private static XElement GetRootElement(XDocument document, string elementName);
    [ExtensionAttribute]
internal static XDocument WithCategories(XDocument document, String[] categories);
    [ExtensionAttribute]
internal static XDocument WithCategories(XDocument document, XElement[] categories);
    [NullableContextAttribute("2")]
internal static XElement Node(string id, string label, string group);
    [ExtensionAttribute]
internal static XDocument WithNode(XDocument document, XElement node);
    internal static XElement Link(string source, string target, string label);
    internal static XElement Link(XElement source, XElement target, string label);
    [ExtensionAttribute]
internal static XDocument WithLink(XDocument document, XElement link);
    [NullableContextAttribute("2")]
internal static XElement Category(string id, string label, string background, string foreground, string icon, bool isTag, bool isContainment);
    internal static XElement Comment(string label);
    internal static XElement Container(string id, string label);
    [ExtensionAttribute]
internal static XDocument WithContainers(XDocument document, IEnumerable`1<XElement> containers);
    [ExtensionAttribute]
internal static XElement ContainedBy(XElement node, XElement container);
    [ExtensionAttribute]
internal static XElement ContainedBy(XElement node, string containerId, XDocument document);
    [ExtensionAttribute]
internal static XElement WithCategories(XElement element, String[] categories);
    [ExtensionAttribute]
internal static XDocument WithStyle(XDocument document, string categoryId, IEnumerable`1<KeyValuePair`2<string, string>> properties, string targetType);
    [ExtensionAttribute]
internal static XDocument WithStyle(XDocument document, string categoryId, string targetType, string foreground, string background, string icon);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Composition.DiscoveredParts : object {
    public static DiscoveredParts Empty;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<ComposablePartDefinition> <Parts>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableList`1<PartDiscoveryException> <DiscoveryErrors>k__BackingField;
    public ImmutableHashSet`1<ComposablePartDefinition> Parts { get; private set; }
    public ImmutableList`1<PartDiscoveryException> DiscoveryErrors { get; private set; }
    public DiscoveredParts(IEnumerable`1<ComposablePartDefinition> parts, IEnumerable`1<PartDiscoveryException> discoveryErrors);
    private static DiscoveredParts();
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<ComposablePartDefinition> get_Parts();
    [CompilerGeneratedAttribute]
private void set_Parts(ImmutableHashSet`1<ComposablePartDefinition> value);
    [CompilerGeneratedAttribute]
public ImmutableList`1<PartDiscoveryException> get_DiscoveryErrors();
    [CompilerGeneratedAttribute]
private void set_DiscoveryErrors(ImmutableList`1<PartDiscoveryException> value);
    public DiscoveredParts ThrowOnErrors();
    internal DiscoveredParts Merge(DiscoveredParts other);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Composition.DiscoveryProgress : ValueType {
    [CompilerGeneratedAttribute]
private int <CompletedSteps>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TotalSteps>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Status>k__BackingField;
    public int CompletedSteps { get; private set; }
    public int TotalSteps { get; private set; }
    public float Completion { get; }
    public string Status { get; private set; }
    public DiscoveryProgress(int completedSteps, int totalSteps, string status);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_CompletedSteps();
    [CompilerGeneratedAttribute]
private void set_CompletedSteps(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_TotalSteps();
    [CompilerGeneratedAttribute]
private void set_TotalSteps(int value);
    public float get_Completion();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Status();
    [CompilerGeneratedAttribute]
private void set_Status(string value);
}
internal class Microsoft.VisualStudio.Composition.DisposableWithAction : object {
    [NullableAttribute("1")]
private Action action;
    [NullableContextAttribute("1")]
internal DisposableWithAction(Action action);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class Microsoft.VisualStudio.Composition.Export : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<object> exportedValueGetter;
    [CompilerGeneratedAttribute]
private ExportDefinition <Definition>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private AssemblyName <ExportingAssemblyName>k__BackingField;
    public ExportDefinition Definition { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyDictionary`2<string, object> Metadata { get; }
    [NullableAttribute("2")]
public object Value { get; }
    [NullableAttribute("2")]
internal AssemblyName ExportingAssemblyName { get; internal set; }
    private string DebuggerDisplay { get; }
    public Export(string contractName, IReadOnlyDictionary`2<string, object> metadata, Func`1<object> exportedValueGetter);
    public Export(ExportDefinition definition, Func`1<object> exportedValueGetter);
    public Export(ExportDefinition definition, Lazy`1<object> exportedValueGetter);
    [CompilerGeneratedAttribute]
public ExportDefinition get_Definition();
    [CompilerGeneratedAttribute]
private void set_Definition(ExportDefinition value);
    public IReadOnlyDictionary`2<string, object> get_Metadata();
    [NullableContextAttribute("2")]
public object get_Value();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal AssemblyName get_ExportingAssemblyName();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ExportingAssemblyName(AssemblyName value);
    [NullableContextAttribute("2")]
internal virtual object ValueFilter(object lazyValue);
    private string get_DebuggerDisplay();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{ContractName,nq}")]
public class Microsoft.VisualStudio.Composition.ExportDefinition : object {
    [CompilerGeneratedAttribute]
private string <ContractName>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, object> <Metadata>k__BackingField;
    public string ContractName { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyDictionary`2<string, object> Metadata { get; private set; }
    public ExportDefinition(string contractName, IReadOnlyDictionary`2<string, object> metadata);
    [CompilerGeneratedAttribute]
public string get_ContractName();
    [CompilerGeneratedAttribute]
private void set_ContractName(string value);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, object> get_Metadata();
    [CompilerGeneratedAttribute]
private void set_Metadata(IReadOnlyDictionary`2<string, object> value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(ExportDefinition other);
    public void ToString(TextWriter writer);
    internal void GetInputAssemblies(ISet`1<AssemblyName> assemblies, Func`2<Assembly, AssemblyName> nameGetter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Composition.ExportDefinitionBinding : object {
    [CompilerGeneratedAttribute]
private ExportDefinition <ExportDefinition>k__BackingField;
    [CompilerGeneratedAttribute]
private ComposablePartDefinition <PartDefinition>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private MemberRef <ExportingMemberRef>k__BackingField;
    public ExportDefinition ExportDefinition { get; private set; }
    public ComposablePartDefinition PartDefinition { get; private set; }
    [NullableAttribute("2")]
public MemberInfo ExportingMember { get; }
    [NullableAttribute("2")]
public MemberRef ExportingMemberRef { get; private set; }
    public bool IsStaticExport { get; }
    public TypeRef ExportedValueTypeRef { get; }
    public Type ExportedValueType { get; }
    public ExportDefinitionBinding(ExportDefinition exportDefinition, ComposablePartDefinition partDefinition, MemberRef exportingMemberRef);
    [CompilerGeneratedAttribute]
public ExportDefinition get_ExportDefinition();
    [CompilerGeneratedAttribute]
private void set_ExportDefinition(ExportDefinition value);
    [CompilerGeneratedAttribute]
public ComposablePartDefinition get_PartDefinition();
    [CompilerGeneratedAttribute]
private void set_PartDefinition(ComposablePartDefinition value);
    [NullableContextAttribute("2")]
public MemberInfo get_ExportingMember();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public MemberRef get_ExportingMemberRef();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_ExportingMemberRef(MemberRef value);
    public bool get_IsStaticExport();
    public TypeRef get_ExportedValueTypeRef();
    public Type get_ExportedValueType();
    internal ExportDefinitionBinding CloseGenericExport(Type[] genericTypeArguments);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(ExportDefinitionBinding other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Composition.ExportedDelegate : object {
    [NullableAttribute("2")]
private object target;
    private MethodInfo method;
    public ExportedDelegate(object target, MethodInfo method);
    public Delegate CreateDelegate(Type delegateType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.Composition.ExportFactory : object {
    private static string ExportFactoryV1FullName;
    private static string ExportFactoryV2FullName;
    [ExtensionAttribute]
internal static bool IsExportFactoryType(Type type);
    [ExtensionAttribute]
internal static bool IsExportFactoryType(TypeRef type);
    [ExtensionAttribute]
internal static bool IsExportFactoryTypeV1(Type type);
    [ExtensionAttribute]
internal static bool IsExportFactoryTypeV1(TypeRef type);
    [ExtensionAttribute]
internal static bool IsExportFactoryTypeV2(Type type);
    [ExtensionAttribute]
internal static bool IsExportFactoryTypeV2(TypeRef type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Composition.ExportMetadataValueImportConstraint : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public string Name { get; private set; }
    [NullableAttribute("2")]
public object Value { get; private set; }
    public ExportMetadataValueImportConstraint(string name, object value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public object get_Value();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_Value(object value);
    public sealed virtual bool IsSatisfiedBy(ExportDefinition exportDefinition);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IImportSatisfiabilityConstraint obj);
    public sealed virtual void ToString(TextWriter writer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.VisualStudio.Composition.ExportMetadataViewInterfaceEmitProxy : object {
    internal static ComposablePartDefinition PartDefinition;
    private static ExportMetadataViewInterfaceEmitProxy();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.VisualStudio.Composition.ExportProvider : object {
    internal static ExportDefinition ExportProviderExportDefinition;
    internal static ComposablePartDefinition ExportProviderPartDefinition;
    protected static Lazy`1<object> NotInstantiablePartLazy;
    protected static Type[] EmptyTypeArray;
    protected static Object[] EmptyObjectArray;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected static ImmutableDictionary`2<string, object> EmptyMetadata;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Dictionary`2<Type, IReadOnlyDictionary`2<string, object>> GetMetadataViewDefaultsCache;
    private static ImmutableDictionary`2<string, Dictionary`2<TypeRef, PartLifecycleTracker>> SharedInstantiatedPartsTemplate;
    private static ImmutableDictionary`2<string, HashSet`1<IDisposable>> DisposableInstantiatedSharedPartsTemplate;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<ImmutableArray`1<Lazy`2<IMetadataViewProvider, IReadOnlyDictionary`2<string, object>>>> metadataViewProviders;
    private ImmutableDictionary`2<string, Dictionary`2<TypeRef, PartLifecycleTracker>> sharedInstantiatedParts;
    private ImmutableDictionary`2<string, ExportProvider> sharingBoundaryExportProviderOwners;
    private ImmutableDictionary`2<string, HashSet`1<IDisposable>> disposableInstantiatedSharedParts;
    private HashSet`1<IDisposable> disposableNonSharedParts;
    private ImmutableHashSet`1<string> freshSharingBoundaries;
    private Dictionary`2<Type, IMetadataViewProvider> typeAndSelectedMetadataViewProviderCache;
    private bool isDisposed;
    [CompilerGeneratedAttribute]
private Lazy`1<object> <NonDisposableWrapper>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableList`1<Export> <NonDisposableWrapperExportAsListOfOne>k__BackingField;
    [CompilerGeneratedAttribute]
private Resolver <Resolver>k__BackingField;
    private bool Microsoft.IDisposableObservable.IsDisposed { get; }
    protected Lazy`1<object> NonDisposableWrapper { get; private set; }
    protected ImmutableList`1<Export> NonDisposableWrapperExportAsListOfOne { get; private set; }
    protected internal Resolver Resolver { get; }
    private ExportProvider(Resolver resolver, ImmutableDictionary`2<string, Dictionary`2<TypeRef, PartLifecycleTracker>> sharedInstantiatedParts, ImmutableDictionary`2<string, HashSet`1<IDisposable>> disposableInstantiatedSharedParts, ImmutableHashSet`1<string> freshSharingBoundaries, ImmutableDictionary`2<string, ExportProvider> sharingBoundaryExportProviderOwners, Lazy`1<ImmutableArray`1<Lazy`2<IMetadataViewProvider, IReadOnlyDictionary`2<string, object>>>> inheritedMetadataViewProviders);
    private protected ExportProvider(Resolver resolver);
    private protected ExportProvider(ExportProvider parent, ImmutableHashSet`1<string> freshSharingBoundaries);
    private static ExportProvider();
    private sealed virtual override bool Microsoft.IDisposableObservable.get_IsDisposed();
    [CompilerGeneratedAttribute]
protected Lazy`1<object> get_NonDisposableWrapper();
    [CompilerGeneratedAttribute]
private void set_NonDisposableWrapper(Lazy`1<object> value);
    [CompilerGeneratedAttribute]
protected ImmutableList`1<Export> get_NonDisposableWrapperExportAsListOfOne();
    [CompilerGeneratedAttribute]
private void set_NonDisposableWrapperExportAsListOfOne(ImmutableList`1<Export> value);
    [CompilerGeneratedAttribute]
protected internal Resolver get_Resolver();
    [NullableContextAttribute("2")]
public static bool TryGetExportingAssemblyName(Lazy`1<T> export, AssemblyName& assemblyName);
    public Lazy`1<T> GetExport();
    [NullableContextAttribute("2")]
public Lazy`1<T> GetExport(string contractName);
    [NullableContextAttribute("2")]
public Lazy`2<T, TMetadataView> GetExport();
    [NullableContextAttribute("2")]
public Lazy`2<T, TMetadataView> GetExport(string contractName);
    public T GetExportedValue();
    [NullableContextAttribute("2")]
public T GetExportedValue(string contractName);
    public IEnumerable`1<Lazy`1<T>> GetExports();
    [NullableContextAttribute("2")]
public IEnumerable`1<Lazy`1<T>> GetExports(string contractName);
    [NullableContextAttribute("2")]
public IEnumerable`1<Lazy`2<T, TMetadataView>> GetExports();
    [NullableContextAttribute("2")]
public IEnumerable`1<Lazy`2<T, TMetadataView>> GetExports(string contractName);
    public IEnumerable`1<Lazy`2<object, object>> GetExports(Type type, Type metadataViewType, string contractName);
    public IEnumerable`1<T> GetExportedValues();
    [NullableContextAttribute("2")]
public IEnumerable`1<T> GetExportedValues(string contractName);
    public IEnumerable`1<object> GetExportedValues(Type type, string contractName);
    public virtual IEnumerable`1<Export> GetExports(ImportDefinition importDefinition);
    public void ReleaseExport(Export export);
    public void ReleaseExport(Lazy`1<T> export);
    public void ReleaseExports(IEnumerable`1<Export> exports);
    public void ReleaseExports(IEnumerable`1<Lazy`1<T>> exports);
    [NullableContextAttribute("2")]
public void ReleaseExports(IEnumerable`1<Lazy`2<T, TMetadataView>> exports);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected static object CannotInstantiatePartWithNoImportingConstructor();
    private protected static bool IsFullyInitializedExportRequiredWhenSettingImport(bool isLazy, bool isImportingConstructorArgument);
    private protected abstract virtual IEnumerable`1<ExportInfo> GetExportsCore(ImportDefinition importDefinition);
    private protected ExportInfo CreateExport(ImportDefinition importDefinition, IReadOnlyDictionary`2<string, object> exportMetadata, TypeRef originalPartTypeRef, TypeRef constructedPartTypeRef, string partSharingBoundary, bool nonSharedInstanceRequired, MemberRef exportingMemberRef);
    protected object CreateExportFactory(Type importingSiteElementType, IReadOnlyCollection`1<string> sharingBoundaries, Func`1<KeyValuePair`2<object, IDisposable>> valueFactory, Type exportFactoryType, IReadOnlyDictionary`2<string, object> exportMetadata);
    private Export CreateExportFactoryExport(ExportInfo exportInfo, Type exportFactoryType);
    protected object GetStrongTypedMetadata(IReadOnlyDictionary`2<string, object> metadata, Type metadataType);
    [NullableContextAttribute("2")]
protected static object GetValueFromMember(object exportingPart, MemberInfo exportingMember, Type importingSiteElementType, Type exportedValueType);
    private protected PartLifecycleTracker GetOrCreateValue(TypeRef originalPartTypeRef, TypeRef constructedPartTypeRef, string partSharingBoundary, IReadOnlyDictionary`2<string, object> importMetadata, bool nonSharedInstanceRequired, PartLifecycleTracker nonSharedPartOwner);
    private protected PartLifecycleTracker GetOrCreateShareableValue(TypeRef originalPartTypeRef, TypeRef constructedPartTypeRef, string partSharingBoundary, IReadOnlyDictionary`2<string, object> importMetadata);
    private protected PartLifecycleTracker CreateNewValue(TypeRef originalPartTypeRef, TypeRef constructedPartTypeRef, string partSharingBoundary, IReadOnlyDictionary`2<string, object> importMetadata, PartLifecycleTracker nonSharedPartOwner);
    internal abstract virtual PartLifecycleTracker CreatePartLifecycleTracker(TypeRef partType, IReadOnlyDictionary`2<string, object> importMetadata, PartLifecycleTracker nonSharedPartOwner);
    private bool TryGetSharedInstanceFactory(string partSharingBoundary, TypeRef partTypeRef, PartLifecycleTracker& value);
    private PartLifecycleTracker GetOrAddSharedInstanceFactory(string partSharingBoundary, TypeRef partTypeRef, PartLifecycleTracker value);
    protected void TrackDisposableValue(IDisposable instantiatedPart, string sharingBoundary);
    private bool ReleaseNonSharedPart(IDisposable nonSharedPart);
    protected MethodInfo GetMethodWithArity(Type declaringType, string methodName, int arity);
    protected static IReadOnlyDictionary`2<string, object> GetMetadataViewDefaults(Type metadataView);
    internal static int GetOrderMetadata(IReadOnlyDictionary`2<string, object> metadata);
    [NullableContextAttribute("2")]
private static T CastValueTo(object value);
    [NullableContextAttribute("2")]
private IEnumerable`1<Lazy`2<T, TMetadataView>> GetExports(string contractName, ImportCardinality cardinality);
    private IEnumerable`1<Export> GetExports(string contractName, ImportCardinality cardinality, Type type, Type metadataViewType, IMetadataViewProvider& metadataViewProvider);
    private ImmutableArray`1<Lazy`2<IMetadataViewProvider, IReadOnlyDictionary`2<string, object>>> GetMetadataViewProviderExtensions();
    internal virtual IMetadataViewProvider GetMetadataViewProvider(Type metadataView);
    private Dictionary`2<TypeRef, PartLifecycleTracker> AcquireSharingBoundaryInstances(string sharingBoundaryName);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private KeyValuePair`2<string, ExportProvider> <.ctor>b__20_0(string boundary);
    [CompilerGeneratedAttribute]
internal static Lazy`2<T, TMetadataView> <GetExports>g__CreateLazy|81_0(Export export, IMetadataViewProvider metadataViewProvider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Composition.ExportTypeIdentityConstraint : object {
    [CompilerGeneratedAttribute]
private string <TypeIdentityName>k__BackingField;
    public string TypeIdentityName { get; private set; }
    public ExportTypeIdentityConstraint(Type typeIdentity);
    public ExportTypeIdentityConstraint(string typeIdentityName);
    [CompilerGeneratedAttribute]
public string get_TypeIdentityName();
    [CompilerGeneratedAttribute]
private void set_TypeIdentityName(string value);
    public static ImmutableDictionary`2<string, object> GetExportMetadata(Type type);
    public static ImmutableDictionary`2<string, object> GetExportMetadata(string typeIdentity);
    public sealed virtual bool IsSatisfiedBy(ExportDefinition exportDefinition);
    public sealed virtual void ToString(TextWriter writer);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IImportSatisfiabilityConstraint obj);
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.Composition.IAssemblyLoader {
    public abstract virtual Assembly LoadAssembly(string assemblyFullName, string codeBasePath);
    public abstract virtual Assembly LoadAssembly(AssemblyName assemblyName);
}
[NullableContextAttribute("2")]
internal interface Microsoft.VisualStudio.Composition.IComposedLazy {
    public AssemblyName AssemblyName { get; }
    public abstract virtual AssemblyName get_AssemblyName();
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.Composition.ICompositionCacheManager {
    public abstract virtual Task SaveAsync(CompositionConfiguration configuration, Stream cacheStream, CancellationToken cancellationToken);
    public abstract virtual Task`1<IExportProviderFactory> LoadExportProviderFactoryAsync(Stream cacheStream, Resolver resolver, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Composition.IDescriptiveToString {
    public abstract virtual void ToString(TextWriter writer);
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.Composition.IExportProviderFactory {
    public abstract virtual ExportProvider CreateExportProvider();
}
public interface Microsoft.VisualStudio.Composition.IFaultReportingExportProviderFactory {
    [NullableContextAttribute("1")]
public abstract virtual ExportProvider CreateExportProvider(ReportFaultCallback faultCallback);
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.Composition.IImportSatisfiabilityConstraint {
    public abstract virtual bool IsSatisfiedBy(ExportDefinition exportDefinition);
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Composition.IMetadataViewProvider {
    public abstract virtual bool IsMetadataViewSupported(Type metadataType);
    public abstract virtual object CreateProxy(IReadOnlyDictionary`2<string, object> metadata, IReadOnlyDictionary`2<string, object> defaultValues, Type metadataViewType);
}
public enum Microsoft.VisualStudio.Composition.ImportCardinality : Enum {
    public int value__;
    public static ImportCardinality ExactlyOne;
    public static ImportCardinality OneOrZero;
    public static ImportCardinality ZeroOrMore;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{ContractName,nq} ({Cardinality})")]
public class Microsoft.VisualStudio.Composition.ImportDefinition : object {
    private ImmutableList`1<IImportSatisfiabilityConstraint> exportConstraints;
    [CompilerGeneratedAttribute]
private string <ContractName>k__BackingField;
    [CompilerGeneratedAttribute]
private ImportCardinality <Cardinality>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <ExportFactorySharingBoundaries>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, object> <Metadata>k__BackingField;
    public string ContractName { get; private set; }
    public ImportCardinality Cardinality { get; private set; }
    public IReadOnlyCollection`1<string> ExportFactorySharingBoundaries { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyDictionary`2<string, object> Metadata { get; private set; }
    public IReadOnlyCollection`1<IImportSatisfiabilityConstraint> ExportConstraints { get; }
    public ImportDefinition(string contractName, ImportCardinality cardinality, IReadOnlyDictionary`2<string, object> metadata, IReadOnlyCollection`1<IImportSatisfiabilityConstraint> additionalConstraints, IReadOnlyCollection`1<string> exportFactorySharingBoundaries);
    public ImportDefinition(string contractName, ImportCardinality cardinality, IReadOnlyDictionary`2<string, object> metadata, IReadOnlyCollection`1<IImportSatisfiabilityConstraint> additionalConstraints);
    [CompilerGeneratedAttribute]
public string get_ContractName();
    [CompilerGeneratedAttribute]
private void set_ContractName(string value);
    [CompilerGeneratedAttribute]
public ImportCardinality get_Cardinality();
    [CompilerGeneratedAttribute]
private void set_Cardinality(ImportCardinality value);
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<string> get_ExportFactorySharingBoundaries();
    [CompilerGeneratedAttribute]
private void set_ExportFactorySharingBoundaries(IReadOnlyCollection`1<string> value);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, object> get_Metadata();
    [CompilerGeneratedAttribute]
private void set_Metadata(IReadOnlyDictionary`2<string, object> value);
    public IReadOnlyCollection`1<IImportSatisfiabilityConstraint> get_ExportConstraints();
    public ImportDefinition WithExportConstraints(IReadOnlyCollection`1<IImportSatisfiabilityConstraint> constraints);
    public ImportDefinition AddExportConstraint(IImportSatisfiabilityConstraint constraint);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(ImportDefinition other);
    public void ToString(TextWriter writer);
    internal void GetInputAssemblies(ISet`1<AssemblyName> assemblies, Func`2<Assembly, AssemblyName> nameRetriever);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Composition.ImportDefinitionBinding : object {
    private Nullable`1<bool> isLazy;
    [NullableAttribute("2")]
private TypeRef importingSiteElementTypeRef;
    [CompilerGeneratedAttribute]
private ImportDefinition <ImportDefinition>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private MemberRef <ImportingMemberRef>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ParameterRef <ImportingParameterRef>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeRef <ComposablePartTypeRef>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeRef <ImportingSiteTypeRef>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeRef <ImportingSiteTypeWithoutCollectionRef>k__BackingField;
    public ImportDefinition ImportDefinition { get; private set; }
    [NullableAttribute("2")]
public MemberInfo ImportingMember { get; }
    [NullableAttribute("2")]
public MemberRef ImportingMemberRef { get; private set; }
    [NullableAttribute("2")]
public ParameterInfo ImportingParameter { get; }
    [NullableAttribute("2")]
public ParameterRef ImportingParameterRef { get; private set; }
    public Type ComposablePartType { get; }
    public TypeRef ComposablePartTypeRef { get; private set; }
    public Type ImportingSiteType { get; }
    public TypeRef ImportingSiteTypeRef { get; }
    public TypeRef ImportingSiteTypeWithoutCollectionRef { get; }
    public Type ImportingSiteTypeWithoutCollection { get; }
    public TypeRef ImportingSiteElementTypeRef { get; }
    [NullableAttribute("2")]
public Type ImportingSiteElementType { get; }
    public bool IsLazy { get; }
    [NullableAttribute("2")]
public Type MetadataType { get; }
    public bool IsExportFactory { get; }
    [NullableAttribute("2")]
public Type ExportFactoryType { get; }
    public ImportDefinitionBinding(ImportDefinition importDefinition, TypeRef composablePartType, MemberRef importingMember, TypeRef importingSiteTypeRef, TypeRef importingSiteTypeWithoutCollectionRef);
    public ImportDefinitionBinding(ImportDefinition importDefinition, TypeRef composablePartType, ParameterRef importingConstructorParameter, TypeRef importingSiteTypeRef, TypeRef importingSiteTypeWithoutCollectionRef);
    [CompilerGeneratedAttribute]
public ImportDefinition get_ImportDefinition();
    [CompilerGeneratedAttribute]
private void set_ImportDefinition(ImportDefinition value);
    [NullableContextAttribute("2")]
public MemberInfo get_ImportingMember();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public MemberRef get_ImportingMemberRef();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_ImportingMemberRef(MemberRef value);
    [NullableContextAttribute("2")]
public ParameterInfo get_ImportingParameter();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ParameterRef get_ImportingParameterRef();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_ImportingParameterRef(ParameterRef value);
    public Type get_ComposablePartType();
    [CompilerGeneratedAttribute]
public TypeRef get_ComposablePartTypeRef();
    [CompilerGeneratedAttribute]
private void set_ComposablePartTypeRef(TypeRef value);
    public Type get_ImportingSiteType();
    [CompilerGeneratedAttribute]
public TypeRef get_ImportingSiteTypeRef();
    [CompilerGeneratedAttribute]
public TypeRef get_ImportingSiteTypeWithoutCollectionRef();
    public Type get_ImportingSiteTypeWithoutCollection();
    public TypeRef get_ImportingSiteElementTypeRef();
    [NullableContextAttribute("2")]
public Type get_ImportingSiteElementType();
    public bool get_IsLazy();
    [NullableContextAttribute("2")]
public Type get_MetadataType();
    public bool get_IsExportFactory();
    [NullableContextAttribute("2")]
public Type get_ExportFactoryType();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(ImportDefinitionBinding other);
    public void ToString(TextWriter writer);
    internal void GetInputAssemblies(ISet`1<AssemblyName> assemblies, Func`2<Assembly, AssemblyName> nameRetriever);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Composition.ImportMetadataViewConstraint : object {
    private static ImportMetadataViewConstraint EmptyInstance;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<string, MetadatumRequirement> <Requirements>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Resolver <Resolver>k__BackingField;
    public ImmutableDictionary`2<string, MetadatumRequirement> Requirements { get; private set; }
    [NullableAttribute("2")]
public Resolver Resolver { get; }
    public ImportMetadataViewConstraint(IReadOnlyDictionary`2<string, MetadatumRequirement> metadataNamesAndTypes, Resolver resolver);
    private static ImportMetadataViewConstraint();
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<string, MetadatumRequirement> get_Requirements();
    [CompilerGeneratedAttribute]
private void set_Requirements(ImmutableDictionary`2<string, MetadatumRequirement> value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Resolver get_Resolver();
    public static ImportMetadataViewConstraint GetConstraint(TypeRef metadataTypeRef, Resolver resolver);
    public sealed virtual bool IsSatisfiedBy(ExportDefinition exportDefinition);
    public sealed virtual void ToString(TextWriter writer);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IImportSatisfiabilityConstraint obj);
    private static ImmutableDictionary`2<string, MetadatumRequirement> GetRequiredMetadata(TypeRef metadataViewRef, Resolver resolver);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Composition.IndentingTextWriter : TextWriter {
    private static string Indentation;
    private TextWriter inner;
    private Stack`1<string> indentationStack;
    public Encoding Encoding { get; }
    internal IndentingTextWriter(TextWriter inner);
    public virtual Encoding get_Encoding();
    internal static IndentingTextWriter Get(TextWriter writer);
    [NullableContextAttribute("2")]
public virtual void WriteLine(string value);
    public virtual void Write(char value);
    protected virtual void Dispose(bool disposing);
    internal CancelIndent Indent();
    internal void Unindent();
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.Composition.IRuntimeCompositionCacheManager {
    public abstract virtual Task SaveAsync(RuntimeComposition composition, Stream cacheStream, CancellationToken cancellationToken);
    public abstract virtual Task`1<RuntimeComposition> LoadRuntimeCompositionAsync(Stream cacheStream, Resolver resolver, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Microsoft.VisualStudio.Composition.LazyMetadataWrapper : object {
    private static HashSet`1<Assembly> AlwaysLoadedAssemblies;
    private Direction direction;
    private Resolver resolver;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected ImmutableDictionary`2<string, object> underlyingMetadata;
    public IEnumerable`1<string> Keys { get; }
    private ICollection`1<string> System.Collections.Generic.IDictionary<System.String,System.Object>.Keys { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<object> Values { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ICollection`1<object> System.Collections.Generic.IDictionary<System.String,System.Object>.Values { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    [NullableAttribute("2")]
public object Item { get; public set; }
    internal LazyMetadataWrapper(ImmutableDictionary`2<string, object> metadata, Direction direction, Resolver resolver);
    private static LazyMetadataWrapper();
    public sealed virtual IEnumerable`1<string> get_Keys();
    private sealed virtual override ICollection`1<string> System.Collections.Generic.IDictionary<System.String,System.Object>.get_Keys();
    public sealed virtual IEnumerable`1<object> get_Values();
    private sealed virtual override ICollection`1<object> System.Collections.Generic.IDictionary<System.String,System.Object>.get_Values();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual object get_Item(string key);
    public sealed virtual void set_Item(string key, object value);
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual bool TryGetValue(string key, Object& value);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(string key, object value);
    public sealed virtual bool Remove(string key);
    public sealed virtual void Add(KeyValuePair`2<string, object> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<string, object> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<string, object> item);
    internal static IReadOnlyDictionary`2<string, object> TryUnwrap(IReadOnlyDictionary`2<string, object> metadata);
    internal static bool TryGetLoadSafeValueTypeRef(IReadOnlyDictionary`2<string, object> metadata, string key, Resolver resolver, Object& value);
    internal static IReadOnlyDictionary`2<string, object> Rewrap(IReadOnlyDictionary`2<string, object> originalWrapper, IReadOnlyDictionary`2<string, object> updatedMetadata);
    protected virtual LazyMetadataWrapper Clone(LazyMetadataWrapper oldVersion, IReadOnlyDictionary`2<string, object> newMetadata);
    [NullableContextAttribute("2")]
protected object SubstituteValueIfRequired(string key, object value);
    protected virtual object SubstituteValueIfRequired(object value);
    private static bool IsTypeWorthDeferring(Type typeOfValue);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private <>f__AnonymousType11`2<KeyValuePair`2<string, object>, object> <get_Values>b__12_0(KeyValuePair`2<string, object> pair);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private KeyValuePair`2<string, object> <GetEnumerator>b__24_0(KeyValuePair`2<string, object> pair);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.Composition.LazyServices : object {
    private static MethodInfo CreateStronglyTypedLazyOfTMValue;
    private static MethodInfo CreateStronglyTypedLazyOfTValue;
    private static string Lazy1FullName;
    private static string Lazy2FullName;
    internal static Type DefaultMetadataViewType;
    internal static Type DefaultExportedValueType;
    private static LazyServices();
    [ExtensionAttribute]
internal static bool IsAnyLazyType(Type type);
    [ExtensionAttribute]
internal static bool IsAnyLazyType(TypeRef typeRef);
    internal static Lazy`1<T> FromValue(T value);
    [NullableContextAttribute("2")]
internal static Func`4<AssemblyName, Func`1<object>, object, object> CreateStronglyTypedLazyFactory(Type exportType, Type metadataViewType);
    [ExtensionAttribute]
internal static Func`1<T> AsFunc(Lazy`1<T> lazy);
    [ExtensionAttribute]
private static T GetLazyValue(Lazy`1<T> lazy);
    private static Lazy`1<T> CreateStronglyTypedLazyOfT(AssemblyName assemblyName, Func`1<object> funcOfObject, object metadata);
    private static Lazy`2<T, TMetadata> CreateStronglyTypedLazyOfTM(AssemblyName assemblyName, Func`1<object> funcOfObject, object metadata);
}
internal enum Microsoft.VisualStudio.Composition.MetadataTokenType : Enum {
    public UInt32 value__;
    public static MetadataTokenType Type;
    public static MetadataTokenType Field;
    public static MetadataTokenType Method;
    public static MetadataTokenType Parameter;
    public static MetadataTokenType Property;
    public static MetadataTokenType GenericParam;
    public static MetadataTokenType Mask;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Composition.MetadataViewClassDefaultCtorProvider : object {
    internal static ComposablePartDefinition PartDefinition;
    internal static IMetadataViewProvider Default;
    private static MetadataViewClassDefaultCtorProvider();
    public sealed virtual bool IsMetadataViewSupported(Type metadataType);
    public sealed virtual object CreateProxy(IReadOnlyDictionary`2<string, object> metadata, IReadOnlyDictionary`2<string, object> defaultValues, Type metadataViewType);
    private static ConstructorInfo FindConstructor(TypeInfo metadataType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Composition.MetadataViewClassProvider : object {
    internal static ComposablePartDefinition PartDefinition;
    internal static IMetadataViewProvider Default;
    private static MetadataViewClassProvider();
    public sealed virtual bool IsMetadataViewSupported(Type metadataType);
    public sealed virtual object CreateProxy(IReadOnlyDictionary`2<string, object> metadata, IReadOnlyDictionary`2<string, object> defaultValues, Type metadataViewType);
    private static ConstructorInfo FindConstructor(TypeInfo metadataType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.Composition.MetadataViewGenerator : object {
    private static string MetadataViewFactoryName;
    private static Dictionary`2<Type, MetadataViewFactory> MetadataViewFactories;
    private static Type[] CtorArgumentTypes;
    private static MethodInfo MdvDictionaryTryGet;
    private static MethodInfo MdvDictionaryIndexer;
    private static MethodInfo ObjectGetType;
    private static ConstructorInfo ObjectCtor;
    private static Dictionary`2<ImmutableHashSet`1<AssemblyName>, ModuleBuilder> TransparentProxyModuleBuilderByVisibilityCheck;
    private static MetadataViewGenerator();
    private static AssemblyBuilder CreateProxyAssemblyBuilder(ImmutableHashSet`1<AssemblyName> assemblies);
    private static Guid GenerateGuidFromAssemblies(ImmutableHashSet`1<AssemblyName> assemblies);
    private static ModuleBuilder GetProxyModuleBuilder(TypeInfo viewType);
    public static MetadataViewFactory GetMetadataViewFactory(Type viewType);
    private static TypeInfo GenerateInterfaceViewProxyType(Type viewType);
    [ExtensionAttribute]
private static IEnumerable`1<PropertyInfo> GetAllProperties(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Composition.MetadataViewImplProxy : object {
    internal static ComposablePartDefinition PartDefinition;
    private static MetadataViewImplProxy();
    public sealed virtual bool IsMetadataViewSupported(Type metadataType);
    public sealed virtual object CreateProxy(IReadOnlyDictionary`2<string, object> metadata, IReadOnlyDictionary`2<string, object> defaultValues, Type metadataViewType);
    internal static bool HasMetadataViewImplementation(Type metadataType);
    private static ConstructorInfo FindImplClassConstructor(Type metadataType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Composition.NetFxAdapters : object {
    private static ComposablePartDefinition CompositionServicePart;
    private static NetFxAdapters();
    [ExtensionAttribute]
public static ExportProvider AsExportProvider(ExportProvider exportProvider);
    [ExtensionAttribute]
public static ComposableCatalog WithCompositionService(ComposableCatalog catalog);
    [ExtensionAttribute]
[ObsoleteAttribute("Desktop support is automatically included when run on the .NET Framework.")]
public static ComposableCatalog WithDesktopSupport(ComposableCatalog catalog);
}
internal class Microsoft.VisualStudio.Composition.NullableBool : ValueType {
    private int state;
    internal bool HasValue { get; }
    internal bool Value { get; internal set; }
    internal NullableBool(bool value);
    public static NullableBool op_Implicit(bool value);
    internal bool get_HasValue();
    internal bool get_Value();
    internal void set_Value(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Composition.PartCreationPolicyConstraint : object {
    public static PartCreationPolicyConstraint SharedPartRequired;
    public static PartCreationPolicyConstraint NonSharedPartRequired;
    [CompilerGeneratedAttribute]
private CreationPolicy <RequiredCreationPolicy>k__BackingField;
    public CreationPolicy RequiredCreationPolicy { get; private set; }
    private PartCreationPolicyConstraint(CreationPolicy creationPolicy);
    private static PartCreationPolicyConstraint();
    [CompilerGeneratedAttribute]
public CreationPolicy get_RequiredCreationPolicy();
    [CompilerGeneratedAttribute]
private void set_RequiredCreationPolicy(CreationPolicy value);
    public static ImmutableDictionary`2<string, object> GetExportMetadata(CreationPolicy partCreationPolicy);
    [NullableContextAttribute("2")]
public static PartCreationPolicyConstraint GetRequiredCreationPolicyConstraint(CreationPolicy requiredCreationPolicy);
    public static ImmutableHashSet`1<IImportSatisfiabilityConstraint> GetRequiredCreationPolicyConstraints(CreationPolicy requiredCreationPolicy);
    public static bool IsNonSharedInstanceRequired(ImportDefinition importDefinition);
    public sealed virtual bool IsSatisfiedBy(ExportDefinition exportDefinition);
    public sealed virtual void ToString(TextWriter writer);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IImportSatisfiabilityConstraint obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.VisualStudio.Composition.PartDiscovery : object {
    [CompilerGeneratedAttribute]
private Resolver <Resolver>k__BackingField;
    public Resolver Resolver { get; }
    protected PartDiscovery(Resolver resolver);
    [CompilerGeneratedAttribute]
public Resolver get_Resolver();
    public static PartDiscovery Combine(PartDiscovery[] discoveryMechanisms);
    public static PartDiscovery Combine(Resolver resolver, PartDiscovery[] discoveryMechanisms);
    public ComposablePartDefinition CreatePart(Type partType);
    public Task`1<DiscoveredParts> CreatePartsAsync(Type[] partTypes);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Composition.PartDiscovery/<CreatePartsAsync>d__8")]
public Task`1<DiscoveredParts> CreatePartsAsync(IEnumerable`1<Type> partTypes, CancellationToken cancellationToken);
    public Task`1<DiscoveredParts> CreatePartsAsync(Assembly assembly, CancellationToken cancellationToken);
    public abstract virtual bool IsExportFactoryType(Type type);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Composition.PartDiscovery/<CreatePartsAsync>d__11")]
public Task`1<DiscoveredParts> CreatePartsAsync(IEnumerable`1<Assembly> assemblies, IProgress`1<DiscoveryProgress> progress, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Composition.PartDiscovery/<CreatePartsAsync>d__12")]
public Task`1<DiscoveredParts> CreatePartsAsync(IEnumerable`1<string> assemblyPaths, IProgress`1<DiscoveryProgress> progress, CancellationToken cancellationToken);
    internal static void GetAssemblyNamesFromMetadataAttributes(MemberInfo member, ISet`1<AssemblyName> assemblyNames);
    protected internal static string GetContractName(Type type);
    protected internal static Type GetTypeIdentityFromImportingType(Type type, bool importMany);
    protected internal static TypeRef GetTypeIdentityFromImportingTypeRef(TypeRef typeRef, bool importMany);
    protected internal static Type GetElementTypeFromMany(Type type);
    internal static bool TryGetElementTypeFromMany(Type type, Type& elementType);
    protected static Type GetImportingSiteTypeWithoutCollection(ImportDefinition importDefinition, Type importingSiteType);
    protected static ConstructorInfo GetImportingConstructor(Type type, bool publicOnly);
    protected ImmutableHashSet`1<IImportSatisfiabilityConstraint> GetMetadataViewConstraints(Type receivingType, bool importMany);
    protected virtual void ThrowOnInvalidImportingMemberOrParameter(ICustomAttributeProvider member, bool isImportMany);
    protected virtual void ThrowOnInvalidExportingMember(ICustomAttributeProvider member);
    protected internal static ImmutableHashSet`1<IImportSatisfiabilityConstraint> GetExportTypeIdentityConstraints(Type contractType);
    protected internal static ImmutableDictionary`2<string, object> GetImportMetadataForGenericTypeImport(Type contractType);
    [NullableContextAttribute("2")]
protected static Array AddElement(Array priorArray, object value, Type elementType);
    protected abstract virtual IEnumerable`1<Type> GetTypes(Assembly assembly);
    protected abstract virtual ComposablePartDefinition CreatePart(Type partType, bool typeExplicitlyRequested);
    internal static bool IsImportManyCollectionTypeCreateable(ImportDefinitionBinding import);
    internal static bool IsImportManyCollectionTypeCreateable(Type collectionType, Type elementType);
    private static Type GetMetadataType(Type receivingType);
    private Tuple`2<ITargetBlock`1<Type>, Task`1<DiscoveredParts>> CreateDiscoveryBlockChain(bool typeExplicitlyRequested, IProgress`1<DiscoveryProgress> progress, CancellationToken cancellationToken);
    private Tuple`2<ITargetBlock`1<Assembly>, Task`1<DiscoveredParts>> CreateAssemblyDiscoveryBlockChain(IProgress`1<DiscoveryProgress> progress, CancellationToken cancellationToken);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Composition.PartDiscoveryException : Exception {
    [CompilerGeneratedAttribute]
private string <AssemblyPath>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ScannedType>k__BackingField;
    public string AssemblyPath { get; public set; }
    public Type ScannedType { get; public set; }
    public PartDiscoveryException(string message);
    public PartDiscoveryException(string message, Exception innerException);
    [NullableContextAttribute("1")]
protected PartDiscoveryException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public string get_AssemblyPath();
    [CompilerGeneratedAttribute]
public void set_AssemblyPath(string value);
    [CompilerGeneratedAttribute]
public Type get_ScannedType();
    [CompilerGeneratedAttribute]
public void set_ScannedType(Type value);
    [NullableContextAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Composition.PassthroughMetadataViewProvider : object {
    internal static ComposablePartDefinition PartDefinition;
    internal static IMetadataViewProvider Default;
    private static PassthroughMetadataViewProvider();
    public sealed virtual bool IsMetadataViewSupported(Type metadataType);
    public sealed virtual object CreateProxy(IReadOnlyDictionary`2<string, object> metadata, IReadOnlyDictionary`2<string, object> defaultValues, Type metadataViewType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class Microsoft.VisualStudio.Composition.Reflection.FieldRef : MemberRef {
    [CompilerGeneratedAttribute]
private TypeRef <FieldTypeRef>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    public FieldInfo FieldInfo { get; }
    public TypeRef FieldTypeRef { get; }
    public string Name { get; }
    public FieldRef(TypeRef declaringType, TypeRef fieldTypeRef, int metadataToken, string name, bool isStatic);
    public FieldRef(FieldInfo field, Resolver resolver);
    private string get_DebuggerDisplay();
    public FieldInfo get_FieldInfo();
    [CompilerGeneratedAttribute]
public TypeRef get_FieldTypeRef();
    [CompilerGeneratedAttribute]
public virtual string get_Name();
    internal virtual void GetInputAssemblies(ISet`1<AssemblyName> assemblies);
    protected virtual bool EqualsByTypeLocalMetadata(MemberRef other);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(FieldRef fieldRef);
    public virtual int GetHashCode();
    protected virtual MemberInfo Resolve();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.VisualStudio.Composition.Reflection.MemberRef : object {
    private Nullable`1<int> metadataToken;
    [NullableAttribute("2")]
private MemberInfo cachedMemberInfo;
    [CompilerGeneratedAttribute]
private TypeRef <DeclaringType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStatic>k__BackingField;
    public TypeRef DeclaringType { get; }
    public AssemblyName AssemblyName { get; }
    public string Name { get; }
    public bool IsStatic { get; }
    public int MetadataToken { get; }
    public MemberInfo MemberInfo { get; }
    [NullableAttribute("2")]
internal MemberInfo MemberInfoNoResolve { get; }
    internal Resolver Resolver { get; }
    protected MemberRef(TypeRef declaringType, int metadataToken, bool isStatic);
    protected MemberRef(TypeRef declaringType, MemberInfo memberInfo);
    protected MemberRef(MemberInfo memberInfo, Resolver resolver);
    [CompilerGeneratedAttribute]
public TypeRef get_DeclaringType();
    public AssemblyName get_AssemblyName();
    public abstract virtual string get_Name();
    [CompilerGeneratedAttribute]
public bool get_IsStatic();
    public int get_MetadataToken();
    public MemberInfo get_MemberInfo();
    [NullableContextAttribute("2")]
internal MemberInfo get_MemberInfoNoResolve();
    internal Resolver get_Resolver();
    public static MemberRef Get(MemberInfo member, Resolver resolver);
    [NullableContextAttribute("2")]
public virtual bool Equals(MemberRef other);
    protected abstract virtual bool EqualsByTypeLocalMetadata(MemberRef other);
    protected abstract virtual MemberInfo Resolve();
    internal abstract virtual void GetInputAssemblies(ISet`1<AssemblyName> assemblies);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class Microsoft.VisualStudio.Composition.Reflection.MethodRef : MemberRef {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<TypeRef> <ParameterTypes>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<TypeRef> <GenericMethodArguments>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
internal string DebuggerDisplay { get; }
    public MethodBase MethodBase { get; }
    [NullableAttribute("2")]
public MethodBase MethodBaseNoResolve { get; }
    public string Name { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<TypeRef> ParameterTypes { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<TypeRef> GenericMethodArguments { get; }
    public MethodRef(TypeRef declaringType, int metadataToken, string name, bool isStatic, ImmutableArray`1<TypeRef> parameterTypes, ImmutableArray`1<TypeRef> genericMethodArguments);
    public MethodRef(MethodBase method, Resolver resolver);
    public MethodRef(MethodBase method, Resolver resolver, ImmutableArray`1<TypeRef> parameterTypes);
    protected MethodRef(ConstructorInfo constructor, Resolver resolver);
    internal virtual string get_DebuggerDisplay();
    public MethodBase get_MethodBase();
    [NullableContextAttribute("2")]
public MethodBase get_MethodBaseNoResolve();
    protected virtual MemberInfo Resolve();
    [CompilerGeneratedAttribute]
public virtual string get_Name();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<TypeRef> get_ParameterTypes();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<TypeRef> get_GenericMethodArguments();
    [NullableContextAttribute("2")]
public static MethodRef Get(MethodBase method, Resolver resolver);
    internal virtual void GetInputAssemblies(ISet`1<AssemblyName> assemblies);
    protected virtual bool EqualsByTypeLocalMetadata(MemberRef other);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(MethodRef other);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class Microsoft.VisualStudio.Composition.Reflection.ParameterRef : object {
    [NullableAttribute("2")]
private ParameterInfo cachedParameterInfo;
    [CompilerGeneratedAttribute]
private MethodRef <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ParameterIndex>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    public MethodRef Method { get; }
    [NullableAttribute("2")]
public ParameterInfo ParameterInfo { get; }
    public TypeRef DeclaringType { get; }
    public int MethodMetadataToken { get; }
    public int ParameterIndex { get; }
    public AssemblyName AssemblyName { get; }
    internal Resolver Resolver { get; }
    public ParameterRef(MethodRef method, int parameterIndex);
    public ParameterRef(ParameterInfo parameterInfo, Resolver resolver);
    private string get_DebuggerDisplay();
    [CompilerGeneratedAttribute]
public MethodRef get_Method();
    [NullableContextAttribute("2")]
public ParameterInfo get_ParameterInfo();
    public TypeRef get_DeclaringType();
    public int get_MethodMetadataToken();
    [CompilerGeneratedAttribute]
public int get_ParameterIndex();
    public AssemblyName get_AssemblyName();
    internal Resolver get_Resolver();
    public static ParameterRef Get(ParameterInfo parameter, Resolver resolver);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(ParameterRef other);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    internal void GetInputAssemblies(ISet`1<AssemblyName> assemblies);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class Microsoft.VisualStudio.Composition.Reflection.PropertyRef : MemberRef {
    private Nullable`1<int> getMethodMetadataToken;
    private Nullable`1<int> setMethodMetadataToken;
    [CompilerGeneratedAttribute]
private TypeRef <PropertyTypeRef>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    public PropertyInfo PropertyInfo { get; }
    public TypeRef PropertyTypeRef { get; }
    public Nullable`1<int> GetMethodMetadataToken { get; }
    public Nullable`1<int> SetMethodMetadataToken { get; }
    public string Name { get; }
    public PropertyRef(TypeRef declaringType, TypeRef propertyTypeRef, int metadataToken, Nullable`1<int> getMethodMetadataToken, Nullable`1<int> setMethodMetadataToken, string name, bool isStatic);
    public PropertyRef(PropertyInfo propertyInfo, Resolver resolver);
    private string get_DebuggerDisplay();
    public PropertyInfo get_PropertyInfo();
    [CompilerGeneratedAttribute]
public TypeRef get_PropertyTypeRef();
    public Nullable`1<int> get_GetMethodMetadataToken();
    public Nullable`1<int> get_SetMethodMetadataToken();
    [CompilerGeneratedAttribute]
public virtual string get_Name();
    internal virtual void GetInputAssemblies(ISet`1<AssemblyName> assemblies);
    protected virtual bool EqualsByTypeLocalMetadata(MemberRef other);
    protected virtual MemberInfo Resolve();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(PropertyRef other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Composition.Reflection.ResolverExtensions : object {
    private static BindingFlags AllInstanceMembers;
    private static BindingFlags AllMembers;
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Type Resolve(TypeRef typeRef);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static MethodBase Resolve(MethodRef methodRef);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static PropertyInfo Resolve(PropertyRef propertyRef);
    [ExtensionAttribute]
public static MethodInfo ResolveGetter(PropertyRef propertyRef);
    [ExtensionAttribute]
public static MethodInfo ResolveSetter(PropertyRef propertyRef);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static FieldInfo Resolve(FieldRef fieldRef);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ParameterInfo Resolve(ParameterRef parameterRef);
    [ExtensionAttribute]
internal static void GetInputAssemblies(TypeRef typeRef, ISet`1<AssemblyName> assemblies);
    [ExtensionAttribute]
internal static Module GetManifest(Resolver resolver, AssemblyName assemblyName);
    internal static bool TryUseFastReflection(TypeRef typeRef, Module& manifest);
    private static T FindMethodByParameters(IEnumerable`1<T> members, string memberName, ImmutableArray`1<TypeRef> parameterTypes);
    private static bool IsStrongAssemblyIdentityMatch(TypeRef typeRef, Module manifest);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Composition.Reflection.SkipClrVisibilityChecks : object {
    private static ConstructorInfo AttributeBaseClassCtor;
    private static ConstructorInfo AttributeUsageCtor;
    private static PropertyInfo AttributeUsageAllowMultipleProperty;
    private AssemblyBuilder assemblyBuilder;
    private ModuleBuilder moduleBuilder;
    private HashSet`1<string> attributedAssemblyNames;
    [NullableAttribute("2")]
private ConstructorInfo magicAttributeCtor;
    internal SkipClrVisibilityChecks(AssemblyBuilder assemblyBuilder, ModuleBuilder moduleBuilder);
    private static SkipClrVisibilityChecks();
    internal static ImmutableHashSet`1<AssemblyName> GetSkipVisibilityChecksRequirements(TypeInfo typeInfo);
    internal void SkipVisibilityChecksFor(IEnumerable`1<AssemblyName> assemblyNames);
    internal void SkipVisibilityChecksFor(AssemblyName assemblyName);
    private ConstructorInfo GetMagicAttributeCtor();
    private TypeInfo EmitMagicAttribute();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class Microsoft.VisualStudio.Composition.Reflection.TypeRef : object {
    private static IEqualityComparer`1<AssemblyName> AssemblyNameComparer;
    private static ThreadLocal`1<HashSet`1<Type>> recursionControl;
    private Resolver resolver;
    [NullableAttribute("2")]
private Type resolvedType;
    private Nullable`1<int> hashCode;
    [NullableAttribute("2")]
private StrongAssemblyIdentity assemblyId;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<TypeRef> baseTypes;
    [CompilerGeneratedAttribute]
private AssemblyName <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MetadataToken>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullName>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeRefFlags <TypeFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private int <GenericTypeParameterCount>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<TypeRef> <GenericTypeArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeRef <ElementTypeRef>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    public AssemblyName AssemblyName { get; }
    public int MetadataToken { get; private set; }
    public string FullName { get; private set; }
    public TypeRefFlags TypeFlags { get; }
    public bool IsArray { get; }
    public bool IsValueType { get; }
    public int GenericTypeParameterCount { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<TypeRef> GenericTypeArguments { get; private set; }
    public bool IsShallow { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<TypeRef> BaseTypes { get; }
    public TypeRef ElementTypeRef { get; private set; }
    public bool IsGenericType { get; }
    public bool IsGenericTypeDefinition { get; }
    public StrongAssemblyIdentity AssemblyId { get; }
    internal Resolver Resolver { get; }
    internal Type ResolvedType { get; }
    private Type ArrayElementType { get; }
    private TypeRef(Resolver resolver, AssemblyName assemblyName, StrongAssemblyIdentity assemblyId, int metadataToken, string fullName, TypeRefFlags typeFlags, int genericTypeParameterCount, ImmutableArray`1<TypeRef> genericTypeArguments, bool shallow, ImmutableArray`1<TypeRef> baseTypes, TypeRef elementTypeRef);
    private TypeRef(Resolver resolver, Type type, bool shallow);
    private static TypeRef();
    private string get_DebuggerDisplay();
    [CompilerGeneratedAttribute]
public AssemblyName get_AssemblyName();
    [CompilerGeneratedAttribute]
public int get_MetadataToken();
    [CompilerGeneratedAttribute]
private void set_MetadataToken(int value);
    [CompilerGeneratedAttribute]
public string get_FullName();
    [CompilerGeneratedAttribute]
private void set_FullName(string value);
    [CompilerGeneratedAttribute]
public TypeRefFlags get_TypeFlags();
    public bool get_IsArray();
    public bool get_IsValueType();
    [CompilerGeneratedAttribute]
public int get_GenericTypeParameterCount();
    [CompilerGeneratedAttribute]
private void set_GenericTypeParameterCount(int value);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<TypeRef> get_GenericTypeArguments();
    [CompilerGeneratedAttribute]
private void set_GenericTypeArguments(ImmutableArray`1<TypeRef> value);
    public bool get_IsShallow();
    public ImmutableArray`1<TypeRef> get_BaseTypes();
    [CompilerGeneratedAttribute]
public TypeRef get_ElementTypeRef();
    [CompilerGeneratedAttribute]
private void set_ElementTypeRef(TypeRef value);
    public bool get_IsGenericType();
    public bool get_IsGenericTypeDefinition();
    public StrongAssemblyIdentity get_AssemblyId();
    internal Resolver get_Resolver();
    internal Type get_ResolvedType();
    private Type get_ArrayElementType();
    public static TypeRef Get(Resolver resolver, AssemblyName assemblyName, int metadataToken, string fullName, TypeRefFlags typeFlags, int genericTypeParameterCount, ImmutableArray`1<TypeRef> genericTypeArguments, bool shallow, ImmutableArray`1<TypeRef> baseTypes, TypeRef elementTypeRef);
    public static TypeRef Get(Resolver resolver, StrongAssemblyIdentity assemblyId, int metadataToken, string fullName, TypeRefFlags typeFlags, int genericTypeParameterCount, ImmutableArray`1<TypeRef> genericTypeArguments, bool shallow, ImmutableArray`1<TypeRef> baseTypes, TypeRef elementTypeRef);
    [NullableContextAttribute("2")]
public static TypeRef Get(Type type, Resolver resolver);
    public TypeRef MakeGenericTypeRef(ImmutableArray`1<TypeRef> genericTypeArguments);
    public bool IsAssignableFrom(TypeRef other);
    public virtual int GetHashCode();
    internal bool TypeRefEquals(TypeRef other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(TypeRef other);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(Type other);
    internal void GetInputAssemblies(ISet`1<AssemblyName> assemblies);
    private static Rental`1<Type[]> GetResolvedTypeArray(ImmutableArray`1<TypeRef> typeRefs);
    private static Type[] GetGenericTypeArguments(MemberInfo member);
    [NullableContextAttribute("2")]
private bool Equals(TypeRef other, bool allowMvidMismatch);
    [CompilerGeneratedAttribute]
internal static bool <Equals>g__EqualsByValue|70_0(ImmutableArray`1<TypeRef> array, ImmutableArray`1<TypeRef> other, bool allowMvidMismatch);
}
[FlagsAttribute]
public enum Microsoft.VisualStudio.Composition.Reflection.TypeRefFlags : Enum {
    public int value__;
    public static TypeRefFlags None;
    public static TypeRefFlags Array;
    public static TypeRefFlags IsValueType;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Composition.ReflectionHelpers : object {
    private static Assembly Mscorlib;
    private static ReflectionHelpers();
    public static Func`1<object> CreateFuncOfType(Type typeArg, Func`1<object> func);
    [ExtensionAttribute]
internal static bool IsEquivalentTo(Type type1, Type type2);
    internal static Assignability IsAssignableTo(ImportDefinitionBinding import, ExportDefinitionBinding export);
    [ExtensionAttribute]
internal static ImmutableArray`1<TypeRef> GetParameterTypes(MethodBase method, Resolver resolver);
    [ExtensionAttribute]
internal static ImmutableArray`1<TypeRef> GetGenericTypeArguments(MethodBase methodBase, Resolver resolver);
    internal static IReadOnlyList`1<TypeRef> TypesToTypeRefs(Type[] types, Resolver resolver);
    [ExtensionAttribute]
internal static IEnumerable`1<PropertyInfo> EnumProperties(Type type);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Composition.ReflectionHelpers/<EnumTypeAndBaseTypes>d__9")]
[ExtensionAttribute]
internal static IEnumerable`1<Type> EnumTypeAndBaseTypes(Type type);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Composition.ReflectionHelpers/<EnumTypeBaseTypesAndInterfaces>d__10")]
[ExtensionAttribute]
internal static IEnumerable`1<Type> EnumTypeBaseTypesAndInterfaces(Type type);
    [ExtensionAttribute]
internal static IEnumerable`1<PropertyInfo> WherePublicInstance(IEnumerable`1<PropertyInfo> infos);
    [ExtensionAttribute]
internal static bool IsStatic(MemberInfo exportingMember);
    [ExtensionAttribute]
internal static bool IsStatic(MemberRef exportingMemberRef);
    internal static Type GetMemberType(MemberInfo fieldOrPropertyOrType);
    internal static TypeRef GetMemberTypeRef(MemberRef fieldOrPropertyOrTypeRef);
    [ExtensionAttribute]
internal static bool IsPublicInstance(MethodInfo methodInfo);
    internal static string GetTypeName(Type type, bool genericTypeDefinition, bool evenNonPublic, HashSet`1<Assembly> relevantAssemblies, HashSet`1<Type> relevantEmbeddedTypes);
    private static void AddEmbeddedInterfaces(Type type, HashSet`1<Type> relevantEmbeddedTypes, ImmutableStack`1<Type> observedTypes);
    internal static string ReplaceBackTickWithTypeArgs(string originalName, String[] typeArguments);
    internal static bool IsPublic(Type type, bool checkGenericTypeArgs);
    [ExtensionAttribute]
internal static bool HasBaseclassOf(Type type, Type baseClass);
    [ExtensionAttribute]
internal static bool IsEmbeddedType(Type type);
    [ExtensionAttribute]
internal static bool IsEmbeddableAssembly(Assembly assembly);
    internal static Type CloseGenericType(Type genericTypeDefinition, Type constructedType);
    internal static Rental`1<Type[]> ExtractGenericTypeArguments(Type genericTypeDefinition, Type constructedType);
    internal static TypeRef GetExportedValueTypeRef(TypeRef declaringTypeRef, MemberRef exportingMemberRef);
    internal static Type GetContractTypeForDelegate(MethodInfo method);
    internal static MethodBase MapOpenGenericMemberToClosedGeneric(MethodBase method, TypeInfo closedGeneric);
    [ExtensionAttribute]
internal static Attribute Instantiate(CustomAttributeData attributeData);
    [ExtensionAttribute]
internal static object Instantiate(MethodBase ctorOrFactoryMethod, Object[] arguments);
    [DoesNotReturnAttribute]
internal static Exception ThrowUnsupportedImportingConstructor(MethodBase ctorOrFactoryMethod);
    internal static void GetInputAssembliesFromMetadata(ISet`1<AssemblyName> assemblies, IReadOnlyDictionary`2<string, object> metadata, Func`2<Assembly, AssemblyName> nameRetriever);
    [ExtensionAttribute]
internal static int GetMetadataTokenSafe(MemberInfo memberInfo);
    private static string FilterTypeNameForGenericTypeDefinition(Type type, bool fullName);
    private static void GetTypeAndBaseTypeAssemblies(ISet`1<AssemblyName> assemblies, Type type, Func`2<Assembly, AssemblyName> nameRetriever);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Composition.ReflectionHelpers/<GetAllBaseTypesAndInterfaces>d__36")]
private static IEnumerable`1<Type> GetAllBaseTypesAndInterfaces(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Composition.Rental`1 : ValueType {
    [NullableAttribute("2")]
private T value;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Stack`1<T> returnTo;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`1<T> cleanup;
    public T Value { get; }
    internal Rental`1(Stack`1<T> returnTo, Func`2<int, T> create, Action`1<T> cleanup, int createArg);
    public T get_Value();
    public sealed virtual void Dispose();
}
public class Microsoft.VisualStudio.Composition.ReportFaultCallback : MulticastDelegate {
    public ReportFaultCallback(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(Exception e, RuntimeImport import, RuntimeExport export);
    public virtual IAsyncResult BeginInvoke(Exception e, RuntimeImport import, RuntimeExport export, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Composition.Resolver : object {
    public static Resolver DefaultInstance;
    internal Dictionary`2<Type, WeakReference`1<TypeRef>> InstanceCache;
    internal Dictionary`2<Assembly, AssemblyName> NormalizedAssemblyCache;
    private Dictionary`2<AssemblyName, StrongAssemblyIdentity> loadedAssemblyStrongIdentities;
    [CompilerGeneratedAttribute]
private IAssemblyLoader <AssemblyLoader>k__BackingField;
    internal IAssemblyLoader AssemblyLoader { get; }
    public Resolver(IAssemblyLoader assemblyLoader);
    private static Resolver();
    [CompilerGeneratedAttribute]
internal IAssemblyLoader get_AssemblyLoader();
    internal bool TryGetAssemblyId(AssemblyName assemblyName, StrongAssemblyIdentity& assemblyId);
    internal StrongAssemblyIdentity GetStrongAssemblyIdentity(Assembly assembly, AssemblyName assemblyName);
    private StrongAssemblyIdentity NotifyAssemblyLoaded(Assembly assembly, AssemblyName assemblyName);
    internal AssemblyName GetNormalizedAssemblyName(Assembly assembly);
    internal static AssemblyName GetNormalizedAssemblyName(AssemblyName assemblyName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Composition.RuntimeComposition : object {
    private ImmutableHashSet`1<RuntimePart> parts;
    private IReadOnlyDictionary`2<TypeRef, RuntimePart> partsByType;
    private IReadOnlyDictionary`2<string, IReadOnlyCollection`1<RuntimeExport>> exportsByContractName;
    private IReadOnlyDictionary`2<TypeRef, RuntimeExport> metadataViewsAndProviders;
    [CompilerGeneratedAttribute]
private Resolver <Resolver>k__BackingField;
    public IReadOnlyCollection`1<RuntimePart> Parts { get; }
    public IReadOnlyDictionary`2<TypeRef, RuntimeExport> MetadataViewsAndProviders { get; }
    internal Resolver Resolver { get; }
    private RuntimeComposition(IEnumerable`1<RuntimePart> parts, IReadOnlyDictionary`2<TypeRef, RuntimeExport> metadataViewsAndProviders, Resolver resolver);
    public IReadOnlyCollection`1<RuntimePart> get_Parts();
    public IReadOnlyDictionary`2<TypeRef, RuntimeExport> get_MetadataViewsAndProviders();
    [CompilerGeneratedAttribute]
internal Resolver get_Resolver();
    public static RuntimeComposition CreateRuntimeComposition(CompositionConfiguration configuration);
    public static RuntimeComposition CreateRuntimeComposition(IEnumerable`1<RuntimePart> parts, IReadOnlyDictionary`2<TypeRef, RuntimeExport> metadataViewsAndProviders, Resolver resolver);
    public IExportProviderFactory CreateExportProviderFactory();
    public IReadOnlyCollection`1<RuntimeExport> GetExports(string contractName);
    public RuntimePart GetPart(RuntimeExport export);
    public RuntimePart GetPart(TypeRef partType);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(RuntimeComposition other);
    internal static string GetDiagnosticLocation(RuntimeImport import);
    internal static string GetDiagnosticLocation(RuntimeExport export);
    private static RuntimePart CreateRuntimePart(ComposedPart part, CompositionConfiguration configuration);
    private static RuntimeImport CreateRuntimeImport(ImportDefinitionBinding importDefinitionBinding, IReadOnlyList`1<ExportDefinitionBinding> satisfyingExports, Resolver resolver);
    private static RuntimeExport CreateRuntimeExport(ExportDefinition exportDefinition, TypeRef partTypeRef, MemberRef exportingMemberRef, Resolver resolver);
    private static RuntimeExport CreateRuntimeExport(ExportDefinitionBinding exportDefinitionBinding, Resolver resolver);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Composition.RuntimeExportProviderFactory : object {
    private RuntimeComposition composition;
    internal RuntimeExportProviderFactory(RuntimeComposition composition);
    public sealed virtual ExportProvider CreateExportProvider();
    public sealed virtual ExportProvider CreateExportProvider(ReportFaultCallback faultCallback);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.VisualStudio.Composition.SerializationContextBase : object {
    [NullableAttribute("2")]
protected BinaryReader reader;
    [NullableAttribute("2")]
protected BinaryWriter writer;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected Dictionary`2<object, UInt32> serializingObjectTable;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected Object[] deserializingObjectTable;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private protected Func`1<string> readStringDelegate;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`1<object> readObjectDelegate;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`1<TypeRef> readTypeRefDelegate;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Builder<string, object> metadataBuilder;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Stack`1<Builder<TypeRef>> typeRefBuilders;
    private Byte[] guidBuffer;
    private long objectTableCapacityStreamPosition;
    [CompilerGeneratedAttribute]
private Resolver <Resolver>k__BackingField;
    protected Resolver Resolver { get; }
    internal SerializationContextBase(BinaryReader reader, Resolver resolver);
    internal SerializationContextBase(BinaryWriter writer, int estimatedObjectCount, Resolver resolver);
    [CompilerGeneratedAttribute]
protected Resolver get_Resolver();
    public sealed virtual void Dispose();
    protected internal void FinalizeObjectTableCapacity();
    protected virtual void Dispose(bool disposing);
    protected SerializationTrace Trace(string elementName, bool isArray);
    [NullableContextAttribute("2")]
protected void Write(MethodRef methodRef);
    [NullableContextAttribute("2")]
protected MethodRef ReadMethodRef();
    [NullableContextAttribute("2")]
protected void Write(MemberRef memberRef);
    [NullableContextAttribute("2")]
protected MemberRef ReadMemberRef();
    protected void Write(PropertyRef propertyRef);
    [NullableContextAttribute("2")]
protected PropertyRef ReadPropertyRef();
    protected void Write(FieldRef fieldRef);
    [NullableContextAttribute("2")]
protected FieldRef ReadFieldRef();
    [NullableContextAttribute("2")]
protected void Write(ParameterRef parameterRef);
    [NullableContextAttribute("2")]
protected ParameterRef ReadParameterRef();
    protected void WriteCompressedMetadataToken(int metadataToken, MetadataTokenType type);
    protected int ReadCompressedMetadataToken(MetadataTokenType type);
    protected void Write(TypeRef typeRef);
    [NullableContextAttribute("2")]
protected TypeRef ReadTypeRef();
    protected void Write(AssemblyName assemblyName);
    [NullableContextAttribute("2")]
protected AssemblyName ReadAssemblyName();
    protected void Write(StrongAssemblyIdentity assemblyMetadata);
    [NullableContextAttribute("2")]
protected StrongAssemblyIdentity ReadStrongAssemblyIdentity();
    protected void Write(DateTime value);
    protected DateTime ReadDateTime();
    protected void Write(Guid value);
    protected Guid ReadGuid();
    [NullableContextAttribute("2")]
protected void Write(string value);
    [NullableContextAttribute("2")]
protected string ReadString();
    protected void WriteCompressedUInt(UInt32 value);
    protected UInt32 ReadCompressedUInt();
    protected void Write(IReadOnlyCollection`1<T> list, Action`1<T> itemWriter);
    protected void Write(Array list, Action`1<object> itemWriter);
    protected IReadOnlyList`1<T> ReadList(Func`1<T> itemReader);
    protected IReadOnlyList`1<T> ReadList(BinaryReader reader, Func`1<T> itemReader);
    protected ImmutableArray`1<TypeRef> ReadTypeRefImmutableArray(BinaryReader reader, Func`1<TypeRef> itemReader);
    protected Array ReadArray(BinaryReader reader, Func`1<object> itemReader, Type elementType);
    protected void ReadBuffer(Byte[] buffer, int start, int count);
    protected void Write(IReadOnlyDictionary`2<string, object> metadata);
    protected IReadOnlyDictionary`2<string, object> ReadMetadata();
    protected void Write(ImportCardinality cardinality);
    protected ImportCardinality ReadImportCardinality();
    [NullableContextAttribute("2")]
protected bool TryPrepareSerializeReusableObject(object value);
    protected bool TryPrepareDeserializeReusableObject(UInt32& id, T& value);
    protected void OnDeserializedReusableObject(UInt32 id, object value);
    [NullableContextAttribute("2")]
protected void WriteObject(object value);
    [NullableContextAttribute("2")]
protected object ReadObject();
    protected void Write(ObjectType type);
    protected ObjectType ReadObjectType();
    [ConditionalAttribute("TRACESTATS")]
protected void TraceStats();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Composition.StandardAssemblyLoader : object {
    private Dictionary`2<AssemblyName, Assembly> loadedAssemblies;
    public sealed virtual Assembly LoadAssembly(AssemblyName assemblyName);
    public sealed virtual Assembly LoadAssembly(string assemblyFullName, string codeBasePath);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Microsoft.VisualStudio.Composition.Strings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string AllValuesMustBeNonNull { get; }
    internal static string AssemblyNameMustBeSetFirst { get; }
    internal static string CannotBeEmpty { get; }
    internal static string CannotDirectlyDisposeAnImport { get; }
    internal static string CannotImportBecauseExportingPartCannotBeInstantiated { get; }
    internal static string CollectionMustBePublicAndPublicCtorWhenUsingImportingCtor { get; }
    internal static string CollectionTypeMustDeriveFromICollectionOfT { get; }
    internal static string CompilerErrorsOccurred { get; }
    internal static string ContainerDisposalEncounteredExceptions { get; }
    internal static string CustomImportSourceNotSupported { get; }
    internal static string DiscoveredIdenticalPropertiesInMetadataAttributesForPart { get; }
    internal static string ErrorsDuringDiscovery { get; }
    internal static string ErrorsInComposition { get; }
    internal static string ErrorWhileScanningMember { get; }
    internal static string ErrorWhileSettingImport { get; }
    internal static string ExactlyOneEntryForEveryImport { get; }
    internal static string ExceptionThrownByPartUnderInitialization { get; }
    internal static string ExpectedExactlyOneExportButFound { get; }
    internal static string ExpectedOneOrZeroExportsButFound { get; }
    internal static string ExportedValueNotAssignableToImport { get; }
    internal static string ExportingPropertyHasNoGetter { get; }
    internal static string ExportOfExportProviderNotAllowed { get; }
    internal static string ExportsOnMembersNotAllowedWhenDeclaringTypeGeneric { get; }
    internal static string FailedToGenerateEmbeddableTypes { get; }
    internal static string FailStableComposition { get; }
    internal static string FailureWhileScanningType { get; }
    internal static string ImportConstraintTypeNotSupported { get; }
    internal static string ImportingCtorHasUnsupportedParameterTypeForImportMany { get; }
    internal static string ImportingPropertyHasNoSetter { get; }
    internal static string ImportManyOnNonCollectionType { get; }
    internal static string ImportsThatUseGenericTypeParametersNotSupported { get; }
    internal static string InstanceEmpty { get; }
    internal static string IsExpectedOnlyOnImportsOfExportFactoryOfTV2 { get; }
    internal static string IsExportFactoryExpectedTrue { get; }
    internal static string IsNotAssignableFromExportedMEFValue { get; }
    internal static string LoopBetweenNonSharedParts { get; }
    internal static string LoopInvolvingImportingCtorArgumentAndAllNonLazyImports { get; }
    internal static string MemberContainsBothImportAndImportMany { get; }
    internal static string MetadataTypeNotSupported { get; }
    internal static string NoImportingConstructor { get; }
    internal static string NoImportingConstructorFound { get; }
    internal static string NoMemberToSatisfy { get; }
    internal static string NotATypeSpec { get; }
    internal static string NotClosedFormOfOther { get; }
    internal static string NotGenericTypeDefinition { get; }
    internal static string NotInitialized { get; }
    internal static string OnImportsSatisfiedTakeNoParameters { get; }
    internal static string OnlySupportedOnWriteOperations { get; }
    internal static string PartBelongsToAnotherSharingBoundary { get; }
    internal static string PartDiscoveryFailedAtMember { get; }
    internal static string PartIsNotInstantiable { get; }
    internal static string PartIsNotShared { get; }
    internal static string ReadableStreamRequired { get; }
    internal static string RecursiveRequestForPartConstruction { get; }
    internal static string ReflectionTypeLoadExceptionWhileEnumeratingTypes { get; }
    internal static string RequiredImportHasBeenInvalidated { get; }
    internal static string ScanningMEFAssemblies { get; }
    internal static string TypeAlreadyInCatalogAsAnotherPart { get; }
    internal static string TypeMustDefineMemberInfoOrDerivedType { get; }
    internal static string TypeNameWithAssemblyLocation { get; }
    internal static string TypeOfMetadataViewUnsupported { get; }
    internal static string TypeRefCycle { get; }
    internal static string UnableToDeterminePrimarySharingBoundary { get; }
    internal static string UnableToEnumerateTypes { get; }
    internal static string UnableToInstantiateCustomImportCollectionType { get; }
    internal static string UnableToLoadAssembly { get; }
    internal static string UnexpectedConstraintType { get; }
    internal static string UnexpectedMemberType { get; }
    internal static string UnexpectedNumberOfExportsFound { get; }
    internal static string UnexpectedSharedPartState { get; }
    internal static string UnresolvableMetadataToken { get; }
    internal static string UnsupportedFormat { get; }
    internal static string WritableStreamRequired { get; }
    internal static string WrongLength { get; }
    internal static string WrongType { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_AllValuesMustBeNonNull();
    internal static string get_AssemblyNameMustBeSetFirst();
    internal static string get_CannotBeEmpty();
    internal static string get_CannotDirectlyDisposeAnImport();
    internal static string get_CannotImportBecauseExportingPartCannotBeInstantiated();
    internal static string get_CollectionMustBePublicAndPublicCtorWhenUsingImportingCtor();
    internal static string get_CollectionTypeMustDeriveFromICollectionOfT();
    internal static string get_CompilerErrorsOccurred();
    internal static string get_ContainerDisposalEncounteredExceptions();
    internal static string get_CustomImportSourceNotSupported();
    internal static string get_DiscoveredIdenticalPropertiesInMetadataAttributesForPart();
    internal static string get_ErrorsDuringDiscovery();
    internal static string get_ErrorsInComposition();
    internal static string get_ErrorWhileScanningMember();
    internal static string get_ErrorWhileSettingImport();
    internal static string get_ExactlyOneEntryForEveryImport();
    internal static string get_ExceptionThrownByPartUnderInitialization();
    internal static string get_ExpectedExactlyOneExportButFound();
    internal static string get_ExpectedOneOrZeroExportsButFound();
    internal static string get_ExportedValueNotAssignableToImport();
    internal static string get_ExportingPropertyHasNoGetter();
    internal static string get_ExportOfExportProviderNotAllowed();
    internal static string get_ExportsOnMembersNotAllowedWhenDeclaringTypeGeneric();
    internal static string get_FailedToGenerateEmbeddableTypes();
    internal static string get_FailStableComposition();
    internal static string get_FailureWhileScanningType();
    internal static string get_ImportConstraintTypeNotSupported();
    internal static string get_ImportingCtorHasUnsupportedParameterTypeForImportMany();
    internal static string get_ImportingPropertyHasNoSetter();
    internal static string get_ImportManyOnNonCollectionType();
    internal static string get_ImportsThatUseGenericTypeParametersNotSupported();
    internal static string get_InstanceEmpty();
    internal static string get_IsExpectedOnlyOnImportsOfExportFactoryOfTV2();
    internal static string get_IsExportFactoryExpectedTrue();
    internal static string get_IsNotAssignableFromExportedMEFValue();
    internal static string get_LoopBetweenNonSharedParts();
    internal static string get_LoopInvolvingImportingCtorArgumentAndAllNonLazyImports();
    internal static string get_MemberContainsBothImportAndImportMany();
    internal static string get_MetadataTypeNotSupported();
    internal static string get_NoImportingConstructor();
    internal static string get_NoImportingConstructorFound();
    internal static string get_NoMemberToSatisfy();
    internal static string get_NotATypeSpec();
    internal static string get_NotClosedFormOfOther();
    internal static string get_NotGenericTypeDefinition();
    internal static string get_NotInitialized();
    internal static string get_OnImportsSatisfiedTakeNoParameters();
    internal static string get_OnlySupportedOnWriteOperations();
    internal static string get_PartBelongsToAnotherSharingBoundary();
    internal static string get_PartDiscoveryFailedAtMember();
    internal static string get_PartIsNotInstantiable();
    internal static string get_PartIsNotShared();
    internal static string get_ReadableStreamRequired();
    internal static string get_RecursiveRequestForPartConstruction();
    internal static string get_ReflectionTypeLoadExceptionWhileEnumeratingTypes();
    internal static string get_RequiredImportHasBeenInvalidated();
    internal static string get_ScanningMEFAssemblies();
    internal static string get_TypeAlreadyInCatalogAsAnotherPart();
    internal static string get_TypeMustDefineMemberInfoOrDerivedType();
    internal static string get_TypeNameWithAssemblyLocation();
    internal static string get_TypeOfMetadataViewUnsupported();
    internal static string get_TypeRefCycle();
    internal static string get_UnableToDeterminePrimarySharingBoundary();
    internal static string get_UnableToEnumerateTypes();
    internal static string get_UnableToInstantiateCustomImportCollectionType();
    internal static string get_UnableToLoadAssembly();
    internal static string get_UnexpectedConstraintType();
    internal static string get_UnexpectedMemberType();
    internal static string get_UnexpectedNumberOfExportsFound();
    internal static string get_UnexpectedSharedPartState();
    internal static string get_UnresolvableMetadataToken();
    internal static string get_UnsupportedFormat();
    internal static string get_WritableStreamRequired();
    internal static string get_WrongLength();
    internal static string get_WrongType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{Name}")]
public class Microsoft.VisualStudio.Composition.StrongAssemblyIdentity : object {
    [CompilerGeneratedAttribute]
private AssemblyName <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Mvid>k__BackingField;
    public AssemblyName Name { get; }
    public Guid Mvid { get; }
    public StrongAssemblyIdentity(AssemblyName name, Guid mvid);
    [CompilerGeneratedAttribute]
public AssemblyName get_Name();
    [CompilerGeneratedAttribute]
public Guid get_Mvid();
    public static StrongAssemblyIdentity CreateFrom(string assemblyFile, AssemblyName assemblyName);
    public static StrongAssemblyIdentity CreateFrom(Assembly assembly, AssemblyName assemblyName);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(StrongAssemblyIdentity other);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
internal bool Equals(StrongAssemblyIdentity other, bool allowMvidMismatch);
    private static Guid GetMvid(string assemblyFile);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Composition.UniquePropertyNameComparer : object {
    internal static IEqualityComparer`1<PropertyInfo> Default;
    private static UniquePropertyNameComparer();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(PropertyInfo x, PropertyInfo y);
    public sealed virtual int GetHashCode(PropertyInfo obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.Composition.Utilities : object {
    private static string CompositionErrorHeaderFormat;
    internal static void WriteErrors(TextWriter textWriter, IImmutableStack`1<IReadOnlyCollection`1<ComposedPartDiagnostic>> errorStack);
    internal static ComposablePartDefinition GetMetadataViewProviderPartDefinition(Type providerType, int orderPrecedence, Resolver resolver);
    [ExtensionAttribute]
internal static TValue GetValueOrDefault(IReadOnlyDictionary`2<TKey, TValue> dictionary, TKey key);
    [ExtensionAttribute]
internal static TValue GetValueOrDefault(IReadOnlyDictionary`2<TKey, TValue> dictionary, TKey key, TValue defaultValue);
    [ExtensionAttribute]
internal static bool EqualsByValue(IReadOnlyDictionary`2<TKey, TValue> expected, IReadOnlyDictionary`2<TKey, TValue> actual, IEqualityComparer`1<TValue> valueComparer);
    [ExtensionAttribute]
internal static bool TryGetValue(IReadOnlyDictionary`2<string, object> metadata, string key, TValue& value);
    internal static string MakeIdentifierNameSafe(string value);
    [ExtensionAttribute]
internal static bool Contains(ImmutableStack`1<T> stack, T value);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
internal static bool EqualsByValue(ImmutableArray`1<T> array, ImmutableArray`1<T> other);
    [ExtensionAttribute]
internal static void ToString(IReadOnlyDictionary`2<string, object> metadata, IndentingTextWriter writer);
    [ExtensionAttribute]
internal static void ToString(object value, TextWriter writer);
    [ExtensionAttribute]
internal static object SpecifyIfNull(object value);
    [ExtensionAttribute]
internal static void ReportNullSafe(IProgress`1<T> progress, T value);
    [ExtensionAttribute]
internal static Dictionary`2<TKey, TValue> ToDictionary(IEnumerable`1<TValue> source, Func`2<TValue, TKey> keySelector, int capacity);
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
internal class System.Diagnostics.CodeAnalysis.SetsRequiredMembersAttribute : Attribute {
}
internal class System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute : Attribute {
    [NullableContextAttribute("1")]
public CompilerFeatureRequiredAttribute(string feature);
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal static class System.Runtime.CompilerServices.IsExternalInit : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
internal class System.Runtime.CompilerServices.RequiredMemberAttribute : Attribute {
}
[GeneratedCodeAttribute("Nerdbank.GitVersioning.Tasks", "3.6.139.59561")]
[ExcludeFromCodeCoverageAttribute]
internal static class ThisAssembly : object {
    internal static string AssemblyConfiguration;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyVersion;
    internal static DateTime GitCommitDate;
    internal static string GitCommitId;
    internal static bool IsPrerelease;
    internal static bool IsPublicRelease;
    internal static string PublicKey;
    internal static string PublicKeyToken;
    internal static string RootNamespace;
    private static ThisAssembly();
}
