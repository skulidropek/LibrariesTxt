[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[NuGet.Common.EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.NuGet.Common.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[NuGet.Configuration.EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.NuGet.Configuration.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[NuGet.Frameworks.EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.NuGet.Frameworks.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[NuGet.Packaging.EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.NuGet.Packaging.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[NuGet.Versioning.EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.NuGet.Versioning.EmbeddedAttribute : Attribute {
}
internal class NuGet.Client.AnyFramework : NuGetFramework {
    [CompilerGeneratedAttribute]
private static AnyFramework <Instance>k__BackingField;
    internal static AnyFramework Instance { get; }
    private static AnyFramework();
    [CompilerGeneratedAttribute]
internal static AnyFramework get_Instance();
}
public class NuGet.Client.ManagedCodeConventions : object {
    private static ContentPropertyDefinition LocaleProperty;
    private static ContentPropertyDefinition AnyProperty;
    private static ContentPropertyDefinition AssemblyProperty;
    private static ContentPropertyDefinition MSBuildProperty;
    private static ContentPropertyDefinition SatelliteAssemblyProperty;
    private static ContentPropertyDefinition CodeLanguageProperty;
    private static Dictionary`2<string, object> NetTFMTable;
    private static Dictionary`2<string, object> DefaultTfmAny;
    private static PatternTable DotnetAnyTable;
    private static PatternTable AnyTable;
    private static FrameworkReducer FrameworkReducer;
    private RuntimeGraph _runtimeGraph;
    private Dictionary`2<string, NuGetFramework> _frameworkCache;
    [CompilerGeneratedAttribute]
private ManagedCodeCriteria <Criteria>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, ContentPropertyDefinition> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private ManagedCodePatterns <Patterns>k__BackingField;
    public ManagedCodeCriteria Criteria { get; }
    public IReadOnlyDictionary`2<string, ContentPropertyDefinition> Properties { get; }
    public ManagedCodePatterns Patterns { get; }
    public ManagedCodeConventions(RuntimeGraph runtimeGraph);
    private static ManagedCodeConventions();
    [CompilerGeneratedAttribute]
public ManagedCodeCriteria get_Criteria();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, ContentPropertyDefinition> get_Properties();
    [CompilerGeneratedAttribute]
public ManagedCodePatterns get_Patterns();
    private bool RuntimeIdentifier_CompatibilityTest(object criteria, object available);
    private static object CodeLanguage_Parser(string name, PatternTable table);
    private static object Locale_Parser(string name, PatternTable table);
    private object TargetFrameworkName_Parser(string name, PatternTable table);
    private static NuGetFramework TargetFrameworkName_ParserCore(string name);
    private static object AllowEmptyFolderParser(string s, PatternTable table);
    private static bool TargetFrameworkName_CompatibilityTest(object criteria, object available);
    private static int TargetFrameworkName_NearestCompareTest(object projectFramework, object criteria, object available);
    private static Version NormalizeVersion(Version version);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NuGet.Common.ActivityCorrelationId : object {
    private static string CorrelationIdSlot;
    private static string DefaultCorrelationId;
    public static string Current { get; }
    private static ActivityCorrelationId();
    public static string get_Current();
    public static void StartNew();
    public static void Clear();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Common.AggregateEnumerableAsync`1 : object {
    private IList`1<IEnumerableAsync`1<T>> _asyncEnumerables;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IComparer`1<T> _comparer;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEqualityComparer`1<T> _equalityComparer;
    public AggregateEnumerableAsync`1(IList`1<IEnumerableAsync`1<T>> asyncEnumerables, IComparer`1<T> comparer, IEqualityComparer`1<T> equalityComparer);
    public sealed virtual IEnumeratorAsync`1<T> GetEnumeratorAsync();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Common.AggregateEnumeratorAsync`1 : object {
    private HashSet`1<T> _seen;
    private IComparer`1<T> _orderingComparer;
    private List`1<IEnumeratorAsync`1<T>> _asyncEnumerators;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEnumeratorAsync`1<T> _currentEnumeratorAsync;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEnumeratorAsync`1<T> _lastAwaitedEnumeratorAsync;
    private bool firstPass;
    public T Current { get; }
    public AggregateEnumeratorAsync`1(IList`1<IEnumerableAsync`1<T>> asyncEnumerables, IComparer`1<T> orderingComparer, IEqualityComparer`1<T> equalityComparer);
    public sealed virtual T get_Current();
    [AsyncStateMachineAttribute("NuGet.Common.AggregateEnumeratorAsync`1/<MoveNextAsync>d__9")]
public sealed virtual Task`1<bool> MoveNextAsync();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NuGet.Common.AsyncLazy : object {
    public static AsyncLazy`1<T> New(Func`1<Task`1<T>> asyncValueFactory);
    public static AsyncLazy`1<T> New(Func`1<T> valueFactory);
    public static AsyncLazy`1<T> New(Lazy`1<Task`1<T>> inner);
    public static AsyncLazy`1<T> New(T innerData);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[CLSCompliantAttribute("True")]
public class NuGet.Common.AsyncLazy`1 : object {
    private Lazy`1<Task`1<T>> _inner;
    public AsyncLazy`1(Func`1<Task`1<T>> valueFactory);
    public AsyncLazy`1(Lazy`1<Task`1<T>> inner);
    public TaskAwaiter`1<T> GetAwaiter();
    public static Lazy`1<Task`1<T>> op_Implicit(AsyncLazy`1<T> outer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Common.AuthTypeFilteredCredentials : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <AuthTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private NetworkCredential <InnerCredential>k__BackingField;
    public IReadOnlyList`1<string> AuthTypes { get; }
    public NetworkCredential InnerCredential { get; }
    public AuthTypeFilteredCredentials(NetworkCredential innerCredential, IEnumerable`1<string> authTypes);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_AuthTypes();
    [CompilerGeneratedAttribute]
public NetworkCredential get_InnerCredential();
    public sealed virtual NetworkCredential GetCredential(Uri uri, string authType);
}
public static class NuGet.Common.ClientVersionUtility : object {
    [NullableAttribute("2")]
private static string _clientVersion;
    [NullableContextAttribute("1")]
public static string GetNuGetAssemblyVersion();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Common.CommandLineArgumentCombinationException : Exception {
    private ILogMessage _logMessage;
    public CommandLineArgumentCombinationException(string message);
    public virtual ILogMessage AsLogMessage();
}
public static class NuGet.Common.ComparisonUtility : object {
    [NullableAttribute("1")]
public static StringComparer FrameworkReferenceNameComparer;
    private static ComparisonUtility();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NuGet.Common.ConcurrencyUtilities : object {
    private static int NumberOfRetries;
    private static int HashLength;
    private static TimeSpan SleepDuration;
    private static KeyedLock PerFileLock;
    private static bool UseDeleteOnClose;
    [NullableAttribute("2")]
private static string _basePath;
    private static string BasePath { get; }
    private static ConcurrencyUtilities();
    [AsyncStateMachineAttribute("NuGet.Common.ConcurrencyUtilities/<ExecuteWithFileLockedAsync>d__5`1")]
public static Task`1<T> ExecuteWithFileLockedAsync(string filePath, Func`2<CancellationToken, Task`1<T>> action, CancellationToken token);
    public static void ExecuteWithFileLocked(string filePath, Action action);
    private static FileStream AcquireFileStream(string lockPath);
    private static string get_BasePath();
    private static string FileLockPath(string filePath);
    private static string FilePathToLockName(string filePath);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Common.CryptoHashProvider : object {
    private static string SHA512HashAlgorithm;
    private static string SHA256HashAlgorithm;
    private string _hashAlgorithm;
    [NullableContextAttribute("2")]
public CryptoHashProvider(string hashAlgorithm);
    public Byte[] CalculateHash(Stream stream);
    public Byte[] CalculateHash(Byte[] data);
    public bool VerifyHash(Byte[] data, Byte[] hash);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class NuGet.Common.CryptoHashUtility : object {
    private static string SHA256_OID;
    private static string SHA384_OID;
    private static string SHA512_OID;
    private static string SHA256_RSA_OID;
    private static string SHA384_RSA_OID;
    private static string SHA512_RSA_OID;
    private static Lazy`1<bool> AllowFipsAlgorithmsOnly;
    private static CryptoHashUtility();
    [ExtensionAttribute]
public static string ComputeHashAsBase64(HashAlgorithm hashAlgorithm, Stream data);
    [ExtensionAttribute]
public static string ComputeHashAsBase64(HashAlgorithm hashAlgorithm, Stream data, bool leaveStreamOpen);
    [ExtensionAttribute]
public static Byte[] ComputeHash(HashAlgorithmName hashAlgorithmName, Byte[] data);
    [ExtensionAttribute]
public static Byte[] ComputeHash(HashAlgorithm hashAlgorithm, Stream data);
    [ExtensionAttribute]
public static Byte[] ComputeHash(HashAlgorithm hashAlgorithm, Stream data, bool leaveStreamOpen);
    public static HashAlgorithm GetHashAlgorithm(string hashAlgorithmName);
    public static HashAlgorithmName GetHashAlgorithmName(string hashAlgorithm);
    public static HashAlgorithm GetHashAlgorithm(HashAlgorithmName hashAlgorithmName);
    [ExtensionAttribute]
public static HashAlgorithm GetHashProvider(HashAlgorithmName hashAlgorithmName);
    private static bool ReadFipsConfigValue();
    [ExtensionAttribute]
public static HashAlgorithmName ConvertToSystemSecurityHashAlgorithmName(HashAlgorithmName hashAlgorithmName);
    [ExtensionAttribute]
public static string ConvertToOidString(HashAlgorithmName hashAlgorithmName);
    [ExtensionAttribute]
public static Oid ConvertToOid(HashAlgorithmName hashAlgorithm);
    public static HashAlgorithmName OidToHashAlgorithmName(string oid);
    [ExtensionAttribute]
public static string ConvertToOidString(SignatureAlgorithmName signatureAlgorithmName);
    public static string GenerateUniqueToken(string caseInsensitiveKey);
}
public static class NuGet.Common.CultureUtility : object {
    public static void DisableLocalization();
    [NullableContextAttribute("1")]
private static void SetCulture(CultureInfo culture);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NuGet.Common.DatetimeUtility : object {
    public static string ToReadableTimeFormat(TimeSpan time);
    internal static string ToReadableTimeFormat(TimeSpan time, IFormatProvider format);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Common.EnvironmentVariableWrapper : object {
    [CompilerGeneratedAttribute]
private static IEnvironmentVariableReader <Instance>k__BackingField;
    public static IEnvironmentVariableReader Instance { get; }
    private static EnvironmentVariableWrapper();
    [CompilerGeneratedAttribute]
public static IEnvironmentVariableReader get_Instance();
    public sealed virtual string GetEnvironmentVariable(string variable);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Common.ExceptionLogger : object {
    [CompilerGeneratedAttribute]
private bool <ShowStack>k__BackingField;
    [CompilerGeneratedAttribute]
private static ExceptionLogger <Instance>k__BackingField;
    public bool ShowStack { get; }
    public static ExceptionLogger Instance { get; }
    public ExceptionLogger(IEnvironmentVariableReader reader);
    private static ExceptionLogger();
    [CompilerGeneratedAttribute]
public bool get_ShowStack();
    private static bool ShouldShowStack(IEnvironmentVariableReader reader);
    [CompilerGeneratedAttribute]
public static ExceptionLogger get_Instance();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NuGet.Common.ExceptionUtilities : object {
    public static void LogException(Exception ex, ILogger logger);
    public static void LogException(Exception ex, ILogger logger, bool logStackAsError);
    public static string DisplayMessage(Exception exception, bool indent);
    public static string DisplayMessage(Exception exception);
    public static string DisplayMessage(AggregateException exception);
    public static string DisplayMessage(TargetInvocationException exception);
    public static Exception Unwrap(Exception exception);
    [IteratorStateMachineAttribute("NuGet.Common.ExceptionUtilities/<GetMessages>d__7")]
private static IEnumerable`1<string> GetMessages(AggregateException exception);
    private static IEnumerable`1<string> GetMessages(TargetInvocationException exception);
    [IteratorStateMachineAttribute("NuGet.Common.ExceptionUtilities/<GetMessages>d__9")]
private static IEnumerable`1<string> GetMessages(Exception exception);
    [IteratorStateMachineAttribute("NuGet.Common.ExceptionUtilities/<GetLines>d__10")]
private static IEnumerable`1<string> GetLines(string input);
    private static string JoinMessages(IEnumerable`1<string> messages, bool indent);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NuGet.Common.FileUtility : object {
    public static int MaxTries;
    public static FileShare FileSharePermissions;
    private static FileUtility();
    public static string GetTempFilePath(string directory);
    [AsyncStateMachineAttribute("NuGet.Common.FileUtility/<DeleteWithLock>d__3")]
public static Task DeleteWithLock(string filePath);
    [AsyncStateMachineAttribute("NuGet.Common.FileUtility/<ReplaceWithLock>d__4")]
public static Task ReplaceWithLock(Action`1<string> writeSourceFile, string destFilePath);
    public static void Replace(Action`1<string> writeSourceFile, string destFilePath);
    [AsyncStateMachineAttribute("NuGet.Common.FileUtility/<ReplaceAsync>d__6")]
public static Task ReplaceAsync(Func`2<string, Task> writeSourceFile, string destFilePath);
    public static void Replace(string sourceFileName, string destFileName);
    public static void Move(string sourceFileName, string destFileName);
    public static void Delete(string path);
    public static T SafeRead(string filePath, Func`3<FileStream, string, T> read);
    [AsyncStateMachineAttribute("NuGet.Common.FileUtility/<SafeReadAsync>d__11`1")]
public static Task`1<T> SafeReadAsync(string filePath, Func`3<FileStream, string, Task`1<T>> read);
    private static void Sleep(int ms);
}
public enum NuGet.Common.HashAlgorithmName : Enum {
    public int value__;
    public static HashAlgorithmName Unknown;
    public static HashAlgorithmName SHA256;
    public static HashAlgorithmName SHA384;
    public static HashAlgorithmName SHA512;
}
[NullableContextAttribute("1")]
public interface NuGet.Common.ICollectorLogger {
    public IEnumerable`1<IRestoreLogMessage> Errors { get; }
    public abstract virtual IEnumerable`1<IRestoreLogMessage> get_Errors();
}
[NullableContextAttribute("1")]
public interface NuGet.Common.IEnumerableAsync`1 {
    public abstract virtual IEnumeratorAsync`1<T> GetEnumeratorAsync();
}
[NullableContextAttribute("1")]
public interface NuGet.Common.IEnumeratorAsync`1 {
    public T Current { get; }
    public abstract virtual T get_Current();
    public abstract virtual Task`1<bool> MoveNextAsync();
}
[NullableContextAttribute("1")]
public interface NuGet.Common.IEnvironmentVariableReader {
    public abstract virtual string GetEnvironmentVariable(string variable);
}
[NullableContextAttribute("2")]
public interface NuGet.Common.ILogFileContext {
    public string FilePath { get; public set; }
    public int StartLineNumber { get; public set; }
    public int StartColumnNumber { get; public set; }
    public int EndLineNumber { get; public set; }
    public int EndColumnNumber { get; public set; }
    public abstract virtual string get_FilePath();
    public abstract virtual void set_FilePath(string value);
    public abstract virtual int get_StartLineNumber();
    public abstract virtual void set_StartLineNumber(int value);
    public abstract virtual int get_StartColumnNumber();
    public abstract virtual void set_StartColumnNumber(int value);
    public abstract virtual int get_EndLineNumber();
    public abstract virtual void set_EndLineNumber(int value);
    public abstract virtual int get_EndColumnNumber();
    public abstract virtual void set_EndColumnNumber(int value);
}
[NullableContextAttribute("1")]
public interface NuGet.Common.ILogger {
    public abstract virtual void LogDebug(string data);
    public abstract virtual void LogVerbose(string data);
    public abstract virtual void LogInformation(string data);
    public abstract virtual void LogMinimal(string data);
    public abstract virtual void LogWarning(string data);
    public abstract virtual void LogError(string data);
    public abstract virtual void LogInformationSummary(string data);
    public abstract virtual void Log(LogLevel level, string data);
    public abstract virtual Task LogAsync(LogLevel level, string data);
    public abstract virtual void Log(ILogMessage message);
    public abstract virtual Task LogAsync(ILogMessage message);
}
[NullableContextAttribute("1")]
public interface NuGet.Common.ILogMessage {
    public LogLevel Level { get; public set; }
    public WarningLevel WarningLevel { get; public set; }
    public NuGetLogCode Code { get; public set; }
    public string Message { get; public set; }
    [NullableAttribute("2")]
public string ProjectPath { get; public set; }
    public DateTimeOffset Time { get; public set; }
    public abstract virtual LogLevel get_Level();
    public abstract virtual void set_Level(LogLevel value);
    public abstract virtual WarningLevel get_WarningLevel();
    public abstract virtual void set_WarningLevel(WarningLevel value);
    public abstract virtual NuGetLogCode get_Code();
    public abstract virtual void set_Code(NuGetLogCode value);
    public abstract virtual string get_Message();
    public abstract virtual void set_Message(string value);
    [NullableContextAttribute("2")]
public abstract virtual string get_ProjectPath();
    [NullableContextAttribute("2")]
public abstract virtual void set_ProjectPath(string value);
    public abstract virtual DateTimeOffset get_Time();
    public abstract virtual void set_Time(DateTimeOffset value);
}
[NullableContextAttribute("1")]
public interface NuGet.Common.ILogMessageException {
    public abstract virtual ILogMessage AsLogMessage();
}
public interface NuGet.Common.INuGetLogMessage {
}
[NullableContextAttribute("1")]
public interface NuGet.Common.INuGetPathContext {
    public string UserPackageFolder { get; }
    public IReadOnlyList`1<string> FallbackPackageFolders { get; }
    public string HttpCacheFolder { get; }
    public abstract virtual string get_UserPackageFolder();
    public abstract virtual IReadOnlyList`1<string> get_FallbackPackageFolders();
    public abstract virtual string get_HttpCacheFolder();
}
[NullableContextAttribute("1")]
public interface NuGet.Common.INuGetTelemetryService {
    public abstract virtual void EmitTelemetryEvent(TelemetryEvent telemetryData);
    public abstract virtual IDisposable StartActivity(string activityName);
}
[NullableContextAttribute("2")]
public interface NuGet.Common.IPackLogMessage {
    public string LibraryId { get; public set; }
    public NuGetFramework Framework { get; public set; }
    public abstract virtual string get_LibraryId();
    public abstract virtual void set_LibraryId(string value);
    public abstract virtual NuGetFramework get_Framework();
    public abstract virtual void set_Framework(NuGetFramework value);
}
public interface NuGet.Common.IRestoreLogMessage {
    [NullableAttribute("2")]
public string LibraryId { get; public set; }
    [NullableAttribute("1")]
public IReadOnlyList`1<string> TargetGraphs { get; public set; }
    public bool ShouldDisplay { get; public set; }
    [NullableContextAttribute("2")]
public abstract virtual string get_LibraryId();
    [NullableContextAttribute("2")]
public abstract virtual void set_LibraryId(string value);
    [NullableContextAttribute("1")]
public abstract virtual IReadOnlyList`1<string> get_TargetGraphs();
    [NullableContextAttribute("1")]
public abstract virtual void set_TargetGraphs(IReadOnlyList`1<string> value);
    public abstract virtual bool get_ShouldDisplay();
    public abstract virtual void set_ShouldDisplay(bool value);
}
[NullableContextAttribute("1")]
public interface NuGet.Common.ITelemetrySession {
    public abstract virtual void PostEvent(TelemetryEvent telemetryEvent);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.Common.KeyedLock : object {
    private Dictionary`2<string, LockState> _locks;
    private SemaphoreSlim _dictionaryLock;
    [AsyncStateMachineAttribute("NuGet.Common.KeyedLock/<EnterAsync>d__3")]
internal Task EnterAsync(string key, CancellationToken token);
    internal void Enter(string key);
    private LockState GetOrCreate(string key);
    [AsyncStateMachineAttribute("NuGet.Common.KeyedLock/<ExitAsync>d__6")]
internal Task ExitAsync(string key);
    internal void Exit(string key);
    private void Cleanup(string key);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class NuGet.Common.LegacyLoggerAdapter : object {
    public sealed virtual void Log(LogLevel level, string data);
    public sealed virtual Task LogAsync(LogLevel level, string data);
    public virtual void Log(ILogMessage message);
    [AsyncStateMachineAttribute("NuGet.Common.LegacyLoggerAdapter/<LogAsync>d__3")]
public virtual Task LogAsync(ILogMessage message);
    public abstract virtual void LogDebug(string data);
    public abstract virtual void LogVerbose(string data);
    public abstract virtual void LogInformation(string data);
    public abstract virtual void LogMinimal(string data);
    public abstract virtual void LogWarning(string data);
    public abstract virtual void LogError(string data);
    public abstract virtual void LogInformationSummary(string data);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NuGet.Common.LocalResourceUtils : object {
    public static void DeleteDirectoryTree(string folderPath, List`1<string> failedDeletes);
    private static void SafeDeleteDirectoryTree(string folderPath);
    private static void DeleteFilesInDirectoryTree(string folderPath, List`1<string> failedDeletes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class NuGet.Common.LoggerBase : object {
    [CompilerGeneratedAttribute]
private LogLevel <VerbosityLevel>k__BackingField;
    public LogLevel VerbosityLevel { get; public set; }
    public LoggerBase(LogLevel verbosityLevel);
    [CompilerGeneratedAttribute]
public LogLevel get_VerbosityLevel();
    [CompilerGeneratedAttribute]
public void set_VerbosityLevel(LogLevel value);
    public abstract virtual void Log(ILogMessage message);
    public abstract virtual Task LogAsync(ILogMessage message);
    public virtual void Log(LogLevel level, string data);
    public virtual Task LogAsync(LogLevel level, string data);
    public virtual void LogDebug(string data);
    public virtual void LogError(string data);
    public virtual void LogInformation(string data);
    public virtual void LogInformationSummary(string data);
    public virtual void LogMinimal(string data);
    public virtual void LogVerbose(string data);
    public virtual void LogWarning(string data);
    protected virtual bool DisplayMessage(LogLevel messageLevel);
    protected virtual bool CollectMessage(LogLevel messageLevel);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class NuGet.Common.LoggingExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string FormatWithCode(ILogMessage message);
    [ExtensionAttribute]
public static string GetName(NuGetLogCode code);
    [ExtensionAttribute]
public static bool TryGetName(NuGetLogCode code, String& codeString);
}
public enum NuGet.Common.LogLevel : Enum {
    public int value__;
    public static LogLevel Debug;
    public static LogLevel Verbose;
    public static LogLevel Information;
    public static LogLevel Minimal;
    public static LogLevel Warning;
    public static LogLevel Error;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Common.LogMessage : object {
    [CompilerGeneratedAttribute]
private LogLevel <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private WarningLevel <WarningLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetLogCode <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <ProjectPath>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Time>k__BackingField;
    public LogLevel Level { get; public set; }
    public WarningLevel WarningLevel { get; public set; }
    public NuGetLogCode Code { get; public set; }
    public string Message { get; public set; }
    [NullableAttribute("2")]
public string ProjectPath { get; public set; }
    public DateTimeOffset Time { get; public set; }
    public LogMessage(LogLevel level, string message, NuGetLogCode code);
    public LogMessage(LogLevel level, string message);
    [CompilerGeneratedAttribute]
public sealed virtual LogLevel get_Level();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Level(LogLevel value);
    [CompilerGeneratedAttribute]
public sealed virtual WarningLevel get_WarningLevel();
    [CompilerGeneratedAttribute]
public sealed virtual void set_WarningLevel(WarningLevel value);
    [CompilerGeneratedAttribute]
public sealed virtual NuGetLogCode get_Code();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Code(NuGetLogCode value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Message();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Message(string value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_ProjectPath();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void set_ProjectPath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_Time();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Time(DateTimeOffset value);
    public virtual string ToString();
    public static LogMessage CreateError(NuGetLogCode code, string message);
    public static LogMessage CreateWarning(NuGetLogCode code, string message);
    public static LogMessage Create(LogLevel level, string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NuGet.Common.LogMessageProperties : object {
    public static string LEVEL;
    public static string CODE;
    public static string MESSAGE;
    public static string LIBRARY_ID;
    public static string TARGET_GRAPHS;
    public static string WARNING_LEVEL;
    public static string FILE_PATH;
    public static string START_LINE_NUMBER;
    public static string START_COLUMN_NUMBER;
    public static string END_LINE_NUMBER;
    public static string END_COLUMN_NUMBER;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NuGet.Common.Migrations.Migration1 : object {
    public static void Run();
    internal static void DeleteMigratedDirectories(string nugetBaseDirectory);
    internal static void EnsureExpectedPermissions(HashSet`1<string> pathsToCheck, PosixPermissions umask);
    private static HashSet`1<string> GetPathsToCheck();
    private static string GetMonoConfigPath();
    private static string GetDotnetConfigPath();
    private static void EnsureConfigFilePermissions();
    internal static void EnsureConfigFilePermissions(string directory, PosixPermissions umask);
    private static PosixPermissions GetUmask();
    private static void FixPermissions(string path, PosixPermissions umask);
    internal static Nullable`1<PosixPermissions> GetPermissions(string path);
    internal static string Exec(string command, string args);
    [CompilerGeneratedAttribute]
internal static void <GetPathsToCheck>g__AddAllParentDirectoriesUpToHome|3_0(string path, <>c__DisplayClass3_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NuGet.Common.Migrations.MigrationRunner : object {
    private static string MaxMigrationFilename;
    public static void Run();
    internal static void Run(string migrationsDirectory);
    internal static string GetMigrationsDirectory();
    [CompilerGeneratedAttribute]
internal static bool <Run>g__WaitForMutex|2_0(Mutex mutex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.Common.Migrations.PosixPermissions : ValueType {
    private int _mode;
    public PosixPermissions(int mode);
    public virtual string ToString();
    public static PosixPermissions Parse(string input);
    public bool SatisfiesUmask(PosixPermissions umask);
    public PosixPermissions WithUmask(PosixPermissions umask);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NuGet.Common.MSBuildStringUtility : object {
    public static String[] Split(string s);
    public static String[] Split(string s, Char[] chars);
    [NullableContextAttribute("2")]
public static string TrimAndGetNullForEmpty(string s);
    public static String[] TrimAndExcludeNullOrEmpty(String[] strings);
    [NullableContextAttribute("2")]
public static bool IsTrue(string value);
    [NullableContextAttribute("2")]
public static bool IsTrueOrEmpty(string value);
    [IteratorStateMachineAttribute("NuGet.Common.MSBuildStringUtility/<GetNuGetLogCodes>d__6")]
public static IEnumerable`1<NuGetLogCode> GetNuGetLogCodes(string s);
    [NullableContextAttribute("2")]
public static Nullable`1<bool> GetBooleanOrNull(string value);
    [NullableContextAttribute("2")]
public static string Convert(string value);
    public static IEnumerable`1<NuGetLogCode> GetDistinctNuGetLogCodesOrDefault(IEnumerable`1<IEnumerable`1<NuGetLogCode>> nugetLogCodeLists);
}
public static class NuGet.Common.NetworkProtocolUtility : object {
    public static void SetConnectionLimit();
}
public static class NuGet.Common.NuGetEnvironment : object {
    private static string DotNet;
    private static string DotNetExe;
    private static string Home;
    private static string UserProfile;
    private static Lazy`1<string> _getHome;
    private static string _nuGetTempDirectory;
    internal static string NuGetTempDirectory { get; }
    private static NuGetEnvironment();
    internal static string get_NuGetTempDirectory();
    private static string GetNuGetTempDirectory();
    public static string GetFolderPath(NuGetFolderPath folder);
    private static int chmod(string pathname, int mode);
    internal static string GetFolderPath(SpecialFolder folder);
    private static string GetHome();
    private static string GetHomeWindows();
    private static string GetValueOrThrowMissingEnvVarsDotnet(Func`1<string> getValue, string home, string dotnetHome);
    private static string GetValueOrThrowMissingEnvVar(Func`1<string> getValue, string name);
    public static string GetDotNetLocation();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NuGet.Common.NuGetEventSource : object {
    [CompilerGeneratedAttribute]
private static EventSource <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsEnabled>k__BackingField;
    public static EventSource Instance { get; }
    public static bool IsEnabled { get; }
    private static NuGetEventSource();
    [CompilerGeneratedAttribute]
public static EventSource get_Instance();
    [CompilerGeneratedAttribute]
public static bool get_IsEnabled();
}
public enum NuGet.Common.NuGetFolderPath : Enum {
    public int value__;
    public static NuGetFolderPath MachineWideSettingsBaseDirectory;
    public static NuGetFolderPath MachineWideConfigDirectory;
    public static NuGetFolderPath UserSettingsDirectory;
    public static NuGetFolderPath HttpCacheDirectory;
    public static NuGetFolderPath NuGetHome;
    public static NuGetFolderPath DefaultMsBuildPath;
    public static NuGetFolderPath Temp;
    public static NuGetFolderPath NuGetPluginsCacheDirectory;
}
public enum NuGet.Common.NuGetLogCode : Enum {
    public int value__;
    public static NuGetLogCode Undefined;
    public static NuGetLogCode NU1000;
    public static NuGetLogCode NU1001;
    public static NuGetLogCode NU1002;
    public static NuGetLogCode NU1003;
    public static NuGetLogCode NU1004;
    public static NuGetLogCode NU1005;
    public static NuGetLogCode NU1006;
    public static NuGetLogCode NU1007;
    public static NuGetLogCode NU1008;
    public static NuGetLogCode NU1009;
    public static NuGetLogCode NU1010;
    public static NuGetLogCode NU1011;
    public static NuGetLogCode NU1012;
    public static NuGetLogCode NU1013;
    public static NuGetLogCode NU1014;
    public static NuGetLogCode NU1100;
    public static NuGetLogCode NU1101;
    public static NuGetLogCode NU1102;
    public static NuGetLogCode NU1103;
    public static NuGetLogCode NU1104;
    public static NuGetLogCode NU1105;
    public static NuGetLogCode NU1106;
    public static NuGetLogCode NU1107;
    public static NuGetLogCode NU1108;
    public static NuGetLogCode NU1109;
    public static NuGetLogCode NU1110;
    public static NuGetLogCode NU1201;
    public static NuGetLogCode NU1202;
    public static NuGetLogCode NU1203;
    public static NuGetLogCode NU1204;
    public static NuGetLogCode NU1211;
    public static NuGetLogCode NU1212;
    public static NuGetLogCode NU1213;
    public static NuGetLogCode NU1301;
    public static NuGetLogCode NU1401;
    public static NuGetLogCode NU1402;
    public static NuGetLogCode NU1403;
    public static NuGetLogCode NU1410;
    public static NuGetLogCode NU1500;
    public static NuGetLogCode NU1501;
    public static NuGetLogCode NU1502;
    public static NuGetLogCode NU1503;
    public static NuGetLogCode NU1504;
    public static NuGetLogCode NU1505;
    public static NuGetLogCode NU1506;
    public static NuGetLogCode NU1507;
    public static NuGetLogCode NU1601;
    public static NuGetLogCode NU1602;
    public static NuGetLogCode NU1603;
    public static NuGetLogCode NU1604;
    public static NuGetLogCode NU1605;
    public static NuGetLogCode NU1608;
    public static NuGetLogCode NU1701;
    public static NuGetLogCode NU1702;
    public static NuGetLogCode NU1703;
    public static NuGetLogCode NU1801;
    public static NuGetLogCode NU1802;
    public static NuGetLogCode NU1803;
    public static NuGetLogCode NU1900;
    public static NuGetLogCode NU1901;
    public static NuGetLogCode NU1902;
    public static NuGetLogCode NU1903;
    public static NuGetLogCode NU1904;
    public static NuGetLogCode NU3000;
    public static NuGetLogCode NU3001;
    public static NuGetLogCode NU3002;
    public static NuGetLogCode NU3003;
    public static NuGetLogCode NU3004;
    public static NuGetLogCode NU3005;
    public static NuGetLogCode NU3006;
    public static NuGetLogCode NU3007;
    public static NuGetLogCode NU3008;
    public static NuGetLogCode NU3009;
    public static NuGetLogCode NU3010;
    public static NuGetLogCode NU3011;
    public static NuGetLogCode NU3012;
    public static NuGetLogCode NU3013;
    public static NuGetLogCode NU3014;
    public static NuGetLogCode NU3015;
    public static NuGetLogCode NU3016;
    public static NuGetLogCode NU3017;
    public static NuGetLogCode NU3018;
    public static NuGetLogCode NU3019;
    public static NuGetLogCode NU3020;
    public static NuGetLogCode NU3021;
    public static NuGetLogCode NU3022;
    public static NuGetLogCode NU3023;
    public static NuGetLogCode NU3024;
    public static NuGetLogCode NU3025;
    public static NuGetLogCode NU3026;
    public static NuGetLogCode NU3027;
    public static NuGetLogCode NU3028;
    public static NuGetLogCode NU3029;
    public static NuGetLogCode NU3030;
    public static NuGetLogCode NU3031;
    public static NuGetLogCode NU3032;
    public static NuGetLogCode NU3033;
    public static NuGetLogCode NU3034;
    public static NuGetLogCode NU3035;
    public static NuGetLogCode NU3036;
    public static NuGetLogCode NU3037;
    public static NuGetLogCode NU3038;
    public static NuGetLogCode NU3039;
    public static NuGetLogCode NU3040;
    public static NuGetLogCode NU3041;
    public static NuGetLogCode NU3042;
    public static NuGetLogCode NU5000;
    public static NuGetLogCode NU5001;
    public static NuGetLogCode NU5002;
    public static NuGetLogCode NU5003;
    public static NuGetLogCode NU5004;
    public static NuGetLogCode NU5005;
    public static NuGetLogCode NU5007;
    public static NuGetLogCode NU5008;
    public static NuGetLogCode NU5009;
    public static NuGetLogCode NU5010;
    public static NuGetLogCode NU5011;
    public static NuGetLogCode NU5012;
    public static NuGetLogCode NU5013;
    public static NuGetLogCode NU5014;
    public static NuGetLogCode NU5015;
    public static NuGetLogCode NU5016;
    public static NuGetLogCode NU5017;
    public static NuGetLogCode NU5018;
    public static NuGetLogCode NU5019;
    public static NuGetLogCode NU5020;
    public static NuGetLogCode NU5021;
    public static NuGetLogCode NU5022;
    public static NuGetLogCode NU5023;
    public static NuGetLogCode NU5024;
    public static NuGetLogCode NU5025;
    public static NuGetLogCode NU5026;
    public static NuGetLogCode NU5027;
    public static NuGetLogCode NU5028;
    public static NuGetLogCode NU5029;
    public static NuGetLogCode NU5030;
    public static NuGetLogCode NU5031;
    public static NuGetLogCode NU5032;
    public static NuGetLogCode NU5033;
    public static NuGetLogCode NU5034;
    public static NuGetLogCode NU5035;
    public static NuGetLogCode NU5036;
    public static NuGetLogCode NU5037;
    public static NuGetLogCode NU5038;
    public static NuGetLogCode NU5039;
    public static NuGetLogCode NU5040;
    public static NuGetLogCode NU5041;
    public static NuGetLogCode NU5042;
    public static NuGetLogCode NU5045;
    public static NuGetLogCode NU5046;
    public static NuGetLogCode NU5047;
    public static NuGetLogCode NU5048;
    public static NuGetLogCode NU5049;
    public static NuGetLogCode NU5050;
    public static NuGetLogCode NU5100;
    public static NuGetLogCode NU5101;
    public static NuGetLogCode NU5102;
    public static NuGetLogCode NU5103;
    public static NuGetLogCode NU5104;
    public static NuGetLogCode NU5105;
    public static NuGetLogCode NU5106;
    public static NuGetLogCode NU5107;
    public static NuGetLogCode NU5108;
    public static NuGetLogCode NU5109;
    public static NuGetLogCode NU5110;
    public static NuGetLogCode NU5111;
    public static NuGetLogCode NU5112;
    public static NuGetLogCode NU5114;
    public static NuGetLogCode NU5115;
    public static NuGetLogCode NU5116;
    public static NuGetLogCode NU5117;
    public static NuGetLogCode NU5118;
    public static NuGetLogCode NU5119;
    public static NuGetLogCode NU5120;
    public static NuGetLogCode NU5121;
    public static NuGetLogCode NU5122;
    public static NuGetLogCode NU5123;
    public static NuGetLogCode NU5124;
    public static NuGetLogCode NU5125;
    public static NuGetLogCode NU5126;
    public static NuGetLogCode NU5127;
    public static NuGetLogCode NU5128;
    public static NuGetLogCode NU5129;
    public static NuGetLogCode NU5130;
    public static NuGetLogCode NU5131;
    public static NuGetLogCode NU5132;
    public static NuGetLogCode NU5133;
    public static NuGetLogCode NU5500;
    public static NuGetLogCode NU5501;
}
public enum NuGet.Common.NuGetOperationStatus : Enum {
    public int value__;
    public static NuGetOperationStatus NoOp;
    public static NuGetOperationStatus Succeeded;
    public static NuGetOperationStatus Failed;
    public static NuGetOperationStatus Cancelled;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Common.NullLogger : LoggerBase {
    [NullableAttribute("2")]
private static ILogger _instance;
    public static ILogger Instance { get; }
    public static ILogger get_Instance();
    public virtual void Log(ILogMessage message);
    public virtual void Log(LogLevel level, string data);
    public virtual Task LogAsync(ILogMessage message);
    public virtual Task LogAsync(LogLevel level, string data);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class NuGet.Common.PackagingLogMessage : object {
    [CompilerGeneratedAttribute]
private LogLevel <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetLogCode <Code>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Time>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectPath>k__BackingField;
    [CompilerGeneratedAttribute]
private WarningLevel <WarningLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartLineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartColumnNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndLineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndColumnNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LibraryId>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetFramework <Framework>k__BackingField;
    public LogLevel Level { get; public set; }
    public NuGetLogCode Code { get; public set; }
    [NullableAttribute("1")]
public string Message { get; public set; }
    public DateTimeOffset Time { get; public set; }
    public string ProjectPath { get; public set; }
    public WarningLevel WarningLevel { get; public set; }
    public string FilePath { get; public set; }
    public int StartLineNumber { get; public set; }
    public int StartColumnNumber { get; public set; }
    public int EndLineNumber { get; public set; }
    public int EndColumnNumber { get; public set; }
    public string LibraryId { get; public set; }
    public NuGetFramework Framework { get; public set; }
    [NullableContextAttribute("1")]
private PackagingLogMessage(LogLevel logLevel, NuGetLogCode logCode, string message);
    private PackagingLogMessage(LogLevel logLevel, NuGetLogCode logCode, string message, string libraryId, NuGetFramework framework);
    [NullableContextAttribute("1")]
private PackagingLogMessage(LogLevel logLevel, string message);
    [CompilerGeneratedAttribute]
public sealed virtual LogLevel get_Level();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Level(LogLevel value);
    [CompilerGeneratedAttribute]
public sealed virtual NuGetLogCode get_Code();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Code(NuGetLogCode value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual string get_Message();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual void set_Message(string value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_Time();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Time(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ProjectPath();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ProjectPath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual WarningLevel get_WarningLevel();
    [CompilerGeneratedAttribute]
public sealed virtual void set_WarningLevel(WarningLevel value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FilePath();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FilePath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_StartLineNumber();
    [CompilerGeneratedAttribute]
public sealed virtual void set_StartLineNumber(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_StartColumnNumber();
    [CompilerGeneratedAttribute]
public sealed virtual void set_StartColumnNumber(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_EndLineNumber();
    [CompilerGeneratedAttribute]
public sealed virtual void set_EndLineNumber(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_EndColumnNumber();
    [CompilerGeneratedAttribute]
public sealed virtual void set_EndColumnNumber(int value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_LibraryId();
    [CompilerGeneratedAttribute]
public sealed virtual void set_LibraryId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual NuGetFramework get_Framework();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Framework(NuGetFramework value);
    [NullableContextAttribute("1")]
public static PackagingLogMessage CreateError(string message, NuGetLogCode code);
    [NullableContextAttribute("1")]
public static PackagingLogMessage CreateWarning(string message, NuGetLogCode code);
    [NullableContextAttribute("1")]
public static PackagingLogMessage CreateMessage(string message, LogLevel logLevel);
    [NullableContextAttribute("1")]
public static PackagingLogMessage CreateWarning(string message, NuGetLogCode code, string libraryId, NuGetFramework framework);
    private static NuGetLogCode GetDefaultLogCode(LogLevel logLevel);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NuGet.Common.PathResolver : object {
    public static IEnumerable`1<T> GetMatches(IEnumerable`1<T> source, Func`2<T, string> getPath, IEnumerable`1<string> wildcards);
    public static void FilterPackageFiles(ICollection`1<T> source, Func`2<T, string> getPath, IEnumerable`1<string> wildcards);
    public static IEnumerable`1<T> GetFilteredPackageFiles(ICollection`1<T> source, Func`2<T, string> getPath, IEnumerable`1<string> wildcards);
    public static string NormalizeWildcardForExcludedFiles(string basePath, string wildcard);
    private static Regex WildcardToRegex(string wildcard);
    public static IEnumerable`1<string> PerformWildcardSearch(string basePath, string searchPath);
    public static IEnumerable`1<SearchPathResult> PerformWildcardSearch(string basePath, string searchPath, bool includeEmptyDirectories, String& normalizedBasePath);
    internal static string GetPathToEnumerateFrom(string basePath, string searchPath);
    internal static string NormalizeBasePath(string basePath, String& searchPath);
    public static bool IsWildcardSearch(string filter);
    [NullableContextAttribute("2")]
public static bool IsDirectoryPath(string path);
    private static bool IsEmptyDirectory(string directory);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NuGet.Common.PathUtility : object {
    private static Lazy`1<bool> _isFileSystemCaseInsensitive;
    public static bool IsFileSystemCaseInsensitive { get; }
    private static PathUtility();
    public static StringComparer GetStringComparerBasedOnOS();
    public static StringComparison GetStringComparisonBasedOnOS();
    [IteratorStateMachineAttribute("NuGet.Common.PathUtility/<GetUniquePathsBasedOnOS>d__3")]
public static IEnumerable`1<string> GetUniquePathsBasedOnOS(IEnumerable`1<string> paths);
    public static string GetPathWithForwardSlashes(string path);
    public static string EnsureTrailingSlash(string path);
    public static string EnsureTrailingForwardSlash(string path);
    private static string EnsureTrailingCharacter(string path, char trailingCharacter);
    public static bool IsChildOfDirectory(string dir, string candidate);
    [NullableContextAttribute("2")]
public static bool HasTrailingDirectorySeparator(string path);
    public static bool IsDirectorySeparatorChar(char ch);
    public static void EnsureParentDirectory(string filePath);
    public static string GetRelativePath(string path1, string path2);
    public static string GetRelativePath(string path1, string path2, char separator);
    public static string GetAbsolutePath(string basePath, string relativePath);
    public static string GetDirectoryName(string path);
    public static string GetPathWithBackSlashes(string path);
    public static string GetPathWithDirectorySeparator(string path);
    public static string GetPath(Uri uri);
    public static string EscapePSPath(string path);
    public static string SmartTruncate(string path, int maxWidth);
    public static bool IsSubdirectory(string basePath, string path);
    public static string ReplaceAltDirSeparatorWithDirSeparator(string path);
    public static string ReplaceDirSeparatorWithAltDirSeparator(string path);
    public static ZipArchiveEntry GetEntry(ZipArchive archive, string path);
    public static bool get_IsFileSystemCaseInsensitive();
    private static bool CheckIfFileSystemIsCaseInsensitive();
    private static string GetFirstParentDirectoryThatExists(string path);
    private static bool CheckIfFileSystemIsCaseInsensitive(string path);
    public static string StripLeadingDirectorySeparators(string filename);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NuGet.Common.PathValidator : object {
    public static bool IsValidSource(string source);
    public static bool IsValidLocalPath(string path);
    public static bool IsValidUncPath(string path);
    public static bool IsValidUrl(string url);
    public static bool IsValidRelativePath(string path);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NuGet.Common.Preprocessor : object {
    [AsyncStateMachineAttribute("NuGet.Common.Preprocessor/<ProcessAsync>d__0")]
public static Task`1<string> ProcessAsync(Func`1<Task`1<Stream>> streamTaskFactory, Func`2<string, string> tokenReplacement, CancellationToken cancellationToken);
    public static string Process(Stream stream, Func`2<string, string> tokenReplacement);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NuGet.Common.ProjectJsonPathUtilities : object {
    public static string ProjectConfigFileName;
    public static string ProjectConfigFileEnding;
    public static string ProjectLockFileName;
    private static ProjectJsonPathUtilities();
    public static string GetProjectConfigPath(string directoryPath, string projectName);
    public static string GetProjectConfigWithProjectName(string projectName);
    public static string GetProjectLockFileNameWithProjectName(string projectName);
    public static string GetLockFilePath(string configFilePath);
    public static string GetProjectNameFromConfigFileName(string configPath);
    public static bool IsProjectConfig(string configPath);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Common.RestoreLogMessage : object {
    [CompilerGeneratedAttribute]
private LogLevel <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetLogCode <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Time>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <ProjectPath>k__BackingField;
    [CompilerGeneratedAttribute]
private WarningLevel <WarningLevel>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartLineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartColumnNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndLineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndColumnNumber>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <LibraryId>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <TargetGraphs>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldDisplay>k__BackingField;
    public LogLevel Level { get; public set; }
    public NuGetLogCode Code { get; public set; }
    public string Message { get; public set; }
    public DateTimeOffset Time { get; public set; }
    [NullableAttribute("2")]
public string ProjectPath { get; public set; }
    public WarningLevel WarningLevel { get; public set; }
    [NullableAttribute("2")]
public string FilePath { get; public set; }
    public int StartLineNumber { get; public set; }
    public int StartColumnNumber { get; public set; }
    public int EndLineNumber { get; public set; }
    public int EndColumnNumber { get; public set; }
    [NullableAttribute("2")]
public string LibraryId { get; public set; }
    public IReadOnlyList`1<string> TargetGraphs { get; public set; }
    public bool ShouldDisplay { get; public set; }
    public RestoreLogMessage(LogLevel logLevel, NuGetLogCode errorCode, string errorString, string targetGraph, bool logToInnerLogger);
    public RestoreLogMessage(LogLevel logLevel, NuGetLogCode errorCode, string errorString, string targetGraph);
    public RestoreLogMessage(LogLevel logLevel, NuGetLogCode errorCode, string errorString);
    public RestoreLogMessage(LogLevel logLevel, string errorString);
    [CompilerGeneratedAttribute]
public sealed virtual LogLevel get_Level();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Level(LogLevel value);
    [CompilerGeneratedAttribute]
public sealed virtual NuGetLogCode get_Code();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Code(NuGetLogCode value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Message();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Message(string value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_Time();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Time(DateTimeOffset value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_ProjectPath();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void set_ProjectPath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual WarningLevel get_WarningLevel();
    [CompilerGeneratedAttribute]
public sealed virtual void set_WarningLevel(WarningLevel value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_FilePath();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void set_FilePath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_StartLineNumber();
    [CompilerGeneratedAttribute]
public sealed virtual void set_StartLineNumber(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_StartColumnNumber();
    [CompilerGeneratedAttribute]
public sealed virtual void set_StartColumnNumber(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_EndLineNumber();
    [CompilerGeneratedAttribute]
public sealed virtual void set_EndLineNumber(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_EndColumnNumber();
    [CompilerGeneratedAttribute]
public sealed virtual void set_EndColumnNumber(int value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_LibraryId();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void set_LibraryId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<string> get_TargetGraphs();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TargetGraphs(IReadOnlyList`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ShouldDisplay();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ShouldDisplay(bool value);
    public static RestoreLogMessage CreateWarning(NuGetLogCode code, string message, string libraryId, String[] targetGraphs);
    public static RestoreLogMessage CreateWarning(NuGetLogCode code, string message);
    public static RestoreLogMessage CreateError(NuGetLogCode code, string message);
    public static RestoreLogMessage CreateError(NuGetLogCode code, string message, string libraryId, String[] targetGraphs);
    private static NuGetLogCode GetDefaultLogCode(LogLevel logLevel);
}
public enum NuGet.Common.RevocationMode : Enum {
    public int value__;
    public static RevocationMode Online;
    public static RevocationMode Offline;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NuGet.Common.RuntimeEnvironmentHelper : object {
    private static String[] VisualStudioProcesses;
    private static Lazy`1<bool> _isMono;
    private static Lazy`1<bool> _isWindows;
    private static Lazy`1<bool> _IsMacOSX;
    private static Lazy`1<bool> _IsLinux;
    private static Lazy`1<bool> _isRunningInVisualStudio;
    public static bool IsWindows { get; }
    public static bool IsMono { get; }
    public static bool IsRunningInVisualStudio { get; }
    public static bool IsMacOSX { get; }
    public static bool IsLinux { get; }
    private static RuntimeEnvironmentHelper();
    private static int uname(IntPtr buf);
    public static bool get_IsWindows();
    private static bool GetIsWindows();
    public static bool get_IsMono();
    public static bool get_IsRunningInVisualStudio();
    private static string GetCurrentProcessFilePath();
    public static bool get_IsMacOSX();
    private static bool GetIsMacOSX();
    public static bool get_IsLinux();
    private static bool GetIsLinux();
}
public enum NuGet.Common.SignatureAlgorithmName : Enum {
    public int value__;
    public static SignatureAlgorithmName Unknown;
    public static SignatureAlgorithmName SHA256RSA;
    public static SignatureAlgorithmName SHA384RSA;
    public static SignatureAlgorithmName SHA512RSA;
}
public enum NuGet.Common.SignatureValidationMode : Enum {
    public int value__;
    public static SignatureValidationMode Accept;
    public static SignatureValidationMode Require;
}
[ExtensionAttribute]
internal static class NuGet.Common.StringExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static string FormatWithDoubleQuotes(string s);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class NuGet.Common.Strings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string Argument_Must_Be_GreaterThanOrEqualTo { get; }
    internal static string ArgumentNullOrEmpty { get; }
    internal static string MissingRequiredEnvVar { get; }
    internal static string MissingRequiredEnvVarsDotnet { get; }
    internal static string TimeUnits_Hour { get; }
    internal static string TimeUnits_Millisecond { get; }
    internal static string TimeUnits_Minute { get; }
    internal static string TimeUnits_Second { get; }
    internal static string UnableToDetemineClientVersion { get; }
    internal static string UnableToSetNuGetTempFolderPermission { get; }
    internal static string UnauthorizedLockFail { get; }
    internal static string UnsupportedHashAlgorithm { get; }
    internal static string UnsupportedHashAlgorithmName { get; }
    internal static string UnsupportedSignatureAlgorithmName { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_Argument_Must_Be_GreaterThanOrEqualTo();
    internal static string get_ArgumentNullOrEmpty();
    internal static string get_MissingRequiredEnvVar();
    internal static string get_MissingRequiredEnvVarsDotnet();
    internal static string get_TimeUnits_Hour();
    internal static string get_TimeUnits_Millisecond();
    internal static string get_TimeUnits_Minute();
    internal static string get_TimeUnits_Second();
    internal static string get_UnableToDetemineClientVersion();
    internal static string get_UnableToSetNuGetTempFolderPermission();
    internal static string get_UnauthorizedLockFail();
    internal static string get_UnsupportedHashAlgorithm();
    internal static string get_UnsupportedHashAlgorithmName();
    internal static string get_UnsupportedSignatureAlgorithmName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Common.TelemetryActivity : object {
    private DateTime _startTime;
    private Stopwatch _stopwatch;
    private Stopwatch _intervalWatch;
    private List`1<Tuple`2<string, TimeSpan>> _intervalList;
    [NullableAttribute("2")]
private IDisposable _telemetryActivity;
    private bool _disposed;
    [CompilerGeneratedAttribute]
private TelemetryEvent <TelemetryEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <ParentId>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <OperationId>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private static INuGetTelemetryService <NuGetTelemetryService>k__BackingField;
    public TelemetryEvent TelemetryEvent { get; public set; }
    public Guid ParentId { get; }
    public Guid OperationId { get; }
    [NullableAttribute("2")]
public static INuGetTelemetryService NuGetTelemetryService { get; public set; }
    private TelemetryActivity(Guid parentId, TelemetryEvent telemetryEvent, Guid operationId);
    [CompilerGeneratedAttribute]
public TelemetryEvent get_TelemetryEvent();
    [CompilerGeneratedAttribute]
public void set_TelemetryEvent(TelemetryEvent value);
    [CompilerGeneratedAttribute]
public Guid get_ParentId();
    [CompilerGeneratedAttribute]
public Guid get_OperationId();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static INuGetTelemetryService get_NuGetTelemetryService();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static void set_NuGetTelemetryService(INuGetTelemetryService value);
    public void StartIntervalMeasure();
    public void EndIntervalMeasure(string propertyName);
    public IDisposable StartIndependentInterval(string propertyName);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public static void EmitTelemetryEvent(TelemetryEvent TelemetryEvent);
    public static TelemetryActivity Create(string eventName);
    public static TelemetryActivity Create(TelemetryEvent telemetryEvent);
    public static TelemetryActivity Create(Guid parentId, string eventName);
    public static TelemetryActivity Create(Guid parentId, TelemetryEvent telemetryEvent);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class NuGet.Common.TelemetryEvent : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IDictionary`2<string, object> _properties;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IDictionary`2<string, object> _piiProperties;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IDictionary`2<string, object> <ComplexData>k__BackingField;
    public string Name { get; }
    public int Count { get; }
    [NullableAttribute("2")]
public object Item { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IDictionary`2<string, object> ComplexData { get; }
    public TelemetryEvent(string eventName);
    public TelemetryEvent(string eventName, Dictionary`2<string, object> properties);
    [CompilerGeneratedAttribute]
public string get_Name();
    public int get_Count();
    public object get_Item(string key);
    public void set_Item(string key, object value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_ComplexData();
    public IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator();
    public void AddPiiData(string key, object value);
    public IEnumerable`1<KeyValuePair`2<string, object>> GetPiiData();
}
public static class NuGet.Common.TelemetryServiceUtility : object {
    [NullableAttribute("2")]
private static Stopwatch StopWatch;
    public static void StartOrResumeTimer();
    public static void StopTimer();
    public static TimeSpan GetTimerElapsedTime();
    public static double GetTimerElapsedTimeInSeconds();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Common.Token : object {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private TokenCategory <Category>k__BackingField;
    public string Value { get; private set; }
    public TokenCategory Category { get; private set; }
    public Token(TokenCategory category, string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(string value);
    [CompilerGeneratedAttribute]
public TokenCategory get_Category();
    [CompilerGeneratedAttribute]
private void set_Category(TokenCategory value);
}
public enum NuGet.Common.TokenCategory : Enum {
    public int value__;
    public static TokenCategory Text;
    public static TokenCategory Variable;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Common.Tokenizer : object {
    private string _text;
    private int _index;
    public Tokenizer(string text);
    [NullableContextAttribute("2")]
public Token Read();
    private static bool IsWordChar(char ch);
    private Token ParseTokenAfterDollarSign();
    private Token ParseText();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NuGet.Common.UriUtility : object {
    private static string FilePrefix;
    private static bool IsHttpUrl(Uri uri);
    public static Uri CreateSourceUri(string source, UriKind kind);
    public static Uri TryCreateSourceUri(string source, UriKind kind);
    private static string FixSourceUri(string source);
    public static string UrlEncodeOdataParameter(string value);
    public static string GetLocalPath(string localOrUriPath);
    public static string GetAbsolutePathFromFile(string sourceFile, string path);
    [NullableContextAttribute("2")]
public static string GetAbsolutePath(string rootDirectory, string path);
    [NullableContextAttribute("2")]
public static bool IsNuGetOrg(string source);
}
public enum NuGet.Common.WarningLevel : Enum {
    public int value__;
    public static WarningLevel Severe;
    public static WarningLevel Important;
    public static WarningLevel Minimal;
    public static WarningLevel Default;
}
[ObsoleteAttribute("This class is obsolete and will be removed in a future release.")]
public static class NuGet.Common.XmlUtility : object {
    [NullableContextAttribute("1")]
public static XDocument Load(string filePath);
}
public class NuGet.Configuration.AddItem : SettingItem {
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <RequiredAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> <DisallowedValues>k__BackingField;
    public string ElementName { get; }
    public string Key { get; }
    public string Value { get; public set; }
    public IReadOnlyDictionary`2<string, string> AdditionalAttributes { get; }
    protected IReadOnlyCollection`1<string> RequiredAttributes { get; }
    protected IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> DisallowedValues { get; }
    public AddItem(string key, string value);
    internal AddItem(XElement element, SettingsFile origin);
    public AddItem(string key, string value, IReadOnlyDictionary`2<string, string> additionalAttributes);
    public virtual string get_ElementName();
    public string get_Key();
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public IReadOnlyDictionary`2<string, string> get_AdditionalAttributes();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyCollection`1<string> get_RequiredAttributes();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> get_DisallowedValues();
    public virtual string GetValueAsPath();
    public void AddOrUpdateAdditionalAttribute(string attributeName, string value);
    public sealed virtual bool Equals(object other);
    public sealed virtual int GetHashCode();
    public virtual SettingBase Clone();
    internal virtual void Update(SettingItem other);
}
public class NuGet.Configuration.AuthorItem : TrustedSignerItem {
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <RequiredAttributes>k__BackingField;
    public string ElementName { get; }
    protected IReadOnlyCollection`1<string> RequiredAttributes { get; }
    public AuthorItem(string name, CertificateItem[] certificates);
    internal AuthorItem(XElement element, SettingsFile origin);
    public virtual string get_ElementName();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyCollection`1<string> get_RequiredAttributes();
    public virtual SettingBase Clone();
    internal virtual XNode AsXNode();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
public class NuGet.Configuration.CertificateItem : SettingItem {
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <RequiredAttributes>k__BackingField;
    public string ElementName { get; }
    public string Fingerprint { get; public set; }
    public HashAlgorithmName HashAlgorithm { get; public set; }
    public bool AllowUntrustedRoot { get; public set; }
    protected IReadOnlyCollection`1<string> RequiredAttributes { get; }
    public CertificateItem(string fingerprint, HashAlgorithmName hashAlgorithm, bool allowUntrustedRoot);
    internal CertificateItem(XElement element, SettingsFile origin);
    public virtual string get_ElementName();
    public string get_Fingerprint();
    public void set_Fingerprint(string value);
    public HashAlgorithmName get_HashAlgorithm();
    public void set_HashAlgorithm(HashAlgorithmName value);
    public bool get_AllowUntrustedRoot();
    public void set_AllowUntrustedRoot(bool value);
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyCollection`1<string> get_RequiredAttributes();
    public virtual SettingBase Clone();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
public class NuGet.Configuration.ClearItem : SettingItem {
    public string ElementName { get; }
    internal ClearItem(XElement element, SettingsFile origin);
    public virtual string get_ElementName();
    public virtual bool IsEmpty();
    public virtual SettingBase Clone();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
public class NuGet.Configuration.ClientCertificateProvider : object {
    private ISettings _settings;
    public ClientCertificateProvider(ISettings settings);
    public sealed virtual void AddOrUpdate(ClientCertItem item);
    public sealed virtual void Remove(IReadOnlyList`1<ClientCertItem> items);
    public sealed virtual IReadOnlyList`1<ClientCertItem> GetClientCertificates();
    public ClientCertItem GetClientCertificate(string packageSourceName);
}
public abstract class NuGet.Configuration.ClientCertItem : SettingItem {
    public string PackageSource { get; }
    protected bool CanHaveChildren { get; }
    protected ClientCertItem(string packageSource);
    internal ClientCertItem(XElement element, SettingsFile origin);
    public string get_PackageSource();
    protected virtual bool get_CanHaveChildren();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public abstract virtual IEnumerable`1<X509Certificate> Search();
    protected void SetPackageSource(string value);
}
public static class NuGet.Configuration.ConfigurationConstants : object {
    public static string ActivePackageSourceSectionName;
    public static string Add;
    public static string AllowUntrustedRoot;
    public static string AllowInsecureConnections;
    public static string ApiKeys;
    public static string Author;
    public static string BeginIgnoreMarker;
    public static string BindingRedirectsSection;
    public static string Certificate;
    public static string Package;
    public static string Clear;
    public static string ClearTextPasswordAttribute;
    public static string ClearTextPasswordToken;
    public static string ClientCertificates;
    public static string Config;
    public static string Configuration;
    public static string ConfigurationDefaultsFile;
    public static string CredentialsSectionName;
    public static string DefaultPackageManagementFormatKey;
    public static string DefaultPushSource;
    public static string DependencyVersion;
    public static string DisabledPackageSources;
    public static string DoNotShowPackageManagementSelectionKey;
    public static string Enabled;
    public static string EndIgnoreMarker;
    public static string FailOnBindingRedirects;
    public static string FallbackPackageFolders;
    public static string FileCertificate;
    public static string FindByAttribute;
    public static string FindValueAttribute;
    public static string Fingerprint;
    public static string FingerprintAlgorithm;
    public static string UpdatePackageLastAccessTime;
    public static string GlobalPackagesFolder;
    public static string HashAlgorithm;
    public static string HostKey;
    public static string KeyAttribute;
    public static string MaxHttpRequestsPerSource;
    public static string NameAttribute;
    public static string NoProxy;
    public static string Owners;
    public static string PackageManagementSection;
    public static string PackageRestore;
    public static string PackageSourceAttribute;
    public static string PackageSources;
    public static string PasswordAttribute;
    public static string PasswordKey;
    public static string PasswordToken;
    public static string PathAttribute;
    public static string ProtocolVersionAttribute;
    public static string Repository;
    public static string RepositoryPath;
    public static string ServiceIndex;
    public static string SignatureValidationMode;
    public static string SkipBindingRedirectsKey;
    public static string StoreCertificate;
    public static string StoreLocationAttribute;
    public static string StoreNameAttribute;
    public static string TrustedSigners;
    public static string PackageSourceMapping;
    public static string UserKey;
    public static string UsernameToken;
    public static string ValidAuthenticationTypesToken;
    public static string ValueAttribute;
    public static string PatternAttribute;
    private static ConfigurationConstants();
}
public class NuGet.Configuration.ConfigurationDefaults : object {
    private ISettings _settingsManager;
    private bool _defaultPackageSourceInitialized;
    private List`1<PackageSource> _defaultPackageSources;
    private string _defaultPushSource;
    [CompilerGeneratedAttribute]
private static ConfigurationDefaults <Instance>k__BackingField;
    public static ConfigurationDefaults Instance { get; }
    public IEnumerable`1<PackageSource> DefaultPackageSources { get; }
    public string DefaultPushSource { get; }
    public string DefaultPackageRestoreConsent { get; }
    internal ConfigurationDefaults(string directory, string configFile);
    private static ConfigurationDefaults();
    private static ConfigurationDefaults InitializeInstance();
    [CompilerGeneratedAttribute]
public static ConfigurationDefaults get_Instance();
    public IEnumerable`1<PackageSource> get_DefaultPackageSources();
    public string get_DefaultPushSource();
    public string get_DefaultPackageRestoreConsent();
}
public enum NuGet.Configuration.CredentialRequestType : Enum {
    public int value__;
    public static CredentialRequestType Proxy;
    public static CredentialRequestType Unauthorized;
    public static CredentialRequestType Forbidden;
}
public class NuGet.Configuration.CredentialsItem : SettingItem {
    private string _elementName;
    [CompilerGeneratedAttribute]
private bool <IsPasswordClearText>k__BackingField;
    internal AddItem _username;
    internal AddItem _password;
    [CompilerGeneratedAttribute]
private AddItem <_validAuthenticationTypes>k__BackingField;
    public string ElementName { get; protected set; }
    public string Username { get; public set; }
    public bool IsPasswordClearText { get; private set; }
    public string Password { get; }
    public string ValidAuthenticationTypes { get; public set; }
    protected bool CanHaveChildren { get; }
    internal AddItem _validAuthenticationTypes { get; internal set; }
    public CredentialsItem(string name, string username, string password, bool isPasswordClearText, string validAuthenticationTypes);
    internal CredentialsItem(XElement element, SettingsFile origin);
    public virtual string get_ElementName();
    protected virtual void set_ElementName(string value);
    public string get_Username();
    public void set_Username(string value);
    [CompilerGeneratedAttribute]
public bool get_IsPasswordClearText();
    [CompilerGeneratedAttribute]
private void set_IsPasswordClearText(bool value);
    public string get_Password();
    public void UpdatePassword(string password, bool isPasswordClearText);
    public string get_ValidAuthenticationTypes();
    public void set_ValidAuthenticationTypes(string value);
    protected virtual bool get_CanHaveChildren();
    public virtual bool IsEmpty();
    [CompilerGeneratedAttribute]
internal AddItem get__validAuthenticationTypes();
    [CompilerGeneratedAttribute]
internal void set__validAuthenticationTypes(AddItem value);
    public virtual SettingBase Clone();
    internal virtual XNode AsXNode();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    internal virtual void Update(SettingItem other);
    internal virtual void SetOrigin(SettingsFile origin);
    internal virtual void RemoveFromSettings();
}
public static class NuGet.Configuration.EncryptionUtility : object {
    private static Byte[] _entropyBytes;
    private static EncryptionUtility();
    public static string EncryptString(string value);
    public static string DecryptString(string encryptedString);
}
public class NuGet.Configuration.FileClientCertItem : ClientCertItem {
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <AllowedAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <RequiredAttributes>k__BackingField;
    public string ElementName { get; }
    public string FilePath { get; }
    public bool IsPasswordIsClearText { get; }
    public string Password { get; }
    protected IReadOnlyCollection`1<string> AllowedAttributes { get; }
    protected IReadOnlyCollection`1<string> RequiredAttributes { get; }
    public FileClientCertItem(string packageSource, string filePath, string password, bool storePasswordInClearText, string settingsFilePath);
    internal FileClientCertItem(string packageSource, string filePath, string password, bool storePasswordInClearText, SettingsFile origin);
    internal FileClientCertItem(XElement element, SettingsFile origin);
    public virtual string get_ElementName();
    public string get_FilePath();
    public bool get_IsPasswordIsClearText();
    public string get_Password();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyCollection`1<string> get_AllowedAttributes();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyCollection`1<string> get_RequiredAttributes();
    internal virtual XNode AsXNode();
    public virtual SettingBase Clone();
    public virtual IEnumerable`1<X509Certificate> Search();
    public void Update(string filePath, string password, bool storePasswordInClearText);
    private string FindAbsoluteFilePath();
}
internal static class NuGet.Configuration.FileSystemUtility : object {
    internal static XDocument GetOrCreateDocument(XDocument content, string fullPath);
    internal static void AddFile(string fullPath, Action`1<Stream> writeToStream);
    private static int chmod(string pathname, int mode);
    internal static bool IsPathAFile(string path);
    internal static bool DoesFileExistIn(string root, string file);
    internal static IEnumerable`1<string> GetFilesRelativeToRoot(string root, string path, String[] filters, SearchOption searchOption);
    internal static string GetRelativePath(string root, string fullPath);
    internal static string EnsureTrailingSlash(string path);
    internal static string EnsureTrailingForwardSlash(string path);
    private static string EnsureTrailingCharacter(string path, char trailingCharacter);
}
public interface NuGet.Configuration.IClientCertificateProvider {
    public abstract virtual void AddOrUpdate(ClientCertItem item);
    public abstract virtual IReadOnlyList`1<ClientCertItem> GetClientCertificates();
    public abstract virtual void Remove(IReadOnlyList`1<ClientCertItem> items);
}
public interface NuGet.Configuration.ICredentialCache {
    public abstract virtual void Add(Uri uri, ICredentials credentials);
    public abstract virtual ICredentials GetCredentials(Uri uri);
}
public interface NuGet.Configuration.ICredentialService {
    public bool HandlesDefaultCredentials { get; }
    public abstract virtual Task`1<ICredentials> GetCredentialsAsync(Uri uri, IWebProxy proxy, CredentialRequestType type, string message, CancellationToken cancellationToken);
    public abstract virtual bool TryGetLastKnownGoodCredentialsFromCache(Uri uri, bool isProxy, ICredentials& credentials);
    public abstract virtual bool get_HandlesDefaultCredentials();
}
public interface NuGet.Configuration.IExtensionLocator {
    public abstract virtual IEnumerable`1<string> FindExtensions();
    public abstract virtual IEnumerable`1<string> FindCredentialProviders();
}
public interface NuGet.Configuration.IMachineWideSettings {
    public ISettings Settings { get; }
    public abstract virtual ISettings get_Settings();
}
internal class NuGet.Configuration.ImmutableSettings : object {
    private ISettings _settings;
    internal ImmutableSettings(ISettings settings);
    public sealed virtual void add_SettingsChanged(EventHandler value);
    public sealed virtual void remove_SettingsChanged(EventHandler value);
    public sealed virtual void AddOrUpdate(string sectionName, SettingItem item);
    public sealed virtual IList`1<string> GetConfigFilePaths();
    public sealed virtual IList`1<string> GetConfigRoots();
    public sealed virtual SettingSection GetSection(string sectionName);
    public sealed virtual void Remove(string sectionName, SettingItem item);
    public sealed virtual void SaveToDisk();
}
public interface NuGet.Configuration.IPackageSourceProvider {
    public string ActivePackageSourceName { get; }
    public string DefaultPushSource { get; }
    public abstract virtual IEnumerable`1<PackageSource> LoadPackageSources();
    public abstract virtual PackageSource GetPackageSourceByName(string name);
    public abstract virtual PackageSource GetPackageSourceBySource(string source);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PackageSourcesChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PackageSourcesChanged(EventHandler value);
    public abstract virtual void RemovePackageSource(string name);
    public abstract virtual void EnablePackageSource(string name);
    public abstract virtual void DisablePackageSource(string name);
    public abstract virtual void UpdatePackageSource(PackageSource source, bool updateCredentials, bool updateEnabled);
    public abstract virtual void AddPackageSource(PackageSource source);
    public abstract virtual void SavePackageSources(IEnumerable`1<PackageSource> sources);
    public abstract virtual bool IsPackageSourceEnabled(string name);
    public abstract virtual string get_ActivePackageSourceName();
    public abstract virtual string get_DefaultPushSource();
    public abstract virtual void SaveActivePackageSource(PackageSource source);
}
public interface NuGet.Configuration.IProxyCache {
    public abstract virtual void Add(IWebProxy proxy);
    public abstract virtual IWebProxy GetProxy(Uri uri);
}
public interface NuGet.Configuration.IProxyCredentialCache {
    public Guid Version { get; }
    public abstract virtual Guid get_Version();
    public abstract virtual void UpdateCredential(Uri proxyAddress, NetworkCredential credentials);
}
public interface NuGet.Configuration.ISettings {
    public abstract virtual SettingSection GetSection(string sectionName);
    public abstract virtual void AddOrUpdate(string sectionName, SettingItem item);
    public abstract virtual void Remove(string sectionName, SettingItem item);
    public abstract virtual void SaveToDisk();
    [CompilerGeneratedAttribute]
public abstract virtual void add_SettingsChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_SettingsChanged(EventHandler value);
    public abstract virtual IList`1<string> GetConfigFilePaths();
    public abstract virtual IList`1<string> GetConfigRoots();
}
internal interface NuGet.Configuration.ISettingsGroup {
    public abstract virtual void Remove(SettingElement setting);
}
internal class NuGet.Configuration.NuGetConfiguration : SettingsGroup`1<SettingSection> {
    public string ElementName { get; }
    internal IReadOnlyDictionary`2<string, SettingSection> Sections { get; }
    protected bool CanBeCleared { get; }
    private NuGetConfiguration(IReadOnlyDictionary`2<string, string> attributes, IEnumerable`1<SettingSection> children);
    internal NuGetConfiguration(SettingSection[] sections);
    internal NuGetConfiguration(SettingsFile origin);
    internal NuGetConfiguration(XElement element, SettingsFile origin);
    public virtual string get_ElementName();
    internal IReadOnlyDictionary`2<string, SettingSection> get_Sections();
    protected virtual bool get_CanBeCleared();
    public void AddOrUpdate(string sectionName, SettingItem item);
    public void Remove(string sectionName, SettingItem item);
    public SettingSection GetSection(string sectionName);
    internal void MergeSectionsInto(Dictionary`2<string, VirtualSettingSection> sectionsContainer);
    public virtual SettingBase Clone();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
public class NuGet.Configuration.NuGetConfigurationException : Exception {
    public NuGetConfigurationException(string message);
    public NuGetConfigurationException(string message, Exception innerException);
    protected NuGetConfigurationException(SerializationInfo info, StreamingContext context);
}
public static class NuGet.Configuration.NuGetConstants : object {
    public static string NuGetHostName;
    public static string NuGetSymbolHostName;
    public static string V3FeedUrl;
    public static string V2FeedUrl;
    public static string V2LegacyOfficialPackageSourceUrl;
    public static string V2LegacyFeedUrl;
    public static string V1FeedUrl;
    public static string DefaultGalleryServerUrl;
    public static string ReadmeFileName;
    public static string NuGetSolutionSettingsFolder;
    public static string PackageExtension;
    public static string SnupkgExtension;
    public static string SymbolsExtension;
    public static string ManifestExtension;
    public static string ManifestSymbolsExtension;
    public static string ReadmeExtension;
    public static string PackageReferenceFile;
    public static string PackageSpecFileName;
    public static string FeedName;
    public static string DefaultConfigContent;
    private static NuGetConstants();
}
public class NuGet.Configuration.NuGetPathContext : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <FallbackPackageFolders>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserPackageFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HttpCacheFolder>k__BackingField;
    public IReadOnlyList`1<string> FallbackPackageFolders { get; internal set; }
    public string UserPackageFolder { get; internal set; }
    public string HttpCacheFolder { get; internal set; }
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<string> get_FallbackPackageFolders();
    [CompilerGeneratedAttribute]
internal void set_FallbackPackageFolders(IReadOnlyList`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_UserPackageFolder();
    [CompilerGeneratedAttribute]
internal void set_UserPackageFolder(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_HttpCacheFolder();
    [CompilerGeneratedAttribute]
internal void set_HttpCacheFolder(string value);
    public static NuGetPathContext Create(ISettings settings);
    public static NuGetPathContext Create(string settingsRoot);
}
public class NuGet.Configuration.NullSettings : object {
    [CompilerGeneratedAttribute]
private EventHandler SettingsChanged;
    [CompilerGeneratedAttribute]
private static NullSettings <Instance>k__BackingField;
    public static NullSettings Instance { get; }
    private static NullSettings();
    [CompilerGeneratedAttribute]
public sealed virtual void add_SettingsChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_SettingsChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public static NullSettings get_Instance();
    public sealed virtual SettingSection GetSection(string sectionName);
    public sealed virtual void AddOrUpdate(string sectionName, SettingItem item);
    public sealed virtual void Remove(string sectionName, SettingItem item);
    public sealed virtual void SaveToDisk();
    public sealed virtual IList`1<string> GetConfigFilePaths();
    public sealed virtual IList`1<string> GetConfigRoots();
}
public class NuGet.Configuration.OwnersItem : SettingItem {
    public static char OwnersListSeparator;
    [CompilerGeneratedAttribute]
private IList`1<string> <Content>k__BackingField;
    private SettingText _content;
    public string ElementName { get; }
    protected bool CanHaveChildren { get; }
    public IList`1<string> Content { get; private set; }
    public OwnersItem(string owners);
    internal OwnersItem(XElement element, SettingsFile origin);
    private static OwnersItem();
    public virtual string get_ElementName();
    protected virtual bool get_CanHaveChildren();
    [CompilerGeneratedAttribute]
public IList`1<string> get_Content();
    [CompilerGeneratedAttribute]
private void set_Content(IList`1<string> value);
    public virtual SettingBase Clone();
    internal virtual XNode AsXNode();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    internal virtual void Update(SettingItem other);
}
public class NuGet.Configuration.PackagePatternItem : SettingItem {
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <RequiredAttributes>k__BackingField;
    public string ElementName { get; }
    public string Pattern { get; }
    protected IReadOnlyCollection`1<string> RequiredAttributes { get; }
    public PackagePatternItem(string pattern);
    internal PackagePatternItem(XElement element, SettingsFile origin);
    public virtual string get_ElementName();
    public string get_Pattern();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyCollection`1<string> get_RequiredAttributes();
    public virtual SettingBase Clone();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
public class NuGet.Configuration.PackageSource : object {
    public static int DefaultProtocolVersion;
    public static int MaxProtocolVersion;
    internal static bool DefaultAllowInsecureConnections;
    private int _hashCode;
    private string _source;
    private bool _isHttp;
    private bool _isHttps;
    private bool _isLocal;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOfficial>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMachineWide>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEnabled>k__BackingField;
    [NuGet.Configuration.NullableAttribute("2")]
[CompilerGeneratedAttribute]
private PackageSourceCredential <Credentials>k__BackingField;
    [NuGet.Configuration.NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPersistable>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxHttpRequestsPerSource>k__BackingField;
    [NuGet.Configuration.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyList`1<X509Certificate> <ClientCertificates>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ProtocolVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowInsecureConnections>k__BackingField;
    public string Name { get; }
    public string Source { get; public set; }
    [NuGet.Configuration.NullableAttribute("2")]
public Uri TrySourceAsUri { get; }
    public Uri SourceUri { get; }
    public bool IsOfficial { get; public set; }
    public bool IsMachineWide { get; public set; }
    public bool IsEnabled { get; public set; }
    [NuGet.Configuration.NullableAttribute("2")]
public PackageSourceCredential Credentials { get; public set; }
    [NuGet.Configuration.NullableAttribute("2")]
public string Description { get; public set; }
    public bool IsPersistable { get; }
    public int MaxHttpRequestsPerSource { get; public set; }
    [NuGet.Configuration.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyList`1<X509Certificate> ClientCertificates { get; public set; }
    public int ProtocolVersion { get; public set; }
    public bool AllowInsecureConnections { get; public set; }
    public bool IsHttp { get; }
    public bool IsHttps { get; }
    public bool IsLocal { get; }
    public PackageSource(string source);
    public PackageSource(string source, string name);
    public PackageSource(string source, string name, bool isEnabled);
    public PackageSource(string source, string name, bool isEnabled, bool isOfficial, bool isPersistable);
    [CompilerGeneratedAttribute]
public string get_Name();
    public string get_Source();
    public void set_Source(string value);
    [NuGet.Configuration.NullableContextAttribute("2")]
public Uri get_TrySourceAsUri();
    public Uri get_SourceUri();
    [CompilerGeneratedAttribute]
public bool get_IsOfficial();
    [CompilerGeneratedAttribute]
public void set_IsOfficial(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsMachineWide();
    [CompilerGeneratedAttribute]
public void set_IsMachineWide(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsEnabled();
    [CompilerGeneratedAttribute]
public void set_IsEnabled(bool value);
    [NuGet.Configuration.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public PackageSourceCredential get_Credentials();
    [NuGet.Configuration.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Credentials(PackageSourceCredential value);
    [NuGet.Configuration.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Description();
    [NuGet.Configuration.NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public bool get_IsPersistable();
    [CompilerGeneratedAttribute]
public int get_MaxHttpRequestsPerSource();
    [CompilerGeneratedAttribute]
public void set_MaxHttpRequestsPerSource(int value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<X509Certificate> get_ClientCertificates();
    [CompilerGeneratedAttribute]
public void set_ClientCertificates(IReadOnlyList`1<X509Certificate> value);
    [CompilerGeneratedAttribute]
public int get_ProtocolVersion();
    [CompilerGeneratedAttribute]
public void set_ProtocolVersion(int value);
    [CompilerGeneratedAttribute]
public bool get_AllowInsecureConnections();
    [CompilerGeneratedAttribute]
public void set_AllowInsecureConnections(bool value);
    public bool get_IsHttp();
    public bool get_IsHttps();
    public bool get_IsLocal();
    public SourceItem AsSourceItem();
    [NuGet.Configuration.NullableContextAttribute("2")]
public sealed virtual bool Equals(PackageSource other);
    [NuGet.Configuration.NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual string ToString();
    public virtual int GetHashCode();
    public PackageSource Clone();
}
public class NuGet.Configuration.PackageSourceCredential : object {
    [CompilerGeneratedAttribute]
private string <Username>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PasswordText>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPasswordClearText>k__BackingField;
    private Lazy`1<int> _hashCode;
    [CompilerGeneratedAttribute]
private string <ValidAuthenticationTypesText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    public string Username { get; }
    public string PasswordText { get; }
    public bool IsPasswordClearText { get; }
    public IEnumerable`1<string> ValidAuthenticationTypes { get; }
    public string ValidAuthenticationTypesText { get; }
    public string Password { get; }
    public string Source { get; }
    public PackageSourceCredential(string source, string username, string passwordText, bool isPasswordClearText, string validAuthenticationTypesText);
    [CompilerGeneratedAttribute]
public string get_Username();
    [CompilerGeneratedAttribute]
public string get_PasswordText();
    [CompilerGeneratedAttribute]
public bool get_IsPasswordClearText();
    public IEnumerable`1<string> get_ValidAuthenticationTypes();
    [CompilerGeneratedAttribute]
public string get_ValidAuthenticationTypesText();
    public string get_Password();
    [CompilerGeneratedAttribute]
public string get_Source();
    public bool IsValid();
    public static PackageSourceCredential FromUserInput(string source, string username, string password, bool storePasswordInClearText, string validAuthenticationTypesText);
    public ICredentials ToICredentials();
    internal PackageSourceCredential Clone();
    private static IEnumerable`1<string> ParseAuthTypeFilterString(string str);
    public CredentialsItem AsCredentialsItem();
    public sealed virtual bool Equals(PackageSourceCredential other);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
private int <.ctor>b__21_0();
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
public class NuGet.Configuration.PackageSourceMapping : object {
    [CompilerGeneratedAttribute]
private static int <PackageIdMaxLength>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, IReadOnlyList`1<string>> <Patterns>k__BackingField;
    [NuGet.Configuration.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Lazy`1<SearchTree> <SearchTree>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEnabled>k__BackingField;
    internal static int PackageIdMaxLength { get; }
    internal IReadOnlyDictionary`2<string, IReadOnlyList`1<string>> Patterns { get; }
    [NuGet.Configuration.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<SearchTree> SearchTree { get; }
    public bool IsEnabled { get; }
    public PackageSourceMapping(IReadOnlyDictionary`2<string, IReadOnlyList`1<string>> patterns);
    private static PackageSourceMapping();
    [CompilerGeneratedAttribute]
internal static int get_PackageIdMaxLength();
    [CompilerGeneratedAttribute]
internal IReadOnlyDictionary`2<string, IReadOnlyList`1<string>> get_Patterns();
    [CompilerGeneratedAttribute]
private Lazy`1<SearchTree> get_SearchTree();
    [CompilerGeneratedAttribute]
public bool get_IsEnabled();
    public IReadOnlyList`1<string> GetConfiguredPackageSources(string packageId);
    public string SearchForPattern(string packageId);
    public static PackageSourceMapping GetPackageSourceMapping(ISettings settings);
    private SearchTree GetSearchTree();
    [CompilerGeneratedAttribute]
private SearchTree <.ctor>b__14_0();
}
public class NuGet.Configuration.PackageSourceMappingProvider : object {
    private ISettings _settings;
    [CompilerGeneratedAttribute]
private bool <ShouldSkipSave>k__BackingField;
    public bool ShouldSkipSave { get; }
    public PackageSourceMappingProvider(ISettings settings);
    public PackageSourceMappingProvider(ISettings settings, bool shouldSkipSave);
    [CompilerGeneratedAttribute]
public bool get_ShouldSkipSave();
    public IReadOnlyList`1<PackageSourceMappingSourceItem> GetPackageSourceMappingItems();
    internal void Remove(IReadOnlyList`1<PackageSourceMappingSourceItem> packageSourceMappingSourceItems);
    internal void AddOrUpdatePackageSourceMappingSourceItem(PackageSourceMappingSourceItem packageSourceMappingSourceItem);
    public void SavePackageSourceMappings(IReadOnlyList`1<PackageSourceMappingSourceItem> packageSourceMappingsSourceItems);
}
public class NuGet.Configuration.PackageSourceMappingSourceItem : SettingItem {
    [CompilerGeneratedAttribute]
private IList`1<PackagePatternItem> <Patterns>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <RequiredAttributes>k__BackingField;
    internal IEnumerable`1<SettingBase> _parsedDescendants;
    protected bool CanHaveChildren { get; }
    public IList`1<PackagePatternItem> Patterns { get; }
    public string ElementName { get; }
    public string Key { get; }
    protected IReadOnlyCollection`1<string> RequiredAttributes { get; }
    public PackageSourceMappingSourceItem(string name, IEnumerable`1<PackagePatternItem> packagePatternItems);
    internal PackageSourceMappingSourceItem(XElement element, SettingsFile origin);
    protected virtual bool get_CanHaveChildren();
    [CompilerGeneratedAttribute]
public IList`1<PackagePatternItem> get_Patterns();
    public virtual string get_ElementName();
    public virtual string get_Key();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyCollection`1<string> get_RequiredAttributes();
    protected void SetKey(string value);
    internal virtual void SetOrigin(SettingsFile origin);
    internal virtual void RemoveFromSettings();
    public virtual SettingBase Clone();
    internal virtual XNode AsXNode();
    internal virtual void Update(SettingItem other);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
public class NuGet.Configuration.PackageSourceProvider : object {
    [CompilerGeneratedAttribute]
private ISettings <Settings>k__BackingField;
    internal static int MaxSupportedProtocolVersion;
    private IReadOnlyList`1<PackageSource> _configurationDefaultSources;
    [CompilerGeneratedAttribute]
private EventHandler PackageSourcesChanged;
    public ISettings Settings { get; private set; }
    public string DefaultPushSource { get; }
    public string ActivePackageSourceName { get; }
    public PackageSourceProvider(ISettings settings);
    [ObsoleteAttribute("https://github.com/NuGet/Home/issues/8479")]
public PackageSourceProvider(ISettings settings, bool enablePackageSourcesChangedEvent);
    public PackageSourceProvider(ISettings settings, IEnumerable`1<PackageSource> configurationDefaultSources);
    [ObsoleteAttribute("https://github.com/NuGet/Home/issues/8479")]
public PackageSourceProvider(ISettings settings, IEnumerable`1<PackageSource> configurationDefaultSources, bool enablePackageSourcesChangedEvent);
    [CompilerGeneratedAttribute]
public ISettings get_Settings();
    [CompilerGeneratedAttribute]
private void set_Settings(ISettings value);
    private static IReadOnlyList`1<PackageSource> LoadConfigurationDefaultSources(IEnumerable`1<PackageSource> configurationDefaultSources);
    private static List`1<PackageSource> GetPackageSourceFromSettings(ISettings settings);
    public sealed virtual IEnumerable`1<PackageSource> LoadPackageSources();
    public static IEnumerable`1<PackageSource> LoadPackageSources(ISettings settings);
    private static List`1<PackageSource> LoadPackageSources(ISettings settings, IEnumerable`1<PackageSource> defaultPackageSources);
    private static void AddDefaultPackageSources(List`1<PackageSource> loadedPackageSources, IEnumerable`1<PackageSource> defaultPackageSources);
    private static PackageSource ReadPackageSource(SourceItem setting, bool isEnabled, ISettings settings);
    private static int ReadProtocolVersion(SourceItem setting);
    private static bool ReadAllowInsecureConnections(SourceItem setting);
    private static void AddOrUpdateIndexedSource(Dictionary`2<string, IndexedPackageSource> packageSourceLookup, PackageSource packageSource, Int32& packageIndex);
    private static PackageSourceCredential ReadCredential(string sourceName, ISettings settings);
    private static PackageSourceCredential ReadCredentialFromEnvironment(string sourceName);
    public sealed virtual PackageSource GetPackageSourceByName(string name);
    public HashSet`1<string> GetPackageSourceNamesMatchingNamePrefix(string namePrefix);
    public sealed virtual PackageSource GetPackageSourceBySource(string source);
    public sealed virtual void RemovePackageSource(string name);
    private void RemovePackageSource(string name, bool shouldSkipSave, Boolean& isDirty);
    [ObsoleteAttribute("DisablePackageSource(PackageSource source) is deprecated. Please use DisablePackageSource(string name) instead.")]
public void DisablePackageSource(PackageSource source);
    public sealed virtual void DisablePackageSource(string name);
    private void AddDisabledSource(string name, bool shouldSkipSave, Boolean& isDirty);
    public sealed virtual void EnablePackageSource(string name);
    private void RemoveDisabledSource(string name, bool shouldSkipSave, Boolean& isDirty);
    public sealed virtual void UpdatePackageSource(PackageSource source, bool updateCredentials, bool updateEnabled);
    private void UpdatePackageSource(PackageSource newSource, PackageSource existingSource, AddItem existingDisabledSourceItem, CredentialsItem existingCredentialsItem, bool updateEnabled, bool updateCredentials, bool shouldSkipSave, Boolean& isDirty);
    public sealed virtual void AddPackageSource(PackageSource source);
    private void AddPackageSource(PackageSource source, bool shouldSkipSave, Boolean& isDirty);
    public sealed virtual void SavePackageSources(IEnumerable`1<PackageSource> sources);
    private Dictionary`2<string, SourceItem> GetExistingSettingsLookup();
    private void OnPackageSourcesChanged();
    public sealed virtual string get_DefaultPushSource();
    public sealed virtual bool IsPackageSourceEnabled(string name);
    [ObsoleteAttribute("IsPackageSourceEnabled(PackageSource source) is deprecated. Please use IsPackageSourceEnabled(string name) instead.")]
public bool IsPackageSourceEnabled(PackageSource source);
    public sealed virtual string get_ActivePackageSourceName();
    public sealed virtual void SaveActivePackageSource(PackageSource source);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PackageSourcesChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PackageSourcesChanged(EventHandler value);
    [CompilerGeneratedAttribute]
private void <.ctor>b__9_0(object _, EventArgs __);
}
internal class NuGet.Configuration.ParsedSettingSection : SettingSection {
    internal ParsedSettingSection(XElement element, SettingsFile origin);
    internal ParsedSettingSection(string name, SettingItem[] children);
    public virtual SettingBase Clone();
}
public class NuGet.Configuration.ProxyCache : object {
    private static IWebProxy _originalSystemProxy;
    private ConcurrentDictionary`2<Uri, ICredentials> _cachedCredentials;
    private ISettings _settings;
    private IEnvironmentVariableReader _environment;
    private static Lazy`1<ProxyCache> _instance;
    [CompilerGeneratedAttribute]
private Guid <Version>k__BackingField;
    public static ProxyCache Instance { get; }
    public Guid Version { get; private set; }
    public ProxyCache(ISettings settings, IEnvironmentVariableReader environment);
    private static ProxyCache();
    private static ProxyCache FromDefaultSettings();
    public static ProxyCache get_Instance();
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(Guid value);
    public sealed virtual IWebProxy GetProxy(Uri sourceUri);
    private bool TryAddProxyCredentialsToCache(WebProxy configuredProxy);
    public WebProxy GetUserConfiguredProxy();
    public sealed virtual void UpdateCredential(Uri proxyAddress, NetworkCredential credentials);
    public sealed virtual NetworkCredential GetCredential(Uri proxyAddress, string authType);
    [ObsoleteAttribute("Retained for backcompat only. Use UpdateCredential instead")]
public sealed virtual void Add(IWebProxy proxy);
    private static WebProxy GetSystemProxy(Uri uri);
    private static bool IsSystemProxySet(Uri uri);
}
public class NuGet.Configuration.RepositoryItem : TrustedSignerItem {
    private OwnersItem _owners;
    [CompilerGeneratedAttribute]
private IList`1<string> <Owners>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <RequiredAttributes>k__BackingField;
    public string ElementName { get; }
    public string ServiceIndex { get; }
    public string Name { get; public set; }
    public IList`1<string> Owners { get; private set; }
    protected IReadOnlyCollection`1<string> RequiredAttributes { get; }
    public RepositoryItem(string name, string serviceIndex, CertificateItem[] certificates);
    public RepositoryItem(string name, string serviceIndex, string owners, CertificateItem[] certificates);
    internal RepositoryItem(XElement element, SettingsFile origin);
    public virtual string get_ElementName();
    public string get_ServiceIndex();
    public string get_Name();
    public void set_Name(string value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_Owners();
    [CompilerGeneratedAttribute]
private void set_Owners(IList`1<string> value);
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyCollection`1<string> get_RequiredAttributes();
    public virtual SettingBase Clone();
    internal virtual XNode AsXNode();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    internal virtual void SetOrigin(SettingsFile origin);
    internal virtual void RemoveFromSettings();
    internal virtual void Update(SettingItem other);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class NuGet.Configuration.Resources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string Argument_Cannot_Be_Null_Empty_Or_WhiteSpaceOnly { get; }
    internal static string Argument_Cannot_Be_Null_Or_Empty { get; }
    internal static string AttributeNotAllowed { get; }
    internal static string AttributeValueNotAllowed { get; }
    internal static string CannotUpdateDifferentItems { get; }
    internal static string CannotUpdateMachineWide { get; }
    internal static string CannotUpdateNode { get; }
    internal static string CannotUpdateReadOnlyConfig { get; }
    internal static string ClientCertificateDuplicateConfiguration { get; }
    internal static string CredentialsItemMustHaveUsernamePassword { get; }
    internal static string Error_DuplicatePackageSource { get; }
    internal static string Error_EncryptionUnsupported { get; }
    internal static string Error_InvalidAttribute { get; }
    internal static string Error_ItemNeedsAtLeastOnePackagePattern { get; }
    internal static string Error_ItemNeedsAtLeastOnePackagePatternWithPath { get; }
    internal static string Error_MergeTwoDifferentSections { get; }
    internal static string Error_MoreThanOnePassword { get; }
    internal static string Error_MoreThanOneUsername { get; }
    internal static string Error_MoreThanOneValidAuthenticationTypes { get; }
    internal static string Error_StoreCertCertificateNotFound { get; }
    internal static string FileCertItemPasswordAndClearTextPasswordAtSameTime { get; }
    internal static string FileCertItemPasswordCannotBeDecrypted { get; }
    internal static string FileCertItemPathFileNotExist { get; }
    internal static string FileCertItemPathFileNotSet { get; }
    internal static string FileDoesNotExist { get; }
    internal static string InvalidNullSettingsOperation { get; }
    internal static string ItemDoesNotExist { get; }
    internal static string MissingRequiredAttribute { get; }
    internal static string MustContainAbsolutePath { get; }
    internal static string NoAttributesAllowed { get; }
    internal static string NoWritteableConfig { get; }
    internal static string OwnersItemMustHaveAtLeastOneOwner { get; }
    internal static string OwnersMustOnlyHaveContent { get; }
    internal static string PropertyCannotBeNullOrEmpty { get; }
    internal static string RepositoryMustHaveOneOwners { get; }
    internal static string SectionDoesNotExist { get; }
    internal static string Settings_FileName_Cannot_Be_A_Path { get; }
    internal static string ShowError_CannotHaveChildren { get; }
    internal static string ShowError_ConfigDuplicateDisabledSources { get; }
    internal static string ShowError_ConfigHasInvalidPackageSource { get; }
    internal static string ShowError_ConfigInvalidOperation { get; }
    internal static string ShowError_ConfigInvalidXml { get; }
    internal static string ShowError_ConfigRootInvalid { get; }
    internal static string ShowError_ConfigUnauthorizedAccess { get; }
    internal static string TextShouldNotBeEmpty { get; }
    internal static string TrustedSignerMustHaveCertificates { get; }
    internal static string Unknown_Config_Exception { get; }
    internal static string UnknownHashAlgorithmNotSupported { get; }
    internal static string UnsupportedDecryptPassword { get; }
    internal static string UnsupportedEncryptPassword { get; }
    internal static string UnsupportedHashAlgorithm { get; }
    internal static string UserSettings_UnableToParseConfigFile { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_Argument_Cannot_Be_Null_Empty_Or_WhiteSpaceOnly();
    internal static string get_Argument_Cannot_Be_Null_Or_Empty();
    internal static string get_AttributeNotAllowed();
    internal static string get_AttributeValueNotAllowed();
    internal static string get_CannotUpdateDifferentItems();
    internal static string get_CannotUpdateMachineWide();
    internal static string get_CannotUpdateNode();
    internal static string get_CannotUpdateReadOnlyConfig();
    internal static string get_ClientCertificateDuplicateConfiguration();
    internal static string get_CredentialsItemMustHaveUsernamePassword();
    internal static string get_Error_DuplicatePackageSource();
    internal static string get_Error_EncryptionUnsupported();
    internal static string get_Error_InvalidAttribute();
    internal static string get_Error_ItemNeedsAtLeastOnePackagePattern();
    internal static string get_Error_ItemNeedsAtLeastOnePackagePatternWithPath();
    internal static string get_Error_MergeTwoDifferentSections();
    internal static string get_Error_MoreThanOnePassword();
    internal static string get_Error_MoreThanOneUsername();
    internal static string get_Error_MoreThanOneValidAuthenticationTypes();
    internal static string get_Error_StoreCertCertificateNotFound();
    internal static string get_FileCertItemPasswordAndClearTextPasswordAtSameTime();
    internal static string get_FileCertItemPasswordCannotBeDecrypted();
    internal static string get_FileCertItemPathFileNotExist();
    internal static string get_FileCertItemPathFileNotSet();
    internal static string get_FileDoesNotExist();
    internal static string get_InvalidNullSettingsOperation();
    internal static string get_ItemDoesNotExist();
    internal static string get_MissingRequiredAttribute();
    internal static string get_MustContainAbsolutePath();
    internal static string get_NoAttributesAllowed();
    internal static string get_NoWritteableConfig();
    internal static string get_OwnersItemMustHaveAtLeastOneOwner();
    internal static string get_OwnersMustOnlyHaveContent();
    internal static string get_PropertyCannotBeNullOrEmpty();
    internal static string get_RepositoryMustHaveOneOwners();
    internal static string get_SectionDoesNotExist();
    internal static string get_Settings_FileName_Cannot_Be_A_Path();
    internal static string get_ShowError_CannotHaveChildren();
    internal static string get_ShowError_ConfigDuplicateDisabledSources();
    internal static string get_ShowError_ConfigHasInvalidPackageSource();
    internal static string get_ShowError_ConfigInvalidOperation();
    internal static string get_ShowError_ConfigInvalidXml();
    internal static string get_ShowError_ConfigRootInvalid();
    internal static string get_ShowError_ConfigUnauthorizedAccess();
    internal static string get_TextShouldNotBeEmpty();
    internal static string get_TrustedSignerMustHaveCertificates();
    internal static string get_Unknown_Config_Exception();
    internal static string get_UnknownHashAlgorithmNotSupported();
    internal static string get_UnsupportedDecryptPassword();
    internal static string get_UnsupportedEncryptPassword();
    internal static string get_UnsupportedHashAlgorithm();
    internal static string get_UserSettings_UnableToParseConfigFile();
}
internal class NuGet.Configuration.SearchNode : object {
    [NuGet.Configuration.NullableAttribute("1")]
public Dictionary`2<char, SearchNode> Children;
    [CompilerGeneratedAttribute]
private bool <IsGlobbing>k__BackingField;
    [NuGet.Configuration.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public List`1<string> PackageSources;
    public bool IsGlobbing { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IsGlobbing();
    [CompilerGeneratedAttribute]
public void set_IsGlobbing(bool value);
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal class NuGet.Configuration.SearchTree : object {
    private SearchNode _root;
    internal SearchTree(PackageSourceMapping configuration);
    private void Add(string packageSourceKey, string packagePattern);
    public string SearchForPattern(string term);
    public IReadOnlyList`1<string> GetConfiguredPackageSources(string term);
    private SearchNode SearchNodeByTerm(string term);
    private string SearchPatternByTerm(string term);
}
public abstract class NuGet.Configuration.SettingBase : object {
    [CompilerGeneratedAttribute]
private XNode <Node>k__BackingField;
    [CompilerGeneratedAttribute]
private ISettingsGroup <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private SettingsFile <Origin>k__BackingField;
    internal XNode Node { get; private set; }
    internal ISettingsGroup Parent { get; internal set; }
    internal SettingsFile Origin { get; private set; }
    internal SettingBase(XNode node, SettingsFile origin);
    [CompilerGeneratedAttribute]
internal XNode get_Node();
    [CompilerGeneratedAttribute]
private void set_Node(XNode value);
    [CompilerGeneratedAttribute]
internal ISettingsGroup get_Parent();
    [CompilerGeneratedAttribute]
internal void set_Parent(ISettingsGroup value);
    [CompilerGeneratedAttribute]
internal SettingsFile get_Origin();
    [CompilerGeneratedAttribute]
private void set_Origin(SettingsFile value);
    internal bool IsAbstract();
    internal bool IsCopy();
    public abstract virtual bool IsEmpty();
    internal virtual XNode AsXNode();
    public abstract virtual SettingBase Clone();
    internal void SetNode(XNode node);
    internal virtual void SetOrigin(SettingsFile origin);
    internal virtual void RemoveFromSettings();
}
public abstract class NuGet.Configuration.SettingElement : SettingBase {
    [CompilerGeneratedAttribute]
private string <ElementName>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <AllowedAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <RequiredAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> <AllowedValues>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> <DisallowedValues>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <MutableAttributes>k__BackingField;
    public string ElementName { get; protected set; }
    protected IReadOnlyCollection`1<string> AllowedAttributes { get; }
    protected IReadOnlyCollection`1<string> RequiredAttributes { get; }
    protected IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> AllowedValues { get; }
    protected IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> DisallowedValues { get; }
    protected Dictionary`2<string, string> MutableAttributes { get; }
    internal IReadOnlyDictionary`2<string, string> Attributes { get; }
    protected SettingElement(IReadOnlyDictionary`2<string, string> attributes);
    internal SettingElement(XElement element, SettingsFile origin);
    [CompilerGeneratedAttribute]
public virtual string get_ElementName();
    [CompilerGeneratedAttribute]
protected virtual void set_ElementName(string value);
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyCollection`1<string> get_AllowedAttributes();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyCollection`1<string> get_RequiredAttributes();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> get_AllowedValues();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> get_DisallowedValues();
    [CompilerGeneratedAttribute]
protected Dictionary`2<string, string> get_MutableAttributes();
    internal IReadOnlyDictionary`2<string, string> get_Attributes();
    public virtual bool IsEmpty();
    internal virtual XNode AsXNode();
    protected void AddOrUpdateAttribute(string attributeName, string value);
    internal bool UpdateAttribute(string attributeName, string newValue);
    protected void AddAttribute(string attributeName, string value);
    private bool IsAttributeValid(string attributeName, string value);
    private void ValidateAttributes(XElement element, SettingsFile origin);
}
public enum NuGet.Configuration.SettingElementType : Enum {
    public int value__;
    public static SettingElementType Unknown;
    public static SettingElementType Configuration;
    public static SettingElementType ActivePackageSource;
    public static SettingElementType BindingRedirects;
    public static SettingElementType Config;
    public static SettingElementType PackageManagement;
    public static SettingElementType PackageRestore;
    public static SettingElementType PackageSourceCredentials;
    public static SettingElementType PackageSources;
    public static SettingElementType Add;
    public static SettingElementType Author;
    public static SettingElementType Certificate;
    public static SettingElementType Clear;
    public static SettingElementType Owners;
    public static SettingElementType Repository;
    public static SettingElementType FileCert;
    public static SettingElementType StoreCert;
    public static SettingElementType PackageSourceMapping;
    public static SettingElementType PackageSource;
    public static SettingElementType Package;
}
internal static class NuGet.Configuration.SettingFactory : object {
    internal static SettingBase Parse(XNode node, SettingsFile origin);
    internal static IEnumerable`1<T> ParseChildren(XElement xElement, SettingsFile origin, bool canBeCleared);
}
public abstract class NuGet.Configuration.SettingItem : SettingElement {
    [CompilerGeneratedAttribute]
private SettingItem <MergedWith>k__BackingField;
    protected bool CanHaveChildren { get; }
    internal SettingItem MergedWith { get; internal set; }
    protected SettingItem(IReadOnlyDictionary`2<string, string> attributes);
    internal SettingItem(XElement element, SettingsFile origin);
    protected virtual bool get_CanHaveChildren();
    [CompilerGeneratedAttribute]
internal SettingItem get_MergedWith();
    [CompilerGeneratedAttribute]
internal void set_MergedWith(SettingItem value);
    internal virtual void Update(SettingItem setting);
}
public class NuGet.Configuration.Settings : object {
    public static string DefaultSettingsFileName;
    public static String[] OrderedSettingsFileNames;
    public static String[] SupportedMachineWideConfigExtension;
    private Dictionary`2<string, VirtualSettingSection> _computedSections;
    [CompilerGeneratedAttribute]
private EventHandler SettingsChanged;
    [CompilerGeneratedAttribute]
private IList`1<SettingsFile> <SettingsFiles>k__BackingField;
    private IList`1<SettingsFile> SettingsFiles { get; }
    internal IEnumerable`1<SettingsFile> Priority { get; }
    public Settings(string root);
    public Settings(string root, string fileName);
    public Settings(string root, string fileName, bool isMachineWide);
    internal Settings(IList`1<SettingsFile> settingsFiles);
    private static Settings();
    public sealed virtual SettingSection GetSection(string sectionName);
    public sealed virtual void AddOrUpdate(string sectionName, SettingItem item);
    internal void AddOrUpdate(SettingsFile settingsFile, string sectionName, SettingItem item);
    public sealed virtual void Remove(string sectionName, SettingItem item);
    [CompilerGeneratedAttribute]
public sealed virtual void add_SettingsChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_SettingsChanged(EventHandler value);
    [CompilerGeneratedAttribute]
private IList`1<SettingsFile> get_SettingsFiles();
    private SettingsFile GetOutputSettingFileForSection(string sectionName);
    internal IEnumerable`1<SettingsFile> get_Priority();
    public sealed virtual void SaveToDisk();
    public static ISettings LoadDefaultSettings(string root);
    public static ISettings LoadDefaultSettings(string root, string configFileName, IMachineWideSettings machineWideSettings);
    public static ISettings LoadDefaultSettings(string root, string configFileName, IMachineWideSettings machineWideSettings, SettingsLoadingContext settingsLoadingContext);
    public static ISettings LoadSpecificSettings(string root, string configFileName);
    public static ISettings LoadImmutableSettingsGivenConfigPaths(IList`1<string> configFilePaths, SettingsLoadingContext settingsLoadingContext);
    public static ISettings LoadSettingsGivenConfigPaths(IList`1<string> configFilePaths);
    private static ISettings LoadSettingsGivenSettingsFiles(List`1<SettingsFile> settings);
    internal static ISettings LoadSettings(string root, string configFileName, IMachineWideSettings machineWideSettings, bool loadUserWideSettings, bool useTestingGlobalPath, SettingsLoadingContext settingsLoadingContext);
    internal static ISettings LoadSettings(DirectoryInfo root, IMachineWideSettings machineWideSettings, bool loadUserWideSettings, bool useTestingGlobalPath, SettingsLoadingContext settingsLoadingContext);
    private static ISettings LoadSettingsForSpecificConfigs(string root, string configFileName, List`1<SettingsFile> validSettingFiles, IMachineWideSettings machineWideSettings, bool loadUserWideSettings, bool useTestingGlobalPath, SettingsLoadingContext settingsLoadingContext);
    [IteratorStateMachineAttribute("NuGet.Configuration.Settings/<LoadUserSpecificSettings>d__32")]
internal static IEnumerable`1<SettingsFile> LoadUserSpecificSettings(string root, string configFileName, bool useTestingGlobalPath, SettingsLoadingContext settingsLoadingContext);
    private static string GetUserSettingsDirectory(string rootDirectory, bool useTestingGlobalPath);
    private static string GetAdditionalUserWideConfigurationDirectory(string userSettingsDirectory);
    public static ISettings LoadMachineWideSettings(string root, String[] paths);
    public static string ApplyEnvironmentTransform(string value);
    public static Tuple`2<string, string> GetFileNameAndItsRoot(string root, string settingsPath);
    public sealed virtual IList`1<string> GetConfigFilePaths();
    public sealed virtual IList`1<string> GetConfigRoots();
    internal static string ResolvePathFromOrigin(string originDirectoryPath, string originFilePath, string path);
    private static string ResolveRelativePath(string originDirectoryPath, string originFilePath, string path);
    private static string ResolvePath(string configDirectory, string value);
    private static SettingsFile ReadSettings(string settingsRoot, string settingsPath, bool isMachineWideSettings, bool isAdditionalUserWideConfig, SettingsLoadingContext settingsLoadingContext);
    [IteratorStateMachineAttribute("NuGet.Configuration.Settings/<GetSettingsFilesFullPath>d__44")]
private static IEnumerable`1<string> GetSettingsFilesFullPath(string root);
    private static string GetSettingsFileNameFromDir(string directory);
    [IteratorStateMachineAttribute("NuGet.Configuration.Settings/<GetSettingsFilePaths>d__46")]
private static IEnumerable`1<string> GetSettingsFilePaths(string root);
}
public abstract class NuGet.Configuration.SettingSection : SettingsGroup`1<SettingItem> {
    private string _elementName;
    public string ElementName { get; protected set; }
    public IReadOnlyCollection`1<SettingItem> Items { get; }
    protected SettingSection(string name, IReadOnlyDictionary`2<string, string> attributes, IEnumerable`1<SettingItem> children);
    internal SettingSection(XElement element, SettingsFile origin);
    public virtual string get_ElementName();
    protected virtual void set_ElementName(string value);
    public IReadOnlyCollection`1<SettingItem> get_Items();
    public T GetFirstItemWithAttribute(string attributeName, string expectedAttributeValue);
    internal bool Update(SettingItem item);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
internal class NuGet.Configuration.SettingsFile : object {
    [CompilerGeneratedAttribute]
private string <ConfigFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DirectoryPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDirty>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMachineWide>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    private XDocument _xDocument;
    private NuGetConfiguration _rootElement;
    internal string ConfigFilePath { get; }
    internal string DirectoryPath { get; }
    internal string FileName { get; }
    internal bool IsDirty { get; internal set; }
    internal bool IsMachineWide { get; }
    internal bool IsReadOnly { get; }
    public SettingsFile(string directoryPath);
    public SettingsFile(string directoryPath, string fileName);
    public SettingsFile(string directoryPath, string fileName, bool isMachineWide, bool isReadOnly);
    [CompilerGeneratedAttribute]
internal string get_ConfigFilePath();
    [CompilerGeneratedAttribute]
internal string get_DirectoryPath();
    [CompilerGeneratedAttribute]
internal string get_FileName();
    [CompilerGeneratedAttribute]
internal bool get_IsDirty();
    [CompilerGeneratedAttribute]
internal void set_IsDirty(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsMachineWide();
    [CompilerGeneratedAttribute]
internal bool get_IsReadOnly();
    public SettingSection GetSection(string sectionName);
    internal void AddOrUpdate(string sectionName, SettingItem item);
    internal void Remove(string sectionName, SettingItem item);
    internal void SaveToDisk();
    internal bool IsEmpty();
    internal bool TryGetSection(string sectionName, SettingSection& section);
    internal void MergeSectionsInto(Dictionary`2<string, VirtualSettingSection> sectionsContainer);
    private XDocument CreateDefaultConfig();
    private void ExecuteSynchronized(Action ioOperation);
    [CompilerGeneratedAttribute]
private void <SaveToDisk>b__27_0();
}
public abstract class NuGet.Configuration.SettingsGroup`1 : SettingElement {
    [CompilerGeneratedAttribute]
private IList`1<T> <Children>k__BackingField;
    protected IList`1<T> Children { get; private set; }
    protected bool CanBeCleared { get; }
    protected SettingsGroup`1(IReadOnlyDictionary`2<string, string> attributes, IEnumerable`1<T> children);
    internal SettingsGroup`1(XElement element, SettingsFile origin);
    [CompilerGeneratedAttribute]
protected IList`1<T> get_Children();
    [CompilerGeneratedAttribute]
private void set_Children(IList`1<T> value);
    protected virtual bool get_CanBeCleared();
    public virtual bool IsEmpty();
    internal virtual XNode AsXNode();
    internal virtual void SetOrigin(SettingsFile origin);
    internal virtual void RemoveFromSettings();
    internal virtual bool Add(T setting);
    internal virtual void Remove(T setting);
    protected bool TryGetChild(T expectedChild, T& currentChild);
    private sealed virtual override void NuGet.Configuration.ISettingsGroup.Remove(SettingElement setting);
}
public class NuGet.Configuration.SettingsLoadingContext : object {
    private ConcurrentDictionary`2<string, Lazy`1<SettingsFile>> _cache;
    private bool _isDisposed;
    [CompilerGeneratedAttribute]
private EventHandler`1<string> FileRead;
    [CompilerGeneratedAttribute]
internal void add_FileRead(EventHandler`1<string> value);
    [CompilerGeneratedAttribute]
internal void remove_FileRead(EventHandler`1<string> value);
    public sealed virtual void Dispose();
    internal SettingsFile GetOrCreateSettingsFile(string filePath, bool isMachineWide, bool isReadOnly);
}
public static class NuGet.Configuration.SettingsUtility : object {
    private static string GlobalPackagesFolderEnvironmentKey;
    private static string FallbackPackagesFolderEnvironmentKey;
    private static string HttpCacheEnvironmentKey;
    private static string PluginsCacheEnvironmentKey;
    public static string DefaultGlobalPackagesFolderPath;
    private static string RevocationModeEnvironmentKey;
    private static SettingsUtility();
    public static string GetValueForAddItem(ISettings settings, string section, string key, bool isPath);
    public static bool DeleteValue(ISettings settings, string section, string attributeKey, string attributeValue);
    public static string GetRepositoryPath(ISettings settings);
    public static int GetMaxHttpRequest(ISettings settings);
    public static SignatureValidationMode GetSignatureValidationMode(ISettings settings);
    public static bool GetUpdatePackageLastAccessTimeEnabledStatus(ISettings settings);
    public static string GetDecryptedValueForAddItem(ISettings settings, string section, string key, bool isPath);
    public static void SetEncryptedValueForAddItem(ISettings settings, string section, string key, string value);
    public static string GetConfigValue(ISettings settings, string key, bool decrypt, bool isPath);
    public static void SetConfigValue(ISettings settings, string key, string value, bool encrypt);
    public static bool DeleteConfigValue(ISettings settings, string key);
    public static string GetGlobalPackagesFolder(ISettings settings);
    public static IReadOnlyList`1<string> GetFallbackPackageFolders(ISettings settings);
    private static IReadOnlyList`1<string> GetFallbackPackageFoldersFromConfig(ISettings settings);
    public static string GetHttpCacheFolder();
    public static string GetPluginsCacheFolder();
    public static IEnumerable`1<PackageSource> GetEnabledSources(ISettings settings);
    public static string GetDefaultPushSource(ISettings settings);
    public static RevocationMode GetRevocationMode(IEnvironmentVariableReader environmentVariableReader);
    private static void VerifyPathIsRooted(string key, string path);
}
public class NuGet.Configuration.SettingText : SettingBase {
    private string _value;
    public string Value { get; public set; }
    public SettingText(string value);
    internal SettingText(XText text, SettingsFile origin);
    public string get_Value();
    public void set_Value(string value);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual bool IsEmpty();
    public virtual SettingBase Clone();
    internal virtual XNode AsXNode();
}
public class NuGet.Configuration.SourceItem : AddItem {
    public string ProtocolVersion { get; public set; }
    public string AllowInsecureConnections { get; public set; }
    public SourceItem(string key, string value);
    public SourceItem(string key, string value, string protocolVersion);
    public SourceItem(string key, string value, string protocolVersion, string allowInsecureConnections);
    internal SourceItem(XElement element, SettingsFile origin);
    public string get_ProtocolVersion();
    public void set_ProtocolVersion(string value);
    public string get_AllowInsecureConnections();
    public void set_AllowInsecureConnections(string value);
    public virtual SettingBase Clone();
}
public class NuGet.Configuration.StoreClientCertItem : ClientCertItem {
    private static X509FindType DefaultFindBy;
    private static StoreLocation DefaultStoreLocation;
    private static StoreName DefaultStoreName;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <AllowedAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> <AllowedValues>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <RequiredAttributes>k__BackingField;
    public string ElementName { get; }
    public X509FindType FindType { get; }
    public string FindValue { get; }
    public StoreLocation StoreLocation { get; }
    public StoreName StoreName { get; }
    protected IReadOnlyCollection`1<string> AllowedAttributes { get; }
    protected IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> AllowedValues { get; }
    protected IReadOnlyCollection`1<string> RequiredAttributes { get; }
    public StoreClientCertItem(string packageSource, string findValue, Nullable`1<StoreLocation> storeLocation, Nullable`1<StoreName> storeName, Nullable`1<X509FindType> findBy);
    internal StoreClientCertItem(XElement element, SettingsFile origin);
    public static string GetString(X509FindType type);
    public static string GetString(StoreName storeName);
    public static string GetString(StoreLocation storeLocation);
    public virtual string get_ElementName();
    public X509FindType get_FindType();
    public string get_FindValue();
    public StoreLocation get_StoreLocation();
    public StoreName get_StoreName();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyCollection`1<string> get_AllowedAttributes();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> get_AllowedValues();
    [CompilerGeneratedAttribute]
protected virtual IReadOnlyCollection`1<string> get_RequiredAttributes();
    internal virtual XNode AsXNode();
    public virtual SettingBase Clone();
    public virtual IEnumerable`1<X509Certificate> Search();
    public void Update(string findValue, Nullable`1<StoreLocation> storeLocation, Nullable`1<StoreName> storeName, Nullable`1<X509FindType> findBy);
}
public abstract class NuGet.Configuration.TrustedSignerItem : SettingItem {
    [CompilerGeneratedAttribute]
private IList`1<CertificateItem> <Certificates>k__BackingField;
    internal IEnumerable`1<SettingBase> _parsedDescendants;
    protected bool CanHaveChildren { get; }
    public IList`1<CertificateItem> Certificates { get; }
    public string Name { get; }
    protected TrustedSignerItem(string name, IEnumerable`1<CertificateItem> certificates);
    internal TrustedSignerItem(XElement element, SettingsFile origin);
    protected virtual bool get_CanHaveChildren();
    [CompilerGeneratedAttribute]
public IList`1<CertificateItem> get_Certificates();
    public virtual string get_Name();
    protected void SetName(string value);
    internal virtual void SetOrigin(SettingsFile origin);
    internal virtual void RemoveFromSettings();
    internal virtual void Update(SettingItem other);
}
public class NuGet.Configuration.UnknownItem : SettingItem {
    [CompilerGeneratedAttribute]
private string <ElementName>k__BackingField;
    private Dictionary`2<SettingBase, SettingBase> _mutableChildren;
    public string ElementName { get; protected set; }
    public IReadOnlyList`1<SettingBase> Children { get; }
    public IReadOnlyDictionary`2<string, string> Attributes { get; }
    protected bool CanHaveChildren { get; }
    internal UnknownItem(XElement element, SettingsFile origin);
    public UnknownItem(string name, IReadOnlyDictionary`2<string, string> attributes, IEnumerable`1<SettingBase> children);
    [CompilerGeneratedAttribute]
public virtual string get_ElementName();
    [CompilerGeneratedAttribute]
protected virtual void set_ElementName(string value);
    public IReadOnlyList`1<SettingBase> get_Children();
    public IReadOnlyDictionary`2<string, string> get_Attributes();
    public virtual bool IsEmpty();
    protected virtual bool get_CanHaveChildren();
    public virtual SettingBase Clone();
    internal bool Add(SettingBase setting);
    private sealed virtual override void NuGet.Configuration.ISettingsGroup.Remove(SettingElement setting);
    internal void Remove(SettingBase setting);
    internal virtual XNode AsXNode();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    internal virtual void Update(SettingItem setting);
    internal void Merge(UnknownItem item);
    internal virtual void SetOrigin(SettingsFile origin);
    internal virtual void RemoveFromSettings();
}
public class NuGet.Configuration.VirtualSettingSection : SettingSection {
    internal VirtualSettingSection(SettingSection section);
    internal VirtualSettingSection(string name, SettingItem[] children);
    internal VirtualSettingSection(string name, IReadOnlyDictionary`2<string, string> attributes, IEnumerable`1<SettingItem> children);
    internal VirtualSettingSection Merge(SettingSection other);
    internal virtual bool Add(SettingItem setting);
    internal virtual void Remove(SettingItem setting);
    private bool TryRemoveAllMergedWith(SettingItem currentSetting, SettingItem& undeletedItem);
    public virtual SettingBase Clone();
}
public class NuGet.Configuration.WebProxy : object {
    private IReadOnlyList`1<string> _bypassList;
    private Regex[] _regExBypassList;
    [CompilerGeneratedAttribute]
private Uri <ProxyAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private ICredentials <Credentials>k__BackingField;
    public Uri ProxyAddress { get; private set; }
    public ICredentials Credentials { get; public set; }
    public IReadOnlyList`1<string> BypassList { get; public set; }
    public WebProxy(string proxyAddress);
    public WebProxy(Uri proxyAddress);
    [CompilerGeneratedAttribute]
public Uri get_ProxyAddress();
    [CompilerGeneratedAttribute]
private void set_ProxyAddress(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual ICredentials get_Credentials();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Credentials(ICredentials value);
    public IReadOnlyList`1<string> get_BypassList();
    public void set_BypassList(IReadOnlyList`1<string> value);
    public sealed virtual Uri GetProxy(Uri destination);
    public sealed virtual bool IsBypassed(Uri uri);
    private void UpdateRegExList();
    private static string WildcardToRegex(string pattern);
    private static Uri CreateProxyUri(string address);
}
internal static class NuGet.Configuration.XElementUtility : object {
    internal static string GetOptionalAttributeValue(XElement element, string localName);
    internal static string GetOptionalAttributeValue(XElement element, string localName, string namespaceName);
    internal static void AddIndented(XContainer container, XNode content);
    internal static void RemoveIndented(XNode element);
    private static string ComputeOneLevelOfIndentation(XNode node);
    private static bool IsWhiteSpace(XText textNode);
    private static void IndentChildrenElements(XContainer container, string containerIndent, string oneIndentLevel);
    private static void AddLeadingIndentation(XContainer container, string containerIndent, string oneIndentLevel);
    private static void AddTrailingIndentation(XContainer container, string containerIndent);
}
public class NuGet.Configuration.XPlatMachineWideSetting : object {
    private Lazy`1<ISettings> _settings;
    public ISettings Settings { get; }
    public sealed virtual ISettings get_Settings();
}
public class NuGet.ContentModel.Asset : object {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Link>k__BackingField;
    public string Path { get; public set; }
    public string Link { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public string get_Link();
    [CompilerGeneratedAttribute]
public void set_Link(string value);
    public virtual string ToString();
}
public class NuGet.ContentModel.ContentItem : object {
    private Dictionary`2<string, object> _properties;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public string Path { get; public set; }
    public Dictionary`2<string, object> Properties { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    public Dictionary`2<string, object> get_Properties();
    internal void set_Properties(Dictionary`2<string, object> value);
    public virtual string ToString();
    private Dictionary`2<string, object> CreateDictionary();
}
public class NuGet.ContentModel.ContentItemCollection : object {
    private List`1<Asset> _assets;
    private ConcurrentDictionary`2<string, string> _assemblyRelatedExtensions;
    [CompilerGeneratedAttribute]
private bool <HasContract>k__BackingField;
    public bool HasContract { get; private set; }
    [CompilerGeneratedAttribute]
public bool get_HasContract();
    [CompilerGeneratedAttribute]
private void set_HasContract(bool value);
    public void Load(IEnumerable`1<string> paths);
    public IEnumerable`1<ContentItem> FindItems(PatternSet definition);
    [IteratorStateMachineAttribute("NuGet.ContentModel.ContentItemCollection/<FindItemGroups>d__8")]
[ObsoleteAttribute("This method causes excessive memory allocation with yield return. Use ContentItemCollection.PopulateItemGroups instead.")]
public IEnumerable`1<ContentItemGroup> FindItemGroups(PatternSet definition);
    public void PopulateItemGroups(PatternSet definition, IList`1<ContentItemGroup> contentItemGroupList);
    public bool HasItemGroup(SelectionCriteria criteria, PatternSet[] definitions);
    public ContentItemGroup FindBestItemGroup(SelectionCriteria criteria, PatternSet[] definitions);
    private List`1<ContentItem> FindItemsImplementation(PatternSet definition, IEnumerable`1<Asset> assets);
    internal string GetRelatedFileExtensionProperty(string assemblyPath, IEnumerable`1<Asset> assets);
    private static bool IsValidAsset(string path);
}
[DebuggerDisplayAttribute("Items: {Items.Count}, Properties: {Properties.Count}")]
public class NuGet.ContentModel.ContentItemGroup : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ContentItem> <Items>k__BackingField;
    public IDictionary`2<string, object> Properties { get; }
    public IList`1<ContentItem> Items { get; }
    internal ContentItemGroup(IDictionary`2<string, object> properties, IList`1<ContentItem> items);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_Properties();
    [CompilerGeneratedAttribute]
public IList`1<ContentItem> get_Items();
}
public class NuGet.ContentModel.ContentPropertyDefinition : object {
    private static Func`3<object, object, bool> EqualsTest;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <FileExtensions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FileExtensionAllowSubFolders>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<string, PatternTable, object> <Parser>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<object, object, bool> <CompatibilityTest>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`4<object, object, object, int> <CompareTest>k__BackingField;
    public string Name { get; }
    public List`1<string> FileExtensions { get; }
    public bool FileExtensionAllowSubFolders { get; }
    public Func`3<string, PatternTable, object> Parser { get; }
    public Func`3<object, object, bool> CompatibilityTest { get; }
    public Func`4<object, object, object, int> CompareTest { get; }
    public ContentPropertyDefinition(string name);
    public ContentPropertyDefinition(string name, Func`3<string, PatternTable, object> parser);
    public ContentPropertyDefinition(string name, Func`3<object, object, bool> compatibilityTest);
    public ContentPropertyDefinition(string name, Func`3<string, PatternTable, object> parser, Func`3<object, object, bool> compatibilityTest);
    public ContentPropertyDefinition(string name, Func`3<string, PatternTable, object> parser, Func`3<object, object, bool> compatibilityTest, Func`4<object, object, object, int> compareTest);
    public ContentPropertyDefinition(string name, IEnumerable`1<string> fileExtensions);
    public ContentPropertyDefinition(string name, Func`3<string, PatternTable, object> parser, IEnumerable`1<string> fileExtensions);
    public ContentPropertyDefinition(string name, IEnumerable`1<string> fileExtensions, bool allowSubfolders);
    public ContentPropertyDefinition(string name, Func`3<string, PatternTable, object> parser, IEnumerable`1<string> fileExtensions, bool allowSubfolders);
    public ContentPropertyDefinition(string name, Func`3<string, PatternTable, object> parser, Func`3<object, object, bool> compatibilityTest, Func`4<object, object, object, int> compareTest, IEnumerable`1<string> fileExtensions, bool allowSubfolders);
    private static ContentPropertyDefinition();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public List`1<string> get_FileExtensions();
    [CompilerGeneratedAttribute]
public bool get_FileExtensionAllowSubFolders();
    [CompilerGeneratedAttribute]
public Func`3<string, PatternTable, object> get_Parser();
    public virtual bool TryLookup(string name, PatternTable table, Object& value);
    private static bool ContainsSlash(string name);
    [CompilerGeneratedAttribute]
public Func`3<object, object, bool> get_CompatibilityTest();
    [CompilerGeneratedAttribute]
public Func`4<object, object, object, int> get_CompareTest();
    public virtual bool IsCriteriaSatisfied(object critieriaValue, object candidateValue);
    public virtual int Compare(object criteriaValue, object candidateValue1, object candidateValue2);
}
public class NuGet.ContentModel.Infrastructure.PatternExpression : object {
    private List`1<Segment> _segments;
    private Dictionary`2<string, object> _defaults;
    private PatternTable _table;
    public PatternExpression(PatternDefinition pattern);
    private void Initialize(string pattern);
    internal ContentItem Match(string path, IReadOnlyDictionary`2<string, ContentPropertyDefinition> propertyDefinitions);
}
public class NuGet.ContentModel.PatternDefinition : object {
    [CompilerGeneratedAttribute]
private string <Pattern>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, object> <Defaults>k__BackingField;
    [CompilerGeneratedAttribute]
private PatternTable <Table>k__BackingField;
    public string Pattern { get; }
    public IReadOnlyDictionary`2<string, object> Defaults { get; }
    public PatternTable Table { get; }
    public PatternDefinition(string pattern);
    public PatternDefinition(string pattern, PatternTable table);
    public PatternDefinition(string pattern, PatternTable table, IEnumerable`1<KeyValuePair`2<string, object>> defaults);
    [CompilerGeneratedAttribute]
public string get_Pattern();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, object> get_Defaults();
    [CompilerGeneratedAttribute]
public PatternTable get_Table();
    public static PatternDefinition op_Implicit(string pattern);
}
public class NuGet.ContentModel.PatternSet : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<PatternDefinition> <GroupPatterns>k__BackingField;
    [CompilerGeneratedAttribute]
private PatternExpression[] <GroupExpressions>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<PatternDefinition> <PathPatterns>k__BackingField;
    [CompilerGeneratedAttribute]
private PatternExpression[] <PathExpressions>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, ContentPropertyDefinition> <PropertyDefinitions>k__BackingField;
    public IEnumerable`1<PatternDefinition> GroupPatterns { get; }
    internal PatternExpression[] GroupExpressions { get; }
    public IEnumerable`1<PatternDefinition> PathPatterns { get; }
    internal PatternExpression[] PathExpressions { get; }
    public IReadOnlyDictionary`2<string, ContentPropertyDefinition> PropertyDefinitions { get; public set; }
    public PatternSet(IReadOnlyDictionary`2<string, ContentPropertyDefinition> properties, IEnumerable`1<PatternDefinition> groupPatterns, IEnumerable`1<PatternDefinition> pathPatterns);
    [CompilerGeneratedAttribute]
public IEnumerable`1<PatternDefinition> get_GroupPatterns();
    [CompilerGeneratedAttribute]
internal PatternExpression[] get_GroupExpressions();
    [CompilerGeneratedAttribute]
public IEnumerable`1<PatternDefinition> get_PathPatterns();
    [CompilerGeneratedAttribute]
internal PatternExpression[] get_PathExpressions();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, ContentPropertyDefinition> get_PropertyDefinitions();
    [CompilerGeneratedAttribute]
public void set_PropertyDefinitions(IReadOnlyDictionary`2<string, ContentPropertyDefinition> value);
}
public class NuGet.ContentModel.PatternTable : object {
    private Dictionary`2<string, Dictionary`2<string, object>> _table;
    public PatternTable(IEnumerable`1<PatternTableEntry> entries);
    public bool TryLookup(string propertyName, string name, Object& value);
}
public class NuGet.ContentModel.PatternTableEntry : object {
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public string PropertyName { get; }
    public string Name { get; }
    public object Value { get; }
    public PatternTableEntry(string propertyName, string name, object value);
    [CompilerGeneratedAttribute]
public string get_PropertyName();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public object get_Value();
}
public class NuGet.ContentModel.SelectionCriteria : object {
    [CompilerGeneratedAttribute]
private IList`1<SelectionCriteriaEntry> <Entries>k__BackingField;
    public IList`1<SelectionCriteriaEntry> Entries { get; public set; }
    [CompilerGeneratedAttribute]
public IList`1<SelectionCriteriaEntry> get_Entries();
    [CompilerGeneratedAttribute]
public void set_Entries(IList`1<SelectionCriteriaEntry> value);
}
public class NuGet.ContentModel.SelectionCriteriaBuilder : object {
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, ContentPropertyDefinition> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private SelectionCriteria <Criteria>k__BackingField;
    public IReadOnlyDictionary`2<string, ContentPropertyDefinition> Properties { get; }
    public SelectionCriteria Criteria { get; }
    public SelectionCriteriaEntryBuilder Add { get; }
    public SelectionCriteriaBuilder(IReadOnlyDictionary`2<string, ContentPropertyDefinition> properties);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, ContentPropertyDefinition> get_Properties();
    [CompilerGeneratedAttribute]
public virtual SelectionCriteria get_Criteria();
    public virtual SelectionCriteriaEntryBuilder get_Add();
}
public class NuGet.ContentModel.SelectionCriteriaEntry : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Properties>k__BackingField;
    public IDictionary`2<string, object> Properties { get; public set; }
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(IDictionary`2<string, object> value);
}
[DefaultMemberAttribute("Item")]
public class NuGet.ContentModel.SelectionCriteriaEntryBuilder : SelectionCriteriaBuilder {
    [CompilerGeneratedAttribute]
private SelectionCriteriaEntry <Entry>k__BackingField;
    [CompilerGeneratedAttribute]
private SelectionCriteriaBuilder <Builder>k__BackingField;
    public SelectionCriteriaEntry Entry { get; }
    public SelectionCriteriaBuilder Builder { get; }
    public SelectionCriteriaEntryBuilder Item { get; }
    public SelectionCriteriaEntryBuilder Item { get; }
    public SelectionCriteriaEntryBuilder Add { get; }
    public SelectionCriteria Criteria { get; }
    internal SelectionCriteriaEntryBuilder(SelectionCriteriaBuilder builder, SelectionCriteriaEntry entry);
    [CompilerGeneratedAttribute]
public SelectionCriteriaEntry get_Entry();
    [CompilerGeneratedAttribute]
public SelectionCriteriaBuilder get_Builder();
    public SelectionCriteriaEntryBuilder get_Item(string key, string value);
    public SelectionCriteriaEntryBuilder get_Item(string key, object value);
    public virtual SelectionCriteriaEntryBuilder get_Add();
    public virtual SelectionCriteria get_Criteria();
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
public class NuGet.Frameworks.AssetTargetFallbackFramework : NuGetFramework {
    private Nullable`1<int> _hashCode;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<NuGetFramework> <Fallback>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetFramework <RootFramework>k__BackingField;
    public IReadOnlyList`1<NuGetFramework> Fallback { get; }
    public NuGetFramework RootFramework { get; }
    public AssetTargetFallbackFramework(NuGetFramework framework, IReadOnlyList`1<NuGetFramework> fallbackFrameworks);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<NuGetFramework> get_Fallback();
    [CompilerGeneratedAttribute]
public NuGetFramework get_RootFramework();
    private static NuGetFramework ValidateFrameworkArgument(NuGetFramework framework);
    public FallbackFramework AsFallbackFramework();
    [NuGet.Frameworks.NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NuGet.Frameworks.NullableContextAttribute("2")]
public sealed virtual bool Equals(AssetTargetFallbackFramework other);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class NuGet.Frameworks.CompatibilityCacheKey : ValueType {
    [CompilerGeneratedAttribute]
private NuGetFramework <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetFramework <Candidate>k__BackingField;
    private int _hashCode;
    public NuGetFramework Target { get; }
    public NuGetFramework Candidate { get; }
    public CompatibilityCacheKey(NuGetFramework target, NuGetFramework candidate);
    [CompilerGeneratedAttribute]
public NuGetFramework get_Target();
    [CompilerGeneratedAttribute]
public NuGetFramework get_Candidate();
    public virtual int GetHashCode();
    public sealed virtual bool Equals(CompatibilityCacheKey other);
    [NuGet.Frameworks.NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual string ToString();
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
public class NuGet.Frameworks.CompatibilityListProvider : object {
    private IFrameworkNameProvider _nameProvider;
    private IFrameworkCompatibilityProvider _compatibilityProvider;
    private FrameworkReducer _reducer;
    [NuGet.Frameworks.NullableAttribute("2")]
private static IFrameworkCompatibilityListProvider _default;
    public static IFrameworkCompatibilityListProvider Default { get; }
    public CompatibilityListProvider(IFrameworkNameProvider nameProvider, IFrameworkCompatibilityProvider compatibilityProvider);
    public sealed virtual IEnumerable`1<NuGetFramework> GetFrameworksSupporting(NuGetFramework target);
    private IEnumerable`1<NuGetFramework> ReduceDownwards(IEnumerable`1<NuGetFramework> frameworks);
    public static IFrameworkCompatibilityListProvider get_Default();
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
public class NuGet.Frameworks.CompatibilityMappingComparer : object {
    [CompilerGeneratedAttribute]
private static CompatibilityMappingComparer <Instance>k__BackingField;
    public static CompatibilityMappingComparer Instance { get; }
    private static CompatibilityMappingComparer();
    [CompilerGeneratedAttribute]
public static CompatibilityMappingComparer get_Instance();
    [NuGet.Frameworks.NullableContextAttribute("2")]
public sealed virtual bool Equals(OneWayCompatibilityMappingEntry x, OneWayCompatibilityMappingEntry y);
    public sealed virtual int GetHashCode(OneWayCompatibilityMappingEntry obj);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
public class NuGet.Frameworks.CompatibilityProvider : object {
    private IFrameworkNameProvider _mappings;
    private FrameworkExpander _expander;
    private static NuGetFrameworkFullComparer FullComparer;
    private ConcurrentDictionary`2<CompatibilityCacheKey, bool> _cache;
    public CompatibilityProvider(IFrameworkNameProvider mappings);
    private static CompatibilityProvider();
    public sealed virtual bool IsCompatible(NuGetFramework target, NuGetFramework candidate);
    private Nullable`1<bool> IsCompatibleCore(NuGetFramework target, NuGetFramework candidate);
    private Nullable`1<bool> IsSpecialFrameworkCompatible(NuGetFramework target, NuGetFramework candidate);
    private bool IsPCLCompatible(NuGetFramework target, NuGetFramework candidate);
    private bool PCLInnerCompare(IEnumerable`1<NuGetFramework> targetFrameworks, IEnumerable`1<NuGetFramework> candidateFrameworks);
    private bool IsCompatibleWithTarget(NuGetFramework target, NuGetFramework candidate);
    private static bool IsCompatibleWithTargetCore(NuGetFramework target, NuGetFramework candidate);
    private static bool IsVersionCompatible(Version target, Version candidate);
    [IteratorStateMachineAttribute("NuGet.Frameworks.CompatibilityProvider/<GetEquivalentFrameworksClosure>d__13")]
private IEnumerable`1<NuGetFramework> GetEquivalentFrameworksClosure(NuGetFramework framework);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
public class NuGet.Frameworks.CompatibilityTable : object {
    private IFrameworkNameProvider _mappings;
    private IFrameworkCompatibilityProvider _compat;
    private Dictionary`2<NuGetFramework, HashSet`1<NuGetFramework>> _table;
    private FrameworkReducer _reducer;
    public CompatibilityTable(IEnumerable`1<NuGetFramework> frameworks);
    public CompatibilityTable(IEnumerable`1<NuGetFramework> frameworks, IFrameworkNameProvider mappings, IFrameworkCompatibilityProvider compat);
    public bool HasFramework(NuGetFramework framework);
    public IEnumerable`1<NuGetFramework> GetNearest(NuGetFramework framework);
    public bool TryGetCompatible(NuGetFramework framework, IEnumerable`1& compatible);
    private static Dictionary`2<NuGetFramework, HashSet`1<NuGetFramework>> GetTable(IEnumerable`1<NuGetFramework> frameworks, IFrameworkCompatibilityProvider compat);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
public class NuGet.Frameworks.DefaultCompatibilityProvider : CompatibilityProvider {
    [NuGet.Frameworks.NullableAttribute("2")]
private static IFrameworkCompatibilityProvider _instance;
    public static IFrameworkCompatibilityProvider Instance { get; }
    public static IFrameworkCompatibilityProvider get_Instance();
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
public class NuGet.Frameworks.DefaultFrameworkMappings : object {
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Lazy`1<KeyValuePair`2[]> IdentifierSynonymsLazy;
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Lazy`1<KeyValuePair`2[]> IdentifierShortNamesLazy;
    private static Lazy`1<FrameworkSpecificMapping[]> ProfileShortNamesLazy;
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Lazy`1<KeyValuePair`2[]> EquivalentFrameworksLazy;
    private static Lazy`1<FrameworkSpecificMapping[]> EquivalentProfilesLazy;
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Lazy`1<KeyValuePair`2[]> SubSetFrameworksLazy;
    private static Lazy`1<OneWayCompatibilityMappingEntry[]> CompatibilityMappingsLazy;
    private static Lazy`1<String[]> NonPackageBasedFrameworkPrecedenceLazy;
    private static Lazy`1<String[]> PackageBasedFrameworkPrecedenceLazy;
    private static Lazy`1<String[]> EquivalentFrameworkPrecedenceLazy;
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Lazy`1<KeyValuePair`2[]> ShortNameReplacementsLazy;
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Lazy`1<KeyValuePair`2[]> FullNameReplacementsLazy;
    private static Lazy`1<IFrameworkMappings> InstanceLazy;
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<string, string>> IdentifierSynonyms { get; }
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<string, string>> IdentifierShortNames { get; }
    public IEnumerable`1<FrameworkSpecificMapping> ProfileShortNames { get; }
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> EquivalentFrameworks { get; }
    public IEnumerable`1<FrameworkSpecificMapping> EquivalentProfiles { get; }
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<string, string>> SubSetFrameworks { get; }
    public IEnumerable`1<OneWayCompatibilityMappingEntry> CompatibilityMappings { get; }
    public IEnumerable`1<string> NonPackageBasedFrameworkPrecedence { get; }
    public IEnumerable`1<string> PackageBasedFrameworkPrecedence { get; }
    public IEnumerable`1<string> EquivalentFrameworkPrecedence { get; }
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> ShortNameReplacements { get; }
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> FullNameReplacements { get; }
    public static IFrameworkMappings Instance { get; }
    private static DefaultFrameworkMappings();
    public sealed virtual IEnumerable`1<KeyValuePair`2<string, string>> get_IdentifierSynonyms();
    public sealed virtual IEnumerable`1<KeyValuePair`2<string, string>> get_IdentifierShortNames();
    public sealed virtual IEnumerable`1<FrameworkSpecificMapping> get_ProfileShortNames();
    public sealed virtual IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> get_EquivalentFrameworks();
    public sealed virtual IEnumerable`1<FrameworkSpecificMapping> get_EquivalentProfiles();
    public sealed virtual IEnumerable`1<KeyValuePair`2<string, string>> get_SubSetFrameworks();
    public sealed virtual IEnumerable`1<OneWayCompatibilityMappingEntry> get_CompatibilityMappings();
    private static OneWayCompatibilityMappingEntry CreateGenerationMapping(NuGetFramework framework, NuGetFramework netPlatform);
    private static OneWayCompatibilityMappingEntry CreateStandardMapping(NuGetFramework framework, NuGetFramework netPlatform);
    [IteratorStateMachineAttribute("NuGet.Frameworks.DefaultFrameworkMappings/<CreateGenerationAndStandardMapping>d__23")]
private static IEnumerable`1<OneWayCompatibilityMappingEntry> CreateGenerationAndStandardMapping(NuGetFramework framework, NuGetFramework netPlatform, NuGetFramework netStandard);
    private static IEnumerable`1<OneWayCompatibilityMappingEntry> CreateGenerationAndStandardMappingForAllVersions(string framework, NuGetFramework netPlatform, NuGetFramework netStandard);
    public sealed virtual IEnumerable`1<string> get_NonPackageBasedFrameworkPrecedence();
    public sealed virtual IEnumerable`1<string> get_PackageBasedFrameworkPrecedence();
    public sealed virtual IEnumerable`1<string> get_EquivalentFrameworkPrecedence();
    public sealed virtual IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> get_ShortNameReplacements();
    public sealed virtual IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> get_FullNameReplacements();
    public static IFrameworkMappings get_Instance();
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
public class NuGet.Frameworks.DefaultFrameworkNameProvider : FrameworkNameProvider {
    private static Lazy`1<IFrameworkNameProvider> InstanceLazy;
    public static IFrameworkNameProvider Instance { get; }
    private static DefaultFrameworkNameProvider();
    public static IFrameworkNameProvider get_Instance();
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
public class NuGet.Frameworks.DefaultPortableFrameworkMappings : object {
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Lazy`1<KeyValuePair`2[]> ProfileFrameworksLazy;
    private static Int32[] ProfilesWithOptionalFrameworks;
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Lazy`1<List`1<KeyValuePair`2<int, NuGetFramework[]>>> ProfileOptionalFrameworksLazy;
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Lazy`1<KeyValuePair`2[]> CompatibilityMappingsLazy;
    private static Lazy`1<IPortableFrameworkMappings> InstanceLazy;
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<int, NuGetFramework[]>> ProfileFrameworks { get; }
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<int, NuGetFramework[]>> ProfileOptionalFrameworks { get; }
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<int, FrameworkRange>> CompatibilityMappings { get; }
    public static IPortableFrameworkMappings Instance { get; }
    private static DefaultPortableFrameworkMappings();
    public sealed virtual IEnumerable`1<KeyValuePair`2<int, NuGetFramework[]>> get_ProfileFrameworks();
    private static KeyValuePair`2<int, NuGetFramework[]> CreateProfileFrameworks(int profile, NuGetFramework[] frameworks);
    public sealed virtual IEnumerable`1<KeyValuePair`2<int, NuGetFramework[]>> get_ProfileOptionalFrameworks();
    public sealed virtual IEnumerable`1<KeyValuePair`2<int, FrameworkRange>> get_CompatibilityMappings();
    private static KeyValuePair`2<int, FrameworkRange> CreateStandardMapping(int profileNumber, NuGetFramework netStandard);
    public static IPortableFrameworkMappings get_Instance();
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
public class NuGet.Frameworks.DualCompatibilityFramework : NuGetFramework {
    [CompilerGeneratedAttribute]
private NuGetFramework <RootFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetFramework <SecondaryFramework>k__BackingField;
    private Nullable`1<int> _hashCode;
    [NuGet.Frameworks.NullableAttribute("2")]
private FallbackFramework _fallbackFramework;
    public NuGetFramework RootFramework { get; }
    public NuGetFramework SecondaryFramework { get; }
    public DualCompatibilityFramework(NuGetFramework framework, NuGetFramework secondaryFramework);
    [CompilerGeneratedAttribute]
public NuGetFramework get_RootFramework();
    [CompilerGeneratedAttribute]
public NuGetFramework get_SecondaryFramework();
    public FallbackFramework AsFallbackFramework();
    private static NuGetFramework ValidateFrameworkArgument(NuGetFramework framework);
    [NuGet.Frameworks.NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NuGet.Frameworks.NullableContextAttribute("2")]
public bool Equals(DualCompatibilityFramework other);
    public virtual int GetHashCode();
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
public class NuGet.Frameworks.FallbackFramework : NuGetFramework {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<NuGetFramework> <Fallback>k__BackingField;
    private Nullable`1<int> _hashCode;
    public IReadOnlyList`1<NuGetFramework> Fallback { get; }
    public FallbackFramework(NuGetFramework framework, IReadOnlyList`1<NuGetFramework> fallbackFrameworks);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<NuGetFramework> get_Fallback();
    [NuGet.Frameworks.NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NuGet.Frameworks.NullableContextAttribute("2")]
public sealed virtual bool Equals(FallbackFramework other);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
public static class NuGet.Frameworks.FrameworkConstants : object {
    public static Version EmptyVersion;
    public static Version MaxVersion;
    public static Version Version5;
    public static Version Version6;
    public static Version Version7;
    public static Version Version8;
    public static Version Version10;
    public static FrameworkRange DotNetAll;
    private static FrameworkConstants();
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
public class NuGet.Frameworks.FrameworkException : Exception {
    public FrameworkException(string message);
    protected FrameworkException(SerializationInfo info, StreamingContext context);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
public class NuGet.Frameworks.FrameworkExpander : object {
    private IFrameworkNameProvider _mappings;
    public FrameworkExpander(IFrameworkNameProvider mappings);
    [IteratorStateMachineAttribute("NuGet.Frameworks.FrameworkExpander/<Expand>d__3")]
public IEnumerable`1<NuGetFramework> Expand(NuGetFramework framework);
    [IteratorStateMachineAttribute("NuGet.Frameworks.FrameworkExpander/<ExpandInternal>d__4")]
private IEnumerable`1<NuGetFramework> ExpandInternal(NuGetFramework framework);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
public static class NuGet.Frameworks.FrameworkNameHelpers : object {
    public static string GetPortableProfileNumberString(int profileNumber);
    public static string GetFolderName(string identifierShortName, string versionString, string profileShortName);
    public static string GetVersionString(Version version);
    public static Version GetVersion(string versionString);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
public class NuGet.Frameworks.FrameworkNameProvider : object {
    private static HashSet`1<NuGetFramework> EmptyFrameworkSet;
    private static HashSet`1<string> SingleDigitVersionFrameworks;
    private static HashSet`1<string> DecimalPointFrameworks;
    private Dictionary`2<string, string> _identifierSynonyms;
    private Dictionary`2<string, string> _identifierToShortName;
    private Dictionary`2<string, string> _profilesToShortName;
    private Dictionary`2<string, string> _identifierShortToLong;
    private Dictionary`2<string, string> _profileShortToLong;
    private Dictionary`2<int, HashSet`1<NuGetFramework>> _portableFrameworks;
    private Dictionary`2<int, HashSet`1<NuGetFramework>> _portableOptionalFrameworks;
    private Dictionary`2<int, HashSet`1<FrameworkRange>> _portableCompatibilityMappings;
    private Dictionary`2<NuGetFramework, HashSet`1<NuGetFramework>> _equivalentFrameworks;
    private Dictionary`2<string, Dictionary`2<string, HashSet`1<string>>> _equivalentProfiles;
    private Dictionary`2<string, HashSet`1<OneWayCompatibilityMappingEntry>> _compatibilityMappings;
    private Dictionary`2<string, HashSet`1<string>> _subSetFrameworks;
    private Dictionary`2<string, int> _nonPackageBasedFrameworkPrecedence;
    private Dictionary`2<string, int> _packageBasedFrameworkPrecedence;
    private Dictionary`2<string, int> _equivalentFrameworkPrecedence;
    private Dictionary`2<NuGetFramework, NuGetFramework> _shortNameRewrites;
    private Dictionary`2<NuGetFramework, NuGetFramework> _fullNameRewrites;
    private List`1<NuGetFramework> _netStandardVersions;
    private List`1<NuGetFramework> _compatibleCandidates;
    public FrameworkNameProvider(IEnumerable`1<IFrameworkMappings> mappings, IEnumerable`1<IPortableFrameworkMappings> portableMappings);
    private static FrameworkNameProvider();
    private static bool TryConvertOrNormalize(string key, IDictionary`2<string, string> mappings, IDictionary`2<string, string> reverse, String& value);
    public sealed virtual bool TryGetIdentifier(string framework, String& identifier);
    public sealed virtual bool TryGetProfile(string frameworkIdentifier, string profileShortName, String& profile);
    public sealed virtual bool TryGetShortIdentifier(string identifier, String& identifierShortName);
    public sealed virtual bool TryGetShortProfile(string frameworkIdentifier, string profile, String& profileShortName);
    public sealed virtual bool TryGetVersion(string versionString, Version& version);
    public sealed virtual bool TryGetPlatformVersion(string versionString, Version& version);
    public sealed virtual string GetVersionString(string framework, Version version);
    public sealed virtual bool TryGetPortableProfile(IEnumerable`1<NuGetFramework> supportedFrameworks, Int32& profileNumber);
    private HashSet`1<NuGetFramework> RemoveDuplicateFramework(IEnumerable`1<NuGetFramework> supportedFrameworks);
    private HashSet`1<NuGetFramework> GetAllEquivalentFrameworks(NuGetFramework framework);
    [IteratorStateMachineAttribute("NuGet.Frameworks.FrameworkNameProvider/<GetEquivalentPermutations>d__34")]
private IEnumerable`1<HashSet`1<NuGetFramework>> GetEquivalentPermutations(HashSet`1<NuGetFramework> frameworks);
    private HashSet`1<NuGetFramework> GetOptionalFrameworks(int profile);
    public sealed virtual bool TryGetPortableFrameworks(int profile, IEnumerable`1& frameworks);
    public sealed virtual bool TryGetPortableFrameworks(int profile, bool includeOptional, IEnumerable`1& frameworks);
    public sealed virtual bool TryGetPortableFrameworks(string shortPortableProfiles, IEnumerable`1& frameworks);
    public sealed virtual bool TryGetPortableCompatibilityMappings(int profile, IEnumerable`1& supportedFrameworkRanges);
    public sealed virtual bool TryGetPortableProfileNumber(string profile, Int32& profileNumber);
    public sealed virtual bool TryGetPortableFrameworks(string profile, bool includeOptional, IEnumerable`1& frameworks);
    public sealed virtual bool TryGetEquivalentFrameworks(NuGetFramework framework, IEnumerable`1& frameworks);
    public sealed virtual bool TryGetEquivalentFrameworks(FrameworkRange range, IEnumerable`1& frameworks);
    private void InitMappings(IEnumerable`1<IFrameworkMappings> mappings);
    private void InitPortableMappings(IEnumerable`1<IPortableFrameworkMappings> portableMappings);
    private void InitNetStandard();
    private void AddShortNameRewriteMappings(IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> mappings);
    private void AddFullNameRewriteMappings(IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> mappings);
    private void AddCompatibilityMappings(IEnumerable`1<OneWayCompatibilityMappingEntry> mappings);
    private void AddSubSetFrameworks(IEnumerable`1<KeyValuePair`2<string, string>> mappings);
    private void AddEquivalentProfiles(IEnumerable`1<FrameworkSpecificMapping> mappings);
    private void AddEquivalentFrameworks(IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> mappings);
    private void AddFrameworkSynonyms(IEnumerable`1<KeyValuePair`2<string, string>> mappings);
    private void AddIdentifierShortNames(IEnumerable`1<KeyValuePair`2<string, string>> mappings);
    private void AddProfileShortNames(IEnumerable`1<FrameworkSpecificMapping> mappings);
    private void AddPortableProfileMappings(IEnumerable`1<KeyValuePair`2<int, NuGetFramework[]>> mappings);
    private void AddPortableOptionalFrameworks(IEnumerable`1<KeyValuePair`2<int, NuGetFramework[]>> mappings);
    private void AddPortableCompatibilityMappings(IEnumerable`1<KeyValuePair`2<int, FrameworkRange>> mappings);
    public void AddFrameworkPrecedenceMappings(IDictionary`2<string, int> destination, IEnumerable`1<string> mappings);
    public sealed virtual bool TryGetCompatibilityMappings(NuGetFramework framework, IEnumerable`1& supportedFrameworkRanges);
    public sealed virtual bool TryGetSubSetFrameworks(string frameworkIdentifier, IEnumerable`1& subSetFrameworks);
    [NuGet.Frameworks.NullableContextAttribute("2")]
public sealed virtual int CompareFrameworks(NuGetFramework x, NuGetFramework y);
    [NuGet.Frameworks.NullableContextAttribute("2")]
public sealed virtual int CompareEquivalentFrameworks(NuGetFramework x, NuGetFramework y);
    [NuGet.Frameworks.NullableContextAttribute("2")]
private static int CompareUsingPrecedence(NuGetFramework x, NuGetFramework y, Dictionary`2<string, int> precedence);
    public sealed virtual NuGetFramework GetShortNameReplacement(NuGetFramework framework);
    public sealed virtual NuGetFramework GetFullNameReplacement(NuGetFramework framework);
    public sealed virtual IEnumerable`1<NuGetFramework> GetNetStandardVersions();
    public sealed virtual IEnumerable`1<NuGetFramework> GetCompatibleCandidates();
    private void AddNetStandardVersions();
    private void AddCompatibleCandidates();
    private static bool SetEquals(HashSet`1<NuGetFramework> left, HashSet`1<NuGetFramework> right);
    private static void UnionWith(HashSet`1<NuGetFramework> toAccumulate, HashSet`1<NuGetFramework> toAdd);
    [CompilerGeneratedAttribute]
internal static bool <GetVersionString>g__HasGreaterThanNinePart|30_0(<>c__DisplayClass30_0& );
    [CompilerGeneratedAttribute]
internal static bool <GetVersionString>g__IsZero|30_1(Version version);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
public class NuGet.Frameworks.FrameworkPrecedenceSorter : object {
    private IFrameworkNameProvider _mappings;
    private bool _allEquivalent;
    public FrameworkPrecedenceSorter(IFrameworkNameProvider mappings, bool allEquivalent);
    [NuGet.Frameworks.NullableContextAttribute("2")]
public sealed virtual int Compare(NuGetFramework x, NuGetFramework y);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
public class NuGet.Frameworks.FrameworkRange : object {
    private bool _includeMin;
    private bool _includeMax;
    [CompilerGeneratedAttribute]
private NuGetFramework <Min>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetFramework <Max>k__BackingField;
    public NuGetFramework Min { get; }
    public NuGetFramework Max { get; }
    public bool IncludeMin { get; }
    public bool IncludeMax { get; }
    public string FrameworkIdentifier { get; }
    public FrameworkRange(NuGetFramework min, NuGetFramework max);
    public FrameworkRange(NuGetFramework min, NuGetFramework max, bool includeMin, bool includeMax);
    [CompilerGeneratedAttribute]
public NuGetFramework get_Min();
    [CompilerGeneratedAttribute]
public NuGetFramework get_Max();
    public bool get_IncludeMin();
    public bool get_IncludeMax();
    public string get_FrameworkIdentifier();
    public bool Satisfies(NuGetFramework framework);
    private static bool SameExceptForVersion(NuGetFramework x, NuGetFramework y);
    public virtual string ToString();
    [NuGet.Frameworks.NullableContextAttribute("2")]
public sealed virtual bool Equals(FrameworkRange other);
    [NuGet.Frameworks.NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
public class NuGet.Frameworks.FrameworkRangeComparer : object {
    [CompilerGeneratedAttribute]
private static FrameworkRangeComparer <Instance>k__BackingField;
    public static FrameworkRangeComparer Instance { get; }
    private static FrameworkRangeComparer();
    [CompilerGeneratedAttribute]
public static FrameworkRangeComparer get_Instance();
    [NuGet.Frameworks.NullableContextAttribute("2")]
public sealed virtual bool Equals(FrameworkRange x, FrameworkRange y);
    public sealed virtual int GetHashCode(FrameworkRange obj);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
public class NuGet.Frameworks.FrameworkReducer : object {
    private IFrameworkNameProvider _mappings;
    private IFrameworkCompatibilityProvider _compat;
    public FrameworkReducer(IFrameworkNameProvider mappings, IFrameworkCompatibilityProvider compat);
    public NuGetFramework GetNearest(NuGetFramework framework, IEnumerable`1<NuGetFramework> possibleFrameworks);
    private NuGetFramework GetNearestInternal(NuGetFramework framework, IEnumerable`1<NuGetFramework> possibleFrameworks);
    [IteratorStateMachineAttribute("NuGet.Frameworks.FrameworkReducer/<ReduceEquivalent>d__6")]
public IEnumerable`1<NuGetFramework> ReduceEquivalent(IEnumerable`1<NuGetFramework> frameworks);
    public IEnumerable`1<NuGetFramework> ReduceUpwards(IEnumerable`1<NuGetFramework> frameworks);
    public IEnumerable`1<NuGetFramework> ReduceDownwards(IEnumerable`1<NuGetFramework> frameworks);
    private IEnumerable`1<NuGetFramework> ReduceCore(IEnumerable`1<NuGetFramework> frameworks, Func`3<NuGetFramework, NuGetFramework, bool> isCompat);
    private IEnumerable`1<NuGetFramework> GetNearestNonPCLtoPCL(NuGetFramework framework, IEnumerable`1<NuGetFramework> reduced);
    private IEnumerable`1<NuGetFramework> GetNearestPCLtoPCL(NuGetFramework framework, IEnumerable`1<NuGetFramework> reduced);
    private Dictionary`2<NuGetFramework, IEnumerable`1<NuGetFramework>> ExplodePortableFrameworks(IEnumerable`1<NuGetFramework> pcls);
    private IEnumerable`1<NuGetFramework> ExplodePortableFramework(NuGetFramework pcl, bool includeOptional);
    private NuGetFramework GetBestPCL(IEnumerable`1<NuGetFramework> reduced);
    private bool IsBetterPCL(NuGetFramework current, NuGetFramework considering);
    [CompilerGeneratedAttribute]
private bool <ReduceUpwards>b__7_2(NuGetFramework x, NuGetFramework y);
    [CompilerGeneratedAttribute]
private bool <ReduceDownwards>b__8_1(NuGetFramework x, NuGetFramework y);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
public class NuGet.Frameworks.FrameworkRuntimePair : object {
    [CompilerGeneratedAttribute]
private NuGetFramework <Framework>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuntimeIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public NuGetFramework Framework { get; }
    public string RuntimeIdentifier { get; }
    public string Name { get; }
    public FrameworkRuntimePair(NuGetFramework framework, string runtimeIdentifier);
    [CompilerGeneratedAttribute]
public NuGetFramework get_Framework();
    [CompilerGeneratedAttribute]
public string get_RuntimeIdentifier();
    [CompilerGeneratedAttribute]
public string get_Name();
    [NuGet.Frameworks.NullableContextAttribute("2")]
public sealed virtual bool Equals(FrameworkRuntimePair other);
    [NuGet.Frameworks.NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    [ObsoleteAttribute("This type is immutable, so there is no need or point to clone it.")]
public FrameworkRuntimePair Clone();
    [NuGet.Frameworks.NullableContextAttribute("2")]
public sealed virtual int CompareTo(FrameworkRuntimePair other);
    public static string GetName(NuGetFramework framework, string runtimeIdentifier);
    public static string GetTargetGraphName(NuGetFramework framework, string runtimeIdentifier);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
public class NuGet.Frameworks.FrameworkSpecificMapping : object {
    [CompilerGeneratedAttribute]
private string <FrameworkIdentifier>k__BackingField;
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private KeyValuePair`2<string, string> <Mapping>k__BackingField;
    public string FrameworkIdentifier { get; }
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public KeyValuePair`2<string, string> Mapping { get; }
    public FrameworkSpecificMapping(string frameworkIdentifier, string key, string value);
    public FrameworkSpecificMapping(string frameworkIdentifier, KeyValuePair`2<string, string> mapping);
    [CompilerGeneratedAttribute]
public string get_FrameworkIdentifier();
    [CompilerGeneratedAttribute]
public KeyValuePair`2<string, string> get_Mapping();
}
[NuGet.Frameworks.NullableContextAttribute("1")]
public interface NuGet.Frameworks.IFrameworkCompatibilityListProvider {
    public abstract virtual IEnumerable`1<NuGetFramework> GetFrameworksSupporting(NuGetFramework target);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
public interface NuGet.Frameworks.IFrameworkCompatibilityProvider {
    public abstract virtual bool IsCompatible(NuGetFramework framework, NuGetFramework other);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
public interface NuGet.Frameworks.IFrameworkMappings {
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<string, string>> IdentifierSynonyms { get; }
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<string, string>> IdentifierShortNames { get; }
    public IEnumerable`1<FrameworkSpecificMapping> ProfileShortNames { get; }
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> EquivalentFrameworks { get; }
    public IEnumerable`1<FrameworkSpecificMapping> EquivalentProfiles { get; }
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<string, string>> SubSetFrameworks { get; }
    public IEnumerable`1<OneWayCompatibilityMappingEntry> CompatibilityMappings { get; }
    public IEnumerable`1<string> NonPackageBasedFrameworkPrecedence { get; }
    public IEnumerable`1<string> PackageBasedFrameworkPrecedence { get; }
    public IEnumerable`1<string> EquivalentFrameworkPrecedence { get; }
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> ShortNameReplacements { get; }
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> FullNameReplacements { get; }
    public abstract virtual IEnumerable`1<KeyValuePair`2<string, string>> get_IdentifierSynonyms();
    public abstract virtual IEnumerable`1<KeyValuePair`2<string, string>> get_IdentifierShortNames();
    public abstract virtual IEnumerable`1<FrameworkSpecificMapping> get_ProfileShortNames();
    public abstract virtual IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> get_EquivalentFrameworks();
    public abstract virtual IEnumerable`1<FrameworkSpecificMapping> get_EquivalentProfiles();
    public abstract virtual IEnumerable`1<KeyValuePair`2<string, string>> get_SubSetFrameworks();
    public abstract virtual IEnumerable`1<OneWayCompatibilityMappingEntry> get_CompatibilityMappings();
    public abstract virtual IEnumerable`1<string> get_NonPackageBasedFrameworkPrecedence();
    public abstract virtual IEnumerable`1<string> get_PackageBasedFrameworkPrecedence();
    public abstract virtual IEnumerable`1<string> get_EquivalentFrameworkPrecedence();
    public abstract virtual IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> get_ShortNameReplacements();
    public abstract virtual IEnumerable`1<KeyValuePair`2<NuGetFramework, NuGetFramework>> get_FullNameReplacements();
}
[NuGet.Frameworks.NullableContextAttribute("1")]
public interface NuGet.Frameworks.IFrameworkNameProvider {
    public abstract virtual bool TryGetIdentifier(string identifierShortName, String& identifier);
    public abstract virtual bool TryGetShortIdentifier(string identifier, String& identifierShortName);
    public abstract virtual bool TryGetProfile(string frameworkIdentifier, string profileShortName, String& profile);
    public abstract virtual bool TryGetShortProfile(string frameworkIdentifier, string profile, String& profileShortName);
    public abstract virtual bool TryGetVersion(string versionString, Version& version);
    public abstract virtual bool TryGetPlatformVersion(string versionString, Version& version);
    public abstract virtual string GetVersionString(string framework, Version version);
    public abstract virtual bool TryGetPortableProfileNumber(string profile, Int32& profileNumber);
    public abstract virtual bool TryGetPortableProfile(IEnumerable`1<NuGetFramework> supportedFrameworks, Int32& profileNumber);
    public abstract virtual bool TryGetPortableFrameworks(int profile, IEnumerable`1& frameworks);
    public abstract virtual bool TryGetPortableFrameworks(int profile, bool includeOptional, IEnumerable`1& frameworks);
    public abstract virtual bool TryGetPortableFrameworks(string profile, bool includeOptional, IEnumerable`1& frameworks);
    public abstract virtual bool TryGetPortableFrameworks(string shortPortableProfiles, IEnumerable`1& frameworks);
    public abstract virtual bool TryGetPortableCompatibilityMappings(int profile, IEnumerable`1& supportedFrameworkRanges);
    public abstract virtual bool TryGetEquivalentFrameworks(NuGetFramework framework, IEnumerable`1& frameworks);
    public abstract virtual bool TryGetEquivalentFrameworks(FrameworkRange range, IEnumerable`1& frameworks);
    public abstract virtual bool TryGetCompatibilityMappings(NuGetFramework framework, IEnumerable`1& supportedFrameworkRanges);
    public abstract virtual bool TryGetSubSetFrameworks(string frameworkIdentifier, IEnumerable`1& subSetFrameworkIdentifiers);
    [NuGet.Frameworks.NullableContextAttribute("2")]
public abstract virtual int CompareFrameworks(NuGetFramework x, NuGetFramework y);
    [NuGet.Frameworks.NullableContextAttribute("2")]
public abstract virtual int CompareEquivalentFrameworks(NuGetFramework x, NuGetFramework y);
    public abstract virtual NuGetFramework GetShortNameReplacement(NuGetFramework framework);
    public abstract virtual NuGetFramework GetFullNameReplacement(NuGetFramework framework);
    public abstract virtual IEnumerable`1<NuGetFramework> GetNetStandardVersions();
    public abstract virtual IEnumerable`1<NuGetFramework> GetCompatibleCandidates();
}
[NuGet.Frameworks.NullableContextAttribute("1")]
public interface NuGet.Frameworks.IFrameworkSpecific {
    public NuGetFramework TargetFramework { get; }
    public abstract virtual NuGetFramework get_TargetFramework();
}
[NuGet.Frameworks.NullableContextAttribute("1")]
public interface NuGet.Frameworks.IFrameworkTargetable {
    public IEnumerable`1<NuGetFramework> SupportedFrameworks { get; }
    public abstract virtual IEnumerable`1<NuGetFramework> get_SupportedFrameworks();
}
public interface NuGet.Frameworks.IPortableFrameworkMappings {
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<int, NuGetFramework[]>> ProfileFrameworks { get; }
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<int, NuGetFramework[]>> ProfileOptionalFrameworks { get; }
    [NuGet.Frameworks.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<int, FrameworkRange>> CompatibilityMappings { get; }
    public abstract virtual IEnumerable`1<KeyValuePair`2<int, NuGetFramework[]>> get_ProfileFrameworks();
    public abstract virtual IEnumerable`1<KeyValuePair`2<int, NuGetFramework[]>> get_ProfileOptionalFrameworks();
    public abstract virtual IEnumerable`1<KeyValuePair`2<int, FrameworkRange>> get_CompatibilityMappings();
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
public class NuGet.Frameworks.NuGetFramework : object {
    private string _frameworkIdentifier;
    private Version _frameworkVersion;
    private string _frameworkProfile;
    [NuGet.Frameworks.NullableAttribute("2")]
private string _targetFrameworkMoniker;
    [NuGet.Frameworks.NullableAttribute("2")]
private string _targetPlatformMoniker;
    private Nullable`1<int> _hashCode;
    private static int Version5;
    [CompilerGeneratedAttribute]
private string <Platform>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <PlatformVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNet5Era>k__BackingField;
    public static IEqualityComparer`1<NuGetFramework> Comparer;
    public static IEqualityComparer`1<NuGetFramework> FrameworkNameComparer;
    private static SortedSet`1<string> PackagesBased;
    public static NuGetFramework UnsupportedFramework;
    public static NuGetFramework AgnosticFramework;
    public static NuGetFramework AnyFramework;
    private static Char[] CommaSeparator;
    public string Framework { get; }
    public Version Version { get; }
    public string Platform { get; }
    public Version PlatformVersion { get; }
    public bool HasPlatform { get; }
    public bool HasProfile { get; }
    public string Profile { get; }
    public string DotNetFrameworkName { get; }
    public string DotNetPlatformName { get; }
    public bool IsPCL { get; }
    public bool IsPackageBased { get; }
    public bool AllFrameworkVersions { get; }
    public bool IsUnsupported { get; }
    public bool IsAgnostic { get; }
    public bool IsAny { get; }
    public bool IsSpecificFramework { get; }
    internal bool IsNet5Era { get; private set; }
    public NuGetFramework(NuGetFramework framework);
    public NuGetFramework(string framework);
    public NuGetFramework(string framework, Version version);
    public NuGetFramework(string frameworkIdentifier, Version frameworkVersion, string frameworkProfile);
    public NuGetFramework(string frameworkIdentifier, Version frameworkVersion, string platform, Version platformVersion);
    internal NuGetFramework(string frameworkIdentifier, Version frameworkVersion, string profile, string platform, Version platformVersion);
    private static NuGetFramework();
    public string get_Framework();
    public Version get_Version();
    [CompilerGeneratedAttribute]
public string get_Platform();
    [CompilerGeneratedAttribute]
public Version get_PlatformVersion();
    public bool get_HasPlatform();
    public bool get_HasProfile();
    public string get_Profile();
    public string get_DotNetFrameworkName();
    public string GetDotNetFrameworkName(IFrameworkNameProvider mappings);
    public string get_DotNetPlatformName();
    public string GetShortFolderName();
    private string GetFrameworkIdentifier();
    public virtual string GetShortFolderName(IFrameworkNameProvider mappings);
    private static string GetDisplayVersion(Version version);
    private static string GetLettersAndDigitsOnly(string s);
    public bool get_IsPCL();
    public bool get_IsPackageBased();
    public bool get_AllFrameworkVersions();
    public bool get_IsUnsupported();
    public bool get_IsAgnostic();
    public bool get_IsAny();
    public bool get_IsSpecificFramework();
    [CompilerGeneratedAttribute]
internal bool get_IsNet5Era();
    [CompilerGeneratedAttribute]
private void set_IsNet5Era(bool value);
    public virtual string ToString();
    [NuGet.Frameworks.NullableContextAttribute("2")]
public sealed virtual bool Equals(NuGetFramework other);
    [NuGet.Frameworks.NullableContextAttribute("2")]
public static bool op_Equality(NuGetFramework left, NuGetFramework right);
    [NuGet.Frameworks.NullableContextAttribute("2")]
public static bool op_Inequality(NuGetFramework left, NuGetFramework right);
    public virtual int GetHashCode();
    [NuGet.Frameworks.NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    private static Version NormalizeVersion(Version version);
    public static NuGetFramework Parse(string folderName);
    public static NuGetFramework Parse(string folderName, IFrameworkNameProvider mappings);
    public static NuGetFramework ParseComponents(string targetFrameworkMoniker, string targetPlatformMoniker);
    internal static NuGetFramework ParseComponents(string targetFrameworkMoniker, string targetPlatformMoniker, IFrameworkNameProvider mappings);
    private static String[] GetParts(string targetPlatformMoniker);
    public static NuGetFramework ParseFrameworkName(string frameworkName, IFrameworkNameProvider mappings);
    private static void ParseFrameworkNameParts(IFrameworkNameProvider mappings, String[] parts, String& framework, Version& version, String& profile);
    private static void ParsePlatformParts(String[] parts, String& targetPlatformIdentifier, Version& platformVersion);
    public static NuGetFramework ParseFolder(string folderName);
    public static NuGetFramework ParseFolder(string folderName, IFrameworkNameProvider mappings);
    private static bool TryParseDeprecatedFramework(string s, NuGetFramework& framework);
    private static Tuple`3<string, string, string> RawParse(string s);
    private static bool IsLetterOrDot(char c);
    private static bool IsDigitOrDot(char c);
    private static bool IsValidProfileChar(char c);
    private static bool TryParseSpecialFramework(string frameworkString, NuGetFramework& framework);
    private static bool TryParseCommonFramework(string frameworkString, NuGetFramework& framework);
    private static string SingleOrDefaultSafe(IEnumerable`1<string> items);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
[ExtensionAttribute]
public static class NuGet.Frameworks.NuGetFrameworkExtensions : object {
    [ExtensionAttribute]
public static bool IsDesktop(NuGetFramework framework);
    [ExtensionAttribute]
public static T GetNearest(IEnumerable`1<T> items, NuGetFramework projectFramework);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
public class NuGet.Frameworks.NuGetFrameworkFullComparer : object {
    [CompilerGeneratedAttribute]
private static NuGetFrameworkFullComparer <Instance>k__BackingField;
    public static NuGetFrameworkFullComparer Instance { get; }
    private static NuGetFrameworkFullComparer();
    [CompilerGeneratedAttribute]
public static NuGetFrameworkFullComparer get_Instance();
    [NuGet.Frameworks.NullableContextAttribute("2")]
public sealed virtual bool Equals(NuGetFramework x, NuGetFramework y);
    public sealed virtual int GetHashCode(NuGetFramework obj);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
public class NuGet.Frameworks.NuGetFrameworkNameComparer : object {
    [CompilerGeneratedAttribute]
private static NuGetFrameworkNameComparer <Instance>k__BackingField;
    public static NuGetFrameworkNameComparer Instance { get; }
    private static NuGetFrameworkNameComparer();
    [CompilerGeneratedAttribute]
public static NuGetFrameworkNameComparer get_Instance();
    [NuGet.Frameworks.NullableContextAttribute("2")]
public sealed virtual bool Equals(NuGetFramework x, NuGetFramework y);
    public sealed virtual int GetHashCode(NuGetFramework obj);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
public class NuGet.Frameworks.NuGetFrameworkSorter : object {
    [CompilerGeneratedAttribute]
private static NuGetFrameworkSorter <Instance>k__BackingField;
    public static NuGetFrameworkSorter Instance { get; }
    private static NuGetFrameworkSorter();
    [CompilerGeneratedAttribute]
public static NuGetFrameworkSorter get_Instance();
    [NuGet.Frameworks.NullableContextAttribute("2")]
public sealed virtual int Compare(NuGetFramework x, NuGetFramework y);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
public static class NuGet.Frameworks.NuGetFrameworkUtility : object {
    public static T GetNearest(IEnumerable`1<T> items, NuGetFramework framework, Func`2<T, NuGetFramework> selector);
    public static T GetNearest(IEnumerable`1<T> items, NuGetFramework framework, IFrameworkNameProvider frameworkMappings, IFrameworkCompatibilityProvider compatibilityProvider, Func`2<T, NuGetFramework> selector);
    public static T GetNearest(IEnumerable`1<T> items, NuGetFramework framework);
    public static T GetNearest(IEnumerable`1<T> items, NuGetFramework framework, IFrameworkNameProvider frameworkMappings, IFrameworkCompatibilityProvider compatibilityProvider);
    public static bool IsCompatibleWithFallbackCheck(NuGetFramework projectFramework, NuGetFramework candidate);
    public static bool IsNetCore50AndUp(NuGetFramework framework);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
public class NuGet.Frameworks.OneWayCompatibilityMappingEntry : object {
    private FrameworkRange _targetFramework;
    private FrameworkRange _supportedFramework;
    public FrameworkRange TargetFrameworkRange { get; }
    public FrameworkRange SupportedFrameworkRange { get; }
    public static CompatibilityMappingComparer Comparer { get; }
    public OneWayCompatibilityMappingEntry(FrameworkRange targetFramework, FrameworkRange supportedFramework);
    public FrameworkRange get_TargetFrameworkRange();
    public FrameworkRange get_SupportedFrameworkRange();
    public static CompatibilityMappingComparer get_Comparer();
    [NuGet.Frameworks.NullableContextAttribute("2")]
public sealed virtual bool Equals(OneWayCompatibilityMappingEntry other);
    public virtual string ToString();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class NuGet.Frameworks.Strings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ArgumentCannotBeNullOrEmpty { get; }
    internal static string FrameworkDoesNotSupportProfiles { get; }
    internal static string FrameworkMismatch { get; }
    internal static string InvalidFrameworkIdentifier { get; }
    internal static string InvalidFrameworkVersion { get; }
    internal static string InvalidPlatformVersion { get; }
    internal static string InvalidPortableFrameworksDueToHyphen { get; }
    internal static string MissingPortableFrameworks { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ArgumentCannotBeNullOrEmpty();
    internal static string get_FrameworkDoesNotSupportProfiles();
    internal static string get_FrameworkMismatch();
    internal static string get_InvalidFrameworkIdentifier();
    internal static string get_InvalidFrameworkVersion();
    internal static string get_InvalidPlatformVersion();
    internal static string get_InvalidPortableFrameworksDueToHyphen();
    internal static string get_MissingPortableFrameworks();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.NoAllocEnumerateExtensions : object {
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingListEnumerable`1<T> NoAllocEnumerate(IList`1<T> list);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingEnumerable`1<T> NoAllocEnumerate(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingDictionaryEnumerable`2<TKey, TValue> NoAllocEnumerate(IDictionary`2<TKey, TValue> dictionary);
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.NuGet.Configuration1122.NoAllocEnumerateExtensions : object {
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingListEnumerable`1<T> NoAllocEnumerate(IList`1<T> list);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingEnumerable`1<T> NoAllocEnumerate(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingDictionaryEnumerable`2<TKey, TValue> NoAllocEnumerate(IDictionary`2<TKey, TValue> dictionary);
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal class NuGet.NuGet.Configuration1122.SimplePool`1 : object {
    private ConcurrentStack`1<T> _values;
    private Func`1<T> _allocate;
    public NuGet.Configuration1122.SimplePool`1(Func`1<T> allocate);
    public T Allocate();
    public void Free(T value);
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal class NuGet.NuGet.Configuration1122.StringBuilderPool : object {
    private static int MaxPoolSize;
    private NuGet.Configuration1122.SimplePool`1<StringBuilder> _pool;
    public static NuGet.Configuration1122.StringBuilderPool Shared;
    private static NuGet.Configuration1122.StringBuilderPool();
    public StringBuilder Rent(int minimumCapacity);
    public string ToStringAndReturn(StringBuilder builder);
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
internal static class NuGet.NuGet.Configuration1122.TaskResult : object {
    [CompilerGeneratedAttribute]
private static Task`1<bool> <True>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<bool> <False>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <Zero>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <One>k__BackingField;
    public static Task`1<bool> True { get; }
    public static Task`1<bool> False { get; }
    public static Task`1<int> Zero { get; }
    public static Task`1<int> One { get; }
    private static NuGet.Configuration1122.TaskResult();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_True();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_False();
    public static Task`1<bool> Boolean(bool b);
    [CompilerGeneratedAttribute]
public static Task`1<int> get_Zero();
    [CompilerGeneratedAttribute]
public static Task`1<int> get_One();
    public static Task`1<int> Integer(int i);
    public static Task`1<T> Null();
    public static Task`1<IEnumerable`1<T>> EmptyEnumerable();
    public static Task`1<T[]> EmptyArray();
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.NuGet.Frameworks1139.NoAllocEnumerateExtensions : object {
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingListEnumerable`1<T> NoAllocEnumerate(IList`1<T> list);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingEnumerable`1<T> NoAllocEnumerate(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingDictionaryEnumerable`2<TKey, TValue> NoAllocEnumerate(IDictionary`2<TKey, TValue> dictionary);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
internal class NuGet.NuGet.Frameworks1139.SimplePool`1 : object {
    private ConcurrentStack`1<T> _values;
    private Func`1<T> _allocate;
    public NuGet.Frameworks1139.SimplePool`1(Func`1<T> allocate);
    public T Allocate();
    public void Free(T value);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
internal class NuGet.NuGet.Frameworks1139.StringBuilderPool : object {
    private static int MaxPoolSize;
    private NuGet.Frameworks1139.SimplePool`1<StringBuilder> _pool;
    public static NuGet.Frameworks1139.StringBuilderPool Shared;
    private static NuGet.Frameworks1139.StringBuilderPool();
    public StringBuilder Rent(int minimumCapacity);
    public string ToStringAndReturn(StringBuilder builder);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
internal static class NuGet.NuGet.Frameworks1139.TaskResult : object {
    [CompilerGeneratedAttribute]
private static Task`1<bool> <True>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<bool> <False>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <Zero>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <One>k__BackingField;
    public static Task`1<bool> True { get; }
    public static Task`1<bool> False { get; }
    public static Task`1<int> Zero { get; }
    public static Task`1<int> One { get; }
    private static NuGet.Frameworks1139.TaskResult();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_True();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_False();
    public static Task`1<bool> Boolean(bool b);
    [CompilerGeneratedAttribute]
public static Task`1<int> get_Zero();
    [CompilerGeneratedAttribute]
public static Task`1<int> get_One();
    public static Task`1<int> Integer(int i);
    public static Task`1<T> Null();
    public static Task`1<IEnumerable`1<T>> EmptyEnumerable();
    public static Task`1<T[]> EmptyArray();
}
[NuGet.Packaging.NullableContextAttribute("1")]
[NuGet.Packaging.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.NuGet.Packaging1156.NoAllocEnumerateExtensions : object {
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingListEnumerable`1<T> NoAllocEnumerate(IList`1<T> list);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingEnumerable`1<T> NoAllocEnumerate(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingDictionaryEnumerable`2<TKey, TValue> NoAllocEnumerate(IDictionary`2<TKey, TValue> dictionary);
}
[NuGet.Packaging.NullableContextAttribute("1")]
[NuGet.Packaging.NullableAttribute("0")]
internal class NuGet.NuGet.Packaging1156.SimplePool`1 : object {
    private ConcurrentStack`1<T> _values;
    private Func`1<T> _allocate;
    public NuGet.Packaging1156.SimplePool`1(Func`1<T> allocate);
    public T Allocate();
    public void Free(T value);
}
[NuGet.Packaging.NullableContextAttribute("1")]
[NuGet.Packaging.NullableAttribute("0")]
internal class NuGet.NuGet.Packaging1156.StringBuilderPool : object {
    private static int MaxPoolSize;
    private NuGet.Packaging1156.SimplePool`1<StringBuilder> _pool;
    public static NuGet.Packaging1156.StringBuilderPool Shared;
    private static NuGet.Packaging1156.StringBuilderPool();
    public StringBuilder Rent(int minimumCapacity);
    public string ToStringAndReturn(StringBuilder builder);
}
[NuGet.Packaging.NullableContextAttribute("1")]
[NuGet.Packaging.NullableAttribute("0")]
internal static class NuGet.NuGet.Packaging1156.TaskResult : object {
    [CompilerGeneratedAttribute]
private static Task`1<bool> <True>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<bool> <False>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <Zero>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <One>k__BackingField;
    public static Task`1<bool> True { get; }
    public static Task`1<bool> False { get; }
    public static Task`1<int> Zero { get; }
    public static Task`1<int> One { get; }
    private static NuGet.Packaging1156.TaskResult();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_True();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_False();
    public static Task`1<bool> Boolean(bool b);
    [CompilerGeneratedAttribute]
public static Task`1<int> get_Zero();
    [CompilerGeneratedAttribute]
public static Task`1<int> get_One();
    public static Task`1<int> Integer(int i);
    public static Task`1<T> Null();
    public static Task`1<IEnumerable`1<T>> EmptyEnumerable();
    public static Task`1<T[]> EmptyArray();
}
[NuGet.Versioning.NullableContextAttribute("1")]
[NuGet.Versioning.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.NuGet.Versioning1173.NoAllocEnumerateExtensions : object {
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingListEnumerable`1<T> NoAllocEnumerate(IList`1<T> list);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingEnumerable`1<T> NoAllocEnumerate(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingDictionaryEnumerable`2<TKey, TValue> NoAllocEnumerate(IDictionary`2<TKey, TValue> dictionary);
}
[NuGet.Versioning.NullableContextAttribute("1")]
[NuGet.Versioning.NullableAttribute("0")]
internal class NuGet.NuGet.Versioning1173.SimplePool`1 : object {
    private ConcurrentStack`1<T> _values;
    private Func`1<T> _allocate;
    public NuGet.Versioning1173.SimplePool`1(Func`1<T> allocate);
    public T Allocate();
    public void Free(T value);
}
[NuGet.Versioning.NullableContextAttribute("1")]
[NuGet.Versioning.NullableAttribute("0")]
internal class NuGet.NuGet.Versioning1173.StringBuilderPool : object {
    private static int MaxPoolSize;
    private NuGet.Versioning1173.SimplePool`1<StringBuilder> _pool;
    public static NuGet.Versioning1173.StringBuilderPool Shared;
    private static NuGet.Versioning1173.StringBuilderPool();
    public StringBuilder Rent(int minimumCapacity);
    public string ToStringAndReturn(StringBuilder builder);
}
[NuGet.Versioning.NullableContextAttribute("1")]
[NuGet.Versioning.NullableAttribute("0")]
internal static class NuGet.NuGet.Versioning1173.TaskResult : object {
    [CompilerGeneratedAttribute]
private static Task`1<bool> <True>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<bool> <False>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <Zero>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <One>k__BackingField;
    public static Task`1<bool> True { get; }
    public static Task`1<bool> False { get; }
    public static Task`1<int> Zero { get; }
    public static Task`1<int> One { get; }
    private static NuGet.Versioning1173.TaskResult();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_True();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_False();
    public static Task`1<bool> Boolean(bool b);
    [CompilerGeneratedAttribute]
public static Task`1<int> get_Zero();
    [CompilerGeneratedAttribute]
public static Task`1<int> get_One();
    public static Task`1<int> Integer(int i);
    public static Task`1<T> Null();
    public static Task`1<IEnumerable`1<T>> EmptyEnumerable();
    public static Task`1<T[]> EmptyArray();
}
[CompilerGeneratedAttribute]
internal class NuGet.Packaging.<PrivateImplementationDetails> : object {
    internal static __StaticArrayInitTypeSize=72 1322D1B39533BDAC158534C6038A6604353F624FE00BA8853ACE014F39F256F6;
    internal static __StaticArrayInitTypeSize=32 2EF83B43314F8CD03190EEE30ECCF048DA37791237F27C62A579F23EACE9FD70;
    internal static __StaticArrayInitTypeSize=12 4636993D3E1DA4E9D6B8F87B79E8F7C6D018580D52661950EABC3845C5897A4D;
    internal static int 6A3DB24B8BC57D2CCDC198B2D7858EC657F34A7B2C9153BC04CA82D73170876D;
    internal static __StaticArrayInitTypeSize=10 95F9CC13D5B6AC6BF42EDD70B77562DFD84CC4209CCD22831FD3663E74F841EE;
}
[ExtensionAttribute]
public static class NuGet.Packaging.CollectionExtensions : object {
    [ExtensionAttribute]
public static void AddRange(ICollection`1<T> collection, IEnumerable`1<T> items);
}
internal static class NuGet.Packaging.Core.ContentExtractor : object {
    internal static void GetContentForPattern(ContentItemCollection collection, PatternSet pattern, IList`1<ContentItemGroup> itemGroups);
    internal static IEnumerable`1<NuGetFramework> GetGroupFrameworks(IEnumerable`1<ContentItemGroup> groups);
}
public class NuGet.Packaging.Core.ContentFilesEntry : object {
    [CompilerGeneratedAttribute]
private string <Include>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Exclude>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BuildAction>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <CopyToOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Flatten>k__BackingField;
    public string Include { get; }
    public string Exclude { get; }
    public string BuildAction { get; }
    public Nullable`1<bool> CopyToOutput { get; }
    public Nullable`1<bool> Flatten { get; }
    public ContentFilesEntry(string include, string exclude, string buildAction, Nullable`1<bool> copyToOutput, Nullable`1<bool> flatten);
    [CompilerGeneratedAttribute]
public string get_Include();
    [CompilerGeneratedAttribute]
public string get_Exclude();
    [CompilerGeneratedAttribute]
public string get_BuildAction();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_CopyToOutput();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Flatten();
}
public class NuGet.Packaging.Core.ExtractPackageFileDelegate : MulticastDelegate {
    public ExtractPackageFileDelegate(object object, IntPtr method);
    public virtual string Invoke(string sourceFile, string targetPath, Stream fileStream);
    public virtual IAsyncResult BeginInvoke(string sourceFile, string targetPath, Stream fileStream, AsyncCallback callback, object object);
    public virtual string EndInvoke(IAsyncResult result);
}
[DefaultMemberAttribute("Item")]
public class NuGet.Packaging.Core.Fingerprints : object {
    private IDictionary`2<string, string> _keyValuePairs;
    public string Item { get; }
    public Fingerprints(IDictionary`2<string, string> fingerPrints);
    public string get_Item(string key);
    public IEnumerator`1<KeyValuePair`2<string, string>> GetEnumerator();
}
public interface NuGet.Packaging.Core.IAsyncPackageCoreReader {
    public abstract virtual Task`1<PackageIdentity> GetIdentityAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<NuGetVersion> GetMinClientVersionAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IReadOnlyList`1<PackageType>> GetPackageTypesAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<Stream> GetStreamAsync(string path, CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<string>> GetFilesAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<string>> GetFilesAsync(string folder, CancellationToken cancellationToken);
    public abstract virtual Task`1<Stream> GetNuspecAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<string> GetNuspecFileAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<string>> CopyFilesAsync(string destination, IEnumerable`1<string> packageFiles, ExtractPackageFileDelegate extractFile, ILogger logger, CancellationToken cancellationToken);
}
public interface NuGet.Packaging.Core.INuspecCoreReader {
    public abstract virtual string GetId();
    public abstract virtual NuGetVersion GetVersion();
    public abstract virtual NuGetVersion GetMinClientVersion();
    public abstract virtual IReadOnlyList`1<PackageType> GetPackageTypes();
    public abstract virtual PackageIdentity GetIdentity();
    public abstract virtual IEnumerable`1<KeyValuePair`2<string, string>> GetMetadata();
}
public interface NuGet.Packaging.Core.IPackageCoreReader {
    public abstract virtual PackageIdentity GetIdentity();
    public abstract virtual NuGetVersion GetMinClientVersion();
    public abstract virtual IReadOnlyList`1<PackageType> GetPackageTypes();
    public abstract virtual Stream GetStream(string path);
    public abstract virtual IEnumerable`1<string> GetFiles();
    public abstract virtual IEnumerable`1<string> GetFiles(string folder);
    public abstract virtual Stream GetNuspec();
    public abstract virtual string GetNuspecFile();
    public abstract virtual IEnumerable`1<string> CopyFiles(string destination, IEnumerable`1<string> packageFiles, ExtractPackageFileDelegate extractFile, ILogger logger, CancellationToken token);
}
public interface NuGet.Packaging.Core.IPackageIdentityComparer {
}
public interface NuGet.Packaging.Core.IRepositoryCertificateInfo {
    public string ContentUrl { get; }
    public Fingerprints Fingerprints { get; }
    public string Issuer { get; }
    public DateTimeOffset NotAfter { get; }
    public DateTimeOffset NotBefore { get; }
    public string Subject { get; }
    public abstract virtual string get_ContentUrl();
    public abstract virtual Fingerprints get_Fingerprints();
    public abstract virtual string get_Issuer();
    public abstract virtual DateTimeOffset get_NotAfter();
    public abstract virtual DateTimeOffset get_NotBefore();
    public abstract virtual string get_Subject();
}
public class NuGet.Packaging.Core.NuspecCoreReader : NuspecCoreReaderBase {
    public NuspecCoreReader(Stream stream);
    public NuspecCoreReader(XDocument xml);
    [IteratorStateMachineAttribute("NuGet.Packaging.Core.NuspecCoreReader/<GetDependencies>d__2")]
public virtual IEnumerable`1<PackageDependency> GetDependencies();
}
public abstract class NuGet.Packaging.Core.NuspecCoreReaderBase : object {
    private XDocument _xml;
    private XElement _metadataNode;
    private Dictionary`2<string, string> _metadataValues;
    protected static string Metadata;
    protected static string Id;
    protected static string Version;
    protected static string MinClientVersion;
    protected static string DevelopmentDependency;
    protected Dictionary`2<string, string> MetadataValues { get; }
    protected XElement MetadataNode { get; }
    public XDocument Xml { get; }
    public NuspecCoreReaderBase(string path);
    public NuspecCoreReaderBase(Stream stream);
    public NuspecCoreReaderBase(Stream stream, bool leaveStreamOpen);
    public NuspecCoreReaderBase(XDocument xml);
    public virtual string GetId();
    public virtual NuGetVersion GetVersion();
    public virtual NuGetVersion GetMinClientVersion();
    public virtual IReadOnlyList`1<PackageType> GetPackageTypes();
    public virtual bool IsServiceable();
    public virtual bool GetDevelopmentDependency();
    public virtual IEnumerable`1<KeyValuePair`2<string, string>> GetMetadata();
    public virtual string GetMetadataValue(string name);
    protected Dictionary`2<string, string> get_MetadataValues();
    protected XElement get_MetadataNode();
    public XDocument get_Xml();
    public virtual PackageIdentity GetIdentity();
    private static XDocument LoadXml(Stream stream, bool leaveStreamOpen);
}
public static class NuGet.Packaging.Core.NuspecUtility : object {
    public static string PackageTypes;
    public static string PackageType;
    public static string Name;
    public static string Version;
    public static string Serviceable;
    public static string Repository;
    public static string Type;
    public static string RepositoryUrl;
    public static string RepositoryBranch;
    public static string RepositoryCommit;
    public static string License;
    public static string Group;
    public static string FrameworkReferences;
    public static string FrameworkReference;
    public static string TargetFramework;
    private static NuspecUtility();
    public static IReadOnlyList`1<PackageType> GetPackageTypes(XElement metadataNode, bool useMetadataNamespace);
    public static bool IsServiceable(XElement metadataNode);
    [IteratorStateMachineAttribute("NuGet.Packaging.Core.NuspecUtility/<GetFrameworkReferenceGroups>d__17")]
internal static IEnumerable`1<FrameworkReferenceGroup> GetFrameworkReferenceGroups(XElement metadataNode, IFrameworkNameProvider frameworkProvider, bool useMetadataNamespace);
    private static IEnumerable`1<string> GetFrameworkReferences(IEnumerable`1<XElement> nodes);
    private static string GetAttributeValue(XElement element, string attributeName);
}
public class NuGet.Packaging.Core.PackageDependency : object {
    private VersionRange _versionRange;
    private static List`1<string> EmptyList;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Include>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Exclude>k__BackingField;
    public string Id { get; }
    public IReadOnlyList`1<string> Include { get; }
    public IReadOnlyList`1<string> Exclude { get; }
    public VersionRange VersionRange { get; }
    public PackageDependency(string id);
    public PackageDependency(string id, VersionRange versionRange);
    public PackageDependency(string id, VersionRange versionRange, IReadOnlyList`1<string> include, IReadOnlyList`1<string> exclude);
    private static PackageDependency();
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Include();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Exclude();
    public VersionRange get_VersionRange();
    public sealed virtual bool Equals(PackageDependency other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class NuGet.Packaging.Core.PackageDependencyComparer : object {
    private IVersionRangeComparer _versionRangeComparer;
    public static PackageDependencyComparer Default;
    public PackageDependencyComparer(IVersionRangeComparer versionRangeComparer);
    private static PackageDependencyComparer();
    public sealed virtual bool Equals(PackageDependency x, PackageDependency y);
    public sealed virtual int GetHashCode(PackageDependency obj);
}
[NuGet.Packaging.NullableContextAttribute("1")]
[NuGet.Packaging.NullableAttribute("0")]
public class NuGet.Packaging.Core.PackageDependencyInfo : PackageIdentity {
    [CompilerGeneratedAttribute]
private IEnumerable`1<PackageDependency> <Dependencies>k__BackingField;
    public IEnumerable`1<PackageDependency> Dependencies { get; }
    public PackageDependencyInfo(string id, NuGetVersion version);
    public PackageDependencyInfo(PackageIdentity identity, IEnumerable`1<PackageDependency> dependencies);
    public PackageDependencyInfo(string id, NuGetVersion version, IEnumerable`1<PackageDependency> dependencies);
    [CompilerGeneratedAttribute]
public IEnumerable`1<PackageDependency> get_Dependencies();
    [NuGet.Packaging.NullableContextAttribute("2")]
public sealed virtual bool Equals(PackageDependencyInfo other);
    [NuGet.Packaging.NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class NuGet.Packaging.Core.PackageDependencyInfoComparer : object {
    private IPackageIdentityComparer _identityComparer;
    private PackageDependencyComparer _dependencyComparer;
    [CompilerGeneratedAttribute]
private static PackageDependencyInfoComparer <Default>k__BackingField;
    public static PackageDependencyInfoComparer Default { get; }
    public PackageDependencyInfoComparer(IPackageIdentityComparer identityComparer, PackageDependencyComparer dependencyComparer);
    private static PackageDependencyInfoComparer();
    [CompilerGeneratedAttribute]
public static PackageDependencyInfoComparer get_Default();
    public sealed virtual bool Equals(PackageDependencyInfo x, PackageDependencyInfo y);
    public sealed virtual int GetHashCode(PackageDependencyInfo obj);
}
public class NuGet.Packaging.Core.PackageIdentity : object {
    private string _id;
    private NuGetVersion _version;
    private static string ToStringFormat;
    public string Id { get; }
    public NuGetVersion Version { get; }
    public bool HasVersion { get; }
    public static PackageIdentityComparer Comparer { get; }
    public PackageIdentity(string id, NuGetVersion version);
    public string get_Id();
    public NuGetVersion get_Version();
    public bool get_HasVersion();
    public sealed virtual bool Equals(PackageIdentity other);
    public virtual bool Equals(PackageIdentity other, VersionComparison versionComparison);
    public sealed virtual int CompareTo(PackageIdentity other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static PackageIdentityComparer get_Comparer();
    public virtual string ToString();
}
public class NuGet.Packaging.Core.PackageIdentityComparer : object {
    private IVersionComparer _versionComparer;
    [CompilerGeneratedAttribute]
private static PackageIdentityComparer <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private static PackageIdentityComparer <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private static PackageIdentityComparer <VersionRelease>k__BackingField;
    [CompilerGeneratedAttribute]
private static PackageIdentityComparer <VersionReleaseMetadata>k__BackingField;
    public static PackageIdentityComparer Default { get; }
    internal static PackageIdentityComparer Version { get; }
    internal static PackageIdentityComparer VersionRelease { get; }
    internal static PackageIdentityComparer VersionReleaseMetadata { get; }
    public PackageIdentityComparer(VersionComparison versionComparison);
    public PackageIdentityComparer(IVersionComparer versionComparer);
    private static PackageIdentityComparer();
    [CompilerGeneratedAttribute]
public static PackageIdentityComparer get_Default();
    [CompilerGeneratedAttribute]
internal static PackageIdentityComparer get_Version();
    [CompilerGeneratedAttribute]
internal static PackageIdentityComparer get_VersionRelease();
    [CompilerGeneratedAttribute]
internal static PackageIdentityComparer get_VersionReleaseMetadata();
    internal static PackageIdentityComparer Get(VersionComparison versionComparison);
    public sealed virtual bool Equals(PackageIdentity x, PackageIdentity y);
    public sealed virtual int GetHashCode(PackageIdentity obj);
    public sealed virtual int Compare(PackageIdentity x, PackageIdentity y);
}
public class NuGet.Packaging.Core.PackageType : object {
    public static Version EmptyVersion;
    public static PackageType Legacy;
    public static PackageType DotnetCliTool;
    public static PackageType Dependency;
    public static PackageType DotnetTool;
    public static PackageType SymbolsPackage;
    public static PackageType DotnetPlatform;
    public static StringComparer PackageTypeNameComparer;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    public string Name { get; }
    public Version Version { get; }
    public PackageType(string name, Version version);
    private static PackageType();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Version get_Version();
    public virtual bool Equals(object obj);
    public static bool op_Equality(PackageType a, PackageType b);
    public static bool op_Inequality(PackageType a, PackageType b);
    public sealed virtual bool Equals(PackageType other);
    public virtual int GetHashCode();
    public sealed virtual int CompareTo(PackageType other);
}
public static class NuGet.Packaging.Core.PackagingCoreConstants : object {
    public static string HashFileExtension;
    public static string NupkgExtension;
    public static string NuspecExtension;
    public static string PackageDownloadMarkerFileExtension;
    public static string NupkgMetadataFileExtension;
    public static string EmptyFolder;
    public static string ForwardSlashEmptyFolder;
    private static PackagingCoreConstants();
}
public class NuGet.Packaging.Core.PackagingException : Exception {
    private IPackLogMessage _logMessage;
    public PackagingException(string message);
    public PackagingException(NuGetLogCode logCode, string message);
    public PackagingException(NuGetLogCode logCode, string message, Exception innerException);
    public PackagingException(string message, Exception innerException);
    public virtual ILogMessage AsLogMessage();
}
public class NuGet.Packaging.Core.RepositoryMetadata : object {
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Branch>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Commit>k__BackingField;
    public string Type { get; public set; }
    public string Url { get; public set; }
    public string Branch { get; public set; }
    public string Commit { get; public set; }
    public RepositoryMetadata(string type, string url, string branch, string commit);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
    [CompilerGeneratedAttribute]
public string get_Branch();
    [CompilerGeneratedAttribute]
public void set_Branch(string value);
    [CompilerGeneratedAttribute]
public string get_Commit();
    [CompilerGeneratedAttribute]
public void set_Commit(string value);
    public virtual bool Equals(object obj);
    public static bool op_Equality(RepositoryMetadata a, RepositoryMetadata b);
    public static bool op_Inequality(RepositoryMetadata a, RepositoryMetadata b);
    public sealed virtual bool Equals(RepositoryMetadata other);
    public virtual int GetHashCode();
}
internal class NuGet.Packaging.EmptyFrameworkFolderFile : PhysicalPackageFile {
    public EmptyFrameworkFolderFile(string directoryPathInPackage);
}
public enum NuGet.Packaging.ExtractionSource : Enum {
    public int value__;
    public static ExtractionSource RestoreCommand;
    public static ExtractionSource DownloadResource;
    public static ExtractionSource NuGetFolderProject;
}
public class NuGet.Packaging.FallbackPackagePathInfo : object {
    [CompilerGeneratedAttribute]
private VersionFolderPathResolver <PathResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetVersion <Version>k__BackingField;
    public VersionFolderPathResolver PathResolver { get; }
    public string Id { get; }
    public NuGetVersion Version { get; }
    public FallbackPackagePathInfo(string id, NuGetVersion version, VersionFolderPathResolver resolver);
    [CompilerGeneratedAttribute]
public VersionFolderPathResolver get_PathResolver();
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public NuGetVersion get_Version();
}
public class NuGet.Packaging.FallbackPackagePathResolver : object {
    private List`1<VersionFolderPathResolver> _pathResolvers;
    public FallbackPackagePathResolver(INuGetPathContext pathContext);
    public FallbackPackagePathResolver(string userPackageFolder, IEnumerable`1<string> fallbackPackageFolders);
    public string GetPackageDirectory(string packageId, string version);
    public string GetPackageDirectory(string packageId, NuGetVersion version);
    public FallbackPackagePathInfo GetPackageInfo(string packageId, NuGetVersion version);
}
public class NuGet.Packaging.FrameworkAssemblyReference : object {
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<NuGetFramework> <SupportedFrameworks>k__BackingField;
    public string AssemblyName { get; private set; }
    public IEnumerable`1<NuGetFramework> SupportedFrameworks { get; private set; }
    public FrameworkAssemblyReference(string assemblyName, IEnumerable`1<NuGetFramework> supportedFrameworks);
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
private void set_AssemblyName(string value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<NuGetFramework> get_SupportedFrameworks();
    [CompilerGeneratedAttribute]
private void set_SupportedFrameworks(IEnumerable`1<NuGetFramework> value);
}
public static class NuGet.Packaging.FrameworkNameUtility : object {
    public static FrameworkName ParseFrameworkNameFromFilePath(string filePath, String& effectivePath);
    public static FrameworkName ParseFrameworkFolderName(string path, bool strictParsing, String& effectivePath);
    public static NuGetFramework ParseNuGetFrameworkFromFilePath(string filePath, String& effectivePath);
    public static NuGetFramework ParseNuGetFrameworkFolderName(string path, bool strictParsing, String& effectivePath);
}
public class NuGet.Packaging.FrameworkReference : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public FrameworkReference(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    public sealed virtual int Compare(FrameworkReference x, FrameworkReference y);
    public sealed virtual bool Equals(FrameworkReference other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual int CompareTo(FrameworkReference other);
}
public class NuGet.Packaging.FrameworkReferenceGroup : object {
    [CompilerGeneratedAttribute]
private NuGetFramework <TargetFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<FrameworkReference> <FrameworkReferences>k__BackingField;
    public NuGetFramework TargetFramework { get; }
    public IEnumerable`1<FrameworkReference> FrameworkReferences { get; }
    public FrameworkReferenceGroup(NuGetFramework targetFramework, IEnumerable`1<FrameworkReference> frameworkReferences);
    [CompilerGeneratedAttribute]
public sealed virtual NuGetFramework get_TargetFramework();
    [CompilerGeneratedAttribute]
public IEnumerable`1<FrameworkReference> get_FrameworkReferences();
    public sealed virtual bool Equals(FrameworkReferenceGroup other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
public static class NuGet.Packaging.FrameworksExtensions : object {
    [ExtensionAttribute]
public static string GetFrameworkString(NuGetFramework self);
}
public class NuGet.Packaging.FrameworkSpecificGroup : object {
    private NuGetFramework _targetFramework;
    private String[] _items;
    [CompilerGeneratedAttribute]
private bool <HasEmptyFolder>k__BackingField;
    public NuGetFramework TargetFramework { get; }
    public IEnumerable`1<string> Items { get; }
    public bool HasEmptyFolder { get; }
    public FrameworkSpecificGroup(NuGetFramework targetFramework, IEnumerable`1<string> items);
    public sealed virtual NuGetFramework get_TargetFramework();
    public IEnumerable`1<string> get_Items();
    [CompilerGeneratedAttribute]
public bool get_HasEmptyFolder();
    public sealed virtual bool Equals(FrameworkSpecificGroup other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public interface NuGet.Packaging.IAsyncPackageContentReader {
    public abstract virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetFrameworkItemsAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetBuildItemsAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetToolItemsAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetContentItemsAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetLibItemsAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetReferenceItemsAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<PackageDependencyGroup>> GetPackageDependenciesAsync(CancellationToken cancellationToken);
}
public interface NuGet.Packaging.IHashFunction {
    public abstract virtual string GetHash();
    public abstract virtual void Update(Byte[] data, int offset, int count);
}
public interface NuGet.Packaging.INuspecReader {
    public abstract virtual IEnumerable`1<PackageDependencyGroup> GetDependencyGroups();
    public abstract virtual IEnumerable`1<FrameworkSpecificGroup> GetReferenceGroups();
    public abstract virtual IEnumerable`1<FrameworkSpecificGroup> GetFrameworkReferenceGroups();
    public abstract virtual string GetLanguage();
}
public interface NuGet.Packaging.IPackageContentReader {
    public abstract virtual IEnumerable`1<FrameworkSpecificGroup> GetFrameworkItems();
    public abstract virtual IEnumerable`1<FrameworkSpecificGroup> GetBuildItems();
    public abstract virtual IEnumerable`1<FrameworkSpecificGroup> GetToolItems();
    public abstract virtual IEnumerable`1<FrameworkSpecificGroup> GetContentItems();
    public abstract virtual IEnumerable`1<FrameworkSpecificGroup> GetLibItems();
    public abstract virtual IEnumerable`1<FrameworkSpecificGroup> GetReferenceItems();
    public abstract virtual IEnumerable`1<PackageDependencyGroup> GetPackageDependencies();
}
public interface NuGet.Packaging.IPackageDownloader {
    public IAsyncPackageContentReader ContentReader { get; }
    public IAsyncPackageCoreReader CoreReader { get; }
    public ISignedPackageReader SignedPackageReader { get; }
    public string Source { get; }
    public abstract virtual IAsyncPackageContentReader get_ContentReader();
    public abstract virtual IAsyncPackageCoreReader get_CoreReader();
    public abstract virtual ISignedPackageReader get_SignedPackageReader();
    public abstract virtual string get_Source();
    public abstract virtual Task`1<bool> CopyNupkgFileToAsync(string destinationFilePath, CancellationToken cancellationToken);
    public abstract virtual Task`1<string> GetPackageHashAsync(string hashAlgorithm, CancellationToken cancellationToken);
    public abstract virtual void SetExceptionHandler(Func`2<Exception, Task`1<bool>> handleExceptionAsync);
    public abstract virtual void SetThrottle(SemaphoreSlim throttle);
}
public interface NuGet.Packaging.IPackageFile {
    public string Path { get; }
    public string EffectivePath { get; }
    [ObsoleteAttribute("Use NuGetFramework instead. This property will be null for any frameworks net5.0 or above.")]
public FrameworkName TargetFramework { get; }
    public NuGetFramework NuGetFramework { get; }
    public DateTimeOffset LastWriteTime { get; }
    public abstract virtual string get_Path();
    public abstract virtual string get_EffectivePath();
    public abstract virtual FrameworkName get_TargetFramework();
    public abstract virtual NuGetFramework get_NuGetFramework();
    public abstract virtual DateTimeOffset get_LastWriteTime();
    public abstract virtual Stream GetStream();
}
public interface NuGet.Packaging.IPackageMetadata {
    public string Id { get; }
    public NuGetVersion Version { get; }
    public string Title { get; }
    public IEnumerable`1<string> Authors { get; }
    public IEnumerable`1<string> Owners { get; }
    public Uri IconUrl { get; }
    public Uri LicenseUrl { get; }
    public Uri ProjectUrl { get; }
    public bool RequireLicenseAcceptance { get; }
    public bool DevelopmentDependency { get; }
    public string Description { get; }
    public string Summary { get; }
    public string ReleaseNotes { get; }
    public string Language { get; }
    public string Tags { get; }
    public bool Serviceable { get; }
    public string Copyright { get; }
    public string Icon { get; }
    public string Readme { get; }
    public IEnumerable`1<FrameworkAssemblyReference> FrameworkReferences { get; }
    public IEnumerable`1<PackageReferenceSet> PackageAssemblyReferences { get; }
    public IEnumerable`1<PackageDependencyGroup> DependencyGroups { get; }
    public Version MinClientVersion { get; }
    public IEnumerable`1<ManifestContentFiles> ContentFiles { get; }
    public IEnumerable`1<PackageType> PackageTypes { get; }
    public RepositoryMetadata Repository { get; }
    public LicenseMetadata LicenseMetadata { get; }
    public IEnumerable`1<FrameworkReferenceGroup> FrameworkReferenceGroups { get; }
    public abstract virtual string get_Id();
    public abstract virtual NuGetVersion get_Version();
    public abstract virtual string get_Title();
    public abstract virtual IEnumerable`1<string> get_Authors();
    public abstract virtual IEnumerable`1<string> get_Owners();
    public abstract virtual Uri get_IconUrl();
    public abstract virtual Uri get_LicenseUrl();
    public abstract virtual Uri get_ProjectUrl();
    public abstract virtual bool get_RequireLicenseAcceptance();
    public abstract virtual bool get_DevelopmentDependency();
    public abstract virtual string get_Description();
    public abstract virtual string get_Summary();
    public abstract virtual string get_ReleaseNotes();
    public abstract virtual string get_Language();
    public abstract virtual string get_Tags();
    public abstract virtual bool get_Serviceable();
    public abstract virtual string get_Copyright();
    public abstract virtual string get_Icon();
    public abstract virtual string get_Readme();
    public abstract virtual IEnumerable`1<FrameworkAssemblyReference> get_FrameworkReferences();
    public abstract virtual IEnumerable`1<PackageReferenceSet> get_PackageAssemblyReferences();
    public abstract virtual IEnumerable`1<PackageDependencyGroup> get_DependencyGroups();
    public abstract virtual Version get_MinClientVersion();
    public abstract virtual IEnumerable`1<ManifestContentFiles> get_ContentFiles();
    public abstract virtual IEnumerable`1<PackageType> get_PackageTypes();
    public abstract virtual RepositoryMetadata get_Repository();
    public abstract virtual LicenseMetadata get_LicenseMetadata();
    public abstract virtual IEnumerable`1<FrameworkReferenceGroup> get_FrameworkReferenceGroups();
}
public interface NuGet.Packaging.IPackageResolver {
    public abstract virtual IEnumerable`1<PackageIdentity> Resolve(IEnumerable`1<PackageIdentity> targets, IEnumerable`1<PackageDependencyInfo> availablePackages, CancellationToken token);
    public abstract virtual IEnumerable`1<PackageIdentity> Resolve(IEnumerable`1<PackageIdentity> targets, IEnumerable`1<PackageDependencyInfo> availablePackages, IEnumerable`1<PackageReference> installedPackages, CancellationToken token);
    public abstract virtual IEnumerable`1<PackageIdentity> Resolve(IEnumerable`1<string> targets, IEnumerable`1<PackageDependencyInfo> availablePackages, CancellationToken token);
    public abstract virtual IEnumerable`1<PackageIdentity> Resolve(IEnumerable`1<string> targets, IEnumerable`1<PackageDependencyInfo> availablePackages, IEnumerable`1<PackageReference> installedPackages, CancellationToken token);
}
public class NuGet.Packaging.LicenseMetadata : object {
    public static Version EmptyVersion;
    public static Version CurrentVersion;
    public static Uri LicenseFileDeprecationUrl;
    public static string LicenseServiceLinkTemplate;
    [CompilerGeneratedAttribute]
private LicenseType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <License>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetLicenseExpression <LicenseExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <WarningsAndErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    public LicenseType Type { get; }
    public string License { get; }
    public NuGetLicenseExpression LicenseExpression { get; }
    public IReadOnlyList`1<string> WarningsAndErrors { get; }
    public Version Version { get; }
    public Uri LicenseUrl { get; }
    public LicenseMetadata(LicenseType type, string license, NuGetLicenseExpression expression, IReadOnlyList`1<string> warningsAndErrors, Version version);
    private static LicenseMetadata();
    [CompilerGeneratedAttribute]
public LicenseType get_Type();
    [CompilerGeneratedAttribute]
public string get_License();
    [CompilerGeneratedAttribute]
public NuGetLicenseExpression get_LicenseExpression();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_WarningsAndErrors();
    [CompilerGeneratedAttribute]
public Version get_Version();
    public sealed virtual bool Equals(LicenseMetadata other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public Uri get_LicenseUrl();
    private static string GenerateLicenseServiceLink(string license);
}
public class NuGet.Packaging.Licenses.ExceptionData : object {
    [CompilerGeneratedAttribute]
private string <LicenseExceptionID>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDeprecatedLicenseId>k__BackingField;
    public string LicenseExceptionID { get; }
    public bool IsDeprecatedLicenseId { get; }
    public ExceptionData(string licenseID, bool isDeprecatedLicenseId);
    [CompilerGeneratedAttribute]
public string get_LicenseExceptionID();
    [CompilerGeneratedAttribute]
public bool get_IsDeprecatedLicenseId();
}
public class NuGet.Packaging.Licenses.LicenseData : object {
    [CompilerGeneratedAttribute]
private string <LicenseID>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOsiApproved>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDeprecatedLicenseId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFsfLibre>k__BackingField;
    public string LicenseID { get; }
    public bool IsOsiApproved { get; }
    public bool IsDeprecatedLicenseId { get; }
    public bool IsFsfLibre { get; }
    public LicenseData(string licenseID, bool isOsiApproved, bool isDeprecatedLicenseId, bool isFsfLibre);
    [CompilerGeneratedAttribute]
public string get_LicenseID();
    [CompilerGeneratedAttribute]
public bool get_IsOsiApproved();
    [CompilerGeneratedAttribute]
public bool get_IsDeprecatedLicenseId();
    [CompilerGeneratedAttribute]
public bool get_IsFsfLibre();
}
internal class NuGet.Packaging.Licenses.LicenseExpressionToken : object {
    [CompilerGeneratedAttribute]
private LicenseTokenType <TokenType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    internal LicenseTokenType TokenType { get; }
    internal string Value { get; }
    internal LicenseExpressionToken(string value, LicenseTokenType tokenType);
    [CompilerGeneratedAttribute]
internal LicenseTokenType get_TokenType();
    [CompilerGeneratedAttribute]
internal string get_Value();
    public virtual string ToString();
}
internal class NuGet.Packaging.Licenses.LicenseExpressionTokenizer : object {
    private string _value;
    internal LicenseExpressionTokenizer(string value);
    internal bool HasValidCharacters();
    [IteratorStateMachineAttribute("NuGet.Packaging.Licenses.LicenseExpressionTokenizer/<Tokenize>d__3")]
internal IEnumerable`1<LicenseExpressionToken> Tokenize();
    private LicenseExpressionToken ParseBracket(char bracket);
    private LicenseExpressionToken ParseTokenType(string token);
}
public enum NuGet.Packaging.Licenses.LicenseExpressionType : Enum {
    public int value__;
    public static LicenseExpressionType License;
    public static LicenseExpressionType Operator;
}
public abstract class NuGet.Packaging.Licenses.LicenseOperator : NuGetLicenseExpression {
    [CompilerGeneratedAttribute]
private LicenseOperatorType <OperatorType>k__BackingField;
    public LicenseOperatorType OperatorType { get; }
    protected LicenseOperator(LicenseOperatorType operatorType);
    [CompilerGeneratedAttribute]
public LicenseOperatorType get_OperatorType();
}
public enum NuGet.Packaging.Licenses.LicenseOperatorType : Enum {
    public int value__;
    public static LicenseOperatorType WithOperator;
    public static LicenseOperatorType LogicalOperator;
}
internal enum NuGet.Packaging.Licenses.LicenseTokenType : Enum {
    public int value__;
    public static LicenseTokenType WITH;
    public static LicenseTokenType AND;
    public static LicenseTokenType OR;
    public static LicenseTokenType OPENING_BRACKET;
    public static LicenseTokenType CLOSING_BRACKET;
    public static LicenseTokenType IDENTIFIER;
}
[ExtensionAttribute]
internal static class NuGet.Packaging.Licenses.LicenseTokenTypeExtensions : object {
    [ExtensionAttribute]
public static bool IsOperator(LicenseTokenType tokenType);
    [ExtensionAttribute]
public static bool IsValidPrecedingToken(LicenseTokenType current, LicenseTokenType precedingToken);
}
public class NuGet.Packaging.Licenses.LogicalOperator : LicenseOperator {
    [CompilerGeneratedAttribute]
private LogicalOperatorType <LogicalOperatorType>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetLicenseExpression <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetLicenseExpression <Right>k__BackingField;
    public LogicalOperatorType LogicalOperatorType { get; }
    public NuGetLicenseExpression Left { get; }
    public NuGetLicenseExpression Right { get; }
    public LogicalOperator(LogicalOperatorType logicalOperatorType, NuGetLicenseExpression left, NuGetLicenseExpression right);
    [CompilerGeneratedAttribute]
public LogicalOperatorType get_LogicalOperatorType();
    [CompilerGeneratedAttribute]
public NuGetLicenseExpression get_Left();
    [CompilerGeneratedAttribute]
public NuGetLicenseExpression get_Right();
    public virtual string ToString();
}
public enum NuGet.Packaging.Licenses.LogicalOperatorType : Enum {
    public int value__;
    public static LogicalOperatorType And;
    public static LogicalOperatorType Or;
}
public class NuGet.Packaging.Licenses.NuGetLicense : NuGetLicenseExpression {
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Plus>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStandardLicense>k__BackingField;
    internal static string UNLICENSED;
    public string Identifier { get; }
    public bool Plus { get; }
    public bool IsStandardLicense { get; }
    private NuGetLicense(string identifier, bool plus, bool isStandardLicense);
    private static NuGetLicense();
    [CompilerGeneratedAttribute]
public string get_Identifier();
    [CompilerGeneratedAttribute]
public bool get_Plus();
    [CompilerGeneratedAttribute]
public bool get_IsStandardLicense();
    internal static NuGetLicense ParseIdentifier(string licenseIdentifier, bool allowUnlicensed);
    private static bool HasValidCharacters(string value);
    private static NuGetLicense ProcessLicenseNotInStandardData(string licenseIdentifier, bool plus, bool allowUnlicensed);
    public virtual string ToString();
}
public static class NuGet.Packaging.Licenses.NuGetLicenseData : object {
    [CompilerGeneratedAttribute]
private static string <LicenseListVersion>k__BackingField;
    public static IReadOnlyDictionary`2<string, LicenseData> LicenseList;
    public static IReadOnlyDictionary`2<string, ExceptionData> ExceptionList;
    public static string LicenseListVersion { get; }
    private static NuGetLicenseData();
    [CompilerGeneratedAttribute]
public static string get_LicenseListVersion();
}
public class NuGet.Packaging.Licenses.NuGetLicenseException : object {
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    public string Identifier { get; }
    private NuGetLicenseException(string identifier);
    [CompilerGeneratedAttribute]
public string get_Identifier();
    internal static NuGetLicenseException ParseIdentifier(string exceptionIdentifier);
    public virtual string ToString();
}
public abstract class NuGet.Packaging.Licenses.NuGetLicenseExpression : object {
    [CompilerGeneratedAttribute]
private LicenseExpressionType <Type>k__BackingField;
    public LicenseExpressionType Type { get; protected set; }
    [CompilerGeneratedAttribute]
public LicenseExpressionType get_Type();
    [CompilerGeneratedAttribute]
protected void set_Type(LicenseExpressionType value);
    public static NuGetLicenseExpression Parse(string expression);
}
[ExtensionAttribute]
public static class NuGet.Packaging.Licenses.NuGetLicenseExpressionExtensions : object {
    [ExtensionAttribute]
public static bool HasOnlyStandardIdentifiers(NuGetLicenseExpression expression);
    [ExtensionAttribute]
public static void OnEachLeafNode(NuGetLicenseExpression expression, Action`1<NuGetLicense> licenseProcessor, Action`1<NuGetLicenseException> exceptionProcessor);
    [ExtensionAttribute]
public static bool IsUnlicensed(NuGetLicense license);
    [ExtensionAttribute]
public static bool IsUnlicensed(NuGetLicenseExpression expression);
}
internal static class NuGet.Packaging.Licenses.NuGetLicenseExpressionParser : object {
    internal static NuGetLicenseExpression Parse(string expression);
    private static IEnumerable`1<LicenseExpressionToken> GetTokens(string expression);
    private static void ProcessOperators(Stack`1<LicenseExpressionToken> operatorStack, Stack`1<Tuple`2<bool, object>> operandStack);
    private static Tuple`2<bool, object> PopIfNotEmpty(Stack`1<Tuple`2<bool, object>> operandStack);
}
public class NuGet.Packaging.Licenses.NuGetLicenseExpressionParsingException : Exception {
    public NuGetLicenseExpressionParsingException(string message);
    public NuGetLicenseExpressionParsingException(string message, Exception innerException);
    protected NuGetLicenseExpressionParsingException(SerializationInfo info, StreamingContext context);
}
public class NuGet.Packaging.Licenses.WithOperator : LicenseOperator {
    [CompilerGeneratedAttribute]
private NuGetLicense <License>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetLicenseException <Exception>k__BackingField;
    public NuGetLicense License { get; private set; }
    public NuGetLicenseException Exception { get; private set; }
    public WithOperator(NuGetLicense license, NuGetLicenseException exception);
    [CompilerGeneratedAttribute]
public NuGetLicense get_License();
    [CompilerGeneratedAttribute]
private void set_License(NuGetLicense value);
    [CompilerGeneratedAttribute]
public NuGetLicenseException get_Exception();
    [CompilerGeneratedAttribute]
private void set_Exception(NuGetLicenseException value);
    public virtual string ToString();
}
public enum NuGet.Packaging.LicenseType : Enum {
    public int value__;
    public static LicenseType File;
    public static LicenseType Expression;
}
[ObsoleteAttribute("Use NuGet.Protocol.LocalPackageArchiveDownloader")]
public class NuGet.Packaging.LocalPackageArchiveDownloader : object {
    private Func`2<Exception, Task`1<bool>> _handleExceptionAsync;
    private bool _isDisposed;
    private ILogger _logger;
    private string _packageFilePath;
    private PackageIdentity _packageIdentity;
    private Lazy`1<PackageArchiveReader> _packageReader;
    private Lazy`1<FileStream> _sourceStream;
    private SemaphoreSlim _throttle;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    public IAsyncPackageContentReader ContentReader { get; }
    public IAsyncPackageCoreReader CoreReader { get; }
    public ISignedPackageReader SignedPackageReader { get; }
    public string Source { get; }
    public LocalPackageArchiveDownloader(string source, string packageFilePath, PackageIdentity packageIdentity, ILogger logger);
    public sealed virtual IAsyncPackageContentReader get_ContentReader();
    public sealed virtual IAsyncPackageCoreReader get_CoreReader();
    public sealed virtual ISignedPackageReader get_SignedPackageReader();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Source();
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("NuGet.Packaging.LocalPackageArchiveDownloader/<CopyNupkgFileToAsync>d__19")]
public sealed virtual Task`1<bool> CopyNupkgFileToAsync(string destinationFilePath, CancellationToken cancellationToken);
    public sealed virtual Task`1<string> GetPackageHashAsync(string hashAlgorithm, CancellationToken cancellationToken);
    public sealed virtual void SetExceptionHandler(Func`2<Exception, Task`1<bool>> handleExceptionAsync);
    public sealed virtual void SetThrottle(SemaphoreSlim throttle);
    private PackageArchiveReader GetPackageReader();
    private FileStream GetSourceStream();
    private void ThrowIfDisposed();
}
public class NuGet.Packaging.Manifest : object {
    [CompilerGeneratedAttribute]
private ManifestMetadata <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<ManifestFile> <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasFilesNode>k__BackingField;
    public ManifestMetadata Metadata { get; }
    public ICollection`1<ManifestFile> Files { get; }
    public bool HasFilesNode { get; }
    public Manifest(ManifestMetadata metadata);
    public Manifest(ManifestMetadata metadata, ICollection`1<ManifestFile> files);
    [CompilerGeneratedAttribute]
public ManifestMetadata get_Metadata();
    [CompilerGeneratedAttribute]
public ICollection`1<ManifestFile> get_Files();
    [CompilerGeneratedAttribute]
public bool get_HasFilesNode();
    public void Save(Stream stream);
    public void Save(Stream stream, bool generateBackwardsCompatible);
    public void Save(Stream stream, int minimumManifestVersion);
    public void Save(Stream stream, int minimumManifestVersion, bool generateBackwardsCompatible);
    public static Manifest ReadFrom(Stream stream, bool validateSchema);
    public static Manifest ReadFrom(Stream stream, Func`2<string, string> propertyProvider, bool validateSchema);
    private static string GetSchemaNamespace(XDocument document);
    public static Manifest Create(IPackageMetadata metadata);
    private static void ValidateManifestSchema(XDocument document, string schemaNamespace);
    private static void CheckSchemaVersion(XDocument document);
    private static string GetPackageId(XElement metadataElement);
    private static XElement GetMetadataElement(XDocument document);
    public static void Validate(Manifest manifest);
    private static void ValidateDependencyGroups(IPackageMetadata metadata);
    private static void ValidateDependencyVersion(PackageDependency dependency);
}
public class NuGet.Packaging.ManifestContentFiles : object {
    [CompilerGeneratedAttribute]
private string <Include>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Exclude>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BuildAction>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CopyToOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Flatten>k__BackingField;
    public string Include { get; public set; }
    public string Exclude { get; public set; }
    public string BuildAction { get; public set; }
    public string CopyToOutput { get; public set; }
    public string Flatten { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Include();
    [CompilerGeneratedAttribute]
public void set_Include(string value);
    [CompilerGeneratedAttribute]
public string get_Exclude();
    [CompilerGeneratedAttribute]
public void set_Exclude(string value);
    [CompilerGeneratedAttribute]
public string get_BuildAction();
    [CompilerGeneratedAttribute]
public void set_BuildAction(string value);
    [CompilerGeneratedAttribute]
public string get_CopyToOutput();
    [CompilerGeneratedAttribute]
public void set_CopyToOutput(string value);
    [CompilerGeneratedAttribute]
public string get_Flatten();
    [CompilerGeneratedAttribute]
public void set_Flatten(string value);
}
public class NuGet.Packaging.ManifestFile : object {
    private static Char[] _invalidSourceCharacters;
    internal static Char[] ReferenceFileInvalidCharacters;
    private static Char[] _invalidTargetChars;
    private string _target;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Exclude>k__BackingField;
    public string Source { get; public set; }
    public string Target { get; public set; }
    public string Exclude { get; public set; }
    private static ManifestFile();
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(string value);
    public string get_Target();
    public void set_Target(string value);
    [CompilerGeneratedAttribute]
public string get_Exclude();
    [CompilerGeneratedAttribute]
public void set_Exclude(string value);
    [IteratorStateMachineAttribute("NuGet.Packaging.ManifestFile/<Validate>d__15")]
public IEnumerable`1<string> Validate();
}
public class NuGet.Packaging.ManifestMetadata : object {
    private string _minClientVersionString;
    private IEnumerable`1<string> _authors;
    private IEnumerable`1<string> _owners;
    private string _iconUrl;
    private string _licenseUrl;
    private string _projectUrl;
    [CompilerGeneratedAttribute]
private Version <MinClientVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Icon>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireLicenseAcceptance>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EmitRequireLicenseAcceptance>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DevelopmentDependency>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Summary>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReleaseNotes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Copyright>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Readme>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Serviceable>k__BackingField;
    [CompilerGeneratedAttribute]
private RepositoryMetadata <Repository>k__BackingField;
    private IEnumerable`1<PackageDependencyGroup> _dependencyGroups;
    [CompilerGeneratedAttribute]
private IEnumerable`1<FrameworkReferenceGroup> <FrameworkReferenceGroups>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<FrameworkAssemblyReference> <FrameworkReferences>k__BackingField;
    private IEnumerable`1<PackageReferenceSet> _packageAssemblyReferences;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ManifestContentFiles> <ContentFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<PackageType> <PackageTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private LicenseMetadata <LicenseMetadata>k__BackingField;
    [ManifestVersionAttribute("5")]
public string MinClientVersionString { get; public set; }
    public Version MinClientVersion { get; private set; }
    public string Id { get; public set; }
    public NuGetVersion Version { get; public set; }
    public string Title { get; public set; }
    public IEnumerable`1<string> Authors { get; public set; }
    public IEnumerable`1<string> Owners { get; public set; }
    public Uri IconUrl { get; }
    public string Icon { get; public set; }
    public Uri LicenseUrl { get; }
    public Uri ProjectUrl { get; }
    public bool RequireLicenseAcceptance { get; public set; }
    public bool EmitRequireLicenseAcceptance { get; public set; }
    public bool DevelopmentDependency { get; public set; }
    public string Description { get; public set; }
    public string Summary { get; public set; }
    [ManifestVersionAttribute("2")]
public string ReleaseNotes { get; public set; }
    [ManifestVersionAttribute("2")]
public string Copyright { get; public set; }
    public string Language { get; public set; }
    public string Tags { get; public set; }
    public string Readme { get; public set; }
    public bool Serviceable { get; public set; }
    public RepositoryMetadata Repository { get; public set; }
    public IEnumerable`1<PackageDependencyGroup> DependencyGroups { get; public set; }
    public IEnumerable`1<FrameworkReferenceGroup> FrameworkReferenceGroups { get; public set; }
    public IEnumerable`1<FrameworkAssemblyReference> FrameworkReferences { get; public set; }
    [ManifestVersionAttribute("2")]
public IEnumerable`1<PackageReferenceSet> PackageAssemblyReferences { get; public set; }
    public IEnumerable`1<ManifestContentFiles> ContentFiles { get; public set; }
    public IEnumerable`1<PackageType> PackageTypes { get; public set; }
    public LicenseMetadata LicenseMetadata { get; public set; }
    public ManifestMetadata(IPackageMetadata copy);
    public string get_MinClientVersionString();
    public void set_MinClientVersionString(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Version get_MinClientVersion();
    [CompilerGeneratedAttribute]
private void set_MinClientVersion(Version value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public sealed virtual NuGetVersion get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(NuGetVersion value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    public sealed virtual IEnumerable`1<string> get_Authors();
    public void set_Authors(IEnumerable`1<string> value);
    public sealed virtual IEnumerable`1<string> get_Owners();
    public void set_Owners(IEnumerable`1<string> value);
    public void SetIconUrl(string iconUrl);
    public sealed virtual Uri get_IconUrl();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Icon();
    [CompilerGeneratedAttribute]
public void set_Icon(string value);
    public void SetLicenseUrl(string licenseUrl);
    public sealed virtual Uri get_LicenseUrl();
    public void SetProjectUrl(string projectUrl);
    public sealed virtual Uri get_ProjectUrl();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RequireLicenseAcceptance();
    [CompilerGeneratedAttribute]
public void set_RequireLicenseAcceptance(bool value);
    [CompilerGeneratedAttribute]
public bool get_EmitRequireLicenseAcceptance();
    [CompilerGeneratedAttribute]
public void set_EmitRequireLicenseAcceptance(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_DevelopmentDependency();
    [CompilerGeneratedAttribute]
public void set_DevelopmentDependency(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Summary();
    [CompilerGeneratedAttribute]
public void set_Summary(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ReleaseNotes();
    [CompilerGeneratedAttribute]
public void set_ReleaseNotes(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Copyright();
    [CompilerGeneratedAttribute]
public void set_Copyright(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Language();
    [CompilerGeneratedAttribute]
public void set_Language(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Tags();
    [CompilerGeneratedAttribute]
public void set_Tags(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Readme();
    [CompilerGeneratedAttribute]
public void set_Readme(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Serviceable();
    [CompilerGeneratedAttribute]
public void set_Serviceable(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual RepositoryMetadata get_Repository();
    [CompilerGeneratedAttribute]
public void set_Repository(RepositoryMetadata value);
    public sealed virtual IEnumerable`1<PackageDependencyGroup> get_DependencyGroups();
    public void set_DependencyGroups(IEnumerable`1<PackageDependencyGroup> value);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<FrameworkReferenceGroup> get_FrameworkReferenceGroups();
    [CompilerGeneratedAttribute]
public void set_FrameworkReferenceGroups(IEnumerable`1<FrameworkReferenceGroup> value);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<FrameworkAssemblyReference> get_FrameworkReferences();
    [CompilerGeneratedAttribute]
public void set_FrameworkReferences(IEnumerable`1<FrameworkAssemblyReference> value);
    public sealed virtual IEnumerable`1<PackageReferenceSet> get_PackageAssemblyReferences();
    public void set_PackageAssemblyReferences(IEnumerable`1<PackageReferenceSet> value);
    private static IEnumerable`1<PackageReferenceSet> MergePackageAssemblyReferences(IEnumerable`1<PackageReferenceSet> referenceSets);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<ManifestContentFiles> get_ContentFiles();
    [CompilerGeneratedAttribute]
public void set_ContentFiles(IEnumerable`1<ManifestContentFiles> value);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<PackageType> get_PackageTypes();
    [CompilerGeneratedAttribute]
public void set_PackageTypes(IEnumerable`1<PackageType> value);
    [CompilerGeneratedAttribute]
public sealed virtual LicenseMetadata get_LicenseMetadata();
    [CompilerGeneratedAttribute]
public void set_LicenseMetadata(LicenseMetadata value);
    private static IEnumerable`1<PackageDependencyGroup> MergeDependencyGroups(IEnumerable`1<PackageDependencyGroup> actualDependencyGroups);
    private static PackageDependencyGroup CreatePackageDependencyGroup(PackageDependencyGroup dependencyGroup);
    [IteratorStateMachineAttribute("NuGet.Packaging.ManifestMetadata/<Validate>d__125")]
public IEnumerable`1<string> Validate();
}
internal static class NuGet.Packaging.ManifestReader : object {
    private static String[] RequiredElements;
    private static ManifestReader();
    public static Manifest ReadManifest(XDocument document);
    private static ManifestMetadata ReadMetadata(XElement xElement);
    private static void ReadMetadataValue(ManifestMetadata manifestMetadata, XElement element, HashSet`1<string> allElements);
    private static IEnumerable`1<FrameworkReferenceGroup> ReadFrameworkReferenceGroups(XElement frameworkReferenceGroupsElement);
    private static LicenseMetadata ReadLicenseMetadata(XElement licenseNode);
    private static List`1<ManifestContentFiles> ReadContentFiles(XElement contentFilesElement);
    private static List`1<PackageReferenceSet> ReadReferenceSets(XElement referencesElement);
    public static List`1<string> ReadReference(XElement referenceElement, bool throwIfEmpty);
    private static List`1<FrameworkAssemblyReference> ReadFrameworkAssemblies(XElement frameworkElement);
    private static List`1<PackageDependencyGroup> ReadDependencyGroups(XElement dependenciesElement);
    private static ISet`1<PackageDependency> ReadDependencies(XElement containerElement);
    private static List`1<ManifestFile> ReadFilesList(XElement xElement);
    private static RepositoryMetadata ReadRepository(XElement element);
}
public static class NuGet.Packaging.ManifestSchemaUtility : object {
    internal static string SchemaVersionV1;
    internal static string SchemaVersionV2;
    internal static string SchemaVersionV3;
    internal static string SchemaVersionV4;
    internal static string SchemaVersionV5;
    internal static string SchemaVersionV6;
    private static String[] VersionToSchemaMappings;
    private static ConcurrentDictionary`2<string, XmlSchemaSet> _manifestSchemaSetCache;
    private static ManifestSchemaUtility();
    public static int GetVersionFromNamespace(string namespace);
    public static string GetSchemaNamespace(int version);
    public static XmlSchemaSet GetManifestSchemaSet(string schemaNamespace);
    public static bool IsKnownSchema(string schemaNamespace);
}
[AttributeUsageAttribute("128")]
internal class NuGet.Packaging.ManifestVersionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    public int Version { get; private set; }
    public ManifestVersionAttribute(int version);
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(int value);
}
public static class NuGet.Packaging.ManifestVersionUtility : object {
    public static int DefaultVersion;
    public static int SemverVersion;
    public static int TargetFrameworkSupportForDependencyContentsAndToolsVersion;
    public static int TargetFrameworkSupportForReferencesVersion;
    public static int XdtTransformationVersion;
    public static int GetManifestVersion(ManifestMetadata metadata);
    private static int GetMaxVersionFromMetadata(ManifestMetadata metadata);
    private static int GetVersionFromObject(object obj);
    private static int GetVersionFromPropertyInfo(object obj, PropertyInfo property);
    private static int VisitList(IEnumerable list);
    private static Nullable`1<int> GetPropertyVersion(PropertyInfo property);
}
public class NuGet.Packaging.MinClientVersionException : PackagingException {
    public MinClientVersionException(string message);
    public virtual ILogMessage AsLogMessage();
}
public static class NuGet.Packaging.MinClientVersionUtility : object {
    private static NuGetVersion _clientVersion;
    public static void VerifyMinClientVersion(NuspecCoreReaderBase nuspecReader);
    public static bool IsMinClientVersionCompatible(NuspecCoreReaderBase nuspecReader);
    public static bool IsMinClientVersionCompatible(NuGetVersion packageMinClientVersion);
    public static NuGetVersion GetNuGetClientVersion();
}
internal static class NuGet.Packaging.NuGetExtractionFileIO : object {
    private static int _unixPermissions;
    private static Lazy`1<Func`2<string, FileStream>> _createFileMethod;
    private static NuGetExtractionFileIO();
    internal static FileStream CreateFile(string path);
    private static Func`2<string, FileStream> CreateFileMethodSelector();
    private static FileStream DotnetCoreCreateFile(string path);
    private static FileStream MonoPosixCreateFile(string path);
    private static void ApplyUMaskToUnixPermissions();
    private static bool ApplyUMaskToUnixPermissionsFromProcess();
    private static void ApplyUMaskToUnixPermissionsFromLibc();
    private static int PosixCreate(string pathname, int mode);
    private static int PosixChmod(string pathname, int mode);
    private static int PosixUMask(int mask);
}
public class NuGet.Packaging.NupkgMetadataFile : object {
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentHash>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    public int Version { get; public set; }
    public string ContentHash { get; public set; }
    public string Source { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(int value);
    [CompilerGeneratedAttribute]
public string get_ContentHash();
    [CompilerGeneratedAttribute]
public void set_ContentHash(string value);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(string value);
    public sealed virtual bool Equals(NupkgMetadataFile other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public static class NuGet.Packaging.NupkgMetadataFileFormat : object {
    public static int Version;
    private static string VersionProperty;
    private static string HashProperty;
    private static string SourceProperty;
    private static JsonSerializer JsonSerializer;
    private static NupkgMetadataFileFormat();
    public static NupkgMetadataFile Read(string filePath);
    public static NupkgMetadataFile Read(string filePath, ILogger log);
    public static NupkgMetadataFile Read(Stream stream, ILogger log, string path);
    public static NupkgMetadataFile Read(TextReader reader, ILogger log, string path);
    public static void Write(string filePath, NupkgMetadataFile hashFile);
    public static void Write(Stream stream, NupkgMetadataFile hashFile);
    public static void Write(TextWriter textWriter, NupkgMetadataFile hashFile);
    private static JsonSerializerSettings GetSerializerSettings();
}
public class NuGet.Packaging.NuspecReader : NuspecCoreReaderBase {
    private static string Dependencies;
    private static string Group;
    private static string TargetFramework;
    private static string Dependency;
    private static string References;
    private static string Reference;
    private static string File;
    private static string FrameworkAssemblies;
    private static string FrameworkAssembly;
    private static string AssemblyName;
    private static string Language;
    private static string ContentFiles;
    private static string Files;
    private static string BuildAction;
    private static string Flatten;
    private static string CopyToOutput;
    private static string IncludeFlags;
    private static string ExcludeFlags;
    private static string LicenseUrl;
    private static string Repository;
    private static string Icon;
    private static string Readme;
    private static Char[] CommaArray;
    private IFrameworkNameProvider _frameworkProvider;
    private static List`1<string> EmptyList;
    public NuspecReader(string path);
    public NuspecReader(string path, IFrameworkNameProvider frameworkProvider);
    public NuspecReader(Stream stream);
    public NuspecReader(XDocument xml);
    public NuspecReader(Stream stream, IFrameworkNameProvider frameworkProvider, bool leaveStreamOpen);
    public NuspecReader(XDocument xml, IFrameworkNameProvider frameworkProvider);
    private static NuspecReader();
    public IEnumerable`1<PackageDependencyGroup> GetDependencyGroups();
    [IteratorStateMachineAttribute("NuGet.Packaging.NuspecReader/<GetDependencyGroups>d__31")]
public IEnumerable`1<PackageDependencyGroup> GetDependencyGroups(bool useStrictVersionCheck);
    [IteratorStateMachineAttribute("NuGet.Packaging.NuspecReader/<GetReferenceGroups>d__32")]
public IEnumerable`1<FrameworkSpecificGroup> GetReferenceGroups();
    [ObsoleteAttribute("GetFrameworkReferenceGroups() is deprecated. Please use GetFrameworkAssemblyGroups() instead.")]
public IEnumerable`1<FrameworkSpecificGroup> GetFrameworkReferenceGroups();
    public IEnumerable`1<FrameworkSpecificGroup> GetFrameworkAssemblyGroups();
    public string GetLanguage();
    public string GetLicenseUrl();
    [IteratorStateMachineAttribute("NuGet.Packaging.NuspecReader/<GetContentFiles>d__37")]
public IEnumerable`1<ContentFilesEntry> GetContentFiles();
    public string GetTitle();
    public string GetAuthors();
    public string GetTags();
    public string GetOwners();
    public string GetDescription();
    public string GetReleaseNotes();
    public string GetSummary();
    public string GetProjectUrl();
    public string GetIconUrl();
    public string GetCopyright();
    public RepositoryMetadata GetRepositoryMetadata();
    public LicenseMetadata GetLicenseMetadata();
    private static IList`1<string> GetNonStandardLicenseIdentifiers(NuGetLicenseExpression expression);
    public bool GetRequireLicenseAcceptance();
    public IEnumerable`1<FrameworkReferenceGroup> GetFrameworkRefGroups();
    public string GetIcon();
    public string GetReadme();
    private Nullable`1<bool> AttributeAsNullableBool(XElement element, string attributeName);
    private static string GetAttributeValue(XElement element, string attributeName);
    private static List`1<string> GetFlags(string flags);
    private HashSet`1<PackageDependency> GetPackageDependencies(IEnumerable`1<XElement> nodes, bool useStrictVersionCheck);
}
public class NuGet.Packaging.PackageArchiveReader : PackageReaderBase {
    private ZipArchive _zipArchive;
    private SigningSpecifications _signingSpecifications;
    private IEnvironmentVariableReader _environmentVariableReader;
    [CompilerGeneratedAttribute]
private Stream <ZipReadStream>k__BackingField;
    private Nullable`1<bool> _isSigned;
    protected SigningSpecifications SigningSpecifications { get; }
    protected Stream ZipReadStream { get; protected set; }
    private PackageArchiveReader(IFrameworkNameProvider frameworkProvider, IFrameworkCompatibilityProvider compatibilityProvider);
    internal PackageArchiveReader(Stream stream, IEnvironmentVariableReader environmentVariableReader);
    public PackageArchiveReader(Stream stream);
    public PackageArchiveReader(Stream stream, IFrameworkNameProvider frameworkProvider, IFrameworkCompatibilityProvider compatibilityProvider);
    public PackageArchiveReader(Stream stream, bool leaveStreamOpen);
    public PackageArchiveReader(Stream stream, bool leaveStreamOpen, IFrameworkNameProvider frameworkProvider, IFrameworkCompatibilityProvider compatibilityProvider);
    public PackageArchiveReader(ZipArchive zipArchive);
    public PackageArchiveReader(ZipArchive zipArchive, IFrameworkNameProvider frameworkProvider, IFrameworkCompatibilityProvider compatibilityProvider);
    public PackageArchiveReader(string filePath, IFrameworkNameProvider frameworkProvider, IFrameworkCompatibilityProvider compatibilityProvider);
    protected SigningSpecifications get_SigningSpecifications();
    [CompilerGeneratedAttribute]
protected Stream get_ZipReadStream();
    [CompilerGeneratedAttribute]
protected void set_ZipReadStream(Stream value);
    public virtual IEnumerable`1<string> GetFiles();
    public virtual IEnumerable`1<string> GetFiles(string folder);
    public virtual Stream GetStream(string path);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageArchiveReader/<CopyNupkgAsync>d__22")]
public virtual Task`1<string> CopyNupkgAsync(string nupkgFilePath, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    public virtual IEnumerable`1<string> CopyFiles(string destination, IEnumerable`1<string> packageFiles, ExtractPackageFileDelegate extractFile, ILogger logger, CancellationToken token);
    public string ExtractFile(string packageFile, string targetFilePath, ILogger logger);
    public ZipArchiveEntry GetEntry(string packageFile);
    [IteratorStateMachineAttribute("NuGet.Packaging.PackageArchiveReader/<EnumeratePackageEntries>d__28")]
public IEnumerable`1<ZipFilePair> EnumeratePackageEntries(IEnumerable`1<string> packageFiles, string packageDirectory);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageArchiveReader/<ValidatePackageEntriesAsync>d__29")]
public Task ValidatePackageEntriesAsync(CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageArchiveReader/<GetPrimarySignatureAsync>d__30")]
public virtual Task`1<PrimarySignature> GetPrimarySignatureAsync(CancellationToken token);
    public virtual Task`1<bool> IsSignedAsync(CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageArchiveReader/<ValidateIntegrityAsync>d__32")]
public virtual Task ValidateIntegrityAsync(SignatureContent signatureContent, CancellationToken token);
    public virtual string GetContentHash(CancellationToken token, Func`1<string> GetUnsignedPackageHash);
    public virtual Task`1<Byte[]> GetArchiveHashAsync(HashAlgorithmName hashAlgorithmName, CancellationToken token);
    public virtual bool CanVerifySignedPackages(SignedPackageVerifierSettings verifierSettings);
    protected void ThrowIfZipReadStreamIsNull();
    private string GetContentHashForSignedPackage(CancellationToken token);
}
public class NuGet.Packaging.PackageBuilder : object {
    private static Uri DefaultUri;
    private static DateTime ZipFormatMinDate;
    private static DateTime ZipFormatMaxDate;
    internal static string ManifestRelationType;
    private bool _includeEmptyDirectories;
    private bool _deterministic;
    private ILogger _logger;
    public static int MaxIconFileSize;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private RepositoryMetadata <Repository>k__BackingField;
    [CompilerGeneratedAttribute]
private LicenseMetadata <LicenseMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasSnapshotVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <Authors>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <Owners>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <IconUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Icon>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <LicenseUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ProjectUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireLicenseAcceptance>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EmitRequireLicenseAcceptance>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Serviceable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DevelopmentDependency>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Summary>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReleaseNotes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputName>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Readme>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Copyright>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<PackageDependencyGroup> <DependencyGroups>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<IPackageFile> <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<FrameworkAssemblyReference> <FrameworkReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<FrameworkReferenceGroup> <FrameworkReferenceGroups>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<NuGetFramework> <TargetFrameworks>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<ManifestContentFiles> <ContentFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<PackageReferenceSet> <PackageAssemblyReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<PackageType> <PackageTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <MinClientVersion>k__BackingField;
    private static Char[] HexValues;
    public string Id { get; public set; }
    public NuGetVersion Version { get; public set; }
    public RepositoryMetadata Repository { get; public set; }
    public LicenseMetadata LicenseMetadata { get; public set; }
    public bool HasSnapshotVersion { get; public set; }
    public string Title { get; public set; }
    public ISet`1<string> Authors { get; private set; }
    public ISet`1<string> Owners { get; private set; }
    public Uri IconUrl { get; public set; }
    public string Icon { get; public set; }
    public Uri LicenseUrl { get; public set; }
    public Uri ProjectUrl { get; public set; }
    public bool RequireLicenseAcceptance { get; public set; }
    public bool EmitRequireLicenseAcceptance { get; public set; }
    public bool Serviceable { get; public set; }
    public bool DevelopmentDependency { get; public set; }
    public string Description { get; public set; }
    public string Summary { get; public set; }
    public string ReleaseNotes { get; public set; }
    public string Language { get; public set; }
    public string OutputName { get; public set; }
    public ISet`1<string> Tags { get; private set; }
    public string Readme { get; public set; }
    public Dictionary`2<string, string> Properties { get; private set; }
    public string Copyright { get; public set; }
    public Collection`1<PackageDependencyGroup> DependencyGroups { get; private set; }
    public ICollection`1<IPackageFile> Files { get; private set; }
    public Collection`1<FrameworkAssemblyReference> FrameworkReferences { get; private set; }
    public Collection`1<FrameworkReferenceGroup> FrameworkReferenceGroups { get; private set; }
    public IList`1<NuGetFramework> TargetFrameworks { get; public set; }
    public ICollection`1<ManifestContentFiles> ContentFiles { get; private set; }
    public ICollection`1<PackageReferenceSet> PackageAssemblyReferences { get; public set; }
    public ICollection`1<PackageType> PackageTypes { get; public set; }
    private IEnumerable`1<string> NuGet.Packaging.IPackageMetadata.Authors { get; }
    private IEnumerable`1<string> NuGet.Packaging.IPackageMetadata.Owners { get; }
    private string NuGet.Packaging.IPackageMetadata.Tags { get; }
    private IEnumerable`1<PackageReferenceSet> NuGet.Packaging.IPackageMetadata.PackageAssemblyReferences { get; }
    private IEnumerable`1<PackageDependencyGroup> NuGet.Packaging.IPackageMetadata.DependencyGroups { get; }
    private IEnumerable`1<FrameworkAssemblyReference> NuGet.Packaging.IPackageMetadata.FrameworkReferences { get; }
    private IEnumerable`1<ManifestContentFiles> NuGet.Packaging.IPackageMetadata.ContentFiles { get; }
    private IEnumerable`1<PackageType> NuGet.Packaging.IPackageMetadata.PackageTypes { get; }
    private IEnumerable`1<FrameworkReferenceGroup> NuGet.Packaging.IPackageMetadata.FrameworkReferenceGroups { get; }
    public Version MinClientVersion { get; public set; }
    public PackageBuilder(string path, Func`2<string, string> propertyProvider, bool includeEmptyDirectories);
    public PackageBuilder(string path, Func`2<string, string> propertyProvider, bool includeEmptyDirectories, bool deterministic);
    public PackageBuilder(string path, Func`2<string, string> propertyProvider, bool includeEmptyDirectories, bool deterministic, ILogger logger);
    public PackageBuilder(string path, string basePath, Func`2<string, string> propertyProvider, bool includeEmptyDirectories);
    public PackageBuilder(string path, string basePath, Func`2<string, string> propertyProvider, bool includeEmptyDirectories, bool deterministic, ILogger logger);
    public PackageBuilder(string path, string basePath, Func`2<string, string> propertyProvider, bool includeEmptyDirectories, bool deterministic);
    public PackageBuilder(Stream stream, string basePath);
    public PackageBuilder(Stream stream, string basePath, Func`2<string, string> propertyProvider);
    public PackageBuilder(bool deterministic);
    public PackageBuilder(bool deterministic, ILogger logger);
    private PackageBuilder(bool includeEmptyDirectories, bool deterministic);
    private PackageBuilder(bool includeEmptyDirectories, bool deterministic, ILogger logger);
    private static PackageBuilder();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public sealed virtual NuGetVersion get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(NuGetVersion value);
    [CompilerGeneratedAttribute]
public sealed virtual RepositoryMetadata get_Repository();
    [CompilerGeneratedAttribute]
public void set_Repository(RepositoryMetadata value);
    [CompilerGeneratedAttribute]
public sealed virtual LicenseMetadata get_LicenseMetadata();
    [CompilerGeneratedAttribute]
public void set_LicenseMetadata(LicenseMetadata value);
    [CompilerGeneratedAttribute]
public bool get_HasSnapshotVersion();
    [CompilerGeneratedAttribute]
public void set_HasSnapshotVersion(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public ISet`1<string> get_Authors();
    [CompilerGeneratedAttribute]
private void set_Authors(ISet`1<string> value);
    [CompilerGeneratedAttribute]
public ISet`1<string> get_Owners();
    [CompilerGeneratedAttribute]
private void set_Owners(ISet`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_IconUrl();
    [CompilerGeneratedAttribute]
public void set_IconUrl(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Icon();
    [CompilerGeneratedAttribute]
public void set_Icon(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_LicenseUrl();
    [CompilerGeneratedAttribute]
public void set_LicenseUrl(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_ProjectUrl();
    [CompilerGeneratedAttribute]
public void set_ProjectUrl(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RequireLicenseAcceptance();
    [CompilerGeneratedAttribute]
public void set_RequireLicenseAcceptance(bool value);
    [CompilerGeneratedAttribute]
public bool get_EmitRequireLicenseAcceptance();
    [CompilerGeneratedAttribute]
public void set_EmitRequireLicenseAcceptance(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Serviceable();
    [CompilerGeneratedAttribute]
public void set_Serviceable(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_DevelopmentDependency();
    [CompilerGeneratedAttribute]
public void set_DevelopmentDependency(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Summary();
    [CompilerGeneratedAttribute]
public void set_Summary(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ReleaseNotes();
    [CompilerGeneratedAttribute]
public void set_ReleaseNotes(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Language();
    [CompilerGeneratedAttribute]
public void set_Language(string value);
    [CompilerGeneratedAttribute]
public string get_OutputName();
    [CompilerGeneratedAttribute]
public void set_OutputName(string value);
    [CompilerGeneratedAttribute]
public ISet`1<string> get_Tags();
    [CompilerGeneratedAttribute]
private void set_Tags(ISet`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Readme();
    [CompilerGeneratedAttribute]
public void set_Readme(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Properties();
    [CompilerGeneratedAttribute]
private void set_Properties(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Copyright();
    [CompilerGeneratedAttribute]
public void set_Copyright(string value);
    [CompilerGeneratedAttribute]
public Collection`1<PackageDependencyGroup> get_DependencyGroups();
    [CompilerGeneratedAttribute]
private void set_DependencyGroups(Collection`1<PackageDependencyGroup> value);
    [CompilerGeneratedAttribute]
public ICollection`1<IPackageFile> get_Files();
    [CompilerGeneratedAttribute]
private void set_Files(ICollection`1<IPackageFile> value);
    [CompilerGeneratedAttribute]
public Collection`1<FrameworkAssemblyReference> get_FrameworkReferences();
    [CompilerGeneratedAttribute]
private void set_FrameworkReferences(Collection`1<FrameworkAssemblyReference> value);
    [CompilerGeneratedAttribute]
public Collection`1<FrameworkReferenceGroup> get_FrameworkReferenceGroups();
    [CompilerGeneratedAttribute]
private void set_FrameworkReferenceGroups(Collection`1<FrameworkReferenceGroup> value);
    [CompilerGeneratedAttribute]
public IList`1<NuGetFramework> get_TargetFrameworks();
    [CompilerGeneratedAttribute]
public void set_TargetFrameworks(IList`1<NuGetFramework> value);
    [CompilerGeneratedAttribute]
public ICollection`1<ManifestContentFiles> get_ContentFiles();
    [CompilerGeneratedAttribute]
private void set_ContentFiles(ICollection`1<ManifestContentFiles> value);
    [CompilerGeneratedAttribute]
public ICollection`1<PackageReferenceSet> get_PackageAssemblyReferences();
    [CompilerGeneratedAttribute]
public void set_PackageAssemblyReferences(ICollection`1<PackageReferenceSet> value);
    [CompilerGeneratedAttribute]
public ICollection`1<PackageType> get_PackageTypes();
    [CompilerGeneratedAttribute]
public void set_PackageTypes(ICollection`1<PackageType> value);
    private sealed virtual override IEnumerable`1<string> NuGet.Packaging.IPackageMetadata.get_Authors();
    private sealed virtual override IEnumerable`1<string> NuGet.Packaging.IPackageMetadata.get_Owners();
    private sealed virtual override string NuGet.Packaging.IPackageMetadata.get_Tags();
    private sealed virtual override IEnumerable`1<PackageReferenceSet> NuGet.Packaging.IPackageMetadata.get_PackageAssemblyReferences();
    private sealed virtual override IEnumerable`1<PackageDependencyGroup> NuGet.Packaging.IPackageMetadata.get_DependencyGroups();
    private sealed virtual override IEnumerable`1<FrameworkAssemblyReference> NuGet.Packaging.IPackageMetadata.get_FrameworkReferences();
    private sealed virtual override IEnumerable`1<ManifestContentFiles> NuGet.Packaging.IPackageMetadata.get_ContentFiles();
    private sealed virtual override IEnumerable`1<PackageType> NuGet.Packaging.IPackageMetadata.get_PackageTypes();
    private sealed virtual override IEnumerable`1<FrameworkReferenceGroup> NuGet.Packaging.IPackageMetadata.get_FrameworkReferenceGroups();
    [CompilerGeneratedAttribute]
public sealed virtual Version get_MinClientVersion();
    [CompilerGeneratedAttribute]
public void set_MinClientVersion(Version value);
    public void Save(Stream stream);
    private static Byte[] ReadAllBytes(Stream stream);
    private string CalcPsmdcpName();
    internal static string EncodeHexString(Byte[] sArray);
    private static string CreatorInfo();
    private static int DetermineMinimumSchemaVersion(ICollection`1<IPackageFile> Files, ICollection`1<PackageDependencyGroup> package);
    private static bool RequiresV4TargetFrameworkSchema(ICollection`1<IPackageFile> files);
    private static bool HasContentFilesV2(ICollection`1<IPackageFile> contentFiles);
    private static bool HasIncludeExclude(IEnumerable`1<PackageDependencyGroup> dependencyGroups);
    private static bool HasXdtTransformFile(ICollection`1<IPackageFile> contentFiles);
    private static void ValidateDependencies(SemanticVersion version, IEnumerable`1<PackageDependencyGroup> dependencies);
    public static void ValidateReferenceAssemblies(IEnumerable`1<IPackageFile> files, IEnumerable`1<PackageReferenceSet> packageAssemblyReferences);
    private static void ValidateFrameworkAssemblies(IEnumerable`1<FrameworkAssemblyReference> references, IEnumerable`1<FrameworkReferenceGroup> referenceGroups);
    private static IPackageFile FindFileInPackage(string filePath, IEnumerable`1<IPackageFile> packageFiles, String& filePathIncorrectCase);
    private void ValidateFilesUnique(IEnumerable`1<IPackageFile> files);
    private void ValidateLicenseFile(IEnumerable`1<IPackageFile> files, LicenseMetadata licenseMetadata);
    private void ValidateIconFile(IEnumerable`1<IPackageFile> files, string iconPath);
    private static void ValidateFileFrameworks(IEnumerable`1<IPackageFile> files);
    private void ValidateReadmeFile(IEnumerable`1<IPackageFile> files, string readmePath);
    private void ReadManifest(Stream stream, string basePath, Func`2<string, string> propertyProvider);
    public void Populate(ManifestMetadata manifestMetadata);
    public void PopulateFiles(string basePath, IEnumerable`1<ManifestFile> files);
    private ZipArchiveEntry CreateEntry(ZipArchive package, string entryName, CompressionLevel compressionLevel);
    private static ZipArchiveEntry CreatePackageFileEntry(ZipArchive package, string entryName, DateTimeOffset timeOffset, CompressionLevel compressionLevel, StringBuilder warningMessage);
    private void WriteManifest(ZipArchive package, int minimumManifestVersion, string psmdcpPath);
    private HashSet`1<string> WriteFiles(ZipArchive package, HashSet`1<string> filesWithoutExtensions);
    public void AddFiles(string basePath, string source, string destination, string exclude);
    internal static IEnumerable`1<PhysicalPackageFile> ResolveSearchPattern(string basePath, string searchPath, string targetPath, bool includeEmptyDirectories);
    internal static string ResolvePackagePath(string searchDirectory, string searchPattern, string fullPath, string targetPath);
    private static bool IsKnownFolder(string targetPath);
    private static void ExcludeFiles(List`1<PhysicalPackageFile> searchFiles, string basePath, string exclude);
    private void CreatePart(ZipArchive package, string path, Stream sourceStream, DateTimeOffset lastWriteTime, StringBuilder warningMessage);
    internal static string CreatePartEntryName(string path);
    internal static string GetStringForPartUri(string escapedPath);
    private static IEnumerable`1<string> ParseTags(string tags);
    private void WriteOpcManifestRelationship(ZipArchive package, string path, string psmdcpPath);
    private void WriteOpcContentTypes(ZipArchive package, HashSet`1<string> extensions, HashSet`1<string> filesWithoutExtensions);
    private void WriteOpcPackageProperties(ZipArchive package, string psmdcpPath);
    private string GenerateRelationshipId(string path);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "16.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class NuGet.Packaging.PackageCreation.Resources.NuGetResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string CannotCreateEmptyPackage { get; }
    internal static string DependencyHasInvalidVersion { get; }
    internal static string DuplicateDependenciesDefined { get; }
    internal static string FoundDuplicateFile { get; }
    internal static string IconCannotOpenFile { get; }
    internal static string IconErrorEmpty { get; }
    internal static string IconInvalidExtension { get; }
    internal static string IconMaxFileSizeExceeded { get; }
    internal static string IconMissingRequiredValue { get; }
    internal static string IconNoFileElement { get; }
    internal static string IconNoFileElementWithHint { get; }
    internal static string IncompatibleSchema { get; }
    internal static string InvalidPackageId { get; }
    internal static string Manifest_DependenciesHasMixedElements { get; }
    internal static string Manifest_ExcludeContainsInvalidCharacters { get; }
    internal static string Manifest_IdMaxLengthExceeded { get; }
    internal static string Manifest_InvalidMinClientVersion { get; }
    internal static string Manifest_InvalidReference { get; }
    internal static string Manifest_InvalidReferenceFile { get; }
    internal static string Manifest_LicenseFileExtensionIsInvalid { get; }
    internal static string Manifest_LicenseFileIsNotInNupkg { get; }
    internal static string Manifest_LicenseFileIsNotInNupkgWithHint { get; }
    internal static string Manifest_LicenseUrlCannotBeUsedWithLicenseMetadata { get; }
    internal static string Manifest_PropertyValueReadFailure { get; }
    internal static string Manifest_ReferencesHasMixedElements { get; }
    internal static string Manifest_ReferencesIsEmpty { get; }
    internal static string Manifest_RequiredElementMissing { get; }
    internal static string Manifest_RequiredMetadataMissing { get; }
    internal static string Manifest_RequireLicenseAcceptanceRequiresEmit { get; }
    internal static string Manifest_RequireLicenseAcceptanceRequiresLicenseUrl { get; }
    internal static string Manifest_SourceContainsInvalidCharacters { get; }
    internal static string Manifest_TargetContainsInvalidCharacters { get; }
    internal static string Manifest_UriCannotBeEmpty { get; }
    internal static string PackageAuthoring_FileNotFound { get; }
    internal static string ReadmeCannotOpenFile { get; }
    internal static string ReadmeErrorEmpty { get; }
    internal static string ReadmeFileExtensionIsInvalid { get; }
    internal static string ReadmeMissingRequiredValue { get; }
    internal static string ReadmeNoFileElement { get; }
    internal static string UnknownSchemaVersion { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_CannotCreateEmptyPackage();
    internal static string get_DependencyHasInvalidVersion();
    internal static string get_DuplicateDependenciesDefined();
    internal static string get_FoundDuplicateFile();
    internal static string get_IconCannotOpenFile();
    internal static string get_IconErrorEmpty();
    internal static string get_IconInvalidExtension();
    internal static string get_IconMaxFileSizeExceeded();
    internal static string get_IconMissingRequiredValue();
    internal static string get_IconNoFileElement();
    internal static string get_IconNoFileElementWithHint();
    internal static string get_IncompatibleSchema();
    internal static string get_InvalidPackageId();
    internal static string get_Manifest_DependenciesHasMixedElements();
    internal static string get_Manifest_ExcludeContainsInvalidCharacters();
    internal static string get_Manifest_IdMaxLengthExceeded();
    internal static string get_Manifest_InvalidMinClientVersion();
    internal static string get_Manifest_InvalidReference();
    internal static string get_Manifest_InvalidReferenceFile();
    internal static string get_Manifest_LicenseFileExtensionIsInvalid();
    internal static string get_Manifest_LicenseFileIsNotInNupkg();
    internal static string get_Manifest_LicenseFileIsNotInNupkgWithHint();
    internal static string get_Manifest_LicenseUrlCannotBeUsedWithLicenseMetadata();
    internal static string get_Manifest_PropertyValueReadFailure();
    internal static string get_Manifest_ReferencesHasMixedElements();
    internal static string get_Manifest_ReferencesIsEmpty();
    internal static string get_Manifest_RequiredElementMissing();
    internal static string get_Manifest_RequiredMetadataMissing();
    internal static string get_Manifest_RequireLicenseAcceptanceRequiresEmit();
    internal static string get_Manifest_RequireLicenseAcceptanceRequiresLicenseUrl();
    internal static string get_Manifest_SourceContainsInvalidCharacters();
    internal static string get_Manifest_TargetContainsInvalidCharacters();
    internal static string get_Manifest_UriCannotBeEmpty();
    internal static string get_PackageAuthoring_FileNotFound();
    internal static string get_ReadmeCannotOpenFile();
    internal static string get_ReadmeErrorEmpty();
    internal static string get_ReadmeFileExtensionIsInvalid();
    internal static string get_ReadmeMissingRequiredValue();
    internal static string get_ReadmeNoFileElement();
    internal static string get_UnknownSchemaVersion();
}
public class NuGet.Packaging.PackageDependencyGroup : object {
    private NuGetFramework _targetFramework;
    private IEnumerable`1<PackageDependency> _packages;
    public NuGetFramework TargetFramework { get; }
    public IEnumerable`1<PackageDependency> Packages { get; }
    public PackageDependencyGroup(NuGetFramework targetFramework, IEnumerable`1<PackageDependency> packages);
    public sealed virtual NuGetFramework get_TargetFramework();
    public IEnumerable`1<PackageDependency> get_Packages();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(PackageDependencyGroup other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public static class NuGet.Packaging.PackageExtraction.PackageExtractionBehavior : object {
    private static string XmlDocFileSaveModeEnvironmentKey;
    private static Nullable`1<XmlDocFileSaveMode> _xmlDocFileSaveMode;
    public static XmlDocFileSaveMode XmlDocFileSaveMode { get; public set; }
    public static XmlDocFileSaveMode get_XmlDocFileSaveMode();
    public static void set_XmlDocFileSaveMode(XmlDocFileSaveMode value);
}
public class NuGet.Packaging.PackageExtractionContext : object {
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageSaveMode <PackageSaveMode>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDocFileSaveMode <XmlDocFileSaveMode>k__BackingField;
    [CompilerGeneratedAttribute]
private ClientPolicyContext <ClientPolicyContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CopySatelliteFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private IPackageSignatureVerifier <SignedPackageVerifier>k__BackingField;
    public ILogger Logger { get; }
    public PackageSaveMode PackageSaveMode { get; public set; }
    public XmlDocFileSaveMode XmlDocFileSaveMode { get; public set; }
    public ClientPolicyContext ClientPolicyContext { get; }
    public bool CopySatelliteFiles { get; public set; }
    public IPackageSignatureVerifier SignedPackageVerifier { get; public set; }
    public PackageExtractionContext(PackageSaveMode packageSaveMode, XmlDocFileSaveMode xmlDocFileSaveMode, ClientPolicyContext clientPolicyContext, ILogger logger);
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
public PackageSaveMode get_PackageSaveMode();
    [CompilerGeneratedAttribute]
public void set_PackageSaveMode(PackageSaveMode value);
    [CompilerGeneratedAttribute]
public XmlDocFileSaveMode get_XmlDocFileSaveMode();
    [CompilerGeneratedAttribute]
public void set_XmlDocFileSaveMode(XmlDocFileSaveMode value);
    [CompilerGeneratedAttribute]
public ClientPolicyContext get_ClientPolicyContext();
    [CompilerGeneratedAttribute]
public bool get_CopySatelliteFiles();
    [CompilerGeneratedAttribute]
public void set_CopySatelliteFiles(bool value);
    [CompilerGeneratedAttribute]
public IPackageSignatureVerifier get_SignedPackageVerifier();
    [CompilerGeneratedAttribute]
public void set_SignedPackageVerifier(IPackageSignatureVerifier value);
}
public class NuGet.Packaging.PackageExtractionResult : object {
    [CompilerGeneratedAttribute]
private bool <Cached>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <SignVerifyDelay>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageSignType <PackageType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Success>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Duration>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <SignVerifyStartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <SignVerifyEndTime>k__BackingField;
    public bool Cached { get; }
    public TimeSpan SignVerifyDelay { get; }
    public PackageSignType PackageType { get; }
    public bool Success { get; }
    public TimeSpan Duration { get; public set; }
    public DateTimeOffset SignVerifyStartTime { get; }
    public DateTimeOffset SignVerifyEndTime { get; }
    public PackageExtractionResult(bool cached, TimeSpan signVerifyDelay, PackageSignType packageType, bool success, DateTimeOffset signVerifyStartTime, DateTimeOffset signVerifyEndTime);
    public PackageExtractionResult(bool cached, TimeSpan signVerifyDelay, PackageSignType packageType, bool success, TimeSpan duration);
    [CompilerGeneratedAttribute]
public bool get_Cached();
    [CompilerGeneratedAttribute]
public TimeSpan get_SignVerifyDelay();
    [CompilerGeneratedAttribute]
public PackageSignType get_PackageType();
    [CompilerGeneratedAttribute]
public bool get_Success();
    [CompilerGeneratedAttribute]
public TimeSpan get_Duration();
    [CompilerGeneratedAttribute]
public void set_Duration(TimeSpan value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_SignVerifyStartTime();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_SignVerifyEndTime();
}
public class NuGet.Packaging.PackageExtractionTelemetryEvent : TelemetryEvent {
    public static string EventName;
    public PackageSaveMode PackageSaveMode { get; }
    public NuGetOperationStatus Status { get; }
    public ExtractionSource ExtractionSource { get; }
    public string PackageId { get; }
    public string PackageVersion { get; }
    public PackageExtractionTelemetryEvent(PackageSaveMode packageSaveMode, NuGetOperationStatus status, ExtractionSource extractionSource, PackageIdentity packageId);
    public PackageSaveMode get_PackageSaveMode();
    public NuGetOperationStatus get_Status();
    public ExtractionSource get_ExtractionSource();
    public string get_PackageId();
    public string get_PackageVersion();
    public void LogPackageIdentity(PackageIdentity packageId);
    public void SetResult(NuGetOperationStatus status);
}
public static class NuGet.Packaging.PackageExtractor : object {
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageExtractor/<ExtractPackageAsync>d__0")]
public static Task`1<IEnumerable`1<string>> ExtractPackageAsync(string source, Stream packageStream, PackagePathResolver packagePathResolver, PackageExtractionContext packageExtractionContext, CancellationToken token, Guid parentId);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageExtractor/<ExtractPackageAsync>d__1")]
public static Task`1<IEnumerable`1<string>> ExtractPackageAsync(string source, PackageReaderBase packageReader, Stream packageStream, PackagePathResolver packagePathResolver, PackageExtractionContext packageExtractionContext, CancellationToken token, Guid parentId);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageExtractor/<ExtractPackageAsync>d__2")]
public static Task`1<IEnumerable`1<string>> ExtractPackageAsync(string source, PackageReaderBase packageReader, PackagePathResolver packagePathResolver, PackageExtractionContext packageExtractionContext, CancellationToken token, Guid parentId);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageExtractor/<InstallFromSourceAsync>d__3")]
public static Task`1<bool> InstallFromSourceAsync(string source, PackageIdentity packageIdentity, Func`2<Stream, Task> copyToAsync, VersionFolderPathResolver versionFolderPathResolver, PackageExtractionContext packageExtractionContext, CancellationToken token, Guid parentId);
    private static void DeleteTargetAndTempPaths(string targetPath, string targetTempNupkg);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageExtractor/<InstallFromSourceAsync>d__5")]
public static Task`1<bool> InstallFromSourceAsync(PackageIdentity packageIdentity, IPackageDownloader packageDownloader, VersionFolderPathResolver versionFolderPathResolver, PackageExtractionContext packageExtractionContext, CancellationToken token, Guid parentId);
    private static bool ShouldInclude(string fullName, string hashFileName, string nupkgMetadataFileName);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageExtractor/<CopySatelliteFilesAsync>d__7")]
public static Task`1<IEnumerable`1<string>> CopySatelliteFilesAsync(PackageIdentity packageIdentity, PackagePathResolver packagePathResolver, PackageSaveMode packageSaveMode, PackageExtractionContext packageExtractionContext, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageExtractor/<CopySatelliteFilesAsync>d__8")]
private static Task`1<IEnumerable`1<string>> CopySatelliteFilesAsync(PackageReaderBase packageReader, PackagePathResolver packagePathResolver, PackageSaveMode packageSaveMode, PackageExtractionContext packageExtractionContext, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageExtractor/<VerifyPackageSignatureAsync>d__9")]
private static Task VerifyPackageSignatureAsync(string source, Guid parentId, PackageIdentity package, PackageExtractionContext packageExtractionContext, ISignedPackageReader signedPackageReader, CancellationToken token);
    private static void UpdateSignatureLog(string source, PackageIdentity package, ClientPolicyContext policyContext, SignatureLog message);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageExtractor/<LogPackageSignatureVerificationAsync>d__11")]
private static Task LogPackageSignatureVerificationAsync(string source, PackageIdentity package, ILogger logger, VerifySignaturesResult verifyResult);
    private static RepositorySignatureInfo GetRepositorySignatureInfo(string source);
}
public class NuGet.Packaging.PackageFileExtractor : object {
    private HashSet`1<string> _intellisenseXmlFiles;
    private XmlDocFileSaveMode _xmlDocFileSaveMode;
    public PackageFileExtractor(IEnumerable`1<string> packageFiles, XmlDocFileSaveMode xmlDocFileSaveMode);
    private static HashSet`1<string> GatherIntellisenseXmlFiles(IEnumerable`1<string> packageFiles);
    private static string GetBinaryForLanguageSpecificXml(string file);
    public string ExtractPackageFile(string source, string target, Stream stream);
}
public class NuGet.Packaging.PackageFolderReader : PackageReaderBase {
    private DirectoryInfo _root;
    public PackageFolderReader(string folderPath);
    public PackageFolderReader(DirectoryInfo folder);
    public PackageFolderReader(string folderPath, IFrameworkNameProvider frameworkProvider, IFrameworkCompatibilityProvider compatibilityProvider);
    public PackageFolderReader(DirectoryInfo folder, IFrameworkNameProvider frameworkProvider, IFrameworkCompatibilityProvider compatibilityProvider);
    public virtual string GetNuspecFile();
    public virtual Stream GetStream(string path);
    private FileInfo GetFile(string path);
    public virtual IEnumerable`1<string> GetFiles();
    [IteratorStateMachineAttribute("NuGet.Packaging.PackageFolderReader/<GetFiles>d__9")]
public virtual IEnumerable`1<string> GetFiles(string folder);
    private static bool IsFileInRoot(string path);
    private static bool IsNupkg(string path);
    private static string GetRelativePath(DirectoryInfo root, FileInfo file);
    public virtual IEnumerable`1<string> CopyFiles(string destination, IEnumerable`1<string> packageFiles, ExtractPackageFileDelegate extractFile, ILogger logger, CancellationToken token);
    protected virtual void Dispose(bool disposing);
    public virtual Task`1<PrimarySignature> GetPrimarySignatureAsync(CancellationToken token);
    public virtual Task`1<bool> IsSignedAsync(CancellationToken token);
    public virtual Task ValidateIntegrityAsync(SignatureContent signatureContent, CancellationToken token);
    public virtual Task`1<Byte[]> GetArchiveHashAsync(HashAlgorithmName hashAlgorithm, CancellationToken token);
    public virtual bool CanVerifySignedPackages(SignedPackageVerifierSettings verifierSettings);
    public virtual string GetContentHash(CancellationToken token, Func`1<string> GetUnsignedPackageHash);
}
public static class NuGet.Packaging.PackageHelper : object {
    private static String[] ExcludePaths;
    private static Char[] Slashes;
    private static PackageHelper();
    public static bool IsAssembly(string path);
    public static bool IsNuspec(string path);
    public static bool IsManifest(string path);
    public static bool IsRoot(string path);
    public static bool IsPackageFile(string packageFileName, PackageSaveMode packageSaveMode);
    private static bool IsNuGetGeneratedFile(string path);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageHelper/<GetSatellitePackageInfoAsync>d__8")]
private static Task`1<SatellitePackageInfo> GetSatellitePackageInfoAsync(IAsyncPackageCoreReader packageReader, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageHelper/<GetSatelliteFilesAsync>d__9")]
public static Task`1<Tuple`2<string, IEnumerable`1<string>>> GetSatelliteFilesAsync(PackageReaderBase packageReader, PackagePathResolver packagePathResolver, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageHelper/<GetInstalledPackageFilesAsync>d__10")]
public static Task`1<IEnumerable`1<ZipFilePair>> GetInstalledPackageFilesAsync(PackageArchiveReader packageReader, PackageIdentity packageIdentity, PackagePathResolver packagePathResolver, PackageSaveMode packageSaveMode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageHelper/<GetInstalledSatelliteFilesAsync>d__11")]
public static Task`1<Tuple`2<string, IEnumerable`1<ZipFilePair>>> GetInstalledSatelliteFilesAsync(PackageArchiveReader packageReader, PackagePathResolver packagePathResolver, PackageSaveMode packageSaveMode, CancellationToken cancellationToken);
}
public static class NuGet.Packaging.PackageIdValidator : object {
    public static int MaxPackageIdLength;
    private static Regex IdRegex;
    private static PackageIdValidator();
    public static bool IsValidPackageId(string packageId);
    public static void ValidatePackageId(string packageId);
}
public static class NuGet.Packaging.PackagePathHelper : object {
    internal static IEnumerable`1<string> GetFiles(string root, string path, string filter, bool recursive);
    internal static IEnumerable`1<string> GetDirectories(string root, string path);
    [IteratorStateMachineAttribute("NuGet.Packaging.PackagePathHelper/<GetPackageFiles>d__2")]
private static IEnumerable`1<string> GetPackageFiles(string root, string filter);
    private static bool FileNameMatchesPattern(PackageIdentity packageIdentity, string path);
    public static IEnumerable`1<string> GetPackageLookupPaths(PackageIdentity packageIdentity, PackagePathResolver packagePathResolver);
    public static string GetInstalledPackageFilePath(PackageIdentity packageIdentity, PackagePathResolver packagePathResolver);
}
public class NuGet.Packaging.PackagePathResolver : object {
    private string _rootDirectory;
    [CompilerGeneratedAttribute]
private bool <UseSideBySidePaths>k__BackingField;
    public bool UseSideBySidePaths { get; }
    protected internal string Root { get; }
    public PackagePathResolver(string rootDirectory, bool useSideBySidePaths);
    [CompilerGeneratedAttribute]
public bool get_UseSideBySidePaths();
    protected internal string get_Root();
    public virtual string GetPackageDirectoryName(PackageIdentity packageIdentity);
    public virtual string GetPackageFileName(PackageIdentity packageIdentity);
    public string GetPackageDownloadMarkerFileName(PackageIdentity packageIdentity);
    public string GetManifestFileName(PackageIdentity packageIdentity);
    public virtual string GetInstallPath(PackageIdentity packageIdentity);
    public virtual string GetInstalledPath(PackageIdentity packageIdentity);
    public virtual string GetInstalledPackageFilePath(PackageIdentity packageIdentity);
    private string GetId(PackageIdentity identity);
    private string GetVersion(PackageIdentity identity);
    private StringBuilder GetPathBase(PackageIdentity packageIdentity);
}
public abstract class NuGet.Packaging.PackageReaderBase : object {
    private NuspecReader _nuspecReader;
    [CompilerGeneratedAttribute]
private IFrameworkNameProvider <FrameworkProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IFrameworkCompatibilityProvider <CompatibilityProvider>k__BackingField;
    protected IFrameworkNameProvider FrameworkProvider { get; protected set; }
    protected IFrameworkCompatibilityProvider CompatibilityProvider { get; protected set; }
    public NuspecReader NuspecReader { get; }
    public PackageReaderBase(IFrameworkNameProvider frameworkProvider);
    public PackageReaderBase(IFrameworkNameProvider frameworkProvider, IFrameworkCompatibilityProvider compatibilityProvider);
    [CompilerGeneratedAttribute]
protected IFrameworkNameProvider get_FrameworkProvider();
    [CompilerGeneratedAttribute]
protected void set_FrameworkProvider(IFrameworkNameProvider value);
    [CompilerGeneratedAttribute]
protected IFrameworkCompatibilityProvider get_CompatibilityProvider();
    [CompilerGeneratedAttribute]
protected void set_CompatibilityProvider(IFrameworkCompatibilityProvider value);
    public abstract virtual Stream GetStream(string path);
    public abstract virtual IEnumerable`1<string> GetFiles();
    public abstract virtual IEnumerable`1<string> GetFiles(string folder);
    public abstract virtual IEnumerable`1<string> CopyFiles(string destination, IEnumerable`1<string> packageFiles, ExtractPackageFileDelegate extractFile, ILogger logger, CancellationToken token);
    public virtual PackageIdentity GetIdentity();
    public virtual NuGetVersion GetMinClientVersion();
    public virtual IReadOnlyList`1<PackageType> GetPackageTypes();
    public virtual Stream GetNuspec();
    public virtual string GetNuspecFile();
    public virtual NuspecReader get_NuspecReader();
    public virtual Task`1<PackageIdentity> GetIdentityAsync(CancellationToken cancellationToken);
    public virtual Task`1<NuGetVersion> GetMinClientVersionAsync(CancellationToken cancellationToken);
    public virtual Task`1<IReadOnlyList`1<PackageType>> GetPackageTypesAsync(CancellationToken cancellationToken);
    public virtual Task`1<Stream> GetStreamAsync(string path, CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable`1<string>> GetFilesAsync(CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable`1<string>> GetFilesAsync(string folder, CancellationToken cancellationToken);
    public virtual Task`1<Stream> GetNuspecAsync(CancellationToken cancellationToken);
    public virtual Task`1<string> GetNuspecFileAsync(CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable`1<string>> CopyFilesAsync(string destination, IEnumerable`1<string> packageFiles, ExtractPackageFileDelegate extractFile, ILogger logger, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
    public virtual IEnumerable`1<FrameworkSpecificGroup> GetFrameworkItems();
    public virtual IEnumerable`1<FrameworkSpecificGroup> GetBuildItems();
    public virtual IEnumerable`1<FrameworkSpecificGroup> GetToolItems();
    public virtual IEnumerable`1<FrameworkSpecificGroup> GetContentItems();
    public virtual IEnumerable`1<PackageDependencyGroup> GetPackageDependencies();
    public virtual IEnumerable`1<FrameworkSpecificGroup> GetLibItems();
    public virtual IEnumerable`1<FrameworkSpecificGroup> GetReferenceItems();
    public virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetFrameworkItemsAsync(CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetBuildItemsAsync(CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetToolItemsAsync(CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetContentItemsAsync(CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetLibItemsAsync(CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetReferenceItemsAsync(CancellationToken cancellationToken);
    public virtual Task`1<IEnumerable`1<PackageDependencyGroup>> GetPackageDependenciesAsync(CancellationToken cancellationToken);
    public virtual IEnumerable`1<NuGetFramework> GetSupportedFrameworks();
    public virtual Task`1<IEnumerable`1<NuGetFramework>> GetSupportedFrameworksAsync(CancellationToken cancellationToken);
    public virtual bool IsServiceable();
    public virtual Task`1<bool> IsServiceableAsync(CancellationToken cancellationToken);
    public virtual IEnumerable`1<FrameworkSpecificGroup> GetItems(string folderName);
    public virtual Task`1<IEnumerable`1<FrameworkSpecificGroup>> GetItemsAsync(string folderName, CancellationToken cancellationToken);
    public virtual bool GetDevelopmentDependency();
    public virtual Task`1<bool> GetDevelopmentDependencyAsync(CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("NuGet.Packaging.PackageReaderBase/<GetFileGroups>d__55")]
protected IEnumerable`1<FrameworkSpecificGroup> GetFileGroups(string folder);
    protected NuGetFramework GetFrameworkFromPath(string path, bool allowSubFolders);
    protected static bool IsAllowedBuildFile(string packageId, string path);
    protected static bool IsReferenceAssembly(string path);
    protected static string GetNuspecFile(IEnumerable`1<string> files);
    protected static void ValidatePackageEntry(string normalizedDestination, string normalizedFilePath, PackageIdentity packageIdentity);
    protected string NormalizeDirectoryPath(string path);
    protected static void ValidatePackageEntries(string normalizedDestination, IEnumerable`1<string> packageFiles, PackageIdentity packageIdentity);
    public virtual Task`1<NuspecReader> GetNuspecReaderAsync(CancellationToken cancellationToken);
    public virtual Task`1<string> CopyNupkgAsync(string nupkgFilePath, CancellationToken cancellationToken);
    public abstract virtual Task`1<PrimarySignature> GetPrimarySignatureAsync(CancellationToken token);
    public abstract virtual Task`1<bool> IsSignedAsync(CancellationToken token);
    public abstract virtual Task ValidateIntegrityAsync(SignatureContent signatureContent, CancellationToken token);
    public abstract virtual Task`1<Byte[]> GetArchiveHashAsync(HashAlgorithmName hashAlgorithm, CancellationToken token);
    public abstract virtual bool CanVerifySignedPackages(SignedPackageVerifierSettings verifierSettings);
    public abstract virtual string GetContentHash(CancellationToken token, Func`1<string> GetUnsignedPackageHash);
}
[ExtensionAttribute]
public static class NuGet.Packaging.PackageReaderExtensions : object {
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageReaderExtensions/<GetPackageFilesAsync>d__0")]
[ExtensionAttribute]
public static Task`1<IEnumerable`1<string>> GetPackageFilesAsync(IAsyncPackageCoreReader packageReader, PackageSaveMode packageSaveMode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Packaging.PackageReaderExtensions/<GetSatelliteFilesAsync>d__1")]
[ExtensionAttribute]
public static Task`1<IEnumerable`1<string>> GetSatelliteFilesAsync(IAsyncPackageContentReader packageReader, string packageLanguage, CancellationToken cancellationToken);
}
[DebuggerDisplayAttribute("{PackageIdentity} {TargetFramework}")]
public class NuGet.Packaging.PackageReference : object {
    [CompilerGeneratedAttribute]
private PackageIdentity <PackageIdentity>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionRange <AllowedVersions>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetFramework <TargetFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDevelopmentDependency>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsUserInstalled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireReinstallation>k__BackingField;
    public PackageIdentity PackageIdentity { get; }
    public VersionRange AllowedVersions { get; }
    public bool HasAllowedVersions { get; }
    public NuGetFramework TargetFramework { get; }
    public bool IsDevelopmentDependency { get; }
    public bool IsUserInstalled { get; }
    public bool RequireReinstallation { get; }
    public PackageReference(PackageIdentity identity, NuGetFramework targetFramework);
    public PackageReference(PackageIdentity identity, NuGetFramework targetFramework, bool userInstalled);
    public PackageReference(PackageIdentity identity, NuGetFramework targetFramework, bool userInstalled, bool developmentDependency, bool requireReinstallation);
    public PackageReference(PackageIdentity identity, NuGetFramework targetFramework, bool userInstalled, bool developmentDependency, bool requireReinstallation, VersionRange allowedVersions);
    [CompilerGeneratedAttribute]
public PackageIdentity get_PackageIdentity();
    [CompilerGeneratedAttribute]
public VersionRange get_AllowedVersions();
    public bool get_HasAllowedVersions();
    [CompilerGeneratedAttribute]
public NuGetFramework get_TargetFramework();
    [CompilerGeneratedAttribute]
public bool get_IsDevelopmentDependency();
    [CompilerGeneratedAttribute]
public bool get_IsUserInstalled();
    [CompilerGeneratedAttribute]
public bool get_RequireReinstallation();
    public virtual string ToString();
}
public class NuGet.Packaging.PackageReferenceSet : object {
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <References>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetFramework <TargetFramework>k__BackingField;
    public IReadOnlyCollection`1<string> References { get; }
    public NuGetFramework TargetFramework { get; }
    public PackageReferenceSet(IEnumerable`1<string> references);
    public PackageReferenceSet(string targetFramework, IEnumerable`1<string> references);
    public PackageReferenceSet(NuGetFramework targetFramework, IEnumerable`1<string> references);
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<string> get_References();
    [CompilerGeneratedAttribute]
public NuGetFramework get_TargetFramework();
    [IteratorStateMachineAttribute("NuGet.Packaging.PackageReferenceSet/<Validate>d__9")]
public IEnumerable`1<string> Validate();
}
[FlagsAttribute]
public enum NuGet.Packaging.PackageSaveMode : Enum {
    public int value__;
    public static PackageSaveMode None;
    public static PackageSaveMode Nuspec;
    public static PackageSaveMode Nupkg;
    public static PackageSaveMode Files;
    public static PackageSaveMode Defaultv2;
    public static PackageSaveMode Defaultv3;
}
public static class NuGet.Packaging.PackagesConfig : object {
    public static string PackagesNodeName;
    public static string PackageNodeName;
    public static string IdAttributeName;
    public static string VersionAttributeName;
    public static string TargetFrameworkAttributeName;
    public static string MinClientAttributeName;
    public static string developmentDependencyAttributeName;
    public static string allowedVersionsAttributeName;
    public static string RequireInstallAttributeName;
    public static string UserInstalledAttributeName;
    private static PackagesConfig();
    public static bool TryGetAttribute(XElement node, string name, String& value);
    public static bool HasAttributeValue(XElement node, string attributeName, string targetValue, XElement& element);
    public static bool BoolAttribute(XElement node, string name, bool defaultValue);
}
public class NuGet.Packaging.PackagesConfigReader : object {
    private XDocument _doc;
    private IFrameworkNameProvider _frameworkMappings;
    public PackagesConfigReader(XDocument xml);
    public PackagesConfigReader(IFrameworkNameProvider frameworkMappings, XDocument xml);
    public PackagesConfigReader(Stream stream);
    public PackagesConfigReader(Stream stream, bool leaveStreamOpen);
    public PackagesConfigReader(IFrameworkNameProvider frameworkMappings, Stream stream, bool leaveStreamOpen);
    public NuGetVersion GetMinClientVersion();
    public IEnumerable`1<PackageReference> GetPackages();
    public IEnumerable`1<PackageReference> GetPackages(bool allowDuplicatePackageIds);
}
public class NuGet.Packaging.PackagesConfigReaderException : PackagingException {
    public PackagesConfigReaderException(string message);
    public PackagesConfigReaderException(string message, Exception innerException);
}
public class NuGet.Packaging.PackagesConfigWriter : object {
    private Stream _stream;
    private string _filePath;
    private bool _disposed;
    private NuGetVersion _minClientVersion;
    private IFrameworkNameProvider _frameworkMappings;
    private XDocument _xDocument;
    public PackagesConfigWriter(string fullPath, bool createNew);
    public PackagesConfigWriter(string fullPath, bool createNew, IFrameworkNameProvider frameworkMappings);
    public PackagesConfigWriter(Stream stream, bool createNew);
    public PackagesConfigWriter(Stream stream, bool createNew, IFrameworkNameProvider frameworkMappings);
    public void WriteMinClientVersion(NuGetVersion version);
    public void AddPackageEntry(string packageId, NuGetVersion version, NuGetFramework targetFramework);
    public void AddPackageEntry(PackageIdentity identity, NuGetFramework targetFramework);
    public void AddPackageEntry(PackageReference entry);
    public void UpdatePackageEntry(PackageReference oldEntry, PackageReference newEntry);
    public void UpdateOrAddPackageEntry(XDocument originalConfig, PackageReference newEntry);
    public void RemovePackageEntry(string packageId, NuGetVersion version, NuGetFramework targetFramework);
    public void RemovePackageEntry(PackageIdentity identity, NuGetFramework targetFramework);
    public void RemovePackageEntry(PackageReference entry);
    private XElement CreateXElementForPackageEntry(PackageReference entry);
    private void CreateDefaultXDocument();
    private XElement EnsurePackagesNode();
    private XElement FindMatchingPackageNode(PackageReference entry, XElement packagesNode);
    private XElement ReplacePackageAttributes(XElement existingNode, PackageReference newEntry);
    private void SortPackageNodes(XElement packagesNode);
    private void WriteFile();
    public void WriteFile(string fullPath);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public class NuGet.Packaging.PackagesConfigWriterException : PackagingException {
    public PackagesConfigWriterException(string message);
    public PackagesConfigWriterException(string message, Exception innerException);
}
public class NuGet.Packaging.PackageSigningTelemetryEvent : TelemetryEvent {
    public static string EventName;
    public PackageSignType PackageSignType { get; }
    public NuGetOperationStatus Status { get; }
    public string ExtractionId { get; }
    public PackageSignType get_PackageSignType();
    public NuGetOperationStatus get_Status();
    public string get_ExtractionId();
    public void SetResult(PackageSignType packageSignType, NuGetOperationStatus status);
}
public enum NuGet.Packaging.PackageSignType : Enum {
    public int value__;
    public static PackageSignType Signed;
    public static PackageSignType Unsigned;
}
public static class NuGet.Packaging.PackagingConstants : object {
    public static string AnyFramework;
    public static string AnyCodeLanguage;
    public static string AgnosticFramework;
    public static string TargetFrameworkPropertyKey;
    public static string ContentFilesDefaultBuildAction;
    public static string PackageVerifyDurationName;
    public static string ManifestExtension;
    public static string SnupkgFormat;
    public static string SymbolsNupkgFormat;
    internal static string PackageEmptyFileName;
    private static PackagingConstants();
}
public class NuGet.Packaging.PhysicalPackageFile : object {
    private Func`1<Stream> _streamFactory;
    private string _targetPath;
    private FrameworkName _targetFramework;
    private NuGetFramework _nugetFramework;
    private DateTimeOffset _lastWriteTime;
    [CompilerGeneratedAttribute]
private MemoryStream <MemoryStream>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourcePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EffectivePath>k__BackingField;
    private MemoryStream MemoryStream { get; private set; }
    public string SourcePath { get; public set; }
    public string TargetPath { get; public set; }
    public string Path { get; }
    public string EffectivePath { get; private set; }
    public FrameworkName TargetFramework { get; }
    public NuGetFramework NuGetFramework { get; }
    public DateTimeOffset LastWriteTime { get; }
    public PhysicalPackageFile(MemoryStream stream);
    internal PhysicalPackageFile(Func`1<Stream> streamFactory);
    [CompilerGeneratedAttribute]
private MemoryStream get_MemoryStream();
    [CompilerGeneratedAttribute]
private void set_MemoryStream(MemoryStream value);
    [CompilerGeneratedAttribute]
public string get_SourcePath();
    [CompilerGeneratedAttribute]
public void set_SourcePath(string value);
    public string get_TargetPath();
    public void set_TargetPath(string value);
    public sealed virtual string get_Path();
    [CompilerGeneratedAttribute]
public sealed virtual string get_EffectivePath();
    [CompilerGeneratedAttribute]
private void set_EffectivePath(string value);
    public sealed virtual FrameworkName get_TargetFramework();
    public sealed virtual NuGetFramework get_NuGetFramework();
    public sealed virtual Stream GetStream();
    public sealed virtual DateTimeOffset get_LastWriteTime();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class NuGet.Packaging.RepositorySignatureInfo : object {
    [CompilerGeneratedAttribute]
private bool <AllRepositorySigned>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IRepositoryCertificateInfo> <RepositoryCertificateInfos>k__BackingField;
    public bool AllRepositorySigned { get; }
    public IEnumerable`1<IRepositoryCertificateInfo> RepositoryCertificateInfos { get; }
    public RepositorySignatureInfo(bool allRepositorySigned, IEnumerable`1<IRepositoryCertificateInfo> repositoryCertificateInfos);
    [CompilerGeneratedAttribute]
public bool get_AllRepositorySigned();
    [CompilerGeneratedAttribute]
public IEnumerable`1<IRepositoryCertificateInfo> get_RepositoryCertificateInfos();
}
public class NuGet.Packaging.RepositorySignatureInfoProvider : object {
    private ConcurrentDictionary`2<string, RepositorySignatureInfo> _dict;
    [CompilerGeneratedAttribute]
private static RepositorySignatureInfoProvider <Instance>k__BackingField;
    public static RepositorySignatureInfoProvider Instance { get; }
    private static RepositorySignatureInfoProvider();
    [CompilerGeneratedAttribute]
public static RepositorySignatureInfoProvider get_Instance();
    public bool TryGetRepositorySignatureInfo(string source, RepositorySignatureInfo& repositorySignatureInfo);
    public void AddOrUpdateRepositorySignatureInfo(string source, RepositorySignatureInfo repositorySignatureInfo);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
public class NuGet.Packaging.Rules.AnalysisResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
public static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
public static CultureInfo Culture { get; public set; }
    public static string AssemblyDirectlyUnderLibWarning { get; }
    public static string AssemblyOutsideLibWarning { get; }
    public static string BuildConventionIsViolatedWarning { get; }
    public static string DefaultSpecValueWarning { get; }
    public static string DependenciesGroupsForEachTFMBeginningToFiles { get; }
    public static string DependenciesGroupsForEachTFMBeginningToNuspec { get; }
    public static string DependenciesGroupsForEachTFMEndingToFile { get; }
    public static string DependenciesGroupsForEachTFMEndingToNuspec { get; }
    public static string DependenciesGroupsForEachTFMHasCompatMatch { get; }
    public static string DependenciesGroupsForEachTFMHasNoExactMatch { get; }
    public static string FilePathTooLongWarning { get; }
    public static string IconUrlDeprecationWarning { get; }
    public static string InvalidFrameworkWarning { get; }
    public static string InvalidPlaceholderFileWarning { get; }
    public static string InvalidPrereleaseDependencyWarning { get; }
    public static string InvalidUndottedFrameworkInDependencyGroupsWarning { get; }
    public static string InvalidUndottedFrameworkInFilesWarning { get; }
    public static string InvalidUndottedFrameworkInFrameworkAssemblyGroupsWarning { get; }
    public static string InvalidUndottedFrameworkInReferenceGroupsWarning { get; }
    public static string InvalidUndottedFrameworkWarning { get; }
    public static string LegacyVersionWarning { get; }
    public static string LicenseUrlDeprecationWarning { get; }
    public static string Migrator_AssemblyDirectlyUnderLibWarning { get; }
    public static string Migrator_PackageHasContentFolder { get; }
    public static string Migrator_PackageHasInstallScript { get; }
    public static string Migrator_XdtTransformInPackage { get; }
    public static string MisplacedInitScriptWarning { get; }
    public static string MisplacedTransformFileWarning { get; }
    public static string MissingReadmeInformation { get; }
    public static string NoRefOrLibFolderInPackage { get; }
    public static string PlaceholderFileInPackageWarning { get; }
    public static string ReferencesInNuspecAndRefFilesDontMatchWarning { get; }
    public static string ReferencesInNuspecAndRefFilesDontMatchWarningAddToNuspecListItemFormat { get; }
    public static string ReferencesInNuspecAndRefFilesDontMatchWarningAddToNuspecNoTfmListItemFormat { get; }
    public static string ReferencesInNuspecAndRefFilesDontMatchWarningAddToRefListItemFormat { get; }
    public static string ScriptOutsideToolsWarning { get; }
    public static string UnrecognizedLicenseIdentifier { get; }
    public static string UnrecognizedScriptWarning { get; }
    public static string UnspecifiedDependencyVersionWarning { get; }
    public static string WinRTObsoleteWarning { get; }
    public static ResourceManager get_ResourceManager();
    public static CultureInfo get_Culture();
    public static void set_Culture(CultureInfo value);
    public static string get_AssemblyDirectlyUnderLibWarning();
    public static string get_AssemblyOutsideLibWarning();
    public static string get_BuildConventionIsViolatedWarning();
    public static string get_DefaultSpecValueWarning();
    public static string get_DependenciesGroupsForEachTFMBeginningToFiles();
    public static string get_DependenciesGroupsForEachTFMBeginningToNuspec();
    public static string get_DependenciesGroupsForEachTFMEndingToFile();
    public static string get_DependenciesGroupsForEachTFMEndingToNuspec();
    public static string get_DependenciesGroupsForEachTFMHasCompatMatch();
    public static string get_DependenciesGroupsForEachTFMHasNoExactMatch();
    public static string get_FilePathTooLongWarning();
    public static string get_IconUrlDeprecationWarning();
    public static string get_InvalidFrameworkWarning();
    public static string get_InvalidPlaceholderFileWarning();
    public static string get_InvalidPrereleaseDependencyWarning();
    public static string get_InvalidUndottedFrameworkInDependencyGroupsWarning();
    public static string get_InvalidUndottedFrameworkInFilesWarning();
    public static string get_InvalidUndottedFrameworkInFrameworkAssemblyGroupsWarning();
    public static string get_InvalidUndottedFrameworkInReferenceGroupsWarning();
    public static string get_InvalidUndottedFrameworkWarning();
    public static string get_LegacyVersionWarning();
    public static string get_LicenseUrlDeprecationWarning();
    public static string get_Migrator_AssemblyDirectlyUnderLibWarning();
    public static string get_Migrator_PackageHasContentFolder();
    public static string get_Migrator_PackageHasInstallScript();
    public static string get_Migrator_XdtTransformInPackage();
    public static string get_MisplacedInitScriptWarning();
    public static string get_MisplacedTransformFileWarning();
    public static string get_MissingReadmeInformation();
    public static string get_NoRefOrLibFolderInPackage();
    public static string get_PlaceholderFileInPackageWarning();
    public static string get_ReferencesInNuspecAndRefFilesDontMatchWarning();
    public static string get_ReferencesInNuspecAndRefFilesDontMatchWarningAddToNuspecListItemFormat();
    public static string get_ReferencesInNuspecAndRefFilesDontMatchWarningAddToNuspecNoTfmListItemFormat();
    public static string get_ReferencesInNuspecAndRefFilesDontMatchWarningAddToRefListItemFormat();
    public static string get_ScriptOutsideToolsWarning();
    public static string get_UnrecognizedLicenseIdentifier();
    public static string get_UnrecognizedScriptWarning();
    public static string get_UnspecifiedDependencyVersionWarning();
    public static string get_WinRTObsoleteWarning();
}
internal class NuGet.Packaging.Rules.ContentFolderInPackageReferenceProjectRule : object {
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public ContentFolderInPackageReferenceProjectRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
}
public class NuGet.Packaging.Rules.DefaultManifestValuesRule : object {
    internal static Uri SampleProjectUrl;
    internal static Uri SampleLicenseUrl;
    internal static Uri SampleIconUrl;
    internal static string SampleTags;
    internal static string SampleReleaseNotes;
    internal static string SampleDescription;
    internal static string SampleManifestDependencyId;
    internal static string SampleManifestDependencyVersion;
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public DefaultManifestValuesRule(string messageFormat);
    private static DefaultManifestValuesRule();
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.DefaultManifestValuesRule/<Validate>d__12")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private PackagingLogMessage CreateIssueFor(string field, string value);
}
internal class NuGet.Packaging.Rules.DependenciesGroupsForEachTFMRule : object {
    private static NuGetFramework Net00;
    public string MessageFormat { get; }
    private string CompatMatchFoundWarningMessageFormat { get; }
    private static DependenciesGroupsForEachTFMRule();
    public sealed virtual string get_MessageFormat();
    private string get_CompatMatchFoundWarningMessageFormat();
    public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader package);
    internal IEnumerable`1<PackagingLogMessage> GenerateWarnings(HashSet`1<NuGetFramework> compatNotExactMatches, HashSet`1<NuGetFramework> noExactMatchesFromFile, HashSet`1<NuGetFramework> noExactMatchesFromNuspec);
    internal ValueTuple`3<HashSet`1<NuGetFramework>, HashSet`1<NuGetFramework>, HashSet`1<NuGetFramework>> Categorize(IEnumerable`1<string> files, IEnumerable`1<NuGetFramework> tfmsFromNuspec);
    internal ValueTuple`2<string, string> GenerateWarningString(ICollection`1<NuGetFramework> noExactMatchesFromFile, ICollection`1<NuGetFramework> noExactMatchesFromNuspec, ICollection`1<NuGetFramework> compatNotExactMatches);
    private static IEnumerable`1<NuGetFramework> ExtractTFMsFromNuspec(Stream packageNuspecStream);
}
internal static class NuGet.Packaging.Rules.FrameworkNameValidatorUtility : object {
    internal static bool IsValidFrameworkName(NuGetFramework framework);
    internal static bool IsValidFrameworkName(string path);
    internal static bool IsValidCultureName(PackageArchiveReader builder, string name);
}
public class NuGet.Packaging.Rules.IconUrlDeprecationWarning : object {
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public IconUrlDeprecationWarning(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.IconUrlDeprecationWarning/<Validate>d__4")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
}
internal class NuGet.Packaging.Rules.InitScriptNotUnderToolsRule : object {
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public InitScriptNotUnderToolsRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.InitScriptNotUnderToolsRule/<Validate>d__4")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private PackagingLogMessage CreatePackageIssue(string file);
}
internal class NuGet.Packaging.Rules.InstallScriptInPackageReferenceProjectRule : object {
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public InstallScriptInPackageReferenceProjectRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
}
internal class NuGet.Packaging.Rules.InvalidFrameworkFolderRule : object {
    private static string LibDirectory;
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public InvalidFrameworkFolderRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private PackagingLogMessage CreatePackageIssue(string target);
}
internal class NuGet.Packaging.Rules.InvalidPlaceholderFileRule : object {
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public InvalidPlaceholderFileRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.InvalidPlaceholderFileRule/<Validate>d__4")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private PackagingLogMessage CreatePackageIssueForPlaceholderFile(string target);
}
internal class NuGet.Packaging.Rules.InvalidPrereleaseDependencyRule : object {
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public InvalidPrereleaseDependencyRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.InvalidPrereleaseDependencyRule/<Validate>d__4")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private bool IsPrereleaseDependency(PackageDependency dependency);
    private PackagingLogMessage CreatePackageIssueForPrereleaseDependency(PackageDependency dependency, NuGetFramework framework);
}
internal class NuGet.Packaging.Rules.InvalidUndottedFrameworkRule : object {
    private static string TargetFramework;
    private static string Metadata;
    private static string Dependencies;
    private static string Group;
    private static string References;
    private static string FrameworkAssemblies;
    private static string FrameworkAssembly;
    private static Char[] CommaArray;
    public string MessageFormat { get; }
    private static InvalidUndottedFrameworkRule();
    public sealed virtual string get_MessageFormat();
    public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    internal static IEnumerable`1<PackagingLogMessage> Validate(XDocument xml, IEnumerable`1<string> files);
    internal static IEnumerable`1<PackagingLogMessage> ValidateDependencyGroups(XElement metadataNode);
    internal static IEnumerable`1<PackagingLogMessage> ValidateReferenceGroups(XElement metadataNode);
    internal static IEnumerable`1<PackagingLogMessage> ValidateFrameworkAssemblies(XDocument xml, XElement metadataNode);
    internal static IEnumerable`1<PackagingLogMessage> ValidateFiles(IEnumerable`1<string> files);
    private static XDocument LoadXml(Stream stream);
    private static string GetAttributeValue(XElement element, string attributeName);
    internal static bool FrameworkVersionHasDesiredDots(string frameworkString);
}
public interface NuGet.Packaging.Rules.IPackageRule {
    public string MessageFormat { get; }
    public abstract virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    public abstract virtual string get_MessageFormat();
}
public class NuGet.Packaging.Rules.LicenseUrlDeprecationWarning : object {
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public LicenseUrlDeprecationWarning(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.LicenseUrlDeprecationWarning/<Validate>d__4")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
}
internal class NuGet.Packaging.Rules.MisplacedAssemblyOutsideLibRule : object {
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    private static IEnumerable`1<string> ValidFolders { get; }
    public MisplacedAssemblyOutsideLibRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.MisplacedAssemblyOutsideLibRule/<Validate>d__4")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private PackagingLogMessage CreatePackageIssueForAssembliesOutsideLib(string target);
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.MisplacedAssemblyOutsideLibRule/<get_ValidFolders>d__7")]
private static IEnumerable`1<string> get_ValidFolders();
}
internal class NuGet.Packaging.Rules.MisplacedAssemblyUnderLibRule : object {
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    private static IEnumerable`1<string> ValidFolders { get; }
    public MisplacedAssemblyUnderLibRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.MisplacedAssemblyUnderLibRule/<Validate>d__4")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private PackagingLogMessage CreatePackageIssueForAssembliesUnderLib(string target);
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.MisplacedAssemblyUnderLibRule/<get_ValidFolders>d__7")]
private static IEnumerable`1<string> get_ValidFolders();
}
internal class NuGet.Packaging.Rules.MisplacedScriptFileRule : object {
    private static string ScriptExtension;
    private static string ToolsDirectory;
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public MisplacedScriptFileRule(string messageFormat);
    private static MisplacedScriptFileRule();
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.MisplacedScriptFileRule/<Validate>d__6")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private PackagingLogMessage CreatePackageIssueForMisplacedScript(string target);
}
internal class NuGet.Packaging.Rules.MisplacedTransformFileRule : object {
    private static string CodeTransformExtension;
    private static string ConfigTransformExtension;
    private static string ContentDirectory;
    private static string ContentFilesDirectory;
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public MisplacedTransformFileRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.MisplacedTransformFileRule/<Validate>d__8")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private PackagingLogMessage CreatePackageIssueForMisplacedContent(string path);
}
internal class NuGet.Packaging.Rules.MissingReadmeRule : object {
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public MissingReadmeRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.MissingReadmeRule/<Validate>d__4")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
}
internal class NuGet.Packaging.Rules.NoRefOrLibFolderInPackageRule : object {
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public NoRefOrLibFolderInPackageRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader package);
    internal IEnumerable`1<PackagingLogMessage> Validate(IEnumerable`1<string> files);
    private ValueTuple`2<string, string> GenerateWarningString(String[] possibleFrameworks);
    private static string CreateDirectoriesMessage(String[] possibleFrameworks);
}
public class NuGet.Packaging.Rules.PathTooLongRule : object {
    private static int _pathLenghtWarningThreshold;
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public PathTooLongRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.PathTooLongRule/<Validate>d__5")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private PackagingLogMessage CreatePackageIssueForPathTooLong(string target);
}
internal class NuGet.Packaging.Rules.ReferencesInNuspecMatchRefAssetsRule : object {
    private string _addToRefFormat;
    private string _addToNuspecFormat;
    private string _addToNuspecNoTfmFormat;
    public string MessageFormat { get; }
    public sealed virtual string get_MessageFormat();
    public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    internal IDictionary`2<string, IEnumerable`1<string>> GetReferencesFromNuspec(Stream nuspecStream);
    internal IEnumerable`1<MissingReference> Compare(IDictionary`2<string, IEnumerable`1<string>> nuspecReferences, IEnumerable`1<string> refFiles);
    internal IEnumerable`1<PackagingLogMessage> GenerateWarnings(IEnumerable`1<MissingReference> missingReferences);
    internal List`1<string> GetAllKeys(IEnumerable`1<IGrouping`2<string, string>> filesByTFM);
}
public static class NuGet.Packaging.Rules.RuleSet : object {
    private static IPackageRule[] PackageCreationRuleArray;
    private static IPackageRule[] PackageCreationBestPracticeRuleArray;
    private static ReadOnlyCollection`1<IPackageRule> PackageCreationRules;
    private static ReadOnlyCollection`1<IPackageRule> PackagesConfigToPackageReferenceMigrationRules;
    public static IEnumerable`1<IPackageRule> PackageCreationRuleSet { get; }
    public static IEnumerable`1<IPackageRule> PackagesConfigToPackageReferenceMigrationRuleSet { get; }
    private static RuleSet();
    public static IEnumerable`1<IPackageRule> get_PackageCreationRuleSet();
    public static IEnumerable`1<IPackageRule> get_PackagesConfigToPackageReferenceMigrationRuleSet();
}
internal class NuGet.Packaging.Rules.UnrecognizedLicenseIdentifierRule : object {
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public UnrecognizedLicenseIdentifierRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private void ValidateAllLicenseLeafs(NuGetLicenseExpression expression, IList`1<PackagingLogMessage> logMessages);
}
internal class NuGet.Packaging.Rules.UnrecognizedScriptFileRule : object {
    private static string ScriptExtension;
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public UnrecognizedScriptFileRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.UnrecognizedScriptFileRule/<Validate>d__5")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private PackagingLogMessage CreatePackageIssueForUnrecognizedScripts(string target);
}
public class NuGet.Packaging.Rules.UnspecifiedDependencyVersionRule : object {
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public UnspecifiedDependencyVersionRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.UnspecifiedDependencyVersionRule/<Validate>d__4")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
}
internal class NuGet.Packaging.Rules.UpholdBuildConventionRule : object {
    private static ManagedCodeConventions ManagedCodeConventions;
    private static IReadOnlyList`1<string> BuildFolders;
    public string MessageFormat { get; }
    private static UpholdBuildConventionRule();
    public sealed virtual string get_MessageFormat();
    public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    internal PackagingLogMessage GenerateWarning(ICollection`1<ExpectedFile> expectedFiles);
    internal List`1<ExpectedFile> FindAbsentExpectedFiles(IEnumerable`1<string> files, string packageId);
    private string GetTfm(string file);
    private string GetBuildFolder(string file);
    private bool EndsWithMsbuildFileExtension(string file);
    private bool InsideBuildFolder(string file);
}
internal class NuGet.Packaging.Rules.WinRTNameIsObsoleteRule : object {
    private static String[] Prefixes;
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public WinRTNameIsObsoleteRule(string messageFormat);
    private static WinRTNameIsObsoleteRule();
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.WinRTNameIsObsoleteRule/<Validate>d__5")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private PackagingLogMessage CreateIssue(string file);
}
internal class NuGet.Packaging.Rules.XdtTransformInPackageReferenceProjectRule : object {
    private static string ConfigTransformExtension;
    private static string InstallXdtExtension;
    private static string UninstallXdtExtension;
    private static string ContentDirectory;
    private static string ContentFilesDirectory;
    [CompilerGeneratedAttribute]
private string <MessageFormat>k__BackingField;
    public string MessageFormat { get; }
    public XdtTransformInPackageReferenceProjectRule(string messageFormat);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MessageFormat();
    [IteratorStateMachineAttribute("NuGet.Packaging.Rules.XdtTransformInPackageReferenceProjectRule/<Validate>d__9")]
public sealed virtual IEnumerable`1<PackagingLogMessage> Validate(PackageArchiveReader builder);
    private PackagingLogMessage CreatePackageIssueForTransformFiles(string path);
}
public class NuGet.Packaging.Sha512HashFunction : object {
    private Byte[] _hash;
    private SHA512 _hashFunc;
    public sealed virtual void Update(Byte[] data, int offset, int count);
    public Byte[] GetHashBytes();
    public sealed virtual string GetHash();
    public sealed virtual void Dispose();
}
public class NuGet.Packaging.Signing.Accuracy : object {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Seconds>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Milliseconds>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Microseconds>k__BackingField;
    public Nullable`1<int> Seconds { get; }
    public Nullable`1<int> Milliseconds { get; }
    public Nullable`1<int> Microseconds { get; }
    private Accuracy(Nullable`1<int> seconds, Nullable`1<int> milliseconds, Nullable`1<int> microseconds);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Seconds();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Milliseconds();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Microseconds();
    public static Accuracy Read(Byte[] bytes);
    internal static Accuracy Read(DerSequenceReader reader);
    public Nullable`1<long> GetTotalMicroseconds();
}
public class NuGet.Packaging.Signing.AlgorithmIdentifier : object {
    [CompilerGeneratedAttribute]
private Oid <Algorithm>k__BackingField;
    public Oid Algorithm { get; }
    internal AlgorithmIdentifier(Oid algorithm);
    [CompilerGeneratedAttribute]
public Oid get_Algorithm();
    public static AlgorithmIdentifier Read(Byte[] bytes);
    internal static AlgorithmIdentifier Read(DerSequenceReader reader);
    internal Byte[][] Encode();
}
public class NuGet.Packaging.Signing.AllowListVerificationProvider : object {
    private IReadOnlyCollection`1<VerificationAllowListEntry> _allowList;
    private string _emptyListErrorMessage;
    private string _noMatchErrorMessage;
    private bool _requireNonEmptyAllowList;
    public AllowListVerificationProvider(IReadOnlyCollection`1<VerificationAllowListEntry> allowList, bool requireNonEmptyAllowList, string emptyListErrorMessage, string noMatchErrorMessage);
    public sealed virtual Task`1<PackageVerificationResult> GetTrustResultAsync(ISignedPackageReader package, PrimarySignature signature, SignedPackageVerifierSettings settings, CancellationToken token);
    private PackageVerificationResult VerifyAllowList(ISignedPackageReader package, PrimarySignature signature, SignedPackageVerifierSettings settings);
    private bool IsSignatureAllowed(PrimarySignature signature, IReadOnlyCollection`1<VerificationAllowListEntry> allowList);
    private static bool ShouldVerifyOwners(TrustedSignerAllowListEntry entry, IRepositorySignature repoSignature, IReadOnlyList`1& allowedOwners, IReadOnlyList`1& actualOwners);
    private static bool IsSignatureTargeted(VerificationTarget target, Signature signature);
    private static string GetCertificateFingerprint(Signature signature, HashAlgorithmName fingerprintAlgorithm, IDictionary`2<HashAlgorithmName, string> CertificateFingerprintLookUp);
}
[ExtensionAttribute]
public static class NuGet.Packaging.Signing.AttributeUtility : object {
    public static CryptographicAttributeObject CreateCommitmentTypeIndication(SignatureType type);
    public static SignatureType GetSignatureType(CryptographicAttributeObjectCollection signedAttributes);
    public static CryptographicAttributeObject CreateNuGetV3ServiceIndexUrl(Uri v3ServiceIndexUrl);
    public static Uri GetNuGetV3ServiceIndexUrl(CryptographicAttributeObjectCollection signedAttributes);
    public static CryptographicAttributeObject CreateNuGetPackageOwners(IReadOnlyList`1<string> packageOwners);
    public static IReadOnlyList`1<string> GetNuGetPackageOwners(CryptographicAttributeObjectCollection signedAttributes);
    public static SignatureType GetSignatureType(string oid);
    public static string GetSignatureTypeOid(SignatureType signatureType);
    public static CryptographicAttributeObject CreateSigningCertificateV2(X509Certificate2 certificate, HashAlgorithmName hashAlgorithm);
    [ExtensionAttribute]
internal static CryptographicAttributeObject GetAttributeOrDefault(CryptographicAttributeObjectCollection attributes, string oid);
    private static void ThrowInvalidAttributeException(CryptographicAttributeObject attribute);
    [ExtensionAttribute]
private static List`1<AsnEncodedData> ToList(AsnEncodedDataCollection collection);
    private static IEnumerable`1<SignatureType> GetCommitmentTypeIndicationRawValues(CryptographicAttributeObject attribute);
    [ExtensionAttribute]
public static CryptographicAttributeObject GetAttribute(CryptographicAttributeObjectCollection attributes, string oid);
    [ExtensionAttribute]
public static IEnumerable`1<CryptographicAttributeObject> GetAttributes(CryptographicAttributeObjectCollection attributes, string oid);
}
public class NuGet.Packaging.Signing.AuthorPrimarySignature : PrimarySignature {
    public string FriendlyName { get; }
    public AuthorPrimarySignature(SignedCms signedCms);
    public virtual string get_FriendlyName();
    public virtual SignatureVerificationSummary Verify(Timestamp timestamp, SignatureVerifySettings settings, HashAlgorithmName fingerprintAlgorithm, X509Certificate2Collection certificateExtraStore);
}
public class NuGet.Packaging.Signing.AuthorSignPackageRequest : SignPackageRequest {
    public SignatureType SignatureType { get; }
    public AuthorSignPackageRequest(X509Certificate2 certificate, HashAlgorithmName hashAlgorithm);
    public AuthorSignPackageRequest(X509Certificate2 certificate, HashAlgorithmName signatureHashAlgorithm, HashAlgorithmName timestampHashAlgorithm);
    public virtual SignatureType get_SignatureType();
}
internal class NuGet.Packaging.Signing.BLOB : ValueType {
    public UInt32 cbData;
    public IntPtr pbData;
    public void Dispose();
}
internal class NuGet.Packaging.Signing.CentralDirectoryHeader : object {
    internal static UInt32 SizeInBytesOfFixedLengthFields;
    internal static UInt32 Signature;
    [CompilerGeneratedAttribute]
private ushort <VersionMadeBy>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <VersionNeededToExtract>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <GeneralPurposeBitFlag>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <CompressionMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <LastModFileTime>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <LastModFileDate>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Crc32>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <CompressedSize>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <UncompressedSize>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <FileNameLength>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <ExtraFieldLength>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <FileCommentLength>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <DiskNumberStart>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <InternalFileAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ExternalFileAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <RelativeOffsetOfLocalHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <ExtraField>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <FileComment>k__BackingField;
    [CompilerGeneratedAttribute]
private long <OffsetFromStart>k__BackingField;
    internal ushort VersionMadeBy { get; private set; }
    internal ushort VersionNeededToExtract { get; private set; }
    internal ushort GeneralPurposeBitFlag { get; private set; }
    internal ushort CompressionMethod { get; private set; }
    internal ushort LastModFileTime { get; private set; }
    internal ushort LastModFileDate { get; private set; }
    internal UInt32 Crc32 { get; private set; }
    internal UInt32 CompressedSize { get; private set; }
    internal UInt32 UncompressedSize { get; private set; }
    internal ushort FileNameLength { get; private set; }
    internal ushort ExtraFieldLength { get; private set; }
    internal ushort FileCommentLength { get; private set; }
    internal ushort DiskNumberStart { get; private set; }
    internal ushort InternalFileAttributes { get; private set; }
    internal UInt32 ExternalFileAttributes { get; private set; }
    internal UInt32 RelativeOffsetOfLocalHeader { get; private set; }
    internal Byte[] FileName { get; private set; }
    internal Byte[] ExtraField { get; private set; }
    internal Byte[] FileComment { get; private set; }
    internal long OffsetFromStart { get; private set; }
    [CompilerGeneratedAttribute]
internal ushort get_VersionMadeBy();
    [CompilerGeneratedAttribute]
private void set_VersionMadeBy(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_VersionNeededToExtract();
    [CompilerGeneratedAttribute]
private void set_VersionNeededToExtract(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_GeneralPurposeBitFlag();
    [CompilerGeneratedAttribute]
private void set_GeneralPurposeBitFlag(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_CompressionMethod();
    [CompilerGeneratedAttribute]
private void set_CompressionMethod(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_LastModFileTime();
    [CompilerGeneratedAttribute]
private void set_LastModFileTime(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_LastModFileDate();
    [CompilerGeneratedAttribute]
private void set_LastModFileDate(ushort value);
    [CompilerGeneratedAttribute]
internal UInt32 get_Crc32();
    [CompilerGeneratedAttribute]
private void set_Crc32(UInt32 value);
    [CompilerGeneratedAttribute]
internal UInt32 get_CompressedSize();
    [CompilerGeneratedAttribute]
private void set_CompressedSize(UInt32 value);
    [CompilerGeneratedAttribute]
internal UInt32 get_UncompressedSize();
    [CompilerGeneratedAttribute]
private void set_UncompressedSize(UInt32 value);
    [CompilerGeneratedAttribute]
internal ushort get_FileNameLength();
    [CompilerGeneratedAttribute]
private void set_FileNameLength(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_ExtraFieldLength();
    [CompilerGeneratedAttribute]
private void set_ExtraFieldLength(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_FileCommentLength();
    [CompilerGeneratedAttribute]
private void set_FileCommentLength(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_DiskNumberStart();
    [CompilerGeneratedAttribute]
private void set_DiskNumberStart(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_InternalFileAttributes();
    [CompilerGeneratedAttribute]
private void set_InternalFileAttributes(ushort value);
    [CompilerGeneratedAttribute]
internal UInt32 get_ExternalFileAttributes();
    [CompilerGeneratedAttribute]
private void set_ExternalFileAttributes(UInt32 value);
    [CompilerGeneratedAttribute]
internal UInt32 get_RelativeOffsetOfLocalHeader();
    [CompilerGeneratedAttribute]
private void set_RelativeOffsetOfLocalHeader(UInt32 value);
    [CompilerGeneratedAttribute]
internal Byte[] get_FileName();
    [CompilerGeneratedAttribute]
private void set_FileName(Byte[] value);
    [CompilerGeneratedAttribute]
internal Byte[] get_ExtraField();
    [CompilerGeneratedAttribute]
private void set_ExtraField(Byte[] value);
    [CompilerGeneratedAttribute]
internal Byte[] get_FileComment();
    [CompilerGeneratedAttribute]
private void set_FileComment(Byte[] value);
    [CompilerGeneratedAttribute]
internal long get_OffsetFromStart();
    [CompilerGeneratedAttribute]
private void set_OffsetFromStart(long value);
    internal UInt32 GetSizeInBytes();
    internal static bool TryRead(BinaryReader reader, CentralDirectoryHeader& header);
}
public class NuGet.Packaging.Signing.CentralDirectoryHeaderMetadata : object {
    [CompilerGeneratedAttribute]
private long <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private long <OffsetToLocalFileHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private long <FileEntryTotalSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPackageSignatureFile>k__BackingField;
    [CompilerGeneratedAttribute]
private long <HeaderSize>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ChangeInOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IndexInHeaders>k__BackingField;
    public long Position { get; public set; }
    public long OffsetToLocalFileHeader { get; public set; }
    public long FileEntryTotalSize { get; public set; }
    public bool IsPackageSignatureFile { get; public set; }
    public long HeaderSize { get; public set; }
    public long ChangeInOffset { get; public set; }
    public int IndexInHeaders { get; public set; }
    [CompilerGeneratedAttribute]
public long get_Position();
    [CompilerGeneratedAttribute]
public void set_Position(long value);
    [CompilerGeneratedAttribute]
public long get_OffsetToLocalFileHeader();
    [CompilerGeneratedAttribute]
public void set_OffsetToLocalFileHeader(long value);
    [CompilerGeneratedAttribute]
public long get_FileEntryTotalSize();
    [CompilerGeneratedAttribute]
public void set_FileEntryTotalSize(long value);
    [CompilerGeneratedAttribute]
public bool get_IsPackageSignatureFile();
    [CompilerGeneratedAttribute]
public void set_IsPackageSignatureFile(bool value);
    [CompilerGeneratedAttribute]
public long get_HeaderSize();
    [CompilerGeneratedAttribute]
public void set_HeaderSize(long value);
    [CompilerGeneratedAttribute]
public long get_ChangeInOffset();
    [CompilerGeneratedAttribute]
public void set_ChangeInOffset(long value);
    [CompilerGeneratedAttribute]
public int get_IndexInHeaders();
    [CompilerGeneratedAttribute]
public void set_IndexInHeaders(int value);
}
internal class NuGet.Packaging.Signing.CERT_CONTEXT : ValueType {
    public UInt32 dwCertEncodingType;
    public IntPtr pbCertEncoded;
    public UInt32 cbCertEncoded;
    public IntPtr pCertInfo;
    public IntPtr hCertStore;
}
internal class NuGet.Packaging.Signing.CERT_ID : ValueType {
    internal UInt32 dwIdChoice;
    internal BLOB KeyId;
}
public static class NuGet.Packaging.Signing.CertificateChainUtility : object {
    internal static X509ChainStatusFlags DefaultObservedStatusFlags;
    public static IX509CertificateChain GetCertificateChain(X509Certificate2 certificate, X509Certificate2Collection extraStore, ILogger logger, CertificateType certificateType);
    public static IX509CertificateChain GetCertificateChain(X509Chain x509Chain);
    private static void GetChainStatusFlags(X509Certificate2 certificate, CertificateType certificateType, X509ChainStatusFlags& errorStatusFlags, X509ChainStatusFlags& warningStatusFlags);
    internal static void SetCertBuildChainPolicy(X509ChainPolicy policy, X509Certificate2Collection additionalCertificates, DateTime verificationTime, CertificateType certificateType);
    internal static bool BuildCertificateChain(IX509Chain chain, X509Certificate2 certificate, X509ChainStatus[]& status);
    internal static bool BuildWithPolicy(IX509Chain chain, X509Certificate2 certificate);
    internal static bool ChainStatusListIncludesStatus(X509ChainStatus[] chainStatuses, X509ChainStatusFlags status, IEnumerable`1& chainStatus);
    internal static bool TryGetStatusAndMessage(X509ChainStatus[] chainStatuses, X509ChainStatusFlags status, IEnumerable`1& statusAndMessages);
    internal static IEnumerable`1<string> GetStatusAndMessagesFromChainStatuses(IEnumerable`1<X509ChainStatus> chainStatuses);
    private static void LogAdditionalContext(IX509Chain chain, ILogger logger);
}
public class NuGet.Packaging.Signing.CertificateHashAllowListEntry : VerificationAllowListEntry {
    [CompilerGeneratedAttribute]
private string <Fingerprint>k__BackingField;
    [CompilerGeneratedAttribute]
private HashAlgorithmName <FingerprintAlgorithm>k__BackingField;
    public string Fingerprint { get; }
    public HashAlgorithmName FingerprintAlgorithm { get; }
    public CertificateHashAllowListEntry(VerificationTarget target, SignaturePlacement placement, string fingerprint, HashAlgorithmName algorithm);
    [CompilerGeneratedAttribute]
public string get_Fingerprint();
    [CompilerGeneratedAttribute]
public HashAlgorithmName get_FingerprintAlgorithm();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public enum NuGet.Packaging.Signing.CertificateType : Enum {
    public int value__;
    public static CertificateType Signature;
    public static CertificateType Timestamp;
}
public static class NuGet.Packaging.Signing.CertificateUtility : object {
    private static int ChainDepthLimit;
    public static string X509Certificate2ToString(X509Certificate2 cert, HashAlgorithmName fingerprintAlgorithm);
    internal static IReadOnlyList`1<SignatureLog> X509Certificate2ToLogMessages(X509Certificate2 cert, HashAlgorithmName fingerprintAlgorithm, string indentation);
    private static void X509Certificate2ToString(X509Certificate2 cert, StringBuilder certStringBuilder, HashAlgorithmName fingerprintAlgorithm, string indentation);
    public static string X509Certificate2CollectionToString(X509Certificate2Collection certCollection, HashAlgorithmName fingerprintAlgorithm);
    public static string X509ChainToString(X509Chain chain, HashAlgorithmName fingerprintAlgorithm);
    public static bool IsSignatureAlgorithmSupported(X509Certificate2 certificate);
    public static bool IsCertificatePublicKeyValid(X509Certificate2 certificate);
    public static bool HasLifetimeSigningEku(X509Certificate2 certificate);
    public static bool HasExtendedKeyUsage(X509Certificate2 certificate, string ekuOid);
    public static bool IsValidForPurposeFast(X509Certificate2 certificate, string ekuOid);
    public static bool IsCertificateValidityPeriodInTheFuture(X509Certificate2 certificate);
    public static bool IsDateInsideValidityPeriod(X509Certificate2 certificate, DateTimeOffset date);
    public static Byte[] GetHash(X509Certificate2 certificate, HashAlgorithmName hashAlgorithm);
    public static string GetHashString(X509Certificate2 certificate, HashAlgorithmName hashAlgorithm);
    public static bool IsSelfIssued(X509Certificate2 certificate);
    public static IReadOnlyList`1<Byte[]> GetRawDataForCollection(X509Certificate2Collection certificates);
}
public class NuGet.Packaging.Signing.ClientPolicyContext : object {
    [CompilerGeneratedAttribute]
private SignatureValidationMode <Policy>k__BackingField;
    [CompilerGeneratedAttribute]
private SignedPackageVerifierSettings <VerifierSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<TrustedSignerAllowListEntry> <AllowList>k__BackingField;
    public SignatureValidationMode Policy { get; }
    public SignedPackageVerifierSettings VerifierSettings { get; }
    public IReadOnlyCollection`1<TrustedSignerAllowListEntry> AllowList { get; }
    internal ClientPolicyContext(SignatureValidationMode policy, IReadOnlyCollection`1<TrustedSignerAllowListEntry> allowList);
    [CompilerGeneratedAttribute]
public SignatureValidationMode get_Policy();
    [CompilerGeneratedAttribute]
public SignedPackageVerifierSettings get_VerifierSettings();
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<TrustedSignerAllowListEntry> get_AllowList();
    public static ClientPolicyContext GetClientPolicy(ISettings settings, ILogger logger);
}
internal static class NuGet.Packaging.Signing.CmsFactory : object {
    internal static ICms Create(Byte[] cmsBytes);
}
internal enum NuGet.Packaging.Signing.CMSG_CONTROL_TYPE : Enum {
    public UInt32 value__;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_VERIFY_SIGNATURE;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_DECRYPT;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_VERIFY_HASH;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_ADD_SIGNER;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_DEL_SIGNER;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_ADD_CERT;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_DEL_CERT;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_ADD_CRL;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_DEL_CRL;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_ADD_ATTR_CERT;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_DEL_ATTR_CERT;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_KEY_TRANS_DECRYPT;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_KEY_AGREE_DECRYPT;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_MAIL_LIST_DECRYPT;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_VERIFY_SIGNATURE_EX;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_ADD_CMS_SIGNER_INFO;
    public static CMSG_CONTROL_TYPE CMSG_CTRL_ENABLE_STRONG_SIGNATURE;
}
internal class NuGet.Packaging.Signing.CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA : ValueType {
    internal UInt32 cbSize;
    internal UInt32 dwSignerIndex;
    internal CRYPT_INTEGER_BLOB BLOB;
}
internal class NuGet.Packaging.Signing.CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA : ValueType {
    internal UInt32 cbSize;
    internal UInt32 dwSignerIndex;
    internal UInt32 dwUnauthAttrIndex;
}
[FlagsAttribute]
internal enum NuGet.Packaging.Signing.CMSG_ENCODING : Enum {
    public UInt32 value__;
    public static CMSG_ENCODING X509_ASN_ENCODING;
    public static CMSG_ENCODING PKCS_7_ASN_ENCODING;
    public static CMSG_ENCODING Any;
}
internal enum NuGet.Packaging.Signing.CMSG_GETPARAM_TYPE : Enum {
    public UInt32 value__;
    public static CMSG_GETPARAM_TYPE CMSG_TYPE_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_CONTENT_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_BARE_CONTENT_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_INNER_CONTENT_TYPE_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_SIGNER_COUNT_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_SIGNER_INFO_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_SIGNER_CERT_INFO_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_SIGNER_HASH_ALGORITHM_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_SIGNER_AUTH_ATTR_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_SIGNER_UNAUTH_ATTR_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_CERT_COUNT_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_CERT_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_CRL_COUNT_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_CRL_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_ENVELOPE_ALGORITHM_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_RECIPIENT_COUNT_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_RECIPIENT_INDEX_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_RECIPIENT_INFO_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_HASH_ALGORITHM_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_HASH_DATA_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_COMPUTED_HASH_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_ENCRYPT_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_ENCRYPTED_DIGEST;
    public static CMSG_GETPARAM_TYPE CMSG_ENCODED_SIGNER;
    public static CMSG_GETPARAM_TYPE CMSG_ENCODED_MESSAGE;
    public static CMSG_GETPARAM_TYPE CMSG_VERSION_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_ATTR_CERT_COUNT_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_ATTR_CERT_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_CMS_RECIPIENT_COUNT_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_CMS_RECIPIENT_INDEX_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_CMS_RECIPIENT_ENCRYPTED_KEY_INDEX_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_CMS_RECIPIENT_INFO_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_UNPROTECTED_ATTR_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_SIGNER_CERT_ID_PARAM;
    public static CMSG_GETPARAM_TYPE CMSG_CMS_SIGNER_INFO_PARAM;
}
[FlagsAttribute]
internal enum NuGet.Packaging.Signing.CMSG_OPENTODECODE_FLAGS : Enum {
    public UInt32 value__;
    public static CMSG_OPENTODECODE_FLAGS None;
    public static CMSG_OPENTODECODE_FLAGS CMSG_DETACHED_FLAG;
    public static CMSG_OPENTODECODE_FLAGS CMSG_CRYPT_RELEASE_CONTEXT_FLAG;
}
internal class NuGet.Packaging.Signing.CMSG_SIGNED_ENCODE_INFO : ValueType {
    internal int cbSize;
    internal int cSigners;
    internal IntPtr rgSigners;
    internal int cCertEncoded;
    internal IntPtr rgCertEncoded;
    internal int cCrlEncoded;
    internal IntPtr rgCrlEncoded;
    internal int cAttrCertEncoded;
    internal IntPtr rgAttrCertEncoded;
}
internal class NuGet.Packaging.Signing.CMSG_SIGNER_ENCODE_INFO : ValueType {
    internal UInt32 cbSize;
    internal IntPtr pCertInfo;
    internal IntPtr hCryptProvOrhNCryptKey;
    internal int dwKeySpec;
    internal CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
    internal IntPtr pvHashAuxInfo;
    internal int cAuthAttr;
    internal IntPtr rgAuthAttr;
    internal int cUnauthAttr;
    internal IntPtr rgUnauthAttr;
    internal CERT_ID SignerId;
    internal CRYPT_ALGORITHM_IDENTIFIER HashEncryptionAlgorithm;
    internal IntPtr pvHashEncryptionAuxInfo;
    public void Dispose();
}
internal class NuGet.Packaging.Signing.CMSG_SIGNER_INFO : ValueType {
    internal UInt32 dwVersion;
    internal CRYPTOAPI_BLOB Issuer;
    internal CRYPTOAPI_BLOB SerialNumber;
    internal CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
    internal CRYPT_ALGORITHM_IDENTIFIER HashEncryptionAlgorithm;
    internal CRYPTOAPI_BLOB EncryptedHash;
    internal CRYPT_ATTRIBUTES AuthAttrs;
    internal CRYPT_ATTRIBUTES UnauthAttrs;
}
public class NuGet.Packaging.Signing.CommitmentTypeIndication : object {
    [CompilerGeneratedAttribute]
private Oid <CommitmentTypeId>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<CommitmentTypeQualifier> <Qualifiers>k__BackingField;
    public Oid CommitmentTypeId { get; }
    public IReadOnlyList`1<CommitmentTypeQualifier> Qualifiers { get; }
    private CommitmentTypeIndication(Oid commitmentTypeId, IReadOnlyList`1<CommitmentTypeQualifier> qualifiers);
    [CompilerGeneratedAttribute]
public Oid get_CommitmentTypeId();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<CommitmentTypeQualifier> get_Qualifiers();
    public static CommitmentTypeIndication Create(Oid commitmentTypeId);
    public static CommitmentTypeIndication Read(Byte[] bytes);
    internal static CommitmentTypeIndication Read(DerSequenceReader reader);
    internal Byte[] Encode();
}
public class NuGet.Packaging.Signing.CommitmentTypeQualifier : object {
    [CompilerGeneratedAttribute]
private Oid <CommitmentTypeIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Qualifier>k__BackingField;
    public Oid CommitmentTypeIdentifier { get; }
    public Byte[] Qualifier { get; }
    private CommitmentTypeQualifier(Oid commitmentTypeIdentifier, Byte[] qualifier);
    [CompilerGeneratedAttribute]
public Oid get_CommitmentTypeIdentifier();
    [CompilerGeneratedAttribute]
public Byte[] get_Qualifier();
    public static CommitmentTypeQualifier Read(Byte[] bytes);
    internal static CommitmentTypeQualifier Read(DerSequenceReader reader);
    internal Byte[] Encode();
}
public static class NuGet.Packaging.Signing.Crc32 : object {
    private static UInt32[] CrcLookUpTable;
    private static bool CrcLookUptableComputed;
    private static UInt32 Crc32Polynomial;
    private static Crc32();
    [CLSCompliantAttribute("False")]
public static UInt32 CalculateCrc(Byte[] data);
    private static UInt32 UpdateCrc(UInt32 crc, Byte[] buf, int len);
    private static void ComputeCrcLookUpTable();
}
internal class NuGet.Packaging.Signing.CRYPT_ALGORITHM_IDENTIFIER : ValueType {
    public string pszObjId;
    public CRYPT_INTEGER_BLOB Parameters;
}
internal class NuGet.Packaging.Signing.CRYPT_ATTRIBUTE : ValueType {
    internal IntPtr pszObjId;
    internal UInt32 cValue;
    internal IntPtr rgValue;
}
internal class NuGet.Packaging.Signing.CRYPT_ATTRIBUTE_STRING : ValueType {
    internal string pszObjId;
    internal UInt32 cValue;
    internal IntPtr rgValue;
}
internal class NuGet.Packaging.Signing.CRYPT_ATTRIBUTES : ValueType {
    internal UInt32 cAttr;
    internal IntPtr rgAttr;
}
internal class NuGet.Packaging.Signing.CRYPT_INTEGER_BLOB : ValueType {
    internal UInt32 cbData;
    internal IntPtr pbData;
}
internal class NuGet.Packaging.Signing.DefaultX509ChainBuildPolicy : object {
    [CompilerGeneratedAttribute]
private static IX509ChainBuildPolicy <Instance>k__BackingField;
    internal static IX509ChainBuildPolicy Instance { get; }
    private static DefaultX509ChainBuildPolicy();
    [CompilerGeneratedAttribute]
internal static IX509ChainBuildPolicy get_Instance();
    public sealed virtual bool Build(IX509Chain chain, X509Certificate2 certificate);
}
internal static class NuGet.Packaging.Signing.DerEncoding.DerEncoder : object {
    private static byte ConstructedFlag;
    private static byte ConstructedSequenceTag;
    private static byte ConstructedSetTag;
    private static Byte[][] s_nullTlv;
    private static DerEncoder();
    private static Byte[] EncodeLength(int length);
    internal static Byte[][] SegmentedEncodeBoolean(bool value);
    internal static Byte[][] SegmentedEncodeUnsignedInteger(UInt32 value);
    internal static Byte[][] SegmentedEncodeUnsignedInteger(Byte[] bigEndianBytes);
    internal static Byte[][] SegmentedEncodeUnsignedInteger(Byte[] bigEndianBytes, int offset, int count);
    internal static Byte[][] SegmentedEncodeBitString(Byte[][][] childSegments);
    internal static Byte[][] SegmentedEncodeBitString(Byte[] data);
    internal static Byte[][] SegmentedEncodeBitString(int unusedBits, Byte[] data);
    internal static Byte[][] SegmentedEncodeNamedBitList(Byte[] bigEndianBytes, int namedBitsCount);
    internal static Byte[][] SegmentedEncodeOctetString(Byte[] data);
    internal static Byte[][] SegmentedEncodeNull();
    internal static Byte[] EncodeOid(string oidValue);
    internal static Byte[][] SegmentedEncodeOid(Oid oid);
    internal static Byte[][] SegmentedEncodeOid(string oidValue);
    internal static Byte[][] SegmentedEncodeUtf8String(Char[] chars);
    internal static Byte[][] SegmentedEncodeUtf8String(Char[] chars, int offset, int count);
    internal static Byte[][] ConstructSegmentedSequence(Byte[][][] items);
    internal static Byte[][] ConstructSegmentedSequence(IEnumerable`1<Byte[][]> items);
    internal static Byte[][] ConstructSegmentedContextSpecificValue(int contextId, Byte[][][] items);
    internal static Byte[][] ConstructSegmentedSet(Byte[][][] items);
    internal static Byte[][] ConstructSegmentedPresortedSet(Byte[][][] items);
    internal static bool IsValidPrintableString(Char[] chars);
    internal static bool IsValidPrintableString(Char[] chars, int offset, int count);
    internal static Byte[][] SegmentedEncodePrintableString(Char[] chars);
    internal static Byte[][] SegmentedEncodePrintableString(Char[] chars, int offset, int count);
    internal static Byte[][] SegmentedEncodeIA5String(Char[] chars);
    internal static Byte[][] SegmentedEncodeIA5String(Char[] chars, int offset, int count);
    internal static Byte[][] SegmentedEncodeUtcTime(DateTime utcTime);
    internal static Byte[][] SegmentedEncodeGeneralizedTime(DateTime utcTime);
    internal static Byte[] ConstructSequence(Byte[][][] items);
    internal static Byte[] ConstructSequence(IEnumerable`1<Byte[][]> items);
    private static BigInteger ParseOidRid(string oidValue, Int32& startIndex);
    private static int AtoI(char c);
    private static void EncodeRid(List`1<byte> encodedData, BigInteger& rid);
    private static bool IsPrintableStringCharacter(char c);
    private static Byte[] ConcatenateArrays(Byte[][][] segments);
    private static Byte[] ConcatenateArrays(IEnumerable`1<Byte[][]> segments);
}
public class NuGet.Packaging.Signing.DerEncoding.DerGeneralizedTime : object {
    [CompilerGeneratedAttribute]
private DateTime <DateTime>k__BackingField;
    public DateTime DateTime { get; }
    private DerGeneralizedTime(DateTime datetime);
    [CompilerGeneratedAttribute]
public DateTime get_DateTime();
    public static DerGeneralizedTime Read(string decodedTime);
}
internal class NuGet.Packaging.Signing.DerEncoding.DerSequenceReader : object {
    internal static byte ContextSpecificTagFlag;
    internal static byte ConstructedFlag;
    internal static byte ContextSpecificConstructedTag0;
    internal static byte ContextSpecificConstructedTag1;
    internal static byte ContextSpecificConstructedTag2;
    internal static byte ContextSpecificConstructedTag3;
    internal static byte ContextSpecificConstructedTag4;
    internal static byte ConstructedSequence;
    internal static byte TagClassMask;
    internal static byte TagNumberMask;
    internal static DateTimeFormatInfo s_validityDateTimeFormatInfo;
    private Byte[] _data;
    private int _end;
    private int _position;
    [CompilerGeneratedAttribute]
private int <ContentLength>k__BackingField;
    internal int ContentLength { get; private set; }
    internal bool HasData { get; }
    private DerSequenceReader(bool startAtPayload, Byte[] data, int offset, int length);
    internal DerSequenceReader(Byte[] data);
    internal DerSequenceReader(Byte[] data, int offset, int length);
    private DerSequenceReader(DerTag tagToEat, Byte[] data, int offset, int length);
    [CompilerGeneratedAttribute]
internal int get_ContentLength();
    [CompilerGeneratedAttribute]
private void set_ContentLength(int value);
    internal static DerSequenceReader CreateForPayload(Byte[] payload);
    internal bool get_HasData();
    internal byte PeekTag();
    internal bool HasTag(DerTag expectedTag);
    internal bool HasTag(byte expectedTag);
    internal void SkipValue();
    internal void ValidateAndSkipDerValue();
    internal Byte[] ReadNextEncodedValue();
    internal bool ReadBoolean();
    internal Byte[] ReadValue(DerTag tag);
    internal int ReadInteger();
    internal Byte[] ReadIntegerBytes();
    internal Byte[] ReadBitString();
    internal Byte[] ReadOctetString();
    internal string ReadOidAsString();
    internal Oid ReadOid();
    internal string ReadUtf8String();
    private DerSequenceReader ReadCollectionWithTag(DerTag expected);
    internal DerSequenceReader ReadSequence();
    internal DerSequenceReader ReadSet();
    internal string ReadPrintableString();
    internal string ReadIA5String();
    internal DateTime ReadX509Date();
    internal DateTime ReadUtcTime();
    internal DateTime ReadGeneralizedTime();
    internal string ReadBMPString();
    internal void ReadNull();
    private static string TrimTrailingNulls(string value);
    private DateTime ReadTime(DerTag timeTag, string formatString);
    private Byte[] ReadContentAsBytes();
    private void EatTag(DerTag expected);
    private static void CheckTag(DerTag expected, Byte[] data, int position);
    private int EatLength();
    private static int ScanContentLength(Byte[] data, int offset, int end, Int32& bytesConsumed);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "16.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class NuGet.Packaging.Signing.DerEncoding.SR : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string Argument_InvalidOidValue { get; }
    internal static string Cryptography_Der_Invalid_Encoding { get; }
    internal static string Cryptography_Invalid_IA5String { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_Argument_InvalidOidValue();
    internal static string get_Cryptography_Der_Invalid_Encoding();
    internal static string get_Cryptography_Invalid_IA5String();
}
internal class NuGet.Packaging.Signing.DotNetDefaultTrustStoreX509ChainFactory : object {
    public sealed virtual IX509Chain Create();
}
internal class NuGet.Packaging.Signing.EndOfCentralDirectoryRecord : object {
    private static IReadOnlyList`1<byte> Signature;
    [CompilerGeneratedAttribute]
private ushort <NumberOfThisDisk>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <NumberOfTheDiskWithTheStartOfTheCentralDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <CountOfEntriesInCentralDirectoryOnThisDisk>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <CountOfEntriesInCentralDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <SizeOfCentralDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <OffsetOfStartOfCentralDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <FileCommentLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <FileComment>k__BackingField;
    [CompilerGeneratedAttribute]
private long <OffsetFromStart>k__BackingField;
    internal ushort NumberOfThisDisk { get; private set; }
    internal ushort NumberOfTheDiskWithTheStartOfTheCentralDirectory { get; private set; }
    internal ushort CountOfEntriesInCentralDirectoryOnThisDisk { get; private set; }
    internal ushort CountOfEntriesInCentralDirectory { get; private set; }
    internal UInt32 SizeOfCentralDirectory { get; private set; }
    internal UInt32 OffsetOfStartOfCentralDirectory { get; private set; }
    internal ushort FileCommentLength { get; private set; }
    internal Byte[] FileComment { get; private set; }
    internal long OffsetFromStart { get; private set; }
    private static EndOfCentralDirectoryRecord();
    [CompilerGeneratedAttribute]
internal ushort get_NumberOfThisDisk();
    [CompilerGeneratedAttribute]
private void set_NumberOfThisDisk(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_NumberOfTheDiskWithTheStartOfTheCentralDirectory();
    [CompilerGeneratedAttribute]
private void set_NumberOfTheDiskWithTheStartOfTheCentralDirectory(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_CountOfEntriesInCentralDirectoryOnThisDisk();
    [CompilerGeneratedAttribute]
private void set_CountOfEntriesInCentralDirectoryOnThisDisk(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_CountOfEntriesInCentralDirectory();
    [CompilerGeneratedAttribute]
private void set_CountOfEntriesInCentralDirectory(ushort value);
    [CompilerGeneratedAttribute]
internal UInt32 get_SizeOfCentralDirectory();
    [CompilerGeneratedAttribute]
private void set_SizeOfCentralDirectory(UInt32 value);
    [CompilerGeneratedAttribute]
internal UInt32 get_OffsetOfStartOfCentralDirectory();
    [CompilerGeneratedAttribute]
private void set_OffsetOfStartOfCentralDirectory(UInt32 value);
    [CompilerGeneratedAttribute]
internal ushort get_FileCommentLength();
    [CompilerGeneratedAttribute]
private void set_FileCommentLength(ushort value);
    [CompilerGeneratedAttribute]
internal Byte[] get_FileComment();
    [CompilerGeneratedAttribute]
private void set_FileComment(Byte[] value);
    [CompilerGeneratedAttribute]
internal long get_OffsetFromStart();
    [CompilerGeneratedAttribute]
private void set_OffsetFromStart(long value);
    internal static EndOfCentralDirectoryRecord Read(BinaryReader reader);
    private static void SeekToEndOfCentralDirectoryRecord(BinaryReader reader);
    private static void ThrowByteSignatureNotFoundException(IReadOnlyList`1<byte> signature);
}
internal static class NuGet.Packaging.Signing.EnvironmentVariableConstants : object {
    internal static string DotNetNuGetSignatureVerification;
}
public class NuGet.Packaging.Signing.EssCertId : object {
    [CompilerGeneratedAttribute]
private Byte[] <CertificateHash>k__BackingField;
    [CompilerGeneratedAttribute]
private IssuerSerial <IssuerSerial>k__BackingField;
    public Byte[] CertificateHash { get; }
    public IssuerSerial IssuerSerial { get; }
    private EssCertId(Byte[] hash, IssuerSerial issuerSerial);
    [CompilerGeneratedAttribute]
public Byte[] get_CertificateHash();
    [CompilerGeneratedAttribute]
public IssuerSerial get_IssuerSerial();
    public static EssCertId Read(Byte[] bytes);
    internal static EssCertId Read(DerSequenceReader reader);
}
public class NuGet.Packaging.Signing.EssCertIdV2 : object {
    [CompilerGeneratedAttribute]
private AlgorithmIdentifier <HashAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <CertificateHash>k__BackingField;
    [CompilerGeneratedAttribute]
private IssuerSerial <IssuerSerial>k__BackingField;
    public AlgorithmIdentifier HashAlgorithm { get; }
    public Byte[] CertificateHash { get; }
    public IssuerSerial IssuerSerial { get; }
    private EssCertIdV2(AlgorithmIdentifier hashAlgorithm, Byte[] hash, IssuerSerial issuerSerial);
    [CompilerGeneratedAttribute]
public AlgorithmIdentifier get_HashAlgorithm();
    [CompilerGeneratedAttribute]
public Byte[] get_CertificateHash();
    [CompilerGeneratedAttribute]
public IssuerSerial get_IssuerSerial();
    public static EssCertIdV2 Create(X509Certificate2 certificate, HashAlgorithmName hashAlgorithmName);
    public static EssCertIdV2 Read(Byte[] bytes);
    internal static EssCertIdV2 Read(DerSequenceReader reader);
    internal Byte[][] Encode();
}
public class NuGet.Packaging.Signing.Extension : object {
    [CompilerGeneratedAttribute]
private Oid <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Critical>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Value>k__BackingField;
    public Oid Id { get; }
    public bool Critical { get; }
    public Byte[] Value { get; }
    private Extension(Oid id, bool critical, Byte[] value);
    [CompilerGeneratedAttribute]
public Oid get_Id();
    [CompilerGeneratedAttribute]
public bool get_Critical();
    [CompilerGeneratedAttribute]
public Byte[] get_Value();
    internal static Extension Read(DerSequenceReader reader);
}
public class NuGet.Packaging.Signing.Extensions : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Extension> <ExtensionsList>k__BackingField;
    public IReadOnlyList`1<Extension> ExtensionsList { get; }
    private Extensions(IReadOnlyList`1<Extension> extensions);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<Extension> get_ExtensionsList();
    public static Extensions Read(Byte[] bytes);
    internal static Extensions Read(DerSequenceReader reader);
}
internal class NuGet.Packaging.Signing.ExtraField : object {
    [CompilerGeneratedAttribute]
private ushort <HeaderId>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <DataSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Data>k__BackingField;
    internal ushort HeaderId { get; private set; }
    internal ushort DataSize { get; private set; }
    internal Byte[] Data { get; private set; }
    protected ExtraField(ushort headerId, ushort dataSize, Byte[] data);
    [CompilerGeneratedAttribute]
internal ushort get_HeaderId();
    [CompilerGeneratedAttribute]
private void set_HeaderId(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_DataSize();
    [CompilerGeneratedAttribute]
private void set_DataSize(ushort value);
    [CompilerGeneratedAttribute]
internal Byte[] get_Data();
    [CompilerGeneratedAttribute]
private void set_Data(Byte[] value);
    internal static bool TryRead(CentralDirectoryHeader header, IReadOnlyList`1& extraFields);
    internal static bool TryRead(LocalFileHeader header, IReadOnlyList`1& extraFields);
    private static bool TryRead(Byte[] extraFieldBytes, bool readUncompressedFileSize, bool readCompressedFileSize, bool readRelativeOffsetOfLocalHeader, bool readDiskNumberStart, IReadOnlyList`1& extraFields);
}
public class NuGet.Packaging.Signing.GeneralName : object {
    [CompilerGeneratedAttribute]
private X500DistinguishedName <DirectoryName>k__BackingField;
    public X500DistinguishedName DirectoryName { get; }
    private GeneralName(X500DistinguishedName directoryName);
    [CompilerGeneratedAttribute]
public X500DistinguishedName get_DirectoryName();
    public static GeneralName Create(X500DistinguishedName distinguishedName);
    public static GeneralName Read(Byte[] bytes);
    internal static GeneralName Read(DerSequenceReader reader);
    internal Byte[][] Encode();
}
internal class NuGet.Packaging.Signing.HeapBlockRetainer : object {
    private List`1<SafeLocalAllocHandle> _blocks;
    public IntPtr Alloc(int cbSize);
    public IntPtr Alloc(int howMany, int cbElement);
    public IntPtr AllocAsciiString(string s);
    public IntPtr AllocBytes(Byte[] data);
    public sealed virtual void Dispose();
}
internal interface NuGet.Packaging.Signing.ICms {
    public abstract virtual Byte[] GetPrimarySignatureSignatureValue();
    public abstract virtual Byte[] GetRepositoryCountersignatureSignatureValue();
    public abstract virtual void AddCertificates(IEnumerable`1<X509Certificate2> certificates);
    public abstract virtual void AddCountersignature(CmsSigner cmsSigner, CngKey privateKey);
    public abstract virtual void AddTimestampToRepositoryCountersignature(SignedCms timestamp);
    public abstract virtual void AddTimestamp(SignedCms timestamp);
    public abstract virtual Byte[] Encode();
}
public class NuGet.Packaging.Signing.IntegrityVerificationProvider : object {
    public sealed virtual Task`1<PackageVerificationResult> GetTrustResultAsync(ISignedPackageReader package, PrimarySignature signature, SignedPackageVerifierSettings settings, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Packaging.Signing.IntegrityVerificationProvider/<VerifyPackageIntegrityAsync>d__1")]
private Task`1<PackageVerificationResult> VerifyPackageIntegrityAsync(ISignedPackageReader package, PrimarySignature signature, SignedPackageVerifierSettings settings);
}
public class NuGet.Packaging.Signing.InvalidSignaturePackageVerificationResult : PackageVerificationResult {
    public InvalidSignaturePackageVerificationResult(SignatureVerificationStatus trust, IEnumerable`1<SignatureLog> issues);
}
public interface NuGet.Packaging.Signing.IPackageSignatureVerifier {
    public abstract virtual Task`1<VerifySignaturesResult> VerifySignaturesAsync(ISignedPackageReader package, SignedPackageVerifierSettings settings, CancellationToken token, Guid telemetryOperationId);
}
public interface NuGet.Packaging.Signing.IRepositorySignature {
    public Uri V3ServiceIndexUrl { get; }
    public IReadOnlyList`1<string> PackageOwners { get; }
    public abstract virtual Uri get_V3ServiceIndexUrl();
    public abstract virtual IReadOnlyList`1<string> get_PackageOwners();
}
internal interface NuGet.Packaging.Signing.IRfc3161TimestampRequest {
    public abstract virtual Task`1<IRfc3161TimestampToken> SubmitRequestAsync(Uri timestampUri, TimeSpan timeout);
    public abstract virtual Byte[] GetNonce();
}
internal interface NuGet.Packaging.Signing.IRfc3161TimestampToken {
    public IRfc3161TimestampTokenInfo TokenInfo { get; }
    public abstract virtual IRfc3161TimestampTokenInfo get_TokenInfo();
    public abstract virtual SignedCms AsSignedCms();
}
internal interface NuGet.Packaging.Signing.IRfc3161TimestampTokenInfo {
    public string PolicyId { get; }
    public DateTimeOffset Timestamp { get; }
    public Nullable`1<long> AccuracyInMicroseconds { get; }
    public Oid HashAlgorithmId { get; }
    public abstract virtual string get_PolicyId();
    public abstract virtual DateTimeOffset get_Timestamp();
    public abstract virtual Nullable`1<long> get_AccuracyInMicroseconds();
    public abstract virtual Oid get_HashAlgorithmId();
    public abstract virtual bool HasMessageHash(Byte[] hash);
    public abstract virtual Byte[] GetNonce();
}
public interface NuGet.Packaging.Signing.ISignature {
    public SignatureType Type { get; }
    public SignerInfo SignerInfo { get; }
    public abstract virtual SignatureType get_Type();
    public abstract virtual SignerInfo get_SignerInfo();
}
public interface NuGet.Packaging.Signing.ISignatureProvider {
    public abstract virtual Task`1<PrimarySignature> CreatePrimarySignatureAsync(SignPackageRequest request, SignatureContent signatureContent, ILogger logger, CancellationToken token);
    public abstract virtual Task`1<PrimarySignature> CreateRepositoryCountersignatureAsync(RepositorySignPackageRequest request, PrimarySignature primarySignature, ILogger logger, CancellationToken token);
}
public interface NuGet.Packaging.Signing.ISignatureVerificationProvider {
    public abstract virtual Task`1<PackageVerificationResult> GetTrustResultAsync(ISignedPackageReader package, PrimarySignature signature, SignedPackageVerifierSettings settings, CancellationToken token);
}
public interface NuGet.Packaging.Signing.ISignedPackage {
}
public interface NuGet.Packaging.Signing.ISignedPackageReader {
    public abstract virtual Task`1<PrimarySignature> GetPrimarySignatureAsync(CancellationToken token);
    public abstract virtual Task`1<bool> IsSignedAsync(CancellationToken token);
    public abstract virtual Task`1<Byte[]> GetArchiveHashAsync(HashAlgorithmName hashAlgorithm, CancellationToken token);
    public abstract virtual Task ValidateIntegrityAsync(SignatureContent signatureContent, CancellationToken token);
    public abstract virtual string GetContentHash(CancellationToken token, Func`1<string> GetUnsignedPackageHash);
    public abstract virtual bool CanVerifySignedPackages(SignedPackageVerifierSettings verifierSettings);
}
public interface NuGet.Packaging.Signing.ISignedPackageWriter {
    public abstract virtual Task RemoveSignatureAsync(CancellationToken token);
    public abstract virtual Task AddSignatureAsync(Stream signatureStream, CancellationToken token);
    public abstract virtual Task`1<bool> IsZip64Async(CancellationToken token);
}
public class NuGet.Packaging.Signing.IssuerSerial : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<GeneralName> <GeneralNames>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <SerialNumber>k__BackingField;
    public IReadOnlyList`1<GeneralName> GeneralNames { get; }
    public Byte[] SerialNumber { get; }
    private IssuerSerial(IReadOnlyList`1<GeneralName> generalNames, Byte[] serialNumber);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<GeneralName> get_GeneralNames();
    [CompilerGeneratedAttribute]
public Byte[] get_SerialNumber();
    public static IssuerSerial Create(X509Certificate2 certificate);
    public static IssuerSerial Read(Byte[] bytes);
    internal static IssuerSerial Read(DerSequenceReader reader);
    internal Byte[][] Encode();
    private static IReadOnlyList`1<GeneralName> ReadGeneralNames(DerSequenceReader reader);
}
public interface NuGet.Packaging.Signing.ITimestampProvider {
    public abstract virtual Task`1<PrimarySignature> TimestampSignatureAsync(PrimarySignature primarySignature, TimestampRequest request, ILogger logger, CancellationToken token);
}
public interface NuGet.Packaging.Signing.ITrustedSignersProvider {
    public abstract virtual IReadOnlyList`1<TrustedSignerItem> GetTrustedSigners();
    public abstract virtual void AddOrUpdateTrustedSigner(TrustedSignerItem trustedSigner);
    public abstract virtual void Remove(IReadOnlyList`1<TrustedSignerItem> trustedSigners);
}
public interface NuGet.Packaging.Signing.IX509CertificateChain {
}
internal interface NuGet.Packaging.Signing.IX509Chain {
    public ILogMessage AdditionalContext { get; }
    public X509Chain PrivateReference { get; }
    public X509ChainElementCollection ChainElements { get; }
    public X509ChainPolicy ChainPolicy { get; }
    public X509ChainStatus[] ChainStatus { get; }
    public abstract virtual ILogMessage get_AdditionalContext();
    public abstract virtual X509Chain get_PrivateReference();
    public abstract virtual X509ChainElementCollection get_ChainElements();
    public abstract virtual X509ChainPolicy get_ChainPolicy();
    public abstract virtual X509ChainStatus[] get_ChainStatus();
    public abstract virtual bool Build(X509Certificate2 certificate);
}
internal interface NuGet.Packaging.Signing.IX509ChainBuildPolicy {
    public abstract virtual bool Build(IX509Chain chain, X509Certificate2 certificate);
}
internal interface NuGet.Packaging.Signing.IX509ChainFactory {
    public abstract virtual IX509Chain Create();
}
public class NuGet.Packaging.Signing.KeyPairFileReader : object {
    private static Regex NamePattern;
    private StreamReader _reader;
    private bool _disposed;
    public KeyPairFileReader(Stream stream, Encoding encoding);
    private static KeyPairFileReader();
    public Dictionary`2<string, string> ReadSection();
    private static KeyValuePair`2<string, string> GetProperty(string line);
    private static void ThrowInvalidFormat();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public static class NuGet.Packaging.Signing.KeyPairFileUtility : object {
    public static string GetValueOrThrow(Dictionary`2<string, string> values, string key);
}
public class NuGet.Packaging.Signing.KeyPairFileWriter : object {
    private StreamWriter _writer;
    private bool _disposed;
    public KeyPairFileWriter(Stream stream, Encoding encoding, bool leaveOpen);
    public void WritePair(string key, string value);
    public void WriteSectionBreak();
    private void WriteEOL();
    private static string FormatItem(string key, string value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
internal class NuGet.Packaging.Signing.LocalFileHeader : object {
    internal static UInt32 SizeInBytesOfFixedLengthFields;
    internal static UInt32 Signature;
    [CompilerGeneratedAttribute]
private ushort <VersionNeededToExtract>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <GeneralPurposeBitFlag>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <CompressionMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <LastModFileTime>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <LastModFileDate>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Crc32>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <CompressedSize>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <UncompressedSize>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <FileNameLength>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <ExtraFieldLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <ExtraField>k__BackingField;
    internal ushort VersionNeededToExtract { get; private set; }
    internal ushort GeneralPurposeBitFlag { get; private set; }
    internal ushort CompressionMethod { get; private set; }
    internal ushort LastModFileTime { get; private set; }
    internal ushort LastModFileDate { get; private set; }
    internal UInt32 Crc32 { get; private set; }
    internal UInt32 CompressedSize { get; private set; }
    internal UInt32 UncompressedSize { get; private set; }
    internal ushort FileNameLength { get; private set; }
    internal ushort ExtraFieldLength { get; private set; }
    internal Byte[] FileName { get; private set; }
    internal Byte[] ExtraField { get; private set; }
    [CompilerGeneratedAttribute]
internal ushort get_VersionNeededToExtract();
    [CompilerGeneratedAttribute]
private void set_VersionNeededToExtract(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_GeneralPurposeBitFlag();
    [CompilerGeneratedAttribute]
private void set_GeneralPurposeBitFlag(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_CompressionMethod();
    [CompilerGeneratedAttribute]
private void set_CompressionMethod(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_LastModFileTime();
    [CompilerGeneratedAttribute]
private void set_LastModFileTime(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_LastModFileDate();
    [CompilerGeneratedAttribute]
private void set_LastModFileDate(ushort value);
    [CompilerGeneratedAttribute]
internal UInt32 get_Crc32();
    [CompilerGeneratedAttribute]
private void set_Crc32(UInt32 value);
    [CompilerGeneratedAttribute]
internal UInt32 get_CompressedSize();
    [CompilerGeneratedAttribute]
private void set_CompressedSize(UInt32 value);
    [CompilerGeneratedAttribute]
internal UInt32 get_UncompressedSize();
    [CompilerGeneratedAttribute]
private void set_UncompressedSize(UInt32 value);
    [CompilerGeneratedAttribute]
internal ushort get_FileNameLength();
    [CompilerGeneratedAttribute]
private void set_FileNameLength(ushort value);
    [CompilerGeneratedAttribute]
internal ushort get_ExtraFieldLength();
    [CompilerGeneratedAttribute]
private void set_ExtraFieldLength(ushort value);
    [CompilerGeneratedAttribute]
internal Byte[] get_FileName();
    [CompilerGeneratedAttribute]
private void set_FileName(Byte[] value);
    [CompilerGeneratedAttribute]
internal Byte[] get_ExtraField();
    [CompilerGeneratedAttribute]
private void set_ExtraField(Byte[] value);
    internal static bool TryRead(BinaryReader reader, LocalFileHeader& header);
}
public class NuGet.Packaging.Signing.MessageImprint : object {
    [CompilerGeneratedAttribute]
private AlgorithmIdentifier <HashAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <HashedMessage>k__BackingField;
    public AlgorithmIdentifier HashAlgorithm { get; }
    public Byte[] HashedMessage { get; }
    private MessageImprint(AlgorithmIdentifier hashAlgorithm, Byte[] hashedMessage);
    [CompilerGeneratedAttribute]
public AlgorithmIdentifier get_HashAlgorithm();
    [CompilerGeneratedAttribute]
public Byte[] get_HashedMessage();
    public static MessageImprint Read(Byte[] bytes);
    internal static MessageImprint Read(DerSequenceReader reader);
}
internal class NuGet.Packaging.Signing.NativeCms : object {
    private SafeCryptMsgHandle _handle;
    private NativeCms(SafeCryptMsgHandle handle);
    internal Byte[] GetPrimarySignatureSignatureValue();
    private Byte[] GetByteArrayAttribute(CMSG_GETPARAM_TYPE param, UInt32 index);
    internal Byte[] GetRepositoryCountersignatureSignatureValue();
    private Nullable`1<RepositoryCounterSignerInfo> GetRepositoryCountersignature(HeapBlockRetainer retainer);
    private static bool IsRepositoryCounterSignerInfo(CMSG_SIGNER_INFO counterSignerInfo);
    private static bool IsRepositoryCounterSignerInfo(CRYPT_ATTRIBUTE_STRING commitmentTypeIndicationAttribute);
    internal static NativeCms Decode(Byte[] input);
    internal void AddCertificates(IEnumerable`1<X509Certificate2> certificates);
    internal void AddCountersignature(CmsSigner cmsSigner, CngKey privateKey);
    internal void AddTimestampToRepositoryCountersignature(SignedCms timestamp);
    internal void AddTimestamp(SignedCms timestamp);
    private static CRYPT_ATTRIBUTE GetCryptAttributeForData(Byte[] data, string attributeOid, HeapBlockRetainer hb);
    private static CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA CreateUnsignedAddAttribute(CRYPT_ATTRIBUTE attr, HeapBlockRetainer hb);
    internal Byte[] Encode();
    public sealed virtual void Dispose();
}
internal class NuGet.Packaging.Signing.NativeCmsWrapper : object {
    private NativeCms _nativeCms;
    public NativeCmsWrapper(NativeCms nativeCms);
    public sealed virtual Byte[] GetPrimarySignatureSignatureValue();
    public sealed virtual Byte[] GetRepositoryCountersignatureSignatureValue();
    public sealed virtual void AddCertificates(IEnumerable`1<X509Certificate2> certificates);
    public sealed virtual void AddCountersignature(CmsSigner cmsSigner, CngKey privateKey);
    public sealed virtual void AddTimestampToRepositoryCountersignature(SignedCms timestamp);
    public sealed virtual void AddTimestamp(SignedCms timestamp);
    public sealed virtual Byte[] Encode();
    public sealed virtual void Dispose();
}
internal static class NuGet.Packaging.Signing.NativeMethods : object {
    internal static UInt32 PKCS_ATTRIBUTE;
    internal static UInt32 PKCS7_SIGNER_INFO;
    internal static int ERROR_MORE_DATA;
    internal static UInt32 CMSG_SIGNED;
    internal static UInt32 CERT_KEY_IDENTIFIER_PROP_ID;
    internal static UInt32 CERT_ID_KEY_IDENTIFIER;
    public static SafeCryptMsgHandle CryptMsgOpenToEncode(CMSG_ENCODING dwMsgEncodingType, UInt32 dwFlags, UInt32 dwMsgType, CMSG_SIGNED_ENCODE_INFO& pvMsgEncodeInfo, string pszInnerContentObjID, IntPtr pStreamInfo);
    public static SafeCryptMsgHandle CryptMsgOpenToDecode(CMSG_ENCODING dwMsgEncodingType, CMSG_OPENTODECODE_FLAGS dwFlags, UInt32 dwMsgType, IntPtr hCryptProv, IntPtr pRecipientInfo, IntPtr pStreamInfo);
    public static bool CryptMsgCountersign(SafeCryptMsgHandle hCryptMsg, UInt32 dwIndex, int cCountersigners, CMSG_SIGNER_ENCODE_INFO rgCountersigners);
    public static bool CryptMsgClose(IntPtr hCryptMsg);
    public static bool CryptMsgUpdate(SafeCryptMsgHandle hCryptMsg, Byte[] pbData, UInt32 cbData, bool fFinal);
    public static bool CryptMsgGetParam(SafeCryptMsgHandle hCryptMsg, CMSG_GETPARAM_TYPE dwParamType, UInt32 dwIndex, Byte[] pvData, UInt32& pcbData);
    internal static bool CryptMsgGetParam(SafeCryptMsgHandle hCryptMsg, CMSG_GETPARAM_TYPE dwParamType, UInt32 dwIndex, IntPtr pvData, UInt32& pcbData);
    internal static bool CryptDecodeObject(CMSG_ENCODING dwCertEncodingType, IntPtr lpszStructType, IntPtr pbEncoded, UInt32 cbEncoded, UInt32 dwFlags, IntPtr pvStructInfo, IntPtr pcbStructInfo);
    internal static bool CryptMsgControl(SafeCryptMsgHandle hCryptMsg, UInt32 dwFlags, CMSG_CONTROL_TYPE dwCtrlType, IntPtr pvCtrlPara);
    internal static bool CryptEncodeObjectEx(CMSG_ENCODING dwCertEncodingType, IntPtr lpszStructType, IntPtr pvStructInfo, UInt32 dwFlags, IntPtr pEncodePara, IntPtr pvEncoded, UInt32& pcbEncoded);
    internal static bool CryptReleaseContext(IntPtr hProv, int dwFlags);
    internal static IntPtr CertDuplicateCertificateContext(IntPtr pCertContext);
    internal static bool CertFreeCertificateContext(IntPtr pCertContext);
    internal static bool CertGetCertificateContextProperty(IntPtr pCertContext, UInt32 dwPropId, IntPtr pvData, UInt32& pcbData);
    internal static int GetHRForWin32Error(int err);
}
internal static class NuGet.Packaging.Signing.NativeUtility : object {
    internal static void SafeFree(IntPtr ptr);
    internal static void ThrowIfFailed(bool result);
    internal static SignedCms NativeSign(CmsSigner cmsSigner, Byte[] data, CngKey privateKey);
    internal static CMSG_SIGNER_ENCODE_INFO CreateSignerInfo(CmsSigner cmsSigner, CngKey privateKey, HeapBlockRetainer hb);
}
public class NuGet.Packaging.Signing.NuGetPackageOwners : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <PackageOwners>k__BackingField;
    public IReadOnlyList`1<string> PackageOwners { get; }
    public NuGetPackageOwners(IReadOnlyList`1<string> packageOwners);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_PackageOwners();
    public static NuGetPackageOwners Read(Byte[] bytes);
    internal static NuGetPackageOwners Read(DerSequenceReader reader);
    public Byte[] Encode();
}
public class NuGet.Packaging.Signing.NuGetV3ServiceIndexUrl : object {
    [CompilerGeneratedAttribute]
private Uri <V3ServiceIndexUrl>k__BackingField;
    public Uri V3ServiceIndexUrl { get; }
    public NuGetV3ServiceIndexUrl(Uri v3ServiceIndexUrl);
    [CompilerGeneratedAttribute]
public Uri get_V3ServiceIndexUrl();
    public static NuGetV3ServiceIndexUrl Read(Byte[] bytes);
    internal static NuGetV3ServiceIndexUrl Read(DerSequenceReader reader);
    public Byte[] Encode();
}
public static class NuGet.Packaging.Signing.Oids : object {
    public static string SigningTime;
    public static string Countersignature;
    public static string SignatureTimeStampTokenAttribute;
    public static string Sha1;
    public static string Sha256;
    public static string Sha384;
    public static string Sha512;
    public static string Sha256WithRSAEncryption;
    public static string Sha384WithRSAEncryption;
    public static string Sha512WithRSAEncryption;
    public static string CodeSigningEku;
    public static string Pkcs7Data;
    public static string BaselineTimestampPolicy;
    public static string TimeStampingEku;
    public static string EnhancedKeyUsage;
    public static string TSTInfoContentType;
    public static string LifetimeSigningEku;
    public static string CommitmentTypeIndication;
    public static string CommitmentTypeIdentifierProofOfOrigin;
    public static string CommitmentTypeIdentifierProofOfReceipt;
    public static string SigningCertificate;
    public static string SigningCertificateV2;
    public static string AuthorityKeyIdentifier;
    public static string SubjectKeyIdentifier;
    public static string AnyPolicy;
    public static string IdQtCps;
    public static string IdQtUnotice;
    public static string NuGetV3ServiceIndexUrl;
    public static string NuGetPackageOwners;
}
public class NuGet.Packaging.Signing.PackageSignatureVerifier : object {
    private List`1<ISignatureVerificationProvider> _verificationProviders;
    public PackageSignatureVerifier(IEnumerable`1<ISignatureVerificationProvider> verificationProviders);
    [AsyncStateMachineAttribute("NuGet.Packaging.Signing.PackageSignatureVerifier/<VerifySignaturesAsync>d__2")]
public sealed virtual Task`1<VerifySignaturesResult> VerifySignaturesAsync(ISignedPackageReader package, SignedPackageVerifierSettings settings, CancellationToken token, Guid parentId);
    private static bool IsValid(IEnumerable`1<PackageVerificationResult> verificationResults);
}
public abstract class NuGet.Packaging.Signing.PackageVerificationResult : object {
    [CompilerGeneratedAttribute]
private SignatureVerificationStatus <Trust>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<SignatureLog> <Issues>k__BackingField;
    public SignatureVerificationStatus Trust { get; }
    public IEnumerable`1<SignatureLog> Issues { get; }
    public PackageVerificationResult(SignatureVerificationStatus trust, IEnumerable`1<SignatureLog> issues);
    [CompilerGeneratedAttribute]
public virtual SignatureVerificationStatus get_Trust();
    [CompilerGeneratedAttribute]
public virtual IEnumerable`1<SignatureLog> get_Issues();
    public IEnumerable`1<ILogMessage> GetWarningIssues();
    public IEnumerable`1<ILogMessage> GetErrorIssues();
}
public class NuGet.Packaging.Signing.PolicyInformation : object {
    [CompilerGeneratedAttribute]
private Oid <PolicyIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<PolicyQualifierInfo> <PolicyQualifiers>k__BackingField;
    public Oid PolicyIdentifier { get; }
    public IReadOnlyList`1<PolicyQualifierInfo> PolicyQualifiers { get; }
    private PolicyInformation(Oid policyIdentifier, IReadOnlyList`1<PolicyQualifierInfo> policyQualifiers);
    [CompilerGeneratedAttribute]
public Oid get_PolicyIdentifier();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<PolicyQualifierInfo> get_PolicyQualifiers();
    public static PolicyInformation Read(Byte[] bytes);
    internal static PolicyInformation Read(DerSequenceReader reader);
    private static IReadOnlyList`1<PolicyQualifierInfo> ReadPolicyQualifiers(DerSequenceReader reader, bool isAnyPolicy);
}
public class NuGet.Packaging.Signing.PolicyQualifierInfo : object {
    [CompilerGeneratedAttribute]
private Oid <PolicyQualifierId>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Qualifier>k__BackingField;
    public Oid PolicyQualifierId { get; }
    public Byte[] Qualifier { get; }
    private PolicyQualifierInfo(Oid policyQualifierId, Byte[] qualifier);
    [CompilerGeneratedAttribute]
public Oid get_PolicyQualifierId();
    [CompilerGeneratedAttribute]
public Byte[] get_Qualifier();
    public static PolicyQualifierInfo Read(Byte[] bytes);
    internal static PolicyQualifierInfo Read(DerSequenceReader reader);
}
public abstract class NuGet.Packaging.Signing.PrimarySignature : Signature {
    [CompilerGeneratedAttribute]
private SignedCms <SignedCms>k__BackingField;
    [CompilerGeneratedAttribute]
private SignatureContent <SignatureContent>k__BackingField;
    public SignedCms SignedCms { get; }
    public SignatureContent SignatureContent { get; }
    public string FriendlyName { get; }
    protected PrimarySignature(SignedCms signedCms, SignatureType signatureType);
    [CompilerGeneratedAttribute]
public SignedCms get_SignedCms();
    [CompilerGeneratedAttribute]
public SignatureContent get_SignatureContent();
    public virtual string get_FriendlyName();
    public void Save(Stream stream);
    public Byte[] GetBytes();
    public static PrimarySignature Load(SignedCms cms);
    public static PrimarySignature Load(Byte[] data);
    public static PrimarySignature Load(Stream stream);
    public virtual Byte[] GetSignatureValue();
    protected virtual void ThrowForInvalidSignature();
    protected static void ThrowForInvalidPrimarySignature();
    private static void VerifySigningCertificate(SignedCms signedCms, SignerInfo signerInfo, SigningSpecifications signingSpecifications);
    private static SignerInfo GetSignerInfo(SignedCms signedCms);
    private static SignedCms Decode(Byte[] bytes);
}
public static class NuGet.Packaging.Signing.PrimarySignatureFactory : object {
    public static PrimarySignature CreateSignature(SignedCms signedCms);
}
public class NuGet.Packaging.Signing.ReadOnlyBufferedStream : Stream {
    private static int _defaultBufferSize;
    private Byte[] _buffer;
    private bool _leaveOpen;
    private Lazy`1<long> _length;
    private Stream _stream;
    private long _bufferStartPosition;
    private int _bufferFillLength;
    private bool _isDisposed;
    private long _position;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public ReadOnlyBufferedStream(Stream stream, bool leaveOpen);
    public ReadOnlyBufferedStream(Stream stream, bool leaveOpen, int bufferSize);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    private void FillBuffer();
    private bool IsPositionAfterEndOfStream();
    private bool IsPositionInBuffer();
    private void ThrowIfDisposed();
    [CompilerGeneratedAttribute]
private long <.ctor>b__29_0();
}
public class NuGet.Packaging.Signing.RepositoryCountersignature : Signature {
    private PrimarySignature _primarySignature;
    [CompilerGeneratedAttribute]
private Uri <V3ServiceIndexUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <PackageOwners>k__BackingField;
    public Uri V3ServiceIndexUrl { get; }
    public IReadOnlyList`1<string> PackageOwners { get; }
    public string FriendlyName { get; }
    private RepositoryCountersignature(PrimarySignature primarySignature, SignerInfo counterSignerInfo, Uri v3ServiceIndexUrl, IReadOnlyList`1<string> packageOwners);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_V3ServiceIndexUrl();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<string> get_PackageOwners();
    public virtual string get_FriendlyName();
    public static RepositoryCountersignature GetRepositoryCountersignature(PrimarySignature primarySignature);
    public virtual Byte[] GetSignatureValue();
    protected virtual void ThrowForInvalidSignature();
    public virtual SignatureVerificationSummary Verify(Timestamp timestamp, SignatureVerifySettings settings, HashAlgorithmName fingerprintAlgorithm, X509Certificate2Collection certificateExtraStore);
    internal bool IsRelated(PrimarySignature primarySignature);
}
public class NuGet.Packaging.Signing.RepositoryPrimarySignature : PrimarySignature {
    [CompilerGeneratedAttribute]
private Uri <V3ServiceIndexUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <PackageOwners>k__BackingField;
    public Uri V3ServiceIndexUrl { get; }
    public IReadOnlyList`1<string> PackageOwners { get; }
    public string FriendlyName { get; }
    public RepositoryPrimarySignature(SignedCms signedCms);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_V3ServiceIndexUrl();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<string> get_PackageOwners();
    public virtual string get_FriendlyName();
    public virtual SignatureVerificationSummary Verify(Timestamp timestamp, SignatureVerifySettings settings, HashAlgorithmName fingerprintAlgorithm, X509Certificate2Collection certificateExtraStore);
}
public static class NuGet.Packaging.Signing.RepositorySignatureInfoUtility : object {
    public static SignedPackageVerifierSettings GetSignedPackageVerifierSettings(RepositorySignatureInfo repoSignatureInfo, SignedPackageVerifierSettings fallbackSettings);
    public static IReadOnlyCollection`1<CertificateHashAllowListEntry> GetRepositoryAllowList(IEnumerable`1<IRepositoryCertificateInfo> repositoryCertificateInfos);
}
public class NuGet.Packaging.Signing.RepositorySignPackageRequest : SignPackageRequest {
    [CompilerGeneratedAttribute]
private Uri <V3ServiceIndexUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <PackageOwners>k__BackingField;
    public Uri V3ServiceIndexUrl { get; }
    public IReadOnlyList`1<string> PackageOwners { get; }
    public SignatureType SignatureType { get; }
    public RepositorySignPackageRequest(X509Certificate2 certificate, HashAlgorithmName signatureHashAlgorithm, HashAlgorithmName timestampHashAlgorithm, Uri v3ServiceIndexUrl, IReadOnlyList`1<string> packageOwners);
    [CompilerGeneratedAttribute]
public Uri get_V3ServiceIndexUrl();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_PackageOwners();
    public virtual SignatureType get_SignatureType();
}
internal class NuGet.Packaging.Signing.RetriableX509ChainBuildPolicy : object {
    [CompilerGeneratedAttribute]
private IX509ChainBuildPolicy <InnerPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RetryCount>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <SleepInterval>k__BackingField;
    internal IX509ChainBuildPolicy InnerPolicy { get; }
    internal int RetryCount { get; }
    internal TimeSpan SleepInterval { get; }
    internal RetriableX509ChainBuildPolicy(IX509ChainBuildPolicy innerPolicy, int retryCount, TimeSpan sleepInterval);
    [CompilerGeneratedAttribute]
internal IX509ChainBuildPolicy get_InnerPolicy();
    [CompilerGeneratedAttribute]
internal int get_RetryCount();
    [CompilerGeneratedAttribute]
internal TimeSpan get_SleepInterval();
    public sealed virtual bool Build(IX509Chain chain, X509Certificate2 certificate);
}
public class NuGet.Packaging.Signing.Rfc3161TimestampProvider : object {
    private Uri _timestamperUrl;
    private static TimeSpan RequestTimeout;
    public Rfc3161TimestampProvider(Uri timeStampServerUrl);
    private static Rfc3161TimestampProvider();
    [AsyncStateMachineAttribute("NuGet.Packaging.Signing.Rfc3161TimestampProvider/<TimestampSignatureAsync>d__3")]
public sealed virtual Task`1<PrimarySignature> TimestampSignatureAsync(PrimarySignature primarySignature, TimestampRequest request, ILogger logger, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Packaging.Signing.Rfc3161TimestampProvider/<GetTimestampAsync>d__4")]
internal Task`1<SignedCms> GetTimestampAsync(TimestampRequest request, ILogger logger, CancellationToken token);
    private static SignedCms EnsureCertificatesInCertificatesCollection(SignedCms timestamp, IReadOnlyList`1<X509Certificate2> chain);
    private static void ValidateTimestampCms(SigningSpecifications spec, SignedCms timestampCms, IRfc3161TimestampToken timestampToken);
    private static void ValidateTimestampResponse(Byte[] nonce, Byte[] messageHash, IRfc3161TimestampToken timestampToken);
    private static string GetNameOrOidString(Oid oid);
    private static Byte[] GenerateNonce();
    internal static void EnsureValidNonce(Byte[] nonce);
}
internal class NuGet.Packaging.Signing.Rfc3161TimestampRequest : AsnEncodedData {
    private DataType _data;
    private DataType Data { get; }
    public int Version { get; }
    public Oid HashAlgorithmId { get; }
    public Oid RequestedPolicyId { get; }
    public bool RequestSignerCertificate { get; }
    public bool HasExtensions { get; }
    public Rfc3161TimestampRequest(Byte[] encodedRequest);
    public Rfc3161TimestampRequest(Byte[] messageHash, HashAlgorithmName hashAlgorithm, Oid requestedPolicyId, Byte[] nonce, bool requestSignerCertificates, X509ExtensionCollection extensions);
    public Rfc3161TimestampRequest(Byte[] messageHash, Oid hashAlgorithmId, Oid requestedPolicyId, Byte[] nonce, bool requestSignerCertificates, X509ExtensionCollection extensions);
    private DataType get_Data();
    private static Oid OpportunisticOid(string oidValue, OidGroup group);
    public int get_Version();
    public Byte[] GetMessageHash();
    public Oid get_HashAlgorithmId();
    public Oid get_RequestedPolicyId();
    public Byte[] GetNonce();
    public bool get_RequestSignerCertificate();
    public bool get_HasExtensions();
    public X509ExtensionCollection GetExtensions();
    public IRfc3161TimestampToken SubmitRequest(Uri timestampUri, TimeSpan timeout);
    private static Byte[] Encode(DataType data);
    private static DataType Decode(Byte[] rawData);
    private static bool ResolveAlgorithm(HashAlgorithmName hashAlgorithm, Int32& expectedSizeInBytes, String& algorithmIdentifier);
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
}
internal class NuGet.Packaging.Signing.Rfc3161TimestampRequestFactory : object {
    public static IRfc3161TimestampRequest Create(Byte[] messageHash, HashAlgorithmName hashAlgorithm, Oid requestedPolicyId, Byte[] nonce, bool requestSignerCertificates, X509ExtensionCollection extensions);
}
internal class NuGet.Packaging.Signing.Rfc3161TimestampRequestNet472Wrapper : object {
    private Rfc3161TimestampRequest _rfc3161TimestampRequest;
    public Rfc3161TimestampRequestNet472Wrapper(Byte[] messageHash, HashAlgorithmName hashAlgorithm, Oid requestedPolicyId, Byte[] nonce, bool requestSignerCertificates, X509ExtensionCollection extensions);
    public sealed virtual Task`1<IRfc3161TimestampToken> SubmitRequestAsync(Uri timestampUri, TimeSpan timeout);
    public sealed virtual Byte[] GetNonce();
}
internal class NuGet.Packaging.Signing.Rfc3161TimestampToken : object {
    private Byte[] _encoded;
    [CompilerGeneratedAttribute]
private IRfc3161TimestampTokenInfo <TokenInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate2 <SignerCertificate>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate2Collection <AdditionalCerts>k__BackingField;
    public IRfc3161TimestampTokenInfo TokenInfo { get; }
    public X509Certificate2 SignerCertificate { get; }
    public X509Certificate2Collection AdditionalCerts { get; }
    internal Rfc3161TimestampToken(IRfc3161TimestampTokenInfo tstInfo, X509Certificate2 signerCertificate, X509Certificate2Collection additionalCerts, Byte[] encoded);
    [CompilerGeneratedAttribute]
public IRfc3161TimestampTokenInfo get_TokenInfo();
    [CompilerGeneratedAttribute]
public X509Certificate2 get_SignerCertificate();
    [CompilerGeneratedAttribute]
public X509Certificate2Collection get_AdditionalCerts();
    public Byte[] GetEncodedValue();
    public SignedCms AsSignedCms();
    public static Rfc3161TimestampToken LoadOnly(Byte[] encodedToken);
    public static Rfc3161TimestampToken LoadAndVerifyData(Byte[] encodedToken, Byte[] data);
    public static Rfc3161TimestampToken LoadAndVerifyHash(Byte[] encodedToken, Byte[] hash);
    private static Rfc3161TimestampToken CryptVerifyTimeStampSignature(Byte[] encodedToken, Byte[] data);
}
internal class NuGet.Packaging.Signing.Rfc3161TimestampTokenFactory : object {
    public static IRfc3161TimestampToken Create(IRfc3161TimestampTokenInfo tstInfo, X509Certificate2 signerCertificate, X509Certificate2Collection additionalCerts, Byte[] encoded);
}
public class NuGet.Packaging.Signing.Rfc3161TimestampTokenInfo : AsnEncodedData {
    public static string TimestampTokenInfoId;
    private TstInfo _decoded;
    private TstInfo Decoded { get; }
    public int Version { get; }
    public string PolicyId { get; }
    public Oid HashAlgorithmId { get; }
    public DateTimeOffset Timestamp { get; }
    public Nullable`1<long> AccuracyInMicroseconds { get; }
    public bool IsOrdering { get; }
    public bool HasExtensions { get; }
    public Rfc3161TimestampTokenInfo(Byte[] timestampTokenInfo);
    internal Rfc3161TimestampTokenInfo(IntPtr pTsContext);
    private TstInfo get_Decoded();
    public int get_Version();
    public string get_PolicyId();
    public Oid get_HashAlgorithmId();
    public Byte[] GetMessageHash();
    public bool HasMessageHash(Byte[] hash);
    public Byte[] GetSerialNumber();
    public DateTimeOffset get_Timestamp();
    public Nullable`1<long> get_AccuracyInMicroseconds();
    public bool get_IsOrdering();
    public Byte[] GetNonce();
    public Byte[] GetTimestampAuthorityName();
    public bool get_HasExtensions();
    public X509ExtensionCollection GetExtensions();
    internal static X509ExtensionCollection ShallowCopy(X509ExtensionCollection existing, bool preserveNull);
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    internal static Byte[] CopyFromNative(CRYPTOAPI_BLOB& blob);
}
internal class NuGet.Packaging.Signing.Rfc3161TimestampTokenInfoFactory : object {
    public static IRfc3161TimestampTokenInfo Create(Byte[] bytes);
}
internal class NuGet.Packaging.Signing.Rfc3161TimestampTokenInfoNet472Wrapper : object {
    private Rfc3161TimestampTokenInfo _rfc3161TimestampTokenInfo;
    public string PolicyId { get; }
    public DateTimeOffset Timestamp { get; }
    public Nullable`1<long> AccuracyInMicroseconds { get; }
    public Oid HashAlgorithmId { get; }
    public Rfc3161TimestampTokenInfoNet472Wrapper(Byte[] timestampTokenInfo);
    public Rfc3161TimestampTokenInfoNet472Wrapper(Rfc3161TimestampTokenInfo timestampTokenInfo);
    public sealed virtual string get_PolicyId();
    public sealed virtual DateTimeOffset get_Timestamp();
    public sealed virtual Nullable`1<long> get_AccuracyInMicroseconds();
    public sealed virtual Oid get_HashAlgorithmId();
    public sealed virtual bool HasMessageHash(Byte[] hash);
    public sealed virtual Byte[] GetNonce();
}
internal class NuGet.Packaging.Signing.Rfc3161TimestampTokenNet472Wrapper : object {
    private Rfc3161TimestampToken _rfc3161TimestampToken;
    public IRfc3161TimestampTokenInfo TokenInfo { get; }
    public Rfc3161TimestampTokenNet472Wrapper(IRfc3161TimestampTokenInfo tstInfo, X509Certificate2 signerCertificate, X509Certificate2Collection additionalCerts, Byte[] encoded);
    public sealed virtual IRfc3161TimestampTokenInfo get_TokenInfo();
    public sealed virtual SignedCms AsSignedCms();
}
[ExtensionAttribute]
internal static class NuGet.Packaging.Signing.Rfc3161TimestampUtils : object {
    internal static bool IsLegalOid(string algorithmIdentifier);
    [ExtensionAttribute]
public static Byte[] GetSignature(SignerInfo signerInfo);
    [ExtensionAttribute]
internal static string ByteArrayToHex(Byte[] bytes);
    [ExtensionAttribute]
internal static Byte[] HexToByteArray(string hexString);
}
internal static class NuGet.Packaging.Signing.Rfc3161TimestampVerificationUtility : object {
    internal static bool ValidateSignerCertificateAgainstTimestamp(X509Certificate2 signerCertificate, Timestamp timestamp);
    internal static bool TryReadTSTInfoFromSignedCms(SignedCms timestampCms, IRfc3161TimestampTokenInfo& tstInfo);
    internal static double GetAccuracyInMilliseconds(IRfc3161TimestampTokenInfo tstInfo);
}
internal static class NuGet.Packaging.Signing.Rfc3161TimestampWin32 : object {
    internal static IntPtr TIMESTAMP_REQUEST;
    internal static IntPtr TIMESTAMP_INFO;
    private static Rfc3161TimestampWin32();
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static bool CryptRetrieveTimeStamp(string wszUrl, CryptRetrieveTimeStampFlags dwRetrievalFlags, int dwTimeout, string pszHashId, CRYPT_TIMESTAMP_PARA& pPara, Byte[] pbData, int cbData, IntPtr& ppTsContext, IntPtr& ppTsSigner, IntPtr& phStore);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static bool CryptVerifyTimeStampSignature(Byte[] pbTSContentInfo, int cbTSContentInfo, Byte[] pbData, int cbData, IntPtr hAdditionalStore, IntPtr& ppTsContext, IntPtr& ppTsSigner, IntPtr& phStore);
    [DefaultDllImportSearchPathsAttribute("2048")]
public static bool CryptEncodeObjectEx(CryptEncodingTypes dwCertEncodingType, IntPtr lpszStructType, IntPtr pvStructInfo, CryptEncodeObjectFlags dwFlags, IntPtr pEncodePara, IntPtr pvEncoded, UInt32& pcbEncoded);
    [DefaultDllImportSearchPathsAttribute("2048")]
public static bool CryptDecodeObjectEx(CryptEncodingTypes dwCertEncodingType, IntPtr lpszStructType, IntPtr pbEncoded, int cbEncoded, CryptDecodeObjectFlags dwFlags, IntPtr pDecodePara, IntPtr pvStructInfo, Int32& pcbStructInfo);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static bool CertFreeCertificateContext(IntPtr pCertContext);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static bool CertCloseStore(IntPtr pCertContext, int dwFlags);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static void CryptMemFree(IntPtr pv);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static IntPtr LocalFree(IntPtr handle);
}
internal class NuGet.Packaging.Signing.SafeCryptMsgHandle : SafeHandle {
    internal static SafeCryptMsgHandle InvalidHandle { get; }
    public bool IsInvalid { get; }
    internal SafeCryptMsgHandle(IntPtr handle);
    internal SafeCryptMsgHandle(IntPtr handle, bool ownsHandle);
    internal static SafeCryptMsgHandle get_InvalidHandle();
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
internal class NuGet.Packaging.Signing.SafeLocalAllocHandle : SafeHandle {
    public bool IsInvalid { get; }
    internal SafeLocalAllocHandle(IntPtr handle);
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
public abstract class NuGet.Packaging.Signing.Signature : object {
    private Lazy`1<IReadOnlyList`1<Timestamp>> _timestamps;
    [CompilerGeneratedAttribute]
private SignatureType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private SignerInfo <SignerInfo>k__BackingField;
    private IDictionary`2<HashAlgorithmName, string> _signingCertificateFingerprintLookup;
    public SignatureType Type { get; }
    public IReadOnlyList`1<Timestamp> Timestamps { get; }
    public SignerInfo SignerInfo { get; }
    public string FriendlyName { get; }
    protected Signature(SignerInfo signerInfo, SignatureType type);
    [CompilerGeneratedAttribute]
public sealed virtual SignatureType get_Type();
    public IReadOnlyList`1<Timestamp> get_Timestamps();
    [CompilerGeneratedAttribute]
public sealed virtual SignerInfo get_SignerInfo();
    public abstract virtual Byte[] GetSignatureValue();
    protected abstract virtual void ThrowForInvalidSignature();
    public virtual string get_FriendlyName();
    internal bool TryGetValidTimestamp(SignedPackageVerifierSettings settings, HashAlgorithmName fingerprintAlgorithm, List`1<SignatureLog> issues, SignatureVerificationStatusFlags& verificationFlags, Timestamp& validTimestamp);
    public virtual SignatureVerificationSummary Verify(Timestamp timestamp, SignatureVerifySettings settings, HashAlgorithmName fingerprintAlgorithm, X509Certificate2Collection certificateExtraStore);
    public string GetSigningCertificateFingerprint(HashAlgorithmName algorithm);
    private void VerifySigningTimeAttribute(SignerInfo signerInfo);
    private static IReadOnlyList`1<Timestamp> GetTimestamps(SignerInfo signer, string signatureFriendlyName);
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Timestamp> <.ctor>b__11_0();
}
public class NuGet.Packaging.Signing.SignatureContent : object {
    private SigningSpecifications _signingSpecifications;
    [CompilerGeneratedAttribute]
private HashAlgorithmName <HashAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HashValue>k__BackingField;
    public HashAlgorithmName HashAlgorithm { get; }
    public string HashValue { get; }
    public SignatureContent(SigningSpecifications signingSpecifications, HashAlgorithmName hashAlgorithm, string hashValue);
    [CompilerGeneratedAttribute]
public HashAlgorithmName get_HashAlgorithm();
    [CompilerGeneratedAttribute]
public string get_HashValue();
    private void Save(Stream stream);
    public Byte[] GetBytes();
    public static SignatureContent Load(Byte[] bytes, SigningSpecifications signingSpecifications);
    private static SignatureContent Load(Stream stream, SigningSpecifications signingSpecifications);
    private static void ThrowIfEmpty(Dictionary`2<string, string> properties);
    private static bool TryReadPackageHashProperty(KeyValuePair`2<string, string> property, SigningSpecifications signingSpecifications, HashAlgorithmName& hashAlgorithmName);
    private static void ThrowIfSignatureFormatVersionIsUnsupported(Dictionary`2<string, string> properties, SigningSpecifications signingSpecifications);
}
public class NuGet.Packaging.Signing.SignatureException : PackagingException {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<PackageVerificationResult> <Results>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageIdentity <PackageIdentity>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <VerifyDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetLogCode <Code>k__BackingField;
    public IReadOnlyList`1<PackageVerificationResult> Results { get; }
    public PackageIdentity PackageIdentity { get; }
    public TimeSpan VerifyDuration { get; public set; }
    public NuGetLogCode Code { get; }
    public SignatureException(NuGetLogCode code, string message);
    public SignatureException(NuGetLogCode code, string message, Exception innerException);
    public SignatureException(string message);
    public SignatureException(IReadOnlyList`1<PackageVerificationResult> results, PackageIdentity package);
    public SignatureException(NuGetLogCode code, string message, PackageIdentity package);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<PackageVerificationResult> get_Results();
    [CompilerGeneratedAttribute]
public PackageIdentity get_PackageIdentity();
    [CompilerGeneratedAttribute]
public TimeSpan get_VerifyDuration();
    [CompilerGeneratedAttribute]
public void set_VerifyDuration(TimeSpan value);
    [CompilerGeneratedAttribute]
public NuGetLogCode get_Code();
}
public class NuGet.Packaging.Signing.SignatureLog : object {
    [CompilerGeneratedAttribute]
private LogLevel <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetLogCode <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private WarningLevel <WarningLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectPath>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Time>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LibraryId>k__BackingField;
    public LogLevel Level { get; public set; }
    public string Message { get; public set; }
    public NuGetLogCode Code { get; public set; }
    public WarningLevel WarningLevel { get; public set; }
    public string ProjectPath { get; public set; }
    public DateTimeOffset Time { get; public set; }
    public string LibraryId { get; public set; }
    private SignatureLog(LogLevel level, NuGetLogCode code, string message);
    [CompilerGeneratedAttribute]
public sealed virtual LogLevel get_Level();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Level(LogLevel value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Message();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Message(string value);
    [CompilerGeneratedAttribute]
public sealed virtual NuGetLogCode get_Code();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Code(NuGetLogCode value);
    [CompilerGeneratedAttribute]
public sealed virtual WarningLevel get_WarningLevel();
    [CompilerGeneratedAttribute]
public sealed virtual void set_WarningLevel(WarningLevel value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ProjectPath();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ProjectPath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_Time();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Time(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public string get_LibraryId();
    [CompilerGeneratedAttribute]
public void set_LibraryId(string value);
    public static SignatureLog MinimalLog(string message);
    public static SignatureLog InformationLog(string message);
    public static SignatureLog DetailedLog(string message);
    public static SignatureLog DebugLog(string message);
    public static SignatureLog Issue(bool fatal, NuGetLogCode code, string message);
    public static SignatureLog Error(NuGetLogCode code, string message);
    public sealed virtual bool Equals(SignatureLog other);
    public RestoreLogMessage AsRestoreLogMessage();
}
[FlagsAttribute]
public enum NuGet.Packaging.Signing.SignaturePlacement : Enum {
    public int value__;
    public static SignaturePlacement PrimarySignature;
    public static SignaturePlacement Countersignature;
    public static SignaturePlacement Any;
}
public class NuGet.Packaging.Signing.SignatureTrustAndValidityVerificationProvider : object {
    private HashAlgorithmName _fingerprintAlgorithm;
    private IEnumerable`1<KeyValuePair`2<string, HashAlgorithmName>> _allowUntrustedRootList;
    public SignatureTrustAndValidityVerificationProvider(IEnumerable`1<KeyValuePair`2<string, HashAlgorithmName>> allowUntrustedRootList);
    public sealed virtual Task`1<PackageVerificationResult> GetTrustResultAsync(ISignedPackageReader package, PrimarySignature signature, SignedPackageVerifierSettings settings, CancellationToken token);
    private PackageVerificationResult Verify(PrimarySignature signature, SignedPackageVerifierSettings settings);
    private SignatureVerificationSummary GetTimestamp(Signature signature, SignedPackageVerifierSettings verifierSettings, Timestamp& timestamp);
    private SignatureVerificationSummary VerifyValidityAndTrust(Signature signature, SignedPackageVerifierSettings verifierSettings, SignatureVerifySettings settings, X509Certificate2Collection certificateExtraStore);
    private bool IsUntrustedRootAllowed(Signature signature);
    private static bool HasUntrustedRoot(SignatureVerificationSummary summary);
    private static bool IsSignatureExpired(SignatureVerificationSummary summary);
}
public enum NuGet.Packaging.Signing.SignatureType : Enum {
    public int value__;
    public static SignatureType Unknown;
    public static SignatureType Author;
    public static SignatureType Repository;
}
public static class NuGet.Packaging.Signing.SignatureUtility : object {
    private static int SHA1HashLength;
    public static IX509CertificateChain GetCertificateChain(PrimarySignature primarySignature);
    public static IX509CertificateChain GetCertificateChain(PrimarySignature primarySignature, RepositoryCountersignature repositoryCountersignature);
    internal static IX509CertificateChain GetCertificateChain(SignedCms signedCms, SignerInfo signerInfo, SigningSpecifications signingSpecifications, string signatureFriendlyName);
    private static IX509CertificateChain GetPrimarySignatureCertificates(SignedCms signedCms, SignerInfo signerInfo, SigningSpecifications signingSpecifications, string signatureFriendlyName, bool includeChain);
    public static IX509CertificateChain GetTimestampCertificateChain(PrimarySignature primarySignature);
    public static IX509CertificateChain GetTimestampCertificateChain(PrimarySignature primarySignature, RepositoryCountersignature repositoryCountersignature);
    private static IX509CertificateChain GetRepositoryCountersignatureCertificates(SignedCms signedCms, SignerInfo signerInfo, SigningSpecifications signingSpecifications, bool includeChain);
    public static bool HasRepositoryCountersignature(PrimarySignature primarySignature);
    internal static void LogAdditionalContext(IX509Chain chain, List`1<SignatureLog> issues);
    internal static IX509CertificateChain GetTimestampCertificates(SignedCms signedCms, SigningSpecifications signingSpecifications, string signatureFriendlyName);
    private static IX509CertificateChain GetTimestampCertificates(SignedCms signedCms, SigningSpecifications signingSpecifications, string signatureFriendlyName, bool includeChain);
    private static IX509CertificateChain GetCertificates(SignedCms signedCms, SignerInfo signerInfo, SigningCertificateRequirement signingCertificateRequirement, bool isIssuerSerialRequired, Errors errors, SigningSpecifications signingSpecifications, CertificateType certificateType, bool includeChain);
    private static bool IsMatch(X509Certificate2 certificate, EssCertIdV2 essCertIdV2, Errors errors, bool isIssuerSerialRequired);
    private static bool IsMatch(X509Certificate2 certificate, EssCertId essCertId);
    private static bool AreGeneralNamesEqual(IssuerSerial issuerSerial, X509Certificate2 certificate);
    private static bool AreSerialNumbersEqual(IssuerSerial issuerSerial, X509Certificate2 certificate);
    private static IX509CertificateChain GetCertificateChain(X509Certificate2 certificate, X509Certificate2Collection extraStore, CertificateType certificateType, bool includeCertificatesAfterSigningCertificate);
    private static DerSequenceReader CreateDerSequenceReader(CryptographicAttributeObject attribute);
}
public enum NuGet.Packaging.Signing.SignatureVerificationBehavior : Enum {
    public int value__;
    public static SignatureVerificationBehavior Never;
    public static SignatureVerificationBehavior IfExists;
    public static SignatureVerificationBehavior IfExistsAndIsNecessary;
    public static SignatureVerificationBehavior Always;
}
public enum NuGet.Packaging.Signing.SignatureVerificationStatus : Enum {
    public int value__;
    public static SignatureVerificationStatus Unknown;
    public static SignatureVerificationStatus Suspect;
    public static SignatureVerificationStatus Disallowed;
    public static SignatureVerificationStatus Valid;
}
[FlagsAttribute]
public enum NuGet.Packaging.Signing.SignatureVerificationStatusFlags : Enum {
    public int value__;
    public static SignatureVerificationStatusFlags NoErrors;
    public static SignatureVerificationStatusFlags NoSignature;
    public static SignatureVerificationStatusFlags NoCertificate;
    public static SignatureVerificationStatusFlags MultipleSignatures;
    public static SignatureVerificationStatusFlags SignatureCheckFailed;
    public static SignatureVerificationStatusFlags SignatureAlgorithmUnsupported;
    public static SignatureVerificationStatusFlags CertificatePublicKeyInvalid;
    public static SignatureVerificationStatusFlags HasLifetimeSigningEku;
    public static SignatureVerificationStatusFlags CertificateValidityInTheFuture;
    public static SignatureVerificationStatusFlags CertificateExpired;
    public static SignatureVerificationStatusFlags HashAlgorithmUnsupported;
    public static SignatureVerificationStatusFlags MessageImprintUnsupportedAlgorithm;
    public static SignatureVerificationStatusFlags IntegrityCheckFailed;
    public static SignatureVerificationStatusFlags ChainBuildingFailure;
    public static SignatureVerificationStatusFlags UnknownRevocation;
    public static SignatureVerificationStatusFlags CertificateRevoked;
    public static SignatureVerificationStatusFlags UntrustedRoot;
    public static SignatureVerificationStatusFlags GeneralizedTimeOutsideValidity;
    public static SignatureVerificationStatusFlags NoValidTimestamp;
    public static SignatureVerificationStatusFlags MultipleTimestamps;
    public static SignatureVerificationStatusFlags UnknownBuildStatus;
    public static SignatureVerificationStatusFlags Suspect;
    public static SignatureVerificationStatusFlags Illegal;
    public static SignatureVerificationStatusFlags Untrusted;
}
public class NuGet.Packaging.Signing.SignatureVerificationSummary : object {
    [CompilerGeneratedAttribute]
private SignatureType <SignatureType>k__BackingField;
    [CompilerGeneratedAttribute]
private SignatureVerificationStatus <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private SignatureVerificationStatusFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private Timestamp <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <ExpirationTime>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<SignatureLog> <Issues>k__BackingField;
    public SignatureType SignatureType { get; }
    public SignatureVerificationStatus Status { get; }
    public SignatureVerificationStatusFlags Flags { get; }
    public Timestamp Timestamp { get; }
    public Nullable`1<DateTimeOffset> ExpirationTime { get; }
    public IEnumerable`1<SignatureLog> Issues { get; public set; }
    public SignatureVerificationSummary(SignatureType signatureType, SignatureVerificationStatus status, SignatureVerificationStatusFlags flags, Timestamp timestamp, Nullable`1<DateTimeOffset> expirationTime, IEnumerable`1<SignatureLog> issues);
    public SignatureVerificationSummary(SignatureType signatureType, SignatureVerificationStatus status, SignatureVerificationStatusFlags flags, Timestamp timestamp, IEnumerable`1<SignatureLog> issues);
    public SignatureVerificationSummary(SignatureType signatureType, SignatureVerificationStatus status, SignatureVerificationStatusFlags flags, IEnumerable`1<SignatureLog> issues);
    [CompilerGeneratedAttribute]
public SignatureType get_SignatureType();
    [CompilerGeneratedAttribute]
public SignatureVerificationStatus get_Status();
    [CompilerGeneratedAttribute]
public SignatureVerificationStatusFlags get_Flags();
    [CompilerGeneratedAttribute]
public Timestamp get_Timestamp();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_ExpirationTime();
    [CompilerGeneratedAttribute]
public IEnumerable`1<SignatureLog> get_Issues();
    [CompilerGeneratedAttribute]
public void set_Issues(IEnumerable`1<SignatureLog> value);
}
public class NuGet.Packaging.Signing.SignatureVerifySettings : object {
    [CompilerGeneratedAttribute]
private bool <AllowIllegal>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowUntrusted>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowUnknownRevocation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReportUnknownRevocation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReportUntrustedRoot>k__BackingField;
    [CompilerGeneratedAttribute]
private RevocationMode <RevocationMode>k__BackingField;
    [CompilerGeneratedAttribute]
private static SignatureVerifySettings <Default>k__BackingField;
    public bool AllowIllegal { get; }
    public bool AllowUntrusted { get; }
    public bool AllowUnknownRevocation { get; }
    public bool ReportUnknownRevocation { get; }
    public bool ReportUntrustedRoot { get; }
    public RevocationMode RevocationMode { get; }
    public static SignatureVerifySettings Default { get; }
    public SignatureVerifySettings(bool allowIllegal, bool allowUntrusted, bool allowUnknownRevocation, bool reportUnknownRevocation, bool reportUntrustedRoot, RevocationMode revocationMode);
    private static SignatureVerifySettings();
    [CompilerGeneratedAttribute]
public bool get_AllowIllegal();
    [CompilerGeneratedAttribute]
public bool get_AllowUntrusted();
    [CompilerGeneratedAttribute]
public bool get_AllowUnknownRevocation();
    [CompilerGeneratedAttribute]
public bool get_ReportUnknownRevocation();
    [CompilerGeneratedAttribute]
public bool get_ReportUntrustedRoot();
    [CompilerGeneratedAttribute]
public RevocationMode get_RevocationMode();
    [CompilerGeneratedAttribute]
public static SignatureVerifySettings get_Default();
}
public class NuGet.Packaging.Signing.SignedPackageArchive : PackageArchiveReader {
    private Stream _zipWriteStream;
    public SignedPackageArchive(Stream packageReadStream, Stream packageWriteStream);
    [AsyncStateMachineAttribute("NuGet.Packaging.Signing.SignedPackageArchive/<AddSignatureAsync>d__2")]
public sealed virtual Task AddSignatureAsync(Stream signatureStream, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Packaging.Signing.SignedPackageArchive/<RemoveSignatureAsync>d__3")]
public sealed virtual Task RemoveSignatureAsync(CancellationToken token);
    public sealed virtual Task`1<bool> IsZip64Async(CancellationToken token);
    internal UInt32 GetPackageEntryCount();
    protected virtual void Dispose(bool disposing);
}
public static class NuGet.Packaging.Signing.SignedPackageArchiveIOUtility : object {
    private static int _bufferSize;
    private static SigningSpecifications _signingSpecification;
    private static int ValidZipDate_YearMin;
    private static int ValidZipDate_YearMax;
    private static SignedPackageArchiveIOUtility();
    public static void ReadAndWriteUntilPosition(BinaryReader reader, BinaryWriter writer, long position);
    public static void ReadAndHashUntilPosition(BinaryReader reader, HashAlgorithm hashAlgorithm, long position);
    public static void HashBytes(HashAlgorithm hashAlgorithm, Byte[] bytes);
    internal static void HashBytes(HashAlgorithm hashAlgorithm, Byte[] bytes, int count);
    internal static void ReadAndHashUntilPosition(BinaryReader reader, Sha512HashFunction hashFunc, long position);
    internal static void HashBytes(Sha512HashFunction hashFunc, Byte[] bytes);
    internal static void HashBytes(Sha512HashFunction hashFunc, Byte[] bytes, int count);
    public static SignedPackageArchiveMetadata ReadSignedArchiveMetadata(BinaryReader reader, bool validateSignatureEntry);
    internal static void RemoveSignature(BinaryReader reader, BinaryWriter writer);
    private static UnsignedPackageArchiveMetadata ReadUnsignedArchiveMetadata(BinaryReader reader);
    private static void UpdateLocalFileHeadersTotalSize(IReadOnlyList`1<CentralDirectoryHeaderMetadata> records, long startOfCentralDirectory);
    private static void AssertSignatureEntryMetadata(BinaryReader reader, SignedPackageArchiveMetadata metadata);
    private static void AssertSignatureEntryCommonHeaderFields(BinaryReader reader, string errorPrefix, string errorSuffix);
    private static void AssertValue(UInt32 expectedValue, UInt32 actualValue, NuGetLogCode errorCode, string errorMessagePrefix, string errorMessageSuffix, string fieldName);
    internal static void WriteSignatureIntoZip(MemoryStream signatureStream, BinaryReader reader, BinaryWriter writer);
    private static long WriteLocalFileHeaderIntoZip(BinaryWriter writer, Byte[] fileData, UInt32 crc32, UInt32 dosDateTime);
    private static long WriteFileIntoZip(BinaryWriter writer, Byte[] fileData);
    private static long WriteCentralDirectoryHeaderIntoZip(BinaryWriter writer, Byte[] fileData, UInt32 crc32, UInt32 dosDateTime, long fileOffset);
    private static void ReadAndWriteUpdatedEndOfCentralDirectoryRecordIntoZip(BinaryReader reader, BinaryWriter writer, sbyte entryCountChange, long sizeOfSignatureCentralDirectoryRecord, long sizeOfSignatureFileHeaderAndData);
    private static bool CurrentStreamPositionMatchesByteSignature(BinaryReader reader, Byte[] byteSignature);
    private static UInt32 DateTimeToDosTime(DateTime dateTime);
}
public class NuGet.Packaging.Signing.SignedPackageArchiveMetadata : object {
    [CompilerGeneratedAttribute]
private List`1<CentralDirectoryHeaderMetadata> <CentralDirectoryHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private long <StartOfLocalFileHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private long <EndOfCentralDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SignatureCentralDirectoryHeaderIndex>k__BackingField;
    public List`1<CentralDirectoryHeaderMetadata> CentralDirectoryHeaders { get; public set; }
    public long StartOfLocalFileHeaders { get; public set; }
    public long EndOfCentralDirectory { get; public set; }
    public int SignatureCentralDirectoryHeaderIndex { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<CentralDirectoryHeaderMetadata> get_CentralDirectoryHeaders();
    [CompilerGeneratedAttribute]
public void set_CentralDirectoryHeaders(List`1<CentralDirectoryHeaderMetadata> value);
    [CompilerGeneratedAttribute]
public long get_StartOfLocalFileHeaders();
    [CompilerGeneratedAttribute]
public void set_StartOfLocalFileHeaders(long value);
    [CompilerGeneratedAttribute]
public long get_EndOfCentralDirectory();
    [CompilerGeneratedAttribute]
public void set_EndOfCentralDirectory(long value);
    [CompilerGeneratedAttribute]
public int get_SignatureCentralDirectoryHeaderIndex();
    [CompilerGeneratedAttribute]
public void set_SignatureCentralDirectoryHeaderIndex(int value);
    public CentralDirectoryHeaderMetadata GetPackageSignatureFileCentralDirectoryHeaderMetadata();
}
public static class NuGet.Packaging.Signing.SignedPackageArchiveUtility : object {
    private static SigningSpecifications _signingSpecification;
    private static SignedPackageArchiveUtility();
    public static bool IsSigned(BinaryReader reader);
    public static Stream OpenPackageSignatureFileStream(BinaryReader reader);
    private static Stream GetPackageSignatureFile(BinaryReader reader, CentralDirectoryHeaderMetadata signatureCentralDirectoryHeader);
    private static LocalFileHeader ReadPackageSignatureFileLocalFileHeader(BinaryReader reader, CentralDirectoryHeaderMetadata signatureCentralDirectoryHeader);
    internal static bool IsPackageSignatureFileEntry(Byte[] fileName, ushort generalPurposeBitFlag);
    public static bool IsZip64(BinaryReader reader);
    private static bool HasZip64ExtendedInformationExtraField(CentralDirectoryHeader header);
    private static bool HasZip64ExtendedInformationExtraField(LocalFileHeader header);
    [AsyncStateMachineAttribute("NuGet.Packaging.Signing.SignedPackageArchiveUtility/<RemoveRepositorySignaturesAsync>d__9")]
public static Task`1<bool> RemoveRepositorySignaturesAsync(Stream input, Stream output, CancellationToken cancellationToken);
    private static Task RemoveRepositoryPrimarySignatureAsync(Stream input, Stream output, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Packaging.Signing.SignedPackageArchiveUtility/<RemoveRepositoryCountersignaturesAsync>d__11")]
private static Task`1<bool> RemoveRepositoryCountersignaturesAsync(Stream input, Stream output, SignedCms signedCms, CancellationToken cancellationToken);
    private static bool TryRemoveRepositoryCountersignatures(SignedCms signedCms, SignedCms& updatedSignedCms);
    private static SignedCms Reencode(SignedCms signedCms);
    internal static void SignZip(MemoryStream signatureStream, BinaryReader reader, BinaryWriter writer);
    internal static void UnsignZip(BinaryReader reader, BinaryWriter writer);
    internal static void HashUInt16(HashAlgorithm hashAlgorithm, ushort value);
    internal static void HashUInt32(HashAlgorithm hashAlgorithm, UInt32 value);
    internal static bool VerifySignedPackageIntegrity(BinaryReader reader, HashAlgorithm hashAlgorithm, Byte[] expectedHash);
    private static List`1<CentralDirectoryHeaderMetadata> RemoveSignatureAndOrderByOffset(SignedPackageArchiveMetadata metadata);
    internal static void HashUInt16(Sha512HashFunction hashFunc, ushort value);
    internal static void HashUInt32(Sha512HashFunction hashFunc, UInt32 value);
    internal static string GetPackageContentHash(BinaryReader reader);
    internal static bool IsUtf8(ushort generalPurposeBitFlags);
    private static bool CompareHash(Byte[] expectedHash, Byte[] actualHash);
}
public class NuGet.Packaging.Signing.SignedPackageVerificationResult : PackageVerificationResult {
    [CompilerGeneratedAttribute]
private PrimarySignature <Signature>k__BackingField;
    public PrimarySignature Signature { get; }
    public SignedPackageVerificationResult(SignatureVerificationStatus trust, PrimarySignature signature, IEnumerable`1<SignatureLog> issues);
    [CompilerGeneratedAttribute]
public PrimarySignature get_Signature();
}
public class NuGet.Packaging.Signing.SignedPackageVerifierSettings : object {
    [CompilerGeneratedAttribute]
private bool <AllowUnsigned>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowIllegal>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowUntrusted>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowIgnoreTimestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowMultipleTimestamps>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowNoTimestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowUnknownRevocation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReportUnknownRevocation>k__BackingField;
    [CompilerGeneratedAttribute]
private VerificationTarget <VerificationTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private SignaturePlacement <SignaturePlacement>k__BackingField;
    [CompilerGeneratedAttribute]
private SignatureVerificationBehavior <RepositoryCountersignatureVerificationBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private RevocationMode <RevocationMode>k__BackingField;
    public bool AllowUnsigned { get; }
    public bool AllowIllegal { get; }
    public bool AllowUntrusted { get; }
    public bool AllowIgnoreTimestamp { get; }
    public bool AllowMultipleTimestamps { get; }
    public bool AllowNoTimestamp { get; }
    public bool AllowUnknownRevocation { get; }
    public bool ReportUnknownRevocation { get; }
    public VerificationTarget VerificationTarget { get; }
    public SignaturePlacement SignaturePlacement { get; }
    public SignatureVerificationBehavior RepositoryCountersignatureVerificationBehavior { get; }
    public RevocationMode RevocationMode { get; }
    public SignedPackageVerifierSettings(bool allowUnsigned, bool allowIllegal, bool allowUntrusted, bool allowIgnoreTimestamp, bool allowMultipleTimestamps, bool allowNoTimestamp, bool allowUnknownRevocation, bool reportUnknownRevocation, VerificationTarget verificationTarget, SignaturePlacement signaturePlacement, SignatureVerificationBehavior repositoryCountersignatureVerificationBehavior, RevocationMode revocationMode);
    [CompilerGeneratedAttribute]
public bool get_AllowUnsigned();
    [CompilerGeneratedAttribute]
public bool get_AllowIllegal();
    [CompilerGeneratedAttribute]
public bool get_AllowUntrusted();
    [CompilerGeneratedAttribute]
public bool get_AllowIgnoreTimestamp();
    [CompilerGeneratedAttribute]
public bool get_AllowMultipleTimestamps();
    [CompilerGeneratedAttribute]
public bool get_AllowNoTimestamp();
    [CompilerGeneratedAttribute]
public bool get_AllowUnknownRevocation();
    [CompilerGeneratedAttribute]
public bool get_ReportUnknownRevocation();
    [CompilerGeneratedAttribute]
public VerificationTarget get_VerificationTarget();
    [CompilerGeneratedAttribute]
public SignaturePlacement get_SignaturePlacement();
    [CompilerGeneratedAttribute]
public SignatureVerificationBehavior get_RepositoryCountersignatureVerificationBehavior();
    [CompilerGeneratedAttribute]
public RevocationMode get_RevocationMode();
    public static SignedPackageVerifierSettings GetDefault(IEnvironmentVariableReader environmentVariableReader);
    public static SignedPackageVerifierSettings GetAcceptModeDefaultPolicy(IEnvironmentVariableReader environmentVariableReader);
    public static SignedPackageVerifierSettings GetRequireModeDefaultPolicy(IEnvironmentVariableReader environmentVariableReader);
    public static SignedPackageVerifierSettings GetVerifyCommandDefaultPolicy(IEnvironmentVariableReader environmentVariableReader);
}
public class NuGet.Packaging.Signing.SigningCertificate : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<EssCertId> <Certificates>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<PolicyInformation> <Policies>k__BackingField;
    public IReadOnlyList`1<EssCertId> Certificates { get; }
    public IReadOnlyList`1<PolicyInformation> Policies { get; }
    private SigningCertificate(IReadOnlyList`1<EssCertId> certificates, IReadOnlyList`1<PolicyInformation> policies);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<EssCertId> get_Certificates();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<PolicyInformation> get_Policies();
    public static SigningCertificate Read(Byte[] bytes);
    internal static SigningCertificate Read(DerSequenceReader reader);
    private static List`1<EssCertId> ReadCertificates(DerSequenceReader reader);
    private static IReadOnlyList`1<PolicyInformation> ReadPolicies(DerSequenceReader reader);
}
public class NuGet.Packaging.Signing.SigningCertificateV2 : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<EssCertIdV2> <Certificates>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<PolicyInformation> <Policies>k__BackingField;
    public IReadOnlyList`1<EssCertIdV2> Certificates { get; }
    public IReadOnlyList`1<PolicyInformation> Policies { get; }
    private SigningCertificateV2(IReadOnlyList`1<EssCertIdV2> certificates, IReadOnlyList`1<PolicyInformation> policies);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<EssCertIdV2> get_Certificates();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<PolicyInformation> get_Policies();
    public static SigningCertificateV2 Create(X509Certificate2 certificate, HashAlgorithmName hashAlgorithmName);
    public static SigningCertificateV2 Read(Byte[] bytes);
    internal static SigningCertificateV2 Read(DerSequenceReader reader);
    public Byte[] Encode();
    private static IReadOnlyList`1<EssCertIdV2> ReadCertificates(DerSequenceReader reader);
    private static IReadOnlyList`1<PolicyInformation> ReadPolicies(DerSequenceReader reader);
}
public class NuGet.Packaging.Signing.SigningOptions : object {
    private Lazy`1<Stream> _inputPackageStream;
    private Lazy`1<Stream> _outputPackageStream;
    private bool _isDisposed;
    [CompilerGeneratedAttribute]
private bool <Overwrite>k__BackingField;
    [CompilerGeneratedAttribute]
private ISignatureProvider <SignatureProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    public Stream InputPackageStream { get; }
    public Stream OutputPackageStream { get; }
    public bool Overwrite { get; }
    public ISignatureProvider SignatureProvider { get; }
    public ILogger Logger { get; }
    public SigningOptions(Lazy`1<Stream> inputPackageStream, Lazy`1<Stream> outputPackageStream, bool overwrite, ISignatureProvider signatureProvider, ILogger logger);
    public Stream get_InputPackageStream();
    public Stream get_OutputPackageStream();
    [CompilerGeneratedAttribute]
public bool get_Overwrite();
    [CompilerGeneratedAttribute]
public ISignatureProvider get_SignatureProvider();
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    public static SigningOptions CreateFromFilePaths(string inputPackageFilePath, string outputPackageFilePath, bool overwrite, ISignatureProvider signatureProvider, ILogger logger);
    public sealed virtual void Dispose();
    private static string NormalizeFilePath(string filePath);
}
public abstract class NuGet.Packaging.Signing.SigningSpecifications : object {
    public static SigningSpecificationsV1 V1;
    public string Version { get; }
    public string SignaturePath { get; }
    public HashAlgorithmName[] AllowedHashAlgorithms { get; }
    public String[] AllowedHashAlgorithmOids { get; }
    public SignatureAlgorithmName[] AllowedSignatureAlgorithms { get; }
    public String[] AllowedSignatureAlgorithmOids { get; }
    public int RSAPublicKeyMinLength { get; }
    public Encoding Encoding { get; }
    private static SigningSpecifications();
    public abstract virtual string get_Version();
    public abstract virtual string get_SignaturePath();
    public abstract virtual HashAlgorithmName[] get_AllowedHashAlgorithms();
    public abstract virtual String[] get_AllowedHashAlgorithmOids();
    public abstract virtual SignatureAlgorithmName[] get_AllowedSignatureAlgorithms();
    public abstract virtual String[] get_AllowedSignatureAlgorithmOids();
    public abstract virtual int get_RSAPublicKeyMinLength();
    public abstract virtual Encoding get_Encoding();
}
public class NuGet.Packaging.Signing.SigningSpecificationsV1 : SigningSpecifications {
    private static string _signaturePath;
    private static int _rsaPublicKeyMinLength;
    private static Encoding _encoding;
    private static HashAlgorithmName[] _allowedHashAlgorithms;
    private static String[] _allowedHashAlgorithmOids;
    private static SignatureAlgorithmName[] _allowedSignatureAlgorithms;
    private static String[] _allowedSignatureAlgorithmOids;
    public string Version { get; }
    public string SignaturePath { get; }
    public HashAlgorithmName[] AllowedHashAlgorithms { get; }
    public String[] AllowedHashAlgorithmOids { get; }
    public SignatureAlgorithmName[] AllowedSignatureAlgorithms { get; }
    public String[] AllowedSignatureAlgorithmOids { get; }
    public int RSAPublicKeyMinLength { get; }
    public Encoding Encoding { get; }
    private static SigningSpecificationsV1();
    public virtual string get_Version();
    public virtual string get_SignaturePath();
    public virtual HashAlgorithmName[] get_AllowedHashAlgorithms();
    public virtual String[] get_AllowedHashAlgorithmOids();
    public virtual SignatureAlgorithmName[] get_AllowedSignatureAlgorithms();
    public virtual String[] get_AllowedSignatureAlgorithmOids();
    public virtual int get_RSAPublicKeyMinLength();
    public virtual Encoding get_Encoding();
}
public static class NuGet.Packaging.Signing.SigningUtility : object {
    public static void Verify(SignPackageRequest request, ILogger logger);
    public static CryptographicAttributeObjectCollection CreateSignedAttributes(SignPackageRequest request, IReadOnlyList`1<X509Certificate2> chainList);
    public static CryptographicAttributeObjectCollection CreateSignedAttributes(RepositorySignPackageRequest request, IReadOnlyList`1<X509Certificate2> chainList);
    public static CmsSigner CreateCmsSigner(SignPackageRequest request, ILogger logger);
    [AsyncStateMachineAttribute("NuGet.Packaging.Signing.SigningUtility/<SignAsync>d__4")]
public static Task SignAsync(SigningOptions options, SignPackageRequest signRequest, CancellationToken token);
    private static SignatureContent GenerateSignatureContent(HashAlgorithmName hashAlgorithmName, Byte[] zipArchiveHash);
}
public abstract class NuGet.Packaging.Signing.SignPackageRequest : object {
    private bool _isDisposed;
    [CompilerGeneratedAttribute]
private HashAlgorithmName <SignatureHashAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private HashAlgorithmName <TimestampHashAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate2 <Certificate>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate2Collection <AdditionalCertificates>k__BackingField;
    [CompilerGeneratedAttribute]
private IX509CertificateChain <Chain>k__BackingField;
    [CompilerGeneratedAttribute]
private CngKey <PrivateKey>k__BackingField;
    public HashAlgorithmName SignatureHashAlgorithm { get; }
    public HashAlgorithmName TimestampHashAlgorithm { get; }
    public X509Certificate2 Certificate { get; }
    public X509Certificate2Collection AdditionalCertificates { get; }
    public SignatureType SignatureType { get; }
    internal IX509CertificateChain Chain { get; private set; }
    public CngKey PrivateKey { get; public set; }
    protected SignPackageRequest(X509Certificate2 certificate, HashAlgorithmName signatureHashAlgorithm, HashAlgorithmName timestampHashAlgorithm);
    [CompilerGeneratedAttribute]
public HashAlgorithmName get_SignatureHashAlgorithm();
    [CompilerGeneratedAttribute]
public HashAlgorithmName get_TimestampHashAlgorithm();
    [CompilerGeneratedAttribute]
public X509Certificate2 get_Certificate();
    [CompilerGeneratedAttribute]
public X509Certificate2Collection get_AdditionalCertificates();
    public abstract virtual SignatureType get_SignatureType();
    [CompilerGeneratedAttribute]
internal IX509CertificateChain get_Chain();
    [CompilerGeneratedAttribute]
private void set_Chain(IX509CertificateChain value);
    [CompilerGeneratedAttribute]
public CngKey get_PrivateKey();
    [CompilerGeneratedAttribute]
public void set_PrivateKey(CngKey value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    internal void BuildSigningCertificateChainOnce(ILogger logger);
}
public class NuGet.Packaging.Signing.Timestamp : object {
    [CompilerGeneratedAttribute]
private DateTimeOffset <UpperLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <LowerLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <GeneralizedTime>k__BackingField;
    [CompilerGeneratedAttribute]
private SignedCms <SignedCms>k__BackingField;
    [CompilerGeneratedAttribute]
private IRfc3161TimestampTokenInfo <TstInfo>k__BackingField;
    public DateTimeOffset UpperLimit { get; }
    public DateTimeOffset LowerLimit { get; }
    public DateTimeOffset GeneralizedTime { get; }
    public SignedCms SignedCms { get; }
    public SignerInfo SignerInfo { get; }
    internal IRfc3161TimestampTokenInfo TstInfo { get; }
    public Timestamp(SignedCms timestampCms);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_UpperLimit();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LowerLimit();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_GeneralizedTime();
    [CompilerGeneratedAttribute]
public SignedCms get_SignedCms();
    public SignerInfo get_SignerInfo();
    [CompilerGeneratedAttribute]
internal IRfc3161TimestampTokenInfo get_TstInfo();
    internal SignatureVerificationStatusFlags Verify(Signature signature, SignedPackageVerifierSettings settings, HashAlgorithmName fingerprintAlgorithm, List`1<SignatureLog> issues);
}
public class NuGet.Packaging.Signing.TimestampException : SignatureException {
    public TimestampException(NuGetLogCode code, string message);
    public TimestampException(NuGetLogCode code, string message, Exception innerException);
    public TimestampException(string message);
}
public class NuGet.Packaging.Signing.TimestampRequest : object {
    [CompilerGeneratedAttribute]
private SigningSpecifications <SigningSpecifications>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <HashedMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private HashAlgorithmName <HashAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private SignaturePlacement <Target>k__BackingField;
    public SigningSpecifications SigningSpecifications { get; }
    public Byte[] HashedMessage { get; }
    public HashAlgorithmName HashAlgorithm { get; }
    public SignaturePlacement Target { get; }
    public TimestampRequest(SigningSpecifications signingSpecifications, Byte[] hashedMessage, HashAlgorithmName hashAlgorithm, SignaturePlacement target);
    [CompilerGeneratedAttribute]
public SigningSpecifications get_SigningSpecifications();
    [CompilerGeneratedAttribute]
public Byte[] get_HashedMessage();
    [CompilerGeneratedAttribute]
public HashAlgorithmName get_HashAlgorithm();
    [CompilerGeneratedAttribute]
public SignaturePlacement get_Target();
}
public class NuGet.Packaging.Signing.TrustedSignerAllowListEntry : CertificateHashAllowListEntry {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Owners>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowUntrustedRoot>k__BackingField;
    public IReadOnlyList`1<string> Owners { get; }
    public bool AllowUntrustedRoot { get; }
    public TrustedSignerAllowListEntry(VerificationTarget target, SignaturePlacement placement, string fingerprint, HashAlgorithmName algorithm, bool allowUntrustedRoot, IReadOnlyList`1<string> owners);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Owners();
    [CompilerGeneratedAttribute]
public bool get_AllowUntrustedRoot();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class NuGet.Packaging.Signing.TrustedSignersProvider : object {
    private ISettings _settings;
    public TrustedSignersProvider(ISettings settings);
    public sealed virtual IReadOnlyList`1<TrustedSignerItem> GetTrustedSigners();
    public sealed virtual void Remove(IReadOnlyList`1<TrustedSignerItem> trustedSigners);
    public sealed virtual void AddOrUpdateTrustedSigner(TrustedSignerItem trustedSigner);
    public static IReadOnlyList`1<TrustedSignerAllowListEntry> GetAllowListEntries(ISettings settings, ILogger logger);
    private static string GetCertLookupKey(CertificateItem certificate);
    private static VerificationTarget GetItemTarget(TrustedSignerItem item, SignaturePlacement& placement);
}
public class NuGet.Packaging.Signing.TstInfo : object {
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private Oid <Policy>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageImprint <MessageImprint>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <SerialNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <GenTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Accuracy <Accuracy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Ordering>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Nonce>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Tsa>k__BackingField;
    [CompilerGeneratedAttribute]
private X509ExtensionCollection <Extensions>k__BackingField;
    public int Version { get; }
    public Oid Policy { get; }
    public MessageImprint MessageImprint { get; }
    public Byte[] SerialNumber { get; }
    public DateTimeOffset GenTime { get; }
    public Accuracy Accuracy { get; }
    public bool Ordering { get; }
    public Byte[] Nonce { get; }
    public Byte[] Tsa { get; }
    public X509ExtensionCollection Extensions { get; }
    private TstInfo(int version, Oid policy, MessageImprint messageImprint, Byte[] serialNumber, DateTimeOffset genTime, Accuracy accuracy, bool ordering, Byte[] nonce, Byte[] tsa, X509ExtensionCollection extensions);
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
public Oid get_Policy();
    [CompilerGeneratedAttribute]
public MessageImprint get_MessageImprint();
    [CompilerGeneratedAttribute]
public Byte[] get_SerialNumber();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_GenTime();
    [CompilerGeneratedAttribute]
public Accuracy get_Accuracy();
    [CompilerGeneratedAttribute]
public bool get_Ordering();
    [CompilerGeneratedAttribute]
public Byte[] get_Nonce();
    [CompilerGeneratedAttribute]
public Byte[] get_Tsa();
    [CompilerGeneratedAttribute]
public X509ExtensionCollection get_Extensions();
    public static TstInfo Read(Byte[] bytes);
    internal static TstInfo Read(DerSequenceReader reader);
}
public class NuGet.Packaging.Signing.UnknownPrimarySignature : PrimarySignature {
    public UnknownPrimarySignature(SignedCms signedCms);
}
internal class NuGet.Packaging.Signing.UnsignedPackageArchiveMetadata : object {
    [CompilerGeneratedAttribute]
private long <EndOfLocalFileHeadersPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private long <EndOfCentralDirectoryHeadersPosition>k__BackingField;
    internal long EndOfLocalFileHeadersPosition { get; }
    internal long EndOfCentralDirectoryHeadersPosition { get; }
    internal UnsignedPackageArchiveMetadata(long endOfLocalFileHeadersPosition, long endOfCentralDirectoryHeadersPosition);
    [CompilerGeneratedAttribute]
internal long get_EndOfLocalFileHeadersPosition();
    [CompilerGeneratedAttribute]
internal long get_EndOfCentralDirectoryHeadersPosition();
}
public class NuGet.Packaging.Signing.UnsignedPackageVerificationResult : PackageVerificationResult {
    public UnsignedPackageVerificationResult(SignatureVerificationStatus trust, IEnumerable`1<SignatureLog> issues);
}
internal static class NuGet.Packaging.Signing.Utility.MarshalUtility : object {
    internal static T PtrToStructure(IntPtr pointer);
    internal static int SizeOf();
}
public abstract class NuGet.Packaging.Signing.VerificationAllowListEntry : object {
    [CompilerGeneratedAttribute]
private VerificationTarget <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private SignaturePlacement <Placement>k__BackingField;
    public VerificationTarget Target { get; }
    public SignaturePlacement Placement { get; }
    public VerificationAllowListEntry(VerificationTarget target, SignaturePlacement placement);
    [CompilerGeneratedAttribute]
public VerificationTarget get_Target();
    [CompilerGeneratedAttribute]
public SignaturePlacement get_Placement();
}
[FlagsAttribute]
public enum NuGet.Packaging.Signing.VerificationTarget : Enum {
    public int value__;
    public static VerificationTarget None;
    public static VerificationTarget Unknown;
    public static VerificationTarget Author;
    public static VerificationTarget Repository;
    public static VerificationTarget All;
}
public static class NuGet.Packaging.Signing.VerificationUtility : object {
    public static SignatureVerificationStatus GetSignatureVerificationStatus(SignatureVerificationStatusFlags flags);
    public static bool IsVerificationTarget(SignatureType signatureType, VerificationTarget target);
    internal static SignatureVerificationStatusFlags ValidateSigningCertificate(X509Certificate2 certificate, bool treatIssuesAsErrors, string signatureFriendlyName, List`1<SignatureLog> issues);
    internal static SignatureVerificationStatusFlags ValidateTimestamp(Timestamp timestamp, Signature signature, bool treatIssuesAsErrors, List`1<SignatureLog> issues, SigningSpecifications spec);
}
public class NuGet.Packaging.Signing.VerifySignaturesResult : object {
    [CompilerGeneratedAttribute]
private bool <IsValid>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSigned>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<PackageVerificationResult> <Results>k__BackingField;
    public bool IsValid { get; }
    public bool IsSigned { get; }
    public IReadOnlyList`1<PackageVerificationResult> Results { get; }
    public VerifySignaturesResult(bool isValid, bool isSigned);
    public VerifySignaturesResult(bool isValid, bool isSigned, IEnumerable`1<PackageVerificationResult> results);
    [CompilerGeneratedAttribute]
public bool get_IsValid();
    [CompilerGeneratedAttribute]
public bool get_IsSigned();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<PackageVerificationResult> get_Results();
}
public class NuGet.Packaging.Signing.X509CertificateChain : List`1<X509Certificate2> {
    private bool _isDisposed;
    public sealed virtual void Dispose();
}
internal static class NuGet.Packaging.Signing.X509ChainBuildPolicyFactory : object {
    private static string DefaultValue;
    internal static string DisabledValue;
    internal static string EnvironmentVariableName;
    internal static char ValueDelimiter;
    private static object LockObject;
    private static IX509ChainBuildPolicy Policy;
    private static X509ChainBuildPolicyFactory();
    internal static IX509ChainBuildPolicy Create(IEnvironmentVariableReader reader);
    internal static IX509ChainBuildPolicy CreateWithoutCaching(IEnvironmentVariableReader reader);
}
public class NuGet.Packaging.Signing.X509ChainHolder : object {
    private bool _isDisposed;
    [CompilerGeneratedAttribute]
private X509Chain <Chain>k__BackingField;
    [CompilerGeneratedAttribute]
private IX509Chain <Chain2>k__BackingField;
    public X509Chain Chain { get; }
    internal IX509Chain Chain2 { get; }
    private X509ChainHolder(X509StorePurpose storePurpose);
    [CompilerGeneratedAttribute]
public X509Chain get_Chain();
    [CompilerGeneratedAttribute]
internal IX509Chain get_Chain2();
    internal static X509ChainHolder CreateForCodeSigning();
    internal static X509ChainHolder CreateForTimestamping();
    public sealed virtual void Dispose();
}
internal class NuGet.Packaging.Signing.X509ChainWrapper : object {
    private X509Chain _chain;
    private Func`2<X509Chain, ILogMessage> _getAdditionalContext;
    [CompilerGeneratedAttribute]
private ILogMessage <AdditionalContext>k__BackingField;
    public ILogMessage AdditionalContext { get; private set; }
    public X509ChainElementCollection ChainElements { get; }
    public X509ChainPolicy ChainPolicy { get; }
    public X509ChainStatus[] ChainStatus { get; }
    public X509Chain PrivateReference { get; }
    internal X509ChainWrapper(X509Chain chain);
    internal X509ChainWrapper(X509Chain chain, Func`2<X509Chain, ILogMessage> getAdditionalContext);
    [CompilerGeneratedAttribute]
public sealed virtual ILogMessage get_AdditionalContext();
    [CompilerGeneratedAttribute]
private void set_AdditionalContext(ILogMessage value);
    public sealed virtual X509ChainElementCollection get_ChainElements();
    public sealed virtual X509ChainPolicy get_ChainPolicy();
    public sealed virtual X509ChainStatus[] get_ChainStatus();
    public sealed virtual X509Chain get_PrivateReference();
    public sealed virtual bool Build(X509Certificate2 certificate);
    public sealed virtual void Dispose();
}
public class NuGet.Packaging.Signing.X509SignatureProvider : object {
    private static int INVALID_PROVIDER_TYPE_HRESULT;
    private ITimestampProvider _timestampProvider;
    public X509SignatureProvider(ITimestampProvider timestampProvider);
    public sealed virtual Task`1<PrimarySignature> CreatePrimarySignatureAsync(SignPackageRequest request, SignatureContent signatureContent, ILogger logger, CancellationToken token);
    public sealed virtual Task`1<PrimarySignature> CreateRepositoryCountersignatureAsync(RepositorySignPackageRequest request, PrimarySignature primarySignature, ILogger logger, CancellationToken token);
    private static PrimarySignature CreatePrimarySignature(SignPackageRequest request, SignatureContent signatureContent, ILogger logger);
    private static PrimarySignature CreateRepositoryCountersignature(SignPackageRequest request, PrimarySignature primarySignature, ILogger logger);
    private static PrimarySignature CreatePrimarySignature(CmsSigner cmsSigner, Byte[] signingData, CngKey privateKey);
    private static PrimarySignature CreatePrimarySignature(CmsSigner cmsSigner, SignPackageRequest request, Byte[] signingData);
    private static PrimarySignature CreateRepositoryCountersignature(CmsSigner cmsSigner, PrimarySignature primarySignature, CngKey privateKey);
    private static PrimarySignature CreateRepositoryCountersignature(CmsSigner cmsSigner, SignPackageRequest request, PrimarySignature primarySignature);
    private Task`1<PrimarySignature> TimestampPrimarySignatureAsync(SignPackageRequest request, ILogger logger, PrimarySignature signature, CancellationToken token);
    private Task`1<PrimarySignature> TimestampRepositoryCountersignatureAsync(SignPackageRequest request, ILogger logger, PrimarySignature primarySignature, CancellationToken token);
}
internal enum NuGet.Packaging.Signing.X509StorePurpose : Enum {
    public int value__;
    public static X509StorePurpose CodeSigning;
    public static X509StorePurpose Timestamping;
}
public static class NuGet.Packaging.Signing.X509TrustStore : object {
    private static IX509ChainFactory CodeSigningX509ChainFactory;
    private static IX509ChainFactory TimestampingX509ChainFactory;
    private static object LockObject;
    private static X509TrustStore();
    public static void InitializeForDotNetSdk(ILogger logger);
    internal static IX509ChainFactory GetX509ChainFactory(X509StorePurpose storePurpose, ILogger logger);
    private static IX509ChainFactory GetX509ChainFactory(X509StorePurpose storePurpose, ILogger logger, Func`3<X509StorePurpose, ILogger, IX509ChainFactory> creator);
    private static IX509ChainFactory CreateX509ChainFactoryForDotNetSdk(X509StorePurpose storePurpose, ILogger logger);
    internal static IX509ChainFactory CreateX509ChainFactoryForDotNetSdk(X509StorePurpose storePurpose, ILogger logger, FileInfo fallbackCertificateBundleFile);
    internal static IX509ChainFactory CreateX509ChainFactory(X509StorePurpose storePurpose, ILogger logger);
    internal static void SetCodeSigningX509ChainFactory(IX509ChainFactory chainFactory);
    internal static void SetTimestampingX509ChainFactory(IX509ChainFactory chainFactory);
}
internal class NuGet.Packaging.Signing.Zip64EndOfCentralDirectoryLocator : object {
    internal static UInt32 Signature;
    internal static UInt32 SizeInBytes;
    internal static bool Exists(BinaryReader reader);
}
internal class NuGet.Packaging.Signing.Zip64ExtendedInformationExtraField : ExtraField {
    [CompilerGeneratedAttribute]
private Nullable`1<ulong> <OriginalUncompressedFileSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ulong> <SizeOfCompressedData>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ulong> <OffsetOfLocalHeaderRecord>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<UInt32> <NumberOfDiskOnWhichThisFileStarts>k__BackingField;
    internal Nullable`1<ulong> OriginalUncompressedFileSize { get; private set; }
    internal Nullable`1<ulong> SizeOfCompressedData { get; private set; }
    internal Nullable`1<ulong> OffsetOfLocalHeaderRecord { get; private set; }
    internal Nullable`1<UInt32> NumberOfDiskOnWhichThisFileStarts { get; private set; }
    private Zip64ExtendedInformationExtraField(ushort headerId, ushort dataSize, Byte[] data, Nullable`1<ulong> originalUncompressedFileSize, Nullable`1<ulong> sizeOfCompressedData, Nullable`1<ulong> offsetOfLocalHeaderRecord, Nullable`1<UInt32> numberOfDiskOnWhichThisFileStarts);
    [CompilerGeneratedAttribute]
internal Nullable`1<ulong> get_OriginalUncompressedFileSize();
    [CompilerGeneratedAttribute]
private void set_OriginalUncompressedFileSize(Nullable`1<ulong> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<ulong> get_SizeOfCompressedData();
    [CompilerGeneratedAttribute]
private void set_SizeOfCompressedData(Nullable`1<ulong> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<ulong> get_OffsetOfLocalHeaderRecord();
    [CompilerGeneratedAttribute]
private void set_OffsetOfLocalHeaderRecord(Nullable`1<ulong> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<UInt32> get_NumberOfDiskOnWhichThisFileStarts();
    [CompilerGeneratedAttribute]
private void set_NumberOfDiskOnWhichThisFileStarts(Nullable`1<UInt32> value);
    internal static Zip64ExtendedInformationExtraField Read(ushort headerId, ushort dataSize, Byte[] data, bool readUncompressedFileSize, bool readCompressedFileSize, bool readRelativeOffsetOfLocalHeader, bool readDiskNumberStart);
}
internal static class NuGet.Packaging.Signing.ZipConstants : object {
    internal static ushort Mask16Bit;
    internal static UInt32 Mask32Bit;
    private static ZipConstants();
}
[ExtensionAttribute]
public static class NuGet.Packaging.StreamExtensions : object {
    [ExtensionAttribute]
public static string CopyToFile(Stream inputStream, string fileFullPath);
    private static void CopyTo(Stream inputStream, Stream outputStream);
}
[ExtensionAttribute]
internal static class NuGet.Packaging.StringExtensions : object {
    [ExtensionAttribute]
public static string SafeTrim(string value);
}
internal static class NuGet.Packaging.StringFormatter : object {
    internal static string Log_InstalledPackage(string packageId, string packageVersion, string source, string contentHash, string filePath);
    internal static string ZipFileTimeStampModifiedMessage(string filePath, string originalLastWriteTimeStamp, string updatedLastWriteTimeStamp);
    internal static string ZipFileTimeStampModifiedWarning(string listOfFileTimeStampModifiedMessages);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class NuGet.Packaging.Strings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string AnAbsoluteUriIsRequired { get; }
    internal static string ArgumentCannotBeNullOrEmpty { get; }
    internal static string AuthorPrimarySignatureFriendlyName { get; }
    internal static string CertificateChainBuildFailed { get; }
    internal static string CertificateChainValidationFailed { get; }
    internal static string CertUtilityCertificateHash { get; }
    internal static string CertUtilityCertificateHashSha1 { get; }
    internal static string CertUtilityCertificateIssuer { get; }
    internal static string CertUtilityCertificateSubjectName { get; }
    internal static string CertUtilityCertificateValidity { get; }
    internal static string CertUtilityMultipleCertificatesFooter { get; }
    internal static string CertUtilityMultipleCertificatesHeader { get; }
    internal static string ChainBuilding_UsingDefaultTrustStoreForCodeSigning { get; }
    internal static string ChainBuilding_UsingDefaultTrustStoreForTimestamping { get; }
    internal static string ChainBuilding_UsingFallbackCertificateBundle { get; }
    internal static string ChainBuilding_UsingNoCertificateBundle { get; }
    internal static string ChainBuilding_UsingSystemCertificateBundle { get; }
    internal static string CommitmentTypeIndicationAttributeInvalid { get; }
    internal static string CommitmentTypeIndicationAttributeInvalidCombination { get; }
    internal static string ConflictingAllowUntrustedRoot { get; }
    internal static string DefaultError_EmptyAllowList { get; }
    internal static string DefaultError_NoMatchInAllowList { get; }
    internal static string Error_InvalidTargetFramework { get; }
    internal static string Error_LoadingHashFile { get; }
    internal static string Error_MissingNuspecFile { get; }
    internal static string Error_NoClientAllowList { get; }
    internal static string Error_NoMatchingClientCertificate { get; }
    internal static string Error_NoMatchingRepositoryCertificate { get; }
    internal static string Error_NoRepoAllowList { get; }
    internal static string Error_NotOnePrimarySignature { get; }
    internal static string Error_NotOneRepositoryCounterSignature { get; }
    internal static string Error_RepositorySettings_UnsignedPackage { get; }
    internal static string Error_RepositorySignatureMustNotHaveARepositoryCountersignature { get; }
    internal static string Error_RequireMode_UnsignedPackage { get; }
    internal static string ErrorAuthorTargetCannotBeACountersignature { get; }
    internal static string ErrorByteSignatureNotFound { get; }
    internal static string ErrorDuplicatePackages { get; }
    internal static string ErrorInvalidAllowedVersions { get; }
    internal static string ErrorInvalidCertificateChainUnspecifiedReason { get; }
    internal static string ErrorInvalidMinClientVersion { get; }
    internal static string ErrorInvalidPackageArchive { get; }
    internal static string ErrorInvalidPackageVersion { get; }
    internal static string ErrorInvalidPackageVersionForDependency { get; }
    internal static string ErrorManifestFileNotFound { get; }
    internal static string ErrorMultipleTimestamps { get; }
    internal static string ErrorNoTimestamp { get; }
    internal static string ErrorNullOrEmptyPackageId { get; }
    internal static string ErrorPackageNotSigned { get; }
    internal static string ErrorPackageSignatureInvalid { get; }
    internal static string ErrorUnableCheckPackageEntries { get; }
    internal static string ErrorUnableToDeleteFile { get; }
    internal static string ErrorUnsafePackageEntry { get; }
    internal static string ErrorZip64NotSupported { get; }
    internal static string ExactlyOneAttributeRequired { get; }
    internal static string ExactlyOneAttributeValueRequired { get; }
    internal static string ExtractionLog_InformationPrefix { get; }
    internal static string FailedFileTime { get; }
    internal static string FailToLoadPackagesConfig { get; }
    internal static string FailToWritePackagesConfig { get; }
    internal static string FallbackFolderNotFound { get; }
    internal static string HttpOrHttpsIsRequired { get; }
    internal static string InvalidArgument { get; }
    internal static string InvalidArgumentCombination { get; }
    internal static string InvalidAsn1 { get; }
    internal static string InvalidLicenseExppressionVersion_VersionTooHigh { get; }
    internal static string InvalidNuspecElement { get; }
    internal static string InvalidNuspecEntry { get; }
    internal static string InvalidPackageFrameworkFolderName { get; }
    internal static string InvalidPackageNupkg { get; }
    internal static string InvalidPackageSignatureFile { get; }
    internal static string InvalidPackageSignatureFileEntry { get; }
    internal static string InvalidPackageSignatureFileEntryCentralDirectoryHeader { get; }
    internal static string InvalidPackageSignatureFileEntryLocalFileHeader { get; }
    internal static string InvalidPackageTypeVersion { get; }
    internal static string InvalidPrimarySignature { get; }
    internal static string InvalidRepositoryCountersignature { get; }
    internal static string InvalidSignatureContent { get; }
    internal static string InvalidTimestampSignature { get; }
    internal static string InvalidUrl { get; }
    internal static string InvalidX509StorePurpose { get; }
    internal static string Log_InstalledPackage { get; }
    internal static string Message_Path { get; }
    internal static string MinClientVersionAlreadyExist { get; }
    internal static string MissingMetadataNode { get; }
    internal static string MissingPackageTypeName { get; }
    internal static string MissingTargetPlatformVersionsFromDependencyGroups { get; }
    internal static string MissingTargetPlatformVersionsFromFrameworkAssemblyGroups { get; }
    internal static string MissingTargetPlatformVersionsFromFrameworkAssemblyReferences { get; }
    internal static string MissingTargetPlatformVersionsFromIncludedFiles { get; }
    internal static string MissingTargetPlatformVersionsFromReferenceGroups { get; }
    internal static string MultipleAttributesDisallowed { get; }
    internal static string MultipleNuspecFiles { get; }
    internal static string MultiplePackageSignatureFiles { get; }
    internal static string MustContainAbsolutePath { get; }
    internal static string NoPackageSignatureFile { get; }
    internal static string NoRepositoryCountersignature { get; }
    internal static string NuGetLicense_InvalidLicenseExpressionVersion { get; }
    internal static string NuGetLicense_InvalidLicenseType { get; }
    internal static string NuGetLicense_LicenseElementMissingValue { get; }
    internal static string NuGetLicense_LicenseExpressionVersionTooHigh { get; }
    internal static string NuGetLicense_MissingRequiredValue { get; }
    internal static string NuGetLicenseExpression_DeprecatedIdentifier { get; }
    internal static string NuGetLicenseExpression_ExceptionIdentifierIsLicense { get; }
    internal static string NuGetLicenseExpression_IllegalUnlicensedOperator { get; }
    internal static string NuGetLicenseExpression_InvalidCharacters { get; }
    internal static string NuGetLicenseExpression_InvalidExceptionIdentifier { get; }
    internal static string NuGetLicenseExpression_InvalidExpression { get; }
    internal static string NuGetLicenseExpression_InvalidToken { get; }
    internal static string NuGetLicenseExpression_LicenseIdentifierIsException { get; }
    internal static string NuGetLicenseExpression_LicenseInvalidCharacters { get; }
    internal static string NuGetLicenseExpression_MismatchedParentheses { get; }
    internal static string NuGetLicenseExpression_NonStandardIdentifier { get; }
    internal static string NuGetLicenseExpression_UnexpectedIdentifier { get; }
    internal static string NuGetLicenseExpression_UnlicensedPackageWarning { get; }
    internal static string NuGetPackageOwners { get; }
    internal static string NuGetPackageOwnersInvalid { get; }
    internal static string NuGetPackageOwnersInvalidValue { get; }
    internal static string NuGetV3ServiceIndexUrl { get; }
    internal static string NuGetV3ServiceIndexUrlInvalid { get; }
    internal static string NuGetV3ServiceIndexUrlInvalidValue { get; }
    internal static string PackageEntryAlreadyExist { get; }
    internal static string PackageEntryNotExist { get; }
    internal static string PackageMinVersionNotSatisfied { get; }
    internal static string PackageSignatureVerificationLog { get; }
    internal static string PackagesNodeNotExist { get; }
    internal static string PackageStreamShouldBeSeekable { get; }
    internal static string PrimarySignatureFriendlyName { get; }
    internal static string PrimarySignatureHasNoTimestamp { get; }
    internal static string PropertyCannotBeNull { get; }
    internal static string RangeOutOfBoundsForArray { get; }
    internal static string RepositoryCountersignatureFriendlyName { get; }
    internal static string RepositoryCountersignatureHasNoCertificate { get; }
    internal static string RepositoryCountersignatureHasNoTimestamp { get; }
    internal static string RepositoryPrimarySignatureFriendlyName { get; }
    internal static string SignatureContainsInvalidAttribute { get; }
    internal static string SignatureDebug_HashOidFound { get; }
    internal static string SignatureFailureInvalidHashAlgorithmOid { get; }
    internal static string SignatureFriendlyName { get; }
    internal static string SignatureHashAlgorithm { get; }
    internal static string SignaturePackageIntegrityFailure { get; }
    internal static string SignatureType { get; }
    internal static string SignedPackageAlreadySigned { get; }
    internal static string SignedPackageArchiveIOExtraRead { get; }
    internal static string SignedPackageArchiveIOInvalidRead { get; }
    internal static string SignedPackageNotSignedOnRemove { get; }
    internal static string SignedPackageNotSignedOnVerify { get; }
    internal static string SignedPackagePackageAlreadyCountersigned { get; }
    internal static string SignedPackageUnableToAccessSignature { get; }
    internal static string SignError_TimestampCertificateFailsPublicKeyLengthRequirement { get; }
    internal static string SignError_TimestampGeneralizedTimeInvalid { get; }
    internal static string SignError_TimestampIntegrityCheckFailed { get; }
    internal static string SignError_TimestampNoCertificate { get; }
    internal static string SignError_TimestampNotYetValid { get; }
    internal static string SignError_TimestampSignatureValidationFailed { get; }
    internal static string SignFailureCertificateInvalidProviderType { get; }
    internal static string SigningCannotBeDoneInPlace { get; }
    internal static string SigningCertificateAttributeMustNotBePresent { get; }
    internal static string SigningCertificateCertificateNotFound { get; }
    internal static string SigningCertificateInvalid { get; }
    internal static string SigningCertificateV1OrV2AttributeMustBePresent { get; }
    internal static string SigningCertificateV2CertificateNotFound { get; }
    internal static string SigningCertificateV2Invalid { get; }
    internal static string SigningCertificateV2UnsupportedHashAlgorithm { get; }
    internal static string SigningError_CertificateFailsPublicKeyLengthRequirement { get; }
    internal static string SigningError_CertificateHasLifetimeSigningEKU { get; }
    internal static string SigningError_CertificateHasUnsupportedSignatureAlgorithm { get; }
    internal static string SigningError_NotYetValid { get; }
    internal static string SigningWouldRequireZip64 { get; }
    internal static string StreamMustBeReadable { get; }
    internal static string StreamMustBeSeekable { get; }
    internal static string StringCannotBeNullOrEmpty { get; }
    internal static string TimestampCertificateUnsupportedSignatureAlgorithm { get; }
    internal static string TimestampFailureInvalidHttpScheme { get; }
    internal static string TimestampFailureNonceMismatch { get; }
    internal static string TimestampServiceRespondedError { get; }
    internal static string TimestampSignatureUnsupportedDigestAlgorithm { get; }
    internal static string TimestampValue { get; }
    internal static string UnableToAddEntry { get; }
    internal static string UnableToParseClientVersion { get; }
    internal static string UnableToReadPackageHashInformation { get; }
    internal static string UnexpectedPackageSignatureVerificationError { get; }
    internal static string UnrecognizedEnumValue { get; }
    internal static string UnrelatedSignatures { get; }
    internal static string UnsupportedAsn1 { get; }
    internal static string UnsupportedSignatureFormatVersion { get; }
    internal static string UntrustedRoot_WithCertificateBundle { get; }
    internal static string UntrustedRoot_WithoutCertificateBundle { get; }
    internal static string VerificationCertDisplay { get; }
    internal static string VerificationTimestamperCertDisplay { get; }
    internal static string Verify_ErrorNoCertificate { get; }
    internal static string VerifyCertTrustOfflineWhileRevocationModeOffline { get; }
    internal static string VerifyCertTrustOfflineWhileRevocationModeOnline { get; }
    internal static string VerifyChainBuildingIssue { get; }
    internal static string VerifyChainBuildingIssue_UntrustedRoot { get; }
    internal static string VerifyError_CertificateFailsPublicKeyLengthRequirement { get; }
    internal static string VerifyError_CertificateHasLifetimeSigningEKU { get; }
    internal static string VerifyError_CertificateHasUnsupportedSignatureAlgorithm { get; }
    internal static string VerifyError_CertificateNotYetValid { get; }
    internal static string VerifyError_InvalidCertificateChain { get; }
    internal static string VerifyError_SignatureNotTimeValid { get; }
    internal static string VerifyError_SignatureVerificationFailed { get; }
    internal static string VerifyError_TimestampCertificateFailsPublicKeyLengthRequirement { get; }
    internal static string VerifyError_TimestampGeneralizedTimeInvalid { get; }
    internal static string VerifyError_TimestampIntegrityCheckFailed { get; }
    internal static string VerifyError_TimestampInvalid { get; }
    internal static string VerifyError_TimestampMessageImprintUnsupportedHashAlgorithm { get; }
    internal static string VerifyError_TimestampNoCertificate { get; }
    internal static string VerifyError_TimestampNotYetValid { get; }
    internal static string VerifyError_TimestampSignatureUnsupportedDigestAlgorithm { get; }
    internal static string VerifyError_TimestampSignatureValidationFailed { get; }
    internal static string VerifyError_TimestampUnsupportedSignatureAlgorithm { get; }
    internal static string VerifyError_TimestampVerifyChainBuildingIssue { get; }
    internal static string VerifyTimestampChainBuildingIssue_UntrustedRoot { get; }
    internal static string ZipFileLastWriteTimeStampModifiedMessage { get; }
    internal static string ZipFileTimeStampModifiedWarning { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_AnAbsoluteUriIsRequired();
    internal static string get_ArgumentCannotBeNullOrEmpty();
    internal static string get_AuthorPrimarySignatureFriendlyName();
    internal static string get_CertificateChainBuildFailed();
    internal static string get_CertificateChainValidationFailed();
    internal static string get_CertUtilityCertificateHash();
    internal static string get_CertUtilityCertificateHashSha1();
    internal static string get_CertUtilityCertificateIssuer();
    internal static string get_CertUtilityCertificateSubjectName();
    internal static string get_CertUtilityCertificateValidity();
    internal static string get_CertUtilityMultipleCertificatesFooter();
    internal static string get_CertUtilityMultipleCertificatesHeader();
    internal static string get_ChainBuilding_UsingDefaultTrustStoreForCodeSigning();
    internal static string get_ChainBuilding_UsingDefaultTrustStoreForTimestamping();
    internal static string get_ChainBuilding_UsingFallbackCertificateBundle();
    internal static string get_ChainBuilding_UsingNoCertificateBundle();
    internal static string get_ChainBuilding_UsingSystemCertificateBundle();
    internal static string get_CommitmentTypeIndicationAttributeInvalid();
    internal static string get_CommitmentTypeIndicationAttributeInvalidCombination();
    internal static string get_ConflictingAllowUntrustedRoot();
    internal static string get_DefaultError_EmptyAllowList();
    internal static string get_DefaultError_NoMatchInAllowList();
    internal static string get_Error_InvalidTargetFramework();
    internal static string get_Error_LoadingHashFile();
    internal static string get_Error_MissingNuspecFile();
    internal static string get_Error_NoClientAllowList();
    internal static string get_Error_NoMatchingClientCertificate();
    internal static string get_Error_NoMatchingRepositoryCertificate();
    internal static string get_Error_NoRepoAllowList();
    internal static string get_Error_NotOnePrimarySignature();
    internal static string get_Error_NotOneRepositoryCounterSignature();
    internal static string get_Error_RepositorySettings_UnsignedPackage();
    internal static string get_Error_RepositorySignatureMustNotHaveARepositoryCountersignature();
    internal static string get_Error_RequireMode_UnsignedPackage();
    internal static string get_ErrorAuthorTargetCannotBeACountersignature();
    internal static string get_ErrorByteSignatureNotFound();
    internal static string get_ErrorDuplicatePackages();
    internal static string get_ErrorInvalidAllowedVersions();
    internal static string get_ErrorInvalidCertificateChainUnspecifiedReason();
    internal static string get_ErrorInvalidMinClientVersion();
    internal static string get_ErrorInvalidPackageArchive();
    internal static string get_ErrorInvalidPackageVersion();
    internal static string get_ErrorInvalidPackageVersionForDependency();
    internal static string get_ErrorManifestFileNotFound();
    internal static string get_ErrorMultipleTimestamps();
    internal static string get_ErrorNoTimestamp();
    internal static string get_ErrorNullOrEmptyPackageId();
    internal static string get_ErrorPackageNotSigned();
    internal static string get_ErrorPackageSignatureInvalid();
    internal static string get_ErrorUnableCheckPackageEntries();
    internal static string get_ErrorUnableToDeleteFile();
    internal static string get_ErrorUnsafePackageEntry();
    internal static string get_ErrorZip64NotSupported();
    internal static string get_ExactlyOneAttributeRequired();
    internal static string get_ExactlyOneAttributeValueRequired();
    internal static string get_ExtractionLog_InformationPrefix();
    internal static string get_FailedFileTime();
    internal static string get_FailToLoadPackagesConfig();
    internal static string get_FailToWritePackagesConfig();
    internal static string get_FallbackFolderNotFound();
    internal static string get_HttpOrHttpsIsRequired();
    internal static string get_InvalidArgument();
    internal static string get_InvalidArgumentCombination();
    internal static string get_InvalidAsn1();
    internal static string get_InvalidLicenseExppressionVersion_VersionTooHigh();
    internal static string get_InvalidNuspecElement();
    internal static string get_InvalidNuspecEntry();
    internal static string get_InvalidPackageFrameworkFolderName();
    internal static string get_InvalidPackageNupkg();
    internal static string get_InvalidPackageSignatureFile();
    internal static string get_InvalidPackageSignatureFileEntry();
    internal static string get_InvalidPackageSignatureFileEntryCentralDirectoryHeader();
    internal static string get_InvalidPackageSignatureFileEntryLocalFileHeader();
    internal static string get_InvalidPackageTypeVersion();
    internal static string get_InvalidPrimarySignature();
    internal static string get_InvalidRepositoryCountersignature();
    internal static string get_InvalidSignatureContent();
    internal static string get_InvalidTimestampSignature();
    internal static string get_InvalidUrl();
    internal static string get_InvalidX509StorePurpose();
    internal static string get_Log_InstalledPackage();
    internal static string get_Message_Path();
    internal static string get_MinClientVersionAlreadyExist();
    internal static string get_MissingMetadataNode();
    internal static string get_MissingPackageTypeName();
    internal static string get_MissingTargetPlatformVersionsFromDependencyGroups();
    internal static string get_MissingTargetPlatformVersionsFromFrameworkAssemblyGroups();
    internal static string get_MissingTargetPlatformVersionsFromFrameworkAssemblyReferences();
    internal static string get_MissingTargetPlatformVersionsFromIncludedFiles();
    internal static string get_MissingTargetPlatformVersionsFromReferenceGroups();
    internal static string get_MultipleAttributesDisallowed();
    internal static string get_MultipleNuspecFiles();
    internal static string get_MultiplePackageSignatureFiles();
    internal static string get_MustContainAbsolutePath();
    internal static string get_NoPackageSignatureFile();
    internal static string get_NoRepositoryCountersignature();
    internal static string get_NuGetLicense_InvalidLicenseExpressionVersion();
    internal static string get_NuGetLicense_InvalidLicenseType();
    internal static string get_NuGetLicense_LicenseElementMissingValue();
    internal static string get_NuGetLicense_LicenseExpressionVersionTooHigh();
    internal static string get_NuGetLicense_MissingRequiredValue();
    internal static string get_NuGetLicenseExpression_DeprecatedIdentifier();
    internal static string get_NuGetLicenseExpression_ExceptionIdentifierIsLicense();
    internal static string get_NuGetLicenseExpression_IllegalUnlicensedOperator();
    internal static string get_NuGetLicenseExpression_InvalidCharacters();
    internal static string get_NuGetLicenseExpression_InvalidExceptionIdentifier();
    internal static string get_NuGetLicenseExpression_InvalidExpression();
    internal static string get_NuGetLicenseExpression_InvalidToken();
    internal static string get_NuGetLicenseExpression_LicenseIdentifierIsException();
    internal static string get_NuGetLicenseExpression_LicenseInvalidCharacters();
    internal static string get_NuGetLicenseExpression_MismatchedParentheses();
    internal static string get_NuGetLicenseExpression_NonStandardIdentifier();
    internal static string get_NuGetLicenseExpression_UnexpectedIdentifier();
    internal static string get_NuGetLicenseExpression_UnlicensedPackageWarning();
    internal static string get_NuGetPackageOwners();
    internal static string get_NuGetPackageOwnersInvalid();
    internal static string get_NuGetPackageOwnersInvalidValue();
    internal static string get_NuGetV3ServiceIndexUrl();
    internal static string get_NuGetV3ServiceIndexUrlInvalid();
    internal static string get_NuGetV3ServiceIndexUrlInvalidValue();
    internal static string get_PackageEntryAlreadyExist();
    internal static string get_PackageEntryNotExist();
    internal static string get_PackageMinVersionNotSatisfied();
    internal static string get_PackageSignatureVerificationLog();
    internal static string get_PackagesNodeNotExist();
    internal static string get_PackageStreamShouldBeSeekable();
    internal static string get_PrimarySignatureFriendlyName();
    internal static string get_PrimarySignatureHasNoTimestamp();
    internal static string get_PropertyCannotBeNull();
    internal static string get_RangeOutOfBoundsForArray();
    internal static string get_RepositoryCountersignatureFriendlyName();
    internal static string get_RepositoryCountersignatureHasNoCertificate();
    internal static string get_RepositoryCountersignatureHasNoTimestamp();
    internal static string get_RepositoryPrimarySignatureFriendlyName();
    internal static string get_SignatureContainsInvalidAttribute();
    internal static string get_SignatureDebug_HashOidFound();
    internal static string get_SignatureFailureInvalidHashAlgorithmOid();
    internal static string get_SignatureFriendlyName();
    internal static string get_SignatureHashAlgorithm();
    internal static string get_SignaturePackageIntegrityFailure();
    internal static string get_SignatureType();
    internal static string get_SignedPackageAlreadySigned();
    internal static string get_SignedPackageArchiveIOExtraRead();
    internal static string get_SignedPackageArchiveIOInvalidRead();
    internal static string get_SignedPackageNotSignedOnRemove();
    internal static string get_SignedPackageNotSignedOnVerify();
    internal static string get_SignedPackagePackageAlreadyCountersigned();
    internal static string get_SignedPackageUnableToAccessSignature();
    internal static string get_SignError_TimestampCertificateFailsPublicKeyLengthRequirement();
    internal static string get_SignError_TimestampGeneralizedTimeInvalid();
    internal static string get_SignError_TimestampIntegrityCheckFailed();
    internal static string get_SignError_TimestampNoCertificate();
    internal static string get_SignError_TimestampNotYetValid();
    internal static string get_SignError_TimestampSignatureValidationFailed();
    internal static string get_SignFailureCertificateInvalidProviderType();
    internal static string get_SigningCannotBeDoneInPlace();
    internal static string get_SigningCertificateAttributeMustNotBePresent();
    internal static string get_SigningCertificateCertificateNotFound();
    internal static string get_SigningCertificateInvalid();
    internal static string get_SigningCertificateV1OrV2AttributeMustBePresent();
    internal static string get_SigningCertificateV2CertificateNotFound();
    internal static string get_SigningCertificateV2Invalid();
    internal static string get_SigningCertificateV2UnsupportedHashAlgorithm();
    internal static string get_SigningError_CertificateFailsPublicKeyLengthRequirement();
    internal static string get_SigningError_CertificateHasLifetimeSigningEKU();
    internal static string get_SigningError_CertificateHasUnsupportedSignatureAlgorithm();
    internal static string get_SigningError_NotYetValid();
    internal static string get_SigningWouldRequireZip64();
    internal static string get_StreamMustBeReadable();
    internal static string get_StreamMustBeSeekable();
    internal static string get_StringCannotBeNullOrEmpty();
    internal static string get_TimestampCertificateUnsupportedSignatureAlgorithm();
    internal static string get_TimestampFailureInvalidHttpScheme();
    internal static string get_TimestampFailureNonceMismatch();
    internal static string get_TimestampServiceRespondedError();
    internal static string get_TimestampSignatureUnsupportedDigestAlgorithm();
    internal static string get_TimestampValue();
    internal static string get_UnableToAddEntry();
    internal static string get_UnableToParseClientVersion();
    internal static string get_UnableToReadPackageHashInformation();
    internal static string get_UnexpectedPackageSignatureVerificationError();
    internal static string get_UnrecognizedEnumValue();
    internal static string get_UnrelatedSignatures();
    internal static string get_UnsupportedAsn1();
    internal static string get_UnsupportedSignatureFormatVersion();
    internal static string get_UntrustedRoot_WithCertificateBundle();
    internal static string get_UntrustedRoot_WithoutCertificateBundle();
    internal static string get_VerificationCertDisplay();
    internal static string get_VerificationTimestamperCertDisplay();
    internal static string get_Verify_ErrorNoCertificate();
    internal static string get_VerifyCertTrustOfflineWhileRevocationModeOffline();
    internal static string get_VerifyCertTrustOfflineWhileRevocationModeOnline();
    internal static string get_VerifyChainBuildingIssue();
    internal static string get_VerifyChainBuildingIssue_UntrustedRoot();
    internal static string get_VerifyError_CertificateFailsPublicKeyLengthRequirement();
    internal static string get_VerifyError_CertificateHasLifetimeSigningEKU();
    internal static string get_VerifyError_CertificateHasUnsupportedSignatureAlgorithm();
    internal static string get_VerifyError_CertificateNotYetValid();
    internal static string get_VerifyError_InvalidCertificateChain();
    internal static string get_VerifyError_SignatureNotTimeValid();
    internal static string get_VerifyError_SignatureVerificationFailed();
    internal static string get_VerifyError_TimestampCertificateFailsPublicKeyLengthRequirement();
    internal static string get_VerifyError_TimestampGeneralizedTimeInvalid();
    internal static string get_VerifyError_TimestampIntegrityCheckFailed();
    internal static string get_VerifyError_TimestampInvalid();
    internal static string get_VerifyError_TimestampMessageImprintUnsupportedHashAlgorithm();
    internal static string get_VerifyError_TimestampNoCertificate();
    internal static string get_VerifyError_TimestampNotYetValid();
    internal static string get_VerifyError_TimestampSignatureUnsupportedDigestAlgorithm();
    internal static string get_VerifyError_TimestampSignatureValidationFailed();
    internal static string get_VerifyError_TimestampUnsupportedSignatureAlgorithm();
    internal static string get_VerifyError_TimestampVerifyChainBuildingIssue();
    internal static string get_VerifyTimestampChainBuildingIssue_UntrustedRoot();
    internal static string get_ZipFileLastWriteTimeStampModifiedMessage();
    internal static string get_ZipFileTimeStampModifiedWarning();
}
public static class NuGet.Packaging.TopologicalSortUtility : object {
    public static IReadOnlyList`1<T> SortPackagesByDependencyOrder(IEnumerable`1<T> items, StringComparer comparer, Func`2<T, string> getId, Func`2<T, String[]> getDependencies);
    public static IReadOnlyList`1<PackageDependencyInfo> SortPackagesByDependencyOrder(IEnumerable`1<PackageDependencyInfo> packages);
    private static List`1<ItemDependencyInfo> SortPackagesByDependencyOrder(List`1<ItemDependencyInfo> items, StringComparer comparer);
    private static void UpdateChildCounts(ItemDependencyInfo package);
    private static void CalculateRelationships(ItemDependencyInfo[] packages, Dictionary`2<string, ItemDependencyInfo> lookup);
    private static string GetPackageDependencyInfoId(PackageDependencyInfo info);
    private static String[] GetPackageDependencyInfoDependencies(PackageDependencyInfo info);
}
public class NuGet.Packaging.UnsafePackageEntryException : PackagingException {
    public UnsafePackageEntryException(string message);
    public virtual ILogMessage AsLogMessage();
}
public class NuGet.Packaging.VersionFolderPathResolver : object {
    [CompilerGeneratedAttribute]
private string <RootPath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLowerCase>k__BackingField;
    public string RootPath { get; }
    public bool IsLowerCase { get; }
    public VersionFolderPathResolver(string rootPath);
    public VersionFolderPathResolver(string rootPath, bool isLowercase);
    [CompilerGeneratedAttribute]
public string get_RootPath();
    [CompilerGeneratedAttribute]
public bool get_IsLowerCase();
    public virtual string GetInstallPath(string packageId, NuGetVersion version);
    public string GetVersionListPath(string packageId);
    public string GetPackageFilePath(string packageId, NuGetVersion version);
    public string GetManifestFilePath(string packageId, NuGetVersion version);
    public string GetHashPath(string packageId, NuGetVersion version);
    public string GetHashFileName(string packageId, NuGetVersion version);
    public string GetNupkgMetadataPath(string packageId, NuGetVersion version);
    public virtual string GetVersionListDirectory(string packageId);
    public virtual string GetPackageDirectory(string packageId, NuGetVersion version);
    public virtual string GetPackageFileName(string packageId, NuGetVersion version);
    public string GetPackageDownloadMarkerFileName(string packageId);
    public virtual string GetManifestFileName(string packageId, NuGetVersion version);
    private string Normalize(NuGetVersion version);
    private string Normalize(string packageId);
}
[ExtensionAttribute]
public static class NuGet.Packaging.XElementExtensions : object {
    [ExtensionAttribute]
public static string GetOptionalAttributeValue(XElement element, string localName, string namespaceName);
    [ExtensionAttribute]
public static IEnumerable`1<XElement> ElementsNoNamespace(XContainer container, string localName);
    [ExtensionAttribute]
public static XElement Except(XElement source, XElement target);
    private static XElement FindElement(XElement source, XElement targetChild);
    private static int Compare(XElement target, XElement left, XElement right);
    private static int CountMatches(XElement left, XElement right, Func`3<XAttribute, XAttribute, bool> matcher);
    private static bool HasComment(XElement element, XComment comment);
    private static bool HasConflict(XElement source, XElement target);
    private static bool AttributeEquals(XAttribute source, XAttribute target);
}
[ExtensionAttribute]
internal static class NuGet.Packaging.Xml.PackageMetadataXmlExtensions : object {
    private static string References;
    private static string Reference;
    private static string Group;
    private static string File;
    private static string TargetFramework;
    private static string FrameworkAssemblies;
    private static string FrameworkAssembly;
    private static string AssemblyName;
    private static string Dependencies;
    private static string Files;
    [ExtensionAttribute]
public static XElement ToXElement(ManifestMetadata metadata, XNamespace ns);
    [ExtensionAttribute]
public static XElement ToXElement(ManifestMetadata metadata, XNamespace ns, bool generateBackwardsCompatible);
    private static XElement GetXElementFromGroupableItemSets(XNamespace ns, IEnumerable`1<TSet> objectSets, Func`2<TSet, bool> isGroupable, Func`2<TSet, string> getGroupIdentifer, Func`2<TSet, IEnumerable`1<TItem>> getItems, Func`3<XNamespace, TItem, XElement> getXElementFromItem, string parentName, string identifierAttributeName);
    private static XElement GetXElementFromFrameworkReference(XNamespace ns, FrameworkReference frameworkReference);
    private static XElement GetXElementFromPackageReference(XNamespace ns, string reference);
    private static XElement GetXElementFromPackageDependency(XNamespace ns, PackageDependency dependency);
    private static XElement GetXElementFromFrameworkAssemblies(XNamespace ns, IEnumerable`1<FrameworkAssemblyReference> references);
    private static XElement GetXElementFromManifestContentFiles(XNamespace ns, IEnumerable`1<ManifestContentFiles> contentFiles);
    private static XElement GetXElementFromManifestContentFile(XNamespace ns, ManifestContentFiles file);
    private static XElement GetXElementFromLicenseMetadata(XNamespace ns, LicenseMetadata metadata);
    private static XElement GetXElementFromManifestRepository(XNamespace ns, RepositoryMetadata repository);
    private static XElement GetXElementFromManifestPackageTypes(XNamespace ns, IEnumerable`1<PackageType> packageTypes);
    private static XElement GetXElementFromManifestPackageType(XNamespace ns, PackageType packageType);
    private static XAttribute GetXAttributeFromNameAndValue(string name, object value);
    private static void AddElementIfNotNull(XElement parent, XNamespace ns, string name, T value);
    private static void AddElementIfNotNull(XElement parent, XNamespace ns, string name, T value, Func`2<T, object> process);
    private static void AddElementIfNotEmpty(XElement parent, XNamespace ns, string name, IEnumerable`1<T> value, Func`2<IEnumerable`1<T>, object> process);
}
public enum NuGet.Packaging.XmlDocFileSaveMode : Enum {
    public int value__;
    public static XmlDocFileSaveMode None;
    public static XmlDocFileSaveMode Skip;
    public static XmlDocFileSaveMode Compress;
}
[ObsoleteAttribute("This class is obsolete and will be removed in a future release.")]
public static class NuGet.Packaging.XmlUtility : object {
    public static XDocument LoadSafe(Stream input);
    public static XDocument LoadSafe(Stream input, bool ignoreWhiteSpace);
}
[ExtensionAttribute]
public static class NuGet.Packaging.ZipArchiveExtensions : object {
    [ExtensionAttribute]
public static ZipArchiveEntry LookupEntry(ZipArchive zipArchive, string path);
    [ExtensionAttribute]
public static IEnumerable`1<string> GetFiles(ZipArchive zipArchive);
    private static string UnescapePath(string path);
    [ExtensionAttribute]
public static Stream OpenFile(ZipArchive zipArchive, string path);
    [ExtensionAttribute]
public static string SaveAsFile(ZipArchiveEntry entry, string fileFullPath, ILogger logger);
    [ExtensionAttribute]
public static void UpdateFileTimeFromEntry(ZipArchiveEntry entry, string fileFullPath, ILogger logger);
    internal static void UpdateFileTime(string fileFullPath, DateTime dateTime);
}
public class NuGet.Packaging.ZipFilePair : object {
    private ZipArchiveEntry _packageEntry;
    private string _fileFullPath;
    public string FileFullPath { get; }
    public ZipArchiveEntry PackageEntry { get; }
    public ZipFilePair(string fileFullPath, ZipArchiveEntry entry);
    public string get_FileFullPath();
    public ZipArchiveEntry get_PackageEntry();
    public bool IsInstalled();
}
public class NuGet.RuntimeModel.CompatibilityProfile : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<FrameworkRuntimePair> <RestoreContexts>k__BackingField;
    public string Name { get; }
    public IList`1<FrameworkRuntimePair> RestoreContexts { get; }
    public CompatibilityProfile(string name);
    public CompatibilityProfile(string name, IEnumerable`1<FrameworkRuntimePair> restoreContexts);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public IList`1<FrameworkRuntimePair> get_RestoreContexts();
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CompatibilityProfile other);
    public CompatibilityProfile Clone();
}
public interface NuGet.RuntimeModel.IObjectWriter {
    public abstract virtual void WriteObjectStart();
    public abstract virtual void WriteObjectStart(string name);
    public abstract virtual void WriteObjectEnd();
    public abstract virtual void WriteNameValue(string name, int value);
    public abstract virtual void WriteNameValue(string name, bool value);
    public abstract virtual void WriteNameValue(string name, string value);
    public abstract virtual void WriteNameArray(string name, IEnumerable`1<string> values);
    public abstract virtual void WriteArrayStart(string name);
    public abstract virtual void WriteArrayEnd();
}
public class NuGet.RuntimeModel.JsonObjectWriter : object {
    private JsonWriter _writer;
    private bool _isDisposed;
    public JsonObjectWriter(JsonWriter writer);
    public sealed virtual void Dispose();
    public sealed virtual void WriteObjectStart();
    public sealed virtual void WriteObjectStart(string name);
    public sealed virtual void WriteArrayStart(string name);
    public sealed virtual void WriteObjectEnd();
    public sealed virtual void WriteArrayEnd();
    public sealed virtual void WriteNameValue(string name, int value);
    public sealed virtual void WriteNameValue(string name, bool value);
    public sealed virtual void WriteNameValue(string name, string value);
    public sealed virtual void WriteNameArray(string name, IEnumerable`1<string> values);
    private void ThrowIfDisposed();
}
public static class NuGet.RuntimeModel.JsonRuntimeFormat : object {
    public static RuntimeGraph ReadRuntimeGraph(string filePath);
    public static RuntimeGraph ReadRuntimeGraph(Stream stream);
    public static RuntimeGraph ReadRuntimeGraph(TextReader textReader);
    public static void WriteRuntimeGraph(string filePath, RuntimeGraph runtimeGraph);
    public static RuntimeGraph ReadRuntimeGraph(JToken json);
    public static void WriteRuntimeGraph(IObjectWriter writer, RuntimeGraph runtimeGraph);
    private static void WriteRuntimeDescription(IObjectWriter writer, RuntimeDescription data);
    private static void WriteRuntimeDependencySet(IObjectWriter writer, RuntimeDependencySet data);
    private static void WritePackageDependency(IObjectWriter writer, RuntimePackageDependency data);
    private static void WriteCompatibilityProfile(IObjectWriter writer, CompatibilityProfile data);
    private static CompatibilityProfile ReadCompatibilityProfile(KeyValuePair`2<string, JToken> json);
    [IteratorStateMachineAttribute("NuGet.RuntimeModel.JsonRuntimeFormat/<ReadCompatibilitySets>d__11")]
private static IEnumerable`1<FrameworkRuntimePair> ReadCompatibilitySets(KeyValuePair`2<string, JToken> property);
    private static RuntimeDescription ReadRuntimeDescription(KeyValuePair`2<string, JToken> json);
    private static RuntimeDependencySet ReadRuntimeDependencySet(KeyValuePair`2<string, JToken> json);
    private static RuntimePackageDependency ReadRuntimePackageDependency(KeyValuePair`2<string, JToken> json);
    private static IEnumerable`1<KeyValuePair`2<string, JToken>> EachProperty(JToken json);
}
public class NuGet.RuntimeModel.RuntimeDependencySet : object {
    private static IReadOnlyDictionary`2<string, RuntimePackageDependency> EmptyDependencies;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, RuntimePackageDependency> <Dependencies>k__BackingField;
    public string Id { get; }
    public IReadOnlyDictionary`2<string, RuntimePackageDependency> Dependencies { get; }
    public RuntimeDependencySet(string id);
    public RuntimeDependencySet(string id, IEnumerable`1<RuntimePackageDependency> dependencies);
    private RuntimeDependencySet(string id, IReadOnlyDictionary`2<string, RuntimePackageDependency> dependencies);
    private static RuntimeDependencySet();
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, RuntimePackageDependency> get_Dependencies();
    public sealed virtual bool Equals(RuntimeDependencySet other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [ObsoleteAttribute("This type is immutable, so there is no need or point to clone it.")]
public RuntimeDependencySet Clone();
    public virtual string ToString();
}
public class NuGet.RuntimeModel.RuntimeDescription : object {
    private static IReadOnlyDictionary`2<string, RuntimeDependencySet> EmptyRuntimeDependencySets;
    [CompilerGeneratedAttribute]
private string <RuntimeIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <InheritedRuntimes>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, RuntimeDependencySet> <RuntimeDependencySets>k__BackingField;
    public string RuntimeIdentifier { get; }
    public IReadOnlyList`1<string> InheritedRuntimes { get; }
    public IReadOnlyDictionary`2<string, RuntimeDependencySet> RuntimeDependencySets { get; }
    public RuntimeDescription(string runtimeIdentifier);
    public RuntimeDescription(string runtimeIdentifier, IEnumerable`1<string> inheritedRuntimes);
    public RuntimeDescription(string runtimeIdentifier, IEnumerable`1<RuntimeDependencySet> runtimeDependencySets);
    public RuntimeDescription(string runtimeIdentifier, IEnumerable`1<string> inheritedRuntimes, IEnumerable`1<RuntimeDependencySet> runtimeDependencySets);
    private RuntimeDescription(string runtimeIdentifier, IReadOnlyList`1<string> inheritedRuntimes, IReadOnlyDictionary`2<string, RuntimeDependencySet> runtimeDependencySets);
    private static RuntimeDescription();
    [CompilerGeneratedAttribute]
public string get_RuntimeIdentifier();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_InheritedRuntimes();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, RuntimeDependencySet> get_RuntimeDependencySets();
    public sealed virtual bool Equals(RuntimeDescription other);
    [ObsoleteAttribute("This type is immutable, so there is no need or point to clone it.")]
public RuntimeDescription Clone();
    public static RuntimeDescription Merge(RuntimeDescription left, RuntimeDescription right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NuGet.Packaging.NullableContextAttribute("1")]
[NuGet.Packaging.NullableAttribute("0")]
public class NuGet.RuntimeModel.RuntimeGraph : object {
    private static ReadOnlyDictionary`2<string, RuntimeDescription> EmptyRuntimes;
    private static ReadOnlyDictionary`2<string, CompatibilityProfile> EmptySupports;
    [NuGet.Packaging.NullableAttribute("2")]
private ConcurrentDictionary`2<RuntimeCompatKey, bool> _areCompatible;
    [NuGet.Packaging.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<string, HashSet`1<string>> _expandCache;
    [NuGet.Packaging.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<RuntimeDependencyKey, List`1<RuntimePackageDependency>> _dependencyCache;
    [NuGet.Packaging.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private HashSet`1<string> _packagesWithDependencies;
    public static string RuntimeGraphFileName;
    public static RuntimeGraph Empty;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, RuntimeDescription> <Runtimes>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, CompatibilityProfile> <Supports>k__BackingField;
    public IReadOnlyDictionary`2<string, RuntimeDescription> Runtimes { get; }
    public IReadOnlyDictionary`2<string, CompatibilityProfile> Supports { get; }
    internal bool IsEmpty { get; }
    public RuntimeGraph(IEnumerable`1<RuntimeDescription> runtimes);
    public RuntimeGraph(IEnumerable`1<CompatibilityProfile> supports);
    public RuntimeGraph(IEnumerable`1<RuntimeDescription> runtimes, IEnumerable`1<CompatibilityProfile> supports);
    private RuntimeGraph(IReadOnlyDictionary`2<string, RuntimeDescription> runtimes, IReadOnlyDictionary`2<string, CompatibilityProfile> supports);
    private static RuntimeGraph();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, RuntimeDescription> get_Runtimes();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, CompatibilityProfile> get_Supports();
    internal bool get_IsEmpty();
    public RuntimeGraph Clone();
    public static RuntimeGraph Merge(RuntimeGraph left, RuntimeGraph right);
    public IEnumerable`1<string> ExpandRuntime(string runtime);
    private HashSet`1<string> ExpandRuntimeCached(string runtime);
    public bool AreCompatible(string criteria, string provided);
    public IEnumerable`1<RuntimePackageDependency> FindRuntimeDependencies(string runtimeName, string packageId);
    [NuGet.Packaging.NullableContextAttribute("2")]
public sealed virtual bool Equals(RuntimeGraph other);
    [NuGet.Packaging.NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
internal static IReadOnlyDictionary`2<string, T> <Clone>g__Clone|21_1(IReadOnlyDictionary`2<string, T> source, Func`2<T, T> cloneFunc);
    [CompilerGeneratedAttribute]
private HashSet`1<string> <ExpandRuntimeCached>b__24_0(string r);
    [IteratorStateMachineAttribute("NuGet.RuntimeModel.RuntimeGraph/<<ExpandRuntimeCached>g__ExpandRuntimeInternal|24_1>d")]
[CompilerGeneratedAttribute]
private IEnumerable`1<string> <ExpandRuntimeCached>g__ExpandRuntimeInternal|24_1(string runtime);
    [CompilerGeneratedAttribute]
private bool <AreCompatible>g__AreCompatibleInternal|25_0(RuntimeCompatKey key);
    [CompilerGeneratedAttribute]
private List`1<RuntimePackageDependency> <FindRuntimeDependencies>g__FindRuntimeDependenciesInternal|26_1(RuntimeDependencyKey key);
}
public class NuGet.RuntimeModel.RuntimePackageDependency : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionRange <VersionRange>k__BackingField;
    public string Id { get; }
    public VersionRange VersionRange { get; }
    public RuntimePackageDependency(string id, VersionRange versionRange);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public VersionRange get_VersionRange();
    [ObsoleteAttribute("This type is immutable, so there is no need or point to clone it.")]
public RuntimePackageDependency Clone();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(RuntimePackageDependency other);
}
internal static class NuGet.Shared.EncodingUtility : object {
    [NullableContextAttribute("1")]
internal static string ToHex(Byte[] bytes, int length);
    private static char ToHexChar(int input);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.EqualityUtility : object {
    [ExtensionAttribute]
internal static bool OrderedEquals(IEnumerable`1<TSource> self, IEnumerable`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(ICollection`1<TSource> self, ICollection`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(IList`1<TSource> self, IList`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IEnumerable`1<T> self, IEnumerable`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(ICollection`1<T> self, ICollection`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IList`1<T> self, IList`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SetEqualsWithNullCheck(ISet`1<T> self, ISet`1<T> other, IEqualityComparer`1<T> comparer);
    [NullableContextAttribute("1")]
internal static bool DictionaryEquals(IDictionary`2<TKey, TValue> self, IDictionary`2<TKey, TValue> other, Func`3<TValue, TValue, bool> compareValues);
    [NullableContextAttribute("1")]
internal static bool DictionaryOfSequenceEquals(IDictionary`2<TKey, IEnumerable`1<TValue>> self, IDictionary`2<TKey, IEnumerable`1<TValue>> other);
    [NullableContextAttribute("1")]
internal static bool EqualsWithNullCheck(T self, T other);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static bool EqualsFalse(string value);
    private static bool TryIdentityEquals(T self, T other, Boolean& equals);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.Extensions : object {
    [ExtensionAttribute]
public static List`1<T> AsList(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static HashSet`1<T> AsHashSet(ISet`1<T> enumerable, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> enumeration, Action`1<T> action);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
internal class NuGet.Shared.HashCodeCombiner : ValueType {
    private static long Seed;
    private long _combinedHash;
    internal int CombinedHash { get; }
    internal int get_CombinedHash();
    private void AddHashCode(int i);
    internal void AddObject(int i);
    internal void AddObject(bool b);
    internal void AddObject(T o, IEqualityComparer`1<T> comparer);
    internal void AddObject(T o);
    [NullableContextAttribute("0")]
internal void AddStruct(Nullable`1<T> o);
    [NullableContextAttribute("0")]
internal void AddStruct(T o);
    [NullableContextAttribute("2")]
internal void AddStringIgnoreCase(string s);
    internal void AddSequence(IEnumerable`1<T> sequence);
    internal void AddSequence(T[] array);
    internal void AddSequence(IList`1<T> list);
    internal void AddSequence(IReadOnlyList`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list, IEqualityComparer`1<T> comparer);
    internal void AddDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> dictionary);
    internal static int GetHashCode(T1 o1, T2 o2);
    internal static int GetHashCode(T1 o1, T2 o2, T3 o3);
}
internal static class NuGet.Shared.NuGet.Configuration1122.EncodingUtility : object {
    [NuGet.Configuration.NullableContextAttribute("1")]
internal static string ToHex(Byte[] bytes, int length);
    private static char ToHexChar(int input);
}
[NuGet.Configuration.NullableContextAttribute("2")]
[NuGet.Configuration.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.NuGet.Configuration1122.EqualityUtility : object {
    [ExtensionAttribute]
internal static bool OrderedEquals(IEnumerable`1<TSource> self, IEnumerable`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(ICollection`1<TSource> self, ICollection`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(IList`1<TSource> self, IList`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IEnumerable`1<T> self, IEnumerable`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(ICollection`1<T> self, ICollection`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IList`1<T> self, IList`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SetEqualsWithNullCheck(ISet`1<T> self, ISet`1<T> other, IEqualityComparer`1<T> comparer);
    [NuGet.Configuration.NullableContextAttribute("1")]
internal static bool DictionaryEquals(IDictionary`2<TKey, TValue> self, IDictionary`2<TKey, TValue> other, Func`3<TValue, TValue, bool> compareValues);
    [NuGet.Configuration.NullableContextAttribute("1")]
internal static bool DictionaryOfSequenceEquals(IDictionary`2<TKey, IEnumerable`1<TValue>> self, IDictionary`2<TKey, IEnumerable`1<TValue>> other);
    [NuGet.Configuration.NullableContextAttribute("1")]
internal static bool EqualsWithNullCheck(T self, T other);
    [NuGet.Configuration.NullableContextAttribute("1")]
[ExtensionAttribute]
internal static bool EqualsFalse(string value);
    private static bool TryIdentityEquals(T self, T other, Boolean& equals);
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.NuGet.Configuration1122.Extensions : object {
    [ExtensionAttribute]
public static List`1<T> AsList(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static HashSet`1<T> AsHashSet(ISet`1<T> enumerable, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> enumeration, Action`1<T> action);
}
[NuGet.Configuration.NullableContextAttribute("1")]
[NuGet.Configuration.NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[NuGet.Configuration1122.CompilerFeatureRequiredAttribute("RefStructs")]
internal class NuGet.Shared.NuGet.Configuration1122.HashCodeCombiner : ValueType {
    private static long Seed;
    private long _combinedHash;
    internal int CombinedHash { get; }
    internal int get_CombinedHash();
    private void AddHashCode(int i);
    internal void AddObject(int i);
    internal void AddObject(bool b);
    internal void AddObject(T o, IEqualityComparer`1<T> comparer);
    internal void AddObject(T o);
    [NuGet.Configuration.NullableContextAttribute("0")]
internal void AddStruct(Nullable`1<T> o);
    [NuGet.Configuration.NullableContextAttribute("0")]
internal void AddStruct(T o);
    [NuGet.Configuration.NullableContextAttribute("2")]
internal void AddStringIgnoreCase(string s);
    internal void AddSequence(IEnumerable`1<T> sequence);
    internal void AddSequence(T[] array);
    internal void AddSequence(IList`1<T> list);
    internal void AddSequence(IReadOnlyList`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list, IEqualityComparer`1<T> comparer);
    internal void AddDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> dictionary);
    internal static int GetHashCode(T1 o1, T2 o2);
    internal static int GetHashCode(T1 o1, T2 o2, T3 o3);
}
internal static class NuGet.Shared.NuGet.Configuration1122.XmlUtility : object {
    internal static XDocument Load(string path);
    internal static XDocument Load(string path, LoadOptions options);
    internal static XDocument Load(Stream input);
    internal static XDocument Load(Stream input, LoadOptions options);
    internal static string GetEncodedXMLName(string name);
    internal static XmlReaderSettings GetXmlReaderSettings(LoadOptions options);
}
internal static class NuGet.Shared.NuGet.Frameworks1139.EncodingUtility : object {
    [NuGet.Frameworks.NullableContextAttribute("1")]
internal static string ToHex(Byte[] bytes, int length);
    private static char ToHexChar(int input);
}
[NuGet.Frameworks.NullableContextAttribute("2")]
[NuGet.Frameworks.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.NuGet.Frameworks1139.EqualityUtility : object {
    [ExtensionAttribute]
internal static bool OrderedEquals(IEnumerable`1<TSource> self, IEnumerable`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(ICollection`1<TSource> self, ICollection`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(IList`1<TSource> self, IList`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IEnumerable`1<T> self, IEnumerable`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(ICollection`1<T> self, ICollection`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IList`1<T> self, IList`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SetEqualsWithNullCheck(ISet`1<T> self, ISet`1<T> other, IEqualityComparer`1<T> comparer);
    [NuGet.Frameworks.NullableContextAttribute("1")]
internal static bool DictionaryEquals(IDictionary`2<TKey, TValue> self, IDictionary`2<TKey, TValue> other, Func`3<TValue, TValue, bool> compareValues);
    [NuGet.Frameworks.NullableContextAttribute("1")]
internal static bool DictionaryOfSequenceEquals(IDictionary`2<TKey, IEnumerable`1<TValue>> self, IDictionary`2<TKey, IEnumerable`1<TValue>> other);
    [NuGet.Frameworks.NullableContextAttribute("1")]
internal static bool EqualsWithNullCheck(T self, T other);
    [NuGet.Frameworks.NullableContextAttribute("1")]
[ExtensionAttribute]
internal static bool EqualsFalse(string value);
    private static bool TryIdentityEquals(T self, T other, Boolean& equals);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.NuGet.Frameworks1139.Extensions : object {
    [ExtensionAttribute]
public static List`1<T> AsList(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static HashSet`1<T> AsHashSet(ISet`1<T> enumerable, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> enumeration, Action`1<T> action);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[NuGet.Frameworks1139.CompilerFeatureRequiredAttribute("RefStructs")]
internal class NuGet.Shared.NuGet.Frameworks1139.HashCodeCombiner : ValueType {
    private static long Seed;
    private long _combinedHash;
    internal int CombinedHash { get; }
    internal int get_CombinedHash();
    private void AddHashCode(int i);
    internal void AddObject(int i);
    internal void AddObject(bool b);
    internal void AddObject(T o, IEqualityComparer`1<T> comparer);
    internal void AddObject(T o);
    [NuGet.Frameworks.NullableContextAttribute("0")]
internal void AddStruct(Nullable`1<T> o);
    [NuGet.Frameworks.NullableContextAttribute("0")]
internal void AddStruct(T o);
    [NuGet.Frameworks.NullableContextAttribute("2")]
internal void AddStringIgnoreCase(string s);
    internal void AddSequence(IEnumerable`1<T> sequence);
    internal void AddSequence(T[] array);
    internal void AddSequence(IList`1<T> list);
    internal void AddSequence(IReadOnlyList`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list, IEqualityComparer`1<T> comparer);
    internal void AddDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> dictionary);
    internal static int GetHashCode(T1 o1, T2 o2);
    internal static int GetHashCode(T1 o1, T2 o2, T3 o3);
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
internal static class NuGet.Shared.NuGet.Frameworks1139.XmlUtility : object {
    internal static XDocument Load(string path);
    internal static XDocument Load(string path, LoadOptions options);
    internal static XDocument Load(Stream input);
    internal static XDocument Load(Stream input, LoadOptions options);
    internal static string GetEncodedXMLName(string name);
    internal static XmlReaderSettings GetXmlReaderSettings(LoadOptions options);
}
internal static class NuGet.Shared.NuGet.Packaging1156.EncodingUtility : object {
    [NuGet.Packaging.NullableContextAttribute("1")]
internal static string ToHex(Byte[] bytes, int length);
    private static char ToHexChar(int input);
}
[NuGet.Packaging.NullableContextAttribute("2")]
[NuGet.Packaging.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.NuGet.Packaging1156.EqualityUtility : object {
    [ExtensionAttribute]
internal static bool OrderedEquals(IEnumerable`1<TSource> self, IEnumerable`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(ICollection`1<TSource> self, ICollection`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(IList`1<TSource> self, IList`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IEnumerable`1<T> self, IEnumerable`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(ICollection`1<T> self, ICollection`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IList`1<T> self, IList`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SetEqualsWithNullCheck(ISet`1<T> self, ISet`1<T> other, IEqualityComparer`1<T> comparer);
    [NuGet.Packaging.NullableContextAttribute("1")]
internal static bool DictionaryEquals(IDictionary`2<TKey, TValue> self, IDictionary`2<TKey, TValue> other, Func`3<TValue, TValue, bool> compareValues);
    [NuGet.Packaging.NullableContextAttribute("1")]
internal static bool DictionaryOfSequenceEquals(IDictionary`2<TKey, IEnumerable`1<TValue>> self, IDictionary`2<TKey, IEnumerable`1<TValue>> other);
    [NuGet.Packaging.NullableContextAttribute("1")]
internal static bool EqualsWithNullCheck(T self, T other);
    [NuGet.Packaging.NullableContextAttribute("1")]
[ExtensionAttribute]
internal static bool EqualsFalse(string value);
    private static bool TryIdentityEquals(T self, T other, Boolean& equals);
}
[NuGet.Packaging.NullableContextAttribute("1")]
[NuGet.Packaging.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.NuGet.Packaging1156.Extensions : object {
    [ExtensionAttribute]
public static List`1<T> AsList(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static HashSet`1<T> AsHashSet(ISet`1<T> enumerable, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> enumeration, Action`1<T> action);
}
[NuGet.Packaging.NullableContextAttribute("1")]
[NuGet.Packaging.NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[NuGet.Packaging1156.CompilerFeatureRequiredAttribute("RefStructs")]
internal class NuGet.Shared.NuGet.Packaging1156.HashCodeCombiner : ValueType {
    private static long Seed;
    private long _combinedHash;
    internal int CombinedHash { get; }
    internal int get_CombinedHash();
    private void AddHashCode(int i);
    internal void AddObject(int i);
    internal void AddObject(bool b);
    internal void AddObject(T o, IEqualityComparer`1<T> comparer);
    internal void AddObject(T o);
    [NuGet.Packaging.NullableContextAttribute("0")]
internal void AddStruct(Nullable`1<T> o);
    [NuGet.Packaging.NullableContextAttribute("0")]
internal void AddStruct(T o);
    [NuGet.Packaging.NullableContextAttribute("2")]
internal void AddStringIgnoreCase(string s);
    internal void AddSequence(IEnumerable`1<T> sequence);
    internal void AddSequence(T[] array);
    internal void AddSequence(IList`1<T> list);
    internal void AddSequence(IReadOnlyList`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list, IEqualityComparer`1<T> comparer);
    internal void AddDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> dictionary);
    internal static int GetHashCode(T1 o1, T2 o2);
    internal static int GetHashCode(T1 o1, T2 o2, T3 o3);
}
internal static class NuGet.Shared.NuGet.Packaging1156.XmlUtility : object {
    internal static XDocument Load(string path);
    internal static XDocument Load(string path, LoadOptions options);
    internal static XDocument Load(Stream input);
    internal static XDocument Load(Stream input, LoadOptions options);
    internal static string GetEncodedXMLName(string name);
    internal static XmlReaderSettings GetXmlReaderSettings(LoadOptions options);
}
internal static class NuGet.Shared.NuGet.Versioning1173.EncodingUtility : object {
    [NuGet.Versioning.NullableContextAttribute("1")]
internal static string ToHex(Byte[] bytes, int length);
    private static char ToHexChar(int input);
}
[NuGet.Versioning.NullableContextAttribute("2")]
[NuGet.Versioning.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.NuGet.Versioning1173.EqualityUtility : object {
    [ExtensionAttribute]
internal static bool OrderedEquals(IEnumerable`1<TSource> self, IEnumerable`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(ICollection`1<TSource> self, ICollection`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(IList`1<TSource> self, IList`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IEnumerable`1<T> self, IEnumerable`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(ICollection`1<T> self, ICollection`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IList`1<T> self, IList`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SetEqualsWithNullCheck(ISet`1<T> self, ISet`1<T> other, IEqualityComparer`1<T> comparer);
    [NuGet.Versioning.NullableContextAttribute("1")]
internal static bool DictionaryEquals(IDictionary`2<TKey, TValue> self, IDictionary`2<TKey, TValue> other, Func`3<TValue, TValue, bool> compareValues);
    [NuGet.Versioning.NullableContextAttribute("1")]
internal static bool DictionaryOfSequenceEquals(IDictionary`2<TKey, IEnumerable`1<TValue>> self, IDictionary`2<TKey, IEnumerable`1<TValue>> other);
    [NuGet.Versioning.NullableContextAttribute("1")]
internal static bool EqualsWithNullCheck(T self, T other);
    [NuGet.Versioning.NullableContextAttribute("1")]
[ExtensionAttribute]
internal static bool EqualsFalse(string value);
    private static bool TryIdentityEquals(T self, T other, Boolean& equals);
}
[NuGet.Versioning.NullableContextAttribute("1")]
[NuGet.Versioning.NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.NuGet.Versioning1173.Extensions : object {
    [ExtensionAttribute]
public static List`1<T> AsList(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static HashSet`1<T> AsHashSet(ISet`1<T> enumerable, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> enumeration, Action`1<T> action);
}
[NuGet.Versioning.NullableContextAttribute("1")]
[NuGet.Versioning.NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[NuGet.Versioning1173.CompilerFeatureRequiredAttribute("RefStructs")]
internal class NuGet.Shared.NuGet.Versioning1173.HashCodeCombiner : ValueType {
    private static long Seed;
    private long _combinedHash;
    internal int CombinedHash { get; }
    internal int get_CombinedHash();
    private void AddHashCode(int i);
    internal void AddObject(int i);
    internal void AddObject(bool b);
    internal void AddObject(T o, IEqualityComparer`1<T> comparer);
    internal void AddObject(T o);
    [NuGet.Versioning.NullableContextAttribute("0")]
internal void AddStruct(Nullable`1<T> o);
    [NuGet.Versioning.NullableContextAttribute("0")]
internal void AddStruct(T o);
    [NuGet.Versioning.NullableContextAttribute("2")]
internal void AddStringIgnoreCase(string s);
    internal void AddSequence(IEnumerable`1<T> sequence);
    internal void AddSequence(T[] array);
    internal void AddSequence(IList`1<T> list);
    internal void AddSequence(IReadOnlyList`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list, IEqualityComparer`1<T> comparer);
    internal void AddDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> dictionary);
    internal static int GetHashCode(T1 o1, T2 o2);
    internal static int GetHashCode(T1 o1, T2 o2, T3 o3);
}
[NuGet.Versioning.NullableContextAttribute("1")]
[NuGet.Versioning.NullableAttribute("0")]
internal static class NuGet.Shared.NuGet.Versioning1173.XmlUtility : object {
    internal static XDocument Load(string path);
    internal static XDocument Load(string path, LoadOptions options);
    internal static XDocument Load(Stream input);
    internal static XDocument Load(Stream input, LoadOptions options);
    internal static string GetEncodedXMLName(string name);
    internal static XmlReaderSettings GetXmlReaderSettings(LoadOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NuGet.Shared.XmlUtility : object {
    internal static XDocument Load(string path);
    internal static XDocument Load(string path, LoadOptions options);
    internal static XDocument Load(Stream input);
    internal static XDocument Load(Stream input, LoadOptions options);
    internal static string GetEncodedXMLName(string name);
    internal static XmlReaderSettings GetXmlReaderSettings(LoadOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.SimplePool`1 : object {
    private ConcurrentStack`1<T> _values;
    private Func`1<T> _allocate;
    public SimplePool`1(Func`1<T> allocate);
    public T Allocate();
    public void Free(T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.StringBuilderPool : object {
    private static int MaxPoolSize;
    private SimplePool`1<StringBuilder> _pool;
    public static StringBuilderPool Shared;
    private static StringBuilderPool();
    public StringBuilder Rent(int minimumCapacity);
    public string ToStringAndReturn(StringBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NuGet.TaskResult : object {
    [CompilerGeneratedAttribute]
private static Task`1<bool> <True>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<bool> <False>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <Zero>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <One>k__BackingField;
    public static Task`1<bool> True { get; }
    public static Task`1<bool> False { get; }
    public static Task`1<int> Zero { get; }
    public static Task`1<int> One { get; }
    private static TaskResult();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_True();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_False();
    public static Task`1<bool> Boolean(bool b);
    [CompilerGeneratedAttribute]
public static Task`1<int> get_Zero();
    [CompilerGeneratedAttribute]
public static Task`1<int> get_One();
    public static Task`1<int> Integer(int i);
    public static Task`1<T> Null();
    public static Task`1<IEnumerable`1<T>> EmptyEnumerable();
    public static Task`1<T[]> EmptyArray();
}
[NuGet.Versioning.NullableContextAttribute("1")]
[NuGet.Versioning.NullableAttribute("0")]
public class NuGet.Versioning.FloatRange : object {
    private NuGetVersion _minVersion;
    private NuGetVersionFloatBehavior _floatBehavior;
    [NuGet.Versioning.NullableAttribute("2")]
private string _releasePrefix;
    public bool HasMinVersion { get; }
    public NuGetVersion MinVersion { get; }
    public NuGetVersionFloatBehavior FloatBehavior { get; }
    [NuGet.Versioning.NullableAttribute("2")]
public string OriginalReleasePrefix { get; }
    [NuGet.Versioning1173.MemberNotNullWhenAttribute("True", "OriginalReleasePrefix")]
[NuGet.Versioning1173.MemberNotNullWhenAttribute("True", "_releasePrefix")]
public bool IncludePrerelease { get; }
    public FloatRange(NuGetVersionFloatBehavior floatBehavior);
    public FloatRange(NuGetVersionFloatBehavior floatBehavior, NuGetVersion minVersion);
    public FloatRange(NuGetVersionFloatBehavior floatBehavior, NuGetVersion minVersion, string releasePrefix);
    public bool get_HasMinVersion();
    public NuGetVersion get_MinVersion();
    public NuGetVersionFloatBehavior get_FloatBehavior();
    [NuGet.Versioning.NullableContextAttribute("2")]
public string get_OriginalReleasePrefix();
    [NuGet.Versioning1173.MemberNotNullWhenAttribute("True", "OriginalReleasePrefix")]
[NuGet.Versioning1173.MemberNotNullWhenAttribute("True", "_releasePrefix")]
public bool get_IncludePrerelease();
    public bool Satisfies(NuGetVersion version);
    public static FloatRange Parse(string versionString);
    public static bool TryParse(string versionString, FloatRange& range);
    private static int CalculateVersionParts(string line);
    public virtual string ToString();
    public void ToString(StringBuilder sb);
    [NuGet.Versioning.NullableContextAttribute("2")]
public sealed virtual bool Equals(FloatRange other);
    [NuGet.Versioning.NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
internal static int <TryParse>g__IndexOf|18_0(string str, char c);
}
[NuGet.Versioning.NullableContextAttribute("1")]
public interface NuGet.Versioning.INuGetVersionable {
    public NuGetVersion Version { get; }
    public abstract virtual NuGetVersion get_Version();
}
public interface NuGet.Versioning.IVersionComparer {
}
public interface NuGet.Versioning.IVersionRangeComparer {
}
[NuGet.Versioning.NullableContextAttribute("1")]
[NuGet.Versioning.NullableAttribute("0")]
public class NuGet.Versioning.NuGetVersion : SemanticVersion {
    [NuGet.Versioning.NullableAttribute("2")]
private string _originalString;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Revision>k__BackingField;
    public Version Version { get; }
    public bool IsLegacyVersion { get; }
    public int Revision { get; }
    public bool IsSemVer2 { get; }
    [NuGet.Versioning.NullableAttribute("2")]
public string OriginalVersion { get; }
    public NuGetVersion(string version);
    public NuGetVersion(NuGetVersion version);
    [NuGet.Versioning.NullableContextAttribute("2")]
public NuGetVersion(Version version, string releaseLabel, string metadata);
    public NuGetVersion(int major, int minor, int patch);
    [NuGet.Versioning.NullableContextAttribute("2")]
public NuGetVersion(int major, int minor, int patch, string releaseLabel);
    [NuGet.Versioning.NullableContextAttribute("2")]
public NuGetVersion(int major, int minor, int patch, string releaseLabel, string metadata);
    [NuGet.Versioning.NullableContextAttribute("2")]
public NuGetVersion(int major, int minor, int patch, IEnumerable`1<string> releaseLabels, string metadata);
    public NuGetVersion(int major, int minor, int patch, int revision);
    public NuGetVersion(int major, int minor, int patch, int revision, string releaseLabel, string metadata);
    [NuGet.Versioning.NullableContextAttribute("2")]
public NuGetVersion(int major, int minor, int patch, int revision, IEnumerable`1<string> releaseLabels, string metadata);
    [NuGet.Versioning.NullableContextAttribute("2")]
public NuGetVersion(Version version, IEnumerable`1<string> releaseLabels, string metadata, string originalVersion);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public Version get_Version();
    public virtual bool get_IsLegacyVersion();
    [CompilerGeneratedAttribute]
public int get_Revision();
    public bool get_IsSemVer2();
    [NuGet.Versioning.NullableContextAttribute("2")]
public string get_OriginalVersion();
    public static NuGetVersion Parse(string value);
    [NuGet.Versioning.NullableContextAttribute("2")]
public static bool TryParse(string value, NuGetVersion& version);
    private static bool TryGetNormalizedVersion(string str, Version& version);
    public static bool TryParseStrict(string value, NuGetVersion& version);
    private static string GetLegacyString(Version version, IEnumerable`1<string> releaseLabels, string metadata);
    [NuGet.Versioning.NullableContextAttribute("2")]
private static IEnumerable`1<string> ParseReleaseLabels(string releaseLabels);
    [CompilerGeneratedAttribute]
internal static int <TryParse>g__IndexOf|26_0(string str, char c);
    [CompilerGeneratedAttribute]
internal static bool <TryGetNormalizedVersion>g__ParseSection|27_0(string str, int start, Int32& end, Int32& versionNumber);
    [CompilerGeneratedAttribute]
internal static bool <TryGetNormalizedVersion>g__IsDigit|27_1(char c);
}
public enum NuGet.Versioning.NuGetVersionFloatBehavior : Enum {
    public int value__;
    public static NuGetVersionFloatBehavior None;
    public static NuGetVersionFloatBehavior Prerelease;
    public static NuGetVersionFloatBehavior Revision;
    public static NuGetVersionFloatBehavior Patch;
    public static NuGetVersionFloatBehavior Minor;
    public static NuGetVersionFloatBehavior Major;
    public static NuGetVersionFloatBehavior AbsoluteLatest;
    public static NuGetVersionFloatBehavior PrereleaseRevision;
    public static NuGetVersionFloatBehavior PrereleasePatch;
    public static NuGetVersionFloatBehavior PrereleaseMinor;
    public static NuGetVersionFloatBehavior PrereleaseMajor;
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class NuGet.Versioning.Resources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string Argument_Cannot_Be_Null_Or_Empty { get; }
    internal static string CannotBeNullWhenParameterIsNotNull { get; }
    internal static string InvalidFloatRangeValue { get; }
    internal static string Invalidvalue { get; }
    internal static string TypeNotSupported { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_Argument_Cannot_Be_Null_Or_Empty();
    internal static string get_CannotBeNullWhenParameterIsNotNull();
    internal static string get_InvalidFloatRangeValue();
    internal static string get_Invalidvalue();
    internal static string get_TypeNotSupported();
}
[NuGet.Versioning.NullableContextAttribute("1")]
[NuGet.Versioning.NullableAttribute("0")]
internal static class NuGet.Versioning.ResourcesFormatter : object {
    internal static ArgumentException TypeNotSupported(Type type, string paramName);
    internal static ArgumentNullException CannotBeNullWhenParameterIsNull(string parameterThatIsNull, string parameterThisIsNotNull);
}
[NuGet.Versioning.NullableContextAttribute("2")]
[NuGet.Versioning.NullableAttribute("0")]
[TypeConverterAttribute("NuGet.Versioning.SemanticVersionConverter")]
public class NuGet.Versioning.SemanticVersion : object {
    [NuGet.Versioning.NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal String[] _releaseLabels;
    internal string _metadata;
    [CompilerGeneratedAttribute]
private int <Major>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Minor>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Patch>k__BackingField;
    [NuGet.Versioning.NullableAttribute("1")]
internal static String[] EmptyReleaseLabels;
    public int Major { get; }
    public int Minor { get; }
    public int Patch { get; }
    [NuGet.Versioning.NullableAttribute("1")]
public IEnumerable`1<string> ReleaseLabels { get; }
    [NuGet.Versioning.NullableAttribute("1")]
public string Release { get; }
    public bool IsPrerelease { get; }
    [NuGet.Versioning1173.MemberNotNullWhenAttribute("True", "Metadata")]
public bool HasMetadata { get; }
    public string Metadata { get; }
    [NuGet.Versioning.NullableContextAttribute("1")]
public SemanticVersion(SemanticVersion version);
    public SemanticVersion(int major, int minor, int patch);
    public SemanticVersion(int major, int minor, int patch, string releaseLabel);
    public SemanticVersion(int major, int minor, int patch, string releaseLabel, string metadata);
    public SemanticVersion(int major, int minor, int patch, IEnumerable`1<string> releaseLabels, string metadata);
    protected SemanticVersion(Version version, string releaseLabel, string metadata);
    protected SemanticVersion(int major, int minor, int patch, int revision, string releaseLabel, string metadata);
    protected SemanticVersion(int major, int minor, int patch, int revision, IEnumerable`1<string> releaseLabels, string metadata);
    [NuGet.Versioning.NullableContextAttribute("1")]
protected SemanticVersion(Version version, IEnumerable`1<string> releaseLabels, string metadata);
    private static SemanticVersion();
    [CompilerGeneratedAttribute]
public int get_Major();
    [CompilerGeneratedAttribute]
public int get_Minor();
    [CompilerGeneratedAttribute]
public int get_Patch();
    [NuGet.Versioning.NullableContextAttribute("1")]
public IEnumerable`1<string> get_ReleaseLabels();
    [NuGet.Versioning.NullableContextAttribute("1")]
public string get_Release();
    public virtual bool get_IsPrerelease();
    [NuGet.Versioning1173.MemberNotNullWhenAttribute("True", "Metadata")]
public virtual bool get_HasMetadata();
    public virtual string get_Metadata();
    [NuGet.Versioning.NullableContextAttribute("1")]
public virtual string ToNormalizedString();
    [NuGet.Versioning.NullableContextAttribute("1")]
public virtual string ToFullString();
    [NuGet.Versioning.NullableContextAttribute("1")]
public virtual string ToString();
    public virtual string ToString(string format, IFormatProvider formatProvider);
    protected bool TryFormatter(string format, IFormatProvider formatProvider, String& formattedString);
    public virtual int GetHashCode();
    public virtual int CompareTo(object obj);
    public virtual int CompareTo(SemanticVersion other);
    public virtual bool Equals(object obj);
    public virtual bool Equals(SemanticVersion other);
    public virtual bool Equals(SemanticVersion other, VersionComparison versionComparison);
    public virtual int CompareTo(SemanticVersion other, VersionComparison versionComparison);
    public static bool op_Equality(SemanticVersion version1, SemanticVersion version2);
    public static bool op_Inequality(SemanticVersion version1, SemanticVersion version2);
    [NuGet.Versioning.NullableContextAttribute("1")]
public static bool op_LessThan(SemanticVersion version1, SemanticVersion version2);
    [NuGet.Versioning.NullableContextAttribute("1")]
public static bool op_LessThanOrEqual(SemanticVersion version1, SemanticVersion version2);
    [NuGet.Versioning.NullableContextAttribute("1")]
public static bool op_GreaterThan(SemanticVersion version1, SemanticVersion version2);
    [NuGet.Versioning.NullableContextAttribute("1")]
public static bool op_GreaterThanOrEqual(SemanticVersion version1, SemanticVersion version2);
    private static int Compare(SemanticVersion version1, SemanticVersion version2);
    [NuGet.Versioning.NullableContextAttribute("1")]
public static SemanticVersion Parse(string value);
    [NuGet.Versioning.NullableContextAttribute("1")]
public static bool TryParse(string value, SemanticVersion& version);
    internal static bool IsLetterOrDigitOrDash(char c);
    internal static bool IsDigit(char c);
    [NuGet.Versioning.NullableContextAttribute("1")]
internal static bool IsValid(string s, bool allowLeadingZeros);
    [NuGet.Versioning.NullableContextAttribute("1")]
internal static bool IsValidPart(string s, bool allowLeadingZeros);
    internal static void ParseSections(string value, String& versionString, String[]& releaseLabels, String& buildMetadata);
    [NuGet.Versioning.NullableContextAttribute("1")]
internal static Version NormalizeVersionValue(Version version);
    private static String[] ParseReleaseLabels(string releaseLabels);
}
[NuGet.Versioning.NullableContextAttribute("2")]
[NuGet.Versioning.NullableAttribute("0")]
public class NuGet.Versioning.SemanticVersionConverter : TypeConverter {
    [NuGet.Versioning.NullableContextAttribute("1")]
public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[NuGet.Versioning.NullableContextAttribute("1")]
[NuGet.Versioning.NullableAttribute("0")]
public class NuGet.Versioning.VersionComparer : object {
    private VersionComparison _mode;
    public static IVersionComparer Default;
    public static IVersionComparer Version;
    public static IVersionComparer VersionRelease;
    public static IVersionComparer VersionReleaseMetadata;
    public VersionComparer(VersionComparison versionComparison);
    private static VersionComparer();
    public static IVersionComparer Get(VersionComparison versionComparison);
    [NuGet.Versioning.NullableContextAttribute("2")]
public sealed virtual bool Equals(SemanticVersion x, SemanticVersion y);
    [NuGet.Versioning.NullableContextAttribute("2")]
public static int Compare(SemanticVersion version1, SemanticVersion version2, VersionComparison versionComparison);
    public sealed virtual int GetHashCode(SemanticVersion version);
    [NuGet.Versioning.NullableContextAttribute("2")]
public sealed virtual int Compare(SemanticVersion x, SemanticVersion y);
    [NuGet.Versioning.NullableContextAttribute("2")]
private static int CompareLegacyVersion(NuGetVersion legacyX, NuGetVersion legacyY);
    private static int CompareReleaseLabels(String[] version1, String[] version2);
    private static int CompareRelease(string version1, string version2);
    private static String[] GetReleaseLabelsOrNull(SemanticVersion version);
    private static bool AreReleaseLabelsEqual(SemanticVersion x, SemanticVersion y);
    private static int GetRevisionOrZero(SemanticVersion version);
}
public enum NuGet.Versioning.VersionComparison : Enum {
    public int value__;
    public static VersionComparison Default;
    public static VersionComparison Version;
    public static VersionComparison VersionRelease;
    public static VersionComparison VersionReleaseMetadata;
}
[NuGet.Versioning.NullableContextAttribute("1")]
[NuGet.Versioning.NullableAttribute("0")]
[ExtensionAttribute]
public static class NuGet.Versioning.VersionExtensions : object {
    [ExtensionAttribute]
public static T FindBestMatch(IEnumerable`1<T> items, VersionRange ideal, Func`2<T, NuGetVersion> selector);
    [ExtensionAttribute]
public static INuGetVersionable FindBestMatch(IEnumerable`1<INuGetVersionable> items, VersionRange ideal);
}
[NuGet.Versioning.NullableContextAttribute("1")]
[NuGet.Versioning.NullableAttribute("0")]
public class NuGet.Versioning.VersionFormatter : object {
    public static VersionFormatter Instance;
    private static VersionFormatter();
    [NuGet.Versioning.NullableContextAttribute("2")]
public sealed virtual string Format(string format, object arg, IFormatProvider formatProvider);
    [NuGet.Versioning.NullableContextAttribute("2")]
public sealed virtual object GetFormat(Type formatType);
    private static void Format(StringBuilder builder, char c, SemanticVersion version);
    private static void AppendFull(StringBuilder builder, SemanticVersion version);
    internal static void AppendNormalized(StringBuilder builder, SemanticVersion version);
    private static void AppendVersion(StringBuilder builder, SemanticVersion version);
}
[NuGet.Versioning.NullableContextAttribute("1")]
[NuGet.Versioning.NullableAttribute("0")]
public class NuGet.Versioning.VersionRange : VersionRangeBase {
    [NuGet.Versioning.NullableAttribute("2")]
private FloatRange _floatRange;
    [NuGet.Versioning.NullableAttribute("2")]
private string _originalString;
    public static VersionRange All;
    private static NuGetVersion V0;
    [ObsoleteAttribute("Consider not using this VersionRange. The lack of a proper normalized version means that it is not round trippable in an assets file.")]
public static VersionRange AllFloating;
    public static VersionRange AllStable;
    [ObsoleteAttribute("Consider not using this VersionRange. The lack of a proper normalized version means that it is not round trippable in an assets file.")]
public static VersionRange AllStableFloating;
    public static VersionRange None;
    [NuGet.Versioning1173.MemberNotNullWhenAttribute("True", "MinVersion")]
[NuGet.Versioning1173.MemberNotNullWhenAttribute("True", "Float")]
[NuGet.Versioning1173.MemberNotNullWhenAttribute("True", "_floatRange")]
public bool IsFloating { get; }
    [NuGet.Versioning.NullableAttribute("2")]
public NuGetVersion MinVersion { get; }
    [NuGet.Versioning.NullableAttribute("2")]
public NuGetVersion MaxVersion { get; }
    [NuGet.Versioning1173.MemberNotNullWhenAttribute("True", "MinVersion")]
public bool HasLowerBound { get; }
    [NuGet.Versioning1173.MemberNotNullWhenAttribute("True", "MinVersion")]
public bool IsMinInclusive { get; }
    [NuGet.Versioning1173.MemberNotNullWhenAttribute("True", "MaxVersion")]
public bool HasUpperBound { get; }
    [NuGet.Versioning1173.MemberNotNullWhenAttribute("True", "MaxVersion")]
public bool IsMaxInclusive { get; }
    [NuGet.Versioning1173.MemberNotNullWhenAttribute("True", "MinVersion")]
[NuGet.Versioning1173.MemberNotNullWhenAttribute("True", "MaxVersion")]
public bool HasLowerAndUpperBounds { get; }
    [NuGet.Versioning.NullableAttribute("2")]
public FloatRange Float { get; }
    [NuGet.Versioning.NullableAttribute("2")]
public string OriginalString { get; }
    public VersionRange(NuGetVersion minVersion);
    public VersionRange(NuGetVersion minVersion, FloatRange floatRange);
    public VersionRange(VersionRange range, FloatRange floatRange);
    [NuGet.Versioning.NullableContextAttribute("2")]
public VersionRange(NuGetVersion minVersion, bool includeMinVersion, NuGetVersion maxVersion, bool includeMaxVersion, FloatRange floatRange, string originalString);
    private static VersionRange();
    [NuGet.Versioning1173.MemberNotNullWhenAttribute("True", "MinVersion")]
[NuGet.Versioning1173.MemberNotNullWhenAttribute("True", "Float")]
[NuGet.Versioning1173.MemberNotNullWhenAttribute("True", "_floatRange")]
public bool get_IsFloating();
    [NuGet.Versioning.NullableContextAttribute("2")]
public NuGetVersion get_MinVersion();
    [NuGet.Versioning.NullableContextAttribute("2")]
public NuGetVersion get_MaxVersion();
    [NuGet.Versioning1173.MemberNotNullWhenAttribute("True", "MinVersion")]
public bool get_HasLowerBound();
    [NuGet.Versioning1173.MemberNotNullWhenAttribute("True", "MinVersion")]
public bool get_IsMinInclusive();
    [NuGet.Versioning1173.MemberNotNullWhenAttribute("True", "MaxVersion")]
public bool get_HasUpperBound();
    [NuGet.Versioning1173.MemberNotNullWhenAttribute("True", "MaxVersion")]
public bool get_IsMaxInclusive();
    [NuGet.Versioning1173.MemberNotNullWhenAttribute("True", "MinVersion")]
[NuGet.Versioning1173.MemberNotNullWhenAttribute("True", "MaxVersion")]
public bool get_HasLowerAndUpperBounds();
    [NuGet.Versioning.NullableContextAttribute("2")]
public FloatRange get_Float();
    [NuGet.Versioning.NullableContextAttribute("2")]
public string get_OriginalString();
    public virtual string ToString();
    public virtual string ToNormalizedString();
    public virtual string ToLegacyString();
    public virtual string ToLegacyShortString();
    [NuGet.Versioning.NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    [NuGet.Versioning.NullableContextAttribute("2")]
protected bool TryFormatter(string format, IFormatProvider formatProvider, String& formattedString);
    public string PrettyPrint();
    [NuGet.Versioning.NullableContextAttribute("2")]
public NuGetVersion FindBestMatch(IEnumerable`1<NuGetVersion> versions);
    public bool IsBetter(NuGetVersion current, NuGetVersion considering);
    public VersionRange ToNonSnapshotRange();
    private static NuGetVersion GetNonSnapshotVersion(NuGetVersion version);
    public virtual string ToShortString();
    [NuGet.Versioning.NullableContextAttribute("2")]
public bool Equals(VersionRange other);
    [NuGet.Versioning.NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static VersionRange Parse(string value);
    public static VersionRange Parse(string value, bool allowFloating);
    public static bool TryParse(string value, VersionRange& versionRange);
    public static bool TryParse(string value, bool allowFloating, VersionRange& versionRange);
    public static VersionRange Combine(IEnumerable`1<NuGetVersion> versions);
    public static VersionRange Combine(IEnumerable`1<NuGetVersion> versions, IVersionComparer comparer);
    public static VersionRange Combine(IEnumerable`1<VersionRange> ranges);
    public static VersionRange Combine(IEnumerable`1<VersionRange> ranges, IVersionComparer comparer);
    public static VersionRange CommonSubSet(IEnumerable`1<VersionRange> ranges);
    public static VersionRange CommonSubSet(IEnumerable`1<VersionRange> ranges, IVersionComparer comparer);
    private static bool HasValidRange(VersionRange range);
}
[NuGet.Versioning.NullableContextAttribute("2")]
[NuGet.Versioning.NullableAttribute("0")]
public abstract class NuGet.Versioning.VersionRangeBase : object {
    private bool _includeMinVersion;
    private bool _includeMaxVersion;
    private NuGetVersion _minVersion;
    private NuGetVersion _maxVersion;
    [NuGet.Versioning1173.MemberNotNullWhenAttribute("True", "MinVersion")]
public bool HasLowerBound { get; }
    [NuGet.Versioning1173.MemberNotNullWhenAttribute("True", "MaxVersion")]
public bool HasUpperBound { get; }
    [NuGet.Versioning1173.MemberNotNullWhenAttribute("True", "MinVersion")]
[NuGet.Versioning1173.MemberNotNullWhenAttribute("True", "MaxVersion")]
public bool HasLowerAndUpperBounds { get; }
    [NuGet.Versioning1173.MemberNotNullWhenAttribute("True", "MaxVersion")]
public bool IsMinInclusive { get; }
    [NuGet.Versioning1173.MemberNotNullWhenAttribute("True", "MaxVersion")]
public bool IsMaxInclusive { get; }
    public NuGetVersion MaxVersion { get; }
    public NuGetVersion MinVersion { get; }
    protected bool HasPrereleaseBounds { get; }
    public VersionRangeBase(NuGetVersion minVersion, bool includeMinVersion, NuGetVersion maxVersion, bool includeMaxVersion);
    [NuGet.Versioning1173.MemberNotNullWhenAttribute("True", "MinVersion")]
public bool get_HasLowerBound();
    [NuGet.Versioning1173.MemberNotNullWhenAttribute("True", "MaxVersion")]
public bool get_HasUpperBound();
    [NuGet.Versioning1173.MemberNotNullWhenAttribute("True", "MinVersion")]
[NuGet.Versioning1173.MemberNotNullWhenAttribute("True", "MaxVersion")]
public bool get_HasLowerAndUpperBounds();
    [NuGet.Versioning1173.MemberNotNullWhenAttribute("True", "MaxVersion")]
public bool get_IsMinInclusive();
    [NuGet.Versioning1173.MemberNotNullWhenAttribute("True", "MaxVersion")]
public bool get_IsMaxInclusive();
    public NuGetVersion get_MaxVersion();
    public NuGetVersion get_MinVersion();
    [NuGet.Versioning.NullableContextAttribute("1")]
public bool Satisfies(NuGetVersion version);
    [NuGet.Versioning.NullableContextAttribute("1")]
public bool Satisfies(NuGetVersion version, VersionComparison versionComparison);
    [NuGet.Versioning.NullableContextAttribute("1")]
public bool Satisfies(NuGetVersion version, IVersionComparer comparer);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(VersionRangeBase other);
    [NuGet.Versioning.NullableContextAttribute("1")]
public bool Equals(VersionRangeBase other, IVersionRangeComparer comparer);
    public bool Equals(VersionRangeBase other, VersionComparison versionComparison);
    [NuGet.Versioning.NullableContextAttribute("1")]
public bool Equals(VersionRangeBase other, IVersionComparer versionComparer);
    public bool IsSubSetOrEqualTo(VersionRangeBase possibleSuperSet);
    [NuGet.Versioning.NullableContextAttribute("1")]
public bool IsSubSetOrEqualTo(VersionRangeBase possibleSuperSet, IVersionComparer comparer);
    protected bool get_HasPrereleaseBounds();
    private static Nullable`1<bool> IsPrerelease(SemanticVersion version);
}
[NuGet.Versioning.NullableContextAttribute("1")]
[NuGet.Versioning.NullableAttribute("0")]
public class NuGet.Versioning.VersionRangeComparer : object {
    private IVersionComparer _versionComparer;
    [CompilerGeneratedAttribute]
private static IVersionRangeComparer <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private static IVersionRangeComparer <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private static IVersionRangeComparer <VersionRelease>k__BackingField;
    [CompilerGeneratedAttribute]
private static IVersionRangeComparer <VersionReleaseMetadata>k__BackingField;
    public static IVersionRangeComparer Default { get; }
    internal static IVersionRangeComparer Version { get; }
    public static IVersionRangeComparer VersionRelease { get; }
    internal static IVersionRangeComparer VersionReleaseMetadata { get; }
    public VersionRangeComparer(VersionComparison versionComparison);
    public VersionRangeComparer(IVersionComparer versionComparer);
    private static VersionRangeComparer();
    [CompilerGeneratedAttribute]
public static IVersionRangeComparer get_Default();
    [CompilerGeneratedAttribute]
internal static IVersionRangeComparer get_Version();
    [CompilerGeneratedAttribute]
public static IVersionRangeComparer get_VersionRelease();
    [CompilerGeneratedAttribute]
internal static IVersionRangeComparer get_VersionReleaseMetadata();
    public static IVersionRangeComparer Get(VersionComparison versionComparison);
    [NuGet.Versioning.NullableContextAttribute("2")]
public sealed virtual bool Equals(VersionRangeBase x, VersionRangeBase y);
    public sealed virtual int GetHashCode(VersionRangeBase obj);
}
[NuGet.Versioning.NullableContextAttribute("1")]
[NuGet.Versioning.NullableAttribute("0")]
public class NuGet.Versioning.VersionRangeFormatter : object {
    public static VersionRangeFormatter Instance;
    private static VersionRangeFormatter();
    [NuGet.Versioning.NullableContextAttribute("2")]
public sealed virtual string Format(string format, object arg, IFormatProvider formatProvider);
    [NuGet.Versioning.NullableContextAttribute("2")]
public sealed virtual object GetFormat(Type formatType);
    private static void Format(StringBuilder builder, char c, VersionRange range);
    private static void GetShortString(StringBuilder builder, VersionRange range);
    private static void GetNormalizedString(StringBuilder builder, VersionRange range);
    private static void GetToString(StringBuilder builder, VersionRange range);
    private static void GetLegacyShortString(StringBuilder builder, VersionRangeBase range);
    private static void GetLegacyString(StringBuilder builder, VersionRangeBase range);
    private static void PrettyPrint(StringBuilder builder, VersionRange range, bool useParentheses);
    private static void PrettyPrintBound(StringBuilder builder, NuGetVersion version, bool inclusive, string boundChar);
}
internal class System.Buffers.ArrayPool`1 : object {
    private static int MaxPooledArraySize;
    private NuGet.Packaging1156.SimplePool`1<T[]> _pool;
    public static ArrayPool`1<T> Shared;
    private static ArrayPool`1();
    public T[] Rent(int minimumLength);
    public void Return(T[] array);
}
[ExtensionAttribute]
internal static class System.Collections.Generic.DeconstructionExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static void Deconstruct(KeyValuePair`2<TKey, TValue> pair, TKey& key, TValue& value);
}
[ExtensionAttribute]
internal static class System.Collections.Generic.NuGet.Configuration1122.DeconstructionExtensions : object {
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static void Deconstruct(KeyValuePair`2<TKey, TValue> pair, TKey& key, TValue& value);
}
[ExtensionAttribute]
internal static class System.Collections.Generic.NuGet.Frameworks1139.DeconstructionExtensions : object {
    [NuGet.Frameworks.NullableContextAttribute("1")]
[ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static void Deconstruct(KeyValuePair`2<TKey, TValue> pair, TKey& key, TValue& value);
}
[ExtensionAttribute]
internal static class System.Collections.Generic.NuGet.Packaging1156.DeconstructionExtensions : object {
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static void Deconstruct(KeyValuePair`2<TKey, TValue> pair, TKey& key, TValue& value);
}
[ExtensionAttribute]
internal static class System.Collections.Generic.NuGet.Versioning1173.DeconstructionExtensions : object {
    [NuGet.Versioning.NullableContextAttribute("1")]
[ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static void Deconstruct(KeyValuePair`2<TKey, TValue> pair, TKey& key, TValue& value);
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Configuration1122.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Configuration1122.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Configuration1122.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Configuration1122.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public NuGet.Configuration1122.DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Configuration1122.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Configuration1122.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NuGet.Configuration1122.MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Configuration1122.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public NuGet.Configuration1122.MemberNotNullAttribute(string member);
    public NuGet.Configuration1122.MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Configuration1122.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public NuGet.Configuration1122.MemberNotNullWhenAttribute(bool returnValue, string member);
    public NuGet.Configuration1122.MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Configuration1122.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Configuration1122.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NuGet.Configuration1122.NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Configuration1122.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NuGet.Configuration1122.NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("32")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Configuration1122.SetsRequiredMembersAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Frameworks1139.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Frameworks1139.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Frameworks1139.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Frameworks1139.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public NuGet.Frameworks1139.DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Frameworks1139.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Frameworks1139.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NuGet.Frameworks1139.MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Frameworks1139.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public NuGet.Frameworks1139.MemberNotNullAttribute(string member);
    public NuGet.Frameworks1139.MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Frameworks1139.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public NuGet.Frameworks1139.MemberNotNullWhenAttribute(bool returnValue, string member);
    public NuGet.Frameworks1139.MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Frameworks1139.NotNullAttribute : Attribute {
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Frameworks1139.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NuGet.Frameworks1139.NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Frameworks1139.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NuGet.Frameworks1139.NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("32")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Frameworks1139.SetsRequiredMembersAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Packaging1156.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Packaging1156.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Packaging1156.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Packaging1156.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public NuGet.Packaging1156.DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Packaging1156.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Packaging1156.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NuGet.Packaging1156.MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Packaging1156.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public NuGet.Packaging1156.MemberNotNullAttribute(string member);
    public NuGet.Packaging1156.MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Packaging1156.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public NuGet.Packaging1156.MemberNotNullWhenAttribute(bool returnValue, string member);
    public NuGet.Packaging1156.MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Packaging1156.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Packaging1156.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NuGet.Packaging1156.NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Packaging1156.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NuGet.Packaging1156.NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("32")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Packaging1156.SetsRequiredMembersAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Versioning1173.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Versioning1173.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Versioning1173.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Versioning1173.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public NuGet.Versioning1173.DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Versioning1173.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Versioning1173.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NuGet.Versioning1173.MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NuGet.Versioning.NullableContextAttribute("1")]
[NuGet.Versioning.NullableAttribute("0")]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Versioning1173.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public NuGet.Versioning1173.MemberNotNullAttribute(string member);
    public NuGet.Versioning1173.MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NuGet.Versioning.NullableContextAttribute("1")]
[NuGet.Versioning.NullableAttribute("0")]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Versioning1173.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public NuGet.Versioning1173.MemberNotNullWhenAttribute(bool returnValue, string member);
    public NuGet.Versioning1173.MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Versioning1173.NotNullAttribute : Attribute {
}
[NuGet.Versioning.NullableContextAttribute("1")]
[NuGet.Versioning.NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Versioning1173.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NuGet.Versioning1173.NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Versioning1173.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NuGet.Versioning1173.NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("32")]
internal class System.Diagnostics.CodeAnalysis.NuGet.Versioning1173.SetsRequiredMembersAttribute : Attribute {
}
[AttributeUsageAttribute("32")]
internal class System.Diagnostics.CodeAnalysis.SetsRequiredMembersAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("32767")]
internal class System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FeatureName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    public static string RefStructs;
    public static string RequiredMembers;
    public string FeatureName { get; }
    public bool IsOptional { get; public set; }
    public CompilerFeatureRequiredAttribute(string featureName);
    [CompilerGeneratedAttribute]
public string get_FeatureName();
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsOptional(bool value);
}
[DebuggerNonUserCodeAttribute]
internal static class System.Runtime.CompilerServices.IsExternalInit : object {
}
[CompilerGeneratedAttribute]
[NuGet.Common.EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.NuGet.Common.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public NuGet.Common.RefSafetyRulesAttribute(int );
}
[CompilerGeneratedAttribute]
[NuGet.Configuration.EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NuGet.Configuration.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NuGet.Configuration.NullableAttribute(byte );
    public NuGet.Configuration.NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[NuGet.Configuration.EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NuGet.Configuration.NullableContextAttribute : Attribute {
    public byte Flag;
    public NuGet.Configuration.NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[NuGet.Configuration.EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.NuGet.Configuration.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public NuGet.Configuration.RefSafetyRulesAttribute(int );
}
[AttributeUsageAttribute("32767")]
internal class System.Runtime.CompilerServices.NuGet.Configuration1122.CompilerFeatureRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FeatureName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    public static string RefStructs;
    public static string RequiredMembers;
    public string FeatureName { get; }
    public bool IsOptional { get; public set; }
    public NuGet.Configuration1122.CompilerFeatureRequiredAttribute(string featureName);
    [CompilerGeneratedAttribute]
public string get_FeatureName();
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.NuGet.Configuration1122.IsExternalInit) set_IsOptional(bool value);
}
[DebuggerNonUserCodeAttribute]
internal static class System.Runtime.CompilerServices.NuGet.Configuration1122.IsExternalInit : object {
}
[AttributeUsageAttribute("396")]
[EditorBrowsableAttribute("1")]
internal class System.Runtime.CompilerServices.NuGet.Configuration1122.RequiredMemberAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[NuGet.Frameworks.EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NuGet.Frameworks.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NuGet.Frameworks.NullableAttribute(byte );
    public NuGet.Frameworks.NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[NuGet.Frameworks.EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NuGet.Frameworks.NullableContextAttribute : Attribute {
    public byte Flag;
    public NuGet.Frameworks.NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[NuGet.Frameworks.EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.NuGet.Frameworks.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public NuGet.Frameworks.RefSafetyRulesAttribute(int );
}
[NuGet.Frameworks.NullableContextAttribute("1")]
[NuGet.Frameworks.NullableAttribute("0")]
[AttributeUsageAttribute("32767")]
internal class System.Runtime.CompilerServices.NuGet.Frameworks1139.CompilerFeatureRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FeatureName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    public static string RefStructs;
    public static string RequiredMembers;
    public string FeatureName { get; }
    public bool IsOptional { get; public set; }
    public NuGet.Frameworks1139.CompilerFeatureRequiredAttribute(string featureName);
    [CompilerGeneratedAttribute]
public string get_FeatureName();
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.NuGet.Frameworks1139.IsExternalInit) set_IsOptional(bool value);
}
[DebuggerNonUserCodeAttribute]
internal static class System.Runtime.CompilerServices.NuGet.Frameworks1139.IsExternalInit : object {
}
[AttributeUsageAttribute("396")]
[EditorBrowsableAttribute("1")]
internal class System.Runtime.CompilerServices.NuGet.Frameworks1139.RequiredMemberAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[NuGet.Packaging.EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NuGet.Packaging.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NuGet.Packaging.NullableAttribute(byte );
    public NuGet.Packaging.NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[NuGet.Packaging.EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NuGet.Packaging.NullableContextAttribute : Attribute {
    public byte Flag;
    public NuGet.Packaging.NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[NuGet.Packaging.EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.NuGet.Packaging.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public NuGet.Packaging.RefSafetyRulesAttribute(int );
}
[AttributeUsageAttribute("32767")]
internal class System.Runtime.CompilerServices.NuGet.Packaging1156.CompilerFeatureRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FeatureName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    public static string RefStructs;
    public static string RequiredMembers;
    public string FeatureName { get; }
    public bool IsOptional { get; public set; }
    public NuGet.Packaging1156.CompilerFeatureRequiredAttribute(string featureName);
    [CompilerGeneratedAttribute]
public string get_FeatureName();
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.NuGet.Packaging1156.IsExternalInit) set_IsOptional(bool value);
}
[DebuggerNonUserCodeAttribute]
internal static class System.Runtime.CompilerServices.NuGet.Packaging1156.IsExternalInit : object {
}
[AttributeUsageAttribute("396")]
[EditorBrowsableAttribute("1")]
internal class System.Runtime.CompilerServices.NuGet.Packaging1156.RequiredMemberAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[NuGet.Versioning.EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NuGet.Versioning.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NuGet.Versioning.NullableAttribute(byte );
    public NuGet.Versioning.NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[NuGet.Versioning.EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NuGet.Versioning.NullableContextAttribute : Attribute {
    public byte Flag;
    public NuGet.Versioning.NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[NuGet.Versioning.EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.NuGet.Versioning.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public NuGet.Versioning.RefSafetyRulesAttribute(int );
}
[NuGet.Versioning.NullableContextAttribute("1")]
[NuGet.Versioning.NullableAttribute("0")]
[AttributeUsageAttribute("32767")]
internal class System.Runtime.CompilerServices.NuGet.Versioning1173.CompilerFeatureRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FeatureName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    public static string RefStructs;
    public static string RequiredMembers;
    public string FeatureName { get; }
    public bool IsOptional { get; public set; }
    public NuGet.Versioning1173.CompilerFeatureRequiredAttribute(string featureName);
    [CompilerGeneratedAttribute]
public string get_FeatureName();
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.NuGet.Versioning1173.IsExternalInit) set_IsOptional(bool value);
}
[DebuggerNonUserCodeAttribute]
internal static class System.Runtime.CompilerServices.NuGet.Versioning1173.IsExternalInit : object {
}
[AttributeUsageAttribute("396")]
[EditorBrowsableAttribute("1")]
internal class System.Runtime.CompilerServices.NuGet.Versioning1173.RequiredMemberAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[NuGet.Common.EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[NuGet.Common.EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[AttributeUsageAttribute("396")]
[EditorBrowsableAttribute("1")]
internal class System.Runtime.CompilerServices.RequiredMemberAttribute : Attribute {
}
[GeneratedCodeAttribute("Nerdbank.GitVersioning.Tasks", "3.2.31.56335")]
[ExcludeFromCodeCoverageAttribute]
internal static class ThisAssembly : object {
    internal static string AssemblyVersion;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyConfiguration;
    internal static string GitCommitId;
    internal static string PublicKey;
    internal static string PublicKeyToken;
    internal static bool IsPublicRelease;
    internal static bool IsPrerelease;
    internal static DateTime GitCommitDate;
    internal static string RootNamespace;
    private static ThisAssembly();
}
