[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.AcquireSingletonLock : Activity {
    private IServiceProvider services;
    [NullableAttribute("2")]
private ISingletonService singletonService;
    public AcquireSingletonLock(IServiceProvider services, ISingletonService singletonService);
    public virtual string ToString();
    protected virtual void Invoke(CancellationToken token);
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal abstract class Microsoft.VisualStudio.Setup.Activities.Activity : object {
    [CompilerGeneratedAttribute]
private Exception <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Log>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IServiceProvider <Services>k__BackingField;
    [CompilerGeneratedAttribute]
private IPackage <Package>k__BackingField;
    public Exception Error { get; internal set; }
    internal bool IsDisposed { get; private set; }
    protected internal ILogger Log { get; private set; }
    [NullableAttribute("1")]
protected internal IServiceProvider Services { get; private set; }
    public IPackage Package { get; internal set; }
    [NullableContextAttribute("1")]
protected Activity(IServiceProvider services);
    protected virtual override void Finalize();
    [CompilerGeneratedAttribute]
public sealed virtual Exception get_Error();
    [CompilerGeneratedAttribute]
internal void set_Error(Exception value);
    [CompilerGeneratedAttribute]
internal bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    [CompilerGeneratedAttribute]
protected internal ILogger get_Log();
    [CompilerGeneratedAttribute]
private void set_Log(ILogger value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected internal IServiceProvider get_Services();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void set_Services(IServiceProvider value);
    [CompilerGeneratedAttribute]
public virtual IPackage get_Package();
    [CompilerGeneratedAttribute]
internal virtual void set_Package(IPackage value);
    public sealed virtual void Dispose();
    public sealed virtual void Run(CancellationToken token);
    [NullableContextAttribute("1")]
private void LogActivityFaultException(ITelemetry telemetry, Exception ex);
    [NullableContextAttribute("1")]
public virtual string ToString();
    protected virtual void Dispose(bool disposing);
    protected abstract virtual void Invoke(CancellationToken token);
    private void Initialize();
    protected void AddSkippedPackageToInstance();
    [NullableContextAttribute("1")]
protected void SetRestartManagerRebootState(IRestartManager restartManager, RebootType rebootType);
    [NullableContextAttribute("1")]
protected void HandleRebootRequired(IRestartManager restartManager, bool isBeforeInstall, RebootType rebootType);
    [NullableContextAttribute("1")]
private bool ShouldOverride(IRestartManager restartManager, RebootType rebootType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.ActivityEventArgs : EventArgs {
    private bool cancel;
    [CompilerGeneratedAttribute]
private IActivity <Activity>k__BackingField;
    public IActivity Activity { get; }
    public bool Cancel { get; public set; }
    public ActivityEventArgs(IActivity activity);
    [CompilerGeneratedAttribute]
public IActivity get_Activity();
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.AddARPEntry : ARPEntryBase {
    private IDictionary`2<string, string> properties;
    [NullableAttribute("2")]
private string authoredIconPath;
    internal AddARPEntry(IServiceProvider services, Product product, IDictionary`2<string, string> properties);
    protected virtual void SynchronizedInvoke(CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.VisualStudio.Setup.Activities.ARPEntryBase : SynchronizedActivity {
    protected static string ARPKeyPath;
    [CompilerGeneratedAttribute]
private Product <Product>k__BackingField;
    protected Product Product { get; private set; }
    internal ARPEntryBase(IServiceProvider services, Product product);
    private static ARPEntryBase();
    [CompilerGeneratedAttribute]
protected Product get_Product();
    [CompilerGeneratedAttribute]
private void set_Product(Product value);
    protected string GetARPInstanceKey();
    protected void RemoveDuplicateRegKey();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.AsyncCoordinator : Coordinator {
    private ConcurrentBag`1<Exception> exceptions;
    private WaitHandle[] handles;
    private CancellationToken cancel;
    [CompilerGeneratedAttribute]
private int <Workers>k__BackingField;
    [NullableAttribute("2")]
internal AggregateException Exception { get; }
    internal int Workers { get; private set; }
    internal AsyncCoordinator(IServiceProvider services, int workers);
    [NullableContextAttribute("2")]
internal AggregateException get_Exception();
    [CompilerGeneratedAttribute]
internal int get_Workers();
    [CompilerGeneratedAttribute]
private void set_Workers(int value);
    public void Wait();
    internal void Wait(TimeSpan timeout);
    protected virtual void Invoke(CancellationToken token);
    private void InvokeAsync(object state);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.CacheCatalog : Activity {
    private string path;
    private IPackageIdentity product;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEnumerable`1<IPackageIdentity> packages;
    private ICacheManager cache;
    private IFileSystem fileSystem;
    public CacheCatalog(IServiceProvider services, string path, IPackageIdentity product, IEnumerable`1<IPackageIdentity> packages);
    public virtual string ToString();
    protected virtual void Invoke(CancellationToken token);
    private void StorePreviousCatalog(string cachePath, string cacheDirectory);
    private void SetProduct();
    private void CacheComponents(string cacheDirectory, string cachePath);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.CacheExtensions : Activity {
    private ISet`1<IPackage> plannedPackages;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEnumerable`1<Catalog> extensionManifests;
    private ICacheManager cacheManager;
    [NullableAttribute("2")]
private ILogger logger;
    public CacheExtensions(IServiceProvider services, ISet`1<IPackage> plannedPackages, IEnumerable`1<Catalog> extensionManifests);
    public virtual string ToString();
    protected virtual void Invoke(CancellationToken token);
    private bool CachePackages(Catalog manifest, IEnumerable`1<IPackage> packagesToCache);
    private void CacheManifest(bool cached, Catalog manifest);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.CachePackage : Activity {
    private ICacheManager cache;
    [NullableAttribute("2")]
private ISynchronizedActivity installOrDownload;
    [CompilerGeneratedAttribute]
private bool <Replace>k__BackingField;
    public bool Replace { get; public set; }
    public CachePackage(IServiceProvider services, IPackage package, ISynchronizedActivity installOrDownload);
    [CompilerGeneratedAttribute]
public bool get_Replace();
    [CompilerGeneratedAttribute]
public void set_Replace(bool value);
    public sealed virtual Crc32 ComputeHash(Crc32 crc);
    public virtual string ToString();
    protected virtual void Invoke(CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.CleanPackage : SynchronizedActivity {
    private ICacheManager manager;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`2<IPackageProgress, ProgressDataEventArgs> PackageProgressReceived;
    [CompilerGeneratedAttribute]
private string <Directory>k__BackingField;
    internal string Directory { get; }
    private IPackageIdentity Microsoft.VisualStudio.Setup.IPackageProgress.Package { get; }
    public long Weight { get; }
    public long Size { get; }
    public ProgressType Type { get; }
    internal CleanPackage(IServiceProvider services, IInstallablePackage package);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PackageProgressReceived(EventHandler`2<IPackageProgress, ProgressDataEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PackageProgressReceived(EventHandler`2<IPackageProgress, ProgressDataEventArgs> value);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
internal string get_Directory();
    private sealed virtual override IPackageIdentity Microsoft.VisualStudio.Setup.IPackageProgress.get_Package();
    public sealed virtual long get_Weight();
    public sealed virtual long get_Size();
    public sealed virtual ProgressType get_Type();
    protected virtual void SynchronizedInvoke(CancellationToken token);
    private void SendProgressEvent(double progress);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.CleanPreviousCatalog : Activity {
    private ICacheManager cache;
    private IFileSystem fileSystem;
    public CleanPreviousCatalog(IServiceProvider services);
    public virtual string ToString();
    protected virtual void Invoke(CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.CleanUpExtensionCache : Activity {
    private ICacheManager cacheManager;
    [NullableAttribute("2")]
private ILogger logger;
    [NullableAttribute("2")]
private ITelemetry telemetry;
    public CleanUpExtensionCache(IServiceProvider services);
    public virtual string ToString();
    protected virtual void Invoke(CancellationToken token);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <Invoke>b__5_0(Catalog x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.CleanUpInstanceProperties : Activity {
    public CleanUpInstanceProperties(IServiceProvider services);
    public virtual string ToString();
    protected virtual void Invoke(CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.CleanUpTemporaryCache : Activity {
    private ICacheManager cacher;
    private IFileSystem fileSystem;
    private IRestartManager restartManager;
    private bool isUninstall;
    public CleanUpTemporaryCache(IServiceProvider services, bool isUninstall);
    public virtual string ToString();
    protected virtual void Invoke(CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.Coordinator : object {
    private IServiceProvider services;
    private bool isDisposed;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<ActivityEventArgs> Error;
    [CompilerGeneratedAttribute]
private bool <IsCancelled>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <AggregateWaitTime>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IActivity> <AllActivities>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentQueue`1<IActivity> <Activities>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ILogger <Log>k__BackingField;
    internal bool IsCancelled { get; private set; }
    internal TimeSpan AggregateWaitTime { get; private set; }
    internal IList`1<IActivity> AllActivities { get; }
    protected ConcurrentQueue`1<IActivity> Activities { get; }
    [NullableAttribute("2")]
protected ILogger Log { get; private set; }
    public Coordinator(IServiceProvider services);
    [CompilerGeneratedAttribute]
public void add_Error(EventHandler`1<ActivityEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Error(EventHandler`1<ActivityEventArgs> value);
    [CompilerGeneratedAttribute]
internal bool get_IsCancelled();
    [CompilerGeneratedAttribute]
private void set_IsCancelled(bool value);
    [CompilerGeneratedAttribute]
internal TimeSpan get_AggregateWaitTime();
    [CompilerGeneratedAttribute]
private void set_AggregateWaitTime(TimeSpan value);
    [CompilerGeneratedAttribute]
internal IList`1<IActivity> get_AllActivities();
    [CompilerGeneratedAttribute]
protected ConcurrentQueue`1<IActivity> get_Activities();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected ILogger get_Log();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_Log(ILogger value);
    public void Queue(IActivity activity);
    public sealed virtual void Report(IActivityReporter reporter);
    public void Run(CancellationToken token);
    protected virtual void Invoke(CancellationToken token);
    protected void ThrowIfCancelled(CancellationToken token);
    protected virtual void OnError(ActivityEventArgs e);
    private void Initialize();
    private sealed virtual override IEnumerator`1<IActivity> System.Collections.Generic.IEnumerable<Microsoft.VisualStudio.Setup.Activities.IActivity>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.CopyFile : SynchronizedActivity {
    private IFileSystem fileSystem;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Destination>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DeleteSource>k__BackingField;
    public string Source { get; }
    public string Destination { get; }
    public bool DeleteSource { get; }
    public CopyFile(IServiceProvider services, string source, string destination, bool deleteSource);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public string get_Destination();
    [CompilerGeneratedAttribute]
public bool get_DeleteSource();
    public virtual string ToString();
    protected virtual void SynchronizedInvoke(CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.CreateDirectory : SynchronizedActivity {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Template>k__BackingField;
    public string Path { get; }
    [NullableAttribute("2")]
public string Template { get; }
    public CreateDirectory(IServiceProvider services, string path, string template);
    [CompilerGeneratedAttribute]
public string get_Path();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Template();
    public virtual string ToString();
    protected virtual void SynchronizedInvoke(CancellationToken token);
    [NullableContextAttribute("2")]
private string GetExistingTemplate();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.DeleteCache : DeleteDirectoryBase {
    public DeleteCache(IServiceProvider services, bool systemCache);
    public virtual string ToString();
}
internal abstract class Microsoft.VisualStudio.Setup.Activities.DeleteDirectoriesBase : SynchronizedActivity {
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Directories>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Recursive>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RebootOK>k__BackingField;
    public IEnumerable`1<string> Directories { get; protected set; }
    public bool Recursive { get; protected set; }
    public bool RebootOK { get; protected set; }
    public DeleteDirectoriesBase(IServiceProvider services);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Directories();
    [CompilerGeneratedAttribute]
protected void set_Directories(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_Recursive();
    [CompilerGeneratedAttribute]
protected void set_Recursive(bool value);
    [CompilerGeneratedAttribute]
public bool get_RebootOK();
    [CompilerGeneratedAttribute]
protected void set_RebootOK(bool value);
    public virtual string ToString();
    protected virtual void SynchronizedInvoke(CancellationToken token);
}
internal class Microsoft.VisualStudio.Setup.Activities.DeleteDirectory : DeleteDirectoryBase {
    internal DeleteDirectory(IServiceProvider services, string directory, bool recursive, bool rebootOK);
}
internal abstract class Microsoft.VisualStudio.Setup.Activities.DeleteDirectoryBase : SynchronizedActivity {
    [CompilerGeneratedAttribute]
private string <Directory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Recursive>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RebootOK>k__BackingField;
    public string Directory { get; protected set; }
    public bool Recursive { get; protected set; }
    public bool RebootOK { get; protected set; }
    public DeleteDirectoryBase(IServiceProvider services);
    [CompilerGeneratedAttribute]
public string get_Directory();
    [CompilerGeneratedAttribute]
protected void set_Directory(string value);
    [CompilerGeneratedAttribute]
public bool get_Recursive();
    [CompilerGeneratedAttribute]
protected void set_Recursive(bool value);
    [CompilerGeneratedAttribute]
public bool get_RebootOK();
    [CompilerGeneratedAttribute]
protected void set_RebootOK(bool value);
    public virtual string ToString();
    protected virtual void SynchronizedInvoke(CancellationToken token);
}
internal class Microsoft.VisualStudio.Setup.Activities.DeletedPackageResult : object {
    [CompilerGeneratedAttribute]
private IInstallablePackage <Package>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDeleted>k__BackingField;
    public IInstallablePackage Package { get; private set; }
    public bool IsDeleted { get; private set; }
    public DeletedPackageResult(IInstallablePackage package, bool isDeleted);
    [CompilerGeneratedAttribute]
public IInstallablePackage get_Package();
    [CompilerGeneratedAttribute]
private void set_Package(IInstallablePackage value);
    [CompilerGeneratedAttribute]
public bool get_IsDeleted();
    [CompilerGeneratedAttribute]
private void set_IsDeleted(bool value);
}
internal class Microsoft.VisualStudio.Setup.Activities.DeletePackageFromCacheActivity : Activity {
    private static int MaxRetries;
    private ICacheManager cacheManager;
    private IFileSystem fileSystem;
    private IInstallablePackage packageToDelete;
    [CompilerGeneratedAttribute]
private DeletedPackageResult <DeleteResult>k__BackingField;
    public DeletedPackageResult DeleteResult { get; private set; }
    public DeletePackageFromCacheActivity(IServiceProvider serviceOptions, ICacheManager cacheManager, IFileSystem fileSystem, IInstallablePackage packageToDelete);
    [CompilerGeneratedAttribute]
public DeletedPackageResult get_DeleteResult();
    [CompilerGeneratedAttribute]
private void set_DeleteResult(DeletedPackageResult value);
    protected virtual void Invoke(CancellationToken token);
}
internal class Microsoft.VisualStudio.Setup.Activities.DeletePackagesFromCacheActivity : Activity {
    private ICacheManager cacheManager;
    private IFileSystem fileSystem;
    private AsyncCoordinator asyncCoordinator;
    private IEnumerable`1<IInstallablePackage> packagesToDelete;
    private IList`1<DeletedPackageResult> deletedPackageResults;
    public DeletePackagesFromCacheActivity(IServiceProvider serviceOptions, ICacheManager cacheManager, IFileSystem fileSystem, AsyncCoordinator asyncCoordinator, IEnumerable`1<IInstallablePackage> packagesToDelete, IList`1<DeletedPackageResult> deletedPackageResults);
    protected virtual void Invoke(CancellationToken token);
}
internal class Microsoft.VisualStudio.Setup.Activities.DeleteSwidTag : SwidTagActivity {
    public DeleteSwidTag(IServiceProvider services, IInstance instance);
    public virtual string ToString();
    protected virtual void Invoke(CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.Download : SynchronizedActivity {
    [NullableAttribute("2")]
private ProgressUpdateCallback progress;
    [NullableAttribute("2")]
private IMessageBus messageBus;
    private IDownloadManager downloader;
    private IFileSystem fileSystem;
    [NullableAttribute("2")]
private IPackage package;
    private bool failed;
    private bool isNoSuitableEngineFound;
    private bool authenticationFailed;
    [NullableAttribute("2")]
private Exception lastException;
    internal static int MaximumRetries;
    [CompilerGeneratedAttribute]
private string <Destination>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <Uri>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IList`1<Uri> <OrderedFallBackUris>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private DownloadContext <CurrentDownloadContext>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IEngineContext <EngineContext>k__BackingField;
    internal string Destination { get; private set; }
    internal Uri Uri { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal IList`1<Uri> OrderedFallBackUris { get; private set; }
    [NullableAttribute("2")]
internal DownloadContext CurrentDownloadContext { get; private set; }
    [NullableAttribute("2")]
public IEngineContext EngineContext { get; public set; }
    public Download(IServiceProvider services, Uri uri, string destination, IMessageBus messageBus, DownloadContext downloadContext, ProgressUpdateCallback progress, IList`1<Uri> orderedFallBackUris);
    [CompilerGeneratedAttribute]
internal string get_Destination();
    [CompilerGeneratedAttribute]
private void set_Destination(string value);
    [CompilerGeneratedAttribute]
internal Uri get_Uri();
    [CompilerGeneratedAttribute]
private void set_Uri(Uri value);
    [CompilerGeneratedAttribute]
internal IList`1<Uri> get_OrderedFallBackUris();
    [CompilerGeneratedAttribute]
private void set_OrderedFallBackUris(IList`1<Uri> value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal DownloadContext get_CurrentDownloadContext();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_CurrentDownloadContext(DownloadContext value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IEngineContext get_EngineContext();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_EngineContext(IEngineContext value);
    public virtual string ToString();
    protected virtual void SynchronizedInvoke(CancellationToken token);
    private void DownloadAction(CancellationToken token);
    private bool DownloadWithRetry(Uri uri, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Activities.Download/<DownloadAndVerify>d__35")]
private Task DownloadAndVerify(Uri uri, CancellationToken token);
    [CompilerGeneratedAttribute]
private void <DownloadAndVerify>b__35_0(ProgressUpdateStatus status);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.DownloadPackage : SynchronizedActivity {
    private IMessageBus messageBus;
    private bool layout;
    private AsyncCoordinator activities;
    private ICacheManager manager;
    internal static int ConcurrentDownloads;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`2<IPackageProgress, ProgressDataEventArgs> PackageProgressReceived;
    [CompilerGeneratedAttribute]
private bool <DownloadInParallel>k__BackingField;
    [CompilerGeneratedAttribute]
private IEngineContext <EngineContext>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <FailedDownloadUri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Directory>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Size>k__BackingField;
    internal bool DownloadInParallel { get; internal set; }
    public IEngineContext EngineContext { get; public set; }
    public Uri FailedDownloadUri { get; private set; }
    public string Directory { get; private set; }
    public long Weight { get; }
    public long Size { get; }
    public ProgressType Type { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEnumerable`1<IActivity> Activities { get; }
    [NullableAttribute("1")]
private IPackageIdentity Microsoft.VisualStudio.Setup.IPackageProgress.Package { get; }
    [NullableContextAttribute("1")]
internal DownloadPackage(IServiceProvider services, IInstallablePackage package, IMessageBus messageBus, bool layout);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PackageProgressReceived(EventHandler`2<IPackageProgress, ProgressDataEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PackageProgressReceived(EventHandler`2<IPackageProgress, ProgressDataEventArgs> value);
    [CompilerGeneratedAttribute]
internal bool get_DownloadInParallel();
    [CompilerGeneratedAttribute]
internal void set_DownloadInParallel(bool value);
    [CompilerGeneratedAttribute]
public IEngineContext get_EngineContext();
    [CompilerGeneratedAttribute]
public void set_EngineContext(IEngineContext value);
    [CompilerGeneratedAttribute]
public Uri get_FailedDownloadUri();
    [CompilerGeneratedAttribute]
private void set_FailedDownloadUri(Uri value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Directory();
    [CompilerGeneratedAttribute]
private void set_Directory(string value);
    public sealed virtual long get_Weight();
    [CompilerGeneratedAttribute]
public sealed virtual long get_Size();
    public sealed virtual ProgressType get_Type();
    [NullableContextAttribute("1")]
public sealed virtual void Report(IActivityReporter reporter);
    [NullableContextAttribute("1")]
public virtual string ToString();
    protected virtual void SynchronizedInvoke(CancellationToken token);
    private IEnumerable`1<IActivity> get_Activities();
    private void SendProgressEvent(double progress, bool excludeFromSpeedCalculation);
    private void Initialize();
    [NullableContextAttribute("1")]
private void OnError(object sender, ActivityEventArgs e);
    private sealed virtual override IEnumerator`1<IActivity> System.Collections.Generic.IEnumerable<Microsoft.VisualStudio.Setup.Activities.IActivity>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [NullableContextAttribute("1")]
private sealed virtual override IPackageIdentity Microsoft.VisualStudio.Setup.IPackageProgress.get_Package();
    [NullableContextAttribute("1")]
private Download CreateDownloadActivity(Uri downloadUri, string destination, DownloadContext downloadContext, IList`1<Uri> orderedFallbackList);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.EditLayoutResponseFile : Activity {
    private IInstallationConfigurationService installationConfigurationService;
    private LayoutContext context;
    private IEnumerable`1<string> allLangsInProduct;
    private IEnumerable`1<string> allSelectablesInProduct;
    public EditLayoutResponseFile(IServiceProvider services, LayoutContext context, IEnumerable`1<string> allLangsInProduct, IEnumerable`1<string> allSelectablesInProduct);
    public virtual string ToString();
    protected virtual void Invoke(CancellationToken token);
    private void AddComponents(string sourceResponseFile, ResponseFile responseFile);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <.ctor>b__4_2(string x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.EnableVsixUpdateTasks : Activity {
    private static int ProcessTimeOutInMilliseconds;
    private IProcessService processService;
    private IFileSystem fileSystem;
    private string arguments;
    public EnableVsixUpdateTasks(IServiceProvider services);
    protected virtual void Invoke(CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.ExecuteQueuedNgen : Activity {
    private static bool DefaultFeature;
    private static Version SynchronousNgenStartingVersion;
    private INgenService ngenService;
    private IServiceProvider services;
    private IProcessService processService;
    public ExecuteQueuedNgen(IServiceProvider services);
    private static ExecuteQueuedNgen();
    public virtual string ToString();
    protected virtual void Invoke(CancellationToken token);
    private bool ShouldRunP1NgenSynchronously();
    private bool IsFeatureEnabled();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.ExtensibilityFinalize : RunProductCommand {
    private IEnumerable`1<Install> extensibilityInstalls;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyList`1<IPackageProgress> <PackagesToFinalize>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyList`1<IPackageProgress> PackagesToFinalize { get; private set; }
    public ExtensibilityFinalize(IServiceProvider services, string installDirectory, Product product, IEnumerable`1<Install> extensibilityInstalls, IEngineContext context, ExecuteAction bootstrapperAction);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<IPackageProgress> get_PackagesToFinalize();
    [CompilerGeneratedAttribute]
private void set_PackagesToFinalize(IReadOnlyList`1<IPackageProgress> value);
    protected virtual InstallResult RunCommand(ExeInstaller exeInstaller, Product product, string installDirectory, ExecuteAction bootstrapperAction, String& logFile);
    private string BuildOperationArgument(VsixPackage pkg, ExecuteAction requestedAction, string installDirectory);
    private string BuildExtensionDir(VsixPackage pkg, string installDirectory);
    protected virtual void OnFailure();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.Finalize : RunProductCommand {
    public Finalize(IServiceProvider services, string installDirectory, Product product, IEngineContext context, ExecuteAction bootstrapperAction);
    protected virtual InstallResult RunCommand(ExeInstaller exeInstaller, Product product, string installDirectory, ExecuteAction bootstrapperAction, String& logFile);
    protected virtual void OnFailure();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.GenerateErrorReport : Activity {
    private IEnumerable`1<IPackage> packages;
    [NullableAttribute("2")]
private ErrorReporter errorReporter;
    [NullableAttribute("2")]
private FileLogger errorFileLogger;
    public GenerateErrorReport(IServiceProvider services, IEnumerable`1<IPackage> packages, ErrorReporter errorReporter, FileLogger errorFileLogger);
    public virtual string ToString();
    protected virtual void Invoke(CancellationToken token);
}
[NullableContextAttribute("2")]
internal interface Microsoft.VisualStudio.Setup.Activities.IActivity {
    public Exception Error { get; }
    public IPackage Package { get; }
    public abstract virtual Exception get_Error();
    public abstract virtual IPackage get_Package();
    public abstract virtual void Run(CancellationToken token);
}
internal interface Microsoft.VisualStudio.Setup.Activities.IActivityContainer {
    [NullableContextAttribute("1")]
public abstract virtual void Report(IActivityReporter reporter);
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Setup.Activities.IActivityReporter {
    public abstract virtual IDisposable NewScope();
    public abstract virtual void WriteActivity(IActivity activity);
}
internal interface Microsoft.VisualStudio.Setup.Activities.IDownloadPackageActivity {
    [NullableAttribute("2")]
public string Directory { get; }
    [NullableContextAttribute("2")]
public abstract virtual string get_Directory();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.Initialize : RunProductCommand {
    public Initialize(IServiceProvider services, string installDirectory, Product product, IEngineContext context, ExecuteAction bootstrapperAction);
    protected virtual InstallResult RunCommand(ExeInstaller exeInstaller, Product product, string installDirectory, ExecuteAction bootstrapperAction, String& logFile);
    protected virtual void OnFailure();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.Install : SynchronizedActivity {
    private IDownloadPackageActivity download;
    [NullableAttribute("1")]
private IInstallerFactory factory;
    private Nullable`1<bool> softDetectionHint;
    private string localPath;
    internal static long AdditionalSizeBuffer;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`2<IPackageProgress, ProgressDataEventArgs> PackageProgressReceived;
    [CompilerGeneratedAttribute]
private IEngineContext <EngineContext>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InstallDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private ExecuteAction <RequestedAction>k__BackingField;
    [CompilerGeneratedAttribute]
private InstallResult <ReturnCode>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <RebootRequired>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <SkippedPackage>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <DownloadWaitTime>k__BackingField;
    internal IEngineContext EngineContext { get; internal set; }
    internal string InstallDirectory { get; private set; }
    internal ExecuteAction RequestedAction { get; private set; }
    internal InstallResult ReturnCode { get; private set; }
    internal Nullable`1<bool> RebootRequired { get; private set; }
    internal Nullable`1<bool> SkippedPackage { get; private set; }
    public TimeSpan DownloadWaitTime { get; internal set; }
    public long Weight { get; }
    public long Size { get; }
    public ProgressType Type { get; }
    [NullableAttribute("1")]
private IPackageIdentity Microsoft.VisualStudio.Setup.IPackageProgress.Package { get; }
    [NullableContextAttribute("1")]
internal Install(IServiceProvider services, IInstallerFactory installerFactory, IDownloadPackageActivity download, string installDirectory, InstallablePackage package, ExecuteAction requestedAction, Nullable`1<bool> softDetectionHint);
    [NullableContextAttribute("1")]
internal Install(IServiceProvider services, string installDirectory, InstallablePackage package, ExecuteAction requestedAction, string localPath, Nullable`1<bool> softDetectionHint);
    private static Install();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PackageProgressReceived(EventHandler`2<IPackageProgress, ProgressDataEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PackageProgressReceived(EventHandler`2<IPackageProgress, ProgressDataEventArgs> value);
    [CompilerGeneratedAttribute]
internal IEngineContext get_EngineContext();
    [CompilerGeneratedAttribute]
internal void set_EngineContext(IEngineContext value);
    [CompilerGeneratedAttribute]
internal string get_InstallDirectory();
    [CompilerGeneratedAttribute]
private void set_InstallDirectory(string value);
    [CompilerGeneratedAttribute]
internal ExecuteAction get_RequestedAction();
    [CompilerGeneratedAttribute]
private void set_RequestedAction(ExecuteAction value);
    [CompilerGeneratedAttribute]
internal InstallResult get_ReturnCode();
    [CompilerGeneratedAttribute]
private void set_ReturnCode(InstallResult value);
    [CompilerGeneratedAttribute]
internal Nullable`1<bool> get_RebootRequired();
    [CompilerGeneratedAttribute]
private void set_RebootRequired(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<bool> get_SkippedPackage();
    [CompilerGeneratedAttribute]
private void set_SkippedPackage(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public virtual TimeSpan get_DownloadWaitTime();
    [CompilerGeneratedAttribute]
internal virtual void set_DownloadWaitTime(TimeSpan value);
    public sealed virtual long get_Weight();
    public sealed virtual long get_Size();
    public sealed virtual ProgressType get_Type();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
private void EnsureSufficientDiskSpaceAvailable(InstallablePackage installable);
    protected virtual void SynchronizedInvoke(CancellationToken token);
    private void CachePackage();
    private void UncachePackage();
    [NullableContextAttribute("1")]
private void Installer_ProgressReceived(object sender, ProgressDataEventArgs e);
    [NullableContextAttribute("1")]
public sealed virtual Crc32 ComputeHash(Crc32 crc);
    [NullableContextAttribute("1")]
private sealed virtual override IPackageIdentity Microsoft.VisualStudio.Setup.IPackageProgress.get_Package();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.InstallExtension : Activity {
    private static int ProcessTimeOutPerExtensionInMinutes;
    private IProcessService processService;
    private IFileSystem fileSystem;
    private string arguments;
    private string instanceId;
    [CompilerGeneratedAttribute]
private string <Extension>k__BackingField;
    public string Extension { get; }
    public InstallExtension(IServiceProvider services, string instanceId, string extension);
    [CompilerGeneratedAttribute]
public string get_Extension();
    protected virtual void Invoke(CancellationToken token);
}
internal interface Microsoft.VisualStudio.Setup.Activities.ISynchronizedActivity {
    [NullableAttribute("1")]
public WaitHandle Handle { get; }
    [NullableContextAttribute("1")]
public abstract virtual WaitHandle get_Handle();
    public abstract virtual void Wait();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.NotifyResumable : Activity {
    public NotifyResumable(IServiceProvider services);
    public virtual string ToString();
    protected virtual void Invoke(CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.NotifySystemChange : Activity {
    public NotifySystemChange(IServiceProvider services);
    public virtual string ToString();
    protected virtual void Invoke(CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.PauseNgen : Activity {
    private INgenService ngenService;
    private bool pause;
    private string installDirectory;
    public PauseNgen(IServiceProvider services, string installDirectory, bool pause);
    public virtual string ToString();
    protected virtual void Invoke(CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.Precheck : Activity {
    private IEngineContext engineContext;
    private string destination;
    private RelatedProcesses relatedProcesses;
    public Precheck(IServiceProvider services, IEngineContext engineContext, string destination, RelatedProcesses relatedProcesses);
    public virtual string ToString();
    protected virtual void Invoke(CancellationToken token);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.ReleaseInstallerLocksEarly : Activity {
    private ISingletonService globalMutexSingletonService;
    private ISingletonService singletonLock;
    public ReleaseInstallerLocksEarly(IServiceProvider services, ISingletonService globalMutexSingletonService, ISingletonService singletonLock);
    protected virtual void Invoke(CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.RemoveARPEntry : ARPEntryBase {
    private string arpKeyName;
    internal RemoveARPEntry(IServiceProvider services, Product product);
    protected virtual void SynchronizedInvoke(CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.RetrieveVersion : Activity {
    private static string VersionFile;
    private string catalogPath;
    private string folder;
    public RetrieveVersion(IServiceProvider services, string catalogPath, string folder);
    private static RetrieveVersion();
    public virtual string ToString();
    protected virtual void Invoke(CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.RunOnce : Activity {
    private static string RunOnceKey;
    [NullableAttribute("2")]
private IRegistry registry;
    [NullableAttribute("2")]
private ILogger logger;
    private RunOnceInformation runOnceInformation;
    private bool writeKey;
    public RunOnce(IServiceProvider services, RunOnceInformation runOnceInformation, bool writeKey);
    private static RunOnce();
    public virtual string ToString();
    protected virtual void Invoke(CancellationToken token);
    private void WriteRunOnce(string name);
    private void RemoveRunOnce(string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.VisualStudio.Setup.Activities.RunProductCommand : Activity {
    private Product product;
    private string installDirectory;
    private ExecuteAction bootstrapperAction;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private InstallResult <ReturnCode>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <LogFile>k__BackingField;
    [CompilerGeneratedAttribute]
private IEngineContext <EngineContext>k__BackingField;
    [NullableAttribute("2")]
internal InstallResult ReturnCode { get; private set; }
    [NullableAttribute("2")]
internal string LogFile { get; private set; }
    private protected IEngineContext EngineContext { get; }
    public string WatsonAction { get; }
    public RunProductCommand(IServiceProvider services, string installDirectory, Product product, IEngineContext context, ExecuteAction bootstrapperAction);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal InstallResult get_ReturnCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_ReturnCode(InstallResult value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal string get_LogFile();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_LogFile(string value);
    [CompilerGeneratedAttribute]
private protected IEngineContext get_EngineContext();
    public virtual string get_WatsonAction();
    protected virtual void Invoke(CancellationToken token);
    protected abstract virtual InstallResult RunCommand(ExeInstaller exeInstaller, Product product, string installDirectory, ExecuteAction bootstrapperAction, String& logFile);
    protected abstract virtual void OnFailure();
    private Nullable`1<RebootType> GetSuccessRebootType(InstallResultType installResultType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.SaveInstance : SynchronizedActivity {
    private IInstanceRepository repository;
    public SaveInstance(IServiceProvider services, IInstanceRepository repository);
    public virtual string ToString();
    protected virtual void SynchronizedInvoke(CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.SavePlan : Activity {
    private static string PlanFileName;
    private string root;
    [NullableAttribute("2")]
private IEngineContext context;
    [CompilerGeneratedAttribute]
private Plan <Plan>k__BackingField;
    internal Plan Plan { get; }
    public SavePlan(IServiceProvider services, string root, Plan plan, IEngineContext context);
    private static SavePlan();
    public virtual string ToString();
    protected virtual void Invoke(CancellationToken token);
    [CompilerGeneratedAttribute]
internal Plan get_Plan();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.ScheduleTasks : Activity {
    private IServiceProvider services;
    [NullableAttribute("2")]
private Product product;
    private ExecuteAction bootstrapperAction;
    public ScheduleTasks(IServiceProvider services, Product product, ExecuteAction bootstrapperAction);
    public virtual string ToString();
    protected virtual void Invoke(CancellationToken token);
    private void ScheduleBackgroundDownloadTasks(CancellationToken token);
    private void CleanupTasks();
    private Task`1<bool> IsFeatureEnabledAsync(IRemoteSettingsService remoteSettings, CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.SendCompletionActivitiesProgress : Activity {
    private IServiceProvider services;
    private string package;
    private double progress;
    private ProgressType progressType;
    private ProgressInfo progressInfo;
    public SendCompletionActivitiesProgress(IServiceProvider services, string package, double progress, ProgressType progressType, ProgressInfo progressInfo);
    protected virtual void Invoke(CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.SetTemporaryInstanceProperties : Activity {
    private ICacheManager cache;
    [NullableAttribute("2")]
private string userRequestedAction;
    public SetTemporaryInstanceProperties(IServiceProvider services, IDictionary`2<string, string> engineProperties);
    public virtual string ToString();
    protected virtual void Invoke(CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.SetUrlAssociationDefaults : Activity {
    private IEnumerable`1<Install> installs;
    private IEngineContext context;
    public SetUrlAssociationDefaults(IServiceProvider services, IEnumerable`1<Install> installs, IEngineContext context);
    public virtual string ToString();
    protected virtual void Invoke(CancellationToken token);
    private string GetDefaultProgram(IEnumerable`1<VsixPackage> packages);
    private string GetDefaultProgram(VsixPackage package);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Setup.Activities.SetUrlAssociationDefaults/<GetUrlAssocations>d__7")]
private IEnumerable`1<string> GetUrlAssocations(IEnumerable`1<VsixPackage> packages);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal abstract class Microsoft.VisualStudio.Setup.Activities.SwidTagActivity : Activity {
    [NullableAttribute("1")]
protected static string RegisteredId;
    [CompilerGeneratedAttribute]
private IInstance <Instance>k__BackingField;
    internal IInstance Instance { get; }
    [NullableContextAttribute("1")]
protected SwidTagActivity(IServiceProvider services, IInstance instance);
    private static SwidTagActivity();
    [CompilerGeneratedAttribute]
internal IInstance get_Instance();
    protected string GetPath(IFileSystem fileSystem, String& directory);
}
internal abstract class Microsoft.VisualStudio.Setup.Activities.SynchronizedActivity : Activity {
    [NullableAttribute("1")]
private ManualResetEvent handle;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<EventArgs> Canceled;
    [NullableAttribute("1")]
public WaitHandle Handle { get; }
    [NullableContextAttribute("1")]
protected SynchronizedActivity(IServiceProvider services);
    protected virtual override void Finalize();
    [CompilerGeneratedAttribute]
public void add_Canceled(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Canceled(EventHandler`1<EventArgs> value);
    [NullableContextAttribute("1")]
public sealed virtual WaitHandle get_Handle();
    public sealed virtual void Wait();
    internal void Wait(TimeSpan timeout);
    protected virtual void Dispose(bool disposing);
    protected sealed virtual void Invoke(CancellationToken token);
    protected abstract virtual void SynchronizedInvoke(CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.UpdateDownloadedSizes : SynchronizedActivity {
    private IServiceProvider services;
    private ICacheManager cache;
    [NullableAttribute("2")]
private IInstanceRepository instanceRepo;
    [NullableAttribute("2")]
private Version updateVersion;
    private long totalDownloadSize;
    private bool complete;
    public UpdateDownloadedSizes(IServiceProvider services, Version updateVersion, long totalDownload, bool complete);
    protected virtual void SynchronizedInvoke(CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.UpdateInstanceOnCancel : Activity {
    private ExecuteAction action;
    public UpdateInstanceOnCancel(IServiceProvider services, ExecuteAction action);
    public virtual string ToString();
    protected virtual void Invoke(CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.UpdateLegacyDependency : Activity {
    private bool isAddOrRemove;
    private DependencyActionManager dependencyActionManager;
    [CompilerGeneratedAttribute]
private bool <IsAdd>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageState <DeepDetectionState>k__BackingField;
    internal bool IsAdd { get; private set; }
    private PackageState DeepDetectionState { get; public set; }
    public UpdateLegacyDependency(IInstallablePackage package, DependencyActionManager dependencyActionManager, bool isAddOrRemove, IServiceProvider services);
    [CompilerGeneratedAttribute]
internal bool get_IsAdd();
    [CompilerGeneratedAttribute]
private void set_IsAdd(bool value);
    [CompilerGeneratedAttribute]
private PackageState get_DeepDetectionState();
    [CompilerGeneratedAttribute]
public void set_DeepDetectionState(PackageState value);
    public virtual string ToString();
    protected virtual void Invoke(CancellationToken token);
    public sealed virtual Crc32 ComputeHash(Crc32 crc);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.UpdateProperties : Activity {
    private static string ProductRegistered;
    [NullableAttribute("2")]
private IEngineContext context;
    public UpdateProperties(IServiceProvider services, IEngineContext context);
    private static UpdateProperties();
    public virtual string ToString();
    protected virtual void Invoke(CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.UpdateQueueNgen : Activity {
    private INgenService ngenService;
    public UpdateQueueNgen(IServiceProvider services);
    protected virtual void Invoke(CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.Verify : SynchronizedActivity {
    internal static int MaximumRetries;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IList`1<Tuple`2<string, VerificationInformation>> failedVerificationInfo;
    [NullableAttribute("2")]
private VerificationContext verificationContext;
    private ISignatureVerifierManager verifier;
    private IFileSystem fileSystem;
    private bool enforceMicrosoftSignature;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <VerifyResult>k__BackingField;
    internal string Path { get; }
    public bool VerifyResult { get; private set; }
    public Verify(IServiceProvider services, string filePath, VerificationContext verificationContext);
    public Verify(IServiceProvider services, string filePath, IList`1<Tuple`2<string, VerificationInformation>> failedVerificationInfos);
    public Verify(IServiceProvider services, string filePath, bool enforceMicrosoftSignature, IList`1<Tuple`2<string, VerificationInformation>> failedVerificationInfos);
    private Verify(IServiceProvider services, string filePath, bool enforceMicrosoftSignature);
    [CompilerGeneratedAttribute]
internal string get_Path();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public bool get_VerifyResult();
    [CompilerGeneratedAttribute]
private void set_VerifyResult(bool value);
    protected virtual void SynchronizedInvoke(CancellationToken token);
    private VerificationInformation VerifyFile();
    private VerificationInformation VerifyMicrosoftSignature(VerificationInformation information);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.VerifyPackage : SynchronizedActivity {
    private bool checkCache;
    [NullableAttribute("2")]
private AsyncCoordinator activities;
    [NullableAttribute("2")]
private ICacheManager manager;
    [NullableAttribute("2")]
private IFileSystem fileSystem;
    internal static int ConcurrentVerifications;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`2<IPackageProgress, ProgressDataEventArgs> PackageProgressReceived;
    [CompilerGeneratedAttribute]
private int <TotalPayloads>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IList`1<string> <MissingPayloads>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ConcurrentBag`1<string> <InvalidPayloads>k__BackingField;
    public long Weight { get; }
    public long Size { get; }
    public ProgressType Type { get; }
    internal int TotalPayloads { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal IList`1<string> MissingPayloads { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal ConcurrentBag`1<string> InvalidPayloads { get; private set; }
    private IPackageIdentity Microsoft.VisualStudio.Setup.IPackageProgress.Package { get; }
    internal VerifyPackage(IServiceProvider services, IInstallablePackage package, bool checkCache);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PackageProgressReceived(EventHandler`2<IPackageProgress, ProgressDataEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PackageProgressReceived(EventHandler`2<IPackageProgress, ProgressDataEventArgs> value);
    public sealed virtual long get_Weight();
    public sealed virtual long get_Size();
    public sealed virtual ProgressType get_Type();
    [CompilerGeneratedAttribute]
internal int get_TotalPayloads();
    [CompilerGeneratedAttribute]
private void set_TotalPayloads(int value);
    [CompilerGeneratedAttribute]
internal IList`1<string> get_MissingPayloads();
    [CompilerGeneratedAttribute]
private void set_MissingPayloads(IList`1<string> value);
    [CompilerGeneratedAttribute]
internal ConcurrentBag`1<string> get_InvalidPayloads();
    [CompilerGeneratedAttribute]
private void set_InvalidPayloads(ConcurrentBag`1<string> value);
    private sealed virtual override IPackageIdentity Microsoft.VisualStudio.Setup.IPackageProgress.get_Package();
    public sealed virtual void Report(IActivityReporter reporter);
    public virtual string ToString();
    protected virtual void SynchronizedInvoke(CancellationToken token);
    private void SendProgressEvent(double progress);
    private void Initialize();
    private string GetPayloadPath(string directory, Payload payload, PackageType packageType);
    private sealed virtual override IEnumerator`1<IActivity> System.Collections.Generic.IEnumerable<Microsoft.VisualStudio.Setup.Activities.IActivity>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.VerifyPackageAndDeleteCorruptFiles : Activity {
    private ISignatureVerifierManager verifier;
    private ICacheManager manager;
    private IFileSystem fileSystem;
    private bool verifyLayout;
    internal VerifyPackageAndDeleteCorruptFiles(IServiceProvider services, IInstallablePackage package, bool layout);
    internal static bool IsFilePotentiallyCorrupt(IServiceProvider serviceProvider, string file, int headBuffer, int tailBuffer);
    protected virtual void Invoke(CancellationToken token);
    public virtual string ToString();
    internal static Byte[] GetBytes(IServiceProvider serviceProvider, string fileName, int bufferSize, bool readFromBeginning);
    private void VerifyAndDeleteCorruptFile(string path, VerificationContext verificationContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.VerifyPackagesActivity : Activity {
    private AsyncCoordinator verifyCoordinator;
    private IEnumerable`1<IInstallablePackage> packagesToVerify;
    private IList`1<IInstallablePackage> missingOrInvalidPackages;
    private bool checkCache;
    public VerifyPackagesActivity(IServiceProvider serviceOptions, AsyncCoordinator verifyCoordinator, IEnumerable`1<IInstallablePackage> packagesToVerify, IList`1<IInstallablePackage> missingOrInvalidPackages, bool checkCache);
    protected virtual void Invoke(CancellationToken token);
    private void LogMissingOrInvalidPayloads(IEnumerable`1<VerifyPackage> missingPayloadActivities, IEnumerable`1<VerifyPackage> invalidPayloadActivities);
    private void LogPayloads(IList`1<string> payloads);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.Wait : Activity {
    private AsyncCoordinator activitiesToWaitOn;
    public Wait(IServiceProvider services, AsyncCoordinator activitiesToWaitOn);
    public virtual string ToString();
    protected virtual void Invoke(CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Activities.WriteSwidTag : SwidTagActivity {
    private static string Namespace;
    public WriteSwidTag(IServiceProvider services, IInstance instance);
    private static WriteSwidTag();
    public virtual string ToString();
    protected virtual void Invoke(CancellationToken token);
    [CompilerGeneratedAttribute]
internal static void <Invoke>g__writeCreator|3_0(XmlWriter writer, string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.AdminUpdateConstants : object {
    public static string AllowMUUpdateServiceEnabledRegValue;
    public static string AdministratorUpdatesEnabledRegValue;
    public static string AdministratorUpdatesOptOutRegValue;
    public static ISet`1<string> EnterpriseDefaultRegKeyPaths;
    public static ISet`1<string> EnterpriseMUUpdateServiceDefaultRegKeyPaths;
    public static int VSInstallerRelatedProcessRunningExitCode;
    public static int VSPausedInstallExitCode;
    public static int VSIsRunningExitCode;
    public static int NoInternetExitCode;
    public static int AdministratorUpdatesEnabledRegValueZeroOrNotSetExitCode;
    public static int AdministratorUpdatesOptOutRegValueSetExitCode;
    public static int VSInstallerMissingExitCode;
    public static int BaselineStickinessRegValueMalformedExitCode;
    public static int LayoutMissingPackagesExitCode;
    public static int LayoutUnauthorizedAccessExitCode;
    public static int SystemRebootRequiredExitCode;
    private static AdminUpdateConstants();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.AsyncLazy`1 : object {
    private object syncObject;
    private Func`1<Task`1<T>> factory;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Task`1<T> valueTask;
    public AsyncLazy`1(Func`1<Task`1<T>> factory);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.AsyncLazy`1/<GetValueAsync>d__4")]
public Task`1<T> GetValueAsync();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.BackgroundDownloadScheduler : SchedulerBase {
    public static string BackgroundDownloadTaskPath;
    private static string DefinitionName;
    private string defaultExecutionTimeLimit;
    internal BackgroundDownloadScheduler(IServiceProvider services);
    private static BackgroundDownloadScheduler();
    internal void Schedule();
    internal void Remove();
    private IScheduledTaskDefinition GetTaskDefinition();
    private IScheduledTaskDefinition GetSimpleTaskDefinition();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Setup.BadChannelManifestException : InvalidOperationException {
    public BadChannelManifestException(string message);
    protected BadChannelManifestException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Setup.Bootstrapper.BootstrapperDownloader : object {
    private static int BootstrapperDownloaderParentDirectoryLength;
    private static double BootstrapperDownloadWeight;
    private static double InstallerDownloadWeight;
    public static string OfflineBootstrapperName;
    public static string OfflineInstallerName;
    private static string OfflineBootstrapperInformationName;
    private IServiceProvider services;
    private bool downloadOverMeteredConnections;
    [NullableAttribute("2")]
private Uri bootstrapperUri;
    private bool canThrowExceptions;
    [NullableAttribute("2")]
private Version clientVersion;
    [NullableAttribute("2")]
private string opcUrl;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) operationId;
    [NullableAttribute("2")]
private IDownloadManager downloadManager;
    [NullableAttribute("2")]
private IFileSystem fileSystem;
    [NullableAttribute("2")]
private IHashingService hashingService;
    [NullableAttribute("2")]
private ISignatureVerifierManager signatureManager;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<ProgressEventArgs> Progress;
    [CompilerGeneratedAttribute]
private string <SubRootDirectory>k__BackingField;
    internal string SubRootDirectory { get; private set; }
    private string RootDirectory { get; }
    private IHashingService HashingService { get; }
    private IFileSystem FileSystem { get; }
    private IDownloadManager DownloadManager { get; }
    private ISignatureVerifierManager SignatureManager { get; }
    private string ChannelBootstrapperPath { get; }
    private string BootstrapperPath { get; }
    private string InstallerPath { get; }
    private bool IsMeteredConnection { get; }
    [NullableContextAttribute("2")]
public BootstrapperDownloader(IServiceProvider services, Uri bootstrapperUri, Version clientVersion, bool useGlobalDirectory, string opcUrl);
    internal BootstrapperDownloader(IServiceProvider services, BootstrapperDownloaderSettings settings);
    private static BootstrapperDownloader();
    [CompilerGeneratedAttribute]
public sealed virtual void add_Progress(EventHandler`1<ProgressEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Progress(EventHandler`1<ProgressEventArgs> value);
    [NullableContextAttribute("2")]
public sealed virtual IBootstrapperInformation GetCached(Version minimumRequiredVersion);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Bootstrapper.BootstrapperDownloader/<DownloadAsync>d__23")]
public sealed virtual Task`1<IBootstrapperInformation> DownloadAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Bootstrapper.BootstrapperDownloader/<DownloadAsync>d__24")]
public sealed virtual Task`1<IBootstrapperInformation> DownloadAsync(IChannelManifest manifest, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Bootstrapper.BootstrapperDownloader/<DownloadCoreAsync>d__25")]
private Task`1<IBootstrapperInformation> DownloadCoreAsync(IChannelManifest manifest, bool skipLayoutCheck, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal string get_SubRootDirectory();
    [CompilerGeneratedAttribute]
private void set_SubRootDirectory(string value);
    internal IChannelManifest CreateChannelManifestFromBootstrapperUri(Uri bootstrapperUri, Version clientVersion);
    private string get_RootDirectory();
    private IHashingService get_HashingService();
    private IFileSystem get_FileSystem();
    private IDownloadManager get_DownloadManager();
    private ISignatureVerifierManager get_SignatureManager();
    private string get_ChannelBootstrapperPath();
    private string get_BootstrapperPath();
    private string get_InstallerPath();
    private bool get_IsMeteredConnection();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Bootstrapper.BootstrapperDownloader/<DownloadBootstrapperAsync>d__49")]
private Task`1<Uri> DownloadBootstrapperAsync(ILogger logger, Uri bootstrapperUri, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Bootstrapper.BootstrapperDownloader/<IsInstallerVersionExpectedAsync>d__50")]
private Task`1<bool> IsInstallerVersionExpectedAsync(string tempInstallerPath, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Bootstrapper.BootstrapperDownloader/<DownloadAsync>d__51")]
private Task`1<bool> DownloadAsync(ILogger logger, Uri uri, string path, int operationId, double weight, double offset, CancellationToken cancellationToken);
    private Uri GetInstallerUri(Uri bootstrapperUri, string tempBootstrapperPath);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Bootstrapper.BootstrapperDownloader/<GetPreviousBootstrapperVersionAsync>d__53")]
private Task`1<Version> GetPreviousBootstrapperVersionAsync(CancellationToken cancellationToken);
    private void OnProgress(int operationId, double progress);
    private bool MoveFiles(ILogger logger, string tempBootstrapperPath, string tempInstallerPath);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Bootstrapper.BootstrapperDownloader/<SaveChannelBootstrapperInfoAsync>d__56")]
private Task SaveChannelBootstrapperInfoAsync(IChannelManifest manifest, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Bootstrapper.BootstrapperDownloader/<ShouldDownloadBootstrapperAsync>d__57")]
private Task`1<bool> ShouldDownloadBootstrapperAsync(ILogger logger, IBootstrapperItem bootstrapperItem, CancellationToken cancellationToken);
    private bool IsMicrosoftSigned(string path);
    private bool IsMicrosoftSigned(Stream file, string path);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private Task`1<Version> <GetCached>b__22_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Setup.Bootstrapper.BootstrapperDownloaderFactory : object {
    public static IBootstrapperDownloaderFactory Default;
    private static BootstrapperDownloaderFactory();
    public sealed virtual IBootstrapperDownloader Create(IServiceProvider services, Uri bootstrapperUri, Version clientVersion);
    public sealed virtual IBootstrapperDownloader Create(IServiceProvider services, BootstrapperDownloaderSettings settings);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Setup.Bootstrapper.BootstrapperDownloaderSettings : object {
    [CompilerGeneratedAttribute]
private Uri <BootstrapperUri>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanThrowExceptions>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <ClientVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DownloadOverMeteredConnections>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseGlobalDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OpcUrl>k__BackingField;
    public Uri BootstrapperUri { get; public set; }
    public bool CanThrowExceptions { get; public set; }
    public Version ClientVersion { get; public set; }
    public bool DownloadOverMeteredConnections { get; public set; }
    public bool UseGlobalDirectory { get; public set; }
    public string OpcUrl { get; public set; }
    [CompilerGeneratedAttribute]
public Uri get_BootstrapperUri();
    [CompilerGeneratedAttribute]
public void set_BootstrapperUri(Uri value);
    [CompilerGeneratedAttribute]
public bool get_CanThrowExceptions();
    [CompilerGeneratedAttribute]
public void set_CanThrowExceptions(bool value);
    [CompilerGeneratedAttribute]
public Version get_ClientVersion();
    [CompilerGeneratedAttribute]
public void set_ClientVersion(Version value);
    [CompilerGeneratedAttribute]
public bool get_DownloadOverMeteredConnections();
    [CompilerGeneratedAttribute]
public void set_DownloadOverMeteredConnections(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseGlobalDirectory();
    [CompilerGeneratedAttribute]
public void set_UseGlobalDirectory(bool value);
    [CompilerGeneratedAttribute]
public string get_OpcUrl();
    [CompilerGeneratedAttribute]
public void set_OpcUrl(string value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Bootstrapper.BootstrapperInformation : object {
    private IServiceProvider services;
    [CompilerGeneratedAttribute]
private string <BootstrapperUri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InstallerUri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OfflineBootstrapperPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OfflineInstallerPath>k__BackingField;
    public string BootstrapperUri { get; internal set; }
    public string InstallerUri { get; internal set; }
    public string OfflineBootstrapperPath { get; internal set; }
    public string OfflineInstallerPath { get; internal set; }
    internal BootstrapperInformation(IServiceProvider services);
    [CompilerGeneratedAttribute]
public sealed virtual string get_BootstrapperUri();
    [CompilerGeneratedAttribute]
internal void set_BootstrapperUri(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_InstallerUri();
    [CompilerGeneratedAttribute]
internal void set_InstallerUri(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_OfflineBootstrapperPath();
    [CompilerGeneratedAttribute]
internal void set_OfflineBootstrapperPath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_OfflineInstallerPath();
    [CompilerGeneratedAttribute]
internal void set_OfflineInstallerPath(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Bootstrapper.ConfigurationExtractor : object {
    private static int TimeoutMilliseconds;
    private IServiceProvider services;
    [NullableAttribute("2")]
private IFileSystem fileSystem;
    [NullableAttribute("2")]
private string extractionPath;
    [CompilerGeneratedAttribute]
private string <BootstrapperPath>k__BackingField;
    public string BootstrapperPath { get; }
    private IFileSystem FileSystem { get; }
    public ConfigurationExtractor(IServiceProvider services, string bootstrapperPath);
    [CompilerGeneratedAttribute]
public sealed virtual string get_BootstrapperPath();
    public sealed virtual IConfiguration GetConfiguration();
    public sealed virtual void Remove();
    private IFileSystem get_FileSystem();
    [NullableContextAttribute("2")]
private bool TryGetConfigurationPath(IFileSystem fileSystem, string extractionPath, String& configurationPath);
}
internal class Microsoft.VisualStudio.Setup.Bootstrapper.ConfigurationExtractorFactory : object {
    [NullableContextAttribute("1")]
public sealed virtual IConfigurationExtractor Create(IServiceProvider services, string path);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Bootstrapper.ConfigurationFileReader : object {
    [NullableAttribute("1")]
private static string CommentPrefix;
    [NullableAttribute("1")]
private static string ValueSeparator;
    [NullableAttribute("1")]
private IFileSystem fileSystem;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private String[] lines;
    [CompilerGeneratedAttribute]
private static ConfigurationFileReader <Global>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public static ConfigurationFileReader Global { get; public set; }
    public string Path { get; }
    public ConfigurationFileReader(IServiceProvider services, string path);
    private static ConfigurationFileReader();
    [CompilerGeneratedAttribute]
public static ConfigurationFileReader get_Global();
    [CompilerGeneratedAttribute]
public static void set_Global(ConfigurationFileReader value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [NullableContextAttribute("1")]
public sealed virtual string GetValue(string key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.Setup.Bootstrapper.Extensions : object {
    [ExtensionAttribute]
public static IBootstrapperItem GetBootstrapper(IChannelManifest manifest);
    [ExtensionAttribute]
public static Uri GetBootstrapperUri(IBootstrapperItem bootstrapperItem);
}
[NullableContextAttribute("2")]
public interface Microsoft.VisualStudio.Setup.Bootstrapper.IBootstrapperDownloader {
    [CompilerGeneratedAttribute]
public abstract virtual void add_Progress(EventHandler`1<ProgressEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Progress(EventHandler`1<ProgressEventArgs> value);
    public abstract virtual IBootstrapperInformation GetCached(Version minimumRequiredVersion);
    public abstract virtual Task`1<IBootstrapperInformation> DownloadAsync(IChannelManifest manifest, CancellationToken cancellationToken);
    public abstract virtual Task`1<IBootstrapperInformation> DownloadAsync(CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.Setup.Bootstrapper.IBootstrapperDownloaderFactory {
    public abstract virtual IBootstrapperDownloader Create(IServiceProvider services, Uri bootstrapperUri, Version clientVersion);
    public abstract virtual IBootstrapperDownloader Create(IServiceProvider services, BootstrapperDownloaderSettings settings);
}
[NullableContextAttribute("2")]
public interface Microsoft.VisualStudio.Setup.Bootstrapper.IBootstrapperInformation {
    public string BootstrapperUri { get; }
    public string InstallerUri { get; }
    public string OfflineBootstrapperPath { get; }
    public string OfflineInstallerPath { get; }
    public abstract virtual string get_BootstrapperUri();
    public abstract virtual string get_InstallerUri();
    public abstract virtual string get_OfflineBootstrapperPath();
    public abstract virtual string get_OfflineInstallerPath();
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Setup.Bootstrapper.IConfiguration {
    public abstract virtual string GetValue(string key);
}
internal interface Microsoft.VisualStudio.Setup.Bootstrapper.IConfigurationExtractor {
    public string BootstrapperPath { get; }
    public abstract virtual string get_BootstrapperPath();
    public abstract virtual IConfiguration GetConfiguration();
    public abstract virtual void Remove();
}
internal interface Microsoft.VisualStudio.Setup.Bootstrapper.IConfigurationExtractorFactory {
    public abstract virtual IConfigurationExtractor Create(IServiceProvider services, string path);
}
public class Microsoft.VisualStudio.Setup.Bootstrapper.ProgressEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private int <OperationId>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Progress>k__BackingField;
    public int OperationId { get; }
    public double Progress { get; }
    public ProgressEventArgs(int operationId, double progress);
    [CompilerGeneratedAttribute]
public int get_OperationId();
    [CompilerGeneratedAttribute]
public double get_Progress();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.VisualStudio.Setup.BootstrapperConstants : object {
    public static string CliRelativePath;
    public static string SetupProcessName;
    public static string RootCertCreationFail;
    public static string AutoSelfUpdateMinVersion;
    public static string VsInstallerVersionFilename;
    public static string InstallerSubDirectory;
    public static string InstallerFileName;
    public static string LegacyInstallerFileName;
    public static string PromptWarnName;
    public static string UserSettingsSubDirectory;
    public static string UserSettingsFileName;
    public static string RelativeEnginePath;
    public static string LegacyInstallerAppUserModelId;
    private static BootstrapperConstants();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Setup.Cache.BackgroundDownloadStatus : ValueType {
    [CompilerGeneratedAttribute]
private long <AmountDownloaded>k__BackingField;
    [CompilerGeneratedAttribute]
private long <UpdateDownloadTotalSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsComplete>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <UpdateManifestVersion>k__BackingField;
    public long AmountDownloaded { get; public set; }
    public long UpdateDownloadTotalSize { get; public set; }
    public bool IsComplete { get; public set; }
    public Version UpdateManifestVersion { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_AmountDownloaded();
    [CompilerGeneratedAttribute]
public void set_AmountDownloaded(long value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_UpdateDownloadTotalSize();
    [CompilerGeneratedAttribute]
public void set_UpdateDownloadTotalSize(long value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsComplete();
    [CompilerGeneratedAttribute]
public void set_IsComplete(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Version get_UpdateManifestVersion();
    [CompilerGeneratedAttribute]
public void set_UpdateManifestVersion(Version value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Cache.CacheManager : object {
    private static int FileCopyRetryCount;
    private static object SyncRoot;
    private IServiceProvider services;
    private IFileSystem fileSystem;
    [NullableAttribute("2")]
private ILogger logger;
    [NullableAttribute("2")]
private ISignatureVerifierManager verifier;
    [NullableAttribute("2")]
private string instanceId;
    private IList`1<LayoutRepository> previousLayoutRepositories;
    [NullableAttribute("2")]
private CacheRepository _cache;
    [NullableAttribute("2")]
private DirectoryRepository _temp;
    [CompilerGeneratedAttribute]
private bool <CanCreateInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseComponentCache>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private DirectoryRepository <Layout>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private DirectoryRepository <ExtensionsRepository>k__BackingField;
    public bool IsReadOnly { get; }
    internal bool CanCreateInstance { get; private set; }
    internal bool UseComponentCache { get; private set; }
    private CacheRepository Cache { get; }
    [NullableAttribute("2")]
private DirectoryRepository Layout { get; private set; }
    [NullableAttribute("2")]
private DirectoryRepository ExtensionsRepository { get; private set; }
    private DirectoryRepository Temp { get; }
    internal CacheManager(IServiceProvider services, string instanceId, bool useComponentCache, bool canCreateInstance);
    private static CacheManager();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual CacheState GetCacheState(IPackageIdentity identity, bool layout);
    public sealed virtual IEnumerable`1<Payload> GetRequiredPayloads(IPackage package, bool layout);
    public sealed virtual IEnumerable`1<Payload> GetPayloads(IPackage package);
    public sealed virtual void CachePackage(IInstallablePackage package, bool layout);
    public sealed virtual void PrunePackageCache(IEnumerable`1<IPackage> packages);
    public sealed virtual void AddPackage(IPackage package);
    public sealed virtual IEnumerable`1<IPackage> GetPackages(bool allPackages);
    public sealed virtual IEnumerable`1<IPackage> GetAllCachedPackages();
    public sealed virtual IPackage GetPackage(IPackageIdentity identity);
    public sealed virtual void RemovePackage(IPackage package);
    public sealed virtual bool SetLayoutDirectory(string path, bool override, bool create);
    public sealed virtual void AddPreviousLayoutPath(string path);
    public sealed virtual bool SetExtensionsDirectory(string path, bool override);
    public sealed virtual string GetPackageCacheDirectory(IPackageIdentity identity, bool layout);
    public sealed virtual string GetPackageTemporaryDirectory(IPackageIdentity identity);
    public sealed virtual void SetTemporaryCacheDirectory(string temporaryCacheDirectory);
    public sealed virtual string GetTemporaryCacheDirectory();
    [NullableContextAttribute("2")]
public sealed virtual Instance GetInstance();
    public sealed virtual IEnumerable`1<Instance> GetInstances(bool all);
    [NullableContextAttribute("2")]
public sealed virtual string GetInstanceDirectory();
    [NullableContextAttribute("2")]
public sealed virtual string GetPreviousCatalogPath();
    public sealed virtual void ResetPreviousCatalogInfo();
    [NullableContextAttribute("2")]
public sealed virtual string GetInstanceUserDirectory();
    public sealed virtual void AddExtensionCatalog(Catalog catalog);
    public sealed virtual IEnumerable`1<Catalog> GetExtensionCatalogs();
    public sealed virtual void RemoveExtensionCatalog(string id);
    private bool VerifyPayload(string path, VerificationContext verificationContext, bool throwOnVerificationFailure, bool deleteFileOnVerificationFailure);
    [CompilerGeneratedAttribute]
internal bool get_CanCreateInstance();
    [CompilerGeneratedAttribute]
private void set_CanCreateInstance(bool value);
    [CompilerGeneratedAttribute]
internal bool get_UseComponentCache();
    [CompilerGeneratedAttribute]
private void set_UseComponentCache(bool value);
    private sealed virtual override void Microsoft.VisualStudio.Setup.Cache.IInstanceRepository.Flush(bool initial);
    private sealed virtual override void Microsoft.VisualStudio.Setup.Cache.IInstanceRepository.VerifyInstanceNotModified();
    private sealed virtual override void Microsoft.VisualStudio.Setup.Cache.IInstanceRepository.UpdateChannelInfo(ChannelInfo channelInfo);
    private sealed virtual override void Microsoft.VisualStudio.Setup.Cache.IInstanceRepository.UpdateLayoutPath(string layoutPath);
    private sealed virtual override void Microsoft.VisualStudio.Setup.Cache.IInstanceRepository.UpdateProperties(Dictionary`2<string, string> settings);
    private CacheRepository get_Cache();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private DirectoryRepository get_Layout();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_Layout(DirectoryRepository value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private DirectoryRepository get_ExtensionsRepository();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_ExtensionsRepository(DirectoryRepository value);
    private DirectoryRepository get_Temp();
    private void DeleteCorruptedPayloads(IEnumerable`1<PayloadState> payloads);
    private void InitPreviousLayoutRepositories();
    private void AddPreviousLayout(string previousLayoutPath);
    private string GetPackageLayoutDirectory(IPackageIdentity identity);
    private bool HasNonCorruptPayload(DirectoryRepository layout, string layoutPath, IInstallablePackage package);
    private CacheState GetLayoutCacheState(IPackageIdentity identity, CacheState result);
    private void ValidateLayoutArg(bool layout);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Setup.Cache.CacheManager/<GetLayoutRepositories>d__72")]
private IEnumerable`1<IPackageRepository> GetLayoutRepositories();
    [CompilerGeneratedAttribute]
internal static bool <GetRequiredPayloads>g__cacheCondition|14_0(PayloadState state);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Cache.CacheManagerFactory : object {
    private IServiceContainer services;
    public CacheManagerFactory(IServiceProvider services);
    public sealed virtual ICacheManager Create(string instanceId);
    [CompilerGeneratedAttribute]
private IPolicyService <.ctor>b__1_2();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Cache.CacheRepository : DirectoryRepository {
    internal static string DefaultSubdirectory;
    private static object SyncRoot;
    private static ISet`1<string> IgnoreDirectories;
    private IServiceProvider services;
    private IFileSystem fileSystem;
    private string instanceId;
    private string root;
    private bool keepPayloads;
    private IInstanceReferenceManager referenceManager;
    private ILogger log;
    private IStateManager stateManager;
    [NullableAttribute("2")]
private InstanceRepository _instance;
    [CompilerGeneratedAttribute]
private bool <CanCreateInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseComponentCache>k__BackingField;
    public bool IsReadOnly { get; }
    internal bool CanCreateInstance { get; internal set; }
    internal string Root { get; }
    internal bool UseComponentCache { get; internal set; }
    private bool IsInstanceScoped { get; }
    [NullableAttribute("2")]
private InstanceRepository Instance { get; }
    public CacheRepository(IServiceProvider services, string instanceId);
    private static CacheRepository();
    public virtual bool get_IsReadOnly();
    public virtual void AddPackage(IPackage package);
    public virtual IPackage GetPackage(IPackageIdentity identity);
    public virtual IEnumerable`1<IPackageIdentity> GetPackages();
    public virtual void RemovePackage(IPackage package);
    public sealed virtual void AddManifest(Catalog manifest);
    public sealed virtual IEnumerable`1<Catalog> GetManifests();
    public sealed virtual void RemoveManifest(string id);
    [NullableContextAttribute("2")]
internal Instance GetInstance();
    [NullableContextAttribute("2")]
internal string GetInstanceDirectory();
    [NullableContextAttribute("2")]
public sealed virtual string GetPreviousCatalogPath();
    public sealed virtual void ResetPreviousCatalogInfo();
    [NullableContextAttribute("2")]
internal string GetInstanceUserDirectory();
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Setup.Cache.CacheRepository/<GetInstances>d__27")]
internal IEnumerable`1<Instance> GetInstances(bool all);
    private bool IsResumingRollback();
    internal IEnumerable`1<IPackage> GetAvailablePackages(bool allPackages);
    internal IEnumerable`1<IPackage> GetAllCachedPackages();
    [CompilerGeneratedAttribute]
internal bool get_CanCreateInstance();
    [CompilerGeneratedAttribute]
internal void set_CanCreateInstance(bool value);
    internal virtual string get_Root();
    [CompilerGeneratedAttribute]
internal bool get_UseComponentCache();
    [CompilerGeneratedAttribute]
internal void set_UseComponentCache(bool value);
    private sealed virtual override void Microsoft.VisualStudio.Setup.Cache.IInstanceRepository.Flush(bool initial);
    private sealed virtual override void Microsoft.VisualStudio.Setup.Cache.IInstanceRepository.VerifyInstanceNotModified();
    private sealed virtual override void Microsoft.VisualStudio.Setup.Cache.IInstanceRepository.UpdateChannelInfo(ChannelInfo channelInfo);
    private sealed virtual override void Microsoft.VisualStudio.Setup.Cache.IInstanceRepository.UpdateLayoutPath(string layoutPath);
    private sealed virtual override void Microsoft.VisualStudio.Setup.Cache.IInstanceRepository.UpdateProperties(Dictionary`2<string, string> settings);
    private bool get_IsInstanceScoped();
    [NullableContextAttribute("2")]
private InstanceRepository get_Instance();
    private ICollection`1<IPackage> GetAvailablePackages(IEqualityComparer`1<IPackageIdentity> comparer, bool isResumingRollback);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private IPackage <GetAllCachedPackages>b__30_1(IPackageIdentity x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Cache.CatalogProvider : object {
    private IChannelManager channelManager;
    private IFileSystem fileSystem;
    private IServiceProvider serviceProvider;
    public CatalogProvider(IChannelManager channelManager, IFileSystem fileSystem, IServiceProvider serviceProvider);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Cache.CatalogProvider/<GetChannelCatalogAsync>d__4")]
public sealed virtual Task`1<Catalog> GetChannelCatalogAsync(ChannelManifestPair instanceChannelManifestPair, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Cache.ChannelFeedRepository : object {
    private static string ChannelFeedFileName;
    private static string ChannelFeedUriFileName;
    private static string SubdirectoryName;
    private IServiceProvider services;
    private IFileSystem fileSystem;
    private IHashingService hashService;
    [NullableAttribute("2")]
private ILogger logger;
    private string root;
    private int channelFeedParentDirectoryLength;
    private bool isDisposed;
    internal ChannelFeedRepository(IServiceProvider services, string root);
    private static ChannelFeedRepository();
    internal static IChannelFeedRepository Create(IServiceProvider services);
    public sealed virtual IEnumerable`1<ChannelFeed> GetChannelFeeds();
    public sealed virtual bool AddChannelFeed(Uri feedUri, string feedFilePath);
    public sealed virtual void RemoveChannelFeed(Uri feedUri);
    public sealed virtual void Dispose();
    private void Dispose(bool isDisposing);
    private void AddChannelFeed(string channelRoot, Uri feedUri, string feedFilePath);
    private string GetHashValue(Uri uri);
    private string GetChannelFeedRoot(Uri uri);
    private ChannelFeed GetExistingChannelFeed(string channelRoot);
    private ChannelFeed ReadChannelFeed(string path);
    private bool TryReadChannelFeed(string path, ChannelFeed& feed);
    private IEnumerable`1<string> GetFeedDirectories();
    private bool ChannelHashIsValid(ChannelFeed feed, string feedDirectory);
    private bool TryRemoveChannelFeed(string directory);
    private void CleanupInvalidFeeds();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Cache.ChannelManifestRepository : object {
    internal static int ChannelManifestParentDirectoryLength;
    internal static string ChannelManifestFileName;
    internal static string InstallChannelManifestFileName;
    internal static string InstallProductManifestFileName;
    internal static string SubdirectoryName;
    private static object SyncRoot;
    private static string UpdateFileName;
    private IServiceProvider services;
    private IFileSystem fileSystem;
    private IHashingService hashService;
    private ILogger logger;
    private string root;
    private string readonlyRoot;
    public RepositoryCapabilities Capabilities { get; }
    internal ChannelManifestRepository(IServiceProvider services, string root, string readonlyRoot, string customSubDirectoryName);
    private static ChannelManifestRepository();
    internal static IChannelRepository Create(IServiceProvider services, string customSubDirectoryName);
    public sealed virtual RepositoryCapabilities get_Capabilities();
    public sealed virtual void AddCatalogForChannel(ChannelManifestPair channelManifestPair, string channelProductManifest, string installChannelProductManifest);
    public sealed virtual void GetCatalogPathsForChannel(ChannelManifestPair channelManifestPair, String& channelCatalogFileName, String& installChannelCatalogFileName);
    public sealed virtual void SynchronizeReadOnlyChannel(Uri channelUri);
    public sealed virtual bool AddChannel(ChannelManifestPair channelManifestPair, bool removeExistingCatalog, Nullable`1<DateTimeOffset> lastUpdateDate);
    private bool AddChannel(ChannelManifestPair channelManifestPair, string targetRoot, bool removeExistingCatalog, Nullable`1<DateTimeOffset> lastUpdateDate);
    public sealed virtual IEnumerable`1<ChannelManifestPair> GetChannels(bool localChannelOnly);
    public sealed virtual void RemoveChannel(ChannelManifestPair channelManifestPair);
    public sealed virtual void RemoveReadOnlyChannel(ChannelManifestPair channelManifestPair);
    public sealed virtual void RemoveInstallChannel(ChannelManifestPair channelManifestPair);
    public sealed virtual IEnumerable`1<IChannelManifest> GetInstallChannels();
    public sealed virtual Nullable`1<DateTimeOffset> GetLastUpdateDate(ChannelManifestPair channelManifestPair);
    public sealed virtual void SetLastUpdateDate(ChannelManifestPair channelManifestPair, DateTimeOffset lastUpdateDate);
    private void ComputeCatalogPathsForChannel(string channelRootToUse, ChannelManifestPair channelManifestPair, String& channelCatalogFileName, String& installChannelCatalogFileName);
    private IEnumerable`1<ChannelManifestPair> GetChannels(string searchRoot);
    private bool TryParseChannelManifest(string destination, IChannelManifest& channelManifest);
    private void WriteChannelManifest(IChannelManifest channelManifest, string channelManifestRoot, string channelManifestFileName);
    private void ValidateChannelUris(IChannelManifest channelManifest, IChannelManifest installChannelManifest);
    private void ValidateChannelUri(Uri channelUri);
    private IChannelManifest GetExistingChannelManifest(string channelManifestFileName);
    [NullableContextAttribute("2")]
private string GetChannelManifestRoot(IChannelManifest channelManifest, IChannelManifest installChannelManifest, bool createRoot);
    [NullableContextAttribute("2")]
private string GetReadOnlyChannelManifestRoot(IChannelManifest channelManifest, IChannelManifest installChannelManifest, bool createRoot);
    private string GetChannelManifestRoot(IChannelManifest channelManifest, IChannelManifest installChannelManifest, string targetRoot, bool createRoot);
    [NullableContextAttribute("2")]
private bool SynchronizeReadOnlyChannel(IChannelManifest channelManifest);
    [NullableContextAttribute("2")]
private void WriteLastUpdateDate(string channelRoot, Nullable`1<DateTimeOffset> lastUpdateDate);
    [NullableContextAttribute("2")]
private Nullable`1<DateTimeOffset> ReadLastUpdateDate(string channelRoot);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Cache.CurrentProcessInstanceProvider : object {
    private IQuery query;
    public CurrentProcessInstanceProvider(IQuery query);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Cache.CurrentProcessInstanceProvider/<GetInstanceAsync>d__2")]
public sealed virtual Task`1<IInstance> GetInstanceAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private IInstance <GetInstanceAsync>b__2_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Cache.CustomChannelInfo : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<SupportedProductInfo> <SupportedProducts>k__BackingField;
    [CompilerGeneratedAttribute]
private IChannel <Channel>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public IEnumerable`1<SupportedProductInfo> SupportedProducts { get; public set; }
    public IChannel Channel { get; public set; }
    public CustomChannelInfo(IEnumerable`1<SupportedProductInfo> SupportedProducts, IChannel Channel);
    [CompilerGeneratedAttribute]
protected CustomChannelInfo(CustomChannelInfo original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public IEnumerable`1<SupportedProductInfo> get_SupportedProducts();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SupportedProducts(IEnumerable`1<SupportedProductInfo> value);
    [CompilerGeneratedAttribute]
public IChannel get_Channel();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Channel(IChannel value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(CustomChannelInfo left, CustomChannelInfo right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(CustomChannelInfo left, CustomChannelInfo right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(CustomChannelInfo other);
    [CompilerGeneratedAttribute]
public virtual CustomChannelInfo <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(IEnumerable`1& SupportedProducts, IChannel& Channel);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Cache.CustomChannelRepository : object {
    private static string ChannelsBaseKey;
    private static string DisabledChannelsBaseKey;
    private static string ChannelUriKeyValue;
    private static string ChannelDescriptionKeyValue;
    private IRegistry registry;
    private ILayoutChannelReader layoutChannelReader;
    [NullableAttribute("2")]
private ILogger logger;
    [NullableAttribute("2")]
private ITelemetry telemetry;
    public CustomChannelRepository(IServiceProvider services);
    private static CustomChannelRepository();
    public sealed virtual IEnumerable`1<ChannelSummary> GetChannels();
    public sealed virtual IEnumerable`1<ChannelSummary> GetDisabledChannels();
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Setup.Cache.CustomChannelRepository/<ReadChannelSummaries>d__11")]
private IEnumerable`1<ChannelSummary> ReadChannelSummaries();
    private IEnumerable`1<ChannelSummary> ReadDisabledChannelSummaries();
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Setup.Cache.CustomChannelRepository/<ReadBaseChannelSummaryFromRegistry>d__13")]
private IEnumerable`1<ChannelSummary> ReadBaseChannelSummaryFromRegistry(string channelsSubkey, ChannelSummaryType defaultType);
    private ChannelSummary ReadBaseInformationFromRegistry(IRegistryKey channelsKey, string channelKeyName, ChannelSummaryType defaultType);
    public sealed virtual IEnumerable`1<ChannelNode`1<IProductSummaryItem>> GetCustomChannelProducts(ChannelSummary channelSummary);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.VisualStudio.Setup.Cache.DirectoryRepository : object {
    internal static string ManifestFileName;
    internal static string VsixPayloadName;
    private IServiceProvider services;
    [NullableAttribute("2")]
private ILogger logger;
    [NullableAttribute("2")]
private ISignatureVerifierManager verifier;
    [CompilerGeneratedAttribute]
private IFileSystem <FileSystem>k__BackingField;
    public RepositoryCapabilities Capabilities { get; }
    public bool IsReadOnly { get; }
    internal string Root { get; }
    protected IFileSystem FileSystem { get; private set; }
    protected DirectoryRepository(IServiceProvider services);
    private static DirectoryRepository();
    public virtual RepositoryCapabilities get_Capabilities();
    public virtual bool get_IsReadOnly();
    public virtual void AddPackage(IPackage package);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Setup.Cache.DirectoryRepository/<GetPackages>d__11")]
public virtual IEnumerable`1<IPackageIdentity> GetPackages();
    public virtual IPackage GetPackage(IPackageIdentity identity);
    public virtual string GetPackageDirectory(IPackageIdentity identity);
    public virtual IEnumerable`1<PayloadState> GetPayloads(IInstallablePackage package);
    public IEnumerable`1<PayloadState> GetPayloads(IInstallablePackage package, bool verifySignature);
    public IEnumerable`1<PayloadState> GetPayloads(IInstallablePackage package, bool verifySignature, bool deleteCorrupt);
    public virtual void RemovePackage(IPackage package);
    internal abstract virtual string get_Root();
    [CompilerGeneratedAttribute]
protected IFileSystem get_FileSystem();
    [CompilerGeneratedAttribute]
private void set_FileSystem(IFileSystem value);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Setup.Cache.DirectoryRepository/<YieldPayloads>d__24")]
private IEnumerable`1<PayloadState> YieldPayloads(IInstallablePackage package, bool verifySignature, bool deleteCorrupt);
    private bool MergeAndValidateShortcutLocalPath(IInstallablePackage source, IInstallablePackage target);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <MergeAndValidateShortcutLocalPath>b__25_1(string x);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.VisualStudio.Setup.Cache.ExtensionManifestRepository : ManifestRepository`3<Catalog, ManifestIdentityComparer, CatalogSerializer> {
    private string root;
    [NullableAttribute("2")]
private CatalogSerializer serializer;
    protected string Root { get; }
    internal ExtensionManifestRepository(IServiceProvider services, string root);
    public IPackage GetPackage(IPackageIdentity identity);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Setup.Cache.ExtensionManifestRepository/<GetPackages>d__4")]
public IEnumerable`1<IPackage> GetPackages();
    protected virtual string get_Root();
    protected virtual CatalogSerializer CreateSerializer();
    protected virtual Catalog Find(string id);
    protected virtual void OnCache(Catalog manifest);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.Setup.Cache.Extensions : object {
    [ExtensionAttribute]
internal static void AddPackageExtensions(IInstance instance, IPackage package, IEnumerable`1& extensions, IServiceProvider services, DependencyCollection deprecatedPackages);
    [ExtensionAttribute]
internal static ISet`1<IPackageIdentity> GetDeprecatedPackages(IInstance instance, DependencyCollection deprecatedPackages, IServiceProvider services, IEqualityComparer`1<IPackageIdentity> comparer);
    [ExtensionAttribute]
internal static ISet`1<PackageReference> GetRollbackExemptExtensionPackages(IInstance instance, bool isResumingRollback);
    [ExtensionAttribute]
internal static void StoreRollbackExemptExtensionPackages(IInstance instance, IEnumerable`1<IPackage> packages, bool isResumingRollback);
    [ExtensionAttribute]
internal static CatalogInfo GetPreviousCatalogInfo(IInstance instance, IServiceProvider services);
    [ExtensionAttribute]
internal static string GetCatalogPath(ICacheManager manager);
    [ExtensionAttribute]
internal static int GetExtensionCatalogsCount(ICacheManager manager, IEnumerable`1<string> add, IEnumerable`1<string> remove);
    [ExtensionAttribute]
internal static bool Supports(IPackageRepository repository, RepositoryCapabilities capability, bool throw);
    [ExtensionAttribute]
internal static void ValidateCanWrite(IReadOnlyRepository repository);
    [ExtensionAttribute]
internal static long GetTempCacheSize(ICacheManager manager, IServiceProvider services);
    [ExtensionAttribute]
internal static Uri GetLayoutUri(Payload payload, IPackage package, Uri layoutUri);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Cache.ExtensionsRepository : DirectoryRepository {
    [CompilerGeneratedAttribute]
private string <Root>k__BackingField;
    internal string Root { get; }
    public ExtensionsRepository(IServiceProvider services, string root);
    [CompilerGeneratedAttribute]
internal virtual string get_Root();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Cache.FileStateManager : object {
    internal static string StateFileName;
    private static string StatePackagesFileName;
    private static string StateErrorsFileName;
    private static Version RequiredEngineVersion;
    private IServiceProvider services;
    private string root;
    [NullableAttribute("2")]
private string userRoot;
    [NullableAttribute("2")]
private IFileSystem fileSystem;
    [NullableAttribute("2")]
private IAccountProfileService accountProfileService;
    [NullableAttribute("2")]
private ILogger logger;
    public FileStateManager(IServiceProvider services, string root, string userRoot);
    private static FileStateManager();
    public sealed virtual IEnumerable`1<string> GetInstanceIds();
    public sealed virtual bool TryGetInstanceLastWriteTime(string instanceId, DateTimeOffset& lastWriteTime);
    public sealed virtual bool TryReadInstance(string instanceId, Instance& instance);
    public sealed virtual void WriteInstance(Instance instance);
    private void ComputeInstanceDirectoryAndStateFilePath(string instanceId, String& directory, String& stateFilePath, String& userDirectory, String& userFilePath);
    private void Initialize();
    private void WriteInstance(Instance instance, string directory, string fileName);
    private void WriteInstance(Instance instance, string directory, string fileName, SerializationContext context, Func`1<bool> condition);
    private void WriteInstance(Instance instance, string directory, string fileName, Func`1<bool> condition, Func`1<InstanceSerializer> serializerFactory);
    [CompilerGeneratedAttribute]
private InstanceSerializer <WriteInstance>b__17_0();
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Setup.Cache.ICacheManagerFactory {
    public abstract virtual ICacheManager Create(string instanceId);
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Setup.Cache.ICatalogProvider {
    public abstract virtual Task`1<Catalog> GetChannelCatalogAsync(ChannelManifestPair instanceChannelManifestPair, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Setup.Cache.IChannelFeedRepository {
    public abstract virtual IEnumerable`1<ChannelFeed> GetChannelFeeds();
    public abstract virtual bool AddChannelFeed(Uri feedUri, string feedFilePath);
    public abstract virtual void RemoveChannelFeed(Uri feedUri);
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Setup.Cache.IChannelRepository {
    public RepositoryCapabilities Capabilities { get; }
    public abstract virtual RepositoryCapabilities get_Capabilities();
    public abstract virtual void AddCatalogForChannel(ChannelManifestPair channelManifestPair, string channelProductManifest, string installChannelProductManifest);
    public abstract virtual void GetCatalogPathsForChannel(ChannelManifestPair channelManifestPair, String& channelCatalogFileName, String& installChannelCatalogFileName);
    public abstract virtual void SynchronizeReadOnlyChannel(Uri channelUri);
    public abstract virtual bool AddChannel(ChannelManifestPair channelManifestPair, bool removeExistingCatalog, Nullable`1<DateTimeOffset> lastUpdateDate);
    public abstract virtual void RemoveChannel(ChannelManifestPair channelManifestPair);
    public abstract virtual void RemoveReadOnlyChannel(ChannelManifestPair channelManifestPair);
    public abstract virtual void RemoveInstallChannel(ChannelManifestPair channelManifestPair);
    public abstract virtual IEnumerable`1<ChannelManifestPair> GetChannels(bool localChannelOnly);
    public abstract virtual IEnumerable`1<IChannelManifest> GetInstallChannels();
    public abstract virtual Nullable`1<DateTimeOffset> GetLastUpdateDate(ChannelManifestPair channelManifestPair);
    public abstract virtual void SetLastUpdateDate(ChannelManifestPair channelManifestPair, DateTimeOffset lastUpdateDate);
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Setup.Cache.ICustomChannelRepository {
    public abstract virtual IEnumerable`1<ChannelSummary> GetChannels();
    public abstract virtual IEnumerable`1<ChannelSummary> GetDisabledChannels();
    public abstract virtual IEnumerable`1<ChannelNode`1<IProductSummaryItem>> GetCustomChannelProducts(ChannelSummary channelSummary);
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Setup.Cache.IInstanceProvider {
    public abstract virtual Task`1<IInstance> GetInstanceAsync(CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Setup.Cache.IInstanceRepository {
    public abstract virtual void Flush(bool initial);
    public abstract virtual void VerifyInstanceNotModified();
    public abstract virtual void UpdateChannelInfo(ChannelInfo channelInfo);
    public abstract virtual void UpdateLayoutPath(string layoutPath);
    public abstract virtual void UpdateProperties(Dictionary`2<string, string> properties);
    [NullableContextAttribute("2")]
public abstract virtual string GetPreviousCatalogPath();
    public abstract virtual void ResetPreviousCatalogInfo();
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Setup.Cache.IInstanceRepositoryFactory {
    public abstract virtual IInstanceRepository Create(string instanceId);
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Setup.Cache.ILayoutChannelReader {
    public abstract virtual ChannelSummary ReadFromSummary(ChannelSummary summmary);
    public abstract virtual ChannelSummary ReadFromChannel(Uri channelUri);
    public abstract virtual IEnumerable`1<ChannelNode`1<IProductSummaryItem>> GetFilteredProductSummaries(ChannelSummary channelSummary);
    public abstract virtual CustomChannelInfo GetCustomChannelInfo(ChannelSummary channelSummary);
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Setup.Cache.IManifestRepository`1 {
    public abstract virtual void AddManifest(TManifest manifest);
    public abstract virtual IEnumerable`1<TManifest> GetManifests();
    public abstract virtual void RemoveManifest(string id);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Cache.InstanceRepository : object {
    internal static int InstanceGenerationAttempts;
    internal static int InstanceLength;
    internal static string CatalogFileName;
    internal static string PreviousCatalogFileName;
    internal static string ComponentCacheFileName;
    internal static string StateFileName;
    internal static string SubdirectoryName;
    private static object SyncRoot;
    private static string ExtensionsDirectoryName;
    private IServiceProvider services;
    private IFileSystem fileSystem;
    private ILogger logger;
    private IStateManager stateManager;
    private IAccountProfileService accountProfileService;
    private string root;
    [NullableAttribute("2")]
private string userRoot;
    [NullableAttribute("2")]
private string instanceId;
    [NullableAttribute("2")]
private string instanceDirectory;
    [NullableAttribute("2")]
private string instanceUserDirectory;
    [NullableAttribute("2")]
private string extensionsDirectory;
    [NullableAttribute("2")]
private Instance instance;
    [NullableAttribute("2")]
private InstanceMonitor monitor;
    [NullableAttribute("2")]
private ExtensionManifestRepository extensions;
    private Nullable`1<DateTimeOffset> lastWriteTime;
    [CompilerGeneratedAttribute]
private bool <UseComponentCache>k__BackingField;
    public RepositoryCapabilities Capabilities { get; }
    public bool IsReadOnly { get; }
    internal bool UseComponentCache { get; internal set; }
    internal InstanceRepository(IServiceProvider services, string root, string instanceId);
    private static InstanceRepository();
    public sealed virtual RepositoryCapabilities get_Capabilities();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void AddPackage(IPackage package);
    public sealed virtual IPackage GetPackage(IPackageIdentity identity);
    public sealed virtual string GetPackageDirectory(IPackageIdentity identity);
    public sealed virtual IEnumerable`1<IPackageIdentity> GetPackages();
    public sealed virtual IEnumerable`1<PayloadState> GetPayloads(IInstallablePackage package);
    public sealed virtual void RemovePackage(IPackage package);
    public sealed virtual void Flush(bool initial);
    public sealed virtual void VerifyInstanceNotModified();
    public sealed virtual void UpdateChannelInfo(ChannelInfo channelInfo);
    public sealed virtual void UpdateLayoutPath(string layoutPath);
    public sealed virtual void UpdateProperties(Dictionary`2<string, string> properties);
    public sealed virtual void AddManifest(Catalog manifest);
    public sealed virtual IEnumerable`1<Catalog> GetManifests();
    public sealed virtual void RemoveManifest(string id);
    internal static IStateManager CreateDefaultStateManager(IServiceProvider services, string root, string userRoot);
    internal static bool TryGet(IServiceProvider services, string root, string instanceId, InstanceRepository& repository);
    internal IEnumerable`1<IPackage> GetAvailablePackages(DependencyCollection& deprecated);
    internal Instance GetInstance();
    [NullableContextAttribute("2")]
internal string GetInstanceDirectory();
    [NullableContextAttribute("2")]
public sealed virtual string GetPreviousCatalogPath();
    [NullableContextAttribute("2")]
internal string GetInstanceUserDirectory();
    [CompilerGeneratedAttribute]
internal bool get_UseComponentCache();
    [CompilerGeneratedAttribute]
internal void set_UseComponentCache(bool value);
    [NullableContextAttribute("2")]
private Catalog GetCatalog();
    public sealed virtual void ResetPreviousCatalogInfo();
    private void SetIfCorrupt(Instance instance);
    private void EncodeInstanceIconIntoBase64(Instance instance);
    private string GetInstanceId();
    [NullableContextAttribute("2")]
private void InitializeDirectories(string instanceId);
    private void WriteIconFile(Icon icon, bool alwaysWrite);
    private bool TryGetIconFileNameForMimeType(string mimeType, String& fileName);
    private bool TryGetFileExtensionForMimeType(string mimeType, String& extension);
    private bool TryGetUniqueDirectory(Random random, String& name);
    private void UpdateLastWriteTime(string instanceId);
}
internal class Microsoft.VisualStudio.Setup.Cache.InstanceRepositoryFactory : object {
    private IServiceProvider services;
    public InstanceRepositoryFactory(IServiceProvider services);
    public sealed virtual IInstanceRepository Create(string instanceId);
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Setup.Cache.IPackageRepository {
    public RepositoryCapabilities Capabilities { get; }
    public abstract virtual RepositoryCapabilities get_Capabilities();
    public abstract virtual void AddPackage(IPackage package);
    public abstract virtual IEnumerable`1<IPackageIdentity> GetPackages();
    public abstract virtual IPackage GetPackage(IPackageIdentity identity);
    public abstract virtual string GetPackageDirectory(IPackageIdentity identity);
    public abstract virtual IEnumerable`1<PayloadState> GetPayloads(IInstallablePackage package);
    public abstract virtual void RemovePackage(IPackage package);
}
public interface Microsoft.VisualStudio.Setup.Cache.IQuery {
    public abstract virtual IEnumerable`1<IInstance> GetInstances();
    public abstract virtual IEnumerable`1<IInstance> GetAllInstances();
    public abstract virtual IInstance GetInstanceForCurrentProcess();
    public abstract virtual IInstance GetInstanceForPath(string path);
    public abstract virtual IInstance GetInstanceForId(string instanceId);
    public abstract virtual IInstance GetInstanceForPath(string path, bool includeIncomplete);
    public abstract virtual IEnumerable`1<IPackage> GetPackages(string instanceId);
    public abstract virtual IEnumerable`1<IPackage> GetPackages(string instanceId, bool all);
    public abstract virtual IEnumerable`1<IPackage> GetUpdatedPackages(string instanceId, DependencyComparisonSeed seed);
    public abstract virtual IUpdateInformation GetUpdateInformation(string instanceId, DependencyComparisonSeed seed);
    public abstract virtual bool IsUpdateAvailable(IInstance instance, DependencyComparisonSeed seed, bool forceUpdate);
    public abstract virtual bool IsPreviousAvailable(IInstance instance);
    public abstract virtual BackgroundDownloadStatus GetBackgroundDownloadStatus(IInstance instance);
}
internal interface Microsoft.VisualStudio.Setup.Cache.IReadOnlyRepository {
    public bool IsReadOnly { get; }
    public abstract virtual bool get_IsReadOnly();
}
internal interface Microsoft.VisualStudio.Setup.Cache.IStateManager {
    public abstract virtual IEnumerable`1<string> GetInstanceIds();
    public abstract virtual bool TryGetInstanceLastWriteTime(string instanceId, DateTimeOffset& lastWriteTime);
    public abstract virtual bool TryReadInstance(string instanceId, Instance& instance);
    public abstract virtual void WriteInstance(Instance instance);
}
public interface Microsoft.VisualStudio.Setup.Cache.IUpdateInformation {
    public string InstanceId { get; }
    public bool IsUpdateAvailable { get; }
    public long DownloadSize { get; }
    public IEnumerable`1<IPackage> UpdatedPackages { get; }
    public IEnumerable`1<IPackage> AdvertisedPackages { get; }
    public BackgroundDownloadStatus BackgroundDownloadStatus { get; }
    public abstract virtual string get_InstanceId();
    public abstract virtual bool get_IsUpdateAvailable();
    public abstract virtual long get_DownloadSize();
    public abstract virtual IEnumerable`1<IPackage> get_UpdatedPackages();
    public abstract virtual IEnumerable`1<IPackage> get_AdvertisedPackages();
    public abstract virtual BackgroundDownloadStatus get_BackgroundDownloadStatus();
}
internal interface Microsoft.VisualStudio.Setup.Cache.IUpdateQueryInternal {
    public abstract virtual bool IsUpdateAvailableForAnyInstalledPackage(IInstance instance, Catalog catalog, bool forceUpdate);
    public abstract virtual bool HasUpdateManifest(IInstance instance, ChannelManifestPair targetChannel);
    public abstract virtual IEnumerable`1<IPackage> GetRequiredUpdatePackages(string instanceId, Catalog catalog);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Cache.LayoutChannelReader : object {
    private IServiceProvider services;
    private IFileSystem fileSystem;
    private ILogger logger;
    private ResponseFileSerializer responseFileSerializer;
    public LayoutChannelReader(IServiceProvider services);
    public sealed virtual CustomChannelInfo GetCustomChannelInfo(ChannelSummary channelSummary);
    public sealed virtual ChannelSummary ReadFromSummary(ChannelSummary summary);
    public sealed virtual IEnumerable`1<ChannelNode`1<IProductSummaryItem>> GetFilteredProductSummaries(ChannelSummary channelSummary);
    public sealed virtual ChannelSummary ReadFromChannel(Uri channelUri);
    [NullableContextAttribute("2")]
private IEnumerable`1<string> ReadSupportedProducts(ResponseFile responseFile);
    private ResponseFile ReadResponseFile(string channelUriString);
}
internal class Microsoft.VisualStudio.Setup.Cache.LayoutRepository : DirectoryRepository {
    private string root;
    private bool create;
    public RepositoryCapabilities Capabilities { get; }
    internal string Root { get; }
    public LayoutRepository(IServiceProvider services, string root, bool create);
    public virtual RepositoryCapabilities get_Capabilities();
    public virtual void AddPackage(IPackage package);
    public virtual string GetPackageDirectory(IPackageIdentity identity);
    internal virtual string get_Root();
    public static void ValidateLayout(IFileSystem fileSystem, string root, bool create);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.VisualStudio.Setup.Cache.ManifestRepository`3 : object {
    private static string Extension;
    private static string ExtensionFilter;
    private IFileSystem fileSystem;
    private IDictionary`2<TManifest, string> cache;
    private bool initialized;
    [CompilerGeneratedAttribute]
private IServiceProvider <Services>k__BackingField;
    protected string Root { get; }
    protected IServiceProvider Services { get; }
    private static ManifestRepository`3();
    public ManifestRepository`3(IServiceProvider services, TComparer comparer);
    public sealed virtual void AddManifest(TManifest manifest);
    public sealed virtual IEnumerable`1<TManifest> GetManifests();
    public sealed virtual void RemoveManifest(string id);
    public void Refresh();
    protected abstract virtual string get_Root();
    [CompilerGeneratedAttribute]
protected IServiceProvider get_Services();
    protected abstract virtual TSerializer CreateSerializer();
    protected abstract virtual TManifest Find(string id);
    protected virtual void OnCache(TManifest manifest);
    private void Initialize();
    private void EnsureDirectory();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Cache.PayloadState : ValueType {
    [CompilerGeneratedAttribute]
private Payload <Payload>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPresent>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsVerified>k__BackingField;
    public Payload Payload { get; }
    public string Path { get; }
    public bool IsPresent { get; }
    public Nullable`1<bool> IsVerified { get; }
    public PayloadState(Payload payload, string path, bool isPresent);
    public PayloadState(Payload payload, string path, bool isPresent, Nullable`1<bool> isVerified);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Payload get_Payload();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Path();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsPresent();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsVerified();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Setup.Cache.Query : object {
    private ServiceProvider services;
    [NullableAttribute("2")]
private IFileSystem fileSystem;
    [NullableAttribute("2")]
private ILogger logger;
    [NullableAttribute("2")]
private IOperatingSystem operatingSystem;
    [NullableAttribute("2")]
private IRegistry registry;
    [NullableAttribute("2")]
private IPolicyService policy;
    [NullableAttribute("2")]
private IRestartManager restartManager;
    private bool isInitialized;
    [NullableAttribute("2")]
private IProcessService processService;
    [NullableAttribute("2")]
private ICacheManagerFactory cacheFactory;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    public bool IsDisposed { get; private set; }
    public Query(IServiceProvider services);
    protected virtual override void Finalize();
    [CompilerGeneratedAttribute]
public bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    public sealed virtual void Dispose();
    public sealed virtual IEnumerable`1<IInstance> GetInstances();
    public sealed virtual IEnumerable`1<IInstance> GetAllInstances();
    public sealed virtual IInstance GetInstanceForCurrentProcess();
    public sealed virtual IInstance GetInstanceForPath(string path);
    public sealed virtual IInstance GetInstanceForId(string instanceId);
    public sealed virtual IInstance GetInstanceForPath(string path, bool includeIncomplete);
    public sealed virtual IEnumerable`1<IPackage> GetPackages(string instanceId);
    public sealed virtual IEnumerable`1<IPackage> GetPackages(string instanceId, bool all);
    public sealed virtual IEnumerable`1<IPackage> GetUpdatedPackages(string instanceId, DependencyComparisonSeed seed);
    public sealed virtual bool IsUpdateAvailable(IInstance instance, DependencyComparisonSeed seed, bool forceUpdate);
    public sealed virtual bool IsPreviousAvailable(IInstance instance);
    public sealed virtual IUpdateInformation GetUpdateInformation(string instanceId, DependencyComparisonSeed seed);
    public sealed virtual BackgroundDownloadStatus GetBackgroundDownloadStatus(IInstance instance);
    private IDependencyGraph GetUpdateGraph(IServiceContainer services, IDependencyComparisonSeed seed);
    private IDependencyGraph GetUpdateGraph(IServiceContainer services, Catalog updatedCatalog, IDependencyComparisonSeed seed);
    private string GetCatalogPath(ICacheManager cache);
    private bool HasUpdateManifest(IInstance instance);
    public sealed virtual bool HasUpdateManifest(IInstance instance, ChannelManifestPair targetChannel);
    public sealed virtual bool IsUpdateAvailableForAnyInstalledPackage(IInstance instance, Catalog catalog, bool forceUpdate);
    public sealed virtual IEnumerable`1<IPackage> GetRequiredUpdatePackages(string instanceId, Catalog catalog);
    private void Initialize();
    private ChannelManifestPair GetChannelManifestPair(IInstance instance);
    private IEnumerable`1<IInstance> GetInstances(bool all);
    private IInstance GetInstance(string instanceId);
    private void Dispose(bool disposing);
    private bool TryParseNewerCatalog(IServiceProvider services, string path, Catalog& catalog);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private ILogger <Initialize>b__37_1();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private IOperatingSystem <Initialize>b__37_3();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private IPolicyService <Initialize>b__37_4();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private IRestartManager <Initialize>b__37_5();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private ICacheManagerFactory <Initialize>b__37_7();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Cache.SupportedProductInfo : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <ProductArch>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public string Id { get; public set; }
    [NullableAttribute("2")]
public string ProductArch { get; public set; }
    public SupportedProductInfo(string Id, string ProductArch);
    [CompilerGeneratedAttribute]
protected SupportedProductInfo(SupportedProductInfo original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Id(string value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_ProductArch();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ProductArch(string value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SupportedProductInfo left, SupportedProductInfo right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SupportedProductInfo left, SupportedProductInfo right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(SupportedProductInfo other);
    [CompilerGeneratedAttribute]
public virtual SupportedProductInfo <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(String& Id, String& ProductArch);
}
internal class Microsoft.VisualStudio.Setup.Cache.TemporaryRepository : DirectoryRepository {
    private string root;
    private IHashingService hasher;
    public RepositoryCapabilities Capabilities { get; }
    internal string Root { get; }
    public TemporaryRepository(IServiceProvider services, string uniqueIdOrPath, bool isFullPath);
    public virtual RepositoryCapabilities get_Capabilities();
    internal virtual string get_Root();
    public virtual string GetPackageDirectory(IPackageIdentity identity);
}
internal class Microsoft.VisualStudio.Setup.Cache.UpdateInformation : object {
    [CompilerGeneratedAttribute]
private string <InstanceId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsUpdateAvailable>k__BackingField;
    [CompilerGeneratedAttribute]
private long <DownloadSize>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IPackage> <UpdatedPackages>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IPackage> <AdvertisedPackages>k__BackingField;
    [CompilerGeneratedAttribute]
private BackgroundDownloadStatus <BackgroundDownloadStatus>k__BackingField;
    public string InstanceId { get; }
    public bool IsUpdateAvailable { get; }
    public long DownloadSize { get; }
    public IEnumerable`1<IPackage> UpdatedPackages { get; }
    public IEnumerable`1<IPackage> AdvertisedPackages { get; }
    public BackgroundDownloadStatus BackgroundDownloadStatus { get; }
    public UpdateInformation(string instanceId, bool isUpdateAvailable, long downloadSize, IEnumerable`1<IPackage> updatedPackages, IEnumerable`1<IPackage> advertisedPackages, BackgroundDownloadStatus backgroundDownloadStatus);
    [CompilerGeneratedAttribute]
public sealed virtual string get_InstanceId();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsUpdateAvailable();
    [CompilerGeneratedAttribute]
public sealed virtual long get_DownloadSize();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<IPackage> get_UpdatedPackages();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<IPackage> get_AdvertisedPackages();
    [CompilerGeneratedAttribute]
public sealed virtual BackgroundDownloadStatus get_BackgroundDownloadStatus();
}
public class Microsoft.VisualStudio.Setup.CanceledByPrecheckException : Exception {
    [NullableContextAttribute("1")]
public CanceledByPrecheckException(string error, int errorCode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.CatalogValidator : object {
    private IServiceProvider services;
    public CatalogValidator(IServiceProvider services);
    public bool ShouldUninstallCatalogs(IEnumerable`1<string> catalogs, IEnumerable`1<IPackage> packages);
    private bool ShouldContinue(Message& message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.ChannelDownloader : object {
    private IServiceProvider services;
    private IFileSystem fileSystem;
    private ILockService lockService;
    [NullableAttribute("2")]
private ILogger logger;
    private IDownloadManager downloadManager;
    private IDictionary`2<string, IDisposable> lockedFilesDictionary;
    public ChannelDownloader(IServiceProvider services);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.ChannelDownloader/<GetLatestChannelManifestAsync>d__7")]
public sealed virtual Task`1<ManifestDownloadSummary> GetLatestChannelManifestAsync(Uri channelUri, string temporaryCacheDirectory, CancellationToken cancellationToken, ITelemetryOperation updateAsyncOperation, Nullable`1<DateTimeOffset> lastModifiedDate);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.ChannelInfo : object {
    [CompilerGeneratedAttribute]
private string <ChannelId>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ChannelUri>k__BackingField;
    public string ChannelId { get; }
    public Uri ChannelUri { get; }
    public ChannelInfo(string channelId, Uri channelUri);
    [CompilerGeneratedAttribute]
public string get_ChannelId();
    [CompilerGeneratedAttribute]
public Uri get_ChannelUri();
}
public class Microsoft.VisualStudio.Setup.ChannelManager : ChannelManagerBase {
    private static int DefaultGetTemporaryCacheDirectoryRetryCount;
    private static object SyncRoot;
    private ILogger logger;
    private IFileSystem fileSystem;
    private IPolicyService policyService;
    private IMachineService machineService;
    private Version clientVersion;
    private ChannelStatusTracker channelStatusTracker;
    private IChannelValidator channelValidator;
    private bool isInitialized;
    private IDownloadManager downloadManager;
    private ILockService lockService;
    private IDictionary`2<string, IDisposable> lockedFilesDictionary;
    private ITelemetry telemetry;
    private IChannelRepository channelRepository;
    private IChannelDownloader channelDownloader;
    private Version latestEngineVersion;
    private IQueryFactory queryFactory;
    [CompilerGeneratedAttribute]
private bool <IsEngineUpdateRequired>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UpdateEngineUriString>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <UpdateClientVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InstallLayoutPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OpcUrl>k__BackingField;
    public bool IsEngineUpdateRequired { get; public set; }
    public string UpdateEngineUriString { get; public set; }
    public Version UpdateClientVersion { get; public set; }
    public string InstallLayoutPath { get; public set; }
    public string OpcUrl { get; public set; }
    public ChannelManager(IServiceProvider services, string clientVersionString);
    private static ChannelManager();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsEngineUpdateRequired();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsEngineUpdateRequired(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_UpdateEngineUriString();
    [CompilerGeneratedAttribute]
public sealed virtual void set_UpdateEngineUriString(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Version get_UpdateClientVersion();
    [CompilerGeneratedAttribute]
public sealed virtual void set_UpdateClientVersion(Version value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_InstallLayoutPath();
    [CompilerGeneratedAttribute]
public sealed virtual void set_InstallLayoutPath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_OpcUrl();
    [CompilerGeneratedAttribute]
public sealed virtual void set_OpcUrl(string value);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.ChannelManager/<AddAsync>d__39")]
public sealed virtual Task`1<ChannelManifestPair> AddAsync(Uri channelUri, Uri installChannelUri, CancellationToken cancellationToken, Uri installCatalogUri);
    public sealed virtual IEnumerable`1<ChannelManifestPair> GetChannels(bool localChannelOnly);
    public sealed virtual void Remove(Uri channelUri);
    public sealed virtual void RemoveInstallChannel(Uri channelUri);
    public sealed virtual void CleanupInstallChannels(CancellationToken cancellationToken);
    public sealed virtual void EnsureEngineCanReadManifests(CancellationToken cancellationToken, bool throwOnUpdate);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.ChannelManager/<UpdateAsync>d__45")]
public sealed virtual Task`1<IChannelManifest> UpdateAsync(ChannelManifestPair channelManifestPair);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.ChannelManager/<UpdateAsync>d__46")]
public sealed virtual Task`1<IChannelManifest> UpdateAsync(ChannelManifestPair channelManifestPair, bool throwOnUpdateRequired);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.ChannelManager/<UpdateAsync>d__47")]
public sealed virtual Task`1<IChannelUpdateInformation> UpdateAsync(ChannelManifestPair channelManifestPair, UpdateOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.ChannelManager/<EnsureExistingChannelsAreCachedAsync>d__48")]
public sealed virtual Task EnsureExistingChannelsAreCachedAsync(IEnumerable`1<IInstance> instances, CancellationToken cancellationToken);
    private static void ThrowIfChannelMissing(T item, string identity, string methodName);
    private static void ThrowIfProductMissing(T item, string channelIdentity, string productId, string methodName);
    [ObsoleteAttribute]
public sealed virtual ChannelNode`1<IProductSummaryItem> GetChannelProductSummary(string channelId, string productId, string productArch);
    public sealed virtual ChannelNode`1<IProductSummaryItem> GetChannelProductSummary(Uri channelUri, string productId, string productArch);
    private ChannelNode`1<IProductSummaryItem> GetProductFromChannel(IChannelManifest channelManifest, string productId, string productArch);
    public sealed virtual void SynchronizeReadOnlyChannels();
    private bool EnsureEngineCanReadManifests(IChannelManifest latestChannelManifest, bool throwOnUpdate);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.ChannelManager/<UpdateAllAsync>d__56")]
public sealed virtual Task`1<bool> UpdateAllAsync();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.ChannelManager/<UpdateAllAsync>d__57")]
public sealed virtual Task`1<bool> UpdateAllAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.ChannelManager/<AddCatalogForChannelAsync>d__58")]
public sealed virtual Task`1<bool> AddCatalogForChannelAsync(ChannelManifestPair channelManifestPair);
    public sealed virtual void GetCatalogPathsForChannel(ChannelManifestPair channelManifestPair, String& channelCatalogFileName, String& installChannelCatalogFileName);
    [ObsoleteAttribute]
public sealed virtual ChannelManifestPair GetChannel(string channelId, bool localChannelOnly);
    public sealed virtual ChannelManifestPair GetChannel(Uri channelUri, bool localChannelOnly);
    public sealed virtual IEnumerable`1<IChannelManifest> GetInstallChannels();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.ChannelManager/<DownloadChannelManifestAsync>d__63")]
public sealed virtual Task`1<string> DownloadChannelManifestAsync(Uri channelManifestUri);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.ChannelManager/<DownloadCatalogFromChannelManifestAsync>d__64")]
public sealed virtual Task`1<string> DownloadCatalogFromChannelManifestAsync(string channelManifestPath);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.ChannelManager/<DownloadCatalogAsync>d__65")]
public sealed virtual Task`1<string> DownloadCatalogAsync(Uri catalogUri, CancellationToken cancellationToken);
    public sealed virtual ChannelStatus GetChannelStatus(Uri channelUri);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.ChannelManager/<DownloadCatalogAsync>d__67")]
private Task`1<string> DownloadCatalogAsync(IChannelManifest channelManifest, CancellationToken cancellationToken);
    private void Remove(ChannelManifestPair channelManifestPair);
    private void RemoveReadOnlyChannel(ChannelManifestPair channelManifestPair);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.ChannelManager/<UpdateAsync>d__70")]
private Task`1<IChannelUpdateInformation> UpdateAsync(ChannelManifestPair channelManifestPair, bool throwOnUpdateRequired, bool downloadOfflineInstaller, bool alwaysCacheManifest, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.ChannelManager/<UpdateChannelManifestAsync>d__71")]
private Task`1<IChannelUpdateInformation> UpdateChannelManifestAsync(ChannelManifestPair channelManifestPair, bool throwOnUpdateRequired, bool downloadOfflineInstaller, bool alwaysCacheManifest, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.ChannelManager/<AddCatalogForChannelAsync>d__72")]
private Task`1<bool> AddCatalogForChannelAsync(ChannelManifestPair channelManifestPair, CancellationToken cancellationToken);
    private Uri GetLatestBootstrapperLocation(IChannelManifest manifest);
    private bool IsCatalogUpToDate(IChannelManifest channelManifest, string channelCatalogPath);
    private Version GetClientVersion(IChannelManifest manifest);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.ChannelManager/<DownloadJsonFileAsync>d__76")]
private Task`1<string> DownloadJsonFileAsync(Uri uri, CancellationToken cancellationToken);
    private void ValidateUris(IChannelManifest channelManifest, IChannelManifest installChannelManifest);
    private void ValidateUris(Uri channelUri, Uri installChannelUri);
    private void TryRemoveInstallChannel(ChannelManifestPair channelManifestPair);
    protected virtual void Initialize();
    private void DeleteTemporaryFiles(string path);
    private void HandleDownloadFailureException(DownloadFailureException ex, InvalidSignatureException invalidSignatureException);
    private bool IsDownloadFailureExceptionInvalidSignatureException(DownloadFailureException ex, InvalidSignatureException& invalidSignatureException);
    private bool IsVerificationResultInvalidTestCertificate(InvalidSignatureException ex);
    private IEnumerable`1<IInstance> GetInstances();
    [CompilerGeneratedAttribute]
private IQueryFactory <Initialize>b__80_0();
}
public abstract class Microsoft.VisualStudio.Setup.ChannelManagerBase : object {
    private static int DefaultGetTemporaryCacheDirectoryRetryCount;
    private static object SyncRoot;
    private ILogger logger;
    private IFileSystem fileSystem;
    private IPolicyService policyService;
    private bool isInitialized;
    private ILockService lockService;
    private ITelemetry telemetry;
    private string temporaryCacheDirectory;
    [CompilerGeneratedAttribute]
private bool <UpdateDisabled>k__BackingField;
    [CompilerGeneratedAttribute]
private ServiceProvider <Services>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    protected bool UpdateDisabled { get; protected set; }
    protected ServiceProvider Services { get; private set; }
    public bool IsDisposed { get; private set; }
    protected string TemporaryCacheDirectory { get; }
    public ChannelManagerBase(IServiceProvider services);
    private static ChannelManagerBase();
    [CompilerGeneratedAttribute]
protected bool get_UpdateDisabled();
    [CompilerGeneratedAttribute]
protected void set_UpdateDisabled(bool value);
    [CompilerGeneratedAttribute]
protected ServiceProvider get_Services();
    [CompilerGeneratedAttribute]
private void set_Services(ServiceProvider value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    protected virtual void Initialize();
    protected string get_TemporaryCacheDirectory();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    private void CleanupTemporaryCacheDirectory();
    private void EnsureCanChannelUpdateStatus();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private IDownloadManager <Initialize>b__22_3();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private ISignatureVerifierManager <Initialize>b__22_4();
    [CompilerGeneratedAttribute]
private ILockService <Initialize>b__22_5();
    [CompilerGeneratedAttribute]
private ITelemetry <Initialize>b__22_6();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private IChannelDownloader <Initialize>b__22_7();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Setup.ChannelManifestDownloadException : EngineException {
    public ChannelManifestDownloadException(ResourceManager resourceManager, string resourceId, Object[] args);
    public ChannelManifestDownloadException(Exception innerException, ResourceManager resourceManager, string resourceId, Object[] args);
    protected ChannelManifestDownloadException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.VisualStudio.Setup.ChannelSets.UpdateOptions : object {
    [CompilerGeneratedAttribute]
private bool <DownloadOfflineInstaller>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ThrowOnUpdateRequired>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AlwaysCacheManifests>k__BackingField;
    public bool DownloadOfflineInstaller { get; public set; }
    public bool ThrowOnUpdateRequired { get; public set; }
    public bool AlwaysCacheManifests { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_DownloadOfflineInstaller();
    [CompilerGeneratedAttribute]
public void set_DownloadOfflineInstaller(bool value);
    [CompilerGeneratedAttribute]
public bool get_ThrowOnUpdateRequired();
    [CompilerGeneratedAttribute]
public void set_ThrowOnUpdateRequired(bool value);
    [CompilerGeneratedAttribute]
public bool get_AlwaysCacheManifests();
    [CompilerGeneratedAttribute]
public void set_AlwaysCacheManifests(bool value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.ChannelUpdateInformation : object {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IChannelManifest <ChannelManifest>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OfflineBootstrapperPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OfflineInstallerPath>k__BackingField;
    [NullableAttribute("1")]
public IChannelManifest ChannelManifest { get; }
    public string OfflineBootstrapperPath { get; }
    public string OfflineInstallerPath { get; }
    [NullableContextAttribute("1")]
internal ChannelUpdateInformation(IChannelManifest channelManifest, IBootstrapperInformation bootstrapperInformation);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual IChannelManifest get_ChannelManifest();
    [CompilerGeneratedAttribute]
public sealed virtual string get_OfflineBootstrapperPath();
    [CompilerGeneratedAttribute]
public sealed virtual string get_OfflineInstallerPath();
}
internal class Microsoft.VisualStudio.Setup.ChannelValidator : object {
    [NullableAttribute("2")]
private ILogger logger;
    [NullableContextAttribute("1")]
public ChannelValidator(IServiceProvider services);
    [NullableContextAttribute("1")]
public sealed virtual void ValidateChannelUri(Uri channelUri);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.ChipConstants : object {
    public static string X86;
    public static string X64;
    private static ChipConstants();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.CleanLayoutOperation : LayoutOperationBase {
    private static int ConcurrentClean;
    private static object LockObject;
    private IList`1<CleanPackage> cleanPackages;
    private AsyncCoordinator parallelCleans;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IList`1<string> directoryToBeCleaned;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentBag`1<string> directoryFailedToBeCleaned;
    public long DownloadSize { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyCollection`1<DownloadPackage> PackagesToDownload { get; }
    internal CleanLayoutOperation(IServiceProvider services, ISet`1<IPackage> packages, LayoutContext layoutContext);
    private static CleanLayoutOperation();
    public virtual long get_DownloadSize();
    public virtual IReadOnlyCollection`1<DownloadPackage> get_PackagesToDownload();
    public virtual void Run(CancellationToken token);
    protected virtual void PlanOperation();
    private IList`1<IPackageIdentity> GetPackages(IEnumerable`1<string> catalogs);
    private void OnError(object sender, ActivityEventArgs args);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Setup.Client : object {
    public static Version GetClientPackageVersion(IServiceProvider services, string installerLocation);
    public static ClientVersionFile GetInstalledClientVersionFile(IServiceProvider services, string installerLocation);
    [NullableContextAttribute("1")]
public static Version GetClientPackageVersionFromOpc(IServiceProvider services, string opcPath, CancellationToken cancellationToken);
    public static Version GetInstallerVersion(IServiceProvider services, string installerLocation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Setup.ClientVersionFile : object {
    private static string VERSION_FILE_VERSION_PARAMETER_NAME;
    private static string VERSION_FILE_BRANCH_PARAMETER_NAME;
    private static string VERSION_FILE_NAME_PARAMETER_NAME;
    private static string VERSION_FILE_INSTALLER_VERSION_PARAMETER_NAME;
    private IDictionary`2<string, object> versionFileData;
    [NullableAttribute("2")]
public Version Version { get; }
    [NullableAttribute("2")]
public Version InstallerVersion { get; }
    [NullableAttribute("2")]
public string Branch { get; }
    public string Name { get; }
    [NullableContextAttribute("2")]
public ClientVersionFile(IServiceProvider services, string path, Stream clientFileStream);
    [NullableContextAttribute("2")]
public static bool TryCreate(IServiceProvider services, Stream clientFileStream, ClientVersionFile& versionFile);
    [NullableContextAttribute("2")]
public Version get_Version();
    [NullableContextAttribute("2")]
public Version get_InstallerVersion();
    [NullableContextAttribute("2")]
public string get_Branch();
    public string get_Name();
    private bool TryGetFileData(string propertyName, String& propertyValue);
}
public static class Microsoft.VisualStudio.Setup.CommandLineUtilities : object {
    [NullableContextAttribute("2")]
public static string SanitizeCommandLineArgs(string rawArgs);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.VisualStudio.Setup.Compression.ArchiveFileInfo : FileSystemInfo {
    private string name;
    private bool initialized;
    private bool exists;
    private FileAttributes attributes;
    private DateTime lastWriteTime;
    private long length;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ArchiveNumber>k__BackingField;
    public string Name { get; }
    public string Path { get; }
    public string FullName { get; }
    public int ArchiveNumber { get; }
    public bool Exists { get; }
    public long Length { get; }
    protected ArchiveFileInfo(string filePath);
    protected ArchiveFileInfo(string filePath, int archiveNumber, FileAttributes attributes, DateTime lastWriteTime, long length);
    public virtual string get_Name();
    [CompilerGeneratedAttribute]
public string get_Path();
    public virtual string get_FullName();
    [CompilerGeneratedAttribute]
public int get_ArchiveNumber();
    public virtual bool get_Exists();
    public long get_Length();
    public virtual string ToString();
    public virtual void Delete();
    public void Refresh();
    protected virtual void Refresh(ArchiveFileInfo newFileInfo);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Compression.BasicUnpackStreamContext : object {
    private Stream archiveStream;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Stream <FileStream>k__BackingField;
    [NullableAttribute("2")]
public Stream FileStream { get; private set; }
    public BasicUnpackStreamContext(Stream archiveStream);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Stream get_FileStream();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_FileStream(Stream value);
    public sealed virtual Stream OpenArchiveReadStream(int archiveNumber, string archiveName, CompressionEngine compressionEngine);
    public sealed virtual void CloseArchiveReadStream(int archiveNumber, string archiveName, Stream stream);
    public sealed virtual Stream OpenFileWriteStream(string path, long fileSize, DateTime lastWriteTime);
    public sealed virtual void CloseFileWriteStream(string path, Stream stream, FileAttributes attributes, DateTime lastWriteTime);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Compression.CabEngine : CompressionEngine {
    [NullableAttribute("2")]
private CabUnpacker unpacker;
    private CabUnpacker Unpacker { get; }
    protected virtual void Dispose(bool disposing);
    private CabUnpacker get_Unpacker();
    public virtual IList`1<ArchiveFileInfo> GetFileInfo(IUnpackStreamContext streamContext, Predicate`1<string> fileFilter);
    public virtual void Unpack(IUnpackStreamContext streamContext, Predicate`1<string> fileFilter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Setup.Compression.CabException : IOException {
    private static int FDIERRORRESOURCEOFFSET;
    private static Dictionary`2<int, string> ErrorMessages;
    private int error;
    private int errorCode;
    public int Error { get; }
    public int ErrorCode { get; }
    private static CabException();
    public CabException(string message, Exception innerException);
    public CabException(string message);
    [NullableContextAttribute("2")]
internal CabException(int error, int errorCode, string message, Exception innerException);
    internal CabException(int error, int errorCode, string message);
    protected CabException(SerializationInfo info, StreamingContext context);
    public int get_Error();
    public int get_ErrorCode();
    internal static string GetErrorMessage(int error, int errorCode);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Compression.CabFileInfo : ArchiveFileInfo {
    private int cabFolder;
    public int CabinetFolderNumber { get; }
    internal CabFileInfo(string filePath, int cabFolder, int cabNumber, FileAttributes attributes, DateTime lastWriteTime, long length);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public int get_CabinetFolderNumber();
    protected virtual void Refresh(ArchiveFileInfo newFileInfo);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Compression.CabUnpacker : CabWorker {
    private object syncRoot;
    [NullableAttribute("2")]
private FDISafeHandle fdiHandle;
    private PFNALLOC fdiAllocMemHandler;
    private PFNFREE fdiFreeMemHandler;
    private PFNOPEN fdiOpenStreamHandler;
    private PFNREAD fdiReadStreamHandler;
    private PFNWRITE fdiWriteStreamHandler;
    private PFNCLOSE fdiCloseStreamHandler;
    private PFNSEEK fdiSeekStreamHandler;
    [NullableAttribute("2")]
private IUnpackStreamContext context;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ArchiveFileInfo> fileList;
    private int folderId;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Predicate`1<string> filter;
    public CabUnpacker(CabEngine cabEngine);
    public IList`1<ArchiveFileInfo> GetFileInfo(IUnpackStreamContext streamContext, Predicate`1<string> fileFilter);
    public void Unpack(IUnpackStreamContext streamContext, Predicate`1<string> fileFilter);
    internal virtual IntPtr CabOpenStreamEx(PSTR pstrPath, int openFlags, int shareMode, Int32& err);
    internal virtual int CabCloseStreamEx(IntPtr streamHandle, Int32& err);
    protected virtual void Dispose(bool disposing);
    private static string GetFileName(FDINOTIFICATION notification);
    [NullableContextAttribute("0")]
private IntPtr CabListNotify(FDINOTIFICATIONTYPE notificationType, FDINOTIFICATION* notification);
    [NullableContextAttribute("0")]
private IntPtr CabExtractNotify(FDINOTIFICATIONTYPE notificationType, FDINOTIFICATION* notification);
    private int CabExtractCopyFile(FDINOTIFICATION notification);
    private int CabExtractCloseFile(FDINOTIFICATION notification);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal abstract class Microsoft.VisualStudio.Setup.Compression.CabWorker : object {
    [NullableAttribute("1")]
internal static string CabStreamName;
    [NullableAttribute("1")]
private Byte[] buf;
    private ERF erf;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private CabEngine <CabEngine>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private HandleManager`1<Stream> <StreamHandles>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IDictionary`2<string, short> <CabNumbers>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NextCabinetName>k__BackingField;
    [CompilerGeneratedAttribute]
private Stream <CabStream>k__BackingField;
    [CompilerGeneratedAttribute]
private Stream <FileStream>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CurrentFileName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CurrentArchiveName>k__BackingField;
    [CompilerGeneratedAttribute]
private short <CurrentArchiveNumber>k__BackingField;
    [NullableAttribute("1")]
public CabEngine CabEngine { get; }
    internal ERF Erf { get; }
    [NullableAttribute("1")]
internal HandleManager`1<Stream> StreamHandles { get; }
    [NullableAttribute("1")]
internal IDictionary`2<string, short> CabNumbers { get; }
    internal string NextCabinetName { get; internal set; }
    internal Stream CabStream { get; internal set; }
    internal Stream FileStream { get; internal set; }
    protected string CurrentFileName { get; protected set; }
    protected string CurrentArchiveName { get; protected set; }
    protected short CurrentArchiveNumber { get; protected set; }
    [NullableContextAttribute("1")]
protected CabWorker(CabEngine cabEngine);
    protected virtual override void Finalize();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public CabEngine get_CabEngine();
    internal ERF get_Erf();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal HandleManager`1<Stream> get_StreamHandles();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal IDictionary`2<string, short> get_CabNumbers();
    [CompilerGeneratedAttribute]
internal string get_NextCabinetName();
    [CompilerGeneratedAttribute]
internal void set_NextCabinetName(string value);
    [CompilerGeneratedAttribute]
internal Stream get_CabStream();
    [CompilerGeneratedAttribute]
internal void set_CabStream(Stream value);
    [CompilerGeneratedAttribute]
internal Stream get_FileStream();
    [CompilerGeneratedAttribute]
internal void set_FileStream(Stream value);
    [CompilerGeneratedAttribute]
protected string get_CurrentFileName();
    [CompilerGeneratedAttribute]
protected void set_CurrentFileName(string value);
    [CompilerGeneratedAttribute]
protected string get_CurrentArchiveName();
    [CompilerGeneratedAttribute]
protected void set_CurrentArchiveName(string value);
    [CompilerGeneratedAttribute]
protected short get_CurrentArchiveNumber();
    [CompilerGeneratedAttribute]
protected void set_CurrentArchiveNumber(short value);
    public sealed virtual void Dispose();
    protected void ResetData();
    [NullableContextAttribute("0")]
internal Void* CabAllocMem(UInt32 byteCount);
    [NullableContextAttribute("0")]
internal void CabFreeMem(Void* memPointer);
    internal IntPtr CabOpenStream(PSTR path, int openFlags, int shareMode);
    internal virtual IntPtr CabOpenStreamEx(PSTR path, int openFlags, int shareMode, Int32& err);
    [NullableContextAttribute("0")]
internal UInt32 CabReadStream(IntPtr streamHandle, Void* memory, UInt32 cb);
    [NullableContextAttribute("0")]
internal virtual UInt32 CabReadStreamEx(IntPtr streamHandle, Void* memory, UInt32 cb, Int32& err);
    [NullableContextAttribute("0")]
internal UInt32 CabWriteStream(IntPtr streamHandle, Void* memory, UInt32 cb);
    [NullableContextAttribute("0")]
internal virtual UInt32 CabWriteStreamEx(IntPtr streamHandle, Void* memory, UInt32 cb, Int32& err);
    internal int CabCloseStream(IntPtr streamHandle);
    internal virtual int CabCloseStreamEx(IntPtr streamHandle, Int32& err);
    internal int CabSeekStream(IntPtr streamHandle, int offset, int seekOrigin);
    internal virtual int CabSeekStreamEx(IntPtr streamHandle, int offset, int seekOrigin, Int32& err);
    protected virtual void Dispose(bool disposing);
    protected void CheckError();
    [NullableContextAttribute("1")]
protected FDISafeHandle FDICreate(PFNALLOC fdiAlloc, PFNFREE fdiFree, PFNOPEN fdiOpen, PFNREAD fdiRead, PFNWRITE fdiWrite, PFNCLOSE fdiClose, PFNSEEK fdiSeek);
    protected void ResetErf();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.VisualStudio.Setup.Compression.CompressionEngine : object {
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    public IList`1<ArchiveFileInfo> GetFileInfo(Stream stream);
    public abstract virtual IList`1<ArchiveFileInfo> GetFileInfo(IUnpackStreamContext streamContext, Predicate`1<string> fileFilter);
    public IList`1<string> GetFiles(Stream stream);
    public IList`1<string> GetFiles(IUnpackStreamContext streamContext, Predicate`1<string> fileFilter);
    public Stream Unpack(Stream stream, string path);
    public abstract virtual void Unpack(IUnpackStreamContext streamContext, Predicate`1<string> fileFilter);
    protected virtual void Dispose(bool disposing);
    public static void DosDateAndTimeToDateTime(ushort dosDate, ushort dosTime, DateTime& dateTime);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Compression.DuplicateStream : Stream {
    private long position;
    [CompilerGeneratedAttribute]
private Stream <Source>k__BackingField;
    public Stream Source { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public DuplicateStream(Stream source);
    [CompilerGeneratedAttribute]
public Stream get_Source();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public static Stream OriginalStream(Stream stream);
    public virtual void Flush();
    public virtual void SetLength(long value);
    public virtual void Close();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
}
internal class Microsoft.VisualStudio.Setup.Compression.FDISafeHandle : SafeHandle {
    public bool IsInvalid { get; }
    internal FDISafeHandle(Void* handle);
    public virtual bool get_IsInvalid();
    public Void* ToPointer();
    protected virtual bool ReleaseHandle();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Microsoft.VisualStudio.Setup.Compression.HandleManager`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<T> handles;
    public T Item { get; }
    public T Item { get; }
    public T get_Item(int handle);
    public T get_Item(IntPtr handle);
    [NullableContextAttribute("1")]
public int AllocHandle(T obj);
    public void FreeHandle(int handle);
    public void FreeHandle(IntPtr handle);
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Setup.Compression.IUnpackStreamContext {
    public abstract virtual Stream OpenArchiveReadStream(int archiveNumber, string archiveName, CompressionEngine compressionEngine);
    public abstract virtual void CloseArchiveReadStream(int archiveNumber, string archiveName, Stream stream);
    public abstract virtual Stream OpenFileWriteStream(string path, long fileSize, DateTime lastWriteTime);
    public abstract virtual void CloseFileWriteStream(string path, Stream stream, FileAttributes attributes, DateTime lastWriteTime);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Setup.ConditionEvaluatorFactory : object {
    private IDictionary`2<ConditionType, IConditionEvaluator> conditionEvaluators;
    public void AddConditionEvaluator(IConditionEvaluator evaluator);
    public IConditionEvaluator GetConditionEvaluator(Condition condition);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Setup.ConditionsEvaluator : object {
    public bool EvaluateConditions(IServiceProvider services, ConditionGroup conditions, ConditionEvaluatorFactory evaluatorFactory, IDictionary`2<string, string> properties);
    internal bool ParseJoin(Condition condition);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.ConsumerUpdateConstants : object {
    public static string AllowMUUpdateServiceEnabledRegValue;
    public static ISet`1<string> ConsumerMUUpdateServiceDefaultRegKeyPaths;
    public static int VSthroughMUUpdatesOptOutRegValueSetExitCode;
    private static ConsumerUpdateConstants();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Copier : object {
    private static int ProcessKillDelay;
    private static int MaximiumProcessShutdownAttempts;
    private static string OldDirectorySuffix;
    private static int CopyRetries;
    private static TimeSpan ProcessRetryDelay;
    private CopierSettings settings;
    private IFileSystem fileSystem;
    [NullableAttribute("2")]
private ILogger logger;
    private IProcessService processService;
    private IServiceControllerFactory serviceControllerFactory;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) operationId;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<CopierProgressEventArgs> Progress;
    [CompilerGeneratedAttribute]
private int <MaximumConcurrency>k__BackingField;
    internal int MaximumConcurrency { get; }
    [NullableContextAttribute("2")]
public Copier(IServiceProvider services, CopierSettings settings);
    private static Copier();
    [CompilerGeneratedAttribute]
public void add_Progress(EventHandler`1<CopierProgressEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Progress(EventHandler`1<CopierProgressEventArgs> value);
    [CompilerGeneratedAttribute]
internal int get_MaximumConcurrency();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Copier/<CopyDirectoryAsync>d__18")]
public Task CopyDirectoryAsync(string source, string destination, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Copier/<MoveDirectoryAsync>d__19")]
public Task MoveDirectoryAsync(string source, string destination, bool atomicMove, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Copier/<SafeUpdateDirectoryAsync>d__20")]
public Task SafeUpdateDirectoryAsync(string source, string destination, IEnumerable`1<string> relatedServices, CancellationToken cancellationToken);
    private void CreateDirectoryIfNotExists(string path, bool isDirectory);
    private void EnumerateFiles(string source, string destination, CopierOperation operation, int operationId, BlockingCollection`1<CopierData> queue, Int32& fileCount);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Copier/<InvokeAsync>d__23")]
private Task InvokeAsync(string source, string destination, CopierOperation operation, int operationId, CancellationToken cancellationToken);
    private void InvokeOperation(string source, string destination, BlockingCollection`1<CopierData> queue, Int32& fileCount);
    private bool InvokeCopyOperation(string sourcePath, string destinationPath);
    private bool InvokeDeleteOperation(string sourcePath);
    private bool InvokeMoveOperation(string sourcePath, string destinationPath);
    private void OnProgress(CopierOperation operation, int operationId, Double& progress);
    private Task`1<bool> MoveDirectoryAsyncInternal(string source, string destination, bool throwOnFailure, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Copier/<ShutdownServicesAsync>d__31")]
private Task ShutdownServicesAsync(IEnumerable`1<string> services);
    private Task ShutdownRunningProcesses(string directory);
    private Task DeleteDirectoryAsync(string path, bool rebootOK, CancellationToken cancellationToken);
}
internal enum Microsoft.VisualStudio.Setup.CopierOperation : Enum {
    public int value__;
    public static CopierOperation Copy;
    public static CopierOperation Move;
    public static CopierOperation Delete;
}
internal class Microsoft.VisualStudio.Setup.CopierProgressEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private CopierOperation <Operation>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OperationId>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Progress>k__BackingField;
    public CopierOperation Operation { get; }
    public int OperationId { get; }
    public double Progress { get; }
    internal CopierProgressEventArgs(CopierOperation operation, int operationId, double progress);
    [CompilerGeneratedAttribute]
public CopierOperation get_Operation();
    [CompilerGeneratedAttribute]
public int get_OperationId();
    [CompilerGeneratedAttribute]
public double get_Progress();
}
internal class Microsoft.VisualStudio.Setup.CopierSettings : object {
    [CompilerGeneratedAttribute]
private bool <DeleteAfterReboot>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumConcurrency>k__BackingField;
    public bool DeleteAfterReboot { get; public set; }
    public Nullable`1<int> MaximumConcurrency { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_DeleteAfterReboot();
    [CompilerGeneratedAttribute]
public void set_DeleteAfterReboot(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximumConcurrency();
    [CompilerGeneratedAttribute]
public void set_MaximumConcurrency(Nullable`1<int> value);
}
internal static class Microsoft.VisualStudio.Setup.DefaultAccountInformation : object {
    [NullableAttribute("1")]
internal static string WellKnownRid;
    private static DefaultAccountInformation();
}
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Setup.Dependencies.Extensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<IPackage> GetAdvertisedComponents(IDependencyGraph graph);
    [ExtensionAttribute]
internal static IEnumerable`1<IDependencyNode> GetNewlyRecommendedComponents(IDependencyGraph graph);
    [ExtensionAttribute]
public static void UpdateSelection(IDependencyGraph graph, IEnumerable`1<SelectedPackage> selectedPackageIds);
    [ExtensionAttribute]
public static void UpdateLayoutSelection(IDependencyNode node, RequestedState requestedState, DependencyType includeScope);
    [ExtensionAttribute]
private static bool CheckLayoutIncludeScope(IDependencyArc arc, DependencyType includeScope);
    [ExtensionAttribute]
private static void UpdateSelectionBase(IDependencyGraph graph, IDictionary`2<string, SelectedState> selectedStateByPackageId);
    private static void ApplySelection(IDependencyGraph graph, IDictionary`2<string, SelectedState> selectedStateByPackageId);
    private static bool CheckIfParentsShouldAdvertise(IDependencyNode advertisedComponent);
    private static IPackage GetSupersededPackage(IDependencyNode node);
    private static IEnumerable`1<IDependencyNode> GetUpdatedSelectedParentWorkloads(IDependencyNode node);
    private static bool IsRecommended(IPackage parent, IPackage child);
    private static bool IsRecommended(IDependencyNode parent, IPackage child);
    private static bool IsNewlyRecommended(IEnumerable`1<IDependencyNode> parents, IPackage oldPackage, IPackage newPackage);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.DependencyActionManager : object {
    internal static RegistryHive Hive;
    internal static string Root;
    internal static string Dependents;
    internal static string InstanceDependency;
    private IServiceProvider services;
    [NullableAttribute("2")]
private IRegistry registryService;
    private bool isInitialized;
    [NullableAttribute("2")]
private ILogger log;
    [NullableAttribute("2")]
private IInstanceReferenceManager referenceManager;
    internal DependencyActionManager(IServiceProvider services);
    private static DependencyActionManager();
    internal Nullable`1<bool> PlanDependencyAction(IInstallablePackage package, PackageState currentState, ExecuteAction plannedAction, ExecuteAction bootstrapperAction);
    internal ExecuteAction PlanPackageWithLegacyDependencies(IInstallablePackage package, ExecuteAction requestedAction);
    private bool ShouldConvertExecuteActionToNone(IInstallablePackage package, ExecuteAction requestedAction);
    private bool HasDependents(IInstallablePackage package, bool isDowngrade);
    private Version GetMinimumVersionForDowngrade(IPackage package);
    internal void AddLegacyDependency(IInstallablePackage package);
    internal void RemoveLegacyDependency(IInstallablePackage package);
    internal IEnumerable`1<string> GetExistingDependencies(IInstallablePackage package);
    private void UpdateLegacyDependency(IInstallablePackage package, bool isAdd);
    private void WriteAdditionalProviderKeyInformation(IInstallablePackage package, IRegistryKey providerKey);
    [MemberNotNullAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private void Initialize();
}
internal static class Microsoft.VisualStudio.Setup.DismUtility : object {
    internal static string GetExpandExecutable { get; }
    private static string GetDismExecutable { get; }
    internal static string get_GetExpandExecutable();
    internal static Result InstallMSU(string msuPath, string logFileName, IServiceProvider serviceProvider);
    internal static Result InstallFeature(string windowsFeatureName, string logFileName, IServiceProvider serviceProvider);
    private static string get_GetDismExecutable();
    private static Result Install(string arguments, IServiceProvider serviceProvider);
}
public class Microsoft.VisualStudio.Setup.Engine : object {
    public static int MaxInstallRootPathLength;
    public static string SetupEngineFilePathPropertyName;
    public static string InInstallFromLayoutModePropertyName;
    internal static string DefaultUILanguage;
    private ServiceProvider services;
    private string instanceId;
    private ConcurrentDictionary`2<IPackage, bool> packages;
    private ISet`1<Catalog> extensions;
    private DependencyCollection deprecated;
    private DependencyComparisonSeed defaultSeed;
    private HashSet`1<string> resettableProperties;
    private TelemetryContext telemetryContext;
    private ExtensionApplicabilityArtifacts extensionApplicabilityArtifacts;
    private IApplicabilityService applicabilityService;
    private IWindowsInstallerService windowsInstallerService;
    private INgenService ngenService;
    private ICacheManager cache;
    private IDownloadManager downloader;
    private IHashingService hash;
    private IFileSystem fileSystem;
    private IReparseAwareFileSystem reparseAwareFileSystem;
    private ILogger logger;
    private ITelemetry telemetry;
    private Coordinator downloads;
    private Coordinator installs;
    private IDependencyManager dependencyManager;
    private IInstanceReferenceManager referenceManager;
    private IDependencyGraph dependencyGraph;
    private IRegistry registry;
    private IRestartManager restartManager;
    private IPolicyService policy;
    private IProcessService processService;
    private IOperatingSystem operatingSystem;
    private IPendingRebootOperations rebootPendingOperations;
    private ISettingsService settings;
    private IPackageDetectionService packageDetection;
    private IAccountProfileService accountProfileService;
    private IVariableResolver variableResolver;
    private DependencyComparisonSeed seed;
    private Uri manifestUri;
    private bool isInitialized;
    private string temporaryLayoutDirectory;
    private RunOnceInformation runOnceInformation;
    private bool shouldCreateLayout;
    private bool canOverwriteProperties;
    private bool canOverwriteFiles;
    private FileLogger errorFileLogger;
    private ChannelManifestPair channelPair;
    private IPrecheckEvaluatorFactory precheckEaluatorFactory;
    private IManifestValidatorFactory manifestValidatorFactory;
    private IWindowsRestartManagerFactory rmFactory;
    private ILockService lockService;
    private bool isPreDynamicEndpoint;
    private Uri layoutUri;
    private object graphLock;
    [CompilerGeneratedAttribute]
private bool <IsDirty>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CatalogPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LayoutDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LogFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorLogFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <KeepWindowsUpdateOn>k__BackingField;
    [CompilerGeneratedAttribute]
private VariableCollection <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <ManifestVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <BuildVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <OperationStartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private EngineDriveInfo <DriveInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private ExecuteAction <BootstrapperAction>k__BackingField;
    [CompilerGeneratedAttribute]
private ITelemetryOperation <InstallOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private PrecheckParameters <PrecheckParameters>k__BackingField;
    public bool IsDirty { get; private set; }
    public string CatalogPath { get; private set; }
    public IEnumerable`1<Catalog> ExtensionCatalogs { get; }
    public string LayoutDirectory { get; private set; }
    public string LogFilePath { get; public set; }
    public string ErrorLogFilePath { get; public set; }
    public bool KeepWindowsUpdateOn { get; public set; }
    public VariableCollection Properties { get; private set; }
    public bool IsDisposed { get; private set; }
    public Version ManifestVersion { get; private set; }
    public Version BuildVersion { get; private set; }
    public DateTimeOffset OperationStartTime { get; private set; }
    public EngineDriveInfo DriveInfo { get; private set; }
    public ExecuteAction BootstrapperAction { get; private set; }
    public ITelemetryOperation InstallOperation { get; private set; }
    public PrecheckParameters PrecheckParameters { get; private set; }
    public DependencyComparisonSeed Seed { get; public set; }
    public bool CanOverwriteProperties { get; public set; }
    public bool CanOverwriteFiles { get; public set; }
    internal IEnumerable`1<IPackage> AvailablePackages { get; }
    public IInstance Instance { get; }
    private IChannelManifest TargetChannelManifest { get; }
    private string ChannelId { get; }
    private Uri ChannelUri { get; }
    private Uri InstallChannelUri { get; }
    private IDependencyGraph DependencyGraph { get; private set; }
    public Engine(IServiceProvider services, string instanceId);
    private static Engine();
    protected virtual override void Finalize();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDirty();
    [CompilerGeneratedAttribute]
private void set_IsDirty(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_CatalogPath();
    [CompilerGeneratedAttribute]
private void set_CatalogPath(string value);
    public sealed virtual IEnumerable`1<Catalog> get_ExtensionCatalogs();
    [CompilerGeneratedAttribute]
public sealed virtual string get_LayoutDirectory();
    [CompilerGeneratedAttribute]
private void set_LayoutDirectory(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_LogFilePath();
    [CompilerGeneratedAttribute]
public void set_LogFilePath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ErrorLogFilePath();
    [CompilerGeneratedAttribute]
public void set_ErrorLogFilePath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_KeepWindowsUpdateOn();
    [CompilerGeneratedAttribute]
public sealed virtual void set_KeepWindowsUpdateOn(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual VariableCollection get_Properties();
    [CompilerGeneratedAttribute]
private void set_Properties(VariableCollection value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual Version get_ManifestVersion();
    [CompilerGeneratedAttribute]
private void set_ManifestVersion(Version value);
    [CompilerGeneratedAttribute]
public sealed virtual Version get_BuildVersion();
    [CompilerGeneratedAttribute]
private void set_BuildVersion(Version value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_OperationStartTime();
    [CompilerGeneratedAttribute]
private void set_OperationStartTime(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public sealed virtual EngineDriveInfo get_DriveInfo();
    [CompilerGeneratedAttribute]
private void set_DriveInfo(EngineDriveInfo value);
    [CompilerGeneratedAttribute]
public sealed virtual ExecuteAction get_BootstrapperAction();
    [CompilerGeneratedAttribute]
private void set_BootstrapperAction(ExecuteAction value);
    [CompilerGeneratedAttribute]
public sealed virtual ITelemetryOperation get_InstallOperation();
    [CompilerGeneratedAttribute]
private void set_InstallOperation(ITelemetryOperation value);
    [CompilerGeneratedAttribute]
public sealed virtual PrecheckParameters get_PrecheckParameters();
    [CompilerGeneratedAttribute]
private void set_PrecheckParameters(PrecheckParameters value);
    public sealed virtual DependencyComparisonSeed get_Seed();
    public sealed virtual void set_Seed(DependencyComparisonSeed value);
    public sealed virtual bool get_CanOverwriteProperties();
    public sealed virtual void set_CanOverwriteProperties(bool value);
    public sealed virtual bool get_CanOverwriteFiles();
    public sealed virtual void set_CanOverwriteFiles(bool value);
    internal IEnumerable`1<IPackage> get_AvailablePackages();
    public sealed virtual IInstance get_Instance();
    public static void VerifyInstallationPath(IServiceProvider services, string installationPath, IInstance instance, IQuery query);
    internal static string CalculateCurrentOperation(ExecuteAction action, IInstance instance, Product product);
    private static bool IsResumedRollback(IInstance instance);
    private static bool IsResumedRepair(IInstance instance);
    public sealed virtual void SetLayoutDirectory(string path, bool create);
    public sealed virtual void SetLayoutUri(Uri layoutUri);
    public sealed virtual void SetTemporaryLayoutDirectory(string path);
    public sealed virtual void SetExtensionsDirectory(string path);
    public sealed virtual void Load(ChannelNode`1<IProductSummaryItem> channelProduct, CancellationToken token, bool skipVerify);
    public sealed virtual void Load(Uri manifestUri, Uri channelUri, Uri installChannelUri, CancellationToken token, bool skipVerify);
    public sealed virtual void LoadPartialJson(string catalogJson);
    public sealed virtual void LoadPartialEmbeddedJson(string catalogJson);
    public void LoadPartialJson(string catalogJson, bool replace);
    public void LoadPartialJson(string catalogJson, bool replace, bool isEmbedded);
    public sealed virtual void Load(string path, bool skipVerify);
    private void Load(Catalog catalog, ITelemetryOperation loadOperation);
    public sealed virtual IEnumerable`1<Product> GetProducts();
    public sealed virtual IDependencyGraph GetProductDependencyGraph(Product product, bool overwrite);
    public sealed virtual IDependencyGraph GetProductDependencyGraphWithSelection(Product product, bool overwrite);
    public sealed virtual string GetDefaultInstallDirectory(Product product);
    public sealed virtual void Dispose();
    private sealed virtual override void Microsoft.VisualStudio.Setup.IEngine.Layout(Product product, LayoutContext layoutContext, CancellationToken token);
    public sealed virtual IInstance Install(Product product, string destination, CancellationToken token);
    private void LogSystemMetrics(string measurementScope);
    private void RunCoreOperation(InstallOperation coreOperation, ExecuteAction action, ITelemetryOperation telemetryOperation, CancellationToken token);
    public sealed virtual IInstance Repair(CancellationToken token);
    public sealed virtual void Uninstall(CancellationToken token);
    public sealed virtual void SetRunOnceInformation(string processPath, string arguments);
    public sealed virtual void SetTelemetryContext(TelemetryContext context);
    public sealed virtual RegisteredProductInfo GetRegisteredProduct();
    internal void GetDefaultNgenApplication(string installDir, Product product);
    private static void LogHeader(ILogger logger);
    private IDictionary`2<string, object> InitializeTelemetryProperties(string operation);
    private void SetInInstallFromLayoutMode(bool value);
    private void AddChannelVariables(string channelId, string installChannelUri, string channelUri, string channelManifestId);
    private Uri SelectChannelUri(Uri channelUri, Uri installChannelUri);
    private string CacheCatalogUsingChannelManager(Uri channelUri, Uri installChannelUri);
    private string DownloadCatalogUsingManifestUri(Uri manifestUri, CancellationToken token);
    private void AddParentCorrelation(IDependencyGraph graph, RequestedState filter);
    private void AddAncestorWorkloads(IEnumerable`1<IDependencyArc> parents, IList`1<string> ancestors, RequestedState filter);
    public sealed virtual void Initialize();
    private void AddAdditionalProperties(IInstance instance);
    private void AddPropertiesFromPolicy();
    private IEnumerable`1<IPackage> GetInstancePackages();
    private IEnumerable`1<IPackage> GetAllCachedPackages();
    private void CheckForEngineUpdate(Version manifestEngineVersion);
    private ILogger AggregateLogger(ILogger clientLogger);
    private void UpdateInstanceAndAddOperationalVariables(Product product, string productId, IEnumerable`1<IPackage> packages, string destination, ExecuteAction action);
    private void AddOperationalVariables(Product product, string productId, IEnumerable`1<IPackage> packages, string destination, ExecuteAction action, string installationVersion, string enginePath);
    private bool TryGetDefaultChannelInformation(string productId, Uri& defaultUpdateChannelUri, Uri& defaultInstallChannelUri, String& defaultChannelId);
    private string GetCurrentUILanguage();
    private bool TryBuildDependencyGraph(Product product, Exception& error, bool overwrite, ITelemetryOperation telemetryOperation);
    private void BuildDependencyGraph(Product product, bool overwrite, ITelemetryOperation telemetryOperation);
    private IDependencyGraph GetDependencyGraph(Product product);
    private void Dispose(bool disposing);
    private void CleanupTempFiles();
    private InstallOperation CreateInstallOperation(Product product, string destination, ExecuteAction action, ITelemetryOperation telemetryOperation);
    private void SetRootRequestedState(IDependencyNode root, ExecuteAction action);
    private void UpdateInstance(Product product, string destination, ExecuteAction action, string installationVersion, String& enginePath);
    private bool ShouldUpdateChannel(IInstance instance);
    private bool ShouldUpdateDate(Version instanceProductVersion, Version productVersion);
    private void RunOperation(InstallOperation installOperation, CancellationToken token, ExecuteAction action, ITelemetryOperation telemetryOperation);
    internal bool TryDisableWindowsUpdate(ITelemetryOperation telemetryOperation, bool keepWindowsUpdateOn);
    private void AddPolicyProperties(ITelemetryOperation telemetryOperation);
    private void LogEnvironmentVariables();
    private void LogPolicySettings();
    private void AddOperationEndProperties(ITelemetryOperation telOperation, InstallOperation operationPerformed);
    private void SetLayoutDirectoryForInstall(IInstance instance);
    private void SetLayoutUriForInstall(IInstance instance);
    private void TrySetLayoutDirectoryFromInstance(IInstance instance);
    private void TrySetLayoutUriFromInstance(IInstance instance);
    private void AddCEIPProperties();
    private void UpdateInstanceSeed(Instance instance);
    private void UpdatePropertiesFromInstance(IInstance instance);
    private void LoadChannel(Uri channelUri, Uri installChannelUri);
    private void LoadChannel(Uri channelUri);
    private void LoadChannel(string channelId);
    private void SetDriveState(string installDir);
    private void RunPrecheck(string destination, Product product, ExecuteAction action, IWindowsRestartManager rmService, ITelemetryOperation installOperation, InstallOperation install);
    private PrecheckParameters SetupPrecheckParameters(string destination, Product product, ExecuteAction action, ITelemetryOperation telemetryOperation, InstallOperation install);
    private IEnumerable`1<ISelectablePackage> GetOutOfSupportSelectables();
    private bool IsOperation(KnownOperation operation);
    private void ResetDependencyGraph();
    private void UpdateExtensions(ExtensionApplicabilityArtifacts artifacts);
    private IChannelManifest get_TargetChannelManifest();
    private string get_ChannelId();
    private Uri get_ChannelUri();
    private Uri get_InstallChannelUri();
    private void TryRestartRmService(IWindowsRestartManager rmService);
    private void ConfigureSignatureVerifier(CatalogInfo catalogInfo);
    private bool TryResolveDirectory(string path, String& resolvedPath);
    private IDependencyGraph get_DependencyGraph();
    private void set_DependencyGraph(IDependencyGraph value);
    [CompilerGeneratedAttribute]
private IFileSystem <Initialize>b__172_0();
    [CompilerGeneratedAttribute]
private IReparseAwareFileSystem <Initialize>b__172_1();
    [CompilerGeneratedAttribute]
private IOperatingSystem <Initialize>b__172_5();
    [CompilerGeneratedAttribute]
private IPolicyService <Initialize>b__172_6();
    [CompilerGeneratedAttribute]
private IRestartManager <Initialize>b__172_7();
    [CompilerGeneratedAttribute]
private IManifestValidatorFactory <Initialize>b__172_10();
    [CompilerGeneratedAttribute]
private ILockService <Initialize>b__172_12();
    [CompilerGeneratedAttribute]
private IDownloadManager <Initialize>b__172_13();
    [CompilerGeneratedAttribute]
private IDependencyManager <Initialize>b__172_16();
    [CompilerGeneratedAttribute]
private IInstanceReferenceManager <Initialize>b__172_17();
    [CompilerGeneratedAttribute]
private IWindowsInstallerService <Initialize>b__172_18();
    [CompilerGeneratedAttribute]
private INgenService <Initialize>b__172_19();
    [CompilerGeneratedAttribute]
private IPackageDetectionService <Initialize>b__172_20();
    [CompilerGeneratedAttribute]
private IAccountProfileService <Initialize>b__172_22();
    [CompilerGeneratedAttribute]
private ICacheManager <Initialize>b__172_23();
}
public class Microsoft.VisualStudio.Setup.EngineDriveInfo : object {
    [CompilerGeneratedAttribute]
private bool <IsTargetAndSystemDriveDifferent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSharedAndSystemDriveDifferent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSharedAndTargetDriveDifferent>k__BackingField;
    internal bool IsTargetAndSystemDriveDifferent { get; }
    internal bool IsSharedAndSystemDriveDifferent { get; }
    internal bool IsSharedAndTargetDriveDifferent { get; }
    public EngineDriveInfo(bool targetSystem, bool sharedSystem, bool sharedTarget);
    [CompilerGeneratedAttribute]
internal bool get_IsTargetAndSystemDriveDifferent();
    [CompilerGeneratedAttribute]
internal bool get_IsSharedAndSystemDriveDifferent();
    [CompilerGeneratedAttribute]
internal bool get_IsSharedAndTargetDriveDifferent();
}
public class Microsoft.VisualStudio.Setup.EngineFactory : object {
    [CompilerGeneratedAttribute]
private string <CampaignId>k__BackingField;
    public string CampaignId { get; }
    public EngineFactory(string campaignId);
    [CompilerGeneratedAttribute]
public string get_CampaignId();
    public sealed virtual IEngine Create(IServiceProvider serviceProvider, string instanceId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.VisualStudio.Setup.EngineInfo : object {
    [CompilerGeneratedAttribute]
private static string <EngineVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <EngineFileVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <AssemblyName>k__BackingField;
    internal static string EngineVersion { get; private set; }
    internal static string EngineFileVersion { get; private set; }
    internal static string Title { get; private set; }
    internal static string AssemblyName { get; private set; }
    private static EngineInfo();
    [CompilerGeneratedAttribute]
internal static string get_EngineVersion();
    [CompilerGeneratedAttribute]
private static void set_EngineVersion(string value);
    [CompilerGeneratedAttribute]
internal static string get_EngineFileVersion();
    [CompilerGeneratedAttribute]
private static void set_EngineFileVersion(string value);
    [CompilerGeneratedAttribute]
internal static string get_Title();
    [CompilerGeneratedAttribute]
private static void set_Title(string value);
    [CompilerGeneratedAttribute]
internal static string get_AssemblyName();
    [CompilerGeneratedAttribute]
private static void set_AssemblyName(string value);
}
internal class Microsoft.VisualStudio.Setup.ErrorReporter : object {
    private static int IndentSize;
    private ICacheManager cacher;
    private IFileSystem fileSystem;
    private IEngineContext engineContext;
    internal ErrorReporter(IServiceProvider services, IEngineContext engineContext);
    internal static void ParseDownloadFailure(DownloadPackage download, String& errorCode, String& description, IEnumerable`1& nonLocalizedDetails, IEnumerable`1& localizedDetails);
    private void AddPackageFailureToInstance(FailedPackageReference failedPackageReference);
    internal void AddInstallFailureToInstance(Install install, string returnCode);
    private void AddInstallResultDetails(InstallResult installResult, IList`1<string> details);
    internal void AddDownloadFailureToInstance(DownloadPackage download, string returnCode, string description, IEnumerable`1<string> details);
    internal void AddProductCommandFailureToInstance(RunProductCommand runProductCommand);
    private void AddExtFinalizerFailureToInstance(ExtensibilityFinalize extFinalizer);
    internal void GenerateErrorReport(IEnumerable`1<IPackage> packages);
    private void WriteIndent(TextWriter writer, int indent);
    private void WriteValue(TextWriter writer, string value, string header, int indent);
    private void WriteList(TextWriter writer, IEnumerable`1<string> items, int indent);
    private string GetDisplayName(IPackageIdentity packageIdentity, IDictionary`2<IPackageIdentity, IPackage> packageLookup);
    private void WritePackageList(TextWriter writer, string header, IEnumerable`1<IPackageIdentity> packages, IDictionary`2<IPackageIdentity, IPackage> packageLookup, int indent);
    private void WriteFailedPackage(TextWriter writer, FailedPackageReference failedPackage, IDictionary`2<IPackageIdentity, IPackage> packageLookup);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Setup.EvaluatedInstallSizes : object {
    public static Lazy`1<IEvaluatedInstallSizes> Empty;
    [NullableAttribute("2")]
private IPolicyService policyService;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, DriveSpaceEvaluation> <InstallSizes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasSufficientDiskSpace>k__BackingField;
    public IDictionary`2<string, DriveSpaceEvaluation> InstallSizes { get; }
    public bool HasSufficientDiskSpace { get; }
    public EvaluatedInstallSizes(IServiceProvider services, InstallSize size, string targetInstallDirectory, VariableCollection properties, string cachePath, string sharedPath, long additionalBuffer);
    private static EvaluatedInstallSizes();
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, DriveSpaceEvaluation> get_InstallSizes();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasSufficientDiskSpace();
    private void SetSizeMembers(long actual, long delta, string drivename, DrivePathType segmentType);
}
public class Microsoft.VisualStudio.Setup.EventHandler`2 : MulticastDelegate {
    public EventHandler`2(object object, IntPtr method);
    public virtual void Invoke(TSender sender, TArgs e);
    public virtual IAsyncResult BeginInvoke(TSender sender, TArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.ExportData : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <SelectedPackageIds>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <ExtensionData>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public IEnumerable`1<string> SelectedPackageIds { get; public set; }
    public IEnumerable`1<string> ExtensionData { get; public set; }
    public ExportData(IEnumerable`1<string> SelectedPackageIds, IEnumerable`1<string> ExtensionData);
    [CompilerGeneratedAttribute]
protected ExportData(ExportData original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_SelectedPackageIds();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SelectedPackageIds(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_ExtensionData();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ExtensionData(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(ExportData left, ExportData right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(ExportData left, ExportData right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(ExportData other);
    [CompilerGeneratedAttribute]
public virtual ExportData <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(IEnumerable`1& SelectedPackageIds, IEnumerable`1& ExtensionData);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Extension.AddExtensionsResult : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<Uri, ExtensionContents> <AddedExtensions>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <ExistingExtensions>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public IDictionary`2<Uri, ExtensionContents> AddedExtensions { get; public set; }
    public IEnumerable`1<string> ExistingExtensions { get; public set; }
    public AddExtensionsResult(IDictionary`2<Uri, ExtensionContents> AddedExtensions, IEnumerable`1<string> ExistingExtensions);
    [CompilerGeneratedAttribute]
protected AddExtensionsResult(AddExtensionsResult original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public IDictionary`2<Uri, ExtensionContents> get_AddedExtensions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AddedExtensions(IDictionary`2<Uri, ExtensionContents> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_ExistingExtensions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ExistingExtensions(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(AddExtensionsResult left, AddExtensionsResult right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(AddExtensionsResult left, AddExtensionsResult right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(AddExtensionsResult other);
    [CompilerGeneratedAttribute]
public virtual AddExtensionsResult <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(IDictionary`2& AddedExtensions, IEnumerable`1& ExistingExtensions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Extension.ExtensionCache : object {
    private Dictionary`2<Uri, LocalExtension> extensions;
    [NullableAttribute("2")]
private string extensionsDir;
    private IFileSystem fileSystem;
    public ExtensionCache(IFileSystem fileSystem);
    public sealed virtual bool TryGetExtension(Uri extensionUri, ExtensionContents& extensionContents);
    public sealed virtual void CacheExtension(Uri extensionUri, ExtensionContents extensionContents, Stream extensionStream);
    public sealed virtual string GetExtensionPath(Uri extensionUri);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Setup.Extension.ExtensionContents : object {
    [CompilerGeneratedAttribute]
private string <CatalogJson>k__BackingField;
    [CompilerGeneratedAttribute]
private VsixType <Type>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ExtensionManifest <ExtensionManifest>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsExtensionPack>k__BackingField;
    public string CatalogJson { get; public set; }
    public VsixType Type { get; }
    [NullableAttribute("2")]
public ExtensionManifest ExtensionManifest { get; }
    public bool IsExtensionPack { get; }
    public ExtensionContents(string catalogJson, VsixType type, ExtensionManifest extensionManifest, bool isExtensionPack);
    [CompilerGeneratedAttribute]
public string get_CatalogJson();
    [CompilerGeneratedAttribute]
public void set_CatalogJson(string value);
    [CompilerGeneratedAttribute]
public VsixType get_Type();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ExtensionManifest get_ExtensionManifest();
    [CompilerGeneratedAttribute]
public bool get_IsExtensionPack();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Extension.ExtensionDisplayInformation : object {
    [CompilerGeneratedAttribute]
private Uri <Uri>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ExtensionOrigin <Origin>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Uri Uri { get; public set; }
    [NullableAttribute("2")]
public string Name { get; public set; }
    public ExtensionOrigin Origin { get; public set; }
    public ExtensionDisplayInformation(Uri Uri, string Name, ExtensionOrigin Origin);
    [CompilerGeneratedAttribute]
protected ExtensionDisplayInformation(ExtensionDisplayInformation original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Uri get_Uri();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Uri(Uri value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Name();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Name(string value);
    [CompilerGeneratedAttribute]
public ExtensionOrigin get_Origin();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Origin(ExtensionOrigin value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(ExtensionDisplayInformation left, ExtensionDisplayInformation right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(ExtensionDisplayInformation left, ExtensionDisplayInformation right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(ExtensionDisplayInformation other);
    [CompilerGeneratedAttribute]
public virtual ExtensionDisplayInformation <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Uri& Uri, String& Name, ExtensionOrigin& Origin);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Extension.ExtensionDownloadSummary : object {
    [CompilerGeneratedAttribute]
private bool <IsSuccess>k__BackingField;
    [CompilerGeneratedAttribute]
private VerificationResult <VerificationResult>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate2 <Certificate>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public bool IsSuccess { get; public set; }
    public VerificationResult VerificationResult { get; public set; }
    public X509Certificate2 Certificate { get; public set; }
    public ExtensionDownloadSummary(bool IsSuccess, VerificationResult VerificationResult, X509Certificate2 Certificate);
    [CompilerGeneratedAttribute]
protected ExtensionDownloadSummary(ExtensionDownloadSummary original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public bool get_IsSuccess();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsSuccess(bool value);
    [CompilerGeneratedAttribute]
public VerificationResult get_VerificationResult();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_VerificationResult(VerificationResult value);
    [CompilerGeneratedAttribute]
public X509Certificate2 get_Certificate();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Certificate(X509Certificate2 value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ExtensionDownloadSummary left, ExtensionDownloadSummary right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ExtensionDownloadSummary left, ExtensionDownloadSummary right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(ExtensionDownloadSummary other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual ExtensionDownloadSummary <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Boolean& IsSuccess, VerificationResult& VerificationResult, X509Certificate2& Certificate);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Extension.ExtensionQueryResult : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<ExtensionDisplayInformation> <ExtensionSummaries>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<FailedExtensionDisplayInformation> <FailedExtensions>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public IEnumerable`1<ExtensionDisplayInformation> ExtensionSummaries { get; public set; }
    public IEnumerable`1<FailedExtensionDisplayInformation> FailedExtensions { get; public set; }
    public ExtensionQueryResult(IEnumerable`1<ExtensionDisplayInformation> ExtensionSummaries, IEnumerable`1<FailedExtensionDisplayInformation> FailedExtensions);
    [CompilerGeneratedAttribute]
protected ExtensionQueryResult(ExtensionQueryResult original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public IEnumerable`1<ExtensionDisplayInformation> get_ExtensionSummaries();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ExtensionSummaries(IEnumerable`1<ExtensionDisplayInformation> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<FailedExtensionDisplayInformation> get_FailedExtensions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FailedExtensions(IEnumerable`1<FailedExtensionDisplayInformation> value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(ExtensionQueryResult left, ExtensionQueryResult right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(ExtensionQueryResult left, ExtensionQueryResult right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(ExtensionQueryResult other);
    [CompilerGeneratedAttribute]
public virtual ExtensionQueryResult <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(IEnumerable`1& ExtensionSummaries, IEnumerable`1& FailedExtensions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Setup.Extension.ExtensionService : object {
    private static string VisualStudioExtensibilityType;
    private static string ExtensionPackManifestFileExtension;
    private static string CatalogPartPath;
    private static Uri ExtensionManifestPartUri;
    private static string DotNetFrameworkIdentifier;
    private static string MPFDependencyStartsWith;
    private static VersionRange VersionRangeToIgnoreMPFDependency;
    private IFileSystem fileSystem;
    private Lazy`1<IDownloadManager> lazyDownloadManager;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<ILogger> lazyLogger;
    private Lazy`1<ISignatureVerifierManager> lazySignatureManager;
    private Lazy`1<VsixInstaller> lazyVsixInstaller;
    private string tempRoot;
    private IServiceProvider services;
    private bool disposed;
    public ExtensionService(IServiceProvider services);
    private static ExtensionService();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Extension.ExtensionService/<Microsoft-VisualStudio-Setup-Extension-IExtensionServiceInternal-DownloadAsync>d__15")]
private sealed virtual override Task`1<ExtensionDownloadSummary> Microsoft.VisualStudio.Setup.Extension.IExtensionServiceInternal.DownloadAsync(Uri uri, Stream downloadStream, CancellationToken token);
    public sealed virtual ExtensionContents ParseExtension(Stream vsixStream);
    public sealed virtual SupportedExtensionResult IsSupportedExtension(ExtensionContents contents);
    public sealed virtual bool IsExtensionHotloadable(ExtensionContents contents);
    public sealed virtual bool ProductSupportsExtension(ExtensionContents contents, string productId, Version productVersion, string productArch);
    private sealed virtual override IEnumerable`1<ExtensionDependency> Microsoft.VisualStudio.Setup.Extension.IExtensionServiceInternal.ParseExtensionDependencies(ExtensionContents contents);
    private sealed virtual override Stream Microsoft.VisualStudio.Setup.Extension.IExtensionServiceInternal.GetEmbeddedExtensionStream(Stream vsixStream, string embeddedPath);
    private sealed virtual override bool Microsoft.VisualStudio.Setup.Extension.IExtensionServiceInternal.TryAddInstalledExtensionDependency(IDependencyGraph dependencyGraph, ExtensionContents extensionContents, ExtensionDependency extensionDependency);
    private sealed virtual override bool Microsoft.VisualStudio.Setup.Extension.IExtensionServiceInternal.TryAddExtensionDependencyToCatalog(ExtensionContents parentContents, ExtensionContents embeddedContents, ExtensionDependency extensionDependency);
    private bool AddExtensionDependency(ExtensionContents parentContents, Component dependencyComponent, ExtensionDependency extensionDependency);
    private Stream GetExtensionPart(Stream vsixStream, string partPath, ExtensionManifest& extensionManifest, Boolean& isExtensionPack);
    private ExtensionManifest GetExtensionManifest(Package package);
    private bool GetIsExtensionPack(Package package);
    private bool IsExtensionDependency(ExtensionDependency dependency);
    private void WriteVerbose(string message, Object[] args);
    private void WriteWarning(string message, Object[] args);
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    private sealed virtual override void System.IDisposable.Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.VisualStudio.Setup.Extension.ExtensionsHelper : object {
    private static IDictionary`2<string, string> productIdToTargetMapping;
    private static IDictionary`2<string, VSExtensionTarget> targetIdToSkuMapping;
    private static IDictionary`2<string, string> productArchMapping;
    private static ExtensionsHelper();
    public static bool TryGetTargetForProductId(string productId, VSExtensionTarget& extensionTarget);
    [NullableContextAttribute("2")]
public static bool TryGetTargetForTargetId(string targetId, VSExtensionTarget& extensionTarget);
    public static bool IsSupportedTarget(VSExtensionTarget installationTarget, VSExtensionTarget supportedTarget);
    [NullableContextAttribute("2")]
public static bool IsProductArchSupported(string productArch, string targetArch);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Extension.FailedExtensionDisplayInformation : object {
    [CompilerGeneratedAttribute]
private string <ExtensionName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPublic>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public string ExtensionName { get; public set; }
    public bool IsPublic { get; public set; }
    public FailedExtensionDisplayInformation(string ExtensionName, bool IsPublic);
    [CompilerGeneratedAttribute]
protected FailedExtensionDisplayInformation(FailedExtensionDisplayInformation original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public string get_ExtensionName();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ExtensionName(string value);
    [CompilerGeneratedAttribute]
public bool get_IsPublic();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsPublic(bool value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(FailedExtensionDisplayInformation left, FailedExtensionDisplayInformation right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(FailedExtensionDisplayInformation left, FailedExtensionDisplayInformation right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(FailedExtensionDisplayInformation other);
    [CompilerGeneratedAttribute]
public virtual FailedExtensionDisplayInformation <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(String& ExtensionName, Boolean& IsPublic);
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Setup.Extension.IExtensionCache {
    public abstract virtual void CacheExtension(Uri extensionUri, ExtensionContents extensionContents, Stream extensionStream);
    public abstract virtual string GetExtensionPath(Uri extensionUri);
    public abstract virtual bool TryGetExtension(Uri extensionUri, ExtensionContents& extensionContents);
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.Setup.Extension.IExtensionService {
    public abstract virtual ExtensionContents ParseExtension(Stream vsixStream);
    public abstract virtual bool IsExtensionHotloadable(ExtensionContents contents);
    public abstract virtual SupportedExtensionResult IsSupportedExtension(ExtensionContents extensionContents);
    public abstract virtual bool ProductSupportsExtension(ExtensionContents contents, string productId, Version productVersion, string productArch);
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Setup.Extension.IExtensionServiceInternal {
    public abstract virtual Task`1<ExtensionDownloadSummary> DownloadAsync(Uri uri, Stream downloadStream, CancellationToken token);
    public abstract virtual IEnumerable`1<ExtensionDependency> ParseExtensionDependencies(ExtensionContents contents);
    public abstract virtual Stream GetEmbeddedExtensionStream(Stream vsixStream, string embeddedPath);
    public abstract virtual bool TryAddInstalledExtensionDependency(IDependencyGraph dependencyGraph, ExtensionContents parentExtensionContents, ExtensionDependency extensionDependency);
    public abstract virtual bool TryAddExtensionDependencyToCatalog(ExtensionContents parentContents, ExtensionContents dependencyContents, ExtensionDependency extensionDependency);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[XmlTypeAttribute]
public class Microsoft.VisualStudio.Setup.Extension.Serialization.ExtensionDependency : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRequired>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private XmlAttribute[] <OtherAttributes>k__BackingField;
    [XmlAttributeAttribute]
public string Id { get; public set; }
    [XmlAttributeAttribute]
public string Location { get; public set; }
    [XmlAttributeAttribute]
public string Version { get; public set; }
    [XmlAttributeAttribute]
[DefaultValueAttribute("True")]
public bool IsRequired { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[XmlAnyAttributeAttribute]
public XmlAttribute[] OtherAttributes { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_Location();
    [CompilerGeneratedAttribute]
public void set_Location(string value);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public bool get_IsRequired();
    [CompilerGeneratedAttribute]
public void set_IsRequired(bool value);
    [CompilerGeneratedAttribute]
public XmlAttribute[] get_OtherAttributes();
    [CompilerGeneratedAttribute]
public void set_OtherAttributes(XmlAttribute[] value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[XmlRootAttribute]
public class Microsoft.VisualStudio.Setup.Extension.Serialization.ExtensionManifest : object {
    [CompilerGeneratedAttribute]
private Metadata <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private InstallationInformation <InstallationInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ExtensionDependency[] <Dependencies>k__BackingField;
    public Metadata Metadata { get; public set; }
    [XmlElementAttribute]
public InstallationInformation InstallationInformation { get; public set; }
    [XmlAttributeAttribute]
public string Version { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[XmlArrayAttribute]
[XmlArrayItemAttribute]
public ExtensionDependency[] Dependencies { get; public set; }
    [CompilerGeneratedAttribute]
public Metadata get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(Metadata value);
    [CompilerGeneratedAttribute]
public InstallationInformation get_InstallationInformation();
    [CompilerGeneratedAttribute]
public void set_InstallationInformation(InstallationInformation value);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public ExtensionDependency[] get_Dependencies();
    [CompilerGeneratedAttribute]
public void set_Dependencies(ExtensionDependency[] value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[XmlTypeAttribute]
public class Microsoft.VisualStudio.Setup.Extension.Serialization.InstallationInformation : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private InstallationTarget[] <InstallationTargets>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SystemComponent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllUsers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Experimental>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExtensionType>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private XmlElement[] <OtherElements>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private XmlAttribute[] <OtherAttributes>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[XmlElementAttribute("InstallationTarget")]
public InstallationTarget[] InstallationTargets { get; public set; }
    [XmlAttributeAttribute]
public bool SystemComponent { get; public set; }
    [XmlAttributeAttribute]
public bool AllUsers { get; public set; }
    [XmlAttributeAttribute]
public bool Experimental { get; public set; }
    [XmlAttributeAttribute]
public string ExtensionType { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[XmlAnyElementAttribute]
public XmlElement[] OtherElements { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[XmlAnyAttributeAttribute]
public XmlAttribute[] OtherAttributes { get; public set; }
    [CompilerGeneratedAttribute]
public InstallationTarget[] get_InstallationTargets();
    [CompilerGeneratedAttribute]
public void set_InstallationTargets(InstallationTarget[] value);
    [CompilerGeneratedAttribute]
public bool get_SystemComponent();
    [CompilerGeneratedAttribute]
public void set_SystemComponent(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllUsers();
    [CompilerGeneratedAttribute]
public void set_AllUsers(bool value);
    [CompilerGeneratedAttribute]
public bool get_Experimental();
    [CompilerGeneratedAttribute]
public void set_Experimental(bool value);
    [CompilerGeneratedAttribute]
public string get_ExtensionType();
    [CompilerGeneratedAttribute]
public void set_ExtensionType(string value);
    [CompilerGeneratedAttribute]
public XmlElement[] get_OtherElements();
    [CompilerGeneratedAttribute]
public void set_OtherElements(XmlElement[] value);
    [CompilerGeneratedAttribute]
public XmlAttribute[] get_OtherAttributes();
    [CompilerGeneratedAttribute]
public void set_OtherAttributes(XmlAttribute[] value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[XmlTypeAttribute]
public class Microsoft.VisualStudio.Setup.Extension.Serialization.InstallationTarget : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetPlatformIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetPlatformVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SdkName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SdkVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProductArchitecture>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private XmlElement[] <OtherElements>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private XmlAttribute[] <OtherAttributes>k__BackingField;
    [XmlAttributeAttribute]
public string Id { get; public set; }
    [XmlAttributeAttribute]
public string Version { get; public set; }
    [XmlAttributeAttribute]
public string TargetPlatformIdentifier { get; public set; }
    [XmlAttributeAttribute]
public string TargetPlatformVersion { get; public set; }
    [XmlAttributeAttribute]
public string SdkName { get; public set; }
    [XmlAttributeAttribute]
public string SdkVersion { get; public set; }
    [XmlElementAttribute]
public string ProductArchitecture { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[XmlAnyElementAttribute]
public XmlElement[] OtherElements { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[XmlAnyAttributeAttribute]
public XmlAttribute[] OtherAttributes { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public string get_TargetPlatformIdentifier();
    [CompilerGeneratedAttribute]
public void set_TargetPlatformIdentifier(string value);
    [CompilerGeneratedAttribute]
public string get_TargetPlatformVersion();
    [CompilerGeneratedAttribute]
public void set_TargetPlatformVersion(string value);
    [CompilerGeneratedAttribute]
public string get_SdkName();
    [CompilerGeneratedAttribute]
public void set_SdkName(string value);
    [CompilerGeneratedAttribute]
public string get_SdkVersion();
    [CompilerGeneratedAttribute]
public void set_SdkVersion(string value);
    [CompilerGeneratedAttribute]
public string get_ProductArchitecture();
    [CompilerGeneratedAttribute]
public void set_ProductArchitecture(string value);
    [CompilerGeneratedAttribute]
public XmlElement[] get_OtherElements();
    [CompilerGeneratedAttribute]
public void set_OtherElements(XmlElement[] value);
    [CompilerGeneratedAttribute]
public XmlAttribute[] get_OtherAttributes();
    [CompilerGeneratedAttribute]
public void set_OtherAttributes(XmlAttribute[] value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[XmlTypeAttribute]
public class Microsoft.VisualStudio.Setup.Extension.Serialization.Metadata : object {
    [CompilerGeneratedAttribute]
private string <MoreInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <License>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private XmlElement[] <OtherElements>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private XmlAttribute[] <OtherAttributes>k__BackingField;
    public string MoreInfo { get; public set; }
    public string License { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[XmlAnyElementAttribute]
public XmlElement[] OtherElements { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[XmlAnyAttributeAttribute]
public XmlAttribute[] OtherAttributes { get; public set; }
    [CompilerGeneratedAttribute]
public string get_MoreInfo();
    [CompilerGeneratedAttribute]
public void set_MoreInfo(string value);
    [CompilerGeneratedAttribute]
public string get_License();
    [CompilerGeneratedAttribute]
public void set_License(string value);
    [CompilerGeneratedAttribute]
public XmlElement[] get_OtherElements();
    [CompilerGeneratedAttribute]
public void set_OtherElements(XmlElement[] value);
    [CompilerGeneratedAttribute]
public XmlAttribute[] get_OtherAttributes();
    [CompilerGeneratedAttribute]
public void set_OtherAttributes(XmlAttribute[] value);
}
public enum Microsoft.VisualStudio.Setup.Extension.SupportedExtensionResult : Enum {
    public int value__;
    public static SupportedExtensionResult Supported;
    public static SupportedExtensionResult UnsupportedType;
    public static SupportedExtensionResult UnsupportedProduct;
}
[FlagsAttribute]
internal enum Microsoft.VisualStudio.Setup.Extension.VSExtensionTarget : Enum {
    public int value__;
    public static VSExtensionTarget VSWinDesktopExpress;
    public static VSExtensionTarget ExpressAll;
    public static VSExtensionTarget Enterprise;
    public static VSExtensionTarget Ultimate;
    public static VSExtensionTarget Premium;
    public static VSExtensionTarget Professional;
    public static VSExtensionTarget Community;
    public static VSExtensionTarget VSLS;
    public static VSExtensionTarget TeamExplorer;
    public static VSExtensionTarget SQL;
    public static VSExtensionTarget IntegratedShell;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.ExtensionApplicabilityArtifacts : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Branch>k__BackingField;
    public string Id { get; }
    public string Name { get; }
    public Version Version { get; }
    public string Branch { get; }
    [NullableContextAttribute("1")]
internal ExtensionApplicabilityArtifacts(Catalog catalog);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual Version get_Version();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Branch();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Microsoft.VisualStudio.Setup.Extensions : object {
    private static int DefaultRetryCount;
    private static int DefaultRetryDelay;
    private static char Escape;
    private static char VariableStart;
    private static char VariableEnd;
    private static string ProgramFiles64Env;
    private static string ProgramFiles;
    private static string ProgramFilesX86;
    private static string ProgramFiles64;
    private static string ProgramFilesX64;
    private static string CommonProgramFiles64Env;
    private static string CommonProgramFiles;
    private static string CommonProgramFilesX86;
    private static string CommonProgramFiles64;
    private static string CommonProgramFilesX64;
    private static string ProgramData;
    private static string SystemToken;
    private static string SystemFolder;
    private static string SystemX86;
    private static string System64;
    private static string SystemX64;
    private static string Windows;
    private static string FolderSuffix;
    private static string VSIXInstallerExeName;
    private static CultureInfo DefaultLocale;
    private static IEnumerable`1<string> EnglishFallbackLocales;
    private static Int32[] SupportedLCIDs;
    private static int SimplifiedChineseLCID;
    private static int TraditionalChineseLCID;
    private static int MandarinTraditionalChineseLCID;
    private static int MandarinSimplifiedChineseLCID;
    private static int ChineseLCID;
    [NullableAttribute("2")]
private static ConditionEvaluatorFactory conditionEvaluatorFactory;
    private static Extensions();
    private static IReadOnlyDictionary`2<string, Func`1<string>> GetSpecialFolders(IFileSystem fileSystem);
    [ExtensionAttribute]
internal static void SetChipAndMachineArch(DependencyComparisonSeed seed, IMachineService machineService);
    [ExtensionAttribute]
public static void RemoveAllChannels(IChannelManager channelManager, IServiceProvider serviceProvider);
    [ExtensionAttribute]
public static void AddRange(IProducerConsumerCollection`1<T> source, IEnumerable`1<T> items);
    [ExtensionAttribute]
internal static void TryQuarantinePayloadFile(IFileSystem filesystem, IServiceProvider serviceProvider, string payloadFile);
    [ExtensionAttribute]
internal static bool FileContentsAreEqual(IFileSystem myFileSystem, IHashingService hashingService, string firstFile, string secondFile);
    [ExtensionAttribute]
public static bool IsMeteredConnection(IOperatingSystem operatingSystem);
    [ExtensionAttribute]
internal static void ParseUnhandledExceptionObject(UnhandledExceptionEventArgs args, String& message, ErrorCode& errorCode);
    [ExtensionAttribute]
public static bool IsLayoutPath(Uri uri);
    [ExtensionAttribute]
internal static bool IsLayoutChannel(IChannelManifest channelManifest);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsMicrosoftChannelUri(Uri uri);
    [ExtensionAttribute]
internal static string GetWebLayoutOpcUrl(Uri uri);
    [ExtensionAttribute]
internal static bool IsWebLayoutChannel(IChannelManifest channelManifest);
    [ExtensionAttribute]
internal static bool IsWindows7(IOperatingSystem operatingSystem);
    [ExtensionAttribute]
internal static string GetNeutralMessage(VerificationInformation information, bool isTelemetryMessage);
    [ExtensionAttribute]
internal static string GetFailureSignature(IPackage package, string packageAction, string returnCode);
    [ExtensionAttribute]
internal static string ReplaceVariables(string value, Dictionary`2<string, string> properties, ISet`1<string> variablesToIgnore, bool recursive);
    [ExtensionAttribute]
internal static string ReplaceVariables(string value, IDictionary`2<string, string> properties, ISet`1<string> variablesToIgnore, bool recursive);
    [ExtensionAttribute]
internal static string ReplaceVariables(string value, IReadOnlyDictionary`2<string, string> properties, ISet`1<string> variablesToIgnore, bool recursive, IFileSystem fileSystem);
    [ExtensionAttribute]
internal static IEnumerable`1<string> GetNonCriticalProcesses(ISet`1<IPackage> packages);
    [ExtensionAttribute]
internal static IEnumerable`1<ISelectablePackage> OutOfSupportSelectables(ISet`1<IPackage> packages, ILogger logger);
    [ExtensionAttribute]
internal static bool InDownloadThenInstallMode(IEngineContext engine);
    [ExtensionAttribute]
internal static bool IsPreDynamicEndpoint(IEngineContext engine);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static bool InDownloadOnlyMode(IEngineContext engine);
    [ExtensionAttribute]
internal static bool IsDownloaded(IInstance instance);
    [ExtensionAttribute]
internal static bool IsSelectionStateChanged(IInstance instance, Int32& currentSelectionStateHash);
    [ExtensionAttribute]
internal static bool IsPausedOperation(IInstance instance, ExecuteAction operation);
    [ExtensionAttribute]
internal static bool IsPausedOperation(IInstance instance, KnownOperation operation);
    [ExtensionAttribute]
private static bool IsPausedOperation(IInstance instance, string propertyName, string operation);
    [ExtensionAttribute]
internal static bool IsInstallStateChanged(IInstance instance, Func`2<IInstance, int> func, string propertyName, Int32& currentValue);
    private static int HashCurrentSelectionState(IInstance instance);
    private static bool TryResolveVariable(string name, IReadOnlyDictionary`2<string, string> properties, String& value, ISet`1<string> variablesToIgnore, IReadOnlyDictionary`2<string, Func`1<string>> specialFolders);
    private static bool IsValidVariableName(string name);
    private static bool TryGetSpecialFolder(IReadOnlyDictionary`2<string, Func`1<string>> specialFolders, string name, String& value);
    private static bool TryGetSpecialFolderHelper(IReadOnlyDictionary`2<string, Func`1<string>> specialFolders, string name, String& value);
    private static string GetProgramFilesFolder(IFileSystem fileSystem, string programFilesName);
    private static string GetCommonProgramFilesFolder(IFileSystem fileSystem, string commonProgramFilesName);
    private static string GetSystemFolder(IFileSystem fileSystem, string systemFolder);
    private static string AddDirSeparatorToPath(string path);
    [ExtensionAttribute]
internal static string FormattedSize(long sizeInBytes, CultureInfo culture);
    [ExtensionAttribute]
internal static bool HasExceptions(AggregateException source);
    [ExtensionAttribute]
public static bool IsExceptionType(Exception error);
    [ExtensionAttribute]
public static Exception TryGetWrappedException(Exception exception);
    [ExtensionAttribute]
public static IReadOnlyCollection`1<Exception> TryGetWrappedExceptions(Exception exception);
    [ExtensionAttribute]
internal static bool Evaluate(ConditionGroup group, IServiceProvider services, IDictionary`2<string, string> properties);
    [ExtensionAttribute]
public static Stream CreateFileWithRetry(IFileSystem fileSystem, string path, int retryCount, int retryDelay);
    [ExtensionAttribute]
public static TextWriter CreateTextWithRetry(IFileSystem fileSystem, string path, bool buffer, int retryCount, int retryDelay, bool createDirectory);
    [ExtensionAttribute]
public static string CreateTemporaryFolderInTempWithRetry(IFileSystem fileSystem, int retryCount, int retryDelay);
    [ExtensionAttribute]
public static void CopyFileWithRetry(IFileSystem fileSystem, string source, string destination, int retryCount, int retryDelay);
    [ExtensionAttribute]
public static void EnsureDirectoryEmpty(IFileSystem fileSystem, string directory);
    [ExtensionAttribute]
public static void MoveFileWithRetry(IFileSystem fileSystem, string source, string destination, bool replace, int retryCount, int retryDelay);
    [ExtensionAttribute]
public static void DeleteFileIfInTemp(IFileSystem fileSystem, string path);
    [ExtensionAttribute]
public static bool DeleteFileIfExists(IFileSystem fileSystem, string path, int retryCount, int retryDelay);
    [ExtensionAttribute]
public static bool DeleteFileWithLongRetry(IFileSystem fileSystem, string path, int retryCount, int retryDelay, ILogger logger);
    [ExtensionAttribute]
public static bool DeleteFileWithRetry(IFileSystem fileSystem, string path, Boolean& rebootRequired, bool rebootOK, int retryCount, int retryDelay, Func`3<Exception, int, bool> errorAction, ILogger logger);
    [ExtensionAttribute]
public static bool DeleteDirectoryWithRetry(IFileSystem fileSystem, string path, Boolean& rebootRequired, bool rebootOK, bool recursive, int retryCount, int retryDelay, Func`3<Exception, int, bool> errorAction);
    [ExtensionAttribute]
public static bool TryDeleteDirectoryWithRetry(IFileSystem fileSystem, string path, bool recursive, int retryCount, int retryDelay);
    [ExtensionAttribute]
public static bool DeleteEmptyAncestorsWithRetry(IFileSystem fileSystem, string path, bool rebootOK, int retryCount, int retryDelay);
    [ExtensionAttribute]
public static string GetExistingAncestor(IFileSystem fileSystem, string path);
    [ExtensionAttribute]
public static bool SetFileTimeWithRetry(IFileSystem fileSystem, string path, Nullable`1<DateTimeOffset> creationTime, Nullable`1<DateTimeOffset> lastWriteTime, int retryCount, int retryDelay, bool throwOnFailure);
    [ExtensionAttribute]
public static Task HideDirectoryAsync(IFileSystem fileSystem, string path, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static String[] ReadAllLines(IFileSystem fileSystem, string path);
    [ExtensionAttribute]
public static string ReadAllText(IFileSystem fileSystem, string path);
    [ExtensionAttribute]
public static void WriteAllBytes(IFileSystem fileSystem, string path, Byte[] buffer);
    [ExtensionAttribute]
public static void CreateFileFromStream(IFileSystem fileSystem, Stream input, string targetFile);
    [ExtensionAttribute]
internal static long GetSystemDriveFreeSpace(IFileSystem fileSystem);
    [ExtensionAttribute]
public static bool IsDirectoryEmpty(IFileSystem fileSystem, string path);
    [ExtensionAttribute]
public static bool IsDirectoryPresentAndEmpty(IFileSystem fileSystem, string path);
    [ExtensionAttribute]
internal static string GetInstallerPath(IFileSystem fileSystem);
    [ExtensionAttribute]
internal static CompatiblePresent IsCompatibleVersionPresent(IInstallablePackage package, Version& compatibleVersion);
    [ExtensionAttribute]
internal static Version GetPackageVersion(IInstallablePackage package);
    [ExtensionAttribute]
public static IEnumerable`1<IWindowsRestartManagerProcessInfo> GetProcesses(IWindowsRestartManagerFactory factory, IEnumerable`1<string> paths, IEnumerable`1<string> serviceNames, IServiceProvider services);
    [ExtensionAttribute]
internal static IInstallablePackage GetCompatiblePackage(IInstallablePackage package, ICacheManager cache);
    [ExtensionAttribute]
internal static bool IsExceptionCancelingOperation(Exception error);
    private static void UnsetReadOnly(IFileSystem fileSystem, string source, ILogger logger);
    private static bool ExecuteFileActionWithRetry(int retryCount, int retryDelay, Action fileAction, bool throwOnFailure, Func`3<Exception, int, bool> errorAction);
    private static bool TryExecuteFileActionWithRetry(int retryCount, int retryDelay, Action fileAction);
    private static bool MoveFile(IFileSystem fileSystem, string source, string destination, ILogger logger, bool afterReboot, bool replace);
    private static void ThrowLastIOException();
    [ExtensionAttribute]
internal static IEnumerable`1<string> GetLogPaths(LogFile logFile, IServiceProvider services, IDictionary`2<string, string> properites);
    [ExtensionAttribute]
internal static int GetPackagesHashCode(IEnumerable`1<IPackageIdentity> packages, IEqualityComparer`1<IPackageIdentity> comparer, int seed);
    [ExtensionAttribute]
internal static long GetTotalPackageSize(IEnumerable`1<IPackageProgress> packages);
    [ExtensionAttribute]
public static T AddServiceIfNotDefined(IServiceContainer services, Func`1<T> getter);
    [ExtensionAttribute]
public static T GetService(IServiceProvider provider, T& object, Func`1<T> getter);
    [ExtensionAttribute]
public static T GetService(IServiceProvider provider, T& object, bool throwIfNotDefined);
    [ExtensionAttribute]
private static T GetService(IServiceProvider provider, T& object, bool throwIfNotDefined, Func`1<T> getter);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Setup.Extensions/<SplitByLength>d__119")]
[ExtensionAttribute]
public static IEnumerable`1<string> SplitByLength(string str, int maxLength);
    [ExtensionAttribute]
internal static TelemetryResult ToTelemetryResult(Result result);
    [ExtensionAttribute]
public static VerificationInformation VerifyMicrosoftSignature(ISignatureVerifierManager signatureManager, Stream file, string path);
    [ExtensionAttribute]
public static VerificationInformation VerifyGitHubSignature(ISignatureVerifierManager signatureManager, Stream file, string path);
    [ExtensionAttribute]
public static CultureInfo GetSupportedLocale(CultureInfo locale);
    [ExtensionAttribute]
public static ChannelNode`1<IProductSummaryItem> GetChannelProductForInstance(IChannelManager channelManager, IInstance instance);
    [ExtensionAttribute]
public static ChannelManifestPair GetChannelForInstance(IChannelManager channelManager, IInstance instance, bool perUserChannelsOnly);
    [ExtensionAttribute]
public static bool TryGetLocalPath(IFileSystem fileSystem, Uri uri, String& localPath);
    [ExtensionAttribute]
public static void WriteAllText(IFileSystem fileSystem, string path, string text);
    [ExtensionAttribute]
internal static Uri Combine(Uri uri, String[] additionalParts);
    private static bool ShouldFallbackToEnglish(CultureInfo locale);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static string GetLogFilePath(ILogger logger);
    [ExtensionAttribute]
internal static string GetFilePath(FileStream fileStream);
    [ExtensionAttribute]
internal static string GetVSIXInstallerPath(IFileSystem fileSystem);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static void AppendExtendedProperties(IDictionary`2<string, string> properties, VsixPackage vsixPackage, string installDir);
    [ExtensionAttribute]
internal static ScheduleHotloadResult IsOnlyHotloadInstallPlanned(Schedule schedule);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.FileConditionEvaluator : object {
    public ConditionType Type { get; }
    public sealed virtual ConditionType get_Type();
    public sealed virtual bool Evaluate(IServiceProvider services, Condition condition, IDictionary`2<string, string> properties);
    private bool EvaluateFileHash(IHashingService hashingService, string filePath, string fileHash);
    private bool EvaluateFileVersion(IFileSystem fileSystem, string filePath, VersionRange fileVersionRange);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.FileInitializerEvaluator : object {
    public void Evaluate(IServiceProvider services, PropertyInitializer initializer, VariableCollection properties);
    private string GetFileInitializerValue(IServiceProvider services, FilePropertyInitializer initializer, IDictionary`2<string, string> properties);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.HotloadInstallScheduler : InstallSchedulerBase {
    public HotloadInstallScheduler(SchedulerServiceOptions serviceOptions, Product product, ISet`1<IPackage> plannedPackages, string destination, ExecuteAction bootstrapperAction, IEngineContext engineContext, ErrorReporter errorReporter, FileLogger errorFileLogger, ISet`1<string> catalogsToUninstall);
    private protected virtual void QueueInitialActivitiesImpl(Schedule schedule, string installDir, ISet`1<IPackage> plannedPackages);
    private protected virtual void QueuePreparationActivitiesImpl(Schedule schedule, Plan plan, IDictionary`2<string, string> engineProperties, string installDir, IDictionary`2<string, object> telemetryProperties);
    private protected virtual void QueuePreInstallActivitiesImpl(Schedule schedule);
    private protected virtual void QueueInstallActivitiesImpl(Schedule schedule);
    private protected virtual void QueuePostInstallActivitiesImpl(Schedule schedule, string installDir);
    private protected virtual void QueueCleanupActivitiesImpl(Schedule schedule, string installDir);
    private protected virtual void QueueFinalActivitiesImpl(Schedule schedule, ISet`1<IPackage> plannedPackages);
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Setup.IChannelDownloader {
    public abstract virtual Task`1<ManifestDownloadSummary> GetLatestChannelManifestAsync(Uri channelUri, string temporaryCacheDirectory, CancellationToken cancellationToken, ITelemetryOperation updateAsyncOperation, Nullable`1<DateTimeOffset> lastModifiedDate);
}
public interface Microsoft.VisualStudio.Setup.IChannelManager {
    public bool IsEngineUpdateRequired { get; public set; }
    public string UpdateEngineUriString { get; public set; }
    public Version UpdateClientVersion { get; public set; }
    public string InstallLayoutPath { get; public set; }
    public bool IsDisposed { get; }
    public string OpcUrl { get; public set; }
    public abstract virtual IEnumerable`1<ChannelManifestPair> GetChannels(bool localChannelOnly);
    public abstract virtual Task`1<ChannelManifestPair> AddAsync(Uri channelUri, Uri installChannelUri, CancellationToken cancellationToken, Uri installCatalogUri);
    public abstract virtual Task`1<IChannelManifest> UpdateAsync(ChannelManifestPair channelManifestPair);
    public abstract virtual Task`1<IChannelManifest> UpdateAsync(ChannelManifestPair channelManifestPair, bool throwOnUpdateRequired);
    public abstract virtual Task`1<IChannelUpdateInformation> UpdateAsync(ChannelManifestPair channelManifestPair, UpdateOptions options, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> UpdateAllAsync();
    public abstract virtual Task`1<bool> UpdateAllAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> AddCatalogForChannelAsync(ChannelManifestPair channelManifestPair);
    public abstract virtual void GetCatalogPathsForChannel(ChannelManifestPair channelManifestPair, String& channelCatalogFileName, String& installChannelCatalogFileName);
    public abstract virtual void Remove(Uri channelUri);
    public abstract virtual void RemoveInstallChannel(Uri channelUri);
    public abstract virtual void CleanupInstallChannels(CancellationToken cancellationToken);
    public abstract virtual Task EnsureExistingChannelsAreCachedAsync(IEnumerable`1<IInstance> instances, CancellationToken cancellationToken);
    public abstract virtual void EnsureEngineCanReadManifests(CancellationToken cancellationToken, bool throwOnUpdate);
    public abstract virtual ChannelManifestPair GetChannel(Uri channelUri, bool localChannelOnly);
    [ObsoleteAttribute("Channels should be identified by their channelUri. Use the other overload of GetChannel instead")]
public abstract virtual ChannelManifestPair GetChannel(string channelId, bool localChannelOnly);
    public abstract virtual ChannelStatus GetChannelStatus(Uri channelUri);
    public abstract virtual IEnumerable`1<IChannelManifest> GetInstallChannels();
    public abstract virtual Task`1<string> DownloadChannelManifestAsync(Uri channelManifestUri);
    public abstract virtual Task`1<string> DownloadCatalogFromChannelManifestAsync(string channelManifestPath);
    [ObsoleteAttribute("Channels should be identified by their channelUri. Use the other overload of GetChannelProductSummary instead")]
public abstract virtual ChannelNode`1<IProductSummaryItem> GetChannelProductSummary(string channelId, string productId, string productArch);
    public abstract virtual ChannelNode`1<IProductSummaryItem> GetChannelProductSummary(Uri channelUri, string productId, string productArch);
    public abstract virtual void SynchronizeReadOnlyChannels();
    internal abstract virtual Task`1<string> DownloadCatalogAsync(Uri catalogUri, CancellationToken cancellationToken);
    public abstract virtual bool get_IsEngineUpdateRequired();
    public abstract virtual void set_IsEngineUpdateRequired(bool value);
    public abstract virtual string get_UpdateEngineUriString();
    public abstract virtual void set_UpdateEngineUriString(string value);
    public abstract virtual Version get_UpdateClientVersion();
    public abstract virtual void set_UpdateClientVersion(Version value);
    public abstract virtual string get_InstallLayoutPath();
    public abstract virtual void set_InstallLayoutPath(string value);
    public abstract virtual bool get_IsDisposed();
    public abstract virtual string get_OpcUrl();
    public abstract virtual void set_OpcUrl(string value);
}
public interface Microsoft.VisualStudio.Setup.IChannelUpdateInformation {
    public IChannelManifest ChannelManifest { get; }
    public string OfflineBootstrapperPath { get; }
    public string OfflineInstallerPath { get; }
    public abstract virtual IChannelManifest get_ChannelManifest();
    public abstract virtual string get_OfflineBootstrapperPath();
    public abstract virtual string get_OfflineInstallerPath();
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Setup.IChannelValidator {
    public abstract virtual void ValidateChannelUri(Uri channelUri);
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.Setup.IConditionEvaluator {
    public ConditionType Type { get; }
    public abstract virtual ConditionType get_Type();
    public abstract virtual bool Evaluate(IServiceProvider services, Condition condition, IDictionary`2<string, string> properties);
}
public interface Microsoft.VisualStudio.Setup.IEngine {
    public string LayoutDirectory { get; }
    public bool IsDisposed { get; }
    public bool IsDirty { get; }
    public Version ManifestVersion { get; }
    public Version BuildVersion { get; }
    public DependencyComparisonSeed Seed { get; public set; }
    public bool CanOverwriteProperties { get; public set; }
    public bool CanOverwriteFiles { get; public set; }
    public IInstance Instance { get; }
    public bool KeepWindowsUpdateOn { get; public set; }
    public abstract virtual string get_LayoutDirectory();
    public abstract virtual bool get_IsDisposed();
    public abstract virtual bool get_IsDirty();
    public abstract virtual Version get_ManifestVersion();
    public abstract virtual Version get_BuildVersion();
    public abstract virtual DependencyComparisonSeed get_Seed();
    public abstract virtual void set_Seed(DependencyComparisonSeed value);
    public abstract virtual bool get_CanOverwriteProperties();
    public abstract virtual void set_CanOverwriteProperties(bool value);
    public abstract virtual bool get_CanOverwriteFiles();
    public abstract virtual void set_CanOverwriteFiles(bool value);
    public abstract virtual IInstance get_Instance();
    public abstract virtual bool get_KeepWindowsUpdateOn();
    public abstract virtual void set_KeepWindowsUpdateOn(bool value);
    public abstract virtual void SetLayoutDirectory(string path, bool create);
    public abstract virtual void SetLayoutUri(Uri layoutUri);
    public abstract virtual void SetTemporaryLayoutDirectory(string path);
    public abstract virtual void SetExtensionsDirectory(string path);
    public abstract virtual void Load(Uri manifestUri, Uri channelUri, Uri installChannelUri, CancellationToken token, bool skipVerify);
    public abstract virtual void Load(string path, bool skipVerify);
    public abstract virtual void Load(ChannelNode`1<IProductSummaryItem> channelProduct, CancellationToken token, bool skipVerify);
    public abstract virtual void LoadPartialJson(string catalogJson);
    public abstract virtual void LoadPartialEmbeddedJson(string catalogJson);
    public abstract virtual IEnumerable`1<Product> GetProducts();
    public abstract virtual IDependencyGraph GetProductDependencyGraph(Product product, bool overwrite);
    public abstract virtual IDependencyGraph GetProductDependencyGraphWithSelection(Product product, bool overwrite);
    internal abstract virtual void Layout(Product product, LayoutContext layoutContext, CancellationToken token);
    public abstract virtual IInstance Install(Product product, string destination, CancellationToken token);
    public abstract virtual IInstance Repair(CancellationToken token);
    public abstract virtual void Uninstall(CancellationToken token);
    public abstract virtual void SetRunOnceInformation(string processPath, string arguments);
    public abstract virtual string GetDefaultInstallDirectory(Product product);
    public abstract virtual void SetTelemetryContext(TelemetryContext context);
    public abstract virtual void Initialize();
    public abstract virtual RegisteredProductInfo GetRegisteredProduct();
}
public interface Microsoft.VisualStudio.Setup.IEngineContext {
    public string CatalogPath { get; }
    public IEnumerable`1<Catalog> ExtensionCatalogs { get; }
    public string LogFilePath { get; }
    public string ErrorLogFilePath { get; }
    public VariableCollection Properties { get; }
    public DateTimeOffset OperationStartTime { get; }
    public ExecuteAction BootstrapperAction { get; }
    public EngineDriveInfo DriveInfo { get; }
    public ITelemetryOperation InstallOperation { get; }
    internal PrecheckParameters PrecheckParameters { get; }
    public abstract virtual string get_CatalogPath();
    public abstract virtual IEnumerable`1<Catalog> get_ExtensionCatalogs();
    public abstract virtual string get_LogFilePath();
    public abstract virtual string get_ErrorLogFilePath();
    public abstract virtual VariableCollection get_Properties();
    public abstract virtual DateTimeOffset get_OperationStartTime();
    public abstract virtual ExecuteAction get_BootstrapperAction();
    public abstract virtual EngineDriveInfo get_DriveInfo();
    public abstract virtual ITelemetryOperation get_InstallOperation();
    internal abstract virtual PrecheckParameters get_PrecheckParameters();
}
internal interface Microsoft.VisualStudio.Setup.IEngineOperation {
    public IReadOnlyDictionary`2<string, object> TelemetryProperties { get; }
    public abstract virtual IReadOnlyDictionary`2<string, object> get_TelemetryProperties();
    public abstract virtual void Run(CancellationToken token);
}
public interface Microsoft.VisualStudio.Setup.IEvaluatedInstallSizes {
    public bool HasSufficientDiskSpace { get; }
    public IDictionary`2<string, DriveSpaceEvaluation> InstallSizes { get; }
    public abstract virtual bool get_HasSufficientDiskSpace();
    public abstract virtual IDictionary`2<string, DriveSpaceEvaluation> get_InstallSizes();
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Setup.IExeInstallerRunner {
    public abstract virtual Result Run(CancellationToken token);
}
internal interface Microsoft.VisualStudio.Setup.IInstallationConfigurationFactory {
    public abstract virtual InstallationConfiguration Create(IDependencyGraph graph, ExportData exportData);
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Setup.IInstanceReferenceManager {
    public abstract virtual bool HasInstances(IPackage package);
    public abstract virtual bool HasInstancesAboveVersion(IPackage package, Version version);
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Setup.ILatestInstallerFeedManager {
    public abstract virtual Task`1<bool> UpdateAsync(CancellationToken token);
    [NullableContextAttribute("2")]
public abstract virtual LatestInstallerFeed GetLatestInstallerFeed();
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Setup.ILayoutOperationFactory {
    public abstract virtual IEngineOperation CreateLayoutOperation(IServiceProvider services, LayoutContext layoutContext, IEngineContext engineContext, ISet`1<IPackage> packages);
}
internal interface Microsoft.VisualStudio.Setup.INativeErrorCodeException {
    public int NativeErrorCode { get; }
    public abstract virtual int get_NativeErrorCode();
}
internal class Microsoft.VisualStudio.Setup.InstallationConfigurationFactory : object {
    [NullableContextAttribute("1")]
public sealed virtual InstallationConfiguration Create(IDependencyGraph graph, ExportData exportData);
    [NullableContextAttribute("1")]
private ExtensionRecords GetExtensionsToExport(IEnumerable`1<string> publicExtensionsURLs);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Setup.InstallationConfigurationPackages : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <ApplicablePackageIds>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <NonApplicablePackageIds>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <UnknownPackageIds>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <ApplicableMarketplaceExtensions>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <UnknownPrivateExtensions>k__BackingField;
    public IEnumerable`1<string> ApplicablePackageIds { get; }
    public IEnumerable`1<string> NonApplicablePackageIds { get; }
    public IEnumerable`1<string> UnknownPackageIds { get; }
    public IEnumerable`1<string> ApplicableMarketplaceExtensions { get; }
    public IEnumerable`1<string> UnknownPrivateExtensions { get; }
    public InstallationConfigurationPackages(IEnumerable`1<string> applicablePackageIds, IEnumerable`1<string> nonApplicablePackageIds, IEnumerable`1<string> unknownPackageIds, IEnumerable`1<string> applicableMarketplaceExtensions, IEnumerable`1<string> unknownPrivateExtensions);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_ApplicablePackageIds();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_NonApplicablePackageIds();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_UnknownPackageIds();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_ApplicableMarketplaceExtensions();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_UnknownPrivateExtensions();
}
internal class Microsoft.VisualStudio.Setup.Installer.BundleErrorEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private int <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private int <UIHint>k__BackingField;
    [CompilerGeneratedAttribute]
private BurnResult <Result>k__BackingField;
    public int Code { get; }
    public string Message { get; }
    public int UIHint { get; }
    public BurnResult Result { get; public set; }
    public BundleErrorEventArgs(int code, string message, int uiHint, BurnResult result);
    [CompilerGeneratedAttribute]
public int get_Code();
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public int get_UIHint();
    [CompilerGeneratedAttribute]
public BurnResult get_Result();
    [CompilerGeneratedAttribute]
public void set_Result(BurnResult value);
}
internal class Microsoft.VisualStudio.Setup.Installer.BundleProgressEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private int <Progress>k__BackingField;
    [CompilerGeneratedAttribute]
private BurnResult <Result>k__BackingField;
    internal int Progress { get; }
    public BurnResult Result { get; public set; }
    public BundleProgressEventArgs(int progress, BurnResult result);
    [CompilerGeneratedAttribute]
internal int get_Progress();
    [CompilerGeneratedAttribute]
public BurnResult get_Result();
    [CompilerGeneratedAttribute]
public void set_Result(BurnResult value);
}
internal enum Microsoft.VisualStudio.Setup.Installer.BurnResult : Enum {
    public int value__;
    public static BurnResult Error;
    public static BurnResult None;
    public static BurnResult Ok;
    public static BurnResult Cancel;
    public static BurnResult Abort;
    public static BurnResult Retry;
    public static BurnResult Ignore;
    public static BurnResult Yes;
    public static BurnResult No;
    public static BurnResult Close;
    public static BurnResult Help;
    public static BurnResult TryAgain;
    public static BurnResult Continue;
}
internal class Microsoft.VisualStudio.Setup.Installer.BurnRunner : object {
    private static int BurnRunnerConnectTimeout;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private IProcessService <ProcessService>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    public string Path { get; }
    public string Arguments { get; }
    private IProcessService ProcessService { get; }
    private ILogger Logger { get; }
    public BurnRunner(IServiceProvider services, string path, string arguments);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public string get_Arguments();
    private void OnError(BundleErrorEventArgs e);
    private void OnStart(string path);
    private void OnFinish(string path);
    [CompilerGeneratedAttribute]
private IProcessService get_ProcessService();
    [CompilerGeneratedAttribute]
private ILogger get_Logger();
    public sealed virtual Result Run(CancellationToken token);
    private BurnResult ProcessProgressMessage(NamedPipeServerStream pipe, CancellationToken token);
    private BurnResult ProcessErrorMessage(NamedPipeServerStream pipe, CancellationToken token);
    private void Connect(NamedPipeServerStream pipe, string pipeSecret, int pid, CancellationToken token);
    private void WriteSecretToPipe(NamedPipeServerStream pipe, string secret);
    private void PumpMessages(NamedPipeServerStream pipe, CancellationToken token);
    private void CompleteMessage(NamedPipeServerStream pipe, BurnResult result);
    private UInt32 ReadNumberFromPipe(NamedPipeServerStream pipe);
    private string ReadStringFromPipe(NamedPipeServerStream pipe);
    private bool TryReadNumberFromPipe(NamedPipeServerStream pipe, UInt32& value);
    private void WriteNumberToPipe(NamedPipeServerStream pipe, UInt32 value);
    private void AppendData(StringBuilder output, DataReceivedEventArgs args);
}
internal class Microsoft.VisualStudio.Setup.Installer.DismInstallerReturnCodes : InstallResultCollection {
}
internal class Microsoft.VisualStudio.Setup.Installer.ErrorMode : object {
    private int oldMode;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    internal bool IsDisposed { get; private set; }
    internal ErrorMode(ErrorModes mode);
    [CompilerGeneratedAttribute]
internal bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
}
[FlagsAttribute]
internal enum Microsoft.VisualStudio.Setup.Installer.ErrorModes : Enum {
    public int value__;
    public static ErrorModes Default;
    public static ErrorModes FailCriticalErrors;
    public static ErrorModes NoGpFaultErrorBox;
    public static ErrorModes NoAlignmentFaultExcept;
    public static ErrorModes NoOpenFileErrorBox;
}
internal class Microsoft.VisualStudio.Setup.Installer.ExeInstaller : InstallerBase {
    private static string PowerShellFileName;
    private static ISet`1<string> PowerShellVariablesToIgnore;
    private static string FirstPayloadAlias;
    private string fileName;
    private Dictionary`2<InstallResult, InstallRetry> retryCodes;
    [CompilerGeneratedAttribute]
private InstallResultCollection <ReturnCodes>k__BackingField;
    protected InstallResultCollection ReturnCodes { get; }
    internal ExeInstaller(IServiceProvider container);
    private static ExeInstaller();
    [CompilerGeneratedAttribute]
protected virtual InstallResultCollection get_ReturnCodes();
    protected virtual InstallResult InstallCore(string localPath, string installDir, InstallablePackage pkg);
    private CommandParameter GetInstallParamsToUse(ExePackage exePkg);
    private bool InInstallFromLayoutMode();
    protected virtual InstallResult RepairCore(string installDir, InstallablePackage pkg, string localPath);
    protected virtual InstallResult UninstallCore(string installDir, InstallablePackage pkg, string localPath, bool isManifestCached);
    internal InstallResult Initialize(Product product, ExecuteAction bootstrapperAction, String& logFile);
    internal InstallResult Finalize(Product product, ExecuteAction bootstrapperAction, String& logFile);
    internal InstallResult FinalizeExtensibility(Product product, string extensionOperations, ExecuteAction bootstrapperAction, String& logFile);
    private InstallResult RunProductCommand(Product product, CommandParameter parameter, string telemetryOperationType, string telemetryCancelOperation, string logOperation, string exceptionMessage, ExecuteAction action, String& logFile, IDictionary`2<string, string> additionalProperties);
    private string GetPackageLayoutDir(Package pkg);
    private string GetPackageOriginalSource(Package pkg);
    private int RunCommands(CommandParameter parameters, Package pkg, string localPath, string logFile, String& errorMsg, String& outputMsg, String& command, string productCommand, IDictionary`2<string, string> transientProperties);
    internal InstallResult ReturnExeCode(int code, ExePackage package, string command, ExecuteAction action);
    private FileLogger GetLoggerForPackage(string logPath);
    protected bool TryGetValidatedInstallerFilePathForExe(string localPath, InstallablePackage pkg, String& primaryPayloadPath, bool fallbackToFirstPayload);
}
internal class Microsoft.VisualStudio.Setup.Installer.ExeInstallerReturnCodes : InstallResultCollection {
}
internal class Microsoft.VisualStudio.Setup.Installer.ExeInstallerRunnerFactory : object {
    [NullableAttribute("1")]
internal static IExeInstallerRunnerFactory Default;
    private static ExeInstallerRunnerFactory();
    [NullableContextAttribute("1")]
public sealed virtual IExeInstallerRunner GetExeRunner(IServiceProvider services, ExeProtocol protocol, string payloadPath, string arguments);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.Setup.Installer.Extensions : object {
    [ExtensionAttribute]
internal static string GetUrl(IUniformResourceLocator source);
    [ExtensionAttribute]
internal static bool IsPayloadRequired(IInstallablePackage package, ExecuteAction action, IServiceProvider services, ExecuteAction bootstrapperAction);
    [ExtensionAttribute]
internal static bool IsPermanent(IInstallablePackage package);
    [ExtensionAttribute]
internal static bool IsUninstallable(IInstallablePackage package);
}
public abstract class Microsoft.VisualStudio.Setup.Installer.FileInstaller : InstallerBase {
    private static string NewFilePrefix;
    private IPendingRebootOperations rebootPendingOperationsService;
    private IList`1<string> lockedFiles;
    private ILockedFileResolver lockedFileResolver;
    protected internal IEnumerable`1<string> LockedFiles { get; }
    protected FileInstaller(IServiceProvider services);
    private static FileInstaller();
    protected internal IEnumerable`1<string> get_LockedFiles();
    protected sealed virtual InstallResult InstallCore(string localPath, string installDir, InstallablePackage pkg);
    protected sealed virtual InstallResult RepairCore(string installDir, InstallablePackage pkg, string localPath);
    protected sealed virtual InstallResult UninstallCore(string installDir, InstallablePackage pkg, string localPath, bool isManifestCached);
    protected abstract virtual InstallResult InstallCoreInternal(string localPath, string installDir, InstallablePackage pkg);
    protected abstract virtual InstallResult RepairCoreInternal(string installDir, InstallablePackage pkg, string localPath);
    protected abstract virtual InstallResult UninstallCoreInternal(string installDir, InstallablePackage pkg, string localPath, bool isManifestCached);
    internal void GetFolderAncestors(string pathToStartFrom, string rootDir, ISet`1<string> ancestors);
    protected bool CopyFile(string sourcePath, Stream source, string destinationPath, RebootType& rebootRequired, ILogger logger);
    protected bool DeleteFile(string file, string installDir, ILogger logger, Boolean& rebootRequired, ISet`1<string> dirsDeleteCandidates);
    protected void DeleteEmptyDirectories(ISet`1<string> dirsDeleteCandidates, bool rebootPending, ILogger logger);
    private InstallResult DoAction(Func`1<InstallResult> action);
    private void LogLockingProcesses();
    private void Reset();
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Setup.Installer.IExeInstallerRunnerFactory {
    public abstract virtual IExeInstallerRunner GetExeRunner(IServiceProvider services, ExeProtocol protocol, string payloadPath, string arguments);
}
internal interface Microsoft.VisualStudio.Setup.Installer.IInstaller {
    public IEngineContext EngineContext { get; public set; }
    public abstract virtual IEngineContext get_EngineContext();
    public abstract virtual void set_EngineContext(IEngineContext value);
    public abstract virtual InstallResult Install(string destination, InstallablePackage package, string path, Nullable`1<bool> isDetected, CancellationToken token);
    public abstract virtual InstallResult Repair(string destination, InstallablePackage package, string path, Nullable`1<bool> isDetected, CancellationToken token);
    public abstract virtual InstallResult Uninstall(string destination, InstallablePackage package, string path, Nullable`1<bool> isDetected, CancellationToken token);
    public abstract virtual InstallResult PlanExecuteAction(InstallablePackage pkg, ExecuteAction requestedAction, ExecuteAction& plannedAction, PackageState& currentState, Nullable`1<bool> softDetectionHint, string localPath);
    public abstract virtual bool IsCorruptPackageReturnCode(int returnCode);
    public abstract virtual InstallResult GetCurrentPackageState(InstallablePackage pkg, PackageState& currentState, Nullable`1<bool> softDetectionHint);
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Setup.Installer.IInstallerFactory {
    public abstract virtual IInstaller CreateInstaller(InstallablePackage package, IServiceProvider services);
}
internal interface Microsoft.VisualStudio.Setup.Installer.ILockedFileResolver {
    public abstract virtual void Log(IEnumerable`1<string> paths);
}
internal interface Microsoft.VisualStudio.Setup.Installer.IMsiZapResolver {
    public abstract virtual void Zap(string productCode);
}
public abstract class Microsoft.VisualStudio.Setup.Installer.InstallerBase : object {
    private bool isInitialized;
    [CompilerGeneratedAttribute]
private EventHandler`1<ProgressDataEventArgs> ProgressReceived;
    [CompilerGeneratedAttribute]
private IEngineContext <EngineContext>k__BackingField;
    [CompilerGeneratedAttribute]
private IServiceProvider <Services>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <LoggingService>k__BackingField;
    [CompilerGeneratedAttribute]
private ICacheManager <CacheService>k__BackingField;
    [CompilerGeneratedAttribute]
private InstallablePackage <CurrentPackage>k__BackingField;
    [CompilerGeneratedAttribute]
private ITelemetry <TelemetryService>k__BackingField;
    [CompilerGeneratedAttribute]
private IPolicyService <PolicyService>k__BackingField;
    [CompilerGeneratedAttribute]
private IFileSystem <FileSystem>k__BackingField;
    [CompilerGeneratedAttribute]
private IHashingService <HashService>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, object> <AdditionalTelemetryProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SleepMilliseconds>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RetryLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private InstallResultCollection <ReturnCodes>k__BackingField;
    public IEngineContext EngineContext { get; public set; }
    protected IServiceProvider Services { get; private set; }
    protected ILogger LoggingService { get; protected set; }
    protected ICacheManager CacheService { get; protected set; }
    protected InstallablePackage CurrentPackage { get; private set; }
    protected ITelemetry TelemetryService { get; protected set; }
    protected IPolicyService PolicyService { get; protected set; }
    protected IFileSystem FileSystem { get; }
    protected IHashingService HashService { get; protected set; }
    internal Dictionary`2<string, object> AdditionalTelemetryProperties { get; internal set; }
    internal int SleepMilliseconds { get; internal set; }
    protected int RetryLimit { get; protected set; }
    protected CancellationToken Token { get; private set; }
    protected InstallResultCollection ReturnCodes { get; }
    public InstallerBase(IServiceProvider services);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ProgressReceived(EventHandler`1<ProgressDataEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ProgressReceived(EventHandler`1<ProgressDataEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual IEngineContext get_EngineContext();
    [CompilerGeneratedAttribute]
public sealed virtual void set_EngineContext(IEngineContext value);
    [CompilerGeneratedAttribute]
protected IServiceProvider get_Services();
    [CompilerGeneratedAttribute]
private void set_Services(IServiceProvider value);
    [CompilerGeneratedAttribute]
protected ILogger get_LoggingService();
    [CompilerGeneratedAttribute]
protected void set_LoggingService(ILogger value);
    [CompilerGeneratedAttribute]
protected ICacheManager get_CacheService();
    [CompilerGeneratedAttribute]
protected void set_CacheService(ICacheManager value);
    [CompilerGeneratedAttribute]
protected InstallablePackage get_CurrentPackage();
    [CompilerGeneratedAttribute]
private void set_CurrentPackage(InstallablePackage value);
    [CompilerGeneratedAttribute]
protected ITelemetry get_TelemetryService();
    [CompilerGeneratedAttribute]
protected void set_TelemetryService(ITelemetry value);
    [CompilerGeneratedAttribute]
protected IPolicyService get_PolicyService();
    [CompilerGeneratedAttribute]
protected void set_PolicyService(IPolicyService value);
    [CompilerGeneratedAttribute]
protected IFileSystem get_FileSystem();
    [CompilerGeneratedAttribute]
protected IHashingService get_HashService();
    [CompilerGeneratedAttribute]
protected void set_HashService(IHashingService value);
    [CompilerGeneratedAttribute]
internal Dictionary`2<string, object> get_AdditionalTelemetryProperties();
    [CompilerGeneratedAttribute]
internal void set_AdditionalTelemetryProperties(Dictionary`2<string, object> value);
    [CompilerGeneratedAttribute]
internal int get_SleepMilliseconds();
    [CompilerGeneratedAttribute]
internal void set_SleepMilliseconds(int value);
    [CompilerGeneratedAttribute]
protected int get_RetryLimit();
    [CompilerGeneratedAttribute]
protected void set_RetryLimit(int value);
    [CompilerGeneratedAttribute]
protected CancellationToken get_Token();
    [CompilerGeneratedAttribute]
private void set_Token(CancellationToken value);
    [CompilerGeneratedAttribute]
protected virtual InstallResultCollection get_ReturnCodes();
    protected virtual void AddPackageTelemetryProperties(IDictionary`2<string, object> telemetryProperties, IPackage package);
    public sealed virtual InstallResult Install(string destination, InstallablePackage package, string path, Nullable`1<bool> isDetected, CancellationToken token);
    public sealed virtual InstallResult Repair(string destination, InstallablePackage package, string path, Nullable`1<bool> isDetected, CancellationToken token);
    public sealed virtual InstallResult Uninstall(string destination, InstallablePackage package, string path, Nullable`1<bool> isDetected, CancellationToken token);
    protected IDictionary`2<string, string> GetProperties();
    public virtual InstallResult PlanExecuteAction(InstallablePackage pkg, ExecuteAction requestedAction, ExecuteAction& plannedAction, PackageState& currentState, Nullable`1<bool> softDetectionHint, string localPath);
    public virtual bool IsCorruptPackageReturnCode(int returnCode);
    public virtual InstallResult GetCurrentPackageState(InstallablePackage pkg, PackageState& currentState, Nullable`1<bool> softDetectionHint);
    protected virtual void OnProgressReceived(ProgressDataEventArgs e);
    protected InstallResult EvaluateDetectConditions(InstallablePackage package, ConditionGroup detectConditions, PackageState& currentState);
    protected abstract virtual InstallResult InstallCore(string localPath, string installDir, InstallablePackage pkg);
    protected abstract virtual InstallResult RepairCore(string installDir, InstallablePackage pkg, string localPath);
    protected abstract virtual InstallResult UninstallCore(string installDir, InstallablePackage pkg, string localPath, bool isManifestCached);
    protected T ValidatePackageParam(InstallablePackage pkg);
    protected string GetLogFileName(InstallablePackage pkg, string installerFile);
    protected InstallResultCollection GetCustomReturnCodes(InstallablePackage package);
    protected InstallResult GetMessageFromSystemIfNotMapped(InstallResultCollection returnCodes, int code, ExecuteAction action);
    protected T TryGetCachedPackage(IPackageIdentity identity);
    protected virtual bool TryGetValidatedInstallerFilePath(string localPath, InstallablePackage pkg, String& primaryPayloadPath);
    private bool TryGetValidatedInstallerFilePathFromPayload(string localPath, InstallablePackage pkg, String& primaryPayloadPath);
    protected string GetPackageNameForLogging(InstallablePackage package, string localPath);
    protected InstallResult ExecutePackageWithRetry(InstallablePackage package, Func`1<InstallResult> action, Dictionary`2<InstallResult, InstallRetry> retryCodes, ExecuteAction bootstrapperAction);
    protected InstallResult ExecutePackageWithMessageBusRetry(InstallablePackage package, Func`1<InstallResult> action, Dictionary`2<InstallResult, InstallRetry> retryCodes, ExecuteAction bootstrapperAction);
    protected virtual bool OnErrorRetry(InstallResult result);
    private InstallResult PlanAndApplyExecuteAction(string installDir, InstallablePackage pkg, string localPath, ExecuteAction requestedAction, Nullable`1<bool> softDetectionHint);
    private InstallResult InstallHelper(InstallData installData);
    private InstallResult RepairHelper(InstallData repairData);
    private InstallResult UninstallHelper(InstallData uninstallData);
    protected string GetInstallResultDetails(InstallResult installResult, IPackage package, string packageAction);
    protected void PrintReturnCode(InstallResult returnCode, InstallablePackage package, ExecuteAction executeAction, ILogger logger);
    private void LogPackageFailure(InstallablePackage package, ExecuteAction executeAction, string details, ILogger logger);
    protected void Initialize();
}
internal static class Microsoft.VisualStudio.Setup.Installer.InstallerDiagnosticMessages : object {
    internal static string ExtractionOpenPackage;
    internal static string ExtractionQueryParts;
    internal static string PartProcessing;
    internal static string CreateVsixCertFileText;
    internal static string MissingVsixCertFileText;
    internal static string VsixCertFileExistsText;
    internal static string VsixSubjectNameMissing;
    internal static string ExceptionDeletingVsixCertFileText;
    internal static string ExceptionCreatingVsixCertFileText;
    internal static string VsixIncompleteCertChain;
    private static InstallerDiagnosticMessages();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Installer.InstallerFactory : object {
    private static string NuGetConfigFileName;
    private Dictionary`2<PackageType, InstallerBase> installers;
    private NgenArchitecture defaultArchitecture;
    internal static IInstallerFactory Default { get; }
    internal static IInstallerFactory Default64 { get; }
    internal static IInstallerFactory DefaultArm64 { get; }
    private InstallerFactory(NgenArchitecture defaultArchitecture);
    private static InstallerFactory();
    internal static IInstallerFactory get_Default();
    internal static IInstallerFactory get_Default64();
    internal static IInstallerFactory get_DefaultArm64();
    public sealed virtual IInstaller CreateInstaller(InstallablePackage package, IServiceProvider services);
}
public class Microsoft.VisualStudio.Setup.Installer.InstallRetry : ValueType {
    internal static int DefaultRetryCount;
    internal static int DefaultUserRetryCount;
    private static ResourceManager DefaultResourceManager;
    private ResourceManager resourceManager;
    private Nullable`1<bool> shouldPrompt;
    [CompilerGeneratedAttribute]
private string <ResourceId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RetryCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <UserRetryCount>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldResolve>k__BackingField;
    public ResourceManager ResourceManager { get; internal set; }
    public string ResourceId { get; internal set; }
    public int RetryCount { get; internal set; }
    public int UserRetryCount { get; internal set; }
    public bool ShouldResolve { get; internal set; }
    public bool ShouldPrompt { get; internal set; }
    internal InstallRetry(string resourceId, int retryCount, int userRetryCount);
    private static InstallRetry();
    public ResourceManager get_ResourceManager();
    internal void set_ResourceManager(ResourceManager value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_ResourceId();
    [CompilerGeneratedAttribute]
internal void set_ResourceId(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_RetryCount();
    [CompilerGeneratedAttribute]
internal void set_RetryCount(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_UserRetryCount();
    [CompilerGeneratedAttribute]
internal void set_UserRetryCount(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_ShouldResolve();
    [CompilerGeneratedAttribute]
internal void set_ShouldResolve(bool value);
    public bool get_ShouldPrompt();
    internal void set_ShouldPrompt(bool value);
}
[GuidAttribute("FBF23B40-E3F0-101B-8488-00AA003E56F8")]
internal class Microsoft.VisualStudio.Setup.Installer.InternetShortcut : object {
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("6F79D558-3E96-4549-A1D1-7D75D2288814")]
internal interface Microsoft.VisualStudio.Setup.Installer.IPropertyDescription {
    public abstract virtual void GetPropertyKey(PROPERTYKEY& pkey);
    public abstract virtual void GetCanonicalName(String& ppszName);
    public abstract virtual void GetPropertyType(VarEnum& pvartype);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("886D8EEB-8CF2-4446-8D02-CDBA1DBDCF99")]
internal interface Microsoft.VisualStudio.Setup.Installer.IPropertyStore {
    public abstract virtual void GetCount(UInt32& cProps);
    public abstract virtual void GetAt(UInt32 iProp, PROPERTYKEY& pkey);
    public abstract virtual void GetValue(PROPERTYKEY& key, PROPVARIANT& pv);
    public abstract virtual void SetValue(PROPERTYKEY& key, PROPVARIANT& pv);
    public abstract virtual void Commit();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("000214F9-0000-0000-C000-000000000046")]
internal interface Microsoft.VisualStudio.Setup.Installer.IShellLink {
    public abstract virtual void GetPath(StringBuilder pszFile, int cchMaxPath, IntPtr pfd, int fFlags);
    public abstract virtual void GetIDList(IntPtr& ppidl);
    public abstract virtual void SetIDList(IntPtr pidl);
    public abstract virtual void GetDescription(StringBuilder pszName, int cchMaxName);
    public abstract virtual void SetDescription(string pszName);
    public abstract virtual void GetWorkingDirectory(StringBuilder pszDir, int cchMaxPath);
    public abstract virtual void SetWorkingDirectory(string pszDir);
    public abstract virtual void GetArguments(StringBuilder pszArgs, int cchMaxPath);
    public abstract virtual void SetArguments(string pszArgs);
    public abstract virtual void GetHotkey(Int16& pwHotkey);
    public abstract virtual void SetHotkey(short wHotkey);
    public abstract virtual void GetShowCmd(Int32& piShowCmd);
    public abstract virtual void SetShowCmd(int iShowCmd);
    public abstract virtual void GetIconLocation(StringBuilder pszIconPath, int cchIconPath, Int32& piIcon);
    public abstract virtual void SetIconLocation(string pszIconPath, int iIcon);
    public abstract virtual void SetRelativePath(string pszPathRel, int dwReserved);
    public abstract virtual void Resolve(IntPtr hwnd, int fFlags);
    public abstract virtual void SetPath(string pszFile);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("CABB0DA0-DA57-11CF-9974-0020AFD79762")]
internal interface Microsoft.VisualStudio.Setup.Installer.IUniformResourceLocator {
    public abstract virtual void SetURL(string pcszURL, int flags);
    public abstract virtual void GetURL(IntPtr& ppszURL);
}
internal class Microsoft.VisualStudio.Setup.Installer.LockedFileResolver : object {
    private IServiceProvider services;
    private IFileSystem fileSystem;
    private ILogger logger;
    private IFileSystem FileSystem { get; }
    private ILogger Logger { get; }
    public LockedFileResolver(IServiceProvider services);
    private IFileSystem get_FileSystem();
    private ILogger get_Logger();
    public sealed virtual void Log(IEnumerable`1<string> paths);
    private string Format(IWindowsRestartManagerProcessInfo info);
}
internal class Microsoft.VisualStudio.Setup.Installer.MsiInstaller : InstallerBase {
    internal static int MsiSouceAbsent;
    internal static int RegKeyCouldNotBeOpened;
    private static Product product;
    private IWindowsInstallerService windowsInstallerService;
    private MsiMessageProcessor processor;
    private InstallResult err;
    private ISet`1<string> zappedProductCodes;
    private Dictionary`2<InstallResult, InstallRetry> retryCodes;
    private ILockedFileResolver lockedFileResolver;
    [CompilerGeneratedAttribute]
private InstallResultCollection <ReturnCodes>k__BackingField;
    protected InstallResultCollection ReturnCodes { get; }
    internal MsiInstaller(IServiceProvider container, MsiMessageProcessor processor);
    private static MsiInstaller();
    [CompilerGeneratedAttribute]
protected virtual InstallResultCollection get_ReturnCodes();
    public virtual bool IsCorruptPackageReturnCode(int returnCode);
    public virtual InstallResult GetCurrentPackageState(InstallablePackage pkg, PackageState& currentState, Nullable`1<bool> softDetectionHint);
    protected virtual InstallResult InstallCore(string localPath, string installDir, InstallablePackage pkg);
    protected virtual InstallResult RepairCore(string installDir, InstallablePackage pkg, string localPath);
    protected virtual InstallResult UninstallCore(string installDir, InstallablePackage pkg, string localPath, bool isManifestCached);
    protected virtual void AddPackageTelemetryProperties(IDictionary`2<string, object> telemetryProperties, IPackage package);
    protected virtual bool OnErrorRetry(InstallResult result);
    private bool ZapProducts(IResolverFactory factory, IEnumerable`1<string> productCodes);
    private InstallResult DoAction(MsiPackage package, Func`1<InstallResult> action, Dictionary`2<InstallResult, InstallRetry> retryCodes, ExecuteAction bootstrapperAction);
    private void LogLockingProcesses();
    private InstallResult ReturnMsiCode(int code, string installerFile, MsiPackage msiPackage, ExecuteAction action, string properties);
    private string GetStandardMSIProperties(MsiPackage msiPkg, string installDir);
    private string AppendPatchPropertyIfApplicable(string installerFile, string currentCommandLine);
    private MessageResult OnMessage(InstallMessage messageType, Record record, MessageButtons buttons, MessageIcon icon, MessageDefaultButton defaultButton);
    private MessageResult OnInstallStart(Record record);
    private MessageResult OnActionStart(Record record);
    private MessageResult OnActionData(Record record);
    private MessageResult OnError(Record record);
    private MessageResult OnProgress();
    private void EmitProgress();
    private void DetectCompatiblePackage(MsiPackage package);
    private string DetectCompatiblePackage(string providerKeyStr, String& packageId);
    private void MarkSupersededAbsentIfApplicable(MsiPackage msi, Version installedVersion, PackageState& installState);
}
internal class Microsoft.VisualStudio.Setup.Installer.MsiInstallerReturnCodes : InstallResultCollection {
}
internal class Microsoft.VisualStudio.Setup.Installer.MsiMessageProcessor : object {
    internal static InstallLogModes RequiredLogModes;
    private IDictionary`2<string, bool> missingProducts;
    private bool monitorMissingProducts;
    [CompilerGeneratedAttribute]
private string <CurrentProductCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CurrentProductIsCorrupt>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <LockedFiles>k__BackingField;
    internal string CurrentProductCode { get; private set; }
    internal bool CurrentProductIsCorrupt { get; private set; }
    internal IList`1<string> LockedFiles { get; }
    internal IEnumerable`1<string> MissingProducts { get; }
    [CompilerGeneratedAttribute]
internal string get_CurrentProductCode();
    [CompilerGeneratedAttribute]
private void set_CurrentProductCode(string value);
    [CompilerGeneratedAttribute]
internal bool get_CurrentProductIsCorrupt();
    [CompilerGeneratedAttribute]
private void set_CurrentProductIsCorrupt(bool value);
    [CompilerGeneratedAttribute]
internal IList`1<string> get_LockedFiles();
    internal IEnumerable`1<string> get_MissingProducts();
    internal void ProcessError(InstallResult error, MsiPackage package);
    internal void ProcessRecord(InstallMessage messageType, IRecord record);
    internal void Reset();
}
internal class Microsoft.VisualStudio.Setup.Installer.MsiUserInterfaceHandler : object {
    private INSTALLUILEVEL previousInternalUI;
    private ExternalUIRecordHandler previousExternalUI;
    internal MsiUserInterfaceHandler(ExternalUIRecordHandler handler, bool force);
    public sealed virtual void Dispose();
}
internal class Microsoft.VisualStudio.Setup.Installer.MsiZapResolver : object {
    private static Byte[] Translation;
    private ILogger logger;
    [CompilerGeneratedAttribute]
private IServiceProvider <Services>k__BackingField;
    internal IServiceProvider Services { get; }
    public MsiZapResolver(IServiceProvider services);
    private static MsiZapResolver();
    public sealed virtual void Zap(string productCode);
    [CompilerGeneratedAttribute]
internal IServiceProvider get_Services();
    internal static IEnumerable`1<string> GetProductCodes(MsiMessageProcessor processor);
    internal static bool ShouldZap(InstallResult result);
    private static void RemoveChildKeys(ITransactedRegistryKey root, string packedProductCode);
    private static string Translate(Guid productCode);
    private void RemoveSourceRegistration(ITransactedRegistryKey root, string packedProductCode);
    private void RemoveProductRegistration(ITransactedRegistryKey root, string packedProductCode, string productCode);
    private void RemoveUpgradeRegistration(ITransactedRegistryKey root, string packedProductCode);
    private void RemoveComponentRegistration(ITransactedRegistryKey root, string packedProductCode);
}
internal class Microsoft.VisualStudio.Setup.Installer.MsuInstaller : InstallerBase {
    private Dictionary`2<InstallResult, InstallRetry> retryCodes;
    [CompilerGeneratedAttribute]
private InstallResultCollection <ReturnCodes>k__BackingField;
    protected InstallResultCollection ReturnCodes { get; }
    internal MsuInstaller(IServiceProvider container);
    [CompilerGeneratedAttribute]
protected virtual InstallResultCollection get_ReturnCodes();
    protected virtual InstallResult InstallCore(string localPath, string installDir, InstallablePackage pkg);
    private InstallResult GetInstallResult(Result dismResult, InstallablePackage pkg, ExecuteAction action);
    protected virtual InstallResult RepairCore(string installDir, InstallablePackage pkg, string localPath);
    protected virtual InstallResult UninstallCore(string installDir, InstallablePackage pkg, string localPath, bool isManifestCached);
    protected virtual bool TryGetValidatedInstallerFilePath(string localPath, InstallablePackage pkg, String& primaryPayloadPath);
    private string ExpandPackage(string originalPath);
}
internal class Microsoft.VisualStudio.Setup.Installer.NativeExternalUIHandler : MulticastDelegate {
    public NativeExternalUIHandler(object object, IntPtr method);
    public virtual int Invoke(IntPtr context, int messageType, string message);
    public virtual IAsyncResult BeginInvoke(IntPtr context, int messageType, string message, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
internal class Microsoft.VisualStudio.Setup.Installer.NativeExternalUIRecordHandler : MulticastDelegate {
    public NativeExternalUIRecordHandler(object object, IntPtr method);
    public virtual int Invoke(IntPtr context, int messageType, int recordHandle);
    public virtual IAsyncResult BeginInvoke(IntPtr context, int messageType, int recordHandle, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
internal class Microsoft.VisualStudio.Setup.Installer.NativeMethods : object {
    internal static int DISMAPI_E_UNKNOWN_FEATURE;
    internal static int CBS_E_BUSY;
    internal static int ERROR_SUCCESS;
    internal static int ERROR_INVALID_PARAMETER;
    internal static int ERROR_INSTALL_SUSPEND;
    internal static int ERROR_PRODUCT_VERSION;
    internal static int ERROR_ANOTHER_INSTALLATION_IN_PROGRESS;
    internal static int ERROR_SUCCESS_REBOOT_INITIATED;
    internal static int ERROR_SUCCESS_REBOOT_REQUIRED;
    internal static int ERROR_SUCCESS_REBOOT_RECOMMENDED;
    internal static int ERROR_ANOTHER_EDGEUPDATE_RUNNING;
    internal static int ERROR_ANOTHER_MICROSOFTAPPLICATION_INSTALLER_RUNNING;
    internal static int MAX_PATH;
    internal static int STGM_READ;
    internal static int S_OK;
    internal static int VARIANT_TRUE;
    internal static int VARIANT_FALSE;
    internal static string IID_IPropertyDescription;
    internal static Guid GuidIPropertyDescription;
    private static NativeMethods();
    internal static int MsiEnableLog(int dwLogMode, string szLogFile, int dwLogAttributes);
    internal static int MsiInstallProduct(string szPackagePath, string szCommandLine);
    internal static int MsiConfigureProductEx(string szProduct, int iInstallLevel, int eInstallState, string szCommandLine);
    internal static int MsiRecordGetFieldCount(int hRecord);
    internal static int MsiRecordGetInteger(int hRecord, int iField);
    internal static int MsiRecordGetString(int hRecord, int iField, StringBuilder szValueBuf, Int32& cchValueBuf);
    internal static int MsiRecordSetString(int hRecord, int iField, string szValue);
    internal static int MsiFormatRecord(int hInstall, int hRecord, StringBuilder szResultBuf, Int32& cchResultBuf);
    internal static int MsiCloseHandle(int hAny);
    internal static int MsiEnumRelatedProducts(string upgradeCode, int dwReserved, int iProductIndex, StringBuilder lpProductBuf);
    internal static int MsiGetProductInfoEx(string szProductCode, string szUserSid, int dwContext, string szProperty, StringBuilder lpValue, Int32& pcchValue);
    internal static int MsiSetExternalUIRecord(NativeExternalUIRecordHandler puiHandler, int dwMessageFilter, IntPtr pvContext, NativeExternalUIRecordHandler& ppuiPrevHandler);
    internal static int SetErrorMode(int newMode);
    internal static bool DosDateTimeToFileTime(short wFatDate, short wFatTime, Int64& fileTime);
    internal static int PropVariantClear(PROPVARIANT& pvar);
    internal static int PSGetPropertyKeyFromName(string pszName, PROPERTYKEY& ppropKey);
    internal static int PSGetPropertyDescription(PROPERTYKEY& propkey, Guid& riid, IPropertyDescription& ppv);
}
internal class Microsoft.VisualStudio.Setup.Installer.Ngen : object {
    private static IDictionary`2<string, NgenArchitecture> ArchMapping;
    [CompilerGeneratedAttribute]
private string <FileLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileNameAsAuthored>k__BackingField;
    [CompilerGeneratedAttribute]
private NgenArchitecture <Architecture>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <NgenConfigurationFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NgenPriority>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NgenDependencies>k__BackingField;
    internal string FileLocation { get; private set; }
    internal string FileNameAsAuthored { get; private set; }
    internal NgenArchitecture Architecture { get; private set; }
    internal IList`1<string> NgenConfigurationFiles { get; private set; }
    internal int NgenPriority { get; private set; }
    internal bool NgenDependencies { get; private set; }
    internal Ngen(string fileNameAsAuthored, string fileLocation);
    private static Ngen();
    [CompilerGeneratedAttribute]
internal string get_FileLocation();
    [CompilerGeneratedAttribute]
private void set_FileLocation(string value);
    [CompilerGeneratedAttribute]
internal string get_FileNameAsAuthored();
    [CompilerGeneratedAttribute]
private void set_FileNameAsAuthored(string value);
    [CompilerGeneratedAttribute]
internal NgenArchitecture get_Architecture();
    [CompilerGeneratedAttribute]
private void set_Architecture(NgenArchitecture value);
    [CompilerGeneratedAttribute]
internal IList`1<string> get_NgenConfigurationFiles();
    [CompilerGeneratedAttribute]
private void set_NgenConfigurationFiles(IList`1<string> value);
    [CompilerGeneratedAttribute]
internal int get_NgenPriority();
    [CompilerGeneratedAttribute]
private void set_NgenPriority(int value);
    [CompilerGeneratedAttribute]
internal bool get_NgenDependencies();
    [CompilerGeneratedAttribute]
private void set_NgenDependencies(bool value);
    internal static Ngen TryGetNgenForFile(VsixPackage vsixPkg, string fileName, string fileLocation, string defaultNgenConfigPath, IDictionary`2<string, string> variableMapping, ILogger logger, NgenArchitecture defaultNgenArchitecture);
    internal void Queue(IRegistry registry, ILogger logger);
    private void EnsureInitialized();
}
internal static class Microsoft.VisualStudio.Setup.Installer.NgenHelper : object {
    internal static string NgenQueueKey32;
    internal static string NgenQueueKey64;
    internal static string NgenQueueKeyArm64;
    private static object RegistryLock;
    private static int NgenActivitiesTimeoutInSeconds;
    private static Random random;
    private static NgenHelper();
    internal static IEnumerable`1<NgenArchitecture> GetArchitectures(IServiceProvider serviceProvider);
    internal static void QueueBinaryForNgen(string assemblyPath, IEnumerable`1<NgenArchitecture> architectures, int ngenPriority, bool ngenDependencies, IEnumerable`1<string> configFilePaths, IRegistry registry, ILogger logger);
    internal static bool ExecuteQueuedNgenTasks(IServiceProvider serviceProvider, IEnumerable`1<NgenArchitecture> architectures, CancellationToken token, int priority);
    internal static bool PauseNgenTasks(IServiceProvider serviceProvider, IEnumerable`1<NgenArchitecture> architectures, CancellationToken token);
    internal static bool UpdateQueueNgenTasks(IServiceProvider serviceProvider, IEnumerable`1<NgenArchitecture> architectures, CancellationToken token);
    internal static bool ContinueNgenTasks(IServiceProvider serviceProvider, IEnumerable`1<NgenArchitecture> architectures, CancellationToken token);
    private static bool ExecuteNgenOperation(IServiceProvider serviceProvider, IEnumerable`1<NgenArchitecture> architectures, string commandLine, CancellationToken token);
    private static string GetNgenPath(IFileSystem fileSystem, NgenArchitecture arch);
}
internal class Microsoft.VisualStudio.Setup.Installer.NuGetPackageInstaller : FileInstaller {
    private IFileSystem fileSystem;
    private ISettings settings;
    private string nugetFallbackFolder;
    internal NuGetPackageInstaller(IServiceProvider container, ISettings settings);
    protected virtual InstallResult InstallCoreInternal(string localPath, string installDir, InstallablePackage pkg);
    private InstallResult ExtractNupkg(ILogger logger, NupkgLoggerAdapter loggerAdapter, string installerFile, string targetPath, NuGetPackage nuGetPackage);
    private void HandleSignatureException(ILogger logger, SignatureException ex);
    private bool VerifyInstallSuccess(string packageId, string packageVersion, string targetPath);
    private void RemoveNupkgFromInstallFolder(ILogger logger, string packageId, string packageVersion, string targetPath);
    private void AddRelativeFilesAndDirectoriesRecursively(NuGetPackage nuGetPackage, ILogger logger, string path);
    protected virtual InstallResult RepairCoreInternal(string installDir, InstallablePackage pkg, string localPath);
    protected virtual InstallResult UninstallCoreInternal(string installDir, InstallablePackage pkg, string localPath, bool isManifestCached);
    internal bool TryGetTargetPath(NuGetPackage nuGetPackage, String& targetPath);
    private void DeleteNugetConfigIfNecessary(ILogger logger);
    private FileLogger GetLoggerForPackage(NuGetPackage pkg, string installerFile);
    [CompilerGeneratedAttribute]
private void <AddRelativeFilesAndDirectoriesRecursively>g__getRelativeFilesAndDirectoriesRecursively|9_0(string basePath, string subFolder, <>c__DisplayClass9_0& );
}
internal class Microsoft.VisualStudio.Setup.Installer.PROPERTYKEY : ValueType {
    public Guid FormatId;
    public UInt32 PropertyId;
}
internal class Microsoft.VisualStudio.Setup.Installer.PROPVARIANT : ValueType {
    public ushort Vt;
    public IntPtr PointerVal;
    public short BoolVal;
    public int IntVal;
    public UInt32 UIntVal;
}
[GuidAttribute("00021401-0000-0000-C000-000000000046")]
internal class Microsoft.VisualStudio.Setup.Installer.ShellLink : object {
}
internal class Microsoft.VisualStudio.Setup.Installer.SystemTime : ValueType {
    private short wYear;
    private short wMonth;
    private short wDayOfWeek;
    private short wDay;
    private short wHour;
    private short wMinute;
    private short wSecond;
    private short wMilliseconds;
    internal DateTime ToDateTime();
}
internal class Microsoft.VisualStudio.Setup.Installer.Tool : object {
    internal static int Retries;
    internal static TimeSpan TimeBetweenRetries;
    private bool redirectOutput;
    private bool checkSignature;
    private bool killOnTimeout;
    private bool processWillBeElevating;
    private bool isInRoot;
    private ILogger logger;
    [CompilerGeneratedAttribute]
private string <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <Timeout>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfRetries>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ToolFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WorkingDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private IFileSystem <FileSystem>k__BackingField;
    [CompilerGeneratedAttribute]
private IProcessService <ProcessService>k__BackingField;
    [CompilerGeneratedAttribute]
private ISignatureVerifierManager <Verifier>k__BackingField;
    public string Arguments { get; private set; }
    public string CommandLine { get; }
    public Nullable`1<TimeSpan> Timeout { get; public set; }
    public int NumberOfRetries { get; public set; }
    public string ToolFile { get; private set; }
    public string WorkingDirectory { get; public set; }
    private IFileSystem FileSystem { get; }
    private IProcessService ProcessService { get; }
    private ISignatureVerifierManager Verifier { get; }
    public Tool(IServiceProvider serviceProvider, string toolFile, string arguments, bool redirectOutput, bool checkSignature, bool killOnTimeout, bool processWillBeElevating, bool isInRoot);
    private static Tool();
    [CompilerGeneratedAttribute]
public virtual string get_Arguments();
    [CompilerGeneratedAttribute]
private void set_Arguments(string value);
    public string get_CommandLine();
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_Timeout();
    [CompilerGeneratedAttribute]
public void set_Timeout(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public int get_NumberOfRetries();
    [CompilerGeneratedAttribute]
public void set_NumberOfRetries(int value);
    [CompilerGeneratedAttribute]
public string get_ToolFile();
    [CompilerGeneratedAttribute]
private void set_ToolFile(string value);
    [CompilerGeneratedAttribute]
public string get_WorkingDirectory();
    [CompilerGeneratedAttribute]
public void set_WorkingDirectory(string value);
    public virtual Result Run(CancellationToken token);
    [CompilerGeneratedAttribute]
private IFileSystem get_FileSystem();
    [CompilerGeneratedAttribute]
private IProcessService get_ProcessService();
    [CompilerGeneratedAttribute]
private ISignatureVerifierManager get_Verifier();
    private SignatureManager GetSignatureManager(IServiceProvider serviceProvider);
    private Result Run(string arguments);
    private void AppendData(SynchronizedStringBuilder ouptut, DataReceivedEventArgs args);
    private Result CheckSignature(string path);
    private Result ProcessVerification(VerificationInformation verification, string fileName);
}
public class Microsoft.VisualStudio.Setup.Installer.VsixInstaller : FileInstaller {
    private static char AltDirectorySeparatorChar;
    private static char DirectorySeparatorChar;
    private static string ManifestName;
    private static string ManifestPath;
    private static string CatalogName;
    private static string CatalogPath;
    private static string VsixManifestName;
    private static string VsixManifestPath;
    private static string RootDirectory;
    private static string CertificateInformationFileName;
    private static string CsvDelimeter;
    private static string Quote;
    private static string urlAssociationName;
    private static string fileAssociationName;
    private static string applicationDescriptionName;
    private static string applicationName;
    private NgenArchitecture defaultArchitecture;
    private IShortcutFactory shortcutFactory;
    private bool isRepair;
    private StringBuilder csvBuilder;
    private Nullable`1<VsixType> vsixType;
    [CompilerGeneratedAttribute]
private InstallResultCollection <ReturnCodes>k__BackingField;
    protected InstallResultCollection ReturnCodes { get; }
    public VsixInstaller(IServiceProvider container);
    public VsixInstaller(IServiceProvider container, NgenArchitecture defaultArchitecture);
    public VsixInstaller(IServiceProvider container, NgenArchitecture defaultArchitecture, IShortcutFactory shortcutFactory);
    private static VsixInstaller();
    [CompilerGeneratedAttribute]
protected virtual InstallResultCollection get_ReturnCodes();
    public VsixType GetVsixType(Stream vsixStream);
    internal VsixType GetVsixType(string vsixPath, VsixPackage vsixPackage);
    public string CreateVsixV3CertificateInformation(Package package, string installDir);
    public string GetExtensionDir(VsixPackage pkg, string installDir);
    public InstallResult Install(string localPath, string installDir, VsixPackage pkg);
    protected virtual InstallResult InstallCoreInternal(string localPath, string installDir, InstallablePackage pkg);
    private bool CanOverwriteFiles(VsixType vsixType, VsixPackage vsix);
    protected virtual InstallResult RepairCoreInternal(string installDir, InstallablePackage pkg, string localPath);
    public InstallResult Uninstall(string installDir, VsixPackage pkg);
    protected virtual InstallResult UninstallCoreInternal(string installDir, InstallablePackage pkg, string localPath, bool isManifestCached);
    private Tuple`2<bool, string> UninstallWithoutCachedManifestAndPayload(VsixPackage vsixPkg, IDictionary`2<string, string> nonEnvironmentVars, string layoutDir, SortedSet`1<string> dirsDeleteCandidates, FileLogger logger);
    private Tuple`2<bool, string> ProcessVsixForUninstall(IDictionary`2<string, string> nonEnvironmentVars, IDictionary`2<string, string> folderMappings, string layoutDir, VsixType vsixType, FileLogger logger, SortedSet`1<string> dirsDeleteCandidates, IEnumerable`1<string> fileNames);
    private bool ProcessFileForUninstall(IDictionary`2<string, string> resolvedFolderMapping, string layoutDir, VsixType vsixType, FileLogger logger, SortedSet`1<string> dirsDeleteCandidates, string fileName, Boolean& rebootRequired);
    private FileLogger GetLoggerForPackage(VsixPackage pkg, string installerFile);
    private VsixType ParseVsix(IDictionary`2<string, string> nonEnvironmentVars, VsixPackage vsixPkg, string installerFile, string installDir, String& layoutDir);
    private string GetVsixV3LayoutForPart(string partPath, string layoutDir, IDictionary`2<string, string> resolvedFolderMappings, String& layoutDirOfFile);
    private IDictionary`2<string, string> GetResolvedFolderMappings(IDictionary`2<string, string> nonEnvironmentVars, IDictionary`2<string, string> folderMappings);
    private bool TryGetRootFolder(string partPath, String& rootFolder);
    internal void InstallVsixManifest(VsixPackage vsixPkg, IDictionary`2<string, string> nonEnvironmentVars, IRegistry registry, ILogger logger);
    internal void UninstallVsixManifest(VsixPackage vsixPkg, IDictionary`2<string, string> nonEnvironmentVars, IRegistry registry, ILogger logger);
    internal void InstallProgIds(VsixPackage vsixPkg, IRegistry registry, IDictionary`2<string, string> nonEnvironmentVars, ILogger logger);
    internal void UninstallProgIds(VsixPackage vsixPkg, IRegistry registry, IDictionary`2<string, string> nonEnvironmentVars, ILogger logger);
    internal void InstallFileAssociations(VsixPackage vsixPkg, IRegistry registry, IDictionary`2<string, string> nonEnvironmentVars, ILogger logger);
    internal void UninstallFileAssociations(VsixPackage vsixPkg, IRegistry registry, IDictionary`2<string, string> nonEnvironmentVars, ILogger logger);
    internal void InstallUrlAssociations(VsixPackage vsixPkg, IRegistry registry, IDictionary`2<string, string> nonEnvironmentVars, ILogger logger);
    internal void UninstallUrlAssociations(VsixPackage vsixPkg, IRegistry registry, IDictionary`2<string, string> nonEnvironmentVars, ILogger logger);
    internal void InstallDefaultProgram(VsixPackage vsixPkg, IRegistry registry, IDictionary`2<string, string> nonEnvironmentVars, ILogger logger);
    internal void UninstallDefaultProgram(VsixPackage vsixPkg, IRegistry registry, IDictionary`2<string, string> nonEnvironmentVars, ILogger logger);
    internal void DoShortcutAction(VsixPackage pkg, IDictionary`2<string, string> variableMapping, bool create);
    internal bool ValidateProgId(string progId, ILogger logger);
    private VsixPackage GetEmbeddedVsixPackage(IPackageIdentity vsix, Package package, ExecuteAction action, ILogger logger, bool isManifestCached);
    private VsixPackage GetEmbeddedVsixPackageFromPayload(Package package, ILogger logger);
    internal string GetNgenConfigApplication(VsixPackage vsixPkg, IDictionary`2<string, string> variableMapping);
    protected virtual void AddPackageTelemetryProperties(IDictionary`2<string, object> telemetryProperties, IPackage package);
    private void PersistVsixData(VsixPackage pkgToCache, VsixPackage embeddedVsixPkg);
    private InstallResult ReturnVSIXReturnCode(InstallablePackage pkg, ExecuteAction action, RebootType rebootPending, Nullable`1<int> code, string resourceId, string details, ILogger pkgLogger);
    private X509Chain GetX509Chain(bool useMachineContext);
    private void BuildCsvString(string csvElement, bool lastElement);
    private bool FullChainCheck(X509Chain x509Chain);
    [CompilerGeneratedAttribute]
private void <InstallCoreInternal>g__install|33_1(PackagePart part, bool saveExtensionManifest, <>c__DisplayClass33_0& , <>c__DisplayClass33_1& , <>c__DisplayClass33_2& , <>c__DisplayClass33_3& , <>c__DisplayClass33_4& );
}
internal class Microsoft.VisualStudio.Setup.Installer.VsixInstallerReturnCodes : InstallResultCollection {
}
public enum Microsoft.VisualStudio.Setup.Installer.VsixType : Enum {
    public int value__;
    public static VsixType Fopx;
    public static VsixType VsixV2;
    public static VsixType VsixV3;
}
internal class Microsoft.VisualStudio.Setup.Installer.WindowsFeatureInstaller : InstallerBase {
    private Dictionary`2<InstallResult, InstallRetry> retryCodes;
    [CompilerGeneratedAttribute]
private InstallResultCollection <ReturnCodes>k__BackingField;
    protected InstallResultCollection ReturnCodes { get; }
    internal WindowsFeatureInstaller(IServiceProvider container);
    [CompilerGeneratedAttribute]
protected virtual InstallResultCollection get_ReturnCodes();
    protected virtual InstallResult InstallCore(string localPath, string installDir, InstallablePackage pkg);
    protected virtual InstallResult RepairCore(string installDir, InstallablePackage pkg, string localPath);
    protected virtual InstallResult UninstallCore(string installDir, InstallablePackage pkg, string localPath, bool isManifestCached);
}
internal class Microsoft.VisualStudio.Setup.Installer.WindowsInstaller.ExternalUIRecordHandler : MulticastDelegate {
    public ExternalUIRecordHandler(object object, IntPtr method);
    public virtual MessageResult Invoke(InstallMessage messageType, Record messageRecord, MessageButtons buttons, MessageIcon icon, MessageDefaultButton defaultButton);
    public virtual IAsyncResult BeginInvoke(InstallMessage messageType, Record messageRecord, MessageButtons buttons, MessageIcon icon, MessageDefaultButton defaultButton, AsyncCallback callback, object object);
    public virtual MessageResult EndInvoke(IAsyncResult result);
}
internal class Microsoft.VisualStudio.Setup.Installer.WindowsInstaller.ExternalUIRecordProxy : object {
    [CompilerGeneratedAttribute]
private ExternalUIRecordHandler <Handler>k__BackingField;
    public ExternalUIRecordHandler Handler { get; }
    internal ExternalUIRecordProxy(ExternalUIRecordHandler handler);
    [CompilerGeneratedAttribute]
public ExternalUIRecordHandler get_Handler();
    public int ProxyHandler(IntPtr contextPtr, int messageType, int recordHandle);
}
internal static class Microsoft.VisualStudio.Setup.Installer.WindowsInstaller.Installer : object {
    private static IList externalUIHandlers;
    private static bool rebootRequired;
    private static bool rebootInitiated;
    internal static bool RebootRequired { get; }
    internal static bool RebootInitiated { get; }
    private static Installer();
    internal static bool get_RebootRequired();
    internal static bool get_RebootInitiated();
    internal static int InstallProduct(string packagePath, string commandLine);
    internal static int ConfigureProduct(string productCode, int installLevel, int installState, string commandLine);
    internal static ExternalUIRecordHandler SetExternalUI(ExternalUIRecordHandler uiHandler, InstallLogModes messageFilter);
    internal static INSTALLUILEVEL SetInternalUI(INSTALLUILEVEL uiOptions);
    internal static void EnableLog(InstallLogModes logModes, string logFile);
    internal static void EnableLog(InstallLogModes logModes, string logFile, bool append, bool flushEveryLine);
    private static int CheckInstallResult(int ret);
}
internal abstract class Microsoft.VisualStudio.Setup.Installer.WindowsInstaller.InstallerHandle : object {
    private MsiHandle handle;
    [SuppressMessageAttribute("Microsoft.Design", "CA1065:DoNotRaiseExceptionsInUnexpectedLocations")]
public int Handle { get; }
    public bool IsClosed { get; }
    internal object Sync { get; }
    protected InstallerHandle(int handle);
    public int get_Handle();
    public bool get_IsClosed();
    internal object get_Sync();
    public sealed virtual void Dispose();
    public void Close();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    protected virtual void Dispose(bool disposing);
}
internal enum Microsoft.VisualStudio.Setup.Installer.WindowsInstaller.InstallLevel : Enum {
    public int value__;
    public static InstallLevel INSTALLLEVEL_DEFAULT;
    public static InstallLevel INSTALLLEVEL_MINIMUM;
    public static InstallLevel INSTALLLEVEL_MAXIMUM;
}
[FlagsAttribute]
internal enum Microsoft.VisualStudio.Setup.Installer.WindowsInstaller.InstallLogModes : Enum {
    public int value__;
    public static InstallLogModes None;
    public static InstallLogModes ActionData;
    public static InstallLogModes ActionStart;
    public static InstallLogModes CommonData;
    public static InstallLogModes Error;
    public static InstallLogModes ExtraDebug;
    public static InstallLogModes FatalExit;
    public static InstallLogModes FilesInUse;
    public static InstallLogModes Info;
    public static InstallLogModes Initialize;
    public static InstallLogModes InstallStart;
    public static InstallLogModes InstallEnd;
    public static InstallLogModes LogOnlyOnError;
    public static InstallLogModes LogPerformance;
    public static InstallLogModes OutOfDiskSpace;
    public static InstallLogModes Progress;
    public static InstallLogModes PropertyDump;
    public static InstallLogModes ResolveSource;
    public static InstallLogModes RMFilesInUse;
    public static InstallLogModes ShowDialog;
    public static InstallLogModes Terminate;
    public static InstallLogModes User;
    public static InstallLogModes Verbose;
    public static InstallLogModes Warning;
}
internal enum Microsoft.VisualStudio.Setup.Installer.WindowsInstaller.InstallMessage : Enum {
    public int value__;
    public static InstallMessage FatalExit;
    public static InstallMessage Error;
    public static InstallMessage Warning;
    public static InstallMessage User;
    public static InstallMessage Info;
    public static InstallMessage FilesInUse;
    public static InstallMessage ResolveSource;
    public static InstallMessage OutOfDiskSpace;
    public static InstallMessage ActionStart;
    public static InstallMessage ActionData;
    public static InstallMessage Progress;
    public static InstallMessage CommonData;
    public static InstallMessage Initialize;
    public static InstallMessage Terminate;
    public static InstallMessage ShowDialog;
    public static InstallMessage Performance;
    public static InstallMessage RMFilesInUse;
    public static InstallMessage InstallStart;
    public static InstallMessage InstallEnd;
}
internal enum Microsoft.VisualStudio.Setup.Installer.WindowsInstaller.InstallState : Enum {
    public int value__;
    public static InstallState NotUsed;
    public static InstallState BadConfig;
    public static InstallState Incomplete;
    public static InstallState SourceAbsent;
    public static InstallState MoreData;
    public static InstallState InvalidArgument;
    public static InstallState Unknown;
    public static InstallState Broken;
    public static InstallState Advertised;
    public static InstallState Removed;
    public static InstallState Absent;
    public static InstallState Local;
    public static InstallState Source;
    public static InstallState Default;
}
public class Microsoft.VisualStudio.Setup.Installer.WindowsInstaller.InvalidHandleException : Exception {
    public InvalidHandleException(string msg, Exception innerException);
    public InvalidHandleException(string msg);
    protected InvalidHandleException(SerializationInfo info, StreamingContext context);
}
internal interface Microsoft.VisualStudio.Setup.Installer.WindowsInstaller.IRecord {
    public int FieldCount { get; }
    public abstract virtual int get_FieldCount();
    public abstract virtual int GetInteger(int field);
    public abstract virtual string GetString(int field);
}
internal enum Microsoft.VisualStudio.Setup.Installer.WindowsInstaller.MessageButtons : Enum {
    public int value__;
    public static MessageButtons OK;
    public static MessageButtons OKCancel;
    public static MessageButtons AbortRetryIgnore;
    public static MessageButtons YesNoCancel;
    public static MessageButtons YesNo;
    public static MessageButtons RetryCancel;
}
internal enum Microsoft.VisualStudio.Setup.Installer.WindowsInstaller.MessageDefaultButton : Enum {
    public int value__;
    public static MessageDefaultButton Button1;
    public static MessageDefaultButton Button2;
    public static MessageDefaultButton Button3;
}
internal enum Microsoft.VisualStudio.Setup.Installer.WindowsInstaller.MessageIcon : Enum {
    public int value__;
    public static MessageIcon None;
    public static MessageIcon Error;
    public static MessageIcon Hand;
    public static MessageIcon Stop;
    public static MessageIcon Question;
    public static MessageIcon Exclamation;
    public static MessageIcon Warning;
    public static MessageIcon Asterisk;
    public static MessageIcon Information;
}
internal enum Microsoft.VisualStudio.Setup.Installer.WindowsInstaller.MessageResult : Enum {
    public int value__;
    public static MessageResult Error;
    public static MessageResult None;
    public static MessageResult OK;
    public static MessageResult Cancel;
    public static MessageResult Abort;
    public static MessageResult Retry;
    public static MessageResult Ignore;
    public static MessageResult Yes;
    public static MessageResult No;
}
internal class Microsoft.VisualStudio.Setup.Installer.WindowsInstaller.MsiHandle : object {
    private bool disposedValue;
    [CompilerGeneratedAttribute]
private int <Handle>k__BackingField;
    public int Handle { get; private set; }
    public bool IsClosed { get; }
    public MsiHandle(int handle);
    protected virtual override void Finalize();
    [CompilerGeneratedAttribute]
public int get_Handle();
    [CompilerGeneratedAttribute]
private void set_Handle(int value);
    public bool get_IsClosed();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
internal class Microsoft.VisualStudio.Setup.Installer.WindowsInstaller.Record : InstallerHandle {
    [CompilerGeneratedAttribute]
private bool <IsFormatStringInvalid>k__BackingField;
    public int FieldCount { get; }
    public string FormatString { get; public set; }
    protected internal bool IsFormatStringInvalid { get; protected internal set; }
    internal Record(int handle);
    public sealed virtual int get_FieldCount();
    public string get_FormatString();
    public void set_FormatString(string value);
    [CompilerGeneratedAttribute]
protected internal bool get_IsFormatStringInvalid();
    [CompilerGeneratedAttribute]
protected internal void set_IsFormatStringInvalid(bool value);
    public static Record FromHandle(int handle);
    public void SetString(int field, string value);
    public sealed virtual int GetInteger(int field);
    public sealed virtual string GetString(int field);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private void CheckRange(int field);
}
internal class Microsoft.VisualStudio.Setup.Installer.ZipInstaller : FileInstaller {
    internal ZipInstaller(IServiceProvider container);
    protected virtual InstallResult InstallCoreInternal(string localPath, string installDir, InstallablePackage pkg);
    protected virtual InstallResult RepairCoreInternal(string installDir, InstallablePackage pkg, string localPath);
    protected virtual InstallResult UninstallCoreInternal(string installDir, InstallablePackage pkg, string localPath, bool isManifestCached);
    private FileLogger GetLoggerForPackage(ZipPackage pkg, string installerFile);
    internal bool TryGetTargetPath(string installDir, ZipPackage zipPackage, String& targetPath);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Setup.Installer.ZipInstaller/<CreateRegexes>d__6")]
private IEnumerable`1<Regex> CreateRegexes(IList`1<string> patterns, ILogger logger);
    private InstallResult ExtractEntries(IEnumerable`1<ZipArchiveEntry> entries, string targetPath, IEnumerable`1<Regex> exclusions, ZipPackage package, ILogger logger);
    private bool ExtractEntry(ZipArchiveEntry entry, string fullPath, ZipPackage package, RebootType& rebootRequired, ILogger logger);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.InstallOperation : object {
    private static IEnumerable`1<string> UpdateRelatedKeys;
    private static string VsSetupMutex;
    private static string EmptyPackageName;
    private IServiceProvider services;
    private Dictionary`2<string, object> telemetryProperties;
    private ExecuteAction bootstrapperAction;
    private InstallSchedulerFactory installSchedulerFactory;
    private IList`1<IPackageProgress> otherFailedPackages;
    [NullableAttribute("2")]
private ISingletonService globalMutexSingletonService;
    [NullableAttribute("2")]
private ICacheManager cacher;
    [NullableAttribute("2")]
private ILogger logger;
    [NullableAttribute("2")]
private IPolicyService policy;
    [NullableAttribute("2")]
private ProgressAggregatorBase installProgress;
    [NullableAttribute("2")]
private ProgressAggregatorBase downloadProgress;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IDictionary`2<string, string> properties;
    [NullableAttribute("2")]
private CancellationTokenSource linkedCancellationTokenSource;
    [NullableAttribute("2")]
private ITester tester;
    [NullableAttribute("2")]
private Schedule schedule;
    private bool isDisposed;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ErrorReporter <ErrorReporter>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IEngineContext <EngineContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCancelled>k__BackingField;
    [NullableAttribute("2")]
private ErrorReporter ErrorReporter { get; }
    [NullableAttribute("2")]
internal IEngineContext EngineContext { get; }
    public IReadOnlyDictionary`2<string, object> TelemetryProperties { get; }
    private bool IsCancelled { get; private set; }
    internal InstallOperation(Product product, IEnumerable`1<IPackage> packages, string destination, ExecuteAction bootstrapperAction, IServiceProvider services, IEngineContext engineContext, RunOnceInformation runOnceInformation, ErrorReporter errorReporter, FileLogger errorFileLogger, IEnumerable`1<string> uninstallExtensionCatalogIds);
    private static InstallOperation();
    private void DownloadOnCanceled(object obj, EventArgs args);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private ErrorReporter get_ErrorReporter();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal IEngineContext get_EngineContext();
    public sealed virtual IReadOnlyDictionary`2<string, object> get_TelemetryProperties();
    [CompilerGeneratedAttribute]
private bool get_IsCancelled();
    [CompilerGeneratedAttribute]
private void set_IsCancelled(bool value);
    private IDictionary`2<string, string> GetProperties();
    internal void Schedule();
    public sealed virtual void Run(CancellationToken token);
    internal void DeleteUserProfileUpdateProperties(Instance instance);
    private void OnError(object sender, ActivityEventArgs e);
    private string GetGenericErrorFromActivity(IActivity activity);
    private void Initialize();
    internal void UpdateInstanceWithProgress(Instance instance, IEnumerable`1<IPackageProgress> packageDownloadProgressCollection, IEnumerable`1<IPackageProgress> packageInstallProgressCollection);
    internal void SetPrecheckParametersForScheduledOperation(PrecheckParameters precheckParams, IReadOnlyDictionary`2<string, string> engineProperties);
    private bool HasMSIToBeApplied(IReadOnlyList`1<IActivity> packagesToInstallOrUninstall);
    private void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.InstallScheduler : InstallSchedulerBase {
    [NullableAttribute("2")]
private RunOnceInformation runOnceInformation;
    private ISingletonService globalMutexSingletonService;
    private ISingletonService operationSingletonService;
    public InstallScheduler(SchedulerServiceOptions serviceOptions, Product product, ISet`1<IPackage> plannedPackages, string destination, ExecuteAction bootstrapperAction, IEngineContext engineContext, RunOnceInformation runOnceInformation, ErrorReporter errorReporter, FileLogger errorFileLogger, ISet`1<string> catalogsToUninstall, ISingletonService globalMutexSingletonService);
    private protected virtual void QueueInitialActivitiesImpl(Schedule schedule, string installDir, ISet`1<IPackage> plannedPackages);
    private protected virtual void QueuePreparationActivitiesImpl(Schedule schedule, Plan plan, IDictionary`2<string, string> engineProperties, string installDir, IDictionary`2<string, object> telemetryProperties);
    private protected virtual void QueuePreInstallActivitiesImpl(Schedule schedule);
    private protected virtual void QueueInstallActivitiesImpl(Schedule schedule);
    private protected virtual void QueuePostInstallActivitiesImpl(Schedule schedule, string installDir);
    private protected virtual void QueueCleanupActivitiesImpl(Schedule schedule, string installDir);
    private protected virtual void QueueFinalActivitiesImpl(Schedule schedule, ISet`1<IPackage> plannedPackages);
    private void QueueInitializer(Coordinator coordinator, Initialize initializer);
    private void QueueFinalizer(Coordinator coordinator, Finalize finalizer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.VisualStudio.Setup.InstallSchedulerBase : object {
    private static int PrecheckActivityInterval;
    [NullableAttribute("2")]
private ErrorReporter errorReporter;
    [NullableAttribute("2")]
private FileLogger errorFileLogger;
    private ISet`1<IPackage> plannedPackages;
    [CompilerGeneratedAttribute]
private SchedulerServiceOptions <ServiceOptions>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Product <Product>k__BackingField;
    [CompilerGeneratedAttribute]
private ExecuteAction <BootstrapperAction>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IEngineContext <EngineContext>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Destination>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <CatalogsToUninstall>k__BackingField;
    private protected SchedulerServiceOptions ServiceOptions { get; }
    [NullableAttribute("2")]
private protected Product Product { get; }
    private protected ExecuteAction BootstrapperAction { get; }
    [NullableAttribute("2")]
private protected IEngineContext EngineContext { get; }
    private protected string Destination { get; }
    private protected ISet`1<string> CatalogsToUninstall { get; }
    internal InstallSchedulerBase(SchedulerServiceOptions serviceOptions, Product product, ISet`1<IPackage> plannedPackages, string destination, ExecuteAction bootstrapperAction, IEngineContext engineContext, ErrorReporter errorReporter, FileLogger errorFileLogger, ISet`1<string> catalogsToUninstall);
    [CompilerGeneratedAttribute]
private protected SchedulerServiceOptions get_ServiceOptions();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private protected Product get_Product();
    [CompilerGeneratedAttribute]
private protected ExecuteAction get_BootstrapperAction();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private protected IEngineContext get_EngineContext();
    [CompilerGeneratedAttribute]
private protected string get_Destination();
    [CompilerGeneratedAttribute]
private protected ISet`1<string> get_CatalogsToUninstall();
    internal void Schedule(string installDir, Dictionary`2<string, string> engineProperties, IDictionary`2<string, object> telemetryProperties, Schedule schedule, Plan plan);
    private protected abstract virtual void QueueInitialActivitiesImpl(Schedule schedule, string installDir, ISet`1<IPackage> plannedPackages);
    private void QueueInitialActivities(Schedule schedule, string installDir, ISet`1<IPackage> plannedPackages);
    private protected abstract virtual void QueuePreparationActivitiesImpl(Schedule schedule, Plan plan, IDictionary`2<string, string> engineProperties, string installDir, IDictionary`2<string, object> telemetryProperties);
    private void QueuePreparationActivities(Schedule schedule, Plan plan, IDictionary`2<string, string> engineProperties, string installDir, IDictionary`2<string, object> telemetryProperties);
    private protected abstract virtual void QueuePreInstallActivitiesImpl(Schedule schedule);
    private void QueuePreInstallActivities(Schedule schedule);
    private protected abstract virtual void QueueInstallActivitiesImpl(Schedule schedule);
    private void QueueInstallActivities(Schedule schedule);
    private protected abstract virtual void QueuePostInstallActivitiesImpl(Schedule schedule, string installDir);
    private void QueuePostInstallActivities(Schedule schedule, string installDir);
    private protected abstract virtual void QueueCleanupActivitiesImpl(Schedule schedule, string installDir);
    private void QueueCleanupActivities(Schedule schedule, string installDir);
    private protected abstract virtual void QueueFinalActivitiesImpl(Schedule schedule, ISet`1<IPackage> plannedPackages);
    private void QueueFinalActivities(Schedule schedule, ISet`1<IPackage> plannedPackages);
    private void QueueDownloadOnlyActivities(Schedule schedule, long downloadSize, IReadOnlyDictionary`2<string, string> engineProperties, IEnumerable`1<IPackage> plannedPackages);
    internal static RelatedProcesses GetRelatedProcesses(IReadOnlyDictionary`2<string, string> engineProperties, IReadOnlyList`1<IActivity> packagesToInstallOrUninstall);
    private static void HandleProcesses(ISet`1<string> processesToCheck, IList`1<string> processesAuthored, IReadOnlyDictionary`2<string, string> engineProperties);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.InstallSchedulerFactory : object {
    [NullableAttribute("1")]
private SchedulerServiceOptions serviceOptions;
    private Product product;
    [NullableAttribute("1")]
private IEnumerable`1<IPackage> packages;
    [NullableAttribute("1")]
private string destination;
    private ExecuteAction bootstrapperAction;
    private IEngineContext engineContext;
    private RunOnceInformation runOnceInformation;
    private ErrorReporter errorReporter;
    private FileLogger errorFileLogger;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEnumerable`1<string> uninstallExtensionCatalogIds;
    internal InstallSchedulerFactory(SchedulerServiceOptions serviceOptions, Product product, IEnumerable`1<IPackage> packages, string destination, ExecuteAction bootstrapperAction, IEngineContext engineContext, RunOnceInformation runOnceInformation, ErrorReporter errorReporter, FileLogger errorFileLogger, IEnumerable`1<string> uninstallExtensionCatalogIds);
    [NullableContextAttribute("1")]
internal Schedule BuildSchedule(IDictionary`2<string, object> telemetryProperties, EventHandler`1<EventArgs> downloadOnCanceledHandler, ISingletonService globalMutexSingletonService);
    [NullableContextAttribute("1")]
private string PrepareInstallDir(IDictionary`2<string, string> engineProperties);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.InstanceDependencyManager : PackageReferenceManager {
    private IServiceProvider services;
    private IPackageReferenceManager legacyDependencyManager;
    private Lazy`1<IDictionary`2<string, Version>> lazySingletonPackageLookup;
    [NullableAttribute("2")]
private ILogger log;
    [NullableAttribute("2")]
private ICacheManager cache;
    [NullableAttribute("2")]
private ICacheManagerFactory cacheManagerFactory;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEnumerable`1<Instance> otherInstances;
    [NullableAttribute("2")]
private string currentInstanceId;
    private bool isInitialized;
    internal InstanceDependencyManager(IServiceProvider services);
    public sealed virtual bool HasInstances(IPackage package);
    public sealed virtual bool HasInstancesAboveVersion(IPackage package, Version version);
    protected virtual bool HasDependentsCore(IPackage package);
    protected virtual bool HasDowngradeDependentsCore(IPackage package, Version version);
    private bool HasInstancesForNonSingleton(IPackage package);
    private string GetSingletonProviderKey(IPackage package);
    private bool CanCheckInstances();
    private void Initialize();
    private IDictionary`2<string, Version> InitializeSingletonPackageLookup();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <Initialize>b__17_0(Instance i);
}
public class Microsoft.VisualStudio.Setup.InstanceModifiedException : EngineException {
    [NullableContextAttribute("1")]
protected InstanceModifiedException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.Setup.IOpcService {
    public abstract virtual void Verify(IServiceProvider serviceProvider, Stream packageStream, string layoutLocation);
    public abstract virtual void Extract(IServiceProvider serviceProvider, Stream packageStream, string targetDir, CancellationToken cancellationToken, bool lockFiles);
    public abstract virtual Stream ExtractFile(IServiceProvider serviceProvider, Stream packageStream, string fileName);
}
public interface Microsoft.VisualStudio.Setup.IPackageProgress {
    public IPackageIdentity Package { get; }
    public long Weight { get; }
    public long Size { get; }
    public ProgressType Type { get; }
    public abstract virtual IPackageIdentity get_Package();
    public abstract virtual long get_Weight();
    public abstract virtual long get_Size();
    public abstract virtual ProgressType get_Type();
    [CompilerGeneratedAttribute]
public abstract virtual void add_PackageProgressReceived(EventHandler`2<IPackageProgress, ProgressDataEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PackageProgressReceived(EventHandler`2<IPackageProgress, ProgressDataEventArgs> value);
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Setup.IPackageReferenceManager {
    public ExecuteAction BootstrapperAction { get; public set; }
    public abstract virtual ExecuteAction get_BootstrapperAction();
    public abstract virtual void set_BootstrapperAction(ExecuteAction value);
    public abstract virtual bool HasDependents(IPackage package);
    public abstract virtual bool HasDowngradeDependents(IPackage package, Version version);
    public abstract virtual bool IgnoreDependents(IPackage package);
}
internal interface Microsoft.VisualStudio.Setup.IPolicyUpdater {
    public abstract virtual bool UpdatePolicy(PolicySettings policySettings);
    public abstract virtual bool UpdateKeepDownloadPayloads(bool keepDownloadPayloads);
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Setup.IProgressProvider {
    [CompilerGeneratedAttribute]
public abstract virtual void add_ProgressReceived(EventHandler`1<ProgressDataEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ProgressReceived(EventHandler`1<ProgressDataEventArgs> value);
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Setup.ITester {
    public abstract virtual void Test(Object[] args);
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Setup.IWorkloadOverridesProvider {
    public abstract virtual WorkloadOverrides GetOverrides(string channelId, int waitTimeInMilliseconds);
    public abstract virtual Task`1<WorkloadOverrides> GetOverridesAsync(string channelId, int waitTimeInMilliseconds);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.KeyEqualityComparer`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<T, TKey> extractor;
    public KeyEqualityComparer`2(Func`2<T, TKey> extractor);
    public sealed virtual bool Equals(T x, T y);
    public sealed virtual int GetHashCode(T obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.LatestInstallerFeedManager : object {
    private static string LatestInstallerFeedFileExtension;
    private static Uri LatestInstallerFeedUri;
    private static string LatestInstallerFeedFileName;
    private static string SubdirectoryName;
    private IServiceProvider services;
    [NullableAttribute("2")]
private ILogger logger;
    [NullableAttribute("2")]
private ITelemetry telemetry;
    private IFileSystem fileSystem;
    private IDownloadManager downloadManager;
    private string feedCachePath;
    public LatestInstallerFeedManager(IServiceProvider serviceProvider);
    private static LatestInstallerFeedManager();
    [NullableContextAttribute("2")]
public sealed virtual LatestInstallerFeed GetLatestInstallerFeed();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.LatestInstallerFeedManager/<UpdateAsync>d__12")]
public sealed virtual Task`1<bool> UpdateAsync(CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.VisualStudio.Setup.LayoutConstants : object {
    public static string CatalogFileName;
    public static string CleanedCatalogFileName;
    public static string ChannelManifestFileName;
    public static string ResponseFileName;
    public static string ResponseTemplateFileName;
    public static string LayoutSettingsFile;
    public static string InstallerOPCFile;
    public static string BootstrapperStaticName;
    public static string ArchiveFolder;
    public static string CeipEnvironmentVariable;
    public static string NeutralLanguage;
    public static string UseLatestInstallerCommand;
    public static string VSConfigFileName;
    private static LayoutConstants();
}
internal class Microsoft.VisualStudio.Setup.LayoutContext : object {
    [CompilerGeneratedAttribute]
private IPackage <Product>k__BackingField;
    [CompilerGeneratedAttribute]
private DependencyComparisonSeed <Seed>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Destination>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InstallResponseFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InstallResponseTemplateFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LayoutSettingsFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResponseFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InstallChannelManifestPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CatalogPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InstallerPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BootstrapperPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InstallChannelUri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChannelUri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChannelId>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, DependencyType> <ComponentsToAdd>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <All>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeOptional>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeRecommended>k__BackingField;
    [CompilerGeneratedAttribute]
private LayoutMode <LayoutMode>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <CatalogsToClean>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseLatestInstaller>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProductArch>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VSConfigFilePath>k__BackingField;
    public IPackage Product { get; public set; }
    public DependencyComparisonSeed Seed { get; public set; }
    public string Destination { get; public set; }
    public string InstallResponseFilePath { get; public set; }
    public string InstallResponseTemplateFilePath { get; public set; }
    public string LayoutSettingsFilePath { get; public set; }
    public string ResponseFilePath { get; public set; }
    public string InstallChannelManifestPath { get; public set; }
    public string CatalogPath { get; public set; }
    public string InstallerPath { get; public set; }
    public string BootstrapperPath { get; public set; }
    public string InstallChannelUri { get; public set; }
    public string ChannelUri { get; public set; }
    public string ChannelId { get; public set; }
    public Dictionary`2<string, DependencyType> ComponentsToAdd { get; }
    public bool All { get; public set; }
    public bool IncludeOptional { get; public set; }
    public bool IncludeRecommended { get; public set; }
    public LayoutMode LayoutMode { get; public set; }
    public IList`1<string> CatalogsToClean { get; }
    public bool UseLatestInstaller { get; public set; }
    public string ProductArch { get; public set; }
    public string VSConfigFilePath { get; public set; }
    [CompilerGeneratedAttribute]
public IPackage get_Product();
    [CompilerGeneratedAttribute]
public void set_Product(IPackage value);
    [CompilerGeneratedAttribute]
public DependencyComparisonSeed get_Seed();
    [CompilerGeneratedAttribute]
public void set_Seed(DependencyComparisonSeed value);
    [CompilerGeneratedAttribute]
public string get_Destination();
    [CompilerGeneratedAttribute]
public void set_Destination(string value);
    [CompilerGeneratedAttribute]
public string get_InstallResponseFilePath();
    [CompilerGeneratedAttribute]
public void set_InstallResponseFilePath(string value);
    [CompilerGeneratedAttribute]
public string get_InstallResponseTemplateFilePath();
    [CompilerGeneratedAttribute]
public void set_InstallResponseTemplateFilePath(string value);
    [CompilerGeneratedAttribute]
public string get_LayoutSettingsFilePath();
    [CompilerGeneratedAttribute]
public void set_LayoutSettingsFilePath(string value);
    [CompilerGeneratedAttribute]
public string get_ResponseFilePath();
    [CompilerGeneratedAttribute]
public void set_ResponseFilePath(string value);
    [CompilerGeneratedAttribute]
public string get_InstallChannelManifestPath();
    [CompilerGeneratedAttribute]
public void set_InstallChannelManifestPath(string value);
    [CompilerGeneratedAttribute]
public string get_CatalogPath();
    [CompilerGeneratedAttribute]
public void set_CatalogPath(string value);
    [CompilerGeneratedAttribute]
public string get_InstallerPath();
    [CompilerGeneratedAttribute]
public void set_InstallerPath(string value);
    [CompilerGeneratedAttribute]
public string get_BootstrapperPath();
    [CompilerGeneratedAttribute]
public void set_BootstrapperPath(string value);
    [CompilerGeneratedAttribute]
public string get_InstallChannelUri();
    [CompilerGeneratedAttribute]
public void set_InstallChannelUri(string value);
    [CompilerGeneratedAttribute]
public string get_ChannelUri();
    [CompilerGeneratedAttribute]
public void set_ChannelUri(string value);
    [CompilerGeneratedAttribute]
public string get_ChannelId();
    [CompilerGeneratedAttribute]
public void set_ChannelId(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, DependencyType> get_ComponentsToAdd();
    [CompilerGeneratedAttribute]
public bool get_All();
    [CompilerGeneratedAttribute]
public void set_All(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeOptional();
    [CompilerGeneratedAttribute]
public void set_IncludeOptional(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeRecommended();
    [CompilerGeneratedAttribute]
public void set_IncludeRecommended(bool value);
    [CompilerGeneratedAttribute]
public LayoutMode get_LayoutMode();
    [CompilerGeneratedAttribute]
public void set_LayoutMode(LayoutMode value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_CatalogsToClean();
    [CompilerGeneratedAttribute]
public bool get_UseLatestInstaller();
    [CompilerGeneratedAttribute]
public void set_UseLatestInstaller(bool value);
    [CompilerGeneratedAttribute]
public string get_ProductArch();
    [CompilerGeneratedAttribute]
public void set_ProductArch(string value);
    [CompilerGeneratedAttribute]
public string get_VSConfigFilePath();
    [CompilerGeneratedAttribute]
public void set_VSConfigFilePath(string value);
}
internal enum Microsoft.VisualStudio.Setup.LayoutMode : Enum {
    public int value__;
    public static LayoutMode Layout;
    public static LayoutMode ModifyLayout;
    public static LayoutMode UpdateLayout;
    public static LayoutMode VerifyLayout;
    public static LayoutMode FixLayout;
    public static LayoutMode CleanLayout;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.LayoutOperation : LayoutOperationBase {
    private Coordinator prepartions;
    private AsyncCoordinator parallelDownloads;
    private Coordinator sequentialDownloads;
    private IList`1<DownloadPackage> packagesToDownload;
    private ISignatureVerifierManager verifier;
    private IFileSystem fileSystem;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IReadOnlyCollection`1<DownloadPackage> packagesToDownloadRO;
    [CompilerGeneratedAttribute]
private int <ConcurrentDownloads>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ApplyAll>k__BackingField;
    internal int ConcurrentDownloads { get; private set; }
    public long DownloadSize { get; }
    public IReadOnlyCollection`1<DownloadPackage> PackagesToDownload { get; }
    internal bool ApplyAll { get; internal set; }
    internal LayoutOperation(IServiceProvider services, ISet`1<IPackage> packages, LayoutContext layoutContext);
    [CompilerGeneratedAttribute]
internal int get_ConcurrentDownloads();
    [CompilerGeneratedAttribute]
private void set_ConcurrentDownloads(int value);
    public virtual long get_DownloadSize();
    public virtual IReadOnlyCollection`1<DownloadPackage> get_PackagesToDownload();
    [CompilerGeneratedAttribute]
internal bool get_ApplyAll();
    [CompilerGeneratedAttribute]
internal void set_ApplyAll(bool value);
    protected virtual void PlanOperation();
    public virtual void Run(CancellationToken token);
    private void OnError(object sender, ActivityEventArgs args);
    private VerificationInformation VerifySignature(string path);
    private SignatureManager GetSignatureManager(IServiceProvider services);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal abstract class Microsoft.VisualStudio.Setup.LayoutOperationBase : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static String[] NullArray;
    [NullableAttribute("1")]
private Dictionary`2<string, object> telemetryProperties;
    private Nullable`1<bool> planSuccessful;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ISet`1<string> allSelectablesInProduct;
    private bool isDisposed;
    [CompilerGeneratedAttribute]
private bool <OperationSuccessful>k__BackingField;
    [CompilerGeneratedAttribute]
private IEngineContext <EngineContext>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IServiceProvider <Services>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private LayoutContext <LayoutContext>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private ISet`1<IPackage> <Packages>k__BackingField;
    [CompilerGeneratedAttribute]
private IDependencyManager <DependencyManager>k__BackingField;
    [CompilerGeneratedAttribute]
private ICacheManager <Cacher>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private ISignatureVerifierManager <Verifier>k__BackingField;
    [CompilerGeneratedAttribute]
private IFileSystem <FileSystem>k__BackingField;
    [CompilerGeneratedAttribute]
private IMessageBus <MessageBus>k__BackingField;
    [CompilerGeneratedAttribute]
private ProgressAggregator <Progress>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IEnumerable`1<string> <AllLanguagesInProduct>k__BackingField;
    internal bool OperationSuccessful { get; internal set; }
    public long DownloadSize { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyCollection`1<DownloadPackage> PackagesToDownload { get; }
    [NullableAttribute("1")]
public IReadOnlyDictionary`2<string, object> TelemetryProperties { get; }
    internal IEngineContext EngineContext { get; internal set; }
    [NullableAttribute("1")]
protected IServiceProvider Services { get; }
    [NullableAttribute("1")]
protected LayoutContext LayoutContext { get; }
    [NullableAttribute("1")]
protected ISet`1<IPackage> Packages { get; }
    protected IDependencyManager DependencyManager { get; private set; }
    protected ICacheManager Cacher { get; private set; }
    protected ILogger Logger { get; private set; }
    protected ISignatureVerifierManager Verifier { get; private set; }
    protected IFileSystem FileSystem { get; private set; }
    protected IMessageBus MessageBus { get; private set; }
    protected ProgressAggregator Progress { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected IEnumerable`1<string> AllLanguagesInProduct { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected IEnumerable`1<string> AllSelectablesInProduct { get; }
    [NullableContextAttribute("1")]
internal LayoutOperationBase(IServiceProvider services, ISet`1<IPackage> packages, LayoutContext layoutContext);
    private static LayoutOperationBase();
    [CompilerGeneratedAttribute]
internal bool get_OperationSuccessful();
    [CompilerGeneratedAttribute]
internal void set_OperationSuccessful(bool value);
    public abstract virtual long get_DownloadSize();
    public abstract virtual IReadOnlyCollection`1<DownloadPackage> get_PackagesToDownload();
    [NullableContextAttribute("1")]
public sealed virtual IReadOnlyDictionary`2<string, object> get_TelemetryProperties();
    [CompilerGeneratedAttribute]
internal IEngineContext get_EngineContext();
    [CompilerGeneratedAttribute]
internal void set_EngineContext(IEngineContext value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected IServiceProvider get_Services();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected LayoutContext get_LayoutContext();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected ISet`1<IPackage> get_Packages();
    [CompilerGeneratedAttribute]
protected IDependencyManager get_DependencyManager();
    [CompilerGeneratedAttribute]
private void set_DependencyManager(IDependencyManager value);
    [CompilerGeneratedAttribute]
protected ICacheManager get_Cacher();
    [CompilerGeneratedAttribute]
private void set_Cacher(ICacheManager value);
    [CompilerGeneratedAttribute]
protected ILogger get_Logger();
    [CompilerGeneratedAttribute]
private void set_Logger(ILogger value);
    [CompilerGeneratedAttribute]
protected ISignatureVerifierManager get_Verifier();
    [CompilerGeneratedAttribute]
private void set_Verifier(ISignatureVerifierManager value);
    [CompilerGeneratedAttribute]
protected IFileSystem get_FileSystem();
    [CompilerGeneratedAttribute]
private void set_FileSystem(IFileSystem value);
    [CompilerGeneratedAttribute]
protected IMessageBus get_MessageBus();
    [CompilerGeneratedAttribute]
private void set_MessageBus(IMessageBus value);
    [CompilerGeneratedAttribute]
protected ProgressAggregator get_Progress();
    [CompilerGeneratedAttribute]
private void set_Progress(ProgressAggregator value);
    public bool Plan();
    public abstract virtual void Run(CancellationToken token);
    protected abstract virtual void PlanOperation();
    [NullableContextAttribute("1")]
internal void AddTelemetryProperty(string propertyName, object propertyValue);
    [NullableContextAttribute("1")]
[MemberNotNullAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected ISet`1<IPackage> ComputePackagesToApply(ISet`1<IPackage> allPackages, bool useProductFromLayoutContext);
    [MemberNotNullAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected void Initialize();
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("Microsoft.VisualStudio.Setup.LayoutOperationBase/<YieldNotificationMessages>d__63")]
protected IEnumerable`1<Message> YieldNotificationMessages(IEnumerable`1<string> msgBag, ActivityType activityType);
    [CompilerGeneratedAttribute]
protected IEnumerable`1<string> get_AllLanguagesInProduct();
    [CompilerGeneratedAttribute]
private void set_AllLanguagesInProduct(IEnumerable`1<string> value);
    protected IEnumerable`1<string> get_AllSelectablesInProduct();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <ComputePackagesToApply>b__61_0(Product p);
}
internal class Microsoft.VisualStudio.Setup.LayoutOperationFactory : object {
    [NullableAttribute("1")]
public static ILayoutOperationFactory Default;
    private static LayoutOperationFactory();
    [NullableContextAttribute("1")]
public sealed virtual IEngineOperation CreateLayoutOperation(IServiceProvider services, LayoutContext layoutContext, IEngineContext engineContext, ISet`1<IPackage> packages);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class Microsoft.VisualStudio.Setup.Layouts.LayoutHelpers : object {
    internal static string ResolveProductArch(string productArch, IEnumerable`1<Product> candidateProducts);
    private static string MapMatchAnyProductArch(string productArch);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.LegacyDependencyManager : PackageReferenceManager {
    private IServiceProvider services;
    [NullableAttribute("2")]
private ILogger log;
    [NullableAttribute("2")]
private IRegistry registryService;
    private bool isInitialized;
    internal LegacyDependencyManager(IServiceProvider services);
    protected virtual bool HasDependentsCore(IPackage package);
    protected virtual bool HasDowngradeDependentsCore(IPackage package, Version version);
    private bool HasDependentsImpl(IPackage package);
    [MemberNotNullAttribute("registryService")]
private void Initialize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.LogActionWrapper : object {
    private ILogger log;
    private string actionNameMessage;
    internal LogActionWrapper(ILogger log, string actionName, Object[] args);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.VisualStudio.Setup.LogicalExpressionEvaluator : object {
    private static string LeftParenthesis;
    private static string RightParenthesis;
    private static Char[] SplitChars;
    private static Dictionary`2<Operator, int> OperatorPriorityMap;
    private static LogicalExpressionEvaluator();
    internal static bool IsOperator(string value);
    internal static int GetPriority(string operatorValue);
    internal static bool EvaluateInfixLogicalExpression(string expression, IDictionary`2<string, bool> individualConditionEvaluatedResult);
    internal static IList`1<string> ConvertInfixToPostfixExpression(string infixExpression);
    internal static bool EvaluatePostfixLogicalExpression(IList`1<string> postfixExpression, IDictionary`2<string, bool> individualConditionEvaluatedResult);
    internal static IList`1<string> SeparateParenthesis(string value);
    internal static bool EnsureParenthesisIsCorrect(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.MachineArchConstants : object {
    public static string X86;
    public static string X64;
    public static string Arm64;
    private static MachineArchConstants();
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.Setup.Message.Extensions : object {
    [ExtensionAttribute]
public static MessageResult Prompt(IMessageBus bus, Message& message, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static MessageResult RetryPrompt(IMessageBus bus, IServiceProvider serviceProvider, Func`2<MessageResult, Nullable`1<Message>> doAction, CancellationToken token);
    private static MessageResultTypes CancelOrDefault(Message& message);
}
internal static class Microsoft.VisualStudio.Setup.MsiProgressWatcher : object {
    private static Double[] weights;
    private static List`1<MSIProgress> phases;
    [CompilerGeneratedAttribute]
private static string <CurrentAction>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <CurrentActionTemplate>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <CurrentActionDetail>k__BackingField;
    internal static string CurrentAction { get; internal set; }
    internal static string CurrentActionTemplate { get; internal set; }
    internal static string CurrentActionDetail { get; internal set; }
    private static MsiProgressWatcher();
    [CompilerGeneratedAttribute]
internal static string get_CurrentAction();
    [CompilerGeneratedAttribute]
internal static void set_CurrentAction(string value);
    [CompilerGeneratedAttribute]
internal static string get_CurrentActionTemplate();
    [CompilerGeneratedAttribute]
internal static void set_CurrentActionTemplate(string value);
    [CompilerGeneratedAttribute]
internal static string get_CurrentActionDetail();
    [CompilerGeneratedAttribute]
internal static void set_CurrentActionDetail(string value);
    internal static MSIProgress Add();
    internal static MSIProgress Current();
    internal static double Percent();
    internal static int Index();
    internal static bool IsValid();
    internal static void Reset();
}
internal static class Microsoft.VisualStudio.Setup.NgenConstants : object {
    public static double ProgressMaxBeforeNgenActivityStarts;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.NugetConfigGenerator : object {
    private static string NugetConfigFileName;
    [NullableAttribute("2")]
private ILogger logger;
    private IServiceProvider container;
    internal NugetConfigGenerator(IServiceProvider container, ILogger logger);
    internal void AddNugetConfig(string nugetConfigDirectoryPath, string fallbackfolderPath);
    internal void DeleteNugetConfig(string nugetConfigDirectoryPath);
    private XDocument GenerateXDocument(string fallbackfolderPath);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.OpcExtractor : object {
    private static int RetryDuration;
    private static int RetryCount;
    private static string RootDirectory;
    [NullableAttribute("2")]
private ILogger logger;
    private ILockService lockService;
    [NullableAttribute("2")]
private IProgressReporter progressReporter;
    private IFileSystem fileSystem;
    public OpcExtractor(IServiceProvider serviceProvider);
    private static OpcExtractor();
    public void Extract(Stream packageStream, string targetDir, CancellationToken cancellationToken, bool lockFiles);
    public Stream ExtractFile(Stream packageStream, string fileName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Setup.OpcService : object {
    public static IOpcService Default;
    private static OpcService();
    public sealed virtual void Verify(IServiceProvider serviceProvider, Stream packageStream, string layoutLocation);
    public sealed virtual void Extract(IServiceProvider serviceProvider, Stream packageStream, string targetDir, CancellationToken cancellationToken, bool lockFiles);
    public sealed virtual Stream ExtractFile(IServiceProvider serviceProvider, Stream packageStream, string fileName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.OpcVerifier : object {
    private static string TestSubject;
    private static string MicrosoftSubject;
    private static string TestCertificateRoot1;
    private static string TestCertificateRoot2;
    private static string LayoutCertSubPath;
    private static string OpcSignRootFileName;
    private IServiceProvider serviceProvider;
    [NullableAttribute("2")]
private ILogger logger;
    [NullableAttribute("2")]
private IFileSystem fileSystem;
    private ISignatureVerifierManager verifier;
    public OpcVerifier(IServiceProvider serviceProvider);
    private static OpcVerifier();
    public void Verify(Stream packageStream, string layoutLocation, bool skipSavingCertificate);
    public void VerifyOpcCertificate(Stream packageStream, string layoutLocation);
    private static bool IsTestSigned(X509Certificate2 signer);
    private void CopyCertsToLayoutFolder(string layoutLocation, X509Certificate2 signCertificate);
    [NullableContextAttribute("2")]
private Byte[] GetRootCertificate(X509Certificate2 certificate);
    private X509Certificate2 GetSigningCertificate(Stream packageStream);
}
public enum Microsoft.VisualStudio.Setup.OperationMode : Enum {
    public int value__;
    public static OperationMode InstallWhileDownloading;
    public static OperationMode DownloadThenInstall;
    public static OperationMode DownloadOnly;
}
public class Microsoft.VisualStudio.Setup.OutOfDiskspaceException : EngineException {
    [NullableContextAttribute("1")]
public OutOfDiskspaceException(string resourceId, Object[] args);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Setup.PackageFailureException : Exception {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEnumerable`1<IPackageProgress> packagesFailed;
    private bool intializerFailed;
    private bool finalizerFailed;
    [NullableAttribute("2")]
private string error;
    [CompilerGeneratedAttribute]
private bool <ShouldLog>k__BackingField;
    public string Message { get; }
    public bool ShouldLog { get; public set; }
    private string Error { get; }
    public PackageFailureException(IEnumerable`1<IPackageProgress> packagesFailed, bool intializerFailed, bool finalizerFailed, int errorCode);
    protected PackageFailureException(SerializationInfo info, StreamingContext context);
    internal PackageFailureException(string error, int errorCode);
    public virtual string get_Message();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ShouldLog();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ShouldLog(bool value);
    private string get_Error();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[DataContractAttribute]
internal class Microsoft.VisualStudio.Setup.PackagePlan : object {
    private bool installable;
    private bool logDependencyAction;
    private Nullable`1<ExecuteAction> plannedAction;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private RequestedState <RequestedState>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<SelectedState> <SelectedState>k__BackingField;
    [CompilerGeneratedAttribute]
private CurrentState <SoftDetectionState>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<PackageState> <DeepDetectionState>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <AddOrRemoveDependencyAction>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ExecuteAction> <PlannedActionBeforeRefCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ExecuteAction> <PlannedActionAfterRefCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ExecuteAction> <FinalPlannedAction>k__BackingField;
    [DataMemberAttribute]
public string Id { get; public set; }
    [DataMemberAttribute]
public RequestedState RequestedState { get; public set; }
    [DataMemberAttribute]
public Nullable`1<SelectedState> SelectedState { get; public set; }
    [DataMemberAttribute]
public CurrentState SoftDetectionState { get; public set; }
    [DataMemberAttribute]
public Nullable`1<PackageState> DeepDetectionState { get; public set; }
    [DataMemberAttribute]
public ExecuteAction PlannedAction { get; public set; }
    [IgnoreDataMemberAttribute]
internal Nullable`1<bool> AddOrRemoveDependencyAction { get; internal set; }
    [IgnoreDataMemberAttribute]
internal Nullable`1<ExecuteAction> PlannedActionBeforeRefCount { get; internal set; }
    [IgnoreDataMemberAttribute]
internal Nullable`1<ExecuteAction> PlannedActionAfterRefCount { get; internal set; }
    [IgnoreDataMemberAttribute]
internal Nullable`1<ExecuteAction> FinalPlannedAction { get; internal set; }
    internal PackagePlan(IPackage package);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public RequestedState get_RequestedState();
    [CompilerGeneratedAttribute]
public void set_RequestedState(RequestedState value);
    [CompilerGeneratedAttribute]
public Nullable`1<SelectedState> get_SelectedState();
    [CompilerGeneratedAttribute]
public void set_SelectedState(Nullable`1<SelectedState> value);
    [CompilerGeneratedAttribute]
public CurrentState get_SoftDetectionState();
    [CompilerGeneratedAttribute]
public void set_SoftDetectionState(CurrentState value);
    [CompilerGeneratedAttribute]
public Nullable`1<PackageState> get_DeepDetectionState();
    [CompilerGeneratedAttribute]
public void set_DeepDetectionState(Nullable`1<PackageState> value);
    public ExecuteAction get_PlannedAction();
    public void set_PlannedAction(ExecuteAction value);
    [CompilerGeneratedAttribute]
internal Nullable`1<bool> get_AddOrRemoveDependencyAction();
    [CompilerGeneratedAttribute]
internal void set_AddOrRemoveDependencyAction(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<ExecuteAction> get_PlannedActionBeforeRefCount();
    [CompilerGeneratedAttribute]
internal void set_PlannedActionBeforeRefCount(Nullable`1<ExecuteAction> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<ExecuteAction> get_PlannedActionAfterRefCount();
    [CompilerGeneratedAttribute]
internal void set_PlannedActionAfterRefCount(Nullable`1<ExecuteAction> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<ExecuteAction> get_FinalPlannedAction();
    [CompilerGeneratedAttribute]
internal void set_FinalPlannedAction(Nullable`1<ExecuteAction> value);
    internal void Print(ILogger logger);
    private ExecuteAction GetPlannedAction();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.PackageProgressComparer : object {
    [NullableAttribute("1")]
internal static IEqualityComparer`1<IPackageProgress> Default;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEqualityComparer`1<IPackageIdentity> comparer;
    internal PackageProgressComparer(IEqualityComparer`1<IPackageIdentity> comparer);
    private static PackageProgressComparer();
    public sealed virtual bool Equals(IPackageProgress x, IPackageProgress y);
    public sealed virtual int GetHashCode(IPackageProgress obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.VisualStudio.Setup.PackageReferenceManager : object {
    [CompilerGeneratedAttribute]
private ExecuteAction <BootstrapperAction>k__BackingField;
    public ExecuteAction BootstrapperAction { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual ExecuteAction get_BootstrapperAction();
    [CompilerGeneratedAttribute]
public sealed virtual void set_BootstrapperAction(ExecuteAction value);
    public sealed virtual bool IgnoreDependents(IPackage package);
    protected abstract virtual bool HasDependentsCore(IPackage package);
    protected abstract virtual bool HasDowngradeDependentsCore(IPackage package, Version version);
    public sealed virtual bool HasDependents(IPackage package);
    public sealed virtual bool HasDowngradeDependents(IPackage package, Version version);
}
[DataContractAttribute]
internal class Microsoft.VisualStudio.Setup.Plan : object {
    [CompilerGeneratedAttribute]
private IList`1<PackagePlan> <Packages>k__BackingField;
    [DataMemberAttribute]
public IList`1<PackagePlan> Packages { get; }
    [CompilerGeneratedAttribute]
public IList`1<PackagePlan> get_Packages();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Planner : object {
    private static ISet`1<string> PackagesWithDuplicateFiles;
    private static string ConfigurationPackageId;
    private static TimeSpan DefaultDownloadMessageBusRateLimit;
    private SchedulerServiceOptions serviceOptions;
    [NullableAttribute("2")]
private Product product;
    private ExecuteAction bootstrapperAction;
    [NullableAttribute("2")]
private IEngineContext engineContext;
    private ISet`1<string> catalogsToUninstall;
    private DependencyActionManager dependencyActionManager;
    private IInstallerFactory installerFactory;
    [NullableAttribute("2")]
private IMessageBus downloadMessageBus;
    public Planner(SchedulerServiceOptions serviceOptions, Product product, ExecuteAction bootstrapperAction, IEngineContext engineContext, ISet`1<string> catalogsToUninstall);
    private static Planner();
    [NullableContextAttribute("2")]
private static bool ShouldCheckSupersedingPackagePlan(IInstallablePackage supersedingPackage);
    private static IEnumerable`1<T> ReorderList(IEnumerable`1<T> list);
    private static bool IsPresent(IPackage package);
    private static bool IsDowngradePackagePermanent(IInstallablePackage installable);
    private static bool IsOperationStateChanged(IInstance instance, Int32& currentInstallStateHash, IEnumerable`1<IActivity> installsOrUninstalls);
    private static int HashCurrentOperationState(IEnumerable`1<IActivity> installsOrUninstalls);
    private static ExecuteAction ConvertToExecuteAction(RequestedState requestedState, CurrentState currentState, ExecuteAction bootstrapperActionToConvert);
    internal PlanResult Plan(ISet`1<IPackage> plannedPackages, string installDir, IDictionary`2<string, string> engineProperties, IDictionary`2<string, object> telemetryProperties, EventHandler`1<EventArgs> downloadOnCanceledHandler);
    private PackageActivities PlanInstallable(InstallablePackage installable, IDictionary`2<IPackageIdentity, DownloadPackage> downloadLookup, PackagePlan& packagePlan, bool repairPackagesWithDuplicateFiles, bool upgradeConfigurationPackage, bool isOrphan, string installDir, ISet`1<IPackage> plannedPackages, IList`1<IActivity> packagesToInstall, IList`1<IActivity> packagesToVerify, EventHandler`1<EventArgs> downloadOnCanceledHandler);
    private InstallablePackage GetOrphanedSupersedingPackage(IInstallablePackage orphan, bool isOrphan, ISet`1<IPackage> plannedPackages);
    private ISet`1<IPackageIdentity> AddOrphanedPackages(ISet`1<IPackage> plannedPackages);
    private void ScheduleReplaceActivities(IPackage package, IDictionary`2<IPackageIdentity, DownloadPackage> downloadLookup, string installDir, IList`1<PackagePlan> uninstallPlans, IList`1<IActivity> packagesToUninstall, EventHandler`1<EventArgs> downloadOnCanceledHandler);
    private PackageActivities CreateDownloadInstallActivities(InstallablePackage installable, ExecuteAction action, bool isPresent, string installDir, EventHandler`1<EventArgs> downloadOnCanceledHandler);
    private IInstallerFactory GetInstallerFactory();
}
internal class Microsoft.VisualStudio.Setup.PolicyUpdater : object {
    private ILogger logger;
    private IWritablePolicyService policyService;
    private IServiceProvider services;
    public PolicyUpdater(IServiceProvider services);
    public sealed virtual bool UpdateKeepDownloadPayloads(bool keepDownloadPayloads);
    public sealed virtual bool UpdatePolicy(PolicySettings policySettings);
}
internal class Microsoft.VisualStudio.Setup.PrecheckManager : object {
    private ServiceProvider services;
    private IPrecheckEvaluatorFactory precheckEvaluatorFactory;
    private ILogger logger;
    internal PrecheckManager(IServiceProvider services);
    public sealed virtual void RunPrechecks(PrecheckParameters precheckParameters, VariableCollection properties);
    public sealed virtual void ShutDownOtherRunningVSProcesses(string vsFolder, IWindowsRestartManager rmService, IEnumerable`1<string> relatedProcessDirectories, IEnumerable`1<string> relatedProcessFiles, IEnumerable`1<string> relatedServices);
    internal Nullable`1<Message> EvaluatePrechecks(PrecheckParameters precheckParams, VariableCollection properties, IEnumerable`1& evaluators, IDictionary`2& failedEvaluators, Boolean& anyFatalErrors);
    private void RecordPrecheckResults(IDictionary`2<string, IValidationResult> failedEvaluators, IEnumerable`1<IPrecheckEvaluator> evaluators, Nullable`1<bool> isCancelled, ITelemetryOperation operation);
}
internal class Microsoft.VisualStudio.Setup.ProductConditionEvaluator : object {
    public ConditionType Type { get; }
    public sealed virtual ConditionType get_Type();
    [NullableContextAttribute("1")]
public sealed virtual bool Evaluate(IServiceProvider services, Condition condition, IDictionary`2<string, string> properties);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Setup.ProgressDataEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <PackageDisplayInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PayloadUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StepInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Progress>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExcludeFromSpeedCalculation>k__BackingField;
    [CompilerGeneratedAttribute]
private ProgressInfo <DetailedProgress>k__BackingField;
    public string PackageDisplayInfo { get; private set; }
    public string PayloadUrl { get; internal set; }
    public string StepInfo { get; private set; }
    public double Progress { get; internal set; }
    public bool ExcludeFromSpeedCalculation { get; internal set; }
    public ProgressInfo DetailedProgress { get; internal set; }
    [NullableContextAttribute("1")]
public ProgressDataEventArgs(string packageInfo, double progress, string stepInfo);
    [CompilerGeneratedAttribute]
public string get_PackageDisplayInfo();
    [CompilerGeneratedAttribute]
private void set_PackageDisplayInfo(string value);
    [CompilerGeneratedAttribute]
public string get_PayloadUrl();
    [CompilerGeneratedAttribute]
internal void set_PayloadUrl(string value);
    [CompilerGeneratedAttribute]
public string get_StepInfo();
    [CompilerGeneratedAttribute]
private void set_StepInfo(string value);
    [CompilerGeneratedAttribute]
public double get_Progress();
    [CompilerGeneratedAttribute]
internal void set_Progress(double value);
    [CompilerGeneratedAttribute]
public bool get_ExcludeFromSpeedCalculation();
    [CompilerGeneratedAttribute]
internal void set_ExcludeFromSpeedCalculation(bool value);
    [CompilerGeneratedAttribute]
public ProgressInfo get_DetailedProgress();
    [CompilerGeneratedAttribute]
internal void set_DetailedProgress(ProgressInfo value);
}
public class Microsoft.VisualStudio.Setup.ProgressInfo : ValueType {
    [CompilerGeneratedAttribute]
private int <CurrentPackage>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TotalPackages>k__BackingField;
    [CompilerGeneratedAttribute]
private long <DownloadedSize>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalSize>k__BackingField;
    [CompilerGeneratedAttribute]
private long <DownloadSpeed>k__BackingField;
    public int CurrentPackage { get; internal set; }
    public int TotalPackages { get; internal set; }
    public long DownloadedSize { get; internal set; }
    public long TotalSize { get; internal set; }
    public long DownloadSpeed { get; internal set; }
    [JsonConstructorAttribute]
public ProgressInfo(int currentPackage, int totalPackages, long downloadedSize, long totalSize, long downloadSpeed);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_CurrentPackage();
    [CompilerGeneratedAttribute]
internal void set_CurrentPackage(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_TotalPackages();
    [CompilerGeneratedAttribute]
internal void set_TotalPackages(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_DownloadedSize();
    [CompilerGeneratedAttribute]
internal void set_DownloadedSize(long value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_TotalSize();
    [CompilerGeneratedAttribute]
internal void set_TotalSize(long value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_DownloadSpeed();
    [CompilerGeneratedAttribute]
internal void set_DownloadSpeed(long value);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
public enum Microsoft.VisualStudio.Setup.ProgressType : Enum {
    public int value__;
    public static ProgressType None;
    public static ProgressType Install;
    public static ProgressType Download;
    public static ProgressType Verify;
    public static ProgressType Clean;
    public static ProgressType SelfUpdate;
    public static ProgressType UninstallAll;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Setup.RebootRequiredException : UxException {
    public RebootRequiredException(ResourceManager resources, string resourceId, Object[] args);
    protected RebootRequiredException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Setup.RecoverableFailureException : UxException {
    public RecoverableFailureException(ResourceManager resources, string resourceId, Object[] args);
    protected RecoverableFailureException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Setup.RegisteredProductInfo : object {
    [CompilerGeneratedAttribute]
private Product <Product>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InstallationPath>k__BackingField;
    public Product Product { get; }
    public string InstallationPath { get; }
    public RegisteredProductInfo(Product product, string installPath);
    [CompilerGeneratedAttribute]
public Product get_Product();
    [CompilerGeneratedAttribute]
public string get_InstallationPath();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.RegistryConditionEvaluator : RegistryEvaluator {
    private static string HexPrefix;
    private static string DotSeparator;
    private static string VersionAppendix;
    public ConditionType Type { get; }
    private static RegistryConditionEvaluator();
    public sealed virtual ConditionType get_Type();
    public sealed virtual bool Evaluate(IServiceProvider services, Condition condition, IDictionary`2<string, string> properties);
    public void Evaluate(IServiceProvider services, PropertyInitializer registryInitializer, IDictionary`2<string, string> properties);
    internal string GetRegistryInitializerValue(IServiceProvider services, RegistryPropertyInitializer initializer, IEnumerable`1<IRegistryKey> keys, IDictionary`2<string, string> properties);
    internal bool EvaluateStringRegistryCondition(IServiceProvider services, RegistryCondition condition, IEnumerable`1<IRegistryKey> keys, IDictionary`2<string, string> properties);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal abstract class Microsoft.VisualStudio.Setup.RegistryEvaluator : object {
    protected static MatchedRegistryPair GetMatchingPair(IEnumerable`1<IRegistryKey> keys, string regValue);
    [NullableContextAttribute("1")]
internal IEnumerable`1<IRegistryKey> GetRegistryKeys(string registryKey, string chip, IServiceProvider services);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.RegistryInitializerEvaluator : RegistryEvaluator {
    public void Evaluate(IServiceProvider services, PropertyInitializer registryInitializer, VariableCollection properties);
    internal string GetRegistryInitializerValue(IServiceProvider services, RegistryPropertyInitializer initializer, IEnumerable`1<IRegistryKey> keys, IDictionary`2<string, string> properties);
}
internal class Microsoft.VisualStudio.Setup.RelatedProcesses : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal ISet`1<string> RelatedProcessFiles;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal ISet`1<string> RelatedProcessDirectories;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal ISet`1<string> RelatedServices;
}
[FlagsAttribute]
internal enum Microsoft.VisualStudio.Setup.RepositoryCapabilities : Enum {
    public int value__;
    public static RepositoryCapabilities None;
    public static RepositoryCapabilities CanAdd;
    public static RepositoryCapabilities CanRemove;
    public static RepositoryCapabilities CanResolvePath;
    public static RepositoryCapabilities All;
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Microsoft.VisualStudio.Setup.Resources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ArgumentInvalidType_Args1 { get; }
    internal static string Arm64SystemRequired_Args1 { get; }
    internal static string AuthenticodeVerificationResult_Args2 { get; }
    internal static string BootstrapperSignatureVerificationFailed_Args1 { get; }
    internal static string BootstrapperTestSignatureVerificationFailed_Args1 { get; }
    internal static string CancelledDuringVerification { get; }
    internal static string CannotInstallToAnExistingInstanceDirectory_Args1 { get; }
    internal static string CannotInstallToEmptyDirectory_Args1 { get; }
    internal static string CatalogFailedToDeserialize_Args1 { get; }
    internal static string CatalogFailedToLoad_Args1 { get; }
    internal static string CatalogNotFromMicrosoft { get; }
    internal static string CatalogVerificationException_Args2 { get; }
    internal static string CatalogVerificationMissingFile_Args1 { get; }
    internal static string CertificateIsInvalid_Args1 { get; }
    internal static string ChannelLessInstance_Args1 { get; }
    internal static string ChannelMajorVersionMismatch { get; }
    internal static string ChannelManifestMissingBootstrapperUri { get; }
    internal static string ChannelManifestShouldHaveOneBootstrapper_Args1 { get; }
    internal static string ChannelManifestSignatureVerificationFailed { get; }
    internal static string ChannelManifestTestSignatureVerificationFailed { get; }
    internal static string ChannelProductMismatch { get; }
    internal static string CleaningUp { get; }
    internal static string CleanLayoutConfirmToDelete { get; }
    internal static string CleanLayoutDeleteCurrentCatalogNotSupported_Args1 { get; }
    internal static string CleanLayoutNoFilesToDelete { get; }
    internal static string ContainerNotSupported { get; }
    internal static string DirectoryNotEmpty_Args1 { get; }
    internal static string DownloadEngineFailed_Args2 { get; }
    internal static string DownloadHelpLinkText { get; }
    internal static string DriveTypeNotFixed_Args1 { get; }
    internal static string ElevationRequired { get; }
    internal static string Error_AuthenticationFailed_Message { get; }
    internal static string Error_DirectoryOperationFailed_Arg1 { get; }
    internal static string Error_FailedToDelete_FileInUse_Args2 { get; }
    internal static string Error_FailedToDelete_FileIsReadOnly_Args2 { get; }
    internal static string Error_FailedToDelete_FilePathEmpty_Args2 { get; }
    internal static string Error_FailedToDelete_FileSystemOrPathIsNull_Args2 { get; }
    internal static string Error_FailedToUninstall_InvalidTargetPath_Args2 { get; }
    internal static string Error_FailedToUninstall_PackageNull { get; }
    internal static string Error_NuGetPackageIdOrNuGetPackageVersionNull { get; }
    internal static string ErrorReport_Header { get; }
    internal static string ErrorReport_PackageFailure_Details { get; }
    internal static string ErrorReport_PackageFailure_ImpactedComponents { get; }
    internal static string ErrorReport_PackageFailure_ImpactedWorkloads { get; }
    internal static string ErrorReport_PackageFailure_Log { get; }
    internal static string ErrorReport_PackageFailure_SearchURL { get; }
    internal static string ErrorReport_PackageNameFormat_Args2 { get; }
    internal static string ExtensibilityFinalizerFailedToExecute { get; }
    internal static string ExtensionNotApplicable_Args1 { get; }
    internal static string FailedToRestoreChannelForUri_Args2 { get; }
    internal static string File_NotGitHubSigned { get; }
    internal static string File_NotGitHubSigned_Arg1 { get; }
    internal static string File_NotMicrosoftSigned { get; }
    internal static string File_NotMicrosoftSigned_Arg1 { get; }
    internal static string FileDeletionFailed_Args1 { get; }
    internal static string FileInstallationFailed_Args1 { get; }
    internal static string FileInstallationPathInvalid_Args1 { get; }
    internal static string FileIsMissing_Arg1 { get; }
    internal static string FinishingUp { get; }
    internal static string HashVerificationFailed_Args3 { get; }
    internal static string HashVerificationSucceeded_Args2 { get; }
    internal static string HyperVNotSupported { get; }
    internal static string InstallingProduct_Args1 { get; }
    internal static string InstallingVSIXExtensions { get; }
    internal static string InstallPathTooLong { get; }
    internal static string InstanceCorrupt { get; }
    internal static string InstanceModified { get; }
    internal static string InvalidDirectory_Args1 { get; }
    internal static string InvalidPath_Args1 { get; }
    internal static string InvalidSignatureOnPath_Args1 { get; }
    internal static string InvalidTransaction { get; }
    internal static string ManifestFile_Args1 { get; }
    internal static string ManifestSignatureVerificationFailed { get; }
    internal static string ManifestTestSignFail { get; }
    internal static string MidInstall_Busy { get; }
    internal static string MidInstall_Busy_Vital { get; }
    internal static string MidInstall_DownloadFailed_Args3 { get; }
    internal static string MidInstall_DownloadNineTimes { get; }
    internal static string MidInstall_DownloadThreeTimes { get; }
    internal static string MidInstall_SHARING_VIOLATION { get; }
    internal static string MidInstall_VitalDownloadFailed_Args3 { get; }
    internal static string OptimizingAssemblies { get; }
    internal static string OS32BitRequired { get; }
    internal static string OS64BitRequired { get; }
    internal static string OSVersionNotSupported_Args2 { get; }
    internal static string OutOfDiskspaceException { get; }
    internal static string OutOfDiskspaceException_Args4 { get; }
    internal static string PackageFailedToDownload_Args2 { get; }
    internal static string PackageFailedToInstall_Args1 { get; }
    internal static string PackageFailedToRepair_Args1 { get; }
    internal static string PackageFailedToUninstall_Args1 { get; }
    internal static string PackageFailedToVerify_Args1 { get; }
    internal static string PackageHasMultipleSignatures_Args1 { get; }
    internal static string PackageIsNotSigned_Args1 { get; }
    internal static string PackageMessageDetails_Args1 { get; }
    internal static string PackageMessageId_Args1 { get; }
    internal static string PackageReturnCode_Args1 { get; }
    internal static string PackageReturnCodeDetails_Args1 { get; }
    internal static string PackageVerificationException_Args2 { get; }
    internal static string PackageVerificationResult_Args2 { get; }
    internal static string PathCombineFailure_Args2 { get; }
    internal static string PathDoesNotMatchRegisteredPath_Args3 { get; }
    internal static string PathNotRooted_Args1 { get; }
    internal static string PathOverlap_Cache_Shared { get; }
    internal static string PathOverlap_Installation_Cache { get; }
    internal static string PathOverlap_Installation_Shared { get; }
    internal static string PathToLongMaxAllowed_Cache_Args1 { get; }
    internal static string PathToLongMaxAllowed_Shared_Args1 { get; }
    internal static string PathToLongMaxAllowedIs_Args1 { get; }
    internal static string PreCheck_AdminUpdateNotEnabled { get; }
    internal static string PreCheck_AdminUpdateOptedOut { get; }
    internal static string PreCheck_ArmMachine { get; }
    internal static string PreCheck_BatteryLow_Args1 { get; }
    internal static string Precheck_BlockedOSCheck_Args1 { get; }
    internal static string PreCheck_ConsumerUpdateOptedOut { get; }
    internal static string Precheck_DriveAccessibilityCheck_Args1 { get; }
    internal static string PreCheck_ExperimentOff { get; }
    internal static string PreCheck_FeatureSwitchOff { get; }
    internal static string Precheck_GPOPolicyPreventsInstallOfWebView2 { get; }
    internal static string PreCheck_InstancePaused { get; }
    internal static string PreCheck_MeteredConnection { get; }
    internal static string Precheck_MissingArmSSU_Args1 { get; }
    internal static string Precheck_MissingOrInvalidInstallingPackagesInLayoutCaches_Args1 { get; }
    internal static string Precheck_MissingOrInvalidUninstallingAndInstallingPackagesInAllCaches_Args2 { get; }
    internal static string Precheck_MissingOrInvalidUninstallingPackagesInPackageCaches_Args1 { get; }
    internal static string PreCheck_NoInstances { get; }
    internal static string Precheck_NoInternetConnection { get; }
    internal static string Precheck_NotElevated { get; }
    internal static string Precheck_NotEnoughDiskSpace_Args2 { get; }
    internal static string Precheck_NotEnoughDiskSpace_Args4 { get; }
    internal static string Precheck_NotEnoughDiskSpace_Args6 { get; }
    internal static string Precheck_NotEnoughDiskSpace_ManyDrives { get; }
    internal static string PreCheck_OutOfSupportWarning_Args1 { get; }
    internal static string PreCheck_PolicyDisabled { get; }
    internal static string Precheck_SoftRebootStatusCheck { get; }
    internal static string PreCheck_TargetDirDoesNotExist { get; }
    internal static string PreCheck_TargetDriveNotReady { get; }
    internal static string Precheck_TestingMsiInstallationCheck { get; }
    internal static string Precheck_UnsupportedOSCheck_Args1 { get; }
    internal static string PreCheck_VSProcessesRunningPlural_Args1 { get; }
    internal static string PreCheck_VSProcessesRunningSingular_Args1 { get; }
    internal static string Product_Not_Applicable { get; }
    internal static string ProductFinalizerFailedToExecute { get; }
    internal static string ProductIntializerFailedToExecute { get; }
    internal static string ProductWithNicknameFormat_Args2 { get; }
    internal static string ProductWithSuffixFormat_Args2 { get; }
    internal static string RebootRequiredAfterInstall_Args1 { get; }
    internal static string RebootRequiredBeforeInstall_Args1 { get; }
    internal static string RepairingProduct_Args1 { get; }
    internal static string RequiredConditionsNotSatisfied_Args1 { get; }
    internal static string RetryCounts { get; }
    internal static string SignatureManagerUnsupportedCatalogPayload_Args2 { get; }
    internal static string SignatureManagerUnsupportedExtension_Args1 { get; }
    internal static string SignerVerificationFailed_Args3 { get; }
    internal static string Size_B_Args1 { get; }
    internal static string Size_GB_Args1 { get; }
    internal static string Size_KB_Args1 { get; }
    internal static string Size_MB_Args1 { get; }
    internal static string Size_PB_Args1 { get; }
    internal static string Size_TB_Args1 { get; }
    internal static string StopActivitiesErrorMessage_Args1 { get; }
    internal static string SystemRebootRequired { get; }
    internal static string UnableToDetermineEngineVersion { get; }
    internal static string UnableToDownloadChannelManifest_Args1 { get; }
    internal static string UnableToParseCatalog_Args1 { get; }
    internal static string UninstallingProduct_Args1 { get; }
    internal static string UpdateOverExperiments { get; }
    internal static string UpdateToOlderProduct { get; }
    internal static string ValidationException { get; }
    internal static string VerifyLayoutFailed { get; }
    internal static string VerifyLayoutInvalidPackages { get; }
    internal static string VerifyLayoutMissingPackages { get; }
    internal static string VisualStudioInstallerName { get; }
    internal static string VsixDownloadFailed { get; }
    internal static string VsixInvalidCatalog { get; }
    internal static string VsixPathInvalid { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ArgumentInvalidType_Args1();
    internal static string get_Arm64SystemRequired_Args1();
    internal static string get_AuthenticodeVerificationResult_Args2();
    internal static string get_BootstrapperSignatureVerificationFailed_Args1();
    internal static string get_BootstrapperTestSignatureVerificationFailed_Args1();
    internal static string get_CancelledDuringVerification();
    internal static string get_CannotInstallToAnExistingInstanceDirectory_Args1();
    internal static string get_CannotInstallToEmptyDirectory_Args1();
    internal static string get_CatalogFailedToDeserialize_Args1();
    internal static string get_CatalogFailedToLoad_Args1();
    internal static string get_CatalogNotFromMicrosoft();
    internal static string get_CatalogVerificationException_Args2();
    internal static string get_CatalogVerificationMissingFile_Args1();
    internal static string get_CertificateIsInvalid_Args1();
    internal static string get_ChannelLessInstance_Args1();
    internal static string get_ChannelMajorVersionMismatch();
    internal static string get_ChannelManifestMissingBootstrapperUri();
    internal static string get_ChannelManifestShouldHaveOneBootstrapper_Args1();
    internal static string get_ChannelManifestSignatureVerificationFailed();
    internal static string get_ChannelManifestTestSignatureVerificationFailed();
    internal static string get_ChannelProductMismatch();
    internal static string get_CleaningUp();
    internal static string get_CleanLayoutConfirmToDelete();
    internal static string get_CleanLayoutDeleteCurrentCatalogNotSupported_Args1();
    internal static string get_CleanLayoutNoFilesToDelete();
    internal static string get_ContainerNotSupported();
    internal static string get_DirectoryNotEmpty_Args1();
    internal static string get_DownloadEngineFailed_Args2();
    internal static string get_DownloadHelpLinkText();
    internal static string get_DriveTypeNotFixed_Args1();
    internal static string get_ElevationRequired();
    internal static string get_Error_AuthenticationFailed_Message();
    internal static string get_Error_DirectoryOperationFailed_Arg1();
    internal static string get_Error_FailedToDelete_FileInUse_Args2();
    internal static string get_Error_FailedToDelete_FileIsReadOnly_Args2();
    internal static string get_Error_FailedToDelete_FilePathEmpty_Args2();
    internal static string get_Error_FailedToDelete_FileSystemOrPathIsNull_Args2();
    internal static string get_Error_FailedToUninstall_InvalidTargetPath_Args2();
    internal static string get_Error_FailedToUninstall_PackageNull();
    internal static string get_Error_NuGetPackageIdOrNuGetPackageVersionNull();
    internal static string get_ErrorReport_Header();
    internal static string get_ErrorReport_PackageFailure_Details();
    internal static string get_ErrorReport_PackageFailure_ImpactedComponents();
    internal static string get_ErrorReport_PackageFailure_ImpactedWorkloads();
    internal static string get_ErrorReport_PackageFailure_Log();
    internal static string get_ErrorReport_PackageFailure_SearchURL();
    internal static string get_ErrorReport_PackageNameFormat_Args2();
    internal static string get_ExtensibilityFinalizerFailedToExecute();
    internal static string get_ExtensionNotApplicable_Args1();
    internal static string get_FailedToRestoreChannelForUri_Args2();
    internal static string get_File_NotGitHubSigned();
    internal static string get_File_NotGitHubSigned_Arg1();
    internal static string get_File_NotMicrosoftSigned();
    internal static string get_File_NotMicrosoftSigned_Arg1();
    internal static string get_FileDeletionFailed_Args1();
    internal static string get_FileInstallationFailed_Args1();
    internal static string get_FileInstallationPathInvalid_Args1();
    internal static string get_FileIsMissing_Arg1();
    internal static string get_FinishingUp();
    internal static string get_HashVerificationFailed_Args3();
    internal static string get_HashVerificationSucceeded_Args2();
    internal static string get_HyperVNotSupported();
    internal static string get_InstallingProduct_Args1();
    internal static string get_InstallingVSIXExtensions();
    internal static string get_InstallPathTooLong();
    internal static string get_InstanceCorrupt();
    internal static string get_InstanceModified();
    internal static string get_InvalidDirectory_Args1();
    internal static string get_InvalidPath_Args1();
    internal static string get_InvalidSignatureOnPath_Args1();
    internal static string get_InvalidTransaction();
    internal static string get_ManifestFile_Args1();
    internal static string get_ManifestSignatureVerificationFailed();
    internal static string get_ManifestTestSignFail();
    internal static string get_MidInstall_Busy();
    internal static string get_MidInstall_Busy_Vital();
    internal static string get_MidInstall_DownloadFailed_Args3();
    internal static string get_MidInstall_DownloadNineTimes();
    internal static string get_MidInstall_DownloadThreeTimes();
    internal static string get_MidInstall_SHARING_VIOLATION();
    internal static string get_MidInstall_VitalDownloadFailed_Args3();
    internal static string get_OptimizingAssemblies();
    internal static string get_OS32BitRequired();
    internal static string get_OS64BitRequired();
    internal static string get_OSVersionNotSupported_Args2();
    internal static string get_OutOfDiskspaceException();
    internal static string get_OutOfDiskspaceException_Args4();
    internal static string get_PackageFailedToDownload_Args2();
    internal static string get_PackageFailedToInstall_Args1();
    internal static string get_PackageFailedToRepair_Args1();
    internal static string get_PackageFailedToUninstall_Args1();
    internal static string get_PackageFailedToVerify_Args1();
    internal static string get_PackageHasMultipleSignatures_Args1();
    internal static string get_PackageIsNotSigned_Args1();
    internal static string get_PackageMessageDetails_Args1();
    internal static string get_PackageMessageId_Args1();
    internal static string get_PackageReturnCode_Args1();
    internal static string get_PackageReturnCodeDetails_Args1();
    internal static string get_PackageVerificationException_Args2();
    internal static string get_PackageVerificationResult_Args2();
    internal static string get_PathCombineFailure_Args2();
    internal static string get_PathDoesNotMatchRegisteredPath_Args3();
    internal static string get_PathNotRooted_Args1();
    internal static string get_PathOverlap_Cache_Shared();
    internal static string get_PathOverlap_Installation_Cache();
    internal static string get_PathOverlap_Installation_Shared();
    internal static string get_PathToLongMaxAllowed_Cache_Args1();
    internal static string get_PathToLongMaxAllowed_Shared_Args1();
    internal static string get_PathToLongMaxAllowedIs_Args1();
    internal static string get_PreCheck_AdminUpdateNotEnabled();
    internal static string get_PreCheck_AdminUpdateOptedOut();
    internal static string get_PreCheck_ArmMachine();
    internal static string get_PreCheck_BatteryLow_Args1();
    internal static string get_Precheck_BlockedOSCheck_Args1();
    internal static string get_PreCheck_ConsumerUpdateOptedOut();
    internal static string get_Precheck_DriveAccessibilityCheck_Args1();
    internal static string get_PreCheck_ExperimentOff();
    internal static string get_PreCheck_FeatureSwitchOff();
    internal static string get_Precheck_GPOPolicyPreventsInstallOfWebView2();
    internal static string get_PreCheck_InstancePaused();
    internal static string get_PreCheck_MeteredConnection();
    internal static string get_Precheck_MissingArmSSU_Args1();
    internal static string get_Precheck_MissingOrInvalidInstallingPackagesInLayoutCaches_Args1();
    internal static string get_Precheck_MissingOrInvalidUninstallingAndInstallingPackagesInAllCaches_Args2();
    internal static string get_Precheck_MissingOrInvalidUninstallingPackagesInPackageCaches_Args1();
    internal static string get_PreCheck_NoInstances();
    internal static string get_Precheck_NoInternetConnection();
    internal static string get_Precheck_NotElevated();
    internal static string get_Precheck_NotEnoughDiskSpace_Args2();
    internal static string get_Precheck_NotEnoughDiskSpace_Args4();
    internal static string get_Precheck_NotEnoughDiskSpace_Args6();
    internal static string get_Precheck_NotEnoughDiskSpace_ManyDrives();
    internal static string get_PreCheck_OutOfSupportWarning_Args1();
    internal static string get_PreCheck_PolicyDisabled();
    internal static string get_Precheck_SoftRebootStatusCheck();
    internal static string get_PreCheck_TargetDirDoesNotExist();
    internal static string get_PreCheck_TargetDriveNotReady();
    internal static string get_Precheck_TestingMsiInstallationCheck();
    internal static string get_Precheck_UnsupportedOSCheck_Args1();
    internal static string get_PreCheck_VSProcessesRunningPlural_Args1();
    internal static string get_PreCheck_VSProcessesRunningSingular_Args1();
    internal static string get_Product_Not_Applicable();
    internal static string get_ProductFinalizerFailedToExecute();
    internal static string get_ProductIntializerFailedToExecute();
    internal static string get_ProductWithNicknameFormat_Args2();
    internal static string get_ProductWithSuffixFormat_Args2();
    internal static string get_RebootRequiredAfterInstall_Args1();
    internal static string get_RebootRequiredBeforeInstall_Args1();
    internal static string get_RepairingProduct_Args1();
    internal static string get_RequiredConditionsNotSatisfied_Args1();
    internal static string get_RetryCounts();
    internal static string get_SignatureManagerUnsupportedCatalogPayload_Args2();
    internal static string get_SignatureManagerUnsupportedExtension_Args1();
    internal static string get_SignerVerificationFailed_Args3();
    internal static string get_Size_B_Args1();
    internal static string get_Size_GB_Args1();
    internal static string get_Size_KB_Args1();
    internal static string get_Size_MB_Args1();
    internal static string get_Size_PB_Args1();
    internal static string get_Size_TB_Args1();
    internal static string get_StopActivitiesErrorMessage_Args1();
    internal static string get_SystemRebootRequired();
    internal static string get_UnableToDetermineEngineVersion();
    internal static string get_UnableToDownloadChannelManifest_Args1();
    internal static string get_UnableToParseCatalog_Args1();
    internal static string get_UninstallingProduct_Args1();
    internal static string get_UpdateOverExperiments();
    internal static string get_UpdateToOlderProduct();
    internal static string get_ValidationException();
    internal static string get_VerifyLayoutFailed();
    internal static string get_VerifyLayoutInvalidPackages();
    internal static string get_VerifyLayoutMissingPackages();
    internal static string get_VisualStudioInstallerName();
    internal static string get_VsixDownloadFailed();
    internal static string get_VsixInvalidCatalog();
    internal static string get_VsixPathInvalid();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[DataContractAttribute]
internal class Microsoft.VisualStudio.Setup.ResponseFile : object {
    [CompilerGeneratedAttribute]
private string <InstallChannelUri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChannelUri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InstallCatalogUri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChannelId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProductId>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private List`1<string> <Add>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private List`1<string> <AddProductLang>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseLatestInstaller>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProductArch>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VSConfigFilePath>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IDictionary`2<string, object> <OtherProperties>k__BackingField;
    [DataMemberAttribute]
public string InstallChannelUri { get; public set; }
    [DataMemberAttribute]
public string ChannelUri { get; public set; }
    [DataMemberAttribute]
public string InstallCatalogUri { get; public set; }
    [DataMemberAttribute]
public string ChannelId { get; public set; }
    [DataMemberAttribute]
public string ProductId { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DataMemberAttribute]
public List`1<string> Add { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DataMemberAttribute]
public List`1<string> AddProductLang { get; public set; }
    [DataMemberAttribute]
public bool UseLatestInstaller { get; public set; }
    [DataMemberAttribute]
public string ProductArch { get; public set; }
    [DataMemberAttribute]
public string VSConfigFilePath { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[JsonExtensionDataAttribute]
public IDictionary`2<string, object> OtherProperties { get; public set; }
    [CompilerGeneratedAttribute]
public string get_InstallChannelUri();
    [CompilerGeneratedAttribute]
public void set_InstallChannelUri(string value);
    [CompilerGeneratedAttribute]
public string get_ChannelUri();
    [CompilerGeneratedAttribute]
public void set_ChannelUri(string value);
    [CompilerGeneratedAttribute]
public string get_InstallCatalogUri();
    [CompilerGeneratedAttribute]
public void set_InstallCatalogUri(string value);
    [CompilerGeneratedAttribute]
public string get_ChannelId();
    [CompilerGeneratedAttribute]
public void set_ChannelId(string value);
    [CompilerGeneratedAttribute]
public string get_ProductId();
    [CompilerGeneratedAttribute]
public void set_ProductId(string value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Add();
    [CompilerGeneratedAttribute]
public void set_Add(List`1<string> value);
    [CompilerGeneratedAttribute]
public List`1<string> get_AddProductLang();
    [CompilerGeneratedAttribute]
public void set_AddProductLang(List`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_UseLatestInstaller();
    [CompilerGeneratedAttribute]
public void set_UseLatestInstaller(bool value);
    [CompilerGeneratedAttribute]
public string get_ProductArch();
    [CompilerGeneratedAttribute]
public void set_ProductArch(string value);
    [CompilerGeneratedAttribute]
public string get_VSConfigFilePath();
    [CompilerGeneratedAttribute]
public void set_VSConfigFilePath(string value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_OtherProperties();
    [CompilerGeneratedAttribute]
public void set_OtherProperties(IDictionary`2<string, object> value);
}
public class Microsoft.VisualStudio.Setup.Result : object {
    public static int FailedExitCode;
    public static int TimedOutExitCode;
    [CompilerGeneratedAttribute]
private string <Command>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ExitCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TimedOut>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StandardError>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StandardOutput>k__BackingField;
    public string Command { get; public set; }
    public int ExitCode { get; public set; }
    public bool TimedOut { get; public set; }
    public string StandardError { get; public set; }
    public string StandardOutput { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Command();
    [CompilerGeneratedAttribute]
public void set_Command(string value);
    [CompilerGeneratedAttribute]
public int get_ExitCode();
    [CompilerGeneratedAttribute]
public void set_ExitCode(int value);
    [CompilerGeneratedAttribute]
public bool get_TimedOut();
    [CompilerGeneratedAttribute]
public void set_TimedOut(bool value);
    [CompilerGeneratedAttribute]
public string get_StandardError();
    [CompilerGeneratedAttribute]
public void set_StandardError(string value);
    [CompilerGeneratedAttribute]
public string get_StandardOutput();
    [CompilerGeneratedAttribute]
public void set_StandardOutput(string value);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.RunOnceInformation : object {
    [CompilerGeneratedAttribute]
private string <ProcessPath>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Arguments>k__BackingField;
    internal string ProcessPath { get; private set; }
    [NullableAttribute("2")]
internal string Arguments { get; private set; }
    internal RunOnceInformation(string processPath, string arguments);
    [CompilerGeneratedAttribute]
internal string get_ProcessPath();
    [CompilerGeneratedAttribute]
private void set_ProcessPath(string value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal string get_Arguments();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_Arguments(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Schedule : object {
    private bool isDisposed;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IActivity> <PackagesToInstallOrUninstall>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IActivity> <PackagesToInstall>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IActivity> <PackagesToUninstall>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IActivity> <PackagesToVerify>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<DownloadPackage> <PackagesToDownload>k__BackingField;
    [CompilerGeneratedAttribute]
private AsyncCoordinator <DownloadsCoordinator>k__BackingField;
    [CompilerGeneratedAttribute]
private Coordinator <ReverifyPackageCacheCoordinator>k__BackingField;
    [CompilerGeneratedAttribute]
private Coordinator <InstallCoordinator>k__BackingField;
    [CompilerGeneratedAttribute]
private Coordinator <CancelCleanupCoordinator>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Initialize <Initializer>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Finalize <Finalizer>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public IReadOnlyList`1<IActivity> PackagesToInstallOrUninstall { get; }
    public IReadOnlyList`1<IActivity> PackagesToInstall { get; }
    public IReadOnlyList`1<IActivity> PackagesToUninstall { get; }
    public IReadOnlyList`1<IActivity> PackagesToVerify { get; }
    public IReadOnlyList`1<DownloadPackage> PackagesToDownload { get; }
    public AsyncCoordinator DownloadsCoordinator { get; }
    public Coordinator ReverifyPackageCacheCoordinator { get; }
    public Coordinator InstallCoordinator { get; }
    public Coordinator CancelCleanupCoordinator { get; }
    [NullableAttribute("2")]
public Initialize Initializer { get; public set; }
    [NullableAttribute("2")]
public Finalize Finalizer { get; public set; }
    public Schedule(SchedulerServiceOptions serviceOptions, int concurrentDownloads, IReadOnlyList`1<IActivity> installsOrUninstalls, IReadOnlyList`1<IActivity> packagesToInstall, IReadOnlyList`1<IActivity> packagesToUninstall, IReadOnlyList`1<IActivity> packagesToVerify, IReadOnlyList`1<DownloadPackage> packagesToDownload);
    [CompilerGeneratedAttribute]
protected Schedule(Schedule original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<IActivity> get_PackagesToInstallOrUninstall();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<IActivity> get_PackagesToInstall();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<IActivity> get_PackagesToUninstall();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<IActivity> get_PackagesToVerify();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<DownloadPackage> get_PackagesToDownload();
    [CompilerGeneratedAttribute]
public AsyncCoordinator get_DownloadsCoordinator();
    [CompilerGeneratedAttribute]
public Coordinator get_ReverifyPackageCacheCoordinator();
    [CompilerGeneratedAttribute]
public Coordinator get_InstallCoordinator();
    [CompilerGeneratedAttribute]
public Coordinator get_CancelCleanupCoordinator();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Initialize get_Initializer();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Initializer(Initialize value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Finalize get_Finalizer();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Finalizer(Finalize value);
    private void Dispose(bool disposing);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(Schedule left, Schedule right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(Schedule left, Schedule right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(Schedule other);
    [CompilerGeneratedAttribute]
public virtual Schedule <Clone>$();
}
internal enum Microsoft.VisualStudio.Setup.Security.AccessObjectType : Enum {
    public int value__;
    public static AccessObjectType FileObject;
    public static AccessObjectType Service;
    public static AccessObjectType KernelObject;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Security.AuthenticodeVerifier : object {
    private static string MSI;
    private static string MSP;
    private static string TempFileNotDeleted;
    private static int DefaultSleepDuration;
    private IFileSystem fileSystem;
    [NullableAttribute("2")]
private ILogger log;
    [NullableAttribute("2")]
private ITelemetry telemetry;
    [CompilerGeneratedAttribute]
private bool <CheckHashOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableRevocationChecks>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SleepDuration>k__BackingField;
    internal bool CheckHashOnly { get; internal set; }
    internal bool EnableRevocationChecks { get; internal set; }
    internal int SleepDuration { get; internal set; }
    [NullableContextAttribute("2")]
internal AuthenticodeVerifier(IServiceProvider services);
    private static AuthenticodeVerifier();
    [CompilerGeneratedAttribute]
internal bool get_CheckHashOnly();
    [CompilerGeneratedAttribute]
internal void set_CheckHashOnly(bool value);
    [CompilerGeneratedAttribute]
internal bool get_EnableRevocationChecks();
    [CompilerGeneratedAttribute]
internal void set_EnableRevocationChecks(bool value);
    [CompilerGeneratedAttribute]
internal int get_SleepDuration();
    [CompilerGeneratedAttribute]
internal void set_SleepDuration(int value);
    public sealed virtual VerificationInformation Verify(FileStream file, string path, string layoutCertificatePath);
    private VerificationInformation VerifyStream(FileStream stream, string path, string originalPath);
    public sealed virtual Signer GetSigner(FileStream file, string path);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Security.CounterSign : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IList`1<string> <X509Data>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CounterSignatureMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CounterSignature>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IList`1<string> X509Data { get; public set; }
    public string Timestamp { get; public set; }
    public string CounterSignatureMethod { get; public set; }
    public string CounterSignature { get; public set; }
    [CompilerGeneratedAttribute]
public IList`1<string> get_X509Data();
    [CompilerGeneratedAttribute]
public void set_X509Data(IList`1<string> value);
    [CompilerGeneratedAttribute]
public string get_Timestamp();
    [CompilerGeneratedAttribute]
public void set_Timestamp(string value);
    [CompilerGeneratedAttribute]
public string get_CounterSignatureMethod();
    [CompilerGeneratedAttribute]
public void set_CounterSignatureMethod(string value);
    [CompilerGeneratedAttribute]
public string get_CounterSignature();
    [CompilerGeneratedAttribute]
public void set_CounterSignature(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Security.Crc32 : object {
    private static UInt32 DefaultStartValue;
    private static UInt32[] table;
    private UInt32 hash;
    private static Crc32();
    public Crc32 ComputeHash(string s, StringComparison comparisonType);
    public Crc32 ComputeHash(int i);
    public Crc32 ComputeHash(bool b);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(Crc32 other);
    public virtual bool Equals(object other);
    public virtual string ToString();
    private static string ConvertCase(string s, StringComparison comparisonType);
    private UInt32 ComputHashCore(Byte[] buffer);
}
internal class Microsoft.VisualStudio.Setup.Security.CRYPT_PROVIDER_CERT : ValueType {
    internal int cbStruct;
    internal IntPtr pCert;
    internal bool fCommercial;
    internal bool fTrustedRoot;
    internal bool fSelfSigned;
    internal bool fTestCert;
    internal int dwRevokedReason;
    internal int dwConfidence;
    internal int dwError;
    internal IntPtr pTrustListContext;
    internal bool fTrustListSignerCert;
    internal IntPtr pCtlContext;
    internal int dwCtlError;
    internal bool fIsCyclic;
    internal IntPtr pChainElement;
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Setup.Security.IComputeCrc32 {
    public abstract virtual Crc32 ComputeHash(Crc32 crc);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Security.IntermediateCertificates : object {
    private ILogger log;
    [CompilerGeneratedAttribute]
private X509Certificate2 <Sha1Certificate>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate2 <Sha2Certificate>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLoaded>k__BackingField;
    internal X509Certificate2 Sha1Certificate { get; private set; }
    internal X509Certificate2 Sha2Certificate { get; private set; }
    internal bool IsLoaded { get; private set; }
    internal IntermediateCertificates(IServiceProvider services);
    [CompilerGeneratedAttribute]
internal X509Certificate2 get_Sha1Certificate();
    [CompilerGeneratedAttribute]
private void set_Sha1Certificate(X509Certificate2 value);
    [CompilerGeneratedAttribute]
internal X509Certificate2 get_Sha2Certificate();
    [CompilerGeneratedAttribute]
private void set_Sha2Certificate(X509Certificate2 value);
    [CompilerGeneratedAttribute]
internal bool get_IsLoaded();
    [CompilerGeneratedAttribute]
private void set_IsLoaded(bool value);
    private void LoadIntermediateCertificates();
    [NullableContextAttribute("1")]
private X509Certificate2 GetCertFromString(string keyData);
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Setup.Security.ISecurityAccessRightsService {
    public abstract virtual void AddAccessRights(IntPtr objectHandle, AccessObjectType objectType, SecurityIdentifier user, UInt32 accessRights);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Security.KeyInfo : object {
    [CompilerGeneratedAttribute]
private KeyValue <KeyValue>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IList`1<string> <X509Data>k__BackingField;
    public KeyValue KeyValue { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IList`1<string> X509Data { get; public set; }
    [CompilerGeneratedAttribute]
public KeyValue get_KeyValue();
    [CompilerGeneratedAttribute]
public void set_KeyValue(KeyValue value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_X509Data();
    [CompilerGeneratedAttribute]
public void set_X509Data(IList`1<string> value);
    [NullableContextAttribute("1")]
private List`1<string> GetJson();
    [NullableContextAttribute("1")]
internal string GetKeyInfoBlob();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Security.KeyValue : object {
    [CompilerGeneratedAttribute]
private RsaKeyValue <RsaKeyValue>k__BackingField;
    public RsaKeyValue RsaKeyValue { get; public set; }
    [CompilerGeneratedAttribute]
public RsaKeyValue get_RsaKeyValue();
    [CompilerGeneratedAttribute]
public void set_RsaKeyValue(RsaKeyValue value);
    internal List`1<string> GetJson();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Security.ManifestDoc : object {
    [NullableAttribute("1")]
private string ps1SignatureBeginTag;
    [NullableAttribute("1")]
private string ps1SignatureEndTag;
    [NullableAttribute("1")]
private string rBracket;
    [NullableAttribute("1")]
private string lBracket;
    [NullableAttribute("1")]
private string comma;
    [CompilerGeneratedAttribute]
private string <ContentBlob>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentWhiteSpace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SignatureBlob>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TempFileName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Bom>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private FileStream <ManifestStream>k__BackingField;
    internal string ContentBlob { get; internal set; }
    internal string ContentWhiteSpace { get; internal set; }
    internal string SignatureBlob { get; internal set; }
    internal string TempFileName { get; internal set; }
    internal string Bom { get; internal set; }
    [NullableAttribute("1")]
private FileStream ManifestStream { get; private set; }
    [NullableContextAttribute("1")]
internal ManifestDoc(FileStream fileStream);
    [CompilerGeneratedAttribute]
internal string get_ContentBlob();
    [CompilerGeneratedAttribute]
internal void set_ContentBlob(string value);
    [CompilerGeneratedAttribute]
internal string get_ContentWhiteSpace();
    [CompilerGeneratedAttribute]
internal void set_ContentWhiteSpace(string value);
    [CompilerGeneratedAttribute]
internal string get_SignatureBlob();
    [CompilerGeneratedAttribute]
internal void set_SignatureBlob(string value);
    [CompilerGeneratedAttribute]
internal string get_TempFileName();
    [CompilerGeneratedAttribute]
internal void set_TempFileName(string value);
    [CompilerGeneratedAttribute]
internal string get_Bom();
    [CompilerGeneratedAttribute]
internal void set_Bom(string value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private FileStream get_ManifestStream();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void set_ManifestStream(FileStream value);
    internal void LoadBlobFromFile();
    internal void SetPs1TempFileName();
    [NullableContextAttribute("1")]
internal string AppendPs1CertFooter(string ps1SignatureBlob);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.VisualStudio.Setup.Security.ManifestMethods : object {
    private static string ColonSeperator;
    private static string Quote;
    private static string Comma;
    private static ManifestMethods();
    internal static Byte[] CalculateHashValue(string dataBlob, string hashMethod);
    internal static string GetAlgorithmName(string algorithm);
    internal static void EnableSha256RSA(string signatureMethod, string digestMethod);
    internal static string StringElement(string elementName, string elementValue, bool lastInSchema);
    internal static List`1<string> ElementList(string elementName, IList`1<string> elementValueList, bool lastInSchema);
    internal static List`1<string> NestedSchema(string elementName, List`1<string> schemaList, bool lastInSchema);
    internal static string InsertTab(int level);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Setup.Security.ManifestSignatureVerificationFailedException : SignatureVerificationFailedException {
    public ManifestSignatureVerificationFailedException(ResourceManager resources, string resourceId, Object[] args);
    protected ManifestSignatureVerificationFailedException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Security.ManifestVerifier : object {
    private IFileSystem fileSystem;
    [NullableAttribute("2")]
private ILogger log;
    [NullableAttribute("2")]
private ITelemetry telemetry;
    [NullableAttribute("2")]
private ISettingsService settings;
    private string manifestSignRootCert;
    private string manifestCounterSignRootCert;
    [CompilerGeneratedAttribute]
private bool <EnableRevocationChecks>k__BackingField;
    internal bool EnableRevocationChecks { get; internal set; }
    [NullableContextAttribute("2")]
internal ManifestVerifier(IServiceProvider services);
    [CompilerGeneratedAttribute]
internal bool get_EnableRevocationChecks();
    [CompilerGeneratedAttribute]
internal void set_EnableRevocationChecks(bool value);
    public sealed virtual VerificationInformation Verify(FileStream fileStream, string path, string layoutCertPath);
    public sealed virtual Signer GetSigner(FileStream file, string path);
    internal bool CheckCertChain(X509CertificateCollection x509Certs, X509Certificate2 signValueCert);
    internal X509ChainStatusFlags CheckChainStatusFlags(X509ChainStatus[] certChainStatus);
    internal X509Chain ConfigureChainForBuilding(X509CertificateCollection x509Certs, bool checkMachineCerts, bool isOfflineRevocation);
    internal bool CheckTimeStamp(X509Certificate2 signCertificate, string timeStamp);
    internal X509CertificateCollection GetCertListFromX509Data(IList`1<string> x509Data);
    private VerificationResult CheckSign(ManifestDoc manifestDoc, Signature signature, string layoutCertPath, IList`1& signers);
    private bool SignedCmsValidate(string signatureValue, string reference, X509Certificate2 signCertificate);
    private bool AsymmetricValidate(string signatureValue, Byte[] referenceRawData, X509Certificate2 signCertificate, string digestMethod);
    private VerificationResult CheckPS1Authenticode(ManifestDoc manifestDoc, SignObject fileSignature, bool checkWithoutBom, string layoutCertPath);
    private void CopyCertsToLayoutFolder(string layoutCertPath, X509Certificate2 signCertificate, X509Certificate2 csSignCertificate);
    private Byte[] GetRootCertificate(X509Certificate2 certificate);
}
internal static class Microsoft.VisualStudio.Setup.Security.NativeMethods : object {
    internal static int ERROR_SUCCESS;
    internal static int TRUST_E_PROVIDER_UNKNOWN;
    internal static int TRUST_E_ACTION_UNKNOWN;
    internal static int TRUST_E_SUBJECT_FORM_UNKNOWN;
    internal static int TRUST_E_SUBJECT_NOT_TRUSTED;
    internal static int TRUST_E_NOSIGNATURE;
    internal static int CERT_E_UNTRUSTEDROOT;
    internal static int CERT_E_CHAINING;
    internal static int CRYPT_E_REVOKED;
    internal static IntPtr INVALID_HANDLE_VALUE;
    internal static Guid WINTRUST_ACTION_GENERIC_VERIFY_V2;
    private static NativeMethods();
    internal static int WinVerifyTrust(IntPtr hWnd, Guid pgActionID, WINTRUST_DATA pWVTData);
    internal static IntPtr WTHelperProvDataFromStateData(IntPtr hStateData);
    internal static IntPtr WTHelperGetProvSignerFromChain(IntPtr pProvData, int idxSigner, bool fCounterSigner, int idxCounterSigner);
    internal static IntPtr WTHelperGetProvCertFromChain(IntPtr pSgnr, int idxCert);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Security.OpcPackageVerifier : object {
    private static string Sha2URI;
    private static string Sha1AlgName;
    private IFileSystem fileSystem;
    [NullableAttribute("2")]
private ILogger log;
    [NullableAttribute("2")]
private ITelemetry telemetry;
    private IntermediateCertificates intermediateCertificates;
    [NullableContextAttribute("2")]
internal OpcPackageVerifier(IServiceProvider services);
    private static OpcPackageVerifier();
    public sealed virtual VerificationInformation Verify(FileStream file, string path, string layoutCertificatePath);
    public sealed virtual Signer GetSigner(FileStream file, string path);
    private static bool IsTestSigned(X509Certificate signer);
    private static VerificationResult MapResult(VerifyResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Security.RsaKeyValue : object {
    [CompilerGeneratedAttribute]
private string <Modulus>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Exponent>k__BackingField;
    public string Modulus { get; public set; }
    public string Exponent { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Modulus();
    [CompilerGeneratedAttribute]
public void set_Modulus(string value);
    [CompilerGeneratedAttribute]
public string get_Exponent();
    [CompilerGeneratedAttribute]
public void set_Exponent(string value);
    [NullableContextAttribute("1")]
internal List`1<string> GetJson();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Setup.Security.RSAPKCS1SHA256SignatureDescription : SignatureDescription {
    public virtual AsymmetricSignatureDeformatter CreateDeformatter(AsymmetricAlgorithm key);
    public virtual AsymmetricSignatureFormatter CreateFormatter(AsymmetricAlgorithm key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Setup.Security.RSAPKCS1SHA256SignatureDescriptionSha1Digest : SignatureDescription {
    public virtual AsymmetricSignatureDeformatter CreateDeformatter(AsymmetricAlgorithm key);
    public virtual AsymmetricSignatureFormatter CreateFormatter(AsymmetricAlgorithm key);
}
internal class Microsoft.VisualStudio.Setup.Security.SecurityAccessRightsService : object {
    [NullableContextAttribute("1")]
public sealed virtual void AddAccessRights(IntPtr objectHandle, AccessObjectType objectType, SecurityIdentifier user, UInt32 accessRights);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Security.Signature : object {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <MessageValue>k__BackingField;
    [CompilerGeneratedAttribute]
private SignInfo <SignInfo>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <SignatureValue>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyInfo <KeyInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private CounterSign <CounterSign>k__BackingField;
    [NullableAttribute("2")]
public string MessageValue { get; public set; }
    public SignInfo SignInfo { get; public set; }
    [NullableAttribute("2")]
public string SignatureValue { get; public set; }
    public KeyInfo KeyInfo { get; public set; }
    [JsonPropertyAttribute]
public CounterSign CounterSign { get; public set; }
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_MessageValue();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_MessageValue(string value);
    [CompilerGeneratedAttribute]
public SignInfo get_SignInfo();
    [CompilerGeneratedAttribute]
public void set_SignInfo(SignInfo value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_SignatureValue();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_SignatureValue(string value);
    [CompilerGeneratedAttribute]
public KeyInfo get_KeyInfo();
    [CompilerGeneratedAttribute]
public void set_KeyInfo(KeyInfo value);
    [CompilerGeneratedAttribute]
public CounterSign get_CounterSign();
    [CompilerGeneratedAttribute]
public void set_CounterSign(CounterSign value);
    [NullableContextAttribute("2")]
internal string TranformToPkcs();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Setup.Security.SignatureManager : object {
    public static string PrefixCN;
    internal static string VSBuildLabSubject;
    internal static string VSBuildLabParentCertSubject;
    private static string Microsoft401Subject;
    private static string GitHubSubject;
    private static string Delimiter;
    private IDictionary`2<string, ISignatureVerifier> verifiers;
    [NullableAttribute("2")]
private IServiceProvider services;
    private IFileSystem fileSystem;
    [NullableAttribute("2")]
private ILogger log;
    [NullableAttribute("2")]
private ITelemetry telemetry;
    private IHashingService hashingService;
    private string certificateSubPath;
    private bool fallbackToSignature;
    [NullableContextAttribute("2")]
public SignatureManager(IServiceProvider services);
    private static SignatureManager();
    public void AddDefaultVerifiers();
    public sealed virtual void SetFallbackIndicator(Version version);
    internal void AddSignatureVerifier(ISignatureVerifier verifier, string extension);
    [NullableContextAttribute("2")]
public sealed virtual bool IsMicrosoftSubjectName(string signer);
    [NullableContextAttribute("2")]
public sealed virtual bool IsGitHubSubjectName(string signer);
    public sealed virtual VerificationInformation Verify(string path, VerificationContext verificationContext, string layoutPath);
    public sealed virtual VerificationInformation Verify(Stream file, string path, VerificationContext verificationContext);
    [NullableContextAttribute("2")]
public sealed virtual Signer GetSigner(Stream file, string path);
    private static void NormalizeExtension(String& extension);
    private VerificationInformation VerifySignatureAndSigner(FileStream fileStream, string path, VerificationContext verificationContext);
    private VerificationInformation VerifySha256(FileStream fileStream, string expected, string path);
    internal VerificationInformation VerifySigner(VerificationInformation verificationInfo, string expectedSignerStr, string path);
    [NullableContextAttribute("2")]
public sealed virtual bool VerifySigner(string expectedSignerStr, string actualSignerStr);
    private ISignatureVerifier GetVerifier(string extension);
    [NullableContextAttribute("2")]
internal static string GetComparisonString(string subjectName);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Setup.Security.SignatureManager/<GetField>d__30")]
internal static IEnumerable`1<string> GetField(string subjectName, string fieldName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Setup.Security.SignatureVerificationFailedException : UxException {
    public SignatureVerificationFailedException(ResourceManager resources, string resourceId, Object[] args);
    protected SignatureVerificationFailedException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Security.SignInfo : object {
    [CompilerGeneratedAttribute]
private string <SignatureMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DigestMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DigestValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Canonicalization>k__BackingField;
    public string SignatureMethod { get; public set; }
    public string DigestMethod { get; public set; }
    public string DigestValue { get; public set; }
    public string Canonicalization { get; public set; }
    [CompilerGeneratedAttribute]
public string get_SignatureMethod();
    [CompilerGeneratedAttribute]
public void set_SignatureMethod(string value);
    [CompilerGeneratedAttribute]
public string get_DigestMethod();
    [CompilerGeneratedAttribute]
public void set_DigestMethod(string value);
    [CompilerGeneratedAttribute]
public string get_DigestValue();
    [CompilerGeneratedAttribute]
public void set_DigestValue(string value);
    [CompilerGeneratedAttribute]
public string get_Canonicalization();
    [CompilerGeneratedAttribute]
public void set_Canonicalization(string value);
    [NullableContextAttribute("1")]
private List`1<string> GetJson();
    [NullableContextAttribute("1")]
internal string GetSignInfoBlob();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Security.SignObject : object {
    [CompilerGeneratedAttribute]
private Signature <Signature>k__BackingField;
    public Signature Signature { get; public set; }
    [CompilerGeneratedAttribute]
public Signature get_Signature();
    [CompilerGeneratedAttribute]
public void set_Signature(Signature value);
}
internal class Microsoft.VisualStudio.Setup.Security.UnsignedVerifier : object {
    [NullableContextAttribute("1")]
public sealed virtual VerificationInformation Verify(FileStream file, string path, string layoutCertificatePath);
    [NullableContextAttribute("1")]
public sealed virtual Signer GetSigner(FileStream file, string path);
}
internal class Microsoft.VisualStudio.Setup.Security.WINTRUST_DATA : object {
    private UInt32 cbStruct;
    private IntPtr pPolicyCallbackData;
    private IntPtr pSIPClientData;
    private WINTRUST_DATA_UI dwUIChoice;
    private WINTRUST_DATA_REVOKE fdwRevocationChecks;
    private WINTRUST_DATA_CHOICE dwUnionChoice;
    private IntPtr pFileInfo;
    private WINTRUST_DATA_STATEACTION dwStateAction;
    private IntPtr hWVTStateData;
    private string pwszURLReference;
    private WINTRUST_DATA_PROVIDER_FLAGS dwProvFlags;
    private WINTRUST_DATA_UICONTEXT dwUIContext;
    internal bool CheckHashOnly { get; internal set; }
    internal bool CheckRevocationCache { get; internal set; }
    internal bool EnableRevocationChecks { get; internal set; }
    internal WINTRUST_DATA(SafeHandle file, string path);
    protected virtual override void Finalize();
    internal bool get_CheckHashOnly();
    internal void set_CheckHashOnly(bool value);
    internal bool get_CheckRevocationCache();
    internal void set_CheckRevocationCache(bool value);
    internal bool get_EnableRevocationChecks();
    internal void set_EnableRevocationChecks(bool value);
    internal void PrepareClose();
    internal string GetSubjectName();
    private sealed virtual override void System.IDisposable.Dispose();
    private void Dispose(bool disposing);
    private bool HasProviderFlag(WINTRUST_DATA_PROVIDER_FLAGS value);
    private void SetProviderFlag(WINTRUST_DATA_PROVIDER_FLAGS value, bool remove);
}
internal enum Microsoft.VisualStudio.Setup.Security.WINTRUST_DATA_CHOICE : Enum {
    public int value__;
    public static WINTRUST_DATA_CHOICE WTD_CHOICE_FILE;
}
[FlagsAttribute]
internal enum Microsoft.VisualStudio.Setup.Security.WINTRUST_DATA_PROVIDER_FLAGS : Enum {
    public int value__;
    public static WINTRUST_DATA_PROVIDER_FLAGS WTD_REVOCATION_CHECK_NONE;
    public static WINTRUST_DATA_PROVIDER_FLAGS WTD_REVOCATION_CHECK_END_CERT;
    public static WINTRUST_DATA_PROVIDER_FLAGS WTD_REVOCATION_CHECK_CHAIN;
    public static WINTRUST_DATA_PROVIDER_FLAGS WTD_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT;
    public static WINTRUST_DATA_PROVIDER_FLAGS WTD_HASH_ONLY_FLAG;
    public static WINTRUST_DATA_PROVIDER_FLAGS WTD_LIFETIME_SIGNING_FLAG;
    public static WINTRUST_DATA_PROVIDER_FLAGS WTD_CACHE_ONLY_URL_RETRIEVAL;
    public static WINTRUST_DATA_PROVIDER_FLAGS WTD_DISABLE_MD2_MD4;
}
internal enum Microsoft.VisualStudio.Setup.Security.WINTRUST_DATA_REVOKE : Enum {
    public int value__;
    public static WINTRUST_DATA_REVOKE WTD_REVOKE_NONE;
    public static WINTRUST_DATA_REVOKE WTD_REVOKE_WHOLECHAIN;
}
internal enum Microsoft.VisualStudio.Setup.Security.WINTRUST_DATA_STATEACTION : Enum {
    public int value__;
    public static WINTRUST_DATA_STATEACTION WTD_STATEACTION_IGNORE;
    public static WINTRUST_DATA_STATEACTION WTD_STATEACTION_VERIFY;
    public static WINTRUST_DATA_STATEACTION WTD_STATEACTION_CLOSE;
    public static WINTRUST_DATA_STATEACTION WTD_STATEACTION_AUTO_CACHE;
    public static WINTRUST_DATA_STATEACTION WTD_STATEACTION_AUTO_CACHE_FLUSH;
}
internal enum Microsoft.VisualStudio.Setup.Security.WINTRUST_DATA_UI : Enum {
    public int value__;
    public static WINTRUST_DATA_UI WTD_UI_ALL;
    public static WINTRUST_DATA_UI WTD_UI_NONE;
    public static WINTRUST_DATA_UI WTD_UI_NOBAD;
    public static WINTRUST_DATA_UI WTD_UI_NOGOOD;
}
internal enum Microsoft.VisualStudio.Setup.Security.WINTRUST_DATA_UICONTEXT : Enum {
    public int value__;
    public static WINTRUST_DATA_UICONTEXT WTD_UICONTEXT_EXECUTE;
    public static WINTRUST_DATA_UICONTEXT WTD_UICONTEXT_INSTALL;
}
internal class Microsoft.VisualStudio.Setup.Security.WINTRUST_FILE_INFO : object {
    private UInt32 cbStruct;
    private IntPtr pcwszFilePath;
    private IntPtr hFile;
    private IntPtr pgKnownSubject;
    internal int Size { get; }
    internal WINTRUST_FILE_INFO(SafeHandle file, string path);
    protected virtual override void Finalize();
    private sealed virtual override void System.IDisposable.Dispose();
    internal int get_Size();
    private void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Setup.SelectedPackage : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private SelectedState <SelectedState>k__BackingField;
    public string Id { get; }
    public SelectedState SelectedState { get; }
    public SelectedPackage(string id, SelectedState selectedState);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public SelectedState get_SelectedState();
}
internal class Microsoft.VisualStudio.Setup.Serialization.CachePolicy : object {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <KeepDownloadedPayloads>k__BackingField;
    public string Path { get; }
    public bool KeepDownloadedPayloads { get; }
    public CachePolicy(bool keepDownloadedPayloads, string path);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public bool get_KeepDownloadedPayloads();
}
internal class Microsoft.VisualStudio.Setup.Serialization.Icon : object {
    [CompilerGeneratedAttribute]
private string <MimeType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Data>k__BackingField;
    public string MimeType { get; }
    public string Data { get; }
    public Icon(string mimeType, string data);
    [CompilerGeneratedAttribute]
public string get_MimeType();
    [CompilerGeneratedAttribute]
public string get_Data();
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Setup.Serialization.IJsonParser {
    public abstract virtual T Parse(string filePath);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Serialization.JsonParser : object {
    private IFileSystem fileSystem;
    private JsonSerializer serializer;
    public JsonParser(IFileSystem fileSystem, JsonSerializer serializer);
    public sealed virtual T Parse(string filePath);
}
internal class Microsoft.VisualStudio.Setup.Serialization.PolicySettings : object {
    [CompilerGeneratedAttribute]
private CachePolicy <CachePolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private PolicyState <CachePolicyState>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SharedInstallationPath>k__BackingField;
    [CompilerGeneratedAttribute]
private PolicyState <SharedInstallationPathState>k__BackingField;
    public CachePolicy CachePolicy { get; }
    public PolicyState CachePolicyState { get; }
    public string SharedInstallationPath { get; }
    public PolicyState SharedInstallationPathState { get; }
    public PolicySettings(CachePolicy cachePolicy, string sharedInstallationPath, PolicyState cachePolicyState, PolicyState sharedInstallationPathState);
    [CompilerGeneratedAttribute]
public CachePolicy get_CachePolicy();
    [CompilerGeneratedAttribute]
public PolicyState get_CachePolicyState();
    [CompilerGeneratedAttribute]
public string get_SharedInstallationPath();
    [CompilerGeneratedAttribute]
public PolicyState get_SharedInstallationPathState();
    internal static PolicySettings Create(IPolicyService policyService);
}
[JsonConverterAttribute("Newtonsoft.Json.Converters.StringEnumConverter")]
internal enum Microsoft.VisualStudio.Setup.Serialization.PolicyState : Enum {
    public int value__;
    public static PolicyState ReadOnly;
    public static PolicyState ReadWrite;
}
internal class Microsoft.VisualStudio.Setup.Serialization.ResponseFileSerializer : ModelSerializer`1<ResponseFile> {
    public ResponseFileSerializer(IServiceProvider services);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.Setup.SerializerExtensions : object {
    [ExtensionAttribute]
public static void SerializeToFile(ModelSerializer`1<T> serializer, IFileSystem fileSystem, string targetFilePath, T model);
    [ExtensionAttribute]
public static void SerializeToFile(JsonSerializer jsonSerializer, IFileSystem fileSystem, string targetFilePath, object objectToSerialize);
    [ExtensionAttribute]
public static T DeserializeToModel(ModelSerializer`1<T> serializer, IFileSystem fileSystem, string filePath);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.ServiceOptions.InstallerBaseServiceOptions : ServiceOptionsBase {
    [NullableAttribute("2")]
private IRestartManager restartManager;
    [NullableAttribute("2")]
private IRegistry registry;
    [NullableAttribute("2")]
private ITelemetry telemetry;
    [NullableAttribute("2")]
private IWatson watson;
    [NullableAttribute("2")]
private IMessageBus messageBus;
    [NullableAttribute("2")]
private IPolicyService policyService;
    [NullableAttribute("2")]
private IChannelManager channelManager;
    [NullableAttribute("2")]
private IEngineFactory engineFactory;
    [NullableAttribute("2")]
private IExtensionServiceInternal extensionService;
    [NullableAttribute("2")]
private IProcessService processService;
    [NullableAttribute("2")]
private IHashingService hashingService;
    [NullableAttribute("2")]
private IOperatingSystem operatingSystem;
    [NullableAttribute("2")]
private ISettingsService settingsService;
    [NullableAttribute("2")]
private IVariableResolver variableResolver;
    [NullableAttribute("2")]
private IFileSystem fileSystem;
    [NullableAttribute("2")]
private ILogger logger;
    [NullableAttribute("2")]
private IExperimentationSetterService experimentationSetterService;
    [NullableAttribute("2")]
private IQueryFactory queryFactory;
    public IRestartManager RestartManager { get; }
    public IRegistry Registry { get; }
    public ITelemetry Telemetry { get; }
    public IWatson Watson { get; }
    public IMessageBus MessageBus { get; }
    public IPolicyService PolicyService { get; }
    public IChannelManager ChannelManager { get; }
    public IEngineFactory EngineFactory { get; }
    public IExtensionServiceInternal ExtensionService { get; }
    public IProcessService ProcessService { get; }
    public IHashingService HashingService { get; }
    public IOperatingSystem OperatingSystem { get; }
    public ISettingsService SettingsService { get; }
    public IVariableResolver VariableResolver { get; }
    public IFileSystem FileSystem { get; }
    [NullableAttribute("2")]
public ILogger Logger { get; }
    public IExperimentationSetterService ExperimentationSetterService { get; }
    public IQueryFactory QueryFactory { get; }
    public InstallerBaseServiceOptions(IServiceProvider services);
    public IRestartManager get_RestartManager();
    public IRegistry get_Registry();
    public ITelemetry get_Telemetry();
    public IWatson get_Watson();
    public IMessageBus get_MessageBus();
    public IPolicyService get_PolicyService();
    public IChannelManager get_ChannelManager();
    public IEngineFactory get_EngineFactory();
    public IExtensionServiceInternal get_ExtensionService();
    public IProcessService get_ProcessService();
    public IHashingService get_HashingService();
    public IOperatingSystem get_OperatingSystem();
    public ISettingsService get_SettingsService();
    public IVariableResolver get_VariableResolver();
    public IFileSystem get_FileSystem();
    [NullableContextAttribute("2")]
public ILogger get_Logger();
    public IExperimentationSetterService get_ExperimentationSetterService();
    public IQueryFactory get_QueryFactory();
    [CompilerGeneratedAttribute]
private IOperatingSystem <get_OperatingSystem>b__42_0();
    [CompilerGeneratedAttribute]
private IFileSystem <get_FileSystem>b__48_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.ServiceOptions.ProductInstallerServiceOptions : InstallerBaseServiceOptions {
    [NullableAttribute("2")]
private IUpdateSettingsService updateSettingsService;
    public IUpdateSettingsService UpdateSettingsService { get; }
    public ProductInstallerServiceOptions(IServiceProvider services);
    public IUpdateSettingsService get_UpdateSettingsService();
}
internal class Microsoft.VisualStudio.Setup.ServiceOptions.ProductModifierServiceOptions : InstallerBaseServiceOptions {
    public ProductModifierServiceOptions(IServiceProvider services);
}
internal class Microsoft.VisualStudio.Setup.ServiceOptions.ProductRepairerServiceOptions : InstallerBaseServiceOptions {
    public ProductRepairerServiceOptions(IServiceProvider services);
}
internal class Microsoft.VisualStudio.Setup.ServiceOptions.ProductResumerServiceOptions : InstallerBaseServiceOptions {
    public ProductResumerServiceOptions(IServiceProvider services);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.ServiceOptions.ProductReverterServiceOptions : InstallerBaseServiceOptions {
    [NullableAttribute("2")]
private IInstanceRepositoryFactory instanceRepositoryFactory;
    public IInstanceRepositoryFactory InstanceRepositoryFactory { get; }
    public ProductReverterServiceOptions(IServiceProvider services);
    public IInstanceRepositoryFactory get_InstanceRepositoryFactory();
}
internal class Microsoft.VisualStudio.Setup.ServiceOptions.ProductUninstallerServiceOptions : InstallerBaseServiceOptions {
    public ProductUninstallerServiceOptions(IServiceProvider services);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.ServiceOptions.ProductUpdaterServiceOptions : InstallerBaseServiceOptions {
    [NullableAttribute("2")]
private IPolicyUpdater policyUpdater;
    [NullableAttribute("2")]
private IUpdateSettingsService updateSettingsService;
    public IPolicyUpdater PolicyUpdater { get; }
    public IUpdateSettingsService UpdateSettingsService { get; }
    public ProductUpdaterServiceOptions(IServiceProvider services);
    public IPolicyUpdater get_PolicyUpdater();
    public IUpdateSettingsService get_UpdateSettingsService();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.ServiceOptions.ReadOnlyInstallerServiceOptions : ServiceOptionsBase {
    [NullableAttribute("2")]
private IQueryFactory queryFactory;
    [NullableAttribute("2")]
private IPolicyService policyService;
    public IQueryFactory QueryFactory { get; }
    public IPolicyService PolicyService { get; }
    public ReadOnlyInstallerServiceOptions(IServiceProvider services);
    public IQueryFactory get_QueryFactory();
    public IPolicyService get_PolicyService();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.ServiceOptions.SchedulerServiceOptions : ServiceOptionsBase {
    private ILogger logger;
    private ITelemetry telemetry;
    private ICacheManager cacheManager;
    private IPolicyService policy;
    private IInstallerFactory installerFactory;
    private IMessageBus messageBus;
    private IOperatingSystem operatingSystem;
    private IExtensionServiceInternal extensionService;
    [NullableAttribute("1")]
public ILogger Logger { get; }
    public ITelemetry Telemetry { get; }
    [NullableAttribute("1")]
public ICacheManager Cacher { get; }
    [NullableAttribute("1")]
public IPolicyService PolicyService { get; }
    public IInstallerFactory InstallerFactory { get; }
    public IMessageBus MessageBus { get; }
    public IOperatingSystem OperatingSystem { get; }
    public IExtensionServiceInternal ExtensionService { get; }
    [NullableContextAttribute("1")]
public SchedulerServiceOptions(IServiceProvider services);
    [NullableContextAttribute("1")]
public ILogger get_Logger();
    public ITelemetry get_Telemetry();
    [NullableContextAttribute("1")]
public ICacheManager get_Cacher();
    [NullableContextAttribute("1")]
public IPolicyService get_PolicyService();
    public IInstallerFactory get_InstallerFactory();
    public IMessageBus get_MessageBus();
    public IOperatingSystem get_OperatingSystem();
    public IExtensionServiceInternal get_ExtensionService();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private IPolicyService <get_PolicyService>b__16_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.VisualStudio.Setup.ServiceOptions.ServiceOptionsBase : object {
    [CompilerGeneratedAttribute]
private IServiceProvider <Services>k__BackingField;
    protected IServiceProvider Services { get; }
    public ServiceOptionsBase(IServiceProvider services);
    [CompilerGeneratedAttribute]
protected IServiceProvider get_Services();
    protected T GetRequiredService(T& field);
    [NullableContextAttribute("2")]
protected T GetOptionalService(T& field);
    protected T GetService(T& field, Func`1<T> getter);
    private sealed virtual override object System.IServiceProvider.GetService(Type serviceType);
}
[FlagsAttribute]
internal enum Microsoft.VisualStudio.Setup.Services.AccessMask : Enum {
    public int value__;
    public static AccessMask TOKEN_QUERY;
    public static AccessMask TOKEN_ADJUST_PRIVILEGES;
}
public class Microsoft.VisualStudio.Setup.Services.AccountProfileService : object {
    private IServiceProvider services;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InUserMode>k__BackingField;
    public bool IsDisposed { get; private set; }
    public bool InUserMode { get; public set; }
    public WindowsIdentity CurrentUser { get; }
    public bool IsSystemAccount { get; }
    public AccountProfileService(IServiceProvider services);
    protected virtual override void Finalize();
    [CompilerGeneratedAttribute]
public bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_InUserMode();
    [CompilerGeneratedAttribute]
public sealed virtual void set_InUserMode(bool value);
    public sealed virtual WindowsIdentity get_CurrentUser();
    public sealed virtual bool get_IsSystemAccount();
    public sealed virtual bool UpdateUserProfile(string instanceId, IDictionary`2<string, string> properties);
}
public class Microsoft.VisualStudio.Setup.Services.AggregateLogger : object {
    private Func`2<string, string> logFileNameGenerator;
    private List`1<LoggerRegistration> loggers;
    private ReaderWriterLockSlim readWriteLock;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    public bool IsDisposed { get; private set; }
    public IEnumerable`1<ILogger> Loggers { get; }
    public AggregateLogger(Func`2<string, string> logFileNameGenerator, IEnumerable`1<ILogger> loggers);
    protected virtual override void Finalize();
    [CompilerGeneratedAttribute]
public bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    public IEnumerable`1<ILogger> get_Loggers();
    public void Add(ILogger logger, bool keepAlive);
    public sealed virtual void Dispose();
    public sealed virtual string GenerateLogFileName(string packageId);
    public sealed virtual void WriteError(Exception ex, string format, Object[] args);
    public sealed virtual void WriteMessage(string format, Object[] args);
    public sealed virtual void WriteVerbose(string format, Object[] args);
    public sealed virtual void WriteWarning(string format, Object[] args);
    protected virtual void Dispose(bool disposing);
    private void Validate();
    private void WriteCallback(Action`1<ILogger> callback);
}
internal class Microsoft.VisualStudio.Setup.Services.AppDomainService : object {
    public sealed virtual void LoadReferencedAssemblies(Assembly assembly);
}
public class Microsoft.VisualStudio.Setup.Services.ApplicabilityService : object {
    public static IApplicabilityService Default;
    private Nullable`1<bool> is64BitOperatingSystem;
    private Nullable`1<bool> isInContainer;
    private Nullable`1<MachineArchitecture> machineArchitecture;
    private Version operatingSystemVersion;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Func`3<IRequirements, IServiceProvider, ApplicabilityState>> <ApplicabilityChecks>k__BackingField;
    private static ApplicabilityState ValidState;
    private static string ArchitectureFunctorKey;
    private Nullable`1<bool> isHyperVSupported;
    protected bool IsHyperVSupported { get; protected set; }
    internal IEnumerable`1<Func`3<IRequirements, IServiceProvider, ApplicabilityState>> ApplicabilityChecks { get; internal set; }
    private static ApplicabilityService();
    protected bool get_IsHyperVSupported();
    protected void set_IsHyperVSupported(bool value);
    [CompilerGeneratedAttribute]
internal IEnumerable`1<Func`3<IRequirements, IServiceProvider, ApplicabilityState>> get_ApplicabilityChecks();
    [CompilerGeneratedAttribute]
internal void set_ApplicabilityChecks(IEnumerable`1<Func`3<IRequirements, IServiceProvider, ApplicabilityState>> value);
    public sealed virtual void ComputeApplicability(IDependencyNode node, IServiceProvider services);
    public sealed virtual void ComputeApplicability(IRequirements requirements, IServiceProvider services);
    private bool GetIs64BitOperatingSystem(IServiceProvider services);
    private ApplicabilityState CheckArchitecture(IRequirements requirements, IServiceProvider services);
    private Version GetOperatingSystemVersion(IServiceProvider services);
    private ApplicabilityState CheckOsVersion(IRequirements requirements, IServiceProvider services);
    private ApplicabilityState CheckHyperV(IRequirements requirements, IServiceProvider services);
    private void EnsureIsHyperVSupportedInitialized(IServiceProvider services);
    private ApplicabilityState CheckConditions(IRequirements requirements, IServiceProvider services);
    private ApplicabilityState CheckInContainer(IRequirements requirements, IServiceProvider services);
    private bool GetIsInContainer(IServiceProvider services);
    private MachineArchitecture GetMachineArchitecture(IServiceProvider services);
    private bool IsArm64System(IServiceProvider services);
}
[GuidAttribute("591209c7-767b-42b2-9fba-44ee4615f2c7")]
internal class Microsoft.VisualStudio.Setup.Services.ApplicationAssociationRegistration : object {
}
[FlagsAttribute]
public enum Microsoft.VisualStudio.Setup.Services.ApplicationStatus : Enum {
    public int value__;
    public static ApplicationStatus Unknown;
    public static ApplicationStatus Running;
    public static ApplicationStatus Stopped;
    public static ApplicationStatus StoppedOther;
    public static ApplicationStatus Restarted;
    public static ApplicationStatus ErrorOnStop;
    public static ApplicationStatus ErrorOnRestart;
    public static ApplicationStatus ShutdownMasked;
    public static ApplicationStatus RestartMasked;
}
public enum Microsoft.VisualStudio.Setup.Services.ApplicationType : Enum {
    public int value__;
    public static ApplicationType Unknown;
    public static ApplicationType MainWindow;
    public static ApplicationType OtherWindow;
    public static ApplicationType Service;
    public static ApplicationType Explorer;
    public static ApplicationType Console;
    public static ApplicationType Critical;
}
internal enum Microsoft.VisualStudio.Setup.Services.AssociationLevel : Enum {
    public int value__;
    public static AssociationLevel AL_MACHINE;
    public static AssociationLevel AL_EFFECTIVE;
    public static AssociationLevel AL_USER;
}
internal enum Microsoft.VisualStudio.Setup.Services.AssociationType : Enum {
    public int value__;
    public static AssociationType AT_FILEEXTENSION;
    public static AssociationType AT_URLPROTOCOL;
    public static AssociationType AT_STARTMENUCLIENT;
    public static AssociationType AT_MIMETYPE;
}
public enum Microsoft.VisualStudio.Setup.Services.AutomaticUpdatesValue : Enum {
    public int value__;
    public static AutomaticUpdatesValue Blocked;
    public static AutomaticUpdatesValue CatalogAndWSUS;
    public static AutomaticUpdatesValue CatalogWSUSAndAU;
}
[FlagsAttribute]
public enum Microsoft.VisualStudio.Setup.Services.BatteryStatus : Enum {
    public byte value__;
    public static BatteryStatus High;
    public static BatteryStatus Low;
    public static BatteryStatus Critical;
    public static BatteryStatus Charging;
    public static BatteryStatus NoSystemBattery;
    public static BatteryStatus Unknown;
}
public class Microsoft.VisualStudio.Setup.Services.BufferedWriter : TextWriter {
    private static Encoding UTF8;
    private static string Suffix;
    private IFileSystem fileSystem;
    private ITelemetry telemetry;
    private string path;
    private string temporaryPath;
    private TextWriter buffer;
    private bool complete;
    private bool shouldMove;
    [CompilerGeneratedAttribute]
private Encoding <Encoding>k__BackingField;
    public Encoding Encoding { get; }
    public BufferedWriter(string path);
    public BufferedWriter(IFileSystem fileSystem, string path);
    public BufferedWriter(IFileSystem fileSystem, ITelemetry telemetry, string path);
    private static BufferedWriter();
    protected virtual override void Finalize();
    [CompilerGeneratedAttribute]
public virtual Encoding get_Encoding();
    public virtual void Close();
    public virtual void Flush();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.BufferedWriter/<FlushAsync>d__18")]
public virtual Task FlushAsync();
    public virtual void Write(char value);
    public virtual void Write(Char[] buffer);
    public virtual void Write(Char[] buffer, int index, int count);
    public virtual void Write(string value);
    public virtual Task WriteAsync(char value);
    public virtual Task WriteAsync(string value);
    public virtual Task WriteAsync(Char[] buffer, int index, int count);
    public virtual Task WriteLineAsync();
    public virtual Task WriteLineAsync(char value);
    public virtual Task WriteLineAsync(Char[] buffer, int index, int count);
    public virtual Task WriteLineAsync(string value);
    public sealed virtual void Complete();
    protected virtual void Dispose(bool disposing);
    private void Write(Action action);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.BufferedWriter/<WriteAsync>d__33")]
private Task WriteAsync(Func`1<Task> action);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0();
    [CompilerGeneratedAttribute]
private Task <WriteLineAsync>b__26_0();
}
[FlagsAttribute]
internal enum Microsoft.VisualStudio.Setup.Services.ChangeNotifyEventIds : Enum {
    public int value__;
    public static ChangeNotifyEventIds SHCNE_ASSOCCHANGED;
}
[FlagsAttribute]
internal enum Microsoft.VisualStudio.Setup.Services.ChangeNotifyFlags : Enum {
    public int value__;
    public static ChangeNotifyFlags SHCNF_IDLIST;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Services.ChannelFeedManager : object {
    private static Uri DefaultChannelsFileUri;
    [NullableAttribute("2")]
private ILogger logger;
    private IChannelFeedRepository channelFeedRepository;
    private ICustomChannelRepository customChannelRepository;
    private IFileSystem fileSystem;
    private IDownloadManager downloadManager;
    private IPolicyService policyService;
    private IServiceProvider services;
    private bool createdChannelFeedRepository;
    private bool isDisposed;
    public ChannelFeedManager(IServiceProvider services);
    private static ChannelFeedManager();
    public sealed virtual IEnumerable`1<ChannelSummary> GetAvailableChannels();
    public sealed virtual IEnumerable`1<ChannelSummary> GetDisabledChannels();
    private IEnumerable`1<ChannelSummary> GetRemoteFeedChannels();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.ChannelFeedManager/<AddChannelFeedAsync>d__14")]
public sealed virtual Task`1<bool> AddChannelFeedAsync(Uri feedUri, CancellationToken token);
    public sealed virtual void RemoveChannelFeed(Uri feedUri);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.ChannelFeedManager/<UpdateAsync>d__16")]
public sealed virtual Task`1<bool> UpdateAsync(CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.ChannelFeedManager/<UpdateChannelFeedAsync>d__17")]
private Task`1<bool> UpdateChannelFeedAsync(Uri feedUri, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.ChannelFeedManager/<DownloadFeedAsync>d__18")]
private Task`1<string> DownloadFeedAsync(Uri feedUri, CancellationToken token);
    private void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
internal class Microsoft.VisualStudio.Setup.Services.ChildWindowsProcess : WindowsProcess {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IProcessStartInfo <StartInfo>k__BackingField;
    [NullableAttribute("1")]
public IProcessStartInfo StartInfo { get; }
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual IProcessStartInfo get_StartInfo();
}
public class Microsoft.VisualStudio.Setup.Services.ClientMessageBus : object {
    private CancellationToken cancellationToken;
    private ILogger logger;
    [CompilerGeneratedAttribute]
private EventHandler`1<MessageEventArgs> MessageReceived;
    public ClientMessageBus(IServiceProvider services, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public void add_MessageReceived(EventHandler`1<MessageEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_MessageReceived(EventHandler`1<MessageEventArgs> value);
    public sealed virtual Task NotifyMessageAsync(Message message);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.ClientMessageBus/<SendMessageAsync>d__7")]
public sealed virtual Task`1<MessageResult> SendMessageAsync(Message message);
    private void SendMessage(MessageEventArgs eventArgs);
}
public class Microsoft.VisualStudio.Setup.Services.ConsoleLogger : object {
    private static int MessageAvailable;
    private static int Quit;
    private IServiceProvider services;
    private EventWaitHandle[] handles;
    private ConcurrentQueue`1<ConsoleMessage> messages;
    private bool enabled;
    private ConsoleColor foregroundColor;
    private string prefix;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Verbose>k__BackingField;
    public bool IsDisposed { get; private set; }
    public bool Verbose { get; public set; }
    public ConsoleLogger(IServiceProvider services);
    protected virtual override void Finalize();
    [CompilerGeneratedAttribute]
public bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    [CompilerGeneratedAttribute]
public bool get_Verbose();
    [CompilerGeneratedAttribute]
public void set_Verbose(bool value);
    public bool Attach(int processId);
    public bool TryAttach(int processId);
    public sealed virtual void WriteError(Exception ex, string format, Object[] args);
    public sealed virtual void WriteMessage(string format, Object[] args);
    public sealed virtual void WriteVerbose(string format, Object[] args);
    public sealed virtual void WriteWarning(string format, Object[] args);
    public sealed virtual void Dispose();
    private sealed virtual override string Microsoft.VisualStudio.Setup.Services.ILogger.GenerateLogFileName(string packageId);
    private string FormatMessage(string format, object arg0);
    private string FormatMessage(string format, Object[] args);
    private string GetPrefix();
    private void ProcessMessages();
    private void QueueMessage(ConsoleMessage& message);
    private void WriteMessage(ConsoleMessage& message);
}
internal class Microsoft.VisualStudio.Setup.Services.DefaultPolicy : object {
    internal static int DefaultConcurrentDownloads;
    [CompilerGeneratedAttribute]
private string <CachePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CompatibilityInstallationPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SharedInstallationPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UpdateConfigurationFile>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs> Invalidated;
    [CompilerGeneratedAttribute]
private bool <IsCachePathSettable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSharedInstallPathSettable>k__BackingField;
    public AutomaticUpdatesValue AdministratorUpdatesEnabled { get; }
    public bool AdministratorPromptToClose { get; }
    public bool AdministratorUpdatesOptOut { get; }
    public bool AutoUpdateDisabled { get; }
    public bool BackgroundDownloadDisabled { get; }
    public string CachePath { get; public set; }
    public bool ChannelUpdateDisabled { get; }
    public string CompatibilityInstallationPath { get; }
    public int ConcurrentDownloads { get; }
    public bool DiagnosticMode { get; }
    public bool DisableMicrosoftChannelFeed { get; }
    public bool DisableRollback { get; }
    public bool HideAvailableTab { get; }
    public bool IgnoreChannelFeedProductRestriction { get; }
    public bool KeepDownloadedPayloads { get; }
    public bool RemoveOos { get; }
    public bool DisableSound { get; }
    public string SharedInstallationPath { get; }
    public string UpdateConfigurationFile { get; }
    public bool IsCachePathSettable { get; }
    public bool IsSharedInstallPathSettable { get; }
    public bool DisableBlockedOSCheck { get; }
    public ElevationServiceSupport ElevationServiceSupport { get; }
    public bool AdministratorUpdatesNotificationsEnabled { get; }
    public bool AdministratorUpdateOnCloseOptOut { get; }
    public bool VSthroughMUUpdatesOptOut { get; }
    public bool PreviewAutomaticUpdates { get; }
    public bool UpdateNotificationsOptOut { get; }
    public DefaultPolicy(IServiceProvider services);
    private sealed virtual override bool Microsoft.VisualStudio.Setup.Services.IPolicyService.IsPolicySet(string policyPropertyName);
    public sealed virtual AutomaticUpdatesValue get_AdministratorUpdatesEnabled();
    public sealed virtual bool get_AdministratorPromptToClose();
    public sealed virtual bool get_AdministratorUpdatesOptOut();
    public sealed virtual bool get_AutoUpdateDisabled();
    public sealed virtual bool get_BackgroundDownloadDisabled();
    [CompilerGeneratedAttribute]
public sealed virtual string get_CachePath();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CachePath(string value);
    public sealed virtual bool get_ChannelUpdateDisabled();
    [CompilerGeneratedAttribute]
public sealed virtual string get_CompatibilityInstallationPath();
    public sealed virtual int get_ConcurrentDownloads();
    public sealed virtual bool get_DiagnosticMode();
    public sealed virtual bool get_DisableMicrosoftChannelFeed();
    public sealed virtual bool get_DisableRollback();
    public sealed virtual bool get_HideAvailableTab();
    public sealed virtual bool get_IgnoreChannelFeedProductRestriction();
    public sealed virtual bool get_KeepDownloadedPayloads();
    public sealed virtual bool get_RemoveOos();
    public sealed virtual bool get_DisableSound();
    [CompilerGeneratedAttribute]
public sealed virtual string get_SharedInstallationPath();
    [CompilerGeneratedAttribute]
public sealed virtual string get_UpdateConfigurationFile();
    [CompilerGeneratedAttribute]
public sealed virtual void add_Invalidated(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Invalidated(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsCachePathSettable();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsSharedInstallPathSettable();
    public sealed virtual bool get_DisableBlockedOSCheck();
    public sealed virtual ElevationServiceSupport get_ElevationServiceSupport();
    public sealed virtual bool get_AdministratorUpdatesNotificationsEnabled();
    public sealed virtual bool get_AdministratorUpdateOnCloseOptOut();
    public sealed virtual bool get_VSthroughMUUpdatesOptOut();
    public sealed virtual bool get_PreviewAutomaticUpdates();
    public sealed virtual bool get_UpdateNotificationsOptOut();
}
internal class Microsoft.VisualStudio.Setup.Services.DEVICE_TRIM_DESCRIPTOR : ValueType {
    internal UInt32 Version;
    internal UInt32 Size;
    internal bool TrimEnabled;
}
internal class Microsoft.VisualStudio.Setup.Services.DirectoryAccessControl : object {
    [CompilerGeneratedAttribute]
private DirectorySecurity <NativeObject>k__BackingField;
    internal DirectorySecurity NativeObject { get; }
    private object Microsoft.VisualStudio.Setup.Services.IAccessControl.NativeObject { get; }
    public string StringForm { get; }
    internal DirectoryAccessControl(DirectorySecurity security);
    [CompilerGeneratedAttribute]
internal DirectorySecurity get_NativeObject();
    private sealed virtual override object Microsoft.VisualStudio.Setup.Services.IAccessControl.get_NativeObject();
    public sealed virtual string get_StringForm();
    public sealed virtual IAccessControl Clone();
    private string GetSecurityDescriptorSddl();
}
internal class Microsoft.VisualStudio.Setup.Services.DISK_EXTENT : ValueType {
    internal int DiskNumber;
    internal long StartingOffset;
    internal long ExtentLength;
}
internal class Microsoft.VisualStudio.Setup.Services.DiskInfo : object {
    [CompilerGeneratedAttribute]
private int <DiskNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TrimEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SeekPenalty>k__BackingField;
    internal int DiskNumber { get; }
    internal bool TrimEnabled { get; }
    internal bool SeekPenalty { get; }
    internal bool IsSSD { get; }
    public DiskInfo(int diskNumber);
    [CompilerGeneratedAttribute]
internal int get_DiskNumber();
    [CompilerGeneratedAttribute]
internal bool get_TrimEnabled();
    [CompilerGeneratedAttribute]
internal bool get_SeekPenalty();
    internal bool get_IsSSD();
    public virtual string ToString();
}
internal class Microsoft.VisualStudio.Setup.Services.DisposableReaderWriterLock : object {
    [NullableAttribute("1")]
private ReaderWriterLockSlim slimLock;
    private bool isDisposed;
    [NullableContextAttribute("1")]
public IDisposable EnterReadLock();
    [NullableContextAttribute("1")]
public IDisposable EnterWriteLock();
    private void Dispose(bool isDisposing);
    public sealed virtual void Dispose();
}
internal enum Microsoft.VisualStudio.Setup.Services.DriveTypeNative : Enum {
    public int value__;
    public static DriveTypeNative Unknown;
    public static DriveTypeNative Invalid;
    public static DriveTypeNative Removable;
    public static DriveTypeNative Fixed;
    public static DriveTypeNative Remote;
    public static DriveTypeNative CDROM;
    public static DriveTypeNative RAM;
}
public enum Microsoft.VisualStudio.Setup.Services.ElevationServiceSupport : Enum {
    public int value__;
    public static ElevationServiceSupport Blocked;
    public static ElevationServiceSupport UpdateAndRollback;
    public static ElevationServiceSupport All;
}
internal class Microsoft.VisualStudio.Setup.Services.ErrorFileLogger : FileLogger {
    public ErrorFileLogger(IServiceProvider services, string path, string moduleName);
    public static ErrorFileLogger OpenErrorFileLogger(IServiceProvider services, string path, string moduleName, int maxAttempts, int retryIntervalInMs);
    public virtual void WriteError(Exception ex, string format, Object[] args);
    public virtual void WriteMessage(string format, Object[] args);
    public virtual void WriteVerbose(string format, Object[] args);
    public virtual void WriteWarning(string format, Object[] args);
}
public class Microsoft.VisualStudio.Setup.Services.Experimentation.ExperimentationFactory : object {
    private object syncRoot;
    [CompilerGeneratedAttribute]
private string <ClientName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ExperimentationService <ExperimentationService>k__BackingField;
    [CompilerGeneratedAttribute]
private ExperimentationServiceInitializer <ExperimentationServiceInitializer>k__BackingField;
    [CompilerGeneratedAttribute]
private IExperimentationTelemetry <ExperimentationTelemetry>k__BackingField;
    [CompilerGeneratedAttribute]
private TelemetrySession <TelemetrySession>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    internal string ClientName { get; }
    internal string ClientVersion { get; }
    internal ExperimentationService ExperimentationService { get; private set; }
    internal ExperimentationServiceInitializer ExperimentationServiceInitializer { get; private set; }
    internal IExperimentationTelemetry ExperimentationTelemetry { get; }
    internal TelemetrySession TelemetrySession { get; }
    internal ILogger Logger { get; }
    public ExperimentationFactory(string clientName, string clientVersion, TelemetrySession telemetrySession, IExperimentationTelemetry experimentationTelemetry, ILogger logger);
    [CompilerGeneratedAttribute]
internal string get_ClientName();
    [CompilerGeneratedAttribute]
internal string get_ClientVersion();
    [CompilerGeneratedAttribute]
internal ExperimentationService get_ExperimentationService();
    [CompilerGeneratedAttribute]
private void set_ExperimentationService(ExperimentationService value);
    [CompilerGeneratedAttribute]
internal ExperimentationServiceInitializer get_ExperimentationServiceInitializer();
    [CompilerGeneratedAttribute]
private void set_ExperimentationServiceInitializer(ExperimentationServiceInitializer value);
    [CompilerGeneratedAttribute]
internal IExperimentationTelemetry get_ExperimentationTelemetry();
    [CompilerGeneratedAttribute]
internal TelemetrySession get_TelemetrySession();
    [CompilerGeneratedAttribute]
internal ILogger get_Logger();
    public IExperimentationService CreateExperimentationService();
    public IExperimentationSetterService CreateExperimentationSetterService();
    private ExperimentationService CreateExperimentationServiceCore();
}
internal class Microsoft.VisualStudio.Setup.Services.Experimentation.ExperimentationFilterProvider : object {
    private IExperimentationFilterProvider defaultFilterProvider;
    private string exeName;
    private string exeVersion;
    private string branchName;
    private string sku;
    private string channelId;
    private string isInternal;
    private string userId;
    public ExperimentationFilterProvider(IExperimentationFilterProvider defaultFilterProvider, string exeName, string exeVersion, string branchName, string sku, string channelId, string isInternal, string userId);
    public static IExperimentationFilterProvider CreateClientFilter(IExperimentationFilterProvider defaultProvider, string clientName, string clientVersion);
    public sealed virtual string GetFilterValue(Filters filter);
    private string GetValueOrDefault(Filters filter, string value);
}
internal class Microsoft.VisualStudio.Setup.Services.Experimentation.ExperimentationOptinStatusReader : object {
    [CompilerGeneratedAttribute]
private bool <IsOptedIn>k__BackingField;
    public bool IsOptedIn { get; private set; }
    public ExperimentationOptinStatusReader(ITelemetry telemetry);
    public ExperimentationOptinStatusReader(bool isOptedIn);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsOptedIn();
    [CompilerGeneratedAttribute]
private void set_IsOptedIn(bool value);
}
internal class Microsoft.VisualStudio.Setup.Services.Experimentation.ExperimentationService : object {
    private ExperimentationService experimentationService;
    public ExperimentationService(ExperimentationServiceInitializer initializer);
    public sealed virtual void Dispose();
    public sealed virtual bool IsCachedFlightEnabled(string flight);
    public sealed virtual Task`1<bool> IsFlightEnabledAsync(string flight, CancellationToken token);
    public sealed virtual IExperimentationService GetExperimentationService();
    public sealed virtual void SetFlight(Flight flight);
}
public class Microsoft.VisualStudio.Setup.Services.Experimentation.ExperimentationTelemetry : object {
    private ITelemetry telemetry;
    public ExperimentationTelemetry(ITelemetry telemetry);
    public sealed virtual void PostEvent(string name, IDictionary`2<string, string> properties);
    public sealed virtual void SetSharedProperty(string name, string value);
}
public interface Microsoft.VisualStudio.Setup.Services.Experimentation.IExperimentationService {
    public abstract virtual bool IsCachedFlightEnabled(string flight);
    public abstract virtual Task`1<bool> IsFlightEnabledAsync(string flight, CancellationToken token);
    public abstract virtual IExperimentationService GetExperimentationService();
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.Setup.Services.Experimentation.IExperimentationSetterService {
    public abstract virtual void SetFlight(Flight flight);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.Setup.Services.ExtensionMethods : object {
    [ExtensionAttribute]
public static RegistryKey CreateSubKeyTransacted(RegistryKey key, string path, RegistryOptions options);
    [ExtensionAttribute]
public static void DeleteSubKeyTreeTransacted(RegistryKey key, string path, bool throwOnMissingSubKey);
    [ExtensionAttribute]
public static RegistryKey OpenSubKeyTransacted(RegistryKey key, string path, bool writable);
    [ExtensionAttribute]
public static ErrorInformation GetErrorInformation(Exception exception, string errorLogPath);
    private static SafeTransactionHandle GetCurrentTransaction();
    private static REGSAM GetRegistryKeyAccess(bool writable);
    private static RegistryKey OpenSubKeyTransactedImpl(RegistryKey key, string path, bool writable);
    private static T ThrowOrNull(int error);
}
[FlagsAttribute]
internal enum Microsoft.VisualStudio.Setup.Services.FILE_ACCESS : Enum {
    public int value__;
    public static FILE_ACCESS GENERIC_READ;
}
[FlagsAttribute]
internal enum Microsoft.VisualStudio.Setup.Services.FILE_ATTRIBUTES : Enum {
    public int value__;
    public static FILE_ATTRIBUTES NORMAL;
}
[FlagsAttribute]
internal enum Microsoft.VisualStudio.Setup.Services.FILE_DISPOSITION : Enum {
    public int value__;
    public static FILE_DISPOSITION OPEN_EXISTING;
}
[FlagsAttribute]
internal enum Microsoft.VisualStudio.Setup.Services.FILE_SHARE : Enum {
    public int value__;
    public static FILE_SHARE READ;
    public static FILE_SHARE WRITE;
}
public class Microsoft.VisualStudio.Setup.Services.FileLogger : object {
    public static int DefaultOpenFileLoggerRetryIntervalInMs;
    public static int DefaultOpenFileLoggerMaxAttemptsCount;
    private IFileSystem fileSystem;
    private IProcessService processService;
    private TextWriter writer;
    private int sequence;
    private Exception lastFault;
    private IList`1<string> faultedInMemoryLog;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BasePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BaseName>k__BackingField;
    public bool IsDisposed { get; private set; }
    public string Path { get; private set; }
    public string BasePath { get; private set; }
    public string BaseName { get; private set; }
    public FileLogger(IServiceProvider services, string path, string moduleName);
    protected virtual override void Finalize();
    [CompilerGeneratedAttribute]
public bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
private void set_Path(string value);
    [CompilerGeneratedAttribute]
public string get_BasePath();
    [CompilerGeneratedAttribute]
private void set_BasePath(string value);
    [CompilerGeneratedAttribute]
public string get_BaseName();
    [CompilerGeneratedAttribute]
private void set_BaseName(string value);
    public static FileLogger OpenFileLogger(IServiceProvider services, string path, string moduleName, int maxAttempts, int retryIntervalInMs);
    protected static TFileLogger OpenFileLogger(Func`1<TFileLogger> creator, int maxAttempts, int retryIntervalInMs);
    public sealed virtual void Dispose();
    public sealed virtual string GenerateLogFileName(string packageId);
    public bool RetryOpenIfFaulted(ITelemetry telemetry);
    public virtual void WriteError(Exception ex, string format, Object[] args);
    public virtual void WriteMessage(string format, Object[] args);
    public virtual void WriteVerbose(string format, Object[] args);
    public virtual void WriteWarning(string format, Object[] args);
    public void Open();
    private void Dispose(bool disposing);
    protected void WriteLine(string format, Object[] args);
}
public class Microsoft.VisualStudio.Setup.Services.FileSystem : object {
    private static string Root;
    private static string Name;
    private static RegistryHive Hive;
    private IServiceProvider services;
    public static IFileSystem Default;
    public string UserDirectory { get; }
    public string LocalUserDirectory { get; }
    public string CurrentDirectory { get; }
    public string SharedDirectory { get; }
    public string TemporaryDirectory { get; }
    public string SharedProgramsDirectory { get; }
    public string SharedPrograms64Directory { get; }
    public string SystemDirectory { get; }
    public string UserDocumentsDirectory { get; }
    public string CommonProgramsDirectory { get; }
    public string CommonStartMenuDirectory { get; }
    public string OperatingSystemDirectory { get; }
    public FileSystem(IServiceProvider services);
    private static FileSystem();
    public sealed virtual string get_UserDirectory();
    public sealed virtual string get_LocalUserDirectory();
    public sealed virtual string get_CurrentDirectory();
    public sealed virtual string get_SharedDirectory();
    public sealed virtual string get_TemporaryDirectory();
    public sealed virtual string get_SharedProgramsDirectory();
    public sealed virtual string get_SharedPrograms64Directory();
    public sealed virtual string get_SystemDirectory();
    public sealed virtual string get_UserDocumentsDirectory();
    public sealed virtual string get_CommonProgramsDirectory();
    public sealed virtual string get_CommonStartMenuDirectory();
    public sealed virtual string get_OperatingSystemDirectory();
    public sealed virtual string GetTempFileName();
    public sealed virtual string GetRandomFileName(string path, string extension);
    public sealed virtual FileAttributes GetDirectoryAttributes(string path);
    public sealed virtual void SetDirectoryAttributes(string path, FileAttributes attributeValues, FileAttributes attributeMask);
    public sealed virtual bool DirectoryExists(string path);
    public sealed virtual IEnumerable`1<string> GetDirectories(string path, bool recursive);
    public sealed virtual void CreateDirectory(string path);
    public sealed virtual void DeleteDirectory(string path, bool recursive);
    public sealed virtual void DeleteFile(string path);
    public sealed virtual FileAttributes GetFileAttributes(string path);
    public sealed virtual void SetFileAttributes(string path, FileAttributes attributeValues, FileAttributes attributeMask);
    public sealed virtual bool FileExists(string path);
    public sealed virtual Stream OpenFile(string path);
    public sealed virtual void CopyFile(string source, string destination);
    public sealed virtual TextReader OpenText(string path);
    public sealed virtual TextWriter CreateText(string path, bool buffer);
    public sealed virtual Stream CreateFile(string path, FileMode mode, FileAccess access, FileShare share);
    public sealed virtual String[] GetFiles(string path, string pattern, bool recursive);
    public sealed virtual String[] GetFileSystemEntries(string path, string pattern, bool recursive);
    public sealed virtual string ResolveFilePath(string path);
    public sealed virtual bool ForceDeleteDirectoryOnReboot(string path);
    public sealed virtual bool MoveFile(string source, string destination, bool afterReboot, bool replace);
    private bool MoveFileEx(string source, string destination, MoveFileFlags flags);
    private bool RecursivelyDeleteDirectoryOnReboot(string source, MoveFileFlags flags);
    private bool AddPendingFileRename(string source, string destination, ILogger logger);
    public sealed virtual IAccessControl GetDirectorySecurity(string path);
    public sealed virtual void SetDirectorySecurity(string path, IAccessControl security);
    public sealed virtual long GetFileSize(string path);
    public sealed virtual void SetFileTime(string path, Nullable`1<DateTimeOffset> creationTime, Nullable`1<DateTimeOffset> lastWriteTime);
    public sealed virtual long GetDriveFreeSpace(string path);
    public sealed virtual long GetDriveTotalSpace(string path);
    public sealed virtual DriveType GetDriveType(string path);
    public sealed virtual FileTime GetFileTime(string path);
    public sealed virtual Version GetVersionInfo(string path);
    public sealed virtual Version GetFileProductVersion(string path);
    public sealed virtual string GetDirectoryName(string path);
    public sealed virtual string GetFullPath(string path);
    public sealed virtual bool IsDirectoryEmpty(string path);
}
public class Microsoft.VisualStudio.Setup.Services.Flight : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Duration>k__BackingField;
    public string Name { get; }
    public int Duration { get; }
    public Flight(string name, int duration);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public int get_Duration();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.VisualStudio.Setup.Services.FlightService : object {
    public static bool TryParseFlights(IEnumerable`1<string> flights, IEnumerable`1& parsedFlights);
    public static IEnumerable`1<Flight> ParseFlights(IEnumerable`1<string> flights);
    public static bool ValidateFlights(IEnumerable`1<string> flights);
    private static int ParseDuration(string duration);
}
public class Microsoft.VisualStudio.Setup.Services.HashingService : object {
    [CompilerGeneratedAttribute]
private static IHashingService <Default>k__BackingField;
    public static IHashingService Default { get; }
    private static HashingService();
    [CompilerGeneratedAttribute]
public static IHashingService get_Default();
    public sealed virtual string GetHashOfString(string value, HashAlgorithms algorithm);
    public sealed virtual string GetHashOfFile(string path, HashAlgorithms algorithm);
    public sealed virtual string GetHashOfStream(Stream stream, HashAlgorithms algorithm);
    private HashAlgorithm GetAlgorithm(HashAlgorithms algorithm);
}
public interface Microsoft.VisualStudio.Setup.Services.IAccountProfileService {
    public bool InUserMode { get; public set; }
    public WindowsIdentity CurrentUser { get; }
    public bool IsSystemAccount { get; }
    public abstract virtual bool get_InUserMode();
    public abstract virtual void set_InUserMode(bool value);
    public abstract virtual WindowsIdentity get_CurrentUser();
    public abstract virtual bool get_IsSystemAccount();
    public abstract virtual bool UpdateUserProfile(string instanceId, IDictionary`2<string, string> properties);
}
internal interface Microsoft.VisualStudio.Setup.Services.IAppDomainService {
    public abstract virtual void LoadReferencedAssemblies(Assembly assembly);
}
[NullableContextAttribute("1")]
[GuidAttribute("4e530b0a-e611-4c77-a3ac-9031d022281b")]
[InterfaceTypeAttribute("1")]
internal interface Microsoft.VisualStudio.Setup.Services.IApplicationAssociationRegistration {
    public abstract virtual int QueryCurrentDefault(string pszQuery, AssociationType atQueryType, AssociationLevel atQueryLevel, String& ppszAssociation);
    public abstract virtual int QueryAppIsDefault(string pszQuery, AssociationType atQueryType, AssociationLevel atQueryLevel, string pszAppRegistryName, Boolean& pfDefault);
    public abstract virtual int QueryAppIsDefaultAll(AssociationLevel atQueryLevel, string pszAppRegistryName, Boolean& pfDefault);
    public abstract virtual int SetAppAsDefault(string pszAppRegistryName, string pszSet, AssociationType atSetType);
    public abstract virtual int SetAppAsDefaultAll(string pszAppRegistryName);
    public abstract virtual int ClearUserAssociations();
}
internal interface Microsoft.VisualStudio.Setup.Services.IChannelFeedManager {
    public abstract virtual IEnumerable`1<ChannelSummary> GetAvailableChannels();
    public abstract virtual IEnumerable`1<ChannelSummary> GetDisabledChannels();
    public abstract virtual Task`1<bool> UpdateAsync(CancellationToken token);
    public abstract virtual Task`1<bool> AddChannelFeedAsync(Uri feedUri, CancellationToken token);
    public abstract virtual void RemoveChannelFeed(Uri feedUri);
}
public interface Microsoft.VisualStudio.Setup.Services.IDriveInfo {
    public char DriveLetter { get; }
    public bool IsSolidStateDrive { get; }
    public abstract virtual char get_DriveLetter();
    public abstract virtual bool get_IsSolidStateDrive();
}
public interface Microsoft.VisualStudio.Setup.Services.IEngineFactory {
    public abstract virtual IEngine Create(IServiceProvider serviceProvider, string instanceId);
}
public interface Microsoft.VisualStudio.Setup.Services.IInstallationConfigurationService {
    public abstract virtual Task`1<InstallationConfigurationPackages> GetMissingPackageIdsAsync(string filePath, string instanceId, CancellationToken cancellationToken);
    public abstract virtual Task`1<InstallationConfigurationPackages> GetMissingPackageIdsAsync(IInstallationConfiguration installationConfiguration, string instanceId, CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<string>> ExportSelectionsAsync(string filePath, IDependencyGraph graph, IEnumerable`1<string> selectedPackageIds, CancellationToken cancellationToken);
    public abstract virtual Task`1<IInstallationConfiguration> ReadAsync(string filePath, CancellationToken cancellationToken);
    public abstract virtual IInstallationConfiguration Read(string filePath);
}
[NullableContextAttribute("2")]
internal interface Microsoft.VisualStudio.Setup.Services.IInstallerUserSettingsRepository {
    public string Theme { get; public set; }
    public string PreviousSessionId { get; public set; }
    public bool ShowDownlevelSkus { get; }
    [NullableContextAttribute("1")]
public abstract virtual CultureInfo LoadLocale();
    [NullableContextAttribute("1")]
public abstract virtual void SaveLocale(CultureInfo locale);
    public abstract virtual string get_Theme();
    public abstract virtual void set_Theme(string value);
    public abstract virtual string get_PreviousSessionId();
    public abstract virtual void set_PreviousSessionId(string value);
    public abstract virtual bool get_ShowDownlevelSkus();
}
[NullableContextAttribute("1")]
[InterfaceTypeAttribute("1")]
[GuidAttribute("79427A2B-F895-40e0-BE79-B57DC82ED231")]
internal interface Microsoft.VisualStudio.Setup.Services.IKernelTransaction {
    public abstract virtual void GetHandle(SafeTransactionHandle& pHandle);
}
public interface Microsoft.VisualStudio.Setup.Services.ILockService {
    public abstract virtual IDisposable Lock(string path);
    public abstract virtual void UnlockAll();
}
public interface Microsoft.VisualStudio.Setup.Services.IMachineService {
    public abstract virtual MachineArchitecture GetMachineArchitecture();
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Setup.Services.IMarketplaceExtensionService {
    public abstract virtual Task`1<ExtensionQueryResult> GetExtensionUrisAsync(Version instanceVersion, string productArch, IDictionary`2<string, ExtensionOrigin> extensions, CancellationToken token);
    public abstract virtual Task`1<IDictionary`2<string, string>> GetItemNamesAsync(IEnumerable`1<string> vsixIds, CancellationToken token);
}
public interface Microsoft.VisualStudio.Setup.Services.IMutex {
    public abstract virtual void ReleaseMutex();
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.Setup.Services.IMutexService {
    public abstract virtual bool TryGetNamedMutex(string name, IMutex& mutex);
}
internal interface Microsoft.VisualStudio.Setup.Services.INgenService {
    public abstract virtual bool ExecuteQueuedNgenTasks(IEnumerable`1<NgenArchitecture> architectures, CancellationToken token, int priority);
    public abstract virtual bool PauseNgenTasks(IEnumerable`1<NgenArchitecture> architectures, CancellationToken token);
    public abstract virtual bool UpdateQueueNgenTasks(IEnumerable`1<NgenArchitecture> architectures, CancellationToken token);
    public abstract virtual bool ContinueNgenTasks(IEnumerable`1<NgenArchitecture> architectures, CancellationToken token);
}
public interface Microsoft.VisualStudio.Setup.Services.INotifyResumable {
    public abstract virtual void OnResumable();
}
public class Microsoft.VisualStudio.Setup.Services.InstallationConfigurationService : object {
    private IServiceContainer services;
    private IFileSystem fileSystem;
    private ICacheManagerFactory cacheManagerFactory;
    private IInstallationConfigurationFactory installationConfigurationFactory;
    private ILogger logger;
    private ITelemetry telemetry;
    private IMarketplaceExtensionService marketplaceService;
    public InstallationConfigurationService(IServiceProvider services);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.InstallationConfigurationService/<GetMissingPackageIdsAsync>d__8")]
public sealed virtual Task`1<InstallationConfigurationPackages> GetMissingPackageIdsAsync(string filePath, string instanceId, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.InstallationConfigurationService/<GetMissingPackageIdsAsync>d__9")]
public sealed virtual Task`1<InstallationConfigurationPackages> GetMissingPackageIdsAsync(IInstallationConfiguration installationConfiguration, string instanceId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.InstallationConfigurationService/<ExportSelectionsAsync>d__10")]
public sealed virtual Task`1<IEnumerable`1<string>> ExportSelectionsAsync(string filePath, IDependencyGraph graph, IEnumerable`1<string> selectedPackageIds, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.InstallationConfigurationService/<ReadAsync>d__11")]
public sealed virtual Task`1<IInstallationConfiguration> ReadAsync(string filePath, CancellationToken cancellationToken);
    public sealed virtual IInstallationConfiguration Read(string filePath);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.InstallationConfigurationService/<WriteAsync>d__13")]
private Task WriteAsync(string filePath, InstallationConfiguration configuration, CancellationToken cancellationToken);
    private void ValidateConfiguration(IInstallationConfiguration config);
    private Task`1<IDependencyGraph> GetDependencyGraphWithApplicabilityAsync(ICacheManager cache);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.InstallationConfigurationService/<GetMissingMarketPlaceExtensionsAsync>d__16")]
private Task`1<IEnumerable`1<string>> GetMissingMarketPlaceExtensionsAsync(IDictionary`2<string, ExtensionOrigin> marketPlaceItemNames, IEnumerable`1<IDependencyNode> dependencyNodes, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.InstallationConfigurationService/<GetFilteredMarketplaceExtensionsAsync>d__17")]
private Task`1<MarketplaceExtensionsData> GetFilteredMarketplaceExtensionsAsync(IEnumerable`1<IDependencyNode> dependencyNodes, CancellationToken token);
    private string GetMarketplaceUrlFromItemname(string itemname);
    [CompilerGeneratedAttribute]
private ICacheManagerFactory <.ctor>b__7_1();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Services.Installer.ErrorInformation : object {
    [CompilerGeneratedAttribute]
private string <LocalizedMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NeutralMessage>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <StackTrace>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ErrorCode>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <ErrorName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorLogPath>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public string LocalizedMessage { get; }
    public string NeutralMessage { get; }
    [NullableAttribute("1")]
public string StackTrace { get; }
    public int ErrorCode { get; }
    [NullableAttribute("1")]
public string ErrorName { get; }
    public string ErrorLogPath { get; }
    public ErrorInformation(string localizedMessage, string neutralMessage, string stackTrace, int errorCode, string errorName, string errorLogPath);
    [CompilerGeneratedAttribute]
protected ErrorInformation(ErrorInformation original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public string get_LocalizedMessage();
    [CompilerGeneratedAttribute]
public string get_NeutralMessage();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_StackTrace();
    [CompilerGeneratedAttribute]
public int get_ErrorCode();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_ErrorName();
    [CompilerGeneratedAttribute]
public string get_ErrorLogPath();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ErrorInformation left, ErrorInformation right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ErrorInformation left, ErrorInformation right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(ErrorInformation other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual ErrorInformation <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Services.Installer.ExtensionDownloadFailure : object {
    [CompilerGeneratedAttribute]
private ExtensionOptions <ExtensionOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private ExtensionDownloadFailureReason <FailureReason>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public ExtensionOptions ExtensionOptions { get; public set; }
    public ExtensionDownloadFailureReason FailureReason { get; public set; }
    public ExtensionDownloadFailure(ExtensionOptions ExtensionOptions, ExtensionDownloadFailureReason FailureReason);
    [CompilerGeneratedAttribute]
protected ExtensionDownloadFailure(ExtensionDownloadFailure original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public ExtensionOptions get_ExtensionOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ExtensionOptions(ExtensionOptions value);
    [CompilerGeneratedAttribute]
public ExtensionDownloadFailureReason get_FailureReason();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FailureReason(ExtensionDownloadFailureReason value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(ExtensionDownloadFailure left, ExtensionDownloadFailure right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(ExtensionDownloadFailure left, ExtensionDownloadFailure right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(ExtensionDownloadFailure other);
    [CompilerGeneratedAttribute]
public virtual ExtensionDownloadFailure <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(ExtensionOptions& ExtensionOptions, ExtensionDownloadFailureReason& FailureReason);
}
internal enum Microsoft.VisualStudio.Setup.Services.Installer.ExtensionDownloadFailureReason : Enum {
    public int value__;
    public static ExtensionDownloadFailureReason None;
    public static ExtensionDownloadFailureReason GeneralError;
    public static ExtensionDownloadFailureReason HashMismatch;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
internal class Microsoft.VisualStudio.Setup.Services.Installer.ExtensionOptions : object {
    [CompilerGeneratedAttribute]
private Uri <ExtensionUri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Sha256Hash>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <LocalPath>k__BackingField;
    [DataMemberAttribute]
public Uri ExtensionUri { get; }
    [DataMemberAttribute]
public string Sha256Hash { get; }
    [NullableAttribute("2")]
[IgnoreDataMemberAttribute]
public string LocalPath { get; public set; }
    public ExtensionOptions(Uri extensionUri, string sha256Hash);
    [CompilerGeneratedAttribute]
public Uri get_ExtensionUri();
    [CompilerGeneratedAttribute]
public string get_Sha256Hash();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_LocalPath();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_LocalPath(string value);
}
internal interface Microsoft.VisualStudio.Setup.Services.Installer.IInstaller {
    public bool IsDirty { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_Progress(EventHandler`1<ProgressEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Progress(EventHandler`1<ProgressEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Pausable(EventHandler`1<PausableEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Pausable(EventHandler`1<PausableEventArgs> value);
    public abstract virtual bool get_IsDirty();
    public abstract virtual Task`1<InstallOperationResult> InvokeAsync(CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.VisualStudio.Setup.Services.Installer.InstallerBase : object {
    private static Task CompletedTask;
    private InstallerBaseServiceOptions serviceOptions;
    private InstallerBaseOptions options;
    private AsyncLazy`1<bool> lazyInit;
    private AsyncLazy`1<IEngine> lazyEngine;
    private List`1<ExtensionDownloadFailure> failedExtensionDownloads;
    [NullableAttribute("2")]
private string extensionsDir;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<ProgressEventArgs> Progress;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<PausableEventArgs> Pausable;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IEngine <Engine>k__BackingField;
    public bool IsDirty { get; }
    [NullableAttribute("2")]
protected ILogger Logger { get; }
    public bool IsDisposed { get; private set; }
    [NullableAttribute("2")]
[ObsoleteAttribute("Use GetEngineAsync to ensure the engine is initialized.")]
private IEngine Engine { get; private set; }
    public InstallerBase(InstallerBaseServiceOptions serviceOptions, InstallerBaseOptions options, IProgressReporter additionalProgressReporter);
    private static InstallerBase();
    protected virtual Task PreEngineCreationInitializationAsync();
    protected virtual override void Finalize();
    [CompilerGeneratedAttribute]
public sealed virtual void add_Progress(EventHandler`1<ProgressEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Progress(EventHandler`1<ProgressEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Pausable(EventHandler`1<PausableEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Pausable(EventHandler`1<PausableEventArgs> value);
    public sealed virtual bool get_IsDirty();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.Installer.InstallerBase/<InvokeAsync>d__18")]
public sealed virtual Task`1<InstallOperationResult> InvokeAsync(CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.Installer.InstallerBase/<GetEngineAsync>d__19")]
protected Task`1<IEngine> GetEngineAsync();
    protected abstract virtual Task`1<IInstance> InvokeAsyncImpl(CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.Installer.InstallerBase/<GetInstanceAsync>d__21")]
protected Task`1<IInstance> GetInstanceAsync();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.Installer.InstallerBase/<GetDependencyGraphAsync>d__22")]
protected Task`1<IDependencyGraph> GetDependencyGraphAsync(Product product, bool overwrite);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.Installer.InstallerBase/<GetDependencyGraphWithSelectionAsync>d__23")]
protected Task`1<IDependencyGraph> GetDependencyGraphWithSelectionAsync(Product product, bool overwrite);
    [NullableContextAttribute("2")]
protected ILogger get_Logger();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.Installer.InstallerBase/<GetSeedAsync>d__26")]
private Task`1<DependencyComparisonSeed> GetSeedAsync();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.Installer.InstallerBase/<SetEnginePropertyAsync>d__27")]
private Task SetEnginePropertyAsync(string propertyName, string value, bool persist);
    private void SetEngineProperty(IEngine engine, string propertyName, string value, bool persist);
    protected void SetFlights(IEnumerable`1<string> flights);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.Installer.InstallerBase/<GetProductsAsync>d__30")]
protected Task`1<IEnumerable`1<Product>> GetProductsAsync();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.Installer.InstallerBase/<SetLayoutDirectoryAsync>d__31")]
protected Task SetLayoutDirectoryAsync(string layoutPath);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.Installer.InstallerBase/<SetLayoutUriAsync>d__32")]
protected Task SetLayoutUriAsync(Uri layoutUri);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.Installer.InstallerBase/<SetTemporaryLayoutDirectoryAsync>d__33")]
protected Task SetTemporaryLayoutDirectoryAsync(string layoutPath);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.Installer.InstallerBase/<SetNicknameAsync>d__34")]
protected Task SetNicknameAsync(string nickname);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.Installer.InstallerBase/<SetProductKeyAsync>d__35")]
protected Task SetProductKeyAsync(string productKey);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.Installer.InstallerBase/<ApplyGraphStateAsync>d__36")]
protected Task`1<bool> ApplyGraphStateAsync(Product product, IDependencyGraph graph);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.Installer.InstallerBase/<ApplyGraphStateAsync>d__37")]
protected Task`1<bool> ApplyGraphStateAsync(Product product, IDictionary`2<string, ISelectionState> packagesToSelect);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.Installer.InstallerBase/<LoadAsync>d__38")]
protected Task LoadAsync(ChannelNode`1<IProductSummaryItem> channelProduct);
    private void SetClientExecutableAndRunOnceArguments(IEngine engine, string setupExecutablePath, string setupExecutableArguments);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.Installer.InstallerBase/<SetOperationModeAsync>d__40")]
protected Task SetOperationModeAsync(OperationMode mode);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.Installer.InstallerBase/<SetLanguagesAsync>d__41")]
protected Task`1<bool> SetLanguagesAsync(IEnumerable`1<string> languages);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.Installer.InstallerBase/<InvokeEngineAsync>d__42")]
protected Task`1<IInstance> InvokeEngineAsync(TelemetryContext telemetryContext, Func`2<IEngine, IInstance> engineFunc);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.Installer.InstallerBase/<AddExtensionsAsync>d__43")]
protected Task AddExtensionsAsync(IEnumerable`1<ExtensionOptions> extensions, Product product);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.Installer.InstallerBase/<AddExtensionAsync>d__44")]
private Task`1<ExtensionStreamInformation> AddExtensionAsync(ExtensionOptions extension, ExtensionsRepository extensionsRepo, Product product);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.Installer.InstallerBase/<GetProductAsync>d__45")]
protected Task`1<Product> GetProductAsync(ChannelNode`1<IProductSummaryItem> channelProductSummary);
    private Product GetMatchingProduct(ChannelNode`1<IProductSummaryItem> channelProductSummary, IEnumerable`1<Product> products);
    protected Product GetMatchingProductImpl(string productId, string productArch, Version productVersion, IEnumerable`1<Product> matchingProducts, Func`2<IEnumerable`1<Product>, Product> productSelector);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.Installer.InstallerBase/<GetRegisteredInstanceProductAsync>d__48")]
protected Task`1<Product> GetRegisteredInstanceProductAsync();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.Installer.InstallerBase/<DownloadExtensionAsync>d__49")]
private Task`1<ExtensionStreamInformation> DownloadExtensionAsync(ExtensionOptions extension);
    private bool ShouldRethrowEngineException(Exception ex);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.Installer.InstallerBase/<CreateInstallOperationResultAsync>d__52")]
private Task`1<InstallOperationResult> CreateInstallOperationResultAsync(IInstance instance, Exception exception);
    private bool HaveSeedLanguagesChanged(DependencyComparisonSeed seed, IEnumerable`1<string> languages);
    [NullableContextAttribute("2")]
private bool IsInstancePaused(IInstance instance);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.Installer.InstallerBase/<InitializeAsync>d__55")]
private Task InitializeAsync();
    private void SynchronizeReadOnlyChannels();
    private string InitializeExtensionsDirectory(IEngine engine);
    private void SetupExtensionDependencies(Stream parentStream, ExtensionContents parentContents, IEngine engine, Product product, ExtensionsRepository extensionsRepo);
    private void SetupExtensionForInstallation(Stream extensionStream, string catalogJson, ExtensionsRepository extensionsRepository, IDependencyGraph graph, string extensionHash);
    [CompilerGeneratedAttribute]
public bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private void SelectExtensions(IDependencyGraph graph);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.Installer.InstallerBase/<GetExpectedChannelProductAsync>d__67")]
protected Task`1<ChannelNode`1<IProductSummaryItem>> GetExpectedChannelProductAsync(Version expectedVersion, Uri channelUri, string productId, string productArch, Uri installChannelUri, Uri installCatalogUri, CancellationToken token);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private IEngine get_Engine();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_Engine(IEngine value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.VisualStudio.Setup.Services.Installer.InstallerBaseOptions : object {
    [CompilerGeneratedAttribute]
private ResumeArguments <SetupExecutableArguments>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <InstanceId>k__BackingField;
    [CompilerGeneratedAttribute]
private TelemetryContext <TelemetryContext>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InstallationPath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <KeepWindowsUpdateOn>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public ResumeArguments SetupExecutableArguments { get; }
    [NullableAttribute("2")]
public string InstanceId { get; public set; }
    public TelemetryContext TelemetryContext { get; public set; }
    public string InstallationPath { get; }
    public bool KeepWindowsUpdateOn { get; public set; }
    public InstallerBaseOptions(ResumeArguments setupExecutableArguments, string installationPath);
    [CompilerGeneratedAttribute]
protected InstallerBaseOptions(InstallerBaseOptions original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public ResumeArguments get_SetupExecutableArguments();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_InstanceId();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_InstanceId(string value);
    [CompilerGeneratedAttribute]
public TelemetryContext get_TelemetryContext();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TelemetryContext(TelemetryContext value);
    [CompilerGeneratedAttribute]
public string get_InstallationPath();
    [CompilerGeneratedAttribute]
public bool get_KeepWindowsUpdateOn();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_KeepWindowsUpdateOn(bool value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(InstallerBaseOptions left, InstallerBaseOptions right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(InstallerBaseOptions left, InstallerBaseOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(InstallerBaseOptions other);
    [CompilerGeneratedAttribute]
public abstract virtual InstallerBaseOptions <Clone>$();
}
internal class Microsoft.VisualStudio.Setup.Services.Installer.InstallOperationBlockedException : LocalizedException {
    [NullableContextAttribute("1")]
public InstallOperationBlockedException(ResourceManager resources, string resourceId, Object[] args);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Services.Installer.InstallOperationResult : object {
    [CompilerGeneratedAttribute]
private string <InstanceId>k__BackingField;
    [CompilerGeneratedAttribute]
private RebootType <RebootType>k__BackingField;
    [CompilerGeneratedAttribute]
private ErrorInformation <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AutoShutdown>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCanceled>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IReadOnlyList`1<ExtensionDownloadFailure> <FailedExtensionDownloads>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public string InstanceId { get; public set; }
    public RebootType RebootType { get; public set; }
    public ErrorInformation Error { get; public set; }
    public bool AutoShutdown { get; public set; }
    public bool IsCanceled { get; public set; }
    [NullableAttribute("1")]
public IReadOnlyList`1<ExtensionDownloadFailure> FailedExtensionDownloads { get; public set; }
    [CompilerGeneratedAttribute]
protected InstallOperationResult(InstallOperationResult original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public string get_InstanceId();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_InstanceId(string value);
    [CompilerGeneratedAttribute]
public RebootType get_RebootType();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_RebootType(RebootType value);
    [CompilerGeneratedAttribute]
public ErrorInformation get_Error();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Error(ErrorInformation value);
    [CompilerGeneratedAttribute]
public bool get_AutoShutdown();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AutoShutdown(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsCanceled();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsCanceled(bool value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public IReadOnlyList`1<ExtensionDownloadFailure> get_FailedExtensionDownloads();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FailedExtensionDownloads(IReadOnlyList`1<ExtensionDownloadFailure> value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(InstallOperationResult left, InstallOperationResult right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(InstallOperationResult left, InstallOperationResult right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(InstallOperationResult other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual InstallOperationResult <Clone>$();
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Setup.Services.Installer.IPackageSelectorOptions {
    public IDictionary`2<string, ISelectionState> SelectedPackages { get; }
    public IEnumerable`1<string> Languages { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<ExtensionOptions> AdditionalExtensions { get; public set; }
    public abstract virtual IDictionary`2<string, ISelectionState> get_SelectedPackages();
    public abstract virtual IEnumerable`1<string> get_Languages();
    public abstract virtual IEnumerable`1<ExtensionOptions> get_AdditionalExtensions();
    public abstract virtual Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AdditionalExtensions(IEnumerable`1<ExtensionOptions> value);
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Setup.Services.Installer.IReadOnlyInstaller {
    public abstract virtual IEvaluatedInstallSizes CalculateInstallSize(IDependencyGraph graph, string installPath, string cachePath, string sharedInstallationPath, VariableCollection properties);
    [NullableContextAttribute("2")]
public abstract virtual string EvaluateInstallationPath(string installPath, string cachePath, string sharedInstallationPath, bool checkCacheSharedOverlap);
    public abstract virtual string EvaluateCachePath(string cachePath);
    public abstract virtual string EvaluateSharedPath(string sharedInstallationPath);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Services.Installer.ProductInstaller : InstallerBase {
    private static string LowerCasePreviewPackageSuffix;
    private ProductInstallerServiceOptions serviceOptions;
    private ProductInstallerOptions options;
    public ProductInstaller(ProductInstallerServiceOptions serviceOptions, ProductInstallerOptions options);
    private static ProductInstaller();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.Installer.ProductInstaller/<InvokeAsyncImpl>d__4")]
protected virtual Task`1<IInstance> InvokeAsyncImpl(CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.Installer.ProductInstaller/<UpdateGraphAsync>d__5")]
protected virtual Task`1<Product> UpdateGraphAsync(IChannelManager channelManager, CancellationToken token);
    private static void ApplyRequestedAndSelectedStateToDependencyGraph(IDependencyGraph productGraph, IDictionary`2<string, UsedSelectedStatePackage> usedSelectedStatePackageById);
    private void ApplyRequestedAndSelectedStateToDependencyGraph(IDependencyGraph productGraph, IDictionary`2<string, ISelectionState> selectedStateByPackageId);
    private static Dictionary`2<string, UsedSelectedStatePackage> MapUnusedPreviewPackageIdToReleasePackageId(IDictionary`2<string, UsedSelectedStatePackage> usedSelectedStatePackageById);
    private static bool IsUnusedPreviewPackage(KeyValuePair`2<string, UsedSelectedStatePackage> usedSelectedStatePackageById);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Services.Installer.ProductInstallerOptions : InstallerBaseOptions {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IDictionary`2<string, ISelectionState> <SelectedPackages>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IEnumerable`1<string> <Languages>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LayoutPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProductKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Nickname>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Uri <ChannelUri>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <ProductId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProductArch>k__BackingField;
    [CompilerGeneratedAttribute]
private OperationMode <OperationMode>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Version <ExpectedVersion>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IEnumerable`1<string> <VisualStudioFlights>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IEnumerable`1<ExtensionOptions> <AdditionalExtensions>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <LayoutUri>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <InstallChannelUri>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <InstallCatalogUri>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeRecommendedOnUpdate>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [NullableAttribute("1")]
public IDictionary`2<string, ISelectionState> SelectedPackages { get; }
    [NullableAttribute("1")]
public IEnumerable`1<string> Languages { get; }
    public string LayoutPath { get; public set; }
    public string ProductKey { get; public set; }
    public string Nickname { get; public set; }
    [NullableAttribute("1")]
public Uri ChannelUri { get; }
    [NullableAttribute("1")]
public string ProductId { get; }
    public string ProductArch { get; }
    public OperationMode OperationMode { get; }
    [NullableAttribute("1")]
public Version ExpectedVersion { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<string> VisualStudioFlights { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<ExtensionOptions> AdditionalExtensions { get; public set; }
    public Uri LayoutUri { get; public set; }
    public Uri InstallChannelUri { get; public set; }
    public Uri InstallCatalogUri { get; public set; }
    public bool IncludeRecommendedOnUpdate { get; public set; }
    [NullableContextAttribute("1")]
public ProductInstallerOptions(ResumeArguments setupExecutableArguments, string installationPath, Uri channelUri, string productId, string productArch, IDictionary`2<string, ISelectionState> selectedPackages, IEnumerable`1<string> languages, OperationMode operationMode, Version expectedVersion);
    [CompilerGeneratedAttribute]
protected ProductInstallerOptions(ProductInstallerOptions original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, ISelectionState> get_SelectedPackages();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<string> get_Languages();
    [CompilerGeneratedAttribute]
public string get_LayoutPath();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_LayoutPath(string value);
    [CompilerGeneratedAttribute]
public string get_ProductKey();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ProductKey(string value);
    [CompilerGeneratedAttribute]
public string get_Nickname();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Nickname(string value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Uri get_ChannelUri();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_ProductId();
    [CompilerGeneratedAttribute]
public string get_ProductArch();
    [CompilerGeneratedAttribute]
public OperationMode get_OperationMode();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Version get_ExpectedVersion();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_VisualStudioFlights();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_VisualStudioFlights(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<ExtensionOptions> get_AdditionalExtensions();
    [CompilerGeneratedAttribute]
public sealed virtual Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AdditionalExtensions(IEnumerable`1<ExtensionOptions> value);
    [CompilerGeneratedAttribute]
public Uri get_LayoutUri();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_LayoutUri(Uri value);
    [CompilerGeneratedAttribute]
public Uri get_InstallChannelUri();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_InstallChannelUri(Uri value);
    [CompilerGeneratedAttribute]
public Uri get_InstallCatalogUri();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_InstallCatalogUri(Uri value);
    [CompilerGeneratedAttribute]
public bool get_IncludeRecommendedOnUpdate();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IncludeRecommendedOnUpdate(bool value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ProductInstallerOptions left, ProductInstallerOptions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ProductInstallerOptions left, ProductInstallerOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(InstallerBaseOptions other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(ProductInstallerOptions other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual InstallerBaseOptions <Clone>$();
}
internal class Microsoft.VisualStudio.Setup.Services.Installer.ProductModifier : InstallerBase {
    [NullableAttribute("1")]
private ProductModifierOptions options;
    private TelemetryContext telemetryContext;
    [NullableAttribute("2")]
private Product product;
    [NullableContextAttribute("1")]
public ProductModifier(ProductModifierServiceOptions serviceOptions, ProductModifierOptions options);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.Installer.ProductModifier/<InvokeAsyncImpl>d__4")]
protected virtual Task`1<IInstance> InvokeAsyncImpl(CancellationToken token);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.Installer.ProductModifier/<InitializeAsync>d__5")]
private Task InitializeAsync(ProductModifierOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Services.Installer.ProductModifierOptions : InstallerBaseOptions {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, ISelectionState> <SelectedPackages>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Languages>k__BackingField;
    [CompilerGeneratedAttribute]
private OperationMode <OperationMode>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IEnumerable`1<string> <VisualStudioFlights>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IEnumerable`1<ExtensionOptions> <AdditionalExtensions>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public IDictionary`2<string, ISelectionState> SelectedPackages { get; }
    public IEnumerable`1<string> Languages { get; }
    public OperationMode OperationMode { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<string> VisualStudioFlights { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<ExtensionOptions> AdditionalExtensions { get; public set; }
    public ProductModifierOptions(ResumeArguments setupExecutableArguments, string instanceId, string installationPath, IDictionary`2<string, ISelectionState> selectedPackages, IEnumerable`1<string> languages, OperationMode operationMode);
    [CompilerGeneratedAttribute]
protected ProductModifierOptions(ProductModifierOptions original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, ISelectionState> get_SelectedPackages();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<string> get_Languages();
    [CompilerGeneratedAttribute]
public OperationMode get_OperationMode();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_VisualStudioFlights();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_VisualStudioFlights(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<ExtensionOptions> get_AdditionalExtensions();
    [CompilerGeneratedAttribute]
public sealed virtual Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AdditionalExtensions(IEnumerable`1<ExtensionOptions> value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(ProductModifierOptions left, ProductModifierOptions right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(ProductModifierOptions left, ProductModifierOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(InstallerBaseOptions other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(ProductModifierOptions other);
    [CompilerGeneratedAttribute]
public virtual InstallerBaseOptions <Clone>$();
}
internal class Microsoft.VisualStudio.Setup.Services.Installer.ProductRepairer : InstallerBase {
    [NullableAttribute("1")]
private ProductRepairerOptions options;
    [NullableContextAttribute("1")]
public ProductRepairer(ProductRepairerServiceOptions serviceOptions, ProductRepairerOptions options);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.Installer.ProductRepairer/<InvokeAsyncImpl>d__2")]
protected virtual Task`1<IInstance> InvokeAsyncImpl(CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Services.Installer.ProductRepairerOptions : InstallerBaseOptions {
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public ProductRepairerOptions(ResumeArguments setupExecutableArguments, string instanceId, string installationPath);
    [CompilerGeneratedAttribute]
protected ProductRepairerOptions(ProductRepairerOptions original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(ProductRepairerOptions left, ProductRepairerOptions right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(ProductRepairerOptions left, ProductRepairerOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(InstallerBaseOptions other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(ProductRepairerOptions other);
    [CompilerGeneratedAttribute]
public virtual InstallerBaseOptions <Clone>$();
}
internal class Microsoft.VisualStudio.Setup.Services.Installer.ProductResumer : InstallerBase {
    [NullableAttribute("1")]
private ProductResumerOptions options;
    [NullableContextAttribute("1")]
public ProductResumer(ProductResumerServiceOptions serviceOptions, ProductResumerOptions options);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.Installer.ProductResumer/<InvokeAsyncImpl>d__2")]
protected virtual Task`1<IInstance> InvokeAsyncImpl(CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Services.Installer.ProductResumerOptions : InstallerBaseOptions {
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public ProductResumerOptions(ResumeArguments setupExecutableArguments, string instanceId, string installationPath);
    [CompilerGeneratedAttribute]
protected ProductResumerOptions(ProductResumerOptions original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(ProductResumerOptions left, ProductResumerOptions right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(ProductResumerOptions left, ProductResumerOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(InstallerBaseOptions other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(ProductResumerOptions other);
    [CompilerGeneratedAttribute]
public virtual InstallerBaseOptions <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Services.Installer.ProductReverter : InstallerBase {
    private ProductReverterServiceOptions serviceOptions;
    private ProductReverterOptions options;
    public ProductReverter(ProductReverterServiceOptions serviceOptions, ProductReverterOptions options);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.Installer.ProductReverter/<InvokeAsyncImpl>d__3")]
protected virtual Task`1<IInstance> InvokeAsyncImpl(CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.Installer.ProductReverter/<GetProductAsync>d__4")]
private Task`1<Product> GetProductAsync(Product registeredProduct);
    private Product GetMatchingProduct(Product registeredProduct, IEnumerable`1<Product> products);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Services.Installer.ProductReverterOptions : InstallerBaseOptions {
    [CompilerGeneratedAttribute]
private OperationMode <OperationMode>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public OperationMode OperationMode { get; }
    public ProductReverterOptions(ResumeArguments setupExecutableArguments, string instanceId, string installationPath, OperationMode operationMode);
    [CompilerGeneratedAttribute]
protected ProductReverterOptions(ProductReverterOptions original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public OperationMode get_OperationMode();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(ProductReverterOptions left, ProductReverterOptions right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(ProductReverterOptions left, ProductReverterOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(InstallerBaseOptions other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(ProductReverterOptions other);
    [CompilerGeneratedAttribute]
public virtual InstallerBaseOptions <Clone>$();
}
internal class Microsoft.VisualStudio.Setup.Services.Installer.ProductUninstaller : InstallerBase {
    [NullableAttribute("1")]
private ProductUninstallerOptions options;
    [NullableContextAttribute("1")]
public ProductUninstaller(ProductUninstallerServiceOptions serviceOptions, ProductUninstallerOptions options);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.Installer.ProductUninstaller/<InvokeAsyncImpl>d__2")]
protected virtual Task`1<IInstance> InvokeAsyncImpl(CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Services.Installer.ProductUninstallerOptions : InstallerBaseOptions {
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public ProductUninstallerOptions(ResumeArguments setupExecutableArguments, string instanceId, string installationPath);
    [CompilerGeneratedAttribute]
protected ProductUninstallerOptions(ProductUninstallerOptions original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(ProductUninstallerOptions left, ProductUninstallerOptions right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(ProductUninstallerOptions left, ProductUninstallerOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(InstallerBaseOptions other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(ProductUninstallerOptions other);
    [CompilerGeneratedAttribute]
public virtual InstallerBaseOptions <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Services.Installer.ProductUpdater : InstallerBase {
    private ProductUpdaterServiceOptions serviceOptions;
    private ProductUpdaterOptions options;
    private bool changedChannels;
    public ProductUpdater(ProductUpdaterServiceOptions serviceOptions, ProductUpdaterOptions options);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.Installer.ProductUpdater/<InvokeAsyncImpl>d__4")]
protected virtual Task`1<IInstance> InvokeAsyncImpl(CancellationToken token);
    private static IProgressReporter CreateWUProgressReporter(ProductUpdaterServiceOptions serviceOptions, ProductUpdaterOptions updateOptions);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.Installer.ProductUpdater/<PreEngineCreationInitializationAsync>d__6")]
protected virtual Task PreEngineCreationInitializationAsync();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.Installer.ProductUpdater/<ChangeChannelAsync>d__7")]
private Task`1<bool> ChangeChannelAsync();
    private void DeselectOosComponents(IDependencyGraph graph);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Services.Installer.ProductUpdaterOptions : InstallerBaseOptions {
    [CompilerGeneratedAttribute]
private string <LayoutPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InstallLayoutPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProductKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Nickname>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UpdateFromVS>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IDictionary`2<string, ISelectionState> <SelectedAdvertisedPackages>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RemoveOos>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeRecommended>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Version <UpdateVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private OperationMode <OperationMode>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IEnumerable`1<string> <VisualStudioFlights>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ChannelUri>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <InstallChannelUri>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <InstallCatalogUri>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <LayoutUri>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <WUProgressCBClsID>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public string LayoutPath { get; public set; }
    public string InstallLayoutPath { get; public set; }
    public string ProductKey { get; public set; }
    public string Nickname { get; public set; }
    public bool UpdateFromVS { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IDictionary`2<string, ISelectionState> SelectedAdvertisedPackages { get; }
    public bool RemoveOos { get; }
    public bool IncludeRecommended { get; }
    [NullableAttribute("1")]
public Version UpdateVersion { get; }
    public OperationMode OperationMode { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<string> VisualStudioFlights { get; public set; }
    public Uri ChannelUri { get; public set; }
    public Uri InstallChannelUri { get; public set; }
    public Uri InstallCatalogUri { get; public set; }
    public Uri LayoutUri { get; public set; }
    public Guid WUProgressCBClsID { get; public set; }
    [NullableContextAttribute("1")]
public ProductUpdaterOptions(ResumeArguments setupExecutableArguments, string instanceId, string installationPath, bool updateFromVS, IDictionary`2<string, ISelectionState> selectedAdvertisedPackages, Version updateVersion, OperationMode operationMode, bool removeOos, bool includeRecommended);
    [CompilerGeneratedAttribute]
protected ProductUpdaterOptions(ProductUpdaterOptions original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public string get_LayoutPath();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_LayoutPath(string value);
    [CompilerGeneratedAttribute]
public string get_InstallLayoutPath();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_InstallLayoutPath(string value);
    [CompilerGeneratedAttribute]
public string get_ProductKey();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ProductKey(string value);
    [CompilerGeneratedAttribute]
public string get_Nickname();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Nickname(string value);
    [CompilerGeneratedAttribute]
public bool get_UpdateFromVS();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, ISelectionState> get_SelectedAdvertisedPackages();
    [CompilerGeneratedAttribute]
public bool get_RemoveOos();
    [CompilerGeneratedAttribute]
public bool get_IncludeRecommended();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Version get_UpdateVersion();
    [CompilerGeneratedAttribute]
public OperationMode get_OperationMode();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_VisualStudioFlights();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_VisualStudioFlights(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public Uri get_ChannelUri();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ChannelUri(Uri value);
    [CompilerGeneratedAttribute]
public Uri get_InstallChannelUri();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_InstallChannelUri(Uri value);
    [CompilerGeneratedAttribute]
public Uri get_InstallCatalogUri();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_InstallCatalogUri(Uri value);
    [CompilerGeneratedAttribute]
public Uri get_LayoutUri();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_LayoutUri(Uri value);
    [CompilerGeneratedAttribute]
public Guid get_WUProgressCBClsID();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_WUProgressCBClsID(Guid value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ProductUpdaterOptions left, ProductUpdaterOptions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ProductUpdaterOptions left, ProductUpdaterOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(InstallerBaseOptions other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(ProductUpdaterOptions other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual InstallerBaseOptions <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Services.Installer.ReadOnlyInstaller : object {
    private ReadOnlyInstallerServiceOptions serviceOptions;
    public ReadOnlyInstaller(ReadOnlyInstallerServiceOptions serviceOptions);
    public sealed virtual IEvaluatedInstallSizes CalculateInstallSize(IDependencyGraph graph, string installPath, string cachePath, string sharedInstallationPath, VariableCollection properties);
    [NullableContextAttribute("2")]
public sealed virtual string EvaluateInstallationPath(string installPath, string cachePath, string sharedInstallationPath, bool checkCacheSharedOverlap);
    public sealed virtual string EvaluateCachePath(string cachePath);
    public sealed virtual string EvaluateSharedPath(string sharedInstallationPath);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Services.Installer.ResumeArguments : object {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <ActivityId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InstallationPath>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <ProductKey>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsQuiet>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPassive>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InstallSessionId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasValue>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [NullableAttribute("2")]
public string ActivityId { get; public set; }
    public string InstallationPath { get; }
    [NullableAttribute("2")]
public string ProductKey { get; public set; }
    public bool IsQuiet { get; }
    public bool IsPassive { get; }
    public string InstallSessionId { get; }
    public bool HasValue { get; }
    [JsonConstructorAttribute]
public ResumeArguments(string installationPath, string installSessionId, bool isQuiet, bool isPassive);
    [CompilerGeneratedAttribute]
protected ResumeArguments(ResumeArguments original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_ActivityId();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ActivityId(string value);
    [CompilerGeneratedAttribute]
public string get_InstallationPath();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_ProductKey();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ProductKey(string value);
    [CompilerGeneratedAttribute]
public bool get_IsQuiet();
    [CompilerGeneratedAttribute]
public bool get_IsPassive();
    [CompilerGeneratedAttribute]
public string get_InstallSessionId();
    [CompilerGeneratedAttribute]
public bool get_HasValue();
    public string GetResumeString();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(ResumeArguments left, ResumeArguments right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(ResumeArguments left, ResumeArguments right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(ResumeArguments other);
    [CompilerGeneratedAttribute]
public virtual ResumeArguments <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Services.Installer.Rpc.InstallerRpcValidator : object {
    private static string InstallerSubPathRegexString;
    private IProcessService processService;
    private IFileSystem fileSystem;
    private ISignatureVerifierManager signatureVerifier;
    [NullableAttribute("2")]
private ILogger logger;
    [NullableAttribute("2")]
private ITelemetry telemetry;
    private static InstallerRpcValidator();
    public InstallerRpcValidator(IProcessService processService, IFileSystem fileSystem, ISignatureVerifierManager signatureVerifier, ILogger logger, ITelemetry telemetry);
    public sealed virtual bool IsValidRpcConnection(int clientPid);
    private bool IsSupportedPath(string clientPath);
    private bool IsMicrosoftSigned(string clientPath);
}
internal interface Microsoft.VisualStudio.Setup.Services.Installer.Rpc.IRpcConnectionValidator {
    public abstract virtual bool IsValidRpcConnection(int otherProcessId);
}
[NullableContextAttribute("2")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.VisualStudio.Setup.Services.InstallerUserSettingsRepository : SettingFileRepositoryBase`1<UserSettings> {
    protected bool IsEmpty { get; }
    public string PreviousSessionId { get; public set; }
    public string Theme { get; public set; }
    public bool ShowDownlevelSkus { get; }
    [NullableContextAttribute("1")]
public InstallerUserSettingsRepository(IServiceProvider services);
    [NullableContextAttribute("1")]
private static IFileSystem GetFileSystem(IServiceProvider services);
    protected virtual bool get_IsEmpty();
    public sealed virtual string get_PreviousSessionId();
    public sealed virtual void set_PreviousSessionId(string value);
    public sealed virtual string get_Theme();
    public sealed virtual void set_Theme(string value);
    public sealed virtual bool get_ShowDownlevelSkus();
    [NullableContextAttribute("1")]
public sealed virtual CultureInfo LoadLocale();
    [NullableContextAttribute("1")]
public sealed virtual void SaveLocale(CultureInfo locale);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <set_PreviousSessionId>b__6_0(string newValue);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <set_Theme>b__9_0(string newValue);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <SaveLocale>b__13_0(string newValue);
}
public interface Microsoft.VisualStudio.Setup.Services.IOperatingSystem {
    public Version Version { get; }
    public bool InContainer { get; }
    public bool Is64Bit { get; }
    public NetworkCostType ConnectionCost { get; }
    public CultureInfo CurrentUICulture { get; }
    public int ProcessorCount { get; }
    public abstract virtual Version get_Version();
    public abstract virtual void NotifyChange();
    public abstract virtual void SetUrlAssociationDefaults(IEnumerable`1<string> associations, string defaultApplication);
    public abstract virtual void StartUpdates();
    public abstract virtual void StopUpdates();
    public abstract virtual bool AreUpdatesOFF();
    public abstract virtual bool get_InContainer();
    public abstract virtual bool get_Is64Bit();
    public abstract virtual NetworkCostType get_ConnectionCost();
    public abstract virtual CultureInfo get_CurrentUICulture();
    public abstract virtual int get_ProcessorCount();
    public abstract virtual IDisposable SuspendSleep();
    public abstract virtual IEnumerable`1<IDriveInfo> GetPhysicalDiskInfo();
    public abstract virtual SystemPowerStatus GetSystemPowerStatus();
    public abstract virtual string GetEnvironmentVariable(string key);
    public abstract virtual bool Restart(ShutdownReason restartReason);
    public abstract virtual bool IsRunningApplicationServerMode();
    public abstract virtual bool IsType(OperatingSystemType type);
}
internal interface Microsoft.VisualStudio.Setup.Services.IPendingRebootOperations {
    public ISet`1<string> FilesToBeDeleted { get; }
    public abstract virtual ISet`1<string> get_FilesToBeDeleted();
    public abstract virtual void Clear();
}
public interface Microsoft.VisualStudio.Setup.Services.IPolicyService {
    public AutomaticUpdatesValue AdministratorUpdatesEnabled { get; }
    public bool AdministratorUpdatesOptOut { get; }
    public bool AdministratorPromptToClose { get; }
    public bool AutoUpdateDisabled { get; }
    public bool BackgroundDownloadDisabled { get; }
    public string CachePath { get; public set; }
    public string CompatibilityInstallationPath { get; }
    public bool DiagnosticMode { get; }
    public bool DisableMicrosoftChannelFeed { get; }
    public bool DisableRollback { get; }
    public bool HideAvailableTab { get; }
    public bool IgnoreChannelFeedProductRestriction { get; }
    public bool RemoveOos { get; }
    public bool DisableSound { get; }
    public string SharedInstallationPath { get; }
    public bool ChannelUpdateDisabled { get; }
    public int ConcurrentDownloads { get; }
    public bool KeepDownloadedPayloads { get; }
    public string UpdateConfigurationFile { get; }
    public bool IsCachePathSettable { get; }
    public bool IsSharedInstallPathSettable { get; }
    public bool DisableBlockedOSCheck { get; }
    public ElevationServiceSupport ElevationServiceSupport { get; }
    public bool AdministratorUpdatesNotificationsEnabled { get; }
    public bool AdministratorUpdateOnCloseOptOut { get; }
    public bool VSthroughMUUpdatesOptOut { get; }
    public bool PreviewAutomaticUpdates { get; }
    public bool UpdateNotificationsOptOut { get; }
    internal abstract virtual bool IsPolicySet(string policyPropertyName);
    public abstract virtual AutomaticUpdatesValue get_AdministratorUpdatesEnabled();
    public abstract virtual bool get_AdministratorUpdatesOptOut();
    public abstract virtual bool get_AdministratorPromptToClose();
    public abstract virtual bool get_AutoUpdateDisabled();
    public abstract virtual bool get_BackgroundDownloadDisabled();
    public abstract virtual string get_CachePath();
    public abstract virtual void set_CachePath(string value);
    public abstract virtual string get_CompatibilityInstallationPath();
    public abstract virtual bool get_DiagnosticMode();
    public abstract virtual bool get_DisableMicrosoftChannelFeed();
    public abstract virtual bool get_DisableRollback();
    public abstract virtual bool get_HideAvailableTab();
    public abstract virtual bool get_IgnoreChannelFeedProductRestriction();
    public abstract virtual bool get_RemoveOos();
    public abstract virtual bool get_DisableSound();
    public abstract virtual string get_SharedInstallationPath();
    public abstract virtual bool get_ChannelUpdateDisabled();
    public abstract virtual int get_ConcurrentDownloads();
    public abstract virtual bool get_KeepDownloadedPayloads();
    public abstract virtual string get_UpdateConfigurationFile();
    [CompilerGeneratedAttribute]
public abstract virtual void add_Invalidated(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Invalidated(EventHandler`1<EventArgs> value);
    public abstract virtual bool get_IsCachePathSettable();
    public abstract virtual bool get_IsSharedInstallPathSettable();
    public abstract virtual bool get_DisableBlockedOSCheck();
    public abstract virtual ElevationServiceSupport get_ElevationServiceSupport();
    public abstract virtual bool get_AdministratorUpdatesNotificationsEnabled();
    public abstract virtual bool get_AdministratorUpdateOnCloseOptOut();
    public abstract virtual bool get_VSthroughMUUpdatesOptOut();
    public abstract virtual bool get_PreviewAutomaticUpdates();
    public abstract virtual bool get_UpdateNotificationsOptOut();
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Setup.Services.IPrecheckEvaluatorFactory {
    public abstract virtual IEnumerable`1<IPrecheckEvaluator> GetPrecheckEvaluators(IServiceProvider services, PrecheckParameters precheckParams, VariableCollection properties);
}
public interface Microsoft.VisualStudio.Setup.Services.IPrecheckManager {
    public abstract virtual void RunPrechecks(PrecheckParameters precheckParameters, VariableCollection properties);
    public abstract virtual void ShutDownOtherRunningVSProcesses(string vsFolder, IWindowsRestartManager rmService, IEnumerable`1<string> relatedProcessDirectories, IEnumerable`1<string> relatedProcessFiles, IEnumerable`1<string> relatedServices);
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Setup.Services.IProgressReceiver {
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnReport(EventHandler`1<ProgressEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnReport(EventHandler`1<ProgressEventArgs> value);
}
public interface Microsoft.VisualStudio.Setup.Services.IProgressReporter {
    public abstract virtual void Report(string package, double progress, ProgressType type, ProgressInfo detailedProgress);
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.Setup.Services.IQueryFactory {
    public abstract virtual IQuery Create();
}
internal interface Microsoft.VisualStudio.Setup.Services.IResolver {
}
internal interface Microsoft.VisualStudio.Setup.Services.IResolverFactory {
    public abstract virtual T GetResolver(IServiceProvider services);
}
public interface Microsoft.VisualStudio.Setup.Services.IScheduledTaskDefinition {
    public string Name { get; public set; }
    public string Directory { get; public set; }
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
    public abstract virtual string get_Directory();
    public abstract virtual void set_Directory(string value);
}
public interface Microsoft.VisualStudio.Setup.Services.IScheduledTaskDetails {
    public TaskRegistrationInfo RegistrationInfo { get; public set; }
    public abstract virtual TaskRegistrationInfo get_RegistrationInfo();
    public abstract virtual void set_RegistrationInfo(TaskRegistrationInfo value);
}
public interface Microsoft.VisualStudio.Setup.Services.IServiceContainer {
    public bool IsDisposed { get; }
    public abstract virtual bool get_IsDisposed();
    public abstract virtual void AddService(T service, bool throwIfExists, bool keepAlive);
    public abstract virtual void AddService(T& object, Func`1<T> getter);
    public abstract virtual void AddService(T& object, bool keepAlive, Func`1<T> getter);
}
internal interface Microsoft.VisualStudio.Setup.Services.IServiceController {
    public bool CanStop { get; }
    public string DisplayName { get; }
    public string ServiceName { get; }
    public ServiceControllerStatus Status { get; }
    public bool Exists { get; }
    public abstract virtual bool get_CanStop();
    public abstract virtual string get_DisplayName();
    public abstract virtual string get_ServiceName();
    public abstract virtual ServiceControllerStatus get_Status();
    public abstract virtual void Stop();
    public abstract virtual void Start();
    public abstract virtual void WaitForStatus(ServiceControllerStatus status, TimeSpan timeout);
    public abstract virtual bool get_Exists();
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Setup.Services.IServiceControllerFactory {
    public abstract virtual IServiceController Create(string serviceName);
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Setup.Services.IServiceRegistrationService {
    public abstract virtual void InstallService(string servicePath, string serviceName, string serviceDisplayName, string description, bool autoStart, bool canAllUsersChangeState);
    public abstract virtual void UpdateService(string servicePath, string serviceName, string serviceDisplayName);
    public abstract virtual void UninstallService(string serviceName);
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Setup.Services.IShortcutService {
    public abstract virtual bool CreateShortcuts(IEnumerable`1<Shortcut> shortcuts, IDictionary`2<string, string> variables);
    public abstract virtual bool DeleteShortcuts(IEnumerable`1<ShortcutInformation> shortcuts, IDictionary`2<string, string> variables);
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Setup.Services.ISingletonService {
    public int NumberOfRelaunches { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_SecondInstanceStarted(EventHandler`1<SingletonEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_SecondInstanceStarted(EventHandler`1<SingletonEventArgs> value);
    public abstract virtual bool GetSingletonLock();
    public abstract virtual bool ReleaseSingletonLock();
    public abstract virtual int get_NumberOfRelaunches();
}
internal interface Microsoft.VisualStudio.Setup.Services.IStopSignal {
    [CompilerGeneratedAttribute]
public abstract virtual void add_StopRequested(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StopRequested(EventHandler`1<EventArgs> value);
    public abstract virtual void Stop();
}
public interface Microsoft.VisualStudio.Setup.Services.ITaskScheduler {
    public abstract virtual void Create(IScheduledTaskDefinition definition, bool excludeUpdate);
    public abstract virtual void Remove(IScheduledTaskDefinition definition);
    public abstract virtual void RemoveAll();
    public abstract virtual bool TryGetTaskDetails(string name, string directory, IScheduledTaskDetails& taskDetails);
    public abstract virtual void RegisterTask(string name, string directory, string taskXmlContent, string userAccount, TaskLogonType logonType);
}
internal interface Microsoft.VisualStudio.Setup.Services.ITelemetrySamplingService {
    public int SampledPercentage { get; }
    public abstract virtual int get_SampledPercentage();
    public abstract virtual bool CanBeSampled(string eventName);
    public abstract virtual bool IsDropped(string eventName);
}
public interface Microsoft.VisualStudio.Setup.Services.ITransactedRegistryKey {
    public abstract virtual IRegistryKey CreateSubKeyTransacted(string path, RegistryOptions options);
    public abstract virtual void DeleteSubKeyTreeTransacted(string path, bool throwOnMissingSubKey);
    public abstract virtual IRegistryKey OpenSubKeyTransacted(string path, bool writable);
}
[GuidAttribute("2ab9b851-c9c1-4d31-9d59-e097b760b106")]
[InterfaceTypeAttribute("1")]
internal interface Microsoft.VisualStudio.Setup.Services.IUpdateInstallerProgress {
    public abstract virtual int SetProgress(UInt32 percentComplete);
}
internal interface Microsoft.VisualStudio.Setup.Services.IUpdateSettingsService {
    public abstract virtual void ChangeChannel(string instanceId, IChannel newChannel);
    public abstract virtual void ChangeUpdateSettings(string instanceId, Nullable`1<bool> removeOos, bool includeRecommendedOnUpdate);
    public abstract virtual void InitializeUpdateSettings(IEngine engine, Nullable`1<bool> removeOos, bool includeRecommendedOnUpdate);
}
public interface Microsoft.VisualStudio.Setup.Services.IVariableResolver {
    public abstract virtual string ResolveVariables(string value, IDictionary`2<string, string> properties);
}
public interface Microsoft.VisualStudio.Setup.Services.IWatson {
    public abstract virtual void FileWERReport(IEngineContext context, IPackage currentPackage, string packageAction, string returnCode, string details, bool sendReport, bool addLogs, string logFile, bool createDump, IEnumerable`1<LogFile> additionalLogFiles, IDictionary`2<string, string> properties);
}
public interface Microsoft.VisualStudio.Setup.Services.IWindowsRestartManager {
    public abstract virtual void Register(IEnumerable`1<string> files, IEnumerable`1<IProcess> processes, IEnumerable`1<string> services);
    public abstract virtual void Shutdown(WindowsRestartManagerShutdown action);
    public abstract virtual void Restart();
    public abstract virtual IEnumerable`1<IWindowsRestartManagerProcessInfo> GetProcesses();
}
public interface Microsoft.VisualStudio.Setup.Services.IWindowsRestartManagerFactory {
    public abstract virtual IWindowsRestartManager Create();
}
public interface Microsoft.VisualStudio.Setup.Services.IWindowsRestartManagerProcessInfo {
    public int Id { get; }
    public DateTime StartTime { get; }
    public string Description { get; }
    public string ServiceName { get; }
    public ApplicationType ApplicationType { get; }
    public ApplicationStatus ApplicationStatus { get; }
    public bool IsRestartable { get; }
    public abstract virtual int get_Id();
    public abstract virtual DateTime get_StartTime();
    public abstract virtual string get_Description();
    public abstract virtual string get_ServiceName();
    public abstract virtual ApplicationType get_ApplicationType();
    public abstract virtual ApplicationStatus get_ApplicationStatus();
    public abstract virtual bool get_IsRestartable();
}
internal interface Microsoft.VisualStudio.Setup.Services.IWritablePolicyService {
    public bool KeepDownloadedPayloads { get; public set; }
    public string SharedInstallationPath { get; public set; }
    public abstract virtual bool get_KeepDownloadedPayloads();
    public abstract virtual void set_KeepDownloadedPayloads(bool value);
    public abstract virtual string get_SharedInstallationPath();
    public abstract virtual void set_SharedInstallationPath(string value);
}
public class Microsoft.VisualStudio.Setup.Services.LockService : object {
    private IFileSystem fileSystem;
    private IDictionary`2<string, FileLock> lockedFiles;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    public bool IsDisposed { get; private set; }
    public LockService(IServiceProvider services);
    protected virtual override void Finalize();
    [CompilerGeneratedAttribute]
public bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    public sealed virtual IDisposable Lock(string path);
    public sealed virtual void UnlockAll();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
internal class Microsoft.VisualStudio.Setup.Services.LogicalDriveInfo : object {
    [CompilerGeneratedAttribute]
private char <DriveLetter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSolidStateDrive>k__BackingField;
    [CompilerGeneratedAttribute]
private DriveTypeNative <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<DiskInfo> <Disks>k__BackingField;
    public char DriveLetter { get; }
    public bool IsSolidStateDrive { get; }
    internal DriveTypeNative Type { get; }
    internal IEnumerable`1<DiskInfo> Disks { get; }
    internal LogicalDriveInfo(char driveLetter, DriveTypeNative type, IEnumerable`1<DiskInfo> disks, bool isSolidStateDrive);
    [CompilerGeneratedAttribute]
public sealed virtual char get_DriveLetter();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsSolidStateDrive();
    [CompilerGeneratedAttribute]
internal DriveTypeNative get_Type();
    [CompilerGeneratedAttribute]
internal IEnumerable`1<DiskInfo> get_Disks();
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.LogicalDriveInfo/<GetDrives>d__13")]
internal static IEnumerable`1<LogicalDriveInfo> GetDrives();
    internal static LogicalDriveInfo Create(char driveLetter);
}
internal class Microsoft.VisualStudio.Setup.Services.LUID : ValueType {
    [CompilerGeneratedAttribute]
private UInt32 <LowPart>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HighPart>k__BackingField;
    public UInt32 LowPart { get; public set; }
    public int HighPart { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_LowPart();
    [CompilerGeneratedAttribute]
public void set_LowPart(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_HighPart();
    [CompilerGeneratedAttribute]
public void set_HighPart(int value);
}
internal class Microsoft.VisualStudio.Setup.Services.LUID_AND_ATTRIBUTES : ValueType {
    [CompilerGeneratedAttribute]
private LUID <Luid>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Attributes>k__BackingField;
    public LUID Luid { get; public set; }
    public UInt32 Attributes { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public LUID get_Luid();
    [CompilerGeneratedAttribute]
public void set_Luid(LUID value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_Attributes();
    [CompilerGeneratedAttribute]
public void set_Attributes(UInt32 value);
}
public enum Microsoft.VisualStudio.Setup.Services.MachineArchitecture : Enum {
    public int value__;
    public static MachineArchitecture Unknown;
    public static MachineArchitecture x86;
    public static MachineArchitecture x64;
    public static MachineArchitecture Arm;
    public static MachineArchitecture Arm64;
}
public class Microsoft.VisualStudio.Setup.Services.MachineService : object {
    [NullableAttribute("1")]
private IProcessService processService;
    [NullableAttribute("1")]
private IOperatingSystem operatingSystem;
    [NullableAttribute("2")]
private ILogger logger;
    [NullableContextAttribute("2")]
public MachineService(IServiceProvider services);
    public sealed virtual MachineArchitecture GetMachineArchitecture();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Services.MarketplaceExtensionService : object {
    private static int MaxConcurrentThreads;
    internal static string VisualStudioMarketplaceBaseUri;
    internal static string VisualStudioMarketplaceItemPagePrefix;
    private static IEnumerable`1<ApiResourceLocation> ResourceLocations;
    private static string VSUriPostfix;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<ILogger> lazyLogger;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<ITelemetry> lazyTelemetry;
    private SemaphoreSlim semaphore;
    public MarketplaceExtensionService(IServiceProvider services);
    private static MarketplaceExtensionService();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.MarketplaceExtensionService/<GetExtensionUrisAsync>d__9")]
public sealed virtual Task`1<ExtensionQueryResult> GetExtensionUrisAsync(Version instanceVersion, string productArch, IDictionary`2<string, ExtensionOrigin> extensions, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.MarketplaceExtensionService/<GetItemNamesAsync>d__10")]
public sealed virtual Task`1<IDictionary`2<string, string>> GetItemNamesAsync(IEnumerable`1<string> vsixIds, CancellationToken token);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.MarketplaceExtensionService/<GetItemNameAsync>d__11")]
private Task`1<string> GetItemNameAsync(string vsixId, CancellationToken token);
    private bool TryGetSingleExtension(ExtensionQueryResult queryResult, PublishedExtension& extension);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.MarketplaceExtensionService/<GetExtensionSummary>d__13")]
private Task`1<ExtensionDisplayInformation> GetExtensionSummary(GalleryHttpClient client, string extension, ExtensionOrigin origin, string instanceVersion, string arch, CancellationToken token);
    private List`1<FilterCriteria> GetFilterCriteria(string extension, string instanceVersion, string arch);
    [NullableContextAttribute("2")]
private string TranslateArchitecture(string productArch);
    private void WriteVerbose(string message, Object[] args);
    private void InitializeClient(GalleryHttpClient client);
}
internal class Microsoft.VisualStudio.Setup.Services.MEMORYSTATUSEX : object {
    public UInt32 Length;
    public UInt32 MemoryLoad;
    public ulong TotalPhys;
    public ulong AvailPhys;
    public ulong TotalPageFile;
    public ulong AvailPageFile;
    public ulong TotalVirtual;
    public ulong AvailVirtual;
    public ulong AvailExtendedVirtual;
}
public class Microsoft.VisualStudio.Setup.Services.MessageEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Message <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageResult <Result>k__BackingField;
    public Message Message { get; }
    public MessageResult Result { get; public set; }
    public MessageEventArgs(Message message);
    [CompilerGeneratedAttribute]
public Message get_Message();
    [CompilerGeneratedAttribute]
public MessageResult get_Result();
    [CompilerGeneratedAttribute]
public void set_Result(MessageResult value);
}
[FlagsAttribute]
internal enum Microsoft.VisualStudio.Setup.Services.MoveFileFlags : Enum {
    public int value__;
    public static MoveFileFlags NONE;
    public static MoveFileFlags MOVEFILE_REPLACE_EXISTING;
    public static MoveFileFlags MOVEFILE_COPY_ALLOWED;
    public static MoveFileFlags MOVEFILE_DELAY_UNTIL_REBOOT;
    public static MoveFileFlags MOVEFILE_WRITE_THROUGH;
}
internal class Microsoft.VisualStudio.Setup.Services.MutexFacade : object {
    [NullableAttribute("1")]
private Mutex mutex;
    [NullableContextAttribute("1")]
public MutexFacade(Mutex mutex);
    public sealed virtual void Dispose();
    public sealed virtual void ReleaseMutex();
}
public class Microsoft.VisualStudio.Setup.Services.MutexService : object {
    [NullableContextAttribute("1")]
public sealed virtual bool TryGetNamedMutex(string name, IMutex& mutex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.VisualStudio.Setup.Services.NativeMethods : object {
    internal static int ATTACH_PARENT_PROCESS;
    internal static int ERROR_SUCCESS;
    internal static int ERROR_ACCESS_DENIED;
    internal static int ERROR_INVALID_HANDLE;
    internal static int ERROR_INVALID_PARAMETER;
    internal static int ERROR_MORE_DATA;
    internal static int ERROR_NO_ASSOCIATION;
    internal static int ERROR_BAD_IMPERSONATION_LEVEL;
    internal static int QueryFullProcessImageNameBufferSize;
    internal static int CCH_RM_SESSION_KEY;
    internal static int CCH_RM_MAX_APP_NAME;
    internal static int CCH_RM_MAX_SVC_NAME;
    internal static ushort IMAGE_FILE_MACHINE_ARM64;
    internal static ushort IMAGE_FILE_MACHINE_AMD64;
    internal static ushort IMAGE_FILE_MACHINE_ARM;
    internal static ushort IMAGE_FILE_MACHINE_ARMNT;
    internal static ushort IMAGE_FILE_MACHINE_THUMB;
    internal static ushort IMAGE_FILE_MACHINE_M32R;
    internal static ushort IMAGE_FILE_MACHINE_I386;
    internal static int VER_SUITE_TERMINAL;
    internal static int VER_SUITE_SINGLEUSERTS;
    internal static int IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS;
    internal static int IOCTL_STORAGE_QUERY_PROPERTY;
    internal static ErrorCode ErrorNoAssociation;
    private static NativeMethods();
    internal static bool CloseHandle(IntPtr hObject);
    internal static bool IsWow64Process2(IntPtr process, UInt16& processMachine, UInt16& nativeMachine);
    internal static bool GetTokenInformation(IntPtr TokenHandle, TokenInformation TokenInformationClass, TokenElevation TokenInformation, int TokenInformationLength, Int32& ReturnLength);
    internal static bool MoveFileEx(string lpExistingFileName, string lpNewFileName, MoveFileFlags dwFlags);
    internal static bool OpenProcessToken(IntPtr ProcessHandle, AccessMask DesiredAccess, IntPtr& TokenHandle);
    internal static void SHChangeNotify(ChangeNotifyEventIds wEventId, ChangeNotifyFlags uFlags, IntPtr dwItem1, IntPtr dwItem2);
    internal static bool InternetGetConnectedState(Int32& lpdwFlags, int dwReserved);
    internal static SafePowerRequestHandle PowerCreateRequest(REASON_CONTEXT& Context);
    internal static bool GlobalMemoryStatusEx(MEMORYSTATUSEX lpBuffer);
    internal static bool PowerSetRequest(SafePowerRequestHandle PowerRequest, POWER_REQUEST_TYPE RequestType);
    internal static bool PowerClearRequest(SafePowerRequestHandle PowerRequest, POWER_REQUEST_TYPE RequestType);
    internal static int RmStartSession(Int32& pSessionHandle, int dwSessionFlags, StringBuilder strSessionKey);
    internal static int RmRegisterResources(int dwSessionHandle, int nFiles, String[] rgsFilenames, int nApplications, RM_UNIQUE_PROCESS[] rgApplications, int nServices, String[] rgsServiceNames);
    internal static int RmGetList(int dwSessionHandle, Int32& pnProcInfoNeeded, Int32& pnProcInfo, RM_PROCESS_INFO[] rgAffectedApps, Int32& lpdwRebootReasons);
    internal static int RmShutdown(int dwSessionHandle, WindowsRestartManagerShutdown lActionFlags, RM_WRITE_STATUS_CALLBACK fnStatus);
    internal static int RmRestart(int dwSessionHandle, int dwRestartFlags, RM_WRITE_STATUS_CALLBACK fnStatus);
    internal static int RmEndSession(int dwSessionHandle);
    internal static SafeProcessHandle OpenProcess(ProcessAccessFlags dwDesiredAccess, bool bInheritHandle, int dwProcessId);
    internal static bool QueryFullProcessImageName(SafeProcessHandle hProcess, ProcessNameFlags dwFlags, StringBuilder lpExeName, Int32& size);
    internal static int RegCreateKeyTransacted(SafeRegistryHandle hKey, string lpSubKey, int Reserved, string lpClass, RegistryOptions dwOptions, REGSAM samDesired, IntPtr lpSecurityAttributes, SafeRegistryHandle& phkResult, REG_DISPOSITION& lpdwDisposition, SafeTransactionHandle hTransaction, IntPtr pExtendedParameter);
    internal static int RegOpenKeyTransacted(SafeRegistryHandle hKey, string lpSubKey, RegistryOptions dwOptions, REGSAM samDesired, SafeRegistryHandle& phkResult, SafeTransactionHandle hTransaction, IntPtr pExtendedParameter);
    internal static bool LookupAccountSid(string lpSystemName, Byte[] sid, StringBuilder lpName, UInt32& cchName, StringBuilder referencedDomainName, UInt32& cchReferencedDomainName, SID_NAME_USE& peUse);
    internal static SafeFileHandle CreateFile(string lpFileName, FILE_ACCESS dwDesiredAccess, FILE_SHARE dwShareMode, IntPtr lpSecurityAttributes, FILE_DISPOSITION dwCreationDisposition, FILE_ATTRIBUTES dwFlagsAndAttributes, IntPtr hTemplateFile);
    internal static bool DeviceIoControl(SafeFileHandle hDevice, int dwIoControlCode, IntPtr lpInBuffer, int nInBufferSize, IntPtr lpOutBuffer, int nOutBufferSize, Int32& lpBytesReturned, IntPtr lpOverlapped);
    internal static bool DeviceIoControl(SafeFileHandle hDevice, int dwIoControlCode, STORAGE_PROPERTY_QUERY& lpInBuffer, int nInBufferSize, STORAGE_PROPERTY_BOOLEAN_DESCRIPTOR& lpOutBuffer, int nOutBufferSize, Int32& lpBytesReturned, IntPtr lpOverlapped);
    internal static int GetLogicalDrives();
    internal static DriveTypeNative GetDriveType(string lpRootPathName);
    [NullableContextAttribute("2")]
internal static int SizeOf(byte pack);
    internal static bool GetSystemPowerStatus(SYSTEM_POWER_STATUS& lpSystemPowerStatus);
    internal static bool InitiateSystemShutdownEx(string machineName, string message, UInt32 timeout, bool forceCloseApps, bool reboot, ShutdownReason reason);
    internal static bool LookupPrivilegeValue(string systemName, string privilegeName, LUID& luid);
    public static bool AdjustTokenPrivileges(IntPtr tokenHandle, bool disableAllPrivileges, TOKEN_PRIVILEGES& newState, UInt32 bufferLength, IntPtr previousState, IntPtr returnLength);
    internal static bool AttachConsole(int dwProcessId);
    internal static bool FreeConsole();
    internal static bool GetVersionExW(OSVERSIONINFOEX& osVersionInfo);
    internal static bool IsOS(int os);
}
public enum Microsoft.VisualStudio.Setup.Services.NetworkCostType : Enum {
    public int value__;
    public static NetworkCostType Unknown;
    public static NetworkCostType Unrestricted;
    public static NetworkCostType Fixed;
    public static NetworkCostType Variable;
    public static NetworkCostType Other;
}
internal class Microsoft.VisualStudio.Setup.Services.NgenService : object {
    private IServiceProvider serviceProvider;
    public NgenService(IServiceProvider serviceProvider);
    public sealed virtual bool ExecuteQueuedNgenTasks(IEnumerable`1<NgenArchitecture> architectures, CancellationToken token, int priority);
    public sealed virtual bool PauseNgenTasks(IEnumerable`1<NgenArchitecture> architectures, CancellationToken token);
    public sealed virtual bool UpdateQueueNgenTasks(IEnumerable`1<NgenArchitecture> architectures, CancellationToken token);
    public sealed virtual bool ContinueNgenTasks(IEnumerable`1<NgenArchitecture> architectures, CancellationToken token);
}
public class Microsoft.VisualStudio.Setup.Services.NotifyResumable : object {
    [CompilerGeneratedAttribute]
private EventHandler OperationResumable;
    [CompilerGeneratedAttribute]
public void add_OperationResumable(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_OperationResumable(EventHandler value);
    public sealed virtual void OnResumable();
}
public class Microsoft.VisualStudio.Setup.Services.NullStopSignal : object {
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs> StopRequested;
    [CompilerGeneratedAttribute]
public sealed virtual void add_StopRequested(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_StopRequested(EventHandler`1<EventArgs> value);
    public sealed virtual void Stop();
}
internal class Microsoft.VisualStudio.Setup.Services.NupkgLoggerAdapter : object {
    private ILogger logger;
    public NupkgLoggerAdapter(ILogger logger);
    public sealed virtual void Log(LogLevel level, string data);
    public sealed virtual void Log(ILogMessage message);
    public sealed virtual Task LogAsync(LogLevel level, string data);
    public sealed virtual Task LogAsync(ILogMessage message);
    public sealed virtual void LogDebug(string data);
    public sealed virtual void LogError(string data);
    public sealed virtual void LogInformation(string data);
    public sealed virtual void LogInformationSummary(string data);
    public sealed virtual void LogMinimal(string data);
    public sealed virtual void LogVerbose(string data);
    public sealed virtual void LogWarning(string data);
}
public class Microsoft.VisualStudio.Setup.Services.OperatingSystem : object {
    public static IOperatingSystem Default;
    private static string WindowsUpdateService;
    private IServiceProvider services;
    private ILogger logger;
    private Nullable`1<bool> inContainer;
    private IEnumerable`1<IDriveInfo> physicalDiskInfo;
    public Version Version { get; }
    public bool InContainer { get; }
    public bool Is64Bit { get; }
    public NetworkCostType ConnectionCost { get; }
    public CultureInfo CurrentUICulture { get; }
    public int ProcessorCount { get; }
    public OperatingSystem(IServiceProvider services);
    private static OperatingSystem();
    public sealed virtual Version get_Version();
    public sealed virtual void NotifyChange();
    public sealed virtual void SetUrlAssociationDefaults(IEnumerable`1<string> associations, string defaultApplication);
    public sealed virtual void StartUpdates();
    public sealed virtual void StopUpdates();
    public sealed virtual bool AreUpdatesOFF();
    public sealed virtual bool get_InContainer();
    public sealed virtual bool get_Is64Bit();
    public sealed virtual NetworkCostType get_ConnectionCost();
    public sealed virtual CultureInfo get_CurrentUICulture();
    public sealed virtual int get_ProcessorCount();
    public sealed virtual IDisposable SuspendSleep();
    public sealed virtual IEnumerable`1<IDriveInfo> GetPhysicalDiskInfo();
    public sealed virtual SystemPowerStatus GetSystemPowerStatus();
    private static NetworkCostType ConnectionCostPrivate();
    public sealed virtual string GetEnvironmentVariable(string key);
    public sealed virtual bool Restart(ShutdownReason reason);
    public sealed virtual bool IsRunningApplicationServerMode();
    public sealed virtual bool IsType(OperatingSystemType type);
    private bool GetShutdownPrivileges();
}
public enum Microsoft.VisualStudio.Setup.Services.OperatingSystemType : Enum {
    public int value__;
    public static OperatingSystemType OS_ANYSERVER;
}
internal class Microsoft.VisualStudio.Setup.Services.OSVERSIONINFOEX : ValueType {
    internal int DwOSVersionInfoSize;
    internal int DwMajorVersion;
    internal int DwMinorVersion;
    internal int DwBuildNumber;
    internal int DwPlatformId;
    [NullableAttribute("1")]
internal string SzCSDVersion;
    internal short WServicePackMajor;
    internal short WServicePackMinor;
    internal short WSuiteMask;
    internal byte WProductType;
    internal byte WReserved;
}
internal class Microsoft.VisualStudio.Setup.Services.PackageDetectionService : object {
    private IServiceProvider services;
    private IEngineContext context;
    private bool initialized;
    private ISettingsService settings;
    private ICacheManager cache;
    private IInstallerFactory factory;
    private RegistryInitializerEvaluator regEvaluator;
    private FileInitializerEvaluator fileEvaluator;
    public PackageDetectionService(IServiceProvider services, IEngineContext context);
    public sealed virtual bool IsInstalled(IPackage package);
    private void Initialize();
    private bool DoSoftDefection(IPackage package);
    private bool DoDeepDetection(InstallablePackage installablePackage, Nullable`1<bool> softDetectionHint);
}
public class Microsoft.VisualStudio.Setup.Services.PausableEventArgs : EventArgs {
}
internal class Microsoft.VisualStudio.Setup.Services.PendingRebootOperations : object {
    private HashSet`1<string> filesToDelete;
    public ISet`1<string> FilesToBeDeleted { get; }
    public sealed virtual ISet`1<string> get_FilesToBeDeleted();
    public sealed virtual void Clear();
}
public class Microsoft.VisualStudio.Setup.Services.PolicyService : object {
    internal static int MaxCachePathLength;
    internal static int MaxConcurrentDownloads;
    internal static string RegistryKeyPath;
    internal static string PolicyKeyPath;
    [CompilerGeneratedAttribute]
private static EventHandler`1<EventArgs> AllInvalidated;
    private static IDictionary`2<string, string> RegistryValueNameLookup;
    private IServiceProvider services;
    private IPolicyService defaults;
    private string cachePath;
    private EventHandler`1<EventArgs> invalidated;
    private IRegistry registry;
    private ILogger logger;
    private IOperatingSystem operatingSystem;
    [CompilerGeneratedAttribute]
private SetOnce`1<string> <SharedInstallationPath>k__BackingField;
    [CompilerGeneratedAttribute]
private SetOnce`1<string> <CompatibilityInstallationPath>k__BackingField;
    public string CachePath { get; public set; }
    public SetOnce`1<string> SharedInstallationPath { get; }
    public SetOnce`1<string> CompatibilityInstallationPath { get; }
    private IOperatingSystem OperatingSystem { get; }
    private IRegistry Registry { get; }
    private ICacheManager CacheManager { get; }
    private ILogger Logger { get; }
    public bool IsCachePathSettable { get; }
    private bool Microsoft.VisualStudio.Setup.Services.IPolicyService.IsSharedInstallPathSettable { get; }
    public bool KeepDownloadedPayloads { get; public set; }
    private string Microsoft.VisualStudio.Setup.Services.IPolicyService.SharedInstallationPath { get; }
    private string Microsoft.VisualStudio.Setup.Services.IWritablePolicyService.SharedInstallationPath { get; private set; }
    private string Microsoft.VisualStudio.Setup.Services.IPolicyService.CompatibilityInstallationPath { get; }
    public int ConcurrentDownloads { get; }
    public AutomaticUpdatesValue AdministratorUpdatesEnabled { get; }
    public bool AdministratorPromptToClose { get; }
    public bool AdministratorUpdatesOptOut { get; }
    public bool DiagnosticMode { get; }
    public bool ChannelUpdateDisabled { get; }
    public bool AutoUpdateDisabled { get; }
    public bool BackgroundDownloadDisabled { get; }
    public bool DisableMicrosoftChannelFeed { get; }
    public bool DisableRollback { get; }
    public bool HideAvailableTab { get; }
    public bool IgnoreChannelFeedProductRestriction { get; }
    public bool RemoveOos { get; }
    public bool DisableSound { get; }
    public string UpdateConfigurationFile { get; }
    public bool DisableBlockedOSCheck { get; }
    public ElevationServiceSupport ElevationServiceSupport { get; }
    public bool AdministratorUpdatesNotificationsEnabled { get; }
    public bool AdministratorUpdateOnCloseOptOut { get; }
    public bool VSthroughMUUpdatesOptOut { get; }
    public bool PreviewAutomaticUpdates { get; }
    public bool UpdateNotificationsOptOut { get; }
    public PolicyService(IServiceProvider services);
    private static PolicyService();
    [CompilerGeneratedAttribute]
private static void add_AllInvalidated(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
private static void remove_AllInvalidated(EventHandler`1<EventArgs> value);
    public sealed virtual string get_CachePath();
    public sealed virtual void set_CachePath(string value);
    [CompilerGeneratedAttribute]
public SetOnce`1<string> get_SharedInstallationPath();
    [CompilerGeneratedAttribute]
public SetOnce`1<string> get_CompatibilityInstallationPath();
    public static void Invalidate();
    public sealed virtual void add_Invalidated(EventHandler`1<EventArgs> value);
    public sealed virtual void remove_Invalidated(EventHandler`1<EventArgs> value);
    private void OnAllInvalidated(object sender, EventArgs args);
    private string GetCachePathPolicy();
    private IOperatingSystem get_OperatingSystem();
    private IRegistry get_Registry();
    private ICacheManager get_CacheManager();
    private ILogger get_Logger();
    private bool IsValueSet(string propertyName);
    private bool IsCachePathSafeToChange(string propertyName);
    private bool GroupPolicyIsSet(string propertyName);
    private Func`2<string, T> GetValueWithDefault(T defaultValue);
    private bool GetValue(string propertyName, T& value);
    private void SetValue(string propertyName, T value);
    public static void VerifyCustomPath(IServiceProvider services, string customPath, DrivePathType pathType);
    public static void CheckPathOverlap(string installationPath, string cachePath, string sharedPath, bool checkCacheSharedOverlap);
    private void TrySetCachePath(string propertyName, T value);
    private IRegistryKey CreateKey();
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.PolicyService/<OpenKeys>d__49")]
private IEnumerable`1<IRegistryKey> OpenKeys();
    private IRegistryKey GetPolicyKey();
    private sealed virtual override bool Microsoft.VisualStudio.Setup.Services.IPolicyService.IsPolicySet(string policyName);
    public sealed virtual bool get_IsCachePathSettable();
    private sealed virtual override bool Microsoft.VisualStudio.Setup.Services.IPolicyService.get_IsSharedInstallPathSettable();
    public sealed virtual bool get_KeepDownloadedPayloads();
    public sealed virtual void set_KeepDownloadedPayloads(bool value);
    private sealed virtual override string Microsoft.VisualStudio.Setup.Services.IPolicyService.get_SharedInstallationPath();
    private sealed virtual override string Microsoft.VisualStudio.Setup.Services.IWritablePolicyService.get_SharedInstallationPath();
    private sealed virtual override void Microsoft.VisualStudio.Setup.Services.IWritablePolicyService.set_SharedInstallationPath(string value);
    private sealed virtual override string Microsoft.VisualStudio.Setup.Services.IPolicyService.get_CompatibilityInstallationPath();
    public sealed virtual int get_ConcurrentDownloads();
    public sealed virtual AutomaticUpdatesValue get_AdministratorUpdatesEnabled();
    public sealed virtual bool get_AdministratorPromptToClose();
    public sealed virtual bool get_AdministratorUpdatesOptOut();
    public sealed virtual bool get_DiagnosticMode();
    public sealed virtual bool get_ChannelUpdateDisabled();
    public sealed virtual bool get_AutoUpdateDisabled();
    public sealed virtual bool get_BackgroundDownloadDisabled();
    public sealed virtual bool get_DisableMicrosoftChannelFeed();
    public sealed virtual bool get_DisableRollback();
    public sealed virtual bool get_HideAvailableTab();
    public sealed virtual bool get_IgnoreChannelFeedProductRestriction();
    public sealed virtual bool get_RemoveOos();
    public sealed virtual bool get_DisableSound();
    public sealed virtual string get_UpdateConfigurationFile();
    public sealed virtual bool get_DisableBlockedOSCheck();
    public sealed virtual ElevationServiceSupport get_ElevationServiceSupport();
    public sealed virtual bool get_AdministratorUpdatesNotificationsEnabled();
    public sealed virtual bool get_AdministratorUpdateOnCloseOptOut();
    public sealed virtual bool get_VSthroughMUUpdatesOptOut();
    public sealed virtual bool get_PreviewAutomaticUpdates();
    public sealed virtual bool get_UpdateNotificationsOptOut();
}
internal enum Microsoft.VisualStudio.Setup.Services.POWER_REQUEST_TYPE : Enum {
    public int value__;
    public static POWER_REQUEST_TYPE PowerRequestDisplayRequired;
    public static POWER_REQUEST_TYPE PowerRequestSystemRequired;
    public static POWER_REQUEST_TYPE PowerRequestAwayModeRequired;
    public static POWER_REQUEST_TYPE PowerRequestExecutionRequired;
}
internal class Microsoft.VisualStudio.Setup.Services.PowerRequest : object {
    private POWER_REQUEST_TYPE type;
    private ILogger logger;
    private SafePowerRequestHandle handle;
    private bool disposed;
    public PowerRequest(IServiceProvider services, POWER_REQUEST_TYPE type);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    private SafePowerRequestHandle CreatePowerRequest();
    private void Dispose(bool disposing);
}
[FlagsAttribute]
internal enum Microsoft.VisualStudio.Setup.Services.PowerRequestContextFlags : Enum {
    public int value__;
    public static PowerRequestContextFlags POWER_REQUEST_CONTEXT_SIMPLE_STRING;
}
internal enum Microsoft.VisualStudio.Setup.Services.PowerRequestContextVersion : Enum {
    public int value__;
    public static PowerRequestContextVersion POWER_REQUEST_CONTEXT_VERSION;
}
internal enum Microsoft.VisualStudio.Setup.Services.PrivilegeAttributes : Enum {
    public UInt32 value__;
    public static PrivilegeAttributes SE_PRIVILEGE_ENABLED;
    public static PrivilegeAttributes SE_PRIVILEGE_ENABLED_BY_DEFAULT;
    public static PrivilegeAttributes SE_PRIVILEGE_REMOVED;
    public static PrivilegeAttributes SE_PRIVILEGE_USED_FOR_ACCESS;
}
internal static class Microsoft.VisualStudio.Setup.Services.Privileges : object {
    [NullableAttribute("1")]
internal static string SE_SHUTDOWN_NAME;
    private static Privileges();
}
[FlagsAttribute]
internal enum Microsoft.VisualStudio.Setup.Services.ProcessAccessFlags : Enum {
    public int value__;
    public static ProcessAccessFlags PROCESS_QUERY_LIMITED_INFORMATION;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Services.ProcessInfo : object {
    private Lazy`1<string> lazyMainModuleFileName;
    private Lazy`1<UInt32> lazyExitCode;
    private Lazy`1<bool> lazyIsElevated;
    private Lazy`1<SecurityIdentifier> lazyUser;
    [CompilerGeneratedAttribute]
private int <ProcessId>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public int ProcessId { get; }
    public string MainModuleFileName { get; }
    public string Description { get; }
    public bool IsElevated { get; }
    public bool HasExited { get; }
    public int ExitCode { get; }
    public SecurityIdentifier User { get; }
    public ProcessInfo(int id);
    [CompilerGeneratedAttribute]
protected ProcessInfo(ProcessInfo original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public sealed virtual int get_ProcessId();
    public sealed virtual string get_MainModuleFileName();
    public sealed virtual string get_Description();
    public sealed virtual bool get_IsElevated();
    public sealed virtual bool get_HasExited();
    public sealed virtual int get_ExitCode();
    public sealed virtual SecurityIdentifier get_User();
    private string GetMainModuleFileName();
    private UInt32 GetExitCode();
    private bool GetIsElevated();
    private SecurityIdentifier GetUser();
    private SafeHandle OpenQueryProcessHandle();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(ProcessInfo left, ProcessInfo right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(ProcessInfo left, ProcessInfo right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(ProcessInfo other);
    [CompilerGeneratedAttribute]
public virtual ProcessInfo <Clone>$();
}
[FlagsAttribute]
internal enum Microsoft.VisualStudio.Setup.Services.ProcessNameFlags : Enum {
    public int value__;
    public static ProcessNameFlags PROCESS_NAME_NONE;
}
public class Microsoft.VisualStudio.Setup.Services.ProcessService : object {
    public static IProcessService Default;
    private static ProcessService();
    public sealed virtual IChildProcess CreateProcess();
    public sealed virtual IEnumerable`1<IProcess> GetAllProcessesFromFolders(IEnumerable`1<string> folders);
    public sealed virtual IProcess GetCurrentProcess();
    public sealed virtual IEnumerable`1<IProcess> GetProcesses();
    public sealed virtual IEnumerable`1<IProcess> GetProcessesByName(string name);
    public sealed virtual IProcess GetProcessById(int id);
    public sealed virtual bool IsElevated();
    public sealed virtual IProcessInfo GetProcessInfo(int id);
    public sealed virtual void RunAsLoggedOnUser(string filePath, string arguments);
    private IShellDispatch2 GetShellDispatchForLoggedInUser();
}
public class Microsoft.VisualStudio.Setup.Services.ProcessStartInfo : object {
    private ProcessStartInfo startInfo;
    private IDictionary`2<string, string> environmentVariables;
    public string Arguments { get; public set; }
    public bool CreateNoWindow { get; public set; }
    public bool RedirectStandardOutput { get; public set; }
    public bool RedirectStandardError { get; public set; }
    public bool UseShellExecute { get; public set; }
    public string FileName { get; public set; }
    public string WorkingDirectory { get; public set; }
    public string Verb { get; public set; }
    public ProcessWindowStyle WindowStyle { get; public set; }
    public IDictionary`2<string, string> EnvironmentVariables { get; }
    public ProcessStartInfo(ProcessStartInfo startInfo);
    public sealed virtual string get_Arguments();
    public sealed virtual void set_Arguments(string value);
    public sealed virtual bool get_CreateNoWindow();
    public sealed virtual void set_CreateNoWindow(bool value);
    public sealed virtual bool get_RedirectStandardOutput();
    public sealed virtual void set_RedirectStandardOutput(bool value);
    public sealed virtual bool get_RedirectStandardError();
    public sealed virtual void set_RedirectStandardError(bool value);
    public sealed virtual bool get_UseShellExecute();
    public sealed virtual void set_UseShellExecute(bool value);
    public sealed virtual string get_FileName();
    public sealed virtual void set_FileName(string value);
    public sealed virtual string get_WorkingDirectory();
    public sealed virtual void set_WorkingDirectory(string value);
    public sealed virtual string get_Verb();
    public sealed virtual void set_Verb(string value);
    public sealed virtual ProcessWindowStyle get_WindowStyle();
    public sealed virtual void set_WindowStyle(ProcessWindowStyle value);
    public sealed virtual IDictionary`2<string, string> get_EnvironmentVariables();
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <get_EnvironmentVariables>b__31_0();
}
internal class Microsoft.VisualStudio.Setup.Services.ProgressAggregator : ProgressAggregatorBase {
    private static int SpeedCalculationWindow;
    private static int MovingAverageCalculationWindow;
    private object syncRoot;
    private IDictionary`2<string, long> progressTable;
    private int completedPackageCount;
    private int totalPackageCount;
    private long totalPackageSize;
    private long completedSize;
    private DateTime downloadTime;
    private int reportTimes;
    private long byteRate;
    private long previousCompletedSizeForSpeedCalculation;
    private long completedSizeForSpeedCalculation;
    protected virtual void InitializeCore();
    protected virtual ProgressDataEventArgs GetAggregationResult(IPackageProgress packageProgress, ProgressDataEventArgs individualProgressData);
    internal static long CalculateMovingAverage(long currentByteRate, long previousByteRate, int reportTimes);
}
internal abstract class Microsoft.VisualStudio.Setup.Services.ProgressAggregatorBase : object {
    private IProgressReporter progressService;
    private Instance instance;
    [CompilerGeneratedAttribute]
private ISet`1<IPackageProgress> <PackageProgressCollection>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalSize>k__BackingField;
    [CompilerGeneratedAttribute]
private long <PreviousTotalSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PreviousTotalPackageCount>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    protected ISet`1<IPackageProgress> PackageProgressCollection { get; private set; }
    protected long TotalSize { get; protected set; }
    protected long PreviousTotalSize { get; protected set; }
    protected int PreviousTotalPackageCount { get; protected set; }
    internal bool IsDisposed { get; private set; }
    [CompilerGeneratedAttribute]
protected ISet`1<IPackageProgress> get_PackageProgressCollection();
    [CompilerGeneratedAttribute]
private void set_PackageProgressCollection(ISet`1<IPackageProgress> value);
    [CompilerGeneratedAttribute]
protected long get_TotalSize();
    [CompilerGeneratedAttribute]
protected void set_TotalSize(long value);
    [CompilerGeneratedAttribute]
protected long get_PreviousTotalSize();
    [CompilerGeneratedAttribute]
protected void set_PreviousTotalSize(long value);
    [CompilerGeneratedAttribute]
protected int get_PreviousTotalPackageCount();
    [CompilerGeneratedAttribute]
protected void set_PreviousTotalPackageCount(int value);
    internal void Initialize(IEnumerable`1<IPackageProgress> packageProgressCollection, IServiceProvider services, Instance instance, ProgressType type);
    protected virtual void InitializeCore();
    protected abstract virtual ProgressDataEventArgs GetAggregationResult(IPackageProgress packageProgress, ProgressDataEventArgs individualProgressData);
    protected void UpdateInstance(string packageId);
    private void PackageProgress_PackageProgressReceived(IPackageProgress sender, ProgressDataEventArgs e);
    [CompilerGeneratedAttribute]
internal bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
}
public class Microsoft.VisualStudio.Setup.Services.ProgressEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <Package>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Progress>k__BackingField;
    [CompilerGeneratedAttribute]
private ProgressType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private ProgressInfo <DetailedProgress>k__BackingField;
    public string Package { get; }
    public double Progress { get; }
    public ProgressType Type { get; }
    public ProgressInfo DetailedProgress { get; }
    public ProgressEventArgs(string package, double progress, ProgressType type);
    [JsonConstructorAttribute]
public ProgressEventArgs(string package, double progress, ProgressType type, ProgressInfo detailedProgress);
    [CompilerGeneratedAttribute]
public string get_Package();
    [CompilerGeneratedAttribute]
public double get_Progress();
    [CompilerGeneratedAttribute]
public ProgressType get_Type();
    [CompilerGeneratedAttribute]
public ProgressInfo get_DetailedProgress();
}
public class Microsoft.VisualStudio.Setup.Services.ProgressReporter : object {
    private static double DefaultProgressSendFrequency;
    private ProgressEventArgs downloadProgress;
    private ProgressEventArgs installProgress;
    private Timer timer;
    [CompilerGeneratedAttribute]
private EventHandler`1<ProgressEventArgs> OnReport;
    private bool disposed;
    public ProgressReporter(double progressSendFrequency);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnReport(EventHandler`1<ProgressEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnReport(EventHandler`1<ProgressEventArgs> value);
    public sealed virtual void Report(string package, double progress, ProgressType type, ProgressInfo detailedProgress);
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <.ctor>b__8_0(object sender, ElapsedEventArgs e);
}
internal class Microsoft.VisualStudio.Setup.Services.ProgressReporterAggregator : object {
    [NullableAttribute("1")]
private IEnumerable`1<IProgressReporter> reporters;
    private bool disposed;
    [NullableContextAttribute("1")]
public ProgressReporterAggregator(IEnumerable`1<IProgressReporter> progressReporters);
    [NullableContextAttribute("1")]
public sealed virtual void Report(string package, double progress, ProgressType type, ProgressInfo detailedProgress);
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Setup.Services.QueryFactory : object {
    private IServiceProvider services;
    public QueryFactory(IServiceProvider services);
    public sealed virtual IQuery Create();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Services.RateLimitedMessageBusProxy : object {
    private IMessageBus messageBus;
    [NullableAttribute("2")]
private ILogger logger;
    private TimeSpan rateLimit;
    private SemaphoreSlim messageSemaphore;
    private LastMessage lastMessage;
    public RateLimitedMessageBusProxy(TimeSpan rateLimit, IMessageBus messageBus, ILogger logger);
    public sealed virtual Task NotifyMessageAsync(Message message);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Services.RateLimitedMessageBusProxy/<SendMessageAsync>d__7")]
public sealed virtual Task`1<MessageResult> SendMessageAsync(Message message);
    private bool IsPastRateLimit();
}
internal class Microsoft.VisualStudio.Setup.Services.REASON_CONTEXT : ValueType {
    public PowerRequestContextVersion Version;
    public PowerRequestContextFlags Flags;
    [NullableAttribute("1")]
public string SimpleReasonString;
}
internal enum Microsoft.VisualStudio.Setup.Services.REG_DISPOSITION : Enum {
    public int value__;
    public static REG_DISPOSITION REG_CREATED_NEW_KEY;
    public static REG_DISPOSITION REG_OPENED_EXISTING_KEY;
}
[FlagsAttribute]
internal enum Microsoft.VisualStudio.Setup.Services.REGSAM : Enum {
    public int value__;
    public static REGSAM KEY_QUERY_VALUE;
    public static REGSAM KEY_SET_VALUE;
    public static REGSAM KEY_CREATE_SUB_KEY;
    public static REGSAM KEY_ENUMERATE_SUB_KEYS;
    public static REGSAM KEY_NOTIFY;
    public static REGSAM KEY_WRITE;
    public static REGSAM KEY_READ;
    public static REGSAM KEY_WOW64_32KEY;
    public static REGSAM KEY_WOW64_64KEY;
}
public class Microsoft.VisualStudio.Setup.Services.RemoteSettingsService : object {
    private IRemoteSettings remoteSettings;
    private static RemoteSettingsService();
    public RemoteSettingsService(string remoteSettingsFileName);
    public RemoteSettingsService(RemoteSettingsInitializer initializer);
    public sealed virtual T GetValue(string collectionPath, string key, T defaultValue);
    public sealed virtual Task`1<T> GetValueAsync(string collectionPath, string key, T defaultValue, CancellationToken cancellationToken);
    public sealed virtual Task`1<IEnumerable`1<TargetedNotificationsAction`1<T>>> GetActionsAsync(string actionPath, CancellationToken cancellationToken);
}
public static class Microsoft.VisualStudio.Setup.Services.RemoteSettingsServiceFactory : object {
    [NullableContextAttribute("1")]
public static RemoteSettingsService Create(TelemetrySession telemetrySession, IExperimentationService experimentationService, string exeName, string exeVersion);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Setup.Services.ReparseAwareFileSystem : object {
    public static IReparseAwareFileSystem Default;
    private IFileSystem nonReparseAwareFileSystem;
    [NullableContextAttribute("2")]
public ReparseAwareFileSystem(IServiceProvider services, IFileSystem nonReparseAwareFileSystem);
    private static ReparseAwareFileSystem();
    public sealed virtual void CreateDirectory(string path, DirectorySecurity accessControl);
    public sealed virtual string ResolveDirectory(string path);
    public sealed virtual bool DirectoryHasReparsePoint(string path);
    private void SetDirectoryPermissions(SafeHandle safeHandle, DirectorySecurity accessControl);
    private void SetDaclAndGroup(HANDLE handle, RawSecurityDescriptor securityDescriptor);
    private void TrySetOwner(HANDLE handle, RawSecurityDescriptor securityDescriptor);
    private void SetSaclIfPresent(HANDLE handle, RawSecurityDescriptor securityDescriptor);
}
internal class Microsoft.VisualStudio.Setup.Services.ResolverFactory : object {
    internal static ResolverFactory Default;
    private IDictionary`2<Type, Func`2<IServiceProvider, object>> resolvers;
    private IServiceProvider services;
    private IMsiZapResolver cachedMsiZapResolver;
    private ILockedFileResolver cachedLockedFileResolver;
    internal ResolverFactory(IServiceProvider services);
    private static ResolverFactory();
    public sealed virtual T GetResolver(IServiceProvider services);
    [CompilerGeneratedAttribute]
private object <.ctor>b__5_0(IServiceProvider s);
    [CompilerGeneratedAttribute]
private object <.ctor>b__5_1(IServiceProvider s);
}
public class Microsoft.VisualStudio.Setup.Services.RestartManager : object {
    private static string WURestartRequiredKey;
    private static string CBSRestartRequiredKey;
    private static string PendingFileRenameOperationsKey;
    private static string PendingFileRenameOperationsValue;
    private static string PendingFileRenameValuePrefix;
    private static string HardRebootRegistryKeyName;
    private static string HardRebootRegistryKeyPath;
    private static string SoftRebootRegistryKeyName;
    private static string SoftRebootRegistryKeyPath;
    private IServiceProvider services;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs> RebootRequired;
    [CompilerGeneratedAttribute]
private RebootType <RebootRequiredType>k__BackingField;
    public RebootType RebootRequiredType { get; public set; }
    private static RestartManager();
    public RestartManager(IServiceProvider services);
    [CompilerGeneratedAttribute]
public sealed virtual void add_RebootRequired(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_RebootRequired(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual RebootType get_RebootRequiredType();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RebootRequiredType(RebootType value);
    public sealed virtual bool CheckSystemPendingReboot(string installDir);
    public sealed virtual void CreateRebootRequiredSemaphore(IInstance instance);
    public sealed virtual void CreateRebootRecommendedSemaphore(IInstance instance);
    private void CreateSemaphore(IInstance instance, string regKeyName);
    public sealed virtual bool RebootRequiredSemaphoreExists(IInstance instance);
    public sealed virtual bool RebootRecommendedSemaphoreExists(IInstance instance);
    private bool CheckSemaphoreValue(IInstance instance, string regKeyPath);
    private bool RebootSemaphoresExist(string installDir);
    private bool CheckRegistryKey(IRegistry registry, string registryKey);
    private void OnRebootRequired();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Services.RM_PROCESS_INFO : ValueType {
    internal RM_UNIQUE_PROCESS Process;
    internal string strAppName;
    internal string strServiceShortName;
    internal ApplicationType ApplicationType;
    internal ApplicationStatus AppStatus;
    internal int TSSessionId;
    internal bool bRestartable;
}
internal class Microsoft.VisualStudio.Setup.Services.RM_UNIQUE_PROCESS : ValueType {
    public int dwProcessId;
    public FILETIME ProcessStartTime;
}
internal class Microsoft.VisualStudio.Setup.Services.RM_WRITE_STATUS_CALLBACK : MulticastDelegate {
    public RM_WRITE_STATUS_CALLBACK(object object, IntPtr method);
    public virtual void Invoke(int nPercentComplete);
    public virtual IAsyncResult BeginInvoke(int nPercentComplete, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.VisualStudio.Setup.Services.SafePowerRequestHandle : SafeHandleMinusOneIsInvalid {
    [ReliabilityContractAttribute("3", "1")]
protected virtual bool ReleaseHandle();
}
internal class Microsoft.VisualStudio.Setup.Services.SafeProcessHandle : SafeHandleZeroOrMinusOneIsInvalid {
    [ReliabilityContractAttribute("3", "1")]
protected virtual bool ReleaseHandle();
}
[SecurityCriticalAttribute]
internal class Microsoft.VisualStudio.Setup.Services.SafeTransactionHandle : SafeHandleZeroOrMinusOneIsInvalid {
    [SecurityCriticalAttribute]
protected virtual bool ReleaseHandle();
}
public interface Microsoft.VisualStudio.Setup.Services.ScheduledTask.ITaskAction {
    public string Id { get; public set; }
    public TaskActionType Type { get; }
    public abstract virtual string get_Id();
    public abstract virtual void set_Id(string value);
    public abstract virtual TaskActionType get_Type();
}
public interface Microsoft.VisualStudio.Setup.Services.ScheduledTask.ITaskTrigger {
    public string Id { get; public set; }
    public TaskTriggerType Type { get; }
    public string StartBoundary { get; public set; }
    public abstract virtual string get_Id();
    public abstract virtual void set_Id(string value);
    public abstract virtual TaskTriggerType get_Type();
    public abstract virtual string get_StartBoundary();
    public abstract virtual void set_StartBoundary(string value);
}
public static class Microsoft.VisualStudio.Setup.Services.ScheduledTask.ScheduledTaskUtilities : object {
    public static Byte[] SystemSid;
    private static ScheduledTaskUtilities();
    public static string GetAccountName(Byte[] sid);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.VisualStudio.Setup.Services.ScheduledTask.SchedulerBase : object {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <ActionPath>k__BackingField;
    [CompilerGeneratedAttribute]
private IServiceProvider <Services>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskScheduler <Scheduler>k__BackingField;
    [NullableAttribute("2")]
protected string ActionPath { get; protected set; }
    protected IServiceProvider Services { get; }
    [NullableAttribute("2")]
protected ILogger Logger { get; }
    protected ITaskScheduler Scheduler { get; }
    internal SchedulerBase(IServiceProvider services);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected virtual string get_ActionPath();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected virtual void set_ActionPath(string value);
    [CompilerGeneratedAttribute]
protected IServiceProvider get_Services();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected ILogger get_Logger();
    [CompilerGeneratedAttribute]
protected ITaskScheduler get_Scheduler();
    internal virtual bool ShouldRun();
}
public enum Microsoft.VisualStudio.Setup.Services.ScheduledTask.TaskActionType : Enum {
    public int value__;
    public static TaskActionType TASK_ACTION_EXEC;
    public static TaskActionType TASK_ACTION_COM_HANDLER;
    public static TaskActionType TASK_ACTION_SEND_EMAIL;
    public static TaskActionType TASK_ACTION_SHOW_MESSAGE;
}
public class Microsoft.VisualStudio.Setup.Services.ScheduledTask.TaskBootTrigger : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StartBoundary>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <RepeatIntervalInMinutes>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <DelayInMinutes>k__BackingField;
    public string Id { get; public set; }
    public TaskTriggerType Type { get; }
    public string StartBoundary { get; public set; }
    public Nullable`1<int> RepeatIntervalInMinutes { get; public set; }
    public Nullable`1<int> DelayInMinutes { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Id(string value);
    public sealed virtual TaskTriggerType get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual string get_StartBoundary();
    [CompilerGeneratedAttribute]
public sealed virtual void set_StartBoundary(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_RepeatIntervalInMinutes();
    [CompilerGeneratedAttribute]
public void set_RepeatIntervalInMinutes(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_DelayInMinutes();
    [CompilerGeneratedAttribute]
public void set_DelayInMinutes(Nullable`1<int> value);
}
public class Microsoft.VisualStudio.Setup.Services.ScheduledTask.TaskDailyTrigger : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StartBoundary>k__BackingField;
    [CompilerGeneratedAttribute]
private short <DaysInterval>k__BackingField;
    public string Id { get; public set; }
    public TaskTriggerType Type { get; }
    public string StartBoundary { get; public set; }
    public short DaysInterval { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Id(string value);
    public sealed virtual TaskTriggerType get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual string get_StartBoundary();
    [CompilerGeneratedAttribute]
public sealed virtual void set_StartBoundary(string value);
    [CompilerGeneratedAttribute]
public short get_DaysInterval();
    [CompilerGeneratedAttribute]
public void set_DaysInterval(short value);
}
internal class Microsoft.VisualStudio.Setup.Services.ScheduledTask.TaskDefinition : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Directory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserAccount>k__BackingField;
    [CompilerGeneratedAttribute]
private TaskLogonType <LogonType>k__BackingField;
    [CompilerGeneratedAttribute]
private TaskRegistrationInfo <RegistrationInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private TaskPrincipal <Principal>k__BackingField;
    [CompilerGeneratedAttribute]
private TaskSettings <Settings>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<ITaskAction> <Actions>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<ITaskTrigger> <Triggers>k__BackingField;
    public string Name { get; public set; }
    public string Directory { get; public set; }
    public string UserAccount { get; public set; }
    public TaskLogonType LogonType { get; public set; }
    public TaskRegistrationInfo RegistrationInfo { get; public set; }
    public TaskPrincipal Principal { get; public set; }
    public TaskSettings Settings { get; public set; }
    public ICollection`1<ITaskAction> Actions { get; }
    public ICollection`1<ITaskTrigger> Triggers { get; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Directory();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Directory(string value);
    [CompilerGeneratedAttribute]
public string get_UserAccount();
    [CompilerGeneratedAttribute]
public void set_UserAccount(string value);
    [CompilerGeneratedAttribute]
public TaskLogonType get_LogonType();
    [CompilerGeneratedAttribute]
public void set_LogonType(TaskLogonType value);
    [CompilerGeneratedAttribute]
public sealed virtual TaskRegistrationInfo get_RegistrationInfo();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RegistrationInfo(TaskRegistrationInfo value);
    [CompilerGeneratedAttribute]
public TaskPrincipal get_Principal();
    [CompilerGeneratedAttribute]
public void set_Principal(TaskPrincipal value);
    [CompilerGeneratedAttribute]
public TaskSettings get_Settings();
    [CompilerGeneratedAttribute]
public void set_Settings(TaskSettings value);
    [CompilerGeneratedAttribute]
public ICollection`1<ITaskAction> get_Actions();
    [CompilerGeneratedAttribute]
public ICollection`1<ITaskTrigger> get_Triggers();
}
public class Microsoft.VisualStudio.Setup.Services.ScheduledTask.TaskExecAction : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WorkingDirectory>k__BackingField;
    public string Id { get; public set; }
    public TaskActionType Type { get; }
    public string Path { get; public set; }
    public string Arguments { get; public set; }
    public string WorkingDirectory { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Id(string value);
    public sealed virtual TaskActionType get_Type();
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public string get_Arguments();
    [CompilerGeneratedAttribute]
public void set_Arguments(string value);
    [CompilerGeneratedAttribute]
public string get_WorkingDirectory();
    [CompilerGeneratedAttribute]
public void set_WorkingDirectory(string value);
}
public class Microsoft.VisualStudio.Setup.Services.ScheduledTask.TaskIdleSettings : object {
    [CompilerGeneratedAttribute]
private string <IdleDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StopOnIdleEnd>k__BackingField;
    public string IdleDuration { get; public set; }
    public bool StopOnIdleEnd { get; public set; }
    [CompilerGeneratedAttribute]
public string get_IdleDuration();
    [CompilerGeneratedAttribute]
public void set_IdleDuration(string value);
    [CompilerGeneratedAttribute]
public bool get_StopOnIdleEnd();
    [CompilerGeneratedAttribute]
public void set_StopOnIdleEnd(bool value);
}
public class Microsoft.VisualStudio.Setup.Services.ScheduledTask.TaskIdleTrigger : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StartBoundary>k__BackingField;
    public string Id { get; public set; }
    public TaskTriggerType Type { get; }
    public string StartBoundary { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Id(string value);
    public sealed virtual TaskTriggerType get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual string get_StartBoundary();
    [CompilerGeneratedAttribute]
public sealed virtual void set_StartBoundary(string value);
}
public class Microsoft.VisualStudio.Setup.Services.ScheduledTask.TaskLogonTrigger : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StartBoundary>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Delay>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserId>k__BackingField;
    public string Id { get; public set; }
    public TaskTriggerType Type { get; }
    public string StartBoundary { get; public set; }
    public string Delay { get; public set; }
    public string UserId { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Id(string value);
    public sealed virtual TaskTriggerType get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual string get_StartBoundary();
    [CompilerGeneratedAttribute]
public sealed virtual void set_StartBoundary(string value);
    [CompilerGeneratedAttribute]
public string get_Delay();
    [CompilerGeneratedAttribute]
public void set_Delay(string value);
    [CompilerGeneratedAttribute]
public string get_UserId();
    [CompilerGeneratedAttribute]
public void set_UserId(string value);
}
public enum Microsoft.VisualStudio.Setup.Services.ScheduledTask.TaskLogonType : Enum {
    public int value__;
    public static TaskLogonType TASK_LOGON_NONE;
    public static TaskLogonType TASK_LOGON_PASSWORD;
    public static TaskLogonType TASK_LOGON_S4U;
    public static TaskLogonType TASK_LOGON_INTERACTIVE_TOKEN;
    public static TaskLogonType TASK_LOGON_GROUP;
    public static TaskLogonType TASK_LOGON_SERVICE_ACCOUNT;
    public static TaskLogonType TASK_LOGON_INTERACTIVE_TOKEN_OR_PASSWORD;
}
public class Microsoft.VisualStudio.Setup.Services.ScheduledTask.TaskMonthlyTrigger : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StartBoundary>k__BackingField;
    [CompilerGeneratedAttribute]
private short <DaysOfMonth>k__BackingField;
    [CompilerGeneratedAttribute]
private short <MonthsOfYear>k__BackingField;
    public string Id { get; public set; }
    public TaskTriggerType Type { get; }
    public string StartBoundary { get; public set; }
    public short DaysOfMonth { get; public set; }
    public short MonthsOfYear { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Id(string value);
    public sealed virtual TaskTriggerType get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual string get_StartBoundary();
    [CompilerGeneratedAttribute]
public sealed virtual void set_StartBoundary(string value);
    [CompilerGeneratedAttribute]
public short get_DaysOfMonth();
    [CompilerGeneratedAttribute]
public void set_DaysOfMonth(short value);
    [CompilerGeneratedAttribute]
public short get_MonthsOfYear();
    [CompilerGeneratedAttribute]
public void set_MonthsOfYear(short value);
}
public class Microsoft.VisualStudio.Setup.Services.ScheduledTask.TaskPrincipal : object {
    [CompilerGeneratedAttribute]
private TaskRunLevel <RunLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserId>k__BackingField;
    [CompilerGeneratedAttribute]
private TaskLogonType <LogonType>k__BackingField;
    public TaskRunLevel RunLevel { get; public set; }
    public string UserId { get; public set; }
    public TaskLogonType LogonType { get; public set; }
    [CompilerGeneratedAttribute]
public TaskRunLevel get_RunLevel();
    [CompilerGeneratedAttribute]
public void set_RunLevel(TaskRunLevel value);
    [CompilerGeneratedAttribute]
public string get_UserId();
    [CompilerGeneratedAttribute]
public void set_UserId(string value);
    [CompilerGeneratedAttribute]
public TaskLogonType get_LogonType();
    [CompilerGeneratedAttribute]
public void set_LogonType(TaskLogonType value);
}
public class Microsoft.VisualStudio.Setup.Services.ScheduledTask.TaskRegistrationInfo : object {
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Author>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Date>k__BackingField;
    public string Description { get; public set; }
    public string Author { get; public set; }
    public string Date { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public string get_Author();
    [CompilerGeneratedAttribute]
public void set_Author(string value);
    [CompilerGeneratedAttribute]
public string get_Date();
    [CompilerGeneratedAttribute]
public void set_Date(string value);
}
public enum Microsoft.VisualStudio.Setup.Services.ScheduledTask.TaskRunLevel : Enum {
    public int value__;
    public static TaskRunLevel TASK_RUNLEVEL_LUA;
    public static TaskRunLevel TASK_RUNLEVEL_HIGHEST;
}
public class Microsoft.VisualStudio.Setup.Services.ScheduledTask.TaskSettings : object {
    [CompilerGeneratedAttribute]
private string <ExecutionTimeLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private TaskIdleSettings <IdleSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RunOnlyIfIdle>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RunOnlyIfNetworkAvailable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisallowStartIfOnBatteries>k__BackingField;
    public string ExecutionTimeLimit { get; public set; }
    public TaskIdleSettings IdleSettings { get; public set; }
    public bool RunOnlyIfIdle { get; public set; }
    public bool RunOnlyIfNetworkAvailable { get; public set; }
    public bool DisallowStartIfOnBatteries { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ExecutionTimeLimit();
    [CompilerGeneratedAttribute]
public void set_ExecutionTimeLimit(string value);
    [CompilerGeneratedAttribute]
public TaskIdleSettings get_IdleSettings();
    [CompilerGeneratedAttribute]
public void set_IdleSettings(TaskIdleSettings value);
    [CompilerGeneratedAttribute]
public bool get_RunOnlyIfIdle();
    [CompilerGeneratedAttribute]
public void set_RunOnlyIfIdle(bool value);
    [CompilerGeneratedAttribute]
public bool get_RunOnlyIfNetworkAvailable();
    [CompilerGeneratedAttribute]
public void set_RunOnlyIfNetworkAvailable(bool value);
    [CompilerGeneratedAttribute]
public bool get_DisallowStartIfOnBatteries();
    [CompilerGeneratedAttribute]
public void set_DisallowStartIfOnBatteries(bool value);
}
public class Microsoft.VisualStudio.Setup.Services.ScheduledTask.TaskTimeTrigger : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StartBoundary>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <RepeatIntervalInMinutes>k__BackingField;
    public string Id { get; public set; }
    public TaskTriggerType Type { get; }
    public string StartBoundary { get; public set; }
    public Nullable`1<int> RepeatIntervalInMinutes { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Id(string value);
    public sealed virtual TaskTriggerType get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual string get_StartBoundary();
    [CompilerGeneratedAttribute]
public sealed virtual void set_StartBoundary(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_RepeatIntervalInMinutes();
    [CompilerGeneratedAttribute]
public void set_RepeatIntervalInMinutes(Nullable`1<int> value);
}
public enum Microsoft.VisualStudio.Setup.Services.ScheduledTask.TaskTriggerType : Enum {
    public int value__;
    public static TaskTriggerType TASK_TRIGGER_EVENT;
    public static TaskTriggerType TASK_TRIGGER_TIME;
    public static TaskTriggerType TASK_TRIGGER_DAILY;
    public static TaskTriggerType TASK_TRIGGER_WEEKLY;
    public static TaskTriggerType TASK_TRIGGER_MONTHLY;
    public static TaskTriggerType TASK_TRIGGER_MONTHLYDOW;
    public static TaskTriggerType TASK_TRIGGER_IDLE;
    public static TaskTriggerType TASK_TRIGGER_REGISTRATION;
    public static TaskTriggerType TASK_TRIGGER_BOOT;
    public static TaskTriggerType TASK_TRIGGER_LOGON;
    public static TaskTriggerType TASK_TRIGGER_SESSION_STATE_CHANGE;
    public static TaskTriggerType TASK_TRIGGER_CUSTOM_TRIGGER_01;
}
public class Microsoft.VisualStudio.Setup.Services.ScheduledTask.TaskWeeklyTrigger : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StartBoundary>k__BackingField;
    [CompilerGeneratedAttribute]
private short <DaysOfWeek>k__BackingField;
    [CompilerGeneratedAttribute]
private short <WeeksInterval>k__BackingField;
    public string Id { get; public set; }
    public TaskTriggerType Type { get; }
    public string StartBoundary { get; public set; }
    public short DaysOfWeek { get; public set; }
    public short WeeksInterval { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Id(string value);
    public sealed virtual TaskTriggerType get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual string get_StartBoundary();
    [CompilerGeneratedAttribute]
public sealed virtual void set_StartBoundary(string value);
    [CompilerGeneratedAttribute]
public short get_DaysOfWeek();
    [CompilerGeneratedAttribute]
public void set_DaysOfWeek(short value);
    [CompilerGeneratedAttribute]
public short get_WeeksInterval();
    [CompilerGeneratedAttribute]
public void set_WeeksInterval(short value);
}
public class Microsoft.VisualStudio.Setup.Services.ScheduledTask.WindowsTaskScheduler : object {
    private static int ERROR_ALREADYEXISTS;
    private static object SyncRoot;
    public static string VisualStudioScheduledTaskPath;
    public static string Author;
    public static string TaskName;
    private string rootDir;
    private string defaultExecutionTimeLimit;
    private string defaultIdleDuration;
    private IServiceProvider services;
    private ILogger logger;
    private TaskScheduler taskScheduler;
    public WindowsTaskScheduler(IServiceProvider services);
    internal WindowsTaskScheduler(IServiceProvider services, TaskScheduler taskScheduler);
    private static WindowsTaskScheduler();
    public sealed virtual void Create(IScheduledTaskDefinition definition, bool excludeUpdate);
    public sealed virtual void Remove(IScheduledTaskDefinition definition);
    public sealed virtual void RemoveAll();
    public sealed virtual bool TryGetTaskDetails(string name, string directory, IScheduledTaskDetails& taskDetails);
    public sealed virtual void RegisterTask(string name, string directory, string taskXmlContent, string userAccount, TaskLogonType logonType);
    private bool TryGetTask(TaskScheduler scheduler, string name, string directory, IRegisteredTask& task);
    private void CleanupFolderRecursively(ITaskFolder folder);
    internal void SetSettings(TaskDefinition inputDefinition, ITaskDefinition taskDefinition);
    internal void SetAction(ITaskAction action, ITaskDefinition taskDefinition);
    internal void SetTrigger(ITaskTrigger trigger, ITaskDefinition taskDefinition);
    internal ITaskFolder GetFolder(string directory);
    private void Initialize();
}
internal class Microsoft.VisualStudio.Setup.Services.ServiceController : object {
    private ServiceController serviceController;
    [CompilerGeneratedAttribute]
private string <ServiceName>k__BackingField;
    public string DisplayName { get; }
    public bool Exists { get; }
    public string ServiceName { get; }
    public bool CanStop { get; }
    public ServiceControllerStatus Status { get; }
    internal ServiceController(string serviceName);
    public sealed virtual string get_DisplayName();
    public sealed virtual bool get_Exists();
    public sealed virtual void Stop();
    public sealed virtual void Start();
    public sealed virtual void WaitForStatus(ServiceControllerStatus status, TimeSpan timeout);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ServiceName();
    public sealed virtual bool get_CanStop();
    public sealed virtual ServiceControllerStatus get_Status();
    public sealed virtual void Dispose();
    private bool DoesServiceExist();
    [CompilerGeneratedAttribute]
private bool <DoesServiceExist>b__17_0(ServiceController x);
}
internal class Microsoft.VisualStudio.Setup.Services.ServiceControllerFactory : object {
    [NullableAttribute("1")]
internal static IServiceControllerFactory Default;
    private static ServiceControllerFactory();
    [NullableContextAttribute("1")]
public sealed virtual IServiceController Create(string serviceName);
}
public class Microsoft.VisualStudio.Setup.Services.ServiceProvider : object {
    private IServiceProvider aggregated;
    private bool disposeAggregated;
    private ConcurrentDictionary`2<Type, ServiceRegistration> services;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    public bool IsDisposed { get; private set; }
    public ServiceProvider(IServiceProvider aggregate);
    public ServiceProvider(IServiceProvider aggregate, bool dispose);
    protected virtual override void Finalize();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    public sealed virtual void AddService(T service, bool throwIfExists, bool keepAlive);
    public sealed virtual void AddService(T& object, Func`1<T> getter);
    public sealed virtual void AddService(T& object, bool keepAlive, Func`1<T> getter);
    public sealed virtual void Dispose();
    public sealed virtual object GetService(Type serviceType);
    private void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Services.ServiceRegistrationService : object {
    private ISecurityAccessRightsService accessRightsService;
    public ServiceRegistrationService(ISecurityAccessRightsService accessRightsService);
    public sealed virtual void InstallService(string servicePath, string serviceName, string serviceDisplayName, string description, bool autoStart, bool canAllUsersChangeState);
    public sealed virtual void UpdateService(string servicePath, string serviceName, string serviceDisplayName);
    public sealed virtual void UninstallService(string serviceName);
    private void SetServiceAclsForAllUsers(HANDLE serviceHandle);
    private SC_HANDLE OpenServiceControlManager();
    private void CloseHandle(SC_HANDLE handle);
    private void ThrowOnFailure(WIN32_ERROR error);
    private void ThrowOnFailure(BOOL succeeded);
}
public class Microsoft.VisualStudio.Setup.Services.SetIfAllowed`1 : object {
    private static object SyncRoot;
    private string name;
    private Func`2<string, bool> isValueSettable;
    private Func`2<string, T> getValue;
    private Action`2<string, T> setValue;
    public bool IsSettable { get; }
    public T Value { get; }
    public SetIfAllowed`1(string name, Func`2<string, bool> isValueSettable, Func`2<string, T> getValue, Action`2<string, T> setValue);
    private static SetIfAllowed`1();
    public bool get_IsSettable();
    public bool TrySet(T value);
    public T get_Value();
}
public class Microsoft.VisualStudio.Setup.Services.SetOnce`1 : object {
    private string name;
    private Func`2<string, bool> isValueSet;
    private Func`2<string, T> getValue;
    private Action`2<string, T> setValue;
    public bool IsSet { get; }
    public T Value { get; }
    public SetOnce`1(string name, Func`2<string, bool> isValueSet, Func`2<string, T> getValue, Action`2<string, T> setValue);
    public bool get_IsSet();
    public bool TrySet(T value);
    public T get_Value();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.VisualStudio.Setup.Services.SettingFileRepositoryBase`1 : object {
    private IFileSystem fileSystem;
    [NullableAttribute("2")]
private ITelemetry telemetry;
    private ISerializer`1<T> serializer;
    private string filePath;
    private CancellationTokenSource cancellationTokenSource;
    private Task initializeTask;
    [NullableAttribute("2")]
private T settings;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    protected bool IsEmpty { get; }
    [NullableAttribute("2")]
protected ILogger Logger { get; }
    internal bool IsDisposed { get; private set; }
    protected T Settings { get; }
    protected SettingFileRepositoryBase`1(IFileSystem fileSystem, ILogger logger, ITelemetry telemetry, ISerializer`1<T> serializer, string filePath);
    protected abstract virtual bool get_IsEmpty();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected ILogger get_Logger();
    protected void SetSetting(TValue currentValue, TValue newValue, Action`1<TValue> setter, IEqualityComparer`1<TValue> comparer);
    [CompilerGeneratedAttribute]
internal bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    protected T get_Settings();
    protected void WriteSettings();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private T InitializeSettings();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private T <.ctor>b__7_0();
}
public class Microsoft.VisualStudio.Setup.Services.SettingsService : object {
    public static ISettingsService Default;
    [CompilerGeneratedAttribute]
private bool <DeepDetectionEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoWeb>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Force>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UpdateFromVS>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ClientProcessId>k__BackingField;
    public bool DeepDetectionEnabled { get; public set; }
    public bool NoWeb { get; public set; }
    public bool Force { get; public set; }
    public bool UpdateFromVS { get; public set; }
    public Nullable`1<int> ClientProcessId { get; public set; }
    private static SettingsService();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_DeepDetectionEnabled();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DeepDetectionEnabled(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_NoWeb();
    [CompilerGeneratedAttribute]
public sealed virtual void set_NoWeb(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Force();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Force(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_UpdateFromVS();
    [CompilerGeneratedAttribute]
public sealed virtual void set_UpdateFromVS(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<int> get_ClientProcessId();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ClientProcessId(Nullable`1<int> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Services.ShortcutService : object {
    [NullableAttribute("2")]
private IServiceProvider services;
    private IShortcutFactory shortcutFactory;
    public ShortcutService(IServiceProvider services, IShortcutFactory shortcutFactory);
    public sealed virtual bool CreateShortcuts(IEnumerable`1<Shortcut> shortcuts, IDictionary`2<string, string> variables);
    public sealed virtual bool DeleteShortcuts(IEnumerable`1<ShortcutInformation> shortcuts, IDictionary`2<string, string> variables);
}
public enum Microsoft.VisualStudio.Setup.Services.ShutdownReason : Enum {
    public UInt32 value__;
    public static ShutdownReason SHTDN_REASON_MAJOR_APPLICATION;
    public static ShutdownReason SHTDN_REASON_MAJOR_HARDWARE;
    public static ShutdownReason SHTDN_REASON_MAJOR_LEGACY_API;
    public static ShutdownReason SHTDN_REASON_MAJOR_OPERATINGSYSTEM;
    public static ShutdownReason SHTDN_REASON_MAJOR_OTHER;
    public static ShutdownReason SHTDN_REASON_MAJOR_POWER;
    public static ShutdownReason SHTDN_REASON_MAJOR_SOFTWARE;
    public static ShutdownReason SHTDN_REASON_MAJOR_SYSTEM;
    public static ShutdownReason SHTDN_REASON_MINOR_BLUESCREEN;
    public static ShutdownReason SHTDN_REASON_MINOR_CORDUNPLUGGED;
    public static ShutdownReason SHTDN_REASON_MINOR_DISK;
    public static ShutdownReason SHTDN_REASON_MINOR_ENVIRONMENT;
    public static ShutdownReason SHTDN_REASON_MINOR_HARDWARE_DRIVER;
    public static ShutdownReason SHTDN_REASON_MINOR_HOTFIX;
    public static ShutdownReason SHTDN_REASON_MINOR_HOTFIX_UNINSTALL;
    public static ShutdownReason SHTDN_REASON_MINOR_HUNG;
    public static ShutdownReason SHTDN_REASON_MINOR_INSTALLATION;
    public static ShutdownReason SHTDN_REASON_MINOR_MAINTENANCE;
    public static ShutdownReason SHTDN_REASON_MINOR_MMC;
    public static ShutdownReason SHTDN_REASON_MINOR_NETWORK_CONNECTIVITY;
    public static ShutdownReason SHTDN_REASON_MINOR_NETWORKCARD;
    public static ShutdownReason SHTDN_REASON_MINOR_OTHER;
    public static ShutdownReason SHTDN_REASON_MINOR_OTHERDRIVER;
    public static ShutdownReason SHTDN_REASON_MINOR_POWER_SUPPLY;
    public static ShutdownReason SHTDN_REASON_MINOR_PROCESSOR;
    public static ShutdownReason SHTDN_REASON_MINOR_RECONFIG;
    public static ShutdownReason SHTDN_REASON_MINOR_SECURITY;
    public static ShutdownReason SHTDN_REASON_MINOR_SECURITYFIX;
    public static ShutdownReason SHTDN_REASON_MINOR_SECURITYFIX_UNINSTALL;
    public static ShutdownReason SHTDN_REASON_MINOR_SERVICEPACK;
    public static ShutdownReason SHTDN_REASON_MINOR_SERVICEPACK_UNINSTALL;
    public static ShutdownReason SHTDN_REASON_MINOR_TERMSRV;
    public static ShutdownReason SHTDN_REASON_MINOR_UNSTABLE;
    public static ShutdownReason SHTDN_REASON_MINOR_UPGRADE;
    public static ShutdownReason SHTDN_REASON_MINOR_WMI;
}
internal class Microsoft.VisualStudio.Setup.Services.SingletonEventArgs : EventArgs {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Services.SingletonService : object {
    private string mutexName;
    private IStopSignal stopSignal;
    private IMutexService mutexService;
    [NullableAttribute("2")]
private ILogger logger;
    [NullableAttribute("2")]
private SynchronizedMutex synchronizedMutex;
    private bool isDisposed;
    private int numberOfRelaunches;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<SingletonEventArgs> SecondInstanceStarted;
    public int NumberOfRelaunches { get; }
    private bool HasMutex { get; }
    public SingletonService(string mutexName, IStopSignal stopSignal, IMutexService mutexService, ILogger logger);
    [CompilerGeneratedAttribute]
public sealed virtual void add_SecondInstanceStarted(EventHandler`1<SingletonEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_SecondInstanceStarted(EventHandler`1<SingletonEventArgs> value);
    public sealed virtual int get_NumberOfRelaunches();
    public sealed virtual bool GetSingletonLock();
    public sealed virtual bool ReleaseSingletonLock();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    private void SignalOtherInstance();
    private void OnStopRequested(object sender, EventArgs e);
    private bool get_HasMutex();
}
internal class Microsoft.VisualStudio.Setup.Services.StopSignal : object {
    public static string BackgroundDownloadSyncEventName;
    public static string OneInstanceSyncEventName;
    public static string WaitForNewWindowSyncEventName;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs> StopRequested;
    private ManualResetEventSlim stopSignalReady;
    private EventWaitHandle handle;
    private bool shouldStop;
    private EventArgs eventArgs;
    public StopSignal(string syncEventName, bool executeOnlyOnce);
    private static StopSignal();
    [CompilerGeneratedAttribute]
public sealed virtual void add_StopRequested(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_StopRequested(EventHandler`1<EventArgs> value);
    public sealed virtual void Stop();
    internal bool IsSetToStop();
    private void WaitForStopSignals(bool executeOnlyOnce);
}
internal class Microsoft.VisualStudio.Setup.Services.STORAGE_PROPERTY_BOOLEAN_DESCRIPTOR : ValueType {
    internal int Version;
    internal int Size;
    internal bool Value;
}
internal enum Microsoft.VisualStudio.Setup.Services.STORAGE_PROPERTY_ID : Enum {
    public int value__;
    public static STORAGE_PROPERTY_ID StorageDeviceSeekPenaltyProperty;
    public static STORAGE_PROPERTY_ID StorageDeviceTrimProperty;
}
internal class Microsoft.VisualStudio.Setup.Services.STORAGE_PROPERTY_QUERY : ValueType {
    internal STORAGE_PROPERTY_ID PropertyId;
    internal STORAGE_PROPERTY_TYPE QueryType;
    [NullableAttribute("1")]
internal Byte[] AdditionalParameters;
    internal int Length { get; }
    internal int get_Length();
}
internal enum Microsoft.VisualStudio.Setup.Services.STORAGE_PROPERTY_TYPE : Enum {
    public int value__;
    public static STORAGE_PROPERTY_TYPE PropertyStandardQuery;
}
internal enum Microsoft.VisualStudio.Setup.Services.STORAGE_QUERY_TYPE : Enum {
    public int value__;
    public static STORAGE_QUERY_TYPE PropertyStandardQuery;
    public static STORAGE_QUERY_TYPE PropertyExistsQuery;
    public static STORAGE_QUERY_TYPE PropertyMaskQuery;
    public static STORAGE_QUERY_TYPE PropertyQueryMaxDefined;
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.VisualStudio.Setup.Services.StringDictionaryAdapter : object {
    private static IEqualityComparer`1<string> EqualityComparer;
    private StringDictionary dictionary;
    private CollectionAdapter keys;
    private CollectionAdapter values;
    public string Item { get; public set; }
    public ICollection`1<string> Keys { get; }
    public ICollection`1<string> Values { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public StringDictionaryAdapter(StringDictionary dictionary);
    private static StringDictionaryAdapter();
    public sealed virtual string get_Item(string key);
    public sealed virtual void set_Item(string key, string value);
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual ICollection`1<string> get_Values();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(string key, string value);
    public sealed virtual void Add(KeyValuePair`2<string, string> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<string, string> item);
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, string>> GetEnumerator();
    public sealed virtual bool Remove(string key);
    public sealed virtual bool Remove(KeyValuePair`2<string, string> item);
    public sealed virtual bool TryGetValue(string key, String& value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
private CollectionAdapter <get_Keys>b__9_0();
    [CompilerGeneratedAttribute]
private CollectionAdapter <get_Values>b__11_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Services.SynchronizedStringBuilder : object {
    private DisposableReaderWriterLock syncLock;
    private StringBuilder builder;
    private bool isDisposed;
    public virtual string ToString();
    public void Append(string text);
    public void AppendLine(string line);
    public void AppendFormat(string format, Object[] args);
    private void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
internal class Microsoft.VisualStudio.Setup.Services.SYSTEM_POWER_STATUS : ValueType {
    public byte ACLineStatus;
    public BatteryStatus BatteryStatus;
    internal byte BatteryLifePercent;
    internal byte SystemStatusFlag;
    public int BatteryLifeTime;
    public int BatteryFullLifeTime;
}
public class Microsoft.VisualStudio.Setup.Services.SystemPowerStatus : object {
    [CompilerGeneratedAttribute]
private BatteryStatus <BatteryStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BatteryLifePercent>k__BackingField;
    public BatteryStatus BatteryStatus { get; public set; }
    public int BatteryLifePercent { get; public set; }
    [CompilerGeneratedAttribute]
public BatteryStatus get_BatteryStatus();
    [CompilerGeneratedAttribute]
public void set_BatteryStatus(BatteryStatus value);
    [CompilerGeneratedAttribute]
public int get_BatteryLifePercent();
    [CompilerGeneratedAttribute]
public void set_BatteryLifePercent(int value);
}
public class Microsoft.VisualStudio.Setup.Services.TargetedNotifications.ClientFilterProvider : RemoteSettingsFilterProvider {
    private string clientName;
    private string clientVersion;
    private string clientLocale;
    private string channelOrProductId;
    private Guid appId;
    private RemoteSettingsFilterProvider defaultProvider;
    public ClientFilterProvider(string clientName, string clientVersion, string clientLocale, string channelOrProductId, Guid appId, RemoteSettingsFilterProvider defaultProvider);
    public virtual string GetApplicationName();
    public virtual string GetApplicationVersion();
    public virtual Guid GetAppIdPackageGuid();
    public virtual string GetBranchBuildFrom();
    public virtual string GetChannelId();
    public virtual string GetChannelManifestId();
    public virtual string GetCulture();
    public virtual bool GetIsUserInternal();
    public virtual string GetMacAddressHash();
    public virtual Guid GetMachineId();
    public virtual string GetManifestId();
    public virtual int GetNotificationsCount();
    public virtual string GetOsType();
    public virtual string GetOsVersion();
    public virtual Guid GetUserId();
    public virtual Task`1<string> GetVsIdAsync();
    public virtual string GetVsSku();
}
public class Microsoft.VisualStudio.Setup.Services.TargetedNotifications.ClientVersionScopeFilterProvider : object {
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    public string Name { get; }
    public Version Version { get; }
    public ClientVersionScopeFilterProvider(Version version);
    public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public Version get_Version();
    public sealed virtual DoubleScopeValue Provide(string key);
    internal int GetVersionPart(string partName);
}
public interface Microsoft.VisualStudio.Setup.Services.TargetedNotifications.ITargetedNotificationsService {
    public abstract virtual Task`1<IEnumerable`1<TargetedNotificationsAction`1<T>>> GetActionsAsync(string actionPath, CancellationToken cancellationToken);
}
public class Microsoft.VisualStudio.Setup.Services.TargetedNotifications.TargetedNotificationsAction`1 : object {
    [CompilerGeneratedAttribute]
private T <Action>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Precedence>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuleId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FlightName>k__BackingField;
    public T Action { get; }
    public int Precedence { get; }
    public string RuleId { get; }
    public string FlightName { get; }
    public TargetedNotificationsAction`1(T action, int precedence, string ruleId, string flightName);
    [CompilerGeneratedAttribute]
public T get_Action();
    [CompilerGeneratedAttribute]
public int get_Precedence();
    [CompilerGeneratedAttribute]
public string get_RuleId();
    [CompilerGeneratedAttribute]
public string get_FlightName();
}
public static class Microsoft.VisualStudio.Setup.Services.TargetedNotifications.TargetedNotificationsConstants : object {
    public static string ProductName;
    public static Guid AppId;
    public static string SurveyActionsPath;
    public static string NoticeActionsPath;
    public static string CommonErrorActionsPath;
    public static string WorkloadOverridesActionsPath;
    public static string HelpLinkActionsPath;
    public static string ReleaseNotesActionPath;
    public static string BulletinActionsPath;
    private static TargetedNotificationsConstants();
}
public class Microsoft.VisualStudio.Setup.Services.Telemetry : object {
    private static int WERP0;
    private static int WERP1;
    private static int WERP2;
    private static int WERP3;
    private static int WERP4;
    private static int WERP5;
    private static int WERP6;
    private static int WERP7;
    private static int WERP8;
    private static int WERP9;
    private static TimeSpan DisposeAndFlushTimeout;
    private static string UserNameProperty;
    private IProcessService processService;
    private ILogger logger;
    private IFileSystem fileSystem;
    private bool createdClonedTelemetrySession;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<ITelemetryEventCorrelation> <SerializedCorrelations>k__BackingField;
    [CompilerGeneratedAttribute]
private TelemetrySession <TelemetrySession>k__BackingField;
    public bool IsDisposed { get; private set; }
    public ICollection`1<ITelemetryEventCorrelation> SerializedCorrelations { get; }
    public string TelemetrySessionID { get; }
    public TelemetrySession TelemetrySession { get; private set; }
    public bool IsOptedIn { get; }
    public bool IsUserMicrosoftInternal { get; }
    public Nullable`1<Guid> UserId { get; }
    public Nullable`1<Guid> MachineId { get; }
    public string UserAlias { get; }
    public Telemetry(IServiceProvider services);
    public Telemetry(IServiceProvider services, bool isOptedIn);
    public Telemetry(IServiceProvider services, string serializedTelemetrySession);
    public Telemetry(IServiceProvider services, TelemetrySession telemetrySession);
    private Telemetry(IServiceProvider services, bool isOptedIn, string serializedTelemetrySession);
    private static Telemetry();
    [CompilerGeneratedAttribute]
public bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    protected virtual override void Finalize();
    [CompilerGeneratedAttribute]
public sealed virtual ICollection`1<ITelemetryEventCorrelation> get_SerializedCorrelations();
    public sealed virtual string get_TelemetrySessionID();
    [CompilerGeneratedAttribute]
public TelemetrySession get_TelemetrySession();
    [CompilerGeneratedAttribute]
private void set_TelemetrySession(TelemetrySession value);
    public sealed virtual object GetCorrelation(object objOperationScope);
    public sealed virtual void SetSharedProperties(object objTelemetryContext, IServiceProvider services);
    public sealed virtual void SetSharedProperties(IDictionary`2<string, object> properties);
    public sealed virtual void GetContextProperties(IPackageIdentity packageIdentity, IDictionary`2<string, object> properties);
    public sealed virtual void WriteFault(string eventName, string description, IDictionary`2<string, object> properties, Exception ex, object objCorrelatedWith, bool overrideCEIP, BucketParameters bucketParameters, bool addLogs, IEnumerable`1<string> logFiles, bool createDump);
    public sealed virtual void WriteEvent(string eventName, IDictionary`2<string, object> properties, object objCorrelation, bool overrideCEIP);
    public sealed virtual void WriteProperty(string propertyName, IDictionary`2<string, object> properties, string values);
    public sealed virtual ITelemetryOperation StartOperation(string eventName, IDictionary`2<string, object> properties, bool overrideCEIP, bool reportStatistics);
    public sealed virtual bool get_IsOptedIn();
    public sealed virtual bool get_IsUserMicrosoftInternal();
    public sealed virtual Nullable`1<Guid> get_UserId();
    public sealed virtual Nullable`1<Guid> get_MachineId();
    public sealed virtual string get_UserAlias();
    public sealed virtual void FlushTelemetrySession(bool shouldRecreate);
    public sealed virtual void SetSharedProperty(string propertyName, object propertyValue);
    public sealed virtual void RemoveSharedProperty(string propertyName);
    public sealed virtual string SerializeSettings();
    public sealed virtual void Dispose();
    protected virtual void PostEvent(TelemetryEvent fault);
    protected virtual void AddFile(FaultEvent evt, string path);
    private void Dispose(bool disposing);
    private FaultEvent CreateFaultEvent(string eventName, string description, IDictionary`2<string, object> properties, Exception ex, object objCorrelatedWith, BucketParameters bucketParameters, bool addLogs, IEnumerable`1<string> logFiles, bool createDump);
    private TelemetryEvent CreateWriteEvent(string eventName, IDictionary`2<string, object> properties, object objCorrelation, ICollection`1<TelemetryEventCorrelation> serializedCorrelation);
    private void CreateSession(string serializedTelemetrySession);
}
internal class Microsoft.VisualStudio.Setup.Services.TelemetryEventCorrelationFacade : object {
    [CompilerGeneratedAttribute]
private TelemetryEventCorrelation <TelemetryEventCorrelation>k__BackingField;
    public TelemetryEventCorrelation TelemetryEventCorrelation { get; }
    public TelemetryEventCorrelationFacade(TelemetryEventCorrelation telemetryEventCorrelation);
    [CompilerGeneratedAttribute]
public TelemetryEventCorrelation get_TelemetryEventCorrelation();
    public sealed virtual string Serialize();
}
internal class Microsoft.VisualStudio.Setup.Services.TelemetryOperation : TelemetryOperationBase {
    private Telemetry telemetry;
    public TelemetryOperation(string eventName, Telemetry telemetry, TelemetrySession telemetrySession, IDictionary`2<string, object> properties, bool reportStatistics);
    protected virtual void Dispose(bool disposing);
}
public abstract class Microsoft.VisualStudio.Setup.Services.TelemetryOperationBase : object {
    public static string EXCEPTIONSTRING;
    public static string NULLPATHSTRING;
    [CompilerGeneratedAttribute]
private TelemetryScope`1<OperationEvent> <OperationScope>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EventName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <ExceptionRecord>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OperationMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private Result <ExecutionResult>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SendFault>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<TelemetryEventCorrelation> <SerializedCorrelation>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <LogFiles>k__BackingField;
    public string OperationCorrelation { get; }
    public Result Result { get; }
    protected TelemetryScope`1<OperationEvent> OperationScope { get; protected set; }
    protected string EventName { get; protected set; }
    protected string ErrorMessage { get; protected set; }
    protected Exception ExceptionRecord { get; protected set; }
    protected string OperationMessage { get; protected set; }
    protected Result ExecutionResult { get; protected set; }
    protected bool SendFault { get; protected set; }
    public IDictionary`2<string, object> Properties { get; }
    public List`1<TelemetryEventCorrelation> SerializedCorrelation { get; private set; }
    public IList`1<string> LogFiles { get; }
    public TelemetryOperationBase(string eventName, TelemetryScope`1<OperationEvent> operationScope, IDictionary`2<string, object> properties, bool reportStatistics);
    private static TelemetryOperationBase();
    public sealed virtual string get_OperationCorrelation();
    public sealed virtual Result get_Result();
    [CompilerGeneratedAttribute]
protected TelemetryScope`1<OperationEvent> get_OperationScope();
    [CompilerGeneratedAttribute]
protected void set_OperationScope(TelemetryScope`1<OperationEvent> value);
    [CompilerGeneratedAttribute]
protected string get_EventName();
    [CompilerGeneratedAttribute]
protected void set_EventName(string value);
    [CompilerGeneratedAttribute]
protected string get_ErrorMessage();
    [CompilerGeneratedAttribute]
protected void set_ErrorMessage(string value);
    [CompilerGeneratedAttribute]
protected Exception get_ExceptionRecord();
    [CompilerGeneratedAttribute]
protected void set_ExceptionRecord(Exception value);
    [CompilerGeneratedAttribute]
protected string get_OperationMessage();
    [CompilerGeneratedAttribute]
protected void set_OperationMessage(string value);
    [CompilerGeneratedAttribute]
protected Result get_ExecutionResult();
    [CompilerGeneratedAttribute]
protected void set_ExecutionResult(Result value);
    [CompilerGeneratedAttribute]
protected bool get_SendFault();
    [CompilerGeneratedAttribute]
protected void set_SendFault(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, object> get_Properties();
    [CompilerGeneratedAttribute]
public List`1<TelemetryEventCorrelation> get_SerializedCorrelation();
    [CompilerGeneratedAttribute]
private void set_SerializedCorrelation(List`1<TelemetryEventCorrelation> value);
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<string> get_LogFiles();
    public sealed virtual void RecordFailure(string message);
    public sealed virtual void RecordCancel(string message);
    public sealed virtual void RecordException(string errorMessage, Exception exception, string message, bool sendFault);
    public sealed virtual void RecordSuccess(string message);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
internal class Microsoft.VisualStudio.Setup.Services.TelemetrySamplingDecorator : object {
    private ITelemetry telemetry;
    private ITelemetrySamplingService samplingService;
    public ICollection`1<ITelemetryEventCorrelation> SerializedCorrelations { get; }
    public string TelemetrySessionID { get; }
    public bool IsOptedIn { get; }
    public bool IsUserMicrosoftInternal { get; }
    public Nullable`1<Guid> UserId { get; }
    public Nullable`1<Guid> MachineId { get; }
    public string UserAlias { get; }
    public TelemetrySamplingDecorator(ITelemetry telemetry, ITelemetrySamplingService samplingService);
    public sealed virtual ICollection`1<ITelemetryEventCorrelation> get_SerializedCorrelations();
    public sealed virtual string get_TelemetrySessionID();
    public sealed virtual bool get_IsOptedIn();
    public sealed virtual bool get_IsUserMicrosoftInternal();
    public sealed virtual Nullable`1<Guid> get_UserId();
    public sealed virtual Nullable`1<Guid> get_MachineId();
    public sealed virtual string get_UserAlias();
    public static ITelemetry Create(ITelemetry telemetry, IRemoteSettingsService remoteSettings);
    public static ITelemetry CreateWithDefaultSampling(ITelemetry telemetry);
    public sealed virtual void Dispose();
    public sealed virtual void FlushTelemetrySession(bool shouldRecreate);
    public sealed virtual void GetContextProperties(IPackageIdentity packageIdentity, IDictionary`2<string, object> properties);
    public sealed virtual object GetCorrelation(object objOperationScope);
    public sealed virtual void RemoveSharedProperty(string propertyName);
    public sealed virtual string SerializeSettings();
    public sealed virtual void SetSharedProperties(object telemetryContext, IServiceProvider services);
    public sealed virtual void SetSharedProperties(IDictionary`2<string, object> properties);
    public sealed virtual void SetSharedProperty(string propertyName, object propertyValue);
    public sealed virtual ITelemetryOperation StartOperation(string eventName, IDictionary`2<string, object> properties, bool overrideCEIP, bool reportStatistics);
    public sealed virtual void WriteEvent(string eventName, IDictionary`2<string, object> properties, object objCorrelation, bool overrideCEIP);
    public sealed virtual void WriteFault(string eventName, string description, IDictionary`2<string, object> properties, Exception ex, object objCorrelatedWith, bool overrideCEIP, BucketParameters bucketParameters, bool addLogs, IEnumerable`1<string> logFiles, bool createDump);
    public sealed virtual void WriteProperty(string propertyName, IDictionary`2<string, object> properties, string values);
    private bool IsDropped(string eventName);
    private IDictionary`2<string, object> GetProperties(string eventName, IDictionary`2<string, object> properties);
}
internal class Microsoft.VisualStudio.Setup.Services.TelemetrySamplingService : object {
    public static int DefaultSampledPercentage;
    private HashSet`1<string> sampledEvents;
    private Random random;
    [CompilerGeneratedAttribute]
private int <SampledPercentage>k__BackingField;
    public int SampledPercentage { get; }
    public TelemetrySamplingService(ITelemetry telemetry, int sampledPercentage);
    [CompilerGeneratedAttribute]
public sealed virtual int get_SampledPercentage();
    public sealed virtual bool CanBeSampled(string eventName);
    public sealed virtual bool IsDropped(string eventName);
    private bool ValidatePercentage(int sampledPercentage);
    private void WriteSamplingTelemetry(ITelemetry telemetry, int sampledPercentage);
}
internal class Microsoft.VisualStudio.Setup.Services.TOKEN_PRIVILEGES : ValueType {
    [CompilerGeneratedAttribute]
private UInt32 <PrivilegeCount>k__BackingField;
    [CompilerGeneratedAttribute]
private LUID_AND_ATTRIBUTES <Privileges>k__BackingField;
    public UInt32 PrivilegeCount { get; public set; }
    public LUID_AND_ATTRIBUTES Privileges { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_PrivilegeCount();
    [CompilerGeneratedAttribute]
public void set_PrivilegeCount(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public LUID_AND_ATTRIBUTES get_Privileges();
    [CompilerGeneratedAttribute]
public void set_Privileges(LUID_AND_ATTRIBUTES value);
}
internal class Microsoft.VisualStudio.Setup.Services.TokenElevation : object {
    private int tokenIsElevated;
    public bool IsElevated { get; }
    public bool get_IsElevated();
}
internal enum Microsoft.VisualStudio.Setup.Services.TokenInformation : Enum {
    public int value__;
    public static TokenInformation TokenElevation;
}
internal class Microsoft.VisualStudio.Setup.Services.UpdateSettingsService : object {
    private IInstanceRepositoryFactory instanceFactory;
    private IFileSystem fileSystem;
    public UpdateSettingsService(IInstanceRepositoryFactory instanceFactory, IFileSystem fileSystem);
    public sealed virtual void ChangeChannel(string instanceId, IChannel newChannel);
    public sealed virtual void ChangeUpdateSettings(string instanceId, Nullable`1<bool> removeOos, bool includeRecommendedOnUpdate);
    public sealed virtual void InitializeUpdateSettings(IEngine engine, Nullable`1<bool> removeOos, bool includeRecommendedOnUpdate);
    private string GetBoolProperty(bool value);
    private void ResetRollbackCatalog(IInstanceRepository instanceRepo);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Services.UserSettings : object {
    [CompilerGeneratedAttribute]
private string <Locale>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Theme>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PreviousSessionId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Debug>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShowDownlevelSkus>k__BackingField;
    public string Locale { get; public set; }
    public string Theme { get; public set; }
    public string PreviousSessionId { get; public set; }
    public bool Debug { get; public set; }
    public bool ShowDownlevelSkus { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Locale();
    [CompilerGeneratedAttribute]
public void set_Locale(string value);
    [CompilerGeneratedAttribute]
public string get_Theme();
    [CompilerGeneratedAttribute]
public void set_Theme(string value);
    [CompilerGeneratedAttribute]
public string get_PreviousSessionId();
    [CompilerGeneratedAttribute]
public void set_PreviousSessionId(string value);
    [CompilerGeneratedAttribute]
public bool get_Debug();
    [CompilerGeneratedAttribute]
public void set_Debug(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShowDownlevelSkus();
    [CompilerGeneratedAttribute]
public void set_ShowDownlevelSkus(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Services.UserSettingsSerializer : object {
    private StringComparer nameComparer;
    private CamelCaseNamingStrategy namingStrategy;
    [NullableAttribute("2")]
private ILogger logger;
    [NullableContextAttribute("2")]
public UserSettingsSerializer(IServiceProvider services);
    public sealed virtual UserSettings Deserialize(Stream stream);
    public UserSettings Deserialize(TextReader textReader);
    public sealed virtual void Serialize(UserSettings object, Stream stream);
    public void Serialize(TextWriter textWriter, UserSettings settings);
    private void SetProperty(UserSettings settings, string propertyName, object value);
    [NullableContextAttribute("2")]
private bool TryGetBoolValue(object value, Boolean& boolValue);
    private void WriteProperty(JsonTextWriter writer, string name, object value);
}
public class Microsoft.VisualStudio.Setup.Services.VariableResolver : object {
    [NullableAttribute("1")]
public static IVariableResolver Default;
    private static VariableResolver();
    [NullableContextAttribute("1")]
public sealed virtual string ResolveVariables(string value, IDictionary`2<string, string> properties);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Services.VOLUME_DISK_EXTENTS : object {
    private IntPtr ptr;
    internal int NumberOfDiskExtents { get; }
    internal DISK_EXTENT[] Extents { get; }
    internal int Length { get; }
    protected virtual override void Finalize();
    internal int get_NumberOfDiskExtents();
    internal DISK_EXTENT[] get_Extents();
    internal void Resize();
    internal int get_Length();
    public static IntPtr op_Implicit(VOLUME_DISK_EXTENTS obj);
    private sealed virtual override void System.IDisposable.Dispose();
    private void Dispose(bool disposing);
}
public class Microsoft.VisualStudio.Setup.Services.Watson : object {
    private static int WatsonsWithoutLogsThreshold;
    private IServiceProvider services;
    private object syncRoot;
    private IEnumerable`1<string> additionalLogPaths;
    private ILogger logger;
    private ITelemetry telemetry;
    private bool isInitialized;
    private int watsonsWithoutLogs;
    public Watson(IServiceProvider services);
    public Watson(IServiceProvider services, IEnumerable`1<string> additionalLogPaths);
    public sealed virtual void FileWERReport(IEngineContext context, IPackage currentPackage, string packageAction, string returnCode, string details, bool sendReport, bool addLogs, string logFile, bool createDump, IEnumerable`1<LogFile> additionalLogFiles, IDictionary`2<string, string> properties);
    private void AddLogs(IEnumerable`1<LogFile> logFiles, IDictionary`2<string, string> properites, ISet`1<string> logPaths);
    private void Initialize();
}
public class Microsoft.VisualStudio.Setup.Services.WindowsInstallerService : object {
    private static string Language;
    private static IWindowsInstallerService instance;
    private ILogger logger;
    private IServiceProvider services;
    public static IWindowsInstallerService Default { get; }
    public WindowsInstallerService(IServiceProvider services);
    private static WindowsInstallerService();
    public static IWindowsInstallerService get_Default();
    public sealed virtual int ConfigureProduct(string productCode, int installLevel, int installState, string commandLine);
    public sealed virtual void EnableLog(string logFile);
    public sealed virtual PackageState GetPackageInstallState(string productCode, string upgradeCode, VersionRange productVersionRange, Nullable`1<int> productLanguage, Version& installedVersion);
    public sealed virtual int InstallProduct(string packagePath, string commandLine);
    public sealed virtual int GetProductInfo(string productCode, String& propertyValue, string propertyName);
    private PackageState EvaluateUpgradeCode(string upgradeCode, VersionRange versionRange, Nullable`1<int> productLanguage, Version& installedVersion);
}
internal class Microsoft.VisualStudio.Setup.Services.WindowsProcess : object {
    [CompilerGeneratedAttribute]
private Process <Process>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<DataReceivedEventArgs> OutputDataReceived;
    [CompilerGeneratedAttribute]
private EventHandler`1<DataReceivedEventArgs> ErrorDataReceived;
    protected internal Process Process { get; }
    public DateTime StartTime { get; }
    public int ExitCode { get; }
    public IntPtr MainWindowHandle { get; }
    public string MainModuleFileName { get; }
    public string MainWindowTitle { get; }
    public int Id { get; }
    public string Description { get; }
    public string ProcessName { get; }
    public bool HasExited { get; }
    public IntPtr Handle { get; }
    internal WindowsProcess(Process process);
    private void Process_ErrorDataReceived(object sender, DataReceivedEventArgs e);
    private void Process_OutputDataReceived(object sender, DataReceivedEventArgs e);
    [CompilerGeneratedAttribute]
protected internal Process get_Process();
    public sealed virtual DateTime get_StartTime();
    public sealed virtual int get_ExitCode();
    public sealed virtual IntPtr get_MainWindowHandle();
    public sealed virtual string get_MainModuleFileName();
    public sealed virtual string get_MainWindowTitle();
    public sealed virtual int get_Id();
    public sealed virtual string get_Description();
    public sealed virtual string get_ProcessName();
    public sealed virtual bool get_HasExited();
    public sealed virtual IntPtr get_Handle();
    [CompilerGeneratedAttribute]
public sealed virtual void add_OutputDataReceived(EventHandler`1<DataReceivedEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OutputDataReceived(EventHandler`1<DataReceivedEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ErrorDataReceived(EventHandler`1<DataReceivedEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ErrorDataReceived(EventHandler`1<DataReceivedEventArgs> value);
    public sealed virtual void BeginErrorReadLine();
    public sealed virtual void BeginOutputReadLine();
    public sealed virtual void Close();
    public sealed virtual void Kill();
    public sealed virtual bool Start();
    public sealed virtual bool WaitForExit(int milliseconds);
    public sealed virtual void WaitForExit();
    public sealed virtual void Dispose();
}
public class Microsoft.VisualStudio.Setup.Services.WindowsRegistry : object {
    public static IRegistry Default;
    private static Dictionary`2<string, RegistryHive> RegistryRootMapping;
    private IOperatingSystem operatingSystem;
    public WindowsRegistry(IServiceProvider services);
    private static WindowsRegistry();
    public sealed virtual RegistryHive ExtractBaseHive(string registryKey, String& keyWithoutBaseHive);
    public sealed virtual IRegistryKey OpenBaseKey(RegistryHive hive, RegistryView view);
}
internal class Microsoft.VisualStudio.Setup.Services.WindowsRegistryKey : object {
    private RegistryKey registryKey;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    public bool IsDisposed { get; private set; }
    public WindowsRegistryKey(RegistryKey registryKey);
    internal static RegistryValueKind Convert(RegistryValueKind kind);
    internal static RegistryHive Convert(RegistryHive hive);
    internal static RegistryView Convert(RegistryView view);
    internal static RegistryOptions Convert(RegistryOptions options);
    protected virtual override void Finalize();
    [CompilerGeneratedAttribute]
public bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    public sealed virtual object GetValue(string valueName);
    public sealed virtual IEnumerable`1<string> GetValueNames();
    public sealed virtual void SetValue(string valueName, object value, RegistryValueKind valueKind);
    public sealed virtual IRegistryKey CreateSubKey(string path, RegistryOptions options);
    public sealed virtual IRegistryKey OpenSubKey(string path, bool writable);
    public sealed virtual void DeleteSubKeyTree(string subkey, bool throwOnMissingSubKey);
    public sealed virtual void DeleteValue(string name, bool throwOnMissingValue);
    public sealed virtual String[] GetSubKeyNames();
    public sealed virtual IRegistryKey CreateSubKeyTransacted(string path, RegistryOptions options);
    public sealed virtual void DeleteSubKeyTreeTransacted(string path, bool throwOnMissingSubKey);
    public sealed virtual IRegistryKey OpenSubKeyTransacted(string path, bool writable);
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
}
internal class Microsoft.VisualStudio.Setup.Services.WindowsRestartManager : object {
    private int sessionId;
    private string sessionKey;
    private bool registered;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    public bool IsDisposed { get; private set; }
    internal WindowsRestartManager(int sessionId, string sessionKey);
    protected virtual override void Finalize();
    [CompilerGeneratedAttribute]
public bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    public sealed virtual void Dispose();
    public sealed virtual void Register(IEnumerable`1<string> files, IEnumerable`1<IProcess> processes, IEnumerable`1<string> services);
    public sealed virtual void Restart();
    public sealed virtual void Shutdown(WindowsRestartManagerShutdown action);
    public sealed virtual IEnumerable`1<IWindowsRestartManagerProcessInfo> GetProcesses();
    internal static void ThrowOnError(int result);
    private static RM_UNIQUE_PROCESS Convert(IProcess process);
    private void Dispose(bool disposing);
}
internal class Microsoft.VisualStudio.Setup.Services.WindowsRestartManagerFactory : object {
    internal static IWindowsRestartManagerFactory Default;
    private static WindowsRestartManagerFactory();
    public sealed virtual IWindowsRestartManager Create();
}
internal class Microsoft.VisualStudio.Setup.Services.WindowsRestartManagerProcessInfo : object {
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <StartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ServiceName>k__BackingField;
    [CompilerGeneratedAttribute]
private ApplicationType <ApplicationType>k__BackingField;
    [CompilerGeneratedAttribute]
private ApplicationStatus <ApplicationStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRestartable>k__BackingField;
    [DataMemberAttribute]
public int Id { get; }
    [DataMemberAttribute]
public DateTime StartTime { get; }
    public string Description { get; }
    [DataMemberAttribute]
public string ServiceName { get; }
    [DataMemberAttribute]
public ApplicationType ApplicationType { get; }
    [DataMemberAttribute]
public ApplicationStatus ApplicationStatus { get; }
    [DataMemberAttribute]
public bool IsRestartable { get; }
    internal WindowsRestartManagerProcessInfo(RM_PROCESS_INFO process);
    [JsonConstructorAttribute]
internal WindowsRestartManagerProcessInfo(int id, DateTime startTime, string description, string serviceName, ApplicationType applicationType, ApplicationStatus applicationStatus, bool isRestartable);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_StartTime();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Description();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ServiceName();
    [CompilerGeneratedAttribute]
public sealed virtual ApplicationType get_ApplicationType();
    [CompilerGeneratedAttribute]
public sealed virtual ApplicationStatus get_ApplicationStatus();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsRestartable();
}
[FlagsAttribute]
public enum Microsoft.VisualStudio.Setup.Services.WindowsRestartManagerShutdown : Enum {
    public int value__;
    public static WindowsRestartManagerShutdown ForceShutdown;
    public static WindowsRestartManagerShutdown ShutdownOnlyRegistered;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Services.WindowsUpdateProgressReporter : object {
    private IUpdateInstallerProgress cmdLineUpdateInstallerProgress;
    private ProductUpdaterServiceOptions serviceOptions;
    private object lockObject;
    private bool hasLoggedError;
    private bool disposed;
    public WindowsUpdateProgressReporter(ProductUpdaterServiceOptions serviceOptions, IUpdateInstallerProgress cmdLineUpdateInstallerProgress);
    public sealed virtual void Report(string package, double progress, ProgressType type, ProgressInfo detailedProgress);
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.SetupTelemetryConstants : object {
    private static string EventPrefix;
    private static string PropertyPrefix;
    internal static string ValidateRpcConnectionError;
    internal static string ExtensionCacheCleanupFailedEvent;
    internal static string ExceptionMessage;
    private static SetupTelemetryConstants();
}
public interface Microsoft.VisualStudio.Setup.Shortcuts.ILocalShortcut {
    [NullableContextAttribute("1")]
public abstract virtual string GetTargetPath();
    [NullableContextAttribute("1")]
public abstract virtual string GetArguments();
}
public interface Microsoft.VisualStudio.Setup.Shortcuts.IShortcut {
    [NullableContextAttribute("1")]
public abstract virtual void Save(string fileName);
}
[NullableContextAttribute("1")]
public interface Microsoft.VisualStudio.Setup.Shortcuts.IShortcutFactory {
    public abstract virtual ILocalShortcut CreateLocalShortcut(Shortcut shortcut, IReadOnlyDictionary`2<string, string> variableMapping);
    public abstract virtual IWebShortcut CreateWebShortcut(WebShortcut shortcut, IReadOnlyDictionary`2<string, string> variableMapping);
    public abstract virtual ILocalShortcut LoadLocalShortcut(string path);
    public abstract virtual IWebShortcut LoadWebShortcut(string path);
}
public interface Microsoft.VisualStudio.Setup.Shortcuts.IWebShortcut {
    [NullableContextAttribute("1")]
public abstract virtual string GetUrl();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Shortcuts.ShellLinkFacade : ShortcutFacadeBase {
    private static int INFOTIPSIZE;
    private static int SLGP_RAWPATH;
    private IShellLink shellLink;
    protected IPersistFile PersistFile { get; }
    public ShellLinkFacade(IShellLink shellLink);
    protected virtual IPersistFile get_PersistFile();
    public sealed virtual string GetTargetPath();
    public sealed virtual string GetArguments();
}
internal abstract class Microsoft.VisualStudio.Setup.Shortcuts.ShortcutFacadeBase : object {
    private bool isDisposed;
    [NullableAttribute("1")]
protected IPersistFile PersistFile { get; }
    [NullableContextAttribute("1")]
public sealed virtual void Save(string fileName);
    [NullableContextAttribute("1")]
protected abstract virtual IPersistFile get_PersistFile();
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Shortcuts.ShortcutFactory : object {
    private static string AppUserModelIdPropertyName;
    [NullableAttribute("2")]
private ILogger logger;
    [NullableContextAttribute("2")]
public ShortcutFactory(ILogger logger);
    private static ShortcutFactory();
    public sealed virtual ILocalShortcut CreateLocalShortcut(Shortcut shortcut, IReadOnlyDictionary`2<string, string> variableMapping);
    public sealed virtual IWebShortcut CreateWebShortcut(WebShortcut shortcut, IReadOnlyDictionary`2<string, string> variableMapping);
    public sealed virtual ILocalShortcut LoadLocalShortcut(string path);
    public sealed virtual IWebShortcut LoadWebShortcut(string path);
    private void SetShellProperties(IShellLink shellLink, Shortcut shortcut, IReadOnlyDictionary`2<string, string> variableMapping);
    private void SetShellProperty(IPropertyStore propertyStore, string name, string value);
    private bool GetPropertyKeyAndType(string name, PROPERTYKEY& key, VarEnum& type);
    private bool GetPropertyVariant(string name, string value, VarEnum type, PROPVARIANT& propVariant);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Shortcuts.WebLinkFacade : ShortcutFacadeBase {
    private IUniformResourceLocator shortcut;
    protected IPersistFile PersistFile { get; }
    public WebLinkFacade(IUniformResourceLocator shortcut);
    protected virtual IPersistFile get_PersistFile();
    public sealed virtual string GetUrl();
}
internal class Microsoft.VisualStudio.Setup.StopActivitiesException : EngineException {
    [NullableContextAttribute("1")]
public StopActivitiesException(ResourceManager resources, string resourceId, Object[] args);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.TargetedNotifications.WorkloadOverrides : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <WorkloadOrder>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChannelId>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, WorkloadResources> <WorkloadResources>k__BackingField;
    public IEnumerable`1<string> WorkloadOrder { get; }
    public string ChannelId { get; }
    public IDictionary`2<string, WorkloadResources> WorkloadResources { get; }
    public WorkloadOverrides(IEnumerable`1<string> workloadOrder, IDictionary`2<string, WorkloadResources> workloadResources, string channelId);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_WorkloadOrder();
    [CompilerGeneratedAttribute]
public string get_ChannelId();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, WorkloadResources> get_WorkloadResources();
}
internal class Microsoft.VisualStudio.Setup.TargetedNotifications.WorkloadResources : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LongDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private Icon <Icon>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    public string Name { get; }
    public string Description { get; }
    public string LongDescription { get; }
    public Icon Icon { get; }
    public string Category { get; }
    public WorkloadResources(string name, string description, string longDescription, Icon icon, string category);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public string get_LongDescription();
    [CompilerGeneratedAttribute]
public Icon get_Icon();
    [CompilerGeneratedAttribute]
public string get_Category();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Setup.TelemetryContext : ValueType {
    public string InstallSessionId;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] SerializedCorrelations;
    public string UserRequestedOperation;
}
public class Microsoft.VisualStudio.Setup.TemplateStringReplacer : object {
    private ILogger logger;
    private StringBuilder stringBuilder;
    public TemplateStringReplacer(string xml, ILogger logger);
    public string GetCurrentXml();
    public void ReplaceText(string placeholderText, string replacementText);
}
public class Microsoft.VisualStudio.Setup.Timer.DefaultTimer : object {
    private Timer timer;
    private bool disposedValue;
    public DefaultTimer(TimerCallback callback, object state, TimeSpan dueTime, TimeSpan period);
    public sealed virtual bool Change(TimeSpan dueTime, TimeSpan period, bool throwOnFailure);
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
}
public interface Microsoft.VisualStudio.Setup.Timer.ITimer {
    public abstract virtual bool Change(TimeSpan dueTime, TimeSpan period, bool throwOnFailure);
}
public interface Microsoft.VisualStudio.Setup.Timer.ITimerFactory {
    public abstract virtual ITimer Create(TimerCallback callback, object state, TimeSpan dueTime, TimeSpan period);
}
public class Microsoft.VisualStudio.Setup.Timer.TimerFactory : object {
    public sealed virtual ITimer Create(TimerCallback callback, object state, TimeSpan dueTime, TimeSpan period);
}
public class Microsoft.VisualStudio.Setup.Tracer : object {
    private string name;
    private ILogger logger;
    private Stopwatch stopwatch;
    public Tracer(IServiceProvider services, string name);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.UnhandledExceptionArtifacts : object {
    [CompilerGeneratedAttribute]
private IList`1<string> <LogFiles>k__BackingField;
    public IList`1<string> LogFiles { get; }
    [CompilerGeneratedAttribute]
public IList`1<string> get_LogFiles();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.UnhandledExceptionHandler : object {
    [NullableAttribute("2")]
private ITelemetry telemetry;
    [NullableAttribute("2")]
private ILogger logger;
    private UnhandledExceptionArtifacts artifacts;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    public bool IsDisposed { get; private set; }
    public UnhandledExceptionHandler(IServiceProvider services, UnhandledExceptionArtifacts artifacts);
    protected virtual override void Finalize();
    internal void OnUnhandledException(object sender, UnhandledExceptionEventArgs e);
    [CompilerGeneratedAttribute]
public bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
[JsonConverterAttribute("Newtonsoft.Json.Converters.StringEnumConverter")]
internal enum Microsoft.VisualStudio.Setup.UpdateClassification : Enum {
    public int value__;
    public static UpdateClassification Connector;
    public static UpdateClassification CriticalUpdate;
    public static UpdateClassification DevelopmentKit;
    public static UpdateClassification Driver;
    public static UpdateClassification FeaturePack;
    public static UpdateClassification Guidance;
    public static UpdateClassification SecurityPatch;
    public static UpdateClassification ServicePack;
    public static UpdateClassification Tool;
    public static UpdateClassification UpdateRollup;
    public static UpdateClassification Update;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Setup.UpdateConfigurationScheduler : SchedulerBase {
    public static string UpdataConfigurationTaskPath;
    private static string DefinitionNamePrefix;
    private static string ProfileKey;
    private IRegistry registry;
    public UpdateConfigurationScheduler(IServiceProvider services);
    private static UpdateConfigurationScheduler();
    public void Schedule();
    internal List`1<SecurityIdentifier> GetUsers();
    private IScheduledTaskDefinition GetTaskDefinition(SecurityIdentifier sid);
    private bool IsDefaultAccount(SecurityIdentifier sid);
    internal virtual bool ShouldRun();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Setup.UpdateRequiredException : Exception {
    public UpdateRequiredException(string message);
    protected UpdateRequiredException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Microsoft.VisualStudio.Setup.UserPropertyNames : object {
    public static string InstallChannelUriProperty;
    public static string AlwaysUpdateOnCloseProperty;
    private static UserPropertyNames();
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.Setup.Utility.DictionaryUtility : object {
    [ExtensionAttribute]
internal static void ModifyDictionaryItem(IDictionary`2<string, object> dictionary, string key, object value);
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.Setup.Utility.HashUtility : object {
    private static object LockObject;
    private static HashUtility();
    [ExtensionAttribute]
internal static string GetHashOfString(HashAlgorithm algorithm, string value);
}
internal static class Microsoft.VisualStudio.Setup.Utility.Hypervisor : object {
    private static int QueryTimeout;
    private static Version MinimumOSVersion;
    private static Nullable`1<bool> supported;
    private static Hypervisor();
    internal static bool Supported(IServiceProvider services);
    private static void EnsureInitialized(IServiceProvider services);
    private static bool IsHyperVSupported(IServiceProvider serviceProvider, ITelemetryOperation telemetryOperation);
    private static bool IsHyperVHost(IServiceProvider serviceProvider);
    private static bool IsHyperVFeatureAvailable(ILogger logger);
    private static bool IsVirtualizationEnabled();
    private static bool IsDataExecutionPreventionEnabled();
}
internal static class Microsoft.VisualStudio.Setup.Utility.IOUtil : object {
    internal static void CopyStream(Stream input, Stream output);
    internal static void RemoveReadOnlyAttribute(string directory);
    internal static bool DeleteFileIfExists(string filePath);
    internal static bool IsOpticalDevice(string dir);
    private static void RemoveReadOnlyAttributeHelper(FileSystemInfo fileSystemObj);
    internal static long GetDriveSpace(string filePath);
    public static string GetPathRoot(string filePath);
    internal static bool IsValidInstallDrive(string filePath);
}
internal class Microsoft.VisualStudio.Setup.Utility.JsonUtility : object {
    public static IDictionary`2<string, object> ParseNameValuePairJsonFile(IServiceProvider services, string filePath);
    public static IDictionary`2<string, object> ParseNameValuePairJsonStream(IServiceProvider services, Stream jsonStream);
    public static IDictionary`2<string, object> ParseNameValuePairJson(string jsonContents);
}
internal static class Microsoft.VisualStudio.Setup.Utility.MemoryUtility : object {
    public static ulong GetTotalPhysicalMemory();
}
internal static class Microsoft.VisualStudio.Setup.Utility.ProcessUtility : object {
    internal static string SetupMutex;
    private static string VsixInstallerProcessName;
    private static ProcessUtility();
    internal static void ShutDownAllProcessesForVSFolder(IServiceProvider serviceProvider, IWindowsRestartManager rmService, string vsFolder, IEnumerable`1<string> additionalFolders, IEnumerable`1<string> additionalFiles, IEnumerable`1<string> relatedServices);
    internal static RunningProcesses GetOtherRunningProcesses(IServiceProvider serviceProvider, string vsFolder, IEnumerable`1<string> relatedProcessDirectories, IEnumerable`1<string> relatedProcessFiles, IEnumerable`1<string> relatedServices, ISet`1<IProcess> relatedProcessFilesFound);
    internal static bool IsProcesssFromFolder(IServiceProvider serviceProvider, IProcess process, string vsFolder);
    internal static Mutex CheckAndSetMutex(string mutexName);
    internal static void CheckAndSetSingletonGlobalLock(IServiceProvider serviceProvider, ISingletonService singletonService);
    internal static Mutex CheckAndSetGlobalLock(IServiceProvider serviceProvider, string name);
    private static void InformMutexMessage(IServiceProvider serviceProvider, Func`1<Nullable`1<Message>> retryAction, string retryMessage);
    private static Message GetSetupCannotRunMessage();
    public static Mutex EnsureMutex(string name);
    public static Mutex EnsureMutex(string name, TimeSpan timeout);
}
internal class Microsoft.VisualStudio.Setup.Utility.RegistryUtility : object {
    [NullableContextAttribute("1")]
public static bool TryGetRegValue(IRegistry registry, string regKey, string regValue, Object& dataValue);
}
internal class Microsoft.VisualStudio.Setup.Utility.RunningProcesses : object {
    [CompilerGeneratedAttribute]
private ICollection`1<IProcess> <Processes>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<IServiceController> <Services>k__BackingField;
    public int Count { get; }
    internal ICollection`1<IProcess> Processes { get; internal set; }
    internal ICollection`1<IServiceController> Services { get; internal set; }
    public sealed virtual int get_Count();
    [CompilerGeneratedAttribute]
internal ICollection`1<IProcess> get_Processes();
    [CompilerGeneratedAttribute]
internal void set_Processes(ICollection`1<IProcess> value);
    [CompilerGeneratedAttribute]
internal ICollection`1<IServiceController> get_Services();
    [CompilerGeneratedAttribute]
internal void set_Services(ICollection`1<IServiceController> value);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Setup.Utility.RunningProcesses/<GetEnumerator>d__10")]
public sealed virtual IEnumerator`1<object> GetEnumerator();
    private sealed virtual override void System.IDisposable.Dispose();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.VisualStudio.Setup.Utility.ServicingBaselinesReader : object {
    public static string ServicingBaselinesJsonFileName;
    public static IList`1<Baseline> Read(string filePath, IFileSystem fileSystem);
    public static bool IsRetired(Baseline baseline);
}
internal static class Microsoft.VisualStudio.Setup.Utility.ShortcutUtility : object {
    private static int WebShortcutCreationTimeout;
    private static string LinkExtension;
    private static string WebExtension;
    private static ShortcutUtility();
    private static IDictionary`2<string, string> GetVariableMapping(IFileSystem fileSystem);
    internal static bool CreateShortcuts(IEnumerable`1<Shortcut> shortcuts, IDictionary`2<string, string> variables, IServiceProvider container, IShortcutFactory shortcutFactory);
    internal static bool CreateWebShortcuts(IEnumerable`1<WebShortcut> webShortcuts, IDictionary`2<string, string> variables, IServiceProvider container, IShortcutFactory shortcutFactory);
    private static bool CreateShortcuts(IEnumerable`1<T> shortcuts, IDictionary`2<string, string> variables, IServiceProvider container, Func`3<T, IReadOnlyDictionary`2<string, string>, IShortcut> create);
    internal static bool DeleteShortcuts(IEnumerable`1<ShortcutInformation> shortcuts, IDictionary`2<string, string> variables, IServiceProvider container, IShortcutFactory shortcutFactory);
    private static bool ShortcutEquals(ShortcutInformation shortcut, string shortcutPath, IReadOnlyDictionary`2<string, string> variables, IShortcutFactory shortcutFactory);
    private static bool LocalShortcutEquals(Shortcut shortcut, string shortcutPath, IReadOnlyDictionary`2<string, string> variables, IShortcutFactory shortcutFactory);
    private static bool WebShortcutEquals(WebShortcut webShortcut, string shortcutPath, IShortcutFactory shortcutFactory);
    private static string GetExtension(ShortcutInformation shortcut);
}
internal class Microsoft.VisualStudio.Setup.Utility.STAThreadRunner`1 : object {
    private ManualResetEvent handle;
    private T result;
    private bool disposed;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public Exception Exception { get; private set; }
    public STAThreadRunner`1(Func`1<T> action);
    protected virtual override void Finalize();
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
private void set_Exception(Exception value);
    public T GetResult(int timeout);
    internal bool Wait(int timeout);
    internal bool Wait(TimeSpan timeout);
    private void Dispose(bool disposing);
    private sealed virtual override void System.IDisposable.Dispose();
}
internal class Microsoft.VisualStudio.Setup.Utility.StringUtility : object {
    internal static CultureInfo Enu;
    private static StringUtility();
    internal static string GetChipForMachineArchitecture();
    internal static string GetNeutralResourceString(string resourceId, ResourceManager resourceManager);
    internal static string GetSystemMeasurementString(string measurementScope, string measurementName, object measurementValue);
    internal static string FormatDisplayName(string displayName, IReadOnlyDictionary`2<string, string> propertyBag);
}
internal static class Microsoft.VisualStudio.Setup.Utility.WindowsInstallerUtil : object {
    [NullableContextAttribute("1")]
internal static int GetProductInfo(string productCode, String& propertyValue, string propertyName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Setup.UxException : LocalizedException {
    public UxException(ResourceManager resources, string resourceId, Object[] args);
    protected UxException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Validation.AnotherInstallationRunning : object {
    private static string MSIServer;
    private static int ErrorCode;
    private IServiceProvider services;
    private bool hasMSIToBeApplied;
    private IServiceController msiServiceController;
    public static PrecheckSupport PrecheckSupport { get; }
    public string Name { get; }
    internal AnotherInstallationRunning(IServiceProvider services, PrecheckParameters precheckParameters);
    private static AnotherInstallationRunning();
    public static PrecheckSupport get_PrecheckSupport();
    public sealed virtual string get_Name();
    [NullableContextAttribute("2")]
public sealed virtual IValidationResult Evaluate();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Validation.ArmMachineCheck : object {
    private static int ErrorCode;
    private IServiceProvider services;
    private bool shouldCheck;
    public static PrecheckSupport PrecheckSupport { get; }
    public string Name { get; }
    internal ArmMachineCheck(IServiceProvider services, PrecheckParameters precheckParameters);
    private static ArmMachineCheck();
    public static PrecheckSupport get_PrecheckSupport();
    public sealed virtual string get_Name();
    [NullableContextAttribute("2")]
public sealed virtual IValidationResult Evaluate();
    [NullableContextAttribute("2")]
private bool ShouldCheckArmMachine(string operation, Product product);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Validation.ArmSSUCheck : object {
    private static int ErrorCode;
    private static VersionRange VersionRequiringSSU;
    private static VersionRange SunValley1VersionRange;
    private static Version SSUVersion;
    private static string DetectionRegistryKey;
    private static string KBUrl;
    private IMachineService machineService;
    private IOperatingSystem operatingSystem;
    private IRegistry registry;
    private PrecheckParameters parameters;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public static PrecheckSupport PrecheckSupport { get; }
    public string Name { get; }
    public ArmSSUCheck(IServiceProvider services, PrecheckParameters parameters);
    private static ArmSSUCheck();
    public static PrecheckSupport get_PrecheckSupport();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [NullableContextAttribute("2")]
public sealed virtual IValidationResult Evaluate();
    private Version DetectServicingVersion();
    private bool ShouldRunCheck();
    private bool IsProductVersionRequiringSSU();
    private bool IsOperatingSystemRequiringSSU();
    private bool IsUninstall();
    private bool IsArmMachine();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Validation.BackgroundDownloadPrecheck : object {
    public static bool DefaultFeatureEnabled;
    private static int ErrorCode;
    private int unknownStatus;
    private IServiceProvider services;
    private IFileSystem fileSystem;
    private IOperatingSystem operatingSystem;
    private IQuery query;
    private double defaultBatteryPercentage;
    private double defaultDiskSpacePercentage;
    private long defaultDiskSpaceSize;
    [NullableAttribute("2")]
private IRemoteSettingsService remoteSettingsService;
    private PrecheckParameters parameters;
    [CompilerGeneratedAttribute]
private RemoteSettingsVariables <RemoteSettingsVariables>k__BackingField;
    [CompilerGeneratedAttribute]
private BackgroundDownloadPrecheckMode <Mode>k__BackingField;
    public static PrecheckSupport PrecheckSupport { get; }
    public string Name { get; }
    public RemoteSettingsVariables RemoteSettingsVariables { get; private set; }
    public BackgroundDownloadPrecheckMode Mode { get; public set; }
    public BackgroundDownloadPrecheck(IServiceProvider services, PrecheckParameters precheckParameters);
    private static BackgroundDownloadPrecheck();
    public static PrecheckSupport get_PrecheckSupport();
    public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public RemoteSettingsVariables get_RemoteSettingsVariables();
    [CompilerGeneratedAttribute]
private void set_RemoteSettingsVariables(RemoteSettingsVariables value);
    [CompilerGeneratedAttribute]
public BackgroundDownloadPrecheckMode get_Mode();
    [CompilerGeneratedAttribute]
public void set_Mode(BackgroundDownloadPrecheckMode value);
    private void Initialize();
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Validation.BackgroundDownloadPrecheck/<InitializeRemoteSettingsAsync>d__26")]
private Task InitializeRemoteSettingsAsync();
    [NullableContextAttribute("2")]
public sealed virtual IValidationResult Evaluate();
    [NullableContextAttribute("2")]
private IValidationResult StartCheck();
    [NullableContextAttribute("2")]
private IValidationResult ReoccurringCheck();
    [NullableContextAttribute("2")]
private IValidationResult FeatureSwitchCheck();
    [NullableContextAttribute("2")]
private IValidationResult InstancesCheck();
    [NullableContextAttribute("2")]
private IValidationResult PolicyCheck();
    [NullableContextAttribute("2")]
private IValidationResult MeteredConnectionCheck();
    [NullableContextAttribute("2")]
private IValidationResult BatteryCheck();
    [NullableContextAttribute("2")]
private IValidationResult TempSpaceCheck();
}
public enum Microsoft.VisualStudio.Setup.Validation.BackgroundDownloadPrecheckMode : Enum {
    public int value__;
    public static BackgroundDownloadPrecheckMode None;
    public static BackgroundDownloadPrecheckMode Start;
    public static BackgroundDownloadPrecheckMode Intermediate;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Validation.Connectivity : object {
    private static int ErrorCode;
    private IServiceProvider services;
    [NullableAttribute("2")]
private ISettingsService settingService;
    [NullableAttribute("2")]
private string installationPath;
    private bool isLayoutSet;
    private ExecuteAction bootstrapperAction;
    [NullableAttribute("2")]
private IQuery query;
    private PrecheckSupport currentSupport;
    private IsConnected getConnectedState;
    public static PrecheckSupport PrecheckSupport { get; }
    public string Name { get; }
    internal Connectivity(IServiceProvider services, PrecheckParameters precheckParameters, IsConnected d);
    private static Connectivity();
    public static PrecheckSupport get_PrecheckSupport();
    public sealed virtual string get_Name();
    [NullableContextAttribute("2")]
public sealed virtual IValidationResult Evaluate();
}
internal static class Microsoft.VisualStudio.Setup.Validation.Constants : object {
    [NullableAttribute("1")]
public static string VisuaStudioArmDocumentationLink;
    private static Constants();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Validation.DriveAccessibilityCheck : object {
    private static int DriveAccessibilityErrorCode;
    [NullableAttribute("2")]
private ILogger logger;
    private IPolicyService policyService;
    private IFileSystem fileSystem;
    private ExecuteAction bootStrapperAction;
    [NullableAttribute("2")]
private string installationPath;
    public static PrecheckSupport PrecheckSupport { get; }
    public string Name { get; }
    internal DriveAccessibilityCheck(IServiceProvider services, PrecheckParameters precheckParameters);
    public static PrecheckSupport get_PrecheckSupport();
    public sealed virtual string get_Name();
    [NullableContextAttribute("2")]
public sealed virtual IValidationResult Evaluate();
    [NullableContextAttribute("2")]
private bool DriveExists(string drivePath);
}
[JsonConverterAttribute("Newtonsoft.Json.Converters.StringEnumConverter")]
public enum Microsoft.VisualStudio.Setup.Validation.DrivePathType : Enum {
    public int value__;
    public static DrivePathType Cache;
    public static DrivePathType Shared;
    public static DrivePathType System;
    public static DrivePathType Target;
    public static DrivePathType SystemCache;
    public static DrivePathType Other;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Setup.Validation.DriveSpaceEvaluation : object {
    [CompilerGeneratedAttribute]
private long <CurrentInstallSize>k__BackingField;
    [CompilerGeneratedAttribute]
private long <RequestedDeltaSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasSufficientDiskSpace>k__BackingField;
    [CompilerGeneratedAttribute]
private long <AvailableDiskSpace>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <DriveName>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<DriveSpaceEvaluationSegment> <Segments>k__BackingField;
    public long CurrentInstallSize { get; public set; }
    public long RequestedDeltaSize { get; public set; }
    public bool HasSufficientDiskSpace { get; public set; }
    public long AvailableDiskSpace { get; public set; }
    [NullableAttribute("2")]
public string DriveName { get; public set; }
    public IList`1<DriveSpaceEvaluationSegment> Segments { get; }
    public DriveSpaceEvaluation(long currentInstallSize, long requestedDeltaSize, bool hasSufficientDiskSpace, string driveName);
    public DriveSpaceEvaluation(long currentInstallSize, long requestedDeltaSize, string driveName);
    [CompilerGeneratedAttribute]
public long get_CurrentInstallSize();
    [CompilerGeneratedAttribute]
public void set_CurrentInstallSize(long value);
    [CompilerGeneratedAttribute]
public long get_RequestedDeltaSize();
    [CompilerGeneratedAttribute]
public void set_RequestedDeltaSize(long value);
    [CompilerGeneratedAttribute]
public bool get_HasSufficientDiskSpace();
    [CompilerGeneratedAttribute]
public void set_HasSufficientDiskSpace(bool value);
    [CompilerGeneratedAttribute]
public long get_AvailableDiskSpace();
    [CompilerGeneratedAttribute]
public void set_AvailableDiskSpace(long value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_DriveName();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_DriveName(string value);
    [CompilerGeneratedAttribute]
public IList`1<DriveSpaceEvaluationSegment> get_Segments();
    public sealed virtual bool Equals(DriveSpaceEvaluation other);
}
public class Microsoft.VisualStudio.Setup.Validation.DriveSpaceEvaluationSegment : object {
    [CompilerGeneratedAttribute]
private DrivePathType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Actual>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Requested>k__BackingField;
    public DrivePathType Type { get; public set; }
    public long Actual { get; public set; }
    public long Requested { get; public set; }
    [CompilerGeneratedAttribute]
public DrivePathType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(DrivePathType value);
    [CompilerGeneratedAttribute]
public long get_Actual();
    [CompilerGeneratedAttribute]
public void set_Actual(long value);
    [CompilerGeneratedAttribute]
public long get_Requested();
    [CompilerGeneratedAttribute]
public void set_Requested(long value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Validation.Elevation : object {
    private static int ErrorCode;
    private IProcessService service;
    public static PrecheckSupport PrecheckSupport { get; }
    public string Name { get; }
    internal Elevation(IServiceProvider services);
    private static Elevation();
    public static PrecheckSupport get_PrecheckSupport();
    public sealed virtual string get_Name();
    [NullableContextAttribute("2")]
public sealed virtual IValidationResult Evaluate();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Validation.ExperimentValidator : object {
    private static string Extension;
    private IServiceProvider services;
    private Catalog catalog;
    [NullableAttribute("2")]
private ILogger logger;
    [NullableAttribute("2")]
private IFileSystem fileSystem;
    public ExperimentValidator(IServiceProvider services, Catalog catalog);
    private static ExperimentValidator();
    public sealed virtual IEnumerable`1<IValidationResult> Validate(Stream stream);
    public sealed virtual IEnumerable`1<IValidationResult> Validate(string content);
    private IEnumerable`1<IValidationResult> Validate(Stream file, string path);
    [NullableContextAttribute("2")]
private IValidationResult CheckSignature(Stream file, string path);
    [NullableContextAttribute("2")]
private IValidationResult CheckApplicability();
    private void Initialize();
}
[ExtensionAttribute]
internal static class Microsoft.VisualStudio.Setup.Validation.Extensions : object {
    [ExtensionAttribute]
public static void ThrowIfErrors(IEnumerable`1<IValidationResult> source);
}
[NullableContextAttribute("1")]
internal interface Microsoft.VisualStudio.Setup.Validation.IPrecheckEvaluator {
    public string Name { get; }
    public abstract virtual string get_Name();
    [NullableContextAttribute("2")]
public abstract virtual IValidationResult Evaluate();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Validation.ManifestValidatorFactory : object {
    private IServiceProvider services;
    public ManifestValidatorFactory(IServiceProvider services);
    public sealed virtual IManifestValidator Create(Catalog catalog, PartialManifestType& manifestType, PartialManifestType defaultValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Validation.MicrosoftUpdateCommonPrechecks : object {
    private IQuery query;
    private ILogger logger;
    private IRegistry registry;
    private IPolicyService policy;
    public string Name { get; }
    internal MicrosoftUpdateCommonPrechecks(IServiceProvider services);
    public sealed virtual string get_Name();
    [NullableContextAttribute("2")]
public sealed virtual IValidationResult Evaluate();
    private bool RegKeyHasNonZeroValue(IRegistry registry, string regValueName, ISet`1<string> registryKeyPaths);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Validation.MsiAvailabilityCheck : object {
    private static int TestingMSIErrorCode;
    private static string TestingMsiPath;
    private static string MsiProperties;
    private static string MsiLogName;
    [NullableAttribute("2")]
private ILogger logger;
    private IFileSystem fileSystem;
    private ExecuteAction bootStrapperAction;
    private IWindowsInstallerService windowsInstallerService;
    private ISignatureVerifierManager signatureManager;
    [NullableAttribute("2")]
private ITelemetry telemetry;
    private bool hasMSIToBeApplied;
    public static PrecheckSupport PrecheckSupport { get; }
    public string Name { get; }
    internal MsiAvailabilityCheck(IServiceProvider services, PrecheckParameters precheckParameters);
    public static PrecheckSupport get_PrecheckSupport();
    public sealed virtual string get_Name();
    [NullableContextAttribute("2")]
public sealed virtual IValidationResult Evaluate();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Validation.OutOfSupportSelectablesCheck : object {
    private static int ErrorCode;
    private static string OosPolicyYear;
    private IServiceProvider services;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEnumerable`1<ISelectablePackage> outOfSupportSelectables;
    [NullableAttribute("2")]
private ITelemetryOperation telemetryOperation;
    public static PrecheckSupport PrecheckSupport { get; }
    public string Name { get; }
    internal OutOfSupportSelectablesCheck(IServiceProvider services, PrecheckParameters precheckParameters);
    private static OutOfSupportSelectablesCheck();
    public static PrecheckSupport get_PrecheckSupport();
    public sealed virtual string get_Name();
    [NullableContextAttribute("2")]
public sealed virtual IValidationResult Evaluate();
    private static IEnumerable`1<string> GetOutOfSupportSelectablesMarkdown(IEnumerable`1<string> packages);
}
internal class Microsoft.VisualStudio.Setup.Validation.PrecheckEvaluatorFactory : object {
    private static PrecheckEvaluatorFactory instance;
    private BackgroundDownloadPrecheck backgroundDownloadPrecheck;
    internal static IPrecheckEvaluatorFactory Default { get; }
    internal static IPrecheckEvaluatorFactory get_Default();
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Setup.Validation.PrecheckEvaluatorFactory/<GetPrecheckEvaluators>d__4")]
public sealed virtual IEnumerable`1<IPrecheckEvaluator> GetPrecheckEvaluators(IServiceProvider services, PrecheckParameters precheckParams, VariableCollection properties);
    private static bool GetConnectedState(Int32& output, int input);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Setup.Validation.PrecheckParameters : object {
    [CompilerGeneratedAttribute]
private string <InstallationPath>k__BackingField;
    [CompilerGeneratedAttribute]
private InstallSize <InstallSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLayoutSet>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasMSIToBeApplied>k__BackingField;
    [CompilerGeneratedAttribute]
private Product <Product>k__BackingField;
    [CompilerGeneratedAttribute]
private ExecuteAction <BootstrapperAction>k__BackingField;
    [CompilerGeneratedAttribute]
private IQuery <Query>k__BackingField;
    [CompilerGeneratedAttribute]
private ITelemetryOperation <Operation>k__BackingField;
    [CompilerGeneratedAttribute]
private PrecheckSupport <PrecheckSupport>k__BackingField;
    [CompilerGeneratedAttribute]
private BackgroundDownloadPrecheckMode <BackgroundDownloadMode>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IEnumerable`1<string> <RelatedProcessDirectories>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IEnumerable`1<string> <RelatedProcessFiles>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IEnumerable`1<string> <RelatedServices>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IEnumerable`1<string> <NonCriticalProcesses>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyCollection`1<IActivity> <PackagesToInstall>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyCollection`1<IActivity> <PackagesToUninstall>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyCollection`1<IDownloadPackageActivity> <PackagesToDownload>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IEnumerable`1<ISelectablePackage> <OutOfSupportSelectables>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserRequestedOperation>k__BackingField;
    public string InstallationPath { get; public set; }
    public InstallSize InstallSize { get; public set; }
    public bool IsLayoutSet { get; public set; }
    public bool HasMSIToBeApplied { get; public set; }
    public Product Product { get; public set; }
    public ExecuteAction BootstrapperAction { get; public set; }
    public IQuery Query { get; public set; }
    public ITelemetryOperation Operation { get; public set; }
    public PrecheckSupport PrecheckSupport { get; public set; }
    public BackgroundDownloadPrecheckMode BackgroundDownloadMode { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<string> RelatedProcessDirectories { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<string> RelatedProcessFiles { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<string> RelatedServices { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<string> NonCriticalProcesses { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal IReadOnlyCollection`1<IActivity> PackagesToInstall { get; internal set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal IReadOnlyCollection`1<IActivity> PackagesToUninstall { get; internal set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal IReadOnlyCollection`1<IDownloadPackageActivity> PackagesToDownload { get; internal set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal IEnumerable`1<ISelectablePackage> OutOfSupportSelectables { get; internal set; }
    internal string UserRequestedOperation { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_InstallationPath();
    [CompilerGeneratedAttribute]
public void set_InstallationPath(string value);
    [CompilerGeneratedAttribute]
public InstallSize get_InstallSize();
    [CompilerGeneratedAttribute]
public void set_InstallSize(InstallSize value);
    [CompilerGeneratedAttribute]
public bool get_IsLayoutSet();
    [CompilerGeneratedAttribute]
public void set_IsLayoutSet(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasMSIToBeApplied();
    [CompilerGeneratedAttribute]
public void set_HasMSIToBeApplied(bool value);
    [CompilerGeneratedAttribute]
public Product get_Product();
    [CompilerGeneratedAttribute]
public void set_Product(Product value);
    [CompilerGeneratedAttribute]
public ExecuteAction get_BootstrapperAction();
    [CompilerGeneratedAttribute]
public void set_BootstrapperAction(ExecuteAction value);
    [CompilerGeneratedAttribute]
public IQuery get_Query();
    [CompilerGeneratedAttribute]
public void set_Query(IQuery value);
    [CompilerGeneratedAttribute]
public ITelemetryOperation get_Operation();
    [CompilerGeneratedAttribute]
public void set_Operation(ITelemetryOperation value);
    [CompilerGeneratedAttribute]
public PrecheckSupport get_PrecheckSupport();
    [CompilerGeneratedAttribute]
public void set_PrecheckSupport(PrecheckSupport value);
    [CompilerGeneratedAttribute]
public BackgroundDownloadPrecheckMode get_BackgroundDownloadMode();
    [CompilerGeneratedAttribute]
public void set_BackgroundDownloadMode(BackgroundDownloadPrecheckMode value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_RelatedProcessDirectories();
    [CompilerGeneratedAttribute]
public void set_RelatedProcessDirectories(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_RelatedProcessFiles();
    [CompilerGeneratedAttribute]
public void set_RelatedProcessFiles(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_RelatedServices();
    [CompilerGeneratedAttribute]
public void set_RelatedServices(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_NonCriticalProcesses();
    [CompilerGeneratedAttribute]
public void set_NonCriticalProcesses(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
internal IReadOnlyCollection`1<IActivity> get_PackagesToInstall();
    [CompilerGeneratedAttribute]
internal void set_PackagesToInstall(IReadOnlyCollection`1<IActivity> value);
    [CompilerGeneratedAttribute]
internal IReadOnlyCollection`1<IActivity> get_PackagesToUninstall();
    [CompilerGeneratedAttribute]
internal void set_PackagesToUninstall(IReadOnlyCollection`1<IActivity> value);
    [CompilerGeneratedAttribute]
internal IReadOnlyCollection`1<IDownloadPackageActivity> get_PackagesToDownload();
    [CompilerGeneratedAttribute]
internal void set_PackagesToDownload(IReadOnlyCollection`1<IDownloadPackageActivity> value);
    [CompilerGeneratedAttribute]
internal IEnumerable`1<ISelectablePackage> get_OutOfSupportSelectables();
    [CompilerGeneratedAttribute]
internal void set_OutOfSupportSelectables(IEnumerable`1<ISelectablePackage> value);
    [CompilerGeneratedAttribute]
internal string get_UserRequestedOperation();
    [CompilerGeneratedAttribute]
internal void set_UserRequestedOperation(string value);
}
[FlagsAttribute]
public enum Microsoft.VisualStudio.Setup.Validation.PrecheckSupport : Enum {
    public int value__;
    public static PrecheckSupport None;
    public static PrecheckSupport Download;
    public static PrecheckSupport Install;
    public static PrecheckSupport BackgroundDownload;
    public static PrecheckSupport BackgroundDownloadSpecific;
    public static PrecheckSupport NoWebInstall;
    public static PrecheckSupport Hotload;
    public static PrecheckSupport All;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Validation.ProcessComparer : object {
    [NullableAttribute("1")]
public static ProcessComparer Default;
    private static ProcessComparer();
    public sealed virtual bool Equals(IProcess x, IProcess y);
    [ExcludeFromCodeCoverageAttribute]
public sealed virtual int GetHashCode(IProcess obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.VisualStudio.Setup.Validation.RegistryCheck : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEnumerable`1<IInstallablePackage> installablePackages;
    private string packageName;
    private IServiceProvider services;
    [CompilerGeneratedAttribute]
private IRegistry <Registry>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    public string Name { get; }
    protected IRegistry Registry { get; private set; }
    protected bool IsPackageInstallable { get; }
    protected ILogger Logger { get; private set; }
    internal RegistryCheck(IServiceProvider serviceProvider, PrecheckParameters precheckParameters, string package);
    public abstract virtual string get_Name();
    [CompilerGeneratedAttribute]
protected IRegistry get_Registry();
    [CompilerGeneratedAttribute]
private void set_Registry(IRegistry value);
    protected bool get_IsPackageInstallable();
    [CompilerGeneratedAttribute]
protected ILogger get_Logger();
    [CompilerGeneratedAttribute]
private void set_Logger(ILogger value);
    [NullableContextAttribute("2")]
public abstract virtual IValidationResult Evaluate();
    protected bool TryGetRegistryKeyValue(IRegistryKey subKey, string registryEntryName, Nullable`1& registryValue);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <get_IsPackageInstallable>b__10_0(IInstallablePackage x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Validation.RegistryCheckWebView2 : RegistryCheck {
    private static int ErrorCode;
    internal static PrecheckSupport PrecheckSupport { get; }
    internal static string EdgeUpdateRegistryKey { get; }
    internal static string InstallRegistryEntryName { get; }
    internal static string InstallDefaultRegistryEntryName { get; }
    internal static string PackageName { get; }
    public string Name { get; }
    internal RegistryCheckWebView2(IServiceProvider services, PrecheckParameters precheckParameters);
    internal static PrecheckSupport get_PrecheckSupport();
    internal static string get_EdgeUpdateRegistryKey();
    internal static string get_InstallRegistryEntryName();
    internal static string get_InstallDefaultRegistryEntryName();
    internal static string get_PackageName();
    public virtual string get_Name();
    [NullableContextAttribute("2")]
public virtual IValidationResult Evaluate();
}
internal class Microsoft.VisualStudio.Setup.Validation.RemoteSettingsVariables : object {
    [CompilerGeneratedAttribute]
private long <MinDiskSpaceRemaining>k__BackingField;
    [CompilerGeneratedAttribute]
private double <BatteryPercentage>k__BackingField;
    public long MinDiskSpaceRemaining { get; public set; }
    public double BatteryPercentage { get; public set; }
    [CompilerGeneratedAttribute]
public long get_MinDiskSpaceRemaining();
    [CompilerGeneratedAttribute]
public void set_MinDiskSpaceRemaining(long value);
    [CompilerGeneratedAttribute]
public double get_BatteryPercentage();
    [CompilerGeneratedAttribute]
public void set_BatteryPercentage(double value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Validation.SizePreCheckEvaluator : object {
    private static int ErrorCode;
    public static long NotEnoughSpaceErrorBytes;
    public static double NotEnoughSpaceErrorPercent;
    private IServiceProvider services;
    [NullableAttribute("2")]
private string installationPath;
    private ExecuteAction bootstrapperAction;
    [NullableAttribute("2")]
private InstallSize installSize;
    [NullableAttribute("2")]
private VariableCollection properties;
    public static PrecheckSupport PrecheckSupport { get; }
    public string Name { get; }
    public SizePreCheckEvaluator(IServiceProvider services, PrecheckParameters precheckParameters, VariableCollection properties);
    private static SizePreCheckEvaluator();
    public static PrecheckSupport get_PrecheckSupport();
    public sealed virtual string get_Name();
    [NullableContextAttribute("2")]
public sealed virtual IValidationResult Evaluate();
    internal bool InsufficientSpaceIsError(IEnumerable`1<DriveSpaceEvaluation> drives);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.Validation.SizePreCheckEvaluator/<GetLimitForErrorAsync>d__15")]
private Task`1<double> GetLimitForErrorAsync(long requestedDeltaSize);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Validation.SoftRebootStatusCheck : object {
    private static int SoftRebootErrorCode;
    private IEnumerable`1<string> vcPackages;
    private IRestartManager restartManager;
    [NullableAttribute("2")]
private ILogger logger;
    [NullableAttribute("2")]
private ITelemetry telemetry;
    private IQueryFactory queryFactory;
    private PrecheckParameters precheckParameters;
    public static PrecheckSupport PrecheckSupport { get; }
    public string Name { get; }
    internal SoftRebootStatusCheck(IServiceProvider services, PrecheckParameters precheckParameters);
    public static PrecheckSupport get_PrecheckSupport();
    public sealed virtual string get_Name();
    [NullableContextAttribute("2")]
public sealed virtual IValidationResult Evaluate();
    private bool IsVcPackageInvolved();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <IsVcPackageInvolved>b__13_6(string p);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <IsVcPackageInvolved>b__13_7(string p);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Validation.TargetDirCheck : object {
    private static int ErrorCode;
    private IServiceProvider services;
    [NullableAttribute("2")]
private string installationPath;
    private ExecuteAction bootstrapperAction;
    [NullableAttribute("2")]
private IQuery query;
    public static PrecheckSupport PrecheckSupport { get; }
    public string Name { get; }
    public TargetDirCheck(IServiceProvider services, PrecheckParameters precheckParameters);
    private static TargetDirCheck();
    public static PrecheckSupport get_PrecheckSupport();
    public sealed virtual string get_Name();
    [NullableContextAttribute("2")]
public sealed virtual IValidationResult Evaluate();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Validation.UnsupportedOSCheck : object {
    private static int UnsupportedOSErrorCode;
    private static int BlockedOSErrorCode;
    private static IList`1<UnsupportedVersionRange> VersionRangeMapping;
    private static string IncompatibleOSDocumentationPathHeader;
    private static string IncompatibleOSDocumentationRelativePath;
    private IOperatingSystem operatingSystem;
    [NullableAttribute("2")]
private ILogger logger;
    private IPolicyService policyService;
    private Version currentVSVersion;
    [NullableAttribute("2")]
private string userRequestedOperation;
    public static PrecheckSupport PrecheckSupport { get; }
    public string Name { get; }
    internal UnsupportedOSCheck(IServiceProvider services, PrecheckParameters precheckParameters);
    private static UnsupportedOSCheck();
    public static PrecheckSupport get_PrecheckSupport();
    public sealed virtual string get_Name();
    [NullableContextAttribute("2")]
public sealed virtual IValidationResult Evaluate();
    private bool IsServerOS();
    private bool IsWithinUnsupportedOSRange(VersionRange winVersionRange);
    private bool IsRunningApplicationServerMode();
    private UnsupportedVersionRange GetUnsupportedVersionRangeMapping(Version vsVersion);
    [NullableContextAttribute("2")]
private bool IsInstall(string operation);
    [NullableContextAttribute("2")]
private bool IsUpdate(string operation);
    [NullableContextAttribute("2")]
private bool IsInstallOrUpdate(string operation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Setup.Validation.ValidationException : EngineException {
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<IValidationResult> <Results>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IValidationResult> <EngineResults>k__BackingField;
    public IReadOnlyCollection`1<IValidationResult> Results { get; }
    internal IList`1<IValidationResult> EngineResults { get; }
    public ValidationException(IEnumerable`1<IValidationResult> results);
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<IValidationResult> get_Results();
    [CompilerGeneratedAttribute]
internal IList`1<IValidationResult> get_EngineResults();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Validation.ValidationResult : object {
    private string resourceId;
    private Object[] resourceArgs;
    private ResourceManager resourceManager;
    [CompilerGeneratedAttribute]
private string <TelemetryErrorMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsWarning>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Exception <Error>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IManifest <Manifest>k__BackingField;
    [CompilerGeneratedAttribute]
private WarningLevel <WarningLevel>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IEnumerable`1<IPackageIdentity> <Microsoft.VisualStudio.Setup.Validation.IValidationResult.Items>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ErrorCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportsRetry>k__BackingField;
    public string Message { get; }
    public string NeutralMessage { get; }
    public string TelemetryErrorMessage { get; }
    public bool IsWarning { get; internal set; }
    [NullableAttribute("2")]
public Exception Error { get; internal set; }
    [NullableAttribute("2")]
public IManifest Manifest { get; internal set; }
    public WarningLevel WarningLevel { get; internal set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEnumerable`1<IPackageIdentity> Microsoft.VisualStudio.Setup.Validation.IValidationResult.Items { get; }
    public int ErrorCode { get; internal set; }
    public bool SupportsRetry { get; internal set; }
    internal ValidationResult(ResourceManager resourceManager, string resourceId, Object[] args);
    internal ValidationResult(string telemetrySafeMessage, ResourceManager resourceManager, string resourceId, Object[] args);
    public sealed virtual string get_Message();
    public sealed virtual string get_NeutralMessage();
    [CompilerGeneratedAttribute]
public sealed virtual string get_TelemetryErrorMessage();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsWarning();
    [CompilerGeneratedAttribute]
internal void set_IsWarning(bool value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual Exception get_Error();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_Error(Exception value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual IManifest get_Manifest();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_Manifest(IManifest value);
    [CompilerGeneratedAttribute]
public sealed virtual WarningLevel get_WarningLevel();
    [CompilerGeneratedAttribute]
internal void set_WarningLevel(WarningLevel value);
    [CompilerGeneratedAttribute]
private sealed virtual override IEnumerable`1<IPackageIdentity> Microsoft.VisualStudio.Setup.Validation.IValidationResult.get_Items();
    [CompilerGeneratedAttribute]
public sealed virtual int get_ErrorCode();
    [CompilerGeneratedAttribute]
internal void set_ErrorCode(int value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SupportsRetry();
    [CompilerGeneratedAttribute]
internal void set_SupportsRetry(bool value);
    private string GetFormattedMessage(IFormatProvider formatProvider, string str);
    private string GetTelemetryErrorMessage(string telemetrySafeMessage);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Validation.VerifySourcePayloads : object {
    private static int ConcurrentActions;
    private static int ErrorCode;
    private IServiceProvider services;
    private ISet`1<IInstallablePackage> downloadingPackages;
    private IEnumerable`1<IInstallablePackage> uninstallingPackages;
    public static PrecheckSupport PrecheckSupport { get; }
    public string Name { get; }
    internal VerifySourcePayloads(IServiceProvider services, PrecheckParameters precheckParameters);
    private static VerifySourcePayloads();
    public static PrecheckSupport get_PrecheckSupport();
    public sealed virtual string get_Name();
    [NullableContextAttribute("2")]
public sealed virtual IValidationResult Evaluate();
    private void IdentifyMissingOrInvalidPackagesInLayout(IServiceProvider services, IEnumerable`1<IInstallablePackage> packagesToVerify, IList`1<IInstallablePackage> missingOrInvalidPackages);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.Validation.VSProcessesRunning : object {
    private static ISet`1<string> AllowedProcesses;
    private static string AllowedProcessPrefix;
    private static int ErrorCode;
    private bool updateFromVS;
    private string installationPath;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEnumerable`1<string> relatedProcessDirectories;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEnumerable`1<string> relatedProcessFiles;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEnumerable`1<string> relatedServices;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEnumerable`1<string> nonCriticalProcesses;
    private IServiceProvider services;
    [NullableAttribute("2")]
private ITelemetryOperation telemetryOperation;
    public static PrecheckSupport PrecheckSupport { get; }
    public string Name { get; }
    internal VSProcessesRunning(IServiceProvider services, PrecheckParameters precheckParameters);
    private static VSProcessesRunning();
    public static PrecheckSupport get_PrecheckSupport();
    public sealed virtual string get_Name();
    [NullableContextAttribute("2")]
public sealed virtual IValidationResult Evaluate();
    private string GetTelemetrySafeMessage(ISet`1<string> processNames);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Microsoft.VisualStudio.Setup.VariableCollection : object {
    internal static StringComparer Comparer;
    private IObservableDictionary`2<string, Variable> reserved;
    private IObservableDictionary`2<string, UserValue> user;
    private ReaderWriterLockSlim collectionLock;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<NotifyCollectionChangedEventArgs`1<KeyValuePair`2<string, string>>> CollectionChanged;
    public int Count { get; }
    [NullableAttribute("2")]
public string Item { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<string, string>> PersistedUserVariables { get; }
    private IEnumerable`1<string> System.Collections.Generic.IReadOnlyDictionary<System.String,System.String>.Keys { get; }
    private IEnumerable`1<string> System.Collections.Generic.IReadOnlyDictionary<System.String,System.String>.Values { get; }
    private static VariableCollection();
    [CompilerGeneratedAttribute]
public sealed virtual void add_CollectionChanged(EventHandler`1<NotifyCollectionChangedEventArgs`1<KeyValuePair`2<string, string>>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CollectionChanged(EventHandler`1<NotifyCollectionChangedEventArgs`1<KeyValuePair`2<string, string>>> value);
    public sealed virtual int get_Count();
    public sealed virtual string get_Item(string name);
    public void set_Item(string name, string value);
    public void Add(string name, string value, bool persist);
    public bool Contains(string name);
    [NullableContextAttribute("2")]
public T Get(string name, T default);
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.Setup.VariableCollection/<GetEnumerator>d__16")]
public IEnumerator`1<KeyValuePair`2<string, string>> GetEnumerator();
    public IEnumerable`1<KeyValuePair`2<string, string>> get_PersistedUserVariables();
    public IDictionary`2<string, string> ToDictionary();
    internal void Add(string name, Func`1<string> initialize);
    internal void Add(string name, bool cache, Func`1<string> initialize);
    private sealed virtual override IEnumerable`1<string> System.Collections.Generic.IReadOnlyDictionary<System.String,System.String>.get_Keys();
    private sealed virtual override IEnumerable`1<string> System.Collections.Generic.IReadOnlyDictionary<System.String,System.String>.get_Values();
    private sealed virtual override bool System.Collections.Generic.IReadOnlyDictionary<System.String,System.String>.ContainsKey(string key);
    private sealed virtual override bool System.Collections.Generic.IReadOnlyDictionary<System.String,System.String>.TryGetValue(string key, String& value);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<string, string>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,System.String>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private static KeyValuePair`2<TKey, TValue> MakeKeyValuePair(TKey key, TValue value);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <.ctor>b__4_0(object source, NotifyCollectionChangedEventArgs`1<KeyValuePair`2<string, Variable>> args);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <.ctor>b__4_1(object source, NotifyCollectionChangedEventArgs`1<KeyValuePair`2<string, UserValue>> args);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.VerifyLayoutOperation : LayoutOperationBase {
    private static int ConcurrentActions;
    private AsyncCoordinator parallelVerifies;
    private AsyncCoordinator parallelCleans;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentBag`1<string> missingPayloads;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentBag`1<string> invalidPayloads;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEnumerable`1<VerifyPackage> verifyPackages;
    public long DownloadSize { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyCollection`1<DownloadPackage> PackagesToDownload { get; }
    internal VerifyLayoutOperation(IServiceProvider services, ISet`1<IPackage> packages, LayoutContext layoutContext);
    private static VerifyLayoutOperation();
    public virtual long get_DownloadSize();
    public virtual IReadOnlyCollection`1<DownloadPackage> get_PackagesToDownload();
    public virtual void Run(CancellationToken token);
    protected virtual void PlanOperation();
    private void ReportMessages(IEnumerable`1<string> messageBag, string neutralMessageContent, string localizedMessageContent);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <PlanOperation>b__12_0(IInstallablePackage p);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private VerifyPackage <PlanOperation>b__12_1(IInstallablePackage p);
}
public class Microsoft.VisualStudio.Setup.VsixLoadException : LocalizedException {
    [NullableContextAttribute("1")]
public VsixLoadException(ResourceManager resourceManager, string resourceId, Object[] args);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.WeakEventHandler`1 : object {
    private WeakReference targetRef;
    private MethodInfo method;
    public WeakEventHandler`1(EventHandler`1<TEventArgs> callback);
    public void Handler(object sender, TEventArgs args);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Microsoft.VisualStudio.Setup.WellKnownPropertyNames : object {
    public static string ChannelSuffix;
    public static string ChannelTitle;
    public static string ChannelManifestId;
    public static string ChannelManifestBuildVersion;
    public static string ChannelProductVersion;
    public static string ChannelReleasenoteUrl;
    public static string AdvertisedPackages;
    public static string UpdateRequiresInstallerUpdate;
    public static string HasUpdate;
    public static string DefaultProgram;
    public static string Nickname;
    public static string ProductDisplayVersion;
    public static string ProductKey;
    public static string ProductSemanticVersion;
    public static string PlanFile;
    public static string AlphaPacksCount;
    public static string CampaignId;
    public static string Canceled;
    public static string AutoUpdate;
    public static string OperationMode;
    public static string UserOperationMode;
    public static string UpdateDownloadTotalSize;
    public static string UpdateDownloadedSize;
    public static string UpdateDownloadComplete;
    public static string UpdateDownloadVersion;
    public static string UserSettingKey;
    public static string LastSuccessfulCheckUTC;
    public static string LastDownloadSize;
    public static string LastInstallSize;
    public static string LastInstallPackageCount;
    public static string LastSelectionState;
    public static string LastExecuteAction;
    public static string LastUserRequestedAction;
    public static string LastAppliedPackageId;
    public static string LastOperationState;
    public static string IsPreDynamicEndpoint;
    public static string RollbackExemptExtensions;
    public static string RemoveOosProperty;
    public static string DisableRollbackProperty;
    public static string IncludeRecommendedProperty;
    private static WellKnownPropertyNames();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.VisualStudio.Setup.WindowsException : EngineException {
    private int error;
    [NullableAttribute("2")]
private string message;
    [NullableAttribute("2")]
private string neutralMessage;
    public int NativeErrorCode { get; }
    public string Message { get; }
    public string NeutralMessage { get; }
    public WindowsException(int error);
    protected WindowsException(SerializationInfo info, StreamingContext context);
    public sealed virtual int get_NativeErrorCode();
    public virtual string get_Message();
    public virtual string get_NeutralMessage();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private string <get_Message>b__8_0();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private string <get_NeutralMessage>b__10_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.VisualStudio.Setup.WorkloadOverridesProvider : object {
    private CancellationTokenSource cancellationToken;
    [NullableAttribute("2")]
private ITelemetry telemetry;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Task`1<IList`1<TargetedNotificationsAction`1<WorkloadOverrides>>> <InitializeTask>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal Task`1<IList`1<TargetedNotificationsAction`1<WorkloadOverrides>>> InitializeTask { get; }
    public WorkloadOverridesProvider(ITargetedNotificationsService service, ITelemetry telemetry);
    public sealed virtual WorkloadOverrides GetOverrides(string channelId, int waitTimeInMilliseconds);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.WorkloadOverridesProvider/<GetOverridesAsync>d__4")]
public sealed virtual Task`1<WorkloadOverrides> GetOverridesAsync(string channelId, int waitTimeInMilliseconds);
    [CompilerGeneratedAttribute]
internal Task`1<IList`1<TargetedNotificationsAction`1<WorkloadOverrides>>> get_InitializeTask();
    private WorkloadOverrides GetOverridesForChannel(string channelId, IList`1<TargetedNotificationsAction`1<WorkloadOverrides>> overrides);
    [AsyncStateMachineAttribute("Microsoft.VisualStudio.Setup.WorkloadOverridesProvider/<FetchTargetedNotifications>d__9")]
private Task`1<IList`1<TargetedNotificationsAction`1<WorkloadOverrides>>> FetchTargetedNotifications(ITargetedNotificationsService service, ITelemetry telemetry);
    [NullableContextAttribute("2")]
private void SetOverrideTelemetryProperties(ITelemetry telemetry, IEnumerable`1<TargetedNotificationsAction`1<WorkloadOverrides>> actions);
}
[AttributeUsageAttribute("2240")]
internal class System.Diagnostics.CodeAnalysis.UnscopedRefAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NativeIntegerAttribute : Attribute {
    public Boolean[] TransformFlags;
    public NativeIntegerAttribute(Boolean[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[GeneratedCodeAttribute("Nerdbank.GitVersioning.Tasks", "3.2.31.56335")]
[ExcludeFromCodeCoverageAttribute]
internal static class ThisAssembly : object {
    internal static string AssemblyVersion;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyConfiguration;
    internal static string GitCommitId;
    internal static string PublicKey;
    internal static string PublicKeyToken;
    internal static bool IsPublicRelease;
    internal static bool IsPrerelease;
    internal static DateTime GitCommitDate;
    internal static string RootNamespace;
    private static ThisAssembly();
}
internal class UsedDriveSpace : object {
    private bool logWatermark;
    private ILogger logger;
    private string measurementScope;
    private string sharedDirectory;
    private long usedSystemSpace;
    private long usedSharedSpace;
    private long usedTargetSpace;
    internal static UsedDriveSpace MeasureSpaceBeforeOperation(string targetDir, IServiceProvider services, IEngineContext engineContext, ITelemetryOperation telemetryOperation, bool logWatermark, string measurementScope);
    internal UsedDriveSpace MeasureSpaceAfterOperation(ITelemetryOperation operation, string targetDir, IEngineContext engineContext);
}
[DefaultMemberAttribute("Item")]
internal class Windows.Win32.__char_1 : ValueType {
    private static int SpanLength;
    [FixedBufferAttribute("System.Char", "1")]
internal <Value>e__FixedBuffer Value;
    internal int Length { get; }
    [UnscopedRefAttribute]
internal Char& Item { get; }
    [IsReadOnlyAttribute]
internal int get_Length();
    internal Char& get_Item(int index);
    [IsReadOnlyAttribute]
internal void CopyTo(Span`1<char> target, int length);
    [IsReadOnlyAttribute]
internal Char[] ToArray(int length);
    [IsReadOnlyAttribute]
internal bool Equals(ReadOnlySpan`1<char> value);
    [IsReadOnlyAttribute]
internal bool Equals(string value);
    [IsReadOnlyAttribute]
internal string ToString(int length);
    [IsReadOnlyAttribute]
public virtual string ToString();
    public static __char_1 op_Implicit(string value);
    public static __char_1 op_Implicit(ReadOnlySpan`1<char> value);
}
[DefaultMemberAttribute("Item")]
internal class Windows.Win32.__char_14 : ValueType {
    private static int SpanLength;
    [FixedBufferAttribute("System.Char", "14")]
internal <Value>e__FixedBuffer Value;
    internal int Length { get; }
    [UnscopedRefAttribute]
internal Char& Item { get; }
    [IsReadOnlyAttribute]
internal int get_Length();
    internal Char& get_Item(int index);
    [IsReadOnlyAttribute]
internal void CopyTo(Span`1<char> target, int length);
    [IsReadOnlyAttribute]
internal Char[] ToArray(int length);
    [IsReadOnlyAttribute]
internal bool Equals(ReadOnlySpan`1<char> value);
    [IsReadOnlyAttribute]
internal bool Equals(string value);
    [IsReadOnlyAttribute]
internal string ToString(int length);
    [IsReadOnlyAttribute]
public virtual string ToString();
    public static __char_14 op_Implicit(string value);
    public static __char_14 op_Implicit(ReadOnlySpan`1<char> value);
}
[DefaultMemberAttribute("Item")]
internal class Windows.Win32.__char_260 : ValueType {
    private static int SpanLength;
    [FixedBufferAttribute("System.Char", "260")]
internal <Value>e__FixedBuffer Value;
    internal int Length { get; }
    [UnscopedRefAttribute]
internal Char& Item { get; }
    [IsReadOnlyAttribute]
internal int get_Length();
    internal Char& get_Item(int index);
    [IsReadOnlyAttribute]
internal void CopyTo(Span`1<char> target, int length);
    [IsReadOnlyAttribute]
internal Char[] ToArray(int length);
    [IsReadOnlyAttribute]
internal bool Equals(ReadOnlySpan`1<char> value);
    [IsReadOnlyAttribute]
internal bool Equals(string value);
    [IsReadOnlyAttribute]
internal string ToString(int length);
    [IsReadOnlyAttribute]
public virtual string ToString();
    public static __char_260 op_Implicit(string value);
    public static __char_260 op_Implicit(ReadOnlySpan`1<char> value);
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal class Windows.Win32.FindCloseSafeHandle : SafeHandle {
    private static IntPtr INVALID_HANDLE_VALUE;
    public bool IsInvalid { get; }
    internal FindCloseSafeHandle(IntPtr preexistingHandle, bool ownsHandle);
    private static FindCloseSafeHandle();
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{Value}")]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal class Windows.Win32.Foundation.BOOLEAN : ValueType {
    internal byte Value;
    internal BOOLEAN(byte value);
    internal BOOLEAN(bool value);
    public static byte op_Implicit(BOOLEAN value);
    public static BOOLEAN op_Explicit(byte value);
    public static bool op_Equality(BOOLEAN left, BOOLEAN right);
    public static bool op_Inequality(BOOLEAN left, BOOLEAN right);
    public sealed virtual bool Equals(BOOLEAN other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Implicit(BOOLEAN value);
    public static BOOLEAN op_Implicit(bool value);
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{Value}")]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal class Windows.Win32.Foundation.BSTR : ValueType {
    internal Char* Value;
    internal int Length { get; }
    internal BSTR(Char* value);
    public static Char* op_Implicit(BSTR value);
    public static BSTR op_Explicit(Char* value);
    public static bool op_Equality(BSTR left, BSTR right);
    public static bool op_Inequality(BSTR left, BSTR right);
    public sealed virtual bool Equals(BSTR other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static IntPtr op_Implicit(BSTR value);
    public static BSTR op_Explicit(IntPtr value);
    public static BSTR op_Explicit(UIntPtr value);
    internal int get_Length();
    public static ReadOnlySpan`1<char> op_Implicit(BSTR bstr);
    internal ReadOnlySpan`1<char> AsSpan();
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay}")]
internal class Windows.Win32.Foundation.PCSTR : ValueType {
    internal Byte* Value;
    internal int Length { get; }
    private string DebuggerDisplay { get; }
    internal PCSTR(Byte* value);
    public static Byte* op_Implicit(PCSTR value);
    public static PCSTR op_Explicit(Byte* value);
    public sealed virtual bool Equals(PCSTR other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal int get_Length();
    public virtual string ToString();
    internal ReadOnlySpan`1<byte> AsSpan();
    private string get_DebuggerDisplay();
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{Value}")]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal class Windows.Win32.Foundation.PSID : ValueType {
    internal Void* Value;
    internal PSID(Void* value);
    public static Void* op_Implicit(PSID value);
    public static PSID op_Explicit(Void* value);
    public static bool op_Equality(PSID left, PSID right);
    public static bool op_Inequality(PSID left, PSID right);
    public sealed virtual bool Equals(PSID other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{Value}")]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal class Windows.Win32.Foundation.PSTR : ValueType {
    internal Byte* Value;
    internal int Length { get; }
    private string DebuggerDisplay { get; }
    internal PSTR(Byte* value);
    public static Byte* op_Implicit(PSTR value);
    public static PSTR op_Implicit(Byte* value);
    public static bool op_Equality(PSTR left, PSTR right);
    public static bool op_Inequality(PSTR left, PSTR right);
    public sealed virtual bool Equals(PSTR other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static PCSTR op_Implicit(PSTR value);
    internal int get_Length();
    internal Span`1<byte> AsSpan();
    private string get_DebuggerDisplay();
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{Value}")]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal class Windows.Win32.Foundation.VARIANT_BOOL : ValueType {
    internal short Value;
    internal static VARIANT_BOOL VARIANT_TRUE;
    internal static VARIANT_BOOL VARIANT_FALSE;
    internal VARIANT_BOOL(short value);
    internal VARIANT_BOOL(bool value);
    private static VARIANT_BOOL();
    public static short op_Implicit(VARIANT_BOOL value);
    public static VARIANT_BOOL op_Explicit(short value);
    public static bool op_Equality(VARIANT_BOOL left, VARIANT_BOOL right);
    public static bool op_Inequality(VARIANT_BOOL left, VARIANT_BOOL right);
    public sealed virtual bool Equals(VARIANT_BOOL other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Implicit(VARIANT_BOOL value);
    public static VARIANT_BOOL op_Implicit(bool value);
}
[ExtensionAttribute]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal static class Windows.Win32.InlineArrayIndexerExtensions : object {
    [ExtensionAttribute]
internal static ReadOnlySpan`1<char> SliceAtNull(ReadOnlySpan`1<char> value);
    [ExtensionAttribute]
internal static Char& modreq(System.Runtime.InteropServices.InAttribute) ReadOnlyItemRef(__char_1& this, int index);
    [ExtensionAttribute]
internal static Char& modreq(System.Runtime.InteropServices.InAttribute) ReadOnlyItemRef(__char_260& this, int index);
    [ExtensionAttribute]
internal static Char& modreq(System.Runtime.InteropServices.InAttribute) ReadOnlyItemRef(__char_14& this, int index);
}
[FlagsAttribute]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal enum Windows.Win32.Security.ACE_FLAGS : Enum {
    public UInt32 value__;
    public static ACE_FLAGS CONTAINER_INHERIT_ACE;
    public static ACE_FLAGS FAILED_ACCESS_ACE_FLAG;
    public static ACE_FLAGS INHERIT_ONLY_ACE;
    public static ACE_FLAGS INHERITED_ACE;
    public static ACE_FLAGS NO_PROPAGATE_INHERIT_ACE;
    public static ACE_FLAGS OBJECT_INHERIT_ACE;
    public static ACE_FLAGS SUCCESSFUL_ACCESS_ACE_FLAG;
    public static ACE_FLAGS SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    public static ACE_FLAGS SUB_CONTAINERS_ONLY_INHERIT;
    public static ACE_FLAGS SUB_OBJECTS_ONLY_INHERIT;
    public static ACE_FLAGS INHERIT_NO_PROPAGATE;
    public static ACE_FLAGS INHERIT_ONLY;
    public static ACE_FLAGS NO_INHERITANCE;
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal class Windows.Win32.Security.ACL : ValueType {
    internal byte AclRevision;
    internal byte Sbz1;
    internal ushort AclSize;
    internal ushort AceCount;
    internal ushort Sbz2;
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal enum Windows.Win32.Security.Authorization.ACCESS_MODE : Enum {
    public int value__;
    public static ACCESS_MODE NOT_USED_ACCESS;
    public static ACCESS_MODE GRANT_ACCESS;
    public static ACCESS_MODE SET_ACCESS;
    public static ACCESS_MODE DENY_ACCESS;
    public static ACCESS_MODE REVOKE_ACCESS;
    public static ACCESS_MODE SET_AUDIT_SUCCESS;
    public static ACCESS_MODE SET_AUDIT_FAILURE;
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal class Windows.Win32.Security.Authorization.EXPLICIT_ACCESS_W : ValueType {
    internal UInt32 grfAccessPermissions;
    internal ACCESS_MODE grfAccessMode;
    internal ACE_FLAGS grfInheritance;
    internal TRUSTEE_W Trustee;
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal enum Windows.Win32.Security.Authorization.MULTIPLE_TRUSTEE_OPERATION : Enum {
    public int value__;
    public static MULTIPLE_TRUSTEE_OPERATION NO_MULTIPLE_TRUSTEE;
    public static MULTIPLE_TRUSTEE_OPERATION TRUSTEE_IS_IMPERSONATE;
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal enum Windows.Win32.Security.Authorization.SE_OBJECT_TYPE : Enum {
    public int value__;
    public static SE_OBJECT_TYPE SE_UNKNOWN_OBJECT_TYPE;
    public static SE_OBJECT_TYPE SE_FILE_OBJECT;
    public static SE_OBJECT_TYPE SE_SERVICE;
    public static SE_OBJECT_TYPE SE_PRINTER;
    public static SE_OBJECT_TYPE SE_REGISTRY_KEY;
    public static SE_OBJECT_TYPE SE_LMSHARE;
    public static SE_OBJECT_TYPE SE_KERNEL_OBJECT;
    public static SE_OBJECT_TYPE SE_WINDOW_OBJECT;
    public static SE_OBJECT_TYPE SE_DS_OBJECT;
    public static SE_OBJECT_TYPE SE_DS_OBJECT_ALL;
    public static SE_OBJECT_TYPE SE_PROVIDER_DEFINED_OBJECT;
    public static SE_OBJECT_TYPE SE_WMIGUID_OBJECT;
    public static SE_OBJECT_TYPE SE_REGISTRY_WOW64_32KEY;
    public static SE_OBJECT_TYPE SE_REGISTRY_WOW64_64KEY;
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal enum Windows.Win32.Security.Authorization.TRUSTEE_FORM : Enum {
    public int value__;
    public static TRUSTEE_FORM TRUSTEE_IS_SID;
    public static TRUSTEE_FORM TRUSTEE_IS_NAME;
    public static TRUSTEE_FORM TRUSTEE_BAD_FORM;
    public static TRUSTEE_FORM TRUSTEE_IS_OBJECTS_AND_SID;
    public static TRUSTEE_FORM TRUSTEE_IS_OBJECTS_AND_NAME;
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal enum Windows.Win32.Security.Authorization.TRUSTEE_TYPE : Enum {
    public int value__;
    public static TRUSTEE_TYPE TRUSTEE_IS_UNKNOWN;
    public static TRUSTEE_TYPE TRUSTEE_IS_USER;
    public static TRUSTEE_TYPE TRUSTEE_IS_GROUP;
    public static TRUSTEE_TYPE TRUSTEE_IS_DOMAIN;
    public static TRUSTEE_TYPE TRUSTEE_IS_ALIAS;
    public static TRUSTEE_TYPE TRUSTEE_IS_WELL_KNOWN_GROUP;
    public static TRUSTEE_TYPE TRUSTEE_IS_DELETED;
    public static TRUSTEE_TYPE TRUSTEE_IS_INVALID;
    public static TRUSTEE_TYPE TRUSTEE_IS_COMPUTER;
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal class Windows.Win32.Security.Authorization.TRUSTEE_W : ValueType {
    internal TRUSTEE_W* pMultipleTrustee;
    internal MULTIPLE_TRUSTEE_OPERATION MultipleTrusteeOperation;
    internal TRUSTEE_FORM TrusteeForm;
    internal TRUSTEE_TYPE TrusteeType;
    internal PWSTR ptstrName;
}
[FlagsAttribute]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal enum Windows.Win32.Security.OBJECT_SECURITY_INFORMATION : Enum {
    public UInt32 value__;
    public static OBJECT_SECURITY_INFORMATION ATTRIBUTE_SECURITY_INFORMATION;
    public static OBJECT_SECURITY_INFORMATION BACKUP_SECURITY_INFORMATION;
    public static OBJECT_SECURITY_INFORMATION DACL_SECURITY_INFORMATION;
    public static OBJECT_SECURITY_INFORMATION GROUP_SECURITY_INFORMATION;
    public static OBJECT_SECURITY_INFORMATION LABEL_SECURITY_INFORMATION;
    public static OBJECT_SECURITY_INFORMATION OWNER_SECURITY_INFORMATION;
    public static OBJECT_SECURITY_INFORMATION PROTECTED_DACL_SECURITY_INFORMATION;
    public static OBJECT_SECURITY_INFORMATION PROTECTED_SACL_SECURITY_INFORMATION;
    public static OBJECT_SECURITY_INFORMATION SACL_SECURITY_INFORMATION;
    public static OBJECT_SECURITY_INFORMATION SCOPE_SECURITY_INFORMATION;
    public static OBJECT_SECURITY_INFORMATION UNPROTECTED_DACL_SECURITY_INFORMATION;
    public static OBJECT_SECURITY_INFORMATION UNPROTECTED_SACL_SECURITY_INFORMATION;
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{Value}")]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal class Windows.Win32.Security.PSECURITY_DESCRIPTOR : ValueType {
    internal Void* Value;
    internal PSECURITY_DESCRIPTOR(Void* value);
    public static Void* op_Implicit(PSECURITY_DESCRIPTOR value);
    public static PSECURITY_DESCRIPTOR op_Explicit(Void* value);
    public static bool op_Equality(PSECURITY_DESCRIPTOR left, PSECURITY_DESCRIPTOR right);
    public static bool op_Inequality(PSECURITY_DESCRIPTOR left, PSECURITY_DESCRIPTOR right);
    public sealed virtual bool Equals(PSECURITY_DESCRIPTOR other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{Value}")]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal class Windows.Win32.Security.SC_HANDLE : ValueType {
    [NativeIntegerAttribute]
internal IntPtr Value;
    internal SC_HANDLE(IntPtr value);
    public static IntPtr op_Implicit(SC_HANDLE value);
    public static SC_HANDLE op_Explicit(IntPtr value);
    public static bool op_Equality(SC_HANDLE left, SC_HANDLE right);
    public static bool op_Inequality(SC_HANDLE left, SC_HANDLE right);
    public sealed virtual bool Equals(SC_HANDLE other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal class Windows.Win32.Security.SECURITY_ATTRIBUTES : ValueType {
    internal UInt32 nLength;
    internal Void* lpSecurityDescriptor;
    internal BOOL bInheritHandle;
}
[FlagsAttribute]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal enum Windows.Win32.Security.SECURITY_DESCRIPTOR_CONTROL : Enum {
    public ushort value__;
    public static SECURITY_DESCRIPTOR_CONTROL SE_OWNER_DEFAULTED;
    public static SECURITY_DESCRIPTOR_CONTROL SE_GROUP_DEFAULTED;
    public static SECURITY_DESCRIPTOR_CONTROL SE_DACL_PRESENT;
    public static SECURITY_DESCRIPTOR_CONTROL SE_DACL_DEFAULTED;
    public static SECURITY_DESCRIPTOR_CONTROL SE_SACL_PRESENT;
    public static SECURITY_DESCRIPTOR_CONTROL SE_SACL_DEFAULTED;
    public static SECURITY_DESCRIPTOR_CONTROL SE_DACL_AUTO_INHERIT_REQ;
    public static SECURITY_DESCRIPTOR_CONTROL SE_SACL_AUTO_INHERIT_REQ;
    public static SECURITY_DESCRIPTOR_CONTROL SE_DACL_AUTO_INHERITED;
    public static SECURITY_DESCRIPTOR_CONTROL SE_SACL_AUTO_INHERITED;
    public static SECURITY_DESCRIPTOR_CONTROL SE_DACL_PROTECTED;
    public static SECURITY_DESCRIPTOR_CONTROL SE_SACL_PROTECTED;
    public static SECURITY_DESCRIPTOR_CONTROL SE_RM_CONTROL_VALID;
    public static SECURITY_DESCRIPTOR_CONTROL SE_SELF_RELATIVE;
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal class Windows.Win32.Security.SID_AND_ATTRIBUTES : ValueType {
    internal PSID Sid;
    internal UInt32 Attributes;
}
[FlagsAttribute]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal enum Windows.Win32.Security.TOKEN_ACCESS_MASK : Enum {
    public UInt32 value__;
    public static TOKEN_ACCESS_MASK TOKEN_DELETE;
    public static TOKEN_ACCESS_MASK TOKEN_READ_CONTROL;
    public static TOKEN_ACCESS_MASK TOKEN_WRITE_DAC;
    public static TOKEN_ACCESS_MASK TOKEN_WRITE_OWNER;
    public static TOKEN_ACCESS_MASK TOKEN_ACCESS_SYSTEM_SECURITY;
    public static TOKEN_ACCESS_MASK TOKEN_ASSIGN_PRIMARY;
    public static TOKEN_ACCESS_MASK TOKEN_DUPLICATE;
    public static TOKEN_ACCESS_MASK TOKEN_IMPERSONATE;
    public static TOKEN_ACCESS_MASK TOKEN_QUERY;
    public static TOKEN_ACCESS_MASK TOKEN_QUERY_SOURCE;
    public static TOKEN_ACCESS_MASK TOKEN_ADJUST_PRIVILEGES;
    public static TOKEN_ACCESS_MASK TOKEN_ADJUST_GROUPS;
    public static TOKEN_ACCESS_MASK TOKEN_ADJUST_DEFAULT;
    public static TOKEN_ACCESS_MASK TOKEN_ADJUST_SESSIONID;
    public static TOKEN_ACCESS_MASK TOKEN_READ;
    public static TOKEN_ACCESS_MASK TOKEN_WRITE;
    public static TOKEN_ACCESS_MASK TOKEN_EXECUTE;
    public static TOKEN_ACCESS_MASK TOKEN_TRUST_CONSTRAINT_MASK;
    public static TOKEN_ACCESS_MASK TOKEN_ACCESS_PSEUDO_HANDLE_WIN8;
    public static TOKEN_ACCESS_MASK TOKEN_ACCESS_PSEUDO_HANDLE;
    public static TOKEN_ACCESS_MASK TOKEN_ALL_ACCESS;
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal class Windows.Win32.Security.TOKEN_ELEVATION : ValueType {
    internal UInt32 TokenIsElevated;
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal enum Windows.Win32.Security.TOKEN_INFORMATION_CLASS : Enum {
    public int value__;
    public static TOKEN_INFORMATION_CLASS TokenUser;
    public static TOKEN_INFORMATION_CLASS TokenGroups;
    public static TOKEN_INFORMATION_CLASS TokenPrivileges;
    public static TOKEN_INFORMATION_CLASS TokenOwner;
    public static TOKEN_INFORMATION_CLASS TokenPrimaryGroup;
    public static TOKEN_INFORMATION_CLASS TokenDefaultDacl;
    public static TOKEN_INFORMATION_CLASS TokenSource;
    public static TOKEN_INFORMATION_CLASS TokenType;
    public static TOKEN_INFORMATION_CLASS TokenImpersonationLevel;
    public static TOKEN_INFORMATION_CLASS TokenStatistics;
    public static TOKEN_INFORMATION_CLASS TokenRestrictedSids;
    public static TOKEN_INFORMATION_CLASS TokenSessionId;
    public static TOKEN_INFORMATION_CLASS TokenGroupsAndPrivileges;
    public static TOKEN_INFORMATION_CLASS TokenSessionReference;
    public static TOKEN_INFORMATION_CLASS TokenSandBoxInert;
    public static TOKEN_INFORMATION_CLASS TokenAuditPolicy;
    public static TOKEN_INFORMATION_CLASS TokenOrigin;
    public static TOKEN_INFORMATION_CLASS TokenElevationType;
    public static TOKEN_INFORMATION_CLASS TokenLinkedToken;
    public static TOKEN_INFORMATION_CLASS TokenElevation;
    public static TOKEN_INFORMATION_CLASS TokenHasRestrictions;
    public static TOKEN_INFORMATION_CLASS TokenAccessInformation;
    public static TOKEN_INFORMATION_CLASS TokenVirtualizationAllowed;
    public static TOKEN_INFORMATION_CLASS TokenVirtualizationEnabled;
    public static TOKEN_INFORMATION_CLASS TokenIntegrityLevel;
    public static TOKEN_INFORMATION_CLASS TokenUIAccess;
    public static TOKEN_INFORMATION_CLASS TokenMandatoryPolicy;
    public static TOKEN_INFORMATION_CLASS TokenLogonSid;
    public static TOKEN_INFORMATION_CLASS TokenIsAppContainer;
    public static TOKEN_INFORMATION_CLASS TokenCapabilities;
    public static TOKEN_INFORMATION_CLASS TokenAppContainerSid;
    public static TOKEN_INFORMATION_CLASS TokenAppContainerNumber;
    public static TOKEN_INFORMATION_CLASS TokenUserClaimAttributes;
    public static TOKEN_INFORMATION_CLASS TokenDeviceClaimAttributes;
    public static TOKEN_INFORMATION_CLASS TokenRestrictedUserClaimAttributes;
    public static TOKEN_INFORMATION_CLASS TokenRestrictedDeviceClaimAttributes;
    public static TOKEN_INFORMATION_CLASS TokenDeviceGroups;
    public static TOKEN_INFORMATION_CLASS TokenRestrictedDeviceGroups;
    public static TOKEN_INFORMATION_CLASS TokenSecurityAttributes;
    public static TOKEN_INFORMATION_CLASS TokenIsRestricted;
    public static TOKEN_INFORMATION_CLASS TokenProcessTrustLevel;
    public static TOKEN_INFORMATION_CLASS TokenPrivateNameSpace;
    public static TOKEN_INFORMATION_CLASS TokenSingletonAttributes;
    public static TOKEN_INFORMATION_CLASS TokenBnoIsolation;
    public static TOKEN_INFORMATION_CLASS TokenChildProcessFlags;
    public static TOKEN_INFORMATION_CLASS TokenIsLessPrivilegedAppContainer;
    public static TOKEN_INFORMATION_CLASS TokenIsSandboxed;
    public static TOKEN_INFORMATION_CLASS TokenIsAppSilo;
    public static TOKEN_INFORMATION_CLASS MaxTokenInfoClass;
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal class Windows.Win32.Security.TOKEN_USER : ValueType {
    internal SID_AND_ATTRIBUTES User;
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal static class Windows.Win32.SetupPInvoke : object {
    [NullableAttribute("1")]
private static string DevicePathPrefix;
    internal static int STILL_ACTIVE;
    internal static int MAX_PATH;
    internal static int CSIDL_Desktop;
    internal static Guid ShellDispatchGuid;
    internal static UInt32 SC_MANAGER_ALL_ACCESS;
    internal static UInt32 SERVICE_ALL_ACCESS;
    internal static UInt32 SERVICE_CHANGE_CONFIG;
    internal static UInt32 SERVICE_ENUMERATE_DEPENDENTS;
    internal static UInt32 SERVICE_INTERROGATE;
    internal static UInt32 SERVICE_NO_CHANGE;
    internal static UInt32 SERVICE_QUERY_CONFIG;
    internal static UInt32 SERVICE_QUERY_STATUS;
    internal static UInt32 SERVICE_START;
    internal static UInt32 SERVICE_STOP;
    internal static Guid SID_STopLevelBrowser;
    private static SetupPInvoke();
    internal static void ThrowOnFailure(bool result);
    internal static void ThrowOnFailure(WIN32_ERROR result);
    internal static void ThrowIfNull(HANDLE handle);
    [NullableContextAttribute("1")]
internal static void ThrowIfNull(SafeHandle handle);
    internal static void CloseHandleIfNotNull(HANDLE handle);
    [NullableContextAttribute("1")]
internal static string GetFilePath(SafeFileHandle fileHandle);
    internal static void BuildTrusteeWithSid(TRUSTEE_W& pTrustee, PSID pSid);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static void BuildTrusteeWithSid(TRUSTEE_W* pTrustee, PSID pSid);
    internal static BOOL ChangeServiceConfig(SC_HANDLE hService, UInt32 dwServiceType, SERVICE_START_TYPE dwStartType, SERVICE_ERROR dwErrorControl, string lpBinaryPathName, string lpLoadOrderGroup, UInt32* lpdwTagId, string lpDependencies, string lpServiceStartName, string lpPassword, string lpDisplayName);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static BOOL ChangeServiceConfig(SC_HANDLE hService, UInt32 dwServiceType, SERVICE_START_TYPE dwStartType, SERVICE_ERROR dwErrorControl, PCWSTR lpBinaryPathName, PCWSTR lpLoadOrderGroup, UInt32* lpdwTagId, PCWSTR lpDependencies, PCWSTR lpServiceStartName, PCWSTR lpPassword, PCWSTR lpDisplayName);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static BOOL ChangeServiceConfig2W(SC_HANDLE hService, SERVICE_CONFIG dwInfoLevel, Void* lpInfo);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static BOOL CloseServiceHandle(SC_HANDLE hSCObject);
    internal static BOOL ConvertStringSidToSid(string StringSid, PSID& Sid);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static BOOL ConvertStringSidToSid(PCWSTR StringSid, PSID* Sid);
    internal static SC_HANDLE CreateService(SC_HANDLE hSCManager, string lpServiceName, string lpDisplayName, UInt32 dwDesiredAccess, ENUM_SERVICE_TYPE dwServiceType, SERVICE_START_TYPE dwStartType, SERVICE_ERROR dwErrorControl, string lpBinaryPathName, string lpLoadOrderGroup, UInt32* lpdwTagId, string lpDependencies, string lpServiceStartName, string lpPassword);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static SC_HANDLE CreateService(SC_HANDLE hSCManager, PCWSTR lpServiceName, PCWSTR lpDisplayName, UInt32 dwDesiredAccess, ENUM_SERVICE_TYPE dwServiceType, SERVICE_START_TYPE dwStartType, SERVICE_ERROR dwErrorControl, PCWSTR lpBinaryPathName, PCWSTR lpLoadOrderGroup, UInt32* lpdwTagId, PCWSTR lpDependencies, PCWSTR lpServiceStartName, PCWSTR lpPassword);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static BOOL DeleteService(SC_HANDLE hService);
    internal static WIN32_ERROR GetNamedSecurityInfo(string pObjectName, SE_OBJECT_TYPE ObjectType, OBJECT_SECURITY_INFORMATION SecurityInfo, PSID* ppsidOwner, PSID* ppsidGroup, ACL** ppDacl, ACL** ppSacl, PSECURITY_DESCRIPTOR& ppSecurityDescriptor);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static WIN32_ERROR GetNamedSecurityInfo(PCWSTR pObjectName, SE_OBJECT_TYPE ObjectType, OBJECT_SECURITY_INFORMATION SecurityInfo, PSID* ppsidOwner, PSID* ppsidGroup, ACL** ppDacl, ACL** ppSacl, PSECURITY_DESCRIPTOR* ppSecurityDescriptor);
    internal static BOOL GetSecurityDescriptorControl(PSECURITY_DESCRIPTOR pSecurityDescriptor, UInt16& pControl, UInt32& lpdwRevision);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static BOOL GetSecurityDescriptorControl(PSECURITY_DESCRIPTOR pSecurityDescriptor, UInt16* pControl, UInt32* lpdwRevision);
    internal static WIN32_ERROR GetSecurityInfo(SafeHandle handle, SE_OBJECT_TYPE ObjectType, UInt32 SecurityInfo, PSID* ppsidOwner, PSID* ppsidGroup, ACL** ppDacl, ACL** ppSacl, PSECURITY_DESCRIPTOR* ppSecurityDescriptor);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static WIN32_ERROR GetSecurityInfo(HANDLE handle, SE_OBJECT_TYPE ObjectType, UInt32 SecurityInfo, PSID* ppsidOwner, PSID* ppsidGroup, ACL** ppDacl, ACL** ppSacl, PSECURITY_DESCRIPTOR* ppSecurityDescriptor);
    internal static BOOL GetTokenInformation(SafeHandle TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, Void* TokenInformation, UInt32 TokenInformationLength, UInt32& ReturnLength);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static BOOL GetTokenInformation(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, Void* TokenInformation, UInt32 TokenInformationLength, UInt32* ReturnLength);
    internal static BOOL OpenProcessToken(SafeHandle ProcessHandle, TOKEN_ACCESS_MASK DesiredAccess, SafeFileHandle& TokenHandle);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static BOOL OpenProcessToken(HANDLE ProcessHandle, TOKEN_ACCESS_MASK DesiredAccess, HANDLE* TokenHandle);
    internal static SC_HANDLE OpenSCManager(string lpMachineName, string lpDatabaseName, UInt32 dwDesiredAccess);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static SC_HANDLE OpenSCManager(PCWSTR lpMachineName, PCWSTR lpDatabaseName, UInt32 dwDesiredAccess);
    internal static SC_HANDLE OpenService(SC_HANDLE hSCManager, string lpServiceName, UInt32 dwDesiredAccess);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static SC_HANDLE OpenService(SC_HANDLE hSCManager, PCWSTR lpServiceName, UInt32 dwDesiredAccess);
    internal static WIN32_ERROR SetEntriesInAcl(Span`1<EXPLICIT_ACCESS_W> pListOfExplicitEntries, Nullable`1<ACL> OldAcl, ACL*& NewAcl);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static WIN32_ERROR SetEntriesInAcl(UInt32 cCountOfExplicitEntries, EXPLICIT_ACCESS_W* pListOfExplicitEntries, ACL* OldAcl, ACL** NewAcl);
    internal static WIN32_ERROR SetSecurityInfo(SafeHandle handle, SE_OBJECT_TYPE ObjectType, UInt32 SecurityInfo, PSID psidOwner, PSID psidGroup, Nullable`1<ACL> pDacl, Nullable`1<ACL> pSacl);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static WIN32_ERROR SetSecurityInfo(HANDLE handle, SE_OBJECT_TYPE ObjectType, UInt32 SecurityInfo, PSID psidOwner, PSID psidGroup, ACL* pDacl, ACL* pSacl);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static BOOL FDICopy(Void* hfdi, PSTR pszCabinet, PSTR pszCabPath, int flags, PFNFDINOTIFY pfnfdin, PFNFDIDECRYPT pfnfdid, Void* pvUser);
    internal static Void* FDICreate(PFNALLOC pfnalloc, PFNFREE pfnfree, PFNOPEN pfnopen, PFNREAD pfnread, PFNWRITE pfnwrite, PFNCLOSE pfnclose, PFNSEEK pfnseek, FDICREATE_CPU_TYPE cpuType, ERF& perf);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static Void* FDICreate(PFNALLOC pfnalloc, PFNFREE pfnfree, PFNOPEN pfnopen, PFNREAD pfnread, PFNWRITE pfnwrite, PFNCLOSE pfnclose, PFNSEEK pfnseek, FDICREATE_CPU_TYPE cpuType, ERF* perf);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static BOOL FDIDestroy(Void* hfdi);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static BOOL CloseHandle(HANDLE hObject);
    internal static BOOL CopyFile(string lpExistingFileName, string lpNewFileName, BOOL bFailIfExists);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static BOOL CopyFile(PCWSTR lpExistingFileName, PCWSTR lpNewFileName, BOOL bFailIfExists);
    internal static SafeFileHandle CreateFile(string lpFileName, UInt32 dwDesiredAccess, FILE_SHARE_MODE dwShareMode, Nullable`1<SECURITY_ATTRIBUTES> lpSecurityAttributes, FILE_CREATION_DISPOSITION dwCreationDisposition, FILE_FLAGS_AND_ATTRIBUTES dwFlagsAndAttributes, SafeHandle hTemplateFile);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static HANDLE CreateFile(PCWSTR lpFileName, UInt32 dwDesiredAccess, FILE_SHARE_MODE dwShareMode, SECURITY_ATTRIBUTES* lpSecurityAttributes, FILE_CREATION_DISPOSITION dwCreationDisposition, FILE_FLAGS_AND_ATTRIBUTES dwFlagsAndAttributes, HANDLE hTemplateFile);
    internal static BOOL DosDateTimeToFileTime(ushort wFatDate, ushort wFatTime, FILETIME& lpFileTime);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static BOOL DosDateTimeToFileTime(ushort wFatDate, ushort wFatTime, FILETIME* lpFileTime);
    internal static FindCloseSafeHandle FindFirstFile(string lpFileName, WIN32_FIND_DATAW& lpFindFileData);
    internal static BOOL FindClose(SafeHandle hFindFile);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static BOOL FindClose(HANDLE hFindFile);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static HANDLE FindFirstFile(PCWSTR lpFileName, WIN32_FIND_DATAW* lpFindFileData);
    internal static BOOL FindNextFile(SafeHandle hFindFile, WIN32_FIND_DATAW& lpFindFileData);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static BOOL FindNextFile(HANDLE hFindFile, WIN32_FIND_DATAW* lpFindFileData);
    internal static BOOL GetExitCodeProcess(SafeHandle hProcess, UInt32& lpExitCode);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static BOOL GetExitCodeProcess(HANDLE hProcess, UInt32* lpExitCode);
    internal static BOOL GetFileInformationByHandle(SafeHandle hFile, BY_HANDLE_FILE_INFORMATION& lpFileInformation);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static BOOL GetFileInformationByHandle(HANDLE hFile, BY_HANDLE_FILE_INFORMATION* lpFileInformation);
    internal static BOOL GetFileInformationByHandleEx(SafeHandle hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, Void* lpFileInformation, UInt32 dwBufferSize);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static BOOL GetFileInformationByHandleEx(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, Void* lpFileInformation, UInt32 dwBufferSize);
    internal static UInt32 GetFinalPathNameByHandle(SafeHandle hFile, PWSTR lpszFilePath, UInt32 cchFilePath, GETFINALPATHNAMEBYHANDLE_FLAGS dwFlags);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static UInt32 GetFinalPathNameByHandle(HANDLE hFile, PWSTR lpszFilePath, UInt32 cchFilePath, GETFINALPATHNAMEBYHANDLE_FLAGS dwFlags);
    internal static UInt32 GetTempFileName(string lpPathName, string lpPrefixString, UInt32 uUnique, PWSTR lpTempFileName);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static UInt32 GetTempFileName(PCWSTR lpPathName, PCWSTR lpPrefixString, UInt32 uUnique, PWSTR lpTempFileName);
    internal static BOOL MoveFileEx(string lpExistingFileName, string lpNewFileName, MOVE_FILE_FLAGS dwFlags);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static BOOL MoveFileEx(PCWSTR lpExistingFileName, PCWSTR lpNewFileName, MOVE_FILE_FLAGS dwFlags);
    internal static SafeFileHandle OpenProcess_SafeHandle(PROCESS_ACCESS_RIGHTS dwDesiredAccess, BOOL bInheritHandle, UInt32 dwProcessId);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static HANDLE OpenProcess(PROCESS_ACCESS_RIGHTS dwDesiredAccess, BOOL bInheritHandle, UInt32 dwProcessId);
    internal static BOOL QueryFullProcessImageName(SafeHandle hProcess, PROCESS_NAME_FORMAT dwFlags, PWSTR lpExeName, UInt32& lpdwSize);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static BOOL QueryFullProcessImageName(HANDLE hProcess, PROCESS_NAME_FORMAT dwFlags, PWSTR lpExeName, UInt32* lpdwSize);
    internal static SafeFileHandle ReOpenFile(SafeHandle hOriginalFile, UInt32 dwDesiredAccess, FILE_SHARE_MODE dwShareMode, FILE_FLAGS_AND_ATTRIBUTES dwFlagsAndAttributes);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static HANDLE ReOpenFile(HANDLE hOriginalFile, UInt32 dwDesiredAccess, FILE_SHARE_MODE dwShareMode, FILE_FLAGS_AND_ATTRIBUTES dwFlagsAndAttributes);
    internal static BOOL SetFileInformationByHandle(SafeHandle hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, Void* lpFileInformation, UInt32 dwBufferSize);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static BOOL SetFileInformationByHandle(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, Void* lpFileInformation, UInt32 dwBufferSize);
    internal static BOOL SetFileTime(SafeHandle hFile, Nullable`1<FILETIME> lpCreationTime, Nullable`1<FILETIME> lpLastAccessTime, Nullable`1<FILETIME> lpLastWriteTime);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static BOOL SetFileTime(HANDLE hFile, FILETIME* lpCreationTime, FILETIME* lpLastAccessTime, FILETIME* lpLastWriteTime);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static INSTALLUILEVEL MsiSetInternalUI(INSTALLUILEVEL dwUILevel, HWND* phWnd);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static void SysFreeString(BSTR bstrString);
    internal static BOOL GetFileVersionInfo(string lptstrFilename, UInt32 dwLen, Void* lpData);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static BOOL GetFileVersionInfo(PCWSTR lptstrFilename, UInt32 dwHandle, UInt32 dwLen, Void* lpData);
    internal static UInt32 GetFileVersionInfoSize(string lptstrFilename, UInt32* lpdwHandle);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static UInt32 GetFileVersionInfoSize(PCWSTR lptstrFilename, UInt32* lpdwHandle);
    internal static BOOL VerQueryValue(Void* pBlock, string lpSubBlock, Void*& lplpBuffer, UInt32& puLen);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static BOOL VerQueryValue(Void* pBlock, PCWSTR lpSubBlock, Void** lplpBuffer, UInt32* puLen);
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal class Windows.Win32.Storage.Cabinets.ERF : ValueType {
    internal int erfOper;
    internal int erfType;
    internal BOOL fError;
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal enum Windows.Win32.Storage.Cabinets.FDICREATE_CPU_TYPE : Enum {
    public int value__;
    public static FDICREATE_CPU_TYPE cpuUNKNOWN;
    public static FDICREATE_CPU_TYPE cpu80286;
    public static FDICREATE_CPU_TYPE cpu80386;
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal class Windows.Win32.Storage.Cabinets.FDIDECRYPT : ValueType {
    internal FDIDECRYPTTYPE fdidt;
    internal Void* pvUser;
    internal _Anonymous_e__Union Anonymous;
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal enum Windows.Win32.Storage.Cabinets.FDIDECRYPTTYPE : Enum {
    public int value__;
    public static FDIDECRYPTTYPE fdidtNEW_CABINET;
    public static FDIDECRYPTTYPE fdidtNEW_FOLDER;
    public static FDIDECRYPTTYPE fdidtDECRYPT;
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal enum Windows.Win32.Storage.Cabinets.FDIERROR : Enum {
    public int value__;
    public static FDIERROR FDIERROR_NONE;
    public static FDIERROR FDIERROR_CABINET_NOT_FOUND;
    public static FDIERROR FDIERROR_NOT_A_CABINET;
    public static FDIERROR FDIERROR_UNKNOWN_CABINET_VERSION;
    public static FDIERROR FDIERROR_CORRUPT_CABINET;
    public static FDIERROR FDIERROR_ALLOC_FAIL;
    public static FDIERROR FDIERROR_BAD_COMPR_TYPE;
    public static FDIERROR FDIERROR_MDI_FAIL;
    public static FDIERROR FDIERROR_TARGET_FILE;
    public static FDIERROR FDIERROR_RESERVE_MISMATCH;
    public static FDIERROR FDIERROR_WRONG_CABINET;
    public static FDIERROR FDIERROR_USER_ABORT;
    public static FDIERROR FDIERROR_EOF;
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal class Windows.Win32.Storage.Cabinets.FDINOTIFICATION : ValueType {
    internal int cb;
    internal PSTR psz1;
    internal PSTR psz2;
    internal PSTR psz3;
    internal Void* pv;
    [NativeIntegerAttribute]
internal IntPtr hf;
    internal ushort date;
    internal ushort time;
    internal ushort attribs;
    internal ushort setID;
    internal ushort iCabinet;
    internal ushort iFolder;
    internal FDIERROR fdie;
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal enum Windows.Win32.Storage.Cabinets.FDINOTIFICATIONTYPE : Enum {
    public int value__;
    public static FDINOTIFICATIONTYPE fdintCABINET_INFO;
    public static FDINOTIFICATIONTYPE fdintPARTIAL_FILE;
    public static FDINOTIFICATIONTYPE fdintCOPY_FILE;
    public static FDINOTIFICATIONTYPE fdintCLOSE_FILE_INFO;
    public static FDINOTIFICATIONTYPE fdintNEXT_CABINET;
    public static FDINOTIFICATIONTYPE fdintENUMERATE;
}
[UnmanagedFunctionPointerAttribute("2")]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal class Windows.Win32.Storage.Cabinets.PFNALLOC : MulticastDelegate {
    public PFNALLOC(object object, IntPtr method);
    public virtual Void* Invoke(UInt32 cb);
    public virtual IAsyncResult BeginInvoke(UInt32 cb, AsyncCallback callback, object object);
    public virtual Void* EndInvoke(IAsyncResult result);
}
[UnmanagedFunctionPointerAttribute("2")]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal class Windows.Win32.Storage.Cabinets.PFNCLOSE : MulticastDelegate {
    public PFNCLOSE(object object, IntPtr method);
    public virtual int Invoke(IntPtr hf);
    public virtual IAsyncResult BeginInvoke(IntPtr hf, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[UnmanagedFunctionPointerAttribute("2")]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal class Windows.Win32.Storage.Cabinets.PFNFDIDECRYPT : MulticastDelegate {
    public PFNFDIDECRYPT(object object, IntPtr method);
    public virtual int Invoke(FDIDECRYPT* pfdid);
    public virtual IAsyncResult BeginInvoke(FDIDECRYPT* pfdid, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[UnmanagedFunctionPointerAttribute("2")]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal class Windows.Win32.Storage.Cabinets.PFNFDINOTIFY : MulticastDelegate {
    public PFNFDINOTIFY(object object, IntPtr method);
    public virtual IntPtr Invoke(FDINOTIFICATIONTYPE fdint, FDINOTIFICATION* pfdin);
    public virtual IAsyncResult BeginInvoke(FDINOTIFICATIONTYPE fdint, FDINOTIFICATION* pfdin, AsyncCallback callback, object object);
    public virtual IntPtr EndInvoke(IAsyncResult result);
}
[UnmanagedFunctionPointerAttribute("2")]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal class Windows.Win32.Storage.Cabinets.PFNFREE : MulticastDelegate {
    public PFNFREE(object object, IntPtr method);
    public virtual void Invoke(Void* pv);
    public virtual IAsyncResult BeginInvoke(Void* pv, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[UnmanagedFunctionPointerAttribute("2")]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal class Windows.Win32.Storage.Cabinets.PFNOPEN : MulticastDelegate {
    public PFNOPEN(object object, IntPtr method);
    public virtual IntPtr Invoke(PSTR pszFile, int oflag, int pmode);
    public virtual IAsyncResult BeginInvoke(PSTR pszFile, int oflag, int pmode, AsyncCallback callback, object object);
    public virtual IntPtr EndInvoke(IAsyncResult result);
}
[UnmanagedFunctionPointerAttribute("2")]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal class Windows.Win32.Storage.Cabinets.PFNREAD : MulticastDelegate {
    public PFNREAD(object object, IntPtr method);
    public virtual UInt32 Invoke(IntPtr hf, Void* pv, UInt32 cb);
    public virtual IAsyncResult BeginInvoke(IntPtr hf, Void* pv, UInt32 cb, AsyncCallback callback, object object);
    public virtual UInt32 EndInvoke(IAsyncResult result);
}
[UnmanagedFunctionPointerAttribute("2")]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal class Windows.Win32.Storage.Cabinets.PFNSEEK : MulticastDelegate {
    public PFNSEEK(object object, IntPtr method);
    public virtual int Invoke(IntPtr hf, int dist, int seektype);
    public virtual IAsyncResult BeginInvoke(IntPtr hf, int dist, int seektype, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[UnmanagedFunctionPointerAttribute("2")]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal class Windows.Win32.Storage.Cabinets.PFNWRITE : MulticastDelegate {
    public PFNWRITE(object object, IntPtr method);
    public virtual UInt32 Invoke(IntPtr hf, Void* pv, UInt32 cb);
    public virtual IAsyncResult BeginInvoke(IntPtr hf, Void* pv, UInt32 cb, AsyncCallback callback, object object);
    public virtual UInt32 EndInvoke(IAsyncResult result);
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal class Windows.Win32.Storage.FileSystem.BY_HANDLE_FILE_INFORMATION : ValueType {
    internal UInt32 dwFileAttributes;
    internal FILETIME ftCreationTime;
    internal FILETIME ftLastAccessTime;
    internal FILETIME ftLastWriteTime;
    internal UInt32 dwVolumeSerialNumber;
    internal UInt32 nFileSizeHigh;
    internal UInt32 nFileSizeLow;
    internal UInt32 nNumberOfLinks;
    internal UInt32 nFileIndexHigh;
    internal UInt32 nFileIndexLow;
}
[FlagsAttribute]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal enum Windows.Win32.Storage.FileSystem.FILE_ACCESS_RIGHTS : Enum {
    public UInt32 value__;
    public static FILE_ACCESS_RIGHTS FILE_READ_DATA;
    public static FILE_ACCESS_RIGHTS FILE_LIST_DIRECTORY;
    public static FILE_ACCESS_RIGHTS FILE_WRITE_DATA;
    public static FILE_ACCESS_RIGHTS FILE_ADD_FILE;
    public static FILE_ACCESS_RIGHTS FILE_APPEND_DATA;
    public static FILE_ACCESS_RIGHTS FILE_ADD_SUBDIRECTORY;
    public static FILE_ACCESS_RIGHTS FILE_CREATE_PIPE_INSTANCE;
    public static FILE_ACCESS_RIGHTS FILE_READ_EA;
    public static FILE_ACCESS_RIGHTS FILE_WRITE_EA;
    public static FILE_ACCESS_RIGHTS FILE_EXECUTE;
    public static FILE_ACCESS_RIGHTS FILE_TRAVERSE;
    public static FILE_ACCESS_RIGHTS FILE_DELETE_CHILD;
    public static FILE_ACCESS_RIGHTS FILE_READ_ATTRIBUTES;
    public static FILE_ACCESS_RIGHTS FILE_WRITE_ATTRIBUTES;
    public static FILE_ACCESS_RIGHTS DELETE;
    public static FILE_ACCESS_RIGHTS READ_CONTROL;
    public static FILE_ACCESS_RIGHTS WRITE_DAC;
    public static FILE_ACCESS_RIGHTS WRITE_OWNER;
    public static FILE_ACCESS_RIGHTS SYNCHRONIZE;
    public static FILE_ACCESS_RIGHTS STANDARD_RIGHTS_REQUIRED;
    public static FILE_ACCESS_RIGHTS STANDARD_RIGHTS_READ;
    public static FILE_ACCESS_RIGHTS STANDARD_RIGHTS_WRITE;
    public static FILE_ACCESS_RIGHTS STANDARD_RIGHTS_EXECUTE;
    public static FILE_ACCESS_RIGHTS STANDARD_RIGHTS_ALL;
    public static FILE_ACCESS_RIGHTS SPECIFIC_RIGHTS_ALL;
    public static FILE_ACCESS_RIGHTS FILE_ALL_ACCESS;
    public static FILE_ACCESS_RIGHTS FILE_GENERIC_READ;
    public static FILE_ACCESS_RIGHTS FILE_GENERIC_WRITE;
    public static FILE_ACCESS_RIGHTS FILE_GENERIC_EXECUTE;
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal class Windows.Win32.Storage.FileSystem.FILE_ATTRIBUTE_TAG_INFO : ValueType {
    internal UInt32 FileAttributes;
    internal UInt32 ReparseTag;
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal class Windows.Win32.Storage.FileSystem.FILE_BASIC_INFO : ValueType {
    internal long CreationTime;
    internal long LastAccessTime;
    internal long LastWriteTime;
    internal long ChangeTime;
    internal UInt32 FileAttributes;
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal enum Windows.Win32.Storage.FileSystem.FILE_CREATION_DISPOSITION : Enum {
    public UInt32 value__;
    public static FILE_CREATION_DISPOSITION CREATE_NEW;
    public static FILE_CREATION_DISPOSITION CREATE_ALWAYS;
    public static FILE_CREATION_DISPOSITION OPEN_EXISTING;
    public static FILE_CREATION_DISPOSITION OPEN_ALWAYS;
    public static FILE_CREATION_DISPOSITION TRUNCATE_EXISTING;
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal class Windows.Win32.Storage.FileSystem.FILE_DISPOSITION_INFO : ValueType {
    internal BOOLEAN DeleteFile;
}
[FlagsAttribute]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal enum Windows.Win32.Storage.FileSystem.FILE_FLAGS_AND_ATTRIBUTES : Enum {
    public UInt32 value__;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_READONLY;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_HIDDEN;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_SYSTEM;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_DIRECTORY;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_ARCHIVE;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_DEVICE;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_NORMAL;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_TEMPORARY;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_SPARSE_FILE;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_REPARSE_POINT;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_COMPRESSED;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_OFFLINE;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_NOT_CONTENT_INDEXED;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_ENCRYPTED;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_INTEGRITY_STREAM;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_VIRTUAL;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_NO_SCRUB_DATA;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_EA;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_PINNED;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_UNPINNED;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_RECALL_ON_OPEN;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_ATTRIBUTE_RECALL_ON_DATA_ACCESS;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_WRITE_THROUGH;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_OVERLAPPED;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_NO_BUFFERING;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_RANDOM_ACCESS;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_SEQUENTIAL_SCAN;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_DELETE_ON_CLOSE;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_BACKUP_SEMANTICS;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_POSIX_SEMANTICS;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_SESSION_AWARE;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_OPEN_REPARSE_POINT;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_OPEN_NO_RECALL;
    public static FILE_FLAGS_AND_ATTRIBUTES FILE_FLAG_FIRST_PIPE_INSTANCE;
    public static FILE_FLAGS_AND_ATTRIBUTES PIPE_ACCESS_DUPLEX;
    public static FILE_FLAGS_AND_ATTRIBUTES PIPE_ACCESS_INBOUND;
    public static FILE_FLAGS_AND_ATTRIBUTES PIPE_ACCESS_OUTBOUND;
    public static FILE_FLAGS_AND_ATTRIBUTES SECURITY_ANONYMOUS;
    public static FILE_FLAGS_AND_ATTRIBUTES SECURITY_IDENTIFICATION;
    public static FILE_FLAGS_AND_ATTRIBUTES SECURITY_IMPERSONATION;
    public static FILE_FLAGS_AND_ATTRIBUTES SECURITY_DELEGATION;
    public static FILE_FLAGS_AND_ATTRIBUTES SECURITY_CONTEXT_TRACKING;
    public static FILE_FLAGS_AND_ATTRIBUTES SECURITY_EFFECTIVE_ONLY;
    public static FILE_FLAGS_AND_ATTRIBUTES SECURITY_SQOS_PRESENT;
    public static FILE_FLAGS_AND_ATTRIBUTES SECURITY_VALID_SQOS_FLAGS;
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal enum Windows.Win32.Storage.FileSystem.FILE_INFO_BY_HANDLE_CLASS : Enum {
    public int value__;
    public static FILE_INFO_BY_HANDLE_CLASS FileBasicInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileStandardInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileNameInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileRenameInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileDispositionInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileAllocationInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileEndOfFileInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileStreamInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileCompressionInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileAttributeTagInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileIdBothDirectoryInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileIdBothDirectoryRestartInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileIoPriorityHintInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileRemoteProtocolInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileFullDirectoryInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileFullDirectoryRestartInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileStorageInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileAlignmentInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileIdInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileIdExtdDirectoryInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileIdExtdDirectoryRestartInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileDispositionInfoEx;
    public static FILE_INFO_BY_HANDLE_CLASS FileRenameInfoEx;
    public static FILE_INFO_BY_HANDLE_CLASS FileCaseSensitiveInfo;
    public static FILE_INFO_BY_HANDLE_CLASS FileNormalizedNameInfo;
    public static FILE_INFO_BY_HANDLE_CLASS MaximumFileInfoByHandleClass;
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal class Windows.Win32.Storage.FileSystem.FILE_RENAME_INFO : ValueType {
    internal _Anonymous_e__Union Anonymous;
    internal HANDLE RootDirectory;
    internal UInt32 FileNameLength;
    internal __char_1 FileName;
}
[FlagsAttribute]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal enum Windows.Win32.Storage.FileSystem.FILE_SHARE_MODE : Enum {
    public UInt32 value__;
    public static FILE_SHARE_MODE FILE_SHARE_NONE;
    public static FILE_SHARE_MODE FILE_SHARE_DELETE;
    public static FILE_SHARE_MODE FILE_SHARE_READ;
    public static FILE_SHARE_MODE FILE_SHARE_WRITE;
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal class Windows.Win32.Storage.FileSystem.FILE_STANDARD_INFO : ValueType {
    internal long AllocationSize;
    internal long EndOfFile;
    internal UInt32 NumberOfLinks;
    internal BOOLEAN DeletePending;
    internal BOOLEAN Directory;
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal enum Windows.Win32.Storage.FileSystem.GETFINALPATHNAMEBYHANDLE_FLAGS : Enum {
    public UInt32 value__;
    public static GETFINALPATHNAMEBYHANDLE_FLAGS VOLUME_NAME_DOS;
    public static GETFINALPATHNAMEBYHANDLE_FLAGS VOLUME_NAME_GUID;
    public static GETFINALPATHNAMEBYHANDLE_FLAGS VOLUME_NAME_NT;
    public static GETFINALPATHNAMEBYHANDLE_FLAGS VOLUME_NAME_NONE;
    public static GETFINALPATHNAMEBYHANDLE_FLAGS FILE_NAME_NORMALIZED;
    public static GETFINALPATHNAMEBYHANDLE_FLAGS FILE_NAME_OPENED;
}
[FlagsAttribute]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal enum Windows.Win32.Storage.FileSystem.MOVE_FILE_FLAGS : Enum {
    public UInt32 value__;
    public static MOVE_FILE_FLAGS MOVEFILE_COPY_ALLOWED;
    public static MOVE_FILE_FLAGS MOVEFILE_CREATE_HARDLINK;
    public static MOVE_FILE_FLAGS MOVEFILE_DELAY_UNTIL_REBOOT;
    public static MOVE_FILE_FLAGS MOVEFILE_REPLACE_EXISTING;
    public static MOVE_FILE_FLAGS MOVEFILE_WRITE_THROUGH;
    public static MOVE_FILE_FLAGS MOVEFILE_FAIL_IF_NOT_TRACKABLE;
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal class Windows.Win32.Storage.FileSystem.WIN32_FIND_DATAW : ValueType {
    internal UInt32 dwFileAttributes;
    internal FILETIME ftCreationTime;
    internal FILETIME ftLastAccessTime;
    internal FILETIME ftLastWriteTime;
    internal UInt32 nFileSizeHigh;
    internal UInt32 nFileSizeLow;
    internal UInt32 dwReserved0;
    internal UInt32 dwReserved1;
    internal __char_260 cFileName;
    internal __char_14 cAlternateFileName;
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal enum Windows.Win32.System.ApplicationInstallationAndServicing.INSTALLUILEVEL : Enum {
    public int value__;
    public static INSTALLUILEVEL INSTALLUILEVEL_NOCHANGE;
    public static INSTALLUILEVEL INSTALLUILEVEL_DEFAULT;
    public static INSTALLUILEVEL INSTALLUILEVEL_NONE;
    public static INSTALLUILEVEL INSTALLUILEVEL_BASIC;
    public static INSTALLUILEVEL INSTALLUILEVEL_REDUCED;
    public static INSTALLUILEVEL INSTALLUILEVEL_FULL;
    public static INSTALLUILEVEL INSTALLUILEVEL_ENDDIALOG;
    public static INSTALLUILEVEL INSTALLUILEVEL_PROGRESSONLY;
    public static INSTALLUILEVEL INSTALLUILEVEL_HIDECANCEL;
    public static INSTALLUILEVEL INSTALLUILEVEL_SOURCERESONLY;
    public static INSTALLUILEVEL INSTALLUILEVEL_UACONLY;
}
[FlagsAttribute]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal enum Windows.Win32.System.Services.ENUM_SERVICE_TYPE : Enum {
    public UInt32 value__;
    public static ENUM_SERVICE_TYPE SERVICE_DRIVER;
    public static ENUM_SERVICE_TYPE SERVICE_KERNEL_DRIVER;
    public static ENUM_SERVICE_TYPE SERVICE_WIN32;
    public static ENUM_SERVICE_TYPE SERVICE_WIN32_SHARE_PROCESS;
    public static ENUM_SERVICE_TYPE SERVICE_ADAPTER;
    public static ENUM_SERVICE_TYPE SERVICE_FILE_SYSTEM_DRIVER;
    public static ENUM_SERVICE_TYPE SERVICE_RECOGNIZER_DRIVER;
    public static ENUM_SERVICE_TYPE SERVICE_WIN32_OWN_PROCESS;
    public static ENUM_SERVICE_TYPE SERVICE_USER_OWN_PROCESS;
    public static ENUM_SERVICE_TYPE SERVICE_USER_SHARE_PROCESS;
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal enum Windows.Win32.System.Services.SERVICE_CONFIG : Enum {
    public UInt32 value__;
    public static SERVICE_CONFIG SERVICE_CONFIG_DELAYED_AUTO_START_INFO;
    public static SERVICE_CONFIG SERVICE_CONFIG_DESCRIPTION;
    public static SERVICE_CONFIG SERVICE_CONFIG_FAILURE_ACTIONS;
    public static SERVICE_CONFIG SERVICE_CONFIG_FAILURE_ACTIONS_FLAG;
    public static SERVICE_CONFIG SERVICE_CONFIG_PREFERRED_NODE;
    public static SERVICE_CONFIG SERVICE_CONFIG_PRESHUTDOWN_INFO;
    public static SERVICE_CONFIG SERVICE_CONFIG_REQUIRED_PRIVILEGES_INFO;
    public static SERVICE_CONFIG SERVICE_CONFIG_SERVICE_SID_INFO;
    public static SERVICE_CONFIG SERVICE_CONFIG_TRIGGER_INFO;
    public static SERVICE_CONFIG SERVICE_CONFIG_LAUNCH_PROTECTED;
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal class Windows.Win32.System.Services.SERVICE_DESCRIPTIONW : ValueType {
    internal PWSTR lpDescription;
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal enum Windows.Win32.System.Services.SERVICE_ERROR : Enum {
    public UInt32 value__;
    public static SERVICE_ERROR SERVICE_ERROR_CRITICAL;
    public static SERVICE_ERROR SERVICE_ERROR_IGNORE;
    public static SERVICE_ERROR SERVICE_ERROR_NORMAL;
    public static SERVICE_ERROR SERVICE_ERROR_SEVERE;
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal enum Windows.Win32.System.Services.SERVICE_START_TYPE : Enum {
    public UInt32 value__;
    public static SERVICE_START_TYPE SERVICE_AUTO_START;
    public static SERVICE_START_TYPE SERVICE_BOOT_START;
    public static SERVICE_START_TYPE SERVICE_DEMAND_START;
    public static SERVICE_START_TYPE SERVICE_DISABLED;
    public static SERVICE_START_TYPE SERVICE_SYSTEM_START;
}
[FlagsAttribute]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal enum Windows.Win32.System.Threading.PROCESS_ACCESS_RIGHTS : Enum {
    public UInt32 value__;
    public static PROCESS_ACCESS_RIGHTS PROCESS_TERMINATE;
    public static PROCESS_ACCESS_RIGHTS PROCESS_CREATE_THREAD;
    public static PROCESS_ACCESS_RIGHTS PROCESS_SET_SESSIONID;
    public static PROCESS_ACCESS_RIGHTS PROCESS_VM_OPERATION;
    public static PROCESS_ACCESS_RIGHTS PROCESS_VM_READ;
    public static PROCESS_ACCESS_RIGHTS PROCESS_VM_WRITE;
    public static PROCESS_ACCESS_RIGHTS PROCESS_DUP_HANDLE;
    public static PROCESS_ACCESS_RIGHTS PROCESS_CREATE_PROCESS;
    public static PROCESS_ACCESS_RIGHTS PROCESS_SET_QUOTA;
    public static PROCESS_ACCESS_RIGHTS PROCESS_SET_INFORMATION;
    public static PROCESS_ACCESS_RIGHTS PROCESS_QUERY_INFORMATION;
    public static PROCESS_ACCESS_RIGHTS PROCESS_SUSPEND_RESUME;
    public static PROCESS_ACCESS_RIGHTS PROCESS_QUERY_LIMITED_INFORMATION;
    public static PROCESS_ACCESS_RIGHTS PROCESS_SET_LIMITED_INFORMATION;
    public static PROCESS_ACCESS_RIGHTS PROCESS_ALL_ACCESS;
    public static PROCESS_ACCESS_RIGHTS PROCESS_DELETE;
    public static PROCESS_ACCESS_RIGHTS PROCESS_READ_CONTROL;
    public static PROCESS_ACCESS_RIGHTS PROCESS_WRITE_DAC;
    public static PROCESS_ACCESS_RIGHTS PROCESS_WRITE_OWNER;
    public static PROCESS_ACCESS_RIGHTS PROCESS_SYNCHRONIZE;
    public static PROCESS_ACCESS_RIGHTS PROCESS_STANDARD_RIGHTS_REQUIRED;
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal enum Windows.Win32.System.Threading.PROCESS_NAME_FORMAT : Enum {
    public UInt32 value__;
    public static PROCESS_NAME_FORMAT PROCESS_NAME_WIN32;
    public static PROCESS_NAME_FORMAT PROCESS_NAME_NATIVE;
}
[ExtensionAttribute]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal static class Windows.Win32.UI_Shell_Folder_Extensions : object {
    [ExtensionAttribute]
internal static FolderItem ParseName(Folder this, SafeHandle bName);
    [ExtensionAttribute]
internal static void NewFolder(Folder this, SafeHandle bName, object vOptions);
}
[FlagsAttribute]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal enum Windows.Win32.UI.Shell._SVGIO : Enum {
    public int value__;
    public static _SVGIO SVGIO_BACKGROUND;
    public static _SVGIO SVGIO_SELECTION;
    public static _SVGIO SVGIO_ALLVIEW;
    public static _SVGIO SVGIO_CHECKED;
    public static _SVGIO SVGIO_TYPE_MASK;
    public static _SVGIO SVGIO_FLAG_VIEWORDER;
}
[GuidAttribute("BBCBDE60-C3FF-11CE-8350-444553540000")]
[InterfaceTypeAttribute("0")]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal interface Windows.Win32.UI.Shell.Folder {
    public BSTR Title { get; }
    public object Application { get; }
    public object Parent { get; }
    public Folder ParentFolder { get; }
    public abstract virtual BSTR get_Title();
    public abstract virtual object get_Application();
    public abstract virtual object get_Parent();
    public abstract virtual Folder get_ParentFolder();
    public abstract virtual FolderItems Items();
    public abstract virtual FolderItem ParseName(BSTR bName);
    public abstract virtual void NewFolder(BSTR bName, object vOptions);
    public abstract virtual void MoveHere(object vItem, object vOptions);
    public abstract virtual void CopyHere(object vItem, object vOptions);
    public abstract virtual BSTR GetDetailsOf(object vItem, int iColumn);
}
[GuidAttribute("FAC32C80-CBE4-11CE-8350-444553540000")]
[InterfaceTypeAttribute("0")]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal interface Windows.Win32.UI.Shell.FolderItem {
    public object Application { get; }
    public object Parent { get; }
    public BSTR Name { get; public set; }
    public BSTR Path { get; }
    public object GetLink { get; }
    public object GetFolder { get; }
    public VARIANT_BOOL IsLink { get; }
    public VARIANT_BOOL IsFolder { get; }
    public VARIANT_BOOL IsFileSystem { get; }
    public VARIANT_BOOL IsBrowsable { get; }
    public double ModifyDate { get; public set; }
    public int Size { get; }
    public BSTR Type { get; }
    public abstract virtual object get_Application();
    public abstract virtual object get_Parent();
    public abstract virtual BSTR get_Name();
    public abstract virtual void set_Name(BSTR value);
    public abstract virtual BSTR get_Path();
    public abstract virtual object get_GetLink();
    public abstract virtual object get_GetFolder();
    public abstract virtual VARIANT_BOOL get_IsLink();
    public abstract virtual VARIANT_BOOL get_IsFolder();
    public abstract virtual VARIANT_BOOL get_IsFileSystem();
    public abstract virtual VARIANT_BOOL get_IsBrowsable();
    public abstract virtual double get_ModifyDate();
    public abstract virtual void set_ModifyDate(double value);
    public abstract virtual int get_Size();
    public abstract virtual BSTR get_Type();
    public abstract virtual FolderItemVerbs Verbs();
    public abstract virtual void InvokeVerb(object vVerb);
}
[GuidAttribute("744129E0-CBE5-11CE-8350-444553540000")]
[InterfaceTypeAttribute("0")]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal interface Windows.Win32.UI.Shell.FolderItems {
    public int Count { get; }
    public object Application { get; }
    public object Parent { get; }
    public abstract virtual int get_Count();
    public abstract virtual object get_Application();
    public abstract virtual object get_Parent();
    public abstract virtual FolderItem Item(object index);
    public abstract virtual object _NewEnum();
}
[GuidAttribute("08EC3E00-50B0-11CF-960C-0080C7F4EE85")]
[InterfaceTypeAttribute("0")]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal interface Windows.Win32.UI.Shell.FolderItemVerb {
    public object Application { get; }
    public object Parent { get; }
    public BSTR Name { get; }
    public abstract virtual object get_Application();
    public abstract virtual object get_Parent();
    public abstract virtual BSTR get_Name();
    public abstract virtual void DoIt();
}
[GuidAttribute("1F8352C0-50B0-11CF-960C-0080C7F4EE85")]
[InterfaceTypeAttribute("0")]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal interface Windows.Win32.UI.Shell.FolderItemVerbs {
    public int Count { get; }
    public object Application { get; }
    public object Parent { get; }
    public abstract virtual int get_Count();
    public abstract virtual object get_Application();
    public abstract virtual object get_Parent();
    public abstract virtual FolderItemVerb Item(object index);
    public abstract virtual object _NewEnum();
}
[GuidAttribute("E7A1AF80-4D96-11CF-960C-0080C7F4EE85")]
[InterfaceTypeAttribute("0")]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal interface Windows.Win32.UI.Shell.IShellFolderViewDual {
    public object Application { get; }
    public object Parent { get; }
    public Folder Folder { get; }
    public FolderItem FocusedItem { get; }
    public object Script { get; }
    public int ViewOptions { get; }
    public abstract virtual object get_Application();
    public abstract virtual object get_Parent();
    public abstract virtual Folder get_Folder();
    public abstract virtual FolderItems SelectedItems();
    public abstract virtual FolderItem get_FocusedItem();
    public abstract virtual void SelectItem(Object& modreq(System.Runtime.InteropServices.InAttribute) pvfi, int dwFlags);
    public abstract virtual BSTR PopupItemMenu(FolderItem pfi, object vx, object vy);
    public abstract virtual object get_Script();
    public abstract virtual int get_ViewOptions();
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal enum Windows.Win32.UI.Shell.ShellWindowFindWindowOptions : Enum {
    public int value__;
    public static ShellWindowFindWindowOptions SWFO_NEEDDISPATCH;
    public static ShellWindowFindWindowOptions SWFO_INCLUDEPENDING;
    public static ShellWindowFindWindowOptions SWFO_COOKIEPASSED;
}
[GuidAttribute("9BA05972-F6A8-11CF-A442-00A0C90A8F39")]
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal class Windows.Win32.UI.Shell.ShellWindows : object {
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal enum Windows.Win32.UI.Shell.ShellWindowTypeConstants : Enum {
    public int value__;
    public static ShellWindowTypeConstants SWC_EXPLORER;
    public static ShellWindowTypeConstants SWC_BROWSER;
    public static ShellWindowTypeConstants SWC_3RDPARTY;
    public static ShellWindowTypeConstants SWC_CALLBACK;
    public static ShellWindowTypeConstants SWC_DESKTOP;
}
[GeneratedCodeAttribute("Microsoft.Windows.CsWin32", "0.3.46-beta+dd815b2b9b")]
internal enum Windows.Win32.UI.WindowsAndMessaging.SHOW_WINDOW_CMD : Enum {
    public int value__;
    public static SHOW_WINDOW_CMD SW_HIDE;
    public static SHOW_WINDOW_CMD SW_SHOWNORMAL;
    public static SHOW_WINDOW_CMD SW_NORMAL;
    public static SHOW_WINDOW_CMD SW_SHOWMINIMIZED;
    public static SHOW_WINDOW_CMD SW_SHOWMAXIMIZED;
    public static SHOW_WINDOW_CMD SW_MAXIMIZE;
    public static SHOW_WINDOW_CMD SW_SHOWNOACTIVATE;
    public static SHOW_WINDOW_CMD SW_SHOW;
    public static SHOW_WINDOW_CMD SW_MINIMIZE;
    public static SHOW_WINDOW_CMD SW_SHOWMINNOACTIVE;
    public static SHOW_WINDOW_CMD SW_SHOWNA;
    public static SHOW_WINDOW_CMD SW_RESTORE;
    public static SHOW_WINDOW_CMD SW_SHOWDEFAULT;
    public static SHOW_WINDOW_CMD SW_FORCEMINIMIZE;
    public static SHOW_WINDOW_CMD SW_MAX;
}
[CompilerGeneratedAttribute]
[TypeIdentifierAttribute("E34CB9F1-C7F7-424C-BE29-027DCC09363A", "WindowsTaskSchedulerInterop._TASK_ACTION_TYPE")]
public enum WindowsTaskSchedulerInterop._TASK_ACTION_TYPE : Enum {
    public int value__;
    public static _TASK_ACTION_TYPE TASK_ACTION_EXEC;
    public static _TASK_ACTION_TYPE TASK_ACTION_COM_HANDLER;
    public static _TASK_ACTION_TYPE TASK_ACTION_SEND_EMAIL;
    public static _TASK_ACTION_TYPE TASK_ACTION_SHOW_MESSAGE;
}
[CompilerGeneratedAttribute]
[TypeIdentifierAttribute("E34CB9F1-C7F7-424C-BE29-027DCC09363A", "WindowsTaskSchedulerInterop._TASK_COMPATIBILITY")]
public enum WindowsTaskSchedulerInterop._TASK_COMPATIBILITY : Enum {
    public int value__;
    public static _TASK_COMPATIBILITY TASK_COMPATIBILITY_AT;
    public static _TASK_COMPATIBILITY TASK_COMPATIBILITY_V1;
    public static _TASK_COMPATIBILITY TASK_COMPATIBILITY_V2;
    public static _TASK_COMPATIBILITY TASK_COMPATIBILITY_V2_1;
    public static _TASK_COMPATIBILITY TASK_COMPATIBILITY_V2_2;
    public static _TASK_COMPATIBILITY TASK_COMPATIBILITY_V2_3;
    public static _TASK_COMPATIBILITY TASK_COMPATIBILITY_V2_4;
}
[CompilerGeneratedAttribute]
[TypeIdentifierAttribute("E34CB9F1-C7F7-424C-BE29-027DCC09363A", "WindowsTaskSchedulerInterop._TASK_CREATION")]
public enum WindowsTaskSchedulerInterop._TASK_CREATION : Enum {
    public int value__;
    public static _TASK_CREATION TASK_VALIDATE_ONLY;
    public static _TASK_CREATION TASK_CREATE;
    public static _TASK_CREATION TASK_UPDATE;
    public static _TASK_CREATION TASK_CREATE_OR_UPDATE;
    public static _TASK_CREATION TASK_DISABLE;
    public static _TASK_CREATION TASK_DONT_ADD_PRINCIPAL_ACE;
    public static _TASK_CREATION TASK_IGNORE_REGISTRATION_TRIGGERS;
}
[CompilerGeneratedAttribute]
[TypeIdentifierAttribute("E34CB9F1-C7F7-424C-BE29-027DCC09363A", "WindowsTaskSchedulerInterop._TASK_INSTANCES_POLICY")]
public enum WindowsTaskSchedulerInterop._TASK_INSTANCES_POLICY : Enum {
    public int value__;
    public static _TASK_INSTANCES_POLICY TASK_INSTANCES_PARALLEL;
    public static _TASK_INSTANCES_POLICY TASK_INSTANCES_QUEUE;
    public static _TASK_INSTANCES_POLICY TASK_INSTANCES_IGNORE_NEW;
    public static _TASK_INSTANCES_POLICY TASK_INSTANCES_STOP_EXISTING;
}
[CompilerGeneratedAttribute]
[TypeIdentifierAttribute("E34CB9F1-C7F7-424C-BE29-027DCC09363A", "WindowsTaskSchedulerInterop._TASK_LOGON_TYPE")]
public enum WindowsTaskSchedulerInterop._TASK_LOGON_TYPE : Enum {
    public int value__;
    public static _TASK_LOGON_TYPE TASK_LOGON_NONE;
    public static _TASK_LOGON_TYPE TASK_LOGON_PASSWORD;
    public static _TASK_LOGON_TYPE TASK_LOGON_S4U;
    public static _TASK_LOGON_TYPE TASK_LOGON_INTERACTIVE_TOKEN;
    public static _TASK_LOGON_TYPE TASK_LOGON_GROUP;
    public static _TASK_LOGON_TYPE TASK_LOGON_SERVICE_ACCOUNT;
    public static _TASK_LOGON_TYPE TASK_LOGON_INTERACTIVE_TOKEN_OR_PASSWORD;
}
[CompilerGeneratedAttribute]
[TypeIdentifierAttribute("E34CB9F1-C7F7-424C-BE29-027DCC09363A", "WindowsTaskSchedulerInterop._TASK_RUNLEVEL")]
public enum WindowsTaskSchedulerInterop._TASK_RUNLEVEL : Enum {
    public int value__;
    public static _TASK_RUNLEVEL TASK_RUNLEVEL_LUA;
    public static _TASK_RUNLEVEL TASK_RUNLEVEL_HIGHEST;
}
[CompilerGeneratedAttribute]
[TypeIdentifierAttribute("E34CB9F1-C7F7-424C-BE29-027DCC09363A", "WindowsTaskSchedulerInterop._TASK_TRIGGER_TYPE2")]
public enum WindowsTaskSchedulerInterop._TASK_TRIGGER_TYPE2 : Enum {
    public int value__;
    public static _TASK_TRIGGER_TYPE2 TASK_TRIGGER_EVENT;
    public static _TASK_TRIGGER_TYPE2 TASK_TRIGGER_TIME;
    public static _TASK_TRIGGER_TYPE2 TASK_TRIGGER_DAILY;
    public static _TASK_TRIGGER_TYPE2 TASK_TRIGGER_WEEKLY;
    public static _TASK_TRIGGER_TYPE2 TASK_TRIGGER_MONTHLY;
    public static _TASK_TRIGGER_TYPE2 TASK_TRIGGER_MONTHLYDOW;
    public static _TASK_TRIGGER_TYPE2 TASK_TRIGGER_IDLE;
    public static _TASK_TRIGGER_TYPE2 TASK_TRIGGER_REGISTRATION;
    public static _TASK_TRIGGER_TYPE2 TASK_TRIGGER_BOOT;
    public static _TASK_TRIGGER_TYPE2 TASK_TRIGGER_LOGON;
    public static _TASK_TRIGGER_TYPE2 TASK_TRIGGER_SESSION_STATE_CHANGE;
    public static _TASK_TRIGGER_TYPE2 TASK_TRIGGER_CUSTOM_TRIGGER_01;
}
[CompilerGeneratedAttribute]
[GuidAttribute("BAE54997-48B1-4CBE-9965-D6BE263EBEA4")]
[TypeIdentifierAttribute]
public interface WindowsTaskSchedulerInterop.IAction {
}
[CompilerGeneratedAttribute]
[GuidAttribute("02820E19-7B98-4ED2-B2E8-FDCCCEFF619B")]
[DefaultMemberAttribute("Item")]
[TypeIdentifierAttribute]
public interface WindowsTaskSchedulerInterop.IActionCollection {
    public void _VtblGap1_5();
    [DispIdAttribute("3")]
public abstract virtual IAction Create(_TASK_ACTION_TYPE Type);
}
[CompilerGeneratedAttribute]
[GuidAttribute("2A9C35DA-D357-41F4-BBC1-207AC1B1F3CB")]
[TypeIdentifierAttribute]
public interface WindowsTaskSchedulerInterop.IBootTrigger {
    [DispIdAttribute("2")]
public string Id { get; public set; }
    [DispIdAttribute("3")]
public IRepetitionPattern Repetition { get; public set; }
    [DispIdAttribute("5")]
public string StartBoundary { get; public set; }
    [DispIdAttribute("20")]
public string Delay { get; public set; }
    public void _VtblGap1_1();
    [DispIdAttribute("2")]
public abstract virtual string get_Id();
    [DispIdAttribute("2")]
public abstract virtual void set_Id(string pId);
    [DispIdAttribute("3")]
public abstract virtual IRepetitionPattern get_Repetition();
    [DispIdAttribute("3")]
public abstract virtual void set_Repetition(IRepetitionPattern ppRepeat);
    public void _VtblGap2_2();
    [DispIdAttribute("5")]
public abstract virtual string get_StartBoundary();
    [DispIdAttribute("5")]
public abstract virtual void set_StartBoundary(string pStart);
    public void _VtblGap3_4();
    [DispIdAttribute("20")]
public abstract virtual string get_Delay();
    [DispIdAttribute("20")]
public abstract virtual void set_Delay(string pDelay);
}
[CompilerGeneratedAttribute]
[GuidAttribute("126C5CD8-B288-41D5-8DBF-E491446ADC5C")]
[TypeIdentifierAttribute]
public interface WindowsTaskSchedulerInterop.IDailyTrigger {
    [DispIdAttribute("2")]
public string Id { get; public set; }
    [DispIdAttribute("5")]
public string StartBoundary { get; public set; }
    [DispIdAttribute("25")]
public short DaysInterval { get; public set; }
    public void _VtblGap1_1();
    [DispIdAttribute("2")]
public abstract virtual string get_Id();
    [DispIdAttribute("2")]
public abstract virtual void set_Id(string pId);
    public void _VtblGap2_4();
    [DispIdAttribute("5")]
public abstract virtual string get_StartBoundary();
    [DispIdAttribute("5")]
public abstract virtual void set_StartBoundary(string pStart);
    public void _VtblGap3_4();
    [DispIdAttribute("25")]
public abstract virtual short get_DaysInterval();
    [DispIdAttribute("25")]
public abstract virtual void set_DaysInterval(short pDays);
}
[CompilerGeneratedAttribute]
[GuidAttribute("4C3D624D-FD6B-49A3-B9B7-09CB3CD3F047")]
[TypeIdentifierAttribute]
public interface WindowsTaskSchedulerInterop.IExecAction {
    [DispIdAttribute("1")]
public string Id { get; public set; }
    [DispIdAttribute("10")]
public string Path { get; public set; }
    [DispIdAttribute("11")]
public string Arguments { get; public set; }
    [DispIdAttribute("12")]
public string WorkingDirectory { get; public set; }
    [DispIdAttribute("1")]
public abstract virtual string get_Id();
    [DispIdAttribute("1")]
public abstract virtual void set_Id(string pId);
    public void _VtblGap1_1();
    [DispIdAttribute("10")]
public abstract virtual string get_Path();
    [DispIdAttribute("10")]
public abstract virtual void set_Path(string pPath);
    [DispIdAttribute("11")]
public abstract virtual string get_Arguments();
    [DispIdAttribute("11")]
public abstract virtual void set_Arguments(string pArgument);
    [DispIdAttribute("12")]
public abstract virtual string get_WorkingDirectory();
    [DispIdAttribute("12")]
public abstract virtual void set_WorkingDirectory(string pWorkingDirectory);
}
[CompilerGeneratedAttribute]
[GuidAttribute("84594461-0053-4342-A8FD-088FABF11F32")]
[TypeIdentifierAttribute]
public interface WindowsTaskSchedulerInterop.IIdleSettings {
    [DispIdAttribute("1")]
public string IdleDuration { get; public set; }
    [DispIdAttribute("3")]
public bool StopOnIdleEnd { get; public set; }
    [DispIdAttribute("1")]
public abstract virtual string get_IdleDuration();
    [DispIdAttribute("1")]
public abstract virtual void set_IdleDuration(string pDelay);
    public void _VtblGap1_2();
    [DispIdAttribute("3")]
public abstract virtual bool get_StopOnIdleEnd();
    [DispIdAttribute("3")]
public abstract virtual void set_StopOnIdleEnd(bool pStop);
}
[CompilerGeneratedAttribute]
[GuidAttribute("D537D2B0-9FB3-4D34-9739-1FF5CE7B1EF3")]
[TypeIdentifierAttribute]
public interface WindowsTaskSchedulerInterop.IIdleTrigger {
    [DispIdAttribute("2")]
public string Id { get; public set; }
    [DispIdAttribute("5")]
public string StartBoundary { get; public set; }
    public void _VtblGap1_1();
    [DispIdAttribute("2")]
public abstract virtual string get_Id();
    [DispIdAttribute("2")]
public abstract virtual void set_Id(string pId);
    public void _VtblGap2_4();
    [DispIdAttribute("5")]
public abstract virtual string get_StartBoundary();
    [DispIdAttribute("5")]
public abstract virtual void set_StartBoundary(string pStart);
}
[CompilerGeneratedAttribute]
[GuidAttribute("72DADE38-FAE4-4B3E-BAF4-5D009AF02B1C")]
[TypeIdentifierAttribute]
public interface WindowsTaskSchedulerInterop.ILogonTrigger {
    [DispIdAttribute("2")]
public string Id { get; public set; }
    [DispIdAttribute("5")]
public string StartBoundary { get; public set; }
    [DispIdAttribute("20")]
public string Delay { get; public set; }
    [DispIdAttribute("21")]
public string UserId { get; public set; }
    public void _VtblGap1_1();
    [DispIdAttribute("2")]
public abstract virtual string get_Id();
    [DispIdAttribute("2")]
public abstract virtual void set_Id(string pId);
    public void _VtblGap2_4();
    [DispIdAttribute("5")]
public abstract virtual string get_StartBoundary();
    [DispIdAttribute("5")]
public abstract virtual void set_StartBoundary(string pStart);
    public void _VtblGap3_4();
    [DispIdAttribute("20")]
public abstract virtual string get_Delay();
    [DispIdAttribute("20")]
public abstract virtual void set_Delay(string pDelay);
    [DispIdAttribute("21")]
public abstract virtual string get_UserId();
    [DispIdAttribute("21")]
public abstract virtual void set_UserId(string pUser);
}
[CompilerGeneratedAttribute]
[GuidAttribute("97C45EF1-6B02-4A1A-9C0E-1EBFBA1500AC")]
[TypeIdentifierAttribute]
public interface WindowsTaskSchedulerInterop.IMonthlyTrigger {
    [DispIdAttribute("2")]
public string Id { get; public set; }
    [DispIdAttribute("5")]
public string StartBoundary { get; public set; }
    [DispIdAttribute("25")]
public int DaysOfMonth { get; public set; }
    [DispIdAttribute("26")]
public short MonthsOfYear { get; public set; }
    public void _VtblGap1_1();
    [DispIdAttribute("2")]
public abstract virtual string get_Id();
    [DispIdAttribute("2")]
public abstract virtual void set_Id(string pId);
    public void _VtblGap2_4();
    [DispIdAttribute("5")]
public abstract virtual string get_StartBoundary();
    [DispIdAttribute("5")]
public abstract virtual void set_StartBoundary(string pStart);
    public void _VtblGap3_4();
    [DispIdAttribute("25")]
public abstract virtual int get_DaysOfMonth();
    [DispIdAttribute("25")]
public abstract virtual void set_DaysOfMonth(int pDays);
    [DispIdAttribute("26")]
public abstract virtual short get_MonthsOfYear();
    [DispIdAttribute("26")]
public abstract virtual void set_MonthsOfYear(short pMonths);
}
[CompilerGeneratedAttribute]
[GuidAttribute("D98D51E5-C9B4-496A-A9C1-18980261CF0F")]
[TypeIdentifierAttribute]
public interface WindowsTaskSchedulerInterop.IPrincipal {
    [DispIdAttribute("3")]
public string UserId { get; public set; }
    [DispIdAttribute("4")]
public _TASK_LOGON_TYPE LogonType { get; public set; }
    [DispIdAttribute("6")]
public _TASK_RUNLEVEL RunLevel { get; public set; }
    public void _VtblGap1_4();
    [DispIdAttribute("3")]
public abstract virtual string get_UserId();
    [DispIdAttribute("3")]
public abstract virtual void set_UserId(string pUser);
    [DispIdAttribute("4")]
public abstract virtual _TASK_LOGON_TYPE get_LogonType();
    [DispIdAttribute("4")]
public abstract virtual void set_LogonType(_TASK_LOGON_TYPE pLogon);
    public void _VtblGap2_2();
    [DispIdAttribute("6")]
public abstract virtual _TASK_RUNLEVEL get_RunLevel();
    [DispIdAttribute("6")]
public abstract virtual void set_RunLevel(_TASK_RUNLEVEL pRunLevel);
}
[CompilerGeneratedAttribute]
[GuidAttribute("9C86F320-DEE3-4DD1-B972-A303F26B061E")]
[DefaultMemberAttribute("Path")]
[TypeIdentifierAttribute]
public interface WindowsTaskSchedulerInterop.IRegisteredTask {
    [DispIdAttribute("1")]
public string Name { get; }
    [DispIdAttribute("0")]
public string Path { get; }
    [DispIdAttribute("13")]
public ITaskDefinition Definition { get; }
    [DispIdAttribute("1")]
public abstract virtual string get_Name();
    [DispIdAttribute("0")]
public abstract virtual string get_Path();
    public void _VtblGap1_10();
    [DispIdAttribute("13")]
public abstract virtual ITaskDefinition get_Definition();
}
[CompilerGeneratedAttribute]
[DefaultMemberAttribute("Item")]
[GuidAttribute("86627EB4-42A7-41E4-A4D9-AC33A72F2D52")]
[TypeIdentifierAttribute]
public interface WindowsTaskSchedulerInterop.IRegisteredTaskCollection {
    public void _VtblGap1_2();
    [DispIdAttribute("-4")]
public abstract virtual IEnumerator GetEnumerator();
}
[CompilerGeneratedAttribute]
[GuidAttribute("416D8B73-CB41-4EA1-805C-9BE9A5AC4A74")]
[TypeIdentifierAttribute]
public interface WindowsTaskSchedulerInterop.IRegistrationInfo {
    [DispIdAttribute("1")]
public string Description { get; public set; }
    [DispIdAttribute("2")]
public string Author { get; public set; }
    [DispIdAttribute("5")]
public string Date { get; public set; }
    [DispIdAttribute("1")]
public abstract virtual string get_Description();
    [DispIdAttribute("1")]
public abstract virtual void set_Description(string pDescription);
    [DispIdAttribute("2")]
public abstract virtual string get_Author();
    [DispIdAttribute("2")]
public abstract virtual void set_Author(string pAuthor);
    public void _VtblGap1_2();
    [DispIdAttribute("5")]
public abstract virtual string get_Date();
    [DispIdAttribute("5")]
public abstract virtual void set_Date(string pDate);
}
[CompilerGeneratedAttribute]
[GuidAttribute("7FB9ACF1-26BE-400E-85B5-294B9C75DFD6")]
[TypeIdentifierAttribute]
public interface WindowsTaskSchedulerInterop.IRepetitionPattern {
    [DispIdAttribute("1")]
public string Interval { get; public set; }
    [DispIdAttribute("1")]
public abstract virtual string get_Interval();
    [DispIdAttribute("1")]
public abstract virtual void set_Interval(string pInterval);
}
[CompilerGeneratedAttribute]
[GuidAttribute("F5BC8FC5-536D-4F77-B852-FBC1356FDEB6")]
[TypeIdentifierAttribute]
public interface WindowsTaskSchedulerInterop.ITaskDefinition {
    [DispIdAttribute("1")]
public IRegistrationInfo RegistrationInfo { get; public set; }
    [DispIdAttribute("2")]
public ITriggerCollection Triggers { get; public set; }
    [DispIdAttribute("7")]
public ITaskSettings Settings { get; public set; }
    [DispIdAttribute("12")]
public IPrincipal Principal { get; public set; }
    [DispIdAttribute("13")]
public IActionCollection Actions { get; public set; }
    [DispIdAttribute("1")]
public abstract virtual IRegistrationInfo get_RegistrationInfo();
    [DispIdAttribute("1")]
public abstract virtual void set_RegistrationInfo(IRegistrationInfo ppRegistrationInfo);
    [DispIdAttribute("2")]
public abstract virtual ITriggerCollection get_Triggers();
    [DispIdAttribute("2")]
public abstract virtual void set_Triggers(ITriggerCollection ppTriggers);
    [DispIdAttribute("7")]
public abstract virtual ITaskSettings get_Settings();
    [DispIdAttribute("7")]
public abstract virtual void set_Settings(ITaskSettings ppSettings);
    public void _VtblGap1_2();
    [DispIdAttribute("12")]
public abstract virtual IPrincipal get_Principal();
    [DispIdAttribute("12")]
public abstract virtual void set_Principal(IPrincipal ppPrincipal);
    [DispIdAttribute("13")]
public abstract virtual IActionCollection get_Actions();
    [DispIdAttribute("13")]
public abstract virtual void set_Actions(IActionCollection ppActions);
}
[CompilerGeneratedAttribute]
[DefaultMemberAttribute("Path")]
[GuidAttribute("8CFAC062-A080-4C15-9A88-AA7C2AF80DFC")]
[TypeIdentifierAttribute]
public interface WindowsTaskSchedulerInterop.ITaskFolder {
    [DispIdAttribute("1")]
public string Name { get; }
    [DispIdAttribute("0")]
public string Path { get; }
    [DispIdAttribute("1")]
public abstract virtual string get_Name();
    [DispIdAttribute("0")]
public abstract virtual string get_Path();
    public void _VtblGap1_1();
    [DispIdAttribute("4")]
public abstract virtual ITaskFolderCollection GetFolders(int flags);
    [DispIdAttribute("5")]
public abstract virtual ITaskFolder CreateFolder(string subFolderName, object sddl);
    [DispIdAttribute("6")]
public abstract virtual void DeleteFolder(string subFolderName, int flags);
    [DispIdAttribute("7")]
public abstract virtual IRegisteredTask GetTask(string Path);
    [DispIdAttribute("8")]
public abstract virtual IRegisteredTaskCollection GetTasks(int flags);
    [DispIdAttribute("9")]
public abstract virtual void DeleteTask(string Name, int flags);
    [DispIdAttribute("10")]
public abstract virtual IRegisteredTask RegisterTask(string Path, string XmlText, int flags, object UserId, object password, _TASK_LOGON_TYPE LogonType, object sddl);
    [DispIdAttribute("11")]
public abstract virtual IRegisteredTask RegisterTaskDefinition(string Path, ITaskDefinition pDefinition, int flags, object UserId, object password, _TASK_LOGON_TYPE LogonType, object sddl);
}
[CompilerGeneratedAttribute]
[GuidAttribute("79184A66-8664-423F-97F1-637356A5D812")]
[DefaultMemberAttribute("Item")]
[TypeIdentifierAttribute]
public interface WindowsTaskSchedulerInterop.ITaskFolderCollection {
    public void _VtblGap1_2();
    [DispIdAttribute("-4")]
public abstract virtual IEnumerator GetEnumerator();
}
[CompilerGeneratedAttribute]
[GuidAttribute("2FABA4C7-4DA9-4013-9697-20CC3FD40F85")]
[DefaultMemberAttribute("TargetServer")]
[TypeIdentifierAttribute]
public interface WindowsTaskSchedulerInterop.ITaskService {
    [DispIdAttribute("0")]
public string TargetServer { get; }
    [DispIdAttribute("1")]
public abstract virtual ITaskFolder GetFolder(string Path);
    public void _VtblGap1_1();
    [DispIdAttribute("3")]
public abstract virtual ITaskDefinition NewTask(UInt32 flags);
    [DispIdAttribute("4")]
public abstract virtual void Connect(object serverName, object user, object domain, object password);
    public void _VtblGap2_1();
    [DispIdAttribute("0")]
public abstract virtual string get_TargetServer();
}
[CompilerGeneratedAttribute]
[GuidAttribute("8FD4711D-2D02-4C8C-87E3-EFF699DE127E")]
[TypeIdentifierAttribute]
public interface WindowsTaskSchedulerInterop.ITaskSettings {
    [DispIdAttribute("6")]
public _TASK_INSTANCES_POLICY MultipleInstances { get; public set; }
    [DispIdAttribute("7")]
public bool StopIfGoingOnBatteries { get; public set; }
    [DispIdAttribute("8")]
public bool DisallowStartIfOnBatteries { get; public set; }
    [DispIdAttribute("12")]
public bool RunOnlyIfNetworkAvailable { get; public set; }
    [DispIdAttribute("13")]
public string ExecutionTimeLimit { get; public set; }
    [DispIdAttribute("17")]
public _TASK_COMPATIBILITY Compatibility { get; public set; }
    [DispIdAttribute("18")]
public bool Hidden { get; public set; }
    [DispIdAttribute("19")]
public IIdleSettings IdleSettings { get; public set; }
    [DispIdAttribute("20")]
public bool RunOnlyIfIdle { get; public set; }
    public void _VtblGap1_6();
    [DispIdAttribute("6")]
public abstract virtual _TASK_INSTANCES_POLICY get_MultipleInstances();
    [DispIdAttribute("6")]
public abstract virtual void set_MultipleInstances(_TASK_INSTANCES_POLICY pPolicy);
    [DispIdAttribute("7")]
public abstract virtual bool get_StopIfGoingOnBatteries();
    [DispIdAttribute("7")]
public abstract virtual void set_StopIfGoingOnBatteries(bool pStopIfOnBatteries);
    [DispIdAttribute("8")]
public abstract virtual bool get_DisallowStartIfOnBatteries();
    [DispIdAttribute("8")]
public abstract virtual void set_DisallowStartIfOnBatteries(bool pDisallowStart);
    public void _VtblGap2_6();
    [DispIdAttribute("12")]
public abstract virtual bool get_RunOnlyIfNetworkAvailable();
    [DispIdAttribute("12")]
public abstract virtual void set_RunOnlyIfNetworkAvailable(bool pRunOnlyIfNetworkAvailable);
    [DispIdAttribute("13")]
public abstract virtual string get_ExecutionTimeLimit();
    [DispIdAttribute("13")]
public abstract virtual void set_ExecutionTimeLimit(string pExecutionTimeLimit);
    public void _VtblGap3_6();
    [DispIdAttribute("17")]
public abstract virtual _TASK_COMPATIBILITY get_Compatibility();
    [DispIdAttribute("17")]
public abstract virtual void set_Compatibility(_TASK_COMPATIBILITY pCompatLevel);
    [DispIdAttribute("18")]
public abstract virtual bool get_Hidden();
    [DispIdAttribute("18")]
public abstract virtual void set_Hidden(bool pHidden);
    [DispIdAttribute("19")]
public abstract virtual IIdleSettings get_IdleSettings();
    [DispIdAttribute("19")]
public abstract virtual void set_IdleSettings(IIdleSettings ppIdleSettings);
    [DispIdAttribute("20")]
public abstract virtual bool get_RunOnlyIfIdle();
    [DispIdAttribute("20")]
public abstract virtual void set_RunOnlyIfIdle(bool pRunOnlyIfIdle);
}
[CompilerGeneratedAttribute]
[GuidAttribute("B45747E0-EBA7-4276-9F29-85C5BB300006")]
[TypeIdentifierAttribute]
public interface WindowsTaskSchedulerInterop.ITimeTrigger {
    [DispIdAttribute("2")]
public string Id { get; public set; }
    [DispIdAttribute("3")]
public IRepetitionPattern Repetition { get; public set; }
    [DispIdAttribute("5")]
public string StartBoundary { get; public set; }
    public void _VtblGap1_1();
    [DispIdAttribute("2")]
public abstract virtual string get_Id();
    [DispIdAttribute("2")]
public abstract virtual void set_Id(string pId);
    [DispIdAttribute("3")]
public abstract virtual IRepetitionPattern get_Repetition();
    [DispIdAttribute("3")]
public abstract virtual void set_Repetition(IRepetitionPattern ppRepeat);
    public void _VtblGap2_2();
    [DispIdAttribute("5")]
public abstract virtual string get_StartBoundary();
    [DispIdAttribute("5")]
public abstract virtual void set_StartBoundary(string pStart);
}
[CompilerGeneratedAttribute]
[GuidAttribute("09941815-EA89-4B5B-89E0-2A773801FAC3")]
[TypeIdentifierAttribute]
public interface WindowsTaskSchedulerInterop.ITrigger {
}
[CompilerGeneratedAttribute]
[DefaultMemberAttribute("Item")]
[GuidAttribute("85DF5081-1B24-4F32-878A-D9D14DF4CB77")]
[TypeIdentifierAttribute]
public interface WindowsTaskSchedulerInterop.ITriggerCollection {
    public void _VtblGap1_3();
    [DispIdAttribute("2")]
public abstract virtual ITrigger Create(_TASK_TRIGGER_TYPE2 Type);
}
[CompilerGeneratedAttribute]
[GuidAttribute("5038FC98-82FF-436D-8728-A512A57C9DC1")]
[TypeIdentifierAttribute]
public interface WindowsTaskSchedulerInterop.IWeeklyTrigger {
    [DispIdAttribute("2")]
public string Id { get; public set; }
    [DispIdAttribute("5")]
public string StartBoundary { get; public set; }
    [DispIdAttribute("25")]
public short DaysOfWeek { get; public set; }
    [DispIdAttribute("26")]
public short WeeksInterval { get; public set; }
    public void _VtblGap1_1();
    [DispIdAttribute("2")]
public abstract virtual string get_Id();
    [DispIdAttribute("2")]
public abstract virtual void set_Id(string pId);
    public void _VtblGap2_4();
    [DispIdAttribute("5")]
public abstract virtual string get_StartBoundary();
    [DispIdAttribute("5")]
public abstract virtual void set_StartBoundary(string pStart);
    public void _VtblGap3_4();
    [DispIdAttribute("25")]
public abstract virtual short get_DaysOfWeek();
    [DispIdAttribute("25")]
public abstract virtual void set_DaysOfWeek(short pDays);
    [DispIdAttribute("26")]
public abstract virtual short get_WeeksInterval();
    [DispIdAttribute("26")]
public abstract virtual void set_WeeksInterval(short pWeeks);
}
[CompilerGeneratedAttribute]
[CoClassAttribute("System.Object")]
[GuidAttribute("2FABA4C7-4DA9-4013-9697-20CC3FD40F85")]
[TypeIdentifierAttribute]
public interface WindowsTaskSchedulerInterop.TaskScheduler {
}
