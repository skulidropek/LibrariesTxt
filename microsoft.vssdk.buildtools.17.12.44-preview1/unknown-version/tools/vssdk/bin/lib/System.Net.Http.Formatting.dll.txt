[ExtensionAttribute]
internal static class System.Collections.Generic.CollectionExtensions : object {
    [ExtensionAttribute]
public static T[] AppendAndReallocate(T[] array, T value);
    [ExtensionAttribute]
public static T[] AsArray(IEnumerable`1<T> values);
    [ExtensionAttribute]
public static Collection`1<T> AsCollection(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static IList`1<T> AsIList(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static List`1<T> AsList(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static void RemoveFrom(List`1<T> list, int start);
    [ExtensionAttribute]
public static T SingleDefaultOrError(IList`1<T> list, Action`1<TArg1> errorAction, TArg1 errorArg1);
    [ExtensionAttribute]
public static TMatch SingleOfTypeDefaultOrError(IList`1<TInput> list, Action`1<TArg1> errorAction, TArg1 errorArg1);
    [ExtensionAttribute]
public static T[] ToArrayWithoutNulls(ICollection`1<T> collection);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TValue> ToDictionaryFast(TValue[] array, Func`2<TValue, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TValue> ToDictionaryFast(IList`1<TValue> list, Func`2<TValue, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TValue> ToDictionaryFast(IEnumerable`1<TValue> enumerable, Func`2<TValue, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    private static Dictionary`2<TKey, TValue> ToDictionaryFastNoCheck(IList`1<TValue> list, Func`2<TValue, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
}
internal class System.Collections.ObjectModel.ListWrapperCollection`1 : Collection`1<T> {
    private List`1<T> _items;
    internal List`1<T> ItemsList { get; }
    internal ListWrapperCollection`1(List`1<T> list);
    internal List`1<T> get_ItemsList();
}
public class System.Net.Http.ByteRangeStreamContent : HttpContent {
    private static string SupportedRangeUnit;
    private static string ByteRangesContentSubtype;
    private static int DefaultBufferSize;
    private static int MinBufferSize;
    private Stream _content;
    private long _start;
    private HttpContent _byteRangeContent;
    private bool _disposed;
    public ByteRangeStreamContent(Stream content, RangeHeaderValue range, string mediaType);
    public ByteRangeStreamContent(Stream content, RangeHeaderValue range, string mediaType, int bufferSize);
    public ByteRangeStreamContent(Stream content, RangeHeaderValue range, MediaTypeHeaderValue mediaType);
    public ByteRangeStreamContent(Stream content, RangeHeaderValue range, MediaTypeHeaderValue mediaType, int bufferSize);
    protected virtual Task SerializeToStreamAsync(Stream stream, TransportContext context);
    protected virtual bool TryComputeLength(Int64& length);
    protected virtual void Dispose(bool disposing);
}
[ExtensionAttribute]
internal static class System.Net.Http.CloneableExtensions : object {
    [ExtensionAttribute]
internal static T Clone(T value);
}
public abstract class System.Net.Http.Formatting.BaseJsonMediaTypeFormatter : MediaTypeFormatter {
    private int _maxDepth;
    private IContractResolver _defaultContractResolver;
    private JsonSerializerSettings _jsonSerializerSettings;
    public JsonSerializerSettings SerializerSettings { get; public set; }
    public int MaxDepth { get; public set; }
    protected BaseJsonMediaTypeFormatter(BaseJsonMediaTypeFormatter formatter);
    public JsonSerializerSettings get_SerializerSettings();
    public void set_SerializerSettings(JsonSerializerSettings value);
    public virtual int get_MaxDepth();
    public virtual void set_MaxDepth(int value);
    public JsonSerializerSettings CreateDefaultSerializerSettings();
    public virtual bool CanReadType(Type type);
    public virtual bool CanWriteType(Type type);
    public virtual Task`1<object> ReadFromStreamAsync(Type type, Stream readStream, HttpContent content, IFormatterLogger formatterLogger);
    private object ReadFromStream(Type type, Stream readStream, HttpContent content, IFormatterLogger formatterLogger);
    public virtual object ReadFromStream(Type type, Stream readStream, Encoding effectiveEncoding, IFormatterLogger formatterLogger);
    private JsonReader CreateJsonReaderInternal(Type type, Stream readStream, Encoding effectiveEncoding);
    public abstract virtual JsonReader CreateJsonReader(Type type, Stream readStream, Encoding effectiveEncoding);
    private JsonSerializer CreateJsonSerializerInternal();
    public virtual JsonSerializer CreateJsonSerializer();
    public virtual Task WriteToStreamAsync(Type type, object value, Stream writeStream, HttpContent content, TransportContext transportContext, CancellationToken cancellationToken);
    private void WriteToStream(Type type, object value, Stream writeStream, HttpContent content);
    public virtual void WriteToStream(Type type, object value, Stream writeStream, Encoding effectiveEncoding);
    private JsonWriter CreateJsonWriterInternal(Type type, Stream writeStream, Encoding effectiveEncoding);
    public abstract virtual JsonWriter CreateJsonWriter(Type type, Stream writeStream, Encoding effectiveEncoding);
}
public class System.Net.Http.Formatting.BsonMediaTypeFormatter : BaseJsonMediaTypeFormatter {
    private static Type OpenDictionaryType;
    public static MediaTypeHeaderValue DefaultMediaType { get; }
    public int MaxDepth { get; public set; }
    protected BsonMediaTypeFormatter(BsonMediaTypeFormatter formatter);
    private static BsonMediaTypeFormatter();
    public static MediaTypeHeaderValue get_DefaultMediaType();
    public sealed virtual int get_MaxDepth();
    public sealed virtual void set_MaxDepth(int value);
    public virtual Task`1<object> ReadFromStreamAsync(Type type, Stream readStream, HttpContent content, IFormatterLogger formatterLogger);
    public virtual object ReadFromStream(Type type, Stream readStream, Encoding effectiveEncoding, IFormatterLogger formatterLogger);
    public virtual JsonReader CreateJsonReader(Type type, Stream readStream, Encoding effectiveEncoding);
    public virtual void WriteToStream(Type type, object value, Stream writeStream, Encoding effectiveEncoding);
    public virtual JsonWriter CreateJsonWriter(Type type, Stream writeStream, Encoding effectiveEncoding);
    private static bool IsSimpleType(Type type);
}
public abstract class System.Net.Http.Formatting.BufferedMediaTypeFormatter : MediaTypeFormatter {
    private static int MinBufferSize;
    private static int DefaultBufferSize;
    private int _bufferSizeInBytes;
    public int BufferSize { get; public set; }
    protected BufferedMediaTypeFormatter(BufferedMediaTypeFormatter formatter);
    public int get_BufferSize();
    public void set_BufferSize(int value);
    public virtual void WriteToStream(Type type, object value, Stream writeStream, HttpContent content, CancellationToken cancellationToken);
    public virtual void WriteToStream(Type type, object value, Stream writeStream, HttpContent content);
    public virtual object ReadFromStream(Type type, Stream readStream, HttpContent content, IFormatterLogger formatterLogger, CancellationToken cancellationToken);
    public virtual object ReadFromStream(Type type, Stream readStream, HttpContent content, IFormatterLogger formatterLogger);
    public sealed virtual Task WriteToStreamAsync(Type type, object value, Stream writeStream, HttpContent content, TransportContext transportContext);
    public sealed virtual Task WriteToStreamAsync(Type type, object value, Stream writeStream, HttpContent content, TransportContext transportContext, CancellationToken cancellationToken);
    private void WriteToStreamSync(Type type, object value, Stream writeStream, HttpContent content, CancellationToken cancellationToken);
    public sealed virtual Task`1<object> ReadFromStreamAsync(Type type, Stream readStream, HttpContent content, IFormatterLogger formatterLogger);
    public sealed virtual Task`1<object> ReadFromStreamAsync(Type type, Stream readStream, HttpContent content, IFormatterLogger formatterLogger, CancellationToken cancellationToken);
    private object ReadFromStreamSync(Type type, Stream readStream, HttpContent content, IFormatterLogger formatterLogger, CancellationToken cancellationToken);
    private static Stream GetBufferStream(Stream innerStream, int bufferSize);
}
public class System.Net.Http.Formatting.ContentNegotiationResult : object {
    private MediaTypeFormatter _formatter;
    [CompilerGeneratedAttribute]
private MediaTypeHeaderValue <MediaType>k__BackingField;
    public MediaTypeFormatter Formatter { get; public set; }
    public MediaTypeHeaderValue MediaType { get; public set; }
    public ContentNegotiationResult(MediaTypeFormatter formatter, MediaTypeHeaderValue mediaType);
    public MediaTypeFormatter get_Formatter();
    public void set_Formatter(MediaTypeFormatter value);
    [CompilerGeneratedAttribute]
public MediaTypeHeaderValue get_MediaType();
    [CompilerGeneratedAttribute]
public void set_MediaType(MediaTypeHeaderValue value);
}
public class System.Net.Http.Formatting.DefaultContentNegotiator : object {
    [CompilerGeneratedAttribute]
private bool <ExcludeMatchOnTypeOnly>k__BackingField;
    public bool ExcludeMatchOnTypeOnly { get; private set; }
    public DefaultContentNegotiator(bool excludeMatchOnTypeOnly);
    [CompilerGeneratedAttribute]
public bool get_ExcludeMatchOnTypeOnly();
    [CompilerGeneratedAttribute]
private void set_ExcludeMatchOnTypeOnly(bool value);
    public virtual ContentNegotiationResult Negotiate(Type type, HttpRequestMessage request, IEnumerable`1<MediaTypeFormatter> formatters);
    protected virtual Collection`1<MediaTypeFormatterMatch> ComputeFormatterMatches(Type type, HttpRequestMessage request, IEnumerable`1<MediaTypeFormatter> formatters);
    protected virtual MediaTypeFormatterMatch SelectResponseMediaTypeFormatter(ICollection`1<MediaTypeFormatterMatch> matches);
    protected virtual Encoding SelectResponseCharacterEncoding(HttpRequestMessage request, MediaTypeFormatter formatter);
    protected virtual MediaTypeFormatterMatch MatchMediaTypeMapping(HttpRequestMessage request, MediaTypeFormatter formatter);
    protected virtual MediaTypeFormatterMatch MatchAcceptHeader(IEnumerable`1<MediaTypeWithQualityHeaderValue> sortedAcceptValues, MediaTypeFormatter formatter);
    protected virtual MediaTypeFormatterMatch MatchRequestMediaType(HttpRequestMessage request, MediaTypeFormatter formatter);
    protected virtual bool ShouldMatchOnType(IEnumerable`1<MediaTypeWithQualityHeaderValue> sortedAcceptValues);
    protected virtual MediaTypeFormatterMatch MatchType(Type type, MediaTypeFormatter formatter);
    protected virtual IEnumerable`1<MediaTypeWithQualityHeaderValue> SortMediaTypeWithQualityHeaderValuesByQFactor(ICollection`1<MediaTypeWithQualityHeaderValue> headerValues);
    protected virtual IEnumerable`1<StringWithQualityHeaderValue> SortStringWithQualityHeaderValuesByQFactor(ICollection`1<StringWithQualityHeaderValue> headerValues);
    protected virtual MediaTypeFormatterMatch UpdateBestMatch(MediaTypeFormatterMatch current, MediaTypeFormatterMatch potentialReplacement);
    private static MediaTypeFormatter[] GetWritingFormatters(IEnumerable`1<MediaTypeFormatter> formatters);
}
public class System.Net.Http.Formatting.DelegatingEnumerable`1 : object {
    private IEnumerable`1<T> _source;
    public DelegatingEnumerable`1(IEnumerable`1<T> source);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public void Add(object item);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
public class System.Net.Http.Formatting.FormDataCollection : object {
    private IEnumerable`1<KeyValuePair`2<string, string>> _pairs;
    private NameValueCollection _nameValueCollection;
    public string Item { get; }
    public FormDataCollection(IEnumerable`1<KeyValuePair`2<string, string>> pairs);
    public FormDataCollection(Uri uri);
    public FormDataCollection(string query);
    public string get_Item(string name);
    private static IEnumerable`1<KeyValuePair`2<string, string>> ParseQueryString(string query);
    public NameValueCollection ReadAsNameValueCollection();
    public string Get(string key);
    public String[] GetValues(string key);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, string>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal static class System.Net.Http.Formatting.FormUrlEncodedJson : object {
    private static string ApplicationFormUrlEncoded;
    private static int MinDepth;
    private static String[] _emptyPath;
    private static FormUrlEncodedJson();
    public static JObject Parse(IEnumerable`1<KeyValuePair`2<string, string>> nameValuePairs);
    public static JObject Parse(IEnumerable`1<KeyValuePair`2<string, string>> nameValuePairs, int maxDepth);
    public static bool TryParse(IEnumerable`1<KeyValuePair`2<string, string>> nameValuePairs, JObject& value);
    public static bool TryParse(IEnumerable`1<KeyValuePair`2<string, string>> nameValuePairs, int maxDepth, JObject& value);
    private static JObject ParseInternal(IEnumerable`1<KeyValuePair`2<string, string>> nameValuePairs, int maxDepth, bool throwOnError);
    private static String[] GetPath(string key, int maxDepth, bool throwOnError);
    private static bool ValidateQueryString(string key, bool throwOnError);
    private static bool Insert(JObject root, String[] path, string value, bool throwOnError);
    private static bool AddToObject(JObject obj, String[] path, string value, bool throwOnError);
    private static bool AddToArray(JObject parent, String[] path, string value, bool throwOnError);
    private static string GetIndex(JObject jsonObject, bool throwOnError);
    private static void FixContiguousArrays(JToken jv);
    private static JToken FixSingleContiguousArray(JToken original);
    private static bool CanBecomeArray(List`1<string> keys, List`1& sortedKeys);
    private static string BuildPathString(String[] path, int i);
}
public class System.Net.Http.Formatting.FormUrlEncodedMediaTypeFormatter : MediaTypeFormatter {
    private static int MinBufferSize;
    private static int DefaultBufferSize;
    private int _readBufferSize;
    private int _maxDepth;
    private bool _isDerived;
    public static MediaTypeHeaderValue DefaultMediaType { get; }
    public int MaxDepth { get; public set; }
    public int ReadBufferSize { get; public set; }
    internal bool CanWriteAnyTypes { get; }
    protected FormUrlEncodedMediaTypeFormatter(FormUrlEncodedMediaTypeFormatter formatter);
    public static MediaTypeHeaderValue get_DefaultMediaType();
    public int get_MaxDepth();
    public void set_MaxDepth(int value);
    public int get_ReadBufferSize();
    public void set_ReadBufferSize(int value);
    internal virtual bool get_CanWriteAnyTypes();
    public virtual bool CanReadType(Type type);
    public virtual bool CanWriteType(Type type);
    public virtual Task`1<object> ReadFromStreamAsync(Type type, Stream readStream, HttpContent content, IFormatterLogger formatterLogger);
    private object ReadFromStream(Type type, Stream readStream);
    private static IEnumerable`1<KeyValuePair`2<string, string>> ReadFormUrlEncoded(Stream input, int bufferSize);
}
public interface System.Net.Http.Formatting.IContentNegotiator {
    public abstract virtual ContentNegotiationResult Negotiate(Type type, HttpRequestMessage request, IEnumerable`1<MediaTypeFormatter> formatters);
}
public interface System.Net.Http.Formatting.IFormatterLogger {
    public abstract virtual void LogError(string errorPath, string errorMessage);
    public abstract virtual void LogError(string errorPath, Exception exception);
}
internal class System.Net.Http.Formatting.Internal.HttpValueCollection : NameValueCollection {
    protected HttpValueCollection(SerializationInfo info, StreamingContext context);
    internal static HttpValueCollection Create();
    internal static HttpValueCollection Create(IEnumerable`1<KeyValuePair`2<string, string>> pairs);
    public virtual void Add(string name, string value);
    public virtual string ToString();
    private static void ThrowIfMaxHttpCollectionKeysExceeded(int count);
    private string ToString(bool urlEncode);
    private static bool AppendNameValuePair(StringBuilder builder, bool first, bool urlEncode, string name, string value);
}
public interface System.Net.Http.Formatting.IRequiredMemberSelector {
    public abstract virtual bool IsRequiredMember(MemberInfo member);
}
public class System.Net.Http.Formatting.JsonContractResolver : DefaultContractResolver {
    private MediaTypeFormatter _formatter;
    public JsonContractResolver(MediaTypeFormatter formatter);
    private void ConfigureProperty(MemberInfo member, JsonProperty property);
    protected virtual JsonProperty CreateProperty(MemberInfo member, MemberSerialization memberSerialization);
}
public class System.Net.Http.Formatting.JsonMediaTypeFormatter : BaseJsonMediaTypeFormatter {
    private ConcurrentDictionary`2<Type, DataContractJsonSerializer> _dataContractSerializerCache;
    private XmlDictionaryReaderQuotas _readerQuotas;
    private RequestHeaderMapping _requestHeaderMapping;
    [CompilerGeneratedAttribute]
private bool <UseDataContractJsonSerializer>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Indent>k__BackingField;
    public static MediaTypeHeaderValue DefaultMediaType { get; }
    public bool UseDataContractJsonSerializer { get; public set; }
    public bool Indent { get; public set; }
    public int MaxDepth { get; public set; }
    protected JsonMediaTypeFormatter(JsonMediaTypeFormatter formatter);
    public static MediaTypeHeaderValue get_DefaultMediaType();
    [CompilerGeneratedAttribute]
public bool get_UseDataContractJsonSerializer();
    [CompilerGeneratedAttribute]
public void set_UseDataContractJsonSerializer(bool value);
    [CompilerGeneratedAttribute]
public bool get_Indent();
    [CompilerGeneratedAttribute]
public void set_Indent(bool value);
    public sealed virtual int get_MaxDepth();
    public sealed virtual void set_MaxDepth(int value);
    public virtual JsonReader CreateJsonReader(Type type, Stream readStream, Encoding effectiveEncoding);
    public virtual JsonWriter CreateJsonWriter(Type type, Stream writeStream, Encoding effectiveEncoding);
    public virtual bool CanReadType(Type type);
    public virtual bool CanWriteType(Type type);
    public virtual object ReadFromStream(Type type, Stream readStream, Encoding effectiveEncoding, IFormatterLogger formatterLogger);
    public virtual Task WriteToStreamAsync(Type type, object value, Stream writeStream, HttpContent content, TransportContext transportContext, CancellationToken cancellationToken);
    public virtual void WriteToStream(Type type, object value, Stream writeStream, Encoding effectiveEncoding);
    private DataContractJsonSerializer CreateDataContractSerializer(Type type, bool throwOnError);
    public virtual DataContractJsonSerializer CreateDataContractSerializer(Type type);
    private DataContractJsonSerializer GetDataContractSerializer(Type type);
    [CompilerGeneratedAttribute]
private DataContractJsonSerializer <CanReadType>b__20_0(Type t);
    [CompilerGeneratedAttribute]
private DataContractJsonSerializer <CanWriteType>b__21_0(Type t);
}
internal static class System.Net.Http.Formatting.MediaTypeConstants : object {
    private static MediaTypeHeaderValue _defaultApplicationXmlMediaType;
    private static MediaTypeHeaderValue _defaultTextXmlMediaType;
    private static MediaTypeHeaderValue _defaultApplicationJsonMediaType;
    private static MediaTypeHeaderValue _defaultTextJsonMediaType;
    private static MediaTypeHeaderValue _defaultApplicationOctetStreamMediaType;
    private static MediaTypeHeaderValue _defaultApplicationFormUrlEncodedMediaType;
    private static MediaTypeHeaderValue _defaultApplicationBsonMediaType;
    public static MediaTypeHeaderValue ApplicationOctetStreamMediaType { get; }
    public static MediaTypeHeaderValue ApplicationXmlMediaType { get; }
    public static MediaTypeHeaderValue ApplicationJsonMediaType { get; }
    public static MediaTypeHeaderValue TextXmlMediaType { get; }
    public static MediaTypeHeaderValue TextJsonMediaType { get; }
    public static MediaTypeHeaderValue ApplicationFormUrlEncodedMediaType { get; }
    public static MediaTypeHeaderValue ApplicationBsonMediaType { get; }
    private static MediaTypeConstants();
    public static MediaTypeHeaderValue get_ApplicationOctetStreamMediaType();
    public static MediaTypeHeaderValue get_ApplicationXmlMediaType();
    public static MediaTypeHeaderValue get_ApplicationJsonMediaType();
    public static MediaTypeHeaderValue get_TextXmlMediaType();
    public static MediaTypeHeaderValue get_TextJsonMediaType();
    public static MediaTypeHeaderValue get_ApplicationFormUrlEncodedMediaType();
    public static MediaTypeHeaderValue get_ApplicationBsonMediaType();
}
public abstract class System.Net.Http.Formatting.MediaTypeFormatter : object {
    private static int DefaultMinHttpCollectionKeys;
    private static int DefaultMaxHttpCollectionKeys;
    private static string IWellKnownComparerTypeName;
    private static ConcurrentDictionary`2<Type, Type> _delegatingEnumerableCache;
    private static ConcurrentDictionary`2<Type, ConstructorInfo> _delegatingEnumerableConstructorCache;
    private static Lazy`1<int> _defaultMaxHttpCollectionKeys;
    private static int _maxHttpCollectionKeys;
    private List`1<MediaTypeHeaderValue> _supportedMediaTypes;
    private List`1<Encoding> _supportedEncodings;
    private List`1<MediaTypeMapping> _mediaTypeMappings;
    private IRequiredMemberSelector _requiredMemberSelector;
    [CompilerGeneratedAttribute]
private Collection`1<MediaTypeHeaderValue> <SupportedMediaTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<Encoding> <SupportedEncodings>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<MediaTypeMapping> <MediaTypeMappings>k__BackingField;
    public static int MaxHttpCollectionKeys { get; public set; }
    public Collection`1<MediaTypeHeaderValue> SupportedMediaTypes { get; private set; }
    internal List`1<MediaTypeHeaderValue> SupportedMediaTypesInternal { get; }
    public Collection`1<Encoding> SupportedEncodings { get; private set; }
    internal List`1<Encoding> SupportedEncodingsInternal { get; }
    public Collection`1<MediaTypeMapping> MediaTypeMappings { get; private set; }
    internal List`1<MediaTypeMapping> MediaTypeMappingsInternal { get; }
    public IRequiredMemberSelector RequiredMemberSelector { get; public set; }
    internal bool CanWriteAnyTypes { get; }
    protected MediaTypeFormatter(MediaTypeFormatter formatter);
    private static MediaTypeFormatter();
    public static int get_MaxHttpCollectionKeys();
    public static void set_MaxHttpCollectionKeys(int value);
    [CompilerGeneratedAttribute]
public Collection`1<MediaTypeHeaderValue> get_SupportedMediaTypes();
    [CompilerGeneratedAttribute]
private void set_SupportedMediaTypes(Collection`1<MediaTypeHeaderValue> value);
    internal List`1<MediaTypeHeaderValue> get_SupportedMediaTypesInternal();
    [CompilerGeneratedAttribute]
public Collection`1<Encoding> get_SupportedEncodings();
    [CompilerGeneratedAttribute]
private void set_SupportedEncodings(Collection`1<Encoding> value);
    internal List`1<Encoding> get_SupportedEncodingsInternal();
    [CompilerGeneratedAttribute]
public Collection`1<MediaTypeMapping> get_MediaTypeMappings();
    [CompilerGeneratedAttribute]
private void set_MediaTypeMappings(Collection`1<MediaTypeMapping> value);
    internal List`1<MediaTypeMapping> get_MediaTypeMappingsInternal();
    public virtual IRequiredMemberSelector get_RequiredMemberSelector();
    public virtual void set_RequiredMemberSelector(IRequiredMemberSelector value);
    internal virtual bool get_CanWriteAnyTypes();
    public virtual Task`1<object> ReadFromStreamAsync(Type type, Stream readStream, HttpContent content, IFormatterLogger formatterLogger);
    public virtual Task`1<object> ReadFromStreamAsync(Type type, Stream readStream, HttpContent content, IFormatterLogger formatterLogger, CancellationToken cancellationToken);
    public virtual Task WriteToStreamAsync(Type type, object value, Stream writeStream, HttpContent content, TransportContext transportContext);
    public virtual Task WriteToStreamAsync(Type type, object value, Stream writeStream, HttpContent content, TransportContext transportContext, CancellationToken cancellationToken);
    private static bool TryGetDelegatingType(Type interfaceType, Type& type);
    private static int InitializeDefaultCollectionKeySize();
    internal static bool TryGetDelegatingTypeForIEnumerableGenericOrSame(Type& type);
    internal static bool TryGetDelegatingTypeForIQueryableGenericOrSame(Type& type);
    internal static ConstructorInfo GetTypeRemappingConstructor(Type type);
    public Encoding SelectCharacterEncoding(HttpContentHeaders contentHeaders);
    public virtual void SetDefaultContentHeaders(Type type, HttpContentHeaders headers, MediaTypeHeaderValue mediaType);
    public virtual MediaTypeFormatter GetPerRequestFormatterInstance(Type type, HttpRequestMessage request, MediaTypeHeaderValue mediaType);
    public abstract virtual bool CanReadType(Type type);
    public abstract virtual bool CanWriteType(Type type);
    private static Type GetOrAddDelegatingType(Type type, Type genericType);
    public static object GetDefaultValueForType(Type type);
}
public class System.Net.Http.Formatting.MediaTypeFormatterCollection : Collection`1<MediaTypeFormatter> {
    private static Type _mediaTypeFormatterType;
    private MediaTypeFormatter[] _writingFormatters;
    [CompilerGeneratedAttribute]
private EventHandler Changing;
    public XmlMediaTypeFormatter XmlFormatter { get; }
    public JsonMediaTypeFormatter JsonFormatter { get; }
    public FormUrlEncodedMediaTypeFormatter FormUrlEncodedFormatter { get; }
    internal MediaTypeFormatter[] WritingFormatters { get; }
    public MediaTypeFormatterCollection(IEnumerable`1<MediaTypeFormatter> formatters);
    private static MediaTypeFormatterCollection();
    [CompilerGeneratedAttribute]
internal void add_Changing(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_Changing(EventHandler value);
    public XmlMediaTypeFormatter get_XmlFormatter();
    public JsonMediaTypeFormatter get_JsonFormatter();
    public FormUrlEncodedMediaTypeFormatter get_FormUrlEncodedFormatter();
    internal MediaTypeFormatter[] get_WritingFormatters();
    public void AddRange(IEnumerable`1<MediaTypeFormatter> items);
    public void InsertRange(int index, IEnumerable`1<MediaTypeFormatter> items);
    public MediaTypeFormatter FindReader(Type type, MediaTypeHeaderValue mediaType);
    public MediaTypeFormatter FindWriter(Type type, MediaTypeHeaderValue mediaType);
    public static bool IsTypeExcludedFromValidation(Type type);
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, MediaTypeFormatter item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, MediaTypeFormatter item);
    private void OnChanging();
    private MediaTypeFormatter[] GetWritingFormatters();
    private static IEnumerable`1<MediaTypeFormatter> CreateDefaultFormatters();
    private void VerifyAndSetFormatters(IEnumerable`1<MediaTypeFormatter> formatters);
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class System.Net.Http.Formatting.MediaTypeFormatterExtensions : object {
    [ExtensionAttribute]
public static void AddQueryStringMapping(MediaTypeFormatter formatter, string queryStringParameterName, string queryStringParameterValue, MediaTypeHeaderValue mediaType);
    [ExtensionAttribute]
public static void AddQueryStringMapping(MediaTypeFormatter formatter, string queryStringParameterName, string queryStringParameterValue, string mediaType);
    [ExtensionAttribute]
public static void AddRequestHeaderMapping(MediaTypeFormatter formatter, string headerName, string headerValue, StringComparison valueComparison, bool isValueSubstring, MediaTypeHeaderValue mediaType);
    [ExtensionAttribute]
public static void AddRequestHeaderMapping(MediaTypeFormatter formatter, string headerName, string headerValue, StringComparison valueComparison, bool isValueSubstring, string mediaType);
}
public class System.Net.Http.Formatting.MediaTypeFormatterMatch : object {
    [CompilerGeneratedAttribute]
private MediaTypeFormatter <Formatter>k__BackingField;
    [CompilerGeneratedAttribute]
private MediaTypeHeaderValue <MediaType>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Quality>k__BackingField;
    [CompilerGeneratedAttribute]
private MediaTypeFormatterMatchRanking <Ranking>k__BackingField;
    public MediaTypeFormatter Formatter { get; private set; }
    public MediaTypeHeaderValue MediaType { get; private set; }
    public double Quality { get; private set; }
    public MediaTypeFormatterMatchRanking Ranking { get; private set; }
    public MediaTypeFormatterMatch(MediaTypeFormatter formatter, MediaTypeHeaderValue mediaType, Nullable`1<double> quality, MediaTypeFormatterMatchRanking ranking);
    [CompilerGeneratedAttribute]
public MediaTypeFormatter get_Formatter();
    [CompilerGeneratedAttribute]
private void set_Formatter(MediaTypeFormatter value);
    [CompilerGeneratedAttribute]
public MediaTypeHeaderValue get_MediaType();
    [CompilerGeneratedAttribute]
private void set_MediaType(MediaTypeHeaderValue value);
    [CompilerGeneratedAttribute]
public double get_Quality();
    [CompilerGeneratedAttribute]
private void set_Quality(double value);
    [CompilerGeneratedAttribute]
public MediaTypeFormatterMatchRanking get_Ranking();
    [CompilerGeneratedAttribute]
private void set_Ranking(MediaTypeFormatterMatchRanking value);
}
public enum System.Net.Http.Formatting.MediaTypeFormatterMatchRanking : Enum {
    public int value__;
    public static MediaTypeFormatterMatchRanking None;
    public static MediaTypeFormatterMatchRanking MatchOnCanWriteType;
    public static MediaTypeFormatterMatchRanking MatchOnRequestAcceptHeaderLiteral;
    public static MediaTypeFormatterMatchRanking MatchOnRequestAcceptHeaderSubtypeMediaRange;
    public static MediaTypeFormatterMatchRanking MatchOnRequestAcceptHeaderAllMediaRange;
    public static MediaTypeFormatterMatchRanking MatchOnRequestWithMediaTypeMapping;
    public static MediaTypeFormatterMatchRanking MatchOnRequestMediaType;
}
[ExtensionAttribute]
internal static class System.Net.Http.Formatting.MediaTypeHeaderValueExtensions : object {
    [ExtensionAttribute]
public static bool IsSubsetOf(MediaTypeHeaderValue mediaType1, MediaTypeHeaderValue mediaType2);
    [ExtensionAttribute]
public static bool IsSubsetOf(MediaTypeHeaderValue mediaType1, MediaTypeHeaderValue mediaType2, MediaTypeHeaderValueRange& mediaType2Range);
}
internal enum System.Net.Http.Formatting.MediaTypeHeaderValueRange : Enum {
    public int value__;
    public static MediaTypeHeaderValueRange None;
    public static MediaTypeHeaderValueRange SubtypeMediaRange;
    public static MediaTypeHeaderValueRange AllMediaRange;
}
public abstract class System.Net.Http.Formatting.MediaTypeMapping : object {
    [CompilerGeneratedAttribute]
private MediaTypeHeaderValue <MediaType>k__BackingField;
    public MediaTypeHeaderValue MediaType { get; private set; }
    protected MediaTypeMapping(MediaTypeHeaderValue mediaType);
    protected MediaTypeMapping(string mediaType);
    [CompilerGeneratedAttribute]
public MediaTypeHeaderValue get_MediaType();
    [CompilerGeneratedAttribute]
private void set_MediaType(MediaTypeHeaderValue value);
    public abstract virtual double TryMatchMediaType(HttpRequestMessage request);
}
internal class System.Net.Http.Formatting.MediaTypeWithQualityHeaderValueComparer : object {
    private static MediaTypeWithQualityHeaderValueComparer _mediaTypeComparer;
    public static MediaTypeWithQualityHeaderValueComparer QualityComparer { get; }
    private static MediaTypeWithQualityHeaderValueComparer();
    public static MediaTypeWithQualityHeaderValueComparer get_QualityComparer();
    public sealed virtual int Compare(MediaTypeWithQualityHeaderValue mediaType1, MediaTypeWithQualityHeaderValue mediaType2);
    private static int CompareBasedOnQualityFactor(MediaTypeWithQualityHeaderValue mediaType1, MediaTypeWithQualityHeaderValue mediaType2);
}
internal class System.Net.Http.Formatting.ParsedMediaTypeHeaderValue : ValueType {
    private static char MediaRangeAsterisk;
    private static char MediaTypeSubtypeDelimiter;
    private string _mediaType;
    private int _delimiterIndex;
    private bool _isAllMediaRange;
    private bool _isSubtypeMediaRange;
    public bool IsAllMediaRange { get; }
    public bool IsSubtypeMediaRange { get; }
    public ParsedMediaTypeHeaderValue(MediaTypeHeaderValue mediaTypeHeaderValue);
    public bool get_IsAllMediaRange();
    public bool get_IsSubtypeMediaRange();
    public bool TypesEqual(ParsedMediaTypeHeaderValue& other);
    public bool SubTypesEqual(ParsedMediaTypeHeaderValue& other);
}
internal class System.Net.Http.Formatting.Parsers.FormUrlEncodedParser : object {
    private static int MinMessageSize;
    private long _totalBytesConsumed;
    private long _maxMessageSize;
    private NameValueState _nameValueState;
    private ICollection`1<KeyValuePair`2<string, string>> _nameValuePairs;
    private CurrentNameValuePair _currentNameValuePair;
    public FormUrlEncodedParser(ICollection`1<KeyValuePair`2<string, string>> nameValuePairs, long maxMessageSize);
    public ParserState ParseBuffer(Byte[] buffer, int bytesReady, Int32& bytesConsumed, bool isFinal);
    private static ParserState ParseNameValuePairs(Byte[] buffer, int bytesReady, Int32& bytesConsumed, NameValueState& nameValueState, long maximumLength, Int64& totalBytesConsumed, CurrentNameValuePair currentNameValuePair, ICollection`1<KeyValuePair`2<string, string>> nameValuePairs);
    private ParserState CopyCurrent(ParserState parseState);
}
internal class System.Net.Http.Formatting.Parsers.HttpRequestHeaderParser : object {
    internal static int DefaultMaxRequestLineSize;
    internal static int DefaultMaxHeaderSize;
    private HttpUnsortedRequest _httpRequest;
    private HttpRequestState _requestStatus;
    private HttpRequestLineParser _requestLineParser;
    private InternetMessageFormatHeaderParser _headerParser;
    public HttpRequestHeaderParser(HttpUnsortedRequest httpRequest);
    public HttpRequestHeaderParser(HttpUnsortedRequest httpRequest, int maxRequestLineSize, int maxHeaderSize);
    public ParserState ParseBuffer(Byte[] buffer, int bytesReady, Int32& bytesConsumed);
}
internal class System.Net.Http.Formatting.Parsers.HttpRequestLineParser : object {
    internal static int MinRequestLineSize;
    private static int DefaultTokenAllocation;
    private int _totalBytesConsumed;
    private int _maximumHeaderLength;
    private HttpRequestLineState _requestLineState;
    private HttpUnsortedRequest _httpRequest;
    private StringBuilder _currentToken;
    public HttpRequestLineParser(HttpUnsortedRequest httpRequest, int maxRequestLineSize);
    public ParserState ParseBuffer(Byte[] buffer, int bytesReady, Int32& bytesConsumed);
    private static ParserState ParseRequestLine(Byte[] buffer, int bytesReady, Int32& bytesConsumed, HttpRequestLineState& requestLineState, int maximumHeaderLength, Int32& totalBytesConsumed, StringBuilder currentToken, HttpUnsortedRequest httpRequest);
}
internal class System.Net.Http.Formatting.Parsers.HttpResponseHeaderParser : object {
    internal static int DefaultMaxStatusLineSize;
    internal static int DefaultMaxHeaderSize;
    private HttpUnsortedResponse _httpResponse;
    private HttpResponseState _responseStatus;
    private HttpStatusLineParser _statusLineParser;
    private InternetMessageFormatHeaderParser _headerParser;
    public HttpResponseHeaderParser(HttpUnsortedResponse httpResponse);
    public HttpResponseHeaderParser(HttpUnsortedResponse httpResponse, int maxResponseLineSize, int maxHeaderSize);
    public ParserState ParseBuffer(Byte[] buffer, int bytesReady, Int32& bytesConsumed);
}
internal class System.Net.Http.Formatting.Parsers.HttpStatusLineParser : object {
    internal static int MinStatusLineSize;
    private static int DefaultTokenAllocation;
    private static int MaxStatusCode;
    private int _totalBytesConsumed;
    private int _maximumHeaderLength;
    private HttpStatusLineState _statusLineState;
    private HttpUnsortedResponse _httpResponse;
    private StringBuilder _currentToken;
    public HttpStatusLineParser(HttpUnsortedResponse httpResponse, int maxStatusLineSize);
    public ParserState ParseBuffer(Byte[] buffer, int bytesReady, Int32& bytesConsumed);
    private static ParserState ParseStatusLine(Byte[] buffer, int bytesReady, Int32& bytesConsumed, HttpStatusLineState& statusLineState, int maximumHeaderLength, Int32& totalBytesConsumed, StringBuilder currentToken, HttpUnsortedResponse httpResponse);
}
internal class System.Net.Http.Formatting.Parsers.InternetMessageFormatHeaderParser : object {
    internal static int MinHeaderSize;
    private int _totalBytesConsumed;
    private int _maxHeaderSize;
    private HeaderFieldState _headerState;
    private HttpHeaders _headers;
    private CurrentHeaderFieldStore _currentHeader;
    private bool _ignoreHeaderValidation;
    public InternetMessageFormatHeaderParser(HttpHeaders headers, int maxHeaderSize);
    public InternetMessageFormatHeaderParser(HttpHeaders headers, int maxHeaderSize, bool ignoreHeaderValidation);
    public ParserState ParseBuffer(Byte[] buffer, int bytesReady, Int32& bytesConsumed);
    private static ParserState ParseHeaderFields(Byte[] buffer, int bytesReady, Int32& bytesConsumed, HeaderFieldState& requestHeaderState, int maximumHeaderLength, Int32& totalBytesConsumed, CurrentHeaderFieldStore currentField, HttpHeaders headers, bool ignoreHeaderValidation);
}
internal class System.Net.Http.Formatting.Parsers.MimeMultipartBodyPartParser : object {
    internal static long DefaultMaxMessageSize;
    private static int DefaultMaxBodyPartHeaderSize;
    private MimeMultipartParser _mimeParser;
    private State _mimeStatus;
    private ArraySegment`1[] _parsedBodyPart;
    private MimeBodyPart _currentBodyPart;
    private bool _isFirst;
    private ParserState _bodyPartHeaderStatus;
    private int _maxBodyPartHeaderSize;
    private MultipartStreamProvider _streamProvider;
    private HttpContent _content;
    public MimeMultipartBodyPartParser(HttpContent content, MultipartStreamProvider streamProvider);
    public MimeMultipartBodyPartParser(HttpContent content, MultipartStreamProvider streamProvider, long maxMessageSize, int maxBodyPartHeaderSize);
    public static bool IsMimeMultipartContent(HttpContent content);
    public sealed virtual void Dispose();
    [IteratorStateMachineAttribute("System.Net.Http.Formatting.Parsers.MimeMultipartBodyPartParser/<ParseBuffer>d__15")]
public IEnumerable`1<MimeBodyPart> ParseBuffer(Byte[] data, int bytesRead);
    protected void Dispose(bool disposing);
    private static string ValidateArguments(HttpContent content, long maxMessageSize, bool throwOnError);
    private void CleanupCurrentBodyPart();
}
internal class System.Net.Http.Formatting.Parsers.MimeMultipartParser : object {
    internal static int MinMessageSize;
    private static int MaxBoundarySize;
    private static byte HTAB;
    private static byte SP;
    private static byte CR;
    private static byte LF;
    private static byte Dash;
    private static ArraySegment`1<byte> _emptyBodyPart;
    private long _totalBytesConsumed;
    private long _maxMessageSize;
    private BodyPartState _bodyPartState;
    private string _boundary;
    private CurrentBodyPartStore _currentBoundary;
    public bool IsWaitingForEndOfMessage { get; }
    public MimeMultipartParser(string boundary, long maxMessageSize);
    private static MimeMultipartParser();
    public bool get_IsWaitingForEndOfMessage();
    public bool CanParseMore(int bytesRead, int bytesConsumed);
    public State ParseBuffer(Byte[] buffer, int bytesReady, Int32& bytesConsumed, ArraySegment`1& remainingBodyPart, ArraySegment`1& bodyPart, Boolean& isFinalBodyPart);
    private static State ParseBodyPart(Byte[] buffer, int bytesReady, Int32& bytesConsumed, BodyPartState& bodyPartState, long maximumMessageLength, Int64& totalBytesConsumed, CurrentBodyPartStore currentBodyPart);
}
internal enum System.Net.Http.Formatting.Parsers.ParserState : Enum {
    public int value__;
    public static ParserState NeedMoreData;
    public static ParserState Done;
    public static ParserState Invalid;
    public static ParserState DataTooBig;
}
public class System.Net.Http.Formatting.QueryStringMapping : MediaTypeMapping {
    private static Type _queryStringMappingType;
    [CompilerGeneratedAttribute]
private string <QueryStringParameterName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <QueryStringParameterValue>k__BackingField;
    public string QueryStringParameterName { get; private set; }
    public string QueryStringParameterValue { get; private set; }
    public QueryStringMapping(string queryStringParameterName, string queryStringParameterValue, string mediaType);
    public QueryStringMapping(string queryStringParameterName, string queryStringParameterValue, MediaTypeHeaderValue mediaType);
    private static QueryStringMapping();
    [CompilerGeneratedAttribute]
public string get_QueryStringParameterName();
    [CompilerGeneratedAttribute]
private void set_QueryStringParameterName(string value);
    [CompilerGeneratedAttribute]
public string get_QueryStringParameterValue();
    [CompilerGeneratedAttribute]
private void set_QueryStringParameterValue(string value);
    public virtual double TryMatchMediaType(HttpRequestMessage request);
    private static NameValueCollection GetQueryString(Uri uri);
    private void Initialize(string queryStringParameterName, string queryStringParameterValue);
    private bool DoesQueryStringMatch(NameValueCollection queryString);
}
public class System.Net.Http.Formatting.RequestHeaderMapping : MediaTypeMapping {
    [CompilerGeneratedAttribute]
private string <HeaderName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HeaderValue>k__BackingField;
    [CompilerGeneratedAttribute]
private StringComparison <HeaderValueComparison>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsValueSubstring>k__BackingField;
    public string HeaderName { get; private set; }
    public string HeaderValue { get; private set; }
    public StringComparison HeaderValueComparison { get; private set; }
    public bool IsValueSubstring { get; private set; }
    public RequestHeaderMapping(string headerName, string headerValue, StringComparison valueComparison, bool isValueSubstring, string mediaType);
    public RequestHeaderMapping(string headerName, string headerValue, StringComparison valueComparison, bool isValueSubstring, MediaTypeHeaderValue mediaType);
    [CompilerGeneratedAttribute]
public string get_HeaderName();
    [CompilerGeneratedAttribute]
private void set_HeaderName(string value);
    [CompilerGeneratedAttribute]
public string get_HeaderValue();
    [CompilerGeneratedAttribute]
private void set_HeaderValue(string value);
    [CompilerGeneratedAttribute]
public StringComparison get_HeaderValueComparison();
    [CompilerGeneratedAttribute]
private void set_HeaderValueComparison(StringComparison value);
    [CompilerGeneratedAttribute]
public bool get_IsValueSubstring();
    [CompilerGeneratedAttribute]
private void set_IsValueSubstring(bool value);
    public virtual double TryMatchMediaType(HttpRequestMessage request);
    private static double MatchHeaderValue(HttpRequestMessage request, string headerName, string headerValue, StringComparison valueComparison, bool isValueSubstring);
    private void Initialize(string headerName, string headerValue, StringComparison valueComparison, bool isValueSubstring);
}
internal static class System.Net.Http.Formatting.StringComparisonHelper : object {
    public static bool IsDefined(StringComparison value);
    public static void Validate(StringComparison value, string parameterName);
}
internal class System.Net.Http.Formatting.StringWithQualityHeaderValueComparer : object {
    private static StringWithQualityHeaderValueComparer _qualityComparer;
    public static StringWithQualityHeaderValueComparer QualityComparer { get; }
    private static StringWithQualityHeaderValueComparer();
    public static StringWithQualityHeaderValueComparer get_QualityComparer();
    public sealed virtual int Compare(StringWithQualityHeaderValue stringWithQuality1, StringWithQualityHeaderValue stringWithQuality2);
}
public class System.Net.Http.Formatting.XmlHttpRequestHeaderMapping : RequestHeaderMapping {
    public virtual double TryMatchMediaType(HttpRequestMessage request);
}
public class System.Net.Http.Formatting.XmlMediaTypeFormatter : MediaTypeFormatter {
    private ConcurrentDictionary`2<Type, object> _serializerCache;
    private XmlDictionaryReaderQuotas _readerQuotas;
    [CompilerGeneratedAttribute]
private bool <UseXmlSerializer>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlWriterSettings <WriterSettings>k__BackingField;
    public static MediaTypeHeaderValue DefaultMediaType { get; }
    [DefaultValueAttribute("False")]
public bool UseXmlSerializer { get; public set; }
    public bool Indent { get; public set; }
    public XmlWriterSettings WriterSettings { get; private set; }
    public int MaxDepth { get; public set; }
    protected XmlMediaTypeFormatter(XmlMediaTypeFormatter formatter);
    public static MediaTypeHeaderValue get_DefaultMediaType();
    [CompilerGeneratedAttribute]
public bool get_UseXmlSerializer();
    [CompilerGeneratedAttribute]
public void set_UseXmlSerializer(bool value);
    public bool get_Indent();
    public void set_Indent(bool value);
    [CompilerGeneratedAttribute]
public XmlWriterSettings get_WriterSettings();
    [CompilerGeneratedAttribute]
private void set_WriterSettings(XmlWriterSettings value);
    public int get_MaxDepth();
    public void set_MaxDepth(int value);
    public void SetSerializer(Type type, XmlObjectSerializer serializer);
    public void SetSerializer(XmlObjectSerializer serializer);
    public void SetSerializer(Type type, XmlSerializer serializer);
    public void SetSerializer(XmlSerializer serializer);
    public bool RemoveSerializer(Type type);
    public virtual bool CanReadType(Type type);
    public virtual bool CanWriteType(Type type);
    public virtual Task`1<object> ReadFromStreamAsync(Type type, Stream readStream, HttpContent content, IFormatterLogger formatterLogger);
    private object ReadFromStream(Type type, Stream readStream, HttpContent content, IFormatterLogger formatterLogger);
    protected internal virtual object GetDeserializer(Type type, HttpContent content);
    protected internal virtual XmlReader CreateXmlReader(Stream readStream, HttpContent content);
    public virtual Task WriteToStreamAsync(Type type, object value, Stream writeStream, HttpContent content, TransportContext transportContext, CancellationToken cancellationToken);
    private void WriteToStream(Type type, object value, Stream writeStream, HttpContent content);
    protected internal virtual object GetSerializer(Type type, object value, HttpContent content);
    protected internal virtual XmlWriter CreateXmlWriter(Stream writeStream, HttpContent content);
    public virtual XmlSerializer CreateXmlSerializer(Type type);
    public virtual DataContractSerializer CreateDataContractSerializer(Type type);
    [EditorBrowsableAttribute("1")]
public XmlReader InvokeCreateXmlReader(Stream readStream, HttpContent content);
    [EditorBrowsableAttribute("1")]
public XmlWriter InvokeCreateXmlWriter(Stream writeStream, HttpContent content);
    [EditorBrowsableAttribute("1")]
public object InvokeGetDeserializer(Type type, HttpContent content);
    [EditorBrowsableAttribute("1")]
public object InvokeGetSerializer(Type type, object value, HttpContent content);
    private object CreateDefaultSerializer(Type type, bool throwOnError);
    private object GetCachedSerializer(Type type, bool throwOnError);
    private void VerifyAndSetSerializer(Type type, object serializer);
    private void SetSerializerInternal(Type type, object serializer);
    private object GetSerializerForType(Type type);
    private static void ThrowInvalidSerializerException(object serializer, string getSerializerMethodName);
}
internal static class System.Net.Http.FormattingUtilities : object {
    private static String[] dateFormats;
    private static string NonTokenChars;
    public static double Match;
    public static double NoMatch;
    public static int DefaultMaxDepth;
    public static int DefaultMinDepth;
    public static string HttpRequestedWithHeader;
    public static string HttpRequestedWithHeaderValue;
    public static string HttpHostHeader;
    public static string HttpVersionToken;
    public static Type HttpRequestMessageType;
    public static Type HttpResponseMessageType;
    public static Type HttpContentType;
    public static Type DelegatingEnumerableGenericType;
    public static Type EnumerableInterfaceGenericType;
    public static Type QueryableInterfaceGenericType;
    public static XsdDataContractExporter XsdDataContractExporter;
    private static FormattingUtilities();
    public static bool IsJTokenType(Type type);
    public static HttpContentHeaders CreateEmptyContentHeaders();
    public static XmlDictionaryReaderQuotas CreateDefaultReaderQuotas();
    public static string UnquoteToken(string token);
    public static bool ValidateHeaderToken(string token);
    public static string DateToString(DateTimeOffset dateTime);
    public static bool TryParseDate(string input, DateTimeOffset& result);
    public static bool TryParseInt32(string value, Int32& result);
}
public class System.Net.Http.Handlers.HttpProgressEventArgs : ProgressChangedEventArgs {
    [CompilerGeneratedAttribute]
private long <BytesTransferred>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <TotalBytes>k__BackingField;
    public long BytesTransferred { get; private set; }
    public Nullable`1<long> TotalBytes { get; private set; }
    public HttpProgressEventArgs(int progressPercentage, object userToken, long bytesTransferred, Nullable`1<long> totalBytes);
    [CompilerGeneratedAttribute]
public long get_BytesTransferred();
    [CompilerGeneratedAttribute]
private void set_BytesTransferred(long value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_TotalBytes();
    [CompilerGeneratedAttribute]
private void set_TotalBytes(Nullable`1<long> value);
}
internal class System.Net.Http.Handlers.ProgressContent : HttpContent {
    private HttpContent _innerContent;
    private ProgressMessageHandler _handler;
    private HttpRequestMessage _request;
    public ProgressContent(HttpContent innerContent, ProgressMessageHandler handler, HttpRequestMessage request);
    protected virtual Task SerializeToStreamAsync(Stream stream, TransportContext context);
    protected virtual bool TryComputeLength(Int64& length);
    protected virtual void Dispose(bool disposing);
}
public class System.Net.Http.Handlers.ProgressMessageHandler : DelegatingHandler {
    [CompilerGeneratedAttribute]
private EventHandler`1<HttpProgressEventArgs> HttpSendProgress;
    [CompilerGeneratedAttribute]
private EventHandler`1<HttpProgressEventArgs> HttpReceiveProgress;
    public ProgressMessageHandler(HttpMessageHandler innerHandler);
    [CompilerGeneratedAttribute]
public void add_HttpSendProgress(EventHandler`1<HttpProgressEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_HttpSendProgress(EventHandler`1<HttpProgressEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_HttpReceiveProgress(EventHandler`1<HttpProgressEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_HttpReceiveProgress(EventHandler`1<HttpProgressEventArgs> value);
    [AsyncStateMachineAttribute("System.Net.Http.Handlers.ProgressMessageHandler/<SendAsync>d__8")]
protected virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    protected internal virtual void OnHttpRequestProgress(HttpRequestMessage request, HttpProgressEventArgs e);
    protected internal virtual void OnHttpResponseProgress(HttpRequestMessage request, HttpProgressEventArgs e);
    private void AddRequestProgress(HttpRequestMessage request);
    [AsyncStateMachineAttribute("System.Net.Http.Handlers.ProgressMessageHandler/<AddResponseProgressAsync>d__12")]
private Task`1<HttpResponseMessage> AddResponseProgressAsync(HttpRequestMessage request, HttpResponseMessage response);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<HttpResponseMessage> <>n__0(HttpRequestMessage request, CancellationToken cancellationToken);
}
internal class System.Net.Http.Handlers.ProgressStream : DelegatingStream {
    private ProgressMessageHandler _handler;
    private HttpRequestMessage _request;
    private long _bytesReceived;
    private Nullable`1<long> _totalBytesToReceive;
    private long _bytesSent;
    private Nullable`1<long> _totalBytesToSend;
    public ProgressStream(Stream innerStream, ProgressMessageHandler handler, HttpRequestMessage request, HttpResponseMessage response);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    [AsyncStateMachineAttribute("System.Net.Http.Handlers.ProgressStream/<ReadAsync>d__9")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    [AsyncStateMachineAttribute("System.Net.Http.Handlers.ProgressStream/<WriteAsync>d__14")]
public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    internal void ReportBytesSent(int bytesSent, object userState);
    private void ReportBytesReceived(int bytesReceived, object userState);
}
internal class System.Net.Http.Handlers.ProgressWriteAsyncResult : AsyncResult {
    private static AsyncCallback _writeCompletedCallback;
    private Stream _innerStream;
    private ProgressStream _progressStream;
    private int _count;
    public ProgressWriteAsyncResult(Stream innerStream, ProgressStream progressStream, Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    private static ProgressWriteAsyncResult();
    private static void WriteCompletedCallback(IAsyncResult result);
    private void WriteCompleted(IAsyncResult result);
    public static void End(IAsyncResult result);
}
[DefaultMemberAttribute("Item")]
public class System.Net.Http.Headers.CookieHeaderValue : object {
    private static string ExpiresToken;
    private static string MaxAgeToken;
    private static string DomainToken;
    private static string PathToken;
    private static string SecureToken;
    private static string HttpOnlyToken;
    private static string DefaultPath;
    private static Char[] segmentSeparator;
    private static Char[] nameValueSeparator;
    private Collection`1<CookieState> _cookies;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <Expires>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <MaxAge>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Domain>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Secure>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HttpOnly>k__BackingField;
    public Collection`1<CookieState> Cookies { get; }
    public Nullable`1<DateTimeOffset> Expires { get; public set; }
    public Nullable`1<TimeSpan> MaxAge { get; public set; }
    public string Domain { get; public set; }
    public string Path { get; public set; }
    public bool Secure { get; public set; }
    public bool HttpOnly { get; public set; }
    public CookieState Item { get; }
    public CookieHeaderValue(string name, string value);
    public CookieHeaderValue(string name, NameValueCollection values);
    private CookieHeaderValue(CookieHeaderValue source);
    private static CookieHeaderValue();
    public Collection`1<CookieState> get_Cookies();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_Expires();
    [CompilerGeneratedAttribute]
public void set_Expires(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_MaxAge();
    [CompilerGeneratedAttribute]
public void set_MaxAge(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public string get_Domain();
    [CompilerGeneratedAttribute]
public void set_Domain(string value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public bool get_Secure();
    [CompilerGeneratedAttribute]
public void set_Secure(bool value);
    [CompilerGeneratedAttribute]
public bool get_HttpOnly();
    [CompilerGeneratedAttribute]
public void set_HttpOnly(bool value);
    public CookieState get_Item(string name);
    public virtual string ToString();
    public sealed virtual object Clone();
    public static bool TryParse(string input, CookieHeaderValue& parsedValue);
    private static bool AppendSegment(StringBuilder builder, bool first, string name, string value);
    private static bool ParseCookieSegment(CookieHeaderValue instance, string segment);
    private static string GetSegmentValue(String[] nameValuePair, string defaultValue);
}
[DefaultMemberAttribute("Item")]
public class System.Net.Http.Headers.CookieState : object {
    private string _name;
    private NameValueCollection _values;
    public string Name { get; public set; }
    public string Value { get; public set; }
    public NameValueCollection Values { get; }
    public string Item { get; public set; }
    public CookieState(string name);
    public CookieState(string name, string value);
    public CookieState(string name, NameValueCollection values);
    private CookieState(CookieState source);
    public string get_Name();
    public void set_Name(string value);
    public string get_Value();
    public void set_Value(string value);
    public NameValueCollection get_Values();
    public string get_Item(string subName);
    public void set_Item(string subName, string value);
    public virtual string ToString();
    public sealed virtual object Clone();
    private static void CheckNameFormat(string name, string parameterName);
    private static void CheckValueFormat(string value, string parameterName);
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class System.Net.Http.HttpClientExtensions : object {
    [ExtensionAttribute]
public static Task`1<HttpResponseMessage> PostAsJsonAsync(HttpClient client, string requestUri, T value);
    [ExtensionAttribute]
public static Task`1<HttpResponseMessage> PostAsJsonAsync(HttpClient client, string requestUri, T value, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<HttpResponseMessage> PostAsJsonAsync(HttpClient client, Uri requestUri, T value);
    [ExtensionAttribute]
public static Task`1<HttpResponseMessage> PostAsJsonAsync(HttpClient client, Uri requestUri, T value, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<HttpResponseMessage> PostAsXmlAsync(HttpClient client, string requestUri, T value);
    [ExtensionAttribute]
public static Task`1<HttpResponseMessage> PostAsXmlAsync(HttpClient client, string requestUri, T value, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<HttpResponseMessage> PostAsXmlAsync(HttpClient client, Uri requestUri, T value);
    [ExtensionAttribute]
public static Task`1<HttpResponseMessage> PostAsXmlAsync(HttpClient client, Uri requestUri, T value, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<HttpResponseMessage> PostAsync(HttpClient client, string requestUri, T value, MediaTypeFormatter formatter);
    [ExtensionAttribute]
public static Task`1<HttpResponseMessage> PostAsync(HttpClient client, string requestUri, T value, MediaTypeFormatter formatter, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<HttpResponseMessage> PostAsync(HttpClient client, string requestUri, T value, MediaTypeFormatter formatter, string mediaType);
    [ExtensionAttribute]
public static Task`1<HttpResponseMessage> PostAsync(HttpClient client, string requestUri, T value, MediaTypeFormatter formatter, string mediaType, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<HttpResponseMessage> PostAsync(HttpClient client, string requestUri, T value, MediaTypeFormatter formatter, MediaTypeHeaderValue mediaType, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<HttpResponseMessage> PostAsync(HttpClient client, Uri requestUri, T value, MediaTypeFormatter formatter);
    [ExtensionAttribute]
public static Task`1<HttpResponseMessage> PostAsync(HttpClient client, Uri requestUri, T value, MediaTypeFormatter formatter, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<HttpResponseMessage> PostAsync(HttpClient client, Uri requestUri, T value, MediaTypeFormatter formatter, string mediaType);
    [ExtensionAttribute]
public static Task`1<HttpResponseMessage> PostAsync(HttpClient client, Uri requestUri, T value, MediaTypeFormatter formatter, string mediaType, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<HttpResponseMessage> PostAsync(HttpClient client, Uri requestUri, T value, MediaTypeFormatter formatter, MediaTypeHeaderValue mediaType, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<HttpResponseMessage> PutAsJsonAsync(HttpClient client, string requestUri, T value);
    [ExtensionAttribute]
public static Task`1<HttpResponseMessage> PutAsJsonAsync(HttpClient client, string requestUri, T value, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<HttpResponseMessage> PutAsJsonAsync(HttpClient client, Uri requestUri, T value);
    [ExtensionAttribute]
public static Task`1<HttpResponseMessage> PutAsJsonAsync(HttpClient client, Uri requestUri, T value, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<HttpResponseMessage> PutAsXmlAsync(HttpClient client, string requestUri, T value);
    [ExtensionAttribute]
public static Task`1<HttpResponseMessage> PutAsXmlAsync(HttpClient client, string requestUri, T value, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<HttpResponseMessage> PutAsXmlAsync(HttpClient client, Uri requestUri, T value);
    [ExtensionAttribute]
public static Task`1<HttpResponseMessage> PutAsXmlAsync(HttpClient client, Uri requestUri, T value, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<HttpResponseMessage> PutAsync(HttpClient client, string requestUri, T value, MediaTypeFormatter formatter);
    [ExtensionAttribute]
public static Task`1<HttpResponseMessage> PutAsync(HttpClient client, string requestUri, T value, MediaTypeFormatter formatter, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<HttpResponseMessage> PutAsync(HttpClient client, string requestUri, T value, MediaTypeFormatter formatter, string mediaType);
    [ExtensionAttribute]
public static Task`1<HttpResponseMessage> PutAsync(HttpClient client, string requestUri, T value, MediaTypeFormatter formatter, string mediaType, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<HttpResponseMessage> PutAsync(HttpClient client, string requestUri, T value, MediaTypeFormatter formatter, MediaTypeHeaderValue mediaType, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<HttpResponseMessage> PutAsync(HttpClient client, Uri requestUri, T value, MediaTypeFormatter formatter);
    [ExtensionAttribute]
public static Task`1<HttpResponseMessage> PutAsync(HttpClient client, Uri requestUri, T value, MediaTypeFormatter formatter, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<HttpResponseMessage> PutAsync(HttpClient client, Uri requestUri, T value, MediaTypeFormatter formatter, string mediaType);
    [ExtensionAttribute]
public static Task`1<HttpResponseMessage> PutAsync(HttpClient client, Uri requestUri, T value, MediaTypeFormatter formatter, string mediaType, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<HttpResponseMessage> PutAsync(HttpClient client, Uri requestUri, T value, MediaTypeFormatter formatter, MediaTypeHeaderValue mediaType, CancellationToken cancellationToken);
}
public static class System.Net.Http.HttpClientFactory : object {
    public static HttpClient Create(DelegatingHandler[] handlers);
    public static HttpClient Create(HttpMessageHandler innerHandler, DelegatingHandler[] handlers);
    public static HttpMessageHandler CreatePipeline(HttpMessageHandler innerHandler, IEnumerable`1<DelegatingHandler> handlers);
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class System.Net.Http.HttpContentExtensions : object {
    private static MediaTypeFormatterCollection _defaultMediaTypeFormatterCollection;
    private static MediaTypeFormatterCollection DefaultMediaTypeFormatterCollection { get; }
    private static HttpContentExtensions();
    private static MediaTypeFormatterCollection get_DefaultMediaTypeFormatterCollection();
    [ExtensionAttribute]
public static Task`1<object> ReadAsAsync(HttpContent content, Type type);
    [ExtensionAttribute]
public static Task`1<object> ReadAsAsync(HttpContent content, Type type, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<object> ReadAsAsync(HttpContent content, Type type, IEnumerable`1<MediaTypeFormatter> formatters);
    [ExtensionAttribute]
public static Task`1<object> ReadAsAsync(HttpContent content, Type type, IEnumerable`1<MediaTypeFormatter> formatters, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<object> ReadAsAsync(HttpContent content, Type type, IEnumerable`1<MediaTypeFormatter> formatters, IFormatterLogger formatterLogger);
    [ExtensionAttribute]
public static Task`1<object> ReadAsAsync(HttpContent content, Type type, IEnumerable`1<MediaTypeFormatter> formatters, IFormatterLogger formatterLogger, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<T> ReadAsAsync(HttpContent content);
    [ExtensionAttribute]
public static Task`1<T> ReadAsAsync(HttpContent content, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<T> ReadAsAsync(HttpContent content, IEnumerable`1<MediaTypeFormatter> formatters);
    [ExtensionAttribute]
public static Task`1<T> ReadAsAsync(HttpContent content, IEnumerable`1<MediaTypeFormatter> formatters, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<T> ReadAsAsync(HttpContent content, IEnumerable`1<MediaTypeFormatter> formatters, IFormatterLogger formatterLogger);
    [ExtensionAttribute]
public static Task`1<T> ReadAsAsync(HttpContent content, IEnumerable`1<MediaTypeFormatter> formatters, IFormatterLogger formatterLogger, CancellationToken cancellationToken);
    private static Task`1<T> ReadAsAsync(HttpContent content, Type type, IEnumerable`1<MediaTypeFormatter> formatters, IFormatterLogger formatterLogger);
    private static Task`1<T> ReadAsAsync(HttpContent content, Type type, IEnumerable`1<MediaTypeFormatter> formatters, IFormatterLogger formatterLogger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Http.HttpContentExtensions/<ReadAsAsyncCore>d__17`1")]
private static Task`1<T> ReadAsAsyncCore(HttpContent content, Type type, IFormatterLogger formatterLogger, MediaTypeFormatter formatter, CancellationToken cancellationToken);
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class System.Net.Http.HttpContentFormDataExtensions : object {
    private static string ApplicationFormUrlEncoded;
    [ExtensionAttribute]
public static bool IsFormData(HttpContent content);
    [ExtensionAttribute]
public static Task`1<NameValueCollection> ReadAsFormDataAsync(HttpContent content);
    [ExtensionAttribute]
public static Task`1<NameValueCollection> ReadAsFormDataAsync(HttpContent content, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Http.HttpContentFormDataExtensions/<ReadAsAsyncCore>d__4")]
private static Task`1<NameValueCollection> ReadAsAsyncCore(HttpContent content, MediaTypeFormatter[] formatters, CancellationToken cancellationToken);
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class System.Net.Http.HttpContentMessageExtensions : object {
    private static int MinBufferSize;
    private static int DefaultBufferSize;
    [ExtensionAttribute]
public static bool IsHttpRequestMessageContent(HttpContent content);
    [ExtensionAttribute]
public static bool IsHttpResponseMessageContent(HttpContent content);
    [ExtensionAttribute]
public static Task`1<HttpRequestMessage> ReadAsHttpRequestMessageAsync(HttpContent content);
    [ExtensionAttribute]
public static Task`1<HttpRequestMessage> ReadAsHttpRequestMessageAsync(HttpContent content, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<HttpRequestMessage> ReadAsHttpRequestMessageAsync(HttpContent content, string uriScheme);
    [ExtensionAttribute]
public static Task`1<HttpRequestMessage> ReadAsHttpRequestMessageAsync(HttpContent content, string uriScheme, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<HttpRequestMessage> ReadAsHttpRequestMessageAsync(HttpContent content, string uriScheme, int bufferSize);
    [ExtensionAttribute]
public static Task`1<HttpRequestMessage> ReadAsHttpRequestMessageAsync(HttpContent content, string uriScheme, int bufferSize, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<HttpRequestMessage> ReadAsHttpRequestMessageAsync(HttpContent content, string uriScheme, int bufferSize, int maxHeaderSize);
    [ExtensionAttribute]
public static Task`1<HttpRequestMessage> ReadAsHttpRequestMessageAsync(HttpContent content, string uriScheme, int bufferSize, int maxHeaderSize, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Http.HttpContentMessageExtensions/<ReadAsHttpRequestMessageAsyncCore>d__12")]
[ExtensionAttribute]
private static Task`1<HttpRequestMessage> ReadAsHttpRequestMessageAsyncCore(HttpContent content, string uriScheme, int bufferSize, int maxHeaderSize, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<HttpResponseMessage> ReadAsHttpResponseMessageAsync(HttpContent content);
    [ExtensionAttribute]
public static Task`1<HttpResponseMessage> ReadAsHttpResponseMessageAsync(HttpContent content, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<HttpResponseMessage> ReadAsHttpResponseMessageAsync(HttpContent content, int bufferSize);
    [ExtensionAttribute]
public static Task`1<HttpResponseMessage> ReadAsHttpResponseMessageAsync(HttpContent content, int bufferSize, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<HttpResponseMessage> ReadAsHttpResponseMessageAsync(HttpContent content, int bufferSize, int maxHeaderSize);
    [ExtensionAttribute]
public static Task`1<HttpResponseMessage> ReadAsHttpResponseMessageAsync(HttpContent content, int bufferSize, int maxHeaderSize, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Http.HttpContentMessageExtensions/<ReadAsHttpResponseMessageAsyncCore>d__19")]
[ExtensionAttribute]
private static Task`1<HttpResponseMessage> ReadAsHttpResponseMessageAsyncCore(HttpContent content, int bufferSize, int maxHeaderSize, CancellationToken cancellationToken);
    private static Uri CreateRequestUri(string uriScheme, HttpUnsortedRequest httpRequest);
    private static HttpContent CreateHeaderFields(HttpHeaders source, HttpHeaders destination, Stream contentStream, int rewind);
    private static HttpRequestMessage CreateHttpRequestMessage(string uriScheme, HttpUnsortedRequest httpRequest, Stream contentStream, int rewind);
    private static HttpResponseMessage CreateHttpResponseMessage(HttpUnsortedResponse httpResponse, Stream contentStream, int rewind);
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class System.Net.Http.HttpContentMultipartExtensions : object {
    private static int MinBufferSize;
    private static int DefaultBufferSize;
    [ExtensionAttribute]
public static bool IsMimeMultipartContent(HttpContent content);
    [ExtensionAttribute]
public static bool IsMimeMultipartContent(HttpContent content, string subtype);
    [ExtensionAttribute]
public static Task`1<MultipartMemoryStreamProvider> ReadAsMultipartAsync(HttpContent content);
    [ExtensionAttribute]
public static Task`1<MultipartMemoryStreamProvider> ReadAsMultipartAsync(HttpContent content, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<T> ReadAsMultipartAsync(HttpContent content, T streamProvider);
    [ExtensionAttribute]
public static Task`1<T> ReadAsMultipartAsync(HttpContent content, T streamProvider, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<T> ReadAsMultipartAsync(HttpContent content, T streamProvider, int bufferSize);
    [AsyncStateMachineAttribute("System.Net.Http.HttpContentMultipartExtensions/<ReadAsMultipartAsync>d__9`1")]
[ExtensionAttribute]
public static Task`1<T> ReadAsMultipartAsync(HttpContent content, T streamProvider, int bufferSize, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Http.HttpContentMultipartExtensions/<MultipartReadAsync>d__10")]
private static Task MultipartReadAsync(MultipartAsyncContext context, CancellationToken cancellationToken);
    private static bool CheckIsFinalPart(MimeBodyPart part, ICollection`1<HttpContent> result);
}
[ExtensionAttribute]
internal static class System.Net.Http.HttpHeaderExtensions : object {
    [ExtensionAttribute]
public static void CopyTo(HttpContentHeaders fromHeaders, HttpContentHeaders toHeaders);
}
public class System.Net.Http.HttpMessageContent : HttpContent {
    private static string SP;
    private static string ColonSP;
    private static string CRLF;
    private static string CommaSeparator;
    private static int DefaultHeaderAllocation;
    private static string DefaultMediaType;
    private static string MsgTypeParameter;
    private static string DefaultRequestMsgType;
    private static string DefaultResponseMsgType;
    private static string DefaultRequestMediaType;
    private static string DefaultResponseMediaType;
    private static HashSet`1<string> _singleValueHeaderFields;
    private static HashSet`1<string> _spaceSeparatedValueHeaderFields;
    private bool _contentConsumed;
    private Lazy`1<Task`1<Stream>> _streamTask;
    [CompilerGeneratedAttribute]
private HttpRequestMessage <HttpRequestMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpResponseMessage <HttpResponseMessage>k__BackingField;
    private HttpContent Content { get; }
    public HttpRequestMessage HttpRequestMessage { get; private set; }
    public HttpResponseMessage HttpResponseMessage { get; private set; }
    public HttpMessageContent(HttpRequestMessage httpRequest);
    public HttpMessageContent(HttpResponseMessage httpResponse);
    private static HttpMessageContent();
    private HttpContent get_Content();
    [CompilerGeneratedAttribute]
public HttpRequestMessage get_HttpRequestMessage();
    [CompilerGeneratedAttribute]
private void set_HttpRequestMessage(HttpRequestMessage value);
    [CompilerGeneratedAttribute]
public HttpResponseMessage get_HttpResponseMessage();
    [CompilerGeneratedAttribute]
private void set_HttpResponseMessage(HttpResponseMessage value);
    private void InitializeStreamTask();
    internal static bool ValidateHttpMessageContent(HttpContent content, bool isRequest, bool throwOnError);
    [AsyncStateMachineAttribute("System.Net.Http.HttpMessageContent/<SerializeToStreamAsync>d__29")]
protected virtual Task SerializeToStreamAsync(Stream stream, TransportContext context);
    protected virtual bool TryComputeLength(Int64& length);
    protected virtual void Dispose(bool disposing);
    private static void SerializeRequestLine(StringBuilder message, HttpRequestMessage httpRequest);
    private static void SerializeStatusLine(StringBuilder message, HttpResponseMessage httpResponse);
    private static void SerializeHeaderFields(StringBuilder message, HttpHeaders headers);
    private Byte[] SerializeHeader();
    private void ValidateStreamForReading(Stream stream);
    [CompilerGeneratedAttribute]
private Task`1<Stream> <InitializeStreamTask>b__27_0();
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class System.Net.Http.HttpRequestHeadersExtensions : object {
    private static string Cookie;
    [ExtensionAttribute]
public static Collection`1<CookieHeaderValue> GetCookies(HttpRequestHeaders headers);
    [ExtensionAttribute]
public static Collection`1<CookieHeaderValue> GetCookies(HttpRequestHeaders headers, string name);
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class System.Net.Http.HttpRequestMessageExtensions : object {
    [ExtensionAttribute]
public static HttpResponseMessage CreateResponse(HttpRequestMessage request, HttpStatusCode statusCode);
    [ExtensionAttribute]
public static HttpResponseMessage CreateResponse(HttpRequestMessage request);
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class System.Net.Http.HttpResponseHeadersExtensions : object {
    private static string SetCookie;
    [ExtensionAttribute]
public static void AddCookies(HttpResponseHeaders headers, IEnumerable`1<CookieHeaderValue> cookies);
}
internal class System.Net.Http.HttpUnsortedHeaders : HttpHeaders {
}
internal class System.Net.Http.HttpUnsortedRequest : object {
    [CompilerGeneratedAttribute]
private HttpMethod <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RequestUri>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpHeaders <HttpHeaders>k__BackingField;
    public HttpMethod Method { get; public set; }
    public string RequestUri { get; public set; }
    public Version Version { get; public set; }
    public HttpHeaders HttpHeaders { get; private set; }
    [CompilerGeneratedAttribute]
public HttpMethod get_Method();
    [CompilerGeneratedAttribute]
public void set_Method(HttpMethod value);
    [CompilerGeneratedAttribute]
public string get_RequestUri();
    [CompilerGeneratedAttribute]
public void set_RequestUri(string value);
    [CompilerGeneratedAttribute]
public Version get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(Version value);
    [CompilerGeneratedAttribute]
public HttpHeaders get_HttpHeaders();
    [CompilerGeneratedAttribute]
private void set_HttpHeaders(HttpHeaders value);
}
internal class System.Net.Http.HttpUnsortedResponse : object {
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpStatusCode <StatusCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReasonPhrase>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpHeaders <HttpHeaders>k__BackingField;
    public Version Version { get; public set; }
    public HttpStatusCode StatusCode { get; public set; }
    public string ReasonPhrase { get; public set; }
    public HttpHeaders HttpHeaders { get; private set; }
    [CompilerGeneratedAttribute]
public Version get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(Version value);
    [CompilerGeneratedAttribute]
public HttpStatusCode get_StatusCode();
    [CompilerGeneratedAttribute]
public void set_StatusCode(HttpStatusCode value);
    [CompilerGeneratedAttribute]
public string get_ReasonPhrase();
    [CompilerGeneratedAttribute]
public void set_ReasonPhrase(string value);
    [CompilerGeneratedAttribute]
public HttpHeaders get_HttpHeaders();
    [CompilerGeneratedAttribute]
private void set_HttpHeaders(HttpHeaders value);
}
internal abstract class System.Net.Http.Internal.AsyncResult : object {
    private AsyncCallback _callback;
    private object _state;
    private bool _isCompleted;
    private bool _completedSynchronously;
    private bool _endCalled;
    private Exception _exception;
    public object AsyncState { get; }
    public WaitHandle AsyncWaitHandle { get; }
    public bool CompletedSynchronously { get; }
    public bool HasCallback { get; }
    public bool IsCompleted { get; }
    protected AsyncResult(AsyncCallback callback, object state);
    public sealed virtual object get_AsyncState();
    public sealed virtual WaitHandle get_AsyncWaitHandle();
    public sealed virtual bool get_CompletedSynchronously();
    public bool get_HasCallback();
    public sealed virtual bool get_IsCompleted();
    protected void Complete(bool completedSynchronously);
    protected void Complete(bool completedSynchronously, Exception exception);
    protected static TAsyncResult End(IAsyncResult result);
}
internal class System.Net.Http.Internal.ByteRangeStream : DelegatingStream {
    private long _lowerbounds;
    private long _totalCount;
    private long _currentCount;
    [CompilerGeneratedAttribute]
private ContentRangeHeaderValue <ContentRange>k__BackingField;
    public ContentRangeHeaderValue ContentRange { get; private set; }
    public long Length { get; }
    public bool CanWrite { get; }
    public long Position { get; public set; }
    public ByteRangeStream(Stream innerStream, RangeItemHeaderValue range);
    [CompilerGeneratedAttribute]
public ContentRangeHeaderValue get_ContentRange();
    [CompilerGeneratedAttribute]
private void set_ContentRange(ContentRangeHeaderValue value);
    public virtual long get_Length();
    public virtual bool get_CanWrite();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
    private int PrepareStreamForRangeRead(int count);
}
internal abstract class System.Net.Http.Internal.DelegatingStream : Stream {
    private Stream _innerStream;
    protected Stream InnerStream { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public bool CanTimeout { get; }
    public int WriteTimeout { get; public set; }
    protected DelegatingStream(Stream innerStream);
    protected Stream get_InnerStream();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual bool get_CanTimeout();
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    protected virtual void Dispose(bool disposing);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual int ReadByte();
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void WriteByte(byte value);
}
internal class System.Net.Http.Internal.NonClosingDelegatingStream : DelegatingStream {
    public NonClosingDelegatingStream(Stream innerStream);
    public virtual void Close();
}
internal class System.Net.Http.Internal.ReadOnlyStreamWithEncodingPreamble : Stream {
    private static Task`1<int> _cancelledTask;
    private Stream _innerStream;
    private ArraySegment`1<byte> _remainingBytes;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ReadOnlyStreamWithEncodingPreamble(Stream innerStream, Encoding encoding);
    private static ReadOnlyStreamWithEncodingPreamble();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    private static Task`1<int> GetCancelledTask();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
public class System.Net.Http.InvalidByteRangeException : Exception {
    [CompilerGeneratedAttribute]
private ContentRangeHeaderValue <ContentRange>k__BackingField;
    public ContentRangeHeaderValue ContentRange { get; private set; }
    public InvalidByteRangeException(ContentRangeHeaderValue contentRange);
    public InvalidByteRangeException(ContentRangeHeaderValue contentRange, string message);
    public InvalidByteRangeException(ContentRangeHeaderValue contentRange, string message, Exception innerException);
    public InvalidByteRangeException(ContentRangeHeaderValue contentRange, SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public ContentRangeHeaderValue get_ContentRange();
    [CompilerGeneratedAttribute]
private void set_ContentRange(ContentRangeHeaderValue value);
    private void Initialize(ContentRangeHeaderValue contentRange);
}
internal class System.Net.Http.MimeBodyPart : object {
    private static Type _streamType;
    private Stream _outputStream;
    private MultipartStreamProvider _streamProvider;
    private HttpContent _parentContent;
    private HttpContent _content;
    private HttpContentHeaders _headers;
    [CompilerGeneratedAttribute]
private InternetMessageFormatHeaderParser <HeaderParser>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ArraySegment`1<byte>> <Segments>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsComplete>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFinal>k__BackingField;
    public InternetMessageFormatHeaderParser HeaderParser { get; private set; }
    public List`1<ArraySegment`1<byte>> Segments { get; private set; }
    public bool IsComplete { get; public set; }
    public bool IsFinal { get; public set; }
    public MimeBodyPart(MultipartStreamProvider streamProvider, int maxBodyPartHeaderSize, HttpContent parentContent);
    private static MimeBodyPart();
    [CompilerGeneratedAttribute]
public InternetMessageFormatHeaderParser get_HeaderParser();
    [CompilerGeneratedAttribute]
private void set_HeaderParser(InternetMessageFormatHeaderParser value);
    public HttpContent GetCompletedHttpContent();
    [CompilerGeneratedAttribute]
public List`1<ArraySegment`1<byte>> get_Segments();
    [CompilerGeneratedAttribute]
private void set_Segments(List`1<ArraySegment`1<byte>> value);
    [CompilerGeneratedAttribute]
public bool get_IsComplete();
    [CompilerGeneratedAttribute]
public void set_IsComplete(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsFinal();
    [CompilerGeneratedAttribute]
public void set_IsFinal(bool value);
    [AsyncStateMachineAttribute("System.Net.Http.MimeBodyPart/<WriteSegment>d__24")]
public Task WriteSegment(ArraySegment`1<byte> segment, CancellationToken cancellationToken);
    private Stream GetOutputStream();
    public sealed virtual void Dispose();
    protected void Dispose(bool disposing);
    private void CleanupHttpContent();
    private void CleanupOutputStream();
}
public class System.Net.Http.MultipartFileData : object {
    [CompilerGeneratedAttribute]
private HttpContentHeaders <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocalFileName>k__BackingField;
    public HttpContentHeaders Headers { get; private set; }
    public string LocalFileName { get; private set; }
    public MultipartFileData(HttpContentHeaders headers, string localFileName);
    [CompilerGeneratedAttribute]
public HttpContentHeaders get_Headers();
    [CompilerGeneratedAttribute]
private void set_Headers(HttpContentHeaders value);
    [CompilerGeneratedAttribute]
public string get_LocalFileName();
    [CompilerGeneratedAttribute]
private void set_LocalFileName(string value);
}
public class System.Net.Http.MultipartFileStreamProvider : MultipartStreamProvider {
    private static int MinBufferSize;
    private static int DefaultBufferSize;
    private string _rootPath;
    private int _bufferSize;
    private Collection`1<MultipartFileData> _fileData;
    public Collection`1<MultipartFileData> FileData { get; }
    protected string RootPath { get; }
    protected int BufferSize { get; }
    public MultipartFileStreamProvider(string rootPath);
    public MultipartFileStreamProvider(string rootPath, int bufferSize);
    public Collection`1<MultipartFileData> get_FileData();
    protected string get_RootPath();
    protected int get_BufferSize();
    public virtual Stream GetStream(HttpContent parent, HttpContentHeaders headers);
    public virtual string GetLocalFileName(HttpContentHeaders headers);
}
public abstract class System.Net.Http.MultipartFormDataRemoteStreamProvider : MultipartStreamProvider {
    private CancellationToken _cancellationToken;
    [CompilerGeneratedAttribute]
private Collection`1<MultipartRemoteFileData> <FileData>k__BackingField;
    [CompilerGeneratedAttribute]
private NameValueCollection <FormData>k__BackingField;
    public Collection`1<MultipartRemoteFileData> FileData { get; private set; }
    public NameValueCollection FormData { get; private set; }
    [CompilerGeneratedAttribute]
public Collection`1<MultipartRemoteFileData> get_FileData();
    [CompilerGeneratedAttribute]
private void set_FileData(Collection`1<MultipartRemoteFileData> value);
    [CompilerGeneratedAttribute]
public NameValueCollection get_FormData();
    [CompilerGeneratedAttribute]
private void set_FormData(NameValueCollection value);
    public abstract virtual RemoteStreamInfo GetRemoteStream(HttpContent parent, HttpContentHeaders headers);
    public virtual Stream GetStream(HttpContent parent, HttpContentHeaders headers);
    public virtual Task ExecutePostProcessingAsync();
    public virtual Task ExecutePostProcessingAsync(CancellationToken cancellationToken);
}
public class System.Net.Http.MultipartFormDataStreamProvider : MultipartFileStreamProvider {
    private CancellationToken _cancellationToken;
    [CompilerGeneratedAttribute]
private NameValueCollection <FormData>k__BackingField;
    public NameValueCollection FormData { get; private set; }
    public MultipartFormDataStreamProvider(string rootPath);
    public MultipartFormDataStreamProvider(string rootPath, int bufferSize);
    [CompilerGeneratedAttribute]
public NameValueCollection get_FormData();
    [CompilerGeneratedAttribute]
private void set_FormData(NameValueCollection value);
    public virtual Stream GetStream(HttpContent parent, HttpContentHeaders headers);
    public virtual Task ExecutePostProcessingAsync();
    public virtual Task ExecutePostProcessingAsync(CancellationToken cancellationToken);
}
internal static class System.Net.Http.MultipartFormDataStreamProviderHelper : object {
    public static bool IsFileContent(HttpContent parent, HttpContentHeaders headers);
    [AsyncStateMachineAttribute("System.Net.Http.MultipartFormDataStreamProviderHelper/<ReadFormDataAsync>d__1")]
public static Task ReadFormDataAsync(Collection`1<HttpContent> contents, NameValueCollection formData, CancellationToken cancellationToken);
}
public class System.Net.Http.MultipartMemoryStreamProvider : MultipartStreamProvider {
    public virtual Stream GetStream(HttpContent parent, HttpContentHeaders headers);
}
public class System.Net.Http.MultipartRelatedStreamProvider : MultipartStreamProvider {
    private static string RelatedSubType;
    private static string ContentID;
    private static string StartParameter;
    private HttpContent _rootContent;
    private HttpContent _parent;
    public HttpContent RootContent { get; }
    public HttpContent get_RootContent();
    public virtual Stream GetStream(HttpContent parent, HttpContentHeaders headers);
    private static HttpContent FindRootContent(HttpContent parent, IEnumerable`1<HttpContent> children);
    private static NameValueHeaderValue FindMultipartRelatedParameter(HttpContent content, string parameterName);
}
public class System.Net.Http.MultipartRemoteFileData : object {
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpContentHeaders <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Location>k__BackingField;
    public string FileName { get; private set; }
    public HttpContentHeaders Headers { get; private set; }
    public string Location { get; private set; }
    public MultipartRemoteFileData(HttpContentHeaders headers, string location, string fileName);
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
private void set_FileName(string value);
    [CompilerGeneratedAttribute]
public HttpContentHeaders get_Headers();
    [CompilerGeneratedAttribute]
private void set_Headers(HttpContentHeaders value);
    [CompilerGeneratedAttribute]
public string get_Location();
    [CompilerGeneratedAttribute]
private void set_Location(string value);
}
public abstract class System.Net.Http.MultipartStreamProvider : object {
    private Collection`1<HttpContent> _contents;
    public Collection`1<HttpContent> Contents { get; }
    public Collection`1<HttpContent> get_Contents();
    public abstract virtual Stream GetStream(HttpContent parent, HttpContentHeaders headers);
    public virtual Task ExecutePostProcessingAsync();
    public virtual Task ExecutePostProcessingAsync(CancellationToken cancellationToken);
}
public class System.Net.Http.ObjectContent : HttpContent {
    private object _value;
    private MediaTypeFormatter _formatter;
    [CompilerGeneratedAttribute]
private Type <ObjectType>k__BackingField;
    public Type ObjectType { get; private set; }
    public MediaTypeFormatter Formatter { get; }
    public object Value { get; public set; }
    public ObjectContent(Type type, object value, MediaTypeFormatter formatter);
    public ObjectContent(Type type, object value, MediaTypeFormatter formatter, string mediaType);
    public ObjectContent(Type type, object value, MediaTypeFormatter formatter, MediaTypeHeaderValue mediaType);
    [CompilerGeneratedAttribute]
public Type get_ObjectType();
    [CompilerGeneratedAttribute]
private void set_ObjectType(Type value);
    public MediaTypeFormatter get_Formatter();
    public object get_Value();
    public void set_Value(object value);
    internal static MediaTypeHeaderValue BuildHeaderValue(string mediaType);
    protected virtual Task SerializeToStreamAsync(Stream stream, TransportContext context);
    protected virtual bool TryComputeLength(Int64& length);
    private static bool IsTypeNullable(Type type);
    private void VerifyAndSetObject(object value);
}
public class System.Net.Http.ObjectContent`1 : ObjectContent {
    public ObjectContent`1(T value, MediaTypeFormatter formatter);
    public ObjectContent`1(T value, MediaTypeFormatter formatter, string mediaType);
    public ObjectContent`1(T value, MediaTypeFormatter formatter, MediaTypeHeaderValue mediaType);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "16.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class System.Net.Http.Properties.Resources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string AsyncResult_CallbackThrewException { get; }
    internal static string AsyncResult_MultipleCompletes { get; }
    internal static string AsyncResult_MultipleEnds { get; }
    internal static string AsyncResult_ResultMismatch { get; }
    internal static string ByteRangeStreamContentNoRanges { get; }
    internal static string ByteRangeStreamContentNotBytesRange { get; }
    internal static string ByteRangeStreamEmpty { get; }
    internal static string ByteRangeStreamInvalidFrom { get; }
    internal static string ByteRangeStreamInvalidOffset { get; }
    internal static string ByteRangeStreamNoneOverlap { get; }
    internal static string ByteRangeStreamNoOverlap { get; }
    internal static string ByteRangeStreamNotSeekable { get; }
    internal static string ByteRangeStreamReadOnly { get; }
    internal static string CannotHaveNullInList { get; }
    internal static string CannotUseMediaRangeForSupportedMediaType { get; }
    internal static string CannotUseNullValueType { get; }
    internal static string CookieInvalidName { get; }
    internal static string CookieNull { get; }
    internal static string DelegatingHandlerArrayContainsNullItem { get; }
    internal static string DelegatingHandlerArrayHasNonNullInnerHandler { get; }
    internal static string ErrorReadingFormUrlEncodedStream { get; }
    internal static string FormUrlEncodedMismatchingTypes { get; }
    internal static string FormUrlEncodedParseError { get; }
    internal static string HttpInvalidStatusCode { get; }
    internal static string HttpInvalidVersion { get; }
    internal static string HttpMessageContentAlreadyRead { get; }
    internal static string HttpMessageContentStreamMustBeSeekable { get; }
    internal static string HttpMessageErrorReading { get; }
    internal static string HttpMessageInvalidMediaType { get; }
    internal static string HttpMessageParserEmptyUri { get; }
    internal static string HttpMessageParserError { get; }
    internal static string HttpMessageParserInvalidHostCount { get; }
    internal static string HttpMessageParserInvalidUriScheme { get; }
    internal static string InvalidArrayInsert { get; }
    internal static string JQuery13CompatModeNotSupportNestedJson { get; }
    internal static string JsonSerializerFactoryReturnedNull { get; }
    internal static string JsonSerializerFactoryThrew { get; }
    internal static string MaxDepthExceeded { get; }
    internal static string MaxHttpCollectionKeyLimitReached { get; }
    internal static string MediaTypeFormatter_BsonParseError_MissingData { get; }
    internal static string MediaTypeFormatter_BsonParseError_UnexpectedData { get; }
    internal static string MediaTypeFormatter_JsonReaderFactoryReturnedNull { get; }
    internal static string MediaTypeFormatter_JsonWriterFactoryReturnedNull { get; }
    internal static string MediaTypeFormatterCannotRead { get; }
    internal static string MediaTypeFormatterCannotReadSync { get; }
    internal static string MediaTypeFormatterCannotWrite { get; }
    internal static string MediaTypeFormatterCannotWriteSync { get; }
    internal static string MediaTypeFormatterNoEncoding { get; }
    internal static string MimeMultipartParserBadBoundary { get; }
    internal static string MultipartFormDataStreamProviderNoContentDisposition { get; }
    internal static string MultipartStreamProviderInvalidLocalFileName { get; }
    internal static string NestedBracketNotValid { get; }
    internal static string NonNullUriRequiredForMediaTypeMapping { get; }
    internal static string NoReadSerializerAvailable { get; }
    internal static string ObjectAndTypeDisagree { get; }
    internal static string ObjectContent_FormatterCannotWriteType { get; }
    internal static string QueryStringNameShouldNotNull { get; }
    internal static string ReadAsHttpMessageUnexpectedTermination { get; }
    internal static string ReadAsMimeMultipartArgumentNoBoundary { get; }
    internal static string ReadAsMimeMultipartArgumentNoContentType { get; }
    internal static string ReadAsMimeMultipartArgumentNoMultipart { get; }
    internal static string ReadAsMimeMultipartErrorReading { get; }
    internal static string ReadAsMimeMultipartErrorWriting { get; }
    internal static string ReadAsMimeMultipartHeaderParseError { get; }
    internal static string ReadAsMimeMultipartParseError { get; }
    internal static string ReadAsMimeMultipartStreamProviderException { get; }
    internal static string ReadAsMimeMultipartStreamProviderNull { get; }
    internal static string ReadAsMimeMultipartStreamProviderReadOnly { get; }
    internal static string ReadAsMimeMultipartUnexpectedTermination { get; }
    internal static string RemoteStreamInfoCannotBeNull { get; }
    internal static string SerializerCannotSerializeType { get; }
    internal static string UnMatchedBracketNotValid { get; }
    internal static string UnsupportedIndent { get; }
    internal static string XmlMediaTypeFormatter_InvalidSerializerType { get; }
    internal static string XmlMediaTypeFormatter_NullReturnedSerializer { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_AsyncResult_CallbackThrewException();
    internal static string get_AsyncResult_MultipleCompletes();
    internal static string get_AsyncResult_MultipleEnds();
    internal static string get_AsyncResult_ResultMismatch();
    internal static string get_ByteRangeStreamContentNoRanges();
    internal static string get_ByteRangeStreamContentNotBytesRange();
    internal static string get_ByteRangeStreamEmpty();
    internal static string get_ByteRangeStreamInvalidFrom();
    internal static string get_ByteRangeStreamInvalidOffset();
    internal static string get_ByteRangeStreamNoneOverlap();
    internal static string get_ByteRangeStreamNoOverlap();
    internal static string get_ByteRangeStreamNotSeekable();
    internal static string get_ByteRangeStreamReadOnly();
    internal static string get_CannotHaveNullInList();
    internal static string get_CannotUseMediaRangeForSupportedMediaType();
    internal static string get_CannotUseNullValueType();
    internal static string get_CookieInvalidName();
    internal static string get_CookieNull();
    internal static string get_DelegatingHandlerArrayContainsNullItem();
    internal static string get_DelegatingHandlerArrayHasNonNullInnerHandler();
    internal static string get_ErrorReadingFormUrlEncodedStream();
    internal static string get_FormUrlEncodedMismatchingTypes();
    internal static string get_FormUrlEncodedParseError();
    internal static string get_HttpInvalidStatusCode();
    internal static string get_HttpInvalidVersion();
    internal static string get_HttpMessageContentAlreadyRead();
    internal static string get_HttpMessageContentStreamMustBeSeekable();
    internal static string get_HttpMessageErrorReading();
    internal static string get_HttpMessageInvalidMediaType();
    internal static string get_HttpMessageParserEmptyUri();
    internal static string get_HttpMessageParserError();
    internal static string get_HttpMessageParserInvalidHostCount();
    internal static string get_HttpMessageParserInvalidUriScheme();
    internal static string get_InvalidArrayInsert();
    internal static string get_JQuery13CompatModeNotSupportNestedJson();
    internal static string get_JsonSerializerFactoryReturnedNull();
    internal static string get_JsonSerializerFactoryThrew();
    internal static string get_MaxDepthExceeded();
    internal static string get_MaxHttpCollectionKeyLimitReached();
    internal static string get_MediaTypeFormatter_BsonParseError_MissingData();
    internal static string get_MediaTypeFormatter_BsonParseError_UnexpectedData();
    internal static string get_MediaTypeFormatter_JsonReaderFactoryReturnedNull();
    internal static string get_MediaTypeFormatter_JsonWriterFactoryReturnedNull();
    internal static string get_MediaTypeFormatterCannotRead();
    internal static string get_MediaTypeFormatterCannotReadSync();
    internal static string get_MediaTypeFormatterCannotWrite();
    internal static string get_MediaTypeFormatterCannotWriteSync();
    internal static string get_MediaTypeFormatterNoEncoding();
    internal static string get_MimeMultipartParserBadBoundary();
    internal static string get_MultipartFormDataStreamProviderNoContentDisposition();
    internal static string get_MultipartStreamProviderInvalidLocalFileName();
    internal static string get_NestedBracketNotValid();
    internal static string get_NonNullUriRequiredForMediaTypeMapping();
    internal static string get_NoReadSerializerAvailable();
    internal static string get_ObjectAndTypeDisagree();
    internal static string get_ObjectContent_FormatterCannotWriteType();
    internal static string get_QueryStringNameShouldNotNull();
    internal static string get_ReadAsHttpMessageUnexpectedTermination();
    internal static string get_ReadAsMimeMultipartArgumentNoBoundary();
    internal static string get_ReadAsMimeMultipartArgumentNoContentType();
    internal static string get_ReadAsMimeMultipartArgumentNoMultipart();
    internal static string get_ReadAsMimeMultipartErrorReading();
    internal static string get_ReadAsMimeMultipartErrorWriting();
    internal static string get_ReadAsMimeMultipartHeaderParseError();
    internal static string get_ReadAsMimeMultipartParseError();
    internal static string get_ReadAsMimeMultipartStreamProviderException();
    internal static string get_ReadAsMimeMultipartStreamProviderNull();
    internal static string get_ReadAsMimeMultipartStreamProviderReadOnly();
    internal static string get_ReadAsMimeMultipartUnexpectedTermination();
    internal static string get_RemoteStreamInfoCannotBeNull();
    internal static string get_SerializerCannotSerializeType();
    internal static string get_UnMatchedBracketNotValid();
    internal static string get_UnsupportedIndent();
    internal static string get_XmlMediaTypeFormatter_InvalidSerializerType();
    internal static string get_XmlMediaTypeFormatter_NullReturnedSerializer();
}
public class System.Net.Http.PushStreamContent : HttpContent {
    private Func`4<Stream, HttpContent, TransportContext, Task> _onStreamAvailable;
    public PushStreamContent(Action`3<Stream, HttpContent, TransportContext> onStreamAvailable);
    public PushStreamContent(Func`4<Stream, HttpContent, TransportContext, Task> onStreamAvailable);
    public PushStreamContent(Action`3<Stream, HttpContent, TransportContext> onStreamAvailable, string mediaType);
    public PushStreamContent(Func`4<Stream, HttpContent, TransportContext, Task> onStreamAvailable, string mediaType);
    public PushStreamContent(Action`3<Stream, HttpContent, TransportContext> onStreamAvailable, MediaTypeHeaderValue mediaType);
    public PushStreamContent(Func`4<Stream, HttpContent, TransportContext, Task> onStreamAvailable, MediaTypeHeaderValue mediaType);
    private static Func`4<Stream, HttpContent, TransportContext, Task> Taskify(Action`3<Stream, HttpContent, TransportContext> onStreamAvailable);
    [AsyncStateMachineAttribute("System.Net.Http.PushStreamContent/<SerializeToStreamAsync>d__8")]
protected virtual Task SerializeToStreamAsync(Stream stream, TransportContext context);
    protected virtual bool TryComputeLength(Int64& length);
}
public class System.Net.Http.RemoteStreamInfo : object {
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private Stream <RemoteStream>k__BackingField;
    public string FileName { get; private set; }
    public string Location { get; private set; }
    public Stream RemoteStream { get; private set; }
    public RemoteStreamInfo(Stream remoteStream, string location, string fileName);
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
private void set_FileName(string value);
    [CompilerGeneratedAttribute]
public string get_Location();
    [CompilerGeneratedAttribute]
private void set_Location(string value);
    [CompilerGeneratedAttribute]
public Stream get_RemoteStream();
    [CompilerGeneratedAttribute]
private void set_RemoteStream(Stream value);
}
[ExtensionAttribute]
internal static class System.Net.Http.TypeExtensions : object {
    [ExtensionAttribute]
public static Type ExtractGenericInterface(Type queryType, Type interfaceType);
    [ExtensionAttribute]
public static bool IsGenericType(Type type);
    [ExtensionAttribute]
public static bool IsInterface(Type type);
    [ExtensionAttribute]
public static bool IsValueType(Type type);
}
public class System.Net.Http.UnsupportedMediaTypeException : Exception {
    [CompilerGeneratedAttribute]
private MediaTypeHeaderValue <MediaType>k__BackingField;
    public MediaTypeHeaderValue MediaType { get; private set; }
    public UnsupportedMediaTypeException(string message, MediaTypeHeaderValue mediaType);
    [CompilerGeneratedAttribute]
public MediaTypeHeaderValue get_MediaType();
    [CompilerGeneratedAttribute]
private void set_MediaType(MediaTypeHeaderValue value);
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class System.Net.Http.UriExtensions : object {
    [ExtensionAttribute]
public static NameValueCollection ParseQueryString(Uri address);
    [ExtensionAttribute]
public static bool TryReadQueryAsJson(Uri address, JObject& value);
    [ExtensionAttribute]
public static bool TryReadQueryAs(Uri address, Type type, Object& value);
    [ExtensionAttribute]
public static bool TryReadQueryAs(Uri address, T& value);
}
internal static class System.Threading.Tasks.TaskHelpers : object {
    private static Task _defaultCompleted;
    private static Task`1<object> _completedTaskReturningNull;
    private static TaskHelpers();
    internal static Task Canceled();
    internal static Task`1<TResult> Canceled();
    internal static Task Completed();
    internal static Task FromError(Exception exception);
    internal static Task`1<TResult> FromError(Exception exception);
    internal static Task`1<object> NullResult();
}
[ExtensionAttribute]
internal static class System.Threading.Tasks.TaskHelpersExtensions : object {
    [AsyncStateMachineAttribute("System.Threading.Tasks.TaskHelpersExtensions/<CastToObject>d__0")]
[ExtensionAttribute]
internal static Task`1<object> CastToObject(Task task);
    [AsyncStateMachineAttribute("System.Threading.Tasks.TaskHelpersExtensions/<CastToObject>d__1`1")]
[ExtensionAttribute]
internal static Task`1<object> CastToObject(Task`1<T> task);
    [ExtensionAttribute]
internal static void ThrowIfFaulted(Task task);
    [ExtensionAttribute]
internal static bool TryGetResult(Task`1<TResult> task, TResult& result);
}
internal static class System.Web.Http.Error : object {
    private static string HttpScheme;
    private static string HttpsScheme;
    internal static string Format(string format, Object[] args);
    internal static ArgumentException Argument(string messageFormat, Object[] messageArgs);
    internal static ArgumentException Argument(string parameterName, string messageFormat, Object[] messageArgs);
    internal static ArgumentException ArgumentUriNotHttpOrHttpsScheme(string parameterName, Uri actualValue);
    internal static ArgumentException ArgumentUriNotAbsolute(string parameterName, Uri actualValue);
    internal static ArgumentException ArgumentUriHasQueryOrFragment(string parameterName, Uri actualValue);
    internal static ArgumentNullException PropertyNull();
    internal static ArgumentNullException ArgumentNull(string parameterName);
    internal static ArgumentNullException ArgumentNull(string parameterName, string messageFormat, Object[] messageArgs);
    internal static ArgumentException ArgumentNullOrEmpty(string parameterName);
    internal static ArgumentOutOfRangeException ArgumentOutOfRange(string parameterName, object actualValue, string messageFormat, Object[] messageArgs);
    internal static ArgumentOutOfRangeException ArgumentMustBeGreaterThanOrEqualTo(string parameterName, object actualValue, object minValue);
    internal static ArgumentOutOfRangeException ArgumentMustBeLessThanOrEqualTo(string parameterName, object actualValue, object maxValue);
    internal static KeyNotFoundException KeyNotFound();
    internal static KeyNotFoundException KeyNotFound(string messageFormat, Object[] messageArgs);
    internal static ObjectDisposedException ObjectDisposed(string messageFormat, Object[] messageArgs);
    internal static OperationCanceledException OperationCanceled();
    internal static OperationCanceledException OperationCanceled(string messageFormat, Object[] messageArgs);
    internal static ArgumentException InvalidEnumArgument(string parameterName, int invalidValue, Type enumClass);
    internal static InvalidOperationException InvalidOperation(string messageFormat, Object[] messageArgs);
    internal static InvalidOperationException InvalidOperation(Exception innerException, string messageFormat, Object[] messageArgs);
    internal static NotSupportedException NotSupported(string messageFormat, Object[] messageArgs);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class System.Web.Http.Properties.CommonWebApiResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ArgumentInvalidAbsoluteUri { get; }
    internal static string ArgumentInvalidHttpUriScheme { get; }
    internal static string ArgumentMustBeGreaterThanOrEqualTo { get; }
    internal static string ArgumentMustBeLessThanOrEqualTo { get; }
    internal static string ArgumentNullOrEmpty { get; }
    internal static string ArgumentUriHasQueryOrFragment { get; }
    internal static string InvalidEnumArgument { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ArgumentInvalidAbsoluteUri();
    internal static string get_ArgumentInvalidHttpUriScheme();
    internal static string get_ArgumentMustBeGreaterThanOrEqualTo();
    internal static string get_ArgumentMustBeLessThanOrEqualTo();
    internal static string get_ArgumentNullOrEmpty();
    internal static string get_ArgumentUriHasQueryOrFragment();
    internal static string get_InvalidEnumArgument();
}
internal static class System.Web.Http.UriQueryUtility : object {
    public static string UrlEncode(string str);
    public static string UrlDecode(string str);
    private static Byte[] UrlEncode(Byte[] bytes, int offset, int count, bool alwaysCreateNewReturnValue);
    private static Byte[] UrlEncode(Byte[] bytes, int offset, int count);
    private static string UrlDecodeInternal(string value, Encoding encoding);
    private static int HexToInt(char h);
    private static char IntToHex(int n);
    private static bool IsUrlSafeChar(char ch);
    private static bool ValidateUrlEncodingParameters(Byte[] bytes, int offset, int count);
}
