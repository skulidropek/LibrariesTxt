public class Antlr.Runtime.ANTLRFileStream : ANTLRStringStream {
    protected string fileName;
    public string SourceName { get; }
    public ANTLRFileStream(string fileName);
    public ANTLRFileStream(string fileName, Encoding encoding);
    public virtual void Load(string fileName, Encoding encoding);
    public virtual string get_SourceName();
}
public class Antlr.Runtime.ANTLRInputStream : ANTLRReaderStream {
    public ANTLRInputStream(Stream input);
    public ANTLRInputStream(Stream input, int size);
    public ANTLRInputStream(Stream input, Encoding encoding);
    public ANTLRInputStream(Stream input, int size, Encoding encoding);
    public ANTLRInputStream(Stream input, int size, int readBufferSize, Encoding encoding);
    private static StreamReader GetStreamReader(Stream input, Encoding encoding);
}
public class Antlr.Runtime.ANTLRReaderStream : ANTLRStringStream {
    public static int ReadBufferSize;
    public static int InitialBufferSize;
    public ANTLRReaderStream(TextReader r);
    public ANTLRReaderStream(TextReader r, int size);
    public ANTLRReaderStream(TextReader r, int size, int readChunkSize);
    public virtual void Load(TextReader r, int size, int readChunkSize);
}
public class Antlr.Runtime.ANTLRStringStream : object {
    protected Char[] data;
    protected int n;
    protected int p;
    private int line;
    private int charPositionInLine;
    protected int markDepth;
    protected IList`1<CharStreamState> markers;
    protected int lastMarker;
    public string name;
    public int Index { get; }
    public int Line { get; public set; }
    public int CharPositionInLine { get; public set; }
    public int Count { get; }
    public string SourceName { get; }
    public ANTLRStringStream(string input);
    public ANTLRStringStream(string input, string sourceName);
    public ANTLRStringStream(Char[] data, int numberOfActualCharsInArray);
    public ANTLRStringStream(Char[] data, int numberOfActualCharsInArray, string sourceName);
    public virtual int get_Index();
    public virtual int get_Line();
    public virtual void set_Line(int value);
    public virtual int get_CharPositionInLine();
    public virtual void set_CharPositionInLine(int value);
    public virtual void Reset();
    public virtual void Consume();
    public virtual int LA(int i);
    public virtual int LT(int i);
    public virtual int get_Count();
    public virtual int Mark();
    public virtual void Rewind(int m);
    public virtual void Rewind();
    public virtual void Release(int marker);
    public virtual void Seek(int index);
    public virtual string Substring(int start, int length);
    public virtual string get_SourceName();
    public virtual string ToString();
}
public class Antlr.Runtime.AstParserRuleReturnScope`2 : ParserRuleReturnScope`1<TToken> {
    private TTree _tree;
    public TTree Tree { get; public set; }
    private object Antlr.Runtime.IAstRuleReturnScope.Tree { get; }
    public sealed virtual TTree get_Tree();
    public void set_Tree(TTree value);
    private sealed virtual override object Antlr.Runtime.IAstRuleReturnScope.get_Tree();
}
public abstract class Antlr.Runtime.BaseRecognizer : object {
    public static int MemoRuleFailed;
    public static int MemoRuleUnknown;
    public static int InitialFollowStackSize;
    public static int DefaultTokenChannel;
    public static int Hidden;
    public static string NextTokenRuleName;
    protected internal RecognizerSharedState state;
    [CompilerGeneratedAttribute]
private TextWriter <TraceDestination>k__BackingField;
    public TextWriter TraceDestination { get; public set; }
    public int NumberOfSyntaxErrors { get; }
    public int BacktrackingLevel { get; public set; }
    public bool Failed { get; }
    public String[] TokenNames { get; }
    public string GrammarFileName { get; }
    public string SourceName { get; }
    public IDebugEventListener DebugListener { get; }
    public BaseRecognizer(RecognizerSharedState state);
    [CompilerGeneratedAttribute]
public TextWriter get_TraceDestination();
    [CompilerGeneratedAttribute]
public void set_TraceDestination(TextWriter value);
    public virtual void SetState(RecognizerSharedState value);
    protected virtual void InitDFAs();
    public virtual void Reset();
    public virtual object Match(IIntStream input, int ttype, BitSet follow);
    public virtual void MatchAny(IIntStream input);
    public virtual bool MismatchIsUnwantedToken(IIntStream input, int ttype);
    public virtual bool MismatchIsMissingToken(IIntStream input, BitSet follow);
    public virtual void ReportError(RecognitionException e);
    public virtual void DisplayRecognitionError(String[] tokenNames, RecognitionException e);
    public virtual string GetErrorMessage(RecognitionException e, String[] tokenNames);
    public virtual int get_NumberOfSyntaxErrors();
    public virtual string GetErrorHeader(RecognitionException e);
    public virtual string GetTokenErrorDisplay(IToken t);
    public virtual void EmitErrorMessage(string msg);
    public virtual void Recover(IIntStream input, RecognitionException re);
    public virtual void BeginResync();
    public virtual void EndResync();
    protected virtual BitSet ComputeErrorRecoverySet();
    protected virtual BitSet ComputeContextSensitiveRuleFOLLOW();
    protected virtual BitSet CombineFollows(bool exact);
    protected virtual object RecoverFromMismatchedToken(IIntStream input, int ttype, BitSet follow);
    public virtual object RecoverFromMismatchedSet(IIntStream input, RecognitionException e, BitSet follow);
    protected virtual object GetCurrentInputSymbol(IIntStream input);
    protected virtual object GetMissingSymbol(IIntStream input, RecognitionException e, int expectedTokenType, BitSet follow);
    public virtual void ConsumeUntil(IIntStream input, int tokenType);
    public virtual void ConsumeUntil(IIntStream input, BitSet set);
    protected void PushFollow(BitSet fset);
    protected void PopFollow();
    public virtual IList`1<string> GetRuleInvocationStack();
    public static IList`1<string> GetRuleInvocationStack(StackTrace trace);
    public virtual int get_BacktrackingLevel();
    public virtual void set_BacktrackingLevel(int value);
    public virtual bool get_Failed();
    public virtual String[] get_TokenNames();
    public virtual string get_GrammarFileName();
    public abstract virtual string get_SourceName();
    public virtual List`1<string> ToStrings(ICollection`1<IToken> tokens);
    public virtual int GetRuleMemoization(int ruleIndex, int ruleStartIndex);
    public virtual bool AlreadyParsedRule(IIntStream input, int ruleIndex);
    public virtual void Memoize(IIntStream input, int ruleIndex, int ruleStartIndex);
    public virtual int GetRuleMemoizationCacheSize();
    public virtual void TraceIn(string ruleName, int ruleIndex, object inputSymbol);
    public virtual void TraceOut(string ruleName, int ruleIndex, object inputSymbol);
    public virtual IDebugEventListener get_DebugListener();
    [ConditionalAttribute("ANTLR_DEBUG")]
protected virtual void DebugEnterRule(string grammarFileName, string ruleName);
    [ConditionalAttribute("ANTLR_DEBUG")]
protected virtual void DebugExitRule(string grammarFileName, string ruleName);
    [ConditionalAttribute("ANTLR_DEBUG")]
protected virtual void DebugEnterSubRule(int decisionNumber);
    [ConditionalAttribute("ANTLR_DEBUG")]
protected virtual void DebugExitSubRule(int decisionNumber);
    [ConditionalAttribute("ANTLR_DEBUG")]
protected virtual void DebugEnterAlt(int alt);
    [ConditionalAttribute("ANTLR_DEBUG")]
protected virtual void DebugEnterDecision(int decisionNumber, bool couldBacktrack);
    [ConditionalAttribute("ANTLR_DEBUG")]
protected virtual void DebugExitDecision(int decisionNumber);
    [ConditionalAttribute("ANTLR_DEBUG")]
protected virtual void DebugLocation(int line, int charPositionInLine);
    [ConditionalAttribute("ANTLR_DEBUG")]
protected virtual void DebugSemanticPredicate(bool result, string predicate);
    [ConditionalAttribute("ANTLR_DEBUG")]
protected virtual void DebugBeginBacktrack(int level);
    [ConditionalAttribute("ANTLR_DEBUG")]
protected virtual void DebugEndBacktrack(int level, bool successful);
    [ConditionalAttribute("ANTLR_DEBUG")]
protected virtual void DebugRecognitionException(RecognitionException ex);
}
public class Antlr.Runtime.BitSet : object {
    private static int BITS;
    private static int LOG_BITS;
    private static int MOD_MASK;
    private UInt64[] _bits;
    [CLSCompliantAttribute("False")]
public BitSet(UInt64[] bits);
    public BitSet(IEnumerable`1<int> items);
    public BitSet(int nbits);
    public static BitSet Of(int el);
    public static BitSet Of(int a, int b);
    public static BitSet Of(int a, int b, int c);
    public static BitSet Of(int a, int b, int c, int d);
    public BitSet Or(BitSet a);
    public void Add(int el);
    public void GrowToInclude(int bit);
    public void OrInPlace(BitSet a);
    private void SetSize(int nwords);
    private static ulong BitMask(int bitNumber);
    public sealed virtual object Clone();
    public int Size();
    public virtual int GetHashCode();
    public virtual bool Equals(object other);
    public bool Member(int el);
    public void Remove(int el);
    public bool IsNil();
    private static int NumWordsToHold(int el);
    public int NumBits();
    public int LengthInLongWords();
    public Int32[] ToArray();
    private static int WordNumber(int bit);
    public virtual string ToString();
    public string ToString(String[] tokenNames);
}
public class Antlr.Runtime.BufferedTokenStream : object {
    private ITokenSource _tokenSource;
    [CLSCompliantAttribute("False")]
protected List`1<IToken> _tokens;
    private int _lastMarker;
    [CLSCompliantAttribute("False")]
protected int _p;
    [CompilerGeneratedAttribute]
private int <Range>k__BackingField;
    public ITokenSource TokenSource { get; public set; }
    public int Index { get; }
    public int Range { get; protected set; }
    public int Count { get; }
    public string SourceName { get; }
    public IToken LastToken { get; }
    public IToken LastRealToken { get; }
    public int MaxLookBehind { get; }
    public BufferedTokenStream(ITokenSource tokenSource);
    public virtual ITokenSource get_TokenSource();
    public virtual void set_TokenSource(ITokenSource value);
    public virtual int get_Index();
    [CompilerGeneratedAttribute]
public virtual int get_Range();
    [CompilerGeneratedAttribute]
protected virtual void set_Range(int value);
    public virtual int get_Count();
    public virtual string get_SourceName();
    public virtual IToken get_LastToken();
    public virtual IToken get_LastRealToken();
    public virtual int get_MaxLookBehind();
    public virtual int Mark();
    public virtual void Release(int marker);
    public virtual void Rewind(int marker);
    public virtual void Rewind();
    public virtual void Reset();
    public virtual void Seek(int index);
    public virtual void Consume();
    protected virtual void Sync(int i);
    protected virtual void Fetch(int n);
    public virtual IToken Get(int i);
    public virtual int LA(int i);
    protected virtual IToken LB(int k);
    public virtual IToken LT(int k);
    protected virtual void Setup();
    public virtual List`1<IToken> GetTokens();
    public virtual List`1<IToken> GetTokens(int start, int stop);
    public virtual List`1<IToken> GetTokens(int start, int stop, BitSet types);
    public virtual List`1<IToken> GetTokens(int start, int stop, IEnumerable`1<int> types);
    public virtual List`1<IToken> GetTokens(int start, int stop, int ttype);
    public virtual string ToString();
    public virtual string ToString(int start, int stop);
    public virtual string ToString(IToken start, IToken stop);
    public virtual void Fill();
}
public static class Antlr.Runtime.CharStreamConstants : object {
    public static int EndOfFile;
}
public class Antlr.Runtime.CharStreamState : object {
    public int p;
    public int line;
    public int charPositionInLine;
}
public class Antlr.Runtime.ClassicToken : object {
    private string text;
    private int type;
    private int line;
    private int charPositionInLine;
    private int channel;
    private int index;
    public string Text { get; public set; }
    public int Type { get; public set; }
    public int Line { get; public set; }
    public int CharPositionInLine { get; public set; }
    public int Channel { get; public set; }
    public int StartIndex { get; public set; }
    public int StopIndex { get; public set; }
    public int TokenIndex { get; public set; }
    public ICharStream InputStream { get; public set; }
    public ClassicToken(int type);
    public ClassicToken(IToken oldToken);
    public ClassicToken(int type, string text);
    public ClassicToken(int type, string text, int channel);
    public sealed virtual string get_Text();
    public sealed virtual void set_Text(string value);
    public sealed virtual int get_Type();
    public sealed virtual void set_Type(int value);
    public sealed virtual int get_Line();
    public sealed virtual void set_Line(int value);
    public sealed virtual int get_CharPositionInLine();
    public sealed virtual void set_CharPositionInLine(int value);
    public sealed virtual int get_Channel();
    public sealed virtual void set_Channel(int value);
    public sealed virtual int get_StartIndex();
    public sealed virtual void set_StartIndex(int value);
    public sealed virtual int get_StopIndex();
    public sealed virtual void set_StopIndex(int value);
    public sealed virtual int get_TokenIndex();
    public sealed virtual void set_TokenIndex(int value);
    public sealed virtual ICharStream get_InputStream();
    public sealed virtual void set_InputStream(ICharStream value);
    public virtual string ToString();
}
public class Antlr.Runtime.CommonToken : object {
    private int type;
    private int line;
    private int charPositionInLine;
    private int channel;
    private ICharStream input;
    private string text;
    private int index;
    private int start;
    private int stop;
    public string Text { get; public set; }
    public int Type { get; public set; }
    public int Line { get; public set; }
    public int CharPositionInLine { get; public set; }
    public int Channel { get; public set; }
    public int StartIndex { get; public set; }
    public int StopIndex { get; public set; }
    public int TokenIndex { get; public set; }
    public ICharStream InputStream { get; public set; }
    public CommonToken(int type);
    public CommonToken(ICharStream input, int type, int channel, int start, int stop);
    public CommonToken(int type, string text);
    public CommonToken(IToken oldToken);
    public sealed virtual string get_Text();
    public sealed virtual void set_Text(string value);
    public sealed virtual int get_Type();
    public sealed virtual void set_Type(int value);
    public sealed virtual int get_Line();
    public sealed virtual void set_Line(int value);
    public sealed virtual int get_CharPositionInLine();
    public sealed virtual void set_CharPositionInLine(int value);
    public sealed virtual int get_Channel();
    public sealed virtual void set_Channel(int value);
    public sealed virtual int get_StartIndex();
    public sealed virtual void set_StartIndex(int value);
    public sealed virtual int get_StopIndex();
    public sealed virtual void set_StopIndex(int value);
    public sealed virtual int get_TokenIndex();
    public sealed virtual void set_TokenIndex(int value);
    public sealed virtual ICharStream get_InputStream();
    public sealed virtual void set_InputStream(ICharStream value);
    public virtual string ToString();
    [OnSerializingAttribute]
internal void OnSerializing(StreamingContext context);
}
public class Antlr.Runtime.CommonTokenStream : BufferedTokenStream {
    private int _channel;
    public int Channel { get; }
    public ITokenSource TokenSource { get; public set; }
    public CommonTokenStream(ITokenSource tokenSource);
    public CommonTokenStream(ITokenSource tokenSource, int channel);
    public int get_Channel();
    public virtual ITokenSource get_TokenSource();
    public virtual void set_TokenSource(ITokenSource value);
    public virtual void Consume();
    protected virtual IToken LB(int k);
    public virtual IToken LT(int k);
    protected virtual int SkipOffTokenChannels(int i);
    protected virtual int SkipOffTokenChannelsReverse(int i);
    public virtual void Reset();
    protected virtual void Setup();
}
public interface Antlr.Runtime.Debug.IDebugEventListener {
    public abstract virtual void Initialize();
    public abstract virtual void EnterRule(string grammarFileName, string ruleName);
    public abstract virtual void EnterAlt(int alt);
    public abstract virtual void ExitRule(string grammarFileName, string ruleName);
    public abstract virtual void EnterSubRule(int decisionNumber);
    public abstract virtual void ExitSubRule(int decisionNumber);
    public abstract virtual void EnterDecision(int decisionNumber, bool couldBacktrack);
    public abstract virtual void ExitDecision(int decisionNumber);
    public abstract virtual void ConsumeToken(IToken t);
    public abstract virtual void ConsumeHiddenToken(IToken t);
    public abstract virtual void LT(int i, IToken t);
    public abstract virtual void Mark(int marker);
    public abstract virtual void Rewind(int marker);
    public abstract virtual void Rewind();
    public abstract virtual void BeginBacktrack(int level);
    public abstract virtual void EndBacktrack(int level, bool successful);
    public abstract virtual void Location(int line, int pos);
    public abstract virtual void RecognitionException(RecognitionException e);
    public abstract virtual void BeginResync();
    public abstract virtual void EndResync();
    public abstract virtual void SemanticPredicate(bool result, string predicate);
    public abstract virtual void Commence();
    public abstract virtual void Terminate();
    public abstract virtual void ConsumeNode(object t);
    public abstract virtual void LT(int i, object t);
    public abstract virtual void NilNode(object t);
    public abstract virtual void ErrorNode(object t);
    public abstract virtual void CreateNode(object t);
    public abstract virtual void CreateNode(object node, IToken token);
    public abstract virtual void BecomeRoot(object newRoot, object oldRoot);
    public abstract virtual void AddChild(object root, object child);
    public abstract virtual void SetTokenBoundaries(object t, int tokenStartIndex, int tokenStopIndex);
}
public class Antlr.Runtime.DFA : object {
    protected Int16[] eot;
    protected Int16[] eof;
    protected Char[] min;
    protected Char[] max;
    protected Int16[] accept;
    protected Int16[] special;
    protected Int16[][] transition;
    protected int decisionNumber;
    protected BaseRecognizer recognizer;
    public bool debug;
    [CompilerGeneratedAttribute]
private SpecialStateTransitionHandler <SpecialStateTransition>k__BackingField;
    public string Description { get; }
    public SpecialStateTransitionHandler SpecialStateTransition { get; private set; }
    public DFA(SpecialStateTransitionHandler specialStateTransition);
    public virtual string get_Description();
    public virtual int Predict(IIntStream input);
    [ConditionalAttribute("DEBUG_DFA")]
private void DfaDebugMessage(string format, Object[] args);
    [ConditionalAttribute("DEBUG_DFA")]
private void DfaDebugInvalidSymbol(int s);
    protected virtual void NoViableAlt(int s, IIntStream input);
    public virtual void Error(NoViableAltException nvae);
    [CompilerGeneratedAttribute]
public SpecialStateTransitionHandler get_SpecialStateTransition();
    [CompilerGeneratedAttribute]
private void set_SpecialStateTransition(SpecialStateTransitionHandler value);
    private static int SpecialStateTransitionDefault(DFA dfa, int s, IIntStream input);
    public static Int16[] UnpackEncodedString(string encodedString);
    public static Char[] UnpackEncodedStringToUnsignedChars(string encodedString);
    [ConditionalAttribute("ANTLR_DEBUG")]
protected virtual void DebugRecognitionException(RecognitionException ex);
}
public class Antlr.Runtime.EarlyExitException : RecognitionException {
    private int _decisionNumber;
    public int DecisionNumber { get; }
    public EarlyExitException(string message);
    public EarlyExitException(string message, Exception innerException);
    public EarlyExitException(int decisionNumber, IIntStream input);
    public EarlyExitException(string message, int decisionNumber, IIntStream input);
    public EarlyExitException(string message, int decisionNumber, IIntStream input, Exception innerException);
    protected EarlyExitException(SerializationInfo info, StreamingContext context);
    public int get_DecisionNumber();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class Antlr.Runtime.FailedPredicateException : RecognitionException {
    private string _ruleName;
    private string _predicateText;
    public string RuleName { get; }
    public string PredicateText { get; }
    public FailedPredicateException(string message);
    public FailedPredicateException(string message, Exception innerException);
    public FailedPredicateException(IIntStream input, string ruleName, string predicateText);
    public FailedPredicateException(string message, IIntStream input, string ruleName, string predicateText);
    public FailedPredicateException(string message, IIntStream input, string ruleName, string predicateText, Exception innerException);
    protected FailedPredicateException(SerializationInfo info, StreamingContext context);
    public string get_RuleName();
    public string get_PredicateText();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
}
[AttributeUsageAttribute("64")]
public class Antlr.Runtime.GrammarRuleAttribute : Attribute {
    private string _name;
    public string Name { get; }
    public GrammarRuleAttribute(string name);
    public string get_Name();
}
public interface Antlr.Runtime.IAstRuleReturnScope {
    public object Tree { get; }
    public abstract virtual object get_Tree();
}
public interface Antlr.Runtime.IAstRuleReturnScope`1 {
    public TAstLabel Tree { get; }
    public abstract virtual TAstLabel get_Tree();
}
public interface Antlr.Runtime.ICharStream {
    public int Line { get; public set; }
    public int CharPositionInLine { get; public set; }
    public abstract virtual string Substring(int start, int length);
    public abstract virtual int LT(int i);
    public abstract virtual int get_Line();
    public abstract virtual void set_Line(int value);
    public abstract virtual int get_CharPositionInLine();
    public abstract virtual void set_CharPositionInLine(int value);
}
public interface Antlr.Runtime.IIntStream {
    public int Index { get; }
    public int Count { get; }
    public string SourceName { get; }
    public abstract virtual void Consume();
    public abstract virtual int LA(int i);
    public abstract virtual int Mark();
    public abstract virtual int get_Index();
    public abstract virtual void Rewind(int marker);
    public abstract virtual void Rewind();
    public abstract virtual void Release(int marker);
    public abstract virtual void Seek(int index);
    public abstract virtual int get_Count();
    public abstract virtual string get_SourceName();
}
public interface Antlr.Runtime.IRuleReturnScope {
    public object Start { get; }
    public object Stop { get; }
    public abstract virtual object get_Start();
    public abstract virtual object get_Stop();
}
public interface Antlr.Runtime.IRuleReturnScope`1 {
    public TLabel Start { get; }
    public TLabel Stop { get; }
    public abstract virtual TLabel get_Start();
    public abstract virtual TLabel get_Stop();
}
public interface Antlr.Runtime.ITemplateRuleReturnScope {
    public object Template { get; }
    public abstract virtual object get_Template();
}
public interface Antlr.Runtime.ITemplateRuleReturnScope`1 {
    public TTemplate Template { get; }
    public abstract virtual TTemplate get_Template();
}
public interface Antlr.Runtime.IToken {
    public string Text { get; public set; }
    public int Type { get; public set; }
    public int Line { get; public set; }
    public int CharPositionInLine { get; public set; }
    public int Channel { get; public set; }
    public int StartIndex { get; public set; }
    public int StopIndex { get; public set; }
    public int TokenIndex { get; public set; }
    public ICharStream InputStream { get; public set; }
    public abstract virtual string get_Text();
    public abstract virtual void set_Text(string value);
    public abstract virtual int get_Type();
    public abstract virtual void set_Type(int value);
    public abstract virtual int get_Line();
    public abstract virtual void set_Line(int value);
    public abstract virtual int get_CharPositionInLine();
    public abstract virtual void set_CharPositionInLine(int value);
    public abstract virtual int get_Channel();
    public abstract virtual void set_Channel(int value);
    public abstract virtual int get_StartIndex();
    public abstract virtual void set_StartIndex(int value);
    public abstract virtual int get_StopIndex();
    public abstract virtual void set_StopIndex(int value);
    public abstract virtual int get_TokenIndex();
    public abstract virtual void set_TokenIndex(int value);
    public abstract virtual ICharStream get_InputStream();
    public abstract virtual void set_InputStream(ICharStream value);
}
public interface Antlr.Runtime.ITokenSource {
    public string SourceName { get; }
    public String[] TokenNames { get; }
    public abstract virtual IToken NextToken();
    public abstract virtual string get_SourceName();
    public abstract virtual String[] get_TokenNames();
}
public interface Antlr.Runtime.ITokenStream {
    public int Range { get; }
    public ITokenSource TokenSource { get; }
    public abstract virtual IToken LT(int k);
    public abstract virtual int get_Range();
    public abstract virtual IToken Get(int i);
    public abstract virtual ITokenSource get_TokenSource();
    public abstract virtual string ToString(int start, int stop);
    public abstract virtual string ToString(IToken start, IToken stop);
}
public interface Antlr.Runtime.ITokenStreamInformation {
    public IToken LastToken { get; }
    public IToken LastRealToken { get; }
    public int MaxLookBehind { get; }
    public abstract virtual IToken get_LastToken();
    public abstract virtual IToken get_LastRealToken();
    public abstract virtual int get_MaxLookBehind();
}
public class Antlr.Runtime.LegacyCommonTokenStream : object {
    private ITokenSource _tokenSource;
    protected List`1<IToken> tokens;
    protected IDictionary`2<int, int> channelOverrideMap;
    protected List`1<int> discardSet;
    protected int channel;
    protected bool discardOffChannelTokens;
    protected int lastMarker;
    protected int p;
    [CompilerGeneratedAttribute]
private int <Range>k__BackingField;
    public int Index { get; }
    public int Range { get; protected set; }
    public int Count { get; }
    public ITokenSource TokenSource { get; }
    public string SourceName { get; }
    public LegacyCommonTokenStream(ITokenSource tokenSource);
    public LegacyCommonTokenStream(ITokenSource tokenSource, int channel);
    public virtual int get_Index();
    [CompilerGeneratedAttribute]
public virtual int get_Range();
    [CompilerGeneratedAttribute]
protected virtual void set_Range(int value);
    public virtual void SetTokenSource(ITokenSource tokenSource);
    public virtual void FillBuffer();
    public virtual void Consume();
    protected virtual int SkipOffTokenChannels(int i);
    protected virtual int SkipOffTokenChannelsReverse(int i);
    public virtual void SetTokenTypeChannel(int ttype, int channel);
    public virtual void DiscardTokenType(int ttype);
    public virtual void SetDiscardOffChannelTokens(bool discardOffChannelTokens);
    public virtual IList`1<IToken> GetTokens();
    public virtual IList`1<IToken> GetTokens(int start, int stop);
    public virtual IList`1<IToken> GetTokens(int start, int stop, BitSet types);
    public virtual IList`1<IToken> GetTokens(int start, int stop, IList`1<int> types);
    public virtual IList`1<IToken> GetTokens(int start, int stop, int ttype);
    public virtual IToken LT(int k);
    protected virtual IToken LB(int k);
    public virtual IToken Get(int i);
    public virtual int LA(int i);
    public virtual int Mark();
    public virtual void Release(int marker);
    public virtual int get_Count();
    public virtual void Rewind(int marker);
    public virtual void Rewind();
    public virtual void Reset();
    public virtual void Seek(int index);
    public virtual ITokenSource get_TokenSource();
    public virtual string get_SourceName();
    public virtual string ToString();
    public virtual string ToString(int start, int stop);
    public virtual string ToString(IToken start, IToken stop);
}
public abstract class Antlr.Runtime.Lexer : BaseRecognizer {
    protected ICharStream input;
    public string Text { get; public set; }
    public int Line { get; public set; }
    public int CharPositionInLine { get; public set; }
    public ICharStream CharStream { get; public set; }
    public string SourceName { get; }
    public int CharIndex { get; }
    public Lexer(ICharStream input);
    public Lexer(ICharStream input, RecognizerSharedState state);
    public string get_Text();
    public void set_Text(string value);
    public int get_Line();
    public void set_Line(int value);
    public int get_CharPositionInLine();
    public void set_CharPositionInLine(int value);
    public virtual void Reset();
    public virtual IToken NextToken();
    public virtual IToken GetEndOfFileToken();
    public virtual void Skip();
    public abstract virtual void mTokens();
    public virtual ICharStream get_CharStream();
    public virtual void set_CharStream(ICharStream value);
    public virtual string get_SourceName();
    public virtual void Emit(IToken token);
    public virtual IToken Emit();
    public virtual void Match(string s);
    public virtual void MatchAny();
    public virtual void Match(int c);
    public virtual void MatchRange(int a, int b);
    public virtual int get_CharIndex();
    public virtual void ReportError(RecognitionException e);
    public virtual string GetErrorMessage(RecognitionException e, String[] tokenNames);
    public virtual string GetCharErrorDisplay(int c);
    public virtual void Recover(RecognitionException re);
    [ConditionalAttribute("ANTLR_TRACE")]
public virtual void TraceIn(string ruleName, int ruleIndex);
    [ConditionalAttribute("ANTLR_TRACE")]
public virtual void TraceOut(string ruleName, int ruleIndex);
    protected virtual void ParseNextToken();
}
public class Antlr.Runtime.Misc.Action : MulticastDelegate {
    public Action(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[DefaultMemberAttribute("Item")]
public class Antlr.Runtime.Misc.FastQueue`1 : object {
    internal List`1<T> _data;
    internal int _p;
    [CompilerGeneratedAttribute]
private int <Range>k__BackingField;
    public int Count { get; }
    public int Range { get; protected set; }
    public T Item { get; }
    public virtual int get_Count();
    [CompilerGeneratedAttribute]
public virtual int get_Range();
    [CompilerGeneratedAttribute]
protected virtual void set_Range(int value);
    public virtual T get_Item(int i);
    public virtual T Dequeue();
    public virtual void Enqueue(T o);
    public virtual T Peek();
    public virtual void Clear();
    public virtual string ToString();
}
public class Antlr.Runtime.Misc.Func`1 : MulticastDelegate {
    public Func`1(object object, IntPtr method);
    public virtual TResult Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class Antlr.Runtime.Misc.Func`2 : MulticastDelegate {
    public Func`2(object object, IntPtr method);
    public virtual TResult Invoke(T arg);
    public virtual IAsyncResult BeginInvoke(T arg, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class Antlr.Runtime.Misc.ListStack`1 : List`1<T> {
    public T Peek();
    public T Peek(int depth);
    public bool TryPeek(T& item);
    public bool TryPeek(int depth, T& item);
    public T Pop();
    public bool TryPop(T& item);
    public void Push(T item);
}
public abstract class Antlr.Runtime.Misc.LookaheadStream`1 : FastQueue`1<T> {
    private int _currentElementIndex;
    private T _previousElement;
    private T _eof;
    private int _lastMarker;
    private int _markDepth;
    public T EndOfFile { get; protected set; }
    public T PreviousElement { get; }
    public int Count { get; }
    public int Index { get; }
    public T get_EndOfFile();
    protected void set_EndOfFile(T value);
    public T get_PreviousElement();
    public virtual void Reset();
    public abstract virtual T NextElement();
    public abstract virtual bool IsEndOfFile(T o);
    public virtual T Dequeue();
    public virtual void Consume();
    protected virtual void SyncAhead(int need);
    public virtual void Fill(int n);
    public virtual int get_Count();
    public virtual T LT(int k);
    public virtual int get_Index();
    public virtual int Mark();
    public virtual void Release(int marker);
    public virtual void Rewind(int marker);
    public virtual void Rewind();
    public virtual void Seek(int index);
    protected virtual T LB(int k);
}
internal static class Antlr.Runtime.Misc.RegexOptionsHelper : object {
    public static RegexOptions Compiled;
    private static RegexOptionsHelper();
}
public class Antlr.Runtime.MismatchedNotSetException : MismatchedSetException {
    public MismatchedNotSetException(string message);
    public MismatchedNotSetException(string message, Exception innerException);
    public MismatchedNotSetException(BitSet expecting, IIntStream input);
    public MismatchedNotSetException(string message, BitSet expecting, IIntStream input);
    public MismatchedNotSetException(string message, BitSet expecting, IIntStream input, Exception innerException);
    protected MismatchedNotSetException(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
}
public class Antlr.Runtime.MismatchedRangeException : RecognitionException {
    private int _a;
    private int _b;
    public int A { get; }
    public int B { get; }
    public MismatchedRangeException(string message);
    public MismatchedRangeException(string message, Exception innerException);
    public MismatchedRangeException(int a, int b, IIntStream input);
    public MismatchedRangeException(string message, int a, int b, IIntStream input);
    public MismatchedRangeException(string message, int a, int b, IIntStream input, Exception innerException);
    protected MismatchedRangeException(SerializationInfo info, StreamingContext context);
    public int get_A();
    public int get_B();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
}
public class Antlr.Runtime.MismatchedSetException : RecognitionException {
    private BitSet _expecting;
    public BitSet Expecting { get; }
    public MismatchedSetException(string message);
    public MismatchedSetException(string message, Exception innerException);
    public MismatchedSetException(BitSet expecting, IIntStream input);
    public MismatchedSetException(string message, BitSet expecting, IIntStream input);
    public MismatchedSetException(string message, BitSet expecting, IIntStream input, Exception innerException);
    protected MismatchedSetException(SerializationInfo info, StreamingContext context);
    public BitSet get_Expecting();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
}
public class Antlr.Runtime.MismatchedTokenException : RecognitionException {
    private int _expecting;
    private ReadOnlyCollection`1<string> _tokenNames;
    public int Expecting { get; }
    public ReadOnlyCollection`1<string> TokenNames { get; }
    public MismatchedTokenException(string message);
    public MismatchedTokenException(string message, Exception innerException);
    public MismatchedTokenException(int expecting, IIntStream input);
    public MismatchedTokenException(int expecting, IIntStream input, IList`1<string> tokenNames);
    public MismatchedTokenException(string message, int expecting, IIntStream input, IList`1<string> tokenNames);
    public MismatchedTokenException(string message, int expecting, IIntStream input, IList`1<string> tokenNames, Exception innerException);
    protected MismatchedTokenException(SerializationInfo info, StreamingContext context);
    public int get_Expecting();
    public ReadOnlyCollection`1<string> get_TokenNames();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
}
public class Antlr.Runtime.MismatchedTreeNodeException : RecognitionException {
    private int _expecting;
    public int Expecting { get; }
    public MismatchedTreeNodeException(string message);
    public MismatchedTreeNodeException(string message, Exception innerException);
    public MismatchedTreeNodeException(int expecting, ITreeNodeStream input);
    public MismatchedTreeNodeException(string message, int expecting, ITreeNodeStream input);
    public MismatchedTreeNodeException(string message, int expecting, ITreeNodeStream input, Exception innerException);
    protected MismatchedTreeNodeException(SerializationInfo info, StreamingContext context);
    public int get_Expecting();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
}
public class Antlr.Runtime.MissingTokenException : MismatchedTokenException {
    private object _inserted;
    public int MissingType { get; }
    public MissingTokenException(string message);
    public MissingTokenException(string message, Exception innerException);
    public MissingTokenException(int expecting, IIntStream input, object inserted);
    public MissingTokenException(int expecting, IIntStream input, object inserted, IList`1<string> tokenNames);
    public MissingTokenException(string message, int expecting, IIntStream input, object inserted, IList`1<string> tokenNames);
    public MissingTokenException(string message, int expecting, IIntStream input, object inserted, IList`1<string> tokenNames, Exception innerException);
    protected MissingTokenException(SerializationInfo info, StreamingContext context);
    public virtual int get_MissingType();
    public virtual string ToString();
}
public class Antlr.Runtime.NoViableAltException : RecognitionException {
    private string _grammarDecisionDescription;
    private int _decisionNumber;
    private int _stateNumber;
    public int DecisionNumber { get; }
    public string GrammarDecisionDescription { get; }
    public int StateNumber { get; }
    public NoViableAltException(string grammarDecisionDescription);
    public NoViableAltException(string message, string grammarDecisionDescription);
    public NoViableAltException(string message, string grammarDecisionDescription, Exception innerException);
    public NoViableAltException(string grammarDecisionDescription, int decisionNumber, int stateNumber, IIntStream input);
    public NoViableAltException(string grammarDecisionDescription, int decisionNumber, int stateNumber, IIntStream input, int k);
    public NoViableAltException(string message, string grammarDecisionDescription, int decisionNumber, int stateNumber, IIntStream input);
    public NoViableAltException(string message, string grammarDecisionDescription, int decisionNumber, int stateNumber, IIntStream input, int k);
    public NoViableAltException(string message, string grammarDecisionDescription, int decisionNumber, int stateNumber, IIntStream input, Exception innerException);
    public NoViableAltException(string message, string grammarDecisionDescription, int decisionNumber, int stateNumber, IIntStream input, int k, Exception innerException);
    protected NoViableAltException(SerializationInfo info, StreamingContext context);
    public int get_DecisionNumber();
    public string get_GrammarDecisionDescription();
    public int get_StateNumber();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
}
public class Antlr.Runtime.Parser : BaseRecognizer {
    public ITokenStream input;
    public ITokenStream TokenStream { get; public set; }
    public string SourceName { get; }
    public Parser(ITokenStream input);
    public Parser(ITokenStream input, RecognizerSharedState state);
    public virtual void Reset();
    protected virtual object GetCurrentInputSymbol(IIntStream input);
    protected virtual object GetMissingSymbol(IIntStream input, RecognitionException e, int expectedTokenType, BitSet follow);
    public virtual ITokenStream get_TokenStream();
    public virtual void set_TokenStream(ITokenStream value);
    public virtual string get_SourceName();
    [ConditionalAttribute("ANTLR_TRACE")]
public virtual void TraceIn(string ruleName, int ruleIndex);
    [ConditionalAttribute("ANTLR_TRACE")]
public virtual void TraceOut(string ruleName, int ruleIndex);
}
public class Antlr.Runtime.ParserRuleReturnScope`1 : object {
    private TToken _start;
    private TToken _stop;
    public TToken Start { get; public set; }
    public TToken Stop { get; public set; }
    private object Antlr.Runtime.IRuleReturnScope.Start { get; }
    private object Antlr.Runtime.IRuleReturnScope.Stop { get; }
    public sealed virtual TToken get_Start();
    public void set_Start(TToken value);
    public sealed virtual TToken get_Stop();
    public void set_Stop(TToken value);
    private sealed virtual override object Antlr.Runtime.IRuleReturnScope.get_Start();
    private sealed virtual override object Antlr.Runtime.IRuleReturnScope.get_Stop();
}
public class Antlr.Runtime.RecognitionException : Exception {
    private IIntStream _input;
    private int _k;
    private int _index;
    private IToken _token;
    private object _node;
    private int _c;
    private int _line;
    private int _charPositionInLine;
    private bool _approximateLineInfo;
    public int UnexpectedType { get; }
    public bool ApproximateLineInfo { get; protected set; }
    public IIntStream Input { get; protected set; }
    public int Lookahead { get; }
    public IToken Token { get; public set; }
    public object Node { get; protected set; }
    public int Character { get; protected set; }
    public int Index { get; protected set; }
    public int Line { get; public set; }
    public int CharPositionInLine { get; public set; }
    public RecognitionException(IIntStream input);
    public RecognitionException(IIntStream input, int k);
    public RecognitionException(string message);
    public RecognitionException(string message, IIntStream input);
    public RecognitionException(string message, IIntStream input, int k);
    public RecognitionException(string message, Exception innerException);
    public RecognitionException(string message, IIntStream input, Exception innerException);
    public RecognitionException(string message, IIntStream input, int k, Exception innerException);
    protected RecognitionException(SerializationInfo info, StreamingContext context);
    public virtual int get_UnexpectedType();
    public bool get_ApproximateLineInfo();
    protected void set_ApproximateLineInfo(bool value);
    public IIntStream get_Input();
    protected void set_Input(IIntStream value);
    public int get_Lookahead();
    public IToken get_Token();
    public void set_Token(IToken value);
    public object get_Node();
    protected void set_Node(object value);
    public int get_Character();
    protected void set_Character(int value);
    public int get_Index();
    protected void set_Index(int value);
    public int get_Line();
    public void set_Line(int value);
    public int get_CharPositionInLine();
    public void set_CharPositionInLine(int value);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    protected virtual void ExtractInformationFromTreeNodeStream(ITreeNodeStream input);
    protected virtual void ExtractInformationFromTreeNodeStream(ITreeNodeStream input, int k);
}
public class Antlr.Runtime.RecognizerSharedState : object {
    public BitSet[] following;
    [CLSCompliantAttribute("False")]
public int _fsp;
    public bool errorRecovery;
    public int lastErrorIndex;
    public bool failed;
    public int syntaxErrors;
    public int backtracking;
    public IDictionary`2[] ruleMemo;
    public IToken token;
    public int tokenStartCharIndex;
    public int tokenStartLine;
    public int tokenStartCharPositionInLine;
    public int channel;
    public int type;
    public string text;
    public RecognizerSharedState(RecognizerSharedState state);
}
public class Antlr.Runtime.SpecialStateTransitionHandler : MulticastDelegate {
    public SpecialStateTransitionHandler(object object, IntPtr method);
    public virtual int Invoke(DFA dfa, int s, IIntStream input);
    public virtual IAsyncResult BeginInvoke(DFA dfa, int s, IIntStream input, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
public class Antlr.Runtime.TemplateParserRuleReturnScope`2 : ParserRuleReturnScope`1<TToken> {
    private TTemplate _template;
    public TTemplate Template { get; public set; }
    private object Antlr.Runtime.ITemplateRuleReturnScope.Template { get; }
    public sealed virtual TTemplate get_Template();
    public void set_Template(TTemplate value);
    private sealed virtual override object Antlr.Runtime.ITemplateRuleReturnScope.get_Template();
}
public static class Antlr.Runtime.TokenChannels : object {
    public static int Default;
    public static int Hidden;
}
[DebuggerDisplayAttribute("TODO: TokenRewriteStream debugger display")]
public class Antlr.Runtime.TokenRewriteStream : CommonTokenStream {
    public static string DEFAULT_PROGRAM_NAME;
    public static int PROGRAM_INIT_SIZE;
    public static int MIN_TOKEN_INDEX;
    protected IDictionary`2<string, IList`1<RewriteOperation>> programs;
    protected IDictionary`2<string, int> lastRewriteTokenIndexes;
    public TokenRewriteStream(ITokenSource tokenSource);
    public TokenRewriteStream(ITokenSource tokenSource, int channel);
    protected void Init();
    public virtual void Rollback(int instructionIndex);
    public virtual void Rollback(string programName, int instructionIndex);
    public virtual void DeleteProgram();
    public virtual void DeleteProgram(string programName);
    public virtual void InsertAfter(IToken t, object text);
    public virtual void InsertAfter(int index, object text);
    public virtual void InsertAfter(string programName, IToken t, object text);
    public virtual void InsertAfter(string programName, int index, object text);
    public virtual void InsertBefore(IToken t, object text);
    public virtual void InsertBefore(int index, object text);
    public virtual void InsertBefore(string programName, IToken t, object text);
    public virtual void InsertBefore(string programName, int index, object text);
    public virtual void Replace(int index, object text);
    public virtual void Replace(int from, int to, object text);
    public virtual void Replace(IToken indexT, object text);
    public virtual void Replace(IToken from, IToken to, object text);
    public virtual void Replace(string programName, int from, int to, object text);
    public virtual void Replace(string programName, IToken from, IToken to, object text);
    public virtual void Delete(int index);
    public virtual void Delete(int from, int to);
    public virtual void Delete(IToken indexT);
    public virtual void Delete(IToken from, IToken to);
    public virtual void Delete(string programName, int from, int to);
    public virtual void Delete(string programName, IToken from, IToken to);
    public virtual int GetLastRewriteTokenIndex();
    protected virtual int GetLastRewriteTokenIndex(string programName);
    protected virtual void SetLastRewriteTokenIndex(string programName, int i);
    protected virtual IList`1<RewriteOperation> GetProgram(string name);
    private IList`1<RewriteOperation> InitializeProgram(string name);
    public virtual string ToOriginalString();
    public virtual string ToOriginalString(int start, int end);
    public virtual string ToString();
    public virtual string ToString(string programName);
    public virtual string ToString(int start, int end);
    public virtual string ToString(string programName, int start, int end);
    protected virtual IDictionary`2<int, RewriteOperation> ReduceToSingleOperationPerIndex(IList`1<RewriteOperation> rewrites);
    protected virtual string CatOpText(object a, object b);
    protected virtual IList`1<RewriteOperation> GetKindOfOps(IList`1<RewriteOperation> rewrites, Type kind);
    protected virtual IList`1<RewriteOperation> GetKindOfOps(IList`1<RewriteOperation> rewrites, Type kind, int before);
    public virtual string ToDebugString();
    public virtual string ToDebugString(int start, int end);
}
public static class Antlr.Runtime.Tokens : object {
    public static IToken Skip;
    private static Tokens();
}
public static class Antlr.Runtime.TokenTypes : object {
    public static int EndOfFile;
    public static int Invalid;
    public static int EndOfRule;
    public static int Down;
    public static int Up;
    public static int Min;
}
internal class Antlr.Runtime.Tree.AntlrRuntime_BaseTreeDebugView : object {
    private BaseTree _tree;
    [DebuggerBrowsableAttribute("3")]
public ITree[] Children { get; }
    public AntlrRuntime_BaseTreeDebugView(BaseTree tree);
    public ITree[] get_Children();
}
public class Antlr.Runtime.Tree.AstTreeRuleReturnScope`2 : TreeRuleReturnScope`1<TInputTree> {
    private TOutputTree _tree;
    public TOutputTree Tree { get; public set; }
    private object Antlr.Runtime.IAstRuleReturnScope.Tree { get; }
    public sealed virtual TOutputTree get_Tree();
    public void set_Tree(TOutputTree value);
    private sealed virtual override object Antlr.Runtime.IAstRuleReturnScope.get_Tree();
}
[DebuggerTypeProxyAttribute("Antlr.Runtime.Tree.AntlrRuntime_BaseTreeDebugView")]
public abstract class Antlr.Runtime.Tree.BaseTree : object {
    private IList`1<ITree> _children;
    [CompilerGeneratedAttribute]
private int <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CharPositionInLine>k__BackingField;
    public IList`1<ITree> Children { get; private set; }
    public int ChildCount { get; }
    public ITree Parent { get; public set; }
    public int ChildIndex { get; public set; }
    public bool IsNil { get; }
    public int TokenStartIndex { get; public set; }
    public int TokenStopIndex { get; public set; }
    public int Type { get; public set; }
    public string Text { get; public set; }
    public int Line { get; public set; }
    public int CharPositionInLine { get; public set; }
    public BaseTree(ITree node);
    public virtual IList`1<ITree> get_Children();
    private void set_Children(IList`1<ITree> value);
    public virtual int get_ChildCount();
    public virtual ITree get_Parent();
    public virtual void set_Parent(ITree value);
    public virtual int get_ChildIndex();
    public virtual void set_ChildIndex(int value);
    public virtual bool get_IsNil();
    public abstract virtual int get_TokenStartIndex();
    public abstract virtual void set_TokenStartIndex(int value);
    public abstract virtual int get_TokenStopIndex();
    public abstract virtual void set_TokenStopIndex(int value);
    public abstract virtual int get_Type();
    public abstract virtual void set_Type(int value);
    public abstract virtual string get_Text();
    public abstract virtual void set_Text(string value);
    [CompilerGeneratedAttribute]
public virtual int get_Line();
    [CompilerGeneratedAttribute]
public virtual void set_Line(int value);
    [CompilerGeneratedAttribute]
public virtual int get_CharPositionInLine();
    [CompilerGeneratedAttribute]
public virtual void set_CharPositionInLine(int value);
    public virtual ITree GetChild(int i);
    public virtual ITree GetFirstChildWithType(int type);
    public virtual void AddChild(ITree t);
    public virtual void AddChildren(IEnumerable`1<ITree> kids);
    public virtual void SetChild(int i, ITree t);
    public virtual void InsertChild(int i, ITree t);
    public virtual object DeleteChild(int i);
    public virtual void ReplaceChildren(int startChildIndex, int stopChildIndex, object t);
    protected virtual IList`1<ITree> CreateChildrenList();
    public virtual void FreshenParentAndChildIndexes();
    public virtual void FreshenParentAndChildIndexes(int offset);
    public virtual void FreshenParentAndChildIndexesDeeply();
    public virtual void FreshenParentAndChildIndexesDeeply(int offset);
    public virtual void SanityCheckParentAndChildIndexes();
    public virtual void SanityCheckParentAndChildIndexes(ITree parent, int i);
    public virtual bool HasAncestor(int ttype);
    public virtual ITree GetAncestor(int ttype);
    public virtual IList`1<ITree> GetAncestors();
    public virtual string ToStringTree();
    public abstract virtual string ToString();
    public abstract virtual ITree DupNode();
}
public abstract class Antlr.Runtime.Tree.BaseTreeAdaptor : object {
    protected IDictionary`2<object, int> treeToUniqueIDMap;
    protected int uniqueNodeID;
    public virtual object Nil();
    public virtual object ErrorNode(ITokenStream input, IToken start, IToken stop, RecognitionException e);
    public virtual bool IsNil(object tree);
    public virtual object DupNode(int type, object treeNode);
    public virtual object DupNode(object treeNode, string text);
    public virtual object DupNode(int type, object treeNode, string text);
    public virtual object DupTree(object tree);
    public virtual object DupTree(object t, object parent);
    public virtual void AddChild(object t, object child);
    public virtual object BecomeRoot(object newRoot, object oldRoot);
    public virtual object RulePostProcessing(object root);
    public virtual object BecomeRoot(IToken newRoot, object oldRoot);
    public virtual object Create(int tokenType, IToken fromToken);
    public virtual object Create(int tokenType, IToken fromToken, string text);
    public virtual object Create(IToken fromToken, string text);
    public virtual object Create(int tokenType, string text);
    public virtual int GetType(object t);
    public virtual void SetType(object t, int type);
    public virtual string GetText(object t);
    public virtual void SetText(object t, string text);
    public virtual object GetChild(object t, int i);
    public virtual void SetChild(object t, int i, object child);
    public virtual object DeleteChild(object t, int i);
    public virtual int GetChildCount(object t);
    public virtual int GetUniqueID(object node);
    public abstract virtual IToken CreateToken(int tokenType, string text);
    public abstract virtual IToken CreateToken(IToken fromToken);
    public abstract virtual object Create(IToken payload);
    public virtual object DupNode(object treeNode);
    public abstract virtual IToken GetToken(object t);
    public virtual void SetTokenBoundaries(object t, IToken startToken, IToken stopToken);
    public virtual int GetTokenStartIndex(object t);
    public virtual int GetTokenStopIndex(object t);
    public virtual object GetParent(object t);
    public virtual void SetParent(object t, object parent);
    public virtual int GetChildIndex(object t);
    public virtual void SetChildIndex(object t, int index);
    public virtual void ReplaceChildren(object parent, int startChildIndex, int stopChildIndex, object t);
    protected virtual ITree GetTree(object t);
}
[DefaultMemberAttribute("Item")]
public class Antlr.Runtime.Tree.BufferedTreeNodeStream : object {
    public static int DEFAULT_INITIAL_BUFFER_SIZE;
    public static int INITIAL_CALL_STACK_SIZE;
    protected object down;
    protected object up;
    protected object eof;
    protected IList nodes;
    protected object root;
    protected ITokenStream tokens;
    private ITreeAdaptor adaptor;
    private bool uniqueNavigationNodes;
    protected int p;
    protected int lastMarker;
    protected Stack`1<int> calls;
    public int Count { get; }
    public object TreeSource { get; }
    public string SourceName { get; }
    public ITokenStream TokenStream { get; public set; }
    public ITreeAdaptor TreeAdaptor { get; public set; }
    public bool UniqueNavigationNodes { get; public set; }
    public IToken LastToken { get; }
    public IToken LastRealToken { get; }
    public int MaxLookBehind { get; }
    public object Item { get; }
    public int Index { get; }
    public BufferedTreeNodeStream(object tree);
    public BufferedTreeNodeStream(ITreeAdaptor adaptor, object tree);
    public BufferedTreeNodeStream(ITreeAdaptor adaptor, object tree, int initialBufferSize);
    public virtual int get_Count();
    public virtual object get_TreeSource();
    public virtual string get_SourceName();
    public virtual ITokenStream get_TokenStream();
    public virtual void set_TokenStream(ITokenStream value);
    public virtual ITreeAdaptor get_TreeAdaptor();
    public virtual void set_TreeAdaptor(ITreeAdaptor value);
    public virtual bool get_UniqueNavigationNodes();
    public virtual void set_UniqueNavigationNodes(bool value);
    public virtual IToken get_LastToken();
    public virtual IToken get_LastRealToken();
    public virtual int get_MaxLookBehind();
    protected virtual void FillBuffer();
    public virtual void FillBuffer(object t);
    protected virtual int GetNodeIndex(object node);
    protected virtual void AddNavigationNode(int ttype);
    public virtual object get_Item(int i);
    public virtual object LT(int k);
    public virtual object GetCurrentSymbol();
    protected virtual object LB(int k);
    public virtual void Consume();
    public virtual int LA(int i);
    public virtual int Mark();
    public virtual void Release(int marker);
    public virtual int get_Index();
    public virtual void Rewind(int marker);
    public virtual void Rewind();
    public virtual void Seek(int index);
    public virtual void Push(int index);
    public virtual int Pop();
    public virtual void Reset();
    public virtual IEnumerator`1<object> Iterator();
    public virtual void ReplaceChildren(object parent, int startChildIndex, int stopChildIndex, object t);
    public virtual string ToTokenTypeString();
    public virtual string ToTokenString(int start, int stop);
    public virtual string ToString(object start, object stop);
}
public class Antlr.Runtime.Tree.CommonErrorNode : CommonTree {
    public IIntStream input;
    public IToken start;
    public IToken stop;
    public RecognitionException trappedException;
    public bool IsNil { get; }
    public string Text { get; public set; }
    public int Type { get; public set; }
    public CommonErrorNode(ITokenStream input, IToken start, IToken stop, RecognitionException e);
    public virtual bool get_IsNil();
    public virtual string get_Text();
    public virtual void set_Text(string value);
    public virtual int get_Type();
    public virtual void set_Type(int value);
    public virtual string ToString();
}
public class Antlr.Runtime.Tree.CommonTree : BaseTree {
    private IToken _token;
    protected int startIndex;
    protected int stopIndex;
    private CommonTree parent;
    private int childIndex;
    public int CharPositionInLine { get; public set; }
    public int ChildIndex { get; public set; }
    public bool IsNil { get; }
    public int Line { get; public set; }
    public ITree Parent { get; public set; }
    public string Text { get; public set; }
    public IToken Token { get; public set; }
    public int TokenStartIndex { get; public set; }
    public int TokenStopIndex { get; public set; }
    public int Type { get; public set; }
    public CommonTree(CommonTree node);
    public CommonTree(IToken t);
    public virtual int get_CharPositionInLine();
    public virtual void set_CharPositionInLine(int value);
    public virtual int get_ChildIndex();
    public virtual void set_ChildIndex(int value);
    public virtual bool get_IsNil();
    public virtual int get_Line();
    public virtual void set_Line(int value);
    public virtual ITree get_Parent();
    public virtual void set_Parent(ITree value);
    public virtual string get_Text();
    public virtual void set_Text(string value);
    public IToken get_Token();
    public void set_Token(IToken value);
    public virtual int get_TokenStartIndex();
    public virtual void set_TokenStartIndex(int value);
    public virtual int get_TokenStopIndex();
    public virtual void set_TokenStopIndex(int value);
    public virtual int get_Type();
    public virtual void set_Type(int value);
    public virtual ITree DupNode();
    public virtual void SetUnknownTokenBoundaries();
    public virtual string ToString();
}
public class Antlr.Runtime.Tree.CommonTreeAdaptor : BaseTreeAdaptor {
    public virtual object Create(IToken payload);
    public virtual IToken CreateToken(int tokenType, string text);
    public virtual IToken CreateToken(IToken fromToken);
    public virtual IToken GetToken(object t);
}
public class Antlr.Runtime.Tree.CommonTreeNodeStream : LookaheadStream`1<object> {
    public static int DEFAULT_INITIAL_BUFFER_SIZE;
    public static int INITIAL_CALL_STACK_SIZE;
    private object _root;
    protected ITokenStream tokens;
    private ITreeAdaptor _adaptor;
    private TreeIterator _it;
    private Stack`1<int> _calls;
    private bool _hasNilRoot;
    private int _level;
    private object _previousLocationElement;
    public string SourceName { get; }
    public ITokenStream TokenStream { get; public set; }
    public ITreeAdaptor TreeAdaptor { get; public set; }
    public object TreeSource { get; }
    public bool UniqueNavigationNodes { get; public set; }
    public CommonTreeNodeStream(object tree);
    public CommonTreeNodeStream(ITreeAdaptor adaptor, object tree);
    public virtual string get_SourceName();
    public virtual ITokenStream get_TokenStream();
    public virtual void set_TokenStream(ITokenStream value);
    public virtual ITreeAdaptor get_TreeAdaptor();
    public virtual void set_TreeAdaptor(ITreeAdaptor value);
    public virtual object get_TreeSource();
    public virtual bool get_UniqueNavigationNodes();
    public virtual void set_UniqueNavigationNodes(bool value);
    public virtual void Reset();
    public virtual object NextElement();
    public virtual object Dequeue();
    public virtual bool IsEndOfFile(object o);
    public virtual int LA(int i);
    public virtual void Push(int index);
    public virtual int Pop();
    public sealed virtual object GetKnownPositionElement(bool allowApproximateLocation);
    public sealed virtual bool HasPositionInformation(object node);
    public virtual void ReplaceChildren(object parent, int startChildIndex, int stopChildIndex, object t);
    public virtual string ToString(object start, object stop);
    public virtual string ToTokenTypeString();
}
public class Antlr.Runtime.Tree.DotTreeGenerator : object {
    private String[] HeaderLines;
    private static string Footer;
    private static string NodeFormat;
    private static string EdgeFormat;
    private Dictionary`2<object, int> nodeToNumberMap;
    private int nodeNumber;
    public virtual string ToDot(object tree, ITreeAdaptor adaptor);
    public virtual string ToDot(ITree tree);
    protected virtual IEnumerable`1<string> DefineNodes(object tree, ITreeAdaptor adaptor);
    protected virtual IEnumerable`1<string> DefineEdges(object tree, ITreeAdaptor adaptor);
    protected virtual string GetNodeText(ITreeAdaptor adaptor, object t);
    protected virtual int GetNodeNumber(object t);
    protected virtual string FixString(string text);
}
public interface Antlr.Runtime.Tree.IPositionTrackingStream {
    public abstract virtual object GetKnownPositionElement(bool allowApproximateLocation);
    public abstract virtual bool HasPositionInformation(object element);
}
public interface Antlr.Runtime.Tree.ITree {
    public int ChildCount { get; }
    public ITree Parent { get; public set; }
    public int ChildIndex { get; public set; }
    public bool IsNil { get; }
    public int TokenStartIndex { get; public set; }
    public int TokenStopIndex { get; public set; }
    public int Type { get; }
    public string Text { get; }
    public int Line { get; }
    public int CharPositionInLine { get; }
    public abstract virtual ITree GetChild(int i);
    public abstract virtual int get_ChildCount();
    public abstract virtual ITree get_Parent();
    public abstract virtual void set_Parent(ITree value);
    public abstract virtual bool HasAncestor(int ttype);
    public abstract virtual ITree GetAncestor(int ttype);
    public abstract virtual IList`1<ITree> GetAncestors();
    public abstract virtual int get_ChildIndex();
    public abstract virtual void set_ChildIndex(int value);
    public abstract virtual void FreshenParentAndChildIndexes();
    public abstract virtual void AddChild(ITree t);
    public abstract virtual void SetChild(int i, ITree t);
    public abstract virtual object DeleteChild(int i);
    public abstract virtual void ReplaceChildren(int startChildIndex, int stopChildIndex, object t);
    public abstract virtual bool get_IsNil();
    public abstract virtual int get_TokenStartIndex();
    public abstract virtual void set_TokenStartIndex(int value);
    public abstract virtual int get_TokenStopIndex();
    public abstract virtual void set_TokenStopIndex(int value);
    public abstract virtual ITree DupNode();
    public abstract virtual int get_Type();
    public abstract virtual string get_Text();
    public abstract virtual int get_Line();
    public abstract virtual int get_CharPositionInLine();
    public abstract virtual string ToStringTree();
    public abstract virtual string ToString();
}
public interface Antlr.Runtime.Tree.ITreeAdaptor {
    public abstract virtual object Create(IToken payload);
    public abstract virtual object Create(int tokenType, IToken fromToken);
    public abstract virtual object Create(int tokenType, IToken fromToken, string text);
    public abstract virtual object Create(IToken fromToken, string text);
    public abstract virtual object Create(int tokenType, string text);
    public abstract virtual object DupNode(object treeNode);
    public abstract virtual object DupNode(int type, object treeNode);
    public abstract virtual object DupNode(object treeNode, string text);
    public abstract virtual object DupNode(int type, object treeNode, string text);
    public abstract virtual object DupTree(object tree);
    public abstract virtual object Nil();
    public abstract virtual object ErrorNode(ITokenStream input, IToken start, IToken stop, RecognitionException e);
    public abstract virtual bool IsNil(object tree);
    public abstract virtual void AddChild(object t, object child);
    public abstract virtual object BecomeRoot(object newRoot, object oldRoot);
    public abstract virtual object RulePostProcessing(object root);
    public abstract virtual int GetUniqueID(object node);
    public abstract virtual object BecomeRoot(IToken newRoot, object oldRoot);
    public abstract virtual int GetType(object t);
    public abstract virtual void SetType(object t, int type);
    public abstract virtual string GetText(object t);
    public abstract virtual void SetText(object t, string text);
    public abstract virtual IToken GetToken(object t);
    public abstract virtual void SetTokenBoundaries(object t, IToken startToken, IToken stopToken);
    public abstract virtual int GetTokenStartIndex(object t);
    public abstract virtual int GetTokenStopIndex(object t);
    public abstract virtual object GetChild(object t, int i);
    public abstract virtual void SetChild(object t, int i, object child);
    public abstract virtual object DeleteChild(object t, int i);
    public abstract virtual int GetChildCount(object t);
    public abstract virtual object GetParent(object t);
    public abstract virtual void SetParent(object t, object parent);
    public abstract virtual int GetChildIndex(object t);
    public abstract virtual void SetChildIndex(object t, int index);
    public abstract virtual void ReplaceChildren(object parent, int startChildIndex, int stopChildIndex, object t);
}
[DefaultMemberAttribute("Item")]
public interface Antlr.Runtime.Tree.ITreeNodeStream {
    public object Item { get; }
    public object TreeSource { get; }
    public ITokenStream TokenStream { get; }
    public ITreeAdaptor TreeAdaptor { get; }
    public bool UniqueNavigationNodes { get; public set; }
    public abstract virtual object get_Item(int i);
    public abstract virtual object LT(int k);
    public abstract virtual object get_TreeSource();
    public abstract virtual ITokenStream get_TokenStream();
    public abstract virtual ITreeAdaptor get_TreeAdaptor();
    public abstract virtual bool get_UniqueNavigationNodes();
    public abstract virtual void set_UniqueNavigationNodes(bool value);
    public abstract virtual string ToString(object start, object stop);
    public abstract virtual void ReplaceChildren(object parent, int startChildIndex, int stopChildIndex, object t);
}
public interface Antlr.Runtime.Tree.ITreeVisitorAction {
    public abstract virtual object Pre(object t);
    public abstract virtual object Post(object t);
}
public class Antlr.Runtime.Tree.ParseTree : BaseTree {
    public object payload;
    public List`1<IToken> hiddenTokens;
    public string Text { get; public set; }
    public int TokenStartIndex { get; public set; }
    public int TokenStopIndex { get; public set; }
    public int Type { get; public set; }
    public ParseTree(object label);
    public virtual string get_Text();
    public virtual void set_Text(string value);
    public virtual int get_TokenStartIndex();
    public virtual void set_TokenStartIndex(int value);
    public virtual int get_TokenStopIndex();
    public virtual void set_TokenStopIndex(int value);
    public virtual int get_Type();
    public virtual void set_Type(int value);
    public virtual ITree DupNode();
    public virtual string ToString();
    public virtual string ToStringWithHiddenTokens();
    public virtual string ToInputString();
    protected virtual void ToStringLeaves(StringBuilder buf);
}
public class Antlr.Runtime.Tree.RewriteCardinalityException : Exception {
    private string _elementDescription;
    public RewriteCardinalityException(string elementDescription);
    public RewriteCardinalityException(string elementDescription, Exception innerException);
    public RewriteCardinalityException(string message, string elementDescription);
    public RewriteCardinalityException(string message, string elementDescription, Exception innerException);
    protected RewriteCardinalityException(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class Antlr.Runtime.Tree.RewriteEarlyExitException : RewriteCardinalityException {
    public RewriteEarlyExitException(string elementDescription);
    public RewriteEarlyExitException(string elementDescription, Exception innerException);
    public RewriteEarlyExitException(string message, string elementDescription);
    public RewriteEarlyExitException(string message, string elementDescription, Exception innerException);
    protected RewriteEarlyExitException(SerializationInfo info, StreamingContext context);
}
public class Antlr.Runtime.Tree.RewriteEmptyStreamException : RewriteCardinalityException {
    public RewriteEmptyStreamException(string elementDescription);
    public RewriteEmptyStreamException(string elementDescription, Exception innerException);
    public RewriteEmptyStreamException(string message, string elementDescription);
    public RewriteEmptyStreamException(string message, string elementDescription, Exception innerException);
    protected RewriteEmptyStreamException(SerializationInfo info, StreamingContext context);
}
public abstract class Antlr.Runtime.Tree.RewriteRuleElementStream : object {
    protected int cursor;
    protected object singleElement;
    protected IList elements;
    protected bool dirty;
    protected string elementDescription;
    protected ITreeAdaptor adaptor;
    public bool HasNext { get; }
    public int Count { get; }
    public string Description { get; }
    public RewriteRuleElementStream(ITreeAdaptor adaptor, string elementDescription);
    public RewriteRuleElementStream(ITreeAdaptor adaptor, string elementDescription, object oneElement);
    public RewriteRuleElementStream(ITreeAdaptor adaptor, string elementDescription, IList elements);
    public virtual void Reset();
    public virtual void Add(object el);
    public virtual object NextTree();
    protected virtual object NextCore();
    protected abstract virtual object Dup(object el);
    protected virtual object ToTree(object el);
    public virtual bool get_HasNext();
    public virtual int get_Count();
    public virtual string get_Description();
}
public class Antlr.Runtime.Tree.RewriteRuleNodeStream : RewriteRuleElementStream {
    public RewriteRuleNodeStream(ITreeAdaptor adaptor, string elementDescription);
    public RewriteRuleNodeStream(ITreeAdaptor adaptor, string elementDescription, object oneElement);
    public RewriteRuleNodeStream(ITreeAdaptor adaptor, string elementDescription, IList elements);
    public virtual object NextNode();
    protected virtual object ToTree(object el);
    protected virtual object Dup(object el);
}
public class Antlr.Runtime.Tree.RewriteRuleSubtreeStream : RewriteRuleElementStream {
    public RewriteRuleSubtreeStream(ITreeAdaptor adaptor, string elementDescription);
    public RewriteRuleSubtreeStream(ITreeAdaptor adaptor, string elementDescription, object oneElement);
    public RewriteRuleSubtreeStream(ITreeAdaptor adaptor, string elementDescription, IList elements);
    public virtual object NextNode();
    protected virtual object Dup(object el);
}
public class Antlr.Runtime.Tree.RewriteRuleTokenStream : RewriteRuleElementStream {
    public RewriteRuleTokenStream(ITreeAdaptor adaptor, string elementDescription);
    public RewriteRuleTokenStream(ITreeAdaptor adaptor, string elementDescription, object oneElement);
    public RewriteRuleTokenStream(ITreeAdaptor adaptor, string elementDescription, IList elements);
    public virtual object NextNode();
    public virtual IToken NextToken();
    protected virtual object ToTree(object el);
    protected virtual object Dup(object el);
}
public class Antlr.Runtime.Tree.TemplateTreeRuleReturnScope`2 : TreeRuleReturnScope`1<TTree> {
    private TTemplate _template;
    public TTemplate Template { get; public set; }
    private object Antlr.Runtime.ITemplateRuleReturnScope.Template { get; }
    public sealed virtual TTemplate get_Template();
    public void set_Template(TTemplate value);
    private sealed virtual override object Antlr.Runtime.ITemplateRuleReturnScope.get_Template();
}
public class Antlr.Runtime.Tree.TreeFilter : TreeParser {
    protected ITokenStream originalTokenStream;
    protected ITreeAdaptor originalAdaptor;
    public TreeFilter(ITreeNodeStream input);
    public TreeFilter(ITreeNodeStream input, RecognizerSharedState state);
    public virtual void ApplyOnce(object t, Action whichRule);
    public virtual void Downup(object t);
    protected virtual void Topdown();
    protected virtual void Bottomup();
    [CompilerGeneratedAttribute]
private object <Downup>b__5_0(object o);
    [CompilerGeneratedAttribute]
private object <Downup>b__5_1(object o);
}
public class Antlr.Runtime.Tree.TreeIterator : object {
    protected ITreeAdaptor adaptor;
    protected object root;
    protected object tree;
    protected bool firstTime;
    private bool reachedEof;
    public object up;
    public object down;
    public object eof;
    protected Queue`1<object> nodes;
    [CompilerGeneratedAttribute]
private object <Current>k__BackingField;
    public object Current { get; private set; }
    public TreeIterator(CommonTree tree);
    public TreeIterator(ITreeAdaptor adaptor, object tree);
    [CompilerGeneratedAttribute]
public sealed virtual object get_Current();
    [CompilerGeneratedAttribute]
private void set_Current(object value);
    public sealed virtual void Dispose();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
public class Antlr.Runtime.Tree.TreeParser : BaseRecognizer {
    public static int DOWN;
    public static int UP;
    private static string dotdot;
    private static string doubleEtc;
    private static Regex dotdotPattern;
    private static Regex doubleEtcPattern;
    protected ITreeNodeStream input;
    public string SourceName { get; }
    public TreeParser(ITreeNodeStream input);
    public TreeParser(ITreeNodeStream input, RecognizerSharedState state);
    private static TreeParser();
    public virtual void Reset();
    public virtual void SetTreeNodeStream(ITreeNodeStream input);
    public virtual ITreeNodeStream GetTreeNodeStream();
    public virtual string get_SourceName();
    protected virtual object GetCurrentInputSymbol(IIntStream input);
    protected virtual object GetMissingSymbol(IIntStream input, RecognitionException e, int expectedTokenType, BitSet follow);
    public virtual void MatchAny(IIntStream ignore);
    protected virtual object RecoverFromMismatchedToken(IIntStream input, int ttype, BitSet follow);
    public virtual string GetErrorHeader(RecognitionException e);
    public virtual string GetErrorMessage(RecognitionException e, String[] tokenNames);
    [ConditionalAttribute("ANTLR_TRACE")]
public virtual void TraceIn(string ruleName, int ruleIndex);
    [ConditionalAttribute("ANTLR_TRACE")]
public virtual void TraceOut(string ruleName, int ruleIndex);
}
public class Antlr.Runtime.Tree.TreePatternLexer : object {
    public static int Begin;
    public static int End;
    public static int Id;
    public static int Arg;
    public static int Percent;
    public static int Colon;
    public static int Dot;
    protected string pattern;
    protected int p;
    protected int c;
    protected int n;
    public StringBuilder sval;
    public bool error;
    public TreePatternLexer(string pattern);
    public virtual int NextToken();
    protected virtual void Consume();
}
public class Antlr.Runtime.Tree.TreePatternParser : object {
    protected TreePatternLexer tokenizer;
    protected int ttype;
    protected TreeWizard wizard;
    protected ITreeAdaptor adaptor;
    public TreePatternParser(TreePatternLexer tokenizer, TreeWizard wizard, ITreeAdaptor adaptor);
    public virtual object Pattern();
    public virtual object ParseTree();
    public virtual object ParseNode();
}
public class Antlr.Runtime.Tree.TreeRewriter : TreeParser {
    protected bool showTransformations;
    protected ITokenStream originalTokenStream;
    protected ITreeAdaptor originalAdaptor;
    private Func`1<IAstRuleReturnScope> topdown_func;
    private Func`1<IAstRuleReturnScope> bottomup_func;
    public TreeRewriter(ITreeNodeStream input);
    public TreeRewriter(ITreeNodeStream input, RecognizerSharedState state);
    public virtual object ApplyOnce(object t, Func`1<IAstRuleReturnScope> whichRule);
    public virtual object ApplyRepeatedly(object t, Func`1<IAstRuleReturnScope> whichRule);
    public virtual object Downup(object t);
    public virtual object Downup(object t, bool showTransformations);
    protected virtual IAstRuleReturnScope Topdown();
    protected virtual IAstRuleReturnScope Bottomup();
    protected virtual void ReportTransformation(object oldTree, object newTree);
    [CompilerGeneratedAttribute]
private IAstRuleReturnScope <.ctor>b__6_0();
    [CompilerGeneratedAttribute]
private IAstRuleReturnScope <.ctor>b__6_1();
    [CompilerGeneratedAttribute]
private object <Downup>b__10_0(object o);
    [CompilerGeneratedAttribute]
private object <Downup>b__10_1(object o);
}
public class Antlr.Runtime.Tree.TreeRuleReturnScope`1 : object {
    private TTree _start;
    public TTree Start { get; public set; }
    private object Antlr.Runtime.IRuleReturnScope.Start { get; }
    private TTree Antlr.Runtime.IRuleReturnScope<TTree>.Stop { get; }
    private object Antlr.Runtime.IRuleReturnScope.Stop { get; }
    public sealed virtual TTree get_Start();
    public void set_Start(TTree value);
    private sealed virtual override object Antlr.Runtime.IRuleReturnScope.get_Start();
    private sealed virtual override TTree Antlr.Runtime.IRuleReturnScope<TTree>.get_Stop();
    private sealed virtual override object Antlr.Runtime.IRuleReturnScope.get_Stop();
}
public class Antlr.Runtime.Tree.TreeVisitor : object {
    protected ITreeAdaptor adaptor;
    public TreeVisitor(ITreeAdaptor adaptor);
    public object Visit(object t, ITreeVisitorAction action);
    public object Visit(object t, Func`2<object, object> preAction, Func`2<object, object> postAction);
}
public class Antlr.Runtime.Tree.TreeVisitorAction : object {
    private Func`2<object, object> _preAction;
    private Func`2<object, object> _postAction;
    public TreeVisitorAction(Func`2<object, object> preAction, Func`2<object, object> postAction);
    public sealed virtual object Pre(object t);
    public sealed virtual object Post(object t);
}
public class Antlr.Runtime.Tree.TreeWizard : object {
    protected ITreeAdaptor adaptor;
    protected IDictionary`2<string, int> tokenNameToTypeMap;
    public TreeWizard(ITreeAdaptor adaptor);
    public TreeWizard(ITreeAdaptor adaptor, IDictionary`2<string, int> tokenNameToTypeMap);
    public TreeWizard(ITreeAdaptor adaptor, String[] tokenNames);
    public TreeWizard(String[] tokenNames);
    public virtual IDictionary`2<string, int> ComputeTokenTypes(String[] tokenNames);
    public virtual int GetTokenType(string tokenName);
    public IDictionary`2<int, IList> Index(object t);
    protected virtual void IndexCore(object t, IDictionary`2<int, IList> m);
    public virtual IList Find(object t, int ttype);
    public virtual IList Find(object t, string pattern);
    public virtual object FindFirst(object t, int ttype);
    public virtual object FindFirst(object t, string pattern);
    public void Visit(object t, int ttype, IContextVisitor visitor);
    public void Visit(object t, int ttype, Action`1<object> action);
    protected virtual void VisitCore(object t, object parent, int childIndex, int ttype, IContextVisitor visitor);
    public void Visit(object t, string pattern, IContextVisitor visitor);
    public bool Parse(object t, string pattern, IDictionary`2<string, object> labels);
    public bool Parse(object t, string pattern);
    protected virtual bool ParseCore(object t1, TreePattern tpattern, IDictionary`2<string, object> labels);
    public virtual object Create(string pattern);
    public static bool Equals(object t1, object t2, ITreeAdaptor adaptor);
    public bool Equals(object t1, object t2);
    protected static bool EqualsCore(object t1, object t2, ITreeAdaptor adaptor);
}
public class Antlr.Runtime.UnbufferedTokenStream : LookaheadStream`1<IToken> {
    [CLSCompliantAttribute("False")]
protected ITokenSource tokenSource;
    protected int tokenIndex;
    protected int channel;
    private ListStack`1<IToken> _realTokens;
    public ITokenSource TokenSource { get; }
    public string SourceName { get; }
    public IToken LastToken { get; }
    public IToken LastRealToken { get; }
    public int MaxLookBehind { get; }
    public UnbufferedTokenStream(ITokenSource tokenSource);
    public sealed virtual ITokenSource get_TokenSource();
    public sealed virtual string get_SourceName();
    public sealed virtual IToken get_LastToken();
    public sealed virtual IToken get_LastRealToken();
    public sealed virtual int get_MaxLookBehind();
    public virtual int Mark();
    public virtual void Release(int marker);
    public virtual void Clear();
    public virtual void Consume();
    public virtual IToken NextElement();
    public virtual bool IsEndOfFile(IToken o);
    public sealed virtual IToken Get(int i);
    public sealed virtual int LA(int i);
    public sealed virtual string ToString(int start, int stop);
    public sealed virtual string ToString(IToken start, IToken stop);
}
public class Antlr.Runtime.UnwantedTokenException : MismatchedTokenException {
    public IToken UnexpectedToken { get; }
    public UnwantedTokenException(string message);
    public UnwantedTokenException(string message, Exception innerException);
    public UnwantedTokenException(int expecting, IIntStream input);
    public UnwantedTokenException(int expecting, IIntStream input, IList`1<string> tokenNames);
    public UnwantedTokenException(string message, int expecting, IIntStream input, IList`1<string> tokenNames);
    public UnwantedTokenException(string message, int expecting, IIntStream input, IList`1<string> tokenNames, Exception innerException);
    protected UnwantedTokenException(SerializationInfo info, StreamingContext context);
    public virtual IToken get_UnexpectedToken();
    public virtual string ToString();
}
