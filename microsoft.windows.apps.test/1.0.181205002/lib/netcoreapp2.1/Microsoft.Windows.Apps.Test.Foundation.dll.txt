internal class Microsoft.Windows.Apps.Test.Foundation.AbsoluteWaitInputAction : object {
    public int duration;
    public sealed virtual void Execute(IRIMPointerInput rim, int elapsedMs);
}
public class Microsoft.Windows.Apps.Test.Foundation.ActionEvent : MulticastDelegate {
    public ActionEvent(object object, IntPtr method);
    public virtual void Invoke(UIObject sender, ActionEventArgs actionInfo);
    public virtual IAsyncResult BeginInvoke(UIObject sender, ActionEventArgs actionInfo, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.Windows.Apps.Test.Foundation.ActionEventArgs : EventArgs {
    private string action;
    private List`1<object> parameters;
    private static ConcurrentDictionary`2<string, ActionEventArgs> defaults;
    public string ActionString { get; }
    public IList`1<object> Parameters { get; }
    public ActionEventArgs(string action, Object[] args);
    private static ActionEventArgs();
    public string get_ActionString();
    public IList`1<object> get_Parameters();
    public static ActionEventArgs GetDefault(string action);
}
public class Microsoft.Windows.Apps.Test.Foundation.ActionException : Exception {
    public ActionException(string message);
    public ActionException(string message, Exception innerException);
}
public static class Microsoft.Windows.Apps.Test.Foundation.ActionHandler : object {
    private static bool _halted;
    private static object _lock;
    private static Dictionary`2<string, ActionSet> _registeredEvents;
    private static ActionEvent _prefixEvents;
    private static bool _activeAction;
    private static bool _activePrefix;
    public static ICollection`1<string> RegisteredActions { get; }
    private static ActionHandler();
    private static void InvokeList(ActionEvent handler, UIObject sender, ActionEventArgs args);
    private static void RemoveAction(string action);
    public static void Halt();
    public static void Subscribe(string action, ActionEvent handler);
    public static void Subscribe(string action, ActionEvent handler, bool addToEnd);
    public static void Remove(string action, ActionEvent handler);
    public static void SubscribeToAll(ActionEvent handler);
    public static void SubscribeToAll(ActionEvent handler, bool addToEnd);
    public static void RemoveFromAll(ActionEvent handler);
    public static ActionOverrideEvent SubscribeForOverride(string action, ActionOverrideEvent replacement);
    public static ActionOverrideEvent SubscribeForOverride(string action, ActionOverrideEvent replacement, bool executeOverrideLast);
    public static ActionOverrideEvent RemoveFromOverride(string action);
    public static ActionResult Invoke(UIObject sender, ActionEventArgs actionInfo);
    public static ActionResult Invoke(UIObject sender, ActionEventArgs actionInfo, Object& overridden);
    public static ActionEvent GetHandler(string action);
    public static ActionOverrideEvent GetOverride(string action);
    public static ICollection`1<string> get_RegisteredActions();
}
public class Microsoft.Windows.Apps.Test.Foundation.ActionOverrideEvent : MulticastDelegate {
    public ActionOverrideEvent(object object, IntPtr method);
    public virtual ActionResult Invoke(UIObject sender, ActionEventArgs actionInfo, Object& overridden);
    public virtual IAsyncResult BeginInvoke(UIObject sender, ActionEventArgs actionInfo, Object& overridden, AsyncCallback callback, object object);
    public virtual ActionResult EndInvoke(Object& overridden, IAsyncResult result);
}
public enum Microsoft.Windows.Apps.Test.Foundation.ActionResult : Enum {
    public int value__;
    public static ActionResult Handled;
    public static ActionResult Unhandled;
    public static ActionResult Proceed;
}
public static class Microsoft.Windows.Apps.Test.Foundation.ActionStrings : object {
    public static string AcceleratorKey;
    public static string AccessKey;
    public static string AddToSelection;
    public static string AutomationId;
    public static string BoundingRectangle;
    public static string CanMaximize;
    public static string CanMinimize;
    public static string CanMove;
    public static string CanResize;
    public static string CanRotate;
    public static string CanSelectMultiple;
    public static string Check;
    public static string ClassName;
    public static string Click;
    public static string ClickDrag;
    public static string Close;
    public static string Collapse;
    public static string Column;
    public static string ColumnHeaders;
    public static string ColumnHeaderItems;
    public static string ColumnSpan;
    public static string ColumnCount;
    public static string ContainingGrid;
    public static string ControlType;
    public static string Culture;
    public static string CurrentView;
    public static string DockPosition;
    public static string DocumentRange;
    public static string DoubleClick;
    public static string DoubleTap;
    public static string Expand;
    public static string ExpandCollapseState;
    public static string Flick;
    public static string Focused;
    public static string FrameworkId;
    public static string FromHandle;
    public static string FromPoint;
    public static string GetCaretRange;
    public static string GetCell;
    public static string GetClickablePoint;
    public static string GetImage;
    public static string GetSelection;
    public static string GetSupportedViews;
    public static string GetUnderlyingObjectModel;
    public static string GetViewName;
    public static string GetVisibleRange;
    public static string HasKeyboardFocus;
    public static string HelpText;
    public static string Highlight;
    public static string HorizontallyScrollable;
    public static string HorizontalScrollPercent;
    public static string HorizontalViewSize;
    public static string Index;
    public static string Invoke;
    public static string IsAvailable;
    public static string IsContentElement;
    public static string IsControlElement;
    public static string IsEnabled;
    public static string IsItemContainerPatternAvailable;
    public static string IsKeyboardFocusable;
    public static string IsModal;
    public static string IsOffscreen;
    public static string IsPassword;
    public static string IsReadOnly;
    public static string IsRequiredForForm;
    public static string IsSelected;
    public static string IsSelectionRequired;
    public static string IsSelectionPatternAvailable;
    public static string IsSelectionItemPatternAvailable;
    public static string ItemStatus;
    public static string ItemType;
    public static string IsTopmost;
    public static string IsVirtualizedItemPatternAvailable;
    public static string LabeledBy;
    public static string LargeChange;
    public static string LocalizedControlType;
    public static string MakeVisible;
    public static string Maximum;
    public static string Minimum;
    public static string Move;
    public static string Name;
    public static string NativeWindowHandle;
    public static string Orientation;
    public static string Pan;
    public static string PinchStretch;
    public static string ProcessId;
    public static string RangeFromAnnotation;
    public static string RangeFromChild;
    public static string RangeFromPoint;
    public static string RangeIsReadOnly;
    public static string RangeSetValue;
    public static string RangeValue;
    public static string RemoveFromSelection;
    public static string Resize;
    public static string Root;
    public static string Rotate;
    public static string Row;
    public static string RowHeaders;
    public static string RowHeaderItems;
    public static string RowSpan;
    public static string RowCount;
    public static string RowOrColumnMajor;
    public static string RuntimeId;
    public static string SaveImage;
    public static string Scroll;
    public static string ScrollHorizontal;
    public static string ScrollIntoView;
    public static string ScrollVertical;
    public static string Select;
    public static string Selection;
    public static string SelectionContainer;
    public static string SendKeys;
    public static string SetCurrentView;
    public static string SetDockPosition;
    public static string SetFocus;
    public static string SetScrollPercent;
    public static string SetValue;
    public static string SetWindowVisualState;
    public static string SmallChange;
    public static string SupportsTextSelection;
    public static string Tap;
    public static string TapAndHold;
    public static string Toggle;
    public static string ToggleState;
    public static string ToString;
    public static string UIObjectConstructing;
    public static string Uncheck;
    public static string Value;
    public static string VerticallyScrollable;
    public static string VerticalScrollPercent;
    public static string VerticalViewSize;
    public static string WaitForInputIdle;
    public static string WaitForReady;
    public static string WindowInteractionState;
    public static string WindowVisualState;
    public static string UIScrollComplete;
}
internal class Microsoft.Windows.Apps.Test.Foundation.Collections.AncestorsNavigator : UINavigator {
    private AutomationElement _root;
    private TreeWalker _treeWalker;
    public AncestorsNavigator(UIObject root, UICondition treeCondition);
    public AncestorsNavigator(AutomationElement root, UICondition treeCondition);
    public AncestorsNavigator(AncestorsNavigator previous);
    private void Initialize(AutomationElement root, TreeWalker treeWalker);
    public virtual UINavigator Duplicate();
    [IteratorStateMachineAttribute("Microsoft.Windows.Apps.Test.Foundation.Collections.AncestorsNavigator/<GetEnumerator>d__5")]
public virtual IEnumerator`1<AutomationElement> GetEnumerator();
    public virtual string ToString();
}
internal class Microsoft.Windows.Apps.Test.Foundation.Collections.AutomationElementTreeNavigator : object {
    private TreeWalker _treeWalker;
    public AutomationElementTreeNavigator(TreeWalker treeWalker);
    public sealed virtual AutomationElement GetNextSibling(AutomationElement current);
    public sealed virtual AutomationElement GetFirstChild(AutomationElement current);
}
internal class Microsoft.Windows.Apps.Test.Foundation.Collections.BreadthFirstDescendantsNavigator : UINavigator {
    private BreadthFirstTreeEnumerator`1<AutomationElement> _treeEnumerator;
    public BreadthFirstDescendantsNavigator(UIObject root, UICondition treeCondition);
    public BreadthFirstDescendantsNavigator(AutomationElement root, UICondition treeCondition);
    public BreadthFirstDescendantsNavigator(BreadthFirstDescendantsNavigator previous);
    private void Initialize(AutomationElement root, UICondition treeCondition);
    protected virtual override void Finalize();
    public virtual UINavigator Duplicate();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    [IteratorStateMachineAttribute("Microsoft.Windows.Apps.Test.Foundation.Collections.BreadthFirstDescendantsNavigator/<GetEnumerator>d__8")]
public virtual IEnumerator`1<AutomationElement> GetEnumerator();
    public virtual string ToString();
}
internal class Microsoft.Windows.Apps.Test.Foundation.Collections.ChildrenNavigator : UINavigator {
    private AutomationElement _root;
    private TreeWalker _treeWalker;
    public ChildrenNavigator(UIObject root, UICondition treeCondition);
    public ChildrenNavigator(AutomationElement root, UICondition treeCondition);
    public ChildrenNavigator(ChildrenNavigator previous);
    private void Initialize(AutomationElement root, UICondition treeCondition);
    public virtual UINavigator Duplicate();
    [IteratorStateMachineAttribute("Microsoft.Windows.Apps.Test.Foundation.Collections.ChildrenNavigator/<GetEnumerator>d__5")]
public virtual IEnumerator`1<AutomationElement> GetEnumerator();
    public virtual string ToString();
}
internal class Microsoft.Windows.Apps.Test.Foundation.Collections.DelegateFilter : object {
    private Predicate`1<UIObject> _callback;
    public DelegateFilter(Predicate`1<UIObject> callback);
    public sealed virtual bool Matches(AutomationElement item);
    public virtual string ToString();
}
internal class Microsoft.Windows.Apps.Test.Foundation.Collections.DepthFirstDescendantsNavigator : UINavigator {
    private DepthFirstTreeEnumerator`1<AutomationElement> _treeEnumerator;
    public DepthFirstDescendantsNavigator(UIObject root, UICondition treeCondition);
    public DepthFirstDescendantsNavigator(AutomationElement root, UICondition treeCondition);
    public DepthFirstDescendantsNavigator(DepthFirstDescendantsNavigator previous);
    private void Initialize(AutomationElement root, UICondition treeCondition);
    protected virtual override void Finalize();
    public virtual UINavigator Duplicate();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    [IteratorStateMachineAttribute("Microsoft.Windows.Apps.Test.Foundation.Collections.DepthFirstDescendantsNavigator/<GetEnumerator>d__8")]
public virtual IEnumerator`1<AutomationElement> GetEnumerator();
    public virtual string ToString();
}
internal class Microsoft.Windows.Apps.Test.Foundation.Collections.DescendantsNavigator : UINavigator {
    private AutomationElement _root;
    private UICondition _treeCondition;
    public DescendantsNavigator(UIObject root, UICondition treeCondition);
    public DescendantsNavigator(AutomationElement root, UICondition treeCondition);
    public DescendantsNavigator(DescendantsNavigator previous);
    private void Initialize(AutomationElement root, UICondition treeCondition);
    public virtual UINavigator Duplicate();
    [IteratorStateMachineAttribute("Microsoft.Windows.Apps.Test.Foundation.Collections.DescendantsNavigator/<GetEnumerator>d__5")]
public virtual IEnumerator`1<AutomationElement> GetEnumerator();
    public virtual string ToString();
}
internal class Microsoft.Windows.Apps.Test.Foundation.Collections.EnumerableNavigator : UINavigator {
    private IEnumerable _enumerable;
    public EnumerableNavigator(IEnumerable enumerable);
    public EnumerableNavigator(EnumerableNavigator previous);
    public virtual UINavigator Duplicate();
    [IteratorStateMachineAttribute("Microsoft.Windows.Apps.Test.Foundation.Collections.EnumerableNavigator/<GetEnumerator>d__3")]
public virtual IEnumerator`1<AutomationElement> GetEnumerator();
    public virtual string ToString();
}
internal class Microsoft.Windows.Apps.Test.Foundation.Collections.FilterConverter : object {
    private IFilter`1<UIObject> _uiObjectFilter;
    public FilterConverter(IFilter`1<UIObject> uiObjectFilter);
    public sealed virtual bool Matches(AutomationElement item);
}
internal class Microsoft.Windows.Apps.Test.Foundation.Collections.ItemContainerChildrenNavigator : UINavigator {
    private AutomationElement _root;
    private TreeWalker _treeWalker;
    private bool _autoRealize;
    public ItemContainerChildrenNavigator(UIObject root, UICondition treeCondition);
    public ItemContainerChildrenNavigator(AutomationElement root, UICondition treeCondition);
    public ItemContainerChildrenNavigator(ItemContainerChildrenNavigator previous);
    private void Initialize(AutomationElement root, UICondition treeCondition);
    public virtual UINavigator Duplicate();
    [IteratorStateMachineAttribute("Microsoft.Windows.Apps.Test.Foundation.Collections.ItemContainerChildrenNavigator/<GetEnumerator>d__5")]
public virtual IEnumerator`1<AutomationElement> GetEnumerator();
    public virtual string ToString();
    private PropertyCondition GetPropertyConditionFromFilter();
    private static void Realize(UIObject uiObject);
}
internal class Microsoft.Windows.Apps.Test.Foundation.Collections.PatternPresentFilter : object {
    private AutomationPattern _pattern;
    public PatternPresentFilter(AutomationPattern pattern);
    public sealed virtual bool Matches(AutomationElement item);
    public virtual string ToString();
}
internal class Microsoft.Windows.Apps.Test.Foundation.Collections.RegexFilter : object {
    private UIProperty _property;
    private Regex _regularExpression;
    public RegexFilter(UIProperty property, string regularExpression);
    public RegexFilter(UIProperty property, Regex regularExpression);
    public sealed virtual bool Matches(AutomationElement item);
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Windows.Apps.Test.Foundation.Collections.RetryingNavigator : UINavigator {
    private UINavigator _containedNavigator;
    private TimeSpan _timeout;
    private int _retryCount;
    public AutomationElement Item { get; }
    public UIObjectFilter Filter { get; }
    public UINavigator ContainedNavigator { get; }
    public RetryingNavigator(UINavigator navigator, TimeSpan timeout, int retryCount);
    public RetryingNavigator(RetryingNavigator previous);
    public virtual UINavigator Duplicate();
    [IteratorStateMachineAttribute("Microsoft.Windows.Apps.Test.Foundation.Collections.RetryingNavigator/<GetEnumerator>d__3")]
public virtual IEnumerator`1<AutomationElement> GetEnumerator();
    public virtual AutomationElement get_Item(int index);
    public virtual UIObjectFilter get_Filter();
    public UINavigator get_ContainedNavigator();
    public virtual string ToString();
}
internal class Microsoft.Windows.Apps.Test.Foundation.Collections.SiblingsNavigator : UINavigator {
    private AutomationElement _root;
    private TreeWalker _treeWalker;
    public SiblingsNavigator(UIObject root, UICondition treeCondition);
    public SiblingsNavigator(AutomationElement root, UICondition treeCondition);
    public SiblingsNavigator(SiblingsNavigator previous);
    private void Initialize(AutomationElement root, UICondition treeCondition);
    public virtual UINavigator Duplicate();
    [IteratorStateMachineAttribute("Microsoft.Windows.Apps.Test.Foundation.Collections.SiblingsNavigator/<GetEnumerator>d__5")]
public virtual IEnumerator`1<AutomationElement> GetEnumerator();
    public virtual string ToString();
}
internal class Microsoft.Windows.Apps.Test.Foundation.Collections.StaticListNavigator : UINavigator {
    private List`1<AutomationElement> _elementList;
    public StaticListNavigator(IEnumerable`1<AutomationElement> enumerable);
    public StaticListNavigator(AutomationElement[] elementArray);
    public StaticListNavigator(StaticListNavigator previous);
    public virtual UINavigator Duplicate();
    [IteratorStateMachineAttribute("Microsoft.Windows.Apps.Test.Foundation.Collections.StaticListNavigator/<GetEnumerator>d__4")]
public virtual IEnumerator`1<AutomationElement> GetEnumerator();
    public virtual string ToString();
}
public class Microsoft.Windows.Apps.Test.Foundation.Collections.UIAncestors`1 : UICollection`1<I> {
    public UIAncestors`1(UIObject root, IFactory`1<I> factory);
    internal UIAncestors`1(AutomationElement root, IFactory`1<I> factory);
    public UIAncestors`1(UIObject root, UICondition treeCondition, IFactory`1<I> factory);
    internal UIAncestors`1(AutomationElement root, UICondition treeCondition, IFactory`1<I> factory);
}
public class Microsoft.Windows.Apps.Test.Foundation.Collections.UIBreadthFirstDescendants`1 : UICollection`1<T> {
    public UIBreadthFirstDescendants`1(UIObject root, IFactory`1<T> factory);
    internal UIBreadthFirstDescendants`1(AutomationElement root, IFactory`1<T> factory);
    public UIBreadthFirstDescendants`1(UIObject root, UICondition treeCondition, IFactory`1<T> factory);
    internal UIBreadthFirstDescendants`1(AutomationElement root, UICondition treeCondition, IFactory`1<T> factory);
}
public class Microsoft.Windows.Apps.Test.Foundation.Collections.UIChildren`1 : UICollection`1<I> {
    public UIChildren`1(UIObject root, IFactory`1<I> factory);
    internal UIChildren`1(AutomationElement root, IFactory`1<I> factory);
    public UIChildren`1(UIObject root, UICondition treeCondition, IFactory`1<I> factory);
    internal UIChildren`1(AutomationElement root, UICondition treeCondition, IFactory`1<I> factory);
}
public class Microsoft.Windows.Apps.Test.Foundation.Collections.UIDepthFirstDescendants`1 : UICollection`1<T> {
    public UIDepthFirstDescendants`1(UIObject root, IFactory`1<T> factory);
    internal UIDepthFirstDescendants`1(AutomationElement root, IFactory`1<T> factory);
    public UIDepthFirstDescendants`1(UIObject root, UICondition treeCondition, IFactory`1<T> factory);
    internal UIDepthFirstDescendants`1(AutomationElement root, UICondition treeCondition, IFactory`1<T> factory);
}
public class Microsoft.Windows.Apps.Test.Foundation.Collections.UIDescendants`1 : UICollection`1<I> {
    public UIDescendants`1(UIObject root, IFactory`1<I> factory);
    internal UIDescendants`1(AutomationElement root, IFactory`1<I> factory);
    public UIDescendants`1(UIObject root, UICondition treeCondition, IFactory`1<I> factory);
    internal UIDescendants`1(AutomationElement root, UICondition treeCondition, IFactory`1<I> factory);
}
public class Microsoft.Windows.Apps.Test.Foundation.Collections.UIItemContainerChildren`1 : UICollection`1<I> {
    public UIItemContainerChildren`1(UIObject root, IFactory`1<I> factory);
    internal UIItemContainerChildren`1(AutomationElement root, IFactory`1<I> factory);
    public UIItemContainerChildren`1(UIObject root, UICondition treeCondition, IFactory`1<I> factory);
    internal UIItemContainerChildren`1(AutomationElement root, UICondition treeCondition, IFactory`1<I> factory);
}
public class Microsoft.Windows.Apps.Test.Foundation.Collections.UIObjectFilter : object {
    private UICondition _condition;
    private List`1<IFilter`1<AutomationElement>> _filters;
    public UICondition UICondition { get; }
    public UIObjectFilter(UIObjectFilter previous);
    internal bool Matches(AutomationElement element);
    internal bool MatchesFilter(AutomationElement element);
    public void Add(UICondition condition);
    public void Add(UIProperty property, Regex regularExpression);
    public void Add(Predicate`1<UIObject> filter);
    internal void Add(IFilter`1<AutomationElement> filter);
    public virtual string ToString();
    public UICondition get_UICondition();
}
public class Microsoft.Windows.Apps.Test.Foundation.Collections.UISiblings`1 : UICollection`1<T> {
    public UISiblings`1(UIObject root, IFactory`1<T> factory);
    internal UISiblings`1(AutomationElement root, IFactory`1<T> factory);
    public UISiblings`1(UIObject root, UICondition treeCondition, IFactory`1<T> factory);
    internal UISiblings`1(AutomationElement root, UICondition treeCondition, IFactory`1<T> factory);
}
public class Microsoft.Windows.Apps.Test.Foundation.CompositeInputControllerMartyr : object {
    private Stack`1<IDisposable> _inputControllerMartyrStack;
    private PointerInputType _previousInputType;
    private bool _disposed;
    public CompositeInputControllerMartyr(PointerInputType previousInputType);
    public void Add(IDisposable martyr);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public class Microsoft.Windows.Apps.Test.Foundation.Context : object {
    private bool _activated;
    private UICondition _treeCondition;
    [ThreadStaticAttribute]
private static Stack`1<Context> _stack;
    private static Context _rawContext;
    private static Context _contentContext;
    private static Context _controlContext;
    private static Context _defaultContext;
    public bool IsActivated { get; public set; }
    public UICondition TreeCondition { get; }
    public static Context Current { get; }
    public static Context RawContext { get; }
    public static Context ContentContext { get; }
    public static Context ControlContext { get; }
    internal static Stack`1<Context> Stack { get; }
    public Context(UICondition treeCondition);
    private static Context();
    public IDisposable Activate();
    public bool get_IsActivated();
    public void set_IsActivated(bool value);
    public UICondition get_TreeCondition();
    public static Context get_Current();
    public static Context get_RawContext();
    public static Context get_ContentContext();
    public static Context get_ControlContext();
    internal static Stack`1<Context> get_Stack();
}
internal class Microsoft.Windows.Apps.Test.Foundation.ContextMartyr : object {
    private Context currentContext;
    public ContextMartyr(Context currentContext);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public class Microsoft.Windows.Apps.Test.Foundation.Controls.Button : UIObject {
    private IInvoke _invokePattern;
    private static IFactory`1<Button> _factory;
    public static IFactory`1<Button> Factory { get; }
    public Button(UIObject uiObject);
    internal Button(AutomationElement element);
    private static Button();
    private void Initialize();
    public virtual void Invoke();
    public sealed virtual UIEventWaiter GetInvokedWaiter();
    public static IFactory`1<Button> get_Factory();
}
public abstract class Microsoft.Windows.Apps.Test.Foundation.Controls.Calendar`1 : UIObject {
    private IGrid`1<I> _gridPattern;
    private ISelection`1<I> _selectionPattern;
    private IValue _valuePattern;
    public UICollection`1<I> Selection { get; }
    public bool CanSelectMultiple { get; }
    public bool IsSelectionRequired { get; }
    public int RowCount { get; }
    public int ColumnCount { get; }
    public string Value { get; }
    public bool IsReadOnly { get; }
    protected IValue ValueProvider { get; protected set; }
    protected IGrid`1<I> GridProvider { get; protected set; }
    protected ISelection`1<I> SelectionProvider { get; protected set; }
    protected Calendar`1(UIObject uiObject, IFactory`1<I> itemFactory);
    internal Calendar`1(AutomationElement element, IFactory`1<I> itemFactory);
    private void Initialize(IFactory`1<I> itemFactory);
    public virtual UICollection`1<I> get_Selection();
    public virtual bool get_CanSelectMultiple();
    public virtual bool get_IsSelectionRequired();
    public virtual I GetCell(int row, int column);
    public virtual int get_RowCount();
    public virtual int get_ColumnCount();
    public virtual void SetValue(string value);
    public virtual string get_Value();
    public virtual bool get_IsReadOnly();
    protected IValue get_ValueProvider();
    protected void set_ValueProvider(IValue value);
    protected IGrid`1<I> get_GridProvider();
    protected void set_GridProvider(IGrid`1<I> value);
    protected ISelection`1<I> get_SelectionProvider();
    protected void set_SelectionProvider(ISelection`1<I> value);
}
public class Microsoft.Windows.Apps.Test.Foundation.Controls.CheckBox : UIObject {
    private IToggle _togglePattern;
    private static IFactory`1<CheckBox> _factory;
    public ToggleState ToggleState { get; }
    public static IFactory`1<CheckBox> Factory { get; }
    public CheckBox(UIObject uiObject);
    internal CheckBox(AutomationElement element);
    private static CheckBox();
    private void Initialize();
    public sealed virtual UIEventWaiter GetToggledWaiter();
    public virtual void Toggle();
    public virtual ToggleState get_ToggleState();
    public void Check();
    public void Uncheck();
    public static IFactory`1<CheckBox> get_Factory();
    private bool SetToggleState(ToggleState toggleState);
}
public class Microsoft.Windows.Apps.Test.Foundation.Controls.CheckMenuItem : UIObject {
    private IToggle _togglePattern;
    private static IFactory`1<CheckMenuItem> _factory;
    public ToggleState ToggleState { get; }
    public static IFactory`1<CheckMenuItem> Factory { get; }
    public CheckMenuItem(UIObject uiObject);
    internal CheckMenuItem(AutomationElement element);
    private static CheckMenuItem();
    private void Initialize();
    public sealed virtual UIEventWaiter GetToggledWaiter();
    public virtual void Toggle();
    public virtual ToggleState get_ToggleState();
    public static IFactory`1<CheckMenuItem> get_Factory();
}
public class Microsoft.Windows.Apps.Test.Foundation.Controls.ComboBox : ComboBox`2<ComboBox, ComboBoxItem> {
    private static IFactory`1<ComboBox> _factory;
    public static IFactory`1<ComboBox> Factory { get; }
    public ComboBox(UIObject uiObject);
    internal ComboBox(AutomationElement element);
    private static ComboBox();
    public static IFactory`1<ComboBox> get_Factory();
}
public abstract class Microsoft.Windows.Apps.Test.Foundation.Controls.ComboBox`2 : UIObject {
    private IExpandCollapse _expandCollapsePattern;
    private ISelection`1<I> _selectionPattern;
    private IValue _valuePattern;
    private IFactory`1<I> _itemFactory;
    private static UICondition _treeCondition;
    public UICollection`1<I> Items { get; }
    public ExpandCollapseState ExpandCollapseState { get; }
    public UICollection`1<I> Selection { get; }
    public bool CanSelectMultiple { get; }
    public bool IsSelectionRequired { get; }
    public UICollection`1<I> AllItems { get; }
    public string Value { get; }
    public bool IsReadOnly { get; }
    protected static UICondition TreeCondition { get; }
    protected IFactory`1<I> ItemFactory { get; protected set; }
    protected IExpandCollapse ExpandCollapseProvider { get; protected set; }
    protected ISelection`1<I> SelectionProvider { get; protected set; }
    private IValue ValueProvider { get; private set; }
    protected ComboBox`2(UIObject uiObject, IFactory`1<I> itemFactory);
    internal ComboBox`2(AutomationElement element, IFactory`1<I> itemFactory);
    private static ComboBox`2();
    private void Initialize(IFactory`1<I> itemFactory);
    public virtual UICollection`1<I> get_Items();
    public virtual void Collapse();
    public virtual void Expand();
    public virtual ExpandCollapseState get_ExpandCollapseState();
    public sealed virtual UIEventWaiter GetCollapsedWaiter();
    public sealed virtual UIEventWaiter GetExpandedWaiter();
    public virtual UICollection`1<I> get_Selection();
    public virtual bool get_CanSelectMultiple();
    public virtual bool get_IsSelectionRequired();
    public sealed virtual UICollection`1<I> get_AllItems();
    public virtual void SetValue(string value);
    public virtual string get_Value();
    public virtual bool get_IsReadOnly();
    protected static UICondition get_TreeCondition();
    protected IFactory`1<I> get_ItemFactory();
    protected void set_ItemFactory(IFactory`1<I> value);
    protected IExpandCollapse get_ExpandCollapseProvider();
    protected void set_ExpandCollapseProvider(IExpandCollapse value);
    protected ISelection`1<I> get_SelectionProvider();
    protected void set_SelectionProvider(ISelection`1<I> value);
    private IValue get_ValueProvider();
    private void set_ValueProvider(IValue value);
}
public class Microsoft.Windows.Apps.Test.Foundation.Controls.ComboBoxItem : ListItem`1<ComboBox> {
    private static IFactory`1<ComboBoxItem> _factory;
    public static IFactory`1<ComboBoxItem> Factory { get; }
    public ComboBoxItem(UIObject uiObject);
    internal ComboBoxItem(AutomationElement element);
    private static ComboBoxItem();
    public static IFactory`1<ComboBoxItem> get_Factory();
}
public class Microsoft.Windows.Apps.Test.Foundation.Controls.Edit : UIObject {
    private IText _textPattern;
    private IValue _valuePattern;
    private static IFactory`1<Edit> _factory;
    public bool SupportsTextSelection { get; }
    public TextPatternRange DocumentRange { get; }
    public string Value { get; }
    public bool IsReadOnly { get; }
    public static IFactory`1<Edit> Factory { get; }
    public Edit(UIObject uiObject);
    internal Edit(AutomationElement element);
    private static Edit();
    private void Initialize();
    public virtual bool get_SupportsTextSelection();
    public virtual TextPatternRange get_DocumentRange();
    public virtual TextPatternRange GetSelection();
    public virtual TextPatternRange RangeFromPoint(Point screenLocation);
    public virtual TextPatternRange RangeFromChild(UIObject childElement);
    public virtual TextPatternRange GetVisibleRange();
    public virtual void SetValue(string value);
    public virtual string get_Value();
    public sealed virtual bool get_IsReadOnly();
    public static IFactory`1<Edit> get_Factory();
}
public class Microsoft.Windows.Apps.Test.Foundation.Controls.Hyperlink : UIObject {
    private IInvoke _invokePattern;
    private static IFactory`1<Hyperlink> _factory;
    public static IFactory`1<Hyperlink> Factory { get; }
    public Hyperlink(UIObject uiObject);
    internal Hyperlink(AutomationElement element);
    private static Hyperlink();
    private void Initialize();
    public virtual void Invoke();
    public sealed virtual UIEventWaiter GetInvokedWaiter();
    public static IFactory`1<Hyperlink> get_Factory();
}
public class Microsoft.Windows.Apps.Test.Foundation.Controls.Image : UIObject {
    private static IFactory`1<Image> _factory;
    public static IFactory`1<Image> Factory { get; }
    public Image(UIObject uiObject);
    internal Image(AutomationElement element);
    private static Image();
    public static IFactory`1<Image> get_Factory();
}
public class Microsoft.Windows.Apps.Test.Foundation.Controls.ItemsView : ItemsView`2<ItemsView, ItemsViewItem> {
    private static IFactory`1<ItemsView> _factory;
    public static IFactory`1<ItemsView> Factory { get; }
    public ItemsView(UIObject uiObject);
    internal ItemsView(AutomationElement element);
    public static IFactory`1<ItemsView> get_Factory();
}
public abstract class Microsoft.Windows.Apps.Test.Foundation.Controls.ItemsView`2 : UIObject {
    private IMultipleView _multipleViewPattern;
    private IItemContainer _itemContainerPattern;
    private ISelection`1<I> _selectionPattern;
    private ITable`1<I> _tablePattern;
    private IFactory`1<I> _itemFactory;
    private static UICondition _treeCondition;
    public UICollection`1<I> Items { get; }
    public UICollection`1<I> AllItems { get; }
    public int CurrentView { get; }
    public UICollection`1<I> Selection { get; }
    public bool CanSelectMultiple { get; }
    public bool IsSelectionRequired { get; }
    public int RowCount { get; }
    public int ColumnCount { get; }
    public UICollection`1<UIObject> RowHeaders { get; }
    public UICollection`1<UIObject> ColumnHeaders { get; }
    public RowOrColumnMajor RowOrColumnMajor { get; }
    protected IMultipleView MultipleViewProvider { get; protected set; }
    protected IItemContainer ItemContainerProvider { get; protected set; }
    protected ITable`1<I> TableProvider { get; protected set; }
    protected IFactory`1<I> ItemFactory { get; protected set; }
    protected ISelection`1<I> SelectionProvider { get; protected set; }
    protected static UICondition TreeCondition { get; }
    protected ItemsView`2(UIObject uiObject, IFactory`1<I> itemFactory);
    internal ItemsView`2(AutomationElement element, IFactory`1<I> itemFactory);
    private static ItemsView`2();
    private void Initialize(IFactory`1<I> itemFactory);
    public virtual UICollection`1<I> get_Items();
    public virtual UICollection`1<I> get_AllItems();
    public virtual string GetViewName(int viewId);
    public virtual void SetCurrentView(int viewId);
    public virtual Int32[] GetSupportedViews();
    public virtual int get_CurrentView();
    public sealed virtual UIObject FindItemByProperty(UIObject uiObject, UIProperty property, object value);
    public virtual UICollection`1<I> get_Selection();
    public virtual bool get_CanSelectMultiple();
    public virtual bool get_IsSelectionRequired();
    public virtual I GetCell(int row, int column);
    public virtual int get_RowCount();
    public virtual int get_ColumnCount();
    public virtual UICollection`1<UIObject> get_RowHeaders();
    public virtual UICollection`1<UIObject> get_ColumnHeaders();
    public virtual RowOrColumnMajor get_RowOrColumnMajor();
    protected IMultipleView get_MultipleViewProvider();
    protected void set_MultipleViewProvider(IMultipleView value);
    protected IItemContainer get_ItemContainerProvider();
    protected void set_ItemContainerProvider(IItemContainer value);
    protected ITable`1<I> get_TableProvider();
    protected void set_TableProvider(ITable`1<I> value);
    protected IFactory`1<I> get_ItemFactory();
    protected void set_ItemFactory(IFactory`1<I> value);
    protected ISelection`1<I> get_SelectionProvider();
    protected void set_SelectionProvider(ISelection`1<I> value);
    protected static UICondition get_TreeCondition();
}
public class Microsoft.Windows.Apps.Test.Foundation.Controls.ItemsViewItem : ItemsViewItem`1<ItemsView> {
    private static IFactory`1<ItemsViewItem> _factory;
    public static IFactory`1<ItemsViewItem> Factory { get; }
    public ItemsViewItem(UIObject uiObject);
    internal ItemsViewItem(AutomationElement element);
    private static ItemsViewItem();
    public static IFactory`1<ItemsViewItem> get_Factory();
}
public abstract class Microsoft.Windows.Apps.Test.Foundation.Controls.ItemsViewItem`1 : UIObject {
    private ISelectionItem`1<C> _selectionItemPattern;
    private IVirtualizedItem _virtualizedItemPattern;
    public bool IsSelected { get; }
    public C SelectionContainer { get; }
    protected ISelectionItem`1<C> SelectionItemProvider { get; protected set; }
    protected IVirtualizedItem VirtualizedItemProvider { get; protected set; }
    protected ItemsViewItem`1(UIObject uiObject, IFactory`1<C> containerFactory);
    internal ItemsViewItem`1(AutomationElement element, IFactory`1<C> containerFactory);
    private void Initialize(IFactory`1<C> containerFactory);
    public virtual void Select();
    public virtual void AddToSelection();
    public sealed virtual UIEventWaiter GetAddedToSelectionWaiter();
    public sealed virtual UIEventWaiter GetRemovedFromSelectionWaiter();
    public sealed virtual UIEventWaiter GetSelectedWaiter();
    public virtual void RemoveFromSelection();
    public virtual bool get_IsSelected();
    public virtual C get_SelectionContainer();
    public sealed virtual void Realize();
    protected ISelectionItem`1<C> get_SelectionItemProvider();
    protected void set_SelectionItemProvider(ISelectionItem`1<C> value);
    protected IVirtualizedItem get_VirtualizedItemProvider();
    protected void set_VirtualizedItemProvider(IVirtualizedItem value);
}
public class Microsoft.Windows.Apps.Test.Foundation.Controls.ListBox : ListBox`2<ListBox, ListBoxItem> {
    private static IFactory`1<ListBox> _factory;
    public static IFactory`1<ListBox> Factory { get; }
    public ListBox(UIObject uiObject);
    internal ListBox(AutomationElement element);
    private static ListBox();
    public static IFactory`1<ListBox> get_Factory();
}
public abstract class Microsoft.Windows.Apps.Test.Foundation.Controls.ListBox`2 : UIObject {
    private ISelection`1<I> _selectionPattern;
    private IFactory`1<I> _itemFactory;
    private IScroll _scrollPattern;
    private static UICondition _treeCondition;
    public UICollection`1<I> Items { get; }
    public UICollection`1<I> AllItems { get; }
    public UICollection`1<I> Selection { get; }
    public bool CanSelectMultiple { get; }
    public bool IsSelectionRequired { get; }
    public bool HorizontallyScrollable { get; }
    public bool VerticallyScrollable { get; }
    public double HorizontalScrollPercent { get; }
    public double VerticalScrollPercent { get; }
    public double HorizontalViewSize { get; }
    public double VerticalViewSize { get; }
    public bool IsSelectionPatternAvailable { get; }
    protected static UICondition TreeCondition { get; }
    protected ListBox`2(UIObject uiObject, IFactory`1<I> itemFactory);
    internal ListBox`2(AutomationElement element, IFactory`1<I> itemFactory);
    private static ListBox`2();
    private void Initialize(IFactory`1<I> itemFactory);
    public virtual UICollection`1<I> get_Items();
    public virtual UICollection`1<I> get_AllItems();
    public virtual UICollection`1<I> get_Selection();
    public virtual bool get_CanSelectMultiple();
    public virtual bool get_IsSelectionRequired();
    public virtual void Scroll(ScrollAmount horizontalAmount, ScrollAmount verticalAmount);
    public virtual void ScrollHorizontal(ScrollAmount amount);
    public virtual void ScrollVertical(ScrollAmount amount);
    public virtual void SetScrollPercent(double horizontalPercent, double verticalPercent);
    public virtual bool get_HorizontallyScrollable();
    public virtual bool get_VerticallyScrollable();
    public virtual double get_HorizontalScrollPercent();
    public virtual double get_VerticalScrollPercent();
    public virtual double get_HorizontalViewSize();
    public virtual double get_VerticalViewSize();
    public bool get_IsSelectionPatternAvailable();
    protected static UICondition get_TreeCondition();
}
public class Microsoft.Windows.Apps.Test.Foundation.Controls.ListBoxItem : ListItem`1<ListBox> {
    private static IFactory`1<ListBoxItem> _factory;
    public static IFactory`1<ListBoxItem> Factory { get; }
    public ListBoxItem(UIObject uiObject);
    internal ListBoxItem(AutomationElement element);
    private static ListBoxItem();
    public static IFactory`1<ListBoxItem> get_Factory();
}
public abstract class Microsoft.Windows.Apps.Test.Foundation.Controls.ListItem`1 : UIObject {
    private ISelectionItem`1<C> _selectionItemPattern;
    private IScrollItem _scrollItemPattern;
    private IVirtualizedItem _virtualizedItemPattern;
    public bool IsSelected { get; }
    public C SelectionContainer { get; }
    public bool IsSelectionItemPatternAvailable { get; }
    protected ISelectionItem`1<C> SelectionItemProvider { get; protected set; }
    protected IScrollItem ScrollItemProvider { get; protected set; }
    protected IVirtualizedItem VirtualizedItemProvider { get; protected set; }
    protected ListItem`1(UIObject uiObject, IFactory`1<C> containerFactory);
    internal ListItem`1(AutomationElement element, IFactory`1<C> containerFactory);
    private void Initialize(IFactory`1<C> containerFactory);
    public virtual void Select();
    public virtual void AddToSelection();
    public sealed virtual UIEventWaiter GetAddedToSelectionWaiter();
    public sealed virtual UIEventWaiter GetRemovedFromSelectionWaiter();
    public sealed virtual UIEventWaiter GetSelectedWaiter();
    public virtual void RemoveFromSelection();
    public virtual bool get_IsSelected();
    public virtual C get_SelectionContainer();
    public sealed virtual void ScrollIntoView();
    public sealed virtual void Realize();
    public bool get_IsSelectionItemPatternAvailable();
    protected ISelectionItem`1<C> get_SelectionItemProvider();
    protected void set_SelectionItemProvider(ISelectionItem`1<C> value);
    protected IScrollItem get_ScrollItemProvider();
    protected void set_ScrollItemProvider(IScrollItem value);
    protected IVirtualizedItem get_VirtualizedItemProvider();
    protected void set_VirtualizedItemProvider(IVirtualizedItem value);
}
public class Microsoft.Windows.Apps.Test.Foundation.Controls.ListView : ListView`2<ListView, ListViewItem> {
    private static IFactory`1<ListView> _factory;
    public static IFactory`1<ListView> Factory { get; }
    public ListView(UIObject uiObject);
    internal ListView(AutomationElement element);
    private static ListView();
    public static IFactory`1<ListView> get_Factory();
}
public abstract class Microsoft.Windows.Apps.Test.Foundation.Controls.ListView`2 : UIObject {
    private IMultipleView _multipleViewPattern;
    private ISelection`1<I> _selectionPattern;
    private ITable`1<I> _tablePattern;
    private IItemContainer _itemContainPattern;
    private IFactory`1<I> _itemFactory;
    private IScroll _scrollPattern;
    private static UICondition _treeCondition;
    public UICollection`1<I> Items { get; }
    public UICollection`1<I> AllItems { get; }
    public int CurrentView { get; }
    public bool IsSelectionPatternAvailable { get; }
    public UICollection`1<I> Selection { get; }
    public bool CanSelectMultiple { get; }
    public bool IsSelectionRequired { get; }
    public int RowCount { get; }
    public int ColumnCount { get; }
    public UICollection`1<UIObject> RowHeaders { get; }
    public UICollection`1<UIObject> ColumnHeaders { get; }
    public RowOrColumnMajor RowOrColumnMajor { get; }
    public bool HorizontallyScrollable { get; }
    public bool VerticallyScrollable { get; }
    public double HorizontalScrollPercent { get; }
    public double VerticalScrollPercent { get; }
    public double HorizontalViewSize { get; }
    public double VerticalViewSize { get; }
    protected static UICondition TreeCondition { get; }
    protected ListView`2(UIObject uiObject, IFactory`1<I> itemFactory);
    internal ListView`2(AutomationElement element, IFactory`1<I> itemFactory);
    private static ListView`2();
    private void Initialize(IFactory`1<I> itemFactory);
    public virtual UICollection`1<I> get_Items();
    public virtual UICollection`1<I> get_AllItems();
    public sealed virtual UIObject FindItemByProperty(UIObject uiObject, UIProperty uiProperty, object value);
    public virtual string GetViewName(int viewId);
    public virtual void SetCurrentView(int viewId);
    public virtual Int32[] GetSupportedViews();
    public virtual int get_CurrentView();
    public bool get_IsSelectionPatternAvailable();
    public virtual UICollection`1<I> get_Selection();
    public virtual bool get_CanSelectMultiple();
    public virtual bool get_IsSelectionRequired();
    public virtual I GetCell(int row, int column);
    public virtual int get_RowCount();
    public virtual int get_ColumnCount();
    public virtual UICollection`1<UIObject> get_RowHeaders();
    public virtual UICollection`1<UIObject> get_ColumnHeaders();
    public virtual RowOrColumnMajor get_RowOrColumnMajor();
    public virtual void Scroll(ScrollAmount horizontalAmount, ScrollAmount verticalAmount);
    public virtual void ScrollHorizontal(ScrollAmount amount);
    public virtual void ScrollVertical(ScrollAmount amount);
    public virtual void SetScrollPercent(double horizontalPercent, double verticalPercent);
    public virtual bool get_HorizontallyScrollable();
    public virtual bool get_VerticallyScrollable();
    public virtual double get_HorizontalScrollPercent();
    public virtual double get_VerticalScrollPercent();
    public virtual double get_HorizontalViewSize();
    public virtual double get_VerticalViewSize();
    protected static UICondition get_TreeCondition();
}
public class Microsoft.Windows.Apps.Test.Foundation.Controls.ListViewItem : ListItem`1<ListView> {
    private static IFactory`1<ListViewItem> _factory;
    public static IFactory`1<ListViewItem> Factory { get; }
    public ListViewItem(UIObject uiObject);
    internal ListViewItem(AutomationElement element);
    private static ListViewItem();
    public static IFactory`1<ListViewItem> get_Factory();
}
public class Microsoft.Windows.Apps.Test.Foundation.Controls.Menu : UIObject {
    private static IFactory`1<Menu> _factory;
    public static IFactory`1<Menu> Factory { get; }
    public Menu(UIObject uiObject);
    internal Menu(AutomationElement element);
    private static Menu();
    public static IFactory`1<Menu> get_Factory();
}
public class Microsoft.Windows.Apps.Test.Foundation.Controls.MenuBar : UIObject {
    private static IFactory`1<MenuBar> _factory;
    private static UICondition _treeCondition;
    public UICollection`1<SubmenuItem> Items { get; }
    public static IFactory`1<MenuBar> Factory { get; }
    public MenuBar(UIObject uiObject);
    internal MenuBar(AutomationElement element);
    private static MenuBar();
    public sealed virtual UICollection`1<SubmenuItem> get_Items();
    public static IFactory`1<MenuBar> get_Factory();
}
public class Microsoft.Windows.Apps.Test.Foundation.Controls.MenuItem : UIObject {
    private static IFactory`1<MenuItem> _factory;
    private IInvoke _invokePattern;
    public static IFactory`1<MenuItem> Factory { get; }
    public MenuItem(UIObject uiObject);
    internal MenuItem(AutomationElement element);
    private static MenuItem();
    private void Initialize();
    public virtual void Invoke();
    public sealed virtual UIEventWaiter GetInvokedWaiter();
    public static IFactory`1<MenuItem> get_Factory();
}
public class Microsoft.Windows.Apps.Test.Foundation.Controls.NavigationView : UIObject {
    private UIObject rootElement;
    private ListView navList;
    private static string _paneID;
    private static string _listID;
    private static Lazy`1<IFactory`1<NavigationView>> _factory;
    public ListViewItem SelectedItem { get; }
    public static IFactory`1<NavigationView> Factory { get; }
    public NavigationView(UIObject coreWindow);
    private static NavigationView();
    public ListViewItem GetItemByName(string name);
    public virtual ListViewItem get_SelectedItem();
    public static IFactory`1<NavigationView> get_Factory();
}
public class Microsoft.Windows.Apps.Test.Foundation.Controls.ProgressBar : UIObject {
    private IValue _valuePattern;
    private static IFactory`1<ProgressBar> _factory;
    public string Value { get; }
    public bool IsReadOnly { get; }
    public static IFactory`1<ProgressBar> Factory { get; }
    public ProgressBar(UIObject uiObject);
    internal ProgressBar(AutomationElement element);
    private static ProgressBar();
    private void Initialize();
    public virtual void SetValue(string value);
    public virtual string get_Value();
    public virtual bool get_IsReadOnly();
    public static IFactory`1<ProgressBar> get_Factory();
}
public class Microsoft.Windows.Apps.Test.Foundation.Controls.RadioButton : UIObject {
    private ISelectionItem`1<UIObject> _selectionItemPattern;
    private static IFactory`1<RadioButton> _factory;
    public bool IsSelected { get; }
    public UIObject SelectionContainer { get; }
    public static IFactory`1<RadioButton> Factory { get; }
    public RadioButton(UIObject uiObject);
    internal RadioButton(AutomationElement element);
    private static RadioButton();
    private void Initialize();
    public virtual void Select();
    public virtual void AddToSelection();
    public sealed virtual UIEventWaiter GetAddedToSelectionWaiter();
    public sealed virtual UIEventWaiter GetRemovedFromSelectionWaiter();
    public sealed virtual UIEventWaiter GetSelectedWaiter();
    public virtual void RemoveFromSelection();
    public virtual bool get_IsSelected();
    public virtual UIObject get_SelectionContainer();
    public static IFactory`1<RadioButton> get_Factory();
}
public class Microsoft.Windows.Apps.Test.Foundation.Controls.RangeValueSlider : UIObject {
    private IRangeValue _rangeValuePattern;
    private static IFactory`1<RangeValueSlider> _factory;
    public double Value { get; }
    public bool IsReadOnly { get; }
    public double Minimum { get; }
    public double Maximum { get; }
    public double LargeChange { get; }
    public double SmallChange { get; }
    public static IFactory`1<RangeValueSlider> Factory { get; }
    public RangeValueSlider(UIObject uiObject);
    internal RangeValueSlider(AutomationElement element);
    private static RangeValueSlider();
    private void Initialize();
    public virtual void SetValue(double value);
    public virtual double get_Value();
    public virtual bool get_IsReadOnly();
    public virtual double get_Minimum();
    public virtual double get_Maximum();
    public virtual double get_LargeChange();
    public virtual double get_SmallChange();
    public static IFactory`1<RangeValueSlider> get_Factory();
}
public class Microsoft.Windows.Apps.Test.Foundation.Controls.RangeValueSpinner : UIObject {
    private IRangeValue _rangeValuePattern;
    private static IFactory`1<RangeValueSpinner> _factory;
    public double Value { get; }
    public bool IsReadOnly { get; }
    public double Minimum { get; }
    public double Maximum { get; }
    public double LargeChange { get; }
    public double SmallChange { get; }
    public static IFactory`1<RangeValueSpinner> Factory { get; }
    public RangeValueSpinner(UIObject uiObject);
    internal RangeValueSpinner(AutomationElement element);
    private static RangeValueSpinner();
    private void Initialize();
    public virtual void SetValue(double value);
    public virtual double get_Value();
    public virtual bool get_IsReadOnly();
    public virtual double get_Minimum();
    public virtual double get_Maximum();
    public virtual double get_LargeChange();
    public virtual double get_SmallChange();
    public static IFactory`1<RangeValueSpinner> get_Factory();
}
public class Microsoft.Windows.Apps.Test.Foundation.Controls.RatingControl : UIObject {
    private IRangeValue _rangeValuePattern;
    private static IFactory`1<RatingControl> _factory;
    public double Value { get; }
    public bool IsReadOnly { get; }
    public double Minimum { get; }
    public double Maximum { get; }
    public double LargeChange { get; }
    public double SmallChange { get; }
    public static IFactory`1<RatingControl> Factory { get; }
    public RatingControl(UIObject uiObject);
    internal RatingControl(AutomationElement element);
    private static RatingControl();
    private void Initialize();
    public virtual void SetValue(double value);
    public virtual double get_Value();
    public virtual bool get_IsReadOnly();
    public virtual double get_Minimum();
    public virtual double get_Maximum();
    public virtual double get_LargeChange();
    public virtual double get_SmallChange();
    public static IFactory`1<RatingControl> get_Factory();
}
public class Microsoft.Windows.Apps.Test.Foundation.Controls.RichTextBlock : TextBlock {
    private static IFactory`1<RichTextBlock> _factory;
    public List`1<TextPatternRange> TextRegionsByFormat { get; }
    public List`1<TextPatternRange> TextRegionsByParagraph { get; }
    public List`1<TextPatternRange> TextRegionsByPage { get; }
    public static IFactory`1<RichTextBlock> Factory { get; }
    public RichTextBlock(UIObject uiObject);
    public RichTextBlock(AutomationElement element);
    private static RichTextBlock();
    public List`1<TextPatternRange> get_TextRegionsByFormat();
    public List`1<TextPatternRange> get_TextRegionsByParagraph();
    public List`1<TextPatternRange> get_TextRegionsByPage();
    public static IFactory`1<RichTextBlock> get_Factory();
}
public class Microsoft.Windows.Apps.Test.Foundation.Controls.ScrollBar : UIObject {
    private static IFactory`1<ScrollBar> _factory;
    private IRangeValue _rangeValuePattern;
    public double Value { get; }
    public bool IsReadOnly { get; }
    public double Minimum { get; }
    public double Maximum { get; }
    public double LargeChange { get; }
    public double SmallChange { get; }
    public static IFactory`1<ScrollBar> Factory { get; }
    protected IRangeValue RangeValueProvider { get; protected set; }
    public ScrollBar(UIObject uiObject);
    internal ScrollBar(AutomationElement element);
    private static ScrollBar();
    private void Initialize();
    public virtual void SetValue(double value);
    public virtual double get_Value();
    public virtual bool get_IsReadOnly();
    public virtual double get_Minimum();
    public virtual double get_Maximum();
    public virtual double get_LargeChange();
    public virtual double get_SmallChange();
    public static IFactory`1<ScrollBar> get_Factory();
    protected IRangeValue get_RangeValueProvider();
    protected void set_RangeValueProvider(IRangeValue value);
}
public class Microsoft.Windows.Apps.Test.Foundation.Controls.SelectionSlider : UIObject {
    private ISelection`1<SelectionSliderItem> _selectionPattern;
    private static IFactory`1<SelectionSlider> _factory;
    public UICollection`1<SelectionSliderItem> Items { get; }
    public UICollection`1<SelectionSliderItem> Selection { get; }
    public bool CanSelectMultiple { get; }
    public bool IsSelectionRequired { get; }
    public static IFactory`1<SelectionSlider> Factory { get; }
    public SelectionSlider(UIObject uiObject);
    internal SelectionSlider(AutomationElement element);
    private static SelectionSlider();
    private void Initialize();
    public sealed virtual UICollection`1<SelectionSliderItem> get_Items();
    public sealed virtual UICollection`1<SelectionSliderItem> get_Selection();
    public virtual bool get_CanSelectMultiple();
    public virtual bool get_IsSelectionRequired();
    public static IFactory`1<SelectionSlider> get_Factory();
}
public class Microsoft.Windows.Apps.Test.Foundation.Controls.SelectionSliderItem : ListItem`1<SelectionSlider> {
    private static IFactory`1<SelectionSliderItem> _factory;
    public static IFactory`1<SelectionSliderItem> Factory { get; }
    public SelectionSliderItem(UIObject uiObject);
    internal SelectionSliderItem(AutomationElement element);
    private static SelectionSliderItem();
    public static IFactory`1<SelectionSliderItem> get_Factory();
}
public class Microsoft.Windows.Apps.Test.Foundation.Controls.SelectionSpinner : UIObject {
    private ISelection`1<SelectionSpinnerItem> _selectionPattern;
    private static IFactory`1<SelectionSpinner> _factory;
    public UICollection`1<SelectionSpinnerItem> Items { get; }
    public UICollection`1<SelectionSpinnerItem> Selection { get; }
    public bool CanSelectMultiple { get; }
    public bool IsSelectionRequired { get; }
    public static IFactory`1<SelectionSpinner> Factory { get; }
    public SelectionSpinner(UIObject uiObject);
    internal SelectionSpinner(AutomationElement element);
    private static SelectionSpinner();
    private void Initialize();
    public sealed virtual UICollection`1<SelectionSpinnerItem> get_Items();
    public sealed virtual UICollection`1<SelectionSpinnerItem> get_Selection();
    public virtual bool get_CanSelectMultiple();
    public virtual bool get_IsSelectionRequired();
    public static IFactory`1<SelectionSpinner> get_Factory();
}
public class Microsoft.Windows.Apps.Test.Foundation.Controls.SelectionSpinnerItem : ListItem`1<SelectionSpinner> {
    private static IFactory`1<SelectionSpinnerItem> _factory;
    public static IFactory`1<SelectionSpinnerItem> Factory { get; }
    public SelectionSpinnerItem(UIObject uiObject);
    internal SelectionSpinnerItem(AutomationElement element);
    private static SelectionSpinnerItem();
    public static IFactory`1<SelectionSpinnerItem> get_Factory();
}
public class Microsoft.Windows.Apps.Test.Foundation.Controls.SplitButton : UIObject {
    private IExpandCollapse _expandCollapsePattern;
    private IInvoke _invokePattern;
    private static IFactory`1<SplitButton> _factory;
    public ExpandCollapseState ExpandCollapseState { get; }
    public static IFactory`1<SplitButton> Factory { get; }
    public SplitButton(UIObject uiObject);
    internal SplitButton(AutomationElement element);
    private static SplitButton();
    private void Initialize();
    public virtual void Collapse();
    public virtual void Expand();
    public virtual ExpandCollapseState get_ExpandCollapseState();
    public sealed virtual UIEventWaiter GetCollapsedWaiter();
    public sealed virtual UIEventWaiter GetExpandedWaiter();
    public virtual void Invoke();
    public sealed virtual UIEventWaiter GetInvokedWaiter();
    public static IFactory`1<SplitButton> get_Factory();
}
public class Microsoft.Windows.Apps.Test.Foundation.Controls.StatusBar : StatusBar`1<UIObject> {
    private static IFactory`1<StatusBar> _factory;
    public static IFactory`1<StatusBar> Factory { get; }
    public StatusBar(UIObject uiObject);
    internal StatusBar(AutomationElement element);
    private static StatusBar();
    public static IFactory`1<StatusBar> get_Factory();
}
public abstract class Microsoft.Windows.Apps.Test.Foundation.Controls.StatusBar`1 : UIObject {
    private IGrid`1<I> _gridPattern;
    public int RowCount { get; }
    public int ColumnCount { get; }
    protected IGrid`1<I> GridProvider { get; protected set; }
    protected StatusBar`1(UIObject uiObject, IFactory`1<I> itemFactory);
    internal StatusBar`1(AutomationElement element, IFactory`1<I> itemFactory);
    private void Initialize(IFactory`1<I> itemFactory);
    public virtual I GetCell(int row, int column);
    public virtual int get_RowCount();
    public virtual int get_ColumnCount();
    protected IGrid`1<I> get_GridProvider();
    protected void set_GridProvider(IGrid`1<I> value);
}
public class Microsoft.Windows.Apps.Test.Foundation.Controls.SubmenuItem : UIObject {
    private IExpandCollapse _expandCollapsePattern;
    private static IFactory`1<SubmenuItem> _factory;
    public ExpandCollapseState ExpandCollapseState { get; }
    public static IFactory`1<SubmenuItem> Factory { get; }
    public SubmenuItem(UIObject uiObject);
    internal SubmenuItem(AutomationElement element);
    private static SubmenuItem();
    private void Initialize();
    public virtual void Collapse();
    public virtual void Expand();
    public virtual ExpandCollapseState get_ExpandCollapseState();
    public sealed virtual UIEventWaiter GetCollapsedWaiter();
    public sealed virtual UIEventWaiter GetExpandedWaiter();
    public static IFactory`1<SubmenuItem> get_Factory();
}
public class Microsoft.Windows.Apps.Test.Foundation.Controls.Tab : Tab`2<Tab, TabItem> {
    private static IFactory`1<Tab> _factory;
    public static IFactory`1<Tab> Factory { get; }
    public Tab(UIObject uiObject);
    internal Tab(AutomationElement element);
    private static Tab();
    public static IFactory`1<Tab> get_Factory();
}
public abstract class Microsoft.Windows.Apps.Test.Foundation.Controls.Tab`2 : UIObject {
    private ISelection`1<I> _selectionPattern;
    private IFactory`1<I> _itemFactory;
    private static UICondition _treeCondition;
    public UICollection`1<I> Items { get; }
    public UICollection`1<I> Selection { get; }
    public bool CanSelectMultiple { get; }
    public bool IsSelectionRequired { get; }
    protected IFactory`1<I> ItemFactory { get; protected set; }
    protected ISelection`1<I> SelectionProvider { get; protected set; }
    protected static UICondition TreeCondition { get; }
    protected Tab`2(UIObject uiObject, IFactory`1<I> itemFactory);
    internal Tab`2(AutomationElement element, IFactory`1<I> itemFactory);
    private static Tab`2();
    private void Initialize(IFactory`1<I> itemFactory);
    public virtual UICollection`1<I> get_Items();
    public virtual UICollection`1<I> get_Selection();
    public virtual bool get_CanSelectMultiple();
    public virtual bool get_IsSelectionRequired();
    protected IFactory`1<I> get_ItemFactory();
    protected void set_ItemFactory(IFactory`1<I> value);
    protected ISelection`1<I> get_SelectionProvider();
    protected void set_SelectionProvider(ISelection`1<I> value);
    protected static UICondition get_TreeCondition();
}
public class Microsoft.Windows.Apps.Test.Foundation.Controls.TabItem : TabItem`1<Tab> {
    private static IFactory`1<TabItem> _factory;
    public static IFactory`1<TabItem> Factory { get; }
    public TabItem(UIObject uiObject);
    internal TabItem(AutomationElement element);
    private static TabItem();
    public static IFactory`1<TabItem> get_Factory();
}
public abstract class Microsoft.Windows.Apps.Test.Foundation.Controls.TabItem`1 : UIObject {
    private ISelectionItem`1<C> _selectionItemPattern;
    public bool IsSelected { get; }
    public C SelectionContainer { get; }
    protected ISelectionItem`1<C> SelectionItemProvider { get; protected set; }
    protected TabItem`1(UIObject uiObject, IFactory`1<C> containerFactory);
    internal TabItem`1(AutomationElement element, IFactory`1<C> containerFactory);
    private void Initialize(IFactory`1<C> containerFactory);
    public virtual void Select();
    public virtual void AddToSelection();
    public sealed virtual UIEventWaiter GetAddedToSelectionWaiter();
    public sealed virtual UIEventWaiter GetRemovedFromSelectionWaiter();
    public sealed virtual UIEventWaiter GetSelectedWaiter();
    public virtual void RemoveFromSelection();
    public virtual bool get_IsSelected();
    public virtual C get_SelectionContainer();
    protected ISelectionItem`1<C> get_SelectionItemProvider();
    protected void set_SelectionItemProvider(ISelectionItem`1<C> value);
}
public class Microsoft.Windows.Apps.Test.Foundation.Controls.TextBlock : UIObject {
    private static IFactory`1<TextBlock> _factory;
    private IText _textPattern;
    public string DocumentText { get; }
    public List`1<TextPatternRange> TextRegionsByWord { get; }
    public List`1<TextPatternRange> TextRegionsByLine { get; }
    public bool SupportsTextSelection { get; }
    public TextPatternRange DocumentRange { get; }
    public static IFactory`1<TextBlock> Factory { get; }
    public TextBlock(UIObject uiObject);
    public TextBlock(AutomationElement element);
    private static TextBlock();
    private void Initialize();
    public string get_DocumentText();
    public List`1<TextPatternRange> get_TextRegionsByWord();
    public List`1<TextPatternRange> get_TextRegionsByLine();
    protected List`1<TextPatternRange> GetTextPatternRanges(TextUnit textUnit);
    public virtual bool get_SupportsTextSelection();
    public virtual TextPatternRange get_DocumentRange();
    public virtual TextPatternRange GetSelection();
    public virtual TextPatternRange RangeFromPoint(Point screenLocation);
    public virtual TextPatternRange RangeFromChild(UIObject childElement);
    public virtual TextPatternRange GetVisibleRange();
    public static IFactory`1<TextBlock> get_Factory();
}
public class Microsoft.Windows.Apps.Test.Foundation.Controls.ToggleButton : UIObject {
    private IToggle _togglePattern;
    private static IFactory`1<ToggleButton> _factory;
    public ToggleState ToggleState { get; }
    public static IFactory`1<ToggleButton> Factory { get; }
    public ToggleButton(UIObject uiObject);
    public ToggleButton(AutomationElement element);
    private static ToggleButton();
    private void Initialize();
    public sealed virtual ToggleState get_ToggleState();
    public virtual void Toggle();
    public sealed virtual UIEventWaiter GetToggledWaiter();
    public void Check();
    public void Uncheck();
    public static IFactory`1<ToggleButton> get_Factory();
    private bool SetToggleState(ToggleState toggleState);
}
public class Microsoft.Windows.Apps.Test.Foundation.Controls.ToggleSwitch : UIObject {
    private IToggle _togglePattern;
    private static IFactory`1<ToggleSwitch> _factory;
    public ToggleState ToggleState { get; }
    public static IFactory`1<ToggleSwitch> Factory { get; }
    public ToggleSwitch(UIObject uiObject);
    public ToggleSwitch(AutomationElement element);
    private static ToggleSwitch();
    private void Initialize();
    public sealed virtual ToggleState get_ToggleState();
    public virtual void Toggle();
    public sealed virtual UIEventWaiter GetToggledWaiter();
    public void TurnOn();
    public void TurnOff();
    public static IFactory`1<ToggleSwitch> get_Factory();
    private bool SetToggleState(ToggleState toggleState);
}
public class Microsoft.Windows.Apps.Test.Foundation.Controls.ToolBar : UIObject {
    private static IFactory`1<ToolBar> _factory;
    public static IFactory`1<ToolBar> Factory { get; }
    public ToolBar(UIObject uiObject);
    internal ToolBar(AutomationElement element);
    private static ToolBar();
    public static IFactory`1<ToolBar> get_Factory();
}
public class Microsoft.Windows.Apps.Test.Foundation.Controls.ToolTip : UIObject {
    private static IFactory`1<ToolTip> _factory;
    public static IFactory`1<ToolTip> Factory { get; }
    public ToolTip(UIObject uiObject);
    internal ToolTip(AutomationElement element);
    private static ToolTip();
    public static IFactory`1<ToolTip> get_Factory();
}
public class Microsoft.Windows.Apps.Test.Foundation.Controls.Tree : Tree`2<Tree, TreeItem> {
    private static IFactory`1<Tree> _factory;
    public static IFactory`1<Tree> Factory { get; }
    public Tree(UIObject uiObject);
    internal Tree(AutomationElement element);
    private static Tree();
    public static IFactory`1<Tree> get_Factory();
}
public abstract class Microsoft.Windows.Apps.Test.Foundation.Controls.Tree`2 : UIObject {
    private ISelection`1<I> _selectionPattern;
    private IFactory`1<I> _itemFactory;
    private static UICondition _treeCondition;
    public UICollection`1<I> Items { get; }
    public UICollection`1<I> Selection { get; }
    public bool CanSelectMultiple { get; }
    public bool IsSelectionRequired { get; }
    protected IFactory`1<I> ItemFactory { get; protected set; }
    protected ISelection`1<I> SelectionProvider { get; protected set; }
    protected static UICondition TreeCondition { get; }
    protected Tree`2(UIObject uiObject, IFactory`1<I> itemFactory);
    internal Tree`2(AutomationElement element, IFactory`1<I> itemFactory);
    private static Tree`2();
    private void Initialize(IFactory`1<I> itemFactory);
    public virtual UICollection`1<I> get_Items();
    public virtual UICollection`1<I> get_Selection();
    public virtual bool get_CanSelectMultiple();
    public virtual bool get_IsSelectionRequired();
    protected IFactory`1<I> get_ItemFactory();
    protected void set_ItemFactory(IFactory`1<I> value);
    protected ISelection`1<I> get_SelectionProvider();
    protected void set_SelectionProvider(ISelection`1<I> value);
    protected static UICondition get_TreeCondition();
}
public class Microsoft.Windows.Apps.Test.Foundation.Controls.TreeItem : TreeItem`2<Tree, TreeItem> {
    private static IFactory`1<TreeItem> _factory;
    public static IFactory`1<TreeItem> Factory { get; }
    public TreeItem(UIObject uiObject);
    internal TreeItem(AutomationElement element);
    private static TreeItem();
    public static IFactory`1<TreeItem> get_Factory();
}
public abstract class Microsoft.Windows.Apps.Test.Foundation.Controls.TreeItem`2 : UIObject {
    private IExpandCollapse _expandCollapsePattern;
    private ISelectionItem`1<C> _selectionItemPattern;
    private IFactory`1<I> _itemFactory;
    private static UICondition _treeCondition;
    public UICollection`1<I> Items { get; }
    public ExpandCollapseState ExpandCollapseState { get; }
    public bool IsSelected { get; }
    public C SelectionContainer { get; }
    protected IFactory`1<I> ItemFactory { get; protected set; }
    protected IExpandCollapse ExpandCollapseProvider { get; protected set; }
    protected ISelectionItem`1<C> SelectionItemProvider { get; protected set; }
    protected static UICondition TreeCondition { get; }
    protected TreeItem`2(UIObject uiObject, IFactory`1<C> containerFactory, IFactory`1<I> itemFactory);
    internal TreeItem`2(AutomationElement element, IFactory`1<C> containerFactory, IFactory`1<I> itemFactory);
    private static TreeItem`2();
    private void Initialize(IFactory`1<C> containerFactory, IFactory`1<I> itemFactory);
    public virtual UICollection`1<I> get_Items();
    public virtual void Collapse();
    public virtual void Expand();
    public virtual ExpandCollapseState get_ExpandCollapseState();
    public sealed virtual UIEventWaiter GetCollapsedWaiter();
    public sealed virtual UIEventWaiter GetExpandedWaiter();
    public virtual void Select();
    public virtual void AddToSelection();
    public sealed virtual UIEventWaiter GetAddedToSelectionWaiter();
    public sealed virtual UIEventWaiter GetRemovedFromSelectionWaiter();
    public sealed virtual UIEventWaiter GetSelectedWaiter();
    public virtual void RemoveFromSelection();
    public virtual bool get_IsSelected();
    public virtual C get_SelectionContainer();
    protected IFactory`1<I> get_ItemFactory();
    protected void set_ItemFactory(IFactory`1<I> value);
    protected IExpandCollapse get_ExpandCollapseProvider();
    protected void set_ExpandCollapseProvider(IExpandCollapse value);
    protected ISelectionItem`1<C> get_SelectionItemProvider();
    protected void set_SelectionItemProvider(ISelectionItem`1<C> value);
    protected static UICondition get_TreeCondition();
}
public class Microsoft.Windows.Apps.Test.Foundation.Controls.Window : UIObject {
    private ITransform _transformPattern;
    private IWindow _windowPattern;
    private static IFactory`1<Window> _factory;
    public bool CanRotate { get; }
    public bool CanResize { get; }
    public bool CanMove { get; }
    public bool CanMaximize { get; }
    public bool CanMinimize { get; }
    public bool IsModal { get; }
    public WindowVisualState WindowVisualState { get; }
    public WindowInteractionState WindowInteractionState { get; }
    public bool IsTopmost { get; }
    public static IFactory`1<Window> Factory { get; }
    public Window(UIObject uiObject);
    internal Window(AutomationElement element);
    private static Window();
    private void Initialize();
    public virtual void Rotate(double degrees);
    public virtual void Resize(double width, double height);
    public virtual void Move(double x, double y);
    public virtual bool get_CanRotate();
    public virtual bool get_CanResize();
    public virtual bool get_CanMove();
    public virtual void SetWindowVisualState(WindowVisualState state);
    public virtual void Close();
    public sealed virtual UIEventWaiter GetWindowClosedWaiter();
    public virtual void WaitForInputIdle(int milliseconds);
    public virtual bool get_CanMaximize();
    public virtual bool get_CanMinimize();
    public virtual bool get_IsModal();
    public virtual WindowVisualState get_WindowVisualState();
    public virtual WindowInteractionState get_WindowInteractionState();
    public virtual bool get_IsTopmost();
    public static IFactory`1<Window> get_Factory();
}
internal class Microsoft.Windows.Apps.Test.Foundation.GlobalizableAndCondition : GlobalizableCondition {
    private List`1<GlobalizableCondition> _conditions;
    private AndCondition _condition;
    public Condition Condition { get; }
    public GlobalizableAndCondition(AndCondition condition);
    public GlobalizableAndCondition(GlobalizableCondition[] conditions);
    public virtual Condition get_Condition();
    public virtual Condition GlobalizeCondition(AutomationElement element, Dictionary`2& propertyValueTranslations);
}
internal abstract class Microsoft.Windows.Apps.Test.Foundation.GlobalizableCondition : object {
    public Condition Condition { get; }
    public static GlobalizableCondition Create(Condition condition);
    public static List`1<GlobalizableCondition> Create(Condition[] conditions);
    public abstract virtual Condition GlobalizeCondition(AutomationElement element, Dictionary`2& propertyValueTranslations);
    public abstract virtual Condition get_Condition();
}
internal class Microsoft.Windows.Apps.Test.Foundation.GlobalizableNotCondition : GlobalizableCondition {
    private NotCondition _notCondition;
    private GlobalizableCondition _condition;
    public Condition Condition { get; }
    public GlobalizableNotCondition(NotCondition notCondition);
    public GlobalizableNotCondition(GlobalizableCondition condition);
    public virtual Condition GlobalizeCondition(AutomationElement element, Dictionary`2& propertyValueTranslations);
    public virtual Condition get_Condition();
}
internal class Microsoft.Windows.Apps.Test.Foundation.GlobalizableOrCondition : GlobalizableCondition {
    private List`1<GlobalizableCondition> _conditions;
    private OrCondition _condition;
    public Condition Condition { get; }
    public GlobalizableOrCondition(OrCondition condition);
    public GlobalizableOrCondition(GlobalizableCondition[] conditions);
    public virtual Condition GlobalizeCondition(AutomationElement element, Dictionary`2& propertyValueTranslations);
    public virtual Condition get_Condition();
}
internal class Microsoft.Windows.Apps.Test.Foundation.GlobalizableOtherConditions : GlobalizableCondition {
    private Condition _condition;
    public Condition Condition { get; }
    public GlobalizableOtherConditions(Condition condition);
    public virtual Condition GlobalizeCondition(AutomationElement element, Dictionary`2& propertyValueTranslations);
    public virtual Condition get_Condition();
}
internal class Microsoft.Windows.Apps.Test.Foundation.GlobalizablePropertyCondition : GlobalizableCondition {
    private object _value;
    private AutomationProperty _property;
    private PropertyCondition _condition;
    public Condition Condition { get; }
    public GlobalizablePropertyCondition(PropertyCondition condition);
    public GlobalizablePropertyCondition(AutomationProperty property, object value);
    public virtual Condition GlobalizeCondition(AutomationElement element, Dictionary`2& propertyValueTranslations);
    public virtual Condition get_Condition();
}
public class Microsoft.Windows.Apps.Test.Foundation.HaltingException : Exception {
    public HaltingException(string message);
    public HaltingException(string message, Exception innerException);
}
public interface Microsoft.Windows.Apps.Test.Foundation.IFactory`1 {
    public abstract virtual I Create(UIObject element);
}
public interface Microsoft.Windows.Apps.Test.Foundation.IFilter`1 {
    public abstract virtual bool Matches(I item);
}
internal interface Microsoft.Windows.Apps.Test.Foundation.IInputAction {
    public abstract virtual void Execute(IRIMPointerInput rim, int elapsedMs);
}
internal interface Microsoft.Windows.Apps.Test.Foundation.IInputAlgorithms {
    public abstract virtual IList`1<IInputAction> PressAndHold(Point point, UInt32 holdDuration, UInt32 tapCount, UInt32 tapDelta, UInt32 packetDelta);
    public abstract virtual IList`1<IInputAction> PressAndHoldAndDrag(Point start, Point end, UInt32 dragDuration, UInt32 holdDuration, UInt32 packetDelta);
    public abstract virtual IList`1<IInputAction> PressAndHoldAndDragWithAcceleration(Point start, Point end, UInt32 holdDuration, float acceleration, UInt32 packetDelta);
    public abstract virtual IList`1<IInputAction> TwoFingerPressAndHold(Point pointOne, Point pointTwo, UInt32 holdDuration, UInt32 tapCount, UInt32 tapDelta, UInt32 packetDelta);
    public abstract virtual IList`1<IInputAction> TwoFingerZoom(Point pointOne, Point pointTwo, float direction, UInt32 duration, UInt32 distance, bool pivotZoom, UInt32 packetDelta);
    public abstract virtual IList`1<IInputAction> TwoFingerPressAndHoldAndDragWithAcceleration(Point pointOne, Point pointTwo, float direction, UInt32 distance, UInt32 holdDuration, float acceleration, UInt32 packetDelta);
    public abstract virtual IList`1<IInputAction> TwoFingerRotate(Point pointOne, Point pointTwo, float rotationAngle, UInt32 duration, bool pivotRotate, UInt32 packetDelta);
}
internal interface Microsoft.Windows.Apps.Test.Foundation.IInputManager {
    public abstract virtual void InjectDynamicPress(Point touchPoint, UInt32 contactId);
    public abstract virtual void InjectionDynamicRelease(UInt32 contactId);
    public abstract virtual void InjectPress(Point point, UInt32 holdDuration, UInt32 tapCount, UInt32 tapDelta, UInt32 packetDelta);
    public abstract virtual void InjectPressAndDrag(Point start, Point end, UInt32 dragDuration, UInt32 holdDuration, UInt32 packetDelta);
    public abstract virtual void InjectPressAndDragWithAcceleration(Point start, Point end, UInt32 holdDuration, float acceleration, UInt32 packetDelta);
    public abstract virtual void InjectMTPanWithAcceleration(Point startFingerOne, Point startFingerTwo, float direction, UInt32 distance, UInt32 holdDuration, float acceleration, UInt32 packetDelta);
    public abstract virtual void InjectMTZoom(Point startFingerOne, Point startFingerTwo, float direction, UInt32 duration, UInt32 distance, bool pivotZoom, UInt32 packetDelta);
    public abstract virtual void InjectMTRotate(Point startFingerOne, Point startFingerTwo, float rotationAngle, UInt32 duration, bool pivotRotate, UInt32 packetDelta);
    public abstract virtual void InjectMTTwoFingerPress(Point pointOne, Point pointTwo, UInt32 holdDuration, UInt32 tapCount, UInt32 tapDelta, UInt32 packetDelta);
    public abstract virtual void InjectMTPressAndTap(Point startFingerOne, Point startFingerTwo, Point endFingerOne, UInt32 deltaFingerTwoDown, UInt32 deltaFingerTwoUp, UInt32 deltaFingerOneUp, UInt32 packetDelta);
    public abstract virtual void InjectMultiTouch(MultiTouchInjectionData[] injectionData, UInt32 packetDelta);
}
internal interface Microsoft.Windows.Apps.Test.Foundation.IInputQueue {
    public abstract virtual void Process(IRIMPointerInput rim, IList`1<IInputAction> inputList);
}
internal interface Microsoft.Windows.Apps.Test.Foundation.ILocalizedStrings {
    public abstract virtual IStringResourceData[] GetTranslations();
    public abstract virtual bool TranslationMatchFound(AutomationElement element, long index);
}
public interface Microsoft.Windows.Apps.Test.Foundation.IMouseWheel {
    public abstract virtual void RotateWheel(UIObject uiObject, int delta);
}
public interface Microsoft.Windows.Apps.Test.Foundation.IMouseWheelInput {
    public abstract virtual void RotateWheel(int delta);
}
public interface Microsoft.Windows.Apps.Test.Foundation.IMultiPointGesture {
    public abstract virtual void PressAndTap(UIObject uiObject);
    public abstract virtual void TwoPointPressAndHold(UIObject uiObject);
    public abstract virtual void TwoPointPressAndHold(UIObject uiObject, UInt32 count);
    public abstract virtual void TwoPointPan(UIObject targetObject, UIObject destinationObject);
    public abstract virtual void TwoPointPan(UIObject targetObject, UIObject destinationObject, float acceleration);
    public abstract virtual void TwoPointPan(UIObject uiObject, float acceleration, UInt32 distance, float direction);
    public abstract virtual void Pinch(UIObject uiObject);
    public abstract virtual void Pinch(UIObject uiObject, UInt32 distance);
    public abstract virtual void Pinch(UIObject uiObject, UInt32 distance, float direction);
    public abstract virtual void Pinch(UIObject uiObject, UInt32 distance, float direction, bool pivot);
    public abstract virtual void Stretch(UIObject uiObject);
    public abstract virtual void Stretch(UIObject uiObject, UInt32 distance);
    public abstract virtual void Stretch(UIObject uiObject, UInt32 distance, float direction);
    public abstract virtual void Stretch(UIObject uiObject, UInt32 distance, float direction, bool pivot);
    public abstract virtual void Rotate(UIObject uiObject, float angle);
    public abstract virtual void Rotate(UIObject uiObject, UInt32 distance, float angle);
    public abstract virtual void Rotate(UIObject uiObject, float angle, bool centerOnPoint);
    public abstract virtual void Rotate(UIObject uiObject, UInt32 distance, float angle, bool centerOnPoint);
}
public interface Microsoft.Windows.Apps.Test.Foundation.IMultiPointGestureInput {
    public abstract virtual void PressAndTap(UInt32 tapCount, UInt32 tapDuration, UInt32 tapDelta, UInt32 distance);
    public abstract virtual void TwoPointPressAndHold(UInt32 tapCount, UInt32 holdDuration, UInt32 tapDelta, UInt32 distance);
    public abstract virtual void TwoPointPan(Point endPoint, UInt32 holdDuration, float acceleration, UInt32 distance);
    public abstract virtual void Pinch(float direction, UInt32 duration, UInt32 startDistance, UInt32 endDistance);
    public abstract virtual void Pinch(float direction, UInt32 duration, UInt32 startDistance, UInt32 endDistance, bool pivot);
    public abstract virtual void Stretch(float direction, UInt32 duration, UInt32 startDistance, UInt32 endDistance);
    public abstract virtual void Stretch(float direction, UInt32 duration, UInt32 startDistance, UInt32 endDistance, bool pivot);
    public abstract virtual void Rotate(float angle, UInt32 duration, bool centerOnPoint, UInt32 distance);
    public abstract virtual void InjectMultiPointGesture(MultiPointInjectionData[] injectionData);
}
internal interface Microsoft.Windows.Apps.Test.Foundation.INativeMethods {
    public abstract virtual void GetKeyboardState(Byte[] keyState);
    public abstract virtual bool GetMouseButtonsSwapped();
    public abstract virtual Rectangle GetClientArea();
}
internal static class Microsoft.Windows.Apps.Test.Foundation.Input : object {
    internal static INativeMethods nativeMethods;
    private static Input();
    internal static IInputAction CreateWait(int duration);
    internal static IList`1<IInputAction> CreateKeyInput(VirtualKey key, KeyAction action, int duration);
    internal static IList`1<IInputAction> CreateKeyInput(char character, int duration);
    internal static IList`1<IInputAction> CreateKeyModifierInputs(ModifierKeys modifierKeys, bool press, int duration);
    internal static IInputAction CreateMouseMoveInput(double absoluteX, double absoluteY);
    internal static Point AdjustPointerMoveInput(Point originalPoint);
    internal static IInputAction CreateMouseDownInput(PointerButtons button, bool swapped);
    internal static IInputAction CreateMouseUpInput(PointerButtons button, bool swapped);
    internal static IInputAction CreateMouseRotateWheelInput(int delta);
    private static PointerButtons DeterminePhysicalButton(PointerButtons button, bool swapped);
    private static MOUSE_EVENT_FLAGS MouseButtonsToMouseInputs(PointerButtons physicalButton, bool isMouseFlagsDown);
    internal static IList`1<IInputAction> PreventAccidentalDoubleClick(double x, double y, Int32[]& previousRuntimeId);
}
internal class Microsoft.Windows.Apps.Test.Foundation.InputAlgorithms : object {
    private static int afterMoveActionWaitDuration;
    private static int afterTapActionWaitDuration;
    public sealed virtual IList`1<IInputAction> PressAndHold(Point point, UInt32 holdDuration, UInt32 tapCount, UInt32 tapDelta, UInt32 packetDelta);
    public sealed virtual IList`1<IInputAction> PressAndHoldAndDrag(Point start, Point end, UInt32 dragDuration, UInt32 holdDuration, UInt32 packetDelta);
    public sealed virtual IList`1<IInputAction> PressAndHoldAndDragWithAcceleration(Point start, Point end, UInt32 holdDuration, float acceleration, UInt32 packetDelta);
    public sealed virtual IList`1<IInputAction> TwoFingerPressAndHold(Point pointOne, Point pointTwo, UInt32 holdDuration, UInt32 tapCount, UInt32 tapDelta, UInt32 packetDelta);
    public sealed virtual IList`1<IInputAction> TwoFingerZoom(Point pointOne, Point pointTwo, float direction, UInt32 duration, UInt32 distance, bool pivotZoom, UInt32 packetDelta);
    public sealed virtual IList`1<IInputAction> TwoFingerPressAndHoldAndDragWithAcceleration(Point pointOne, Point pointTwo, float direction, UInt32 distance, UInt32 holdDuration, float acceleration, UInt32 packetDelta);
    public sealed virtual IList`1<IInputAction> TwoFingerRotate(Point pointOne, Point pointTwo, float rotationAngle, UInt32 duration, bool pivotRotate, UInt32 packetDelta);
    private void Press(Point location, IList`1<IInputAction> injectList);
    private void MultiPress(IList`1<Point> locations, IList`1<IInputAction> injectList);
    private void Wait(Int32& elapsedTime, int duration, IList`1<IInputAction> injectList);
    private void Update(Point location, IList`1<IInputAction> injectList);
    private void MultiUpdate(IList`1<Point> locations, IList`1<IInputAction> injectList);
    private void Release(Point location, IList`1<IInputAction> injectList);
    private void MultiRelease(IList`1<Point> locations, IList`1<IInputAction> injectList);
}
public static class Microsoft.Windows.Apps.Test.Foundation.InputController : object {
    private static PointerInputType activeInputType;
    public static PointerInputType ActiveInputType { get; internal set; }
    private static InputController();
    public static CompositeInputControllerMartyr Activate(PointerInputType inputType);
    public static PointerInputType get_ActiveInputType();
    internal static void set_ActiveInputType(PointerInputType value);
}
internal class Microsoft.Windows.Apps.Test.Foundation.InputControllerMartyr`1 : object {
    private Stack`1<T> _inputControllerStack;
    private T _currentController;
    public InputControllerMartyr`1(Stack`1<T> inputStack, T inputController);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
internal class Microsoft.Windows.Apps.Test.Foundation.InputManager : object {
    private bool _disposed;
    private POINTER_INPUT_TYPE inputType;
    private IRIMPointerInput rim;
    private ITimeManagerFactory timeFactory;
    private IInputAlgorithms inputAlgorithms;
    private static UInt32 _defaultPressDuration;
    private static UInt32 _defaultTapDelta;
    private static UInt32 _defaultPacketDelta;
    private IInputQueue inputQueue;
    private Int32[] _previousRuntimeId;
    public static UInt32 DefaultPressDuration { get; }
    public static UInt32 DefaultTapDelta { get; }
    public static UInt32 DefaultPacketDelta { get; }
    public InputManager(POINTER_INPUT_TYPE inputType, IRIMPointerInputFactory rimFactory, ITimeManagerFactory timeFactory, IInputAlgorithms inputAlgorithms);
    private static InputManager();
    protected virtual override void Finalize();
    public sealed virtual void InjectPress(Point point, UInt32 holdDuration, UInt32 tapCount, UInt32 tapDelta, UInt32 packetDelta);
    public sealed virtual void InjectPressAndDrag(Point start, Point end, UInt32 dragDuration, UInt32 holdDuration, UInt32 packetDelta);
    public sealed virtual void InjectPressAndDragWithAcceleration(Point start, Point end, UInt32 holdDuration, float acceleration, UInt32 packetDelta);
    public sealed virtual void InjectMTPanWithAcceleration(Point startFingerOne, Point startFingerTwo, float direction, UInt32 distance, UInt32 holdDuration, float acceleration, UInt32 packetDelta);
    public sealed virtual void InjectMTZoom(Point startFingerOne, Point startFingerTwo, float direction, UInt32 duration, UInt32 distance, bool pivotZoom, UInt32 packetDelta);
    public sealed virtual void InjectMTRotate(Point startFingerOne, Point startFingerTwo, float rotationAngle, UInt32 duration, bool pivotRotate, UInt32 packetDelta);
    public sealed virtual void InjectMTTwoFingerPress(Point startFingerOne, Point startFingerTwo, UInt32 holdDuration, UInt32 tapCount, UInt32 tapDelta, UInt32 packetDelta);
    public sealed virtual void InjectMTPressAndTap(Point startFingerOne, Point startFingerTwo, Point endFingerOne, UInt32 deltaFingerTwoDown, UInt32 deltaFingerTwoUp, UInt32 deltaFingerOneUp, UInt32 packetDelta);
    public sealed virtual void InjectMultiTouch(MultiTouchInjectionData[] injectionData, UInt32 packetDelta);
    public sealed virtual void InjectDynamicPress(Point touchPoint, UInt32 contactId);
    public sealed virtual void InjectionDynamicRelease(UInt32 contactId);
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    public static UInt32 get_DefaultPressDuration();
    public static UInt32 get_DefaultTapDelta();
    public static UInt32 get_DefaultPacketDelta();
}
internal class Microsoft.Windows.Apps.Test.Foundation.InputQueue : object {
    public sealed virtual void Process(IRIMPointerInput rim, IList`1<IInputAction> inputList);
}
public interface Microsoft.Windows.Apps.Test.Foundation.IPointer {
    public abstract virtual void Click(UIObject uiObject);
    public abstract virtual void Click(UIObject uiObject, PointerButtons button);
    public abstract virtual void Click(UIObject uiObject, PointerButtons button, double offsetX, double offsetY);
    public abstract virtual void DoubleClick(UIObject uiObject);
    public abstract virtual void DoubleClick(UIObject uiObject, PointerButtons button);
    public abstract virtual void DoubleClick(UIObject uiObject, PointerButtons button, double offsetX, double offsetY);
    public abstract virtual void ClickDrag(UIObject targetObject, UIObject destinationObject);
    public abstract virtual void ClickDrag(UIObject targetObject, UIObject destinationObject, PointerButtons button);
    public abstract virtual void Move(UIObject uiObject);
    public abstract virtual void Move(UIObject uiObject, double offsetX, double offsetY);
}
public interface Microsoft.Windows.Apps.Test.Foundation.IPointerInput {
    public Point Location { get; }
    public abstract virtual void Click(PointerButtons button, int count);
    public abstract virtual void ClickDrag(Point endPoint, PointerButtons button, UInt32 dragDuration);
    public abstract virtual void Move(Point point);
    public abstract virtual void Press(PointerButtons button);
    public abstract virtual void Release(PointerButtons button);
    public abstract virtual Point get_Location();
}
internal interface Microsoft.Windows.Apps.Test.Foundation.IRIMPointerInput {
    public abstract virtual void InjectPointer(PointerData pointerData);
    public abstract virtual void InjectPointer(PointerData[] pointerData);
}
internal interface Microsoft.Windows.Apps.Test.Foundation.IRIMPointerInputFactory {
    public abstract virtual IRIMPointerInput Get(POINTER_INPUT_TYPE inputType);
}
public interface Microsoft.Windows.Apps.Test.Foundation.ISinglePointGesture {
    public abstract virtual void Flick(UIObject targetObject, UIObject destinationObject);
    public abstract virtual void Flick(UIObject targetObject, UIObject destinationObject, float acceleration);
    public abstract virtual void Flick(UIObject uiObject, float acceleration, UInt32 distance, float direction);
    public abstract virtual void Pan(UIObject targetObject, UIObject destinationObject);
    public abstract virtual void Pan(UIObject targetObject, UIObject destinationObject, float acceleration);
    public abstract virtual void Pan(UIObject uiObject, float acceleration, UInt32 distance, float direction);
    public abstract virtual void PressAndDrag(UIObject targetObject, UIObject destinationObject);
    public abstract virtual void PressAndDrag(UIObject targetObject, UIObject destinationObject, UInt32 dragDuration);
    public abstract virtual void PressAndDrag(UIObject targetObject, UIObject destinationObject, UInt32 dragDuration, UInt32 pressDuration);
    public abstract virtual void PressAndDrag(UIObject uiObject, UInt32 distance, float direction);
    public abstract virtual void PressAndHold(UIObject uiObject);
    public abstract virtual void PressAndHold(UIObject uiObject, UInt32 holdDuration);
}
public interface Microsoft.Windows.Apps.Test.Foundation.ISinglePointGestureInput {
    public abstract virtual void Flick(Point endPoint, UInt32 holdDuration, float acceleration);
    public abstract virtual void Pan(Point endPoint, UInt32 holdDuration, float acceleration);
    public abstract virtual void PressAndDrag(Point endPoint, UInt32 dragDuration);
    public abstract virtual void PressAndDrag(Point endPoint, UInt32 dragDuration, UInt32 pressDuration);
    public abstract virtual void PressAndHold(UInt32 holdDuration);
}
public interface Microsoft.Windows.Apps.Test.Foundation.ITextInput {
    public abstract virtual void SendText(string text);
}
internal interface Microsoft.Windows.Apps.Test.Foundation.ITimeManager {
}
internal interface Microsoft.Windows.Apps.Test.Foundation.ITimeManagerFactory {
    public abstract virtual ITimeManager Get();
}
internal enum Microsoft.Windows.Apps.Test.Foundation.KeyAction : Enum {
    public int value__;
    public static KeyAction Press;
    public static KeyAction Release;
    public static KeyAction PressAndRelease;
}
public class Microsoft.Windows.Apps.Test.Foundation.Keyboard : object {
    private bool turnOffToggleKeys;
    private static int sendKeysDelay;
    private static string specialChars;
    private static Regex specialCharacterPattern;
    private static object sendKeysLock;
    private KeyTranslator keyTranslator;
    private static object classLock;
    private static Keyboard singletonInstance;
    internal static INativeMethods nativeMethods;
    private IInputQueue inputQueue;
    public static Keyboard Instance { get; }
    public bool TurnOffToggleKeys { get; public set; }
    public static int SendKeysDelay { get; public set; }
    private static Keyboard();
    public static Keyboard get_Instance();
    public sealed virtual void SendText(string text);
    private void SendKeys(string text);
    public static KeyState GetKeyState(VirtualKey virtualKeyCode);
    public static string EscapeSpecialCharacters(string text);
    public bool get_TurnOffToggleKeys();
    public void set_TurnOffToggleKeys(bool value);
    public static int get_SendKeysDelay();
    public static void set_SendKeysDelay(int value);
    private void GetLockToggleInputs(List`1& turnOffLockInputs, List`1& restoreLockInputs);
    private bool IsChar(char character, string characterSet);
    private bool IsSpecial(char character);
    private bool ParseEOS(ParsePosition position);
    private bool ParseWhitespace(ParsePosition position);
    private bool ParseWhitespaces(ParsePosition position);
    private bool ParseDigit(ParsePosition position, Int32& digit);
    private bool ParseNumber(ParsePosition position, Int32& number);
    private bool ParseDownUp(ParsePosition position, KeyAction& keyAction);
    private bool ParseCurlyPostfix(ParsePosition position, Int32& repetitionCount, KeyAction& keyAction);
    private bool ParseSpecialChar(ParsePosition position, List`1<IInputAction> pressInputs);
    private bool ParsePrintable(ParsePosition position, List`1<IInputAction> pressInputs, List`1<IInputAction> releaseInputs);
    private bool ParseNonPrintable(ParsePosition position, List`1<IInputAction> pressInputs, List`1<IInputAction> releaseInputs);
    private bool ParseCurly(ParsePosition position, List`1<IInputAction> inputs);
    private bool ParseBlock(ParsePosition position, List`1<IInputAction> inputs);
    private bool ParseInnerText(ParsePosition position, List`1<IInputAction> inputs);
    private bool ParseModifier(ParsePosition position, List`1<IInputAction> pressInputs, List`1<IInputAction> releaseInputs);
    private bool ParseModifiers(ParsePosition position, List`1<IInputAction> inputs);
    internal bool ParseText(string text, List`1& inputs);
}
internal class Microsoft.Windows.Apps.Test.Foundation.KeyboardInputAction : object {
    public KeyboardInput keyboardInput;
    public sealed virtual void Execute(IRIMPointerInput rim, int elapsedMs);
}
internal class Microsoft.Windows.Apps.Test.Foundation.KeyMap : KeyedCollection`2<VirtualKey, KeyMapItem> {
    protected virtual VirtualKey GetKeyForItem(KeyMapItem item);
}
internal class Microsoft.Windows.Apps.Test.Foundation.KeyMapItem : object {
    public VirtualKey VirtualKey;
    public KeyScanCodes ScanCodes;
    public KeyMapItem(VirtualKey virtualKey, KeyScanCodes scanCodes);
}
internal class Microsoft.Windows.Apps.Test.Foundation.KeyScanCodes : ValueType {
    public ushort MakeCode;
    public ushort BreakCode;
    public KeyScanCodes(ushort makeCode, ushort breakCode);
}
internal class Microsoft.Windows.Apps.Test.Foundation.KeyTranslator : object {
    private NonPrintableMap nonPrintableMap;
    private KeyMap keyMap;
    private IDictionary`2<char, VirtualKey> specialKeysMap;
    private static KeyTranslator singletonInstance;
    private static object classLock;
    public static KeyTranslator Instance { get; }
    private static KeyTranslator();
    public static KeyTranslator get_Instance();
    public ushort GetMakeScanCode(VirtualKey virtualKey);
    public ushort GetMakeScanCode(string name);
    public VirtualKey GetVirtualKey(string keyName);
    public VirtualKey GetVirtualAlphaNumericKey(char alphaNumKey);
    public VirtualKey GetVirtualKeyFromNumpadKey(char numpadKey);
    public bool IsNonPrintableName(string name);
}
internal class Microsoft.Windows.Apps.Test.Foundation.LocalizedStrings2 : object {
    private IStringResourceData[] _translationTable;
    private ILocalizationProvider2 _provider;
    private AutomationElement _contextElement;
    private bool _shouldSendFeedbackToProvider;
    public LocalizedStrings2(AutomationElement contextElement, ILocalizationProvider2 provider);
    public sealed virtual IStringResourceData[] GetTranslations();
    public sealed virtual bool TranslationMatchFound(AutomationElement element, long index);
}
internal class Microsoft.Windows.Apps.Test.Foundation.LocalizedStringsAdapter : object {
    private LocalizedStrings _localizedStrings;
    public LocalizedStringsAdapter(string taggedText);
    public sealed virtual IStringResourceData[] GetTranslations();
    public sealed virtual bool TranslationMatchFound(AutomationElement element, long index);
}
[FlagsAttribute]
public enum Microsoft.Windows.Apps.Test.Foundation.ModifierKeys : Enum {
    public int value__;
    public static ModifierKeys None;
    public static ModifierKeys ShiftFlag;
    public static ModifierKeys ControlFlag;
    public static ModifierKeys AltFlag;
    public static ModifierKeys LeftShiftFlag;
    public static ModifierKeys RightShiftFlag;
    public static ModifierKeys LeftControlFlag;
    public static ModifierKeys RightControlFlag;
    public static ModifierKeys LeftAltFlag;
    public static ModifierKeys RightAltFlag;
    public static ModifierKeys LeftWindowsFlag;
    public static ModifierKeys RightWindowsFlag;
}
internal class Microsoft.Windows.Apps.Test.Foundation.Mouse : object {
    private static object _classLock;
    private static Mouse _singletonInstance;
    private Point _location;
    private Int32[] _previousRuntimeId;
    internal INativeMethods nativeMethods;
    internal IInputQueue inputQueue;
    private static int afterMoveActionWaitDuration;
    private static int afterClickActionWaitDuration;
    private static int afterWheelActionWaitDuration;
    public static Mouse Instance { get; }
    public Point Location { get; }
    private static Mouse();
    public static Mouse get_Instance();
    public virtual void Click(PointerButtons button, int count);
    public sealed virtual void ClickDrag(Point endPoint, PointerButtons button, UInt32 dragDuration);
    public virtual void Move(Point point);
    public virtual void Press(PointerButtons button);
    public virtual void Release(PointerButtons button);
    public virtual Point get_Location();
    public virtual void RotateWheel(int delta);
    private IList`1<IInputAction> Down(PointerButtons button, ModifierKeys modifierKeys);
    private IList`1<IInputAction> Up(PointerButtons button, ModifierKeys modifierKeys);
    private bool GetMouseButtonsSwapped();
    private IList`1<IInputAction> RotateWheel(int delta, ModifierKeys modifierKeys);
}
internal class Microsoft.Windows.Apps.Test.Foundation.MouseInputAction : object {
    public MouseInput mouseInput;
    public sealed virtual void Execute(IRIMPointerInput rim, int elapsedMs);
}
public static class Microsoft.Windows.Apps.Test.Foundation.MouseWheelInput : object {
    private static Stack`1<IMouseWheelInput> _mouseWheelInputStack;
    public static IMouseWheelInput Current { get; }
    private static MouseWheelInput();
    public static void RotateWheel(int delta);
    public static void RotateWheel(UIObject uiObject, int delta);
    public static IDisposable Activate(IMouseWheelInput mouseWheel);
    public static IMouseWheelInput get_Current();
}
internal class Microsoft.Windows.Apps.Test.Foundation.MultiPointerInputAction : object {
    public PointerData[] pointerData;
    public sealed virtual void Execute(IRIMPointerInput rim, int elapsedMs);
}
public static class Microsoft.Windows.Apps.Test.Foundation.MultiPointGesture : object {
    private static Stack`1<IMultiPointGestureInput> _gestureInputStack;
    public static UInt32 DefaultHoldDuration;
    public static UInt32 DefaultTapDelta;
    public static UInt32 DefaultTapDistance;
    public static float DefaultTwoPointPanAcceleration;
    public static UInt32 DefaultTwoPointPanDistance;
    public static UInt32 DefaultPinchStretchDistance;
    public static float DefaultPinchStretchDirection;
    public static UInt32 DefaultPinchStretchDuration;
    public static UInt32 DefaultRotateDistance;
    public static UInt32 DefaultRotateDuration;
    public static IMultiPointGestureInput Current { get; }
    private static MultiPointGesture();
    public static void PressAndTap(UInt32 tapCount, UInt32 tapDuration, UInt32 tapDelta, UInt32 distance);
    public static void TwoPointPressAndHold(UInt32 tapCount, UInt32 holdDuration, UInt32 tapDelta, UInt32 distance);
    public static void TwoPointPan(Point endPoint, UInt32 holdDuration, float acceleration, UInt32 distance);
    public static void Pinch(float direction, UInt32 duration, UInt32 startDistance, UInt32 endDistance);
    public static void Pinch(float direction, UInt32 duration, UInt32 startDistance, UInt32 endDistance, bool pivot);
    public static void Stretch(float direction, UInt32 duration, UInt32 startDistance, UInt32 endDistance);
    public static void Stretch(float direction, UInt32 duration, UInt32 startDistance, UInt32 endDistance, bool pivot);
    public static void Rotate(float angle, UInt32 duration, bool centerOnPoint, UInt32 distance);
    public static void InjectMultiPointGesture(MultiPointInjectionData[] injectionData);
    public static void PressAndTap(UIObject uiObject);
    public static void TwoPointPressAndHold(UIObject uiObject);
    public static void TwoPointPressAndHold(UIObject uiObject, UInt32 count);
    public static void TwoPointPan(UIObject targetObject, UIObject destinationObject);
    public static void TwoPointPan(UIObject targetObject, UIObject destinationObject, float acceleration);
    public static void TwoPointPan(UIObject uiObject, float acceleration, UInt32 distance, float direction);
    public static void Pinch(UIObject uiObject);
    public static void Pinch(UIObject uiObject, UInt32 distance);
    public static void Pinch(UIObject uiObject, UInt32 distance, float direction);
    public static void Pinch(UIObject uiObject, UInt32 distance, float direction, bool pivot);
    public static void Stretch(UIObject uiObject);
    public static void Stretch(UIObject uiObject, UInt32 distance);
    public static void Stretch(UIObject uiObject, UInt32 distance, float direction);
    public static void Stretch(UIObject uiObject, UInt32 distance, float direction, bool pivot);
    public static void Rotate(UIObject uiObject, float angle);
    public static void Rotate(UIObject uiObject, UInt32 distance, float angle);
    public static void Rotate(UIObject uiObject, float angle, bool centerOnPoint);
    public static void Rotate(UIObject uiObject, UInt32 distance, float angle, bool centerOnPoint);
    public static IDisposable Activate(IMultiPointGestureInput pointer);
    public static IMultiPointGestureInput get_Current();
    internal static Point OffsetPinchPoints(UIObject uiObject, UInt32 distance, float direction);
    internal static Point OffsetPinchPoints(Point targetPoint, Rectangle boundingRectangle, UInt32 distance, float direction);
}
public class Microsoft.Windows.Apps.Test.Foundation.MultiPointInjectionData : ValueType {
    public Point[] points;
    public UInt32 duration;
}
internal class Microsoft.Windows.Apps.Test.Foundation.MultiTouch : object {
    private static object _classLock;
    private static MultiTouch _singletonInstance;
    private IInputManager _inputManager;
    private Point[] _location;
    private UInt32 DefaultFirstFingerUpTapDelta;
    private UInt32 DefaultContactId;
    private bool _disposed;
    private static UInt32 MaxNumberOfContacts;
    public static MultiTouch Instance { get; }
    public Point Location { get; }
    private static MultiTouch();
    protected virtual override void Finalize();
    public static MultiTouch get_Instance();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    public sealed virtual void Flick(Point endPoint, UInt32 holdDuration, float acceleration);
    public sealed virtual void Pan(Point endPoint, UInt32 holdDuration, float acceleration);
    public sealed virtual void PressAndDrag(Point endPoint, UInt32 dragDuration);
    public sealed virtual void PressAndDrag(Point endPoint, UInt32 dragDuration, UInt32 pressDuration);
    public sealed virtual void PressAndHold(UInt32 holdDuration);
    public sealed virtual void Click(PointerButtons button, int count);
    public sealed virtual void ClickDrag(Point endPoint, PointerButtons button, UInt32 dragDuration);
    public sealed virtual void Move(Point point);
    public sealed virtual void Press(PointerButtons button);
    public sealed virtual void Release(PointerButtons button);
    public sealed virtual Point get_Location();
    public sealed virtual void PressAndTap(UInt32 tapCount, UInt32 tapDuration, UInt32 tapDelta, UInt32 distance);
    public sealed virtual void TwoPointPressAndHold(UInt32 tapCount, UInt32 holdDuration, UInt32 tapDelta, UInt32 distance);
    public sealed virtual void TwoPointPan(Point endPoint, UInt32 holdDuration, float acceleration, UInt32 distance);
    public sealed virtual void Pinch(float direction, UInt32 duration, UInt32 startDistance, UInt32 endDistance);
    public sealed virtual void Pinch(float direction, UInt32 duration, UInt32 startDistance, UInt32 endDistance, bool pivot);
    public sealed virtual void Stretch(float direction, UInt32 duration, UInt32 startDistance, UInt32 endDistance);
    public sealed virtual void Stretch(float direction, UInt32 duration, UInt32 startDistance, UInt32 endDistance, bool pivot);
    public sealed virtual void Rotate(float angle, UInt32 duration, bool centerOnPoint, UInt32 distance);
    public sealed virtual void InjectMultiPointGesture(MultiPointInjectionData[] injectionData);
    private void Move(Point point, UInt32 contactId);
    private Point GetLocationOfContact(UInt32 contactId);
    private Point CreateSecondFingerPointFromDistance(UInt32 distance, float direction);
    private MultiTouchInjectionData ConvertInjectionData(MultiPointInjectionData injectionData);
    private MultiTouchInjectionData[] ConvertInjectionDataArray(MultiPointInjectionData[] injectionData);
}
public class Microsoft.Windows.Apps.Test.Foundation.MultiTouchInjectionData : ValueType {
    public Point[] points;
    public UInt32 duration;
}
internal class Microsoft.Windows.Apps.Test.Foundation.NativeMethods : object {
    private static int SM_SWAPBUTTON;
    private static int SM_XVIRTUALSCREEN;
    private static int SM_YVIRTUALSCREEN;
    private static int SM_CXVIRTUALSCREEN;
    private static int SM_CYVIRTUALSCREEN;
    public sealed virtual void GetKeyboardState(Byte[] keyState);
    public sealed virtual bool GetMouseButtonsSwapped();
    public sealed virtual Rectangle GetClientArea();
}
internal class Microsoft.Windows.Apps.Test.Foundation.NonPrintableMap : KeyedCollection`2<string, NonPrintableMapItem> {
    public ICollection`1<string> Keys { get; }
    protected virtual string GetKeyForItem(NonPrintableMapItem item);
    public ICollection`1<string> get_Keys();
}
internal class Microsoft.Windows.Apps.Test.Foundation.NonPrintableMapItem : object {
    public string Name;
    public VirtualKey VirtualKey;
    public NonPrintableMapItem(string name, VirtualKey virtualKey);
}
public class Microsoft.Windows.Apps.Test.Foundation.PatternNotFoundException : Exception {
    public PatternNotFoundException(string message);
    public PatternNotFoundException(string message, Exception innerException);
}
public class Microsoft.Windows.Apps.Test.Foundation.Patterns.DockImplementation : PatternImplementation`1<DockPattern> {
    public DockPosition DockPosition { get; }
    public DockImplementation(UIObject uiObject);
    public sealed virtual void SetDockPosition(DockPosition position);
    public sealed virtual DockPosition get_DockPosition();
}
public class Microsoft.Windows.Apps.Test.Foundation.Patterns.ExpandCollapseImplementation : PatternImplementation`1<ExpandCollapsePattern> {
    public ExpandCollapseState ExpandCollapseState { get; }
    public ExpandCollapseImplementation(UIObject uiObject);
    public sealed virtual void Collapse();
    public sealed virtual void Expand();
    public sealed virtual ExpandCollapseState get_ExpandCollapseState();
    public sealed virtual UIEventWaiter GetCollapsedWaiter();
    public sealed virtual UIEventWaiter GetExpandedWaiter();
    private static bool CollapseFilter(WaiterEventArgs args);
    private static bool ExpandFilter(WaiterEventArgs args);
    private static bool ExpandCollapseStateFilter(AutomationPropertyChangedEventArgs args, ExpandCollapseState state);
}
public class Microsoft.Windows.Apps.Test.Foundation.Patterns.GridImplementation`1 : PatternImplementation`1<GridPattern> {
    private IFactory`1<I> _itemFactory;
    public int RowCount { get; }
    public int ColumnCount { get; }
    public GridImplementation`1(UIObject uiObject, IFactory`1<I> itemFactory);
    public sealed virtual I GetCell(int row, int column);
    public sealed virtual int get_RowCount();
    public sealed virtual int get_ColumnCount();
}
public class Microsoft.Windows.Apps.Test.Foundation.Patterns.GridItemImplementation`1 : PatternImplementation`1<GridItemPattern> {
    private IFactory`1<C> _containerFactory;
    public C ContainingGrid { get; }
    public int Row { get; }
    public int Column { get; }
    public int RowSpan { get; }
    public int ColumnSpan { get; }
    public GridItemImplementation`1(UIObject uiObject, IFactory`1<C> containerFactory);
    public sealed virtual C get_ContainingGrid();
    public sealed virtual int get_Row();
    public sealed virtual int get_Column();
    public sealed virtual int get_RowSpan();
    public sealed virtual int get_ColumnSpan();
}
public interface Microsoft.Windows.Apps.Test.Foundation.Patterns.IContainer`1 {
    public UICollection`1<I> Items { get; }
    public abstract virtual UICollection`1<I> get_Items();
}
public interface Microsoft.Windows.Apps.Test.Foundation.Patterns.IDock {
    public DockPosition DockPosition { get; }
    public abstract virtual void SetDockPosition(DockPosition position);
    public abstract virtual DockPosition get_DockPosition();
}
public interface Microsoft.Windows.Apps.Test.Foundation.Patterns.IExpandCollapse {
    public ExpandCollapseState ExpandCollapseState { get; }
    public abstract virtual void Expand();
    public abstract virtual UIEventWaiter GetExpandedWaiter();
    public abstract virtual UIEventWaiter GetCollapsedWaiter();
    public abstract virtual void Collapse();
    public abstract virtual ExpandCollapseState get_ExpandCollapseState();
}
public interface Microsoft.Windows.Apps.Test.Foundation.Patterns.IGrid`1 {
    public int RowCount { get; }
    public int ColumnCount { get; }
    public abstract virtual I GetCell(int row, int column);
    public abstract virtual int get_RowCount();
    public abstract virtual int get_ColumnCount();
}
public interface Microsoft.Windows.Apps.Test.Foundation.Patterns.IGridItem`1 {
    public C ContainingGrid { get; }
    public int Row { get; }
    public int Column { get; }
    public int RowSpan { get; }
    public int ColumnSpan { get; }
    public abstract virtual C get_ContainingGrid();
    public abstract virtual int get_Row();
    public abstract virtual int get_Column();
    public abstract virtual int get_RowSpan();
    public abstract virtual int get_ColumnSpan();
}
public interface Microsoft.Windows.Apps.Test.Foundation.Patterns.IInvoke {
    public abstract virtual void Invoke();
    public abstract virtual UIEventWaiter GetInvokedWaiter();
}
public interface Microsoft.Windows.Apps.Test.Foundation.Patterns.IItemContainer {
    public abstract virtual UIObject FindItemByProperty(UIObject uiObject, UIProperty uiProperty, object value);
}
public interface Microsoft.Windows.Apps.Test.Foundation.Patterns.IMultipleView {
    public int CurrentView { get; }
    public abstract virtual string GetViewName(int viewId);
    public abstract virtual void SetCurrentView(int viewId);
    public abstract virtual Int32[] GetSupportedViews();
    public abstract virtual int get_CurrentView();
}
public class Microsoft.Windows.Apps.Test.Foundation.Patterns.InvokeImplementation : PatternImplementation`1<InvokePattern> {
    public InvokeImplementation(UIObject uiObject);
    public sealed virtual void Invoke();
    public sealed virtual UIEventWaiter GetInvokedWaiter();
}
public interface Microsoft.Windows.Apps.Test.Foundation.Patterns.IObjectModel {
    public abstract virtual object GetUnderlyingObjectModel();
}
public interface Microsoft.Windows.Apps.Test.Foundation.Patterns.IRangeValue {
    public double Minimum { get; }
    public double Maximum { get; }
    public double LargeChange { get; }
    public double SmallChange { get; }
    public double Value { get; }
    public bool IsReadOnly { get; }
    public abstract virtual double get_Minimum();
    public abstract virtual double get_Maximum();
    public abstract virtual double get_LargeChange();
    public abstract virtual double get_SmallChange();
    public abstract virtual void SetValue(double value);
    public abstract virtual double get_Value();
    public abstract virtual bool get_IsReadOnly();
}
public interface Microsoft.Windows.Apps.Test.Foundation.Patterns.IScroll {
    public bool HorizontallyScrollable { get; }
    public bool VerticallyScrollable { get; }
    public double HorizontalScrollPercent { get; }
    public double VerticalScrollPercent { get; }
    public double HorizontalViewSize { get; }
    public double VerticalViewSize { get; }
    public abstract virtual void Scroll(ScrollAmount horizontalAmount, ScrollAmount verticalAmount);
    public abstract virtual void ScrollHorizontal(ScrollAmount amount);
    public abstract virtual void ScrollVertical(ScrollAmount amount);
    public abstract virtual void SetScrollPercent(double horizontalPercent, double verticalPercent);
    public abstract virtual bool get_HorizontallyScrollable();
    public abstract virtual bool get_VerticallyScrollable();
    public abstract virtual double get_HorizontalScrollPercent();
    public abstract virtual double get_VerticalScrollPercent();
    public abstract virtual double get_HorizontalViewSize();
    public abstract virtual double get_VerticalViewSize();
}
public interface Microsoft.Windows.Apps.Test.Foundation.Patterns.IScrollItem {
    public abstract virtual void ScrollIntoView();
}
public interface Microsoft.Windows.Apps.Test.Foundation.Patterns.ISelection`1 {
    public UICollection`1<I> Selection { get; }
    public bool CanSelectMultiple { get; }
    public bool IsSelectionRequired { get; }
    public abstract virtual UICollection`1<I> get_Selection();
    public abstract virtual bool get_CanSelectMultiple();
    public abstract virtual bool get_IsSelectionRequired();
}
public interface Microsoft.Windows.Apps.Test.Foundation.Patterns.ISelectionItem`1 {
    public bool IsSelected { get; }
    public C SelectionContainer { get; }
    public abstract virtual void Select();
    public abstract virtual UIEventWaiter GetSelectedWaiter();
    public abstract virtual void AddToSelection();
    public abstract virtual UIEventWaiter GetAddedToSelectionWaiter();
    public abstract virtual void RemoveFromSelection();
    public abstract virtual UIEventWaiter GetRemovedFromSelectionWaiter();
    public abstract virtual bool get_IsSelected();
    public abstract virtual C get_SelectionContainer();
}
public interface Microsoft.Windows.Apps.Test.Foundation.Patterns.ITable`1 {
    public UICollection`1<UIObject> RowHeaders { get; }
    public UICollection`1<UIObject> ColumnHeaders { get; }
    public RowOrColumnMajor RowOrColumnMajor { get; }
    public abstract virtual UICollection`1<UIObject> get_RowHeaders();
    public abstract virtual UICollection`1<UIObject> get_ColumnHeaders();
    public abstract virtual RowOrColumnMajor get_RowOrColumnMajor();
}
public interface Microsoft.Windows.Apps.Test.Foundation.Patterns.ITableItem`1 {
    public UICollection`1<UIObject> RowHeaderItems { get; }
    public UICollection`1<UIObject> ColumnHeaderItems { get; }
    public abstract virtual UICollection`1<UIObject> get_RowHeaderItems();
    public abstract virtual UICollection`1<UIObject> get_ColumnHeaderItems();
}
public class Microsoft.Windows.Apps.Test.Foundation.Patterns.ItemContainerImplementation : PatternImplementation`1<ItemContainerPattern> {
    public ItemContainerImplementation(UIObject uiObject);
    public sealed virtual UIObject FindItemByProperty(UIObject uiObject, UIProperty uiProperty, object value);
}
public interface Microsoft.Windows.Apps.Test.Foundation.Patterns.IText {
    public bool SupportsTextSelection { get; }
    public TextPatternRange DocumentRange { get; }
    public abstract virtual bool get_SupportsTextSelection();
    public abstract virtual TextPatternRange get_DocumentRange();
    public abstract virtual TextPatternRange GetSelection();
    public abstract virtual TextPatternRange RangeFromPoint(Point screenLocation);
    public abstract virtual TextPatternRange RangeFromChild(UIObject childElement);
    public abstract virtual TextPatternRange GetVisibleRange();
}
public interface Microsoft.Windows.Apps.Test.Foundation.Patterns.IText2 {
    public abstract virtual TextPatternRange RangeFromAnnotation(UIObject annotationElement);
    public abstract virtual TextPatternRange GetCaretRange(Int32& isActive);
}
public interface Microsoft.Windows.Apps.Test.Foundation.Patterns.IToggle {
    public ToggleState ToggleState { get; }
    public abstract virtual void Toggle();
    public abstract virtual ToggleState get_ToggleState();
    public abstract virtual UIEventWaiter GetToggledWaiter();
}
public interface Microsoft.Windows.Apps.Test.Foundation.Patterns.ITransform {
    public bool CanRotate { get; }
    public bool CanResize { get; }
    public bool CanMove { get; }
    public abstract virtual void Rotate(double degrees);
    public abstract virtual void Resize(double width, double height);
    public abstract virtual void Move(double x, double y);
    public abstract virtual bool get_CanRotate();
    public abstract virtual bool get_CanResize();
    public abstract virtual bool get_CanMove();
}
public interface Microsoft.Windows.Apps.Test.Foundation.Patterns.IValue {
    public string Value { get; }
    public bool IsReadOnly { get; }
    public abstract virtual void SetValue(string value);
    public abstract virtual string get_Value();
    public abstract virtual bool get_IsReadOnly();
}
public interface Microsoft.Windows.Apps.Test.Foundation.Patterns.IVirtualizedContainer`1 {
    public UICollection`1<I> AllItems { get; }
    public abstract virtual UICollection`1<I> get_AllItems();
}
public interface Microsoft.Windows.Apps.Test.Foundation.Patterns.IVirtualizedItem {
    public abstract virtual void Realize();
}
public interface Microsoft.Windows.Apps.Test.Foundation.Patterns.IWindow {
    public bool CanMaximize { get; }
    public bool CanMinimize { get; }
    public bool IsModal { get; }
    public WindowVisualState WindowVisualState { get; }
    public WindowInteractionState WindowInteractionState { get; }
    public bool IsTopmost { get; }
    public abstract virtual void SetWindowVisualState(WindowVisualState state);
    public abstract virtual void Close();
    public abstract virtual void WaitForInputIdle(int milliseconds);
    public abstract virtual UIEventWaiter GetWindowClosedWaiter();
    public abstract virtual bool get_CanMaximize();
    public abstract virtual bool get_CanMinimize();
    public abstract virtual bool get_IsModal();
    public abstract virtual WindowVisualState get_WindowVisualState();
    public abstract virtual WindowInteractionState get_WindowInteractionState();
    public abstract virtual bool get_IsTopmost();
}
public class Microsoft.Windows.Apps.Test.Foundation.Patterns.MultipleViewImplementation : PatternImplementation`1<MultipleViewPattern> {
    public int CurrentView { get; }
    public MultipleViewImplementation(UIObject uiObject);
    public sealed virtual string GetViewName(int viewId);
    public sealed virtual void SetCurrentView(int viewId);
    public sealed virtual Int32[] GetSupportedViews();
    public sealed virtual int get_CurrentView();
}
public class Microsoft.Windows.Apps.Test.Foundation.Patterns.PatternImplementation`1 : object {
    private AutomationPattern _patternIdentifier;
    private UIObject _uiObject;
    private P _pattern;
    public bool IsAvailable { get; }
    protected P Pattern { get; }
    protected UIObject UIObject { get; }
    public PatternImplementation`1(UIObject uiObject, AutomationPattern patternIdentifier);
    public bool get_IsAvailable();
    protected P get_Pattern();
    protected UIObject get_UIObject();
}
public class Microsoft.Windows.Apps.Test.Foundation.Patterns.RangeValueImplementation : PatternImplementation`1<RangeValuePattern> {
    public double Minimum { get; }
    public double Maximum { get; }
    public double LargeChange { get; }
    public double SmallChange { get; }
    public double Value { get; }
    public bool IsReadOnly { get; }
    public RangeValueImplementation(UIObject uiObject);
    public sealed virtual double get_Minimum();
    public sealed virtual double get_Maximum();
    public sealed virtual double get_LargeChange();
    public sealed virtual double get_SmallChange();
    public sealed virtual void SetValue(double value);
    public sealed virtual double get_Value();
    public sealed virtual bool get_IsReadOnly();
}
public class Microsoft.Windows.Apps.Test.Foundation.Patterns.ScrollImplementation : PatternImplementation`1<ScrollPattern> {
    public bool HorizontallyScrollable { get; }
    public bool VerticallyScrollable { get; }
    public double HorizontalScrollPercent { get; }
    public double VerticalScrollPercent { get; }
    public double HorizontalViewSize { get; }
    public double VerticalViewSize { get; }
    public ScrollImplementation(UIObject uiObject);
    public sealed virtual void Scroll(ScrollAmount horizontalAmount, ScrollAmount verticalAmount);
    public sealed virtual void ScrollHorizontal(ScrollAmount amount);
    public sealed virtual void ScrollVertical(ScrollAmount amount);
    public sealed virtual void SetScrollPercent(double horizontalPercent, double verticalPercent);
    public sealed virtual bool get_HorizontallyScrollable();
    public sealed virtual bool get_VerticallyScrollable();
    public sealed virtual double get_HorizontalScrollPercent();
    public sealed virtual double get_VerticalScrollPercent();
    public sealed virtual double get_HorizontalViewSize();
    public sealed virtual double get_VerticalViewSize();
}
public class Microsoft.Windows.Apps.Test.Foundation.Patterns.ScrollItemImplementation : PatternImplementation`1<ScrollItemPattern> {
    public ScrollItemImplementation(UIObject uiObject);
    public sealed virtual void ScrollIntoView();
}
public class Microsoft.Windows.Apps.Test.Foundation.Patterns.SelectionImplementation`1 : PatternImplementation`1<SelectionPattern> {
    private IFactory`1<I> _itemFactory;
    public UICollection`1<I> Selection { get; }
    public bool CanSelectMultiple { get; }
    public bool IsSelectionRequired { get; }
    protected IFactory`1<I> ItemFactory { get; protected set; }
    public SelectionImplementation`1(UIObject uiObject, IFactory`1<I> itemFactory);
    public sealed virtual UICollection`1<I> get_Selection();
    public sealed virtual bool get_CanSelectMultiple();
    public sealed virtual bool get_IsSelectionRequired();
    protected IFactory`1<I> get_ItemFactory();
    protected void set_ItemFactory(IFactory`1<I> value);
}
public class Microsoft.Windows.Apps.Test.Foundation.Patterns.SelectionItemImplementation`1 : PatternImplementation`1<SelectionItemPattern> {
    private IFactory`1<C> _containerFactory;
    public bool IsSelected { get; }
    public C SelectionContainer { get; }
    protected IFactory`1<C> ContainerFactory { get; protected set; }
    public SelectionItemImplementation`1(UIObject uiObject, IFactory`1<C> containerFactory);
    public sealed virtual void Select();
    public sealed virtual UIEventWaiter GetSelectedWaiter();
    public sealed virtual void AddToSelection();
    public sealed virtual UIEventWaiter GetAddedToSelectionWaiter();
    public sealed virtual void RemoveFromSelection();
    public sealed virtual UIEventWaiter GetRemovedFromSelectionWaiter();
    public sealed virtual bool get_IsSelected();
    public sealed virtual C get_SelectionContainer();
    protected IFactory`1<C> get_ContainerFactory();
    protected void set_ContainerFactory(IFactory`1<C> value);
}
public class Microsoft.Windows.Apps.Test.Foundation.Patterns.TableImplementation`1 : PatternImplementation`1<TablePattern> {
    private IFactory`1<I> _itemFactory;
    private GridImplementation`1<I> _grid;
    public UICollection`1<UIObject> RowHeaders { get; }
    public UICollection`1<UIObject> ColumnHeaders { get; }
    public RowOrColumnMajor RowOrColumnMajor { get; }
    public int RowCount { get; }
    public int ColumnCount { get; }
    public TableImplementation`1(UIObject uiObject, IFactory`1<I> itemFactory);
    public sealed virtual UICollection`1<UIObject> get_RowHeaders();
    public sealed virtual UICollection`1<UIObject> get_ColumnHeaders();
    public sealed virtual RowOrColumnMajor get_RowOrColumnMajor();
    public sealed virtual I GetCell(int row, int column);
    public sealed virtual int get_RowCount();
    public sealed virtual int get_ColumnCount();
}
public class Microsoft.Windows.Apps.Test.Foundation.Patterns.TableItemImplementation`1 : PatternImplementation`1<TableItemPattern> {
    private IFactory`1<C> _containerFactory;
    private GridItemImplementation`1<C> _gridItem;
    public UICollection`1<UIObject> RowHeaderItems { get; }
    public UICollection`1<UIObject> ColumnHeaderItems { get; }
    public C ContainingGrid { get; }
    public int Row { get; }
    public int Column { get; }
    public int RowSpan { get; }
    public int ColumnSpan { get; }
    public TableItemImplementation`1(UIObject uiObject, IFactory`1<C> containerFactory);
    public sealed virtual UICollection`1<UIObject> get_RowHeaderItems();
    public sealed virtual UICollection`1<UIObject> get_ColumnHeaderItems();
    public sealed virtual C get_ContainingGrid();
    public sealed virtual int get_Row();
    public sealed virtual int get_Column();
    public sealed virtual int get_RowSpan();
    public sealed virtual int get_ColumnSpan();
}
public class Microsoft.Windows.Apps.Test.Foundation.Patterns.TextImplementation : PatternImplementation`1<TextPattern> {
    public bool SupportsTextSelection { get; }
    public TextPatternRange DocumentRange { get; }
    public TextImplementation(UIObject uiObject);
    public sealed virtual bool get_SupportsTextSelection();
    public sealed virtual TextPatternRange get_DocumentRange();
    public sealed virtual TextPatternRange GetSelection();
    public sealed virtual TextPatternRange RangeFromPoint(Point screenLocation);
    public sealed virtual TextPatternRange RangeFromChild(UIObject childElement);
    public sealed virtual TextPatternRange GetVisibleRange();
}
public class Microsoft.Windows.Apps.Test.Foundation.Patterns.TextImplementation2 : PatternImplementation`1<TextPattern2> {
    private TextImplementation _textImplementation;
    public bool SupportsTextSelection { get; }
    public TextPatternRange DocumentRange { get; }
    public TextImplementation2(UIObject uiObject);
    public sealed virtual bool get_SupportsTextSelection();
    public sealed virtual TextPatternRange get_DocumentRange();
    public sealed virtual TextPatternRange GetSelection();
    public sealed virtual TextPatternRange RangeFromPoint(Point screenLocation);
    public sealed virtual TextPatternRange RangeFromChild(UIObject childElement);
    public sealed virtual TextPatternRange GetVisibleRange();
    public sealed virtual TextPatternRange RangeFromAnnotation(UIObject annotationElement);
    public sealed virtual TextPatternRange GetCaretRange(Int32& isActive);
}
public class Microsoft.Windows.Apps.Test.Foundation.Patterns.ToggleImplementation : PatternImplementation`1<TogglePattern> {
    public ToggleState ToggleState { get; }
    public ToggleImplementation(UIObject uiObject);
    public sealed virtual UIEventWaiter GetToggledWaiter();
    public sealed virtual void Toggle();
    public sealed virtual ToggleState get_ToggleState();
}
public class Microsoft.Windows.Apps.Test.Foundation.Patterns.TransformImplementation : PatternImplementation`1<TransformPattern> {
    public bool CanRotate { get; }
    public bool CanResize { get; }
    public bool CanMove { get; }
    public TransformImplementation(UIObject uiObject);
    public sealed virtual void Rotate(double degrees);
    public sealed virtual void Resize(double width, double height);
    public sealed virtual void Move(double x, double y);
    public sealed virtual bool get_CanRotate();
    public sealed virtual bool get_CanResize();
    public sealed virtual bool get_CanMove();
}
public class Microsoft.Windows.Apps.Test.Foundation.Patterns.ValueImplementation : PatternImplementation`1<ValuePattern> {
    public string Value { get; }
    public bool IsReadOnly { get; }
    public ValueImplementation(UIObject uiObject);
    public sealed virtual void SetValue(string value);
    public sealed virtual string get_Value();
    public sealed virtual bool get_IsReadOnly();
}
public class Microsoft.Windows.Apps.Test.Foundation.Patterns.VirtualizedItemImplementation : PatternImplementation`1<VirtualizedItemPattern> {
    public VirtualizedItemImplementation(UIObject uiObject);
    public sealed virtual void Realize();
}
public class Microsoft.Windows.Apps.Test.Foundation.Patterns.WindowImplementation : PatternImplementation`1<WindowPattern> {
    public bool CanMaximize { get; }
    public bool CanMinimize { get; }
    public bool IsModal { get; }
    public WindowVisualState WindowVisualState { get; }
    public WindowInteractionState WindowInteractionState { get; }
    public bool IsTopmost { get; }
    public WindowImplementation(UIObject uiObject);
    public sealed virtual void SetWindowVisualState(WindowVisualState state);
    public sealed virtual void Close();
    public sealed virtual void WaitForInputIdle(int milliseconds);
    public sealed virtual UIEventWaiter GetWindowClosedWaiter();
    public sealed virtual bool get_CanMaximize();
    public sealed virtual bool get_CanMinimize();
    public sealed virtual bool get_IsModal();
    public sealed virtual WindowVisualState get_WindowVisualState();
    public sealed virtual WindowInteractionState get_WindowInteractionState();
    public sealed virtual bool get_IsTopmost();
}
internal class Microsoft.Windows.Apps.Test.Foundation.Pen : object {
    private static object _classLock;
    private static Pen _singletonInstance;
    private IInputManager _inputManager;
    private Point _location;
    private UInt32 DefaultContactId;
    private bool _disposed;
    public static Pen Instance { get; }
    public Point Location { get; }
    private static Pen();
    protected virtual override void Finalize();
    public static Pen get_Instance();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    public sealed virtual void Flick(Point endPoint, UInt32 holdDuration, float acceleration);
    public sealed virtual void Pan(Point endPoint, UInt32 holdDuration, float acceleration);
    public sealed virtual void PressAndDrag(Point endPoint, UInt32 dragDuration);
    public sealed virtual void PressAndDrag(Point endPoint, UInt32 dragDuration, UInt32 pressDuration);
    public sealed virtual void PressAndHold(UInt32 holdDuration);
    public sealed virtual void Click(PointerButtons button, int count);
    public sealed virtual void ClickDrag(Point endPoint, PointerButtons button, UInt32 dragDuration);
    public sealed virtual void Move(Point point);
    public sealed virtual void Press(PointerButtons button);
    public sealed virtual void Release(PointerButtons button);
    public sealed virtual Point get_Location();
}
[FlagsAttribute]
internal enum Microsoft.Windows.Apps.Test.Foundation.POINTER_FLAGS : Enum {
    public UInt32 value__;
    public static POINTER_FLAGS NONE;
    public static POINTER_FLAGS NEW;
    public static POINTER_FLAGS INRANGE;
    public static POINTER_FLAGS INCONTACT;
    public static POINTER_FLAGS FIRSTBUTTON;
    public static POINTER_FLAGS SECONDBUTTON;
    public static POINTER_FLAGS THIRDBUTTON;
    public static POINTER_FLAGS FOURTHBUTTON;
    public static POINTER_FLAGS FIFTHBUTTON;
    public static POINTER_FLAGS PRIMARY;
    public static POINTER_FLAGS CONFIDENCE;
    public static POINTER_FLAGS CANCELED;
    public static POINTER_FLAGS DOWN;
    public static POINTER_FLAGS UPDATE;
    public static POINTER_FLAGS UP;
    public static POINTER_FLAGS WHEEL;
    public static POINTER_FLAGS HWHEEL;
    public static POINTER_FLAGS CAPTURECHANGED;
    public static POINTER_FLAGS HASTRANSFORM;
    public static POINTER_FLAGS HoverStartsOrMoves;
    public static POINTER_FLAGS ContactDown;
    public static POINTER_FLAGS ContactMoves;
    public static POINTER_FLAGS ContactUpToHover;
    public static POINTER_FLAGS HoverEnds;
    public static POINTER_FLAGS End;
}
internal enum Microsoft.Windows.Apps.Test.Foundation.POINTER_INPUT_TYPE : Enum {
    public UInt32 value__;
    public static POINTER_INPUT_TYPE NONE;
    public static POINTER_INPUT_TYPE POINTER;
    public static POINTER_INPUT_TYPE TOUCH;
    public static POINTER_INPUT_TYPE PEN;
    public static POINTER_INPUT_TYPE MOUSE;
    public static POINTER_INPUT_TYPE TOUCHPAD;
}
[FlagsAttribute]
public enum Microsoft.Windows.Apps.Test.Foundation.PointerButtons : Enum {
    public int value__;
    public static PointerButtons None;
    public static PointerButtons Primary;
    public static PointerButtons Secondary;
    public static PointerButtons PhysicalLeft;
    public static PointerButtons PhysicalRight;
    public static PointerButtons Middle;
    public static PointerButtons XButton1;
    public static PointerButtons XButton2;
}
internal class Microsoft.Windows.Apps.Test.Foundation.PointerData : ValueType {
    public POINTER_FLAGS flags;
    public Point location;
    public UInt32 pointerId;
    public virtual string ToString();
}
public static class Microsoft.Windows.Apps.Test.Foundation.PointerInput : object {
    public static UInt32 DefaultDragDuration;
    private static Stack`1<IPointerInput> _pointerInputStack;
    public static Point Location { get; }
    public static IPointerInput Current { get; }
    private static PointerInput();
    public static void Click(PointerButtons button, int count);
    public static void ClickDrag(Point endPoint, PointerButtons button, UInt32 dragDuration);
    public static void Move(Point point);
    public static void Press(PointerButtons button);
    public static void Release(PointerButtons button);
    public static Point get_Location();
    public static void Click(UIObject uiObject);
    public static void Click(UIObject uiObject, PointerButtons button);
    public static void Click(UIObject uiObject, PointerButtons button, double offsetX, double offsetY);
    public static void DoubleClick(UIObject uiObject);
    public static void DoubleClick(UIObject uiObject, PointerButtons button);
    public static void DoubleClick(UIObject uiObject, PointerButtons button, double offsetX, double offsetY);
    public static void ClickDrag(UIObject targetObject, UIObject destinationObject);
    public static void ClickDrag(UIObject targetObject, UIObject destinationObject, PointerButtons button);
    public static void Move(UIObject uiObject);
    public static void Move(UIObject uiObject, double offsetX, double offsetY);
    public static IDisposable Activate(IPointerInput pointer);
    public static IPointerInput get_Current();
    private static void ClickImplementation(UIObject uiObject, PointerButtons button, UInt32 numClicks, double offsetX, double offsetY);
    private static void ClickImplementation(UIObject uiObject, PointerButtons button, UInt32 numClicks);
}
internal class Microsoft.Windows.Apps.Test.Foundation.PointerInputAction : object {
    public PointerData pointerData;
    public sealed virtual void Execute(IRIMPointerInput rim, int elapsedMs);
}
public enum Microsoft.Windows.Apps.Test.Foundation.PointerInputType : Enum {
    public int value__;
    public static PointerInputType None;
    public static PointerInputType Mouse;
    public static PointerInputType Pen;
    public static PointerInputType SingleTouch;
    public static PointerInputType MultiTouch;
}
internal class Microsoft.Windows.Apps.Test.Foundation.QueryLanguage.AndExpression : Expression {
    private Expression _leftExpression;
    private Expression _rightExpression;
    public AndExpression(Expression leftExpression, Expression rightExpression);
    public virtual GlobalizableCondition GetCondition();
    public virtual bool Validate(StringBuilder errors);
}
internal class Microsoft.Windows.Apps.Test.Foundation.QueryLanguage.BooleanLiteralExpression : Expression {
    private bool _value;
    public BooleanLiteralExpression(bool value);
    public virtual GlobalizableCondition GetCondition();
    public virtual bool Validate(StringBuilder errors);
}
internal class Microsoft.Windows.Apps.Test.Foundation.QueryLanguage.BooleanValue : Value {
    private bool _booleanValue;
    public BooleanValue(bool value);
    public virtual bool Validate(Type requiredType, StringBuilder errors);
    public virtual object GetValueObject(Type requiredType);
}
internal class Microsoft.Windows.Apps.Test.Foundation.QueryLanguage.ConditionLexClass : SSLex {
    public static int ConditionLexExprMain;
    public static int ConditionLexTokenIndentifier;
    public static int ConditionLexTokenOr;
    public static int ConditionLexTokenAnd;
    public static int ConditionLexTokenNot;
    public static int ConditionLexTokenOParen;
    public static int ConditionLexTokenCParen;
    public static int ConditionLexTokenOCurly;
    public static int ConditionLexTokenCCurly;
    public static int ConditionLexTokenEqual;
    public static int ConditionLexTokenMinus;
    public static int ConditionLexTokenPlus;
    public static int ConditionLexTokenDot;
    public static int ConditionLexTokenAt;
    public static int ConditionLexTokenString;
    public static int ConditionLexTokenInteger;
    public static int ConditionLexTokenDouble;
    public static int ConditionLexTokenFalse;
    public static int ConditionLexTokenTrue;
    public ConditionLexClass(SSLexTable q_table, SSLexConsumer q_consumer);
    public string tokenToString(int q_token);
    public virtual bool error(SSLexLexeme q_lexeme);
}
internal class Microsoft.Windows.Apps.Test.Foundation.QueryLanguage.ConditionLexTable : SSLexTable {
    private Int32[] m_rows0;
    private Int32[] m_finalStates0;
}
internal class Microsoft.Windows.Apps.Test.Foundation.QueryLanguage.ConditionYaccClass : SSYacc {
    public static int ConditionYaccProdStart;
    public static int ConditionYaccProdExprNot;
    public static int ConditionYaccProdExprAnd;
    public static int ConditionYaccProdExprOr;
    public static int ConditionYaccProdExprNested;
    public static int ConditionYaccProdExprTrue;
    public static int ConditionYaccProdExprFalse;
    public static int ConditionYaccProdExprEqualsLeft;
    public static int ConditionYaccProdExprEqualsRight;
    public static int ConditionYaccProdPropertySimple;
    public static int ConditionYaccProdPropertyQualified;
    public static int ConditionYaccProdValueObject;
    public static int ConditionYaccProdValueString;
    public static int ConditionYaccProdValueTrue;
    public static int ConditionYaccProdValueFalse;
    public static int ConditionYaccProdValueControlType;
    public static int ConditionYaccProdValueNumber;
    public static int ConditionYaccProdNumberNegative;
    public static int ConditionYaccProdNumberPositive;
    public static int ConditionYaccProdValueInteger;
    public static int ConditionYaccProdValueDouble;
    private Object[] parameterObjects;
    private string m_Error;
    public string Error { get; }
    public ConditionYaccClass(SSYaccTable q_table, SSLex q_lex, Object[] parameterObjects);
    public virtual SSYaccStackElement reduce(int q_prod, int q_size);
    public virtual bool error(int q_state, SSLexLexeme q_look);
    public string get_Error();
}
internal class Microsoft.Windows.Apps.Test.Foundation.QueryLanguage.ConditionYaccTable : SSYaccTable {
    private Int32[] m_prodData;
    private Int32[] m_rowData;
}
internal class Microsoft.Windows.Apps.Test.Foundation.QueryLanguage.DoubleValue : Number {
    private string _lexeme;
    private bool _negative;
    public DoubleValue(string lexeme);
    public virtual bool Validate(Type requiredType, StringBuilder errors);
    public virtual object GetValueObject(Type requiredType);
    public virtual void Negate();
}
internal abstract class Microsoft.Windows.Apps.Test.Foundation.QueryLanguage.Expression : SSYaccStackElement {
    public abstract virtual GlobalizableCondition GetCondition();
    public abstract virtual bool Validate(StringBuilder errors);
}
internal class Microsoft.Windows.Apps.Test.Foundation.QueryLanguage.IdentifierValue : Value {
    private string _identifierName;
    public IdentifierValue(string lexeme);
    public virtual bool Validate(Type requiredType, StringBuilder errors);
    public virtual object GetValueObject(Type requiredType);
}
internal class Microsoft.Windows.Apps.Test.Foundation.QueryLanguage.IntegerValue : Number {
    private string _lexeme;
    private bool _negative;
    public IntegerValue(string lexeme);
    public virtual bool Validate(Type requiredType, StringBuilder errors);
    public virtual object GetValueObject(Type requiredType);
    public virtual void Negate();
    private int Parse();
}
internal class Microsoft.Windows.Apps.Test.Foundation.QueryLanguage.NotExpression : Expression {
    private Expression _expression;
    public NotExpression(Expression expression);
    public virtual GlobalizableCondition GetCondition();
    public virtual bool Validate(StringBuilder errors);
}
internal abstract class Microsoft.Windows.Apps.Test.Foundation.QueryLanguage.Number : Value {
    public abstract virtual void Negate();
}
internal class Microsoft.Windows.Apps.Test.Foundation.QueryLanguage.ObjectValue : Value {
    private Object[] _parameterObjects;
    private int _index;
    public ObjectValue(string lexeme, Object[] parameterObjects);
    public virtual bool Validate(Type requiredType, StringBuilder errors);
    public virtual object GetValueObject(Type requiredType);
}
internal class Microsoft.Windows.Apps.Test.Foundation.QueryLanguage.OrExpression : Expression {
    private Expression _leftExpression;
    private Expression _rightExpression;
    public OrExpression(Expression leftExpression, Expression rightExpression);
    public virtual GlobalizableCondition GetCondition();
    public virtual bool Validate(StringBuilder errors);
}
internal class Microsoft.Windows.Apps.Test.Foundation.QueryLanguage.PropertyExpression : Expression {
    private PropertyName _propertyName;
    private Value _propertyValue;
    public PropertyExpression(PropertyName propertyName, Value propertyValue);
    public virtual GlobalizableCondition GetCondition();
    public virtual bool Validate(StringBuilder errors);
}
internal class Microsoft.Windows.Apps.Test.Foundation.QueryLanguage.PropertyName : SSYaccStackElement {
    private string _propertyName;
    public PropertyName(string lexeme);
    public PropertyName(string patternName, string propertyName);
    public UIProperty GetUIProperty();
    public bool Validate(StringBuilder errors);
}
internal class Microsoft.Windows.Apps.Test.Foundation.QueryLanguage.SSVParseLib.SSLex : object {
    public int m_state;
    public Char[] m_currentChar;
    public SSLexTable m_table;
    public SSLexConsumer m_consumer;
    public SSLex(SSLexTable q_table, SSLexConsumer q_consumer);
    public SSLexTable table();
    public SSLexConsumer consumer();
    public virtual bool error(SSLexLexeme q_lexeme);
    public virtual bool complete(SSLexLexeme q_lexeme);
    public SSLexLexeme next();
}
internal class Microsoft.Windows.Apps.Test.Foundation.QueryLanguage.SSVParseLib.SSLexCharacterClass : object {
    public int m_size;
    public int m_min;
    public int m_max;
    public Int32[] m_array;
    public SSLexCharacterClass(int q_size, int q_min, int q_max, Int32[] q_array);
    public SSLexCharacterClass(Int32[] q_array);
    public bool translate(Char[] q_char);
}
internal abstract class Microsoft.Windows.Apps.Test.Foundation.QueryLanguage.SSVParseLib.SSLexConsumer : object {
    public int m_line;
    public int m_start;
    public int m_index;
    public int m_offset;
    public char m_current;
    public int m_length;
    public int m_consumed;
    public int m_scanLine;
    public int m_scanOffset;
    public int m_bufferIndex;
    public char m_bof;
    public bool m_endOfData;
    public Char[] m_buffer;
    public abstract virtual bool getNext();
    public bool next();
    public int line();
    public int offset();
    public char getCurrent();
    public int absoluteOffset();
    public SSLexMark mark();
    public void flushEndOfLine(SSLexMark q_mark);
    public void flushStartOfLine(SSLexMark q_mark);
    public virtual void flushLexeme(SSLexMark q_mark);
    public void flushLexeme();
    public int lexemeLength();
    public int lexemeLength(SSLexMark q_mark);
    public Char[] lexemeBuffer();
    public Char[] lexemeBuffer(SSLexMark q_mark);
}
internal class Microsoft.Windows.Apps.Test.Foundation.QueryLanguage.SSVParseLib.SSLexDfaTableHeader : object {
    public int type;
    public int size;
    public Int32[] reserved;
}
internal class Microsoft.Windows.Apps.Test.Foundation.QueryLanguage.SSVParseLib.SSLexFileConsumer : SSLexConsumer {
    public bool m_first;
    public bool m_unicode;
    public bool m_reversedUnicode;
    public FileStream m_fileStream;
    public SSLexFileConsumer(string q_name, bool q_unicode);
    public bool readByte();
    public bool readUnicodeByte();
    public virtual bool getNext();
    public virtual void flushLexeme(SSLexMark q_mark);
}
internal class Microsoft.Windows.Apps.Test.Foundation.QueryLanguage.SSVParseLib.SSLexFinalState : object {
    public static int m_flagContextStart;
    public static int m_flagStartOfLine;
    public static int m_flagPop;
    public static int m_flagFinal;
    public static int m_flagPush;
    public static int m_flagIgnore;
    public static int m_flagContextEnd;
    public static int m_flagReduce;
    public static int m_flagKeyword;
    public static int m_flagParseToken;
    public int m_flags;
    public int m_token;
    public int m_pushIndex;
    public SSLexFinalState(Int32[] q_final, int q_index);
    private static SSLexFinalState();
    public int token();
    public int pushIndex();
    public bool isPop();
    public bool isPush();
    public bool isFinal();
    public bool isIgnore();
    public bool isReduce();
    public bool isContextEnd();
    public bool isStartOfLine();
    public bool isContextStart();
    public bool isKeyword();
    public bool isParseToken();
}
internal class Microsoft.Windows.Apps.Test.Foundation.QueryLanguage.SSVParseLib.SSLexKeyTable : object {
    public Int32[] m_index;
    public String[] m_keys;
    public SSLexKeyTable(Int32[] q_index, String[] q_keys);
}
internal class Microsoft.Windows.Apps.Test.Foundation.QueryLanguage.SSVParseLib.SSLexLexeme : object {
    public int m_line;
    public int m_token;
    public int m_length;
    public int m_offset;
    public int m_parseToken;
    public Char[] m_lexeme;
    public SSLexLexeme(string q_lexeme, int q_token);
    public SSLexLexeme(SSLexConsumer q_consumer);
    public SSLexLexeme(SSLexConsumer q_consumer, SSLexFinalState q_final, SSLexMark q_mark);
    public int line();
    public int token();
    public int offset();
    public int length();
    public int parseToken();
    public Char[] lexeme();
    public void setLine(int q_line);
    public void setToken(int q_token);
    public void setOffset(int q_offset);
    public void setLength(int q_length);
    public void setparseToken(int q_parseToken);
    public void setLexeme(Char[] q_lexeme);
}
internal class Microsoft.Windows.Apps.Test.Foundation.QueryLanguage.SSVParseLib.SSLexMark : object {
    public int m_line;
    public int m_index;
    public int m_offset;
    public SSLexMark(int q_line, int q_offset, int q_index);
    public int index();
}
internal class Microsoft.Windows.Apps.Test.Foundation.QueryLanguage.SSVParseLib.SSLexStringConsumer : SSLexConsumer {
    public Char[] m_string;
    public SSLexStringConsumer(string q_string);
    public virtual bool getNext();
}
internal class Microsoft.Windows.Apps.Test.Foundation.QueryLanguage.SSVParseLib.SSLexSubtable : object {
    public int m_size;
    public SSLexTableRow[] m_rows;
    public SSLexFinalState[] m_final;
    public static int SSLexStateInvalid;
    public SSLexSubtable(int q_numRows, Int32[] q_rows, Int32[] q_final);
    public int lookup(int q_state, int q_next);
    public SSLexFinalState lookupFinal(int q_state);
}
internal class Microsoft.Windows.Apps.Test.Foundation.QueryLanguage.SSVParseLib.SSLexTable : object {
    public int SSLexTableHeaderSize;
    public int SSLexDfaTableHeaderSize;
    public int SSLexDfaKeywordTableHeaderSize;
    public int SSLexDfaClassTableHeaderSize;
    public int SSLexDfaClassTableEntryHeaderSize;
    public Stack`1<object> m_stack;
    public int m_classes;
    public int m_classMin;
    public int m_classMax;
    public SSLexSubtable[] m_subTables;
    public SSLexKeyTable[] m_keyTables;
    public SSLexCharacterClass[] m_charClassTables;
    public static int SSLexStateInvalid;
    public SSLexTable(string q_file);
    public bool translateClass(Char[] q_char);
    public int convertInt(Byte[] b, int offset);
    public void findKeyword(SSLexLexeme z_lexeme);
    public void gotoSubtable(int q_index);
    public void pushSubtable(int q_index);
    public void popSubtable();
    public int lookup(int q_state, int q_next);
    public SSLexFinalState lookupFinal(int q_state);
}
internal class Microsoft.Windows.Apps.Test.Foundation.QueryLanguage.SSVParseLib.SSLexTableHeader : object {
    public int size;
    public int type;
    public Int32[] reserved;
}
internal class Microsoft.Windows.Apps.Test.Foundation.QueryLanguage.SSVParseLib.SSLexTableRow : object {
    public int m_size;
    public SSLexTableRowEntry[] m_entries;
    public SSLexTableRow(Int32[] q_row, int q_index);
    public int lookup(int q_code);
}
internal class Microsoft.Windows.Apps.Test.Foundation.QueryLanguage.SSVParseLib.SSLexTableRowEntry : object {
    public int m_end;
    public int m_start;
    public int m_state;
    public SSLexTableRowEntry(int q_start, int q_end, int q_state);
    public int end();
    public int start();
    public int state();
}
internal class Microsoft.Windows.Apps.Test.Foundation.QueryLanguage.SSVParseLib.SSYacc : object {
    public static int SSYaccActionShift;
    public static int SSYaccActionError;
    public static int SSYaccActionReduce;
    public static int SSYaccActionAccept;
    public static int SSYaccActionConflict;
    public int m_cache;
    public int m_state;
    public SSLex m_lex;
    public int m_action;
    public int m_leftside;
    public bool m_error;
    public bool m_abort;
    public int m_production;
    public SSYaccStack m_stack;
    public SSYaccTable m_table;
    public int m_productionSize;
    public bool m_endOfInput;
    public SSLexLexeme m_endLexeme;
    public SSLexLexeme m_lookahead;
    public SSLexLexeme m_larLookahead;
    public SSLexSubtable m_lexSubtable;
    public SSYaccStackElement m_element;
    public SSYaccStackElement m_treeRoot;
    public SSYaccCache m_lexemeCache;
    public static int m_eofToken;
    public static int m_errorToken;
    public static int SSYaccLexemeCacheMax;
    public SSYacc(SSYaccTable q_table, SSLex q_lex);
    public virtual SSYaccStackElement reduce(int q_prod, int q_length);
    public virtual SSLexLexeme nextLexeme();
    public virtual SSYaccStackElement stackElement();
    public virtual SSYaccStackElement shift(SSLexLexeme q_lexeme);
    public bool larLookahead(SSLexLexeme q_lex);
    public virtual bool error(int q_state, SSLexLexeme q_look);
    public bool larError(int q_state, SSLexLexeme q_look, SSLexLexeme q_larLook);
    public bool parse();
    public bool doShift();
    public bool doReduce();
    public bool doError();
    public bool doLarError();
    public SSLexLexeme getLexemeCache();
    public bool doConflict();
    public bool doGetLexeme(bool q_look);
    public bool getLexeme(bool q_look);
    public bool goTo(int q_goto);
    public bool syncErr();
    public void lookupAction(int q_state, int q_token);
    public bool lookupGoto(int q_state, int q_token);
    public bool push();
    public bool push(SSYaccStackElement q_element);
    public bool pop(int q_pop);
    public SSYaccStackElement elementFromProduction(int q_index);
    public void setAbort();
    public bool wasAborted();
    public bool wasError();
    public SSYaccStackElement addSubTree();
    public SSYaccStackElement treeRoot();
}
internal class Microsoft.Windows.Apps.Test.Foundation.QueryLanguage.SSVParseLib.SSYaccCache : Queue`1<object> {
    public bool hasElements();
    public SSLexLexeme remove();
}
internal class Microsoft.Windows.Apps.Test.Foundation.QueryLanguage.SSVParseLib.SSYaccSet : Queue`1<object> {
    public bool add(object q_object);
    public bool locate(int q_locate);
}
internal class Microsoft.Windows.Apps.Test.Foundation.QueryLanguage.SSVParseLib.SSYaccStack : List`1<object> {
    public int m_size;
    public SSYaccStack(int q_size, int q_inc);
    public void push(object q_ele);
    public void pop();
    public object elementAt(int index);
    public int getSize();
    public object peek();
}
internal class Microsoft.Windows.Apps.Test.Foundation.QueryLanguage.SSVParseLib.SSYaccStackElement : object {
    public int m_state;
    public int m_subTreeSize;
    public SSLexLexeme m_lexeme;
    public SSYaccStackElement[] m_subTree;
    public int state();
    public SSLexLexeme lexeme();
    public void setState(int q_state);
    public void setLexeme(SSLexLexeme q_lexeme);
    public void createSubTree(int q_size);
    public bool addSubTree(int q_index, SSYaccStackElement q_ele);
    public SSYaccStackElement getSubTree(int q_index);
    public int getSubTreeSize();
}
internal class Microsoft.Windows.Apps.Test.Foundation.QueryLanguage.SSVParseLib.SSYaccTable : object {
    public int SSYaccTableHeaderSize;
    public int SSYaccTableEntrySize;
    public int SSYaccTableRowSize;
    public SSYaccTableRow[] m_rows;
    public SSYaccTableProd[] m_prods;
    public SSYaccTable(string q_file);
    public int convertInt(Byte[] b, int offset);
    public SSYaccTableRow lookupRow(int q_state);
    public SSYaccTableProd lookupProd(int q_index);
    public SSLexSubtable larTable(int q_entry);
}
internal class Microsoft.Windows.Apps.Test.Foundation.QueryLanguage.SSVParseLib.SSYaccTableHeader : object {
    public int type;
    public int prodOrLar;
    public int numRows;
    public int rowOffset;
    public int prodOffset;
    public int numLars();
    public int numProds();
}
internal class Microsoft.Windows.Apps.Test.Foundation.QueryLanguage.SSVParseLib.SSYaccTableProd : object {
    public int m_size;
    public int m_leftside;
    public SSYaccTableProd(int q_size, int q_leftside);
    public int size();
    public int leftside();
}
internal class Microsoft.Windows.Apps.Test.Foundation.QueryLanguage.SSVParseLib.SSYaccTableRow : object {
    public int SSYaccTableEntrySize;
    public int SSYaccTableRowFlagSync;
    public int SSYaccTableRowFlagError;
    public int SSYaccTableRowFlagSyncAll;
    public int m_goto;
    public int m_action;
    public bool m_sync;
    public bool m_error;
    public bool m_syncAll;
    public SSYaccTableRowEntry[] m_entries;
    public SSYaccTableRow(Int32[] q_data, int q_index);
    public SSYaccTableRow(int q_flags, int q_goto, int q_action, Byte[] q_b, int q_index);
    public int convertInt(Byte[] b, int offset);
    public SSYaccTableRowEntry lookupEntry(int q_index);
    public SSYaccTableRowEntry lookupAction(int q_index);
    public SSYaccTableRowEntry lookupGoto(int q_index);
    public SSYaccTableRowEntry lookupError();
    public bool hasError();
    public bool hasSync();
    public bool hasSyncAll();
    public int action();
    public int numEntries();
}
internal class Microsoft.Windows.Apps.Test.Foundation.QueryLanguage.SSVParseLib.SSYaccTableRowEntry : object {
    public static int SSYaccActionShift;
    public static int SSYaccActionError;
    public static int SSYaccActionReduce;
    public static int SSYaccActionAccept;
    public static int SSYaccActionConflict;
    public static UInt32 SSYaccTableEntryFlagSync;
    public static int SSYaccTableEntryFlagShift;
    public static int SSYaccTableEntryFlagReduce;
    public static int SSYaccTableEntryFlagAccept;
    public static int SSYaccTableEntryFlagConflict;
    public static UInt32 SSYaccTableEntryFlagMask;
    public int m_token;
    public int m_entry;
    public int m_action;
    public bool m_sync;
    public SSYaccTableRowEntry(int q_token, int q_entry, int q_action, int q_sync);
    public SSYaccTableRowEntry(int q_entry, int q_token);
    public int action();
    public int entry();
    public int token();
    public bool hasSync();
}
internal class Microsoft.Windows.Apps.Test.Foundation.QueryLanguage.StringValue : Value {
    private string _stringValue;
    public StringValue(string lexeme);
    public virtual bool Validate(Type requiredType, StringBuilder errors);
    public virtual object GetValueObject(Type requiredType);
}
internal static class Microsoft.Windows.Apps.Test.Foundation.QueryLanguage.UIQuery : object {
    private static ConditionLexTable _lexTable;
    private static ConditionYaccTable _yaccTable;
    private static UIQuery();
    public static GlobalizableCondition Parse(string query, Object[] objects);
    public static string Validate(string query, Object[] objects);
    private static Expression GetExpression(string query, StringBuilder errors, Object[] parameterObjects);
}
internal abstract class Microsoft.Windows.Apps.Test.Foundation.QueryLanguage.Value : SSYaccStackElement {
    public abstract virtual bool Validate(Type requiredType, StringBuilder errors);
    public abstract virtual object GetValueObject(Type requiredType);
}
internal class Microsoft.Windows.Apps.Test.Foundation.RelativeWaitInputAction : object {
    public int start;
    public int duration;
    public sealed virtual void Execute(IRIMPointerInput rim, int elapsedMs);
}
internal static class Microsoft.Windows.Apps.Test.Foundation.RIMNativeMethods : object {
    public static ushort INPUT_MOUSE;
    public static ushort INPUT_KEYBOARD;
    public static ushort XBUTTON1;
    public static ushort XBUTTON2;
    public static void InjectKeyboardInput(KeyboardInput keyboardInput);
    public static void InjectMouseInput(MouseInput mouseInput);
}
internal class Microsoft.Windows.Apps.Test.Foundation.RIMPointerInput : object {
    public static UInt32 MIN_PACKET_FREQUENCEY;
    private static UInt32 DEFAULT_TOUCH_COUNT;
    private static UInt32 DEFAULT_PEN_COUNT;
    private static UInt32 MAX_POINTER_COUNT;
    private POINTER_INPUT_TYPE inputType;
    private IntPtr device;
    private bool disposedValue;
    public RIMPointerInput(POINTER_INPUT_TYPE inputType);
    private void InitializeTouchInjection();
    private void InitializePenInjection();
    private void DestroySyntheticPointerDevice();
    public sealed virtual void InjectPointer(PointerData pointerData);
    public sealed virtual void InjectPointer(PointerData[] pointerData);
    private PointerTypeInfo TransformPointer(PointerData pointerData);
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
}
internal class Microsoft.Windows.Apps.Test.Foundation.RIMPointerInputFactory : object {
    public sealed virtual IRIMPointerInput Get(POINTER_INPUT_TYPE type);
}
public enum Microsoft.Windows.Apps.Test.Foundation.Scope : Enum {
    public int value__;
    public static Scope Ancestors;
    public static Scope Children;
    public static Scope Descendants;
    public static Scope Element;
    public static Scope Parent;
    public static Scope Subtree;
}
public static class Microsoft.Windows.Apps.Test.Foundation.SinglePointGesture : object {
    private static Stack`1<ISinglePointGestureInput> _gestureInputStack;
    public static float DefaultFlickAcceleration;
    public static float DefaultPanAcceleration;
    public static UInt32 DefaultDragDuration;
    public static UInt32 DefaultHoldDuration;
    private static int minimumPanFlickDistance;
    public static ISinglePointGestureInput Current { get; }
    public static int MinimumPanFlickDistance { get; }
    private static SinglePointGesture();
    public static void Flick(Point endPoint, UInt32 holdDuration, float acceleration);
    public static void Pan(Point endPoint, UInt32 holdDuration, float acceleration);
    public static void PressAndDrag(Point endPoint, UInt32 dragDuration);
    public static void PressAndDrag(Point endPoint, UInt32 dragDuration, UInt32 pressDuration);
    public static void PressAndHold(UInt32 holdDuration);
    public static void Flick(UIObject targetObject, UIObject destinationObject);
    public static void Flick(UIObject targetObject, UIObject destinationObject, float acceleration);
    public static void Flick(UIObject uiObject, float acceleration, UInt32 distance, float direction);
    public static void Pan(UIObject targetObject, UIObject destinationObject);
    public static void Pan(UIObject targetObject, UIObject destinationObject, float acceleration);
    public static void Pan(UIObject uiObject, float acceleration, UInt32 distance, float direction);
    public static void PressAndDrag(UIObject targetObject, UIObject destinationObject);
    public static void PressAndDrag(UIObject targetObject, UIObject destinationObject, UInt32 dragDuration, UInt32 pressDuration);
    public static void PressAndDrag(UIObject targetObject, UIObject destinationObject, UInt32 dragDuration);
    public static void PressAndDrag(UIObject uiObject, UInt32 distance, float direction);
    public static void PressAndHold(UIObject uiObject);
    public static void PressAndHold(UIObject uiObject, UInt32 holdDuration);
    public static IDisposable Activate(ISinglePointGestureInput pointer);
    public static ISinglePointGestureInput get_Current();
    public static int get_MinimumPanFlickDistance();
}
internal class Microsoft.Windows.Apps.Test.Foundation.SingleTouch : object {
    private static object _classLock;
    private static SingleTouch _singletonInstance;
    private IInputManager _inputManager;
    private Point _location;
    private UInt32 DefaultContactId;
    private bool _disposed;
    public static SingleTouch Instance { get; }
    public Point Location { get; }
    private static SingleTouch();
    protected virtual override void Finalize();
    public static SingleTouch get_Instance();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    public sealed virtual void Flick(Point endPoint, UInt32 holdDuration, float acceleration);
    public sealed virtual void Pan(Point endPoint, UInt32 holdDuration, float acceleration);
    public sealed virtual void PressAndDrag(Point endPoint, UInt32 dragDuration);
    public sealed virtual void PressAndDrag(Point endPoint, UInt32 dragDuration, UInt32 pressDuration);
    public sealed virtual void PressAndHold(UInt32 holdDuration);
    public sealed virtual void Click(PointerButtons button, int count);
    public sealed virtual void ClickDrag(Point endPoint, PointerButtons button, UInt32 dragDuration);
    public sealed virtual void Move(Point point);
    public sealed virtual void Press(PointerButtons button);
    public sealed virtual void Release(PointerButtons button);
    public sealed virtual Point get_Location();
}
internal static class Microsoft.Windows.Apps.Test.Foundation.StringResource : object {
    private static ResourceManager _resourceManager;
    internal static ResourceManager ResourceManager { get; }
    private static StringResource();
    internal static string Get(string id, Object[] args);
    internal static ResourceManager get_ResourceManager();
}
internal class Microsoft.Windows.Apps.Test.Foundation.SupportedProperties : object {
    private UIObject _uiObject;
    internal SupportedProperties(UIObject uiObject);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [IteratorStateMachineAttribute("Microsoft.Windows.Apps.Test.Foundation.SupportedProperties/<GetEnumerator>d__2")]
public sealed virtual IEnumerator`1<UIProperty> GetEnumerator();
}
public static class Microsoft.Windows.Apps.Test.Foundation.TextInput : object {
    private static Stack`1<ITextInput> _textInputStack;
    public static ITextInput Current { get; }
    private static TextInput();
    public static void SendText(string text);
    public static IDisposable Activate(ITextInput textInput);
    public static ITextInput get_Current();
}
internal class Microsoft.Windows.Apps.Test.Foundation.TimeManager : object {
    private static UInt32 NOERROR;
    private UInt32 timePeriod;
    private bool disposedValue;
    private UInt32 GetMinimumTimerResolution();
    private void BeginPeriod(UInt32 uPeriod);
    private void EndPeriod(UInt32 uPeriod);
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
}
internal class Microsoft.Windows.Apps.Test.Foundation.TimeManagerFactory : object {
    public sealed virtual ITimeManager Get();
}
public static class Microsoft.Windows.Apps.Test.Foundation.UAPApp : object {
    private static string SHELL_NAMESPACE_API_DLL;
    private static string SHELL_API_DLL;
    private static string ISHELLITEM_IID;
    private static string ISHELLITEMARRAY_IID;
    private static string SCALING_DLL;
    private static string NTUSERDPI_DLL;
    private static int S_OK;
    private static int E_INVALIDARG;
    private static int E_ACCESSDENIED;
    private static IntPtr DPI_AWARENESS_CONTEXT;
    private static IntPtr DPI_AWARENESS_CONTEXT_UNAWARE;
    private static IntPtr DPI_AWARENESS_CONTEXT_SYSTEM_AWARE;
    private static IntPtr DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE;
    private static IntPtr DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2;
    private static string KERNEL32_DLL;
    private static int InternalCall;
    private static int TopLevelUIObjectTimeout;
    private static UAPApp();
    public static UIObject Launch(string appName, UICondition topLevelWindowCondition);
    public static UIObject Launch(string appName, UICondition topLevelWindowCondition, int timeout);
    public static UIObject LaunchForProtocol(string appName, string uri, UICondition topLevelWindowCondition);
    public static UIObject GetTopLevelUIObject(UICondition topLevelWindowCondition);
    public static UIObject GetTopLevelUIObject(UIObject topWindow);
    public static UIObject GetTopLevelUIObject(UIObject topWindow, int timeout);
    public static UICondition CreateCoreWindowCondition();
    public static void CloseWindow(UIObject window);
    public static void SetTestDPIAwareness();
    private static bool SupportsSetProcessDpiAwarenessContext();
    private static void SHCreateItemFromParsingName(string path, IntPtr pbc, Guid& riid, IShellItem& shellItem);
    private static void SHCreateShellItemArrayFromShellItem(IShellItem psi, Guid& riid, IShellItemArray& ppenum);
    private static int SetProcessDpiAwareness(ProcessDPIAwareness value);
    private static bool SetProcessDpiAwarenessContext(IntPtr value);
    private static IntPtr GetProcAddress(IntPtr module, string methodName);
    private static IntPtr GetModuleHandle(string moduleName);
    internal static bool DoesWin32MethodExist(string moduleName, string methodName);
}
public abstract class Microsoft.Windows.Apps.Test.Foundation.UICollection : object {
    private static bool _autoRealize;
    private static TimeSpan _timeout;
    private static int _retryCount;
    public static TimeSpan Timeout { get; public set; }
    public static int RetryCount { get; public set; }
    public static bool AutoRealize { get; public set; }
    private static UICollection();
    public static TimeSpan get_Timeout();
    public static void set_Timeout(TimeSpan value);
    public static int get_RetryCount();
    public static void set_RetryCount(int value);
    public static bool get_AutoRealize();
    public static void set_AutoRealize(bool value);
}
[DefaultMemberAttribute("Item")]
public class Microsoft.Windows.Apps.Test.Foundation.UICollection`1 : UICollection {
    private UINavigator _navigator;
    private IFactory`1<I> _factory;
    public bool IsReadOnly { get; }
    public int Count { get; }
    private I System.Collections.Generic.IList<I>.Item { get; private set; }
    public I Item { get; public set; }
    public I Item { get; }
    internal UINavigator Navigator { get; }
    protected IFactory`1<I> Factory { get; }
    internal UICollection`1(UINavigator navigator, IFactory`1<I> factory);
    public UICollection`1(UICollection`1<I> previous);
    public virtual UICollection`1<I> Duplicate();
    public sealed virtual void Add(I item);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<I>.Contains(I item);
    public sealed virtual bool Remove(I item);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(I[] array, int arrayIndex);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void Insert(int index, I item);
    private sealed virtual override I System.Collections.Generic.IList<I>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<I>.set_Item(int index, I value);
    public sealed virtual int IndexOf(I item);
    [IteratorStateMachineAttribute("Microsoft.Windows.Apps.Test.Foundation.UICollection`1/<GetEnumerator>d__18")]
public sealed virtual IEnumerator`1<I> GetEnumerator();
    [IteratorStateMachineAttribute("Microsoft.Windows.Apps.Test.Foundation.UICollection`1/<System-Collections-IEnumerable-GetEnumerator>d__19")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public UICollection`1<I> ToStaticCollection();
    public void AddFilter(UIProperty uiProperty, object value);
    public void AddFilter(UICondition condition);
    public void AddFilter(IFilter`1<UIObject> filter);
    internal void AddFilter(IFilter`1<AutomationElement> filter);
    public I get_Item(int index);
    public void set_Item(int index, I value);
    public I get_Item(string automationId);
    public bool Contains(string automationId);
    public bool Contains(UIProperty uiProperty, object value);
    public bool Contains(UICondition condition);
    public bool Contains(IFilter`1<UIObject> filter);
    internal bool Contains(IFilter`1<AutomationElement> filter);
    public bool TryFind(string automationId, I& element);
    public bool TryFind(UIProperty uiProperty, object value, I& element);
    public bool TryFind(UICondition condition, I& element);
    public bool TryFind(IFilter`1<UIObject> filter, I& element);
    internal bool TryFind(IFilter`1<AutomationElement> filter, I& element);
    public I Find(string automationId);
    public I Find(UIProperty uiProperty, object value);
    public I Find(UICondition condition);
    public I Find(IFilter`1<UIObject> filter);
    internal I Find(IFilter`1<AutomationElement> filter);
    public UICollection`1<I> FindMultiple(UIProperty uiProperty, object value);
    public UICollection`1<I> FindMultiple(UICondition condition);
    public UICollection`1<I> FindMultiple(IFilter`1<UIObject> filter);
    internal UICollection`1<I> FindMultiple(IFilter`1<AutomationElement> filter);
    protected I SafeGetItem(int index);
    protected I SafeFind(UICondition condition);
    internal I SafeFind(IFilter`1<AutomationElement> filter);
    public virtual string ToString();
    internal UINavigator get_Navigator();
    protected IFactory`1<I> get_Factory();
}
public class Microsoft.Windows.Apps.Test.Foundation.UICondition : object {
    private GlobalizableCondition _condition;
    private Condition _globalizedCondition;
    private Dictionary`2<AutomationProperty, TranslatedStrings> _propertyValueTranslations;
    private static UICondition _trueCondition;
    private static UICondition _falseCondition;
    private static UICondition _rawTreeCondition;
    private static UICondition _controlTreeCondition;
    private static UICondition _contentTreeCondition;
    public static UICondition True { get; }
    public static UICondition False { get; }
    public static UICondition RawTree { get; }
    public static UICondition ControlTree { get; }
    public static UICondition ContentTree { get; }
    internal Condition Condition { get; }
    internal GlobalizableCondition GlobalizableCondition { get; }
    internal UICondition(Condition condition);
    internal UICondition(GlobalizableCondition condition);
    private static UICondition();
    public static UICondition Create(UIProperty property, object value);
    public static UICondition Create(string query, Object[] objects);
    public static UICondition CreateFromId(string automationId);
    public static UICondition CreateFromName(string name);
    public static UICondition CreateFromClassName(string className);
    public UICondition AndWith(string newCondition, Object[] objects);
    public UICondition AndWith(UICondition newCondition);
    public UICondition OrWith(string newCondition, Object[] objects);
    public UICondition OrWith(UICondition newCondition);
    public UICondition Negate();
    public static UICondition op_BitwiseAnd(UICondition condition1, UICondition condition2);
    public static UICondition op_BitwiseOr(UICondition condition1, UICondition condition2);
    public static UICondition op_LogicalNot(UICondition condition);
    internal bool Matches(AutomationElement element);
    internal AutomationElement FindFirst(AutomationElement root, Scope scope, CacheRequest cr);
    internal AutomationElementCollection FindAll(AutomationElement root, Scope scope, CacheRequest cr);
    public virtual string ToString();
    internal static string ToString(Condition condition);
    private static void BuildDescription(Condition condition, StringBuilder stringBuilder);
    private void SendGlobalizerFeedback(AutomationElement element);
    public static bool IsGlobalizableProperty(UIProperty property);
    internal static bool IsGlobalizableProperty(AutomationProperty property);
    public static UICondition get_True();
    public static UICondition get_False();
    public static UICondition get_RawTree();
    public static UICondition get_ControlTree();
    public static UICondition get_ContentTree();
    internal Condition get_Condition();
    internal GlobalizableCondition get_GlobalizableCondition();
}
[DefaultMemberAttribute("Item")]
internal abstract class Microsoft.Windows.Apps.Test.Foundation.UINavigator : object {
    private UIObjectFilter _filter;
    public AutomationElement Item { get; }
    public UIObjectFilter Filter { get; }
    protected UINavigator(UINavigator previous);
    public abstract virtual UINavigator Duplicate();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public abstract virtual IEnumerator`1<AutomationElement> GetEnumerator();
    public virtual AutomationElement get_Item(int index);
    public virtual UINavigator ToStaticNavigator();
    public void AddFilter(UICondition condition);
    public void AddFilter(IFilter`1<UIObject> filter);
    public void AddFilter(IFilter`1<AutomationElement> filter);
    public virtual UIObjectFilter get_Filter();
}
public class Microsoft.Windows.Apps.Test.Foundation.UIObject : object {
    private AutomationElement _automationElement;
    private static IFactory`1<UIObject> _factory;
    public static UIObject Root { get; }
    public static UIObject Focused { get; }
    public static IFactory`1<UIObject> Factory { get; }
    public string AcceleratorKey { get; }
    public string AccessKey { get; }
    internal AutomationElement AutomationElement { get; }
    public string AutomationId { get; }
    public Rectangle BoundingRectangle { get; }
    public string ClassName { get; }
    public ControlType ControlType { get; }
    public CultureInfo Culture { get; }
    public string FrameworkId { get; }
    public bool HasKeyboardFocus { get; }
    public string HelpText { get; }
    public bool IsContentElement { get; }
    public bool IsItemContainerPatternAvailable { get; }
    public bool IsVirtualizedItemPatternAvailable { get; }
    public bool IsControlElement { get; }
    public bool IsEnabled { get; }
    public bool IsKeyboardFocusable { get; }
    public bool IsOffscreen { get; }
    public bool IsPassword { get; }
    public bool IsRequiredForForm { get; }
    public string ItemStatus { get; }
    public string ItemType { get; }
    public UIObject LabeledBy { get; }
    public string LocalizedControlType { get; }
    public string Name { get; }
    public IntPtr NativeWindowHandle { get; }
    public OrientationType Orientation { get; }
    public int ProcessId { get; }
    public string RuntimeId { get; }
    public UICollection`1<UIObject> Children { get; }
    public UICollection`1<UIObject> Siblings { get; }
    public UICollection`1<UIObject> Ancestors { get; }
    public UICollection`1<UIObject> Descendants { get; }
    public UIObject FirstChild { get; }
    public UIObject LastChild { get; }
    public UIObject NextSibling { get; }
    public UIObject PreviousSibling { get; }
    public UIObject Parent { get; }
    public IEnumerable`1<UIProperty> SupportedProperties { get; }
    private static UIObject();
    public UIObject(UIObject uiObject);
    internal UIObject(AutomationElement element);
    public static UIObject get_Root();
    public static UIObject get_Focused();
    public static UIObject FromHandle(IntPtr hwnd);
    public static UIObject FromPoint(Point pixelLocation);
    public static IFactory`1<UIObject> get_Factory();
    public static bool TrySetConnectionTimeout(TimeSpan timeout);
    public static bool TryGetConnectionTimeout(TimeSpan& timeout);
    public static bool TrySetTransactionTimeout(TimeSpan timeout);
    public static bool TryGetTransactionTimeout(TimeSpan& timeout);
    public virtual string get_AcceleratorKey();
    public virtual string get_AccessKey();
    internal AutomationElement get_AutomationElement();
    public string get_AutomationId();
    public Rectangle get_BoundingRectangle();
    public string get_ClassName();
    public ControlType get_ControlType();
    public CultureInfo get_Culture();
    public string get_FrameworkId();
    public bool get_HasKeyboardFocus();
    public string get_HelpText();
    public bool get_IsContentElement();
    public bool get_IsItemContainerPatternAvailable();
    public bool get_IsVirtualizedItemPatternAvailable();
    public bool get_IsControlElement();
    public bool get_IsEnabled();
    public bool get_IsKeyboardFocusable();
    public bool get_IsOffscreen();
    public bool get_IsPassword();
    public bool get_IsRequiredForForm();
    public string get_ItemStatus();
    public string get_ItemType();
    public UIObject get_LabeledBy();
    public string get_LocalizedControlType();
    public virtual string get_Name();
    public IntPtr get_NativeWindowHandle();
    public OrientationType get_Orientation();
    public int get_ProcessId();
    public string get_RuntimeId();
    public UICollection`1<UIObject> get_Children();
    public UICollection`1<UIObject> get_Siblings();
    public UICollection`1<UIObject> get_Ancestors();
    public UICollection`1<UIObject> get_Descendants();
    public UIObject get_FirstChild();
    public UIObject get_LastChild();
    public UIObject get_NextSibling();
    public UIObject get_PreviousSibling();
    public UIObject get_Parent();
    public void Click();
    public void Click(PointerButtons button);
    public void Click(PointerButtons button, double offsetX, double offsetY);
    protected void ClickImplementation(PointerButtons button, double offsetX, double offsetY);
    public void DoubleClick();
    public void DoubleClick(PointerButtons button);
    public void DoubleClick(PointerButtons button, double offsetX, double offsetY);
    protected void DoubleClickImplementation(PointerButtons button, double offsetX, double offsetY);
    public void ClickDrag(UIObject uiObject);
    public void ClickDrag(PointerButtons button, UIObject uiObject);
    public void MovePointer();
    public void MovePointer(double offsetX, double offsetY);
    public void Tap();
    public virtual void Tap(double offsetX, double offsetY);
    public void DoubleTap();
    public virtual void DoubleTap(double offsetX, double offsetY);
    public void TapAndHold();
    public void TapAndHold(UInt32 duration);
    public void TapAndHold(double offsetX, double offsetY);
    public virtual void TapAndHold(double offsetX, double offsetY, UInt32 duration);
    public void Pan(float direction);
    public void Pan(int distance, float direction);
    public void Pan(Point startPoint, int distance, float direction);
    public virtual void Pan(Point startPoint, Point endPoint);
    public void Flick(float direction);
    public void Flick(Point startPoint, float direction);
    public void Flick(int distance, float direction);
    public void Flick(Point startPoint, int distance, float direction);
    public virtual void Flick(Point startPoint, Point endPoint);
    public void PinchStretch(UInt32 initialDistance, UInt32 finalDistance);
    public void PinchStretch(Point startPoint, UInt32 initialDistance, UInt32 finalDistance);
    public virtual void PinchStretch(Point startPoint, UInt32 initialDistance, UInt32 finalDistance, UInt32 duration);
    private Point ObjectPointToScreenPoint(Point objectPoint);
    public virtual bool Equals(object obj);
    public Point GetClickablePoint();
    public virtual int GetHashCode();
    public IEnumerable`1<UIProperty> get_SupportedProperties();
    public AutomationPattern[] GetSupportedPatterns();
    public object GetProperty(UIProperty property);
    public object GetCachedProperty(UIProperty property);
    public bool Matches(UICondition condition);
    public static bool Matches(UIObject uiObject, UICondition condition);
    internal static bool Matches(AutomationElement element, UICondition condition);
    public void SendKeys(string text);
    public void SetFocus();
    public virtual string ToString();
    public static bool op_Equality(UIObject firstElement, UIObject secondElement);
    public static bool op_Inequality(UIObject firstElement, UIObject secondElement);
    internal static string SafeGetName(UIObject uiObject);
    private Point ComputeOffsetFromUpperLeftCorner();
    private static object WrapValue(object value);
}
public class Microsoft.Windows.Apps.Test.Foundation.UIObjectNotFoundException : Exception {
    private string _searchDomain;
    private string _searchCriteria;
    public string Message { get; }
    public UIObjectNotFoundException(string message);
    public UIObjectNotFoundException(string message, Exception innerException);
    public UIObjectNotFoundException(string searchDomain, UICondition condition);
    public UIObjectNotFoundException(string searchDomain, int index);
    public UIObjectNotFoundException(string searchDomain, UIObject uiObject);
    public UIObjectNotFoundException(string searchDomain, Predicate`1<UIObject> filterCallback);
    public UIObjectNotFoundException(string searchDomain, string searchCriteria);
    private void Initialize(string searchDomain, string searchCriteria);
    public virtual string get_Message();
}
public class Microsoft.Windows.Apps.Test.Foundation.UIProperty : object {
    private string _name;
    private AutomationProperty _property;
    private Type _allowedType;
    private static Dictionary`2<string, UIProperty> _propertyTable;
    private static Dictionary`2<AutomationProperty, UIProperty> _automationPropertyTable;
    private static object lockObject;
    public static IEnumerable`1<UIProperty> AllProperties { get; }
    public string Name { get; }
    internal AutomationProperty Property { get; }
    internal Type Type { get; }
    private static UIProperty();
    private UIProperty(string name, AutomationProperty property, Type allowedType);
    private static UIProperty Create(string name, AutomationProperty property);
    private static UIProperty Create(string name, AutomationProperty property, Type allowedType);
    public static UIProperty Get(string name);
    public static bool Exists(string name);
    internal static UIProperty Get(AutomationProperty property);
    public static void Initialization();
    public virtual string ToString();
    public static IEnumerable`1<UIProperty> get_AllProperties();
    public string get_Name();
    internal AutomationProperty get_Property();
    internal Type get_Type();
}
public class Microsoft.Windows.Apps.Test.Foundation.UIQueryException : Exception {
    public UIQueryException(string message);
    public UIQueryException(string message, Exception innerException);
}
internal class Microsoft.Windows.Apps.Test.Foundation.Utilities.BreadthFirstTreeEnumerator`1 : object {
    private ITreeNavigator`1<I> _navigator;
    private Queue`1<I> _elementQueue;
    private I _root;
    private I _currentElement;
    private TreeEnumerationState _enumerationState;
    private bool _ignoreRoot;
    private bool _disposed;
    private object System.Collections.IEnumerator.Current { get; }
    public I Current { get; }
    public I Root { get; }
    public BreadthFirstTreeEnumerator`1(I root, ITreeNavigator`1<I> navigator);
    public BreadthFirstTreeEnumerator`1(BreadthFirstTreeEnumerator`1<I> previous);
    public BreadthFirstTreeEnumerator`1(I root, ITreeNavigator`1<I> navigator, bool ignoreRoot);
    private void Initialize(I root, ITreeNavigator`1<I> navigator, bool ignoreRoot);
    public virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public sealed virtual bool MoveNext();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual I get_Current();
    public sealed virtual void Reset();
    public I get_Root();
}
internal static class Microsoft.Windows.Apps.Test.Foundation.Utilities.Cache : object {
    internal static UIObject PopulateDefaultCache(UIObject uiObject);
    internal static UIObject BuildUpdatedCache(UIObject uiObject, CacheRequest cacheRequest);
}
internal class Microsoft.Windows.Apps.Test.Foundation.Utilities.DepthFirstTreeEnumerator`1 : object {
    private ITreeNavigator`1<I> _navigator;
    private Stack`1<I> _elementStack;
    private I _root;
    private I _currentElement;
    private TreeEnumerationState _enumerationState;
    private bool _ignoreRoot;
    private bool _disposed;
    private object System.Collections.IEnumerator.Current { get; }
    public I Current { get; }
    public I Root { get; }
    public DepthFirstTreeEnumerator`1(I root, ITreeNavigator`1<I> navigator);
    public DepthFirstTreeEnumerator`1(DepthFirstTreeEnumerator`1<I> previous);
    public DepthFirstTreeEnumerator`1(I root, ITreeNavigator`1<I> navigator, bool ignoreRoot);
    private void Initialize(I root, ITreeNavigator`1<I> navigator, bool ignoreRoot);
    public virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public sealed virtual bool MoveNext();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual I get_Current();
    public sealed virtual void Reset();
    public I get_Root();
}
internal interface Microsoft.Windows.Apps.Test.Foundation.Utilities.ITreeNavigator`1 {
    public abstract virtual T GetNextSibling(T current);
    public abstract virtual T GetFirstChild(T current);
}
public static class Microsoft.Windows.Apps.Test.Foundation.Utilities.Log : object {
    public static Action`2<string, Object[]> OutImplementation;
    internal static Func`2<string, string> CreateUniqueObjectIdImplementation;
    private static long objCount;
    private static Log();
    internal static void Out(string msg, Object[] args);
    internal static string CreateUniqueObjectId(string baseName);
    public static void DisplayVisualTree(UIObject root, UInt32 maxDepth, UInt32 depth);
    private static string Indent(UInt32 count);
}
internal static class Microsoft.Windows.Apps.Test.Foundation.Utilities.RuntimeId : object {
    private static char _delimiter;
    public static Int32[] PartsFromString(string runtimeIdString);
    public static string StringFromParts(Int32[] runtimeIdParts);
}
internal class Microsoft.Windows.Apps.Test.Foundation.Utilities.TranslatedStrings : object {
    private Dictionary`2<string, IList`1<TranslationSource>> _translatedStrings;
    public void Add(string translatedString, ILocalizedStrings localizedStrings, long index);
    public void MatchFound(AutomationElement element, string translatedString);
}
internal class Microsoft.Windows.Apps.Test.Foundation.Utilities.TranslationSource : object {
    private ILocalizedStrings _localizedStrings;
    private long _translationIndex;
    public TranslationSource(ILocalizedStrings localizedStrings, long translationIndex);
    public void MatchFound(AutomationElement element);
}
internal enum Microsoft.Windows.Apps.Test.Foundation.Utilities.TreeEnumerationState : Enum {
    public int value__;
    public static TreeEnumerationState BeforeEnumeration;
    public static TreeEnumerationState AtRoot;
    public static TreeEnumerationState InEnumeration;
    public static TreeEnumerationState AfterEnumeration;
}
internal static class Microsoft.Windows.Apps.Test.Foundation.Utilities.Validate : object {
    public static void ArgumentNotNull(object parameter, string parameterName);
    public static void StringNeitherNullNorEmpty(string parameter, string parameterName);
}
public enum Microsoft.Windows.Apps.Test.Foundation.VirtualKey : Enum {
    public byte value__;
    public static VirtualKey VK_NONE;
    public static VirtualKey VK_LBUTTON;
    public static VirtualKey VK_RBUTTON;
    public static VirtualKey VK_CANCEL;
    public static VirtualKey VK_MBUTTON;
    public static VirtualKey VK_XBUTTON1;
    public static VirtualKey VK_XBUTTON2;
    public static VirtualKey VK_BACK;
    public static VirtualKey VK_TAB;
    public static VirtualKey VK_CLEAR;
    public static VirtualKey VK_RETURN;
    public static VirtualKey VK_SHIFT;
    public static VirtualKey VK_CONTROL;
    public static VirtualKey VK_MENU;
    public static VirtualKey VK_PAUSE;
    public static VirtualKey VK_CAPITAL;
    public static VirtualKey VK_KANA;
    public static VirtualKey VK_HANGEUL;
    public static VirtualKey VK_HANGUL;
    public static VirtualKey VK_JUNJA;
    public static VirtualKey VK_FINAL;
    public static VirtualKey VK_HANJA;
    public static VirtualKey VK_KANJI;
    public static VirtualKey VK_ESCAPE;
    public static VirtualKey VK_CONVERT;
    public static VirtualKey VK_NONCONVERT;
    public static VirtualKey VK_ACCEPT;
    public static VirtualKey VK_MODECHANGE;
    public static VirtualKey VK_SPACE;
    public static VirtualKey VK_PRIOR;
    public static VirtualKey VK_NEXT;
    public static VirtualKey VK_END;
    public static VirtualKey VK_HOME;
    public static VirtualKey VK_LEFT;
    public static VirtualKey VK_UP;
    public static VirtualKey VK_RIGHT;
    public static VirtualKey VK_DOWN;
    public static VirtualKey VK_SELECT;
    public static VirtualKey VK_PRINT;
    public static VirtualKey VK_EXECUTE;
    public static VirtualKey VK_SNAPSHOT;
    public static VirtualKey VK_INSERT;
    public static VirtualKey VK_DELETE;
    public static VirtualKey VK_HELP;
    public static VirtualKey VK_D0;
    public static VirtualKey VK_D1;
    public static VirtualKey VK_D2;
    public static VirtualKey VK_D3;
    public static VirtualKey VK_D4;
    public static VirtualKey VK_D5;
    public static VirtualKey VK_D6;
    public static VirtualKey VK_D7;
    public static VirtualKey VK_D8;
    public static VirtualKey VK_D9;
    public static VirtualKey VK_A;
    public static VirtualKey VK_B;
    public static VirtualKey VK_C;
    public static VirtualKey VK_D;
    public static VirtualKey VK_E;
    public static VirtualKey VK_F;
    public static VirtualKey VK_G;
    public static VirtualKey VK_H;
    public static VirtualKey VK_I;
    public static VirtualKey VK_J;
    public static VirtualKey VK_K;
    public static VirtualKey VK_L;
    public static VirtualKey VK_M;
    public static VirtualKey VK_N;
    public static VirtualKey VK_O;
    public static VirtualKey VK_P;
    public static VirtualKey VK_Q;
    public static VirtualKey VK_R;
    public static VirtualKey VK_S;
    public static VirtualKey VK_T;
    public static VirtualKey VK_U;
    public static VirtualKey VK_V;
    public static VirtualKey VK_W;
    public static VirtualKey VK_X;
    public static VirtualKey VK_Y;
    public static VirtualKey VK_Z;
    public static VirtualKey VK_LWIN;
    public static VirtualKey VK_RWIN;
    public static VirtualKey VK_APPS;
    public static VirtualKey VK_SLEEP;
    public static VirtualKey VK_NUMPAD0;
    public static VirtualKey VK_NUMPAD1;
    public static VirtualKey VK_NUMPAD2;
    public static VirtualKey VK_NUMPAD3;
    public static VirtualKey VK_NUMPAD4;
    public static VirtualKey VK_NUMPAD5;
    public static VirtualKey VK_NUMPAD6;
    public static VirtualKey VK_NUMPAD7;
    public static VirtualKey VK_NUMPAD8;
    public static VirtualKey VK_NUMPAD9;
    public static VirtualKey VK_MULTIPLY;
    public static VirtualKey VK_ADD;
    public static VirtualKey VK_SEPARATOR;
    public static VirtualKey VK_SUBTRACT;
    public static VirtualKey VK_DECIMAL;
    public static VirtualKey VK_DIVIDE;
    public static VirtualKey VK_F1;
    public static VirtualKey VK_F2;
    public static VirtualKey VK_F3;
    public static VirtualKey VK_F4;
    public static VirtualKey VK_F5;
    public static VirtualKey VK_F6;
    public static VirtualKey VK_F7;
    public static VirtualKey VK_F8;
    public static VirtualKey VK_F9;
    public static VirtualKey VK_F10;
    public static VirtualKey VK_F11;
    public static VirtualKey VK_F12;
    public static VirtualKey VK_F13;
    public static VirtualKey VK_F14;
    public static VirtualKey VK_F15;
    public static VirtualKey VK_F16;
    public static VirtualKey VK_F17;
    public static VirtualKey VK_F18;
    public static VirtualKey VK_F19;
    public static VirtualKey VK_F20;
    public static VirtualKey VK_F21;
    public static VirtualKey VK_F22;
    public static VirtualKey VK_F23;
    public static VirtualKey VK_F24;
    public static VirtualKey VK_NUMLOCK;
    public static VirtualKey VK_SCROLL;
    public static VirtualKey VK_LSHIFT;
    public static VirtualKey VK_RSHIFT;
    public static VirtualKey VK_LCONTROL;
    public static VirtualKey VK_RCONTROL;
    public static VirtualKey VK_LMENU;
    public static VirtualKey VK_RMENU;
    public static VirtualKey VK_OEM_1;
    public static VirtualKey VK_OEM_PLUS;
    public static VirtualKey VK_OEM_COMMA;
    public static VirtualKey VK_OEM_MINUS;
    public static VirtualKey VK_OEM_PERIOD;
    public static VirtualKey VK_OEM_2;
    public static VirtualKey VK_OEM_3;
    public static VirtualKey VK_OEM_4;
    public static VirtualKey VK_OEM_5;
    public static VirtualKey VK_OEM_6;
    public static VirtualKey VK_OEM_7;
    public static VirtualKey VK_OEM_8;
}
public class Microsoft.Windows.Apps.Test.Foundation.Waiters.AppLaunchWaiter : Waiter {
    private UICondition topLevelWindowCondition;
    private UIEventWaiter[] waiters;
    private UIObject source;
    public UIObject Source { get; }
    public AppLaunchWaiter(UICondition topLevelWindowCondition);
    public virtual bool TryWait(TimeSpan timeout);
    public UIObject get_Source();
    public virtual void Dispose();
}
public class Microsoft.Windows.Apps.Test.Foundation.Waiters.AutomationEventSource : EventSource {
    private AutomationEvent _eventId;
    private UIObject _root;
    private Scope _scope;
    private WeakReference _sinkReference;
    private AutomationEventHandler _handlingDelegate;
    public bool IsStarted { get; }
    public AutomationEventSource(AutomationEvent eventId, UIObject root, Scope scope);
    protected virtual void Dispose(bool disposing);
    public virtual void Start(IEventSink sink);
    public virtual void Stop();
    public virtual bool get_IsStarted();
    private void Handler(object sender, EventArgs e);
}
public class Microsoft.Windows.Apps.Test.Foundation.Waiters.AutomationEventWaiter : UIEventWaiter {
    private UICondition _condition;
    public AutomationEventWaiter(AutomationEvent eventId, UIObject uiObject, Scope scope);
    public AutomationEventWaiter(AutomationEvent eventId, UIObject uiObject, Scope scope, UICondition condition);
    protected virtual void Start();
    protected virtual void Dispose(bool disposing);
    protected virtual bool Matches(WaiterEventArgs eventArgs);
}
public class Microsoft.Windows.Apps.Test.Foundation.Waiters.CachingWaiter : Waiter {
    private Predicate`1<WaiterEventArgs> _filterDelegate;
    private Queue`1<WaiterEventArgs> _eventQueue;
    private ManualResetEvent _resetEvent;
    private bool _disposed;
    private bool _shutdown;
    private Timer _timer;
    private UIEventWaiter _waiter;
    private object _syncRoot;
    private UIObject _source;
    public UIObject Source { get; }
    public CachingWaiter(UIEventWaiter waiter);
    protected virtual override void Finalize();
    public virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual bool TryWait(TimeSpan timeout);
    public virtual void Reset();
    public void AddFilter(Predicate`1<WaiterEventArgs> callback);
    public void RemoveFilter(Predicate`1<WaiterEventArgs> callback);
    public virtual UIObject get_Source();
    public virtual string ToString();
    private void NotifyHandler(object sender, WaiterEventArgs args);
    private void TimerHandler(object state);
}
public abstract class Microsoft.Windows.Apps.Test.Foundation.Waiters.CompositableWaiter : Waiter {
    protected WaitHandle WaitHandle { get; }
    public static CompositableWaiter WaitAny(CompositableWaiter[] waiters);
    public static CompositableWaiter WaitAny(int timeout, CompositableWaiter[] waiters);
    public static CompositableWaiter WaitAny(TimeSpan timeout, CompositableWaiter[] waiters);
    public static CompositableWaiter TryWaitAny(CompositableWaiter[] waiters);
    public static CompositableWaiter TryWaitAny(int timeout, CompositableWaiter[] waiters);
    public static CompositableWaiter TryWaitAny(TimeSpan timeout, CompositableWaiter[] waiters);
    public static void WaitAll(CompositableWaiter[] waiters);
    public static void WaitAll(int timeout, CompositableWaiter[] waiters);
    public static void WaitAll(TimeSpan timeout, CompositableWaiter[] waiters);
    public static bool TryWaitAll(CompositableWaiter[] waiters);
    public static bool TryWaitAll(int timeout, CompositableWaiter[] waiters);
    public static bool TryWaitAll(TimeSpan timeout, CompositableWaiter[] waiters);
    private static string WaitersToString(Waiter[] waiters);
    protected abstract virtual WaitHandle get_WaitHandle();
}
public class Microsoft.Windows.Apps.Test.Foundation.Waiters.CompositeAllWaiter : Waiter {
    private CompositableWaiter[] _waiters;
    public CompositeAllWaiter(CompositableWaiter[] waiters);
    public virtual bool TryWait(TimeSpan timeout);
    public virtual void Reset();
    public virtual string ToString();
    public virtual void Dispose();
}
public class Microsoft.Windows.Apps.Test.Foundation.Waiters.CompositeAnyWaiter : Waiter {
    private CompositableWaiter[] _waiters;
    private CompositableWaiter _source;
    public CompositableWaiter Source { get; }
    public CompositeAnyWaiter(CompositableWaiter[] waiters);
    public virtual bool TryWait(TimeSpan timeout);
    public virtual string ToString();
    public virtual void Reset();
    public CompositableWaiter get_Source();
    public virtual void Dispose();
}
public class Microsoft.Windows.Apps.Test.Foundation.Waiters.ElementAddedWaiter : UIEventWaiter {
    private UICondition _condition;
    public ElementAddedWaiter(UIObject root, Scope scope);
    public ElementAddedWaiter(UIObject root, Scope scope, string automationId);
    public ElementAddedWaiter(UIObject root, Scope scope, UIProperty uiProperty, object value);
    public ElementAddedWaiter(UIObject root, Scope scope, UICondition condition);
    protected virtual void Start();
    protected virtual void Dispose(bool disposing);
    protected virtual bool Matches(WaiterEventArgs eventArgs);
    public virtual string ToString();
}
public class Microsoft.Windows.Apps.Test.Foundation.Waiters.ElementRemovedWaiter : UIEventWaiter {
    private Int32[] _runtimeId;
    public ElementRemovedWaiter(UIObject root, Scope scope);
    public ElementRemovedWaiter(UIObject root, Scope scope, UIObject uiObject);
    public ElementRemovedWaiter(UIObject root, Scope scope, string runtimeId);
    public ElementRemovedWaiter(UIObject root, Scope scope, Int32[] runtimeId);
    private void Initialize(Int32[] runtimeId);
    protected virtual void Start();
    protected virtual void Dispose(bool disposing);
    protected virtual bool Matches(WaiterEventArgs eventArgs);
    public virtual string ToString();
}
public abstract class Microsoft.Windows.Apps.Test.Foundation.Waiters.EventSource : object {
    private string _debug_identity;
    public bool IsStarted { get; }
    protected virtual override void Finalize();
    public virtual string ToString();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public abstract virtual void Start(IEventSink sink);
    public abstract virtual void Stop();
    public abstract virtual bool get_IsStarted();
}
public class Microsoft.Windows.Apps.Test.Foundation.Waiters.FocusAcquiredWaiter : UIEventWaiter {
    private UICondition _condition;
    public FocusAcquiredWaiter(string automationId);
    public FocusAcquiredWaiter(UIProperty uiProperty, string value);
    public FocusAcquiredWaiter(UICondition condition);
    protected virtual void Start();
    protected virtual void Dispose(bool disposing);
    protected virtual bool Matches(WaiterEventArgs eventArgs);
    public virtual string ToString();
}
public class Microsoft.Windows.Apps.Test.Foundation.Waiters.FocusChangedEventSource : EventSource {
    private WeakReference _sinkReference;
    private AutomationFocusChangedEventHandler _handlingDelegate;
    public bool IsStarted { get; }
    protected virtual void Dispose(bool disposing);
    public virtual void Start(IEventSink sink);
    public virtual void Stop();
    public virtual bool get_IsStarted();
    private void Handler(object sender, EventArgs e);
}
public interface Microsoft.Windows.Apps.Test.Foundation.Waiters.IEventSink {
    public abstract virtual void SinkEvent(WaiterEventArgs eventArgs);
}
public interface Microsoft.Windows.Apps.Test.Foundation.Waiters.IEventSource {
    public bool IsStarted { get; }
    public abstract virtual void Start(IEventSink sink);
    public abstract virtual void Stop();
    public abstract virtual bool get_IsStarted();
}
public class Microsoft.Windows.Apps.Test.Foundation.Waiters.LoadBeginningWaiter : UIEventWaiter {
    public LoadBeginningWaiter(UIObject root);
    public LoadBeginningWaiter(UIObject root, Scope scope);
    protected virtual void Dispose(bool disposing);
    protected virtual bool Matches(WaiterEventArgs eventArgs);
}
public class Microsoft.Windows.Apps.Test.Foundation.Waiters.LoadCompletedWaiter : UIEventWaiter {
    public LoadCompletedWaiter(UIObject root);
    public LoadCompletedWaiter(UIObject root, Scope scope);
    protected virtual void Dispose(bool disposing);
    protected virtual bool Matches(WaiterEventArgs eventArgs);
}
public class Microsoft.Windows.Apps.Test.Foundation.Waiters.MenuClosedWaiter : UIEventWaiter {
    private string _uiObjectDescription;
    public MenuClosedWaiter(UIObject root);
    protected virtual void Start();
    protected virtual void Dispose(bool disposing);
    public virtual string ToString();
}
public class Microsoft.Windows.Apps.Test.Foundation.Waiters.MenuOpenedWaiter : UIEventWaiter {
    private UICondition _condition;
    public MenuOpenedWaiter(string automationId);
    public MenuOpenedWaiter(UIProperty uiProperty, object value);
    public MenuOpenedWaiter(UICondition condition);
    public MenuOpenedWaiter(UIObject rootElement, Scope scope, UICondition condition);
    protected virtual void Start();
    protected virtual void Dispose(bool disposing);
    protected virtual bool Matches(WaiterEventArgs eventArgs);
    public virtual string ToString();
}
public class Microsoft.Windows.Apps.Test.Foundation.Waiters.ProcessClosedWaiter : CompositableWaiter {
    private object _lockObject;
    private bool _isUserProcess;
    private Process _process;
    private ManualResetEvent _blockingProcessEvent;
    private bool _disposed;
    protected WaitHandle WaitHandle { get; }
    public ProcessClosedWaiter(string applicationName);
    public ProcessClosedWaiter(UIObject applicationUIObject);
    public ProcessClosedWaiter(int processId);
    public ProcessClosedWaiter(Process process);
    private void Initialize(Process process);
    public virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual bool TryWait(TimeSpan timeout);
    private void Handler(object sender, EventArgs e);
    public virtual string ToString();
    protected virtual WaitHandle get_WaitHandle();
}
public class Microsoft.Windows.Apps.Test.Foundation.Waiters.ProgressWaiter : UIEventWaiter {
    public ProgressWaiter(UIObject root);
    public ProgressWaiter(UIObject root, Scope scope);
    protected virtual void Dispose(bool disposing);
    protected virtual bool Matches(WaiterEventArgs eventArgs);
}
public class Microsoft.Windows.Apps.Test.Foundation.Waiters.PropertyChangedEventSource : EventSource {
    private AutomationProperty[] _properties;
    private UIObject _root;
    private Scope _scope;
    private WeakReference _sinkReference;
    private AutomationPropertyChangedEventHandler _handlingDelegate;
    public bool IsStarted { get; }
    public PropertyChangedEventSource(UIObject root, Scope scope);
    public PropertyChangedEventSource(UIObject root, Scope scope, UIProperty[] uiProperties);
    protected virtual void Dispose(bool disposing);
    public virtual void Start(IEventSink sink);
    public virtual void Stop();
    public virtual bool get_IsStarted();
    private void Handler(object sender, EventArgs e);
}
public class Microsoft.Windows.Apps.Test.Foundation.Waiters.PropertyChangedEventWaiter : UIEventWaiter {
    public PropertyChangedEventWaiter(UIObject root, UIProperty[] uiProperties);
    public PropertyChangedEventWaiter(UIObject root, Scope scope, UIProperty[] uiProperties);
    public PropertyChangedEventWaiter(UIObject root, Scope scope);
    protected virtual void Start();
    protected virtual void Dispose(bool disposing);
}
public class Microsoft.Windows.Apps.Test.Foundation.Waiters.StructureChangedEventSource : EventSource {
    private UIObject _root;
    private Scope _scope;
    private WeakReference _sinkReference;
    private StructureChangedEventHandler _handlingDelegate;
    public bool IsStarted { get; }
    public StructureChangedEventSource(UIObject root, Scope scope);
    protected virtual void Dispose(bool disposing);
    public virtual void Start(IEventSink sink);
    public virtual void Stop();
    public virtual bool get_IsStarted();
    private void Handler(object sender, EventArgs e);
}
public class Microsoft.Windows.Apps.Test.Foundation.Waiters.StructureChangedEventWaiter : UIEventWaiter {
    public StructureChangedEventWaiter(UIObject root);
    public StructureChangedEventWaiter(UIObject root, Scope scope);
    protected virtual void Start();
}
public class Microsoft.Windows.Apps.Test.Foundation.Waiters.TimeWaiter : Waiter {
    private TimeSpan _timeout;
    public TimeWaiter(int timeout);
    public TimeWaiter(TimeSpan timeout);
    public virtual void Wait();
    public virtual bool TryWait();
    public virtual bool TryWait(TimeSpan timeout);
    public virtual string ToString();
    public virtual void Dispose();
}
public class Microsoft.Windows.Apps.Test.Foundation.Waiters.ToolTipClosedWaiter : UIEventWaiter {
    private string _uiObjectDescription;
    public ToolTipClosedWaiter(UIObject root);
    public ToolTipClosedWaiter(UIObject root, Scope scope);
    protected virtual void Start();
    protected virtual void Dispose(bool disposing);
    public virtual string ToString();
}
public class Microsoft.Windows.Apps.Test.Foundation.Waiters.ToolTipOpenedWaiter : UIEventWaiter {
    private UICondition _condition;
    public ToolTipOpenedWaiter(string automationId);
    public ToolTipOpenedWaiter(UIProperty uiProperty, string value);
    public ToolTipOpenedWaiter(UICondition condition);
    public ToolTipOpenedWaiter(UIObject rootElement, Scope scope, UICondition condition);
    protected virtual void Start();
    protected virtual void Dispose(bool disposing);
    protected virtual bool Matches(WaiterEventArgs eventArgs);
    public virtual string ToString();
}
public abstract class Microsoft.Windows.Apps.Test.Foundation.Waiters.UIEventWaiter : CompositableWaiter {
    [CompilerGeneratedAttribute]
private EventHandler`1<WaiterEventArgs> Notify;
    private object _lockObject;
    private ManualResetEvent _blockingEvent;
    private IEventSource _eventSource;
    private Predicate`1<WaiterEventArgs> _filterDelegate;
    private WaiterEventArgs _eventArgs;
    private IFactory`1<UIObject> _factory;
    private bool _disposed;
    protected WaitHandle WaitHandle { get; }
    public UIObject Source { get; }
    public WaiterEventArgs Arguments { get; }
    public IFactory`1<UIObject> Factory { get; public set; }
    protected UIEventWaiter(IEventSource eventSource);
    protected virtual override void Finalize();
    protected virtual void Start();
    public virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual bool TryWait(TimeSpan timeout);
    public virtual void Reset();
    public sealed virtual void SinkEvent(WaiterEventArgs eventArgs);
    protected virtual bool Matches(WaiterEventArgs eventArgs);
    public void AddFilter(Predicate`1<WaiterEventArgs> callback);
    public void RemoveFilter(Predicate`1<WaiterEventArgs> callback);
    protected virtual void OnNotify(WaiterEventArgs e);
    protected virtual WaitHandle get_WaitHandle();
    public virtual UIObject get_Source();
    public WaiterEventArgs get_Arguments();
    public IFactory`1<UIObject> get_Factory();
    public void set_Factory(IFactory`1<UIObject> value);
    [CompilerGeneratedAttribute]
public void add_Notify(EventHandler`1<WaiterEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Notify(EventHandler`1<WaiterEventArgs> value);
}
public abstract class Microsoft.Windows.Apps.Test.Foundation.Waiters.Waiter : object {
    internal string _debug_identity;
    private static TimeSpan _defaultTimeout;
    private Exception _innerException;
    public static TimeSpan DefaultTimeout { get; public set; }
    public Exception InnerException { get; public set; }
    private static Waiter();
    public virtual void Wait();
    public void Wait(int timeout);
    public void Wait(TimeSpan timeout);
    public virtual bool TryWait();
    public bool TryWait(int timeout);
    public abstract virtual bool TryWait(TimeSpan timeout);
    public virtual void Reset();
    public static TimeSpan get_DefaultTimeout();
    public static void set_DefaultTimeout(TimeSpan value);
    public virtual Exception get_InnerException();
    public virtual void set_InnerException(Exception value);
    public abstract virtual void Dispose();
}
public class Microsoft.Windows.Apps.Test.Foundation.Waiters.WaiterEventArgs : EventArgs {
    private UIObject _sender;
    private EventArgs _eventArgs;
    public UIObject Sender { get; }
    public EventArgs EventArgs { get; }
    internal WaiterEventArgs(object sender, EventArgs eventArgs);
    public UIObject get_Sender();
    public EventArgs get_EventArgs();
}
public class Microsoft.Windows.Apps.Test.Foundation.Waiters.WaiterException : Exception {
    public WaiterException(string message);
    public WaiterException(string message, Exception innerException);
}
public class Microsoft.Windows.Apps.Test.Foundation.Waiters.WaiterTimedOutException : WaiterException {
    public WaiterTimedOutException(string message);
    public WaiterTimedOutException(string message, Exception innerException);
}
public class Microsoft.Windows.Apps.Test.Foundation.Waiters.WindowClosedWaiter : UIEventWaiter {
    private string _uiObjectDescription;
    public WindowClosedWaiter(UIObject root);
    protected virtual void Start();
    protected virtual void Dispose(bool disposing);
    public virtual string ToString();
}
public class Microsoft.Windows.Apps.Test.Foundation.Waiters.WindowOpenedWaiter : UIEventWaiter {
    private UICondition _condition;
    public WindowOpenedWaiter(string automationId);
    public WindowOpenedWaiter(UIProperty uiProperty, string value);
    public WindowOpenedWaiter(UICondition condition);
    public WindowOpenedWaiter(UIObject rootElement, Scope scope, UICondition condition);
    protected virtual void Start();
    protected virtual void Dispose(bool disposing);
    protected virtual bool Matches(WaiterEventArgs eventArgs);
    public virtual string ToString();
}
