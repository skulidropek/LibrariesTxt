[GuidAttribute("30DA92C0-23E8-42A0-AE7C-734A0E5D2782")]
internal class ABI.Microsoft.UI.Xaml.Data.ICustomProperty : object {
}
internal static class ABI.Microsoft.UI.Xaml.Data.ICustomProperty_Delegates : object {
}
internal static class ABI.Microsoft.UI.Xaml.Data.ICustomPropertyProvider_Delegates : object {
}
[GuidAttribute("D026DD64-5F26-5F15-A86A-0DEC8A431796")]
internal class ABI.Microsoft.UI.Xaml.Data.IDataErrorsChangedEventArgsVftbl : ValueType {
    internal Vftbl IInspectableVftbl;
    private Void* _get_PropertyName_0;
    private Void* _put_PropertyName_1;
    public method get_PropertyName_0 { get; }
    public method put_PropertyName_1 { get; }
    public method get_get_PropertyName_0();
    public method get_put_PropertyName_1();
}
[GuidAttribute("63D0C952-396B-54F4-AF8C-BA8724A427BF")]
internal class ABI.Microsoft.UI.Xaml.Data.IPropertyChangedEventArgsVftbl : ValueType {
    internal Vftbl IInspectableVftbl;
    private Void* _get_PropertyName_0;
    public method get_PropertyName_0 { get; }
    public method get_get_PropertyName_0();
}
internal class ABI.Microsoft.UI.Xaml.Data.ManagedCustomProperty : object {
    private PropertyInfo _property;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public string Name { get; }
    public Type Type { get; }
    public ManagedCustomProperty(PropertyInfo property);
    public sealed virtual bool get_CanRead();
    public sealed virtual bool get_CanWrite();
    public sealed virtual string get_Name();
    public sealed virtual Type get_Type();
    public sealed virtual object GetIndexedValue(object target, object index);
    public sealed virtual object GetValue(object target);
    public sealed virtual void SetIndexedValue(object target, object value, object index);
    public sealed virtual void SetValue(object target, object value);
}
[GuidAttribute("7C925755-3E48-42B4-8677-76372267033F")]
internal class ABI.Microsoft.UI.Xaml.Data.ManagedCustomPropertyProviderVftbl : ValueType {
    internal Vftbl IInspectableVftbl;
    private Void* GetCustomProperty_0;
    private Void* GetIndexedProperty_1;
    private Void* GetStringRepresentation_2;
    private Void* get_Type_3;
    private static ManagedCustomPropertyProviderVftbl AbiToProjectionVftable;
    public static IntPtr AbiToProjectionVftablePtr;
    internal static Guid IID;
    private static ManagedCustomPropertyProviderVftbl();
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetCustomProperty_0(IntPtr thisPtr, IntPtr name, IntPtr* result);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetIndexedProperty_1(IntPtr thisPtr, IntPtr name, Type type, IntPtr* result);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetStringRepresentation_2(IntPtr thisPtr, IntPtr* result);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_get_Type_3(IntPtr thisPtr, Type* value);
}
[ObjectReferenceWrapperAttribute("_obj")]
[GuidAttribute("62D0BD1E-B85F-5FCC-842A-7CB0DDA37FE5")]
internal class ABI.Microsoft.UI.Xaml.Data.WinRTDataErrorsChangedEventArgsRuntimeClassFactory : object {
    private ObjectReference`1<Vftbl> _obj;
    public IntPtr ThisPtr { get; }
    public WinRTDataErrorsChangedEventArgsRuntimeClassFactory(IObjectReference obj);
    public WinRTDataErrorsChangedEventArgsRuntimeClassFactory(ObjectReference`1<Vftbl> obj);
    public static ObjectReference`1<Vftbl> FromAbi(IntPtr thisPtr);
    public static WinRTDataErrorsChangedEventArgsRuntimeClassFactory op_Implicit(IObjectReference obj);
    public static WinRTDataErrorsChangedEventArgsRuntimeClassFactory op_Implicit(ObjectReference`1<Vftbl> obj);
    public IntPtr get_ThisPtr();
    public ObjectReference`1<I> AsInterface();
    public A As();
    public IObjectReference CreateInstance(string name);
    public ObjectReferenceValue CreateInstanceForMarshaling(string name);
}
[ObjectReferenceWrapperAttribute("_obj")]
[GuidAttribute("7C0C27A8-0B41-5070-B160-FC9AE960A36C")]
internal class ABI.Microsoft.UI.Xaml.Data.WinRTPropertyChangedEventArgsRuntimeClassFactory : object {
    private ObjectReference`1<Vftbl> _obj;
    public IntPtr ThisPtr { get; }
    public WinRTPropertyChangedEventArgsRuntimeClassFactory(IObjectReference obj);
    public WinRTPropertyChangedEventArgsRuntimeClassFactory(ObjectReference`1<Vftbl> obj);
    public static ObjectReference`1<Vftbl> FromAbi(IntPtr thisPtr);
    public static WinRTPropertyChangedEventArgsRuntimeClassFactory op_Implicit(IObjectReference obj);
    public static WinRTPropertyChangedEventArgsRuntimeClassFactory op_Implicit(ObjectReference`1<Vftbl> obj);
    public IntPtr get_ThisPtr();
    public ObjectReference`1<I> AsInterface();
    public A As();
    public IObjectReference CreateInstance(string name, object baseInterface, IObjectReference& innerInterface);
    public ObjectReferenceValue CreateInstance(string name);
}
[DynamicInterfaceCastableImplementationAttribute]
[GuidAttribute("036D2C08-DF29-41AF-8AA2-D774BE62BA6F")]
internal interface ABI.Microsoft.UI.Xaml.Interop.IBindableIterable {
}
[DynamicInterfaceCastableImplementationAttribute]
[GuidAttribute("6A1D6C07-076D-49F2-8314-F52C9C9A8331")]
internal interface ABI.Microsoft.UI.Xaml.Interop.IBindableIterator {
    private object global::Microsoft.UI.Xaml.Interop.IBindableIterator.Current { get; }
    private bool global::Microsoft.UI.Xaml.Interop.IBindableIterator.HasCurrent { get; }
    internal static ObjectReference`1<Vftbl> FromAbi(IntPtr thisPtr);
    private sealed virtual override bool global::Microsoft.UI.Xaml.Interop.IBindableIterator.MoveNext();
    private sealed virtual override UInt32 global::Microsoft.UI.Xaml.Interop.IBindableIterator.GetMany(Object[]& items);
    private sealed virtual override object global::Microsoft.UI.Xaml.Interop.IBindableIterator.get_Current();
    private sealed virtual override bool global::Microsoft.UI.Xaml.Interop.IBindableIterator.get_HasCurrent();
}
[EditorBrowsableAttribute("1")]
internal static class ABI.Microsoft.UI.Xaml.Interop.IBindableIterator_Delegates : object {
}
[DynamicInterfaceCastableImplementationAttribute]
[GuidAttribute("346DD6E7-976E-4BC3-815D-ECE243BC0F33")]
internal interface ABI.Microsoft.UI.Xaml.Interop.IBindableVectorView {
    private static ConditionalWeakTable`2<IWinRTObject, FromAbiHelper> _helperTable;
    private UInt32 global::Microsoft.UI.Xaml.Interop.IBindableVectorView.Size { get; }
    private static IBindableVectorView();
    internal static ObjectReference`1<Vftbl> FromAbi(IntPtr thisPtr);
    private sealed virtual override object global::Microsoft.UI.Xaml.Interop.IBindableVectorView.GetAt(UInt32 index);
    private sealed virtual override bool global::Microsoft.UI.Xaml.Interop.IBindableVectorView.IndexOf(object value, UInt32& index);
    private sealed virtual override UInt32 global::Microsoft.UI.Xaml.Interop.IBindableVectorView.get_Size();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[EditorBrowsableAttribute("1")]
internal static class ABI.Microsoft.UI.Xaml.Interop.IBindableVectorView_Delegates : object {
}
[ObjectReferenceWrapperAttribute("_obj")]
[GuidAttribute("DA049FF2-D2E0-5FE8-8C7B-F87F26060B6F")]
internal class ABI.Microsoft.UI.Xaml.Interop.INotifyCollectionChangedEventArgs : object {
    private ObjectReference`1<Vftbl> _obj;
    public IObjectReference ObjRef { get; }
    public IntPtr ThisPtr { get; }
    public NotifyCollectionChangedAction Action { get; }
    public IList NewItems { get; }
    public int NewStartingIndex { get; }
    public IList OldItems { get; }
    public int OldStartingIndex { get; }
    public INotifyCollectionChangedEventArgs(IObjectReference obj);
    internal INotifyCollectionChangedEventArgs(ObjectReference`1<Vftbl> obj);
    internal static ObjectReference`1<Vftbl> FromAbi(IntPtr thisPtr);
    public static INotifyCollectionChangedEventArgs op_Implicit(IObjectReference obj);
    public IObjectReference get_ObjRef();
    public IntPtr get_ThisPtr();
    public ObjectReference`1<I> AsInterface();
    public A As();
    public NotifyCollectionChangedAction get_Action();
    public IList get_NewItems();
    public int get_NewStartingIndex();
    public IList get_OldItems();
    public int get_OldStartingIndex();
}
[ObjectReferenceWrapperAttribute("_obj")]
[GuidAttribute("5108EBA4-4892-5A20-8374-A96815E0FD27")]
internal class ABI.Microsoft.UI.Xaml.Interop.WinRTNotifyCollectionChangedEventArgsRuntimeClassFactory : object {
    private ObjectReference`1<Vftbl> _obj;
    public IntPtr ThisPtr { get; }
    public WinRTNotifyCollectionChangedEventArgsRuntimeClassFactory(IObjectReference obj);
    public WinRTNotifyCollectionChangedEventArgsRuntimeClassFactory(ObjectReference`1<Vftbl> obj);
    public static ObjectReference`1<Vftbl> FromAbi(IntPtr thisPtr);
    public static WinRTNotifyCollectionChangedEventArgsRuntimeClassFactory op_Implicit(IObjectReference obj);
    public static WinRTNotifyCollectionChangedEventArgsRuntimeClassFactory op_Implicit(ObjectReference`1<Vftbl> obj);
    public IntPtr get_ThisPtr();
    public ObjectReference`1<I> AsInterface();
    public A As();
    public IObjectReference CreateInstanceWithAllParameters(NotifyCollectionChangedAction action, IList newItems, IList oldItems, int newIndex, int oldIndex, object baseInterface, IObjectReference& innerInterface);
    public ObjectReferenceValue CreateInstanceWithAllParameters(NotifyCollectionChangedAction action, IList newItems, IList oldItems, int newIndex, int oldIndex);
}
internal class ABI.System.Boolean : ValueType {
    private byte value;
    public static bool CreateMarshaler(bool value);
    public static Boolean GetAbi(bool value);
    public static bool FromAbi(Boolean abi);
    public static void CopyAbi(bool value, IntPtr dest);
    public static Boolean FromManaged(bool value);
    public static void CopyManaged(bool arg, IntPtr dest);
    public static void DisposeMarshaler(bool m);
    public static void DisposeAbi(Boolean abi);
}
internal class ABI.System.Char : ValueType {
    private ushort value;
    public static char CreateMarshaler(char value);
    public static Char GetAbi(char value);
    public static char FromAbi(Char abi);
    public static void CopyAbi(char value, IntPtr dest);
    public static Char FromManaged(char value);
    public static void CopyManaged(char arg, IntPtr dest);
    public static void DisposeMarshaler(char m);
    public static void DisposeAbi(Char abi);
}
[DynamicInterfaceCastableImplementationAttribute]
internal interface ABI.System.Collections.Generic.ICollection`1 {
    private int global::System.Collections.Generic.ICollection<T>.Count { get; }
    private bool global::System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private static ICollection`1<T> CreateHelper(IWinRTObject _this);
    private static ICollection`1<T> GetHelper(IWinRTObject _this);
    private sealed virtual override int global::System.Collections.Generic.ICollection<T>.get_Count();
    private sealed virtual override bool global::System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override void global::System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void global::System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool global::System.Collections.Generic.ICollection<T>.Contains(T item);
    private sealed virtual override void global::System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int arrayIndex);
    private sealed virtual override bool global::System.Collections.Generic.ICollection<T>.Remove(T item);
    private sealed virtual override IEnumerator global::System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<T> global::System.Collections.Generic.IEnumerable<T>.GetEnumerator();
}
public static class ABI.System.Collections.Generic.IDictionary_Delegates : object {
}
[DynamicInterfaceCastableImplementationAttribute]
[GuidAttribute("3C2925FE-8519-45C1-AA79-197B6718C1C1")]
internal interface ABI.System.Collections.Generic.IDictionary`2 {
    public static Guid PIID;
    private ICollection`1<K> global::System.Collections.Generic.IDictionary<K,V>.Keys { get; }
    private ICollection`1<V> global::System.Collections.Generic.IDictionary<K,V>.Values { get; }
    private int global::System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<K,V>>.Count { get; }
    private bool global::System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<K,V>>.IsReadOnly { get; }
    private V global::System.Collections.Generic.IDictionary<K,V>.Item { get; private set; }
    private static IDictionary`2();
    public static IObjectReference CreateMarshaler(IDictionary`2<K, V> obj);
    public static ObjectReferenceValue CreateMarshaler2(IDictionary`2<K, V> obj);
    public static IntPtr GetAbi(IObjectReference objRef);
    public static IDictionary`2<K, V> FromAbi(IntPtr thisPtr);
    public static IntPtr FromManaged(IDictionary`2<K, V> value);
    public static void DisposeMarshaler(IObjectReference objRef);
    public static void DisposeAbi(IntPtr abi);
    public static string GetGuidSignature();
    public static ObjectReference`1<Vftbl<K, V>> ObjRefFromAbi(IntPtr thisPtr);
    private sealed virtual override ICollection`1<K> global::System.Collections.Generic.IDictionary<K,V>.get_Keys();
    private sealed virtual override ICollection`1<V> global::System.Collections.Generic.IDictionary<K,V>.get_Values();
    private sealed virtual override int global::System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<K,V>>.get_Count();
    private sealed virtual override bool global::System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<K,V>>.get_IsReadOnly();
    private sealed virtual override V global::System.Collections.Generic.IDictionary<K,V>.get_Item(K key);
    private sealed virtual override void global::System.Collections.Generic.IDictionary<K,V>.set_Item(K key, V value);
    private sealed virtual override void global::System.Collections.Generic.IDictionary<K,V>.Add(K key, V value);
    private sealed virtual override bool global::System.Collections.Generic.IDictionary<K,V>.ContainsKey(K key);
    private sealed virtual override bool global::System.Collections.Generic.IDictionary<K,V>.Remove(K key);
    internal static Dictionary`2<K, ValueTuple`2<IntPtr, V>> GetLookupCache(IWinRTObject _this);
    private sealed virtual override bool global::System.Collections.Generic.IDictionary<K,V>.TryGetValue(K key, V& value);
    private sealed virtual override void global::System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<K,V>>.Add(KeyValuePair`2<K, V> item);
    private sealed virtual override bool global::System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<K,V>>.Contains(KeyValuePair`2<K, V> item);
    private sealed virtual override void global::System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<K,V>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool global::System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<K,V>>.Remove(KeyValuePair`2<K, V> item);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<K, V>> global::System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<K,V>>.GetEnumerator();
    private sealed virtual override IEnumerator global::System.Collections.IEnumerable.GetEnumerator();
}
public static class ABI.System.Collections.Generic.IDictionaryMethods`2 : object {
    public static int get_Count(IObjectReference obj);
    public static bool get_IsReadOnly(IObjectReference _);
    public static void Add(IObjectReference obj, KeyValuePair`2<K, V> item);
    public static void Clear(IObjectReference obj);
    public static bool Contains(IObjectReference obj, Dictionary`2<K, ValueTuple`2<IntPtr, V>> __lookupCache, KeyValuePair`2<K, V> item);
    public static void CopyTo(IObjectReference obj, IObjectReference iEnumerableObjRef, KeyValuePair`2[] array, int arrayIndex);
    public static bool Remove(IObjectReference obj, KeyValuePair`2<K, V> item);
    public static V Indexer_Get(IObjectReference obj, Dictionary`2<K, ValueTuple`2<IntPtr, V>> __lookupCache, K key);
    public static void Indexer_Set(IObjectReference obj, K key, V value);
    public static ICollection`1<K> get_Keys(IObjectReference obj);
    public static ICollection`1<V> get_Values(IObjectReference obj);
    public static bool ContainsKey(IObjectReference obj, K key);
    public static void Add(IObjectReference obj, K key, V value);
    public static bool Remove(IObjectReference obj, K key);
    public static bool TryGetValue(IObjectReference obj, Dictionary`2<K, ValueTuple`2<IntPtr, V>> __lookupCache, K key, V& value);
    private static V Lookup(IObjectReference obj, Dictionary`2<K, ValueTuple`2<IntPtr, V>> __lookupCache, K key);
    private static bool Insert(IObjectReference obj, K key, V value);
}
public static class ABI.System.Collections.Generic.IEnumerable_Delegates : object {
}
[DynamicInterfaceCastableImplementationAttribute]
[GuidAttribute("FAA585EA-6214-4217-AFDA-7F46DE5869B3")]
internal interface ABI.System.Collections.Generic.IEnumerable`1 {
    public static Guid PIID;
    private static IEnumerable`1();
    public static IObjectReference CreateMarshaler(IEnumerable`1<T> obj);
    public static ObjectReferenceValue CreateMarshaler2(IEnumerable`1<T> obj);
    public static IntPtr GetAbi(IObjectReference objRef);
    public static IntPtr FromManaged(IEnumerable`1<T> value);
    public static void DisposeMarshaler(IObjectReference objRef);
    public static void DisposeAbi(IntPtr abi);
    public static string GetGuidSignature();
    public static ObjectReference`1<Vftbl<T>> ObjRefFromAbi(IntPtr thisPtr);
    private sealed virtual override IEnumerator`1<T> global::System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator global::System.Collections.IEnumerable.GetEnumerator();
}
public static class ABI.System.Collections.Generic.IEnumerableMethods`1 : object {
    public static IEnumerator`1<T> GetEnumerator(IObjectReference obj);
}
public static class ABI.System.Collections.Generic.IEnumerator_Delegates : object {
}
[GuidAttribute("6A79E863-4300-459A-9966-CBB660963EE1")]
public class ABI.System.Collections.Generic.IEnumerator`1 : object {
    public static Guid PIID;
    protected ObjectReference`1<Vftbl<T>> _obj;
    private FromAbiHelper<T> _FromIterator;
    public IObjectReference ObjRef { get; }
    public IntPtr ThisPtr { get; }
    public T _Current { get; }
    public bool HasCurrent { get; }
    public T Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public IEnumerator`1(IObjectReference obj);
    public IEnumerator`1(ObjectReference`1<Vftbl<T>> obj);
    private static IEnumerator`1();
    public static IObjectReference CreateMarshaler(IEnumerator`1<T> obj);
    public static ObjectReferenceValue CreateMarshaler2(IEnumerator`1<T> obj);
    public static IntPtr GetAbi(IObjectReference objRef);
    public static IEnumerator`1<T> FromAbi(IntPtr thisPtr);
    internal static IIterator`1<T> FromAbiInternal(IntPtr thisPtr);
    public static IntPtr FromManaged(IEnumerator`1<T> value);
    public static void DisposeMarshaler(IObjectReference objRef);
    public static void DisposeAbi(IntPtr abi);
    public static string GetGuidSignature();
    public static ObjectReference`1<Vftbl<T>> ObjRefFromAbi(IntPtr thisPtr);
    public static IEnumerator`1<T> op_Implicit(IObjectReference obj);
    public static IEnumerator`1<T> op_Implicit(ObjectReference`1<Vftbl<T>> obj);
    public IObjectReference get_ObjRef();
    public IntPtr get_ThisPtr();
    public ObjectReference`1<I> AsInterface();
    public A As();
    public sealed virtual bool _MoveNext();
    public sealed virtual UInt32 GetMany(T[]& items);
    public sealed virtual T get__Current();
    public sealed virtual bool get_HasCurrent();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual void Dispose();
    public sealed virtual T get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
}
public static class ABI.System.Collections.Generic.IList_Delegates : object {
}
[DynamicInterfaceCastableImplementationAttribute]
[GuidAttribute("913337E9-11A1-4345-A3A2-4E7F956E222D")]
internal interface ABI.System.Collections.Generic.IList`1 {
    public static Guid PIID;
    private UInt32 global::Windows.Foundation.Collections.IVector<T>.Size { get; }
    private int global::System.Collections.Generic.ICollection<T>.Count { get; }
    private bool global::System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private T global::System.Collections.Generic.IList<T>.Item { get; private set; }
    private static IList`1();
    public static IObjectReference CreateMarshaler(IList`1<T> obj);
    public static ObjectReferenceValue CreateMarshaler2(IList`1<T> obj);
    public static IntPtr GetAbi(IObjectReference objRef);
    public static IntPtr FromManaged(IList`1<T> value);
    public static void DisposeMarshaler(IObjectReference objRef);
    public static void DisposeAbi(IntPtr abi);
    public static string GetGuidSignature();
    public static ObjectReference`1<Vftbl<T>> ObjRefFromAbi(IntPtr thisPtr);
    private sealed virtual override T global::Windows.Foundation.Collections.IVector<T>.GetAt(UInt32 index);
    private sealed virtual override IReadOnlyList`1<T> global::Windows.Foundation.Collections.IVector<T>.GetView();
    private sealed virtual override bool global::Windows.Foundation.Collections.IVector<T>.IndexOf(T value, UInt32& index);
    private sealed virtual override void global::Windows.Foundation.Collections.IVector<T>.SetAt(UInt32 index, T value);
    private sealed virtual override void global::Windows.Foundation.Collections.IVector<T>.InsertAt(UInt32 index, T value);
    private sealed virtual override void global::Windows.Foundation.Collections.IVector<T>.RemoveAt(UInt32 index);
    private sealed virtual override void global::Windows.Foundation.Collections.IVector<T>.Append(T value);
    private sealed virtual override void global::Windows.Foundation.Collections.IVector<T>.RemoveAtEnd();
    private sealed virtual override void global::Windows.Foundation.Collections.IVector<T>._Clear();
    private sealed virtual override UInt32 global::Windows.Foundation.Collections.IVector<T>.GetMany(UInt32 startIndex, T[]& items);
    private sealed virtual override void global::Windows.Foundation.Collections.IVector<T>.ReplaceAll(T[] items);
    private sealed virtual override UInt32 global::Windows.Foundation.Collections.IVector<T>.get_Size();
    private sealed virtual override int global::System.Collections.Generic.ICollection<T>.get_Count();
    private sealed virtual override bool global::System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override T global::System.Collections.Generic.IList<T>.get_Item(int index);
    private sealed virtual override void global::System.Collections.Generic.IList<T>.set_Item(int index, T value);
    private sealed virtual override int global::System.Collections.Generic.IList<T>.IndexOf(T item);
    private sealed virtual override void global::System.Collections.Generic.IList<T>.Insert(int index, T item);
    private sealed virtual override void global::System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override void global::System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void global::System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool global::System.Collections.Generic.ICollection<T>.Contains(T item);
    private sealed virtual override void global::System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int arrayIndex);
    private sealed virtual override bool global::System.Collections.Generic.ICollection<T>.Remove(T item);
    private sealed virtual override IEnumerator`1<T> global::System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator global::System.Collections.IEnumerable.GetEnumerator();
}
public static class ABI.System.Collections.Generic.IListMethods`1 : object {
    public static int get_Count(IObjectReference obj);
    public static bool get_IsReadOnly(IObjectReference obj);
    public static void Add(IObjectReference obj, T item);
    public static void Clear(IObjectReference obj);
    public static bool Contains(IObjectReference obj, T item);
    public static void CopyTo(IObjectReference obj, T[] array, int arrayIndex);
    public static bool Remove(IObjectReference obj, T item);
    public static T Indexer_Get(IObjectReference obj, int index);
    public static void Indexer_Set(IObjectReference obj, int index, T value);
    public static int IndexOf(IObjectReference obj, T item);
    public static void Insert(IObjectReference obj, int index, T item);
    public static void RemoveAt(IObjectReference obj, int index);
    internal static T GetAtHelper(IObjectReference obj, UInt32 index);
    private static void SetAtHelper(IObjectReference obj, UInt32 index, T value);
    private static void InsertAtHelper(IObjectReference obj, UInt32 index, T item);
    internal static void RemoveAtHelper(IObjectReference obj, UInt32 index);
}
[DynamicInterfaceCastableImplementationAttribute]
internal interface ABI.System.Collections.Generic.IReadOnlyCollection`1 {
    private int global::System.Collections.Generic.IReadOnlyCollection<T>.Count { get; }
    private static IReadOnlyCollection`1<T> CreateHelper(IWinRTObject _this);
    private static IReadOnlyCollection`1<T> GetHelper(IWinRTObject _this);
    private sealed virtual override int global::System.Collections.Generic.IReadOnlyCollection<T>.get_Count();
    private sealed virtual override IEnumerator global::System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<T> global::System.Collections.Generic.IEnumerable<T>.GetEnumerator();
}
public static class ABI.System.Collections.Generic.IReadOnlyDictionary_Delegates : object {
}
[DynamicInterfaceCastableImplementationAttribute]
[GuidAttribute("E480CE40-A338-4ADA-ADCF-272272E48CB9")]
internal interface ABI.System.Collections.Generic.IReadOnlyDictionary`2 {
    public static Guid PIID;
    private IEnumerable`1<K> global::System.Collections.Generic.IReadOnlyDictionary<K,V>.Keys { get; }
    private IEnumerable`1<V> global::System.Collections.Generic.IReadOnlyDictionary<K,V>.Values { get; }
    private int global::System.Collections.Generic.IReadOnlyCollection<System.Collections.Generic.KeyValuePair<K,V>>.Count { get; }
    private V global::System.Collections.Generic.IReadOnlyDictionary<K,V>.Item { get; }
    private static IReadOnlyDictionary`2();
    public static IObjectReference CreateMarshaler(IReadOnlyDictionary`2<K, V> obj);
    public static ObjectReferenceValue CreateMarshaler2(IReadOnlyDictionary`2<K, V> obj);
    public static IntPtr GetAbi(IObjectReference objRef);
    public static IntPtr FromManaged(IReadOnlyDictionary`2<K, V> value);
    public static void DisposeMarshaler(IObjectReference objRef);
    public static void DisposeAbi(IntPtr abi);
    public static string GetGuidSignature();
    public static ObjectReference`1<Vftbl<K, V>> ObjRefFromAbi(IntPtr thisPtr);
    private sealed virtual override IEnumerable`1<K> global::System.Collections.Generic.IReadOnlyDictionary<K,V>.get_Keys();
    private sealed virtual override IEnumerable`1<V> global::System.Collections.Generic.IReadOnlyDictionary<K,V>.get_Values();
    private sealed virtual override int global::System.Collections.Generic.IReadOnlyCollection<System.Collections.Generic.KeyValuePair<K,V>>.get_Count();
    private sealed virtual override V global::System.Collections.Generic.IReadOnlyDictionary<K,V>.get_Item(K key);
    private sealed virtual override bool global::System.Collections.Generic.IReadOnlyDictionary<K,V>.ContainsKey(K key);
    private sealed virtual override bool global::System.Collections.Generic.IReadOnlyDictionary<K,V>.TryGetValue(K key, V& value);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<K, V>> global::System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<K,V>>.GetEnumerator();
    private sealed virtual override IEnumerator global::System.Collections.IEnumerable.GetEnumerator();
}
public static class ABI.System.Collections.Generic.IReadOnlyDictionaryMethods`2 : object {
    public static int get_Count(IObjectReference obj);
    public static V Indexer_Get(IObjectReference obj, K key);
    public static IEnumerable`1<K> get_Keys(IObjectReference obj);
    public static IEnumerable`1<V> get_Values(IObjectReference obj);
    public static bool ContainsKey(IObjectReference obj, K key);
    public static bool TryGetValue(IObjectReference obj, K key, V& value);
    public static V Lookup(IObjectReference obj, K key);
}
public static class ABI.System.Collections.Generic.IReadOnlyList_Delegates : object {
}
[DynamicInterfaceCastableImplementationAttribute]
[GuidAttribute("BBE1FA4C-B0E3-4583-BAEF-1F1B2E483E56")]
internal interface ABI.System.Collections.Generic.IReadOnlyList`1 {
    public static Guid PIID;
    private int global::System.Collections.Generic.IReadOnlyCollection<T>.Count { get; }
    private T global::System.Collections.Generic.IReadOnlyList<T>.Item { get; }
    private static IReadOnlyList`1();
    public static IObjectReference CreateMarshaler(IReadOnlyList`1<T> obj);
    public static ObjectReferenceValue CreateMarshaler2(IReadOnlyList`1<T> obj);
    public static IntPtr GetAbi(IObjectReference objRef);
    public static IntPtr FromManaged(IReadOnlyList`1<T> value);
    public static void DisposeMarshaler(IObjectReference objRef);
    public static void DisposeAbi(IntPtr abi);
    public static string GetGuidSignature();
    public static ObjectReference`1<Vftbl<T>> ObjRefFromAbi(IntPtr thisPtr);
    private sealed virtual override int global::System.Collections.Generic.IReadOnlyCollection<T>.get_Count();
    private sealed virtual override T global::System.Collections.Generic.IReadOnlyList<T>.get_Item(int index);
    private sealed virtual override IEnumerator`1<T> global::System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator global::System.Collections.IEnumerable.GetEnumerator();
}
public static class ABI.System.Collections.Generic.IReadOnlyListMethods`1 : object {
    public static int get_Count(IObjectReference obj);
    public static T Indexer_Get(IObjectReference obj, int index);
}
internal static class ABI.System.Collections.Generic.IVectorMethods`1 : object {
    public static UInt32 get_Size(IObjectReference obj);
    public static T GetAt(IObjectReference obj, UInt32 index);
    public static IReadOnlyList`1<T> GetView(IObjectReference obj);
    public static bool IndexOf(IObjectReference obj, T value, UInt32& index);
    public static void SetAt(IObjectReference obj, UInt32 index, T value);
    public static void InsertAt(IObjectReference obj, UInt32 index, T value);
    public static void RemoveAt(IObjectReference obj, UInt32 index);
    public static void Append(IObjectReference obj, T value);
    public static void RemoveAtEnd(IObjectReference obj);
    public static void Clear(IObjectReference obj);
    public static UInt32 GetMany(IObjectReference obj, UInt32 startIndex, T[]& items);
    public static void ReplaceAll(IObjectReference obj, T[] items);
}
[GuidAttribute("02B51929-C1C4-4A7E-8940-0312B5C18500")]
public class ABI.System.Collections.Generic.KeyValuePair`2 : object {
    public static Guid PIID;
    protected ObjectReference`1<Vftbl<K, V>> _obj;
    public IObjectReference ObjRef { get; }
    public IntPtr ThisPtr { get; }
    public K Key { get; }
    public V Value { get; }
    public KeyValuePair`2(IObjectReference obj);
    public KeyValuePair`2(ObjectReference`1<Vftbl<K, V>> obj);
    private static KeyValuePair`2();
    public static IObjectReference CreateMarshaler(KeyValuePair`2<K, V> obj);
    public static ObjectReferenceValue CreateMarshaler2(KeyValuePair`2<K, V> obj);
    public static IntPtr GetAbi(IObjectReference objRef);
    public static object CreateRcw(IInspectable obj);
    public static KeyValuePair`2<K, V> FromAbi(IntPtr thisPtr);
    public static IntPtr FromManaged(KeyValuePair`2<K, V> obj);
    internal static void CopyManaged(KeyValuePair`2<K, V> o, IntPtr dest);
    internal static MarshalerArray<KeyValuePair`2<K, V>> CreateMarshalerArray(KeyValuePair`2[] array);
    internal static ValueTuple`2<int, IntPtr> GetAbiArray(object box);
    internal static KeyValuePair`2[] FromAbiArray(object box);
    public static ValueTuple`2<int, IntPtr> FromManagedArray(KeyValuePair`2[] array);
    internal static void CopyManagedArray(KeyValuePair`2[] array, IntPtr data);
    public static void DisposeMarshaler(IObjectReference value);
    public static void DisposeAbi(IntPtr abi);
    public static string GetGuidSignature();
    public static ObjectReference`1<Vftbl<K, V>> _FromAbi(IntPtr thisPtr);
    public static KeyValuePair`2<K, V> op_Implicit(IObjectReference obj);
    public static KeyValuePair`2<K, V> op_Implicit(ObjectReference`1<Vftbl<K, V>> obj);
    public IObjectReference get_ObjRef();
    public IntPtr get_ThisPtr();
    public ObjectReference`1<I> AsInterface();
    public A As();
    public sealed virtual K get_Key();
    public sealed virtual V get_Value();
}
[DynamicInterfaceCastableImplementationAttribute]
[GuidAttribute("036D2C08-DF29-41AF-8AA2-D774BE62BA6F")]
internal interface ABI.System.Collections.IEnumerable {
    public static string GetGuidSignature();
    internal static ObjectReference`1<Vftbl> ObjRefFromAbi(IntPtr thisPtr);
    private static FromAbiHelper _AbiHelper(IWinRTObject _this);
    private sealed virtual override IBindableIterator global::Microsoft.UI.Xaml.Interop.IBindableIterable.First();
    private sealed virtual override IEnumerator global::System.Collections.IEnumerable.GetEnumerator();
}
[EditorBrowsableAttribute("1")]
public static class ABI.System.Collections.IEnumerable_Delegates : object {
}
[DynamicInterfaceCastableImplementationAttribute]
[GuidAttribute("393DE7DE-6FD0-4C0D-BB71-47244A113E93")]
internal interface ABI.System.Collections.IList {
    private UInt32 global::Microsoft.UI.Xaml.Interop.IBindableVector.Size { get; }
    private object global::System.Collections.IList.Item { get; private set; }
    private bool global::System.Collections.IList.IsFixedSize { get; }
    private bool global::System.Collections.IList.IsReadOnly { get; }
    private int global::System.Collections.ICollection.Count { get; }
    private bool global::System.Collections.ICollection.IsSynchronized { get; }
    private object global::System.Collections.ICollection.SyncRoot { get; }
    public static string GetGuidSignature();
    internal static ObjectReference`1<Vftbl> ObjRefFromAbi(IntPtr thisPtr);
    private static FromAbiHelper _VectorToList(IWinRTObject _this);
    private sealed virtual override object global::Microsoft.UI.Xaml.Interop.IBindableVector.GetAt(UInt32 index);
    private sealed virtual override IBindableVectorView global::Microsoft.UI.Xaml.Interop.IBindableVector.GetView();
    private sealed virtual override bool global::Microsoft.UI.Xaml.Interop.IBindableVector.IndexOf(object value, UInt32& index);
    private sealed virtual override void global::Microsoft.UI.Xaml.Interop.IBindableVector.SetAt(UInt32 index, object value);
    private sealed virtual override void global::Microsoft.UI.Xaml.Interop.IBindableVector.InsertAt(UInt32 index, object value);
    private sealed virtual override void global::Microsoft.UI.Xaml.Interop.IBindableVector.RemoveAt(UInt32 index);
    private sealed virtual override void global::Microsoft.UI.Xaml.Interop.IBindableVector.Append(object value);
    private sealed virtual override void global::Microsoft.UI.Xaml.Interop.IBindableVector.RemoveAtEnd();
    private sealed virtual override void global::Microsoft.UI.Xaml.Interop.IBindableVector.Clear();
    private sealed virtual override UInt32 global::Microsoft.UI.Xaml.Interop.IBindableVector.get_Size();
    private sealed virtual override object global::System.Collections.IList.get_Item(int index);
    private sealed virtual override void global::System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override bool global::System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool global::System.Collections.IList.get_IsReadOnly();
    private sealed virtual override int global::System.Collections.ICollection.get_Count();
    private sealed virtual override bool global::System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object global::System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override int global::System.Collections.IList.Add(object value);
    private sealed virtual override void global::System.Collections.IList.Clear();
    private sealed virtual override bool global::System.Collections.IList.Contains(object value);
    private sealed virtual override int global::System.Collections.IList.IndexOf(object value);
    private sealed virtual override void global::System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void global::System.Collections.IList.Remove(object value);
    private sealed virtual override void global::System.Collections.IList.RemoveAt(int index);
    private sealed virtual override void global::System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator global::System.Collections.IEnumerable.GetEnumerator();
}
internal static class ABI.System.Collections.IList_Delegates : object {
}
[DynamicInterfaceCastableImplementationAttribute]
[EditorBrowsableAttribute("1")]
[GuidAttribute("530155E1-28A5-5693-87CE-30724D95A06D")]
public interface ABI.System.Collections.Specialized.INotifyCollectionChanged {
    internal static ObjectReference`1<Vftbl> FromAbi(IntPtr thisPtr);
    private static NotifyCollectionChangedEventSource _CollectionChanged(IWinRTObject _this);
    private sealed virtual override void global::System.Collections.Specialized.INotifyCollectionChanged.add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    private sealed virtual override void global::System.Collections.Specialized.INotifyCollectionChanged.remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
}
internal static class ABI.System.Collections.Specialized.NotifyCollectionChangedAction : object {
    public static string GetGuidSignature();
}
[EditorBrowsableAttribute("1")]
public class ABI.System.Collections.Specialized.NotifyCollectionChangedEventArgs : ValueType {
    public static IObjectReference CreateMarshaler(NotifyCollectionChangedEventArgs value);
    public static ObjectReferenceValue CreateMarshaler2(NotifyCollectionChangedEventArgs value);
    public static IntPtr GetAbi(IObjectReference m);
    public static NotifyCollectionChangedEventArgs FromAbi(IntPtr ptr);
    private static NotifyCollectionChangedEventArgs CreateNotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList newItems, IList oldItems, int newStartingIndex, int oldStartingIndex);
    public static void CopyManaged(NotifyCollectionChangedEventArgs o, IntPtr dest);
    public static IntPtr FromManaged(NotifyCollectionChangedEventArgs value);
    public static void DisposeMarshaler(IObjectReference m);
    public static void DisposeAbi(IntPtr abi);
    public static string GetGuidSignature();
}
[EditorBrowsableAttribute("1")]
[GuidAttribute("8B0909DC-2005-5D93-BF8A-725F017BAA8D")]
public static class ABI.System.Collections.Specialized.NotifyCollectionChangedEventHandler : object {
    private static IDelegateVftbl AbiToProjectionVftable;
    public static IntPtr AbiToProjectionVftablePtr;
    [CompilerGeneratedAttribute]
private static Delegate <AbiInvokeDelegate>k__BackingField;
    private static Guid IID;
    public static Delegate AbiInvokeDelegate { get; }
    private static NotifyCollectionChangedEventHandler();
    [CompilerGeneratedAttribute]
public static Delegate get_AbiInvokeDelegate();
    public static IObjectReference CreateMarshaler(NotifyCollectionChangedEventHandler managedDelegate);
    public static ObjectReferenceValue CreateMarshaler2(NotifyCollectionChangedEventHandler managedDelegate);
    public static IntPtr GetAbi(IObjectReference value);
    public static NotifyCollectionChangedEventHandler FromAbi(IntPtr nativeDelegate);
    public static NotifyCollectionChangedEventHandler CreateRcw(IntPtr ptr);
    public static IntPtr FromManaged(NotifyCollectionChangedEventHandler managedDelegate);
    public static void DisposeMarshaler(IObjectReference value);
    public static void DisposeAbi(IntPtr abi);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_Invoke(IntPtr thisPtr, IntPtr sender, IntPtr e);
}
internal class ABI.System.Collections.Specialized.NotifyCollectionChangedEventSource : EventSource`1<NotifyCollectionChangedEventHandler> {
    internal NotifyCollectionChangedEventSource(IObjectReference obj, method addHandler, method removeHandler);
    protected virtual ObjectReferenceValue CreateMarshaler(NotifyCollectionChangedEventHandler del);
    protected virtual State CreateEventState();
}
[EditorBrowsableAttribute("1")]
public class ABI.System.ComponentModel.DataErrorsChangedEventArgs : ValueType {
    public static IObjectReference CreateMarshaler(DataErrorsChangedEventArgs value);
    public static ObjectReferenceValue CreateMarshaler2(DataErrorsChangedEventArgs value);
    public static IntPtr GetAbi(IObjectReference m);
    public static DataErrorsChangedEventArgs FromAbi(IntPtr ptr);
    public static void CopyManaged(DataErrorsChangedEventArgs o, IntPtr dest);
    public static IntPtr FromManaged(DataErrorsChangedEventArgs value);
    public static void DisposeMarshaler(IObjectReference m);
    public static void DisposeAbi(IntPtr abi);
    public static string GetGuidSignature();
}
[DynamicInterfaceCastableImplementationAttribute]
[EditorBrowsableAttribute("1")]
[GuidAttribute("0EE6C2CC-273E-567D-BC0A-1DD87EE51EBA")]
public interface ABI.System.ComponentModel.INotifyDataErrorInfo {
    private bool global::System.ComponentModel.INotifyDataErrorInfo.HasErrors { get; }
    internal static ObjectReference`1<Vftbl> FromAbi(IntPtr thisPtr);
    private static EventSource__EventHandler`1<DataErrorsChangedEventArgs> _ErrorsChanged(IWinRTObject _this);
    private sealed virtual override IEnumerable global::System.ComponentModel.INotifyDataErrorInfo.GetErrors(string propertyName);
    private sealed virtual override bool global::System.ComponentModel.INotifyDataErrorInfo.get_HasErrors();
    private sealed virtual override void global::System.ComponentModel.INotifyDataErrorInfo.add_ErrorsChanged(EventHandler`1<DataErrorsChangedEventArgs> value);
    private sealed virtual override void global::System.ComponentModel.INotifyDataErrorInfo.remove_ErrorsChanged(EventHandler`1<DataErrorsChangedEventArgs> value);
}
internal static class ABI.System.ComponentModel.INotifyDataErrorInfo_Delegates : object {
}
[DynamicInterfaceCastableImplementationAttribute]
[GuidAttribute("90B17601-B065-586E-83D9-9ADC3A695284")]
internal interface ABI.System.ComponentModel.INotifyPropertyChanged {
    internal static ObjectReference`1<Vftbl> FromAbi(IntPtr thisPtr);
    private static PropertyChangedEventSource _PropertyChanged(IWinRTObject _this);
    private sealed virtual override void global::System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void global::System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
}
[EditorBrowsableAttribute("1")]
public class ABI.System.ComponentModel.PropertyChangedEventArgs : ValueType {
    public static IObjectReference CreateMarshaler(PropertyChangedEventArgs value);
    public static ObjectReferenceValue CreateMarshaler2(PropertyChangedEventArgs value);
    public static IntPtr GetAbi(IObjectReference m);
    public static PropertyChangedEventArgs FromAbi(IntPtr ptr);
    public static void CopyManaged(PropertyChangedEventArgs o, IntPtr dest);
    public static IntPtr FromManaged(PropertyChangedEventArgs value);
    public static void DisposeMarshaler(IObjectReference m);
    public static void DisposeAbi(IntPtr abi);
    public static string GetGuidSignature();
}
[EditorBrowsableAttribute("1")]
[GuidAttribute("E3DE52F6-1E32-5DA6-BB2D-B5B6096C962D")]
public static class ABI.System.ComponentModel.PropertyChangedEventHandler : object {
    private static IDelegateVftbl AbiToProjectionVftable;
    public static IntPtr AbiToProjectionVftablePtr;
    [CompilerGeneratedAttribute]
private static Delegate <AbiInvokeDelegate>k__BackingField;
    private static Guid IID;
    public static Delegate AbiInvokeDelegate { get; }
    private static PropertyChangedEventHandler();
    [CompilerGeneratedAttribute]
public static Delegate get_AbiInvokeDelegate();
    public static IObjectReference CreateMarshaler(PropertyChangedEventHandler managedDelegate);
    public static ObjectReferenceValue CreateMarshaler2(PropertyChangedEventHandler managedDelegate);
    public static IntPtr GetAbi(IObjectReference value);
    public static PropertyChangedEventHandler FromAbi(IntPtr nativeDelegate);
    public static PropertyChangedEventHandler CreateRcw(IntPtr ptr);
    public static IntPtr FromManaged(PropertyChangedEventHandler managedDelegate);
    public static void DisposeMarshaler(IObjectReference value);
    public static void DisposeAbi(IntPtr abi);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_Invoke(IntPtr thisPtr, IntPtr sender, IntPtr e);
}
internal class ABI.System.ComponentModel.PropertyChangedEventSource : EventSource`1<PropertyChangedEventHandler> {
    internal PropertyChangedEventSource(IObjectReference obj, method addHandler, method removeHandler);
    protected virtual ObjectReferenceValue CreateMarshaler(PropertyChangedEventHandler del);
    protected virtual State CreateEventState();
}
public class ABI.System.DateTimeOffset : ValueType {
    public long UniversalTime;
    private static long ManagedUtcTicksAtNativeZero;
    public static Marshaler CreateMarshaler(DateTimeOffset value);
    public static DateTimeOffset GetAbi(Marshaler m);
    public static DateTimeOffset FromAbi(DateTimeOffset value);
    public static void CopyAbi(Marshaler arg, IntPtr dest);
    public static DateTimeOffset FromManaged(DateTimeOffset value);
    public static void CopyManaged(DateTimeOffset arg, IntPtr dest);
    public static void DisposeMarshaler(Marshaler m);
    public static void DisposeAbi(DateTimeOffset abi);
    public static string GetGuidSignature();
}
[GuidAttribute("c50898f6-c536-5f47-8583-8b2c2438a13b")]
internal static class ABI.System.EventHandler : object {
    private static IDelegateVftbl AbiToProjectionVftable;
    public static IntPtr AbiToProjectionVftablePtr;
    private static Guid IID;
    private static EventHandler();
    public static IObjectReference CreateMarshaler(EventHandler managedDelegate);
    public static ObjectReferenceValue CreateMarshaler2(EventHandler managedDelegate);
    public static IntPtr GetAbi(IObjectReference value);
    public static EventHandler FromAbi(IntPtr nativeDelegate);
    public static EventHandler CreateRcw(IntPtr ptr);
    public static IntPtr FromManaged(EventHandler managedDelegate);
    public static void DisposeMarshaler(IObjectReference value);
    public static void DisposeAbi(IntPtr abi);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_Invoke(IntPtr thisPtr, IntPtr sender, IntPtr args);
}
[GuidAttribute("9DE1C535-6AE1-11E0-84E1-18A905BCC53F")]
[EditorBrowsableAttribute("1")]
public static class ABI.System.EventHandler`1 : object {
    public static Guid PIID;
    private static Type Abi_Invoke_Type;
    private static IDelegateVftbl AbiToProjectionVftable;
    public static IntPtr AbiToProjectionVftablePtr;
    [CompilerGeneratedAttribute]
private static Delegate <AbiInvokeDelegate>k__BackingField;
    public static Delegate AbiInvokeDelegate { get; }
    private static EventHandler`1();
    [CompilerGeneratedAttribute]
public static Delegate get_AbiInvokeDelegate();
    public static IObjectReference CreateMarshaler(EventHandler`1<T> managedDelegate);
    public static ObjectReferenceValue CreateMarshaler2(EventHandler`1<T> managedDelegate);
    public static IntPtr GetAbi(IObjectReference value);
    public static EventHandler`1<T> FromAbi(IntPtr nativeDelegate);
    public static EventHandler`1<T> CreateRcw(IntPtr ptr);
    public static IntPtr FromManaged(EventHandler`1<T> managedDelegate);
    public static void DisposeMarshaler(IObjectReference value);
    public static void DisposeAbi(IntPtr abi);
    private static int Do_Abi_Invoke(Void* thisPtr, IntPtr sender, TAbi args);
}
internal class ABI.System.EventHandlerEventSource : EventSource`1<EventHandler> {
    internal EventHandlerEventSource(IObjectReference obj, method addHandler, method removeHandler);
    protected virtual ObjectReferenceValue CreateMarshaler(EventHandler del);
    protected virtual State CreateEventState();
}
public class ABI.System.Exception : ValueType {
    public int hr;
    public static Marshaler CreateMarshaler(Exception value);
    public static Exception GetAbi(Marshaler m);
    public static Exception FromAbi(Exception value);
    public static void CopyAbi(Marshaler arg, IntPtr dest);
    public static Exception FromManaged(Exception value);
    public static void CopyManaged(Exception arg, IntPtr dest);
    public static void DisposeMarshaler(Marshaler m);
    public static void DisposeAbi(Exception abi);
    public static string GetGuidSignature();
}
[DynamicInterfaceCastableImplementationAttribute]
[EditorBrowsableAttribute("1")]
[GuidAttribute("30D5A829-7FA4-4026-83BB-D75BAE4EA99E")]
public interface ABI.System.IDisposable {
    internal static ObjectReference`1<Vftbl> FromAbi(IntPtr thisPtr);
    private sealed virtual override void global::System.IDisposable.Dispose();
}
[EditorBrowsableAttribute("1")]
[GuidAttribute("68B3A2DF-8173-539F-B524-C8A2348F5AFB")]
[DynamicInterfaceCastableImplementationAttribute]
internal interface ABI.System.IServiceProvider {
    internal static ObjectReference`1<Vftbl> FromAbi(IntPtr thisPtr);
    private sealed virtual override object global::System.IServiceProvider.GetService(Type type);
}
internal static class ABI.System.IXamlServiceProvider_Delegates : object {
}
internal class ABI.System.Nullable : object {
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public object Value { get; }
    public Nullable(object boxedObject);
    [CompilerGeneratedAttribute]
public object get_Value();
}
[GuidAttribute("3c00fd60-2950-5939-a21a-2d12c5a01b8a")]
internal static class ABI.System.Nullable_bool : object {
    internal static Guid IID;
    private static Nullable_bool();
    public static string GetGuidSignature();
    internal static bool GetValue(IInspectable inspectable);
}
[GuidAttribute("e5198cc8-2873-55f5-b0a1-84ff9e4aad62")]
internal static class ABI.System.Nullable_byte : object {
    internal static Guid IID;
    private static Nullable_byte();
    public static string GetGuidSignature();
    internal static byte GetValue(IInspectable inspectable);
}
[GuidAttribute("fb393ef3-bbac-5bd5-9144-84f23576f415")]
internal static class ABI.System.Nullable_char : object {
    internal static Guid IID;
    private static Nullable_char();
    public static string GetGuidSignature();
    internal static char GetValue(IInspectable inspectable);
}
[GuidAttribute("5541d8a7-497c-5aa4-86fc-7713adbf2a2c")]
internal static class ABI.System.Nullable_DateTimeOffset : object {
    internal static Guid IID;
    private static Nullable_DateTimeOffset();
    public static string GetGuidSignature();
    internal static DateTimeOffset GetValue(IInspectable inspectable);
}
[GuidAttribute("61C17706-2D65-11E0-9AE8-D48564015472")]
internal static class ABI.System.Nullable_Delegate`1 : object {
    public static Guid PIID;
    private static Nullable_Delegate`1();
    public static string GetGuidSignature();
    internal static Nullable GetValue(IInspectable inspectable);
}
internal static class ABI.System.Nullable_Delegates : object {
}
[GuidAttribute("2f2d6c29-5473-5f3e-92e7-96572bb990e2")]
internal static class ABI.System.Nullable_double : object {
    internal static Guid IID;
    private static Nullable_double();
    public static string GetGuidSignature();
    internal static double GetValue(IInspectable inspectable);
}
[GuidAttribute("719cc2ba-3e76-5def-9f1a-38d85a145ea8")]
internal static class ABI.System.Nullable_float : object {
    internal static Guid IID;
    private static Nullable_float();
    public static string GetGuidSignature();
    internal static float GetValue(IInspectable inspectable);
}
[GuidAttribute("7d50f649-632c-51f9-849a-ee49428933ea")]
internal static class ABI.System.Nullable_guid : object {
    internal static Guid IID;
    private static Nullable_guid();
    public static string GetGuidSignature();
    internal static Guid GetValue(IInspectable inspectable);
}
[GuidAttribute("548cefbd-bc8a-5fa0-8df2-957440fc8bf4")]
internal static class ABI.System.Nullable_int : object {
    internal static Guid IID;
    private static Nullable_int();
    public static string GetGuidSignature();
    internal static int GetValue(IInspectable inspectable);
}
[GuidAttribute("4dda9e24-e69f-5c6a-a0a6-93427365af2a")]
internal static class ABI.System.Nullable_long : object {
    internal static Guid IID;
    private static Nullable_long();
    public static string GetGuidSignature();
    internal static long GetValue(IInspectable inspectable);
}
[GuidAttribute("06dccc90-a058-5c88-87b7-6f3360a2fc16")]
internal static class ABI.System.Nullable_Object : object {
    internal static Guid IID;
    private static Nullable_Object();
    public static string GetGuidSignature();
}
[GuidAttribute("95500129-fbf6-5afc-89df-70642d741990")]
internal static class ABI.System.Nullable_sbyte : object {
    internal static Guid IID;
    private static Nullable_sbyte();
    public static string GetGuidSignature();
    internal static sbyte GetValue(IInspectable inspectable);
}
[GuidAttribute("6ec9e41b-6709-5647-9918-a1270110fc4e")]
internal static class ABI.System.Nullable_short : object {
    internal static Guid IID;
    private static Nullable_short();
    public static string GetGuidSignature();
    internal static short GetValue(IInspectable inspectable);
}
[GuidAttribute("fd416dfb-2a07-52eb-aae3-dfce14116c05")]
internal static class ABI.System.Nullable_string : object {
    internal static Guid IID;
    private static Nullable_string();
    public static string GetGuidSignature();
    internal static Nullable GetValue(IInspectable inspectable);
}
[GuidAttribute("604d0c4c-91de-5c2a-935f-362f13eaf800")]
internal static class ABI.System.Nullable_TimeSpan : object {
    internal static Guid IID;
    private static Nullable_TimeSpan();
    public static string GetGuidSignature();
    internal static TimeSpan GetValue(IInspectable inspectable);
}
[GuidAttribute("3830ad99-d8da-53f3-989b-fc92ad222778")]
internal static class ABI.System.Nullable_Type : object {
    internal static Guid IID;
    private static Nullable_Type();
    public static string GetGuidSignature();
    internal static Nullable GetValue(IInspectable inspectable);
}
[GuidAttribute("513ef3af-e784-5325-a91e-97c2b8111cf3")]
internal static class ABI.System.Nullable_uint : object {
    internal static Guid IID;
    private static Nullable_uint();
    public static string GetGuidSignature();
    internal static UInt32 GetValue(IInspectable inspectable);
}
[GuidAttribute("6755e376-53bb-568b-a11d-17239868309e")]
internal static class ABI.System.Nullable_ulong : object {
    internal static Guid IID;
    private static Nullable_ulong();
    public static string GetGuidSignature();
    internal static ulong GetValue(IInspectable inspectable);
}
[GuidAttribute("5ab7d2c3-6b62-5e71-a4b6-2d49c4f238fd")]
internal static class ABI.System.Nullable_ushort : object {
    internal static Guid IID;
    private static Nullable_ushort();
    public static string GetGuidSignature();
    internal static ushort GetValue(IInspectable inspectable);
}
[ObjectReferenceWrapperAttribute("_obj")]
[GuidAttribute("61C17706-2D65-11E0-9AE8-D48564015472")]
public class ABI.System.Nullable`1 : object {
    public static Guid PIID;
    protected ObjectReference`1<Vftbl<T>> _obj;
    public IntPtr ThisPtr { get; }
    public T Value { get; }
    public Nullable`1(IObjectReference obj);
    public Nullable`1(ObjectReference`1<Vftbl<T>> obj);
    private static Nullable`1();
    public static IObjectReference CreateMarshaler(object value);
    public static ObjectReferenceValue CreateMarshaler2(object value);
    public static IntPtr GetAbi(IObjectReference m);
    public static object FromAbi(IntPtr ptr);
    public static void CopyManaged(object o, IntPtr dest);
    public static IntPtr FromManaged(object value);
    public static void DisposeMarshaler(IObjectReference m);
    public static void DisposeAbi(IntPtr abi);
    public static string GetGuidSignature();
    public static Nullable`1<T> op_Implicit(IObjectReference obj);
    public static Nullable`1<T> op_Implicit(ObjectReference`1<Vftbl<T>> obj);
    public IntPtr get_ThisPtr();
    public ObjectReference`1<I> AsInterface();
    public A As();
    internal static T GetValue(IInspectable inspectable);
    public T get_Value();
}
public class ABI.System.Numerics.Matrix3x2 : ValueType {
    public static string GetGuidSignature();
}
public class ABI.System.Numerics.Matrix4x4 : ValueType {
    public static string GetGuidSignature();
}
public class ABI.System.Numerics.Plane : ValueType {
    public static string GetGuidSignature();
}
public class ABI.System.Numerics.Quaternion : ValueType {
    public static string GetGuidSignature();
}
public class ABI.System.Numerics.Vector2 : ValueType {
    public static string GetGuidSignature();
}
public class ABI.System.Numerics.Vector3 : ValueType {
    public static string GetGuidSignature();
}
public class ABI.System.Numerics.Vector4 : ValueType {
    public static string GetGuidSignature();
}
public class ABI.System.TimeSpan : ValueType {
    public long Duration;
    public static Marshaler CreateMarshaler(TimeSpan value);
    public static TimeSpan GetAbi(Marshaler m);
    public static TimeSpan FromAbi(TimeSpan value);
    public static void CopyAbi(Marshaler arg, IntPtr dest);
    public static TimeSpan FromManaged(TimeSpan value);
    public static void CopyManaged(TimeSpan arg, IntPtr dest);
    public static void DisposeMarshaler(Marshaler m);
    public static void DisposeAbi(TimeSpan abi);
    public static string GetGuidSignature();
}
public class ABI.System.Type : ValueType {
    private IntPtr Name;
    private TypeKind Kind;
    private static ConcurrentDictionary`2<Type, string> typeNameCache;
    private static Type();
    private static ValueTuple`2<string, TypeKind> ToAbi(Type value);
    private static string GetNameForTypeCached(Type value, bool customKind);
    public static Marshaler CreateMarshaler(Type value);
    public static Type GetAbi(Pinnable& p);
    public static Type GetAbi(Marshaler m);
    public static Type FromAbi(Type value);
    public static void CopyAbi(Marshaler arg, IntPtr dest);
    public static Type FromManaged(Type value);
    public static void CopyManaged(Type arg, IntPtr dest);
    public static void DisposeMarshaler(Marshaler m);
    public static void DisposeAbi(Type abi);
    public static string GetGuidSignature();
}
[WindowsRuntimeTypeAttribute("Windows.Foundation.UniversalApiContract")]
internal enum ABI.System.TypeKind : Enum {
    public int value__;
    public static TypeKind Primitive;
    public static TypeKind Metadata;
    public static TypeKind Custom;
}
public class ABI.System.Uri : ValueType {
    public static IObjectReference CreateMarshaler(Uri value);
    public static ObjectReferenceValue CreateMarshaler2(Uri value);
    public static IntPtr GetAbi(IObjectReference m);
    public static Uri FromAbi(IntPtr ptr);
    public static void CopyManaged(Uri o, IntPtr dest);
    public static IntPtr FromManaged(Uri value);
    public static void DisposeMarshaler(IObjectReference m);
    public static void DisposeAbi(IntPtr abi);
    public static string GetGuidSignature();
}
[EditorBrowsableAttribute("1")]
[GuidAttribute("E5AF3542-CA67-4081-995B-709DD13792DF")]
[DynamicInterfaceCastableImplementationAttribute]
public interface ABI.System.Windows.Input.ICommand {
    public static ObjectReference`1<Vftbl> FromAbi(IntPtr thisPtr);
    private static EventHandlerEventSource _CanExecuteChanged(IWinRTObject _this);
    private sealed virtual override bool global::System.Windows.Input.ICommand.CanExecute(object parameter);
    private sealed virtual override void global::System.Windows.Input.ICommand.Execute(object parameter);
    private sealed virtual override void global::System.Windows.Input.ICommand.add_CanExecuteChanged(EventHandler value);
    private sealed virtual override void global::System.Windows.Input.ICommand.remove_CanExecuteChanged(EventHandler value);
}
[EditorBrowsableAttribute("1")]
public static class ABI.System.Windows.Input.ICommand_Delegates : object {
}
[ObjectReferenceWrapperAttribute("_obj")]
[GuidAttribute("44A9796F-723E-4FDF-A218-033E75B0C084")]
internal class ABI.System.WinRTUriRuntimeClassFactory : object {
    private ObjectReference`1<Vftbl> _obj;
    public IntPtr ThisPtr { get; }
    public WinRTUriRuntimeClassFactory(IObjectReference obj);
    public WinRTUriRuntimeClassFactory(ObjectReference`1<Vftbl> obj);
    public static ObjectReference`1<Vftbl> FromAbi(IntPtr thisPtr);
    public static WinRTUriRuntimeClassFactory op_Implicit(IObjectReference obj);
    public static WinRTUriRuntimeClassFactory op_Implicit(ObjectReference`1<Vftbl> obj);
    public IntPtr get_ThisPtr();
    public ObjectReference`1<I> AsInterface();
    public A As();
    public IObjectReference CreateUri(string uri);
    public ObjectReferenceValue CreateUriForMarshaling(string uri);
}
internal static class ABI.Windows.Foundation.BoxedArrayIReferenceArrayImpl`1 : object {
    private static Vftbl<T> AbiToProjectionVftable;
    public static IntPtr AbiToProjectionVftablePtr;
    private static Delegate DelegateCache;
    private static BoxedArrayIReferenceArrayImpl`1();
    private static int Do_Abi_get_Value_0(IntPtr thisPtr, Int32& ____return_value__Size, IntPtr& __return_value__);
}
internal static class ABI.Windows.Foundation.BoxedValueIReferenceImpl`1 : object {
    private static Vftbl<T> AbiToProjectionVftable;
    public static IntPtr AbiToProjectionVftablePtr;
    private static BoxedValueIReferenceImpl`1();
    private static int Do_Abi_get_Value_0(Void* thisPtr, TAbi& __return_value__);
}
[DynamicInterfaceCastableImplementationAttribute]
[GuidAttribute("FAA585EA-6214-4217-AFDA-7F46DE5869B3")]
internal interface ABI.Windows.Foundation.Collections.IIterable`1 {
    public static Guid PIID;
    private static IIterable`1();
}
internal static class ABI.Windows.Foundation.Collections.IIterableMethods`1 : object {
    public static IEnumerator`1<T> First(IObjectReference obj);
}
internal static class ABI.Windows.Foundation.Collections.IMapMethods`2 : object {
    public static V Lookup(IObjectReference obj, Dictionary`2<K, ValueTuple`2<IntPtr, V>> __lookupCache, K key);
    public static bool HasKey(IObjectReference obj, K key);
    public static IReadOnlyDictionary`2<K, V> GetView(IObjectReference obj);
    public static bool Insert(IObjectReference obj, K key, V value);
    public static void Remove(IObjectReference obj, K key);
    public static void Clear(IObjectReference obj);
    private static void _ClearHelper(IObjectReference obj);
    public static UInt32 get_Size(IObjectReference obj);
}
internal static class ABI.Windows.Foundation.Collections.IMapViewMethods`2 : object {
    public static V Lookup(IObjectReference obj, K key);
    public static bool HasKey(IObjectReference obj, K key);
    public static void Split(IObjectReference obj, IMapView`2& first, IMapView`2& second);
    public static UInt32 get_Size(IObjectReference obj);
}
internal static class ABI.Windows.Foundation.Collections.IVectorViewMethods`1 : object {
    public static T GetAt(IObjectReference obj, UInt32 index);
    public static bool IndexOf(IObjectReference obj, T value, UInt32& index);
    public static UInt32 GetMany(IObjectReference obj, UInt32 startIndex, T[]& items);
    public static UInt32 get_Size(IObjectReference obj);
}
[DynamicInterfaceCastableImplementationAttribute]
[GuidAttribute("4BD682DD-7554-40E9-9A9B-82654EDE7E62")]
internal interface ABI.Windows.Foundation.IPropertyValue {
    private bool global::Windows.Foundation.IPropertyValue.IsNumericScalar { get; }
    private PropertyType global::Windows.Foundation.IPropertyValue.Type { get; }
    private sealed virtual override byte global::Windows.Foundation.IPropertyValue.GetUInt8();
    private sealed virtual override short global::Windows.Foundation.IPropertyValue.GetInt16();
    private sealed virtual override ushort global::Windows.Foundation.IPropertyValue.GetUInt16();
    private sealed virtual override int global::Windows.Foundation.IPropertyValue.GetInt32();
    private sealed virtual override UInt32 global::Windows.Foundation.IPropertyValue.GetUInt32();
    private sealed virtual override long global::Windows.Foundation.IPropertyValue.GetInt64();
    private sealed virtual override ulong global::Windows.Foundation.IPropertyValue.GetUInt64();
    private sealed virtual override float global::Windows.Foundation.IPropertyValue.GetSingle();
    private sealed virtual override double global::Windows.Foundation.IPropertyValue.GetDouble();
    private sealed virtual override char global::Windows.Foundation.IPropertyValue.GetChar16();
    private sealed virtual override bool global::Windows.Foundation.IPropertyValue.GetBoolean();
    private sealed virtual override string global::Windows.Foundation.IPropertyValue.GetString();
    private sealed virtual override Guid global::Windows.Foundation.IPropertyValue.GetGuid();
    private sealed virtual override DateTimeOffset global::Windows.Foundation.IPropertyValue.GetDateTime();
    private sealed virtual override TimeSpan global::Windows.Foundation.IPropertyValue.GetTimeSpan();
    private sealed virtual override Point global::Windows.Foundation.IPropertyValue.GetPoint();
    private sealed virtual override Size global::Windows.Foundation.IPropertyValue.GetSize();
    private sealed virtual override Rect global::Windows.Foundation.IPropertyValue.GetRect();
    private sealed virtual override void global::Windows.Foundation.IPropertyValue.GetUInt8Array(Byte[]& value);
    private sealed virtual override void global::Windows.Foundation.IPropertyValue.GetInt16Array(Int16[]& value);
    private sealed virtual override void global::Windows.Foundation.IPropertyValue.GetUInt16Array(UInt16[]& value);
    private sealed virtual override void global::Windows.Foundation.IPropertyValue.GetInt32Array(Int32[]& value);
    private sealed virtual override void global::Windows.Foundation.IPropertyValue.GetUInt32Array(UInt32[]& value);
    private sealed virtual override void global::Windows.Foundation.IPropertyValue.GetInt64Array(Int64[]& value);
    private sealed virtual override void global::Windows.Foundation.IPropertyValue.GetUInt64Array(UInt64[]& value);
    private sealed virtual override void global::Windows.Foundation.IPropertyValue.GetSingleArray(Single[]& value);
    private sealed virtual override void global::Windows.Foundation.IPropertyValue.GetDoubleArray(Double[]& value);
    private sealed virtual override void global::Windows.Foundation.IPropertyValue.GetChar16Array(Char[]& value);
    private sealed virtual override void global::Windows.Foundation.IPropertyValue.GetBooleanArray(Boolean[]& value);
    private sealed virtual override void global::Windows.Foundation.IPropertyValue.GetStringArray(String[]& value);
    private sealed virtual override void global::Windows.Foundation.IPropertyValue.GetInspectableArray(Object[]& value);
    private sealed virtual override void global::Windows.Foundation.IPropertyValue.GetGuidArray(Guid[]& value);
    private sealed virtual override void global::Windows.Foundation.IPropertyValue.GetDateTimeArray(DateTimeOffset[]& value);
    private sealed virtual override void global::Windows.Foundation.IPropertyValue.GetTimeSpanArray(TimeSpan[]& value);
    private sealed virtual override void global::Windows.Foundation.IPropertyValue.GetPointArray(Point[]& value);
    private sealed virtual override void global::Windows.Foundation.IPropertyValue.GetSizeArray(Size[]& value);
    private sealed virtual override void global::Windows.Foundation.IPropertyValue.GetRectArray(Rect[]& value);
    private sealed virtual override bool global::Windows.Foundation.IPropertyValue.get_IsNumericScalar();
    private sealed virtual override PropertyType global::Windows.Foundation.IPropertyValue.get_Type();
}
internal static class ABI.Windows.Foundation.IPropertyValue_Delegates : object {
}
internal static class ABI.Windows.Foundation.IReferenceArray_Delegates : object {
}
[ObjectReferenceWrapperAttribute("_obj")]
[GuidAttribute("61C17707-2D65-11E0-9AE8-D48564015472")]
internal class ABI.Windows.Foundation.IReferenceArray`1 : object {
    public static Guid PIID;
    private ObjectReference`1<Vftbl<T>> _obj;
    public IntPtr ThisPtr { get; }
    public T[] Value { get; }
    public IReferenceArray`1(IObjectReference obj);
    public IReferenceArray`1(ObjectReference`1<Vftbl<T>> obj);
    private static IReferenceArray`1();
    public static IObjectReference CreateMarshaler(object value);
    public static ObjectReferenceValue CreateMarshaler2(object value);
    public static IntPtr GetAbi(IObjectReference m);
    public static object FromAbi(IntPtr ptr);
    internal static object GetValue(IInspectable inspectable);
    public static void CopyManaged(object o, IntPtr dest);
    public static IntPtr FromManaged(object value);
    public static void DisposeMarshaler(IObjectReference m);
    public static void DisposeAbi(IntPtr abi);
    public static string GetGuidSignature();
    public static IReferenceArray`1<T> op_Implicit(IObjectReference obj);
    public static IReferenceArray`1<T> op_Implicit(ObjectReference`1<Vftbl<T>> obj);
    public IntPtr get_ThisPtr();
    public ObjectReference`1<I> AsInterface();
    public A As();
    public sealed virtual T[] get_Value();
}
[GuidAttribute("9E365E57-48B2-4160-956F-C7385120BBFC")]
internal class ABI.Windows.Foundation.IUriRuntimeClassVftbl : ValueType {
    internal Vftbl IInspectableVftbl;
    public IntPtr get_AbsoluteUri_0;
    public IntPtr get_DisplayUri_1;
    public IntPtr get_Domain_2;
    public IntPtr get_Extension_3;
    public IntPtr get_Fragment_4;
    public IntPtr get_Host_5;
    public IntPtr get_Password_6;
    public IntPtr get_Path_7;
    public IntPtr get_Query_8;
    public IntPtr get_QueryParsed_9;
    public Void* _get_RawUri_10;
    public IntPtr get_SchemeName_11;
    public IntPtr get_UserName_12;
    public IntPtr get_Port_13;
    public IntPtr get_Suspicious_14;
    public IntPtr Equals_15;
    public IntPtr CombineUri_16;
    public method get_RawUri_10 { get; }
    public method get_get_RawUri_10();
}
internal static class ABI.Windows.Foundation.ManagedIPropertyValueImpl : object {
    private static int TYPE_E_TYPEMISMATCH;
    private static int DISP_E_OVERFLOW;
    private static Vftbl AbiToProjectionVftable;
    public static IntPtr AbiToProjectionVftablePtr;
    internal static Guid IID;
    private static Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_numericScalarTypes;
    private static Dictionary`2<Type, PropertyType> NumericScalarTypes { get; }
    private static ManagedIPropertyValueImpl();
    private static Dictionary`2<Type, PropertyType> get_NumericScalarTypes();
    private static T UnboxValue(object value);
    private static T[] UnboxArray(object value);
    private static bool IsCoercable(object value);
    private static T CoerceValue(object value);
    private static T[] CoerceArray(object value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetUInt8_2(IntPtr thisPtr, Byte* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetInt16_3(IntPtr thisPtr, Int16* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetUInt16_4(IntPtr thisPtr, UInt16* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetInt32_5(IntPtr thisPtr, Int32* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetUInt32_6(IntPtr thisPtr, UInt32* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetInt64_7(IntPtr thisPtr, Int64* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetUInt64_8(IntPtr thisPtr, UInt64* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetSingle_9(IntPtr thisPtr, Single* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetDouble_10(IntPtr thisPtr, Double* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetChar16_11(IntPtr thisPtr, UInt16* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetBoolean_12(IntPtr thisPtr, Byte* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetString_13(IntPtr thisPtr, IntPtr* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetGuid_14(IntPtr thisPtr, Guid* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetDateTime_15(IntPtr thisPtr, DateTimeOffset* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetTimeSpan_16(IntPtr thisPtr, TimeSpan* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetPoint_17(IntPtr thisPtr, Point* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetSize_18(IntPtr thisPtr, Size* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetRect_19(IntPtr thisPtr, Rect* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetUInt8Array_20(IntPtr thisPtr, Int32* __valueSize, IntPtr* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetInt16Array_21(IntPtr thisPtr, Int32* __valueSize, IntPtr* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetUInt16Array_22(IntPtr thisPtr, Int32* __valueSize, IntPtr* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetInt32Array_23(IntPtr thisPtr, Int32* __valueSize, IntPtr* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetUInt32Array_24(IntPtr thisPtr, Int32* __valueSize, IntPtr* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetInt64Array_25(IntPtr thisPtr, Int32* __valueSize, IntPtr* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetUInt64Array_26(IntPtr thisPtr, Int32* __valueSize, IntPtr* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetSingleArray_27(IntPtr thisPtr, Int32* __valueSize, IntPtr* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetDoubleArray_28(IntPtr thisPtr, Int32* __valueSize, IntPtr* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetChar16Array_29(IntPtr thisPtr, Int32* __valueSize, IntPtr* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetBooleanArray_30(IntPtr thisPtr, Int32* __valueSize, IntPtr* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetStringArray_31(IntPtr thisPtr, Int32* __valueSize, IntPtr* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetInspectableArray_32(IntPtr thisPtr, Int32* __valueSize, IntPtr* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetGuidArray_33(IntPtr thisPtr, Int32* __valueSize, IntPtr* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetDateTimeArray_34(IntPtr thisPtr, Int32* __valueSize, IntPtr* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetTimeSpanArray_35(IntPtr thisPtr, Int32* __valueSize, IntPtr* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetPointArray_36(IntPtr thisPtr, Int32* __valueSize, IntPtr* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetSizeArray_37(IntPtr thisPtr, Int32* __valueSize, IntPtr* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetRectArray_38(IntPtr thisPtr, Int32* __valueSize, IntPtr* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_get_IsNumericScalar_1(IntPtr thisPtr, Byte* value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_get_Type_0(IntPtr thisPtr, PropertyType* value);
    private static PropertyType GetPropertyTypeOfObject(object obj);
}
[GuidAttribute("96369F54-8EB6-48F0-ABCE-C1B211E627C3")]
internal class ABI.Windows.Foundation.ManagedIStringableVftbl : ValueType {
    internal Vftbl IInspectableVftbl;
    private Void* _ToString_0;
    private static ManagedIStringableVftbl AbiToProjectionVftable;
    public static IntPtr AbiToProjectionVftablePtr;
    internal static Guid IID;
    private method ToString_0 { get; private set; }
    private static ManagedIStringableVftbl();
    private method get_ToString_0();
    private void set_ToString_0(method value);
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_ToString_0(IntPtr thisPtr, IntPtr* value);
}
public static class ABI.Windows.Foundation.Point : object {
    public static string GetGuidSignature();
}
public static class ABI.Windows.Foundation.Rect : object {
    public static string GetGuidSignature();
}
public static class ABI.Windows.Foundation.Size : object {
    public static string GetGuidSignature();
}
internal static class ABI.WinRT.EventRegistrationToken : object {
    public static string GetGuidSignature();
}
[ObjectReferenceWrapperAttribute("_obj")]
[GuidAttribute("00000035-0000-0000-C000-000000000046")]
public class ABI.WinRT.Interop.IActivationFactory : object {
    protected ObjectReference`1<Vftbl> _obj;
    public IObjectReference ObjRef { get; }
    public IntPtr ThisPtr { get; }
    public IActivationFactory(IObjectReference obj);
    internal IActivationFactory(ObjectReference`1<Vftbl> obj);
    internal static ObjectReference`1<Vftbl> FromAbi(IntPtr thisPtr);
    public static IActivationFactory op_Implicit(IObjectReference obj);
    public IObjectReference get_ObjRef();
    public IntPtr get_ThisPtr();
    public ObjectReference`1<I> AsInterface();
    public A As();
    public sealed virtual IntPtr ActivateInstance();
}
[DynamicInterfaceCastableImplementationAttribute]
[GuidAttribute("94ea2b94-e9cc-49e0-c0ff-ee64ca8f5b90")]
internal interface ABI.WinRT.Interop.IAgileObject {
    public static IntPtr AbiToProjectionVftablePtr;
    private static IAgileObject();
}
[DynamicInterfaceCastableImplementationAttribute]
[GuidAttribute("C03F6A43-65A4-9818-987E-E0B810D2A6F2")]
internal interface ABI.WinRT.Interop.IAgileReference {
    public static IntPtr AbiToProjectionVftablePtr;
    private static IAgileReference();
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_Resolve(IntPtr thisPtr, Guid* riid, IntPtr* objectReference);
    private sealed virtual override IObjectReference global::WinRT.Interop.IAgileReference.Resolve(Guid riid);
}
internal static class ABI.WinRT.Interop.IAgileReferenceMethods : object {
    public static IObjectReference Resolve(IObjectReference _obj, Guid riid);
    public static ObjectReference`1<T> Resolve(IObjectReference _obj, Guid riid);
}
[GuidAttribute("000001da-0000-0000-C000-000000000046")]
internal class ABI.WinRT.Interop.IContextCallback : object {
    internal static Guid IID;
    private ObjectReference`1<Vftbl> _obj;
    public IntPtr ThisPtr { get; }
    public IContextCallback(IObjectReference obj);
    public IContextCallback(ObjectReference`1<Vftbl> obj);
    private static IContextCallback();
    public static ObjectReference`1<Vftbl> FromAbi(IntPtr thisPtr);
    public static IContextCallback op_Implicit(IObjectReference obj);
    public static IContextCallback op_Implicit(ObjectReference`1<Vftbl> obj);
    public IntPtr get_ThisPtr();
    public ObjectReference`1<I> AsInterface();
    public A As();
    public sealed virtual void ContextCallback(PFNCONTEXTCALL pfnCallback, ComCallData* pParam, Guid riid, int iMethod);
}
[GuidAttribute("1CF2B120-547D-101B-8E65-08002B2BD119")]
internal class ABI.WinRT.Interop.IErrorInfo : object {
    protected ObjectReference`1<Vftbl> _obj;
    public IntPtr ThisPtr { get; }
    public IErrorInfo(IObjectReference obj);
    public IErrorInfo(ObjectReference`1<Vftbl> obj);
    public static ObjectReference`1<Vftbl> FromAbi(IntPtr thisPtr);
    public static IErrorInfo op_Implicit(IObjectReference obj);
    public static IErrorInfo op_Implicit(ObjectReference`1<Vftbl> obj);
    public IntPtr get_ThisPtr();
    public ObjectReference`1<I> AsInterface();
    public A As();
    public sealed virtual Guid GetGuid();
    public sealed virtual string GetSource();
    public sealed virtual string GetDescription();
    public sealed virtual string GetHelpFile();
    public sealed virtual string GetHelpFileContent();
}
[GuidAttribute("00000146-0000-0000-C000-000000000046")]
internal class ABI.WinRT.Interop.IGlobalInterfaceTable : object {
    internal static Guid IID;
    private ObjectReference`1<Vftbl> _obj;
    public IntPtr ThisPtr { get; }
    public IGlobalInterfaceTable(IObjectReference obj);
    public IGlobalInterfaceTable(ObjectReference`1<Vftbl> obj);
    private static IGlobalInterfaceTable();
    public static ObjectReference`1<Vftbl> FromAbi(IntPtr thisPtr);
    public static IGlobalInterfaceTable op_Implicit(IObjectReference obj);
    public static IGlobalInterfaceTable op_Implicit(ObjectReference`1<Vftbl> obj);
    public IntPtr get_ThisPtr();
    public ObjectReference`1<I> AsInterface();
    public A As();
    public sealed virtual IntPtr RegisterInterfaceInGlobal(IntPtr ptr, Guid riid);
    public sealed virtual void RevokeInterfaceFromGlobal(IntPtr cookie);
    public sealed virtual IObjectReference GetInterfaceFromGlobal(IntPtr cookie, Guid riid);
}
[GuidAttribute("04a2dbf3-df83-116c-0946-0812abf6e07d")]
internal class ABI.WinRT.Interop.ILanguageExceptionErrorInfo : object {
    protected ObjectReference`1<Vftbl> _obj;
    public IntPtr ThisPtr { get; }
    public ILanguageExceptionErrorInfo(IObjectReference obj);
    public ILanguageExceptionErrorInfo(ObjectReference`1<Vftbl> obj);
    public static ObjectReference`1<Vftbl> FromAbi(IntPtr thisPtr);
    public static ILanguageExceptionErrorInfo op_Implicit(IObjectReference obj);
    public static ILanguageExceptionErrorInfo op_Implicit(ObjectReference`1<Vftbl> obj);
    public IntPtr get_ThisPtr();
    public ObjectReference`1<I> AsInterface();
    public A As();
    public sealed virtual IObjectReference GetLanguageException();
}
[GuidAttribute("00000003-0000-0000-c000-000000000046")]
internal class ABI.WinRT.Interop.IMarshal : object {
    internal static Guid IID;
    private static string NotImplemented_NativeRoutineNotFound;
    internal static Lazy`1<Guid> IID_InProcFreeThreadedMarshaler;
    private ObjectReference`1<Vftbl> _obj;
    public IObjectReference ObjRef { get; }
    public IntPtr ThisPtr { get; }
    public IMarshal(IObjectReference obj);
    internal IMarshal(ObjectReference`1<Vftbl> obj);
    private static IMarshal();
    private static int CoCreateFreeThreadedMarshaler(IntPtr outer, IntPtr& marshalerPtr);
    internal static ObjectReference`1<Vftbl> FromAbi(IntPtr thisPtr);
    public static IMarshal op_Implicit(IObjectReference obj);
    public IObjectReference get_ObjRef();
    public IntPtr get_ThisPtr();
    public ObjectReference`1<I> AsInterface();
    public A As();
    public void GetUnmarshalClass(Guid* riid, IntPtr pv, MSHCTX dwDestContext, IntPtr pvDestContext, MSHLFLAGS mshlFlags, Guid* pCid);
    public void GetMarshalSizeMax(Guid* riid, IntPtr pv, MSHCTX dwDestContext, IntPtr pvDestContext, MSHLFLAGS mshlflags, UInt32* pSize);
    public void MarshalInterface(IntPtr pStm, Guid* riid, IntPtr pv, MSHCTX dwDestContext, IntPtr pvDestContext, MSHLFLAGS mshlflags);
    public void UnmarshalInterface(IntPtr pStm, Guid* riid, IntPtr* ppv);
    public void ReleaseMarshalData(IntPtr pStm);
    public void DisconnectObject(UInt32 dwReserved);
}
internal static class ABI.WinRT.Interop.IMarshal_Delegates : object {
}
[GuidAttribute("82BA7092-4C88-427D-A7BC-16DD93FEB67E")]
internal class ABI.WinRT.Interop.IRestrictedErrorInfo : object {
    protected ObjectReference`1<Vftbl> _obj;
    public IntPtr ThisPtr { get; }
    public IRestrictedErrorInfo(IObjectReference obj);
    public IRestrictedErrorInfo(ObjectReference`1<Vftbl> obj);
    public static ObjectReference`1<Vftbl> FromAbi(IntPtr thisPtr);
    public static IRestrictedErrorInfo op_Implicit(IObjectReference obj);
    public static IRestrictedErrorInfo op_Implicit(ObjectReference`1<Vftbl> obj);
    public IntPtr get_ThisPtr();
    public ObjectReference`1<I> AsInterface();
    public A As();
    public sealed virtual void GetErrorDetails(String& description, Int32& error, String& restrictedDescription, String& capabilitySid);
    public sealed virtual string GetReference();
}
[GuidAttribute("DF0B3D60-548F-101B-8E65-08002B2BD119")]
internal class ABI.WinRT.Interop.ISupportErrorInfo : object {
    protected ObjectReference`1<Vftbl> _obj;
    public IntPtr ThisPtr { get; }
    public ISupportErrorInfo(IObjectReference obj);
    public ISupportErrorInfo(ObjectReference`1<Vftbl> obj);
    public static ObjectReference`1<Vftbl> FromAbi(IntPtr thisPtr);
    public static ISupportErrorInfo op_Implicit(IObjectReference obj);
    public static ISupportErrorInfo op_Implicit(ObjectReference`1<Vftbl> obj);
    public IntPtr get_ThisPtr();
    public ObjectReference`1<I> AsInterface();
    public A As();
    public sealed virtual bool InterfaceSupportsErrorInfo(Guid riid);
}
[DynamicInterfaceCastableImplementationAttribute]
[GuidAttribute("00000037-0000-0000-C000-000000000046")]
internal interface ABI.WinRT.Interop.IWeakReference {
    internal static Guid IID;
    public static IntPtr AbiToProjectionVftablePtr;
    private static IWeakReference();
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_Resolve(IntPtr thisPtr, Guid* riid, IntPtr* objectReference);
    private sealed virtual override IObjectReference global::WinRT.Interop.IWeakReference.Resolve(Guid riid);
}
[DynamicInterfaceCastableImplementationAttribute]
[GuidAttribute("00000038-0000-0000-C000-000000000046")]
internal interface ABI.WinRT.Interop.IWeakReferenceSource {
    internal static Guid IID;
    public static IntPtr AbiToProjectionVftablePtr;
    private static IWeakReferenceSource();
    [UnmanagedCallersOnlyAttribute]
private static int Do_Abi_GetWeakReference(IntPtr thisPtr, IntPtr* weakReference);
    private sealed virtual override IWeakReference global::WinRT.Interop.IWeakReferenceSource.GetWeakReference();
}
public static class ABI.WinRT.Interop.IWeakReferenceSourceMethods : object {
    public static IWeakReference GetWeakReference(IObjectReference _obj);
}
public class Microsoft.UI.Xaml.Automation.ElementNotAvailableException : Exception {
    public ElementNotAvailableException(string message);
    public ElementNotAvailableException(string message, Exception innerException);
    protected ElementNotAvailableException(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
public class Microsoft.UI.Xaml.Automation.ElementNotEnabledException : Exception {
    public ElementNotEnabledException(string message);
    public ElementNotEnabledException(string message, Exception innerException);
}
[WindowsRuntimeTypeAttribute("")]
[GuidAttribute("30DA92C0-23E8-42A0-AE7C-734A0E5D2782")]
internal interface Microsoft.UI.Xaml.Data.ICustomProperty {
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public string Name { get; }
    public Type Type { get; }
    public abstract virtual object GetValue(object target);
    public abstract virtual void SetValue(object target, object value);
    public abstract virtual object GetIndexedValue(object target, object index);
    public abstract virtual void SetIndexedValue(object target, object value, object index);
    public abstract virtual bool get_CanRead();
    public abstract virtual bool get_CanWrite();
    public abstract virtual string get_Name();
    public abstract virtual Type get_Type();
}
[WindowsRuntimeTypeAttribute("")]
[GuidAttribute("036D2C08-DF29-41AF-8AA2-D774BE62BA6F")]
internal interface Microsoft.UI.Xaml.Interop.IBindableIterable {
    public abstract virtual IBindableIterator First();
}
[WindowsRuntimeTypeAttribute("")]
[GuidAttribute("6A1D6C07-076D-49F2-8314-F52C9C9A8331")]
internal interface Microsoft.UI.Xaml.Interop.IBindableIterator {
    public object Current { get; }
    public bool HasCurrent { get; }
    public abstract virtual bool MoveNext();
    public abstract virtual UInt32 GetMany(Object[]& items);
    public abstract virtual object get_Current();
    public abstract virtual bool get_HasCurrent();
}
[WindowsRuntimeTypeAttribute("")]
[GuidAttribute("393DE7DE-6FD0-4C0D-BB71-47244A113E93")]
internal interface Microsoft.UI.Xaml.Interop.IBindableVector {
    public UInt32 Size { get; }
    public abstract virtual object GetAt(UInt32 index);
    public abstract virtual IBindableVectorView GetView();
    public abstract virtual bool IndexOf(object value, UInt32& index);
    public abstract virtual void SetAt(UInt32 index, object value);
    public abstract virtual void InsertAt(UInt32 index, object value);
    public abstract virtual void RemoveAt(UInt32 index);
    public abstract virtual void Append(object value);
    public abstract virtual void RemoveAtEnd();
    public abstract virtual void Clear();
    public abstract virtual UInt32 get_Size();
}
[WindowsRuntimeTypeAttribute("")]
[GuidAttribute("346DD6E7-976E-4BC3-815D-ECE243BC0F33")]
internal interface Microsoft.UI.Xaml.Interop.IBindableVectorView {
    public UInt32 Size { get; }
    public abstract virtual object GetAt(UInt32 index);
    public abstract virtual bool IndexOf(object value, UInt32& index);
    public abstract virtual UInt32 get_Size();
}
public class Microsoft.UI.Xaml.LayoutCycleException : Exception {
    public LayoutCycleException(string message);
    public LayoutCycleException(string message, Exception innerException);
    protected LayoutCycleException(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
public class Microsoft.UI.Xaml.Markup.XamlParseException : Exception {
    public XamlParseException(string message);
    public XamlParseException(string message, Exception innerException);
}
[DefaultMemberAttribute("Item")]
internal class System.Collections.Generic.IDictionaryImpl`2 : object {
    private IObjectReference _inner;
    private Dictionary`2<K, ValueTuple`2<IntPtr, V>> _lookupCache;
    private IObjectReference modreq(System.Runtime.CompilerServices.IsVolatile) __iDictionaryObjRef;
    private IObjectReference modreq(System.Runtime.CompilerServices.IsVolatile) __iEnumerableObjRef;
    private ConcurrentDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) _queryInterfaceCache;
    private ConcurrentDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) _additionalTypeData;
    private IObjectReference iDictionaryObjRef { get; }
    private IObjectReference iEnumerableObjRef { get; }
    private IObjectReference WinRT.IWinRTObject.NativeObject { get; }
    private bool WinRT.IWinRTObject.HasUnwrappableNativeObject { get; }
    private ConcurrentDictionary`2<RuntimeTypeHandle, IObjectReference> WinRT.IWinRTObject.QueryInterfaceCache { get; }
    private ConcurrentDictionary`2<RuntimeTypeHandle, object> WinRT.IWinRTObject.AdditionalTypeData { get; }
    public V Item { get; public set; }
    public ICollection`1<K> Keys { get; }
    public ICollection`1<V> Values { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    internal IDictionaryImpl`2(IObjectReference _inner);
    public static IDictionaryImpl`2<K, V> CreateRcw(IInspectable obj);
    private IObjectReference Make_IDictionaryObjRef();
    private IObjectReference get_iDictionaryObjRef();
    private IObjectReference Make_IEnumerableObjRef();
    private IObjectReference get_iEnumerableObjRef();
    private sealed virtual override IObjectReference WinRT.IWinRTObject.get_NativeObject();
    private sealed virtual override bool WinRT.IWinRTObject.get_HasUnwrappableNativeObject();
    private ConcurrentDictionary`2<RuntimeTypeHandle, IObjectReference> MakeQueryInterfaceCache();
    private sealed virtual override ConcurrentDictionary`2<RuntimeTypeHandle, IObjectReference> WinRT.IWinRTObject.get_QueryInterfaceCache();
    private ConcurrentDictionary`2<RuntimeTypeHandle, object> MakeAdditionalTypeData();
    private sealed virtual override ConcurrentDictionary`2<RuntimeTypeHandle, object> WinRT.IWinRTObject.get_AdditionalTypeData();
    public sealed virtual V get_Item(K key);
    public sealed virtual void set_Item(K key, V value);
    public sealed virtual ICollection`1<K> get_Keys();
    public sealed virtual ICollection`1<V> get_Values();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(K key, V value);
    public sealed virtual void Add(KeyValuePair`2<K, V> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<K, V> item);
    public sealed virtual bool ContainsKey(K key);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<KeyValuePair`2<K, V>> GetEnumerator();
    public sealed virtual bool Remove(K key);
    public sealed virtual bool Remove(KeyValuePair`2<K, V> item);
    public sealed virtual bool TryGetValue(K key, V& value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class System.Collections.Generic.IEnumerableImpl`1 : object {
    private IObjectReference _inner;
    private IObjectReference modreq(System.Runtime.CompilerServices.IsVolatile) __iEnumerableObjRef;
    private ConcurrentDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) _queryInterfaceCache;
    private ConcurrentDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) _additionalTypeData;
    private IObjectReference iEnumerableObjRef { get; }
    private IObjectReference WinRT.IWinRTObject.NativeObject { get; }
    private bool WinRT.IWinRTObject.HasUnwrappableNativeObject { get; }
    private ConcurrentDictionary`2<RuntimeTypeHandle, IObjectReference> WinRT.IWinRTObject.QueryInterfaceCache { get; }
    private ConcurrentDictionary`2<RuntimeTypeHandle, object> WinRT.IWinRTObject.AdditionalTypeData { get; }
    internal IEnumerableImpl`1(IObjectReference _inner);
    public static IEnumerableImpl`1<T> CreateRcw(IInspectable obj);
    private IObjectReference Make_IEnumerableObjRef();
    private IObjectReference get_iEnumerableObjRef();
    private sealed virtual override IObjectReference WinRT.IWinRTObject.get_NativeObject();
    private sealed virtual override bool WinRT.IWinRTObject.get_HasUnwrappableNativeObject();
    private ConcurrentDictionary`2<RuntimeTypeHandle, IObjectReference> MakeQueryInterfaceCache();
    private sealed virtual override ConcurrentDictionary`2<RuntimeTypeHandle, IObjectReference> WinRT.IWinRTObject.get_QueryInterfaceCache();
    private ConcurrentDictionary`2<RuntimeTypeHandle, object> MakeAdditionalTypeData();
    private sealed virtual override ConcurrentDictionary`2<RuntimeTypeHandle, object> WinRT.IWinRTObject.get_AdditionalTypeData();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
internal class System.Collections.Generic.IListImpl`1 : object {
    private IObjectReference _inner;
    private IObjectReference modreq(System.Runtime.CompilerServices.IsVolatile) __iListObjRef;
    private IObjectReference modreq(System.Runtime.CompilerServices.IsVolatile) __iEnumerableObjRef;
    private ConcurrentDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) _queryInterfaceCache;
    private ConcurrentDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) _additionalTypeData;
    private IObjectReference iListObjRef { get; }
    private IObjectReference iEnumerableObjRef { get; }
    public T Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    private IObjectReference WinRT.IWinRTObject.NativeObject { get; }
    private bool WinRT.IWinRTObject.HasUnwrappableNativeObject { get; }
    private ConcurrentDictionary`2<RuntimeTypeHandle, IObjectReference> WinRT.IWinRTObject.QueryInterfaceCache { get; }
    private ConcurrentDictionary`2<RuntimeTypeHandle, object> WinRT.IWinRTObject.AdditionalTypeData { get; }
    internal IListImpl`1(IObjectReference _inner);
    private IObjectReference Make_IListObjRef();
    private IObjectReference get_iListObjRef();
    private IObjectReference Make_IEnumerableObjRef();
    private IObjectReference get_iEnumerableObjRef();
    public static IListImpl`1<T> CreateRcw(IInspectable obj);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override IObjectReference WinRT.IWinRTObject.get_NativeObject();
    private sealed virtual override bool WinRT.IWinRTObject.get_HasUnwrappableNativeObject();
    private ConcurrentDictionary`2<RuntimeTypeHandle, IObjectReference> MakeQueryInterfaceCache();
    private sealed virtual override ConcurrentDictionary`2<RuntimeTypeHandle, IObjectReference> WinRT.IWinRTObject.get_QueryInterfaceCache();
    private ConcurrentDictionary`2<RuntimeTypeHandle, object> MakeAdditionalTypeData();
    private sealed virtual override ConcurrentDictionary`2<RuntimeTypeHandle, object> WinRT.IWinRTObject.get_AdditionalTypeData();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual bool Remove(T item);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
internal class System.Collections.Generic.IReadOnlyDictionaryImpl`2 : object {
    private IObjectReference _inner;
    private IObjectReference modreq(System.Runtime.CompilerServices.IsVolatile) __iReadOnlyDictionaryObjRef;
    private IObjectReference modreq(System.Runtime.CompilerServices.IsVolatile) __iEnumerableObjRef;
    private ConcurrentDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) _queryInterfaceCache;
    private ConcurrentDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) _additionalTypeData;
    private IObjectReference iReadOnlyDictionaryObjRef { get; }
    private IObjectReference iEnumerableObjRef { get; }
    private IObjectReference WinRT.IWinRTObject.NativeObject { get; }
    private bool WinRT.IWinRTObject.HasUnwrappableNativeObject { get; }
    private ConcurrentDictionary`2<RuntimeTypeHandle, IObjectReference> WinRT.IWinRTObject.QueryInterfaceCache { get; }
    private ConcurrentDictionary`2<RuntimeTypeHandle, object> WinRT.IWinRTObject.AdditionalTypeData { get; }
    public V Item { get; }
    public IEnumerable`1<K> Keys { get; }
    public IEnumerable`1<V> Values { get; }
    public int Count { get; }
    internal IReadOnlyDictionaryImpl`2(IObjectReference _inner);
    public static IReadOnlyDictionaryImpl`2<K, V> CreateRcw(IInspectable obj);
    private IObjectReference Make_IDictionaryObjRef();
    private IObjectReference get_iReadOnlyDictionaryObjRef();
    private IObjectReference Make_IEnumerableObjRef();
    private IObjectReference get_iEnumerableObjRef();
    private sealed virtual override IObjectReference WinRT.IWinRTObject.get_NativeObject();
    private sealed virtual override bool WinRT.IWinRTObject.get_HasUnwrappableNativeObject();
    private ConcurrentDictionary`2<RuntimeTypeHandle, IObjectReference> MakeQueryInterfaceCache();
    private sealed virtual override ConcurrentDictionary`2<RuntimeTypeHandle, IObjectReference> WinRT.IWinRTObject.get_QueryInterfaceCache();
    private ConcurrentDictionary`2<RuntimeTypeHandle, object> MakeAdditionalTypeData();
    private sealed virtual override ConcurrentDictionary`2<RuntimeTypeHandle, object> WinRT.IWinRTObject.get_AdditionalTypeData();
    public sealed virtual V get_Item(K key);
    public sealed virtual IEnumerable`1<K> get_Keys();
    public sealed virtual IEnumerable`1<V> get_Values();
    public sealed virtual int get_Count();
    public sealed virtual bool ContainsKey(K key);
    public sealed virtual IEnumerator`1<KeyValuePair`2<K, V>> GetEnumerator();
    public sealed virtual bool TryGetValue(K key, V& value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
internal class System.Collections.Generic.IReadOnlyListImpl`1 : object {
    private IObjectReference _inner;
    private IObjectReference modreq(System.Runtime.CompilerServices.IsVolatile) __iReadOnlyListObjRef;
    private IObjectReference modreq(System.Runtime.CompilerServices.IsVolatile) __iEnumerableObjRef;
    private ConcurrentDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) _queryInterfaceCache;
    private ConcurrentDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) _additionalTypeData;
    private IObjectReference iReadOnlyListObjRef { get; }
    private IObjectReference iEnumerableObjRef { get; }
    private IObjectReference WinRT.IWinRTObject.NativeObject { get; }
    private bool WinRT.IWinRTObject.HasUnwrappableNativeObject { get; }
    private ConcurrentDictionary`2<RuntimeTypeHandle, IObjectReference> WinRT.IWinRTObject.QueryInterfaceCache { get; }
    private ConcurrentDictionary`2<RuntimeTypeHandle, object> WinRT.IWinRTObject.AdditionalTypeData { get; }
    public T Item { get; }
    public int Count { get; }
    internal IReadOnlyListImpl`1(IObjectReference _inner);
    private IObjectReference Make_IListObjRef();
    private IObjectReference get_iReadOnlyListObjRef();
    private IObjectReference Make_IEnumerableObjRef();
    private IObjectReference get_iEnumerableObjRef();
    public static IReadOnlyListImpl`1<T> CreateRcw(IInspectable obj);
    private sealed virtual override IObjectReference WinRT.IWinRTObject.get_NativeObject();
    private sealed virtual override bool WinRT.IWinRTObject.get_HasUnwrappableNativeObject();
    private ConcurrentDictionary`2<RuntimeTypeHandle, IObjectReference> MakeQueryInterfaceCache();
    private sealed virtual override ConcurrentDictionary`2<RuntimeTypeHandle, IObjectReference> WinRT.IWinRTObject.get_QueryInterfaceCache();
    private ConcurrentDictionary`2<RuntimeTypeHandle, object> MakeAdditionalTypeData();
    private sealed virtual override ConcurrentDictionary`2<RuntimeTypeHandle, object> WinRT.IWinRTObject.get_AdditionalTypeData();
    public sealed virtual T get_Item(int index);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExtensionAttribute]
public static class System.Numerics.VectorExtensions : object {
    [ExtensionAttribute]
public static Point ToPoint(Vector2 vector);
    [ExtensionAttribute]
public static Size ToSize(Vector2 vector);
    [ExtensionAttribute]
public static Vector2 ToVector2(Point point);
    [ExtensionAttribute]
public static Vector2 ToVector2(Size size);
}
[AttributeUsageAttribute("64")]
internal class System.Runtime.CompilerServices.ModuleInitializerAttribute : Attribute {
}
[GuidAttribute("FAA585EA-6214-4217-AFDA-7F46DE5869B3")]
internal interface Windows.Foundation.Collections.IIterable`1 {
    public abstract virtual IEnumerator`1<T> First();
}
[GuidAttribute("6A79E863-4300-459A-9966-CBB660963EE1")]
internal interface Windows.Foundation.Collections.IIterator`1 {
    public T _Current { get; }
    public bool HasCurrent { get; }
    public abstract virtual bool _MoveNext();
    public abstract virtual UInt32 GetMany(T[]& items);
    public abstract virtual T get__Current();
    public abstract virtual bool get_HasCurrent();
}
[GuidAttribute("02B51929-C1C4-4A7E-8940-0312B5C18500")]
internal interface Windows.Foundation.Collections.IKeyValuePair`2 {
    public K Key { get; }
    public V Value { get; }
    public abstract virtual K get_Key();
    public abstract virtual V get_Value();
}
[GuidAttribute("3C2925FE-8519-45C1-AA79-197B6718C1C1")]
internal interface Windows.Foundation.Collections.IMap`2 {
    public UInt32 Size { get; }
    public abstract virtual V Lookup(K key);
    public abstract virtual bool HasKey(K key);
    public abstract virtual IReadOnlyDictionary`2<K, V> GetView();
    public abstract virtual bool Insert(K key, V value);
    public abstract virtual void _Remove(K key);
    public abstract virtual void Clear();
    public abstract virtual UInt32 get_Size();
}
[GuidAttribute("E480CE40-A338-4ADA-ADCF-272272E48CB9")]
internal interface Windows.Foundation.Collections.IMapView`2 {
    public UInt32 Size { get; }
    public abstract virtual V Lookup(K key);
    public abstract virtual bool HasKey(K key);
    public abstract virtual void Split(IMapView`2& first, IMapView`2& second);
    public abstract virtual UInt32 get_Size();
}
[GuidAttribute("913337E9-11A1-4345-A3A2-4E7F956E222D")]
internal interface Windows.Foundation.Collections.IVector`1 {
    public UInt32 Size { get; }
    public abstract virtual T GetAt(UInt32 index);
    public abstract virtual IReadOnlyList`1<T> GetView();
    public abstract virtual bool IndexOf(T value, UInt32& index);
    public abstract virtual void SetAt(UInt32 index, T value);
    public abstract virtual void InsertAt(UInt32 index, T value);
    public abstract virtual void RemoveAt(UInt32 index);
    public abstract virtual void Append(T value);
    public abstract virtual void RemoveAtEnd();
    public abstract virtual void _Clear();
    public abstract virtual UInt32 GetMany(UInt32 startIndex, T[]& items);
    public abstract virtual void ReplaceAll(T[] items);
    public abstract virtual UInt32 get_Size();
}
[GuidAttribute("BBE1FA4C-B0E3-4583-BAEF-1F1B2E483E56")]
internal interface Windows.Foundation.Collections.IVectorView`1 {
    public UInt32 Size { get; }
    public abstract virtual T GetAt(UInt32 index);
    public abstract virtual bool IndexOf(T value, UInt32& index);
    public abstract virtual UInt32 GetMany(UInt32 startIndex, T[]& items);
    public abstract virtual UInt32 get_Size();
}
internal static class Windows.Foundation.GSR : object {
    public static string ArgumentOutOfRange_NeedNonNegNum;
    private static GSR();
}
[GuidAttribute("4BD682DD-7554-40E9-9A9B-82654EDE7E62")]
internal interface Windows.Foundation.IPropertyValue {
    public bool IsNumericScalar { get; }
    public PropertyType Type { get; }
    public abstract virtual byte GetUInt8();
    public abstract virtual short GetInt16();
    public abstract virtual ushort GetUInt16();
    public abstract virtual int GetInt32();
    public abstract virtual UInt32 GetUInt32();
    public abstract virtual long GetInt64();
    public abstract virtual ulong GetUInt64();
    public abstract virtual float GetSingle();
    public abstract virtual double GetDouble();
    public abstract virtual char GetChar16();
    public abstract virtual bool GetBoolean();
    public abstract virtual string GetString();
    public abstract virtual Guid GetGuid();
    public abstract virtual DateTimeOffset GetDateTime();
    public abstract virtual TimeSpan GetTimeSpan();
    public abstract virtual Point GetPoint();
    public abstract virtual Size GetSize();
    public abstract virtual Rect GetRect();
    public abstract virtual void GetUInt8Array(Byte[]& value);
    public abstract virtual void GetInt16Array(Int16[]& value);
    public abstract virtual void GetUInt16Array(UInt16[]& value);
    public abstract virtual void GetInt32Array(Int32[]& value);
    public abstract virtual void GetUInt32Array(UInt32[]& value);
    public abstract virtual void GetInt64Array(Int64[]& value);
    public abstract virtual void GetUInt64Array(UInt64[]& value);
    public abstract virtual void GetSingleArray(Single[]& value);
    public abstract virtual void GetDoubleArray(Double[]& value);
    public abstract virtual void GetChar16Array(Char[]& value);
    public abstract virtual void GetBooleanArray(Boolean[]& value);
    public abstract virtual void GetStringArray(String[]& value);
    public abstract virtual void GetInspectableArray(Object[]& value);
    public abstract virtual void GetGuidArray(Guid[]& value);
    public abstract virtual void GetDateTimeArray(DateTimeOffset[]& value);
    public abstract virtual void GetTimeSpanArray(TimeSpan[]& value);
    public abstract virtual void GetPointArray(Point[]& value);
    public abstract virtual void GetSizeArray(Size[]& value);
    public abstract virtual void GetRectArray(Rect[]& value);
    public abstract virtual bool get_IsNumericScalar();
    public abstract virtual PropertyType get_Type();
}
[GuidAttribute("61C17707-2D65-11E0-9AE8-D48564015472")]
internal interface Windows.Foundation.IReferenceArray`1 {
    public T[] Value { get; }
    public abstract virtual T[] get_Value();
}
[WindowsRuntimeTypeAttribute("Windows.Foundation.FoundationContract")]
public class Windows.Foundation.Point : ValueType {
    public float _x;
    public float _y;
    public double X { get; public set; }
    public double Y { get; public set; }
    public Point(float x, float y);
    public Point(double x, double y);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    private string ConvertToString(string format, IFormatProvider provider);
    private static char GetNumericListSeparator(IFormatProvider provider);
    public static bool op_Equality(Point point1, Point point2);
    public static bool op_Inequality(Point point1, Point point2);
    public virtual bool Equals(object o);
    public bool Equals(Point value);
    public virtual int GetHashCode();
}
internal enum Windows.Foundation.PropertyType : Enum {
    public UInt32 value__;
    public static PropertyType Empty;
    public static PropertyType UInt8;
    public static PropertyType Int16;
    public static PropertyType UInt16;
    public static PropertyType Int32;
    public static PropertyType UInt32;
    public static PropertyType Int64;
    public static PropertyType UInt64;
    public static PropertyType Single;
    public static PropertyType Double;
    public static PropertyType Char16;
    public static PropertyType Boolean;
    public static PropertyType String;
    public static PropertyType Inspectable;
    public static PropertyType DateTime;
    public static PropertyType TimeSpan;
    public static PropertyType Guid;
    public static PropertyType Point;
    public static PropertyType Size;
    public static PropertyType Rect;
    public static PropertyType OtherType;
    public static PropertyType UInt8Array;
    public static PropertyType Int16Array;
    public static PropertyType UInt16Array;
    public static PropertyType Int32Array;
    public static PropertyType UInt32Array;
    public static PropertyType Int64Array;
    public static PropertyType UInt64Array;
    public static PropertyType SingleArray;
    public static PropertyType DoubleArray;
    public static PropertyType Char16Array;
    public static PropertyType BooleanArray;
    public static PropertyType StringArray;
    public static PropertyType InspectableArray;
    public static PropertyType DateTimeArray;
    public static PropertyType TimeSpanArray;
    public static PropertyType GuidArray;
    public static PropertyType PointArray;
    public static PropertyType SizeArray;
    public static PropertyType RectArray;
    public static PropertyType OtherTypeArray;
}
[WindowsRuntimeTypeAttribute("Windows.Foundation.FoundationContract")]
public class Windows.Foundation.Rect : ValueType {
    public float _x;
    public float _y;
    public float _width;
    public float _height;
    private static double EmptyX;
    private static double EmptyY;
    private static double EmptyWidth;
    private static double EmptyHeight;
    private static Rect s_empty;
    public double X { get; public set; }
    public double Y { get; public set; }
    public double Width { get; public set; }
    public double Height { get; public set; }
    public double Left { get; }
    public double Top { get; }
    public double Right { get; }
    public double Bottom { get; }
    public static Rect Empty { get; }
    public bool IsEmpty { get; }
    public Rect(float x, float y, float width, float height);
    public Rect(double x, double y, double width, double height);
    public Rect(Point point1, Point point2);
    public Rect(Point location, Size size);
    private static Rect();
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public double get_Width();
    public void set_Width(double value);
    public double get_Height();
    public void set_Height(double value);
    public double get_Left();
    public double get_Top();
    public double get_Right();
    public double get_Bottom();
    public static Rect get_Empty();
    public bool get_IsEmpty();
    public bool Contains(Point point);
    public void Intersect(Rect rect);
    public void Union(Rect rect);
    public void Union(Point point);
    private bool ContainsInternal(float x, float y);
    internal bool IntersectsWith(Rect rect);
    private static Rect CreateEmptyRect();
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
    public bool Equals(Rect value);
    public static bool op_Equality(Rect rect1, Rect rect2);
    public static bool op_Inequality(Rect rect1, Rect rect2);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
[WindowsRuntimeTypeAttribute("Windows.Foundation.FoundationContract")]
public class Windows.Foundation.Size : ValueType {
    public float _width;
    public float _height;
    private static Size s_empty;
    public double Width { get; public set; }
    public double Height { get; public set; }
    public static Size Empty { get; }
    public bool IsEmpty { get; }
    public Size(float width, float height);
    public Size(double width, double height);
    private static Size();
    public double get_Width();
    public void set_Width(double value);
    public double get_Height();
    public void set_Height(double value);
    public static Size get_Empty();
    public bool get_IsEmpty();
    private static Size CreateEmptySize();
    public static bool op_Equality(Size size1, Size size2);
    public static bool op_Inequality(Size size1, Size size2);
    public virtual bool Equals(object o);
    public bool Equals(Size value);
    public virtual int GetHashCode();
    private static bool Equals(Size size1, Size size2);
    public virtual string ToString();
}
public static class Windows.Foundation.TokenizerHelper : object {
    public static char GetNumericListSeparator(IFormatProvider provider);
}
internal class WinRT.ActivatableComponentActivationFactory`1 : ComponentActivationFactory {
    public sealed virtual IntPtr ActivateInstance();
}
internal class WinRT.ActivationFactory`1 : BaseActivationFactory {
    private static ActivationFactory`1<T> _factory;
    private static ActivationFactory`1();
    public static I AsInterface();
    public static ObjectReference`1<I> As();
    public static IObjectReference As(Guid iid);
    public static ObjectReference`1<I> ActivateInstance();
}
public class WinRT.AgileReference : object {
    private static Guid CLSID_StdGlobalInterfaceTable;
    private static Lazy`1<IGlobalInterfaceTable> Git;
    private IObjectReference _agileReference;
    private IntPtr _cookie;
    private bool disposed;
    public AgileReference(IObjectReference instance);
    internal AgileReference(ObjectReferenceValue& instance);
    internal AgileReference(IntPtr thisPtr);
    private static AgileReference();
    public IObjectReference Get();
    internal ObjectReference`1<T> Get(Guid iid);
    protected virtual void Dispose(bool disposing);
    private static IGlobalInterfaceTable GetGitTable();
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
}
public class WinRT.AgileReference`1 : AgileReference {
    public AgileReference`1(IObjectReference instance);
    internal AgileReference`1(ObjectReferenceValue& instance);
    public T Get();
}
internal class WinRT.BaseActivationFactory : object {
    private ObjectReference`1<IActivationFactoryVftbl> _IActivationFactory;
    public ObjectReference`1<IActivationFactoryVftbl> Value { get; }
    public BaseActivationFactory(string typeNamespace, string typeFullName);
    public ObjectReference`1<IActivationFactoryVftbl> get_Value();
    public I AsInterface();
    public ObjectReference`1<I> _ActivateInstance();
    public ObjectReference`1<I> _As();
    public IObjectReference _As(Guid iid);
}
internal class WinRT.Cache : object {
    private IWeakReference target;
    private ConcurrentDictionary`2<int, WeakReference`1<State>> states;
    private static ReaderWriterLockSlim cachesLock;
    private static ConcurrentDictionary`2<IntPtr, Cache> caches;
    private Cache(IWeakReference target, int index, WeakReference`1<State> state);
    private static Cache();
    private Cache Update(IWeakReference target, int index, WeakReference`1<State> state);
    private WeakReference`1<State> GetState(int index);
    private void SetState(int index, WeakReference`1<State> state);
    public static void Create(IObjectReference obj, int index, WeakReference`1<State> state);
    public static WeakReference`1<State> GetState(IObjectReference obj, int index);
    public static void Remove(IntPtr thisPtr, int index, WeakReference`1<State> state);
}
[ExtensionAttribute]
public static class WinRT.CastExtensions : object {
    [ExtensionAttribute]
public static TInterface As(object value);
    [ExtensionAttribute]
public static AgileReference`1<T> AsAgile(T value);
    private static bool TryGetRefForObject(object value, bool allowComposed, IObjectReference& reference);
    private static IObjectReference GetRefForObject(object value);
    private static bool TryGetComposedRefForQI(object value, IObjectReference& objRef);
}
internal class WinRT.ComponentActivationFactory : object {
    public sealed virtual IntPtr ActivateInstance();
}
public class WinRT.ComWrappersHelper : object {
    public static void Init(bool isAggregation, object thisInstance, IntPtr newInstance, IntPtr inner, IObjectReference& objRef);
    public static void Init(IObjectReference objRef, bool addRefFromTrackerSource);
}
public static class WinRT.ComWrappersSupport : object {
    private static ConcurrentDictionary`2<Type, Func`2<IInspectable, object>> TypedObjectFactoryCacheForType;
    private static ConditionalWeakTable`2<object, object> CCWTable;
    private static ConcurrentDictionary`2<Type, Func`2<IntPtr, object>> DelegateFactoryCache;
    private static ConditionalWeakTable`2<object, IInspectable> _boxedValueReferenceCache;
    private static ConcurrentDictionary`2<Type, bool> IsIReferenceTypeCache;
    private static DefaultComWrappers _instance;
    internal static ConditionalWeakTable`2<Type, InspectableInfo> InspectableInfoTable;
    [ThreadStaticAttribute]
internal static Type CreateRCWType;
    private static ComWrappers _comWrappers;
    private static object _comWrappersLock;
    private static ComInterfaceEntry IPropertyValueEntry { get; }
    private static DefaultComWrappers DefaultComWrappersInstance { get; }
    private static ComWrappers ComWrappers { get; private set; }
    public static IUnknownVftbl IUnknownVftbl { get; }
    public static IntPtr IUnknownVftblPtr { get; }
    private static ComWrappersSupport();
    public static TReturn MarshalDelegateInvoke(IntPtr thisPtr, Func`2<TDelegate, TReturn> invoke);
    public static void MarshalDelegateInvoke(IntPtr thisPtr, Action`1<T> invoke);
    internal static bool IsFreeThreaded(IObjectReference objRef);
    public static IObjectReference GetObjectReferenceForInterface(IntPtr externalComObject);
    public static ObjectReference`1<T> GetObjectReferenceForInterface(IntPtr externalComObject);
    public static ObjectReference`1<T> GetObjectReferenceForInterface(IntPtr externalComObject, Guid iid);
    public static void RegisterProjectionAssembly(Assembly assembly);
    internal static object GetRuntimeClassCCWTypeIfAny(object obj);
    internal static List`1<ComInterfaceEntry> GetInterfaceTableEntries(Type type);
    internal static ValueTuple`2<InspectableInfo, List`1<ComInterfaceEntry>> PregenerateNativeTypeInformation(Type type);
    private static bool IsNullableT(Type implementationType);
    private static bool IsAbiNullableDelegate(Type implementationType);
    private static bool IsIReferenceArray(Type implementationType);
    private static Func`2<IInspectable, object> CreateKeyValuePairFactory(Type type);
    internal static Func`2<IntPtr, object> CreateDelegateFactory(Type type);
    private static Func`2<IInspectable, object> CreateNullableTFactory(Type implementationType);
    private static Func`2<IInspectable, object> CreateAbiNullableTFactory(Type implementationType);
    private static Func`2<IInspectable, object> CreateArrayFactory(Type implementationType);
    private static Func`2<IInspectable, object> CreateReferenceCachingFactory(Func`2<IInspectable, object> internalFactory);
    private static Func`2<IInspectable, object> CreateCustomTypeMappingFactory(Type customTypeHelperType);
    internal static Func`2<IInspectable, object> CreateTypedRcwFactory(Type implementationType, string runtimeClassName);
    internal static Type GetRuntimeClassForTypeCreation(IInspectable inspectable, Type staticallyDeterminedType);
    private static bool IsIReferenceType(Type type);
    private static bool ShouldProvideIReference(Type type);
    private static ComInterfaceEntry get_IPropertyValueEntry();
    private static ComInterfaceEntry ProvideIReference(Type type);
    private static bool ShouldProvideIReferenceArray(Type type);
    private static ComInterfaceEntry ProvideIReferenceArray(Type arrayType);
    internal static ObjectReference`1<T> CreateCCWForObject(object obj, Guid iid);
    internal static ObjectReferenceValue CreateCCWForObjectForMarshaling(object obj, Guid iid);
    private static DefaultComWrappers get_DefaultComWrappersInstance();
    private static ComWrappers get_ComWrappers();
    private static void set_ComWrappers(ComWrappers value);
    internal static InspectableInfo GetInspectableInfo(IntPtr pThis);
    public static T CreateRcwForComObject(IntPtr ptr);
    private static T CreateRcwForComObject(IntPtr ptr, bool tryUseCache);
    public static bool TryUnwrapObject(object o, IObjectReference& objRef);
    public static void RegisterObjectForInterface(object obj, IntPtr thisPtr, CreateObjectFlags createObjectFlags);
    public static void RegisterObjectForInterface(object obj, IntPtr thisPtr);
    public static object TryRegisterObjectForInterface(object obj, IntPtr thisPtr);
    public static IObjectReference CreateCCWForObject(object obj);
    internal static IntPtr CreateCCWForObjectForABI(object obj, Guid iid);
    public static T FindObject(IntPtr ptr);
    private static T FindDelegate(IntPtr thisPtr);
    public static IUnknownVftbl get_IUnknownVftbl();
    public static IntPtr get_IUnknownVftblPtr();
    public static IntPtr AllocateVtableMemory(Type vtableType, int size);
    public static void InitializeComWrappers(ComWrappers wrappers);
    internal static Func`2<IInspectable, object> GetTypedRcwFactory(Type implementationType);
    private static Func`2<IInspectable, object> CreateFactoryForImplementationType(string runtimeClassName, Type implementationType);
    [CompilerGeneratedAttribute]
internal static bool <IsIReferenceType>g__IsIReferenceTypeHelper|27_0(Type type);
}
internal static class WinRT.Context : object {
    private static Guid IID_ICallbackWithNoReentrancyToApplicationSTA;
    private static Context();
    private static int CoGetContextToken(IntPtr* contextToken);
    private static int CoGetObjectContext(Guid& riid, IntPtr& ppv);
    public static IntPtr GetContextCallback();
    public static IntPtr GetContextToken();
    public static void CallInContext(IntPtr contextCallbackPtr, IntPtr contextToken, Action callback, Action onFailCallback);
    public static void DisposeContextCallback(IntPtr contextCallbackPtr);
}
public class WinRT.DefaultComWrappers : ComWrappers {
    private static ConditionalWeakTable`2<Type, VtableEntries> TypeVtableEntryTable;
    [CompilerGeneratedAttribute]
private static IntPtr <IUnknownVftblPtr>k__BackingField;
    public static IUnknownVftbl IUnknownVftbl { get; }
    internal static IntPtr IUnknownVftblPtr { get; }
    private static DefaultComWrappers();
    public static IUnknownVftbl get_IUnknownVftbl();
    [CompilerGeneratedAttribute]
internal static IntPtr get_IUnknownVftblPtr();
    protected virtual ComInterfaceEntry* ComputeVtables(object obj, CreateComInterfaceFlags flags, Int32& count);
    private static bool IsRuntimeImplementedRCW(Type objType);
    private static object CreateObject(IntPtr externalComObject);
    protected virtual object CreateObject(IntPtr externalComObject, CreateObjectFlags flags);
    protected virtual void ReleaseObjects(IEnumerable objects);
}
[ExtensionAttribute]
internal static class WinRT.DelegateExtensions : object {
    [ExtensionAttribute]
public static void DynamicInvokeAbi(Delegate del, Object[] invoke_params);
}
[EditorBrowsableAttribute("1")]
public class WinRT.DerivedComposed : object {
    public static DerivedComposed Instance;
    private static DerivedComposed();
}
internal class WinRT.DllModule : object {
    private string _fileName;
    private IntPtr _moduleHandle;
    private method _GetActivationFactory;
    private method _CanUnloadNow;
    private static string _currentModuleDirectory;
    private static Dictionary`2<string, DllModule> _cache;
    private DllModule(string fileName, IntPtr moduleHandle, Void* getActivationFactory);
    private static DllModule();
    public static bool TryLoad(string fileName, DllModule& module);
    private static bool TryCreate(string fileName, DllModule& module);
    public ValueTuple`2<ObjectReference`1<IActivationFactoryVftbl>, int> GetActivationFactory(string runtimeClassId);
    protected virtual override void Finalize();
}
public class WinRT.EventRegistrationToken : ValueType {
    public long Value;
    public EventRegistrationToken(long _Value);
    public static bool op_Equality(EventRegistrationToken x, EventRegistrationToken y);
    public static bool op_Inequality(EventRegistrationToken x, EventRegistrationToken y);
    public sealed virtual bool Equals(EventRegistrationToken other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class WinRT.EventRegistrationTokenTable`1 : object {
    private Dictionary`2<EventRegistrationToken, T> m_tokens;
    public EventRegistrationToken AddEventHandler(T handler);
    private EventRegistrationToken AddEventHandlerNoLock(T handler);
    private static EventRegistrationToken GetPreferredToken(T handler);
    public bool RemoveEventHandler(EventRegistrationToken token, T& handler);
    private void RemoveEventHandlerNoLock(EventRegistrationToken token);
}
internal class WinRT.EventSource__EventHandler`1 : EventSource`1<EventHandler`1<T>> {
    internal EventSource__EventHandler`1(IObjectReference obj, method addHandler, method removeHandler, int index);
    protected virtual ObjectReferenceValue CreateMarshaler(EventHandler`1<T> del);
    protected virtual State CreateEventState();
}
internal abstract class WinRT.EventSource`1 : object {
    protected IObjectReference _obj;
    protected int _index;
    private method _addHandler;
    private method _removeHandler;
    protected WeakReference`1<State> _state;
    private ValueTuple`2<Action`1<TDelegate>, Action`1<TDelegate>> _handlerTuple;
    public ValueTuple`2<Action`1<TDelegate>, Action`1<TDelegate>> EventActions { get; }
    protected EventSource`1(IObjectReference obj, method addHandler, method removeHandler, int index);
    protected abstract virtual ObjectReferenceValue CreateMarshaler(TDelegate del);
    protected abstract virtual State CreateEventState();
    public void Subscribe(TDelegate del);
    public void Unsubscribe(TDelegate del);
    public ValueTuple`2<Action`1<TDelegate>, Action`1<TDelegate>> get_EventActions();
    private void UnsubscribeFromNative(State state);
}
[ExtensionAttribute]
public static class WinRT.ExceptionExtensions : object {
    [ExtensionAttribute]
public static void SetHResult(Exception ex, int value);
    [ExtensionAttribute]
internal static Exception GetExceptionForHR(Exception innerException, int hresult, string messageResource);
}
[ExtensionAttribute]
public static class WinRT.ExceptionHelpers : object {
    private static int COR_E_OBJECTDISPOSED;
    private static int RO_E_CLOSED;
    internal static int E_BOUNDS;
    internal static int E_CHANGED_STATE;
    private static int E_ILLEGAL_STATE_CHANGE;
    private static int E_ILLEGAL_METHOD_CALL;
    private static int E_ILLEGAL_DELEGATE_ASSIGNMENT;
    private static int APPMODEL_ERROR_NO_PACKAGE;
    internal static int E_XAMLPARSEFAILED;
    internal static int E_LAYOUTCYCLE;
    internal static int E_ELEMENTNOTENABLED;
    internal static int E_ELEMENTNOTAVAILABLE;
    internal static int ERROR_INVALID_WINDOW_HANDLE;
    private static method getRestrictedErrorInfo;
    private static method setRestrictedErrorInfo;
    private static method roOriginateLanguageException;
    private static method roReportUnhandledError;
    private static bool initialized;
    private static ExceptionHelpers();
    private static int SetErrorInfo(UInt32 dwReserved, IntPtr perrinfo);
    private static bool Initialize();
    public static void ThrowExceptionForHR(int hr);
    public static Exception GetExceptionForHR(int hr);
    private static Exception GetExceptionForHR(int hr, bool useGlobalErrorState, Boolean& restoredExceptionFromGlobalState);
    public static void SetErrorInfo(Exception ex);
    public static void ReportUnhandledError(Exception ex);
    public static int GetHRForException(Exception ex);
    [ExtensionAttribute]
internal static void AddExceptionDataForRestrictedErrorInfo(Exception ex, string description, string restrictedError, string restrictedErrorReference, string restrictedCapabilitySid, IObjectReference restrictedErrorObject, bool hasRestrictedLanguageErrorObject);
    [ExtensionAttribute]
internal static bool TryGetRestrictedLanguageErrorObject(Exception ex, IObjectReference& restrictedErrorObject);
    public static Exception AttachRestrictedErrorInfo(Exception e);
    [CompilerGeneratedAttribute]
internal static void <ThrowExceptionForHR>g__Throw|20_0(int hr);
}
public static class WinRT.GuidGenerator : object {
    private static Guid wrt_pinterface_namespace;
    private static GuidGenerator();
    public static Guid GetGUID(Type type);
    public static Guid GetIID(Type type);
    public static string GetSignature(Type type);
    private static Guid encode_guid(Span`1<byte> data);
    public static Guid CreateIID(Type type);
}
[ObjectReferenceWrapperAttribute("_obj")]
[GuidAttribute("AF86E2E0-B12D-4c6a-9C5A-D7AA65101E90")]
public class WinRT.IInspectable : object {
    private ObjectReference`1<Vftbl> _obj;
    private ConcurrentDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) _queryInterfaceCache;
    private ConcurrentDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) _additionalTypeData;
    public IntPtr ThisPtr { get; }
    public IObjectReference ObjRef { get; }
    private IObjectReference WinRT.IWinRTObject.NativeObject { get; }
    private bool WinRT.IWinRTObject.HasUnwrappableNativeObject { get; }
    private ConcurrentDictionary`2<RuntimeTypeHandle, IObjectReference> WinRT.IWinRTObject.QueryInterfaceCache { get; }
    private ConcurrentDictionary`2<RuntimeTypeHandle, object> WinRT.IWinRTObject.AdditionalTypeData { get; }
    public IInspectable(IObjectReference obj);
    public IInspectable(ObjectReference`1<Vftbl> obj);
    public static IInspectable FromAbi(IntPtr thisPtr);
    public IntPtr get_ThisPtr();
    public static IInspectable op_Implicit(IObjectReference obj);
    public static IInspectable op_Implicit(ObjectReference`1<Vftbl> obj);
    public ObjectReference`1<I> As();
    public IObjectReference get_ObjRef();
    public string GetRuntimeClassName(bool noThrow);
    private sealed virtual override IObjectReference WinRT.IWinRTObject.get_NativeObject();
    private sealed virtual override bool WinRT.IWinRTObject.get_HasUnwrappableNativeObject();
    private ConcurrentDictionary`2<RuntimeTypeHandle, IObjectReference> MakeQueryInterfaceCache();
    private sealed virtual override ConcurrentDictionary`2<RuntimeTypeHandle, IObjectReference> WinRT.IWinRTObject.get_QueryInterfaceCache();
    private ConcurrentDictionary`2<RuntimeTypeHandle, object> MakeAdditionalTypeData();
    private sealed virtual override ConcurrentDictionary`2<RuntimeTypeHandle, object> WinRT.IWinRTObject.get_AdditionalTypeData();
}
internal static class WinRT.InterfaceIIDs : object {
    internal static Guid IInspectable_IID;
    internal static Guid IUnknown_IID;
    internal static Guid IWeakReferenceSource_IID;
    private static InterfaceIIDs();
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._add_EventHandler : MulticastDelegate {
    public _add_EventHandler(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, IntPtr handler, EventRegistrationToken& token);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, IntPtr handler, EventRegistrationToken& token, AsyncCallback callback, object object);
    public virtual int EndInvoke(EventRegistrationToken& token, IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._get_PropertyAsBoolean : MulticastDelegate {
    public _get_PropertyAsBoolean(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, Byte& value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, Byte& value, AsyncCallback callback, object object);
    public virtual int EndInvoke(Byte& value, IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._get_PropertyAsByte : MulticastDelegate {
    public _get_PropertyAsByte(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, Byte& value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, Byte& value, AsyncCallback callback, object object);
    public virtual int EndInvoke(Byte& value, IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._get_PropertyAsChar : MulticastDelegate {
    public _get_PropertyAsChar(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, UInt16& value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, UInt16& value, AsyncCallback callback, object object);
    public virtual int EndInvoke(UInt16& value, IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._get_PropertyAsDouble : MulticastDelegate {
    public _get_PropertyAsDouble(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, Double& value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, Double& value, AsyncCallback callback, object object);
    public virtual int EndInvoke(Double& value, IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._get_PropertyAsFloat : MulticastDelegate {
    public _get_PropertyAsFloat(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, Single& value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, Single& value, AsyncCallback callback, object object);
    public virtual int EndInvoke(Single& value, IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._get_PropertyAsGuid : MulticastDelegate {
    public _get_PropertyAsGuid(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, Guid& value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, Guid& value, AsyncCallback callback, object object);
    public virtual int EndInvoke(Guid& value, IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._get_PropertyAsInt16 : MulticastDelegate {
    public _get_PropertyAsInt16(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, Int16& value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, Int16& value, AsyncCallback callback, object object);
    public virtual int EndInvoke(Int16& value, IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._get_PropertyAsInt32 : MulticastDelegate {
    public _get_PropertyAsInt32(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, Int32& value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, Int32& value, AsyncCallback callback, object object);
    public virtual int EndInvoke(Int32& value, IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._get_PropertyAsInt64 : MulticastDelegate {
    public _get_PropertyAsInt64(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, Int64& value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, Int64& value, AsyncCallback callback, object object);
    public virtual int EndInvoke(Int64& value, IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._get_PropertyAsObject : MulticastDelegate {
    public _get_PropertyAsObject(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, IntPtr& value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, IntPtr& value, AsyncCallback callback, object object);
    public virtual int EndInvoke(IntPtr& value, IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._get_PropertyAsSByte : MulticastDelegate {
    public _get_PropertyAsSByte(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, SByte& value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, SByte& value, AsyncCallback callback, object object);
    public virtual int EndInvoke(SByte& value, IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._get_PropertyAsString : MulticastDelegate {
    public _get_PropertyAsString(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, IntPtr& value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, IntPtr& value, AsyncCallback callback, object object);
    public virtual int EndInvoke(IntPtr& value, IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._get_PropertyAsUInt16 : MulticastDelegate {
    public _get_PropertyAsUInt16(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, UInt16& value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, UInt16& value, AsyncCallback callback, object object);
    public virtual int EndInvoke(UInt16& value, IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._get_PropertyAsUInt32 : MulticastDelegate {
    public _get_PropertyAsUInt32(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, UInt32& value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, UInt32& value, AsyncCallback callback, object object);
    public virtual int EndInvoke(UInt32& value, IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._get_PropertyAsUInt64 : MulticastDelegate {
    public _get_PropertyAsUInt64(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, UInt64& value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, UInt64& value, AsyncCallback callback, object object);
    public virtual int EndInvoke(UInt64& value, IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._put_PropertyAsBoolean : MulticastDelegate {
    public _put_PropertyAsBoolean(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, byte value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, byte value, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._put_PropertyAsByte : MulticastDelegate {
    public _put_PropertyAsByte(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, byte value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, byte value, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._put_PropertyAsChar : MulticastDelegate {
    public _put_PropertyAsChar(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, ushort value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, ushort value, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._put_PropertyAsDouble : MulticastDelegate {
    public _put_PropertyAsDouble(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, double value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, double value, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._put_PropertyAsFloat : MulticastDelegate {
    public _put_PropertyAsFloat(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, float value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, float value, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._put_PropertyAsGuid : MulticastDelegate {
    public _put_PropertyAsGuid(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, Guid value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, Guid value, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._put_PropertyAsInt16 : MulticastDelegate {
    public _put_PropertyAsInt16(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, short value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, short value, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._put_PropertyAsInt32 : MulticastDelegate {
    public _put_PropertyAsInt32(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, int value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, int value, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._put_PropertyAsInt64 : MulticastDelegate {
    public _put_PropertyAsInt64(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, long value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, long value, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._put_PropertyAsObject : MulticastDelegate {
    public _put_PropertyAsObject(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, IntPtr value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, IntPtr value, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._put_PropertyAsSByte : MulticastDelegate {
    public _put_PropertyAsSByte(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, sbyte value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, sbyte value, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._put_PropertyAsString : MulticastDelegate {
    public _put_PropertyAsString(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, IntPtr value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, IntPtr value, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._put_PropertyAsUInt16 : MulticastDelegate {
    public _put_PropertyAsUInt16(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, ushort value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, ushort value, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._put_PropertyAsUInt32 : MulticastDelegate {
    public _put_PropertyAsUInt32(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, UInt32 value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, UInt32 value, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._put_PropertyAsUInt64 : MulticastDelegate {
    public _put_PropertyAsUInt64(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, ulong value);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, ulong value, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
public class WinRT.Interop._remove_EventHandler : MulticastDelegate {
    public _remove_EventHandler(object object, IntPtr method);
    public virtual int Invoke(IntPtr thisPtr, EventRegistrationToken token);
    public virtual IAsyncResult BeginInvoke(IntPtr thisPtr, EventRegistrationToken token, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
internal class WinRT.Interop.ComCallData : ValueType {
    public int dwDispid;
    public int dwReserved;
    public IntPtr pUserDefined;
}
[WindowsRuntimeTypeAttribute("")]
[GuidAttribute("00000035-0000-0000-C000-000000000046")]
public interface WinRT.Interop.IActivationFactory {
    public abstract virtual IntPtr ActivateInstance();
}
[GuidAttribute("00000035-0000-0000-C000-000000000046")]
internal class WinRT.Interop.IActivationFactoryVftbl : ValueType {
    public Vftbl IInspectableVftbl;
    private Void* _ActivateInstance;
    internal static Guid IID;
    public method ActivateInstance { get; }
    private static IActivationFactoryVftbl();
    public method get_ActivateInstance();
}
[WindowsRuntimeTypeAttribute("")]
[GuidAttribute("94ea2b94-e9cc-49e0-c0ff-ee64ca8f5b90")]
public interface WinRT.Interop.IAgileObject {
    public static Guid IID;
    private static IAgileObject();
}
[WindowsRuntimeTypeAttribute("")]
[GuidAttribute("C03F6A43-65A4-9818-987E-E0B810D2A6F2")]
internal interface WinRT.Interop.IAgileReference {
    public abstract virtual IObjectReference Resolve(Guid riid);
}
[GuidAttribute("000001da-0000-0000-C000-000000000046")]
internal interface WinRT.Interop.IContextCallback {
    public abstract virtual void ContextCallback(PFNCONTEXTCALL pfnCallback, ComCallData* pParam, Guid riid, int iMethod);
}
internal class WinRT.Interop.IDelegateVftbl : ValueType {
    public IUnknownVftbl IUnknownVftbl;
    public IntPtr Invoke;
}
[GuidAttribute("1CF2B120-547D-101B-8E65-08002B2BD119")]
internal interface WinRT.Interop.IErrorInfo {
    public abstract virtual Guid GetGuid();
    public abstract virtual string GetSource();
    public abstract virtual string GetDescription();
    public abstract virtual string GetHelpFile();
    public abstract virtual string GetHelpFileContent();
}
[WindowsRuntimeTypeAttribute("")]
[GuidAttribute("00000146-0000-0000-C000-000000000046")]
internal interface WinRT.Interop.IGlobalInterfaceTable {
    public abstract virtual IntPtr RegisterInterfaceInGlobal(IntPtr ptr, Guid riid);
    public abstract virtual void RevokeInterfaceFromGlobal(IntPtr cookie);
    public abstract virtual IObjectReference GetInterfaceFromGlobal(IntPtr cookie, Guid riid);
}
[GuidAttribute("04a2dbf3-df83-116c-0946-0812abf6e07d")]
internal interface WinRT.Interop.ILanguageExceptionErrorInfo {
    public abstract virtual IObjectReference GetLanguageException();
}
[WindowsRuntimeTypeAttribute("Windows.Foundation.UniversalApiContract")]
[GuidAttribute("00000003-0000-0000-c000-000000000046")]
internal interface WinRT.Interop.IMarshal {
    public abstract virtual void GetUnmarshalClass(Guid* riid, IntPtr pv, MSHCTX dwDestContext, IntPtr pvDestContext, MSHLFLAGS mshlFlags, Guid* pCid);
    public abstract virtual void GetMarshalSizeMax(Guid* riid, IntPtr pv, MSHCTX dwDestContext, IntPtr pvDestContext, MSHLFLAGS mshlflags, UInt32* pSize);
    public abstract virtual void MarshalInterface(IntPtr pStm, Guid* riid, IntPtr pv, MSHCTX dwDestContext, IntPtr pvDestContext, MSHLFLAGS mshlflags);
    public abstract virtual void UnmarshalInterface(IntPtr pStm, Guid* riid, IntPtr* ppv);
    public abstract virtual void ReleaseMarshalData(IntPtr pStm);
    public abstract virtual void DisconnectObject(UInt32 dwReserved);
}
[GuidAttribute("64BD43F8-bFEE-4EC4-B7EB-2935158DAE21")]
internal class WinRT.Interop.IReferenceTrackerTargetVftbl : ValueType {
    public IUnknownVftbl IUnknownVftbl;
    private Void* _AddRefFromReferenceTracker;
    private Void* _ReleaseFromReferenceTracker;
    private Void* _Peg;
    private Void* _Unpeg;
    internal static Guid IID;
    public method AddRefFromReferenceTracker { get; }
    public method ReleaseFromReferenceTracker { get; }
    private static IReferenceTrackerTargetVftbl();
    public method get_AddRefFromReferenceTracker();
    public method get_ReleaseFromReferenceTracker();
}
[GuidAttribute("11D3B13A-180E-4789-A8BE-7712882893E6")]
internal class WinRT.Interop.IReferenceTrackerVftbl : ValueType {
    public IUnknownVftbl IUnknownVftbl;
    private Void* _ConnectFromTrackerSource_0;
    private Void* _DisconnectFromTrackerSource_1;
    private Void* _FindTrackerTargets_2;
    private Void* _GetReferenceTrackerManager_3;
    private Void* _AddRefFromTrackerSource_4;
    private Void* _ReleaseFromTrackerSource_5;
    private Void* _PegFromTrackerSource_6;
    internal static Guid IID;
    public method AddRefFromTrackerSource { get; public set; }
    public method ReleaseFromTrackerSource { get; public set; }
    private static IReferenceTrackerVftbl();
    public method get_AddRefFromTrackerSource();
    public void set_AddRefFromTrackerSource(method value);
    public method get_ReleaseFromTrackerSource();
    public void set_ReleaseFromTrackerSource(method value);
}
[GuidAttribute("82BA7092-4C88-427D-A7BC-16DD93FEB67E")]
internal interface WinRT.Interop.IRestrictedErrorInfo {
    public abstract virtual void GetErrorDetails(String& description, Int32& error, String& restrictedDescription, String& capabilitySid);
    public abstract virtual string GetReference();
}
[GuidAttribute("DF0B3D60-548F-101B-8E65-08002B2BD119")]
internal interface WinRT.Interop.ISupportErrorInfo {
    public abstract virtual bool InterfaceSupportsErrorInfo(Guid riid);
}
[GuidAttribute("00000000-0000-0000-C000-000000000046")]
public class WinRT.Interop.IUnknownVftbl : ValueType {
    private Void* _QueryInterface;
    private Void* _AddRef;
    private Void* _Release;
    internal static Guid IID;
    public method QueryInterface { get; public set; }
    public method AddRef { get; public set; }
    public method Release { get; public set; }
    public static IUnknownVftbl AbiToProjectionVftbl { get; }
    public static IntPtr AbiToProjectionVftblPtr { get; }
    private static IUnknownVftbl();
    public method get_QueryInterface();
    public void set_QueryInterface(method value);
    public method get_AddRef();
    public void set_AddRef(method value);
    public method get_Release();
    public void set_Release(method value);
    public static IUnknownVftbl get_AbiToProjectionVftbl();
    public static IntPtr get_AbiToProjectionVftblPtr();
    internal bool Equals(IUnknownVftbl other);
    internal static bool IsReferenceToManagedObject(IntPtr ptr);
}
[WindowsRuntimeTypeAttribute("")]
[GuidAttribute("00000037-0000-0000-C000-000000000046")]
public interface WinRT.Interop.IWeakReference {
    public abstract virtual IObjectReference Resolve(Guid riid);
}
[WindowsRuntimeTypeAttribute("")]
[GuidAttribute("00000038-0000-0000-C000-000000000046")]
public interface WinRT.Interop.IWeakReferenceSource {
    public abstract virtual IWeakReference GetWeakReference();
}
internal class WinRT.Interop.ManagedExceptionErrorInfo : object {
    private Exception _exception;
    public ManagedExceptionErrorInfo(Exception ex);
    public sealed virtual bool InterfaceSupportsErrorInfo(Guid riid);
    public sealed virtual Guid GetGuid();
    public sealed virtual string GetSource();
    public sealed virtual string GetDescription();
    public sealed virtual string GetHelpFile();
    public sealed virtual string GetHelpFileContent();
}
internal class WinRT.Interop.ManagedWeakReference : object {
    private WeakReference`1<object> _ref;
    public ManagedWeakReference(object obj);
    public sealed virtual IObjectReference Resolve(Guid riid);
    public IntPtr ResolveForABI(Guid riid);
}
internal enum WinRT.Interop.MSHCTX : Enum {
    public int value__;
    public static MSHCTX Local;
    public static MSHCTX NoSharedMem;
    public static MSHCTX DifferentMachine;
    public static MSHCTX InProc;
    public static MSHCTX CrossCtx;
}
internal enum WinRT.Interop.MSHLFLAGS : Enum {
    public int value__;
    public static MSHLFLAGS Normal;
    public static MSHLFLAGS TableStrong;
    public static MSHLFLAGS TableWeak;
    public static MSHLFLAGS NoPing;
}
internal class WinRT.Interop.PFNCONTEXTCALL : MulticastDelegate {
    public PFNCONTEXTCALL(object object, IntPtr method);
    public virtual int Invoke(ComCallData* data);
    public virtual IAsyncResult BeginInvoke(ComCallData* data, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
public abstract class WinRT.IObjectReference : object {
    protected bool disposed;
    private IntPtr _thisPtr;
    private object _disposedLock;
    private IntPtr _referenceTrackerPtr;
    [CompilerGeneratedAttribute]
private bool <IsAggregated>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreventReleaseOnDispose>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreventReleaseFromTrackerSourceOnDispose>k__BackingField;
    public IntPtr ThisPtr { get; }
    private protected IntPtr ThisPtrFromOriginalContext { get; }
    internal bool IsAggregated { get; internal set; }
    internal bool PreventReleaseOnDispose { get; internal set; }
    internal bool PreventReleaseFromTrackerSourceOnDispose { get; internal set; }
    internal IntPtr ReferenceTrackerPtr { get; internal set; }
    internal IReferenceTrackerVftbl ReferenceTracker { get; }
    protected IUnknownVftbl VftblIUnknown { get; }
    private protected IUnknownVftbl VftblIUnknownFromOriginalContext { get; }
    internal bool IsReferenceToManagedObject { get; }
    protected IObjectReference(IntPtr thisPtr);
    public IntPtr get_ThisPtr();
    private protected IntPtr get_ThisPtrFromOriginalContext();
    [CompilerGeneratedAttribute]
internal bool get_IsAggregated();
    [CompilerGeneratedAttribute]
internal void set_IsAggregated(bool value);
    [CompilerGeneratedAttribute]
internal bool get_PreventReleaseOnDispose();
    [CompilerGeneratedAttribute]
internal void set_PreventReleaseOnDispose(bool value);
    [CompilerGeneratedAttribute]
internal bool get_PreventReleaseFromTrackerSourceOnDispose();
    [CompilerGeneratedAttribute]
internal void set_PreventReleaseFromTrackerSourceOnDispose(bool value);
    internal IntPtr get_ReferenceTrackerPtr();
    internal void set_ReferenceTrackerPtr(IntPtr value);
    internal IReferenceTrackerVftbl get_ReferenceTracker();
    protected IUnknownVftbl get_VftblIUnknown();
    private protected IUnknownVftbl get_VftblIUnknownFromOriginalContext();
    protected virtual override void Finalize();
    public ObjectReference`1<T> As();
    public ObjectReference`1<T> As(Guid iid);
    public TInterface AsInterface();
    public int TryAs(ObjectReference`1& objRef);
    public virtual int TryAs(Guid iid, ObjectReference`1& objRef);
    public virtual ObjectReference`1<IUnknownVftbl> AsKnownPtr(IntPtr ptr);
    public virtual int TryAs(Guid iid, IntPtr& ppv);
    public IObjectReference As(Guid iid);
    public T AsType();
    public IntPtr GetRef();
    protected void ThrowIfDisposed();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    internal bool Resurrect();
    protected virtual void AddRef(bool refFromTrackerSource);
    protected virtual void AddRef();
    protected virtual void Release();
    private protected void ReleaseWithoutContext();
    internal bool get_IsReferenceToManagedObject();
    internal void AddRefFromTrackerSource();
    internal void ReleaseFromTrackerSource();
    private void ResurrectTrackerSource();
    private void DisposeTrackerSource();
    private protected virtual IntPtr GetThisPtrForCurrentContext();
    public ObjectReferenceValue AsValue();
    public ObjectReferenceValue AsValue(Guid iid);
}
public interface WinRT.IWinRTObject {
    public IObjectReference NativeObject { get; }
    public bool HasUnwrappableNativeObject { get; }
    protected ConcurrentDictionary`2<RuntimeTypeHandle, IObjectReference> QueryInterfaceCache { get; }
    public ConcurrentDictionary`2<RuntimeTypeHandle, object> AdditionalTypeData { get; }
    private sealed virtual override bool System.Runtime.InteropServices.IDynamicInterfaceCastable.IsInterfaceImplemented(RuntimeTypeHandle interfaceType, bool throwIfNotImplemented);
    public virtual bool IsInterfaceImplementedFallback(RuntimeTypeHandle interfaceType, bool throwIfNotImplemented);
    private sealed virtual override RuntimeTypeHandle System.Runtime.InteropServices.IDynamicInterfaceCastable.GetInterfaceImplementation(RuntimeTypeHandle interfaceType);
    public abstract virtual IObjectReference get_NativeObject();
    public abstract virtual bool get_HasUnwrappableNativeObject();
    protected abstract virtual ConcurrentDictionary`2<RuntimeTypeHandle, IObjectReference> get_QueryInterfaceCache();
    public virtual IObjectReference GetObjectReferenceForType(RuntimeTypeHandle type);
    public virtual IObjectReference GetObjectReferenceForTypeFallback(RuntimeTypeHandle type);
    public abstract virtual ConcurrentDictionary`2<RuntimeTypeHandle, object> get_AdditionalTypeData();
    public virtual object GetOrCreateTypeHelperData(RuntimeTypeHandle type, Func`1<object> helperDataFactory);
    internal virtual void Resurrect();
}
public class WinRT.MarshalBlittable`1 : ValueType {
    public static MarshalerArray<T> CreateMarshalerArray(Array array);
    public static ValueTuple`2<int, IntPtr> GetAbiArray(object box);
    public static T[] FromAbiArray(object box);
    public static ValueTuple`2<int, IntPtr> FromManagedArray(Array array);
    public static void CopyManagedArray(Array array, IntPtr data);
    public static void DisposeMarshalerArray(object box);
    public static void DisposeAbiArray(object box);
}
public static class WinRT.MarshalDelegate : object {
    public static IObjectReference CreateMarshaler(object o, Guid delegateIID, bool unwrapObject);
    public static ObjectReferenceValue CreateMarshaler2(object o, Guid delegateIID, bool unwrapObject);
    public static T FromAbi(IntPtr nativeDelegate);
}
internal static class WinRT.Marshaler : object {
    internal static Action`1<object> EmptyFunc;
    internal static Func`2<object, object> ReturnParameterFunc;
    internal static Action`2<object, IntPtr> CopyIntEnumFunc;
    internal static Action`2<object, IntPtr> CopyUIntEnumFunc;
    internal static Action`2<object, Lazy`1<Action`1<object>>> DisposeMarshaler;
    internal static Func`3<object, Lazy`1<Func`2<object, object>>, object> GetAbi;
    private static Marshaler();
}
public class WinRT.Marshaler`1 : object {
    public static Type AbiType;
    public static Type RefAbiType;
    public static Func`2<T, object> CreateMarshaler;
    internal static Func`2<T, object> CreateMarshaler2;
    public static Func`2<object, object> GetAbi;
    public static Action`2<object, IntPtr> CopyAbi;
    public static Func`2<object, T> FromAbi;
    public static Func`2<T, object> FromManaged;
    public static Action`2<T, IntPtr> CopyManaged;
    public static Action`1<object> DisposeMarshaler;
    public static Action`1<object> DisposeAbi;
    public static Func`2<T[], object> CreateMarshalerArray;
    public static Func`2<object, ValueTuple`2<int, IntPtr>> GetAbiArray;
    public static Func`2<object, T[]> FromAbiArray;
    public static Func`2<T[], ValueTuple`2<int, IntPtr>> FromManagedArray;
    public static Action`2<T[], IntPtr> CopyManagedArray;
    public static Action`1<object> DisposeMarshalerArray;
    public static Action`1<object> DisposeAbiArray;
    private static Marshaler`1();
}
[ExtensionAttribute]
internal static class WinRT.MarshalExtensions : object {
    [ExtensionAttribute]
public static void Dispose(GCHandle handle);
}
public class WinRT.MarshalGeneric`1 : object {
    protected static Type HelperType;
    protected static Type AbiType;
    protected static Type MarshalerType;
    private static bool MarshalByObjectReferenceValueSupported;
    public static Func`2<T, object> CreateMarshaler;
    private static Lazy`1<Func`2<T, object>> CreateMarshalerLazy;
    private static Lazy`1<Func`2<T, object>> CreateMarshaler2Lazy;
    public static Func`2<object, object> GetAbi;
    private static Lazy`1<Func`2<object, object>> GetAbiLazy;
    public static Action`2<object, IntPtr> CopyAbi;
    private static Lazy`1<Action`2<object, IntPtr>> CopyAbiLazy;
    public static Func`2<object, T> FromAbi;
    private static Lazy`1<Func`2<object, T>> FromAbiLazy;
    public static Func`2<T, object> FromManaged;
    private static Lazy`1<Func`2<T, object>> FromManagedLazy;
    public static Action`2<T, IntPtr> CopyManaged;
    private static Lazy`1<Action`2<T, IntPtr>> CopyManagedLazy;
    public static Action`1<object> DisposeMarshaler;
    private static Lazy`1<Action`1<object>> DisposeMarshalerLazy;
    internal static Action`1<object> DisposeAbi;
    private static Lazy`1<Action`1<object>> DisposeAbiLazy;
    internal static Func`2<T[], object> CreateMarshalerArray;
    private static Lazy`1<Func`2<T[], object>> CreateMarshalerArrayLazy;
    internal static Func`2<object, ValueTuple`2<int, IntPtr>> GetAbiArray;
    private static Lazy`1<Func`2<object, ValueTuple`2<int, IntPtr>>> GetAbiArrayLazy;
    internal static Func`2<object, T[]> FromAbiArray;
    private static Lazy`1<Func`2<object, T[]>> FromAbiArrayLazy;
    internal static Func`2<T[], ValueTuple`2<int, IntPtr>> FromManagedArray;
    private static Lazy`1<Func`2<T[], ValueTuple`2<int, IntPtr>>> FromManagedArrayLazy;
    internal static Action`1<object> DisposeMarshalerArray;
    private static Lazy`1<Action`1<object>> DisposeMarshalerArrayLazy;
    internal static Action`1<object> DisposeAbiArray;
    private static Lazy`1<Action`1<object>> DisposeAbiArrayLazy;
    internal static Func`2<T, object> CreateMarshaler2 { get; }
    private static MarshalGeneric`1();
    private static Func`2<T, object> BindCreateMarshaler();
    internal static Func`2<T, object> get_CreateMarshaler2();
    private static Func`2<T, object> BindCreateMarshaler2();
    private static Func`2<object, object> BindGetAbi();
    private static Action`2<object, IntPtr> BindCopyAbi();
    private static Func`2<object, T> BindFromAbi();
    private static Func`2<T, object> BindFromManaged();
    private static Action`2<T, IntPtr> BindCopyManaged();
    private static Action`1<object> BindDisposeMarshaler();
    private static Action`1<object> BindDisposeAbi();
    private static Func`2<T[], object> BindCreateMarshalerArray();
    private static Func`2<object, ValueTuple`2<int, IntPtr>> BindGetAbiArray();
    private static Func`2<object, T[]> BindFromAbiArray();
    private static Func`2<T[], ValueTuple`2<int, IntPtr>> BindFromManagedArray();
    private static Action`1<object> BindDisposeMarshalerArray();
    private static Action`1<object> BindDisposeAbiArray();
    private static void CopyManagedFallback(T value, IntPtr dest);
    internal static void CopyManagedArray(T[] array, IntPtr data);
}
public static class WinRT.MarshalInspectable`1 : object {
    public static IObjectReference CreateMarshaler(T o, Guid iid, bool unwrapObject);
    public static IObjectReference CreateMarshaler(T o, bool unwrapObject);
    public static ObjectReferenceValue CreateMarshaler2(T o, Guid iid, bool unwrapObject);
    public static ObjectReferenceValue CreateMarshaler2(T o, bool unwrapObject);
    public static IntPtr GetAbi(IObjectReference objRef);
    public static IntPtr GetAbi(ObjectReferenceValue value);
    public static T FromAbi(IntPtr ptr);
    public static void DisposeMarshaler(IObjectReference objRef);
    public static void DisposeMarshaler(ObjectReferenceValue value);
    internal static void DisposeMarshaler(object value);
    public static void DisposeAbi(IntPtr ptr);
    public static IntPtr FromManaged(T o, bool unwrapObject);
    public static void CopyManaged(T o, IntPtr dest, bool unwrapObject);
    public static MarshalerArray<T> CreateMarshalerArray(T[] array);
    public static ValueTuple`2<int, IntPtr> GetAbiArray(T box);
    internal static ValueTuple`2<int, IntPtr> GetAbiArray(object box);
    public static T[] FromAbiArray(T box);
    internal static T[] FromAbiArray(object box);
    public static ValueTuple`2<int, IntPtr> FromManagedArray(T[] array);
    public static void CopyManagedArray(T[] array, IntPtr data);
    public static void DisposeMarshalerArray(T box);
    public static void DisposeAbiArray(T box);
    internal static void DisposeMarshalerArray(object box);
    internal static void DisposeAbiArray(object box);
}
public class WinRT.MarshalInterface`1 : ValueType {
    private static Type HelperType;
    private static Func`2<T, IObjectReference> _ToAbi;
    private static Func`2<T, IObjectReference> _CreateMarshaler;
    private static MarshalInterface`1();
    public static T FromAbi(IntPtr ptr);
    public static IObjectReference CreateMarshaler(T value);
    public static ObjectReferenceValue CreateMarshaler2(T value, Guid iid);
    public static IntPtr GetAbi(IObjectReference value);
    public static IntPtr GetAbi(ObjectReferenceValue value);
    public static void DisposeAbi(IntPtr thisPtr);
    public static void DisposeMarshaler(IObjectReference value);
    public static void DisposeMarshaler(ObjectReferenceValue value);
    internal static void DisposeMarshaler(object value);
    public static IntPtr FromManaged(T value);
    public static void CopyManaged(T value, IntPtr dest);
    public static MarshalerArray<T> CreateMarshalerArray(T[] array);
    public static ValueTuple`2<int, IntPtr> GetAbiArray(object box);
    public static T[] FromAbiArray(object box);
    public static void CopyAbiArray(T[] array, object box);
    public static ValueTuple`2<int, IntPtr> FromManagedArray(T[] array);
    public static void CopyManagedArray(T[] array, IntPtr data);
    public static void DisposeMarshalerArray(object box);
    public static void DisposeAbiArray(object box);
    private static Func`2<T, IObjectReference> BindToAbi();
    private static Func`2<T, IObjectReference> BindCreateMarshaler();
}
public class WinRT.MarshalInterfaceHelper`1 : object {
    private static MarshalerArray<T> CreateMarshalerArray(T[] array, Func`2<T, IObjectReference> createMarshaler, Func`2<T, ObjectReferenceValue> createMarshaler2);
    public static MarshalerArray<T> CreateMarshalerArray(T[] array, Func`2<T, IObjectReference> createMarshaler);
    public static MarshalerArray<T> CreateMarshalerArray2(T[] array, Func`2<T, ObjectReferenceValue> createMarshaler);
    public static ValueTuple`2<int, IntPtr> GetAbiArray(object box);
    public static T[] FromAbiArray(object box, Func`2<IntPtr, T> fromAbi);
    public static void CopyAbiArray(T[] array, object box, Func`2<IntPtr, T> fromAbi);
    public static ValueTuple`2<int, IntPtr> FromManagedArray(T[] array, Func`2<T, IntPtr> fromManaged);
    public static void CopyManagedArray(T[] array, IntPtr data, Action`2<T, IntPtr> copyManaged);
    public static void DisposeMarshalerArray(object box);
    public static void DisposeAbiArrayElements(ValueTuple`2<int, IntPtr> abi);
    public static void DisposeAbiArray(object box);
    public static IntPtr GetAbi(IObjectReference objRef);
    public static IntPtr GetAbi(ObjectReferenceValue value);
    public static void DisposeMarshaler(IObjectReference objRef);
    public static void DisposeMarshaler(ObjectReferenceValue value);
    public static void DisposeAbi(IntPtr ptr);
}
public class WinRT.MarshalNonBlittable`1 : MarshalGeneric`1<T> {
    private static Type AbiType;
    private static MarshalNonBlittable`1();
    public static MarshalerArray<T> CreateMarshalerArray(T[] array);
    public static ValueTuple`2<int, IntPtr> GetAbiArray(object box);
    public static T[] FromAbiArray(object box);
    public static void CopyAbiArray(T[] array, object box);
    public static ValueTuple`2<int, IntPtr> FromManagedArray(T[] array);
    public static void CopyManagedArray(T[] array, IntPtr data);
    public static void DisposeMarshalerArray(object box);
    public static void DisposeAbiArrayElements(ValueTuple`2<int, IntPtr> abi);
    public static void DisposeAbiArray(object box);
}
public class WinRT.MarshalString : object {
    private IntPtr _header;
    private GCHandle _gchandle;
    public MarshalString(string value);
    public static Pinnable CreatePinnable(string value);
    public static IntPtr GetAbi(Pinnable& p);
    public void Dispose();
    public static MarshalString CreateMarshaler(string value);
    public IntPtr GetAbi();
    public static IntPtr GetAbi(MarshalString m);
    public static IntPtr GetAbi(object box);
    public static void DisposeMarshaler(MarshalString m);
    public static void DisposeMarshaler(object box);
    public static void DisposeAbi(IntPtr hstring);
    public static void DisposeAbi(object abi);
    public static string FromAbi(IntPtr value);
    public static IntPtr FromManaged(string value);
    public static MarshalerArray CreateMarshalerArray(String[] array);
    public static ValueTuple`2<int, IntPtr> GetAbiArray(object box);
    public static String[] FromAbiArray(object box);
    public static void CopyAbiArray(String[] array, object box);
    public static ValueTuple`2<int, IntPtr> FromManagedArray(String[] array);
    public static void CopyManagedArray(String[] array, IntPtr data);
    public static void DisposeMarshalerArray(object box);
    public static void DisposeAbiArrayElements(ValueTuple`2<int, IntPtr> abi);
    public static void DisposeAbiArray(object box);
}
internal static class WinRT.Mono : object {
    private static Lazy`1<bool> _usingMono;
    private static Mono();
    private static IntPtr mono_thread_current();
    private static bool mono_thread_is_foreign(IntPtr threadPtr);
    private static void mono_unity_thread_fast_attach(IntPtr domainPtr);
    private static void mono_unity_thread_fast_detach();
    private static void mono_thread_pop_appdomain_ref();
    private static IntPtr mono_domain_get();
}
public class WinRT.ObjectReference`1 : IObjectReference {
    private T _vftbl;
    public T Vftbl { get; }
    private ObjectReference`1(IntPtr thisPtr, T vftblT);
    private protected ObjectReference`1(IntPtr thisPtr);
    public T get_Vftbl();
    public static ObjectReference`1<T> Attach(IntPtr& thisPtr);
    public static ObjectReference`1<T> FromAbi(IntPtr thisPtr, T vftblT);
    public static ObjectReference`1<T> FromAbi(IntPtr thisPtr);
    private static T GetVtable(IntPtr thisPtr);
    private protected virtual T GetVftblForCurrentContext();
}
[IsReadOnlyAttribute]
public class WinRT.ObjectReferenceValue : ValueType {
    internal IntPtr ptr;
    internal IntPtr referenceTracker;
    internal bool preventReleaseOnDispose;
    internal IObjectReference objRef;
    internal ObjectReferenceValue(IntPtr ptr);
    internal ObjectReferenceValue(IntPtr ptr, IntPtr referenceTracker, bool preventReleaseOnDispose, IObjectReference objRef);
    public static ObjectReferenceValue Attach(IntPtr& thisPtr);
    public IntPtr GetAbi();
    public IntPtr Detach();
    public void Dispose();
}
internal class WinRT.ObjectReferenceWithContext`1 : ObjectReference`1<T> {
    private IntPtr _contextCallbackPtr;
    private IntPtr _contextToken;
    private ConcurrentDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) __cachedContext;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _isAgileReferenceSet;
    private AgileReference modreq(System.Runtime.CompilerServices.IsVolatile) __agileReference;
    private Guid _iid;
    private ConcurrentDictionary`2<IntPtr, ObjectReference`1<T>> CachedContext { get; }
    private AgileReference AgileReference { get; }
    internal ObjectReferenceWithContext`1(IntPtr thisPtr, IntPtr contextCallbackPtr, IntPtr contextToken);
    internal ObjectReferenceWithContext`1(IntPtr thisPtr, IntPtr contextCallbackPtr, IntPtr contextToken, Guid iid);
    private ConcurrentDictionary`2<IntPtr, ObjectReference`1<T>> get_CachedContext();
    private ConcurrentDictionary`2<IntPtr, ObjectReference`1<T>> Make_CachedContext();
    private AgileReference get_AgileReference();
    private AgileReference Make_AgileReference();
    private protected virtual IntPtr GetThisPtrForCurrentContext();
    private protected virtual T GetVftblForCurrentContext();
    private ObjectReference`1<T> GetCurrentContext();
    protected virtual void Release();
    public virtual ObjectReference`1<IUnknownVftbl> AsKnownPtr(IntPtr ptr);
    public virtual int TryAs(Guid iid, ObjectReference`1& objRef);
    [CompilerGeneratedAttribute]
private void <Make_AgileReference>g__InitAgileReference|10_0();
    [CompilerGeneratedAttribute]
private ObjectReference`1<T> <GetCurrentContext>g__CreateForCurrentContext|16_0(IntPtr _);
}
[EditorBrowsableAttribute("1")]
[AttributeUsageAttribute("4")]
public class WinRT.ObjectReferenceWrapperAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ObjectReferenceField>k__BackingField;
    public string ObjectReferenceField { get; }
    public ObjectReferenceWrapperAttribute(string objectReferenceField);
    [CompilerGeneratedAttribute]
public string get_ObjectReferenceField();
}
internal class WinRT.Platform : object {
    internal static int CoCreateInstance(Guid& clsid, IntPtr outer, UInt32 clsContext, Guid& iid, IntPtr* instance);
    internal static int CoDecrementMTAUsage(IntPtr cookie);
    internal static int CoIncrementMTAUsage(IntPtr* cookie);
    internal static bool FreeLibrary(IntPtr moduleHandle);
    internal static Void* TryGetProcAddress(IntPtr moduleHandle, string functionName);
    internal static Void* GetProcAddress(IntPtr moduleHandle, string functionName);
    internal static IntPtr LoadLibraryExW(string fileName, IntPtr fileHandle, UInt32 flags);
    internal static int RoGetActivationFactory(IntPtr runtimeClassId, Guid& iid, IntPtr* factory);
    internal static int WindowsCreateString(string sourceString, int length, IntPtr* hstring);
    internal static int WindowsCreateStringReference(Char* sourceString, int length, IntPtr* hstring_header, IntPtr* hstring);
    internal static int WindowsDeleteString(IntPtr hstring);
    internal static int WindowsDuplicateString(IntPtr sourceString, IntPtr* hstring);
    internal static Char* WindowsGetStringRawBuffer(IntPtr hstring, UInt32* length);
    internal static int RoGetAgileReference(UInt32 options, Guid& iid, IntPtr unknown, IntPtr* agileReference);
}
[EditorBrowsableAttribute("1")]
[AttributeUsageAttribute("4")]
public class WinRT.ProjectedRuntimeClassAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <DefaultInterfaceProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DefaultInterface>k__BackingField;
    public string DefaultInterfaceProperty { get; }
    public Type DefaultInterface { get; }
    public ProjectedRuntimeClassAttribute(string defaultInterfaceProp);
    public ProjectedRuntimeClassAttribute(Type defaultInterface);
    [CompilerGeneratedAttribute]
public string get_DefaultInterfaceProperty();
    [CompilerGeneratedAttribute]
public Type get_DefaultInterface();
}
internal static class WinRT.ProjectionInitializer : object {
    [ModuleInitializerAttribute]
internal static void InitalizeProjection();
}
public static class WinRT.Projections : object {
    private static ReaderWriterLockSlim rwlock;
    private static Dictionary`2<Type, Type> CustomTypeToHelperTypeMappings;
    private static Dictionary`2<Type, Type> CustomAbiTypeToTypeMappings;
    private static Dictionary`2<string, Type> CustomAbiTypeNameToTypeMappings;
    private static Dictionary`2<Type, string> CustomTypeToAbiTypeNameMappings;
    private static HashSet`1<string> ProjectedRuntimeClassNames;
    private static HashSet`1<Type> ProjectedCustomTypeRuntimeClasses;
    private static ConcurrentDictionary`2<Type, bool> IsTypeWindowsRuntimeTypeCache;
    private static ConcurrentDictionary`2<Type, Type> DefaultInterfaceTypeCache;
    private static Projections();
    public static void RegisterCustomAbiTypeMapping(Type publicType, Type abiType, string winrtTypeName, bool isRuntimeClass);
    private static void RegisterCustomAbiTypeMappingNoLock(Type publicType, Type abiType, string winrtTypeName, bool isRuntimeClass);
    public static Type FindCustomHelperTypeMapping(Type publicType, bool filterToRuntimeClass);
    public static Type FindCustomPublicTypeForAbiType(Type abiType);
    public static Type FindCustomTypeForAbiTypeName(string abiTypeName);
    public static string FindCustomAbiTypeNameForType(Type type);
    public static bool IsTypeWindowsRuntimeType(Type type);
    private static bool IsTypeWindowsRuntimeTypeNoArray(Type type);
    public static bool TryGetCompatibleWindowsRuntimeTypeForVariantType(Type type, Type& compatibleType);
    private static HashSet`1<Type> GetCompatibleTypes(Type type);
    internal static IEnumerable`1<Type> GetAllPossibleTypeCombinations(IEnumerable`1<IEnumerable`1<Type>> compatibleTypesPerGeneric, Type definition);
    internal static bool TryGetCompatibleWindowsRuntimeTypesForVariantType(Type type, IEnumerable`1& compatibleTypes);
    internal static bool TryGetDefaultInterfaceTypeForRuntimeClassType(Type runtimeClass, Type& defaultInterface);
    internal static Type GetDefaultInterfaceTypeForRuntimeClassType(Type runtimeClass);
    internal static bool TryGetMarshalerTypeForProjectedRuntimeClass(IObjectReference objectReference, Type& type);
    [CompilerGeneratedAttribute]
internal static void <GetAllPossibleTypeCombinations>g__GetAllPossibleTypeCombinationsCore|19_0(List`1<Type> accum, Stack`1<Type> stack, IEnumerable`1[] compatibleTypes, int index, <>c__DisplayClass19_0& );
}
public class WinRT.SingleInterfaceOptimizedObject : object {
    private Type _type;
    private IObjectReference _obj;
    private ConcurrentDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) _queryInterfaceCache;
    private ConcurrentDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) _additionalTypeData;
    private IObjectReference WinRT.IWinRTObject.NativeObject { get; }
    private bool WinRT.IWinRTObject.HasUnwrappableNativeObject { get; }
    private ConcurrentDictionary`2<RuntimeTypeHandle, IObjectReference> WinRT.IWinRTObject.QueryInterfaceCache { get; }
    private ConcurrentDictionary`2<RuntimeTypeHandle, object> WinRT.IWinRTObject.AdditionalTypeData { get; }
    public SingleInterfaceOptimizedObject(Type type, IObjectReference objRef);
    internal SingleInterfaceOptimizedObject(Type type, IObjectReference objRef, bool requireQI);
    private sealed virtual override IObjectReference WinRT.IWinRTObject.get_NativeObject();
    private sealed virtual override bool WinRT.IWinRTObject.get_HasUnwrappableNativeObject();
    private ConcurrentDictionary`2<RuntimeTypeHandle, IObjectReference> MakeQueryInterfaceCache();
    private sealed virtual override ConcurrentDictionary`2<RuntimeTypeHandle, IObjectReference> WinRT.IWinRTObject.get_QueryInterfaceCache();
    private ConcurrentDictionary`2<RuntimeTypeHandle, object> MakeAdditionalTypeData();
    private sealed virtual override ConcurrentDictionary`2<RuntimeTypeHandle, object> WinRT.IWinRTObject.get_AdditionalTypeData();
    private sealed virtual override bool System.Runtime.InteropServices.IDynamicInterfaceCastable.IsInterfaceImplemented(RuntimeTypeHandle interfaceType, bool throwIfNotImplemented);
    private sealed virtual override IObjectReference WinRT.IWinRTObject.GetObjectReferenceForType(RuntimeTypeHandle interfaceType);
}
internal abstract class WinRT.State : object {
    public EventRegistrationToken token;
    public Delegate del;
    public Delegate eventInvoke;
    private bool disposedValue;
    private IntPtr obj;
    private int index;
    private WeakReference`1<State> cacheEntry;
    private IntPtr eventInvokePtr;
    private IntPtr referenceTrackerTargetPtr;
    protected State(IntPtr obj, int index);
    protected virtual override void Finalize();
    public WeakReference`1<State> GetWeakReferenceForCache();
    protected abstract virtual Delegate GetEventInvoke();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    public void InitalizeReferenceTracking(IntPtr ptr);
    public bool HasComReferences();
}
public enum WinRT.TrustLevel : Enum {
    public int value__;
    public static TrustLevel BaseTrust;
    public static TrustLevel PartialTrust;
    public static TrustLevel FullTrust;
}
[ExtensionAttribute]
public static class WinRT.TypeExtensions : object {
    private static ConcurrentDictionary`2<Type, Type> HelperTypeCache;
    private static ConcurrentDictionary`2<Type, Type> AuthoringMetadataTypeCache;
    private static TypeExtensions();
    [ExtensionAttribute]
public static Type FindHelperType(Type type);
    [ExtensionAttribute]
public static Type GetHelperType(Type type);
    [ExtensionAttribute]
public static Type GetGuidType(Type type);
    [ExtensionAttribute]
public static Type FindVftblType(Type helperType);
    [ExtensionAttribute]
internal static IntPtr GetAbiToProjectionVftblPtr(Type helperType);
    [ExtensionAttribute]
public static Type GetAbiType(Type type);
    [ExtensionAttribute]
public static Type GetMarshalerType(Type type);
    [ExtensionAttribute]
internal static Type GetMarshaler2Type(Type type);
    [ExtensionAttribute]
internal static Type GetMarshalerArrayType(Type type);
    [ExtensionAttribute]
public static bool IsDelegate(Type type);
    [ExtensionAttribute]
internal static bool IsTypeOfType(Type type);
    [ExtensionAttribute]
public static Type GetRuntimeClassCCWType(Type type);
    [ExtensionAttribute]
internal static Type GetAuthoringMetadataType(Type type);
}
[FlagsAttribute]
internal enum WinRT.TypeNameGenerationFlags : Enum {
    public int value__;
    public static TypeNameGenerationFlags None;
    public static TypeNameGenerationFlags GenerateBoxedName;
    public static TypeNameGenerationFlags NoCustomTypeName;
}
internal static class WinRT.TypeNameSupport : object {
    private static List`1<Assembly> projectionAssemblies;
    private static ConcurrentDictionary`2<string, Type> typeNameCache;
    private static ThreadLocal`1<Stack`1<VisitedType>> VisitedTypes;
    private static TypeNameSupport();
    public static void RegisterProjectionAssembly(Assembly assembly);
    public static Type FindTypeByNameCached(string runtimeClassName);
    public static ValueTuple`2<Type, int> FindTypeByName(ReadOnlySpan`1<char> runtimeClassName);
    private static Type FindTypeByNameCore(string runtimeClassName, Type[] genericTypes);
    public static Type ResolvePrimitiveType(string primitiveTypeName);
    private static ValueTuple`3<string, Type[], int> ParseGenericTypeName(ReadOnlySpan`1<char> partialTypeName);
    public static string GetNameForType(Type type, TypeNameGenerationFlags flags);
    private static bool TryAppendSimpleTypeName(Type type, StringBuilder builder, TypeNameGenerationFlags flags);
    private static bool TryAppendWinRTInterfaceNameForType(Type type, StringBuilder builder, TypeNameGenerationFlags flags);
    private static bool TryAppendTypeName(Type type, StringBuilder builder, TypeNameGenerationFlags flags);
}
internal class WinRT.VftblPtr : ValueType {
    public IntPtr Vftbl;
}
[EditorBrowsableAttribute("1")]
[AttributeUsageAttribute("5148")]
public class WinRT.WindowsRuntimeTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <SourceMetadata>k__BackingField;
    public string SourceMetadata { get; }
    public WindowsRuntimeTypeAttribute(string sourceMetadata);
    [CompilerGeneratedAttribute]
public string get_SourceMetadata();
}
internal class WinRT.WinrtModule : object {
    private IntPtr _mtaCookie;
    private static WinrtModule modreq(System.Runtime.CompilerServices.IsVolatile) _instance;
    public static WinrtModule Instance { get; }
    private static WinrtModule MakeWinRTModule();
    public static WinrtModule get_Instance();
    public static ValueTuple`2<IntPtr, int> GetActivationFactory(IntPtr hstrRuntimeClassId);
    public static ValueTuple`2<ObjectReference`1<IActivationFactoryVftbl>, int> GetActivationFactory(string runtimeClassId);
    protected virtual override void Finalize();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "16.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class WinRT.WinRTRuntimeErrorStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string Arg_IndexOutOfRangeException { get; }
    internal static string Arg_KeyNotFound { get; }
    internal static string Arg_KeyNotFoundWithKey { get; }
    internal static string Arg_RankMultiDimNotSupported { get; }
    internal static string Argument_AddingDuplicate { get; }
    internal static string Argument_AddingDuplicateWithKey { get; }
    internal static string Argument_IndexOutOfArrayBounds { get; }
    internal static string Argument_InsufficientSpaceToCopyCollection { get; }
    internal static string ArgumentOutOfRange_Index { get; }
    internal static string ArgumentOutOfRange_IndexLargerThanMaxValue { get; }
    internal static string InvalidOperation_CannotRemoveLastFromEmptyCollection { get; }
    internal static string InvalidOperation_CollectionBackingDictionaryTooLarge { get; }
    internal static string InvalidOperation_CollectionBackingListTooLarge { get; }
    internal static string InvalidOperation_EnumEnded { get; }
    internal static string InvalidOperation_EnumFailedVersion { get; }
    internal static string InvalidOperation_EnumNotStarted { get; }
    internal static string NotSupported_KeyCollectionSet { get; }
    internal static string NotSupported_ValueCollectionSet { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_Arg_IndexOutOfRangeException();
    internal static string get_Arg_KeyNotFound();
    internal static string get_Arg_KeyNotFoundWithKey();
    internal static string get_Arg_RankMultiDimNotSupported();
    internal static string get_Argument_AddingDuplicate();
    internal static string get_Argument_AddingDuplicateWithKey();
    internal static string get_Argument_IndexOutOfArrayBounds();
    internal static string get_Argument_InsufficientSpaceToCopyCollection();
    internal static string get_ArgumentOutOfRange_Index();
    internal static string get_ArgumentOutOfRange_IndexLargerThanMaxValue();
    internal static string get_InvalidOperation_CannotRemoveLastFromEmptyCollection();
    internal static string get_InvalidOperation_CollectionBackingDictionaryTooLarge();
    internal static string get_InvalidOperation_CollectionBackingListTooLarge();
    internal static string get_InvalidOperation_EnumEnded();
    internal static string get_InvalidOperation_EnumFailedVersion();
    internal static string get_InvalidOperation_EnumNotStarted();
    internal static string get_NotSupported_KeyCollectionSet();
    internal static string get_NotSupported_ValueCollectionSet();
}
