internal static class FxResources.PresentationCore.SR : object {
}
internal static class ModuleInitializer : object {
    public static void Initialize();
}
internal class MS.Internal.AbbreviatedGeometryParser : object {
    private static bool AllowSign;
    private static bool AllowComma;
    private static bool IsFilled;
    private static bool IsClosed;
    private static bool IsStroked;
    private static bool IsSmoothJoin;
    private IFormatProvider _formatProvider;
    private string _pathString;
    private int _pathLength;
    private int _curIndex;
    private bool _figureStarted;
    private Point _lastStart;
    private Point _lastPoint;
    private Point _secondLastPoint;
    private char _token;
    private StreamGeometryContext _context;
    private void ThrowBadToken();
    private bool More();
    private bool SkipWhiteSpace(bool allowComma);
    private bool ReadToken();
    private bool IsNumber(bool allowComma);
    private void SkipDigits(bool signAllowed);
    private double ReadNumber(bool allowComma);
    private bool ReadBool();
    private Point ReadPoint(char cmd, bool allowcomma);
    private Point Reflect();
    private void EnsureFigure();
    internal void ParseToGeometryContext(StreamGeometryContext context, string pathString, int startIndex);
}
internal static class MS.Internal.AppDomainShutdownMonitor : object {
    private static Dictionary`2<WeakReference, WeakReference> _dictionary;
    private static bool _shuttingDown;
    private static AppDomainShutdownMonitor();
    public static void Add(WeakReference listener);
    public static void Remove(WeakReference listener);
    private static void OnShutdown(object sender, EventArgs e);
}
internal static class MS.Internal.AppModel.CookieHandler : object {
    internal static void HandleWebRequest(WebRequest request);
    internal static void HandleWebResponse(WebResponse response);
    [FriendAccessAllowedAttribute]
internal static string GetCookie(Uri uri, bool throwIfNoCookie);
    [FriendAccessAllowedAttribute]
internal static bool SetCookie(Uri uri, string cookieData);
    private static bool SetCookieUnsafe(Uri uri, string cookieData, string p3pHeader);
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.AppModel.CustomCredentialPolicy : object {
    private static IInternetSecurityManager _securityManager;
    private static object _lockObj;
    private static bool _initialized;
    private static CustomCredentialPolicy();
    internal static void EnsureCustomCredentialPolicy();
    public sealed virtual bool ShouldSendCredential(Uri challengeUri, WebRequest request, NetworkCredential credential, IAuthenticationModule authenticationModule);
    private bool IsDefaultCredentials(NetworkCredential credential);
    internal static int MapUrlToZone(Uri uri);
    private static void EnsureSecurityManager();
}
internal class MS.Internal.AppModel.SiteOfOriginContainer : Package {
    internal static BooleanSwitch _traceSwitch;
    private static SecurityCriticalDataForSet`1<Uri> _browserSource;
    private static Nullable`1<SecurityCriticalDataForSet`1<Uri>> _siteOfOriginForClickOnceApp;
    internal static Uri SiteOfOrigin { get; }
    internal static Uri SiteOfOriginForClickOnceApp { get; }
    internal static Uri BrowserSource { get; internal set; }
    internal static bool TraceSwitchEnabled { get; internal set; }
    private static SiteOfOriginContainer();
    [FriendAccessAllowedAttribute]
internal static Uri get_SiteOfOrigin();
    internal static Uri get_SiteOfOriginForClickOnceApp();
    internal static Uri get_BrowserSource();
    internal static void set_BrowserSource(Uri value);
    public virtual bool PartExists(Uri uri);
    internal static bool get_TraceSwitchEnabled();
    internal static void set_TraceSwitchEnabled(bool value);
    protected virtual PackagePart GetPartCore(Uri uri);
    protected virtual PackagePart CreatePartCore(Uri uri, string contentType, CompressionOption compressionOption);
    protected virtual void DeletePartCore(Uri uri);
    protected virtual PackagePart[] GetPartsCore();
    protected virtual void FlushCore();
}
internal class MS.Internal.AppModel.SiteOfOriginPart : PackagePart {
    private Uri _absoluteLocation;
    private ContentType _contentType;
    private Stream _cacheStream;
    private object _globalLock;
    internal SiteOfOriginPart(Package container, Uri uri);
    protected virtual Stream GetStreamCore(FileMode mode, FileAccess access);
    protected virtual string GetContentTypeCore();
    private Stream GetStreamAndSetContentType(bool onlyNeedContentType);
    private Stream HandleFileSource(bool onlyNeedContentType);
    private Stream HandleWebSource(bool onlyNeedContentType);
}
internal class MS.Internal.Automation.AutomationPatternInfo : object {
    private AutomationPattern _id;
    private WrapObject _wcpWrapper;
    internal AutomationPattern ID { get; }
    internal WrapObject WcpWrapper { get; }
    internal AutomationPatternInfo(AutomationPattern id, WrapObject wcpWrapper);
    internal AutomationPattern get_ID();
    internal WrapObject get_WcpWrapper();
}
internal class MS.Internal.Automation.AutomationPropertyInfo : object {
    private AutomationProperty _id;
    private DependencyProperty _dependencyProperty;
    private DependencyProperty _overrideDP;
    internal AutomationProperty ID { get; }
    internal DependencyProperty DependencyProperty { get; }
    internal DependencyProperty OverrideDP { get; }
    internal AutomationPropertyInfo(AutomationProperty id, DependencyProperty dependencyProperty, DependencyProperty overrideDP);
    internal AutomationProperty get_ID();
    internal DependencyProperty get_DependencyProperty();
    internal DependencyProperty get_OverrideDP();
}
internal class MS.Internal.Automation.DockProviderWrapper : MarshalByRefObject {
    private AutomationPeer _peer;
    private IDockProvider _iface;
    public DockPosition DockPosition { get; }
    private DockProviderWrapper(AutomationPeer peer, IDockProvider iface);
    public sealed virtual void SetDockPosition(DockPosition dockPosition);
    public sealed virtual DockPosition get_DockPosition();
    internal static object Wrap(AutomationPeer peer, object iface);
    private object SetDockPosition(object arg);
    private object GetDockPosition(object unused);
}
internal class MS.Internal.Automation.ElementProxy : object {
    private static ReferenceType _automationInteropReferenceType;
    private static bool _shouldCheckInTheRegistry;
    private object _peer;
    public ProviderOptions ProviderOptions { get; }
    public IRawElementProviderSimple HostRawElementProvider { get; }
    public Rect BoundingRectangle { get; }
    public IRawElementProviderFragmentRoot FragmentRoot { get; }
    internal AutomationPeer Peer { get; }
    internal static ReferenceType AutomationInteropReferenceType { get; }
    private ElementProxy(AutomationPeer peer);
    private static ElementProxy();
    public sealed virtual object GetPatternProvider(int pattern);
    public sealed virtual object GetPropertyValue(int property);
    public sealed virtual ProviderOptions get_ProviderOptions();
    public sealed virtual IRawElementProviderSimple get_HostRawElementProvider();
    private IRawElementProviderSimple GetHostHelper(HostedWindowWrapper hwndWrapper);
    public sealed virtual IRawElementProviderFragment Navigate(NavigateDirection direction);
    public sealed virtual Int32[] GetRuntimeId();
    public sealed virtual Rect get_BoundingRectangle();
    public sealed virtual IRawElementProviderSimple[] GetEmbeddedFragmentRoots();
    public sealed virtual void SetFocus();
    public sealed virtual IRawElementProviderFragmentRoot get_FragmentRoot();
    public sealed virtual IRawElementProviderFragment ElementProviderFromPoint(double x, double y);
    public sealed virtual IRawElementProviderFragment GetFocus();
    public sealed virtual void AdviseEventAdded(int eventID, Int32[] properties);
    public sealed virtual void AdviseEventRemoved(int eventID, Int32[] properties);
    internal static ElementProxy StaticWrap(AutomationPeer peer, AutomationPeer referencePeer);
    internal AutomationPeer get_Peer();
    private object InContextElementProviderFromPoint(object arg);
    private object InContextGetFocus(object unused);
    private object InContextGetPatternProvider(object arg);
    private object InContextNavigate(object arg);
    private object InContextGetProviderOptions(object arg);
    private object InContextGetPropertyValue(object arg);
    private object InContextGetHostRawElementProvider(object unused);
    private object InContextGetRuntimeId(object unused);
    private object InContextBoundingRectangle(object unused);
    private object InContextSetFocus(object unused);
    private object InContextFragmentRoot(object unused);
    internal static ReferenceType get_AutomationInteropReferenceType();
}
internal class MS.Internal.Automation.ElementUtil : object {
    internal static Visual GetParent(Visual el);
    internal static Visual GetFirstChild(Visual el);
    internal static Visual GetLastChild(Visual el);
    internal static Visual GetNextSibling(Visual el);
    internal static Visual GetPreviousSibling(Visual el);
    internal static Visual GetRoot(Visual el);
    internal static Rect GetLocalRect(UIElement element);
    internal static Rect GetScreenRect(IntPtr hwnd, UIElement el);
    internal static Visual GetElementFromPoint(IntPtr hwnd, Visual root, Point pointScreen);
    internal static void CheckEnabled(Visual visual);
    internal static object Invoke(AutomationPeer peer, DispatcherOperationCallback work, object arg);
    private static Visual FindVisibleSibling(Visual parent, int start, bool searchForwards);
    private static Visual FindVisibleSibling(Visual parent, Visual child, bool searchForwards);
}
internal static class MS.Internal.Automation.EventMap : object {
    private static Hashtable _eventsTable;
    private static object _lock;
    internal static bool HasListeners { get; }
    private static EventMap();
    private static bool IsKnownLegacyEvent(int id);
    private static bool IsKnownNewEvent(int id);
    private static bool IsKnownEvent(int id);
    private static AutomationEvent GetRegisteredEventObjectHelper(AutomationEvents eventId);
    internal static void AddEvent(int idEvent);
    internal static void RemoveEvent(int idEvent);
    internal static bool HasRegisteredEvent(AutomationEvents eventId);
    internal static AutomationEvent GetRegisteredEvent(AutomationEvents eventId);
    internal static bool get_HasListeners();
    private static void NotifySources();
    private static object NotifySource(object args);
}
internal class MS.Internal.Automation.EventPropertyMap : object {
    private static ReaderWriterLockWrapper _propertyLock;
    private static Hashtable _propertyTable;
    private static EventPropertyMap();
    internal static bool IsInterestingDP(DependencyProperty dp);
    internal static bool AddPropertyNotify(DependencyProperty[] properties);
    internal static bool RemovePropertyNotify(DependencyProperty[] properties);
}
internal class MS.Internal.Automation.ExpandCollapseProviderWrapper : MarshalByRefObject {
    private AutomationPeer _peer;
    private IExpandCollapseProvider _iface;
    public ExpandCollapseState ExpandCollapseState { get; }
    private ExpandCollapseProviderWrapper(AutomationPeer peer, IExpandCollapseProvider iface);
    public sealed virtual void Expand();
    public sealed virtual void Collapse();
    public sealed virtual ExpandCollapseState get_ExpandCollapseState();
    internal static object Wrap(AutomationPeer peer, object iface);
    private object Expand(object unused);
    private object Collapse(object unused);
    private object GetExpandCollapseState(object unused);
}
internal class MS.Internal.Automation.GridItemProviderWrapper : MarshalByRefObject {
    private AutomationPeer _peer;
    private IGridItemProvider _iface;
    public int Row { get; }
    public int Column { get; }
    public int RowSpan { get; }
    public int ColumnSpan { get; }
    public IRawElementProviderSimple ContainingGrid { get; }
    private GridItemProviderWrapper(AutomationPeer peer, IGridItemProvider iface);
    public sealed virtual int get_Row();
    public sealed virtual int get_Column();
    public sealed virtual int get_RowSpan();
    public sealed virtual int get_ColumnSpan();
    public sealed virtual IRawElementProviderSimple get_ContainingGrid();
    internal static object Wrap(AutomationPeer peer, object iface);
    private object GetRow(object unused);
    private object GetColumn(object unused);
    private object GetRowSpan(object unused);
    private object GetColumnSpan(object unused);
    private object GetContainingGrid(object unused);
}
internal class MS.Internal.Automation.GridProviderWrapper : MarshalByRefObject {
    private AutomationPeer _peer;
    private IGridProvider _iface;
    public int RowCount { get; }
    public int ColumnCount { get; }
    private GridProviderWrapper(AutomationPeer peer, IGridProvider iface);
    public sealed virtual IRawElementProviderSimple GetItem(int row, int column);
    public sealed virtual int get_RowCount();
    public sealed virtual int get_ColumnCount();
    internal static object Wrap(AutomationPeer peer, object iface);
    private object GetItem(object arg);
    private object GetRowCount(object unused);
    private object GetColumnCount(object unused);
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.Automation.InteropAutomationProvider : object {
    private HostedWindowWrapper _wrapper;
    private AutomationPeer _parent;
    private ProviderOptions System.Windows.Automation.Provider.IRawElementProviderSimple.ProviderOptions { get; }
    private IRawElementProviderSimple System.Windows.Automation.Provider.IRawElementProviderSimple.HostRawElementProvider { get; }
    private Rect System.Windows.Automation.Provider.IRawElementProviderFragment.BoundingRectangle { get; }
    private IRawElementProviderFragmentRoot System.Windows.Automation.Provider.IRawElementProviderFragment.FragmentRoot { get; }
    internal InteropAutomationProvider(HostedWindowWrapper wrapper, AutomationPeer parent);
    private sealed virtual override ProviderOptions System.Windows.Automation.Provider.IRawElementProviderSimple.get_ProviderOptions();
    private sealed virtual override object System.Windows.Automation.Provider.IRawElementProviderSimple.GetPatternProvider(int patternId);
    private sealed virtual override object System.Windows.Automation.Provider.IRawElementProviderSimple.GetPropertyValue(int propertyId);
    private sealed virtual override IRawElementProviderSimple System.Windows.Automation.Provider.IRawElementProviderSimple.get_HostRawElementProvider();
    private sealed virtual override IRawElementProviderFragment System.Windows.Automation.Provider.IRawElementProviderFragment.Navigate(NavigateDirection direction);
    private sealed virtual override Int32[] System.Windows.Automation.Provider.IRawElementProviderFragment.GetRuntimeId();
    private sealed virtual override Rect System.Windows.Automation.Provider.IRawElementProviderFragment.get_BoundingRectangle();
    private sealed virtual override IRawElementProviderSimple[] System.Windows.Automation.Provider.IRawElementProviderFragment.GetEmbeddedFragmentRoots();
    private sealed virtual override void System.Windows.Automation.Provider.IRawElementProviderFragment.SetFocus();
    private sealed virtual override IRawElementProviderFragmentRoot System.Windows.Automation.Provider.IRawElementProviderFragment.get_FragmentRoot();
    private sealed virtual override IRawElementProviderFragment System.Windows.Automation.Provider.IRawElementProviderFragmentRoot.ElementProviderFromPoint(double x, double y);
    private sealed virtual override IRawElementProviderFragment System.Windows.Automation.Provider.IRawElementProviderFragmentRoot.GetFocus();
}
internal class MS.Internal.Automation.InvokeProviderWrapper : MarshalByRefObject {
    private AutomationPeer _peer;
    private IInvokeProvider _iface;
    private InvokeProviderWrapper(AutomationPeer peer, IInvokeProvider iface);
    public sealed virtual void Invoke();
    internal static object Wrap(AutomationPeer peer, object iface);
    private object Invoke(object unused);
}
internal class MS.Internal.Automation.ItemContainerProviderWrapper : MarshalByRefObject {
    private AutomationPeer _peer;
    private IItemContainerProvider _iface;
    private ItemContainerProviderWrapper(AutomationPeer peer, IItemContainerProvider iface);
    public sealed virtual IRawElementProviderSimple FindItemByProperty(IRawElementProviderSimple startAfter, int propertyId, object value);
    internal static object Wrap(AutomationPeer peer, object iface);
    private object FindItemByProperty(object arg);
}
internal class MS.Internal.Automation.MultipleViewProviderWrapper : MarshalByRefObject {
    private AutomationPeer _peer;
    private IMultipleViewProvider _iface;
    public int CurrentView { get; }
    private MultipleViewProviderWrapper(AutomationPeer peer, IMultipleViewProvider iface);
    public sealed virtual string GetViewName(int viewID);
    public sealed virtual void SetCurrentView(int viewID);
    public sealed virtual int get_CurrentView();
    public sealed virtual Int32[] GetSupportedViews();
    internal static object Wrap(AutomationPeer peer, object iface);
    private object GetViewName(object arg);
    private object SetCurrentView(object arg);
    private object GetCurrentView(object unused);
    private object GetSupportedViews(object unused);
}
internal class MS.Internal.Automation.RangeValueProviderWrapper : MarshalByRefObject {
    private AutomationPeer _peer;
    private IRangeValueProvider _iface;
    public double Value { get; }
    public bool IsReadOnly { get; }
    public double Maximum { get; }
    public double Minimum { get; }
    public double LargeChange { get; }
    public double SmallChange { get; }
    private RangeValueProviderWrapper(AutomationPeer peer, IRangeValueProvider iface);
    public sealed virtual void SetValue(double val);
    public sealed virtual double get_Value();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual double get_Maximum();
    public sealed virtual double get_Minimum();
    public sealed virtual double get_LargeChange();
    public sealed virtual double get_SmallChange();
    internal static object Wrap(AutomationPeer peer, object iface);
    private object SetValueInternal(object arg);
    private object GetValue(object unused);
    private object GetIsReadOnly(object unused);
    private object GetMaximum(object unused);
    private object GetMinimum(object unused);
    private object GetLargeChange(object unused);
    private object GetSmallChange(object unused);
}
internal class MS.Internal.Automation.ScrollItemProviderWrapper : MarshalByRefObject {
    private AutomationPeer _peer;
    private IScrollItemProvider _iface;
    private ScrollItemProviderWrapper(AutomationPeer peer, IScrollItemProvider iface);
    public sealed virtual void ScrollIntoView();
    internal static object Wrap(AutomationPeer peer, object iface);
    private object ScrollIntoView(object unused);
}
internal class MS.Internal.Automation.ScrollProviderWrapper : MarshalByRefObject {
    private AutomationPeer _peer;
    private IScrollProvider _iface;
    public double HorizontalScrollPercent { get; }
    public double VerticalScrollPercent { get; }
    public double HorizontalViewSize { get; }
    public double VerticalViewSize { get; }
    public bool HorizontallyScrollable { get; }
    public bool VerticallyScrollable { get; }
    private ScrollProviderWrapper(AutomationPeer peer, IScrollProvider iface);
    public sealed virtual void Scroll(ScrollAmount horizontalAmount, ScrollAmount verticalAmount);
    public sealed virtual void SetScrollPercent(double horizontalPercent, double verticalPercent);
    public sealed virtual double get_HorizontalScrollPercent();
    public sealed virtual double get_VerticalScrollPercent();
    public sealed virtual double get_HorizontalViewSize();
    public sealed virtual double get_VerticalViewSize();
    public sealed virtual bool get_HorizontallyScrollable();
    public sealed virtual bool get_VerticallyScrollable();
    internal static object Wrap(AutomationPeer peer, object iface);
    private object Scroll(object arg);
    private object SetScrollPercent(object arg);
    private object GetHorizontalScrollPercent(object unused);
    private object GetVerticalScrollPercent(object unused);
    private object GetHorizontalViewSize(object unused);
    private object GetVerticalViewSize(object unused);
    private object GetHorizontallyScrollable(object unused);
    private object GetVerticallyScrollable(object unused);
}
internal class MS.Internal.Automation.SelectionItemProviderWrapper : MarshalByRefObject {
    private AutomationPeer _peer;
    private ISelectionItemProvider _iface;
    public bool IsSelected { get; }
    public IRawElementProviderSimple SelectionContainer { get; }
    private SelectionItemProviderWrapper(AutomationPeer peer, ISelectionItemProvider iface);
    public sealed virtual void Select();
    public sealed virtual void AddToSelection();
    public sealed virtual void RemoveFromSelection();
    public sealed virtual bool get_IsSelected();
    public sealed virtual IRawElementProviderSimple get_SelectionContainer();
    internal static object Wrap(AutomationPeer peer, object iface);
    private object Select(object unused);
    private object AddToSelection(object unused);
    private object RemoveFromSelection(object unused);
    private object GetIsSelected(object unused);
    private object GetSelectionContainer(object unused);
}
internal class MS.Internal.Automation.SelectionProviderWrapper : MarshalByRefObject {
    private AutomationPeer _peer;
    private ISelectionProvider _iface;
    public bool CanSelectMultiple { get; }
    public bool IsSelectionRequired { get; }
    private SelectionProviderWrapper(AutomationPeer peer, ISelectionProvider iface);
    public sealed virtual IRawElementProviderSimple[] GetSelection();
    public sealed virtual bool get_CanSelectMultiple();
    public sealed virtual bool get_IsSelectionRequired();
    internal static object Wrap(AutomationPeer peer, object iface);
    private object GetSelection(object unused);
    private object GetCanSelectMultiple(object unused);
    private object GetIsSelectionRequired(object unused);
}
internal class MS.Internal.Automation.SynchronizedInputAdaptor : object {
    private DependencyObject _owner;
    internal SynchronizedInputAdaptor(DependencyObject owner);
    private sealed virtual override void System.Windows.Automation.Provider.ISynchronizedInputProvider.StartListening(SynchronizedInputType inputType);
    private sealed virtual override void System.Windows.Automation.Provider.ISynchronizedInputProvider.Cancel();
}
internal class MS.Internal.Automation.SynchronizedInputProviderWrapper : MarshalByRefObject {
    private AutomationPeer _peer;
    private ISynchronizedInputProvider _iface;
    private SynchronizedInputProviderWrapper(AutomationPeer peer, ISynchronizedInputProvider iface);
    public sealed virtual void StartListening(SynchronizedInputType inputType);
    public sealed virtual void Cancel();
    internal static object Wrap(AutomationPeer peer, object iface);
    private object StartListening(object arg);
    private object Cancel(object unused);
}
internal class MS.Internal.Automation.TableItemProviderWrapper : MarshalByRefObject {
    private AutomationPeer _peer;
    private ITableItemProvider _iface;
    public int Row { get; }
    public int Column { get; }
    public int RowSpan { get; }
    public int ColumnSpan { get; }
    public IRawElementProviderSimple ContainingGrid { get; }
    private TableItemProviderWrapper(AutomationPeer peer, ITableItemProvider iface);
    public sealed virtual int get_Row();
    public sealed virtual int get_Column();
    public sealed virtual int get_RowSpan();
    public sealed virtual int get_ColumnSpan();
    public sealed virtual IRawElementProviderSimple get_ContainingGrid();
    public sealed virtual IRawElementProviderSimple[] GetRowHeaderItems();
    public sealed virtual IRawElementProviderSimple[] GetColumnHeaderItems();
    internal static object Wrap(AutomationPeer peer, object iface);
    private object GetRow(object unused);
    private object GetColumn(object unused);
    private object GetRowSpan(object unused);
    private object GetColumnSpan(object unused);
    private object GetContainingGrid(object unused);
    private object GetRowHeaderItems(object unused);
    private object GetColumnHeaderItems(object unused);
}
internal class MS.Internal.Automation.TableProviderWrapper : MarshalByRefObject {
    private AutomationPeer _peer;
    private ITableProvider _iface;
    public int RowCount { get; }
    public int ColumnCount { get; }
    public RowOrColumnMajor RowOrColumnMajor { get; }
    private TableProviderWrapper(AutomationPeer peer, ITableProvider iface);
    public sealed virtual IRawElementProviderSimple GetItem(int row, int column);
    public sealed virtual int get_RowCount();
    public sealed virtual int get_ColumnCount();
    public sealed virtual IRawElementProviderSimple[] GetRowHeaders();
    public sealed virtual IRawElementProviderSimple[] GetColumnHeaders();
    public sealed virtual RowOrColumnMajor get_RowOrColumnMajor();
    internal static object Wrap(AutomationPeer peer, object iface);
    private object GetItem(object arg);
    private object GetRowCount(object unused);
    private object GetColumnCount(object unused);
    private object GetRowHeaders(object unused);
    private object GetColumnHeaders(object unused);
    private object GetRowOrColumnMajor(object unused);
}
internal class MS.Internal.Automation.TextProviderWrapper : MarshalByRefObject {
    private AutomationPeer _peer;
    private ITextProvider _iface;
    public ITextRangeProvider DocumentRange { get; }
    public SupportedTextSelection SupportedTextSelection { get; }
    private TextProviderWrapper(AutomationPeer peer, ITextProvider iface);
    public sealed virtual ITextRangeProvider[] GetSelection();
    public sealed virtual ITextRangeProvider[] GetVisibleRanges();
    public sealed virtual ITextRangeProvider RangeFromChild(IRawElementProviderSimple childElement);
    public sealed virtual ITextRangeProvider RangeFromPoint(Point screenLocation);
    public sealed virtual ITextRangeProvider get_DocumentRange();
    public sealed virtual SupportedTextSelection get_SupportedTextSelection();
    internal static object Wrap(AutomationPeer peer, object iface);
    private object GetSelection(object unused);
    private object GetVisibleRanges(object unused);
    private object RangeFromChild(object arg);
    private object RangeFromPoint(object arg);
    private object GetDocumentRange(object unused);
    private object GetSupportedTextSelection(object unused);
}
internal class MS.Internal.Automation.TextRangeProviderWrapper : MarshalByRefObject {
    private AutomationPeer _peer;
    private ITextRangeProvider _iface;
    internal TextRangeProviderWrapper(AutomationPeer peer, ITextRangeProvider iface);
    public sealed virtual ITextRangeProvider Clone();
    public sealed virtual bool Compare(ITextRangeProvider range);
    public sealed virtual int CompareEndpoints(TextPatternRangeEndpoint endpoint, ITextRangeProvider targetRange, TextPatternRangeEndpoint targetEndpoint);
    public sealed virtual void ExpandToEnclosingUnit(TextUnit unit);
    public sealed virtual ITextRangeProvider FindAttribute(int attribute, object val, bool backward);
    public sealed virtual ITextRangeProvider FindText(string text, bool backward, bool ignoreCase);
    public sealed virtual object GetAttributeValue(int attribute);
    public sealed virtual Double[] GetBoundingRectangles();
    public sealed virtual IRawElementProviderSimple GetEnclosingElement();
    public sealed virtual string GetText(int maxLength);
    public sealed virtual int Move(TextUnit unit, int count);
    public sealed virtual int MoveEndpointByUnit(TextPatternRangeEndpoint endpoint, TextUnit unit, int count);
    public sealed virtual void MoveEndpointByRange(TextPatternRangeEndpoint endpoint, ITextRangeProvider targetRange, TextPatternRangeEndpoint targetEndpoint);
    public sealed virtual void Select();
    public sealed virtual void AddToSelection();
    public sealed virtual void RemoveFromSelection();
    public sealed virtual void ScrollIntoView(bool alignToTop);
    public sealed virtual IRawElementProviderSimple[] GetChildren();
    internal static ITextRangeProvider WrapArgument(ITextRangeProvider argument, AutomationPeer peer);
    internal static ITextRangeProvider[] WrapArgument(ITextRangeProvider[] argument, AutomationPeer peer);
    internal static ITextRangeProvider UnwrapArgument(ITextRangeProvider argument);
    private object Clone(object unused);
    private object Compare(object arg);
    private object CompareEndpoints(object arg);
    private object ExpandToEnclosingUnit(object arg);
    private object FindAttribute(object arg);
    private object FindText(object arg);
    private object GetAttributeValue(object arg);
    private object GetBoundingRectangles(object unused);
    private object GetEnclosingElement(object unused);
    private object GetText(object arg);
    private object Move(object arg);
    private object MoveEndpointByUnit(object arg);
    private object MoveEndpointByRange(object arg);
    private object Select(object unused);
    private object AddToSelection(object unused);
    private object RemoveFromSelection(object unused);
    private object ScrollIntoView(object arg);
    private object GetChildren(object unused);
}
internal class MS.Internal.Automation.ToggleProviderWrapper : MarshalByRefObject {
    private AutomationPeer _peer;
    private IToggleProvider _iface;
    public ToggleState ToggleState { get; }
    private ToggleProviderWrapper(AutomationPeer peer, IToggleProvider iface);
    public sealed virtual void Toggle();
    public sealed virtual ToggleState get_ToggleState();
    internal static object Wrap(AutomationPeer peer, object iface);
    private object ToggleInternal(object unused);
    private object GetToggleState(object unused);
}
internal class MS.Internal.Automation.TransformProviderWrapper : MarshalByRefObject {
    private AutomationPeer _peer;
    private ITransformProvider _iface;
    public bool CanMove { get; }
    public bool CanResize { get; }
    public bool CanRotate { get; }
    private TransformProviderWrapper(AutomationPeer peer, ITransformProvider iface);
    public sealed virtual void Move(double x, double y);
    public sealed virtual void Resize(double width, double height);
    public sealed virtual void Rotate(double degrees);
    public sealed virtual bool get_CanMove();
    public sealed virtual bool get_CanResize();
    public sealed virtual bool get_CanRotate();
    internal static object Wrap(AutomationPeer peer, object iface);
    private object Move(object arg);
    private object Resize(object arg);
    private object Rotate(object arg);
    private object GetCanMove(object unused);
    private object GetCanResize(object unused);
    private object GetCanRotate(object unused);
}
internal class MS.Internal.Automation.ValueProviderWrapper : MarshalByRefObject {
    private AutomationPeer _peer;
    private IValueProvider _iface;
    public string Value { get; }
    public bool IsReadOnly { get; }
    private ValueProviderWrapper(AutomationPeer peer, IValueProvider iface);
    public sealed virtual void SetValue(string val);
    public sealed virtual string get_Value();
    public sealed virtual bool get_IsReadOnly();
    internal static object Wrap(AutomationPeer peer, object iface);
    private object SetValueInternal(object arg);
    private object GetValue(object unused);
    private object GetIsReadOnly(object unused);
}
internal class MS.Internal.Automation.VirtualizedItemProviderWrapper : MarshalByRefObject {
    private AutomationPeer _peer;
    private IVirtualizedItemProvider _iface;
    private VirtualizedItemProviderWrapper(AutomationPeer peer, IVirtualizedItemProvider iface);
    public sealed virtual void Realize();
    internal static object Wrap(AutomationPeer peer, object iface);
    private object Realize(object unused);
}
internal class MS.Internal.Automation.WindowProviderWrapper : MarshalByRefObject {
    private AutomationPeer _peer;
    private IWindowProvider _iface;
    public bool Maximizable { get; }
    public bool Minimizable { get; }
    public bool IsModal { get; }
    public WindowVisualState VisualState { get; }
    public WindowInteractionState InteractionState { get; }
    public bool IsTopmost { get; }
    private WindowProviderWrapper(AutomationPeer peer, IWindowProvider iface);
    public sealed virtual void SetVisualState(WindowVisualState state);
    public sealed virtual void Close();
    public sealed virtual bool WaitForInputIdle(int milliseconds);
    public sealed virtual bool get_Maximizable();
    public sealed virtual bool get_Minimizable();
    public sealed virtual bool get_IsModal();
    public sealed virtual WindowVisualState get_VisualState();
    public sealed virtual WindowInteractionState get_InteractionState();
    public sealed virtual bool get_IsTopmost();
    internal static object Wrap(AutomationPeer peer, object iface);
    private object SetVisualState(object arg);
    private object WaitForInputIdle(object arg);
    private object Close(object unused);
    private object GetMaximizable(object unused);
    private object GetMinimizable(object unused);
    private object GetIsModal(object unused);
    private object GetVisualState(object unused);
    private object GetInteractionState(object unused);
    private object GetIsTopmost(object unused);
}
internal class MS.Internal.Automation.WrapObject : MulticastDelegate {
    public WrapObject(object object, IntPtr method);
    public virtual object Invoke(AutomationPeer peer, object iface, IntPtr hwnd);
    public virtual IAsyncResult BeginInvoke(AutomationPeer peer, object iface, IntPtr hwnd, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
internal class MS.Internal.BitmapTransformCaps : ValueType {
    private int nSize;
    private int cMinInputs;
    private int cMaxInputs;
    private bool fSupportMultiFormat;
    private bool fAuxiliaryData;
    private bool fSupportMultiOutput;
    private bool fSupportBanding;
    private bool fSupportMultiResolution;
}
internal class MS.Internal.CharacterAttribute : ValueType {
    internal byte Script;
    internal byte ItemClass;
    internal ushort Flags;
    internal byte BreakType;
    internal DirectionClass BiDi;
    internal short LineBreak;
}
internal enum MS.Internal.CharacterAttributeFlags : Enum {
    public ushort value__;
    public static CharacterAttributeFlags CharacterComplex;
    public static CharacterAttributeFlags CharacterRTL;
    public static CharacterAttributeFlags CharacterLineBreak;
    public static CharacterAttributeFlags CharacterFormatAnchor;
    public static CharacterAttributeFlags CharacterFastText;
    public static CharacterAttributeFlags CharacterIdeo;
    public static CharacterAttributeFlags CharacterExtended;
    public static CharacterAttributeFlags CharacterSpace;
    public static CharacterAttributeFlags CharacterDigit;
    public static CharacterAttributeFlags CharacterParaBreak;
    public static CharacterAttributeFlags CharacterCRLF;
    public static CharacterAttributeFlags CharacterLetter;
}
[DefaultMemberAttribute("Item")]
internal abstract class MS.Internal.CharacterBuffer : object {
    public char Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public abstract virtual Char* GetCharacterPointer();
    public abstract virtual IntPtr PinAndGetCharacterPointer(int offset, GCHandle& gcHandle);
    public abstract virtual void UnpinCharacterPointer(GCHandle gcHandle);
    public abstract virtual void AppendToStringBuilder(StringBuilder stringBuilder, int characterOffset, int length);
    public sealed virtual int IndexOf(char item);
    public sealed virtual void Insert(int index, char item);
    public abstract virtual char get_Item(int index);
    public abstract virtual void set_Item(int index, char value);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void Add(char item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(char item);
    public sealed virtual void CopyTo(Char[] array, int arrayIndex);
    public abstract virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(char item);
    [IteratorStateMachineAttribute("MS.Internal.CharacterBuffer/<System-Collections-Generic-IEnumerable<System-Char>-GetEnumerator>d__19")]
private sealed virtual override IEnumerator`1<char> System.Collections.Generic.IEnumerable<System.Char>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.CharArrayCharacterBuffer : CharacterBuffer {
    private Char[] _characterArray;
    public char Item { get; public set; }
    public int Count { get; }
    public CharArrayCharacterBuffer(Char[] characterArray);
    public virtual char get_Item(int characterOffset);
    public virtual void set_Item(int characterOffset, char value);
    public virtual int get_Count();
    public virtual Char* GetCharacterPointer();
    public virtual IntPtr PinAndGetCharacterPointer(int offset, GCHandle& gcHandle);
    public virtual void UnpinCharacterPointer(GCHandle gcHandle);
    public virtual void AppendToStringBuilder(StringBuilder stringBuilder, int characterOffset, int characterLength);
}
internal enum MS.Internal.CharBreakingType : Enum {
    public byte value__;
    public static CharBreakingType NoBreak;
    public static CharBreakingType ControlBreak;
    public static CharBreakingType DigitBreak;
    public static CharBreakingType PairMirrorBreak;
    public static CharBreakingType SingleMirrorBreak;
}
internal class MS.Internal.CheckedCharPointer : ValueType {
    private CheckedPointer _checkedPointer;
    internal CheckedCharPointer(Char* pointer, int length);
    internal Char* Probe(int offset, int length);
}
internal class MS.Internal.CheckedIntPointer : ValueType {
    private CheckedPointer _checkedPointer;
    internal CheckedIntPointer(Int32* pointer, int length);
    internal Int32* Probe(int offset, int length);
}
internal class MS.Internal.CheckedUShortPointer : ValueType {
    private CheckedPointer _checkedPointer;
    internal CheckedUShortPointer(UInt16* pointer, int length);
    internal UInt16* Probe(int offset, int length);
}
internal enum MS.Internal.ChildType : Enum {
    public int value__;
    public static ChildType eCOB;
    public static ChildType eCOBGROUP;
    public static ChildType eChildLast;
}
internal static class MS.Internal.Classification : object {
    private static SecurityCriticalData`1<IntPtr> _unicodeClassTable;
    private static SecurityCriticalData`1<IntPtr> _charAttributeTable;
    private static SecurityCriticalData`1<IntPtr> _mirroredCharTable;
    private static SecurityCriticalData`1<CombiningMarksClassificationData> _combiningMarksClassification;
    private static Int16*** UnicodeClassTable { get; }
    private static CharacterAttribute* CharAttributeTable { get; }
    private static Classification();
    internal static void MILGetClassificationTables(RawClassificationTables& ct);
    public static short GetUnicodeClassUTF16(char codepoint);
    public static short GetUnicodeClass(int unicodeScalar);
    internal static int UnicodeScalar(CharacterBufferRange unicodeString, Int32& sizeofChar);
    public static bool IsCombining(int unicodeScalar);
    public static bool IsJoiner(int unicodeScalar);
    public static bool IsIVS(int unicodeScalar);
    public static int AdvanceUntilUTF16(CharacterBuffer charBuffer, int offsetToFirstChar, int stringLength, ushort mask, UInt16& charFlags);
    public static int AdvanceWhile(CharacterBufferRange unicodeString, ItemClass itemClass);
    private static Int16*** get_UnicodeClassTable();
    private static CharacterAttribute* get_CharAttributeTable();
    internal static CharacterAttribute CharAttributeOf(int charClass);
}
internal class MS.Internal.ClassificationUtility : object {
    internal static Boolean[] ScriptCaretInfo;
    private static ClassificationUtility _classificationUtilityInstance;
    internal static ClassificationUtility Instance { get; }
    private static ClassificationUtility();
    internal static ClassificationUtility get_Instance();
    public sealed virtual void GetCharAttribute(int unicodeScalar, Boolean& isCombining, Boolean& needsCaretInfo, Boolean& isIndic, Boolean& isDigit, Boolean& isLatin, Boolean& isStrong);
    private static bool IsScriptIndic(ScriptID scriptId);
}
internal class MS.Internal.Collections.ItemInsertedHandler : MulticastDelegate {
    public ItemInsertedHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, object item);
    public virtual IAsyncResult BeginInvoke(object sender, object item, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class MS.Internal.Collections.ItemRemovedHandler : MulticastDelegate {
    public ItemRemovedHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, object item);
    public virtual IAsyncResult BeginInvoke(object sender, object item, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[FriendAccessAllowedAttribute]
internal static class MS.Internal.CommandLibraryHelper : object {
    internal static RoutedUICommand CreateUICommand(string name, Type ownerType, byte commandId);
}
internal static class MS.Internal.Composition.Version : object {
    internal static UInt32 MilSdkVersion { get; }
    internal static UInt32 DwmSdkVersion { get; }
    internal static UInt32 get_MilSdkVersion();
    internal static UInt32 get_DwmSdkVersion();
}
internal static class MS.Internal.CoreAppContextSwitches : object {
    internal static string DoNotScaleForDpiChangesSwitchName;
    private static int _doNotScaleForDpiChanges;
    internal static string DisableStylusAndTouchSupportSwitchName;
    private static int _disableStylusAndTouchSupport;
    internal static string EnablePointerSupportSwitchName;
    private static int _enablePointerSupport;
    internal static string OverrideExceptionWithNullReferenceExceptionName;
    private static int _overrideExceptionWithNullReferenceException;
    internal static string DisableDiagnosticsSwitchName;
    private static int _disableDiagnostics;
    internal static string AllowChangesDuringVisualTreeChangedSwitchName;
    private static int _allowChangesDuringVisualTreeChanged;
    internal static string DisableImplicitTouchKeyboardInvocationSwitchName;
    private static int _disableImplicitTouchKeyboardInvocation;
    internal static string ShouldRenderEvenWhenNoDisplayDevicesAreAvailableSwitchName;
    private static int _shouldRenderEvenWhenNoDisplayDevicesAreAvailable;
    internal static string ShouldNotRenderInNonInteractiveWindowStationSwitchName;
    private static int _shouldNotRenderInNonInteractiveWindowStation;
    internal static string DoNotUsePresentationDpiCapabilityTier2OrGreaterSwitchName;
    private static int _doNotUsePresentationDpiCapabilityTier2OrGreater;
    internal static string DoNotUsePresentationDpiCapabilityTier3OrGreaterSwitchName;
    private static int _doNotUsePresentationDpiCapabilityTier3OrGreater;
    internal static string AllowExternalProcessToBlockAccessToTemporaryFilesSwitchName;
    private static int _allowExternalProcessToBlockAccessToTemporaryFiles;
    public static bool DoNotScaleForDpiChanges { get; }
    public static bool DisableStylusAndTouchSupport { get; }
    public static bool EnablePointerSupport { get; }
    public static bool OverrideExceptionWithNullReferenceException { get; }
    public static bool DisableDiagnostics { get; }
    public static bool AllowChangesDuringVisualTreeChanged { get; }
    public static bool DisableImplicitTouchKeyboardInvocation { get; }
    public static bool UseNetFx47CompatibleAccessibilityFeatures { get; }
    public static bool UseNetFx471CompatibleAccessibilityFeatures { get; }
    public static bool UseNetFx472CompatibleAccessibilityFeatures { get; }
    public static bool ShouldRenderEvenWhenNoDisplayDevicesAreAvailable { get; }
    public static bool ShouldNotRenderInNonInteractiveWindowStation { get; }
    public static bool DoNotUsePresentationDpiCapabilityTier2OrGreater { get; }
    public static bool DoNotUsePresentationDpiCapabilityTier3OrGreater { get; }
    public static bool AllowExternalProcessToBlockAccessToTemporaryFiles { get; }
    public static bool get_DoNotScaleForDpiChanges();
    public static bool get_DisableStylusAndTouchSupport();
    public static bool get_EnablePointerSupport();
    public static bool get_OverrideExceptionWithNullReferenceException();
    public static bool get_DisableDiagnostics();
    public static bool get_AllowChangesDuringVisualTreeChanged();
    public static bool get_DisableImplicitTouchKeyboardInvocation();
    public static bool get_UseNetFx47CompatibleAccessibilityFeatures();
    public static bool get_UseNetFx471CompatibleAccessibilityFeatures();
    public static bool get_UseNetFx472CompatibleAccessibilityFeatures();
    public static bool get_ShouldRenderEvenWhenNoDisplayDevicesAreAvailable();
    public static bool get_ShouldNotRenderInNonInteractiveWindowStation();
    public static bool get_DoNotUsePresentationDpiCapabilityTier2OrGreater();
    public static bool get_DoNotUsePresentationDpiCapabilityTier3OrGreater();
    public static bool get_AllowExternalProcessToBlockAccessToTemporaryFiles();
}
internal class MS.Internal.CustomCategoryAttribute : CategoryAttribute {
    internal CustomCategoryAttribute(string category);
    protected virtual string GetLocalizedString(string value);
}
internal class MS.Internal.DecoderFallbackWithFailureFlag : DecoderFallback {
    private bool _hasFailed;
    public int MaxCharCount { get; }
    public bool HasFailed { get; public set; }
    public virtual DecoderFallbackBuffer CreateFallbackBuffer();
    public virtual int get_MaxCharCount();
    public bool get_HasFailed();
    public void set_HasFailed(bool value);
}
internal class MS.Internal.DeferredElementTreeState : object {
    private Dictionary`2<DependencyObject, DependencyObject> _oldCoreParents;
    private Dictionary`2<DependencyObject, DependencyObject> _oldLogicalParents;
    public bool IsEmpty { get; }
    public void SetCoreParent(DependencyObject element, DependencyObject parent);
    public static DependencyObject GetCoreParent(DependencyObject element, DeferredElementTreeState treeState);
    public static DependencyObject GetInputElementParent(DependencyObject element, DeferredElementTreeState treeState);
    public void SetLogicalParent(DependencyObject element, DependencyObject parent);
    public static DependencyObject GetLogicalParent(DependencyObject element, DeferredElementTreeState treeState);
    public void Clear();
    public bool get_IsEmpty();
}
internal enum MS.Internal.DirectionClass : Enum {
    public byte value__;
    public static DirectionClass Left;
    public static DirectionClass Right;
    public static DirectionClass ArabicNumber;
    public static DirectionClass EuropeanNumber;
    public static DirectionClass ArabicLetter;
    public static DirectionClass EuropeanSeparator;
    public static DirectionClass CommonSeparator;
    public static DirectionClass EuropeanTerminator;
    public static DirectionClass NonSpacingMark;
    public static DirectionClass BoundaryNeutral;
    public static DirectionClass GenericNeutral;
    public static DirectionClass ParagraphSeparator;
    public static DirectionClass LeftToRightEmbedding;
    public static DirectionClass LeftToRightOverride;
    public static DirectionClass RightToLeftEmbedding;
    public static DirectionClass RightToLeftOverride;
    public static DirectionClass PopDirectionalFormat;
    public static DirectionClass SegmentSeparator;
    public static DirectionClass WhiteSpace;
    public static DirectionClass OtherNeutral;
    public static DirectionClass ClassInvalid;
    public static DirectionClass ClassMax;
}
internal enum MS.Internal.DitherType : Enum {
    public int value__;
    public static DitherType DitherTypeNone;
    public static DitherType DitherTypeSolid;
    public static DitherType DitherTypeOrdered4x4;
    public static DitherType DitherTypeOrdered8x8;
    public static DitherType DitherTypeOrdered16x16;
    public static DitherType DitherTypeSpiral4x4;
    public static DitherType DitherTypeSpiral8x8;
    public static DitherType DitherTypeDualSpiral4x4;
    public static DitherType DitherTypeDualSpiral8x8;
    public static DitherType DitherTypeErrorDiffusion;
}
internal class MS.Internal.DpiScale2 : object {
    private DpiScale dpiScale;
    internal double DpiScaleX { get; }
    internal double DpiScaleY { get; }
    internal double PixelsPerDip { get; }
    internal double PixelsPerInchX { get; }
    internal double PixelsPerInchY { get; }
    internal DpiScale2(DpiScale dpiScale);
    internal DpiScale2(double dpiScaleX, double dpiScaleY);
    internal double get_DpiScaleX();
    internal double get_DpiScaleY();
    internal double get_PixelsPerDip();
    internal double get_PixelsPerInchX();
    internal double get_PixelsPerInchY();
    public static DpiScale op_Implicit(DpiScale2 dpiScale2);
    public static bool op_Inequality(DpiScale2 dpiScaleA, DpiScale2 dpiScaleB);
    public static bool op_Equality(DpiScale2 dpiScaleA, DpiScale2 dpiScaleB);
    public sealed virtual bool Equals(DpiScale dpiScale);
    public sealed virtual bool Equals(DpiScale2 dpiScale2);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal static DpiScale2 FromPixelsPerInch(double ppiX, double ppiY);
}
internal static class MS.Internal.DpiUtil : object {
    internal static double DefaultPixelsPerInch;
    internal static DpiAwarenessContextHandle GetDpiAwarenessContext(IntPtr hWnd);
    internal static PROCESS_DPI_AWARENESS GetProcessDpiAwareness(IntPtr hWnd);
    internal static DpiAwarenessContextValue GetProcessDpiAwarenessContextValue(IntPtr hWnd);
    internal static PROCESS_DPI_AWARENESS GetLegacyProcessDpiAwareness();
    internal static DpiScale2 GetSystemDpi();
    internal static DpiScale2 GetSystemDpiFromUIElementCache();
    internal static void UpdateUIElementCacheForSystemDpi(DpiScale2 systemDpiScale);
    internal static DpiScale2 GetWindowDpi(IntPtr hWnd, bool fallbackToNearestMonitorHeuristic);
    internal static HwndDpiInfo GetExtendedDpiInfoForWindow(IntPtr hWnd, bool fallbackToNearestMonitorHeuristic);
    internal static HwndDpiInfo GetExtendedDpiInfoForWindow(IntPtr hWnd);
    internal static IDisposable WithDpiAwarenessContext(DpiAwarenessContextValue dpiAwarenessContext);
    internal static DpiFlags UpdateDpiScalesAndGetIndex(double pixelsPerInchX, double pixelsPerInchY);
}
internal class MS.Internal.Equals : MulticastDelegate {
    public Equals(object object, IntPtr method);
    public virtual bool Invoke(object first, object second);
    public virtual IAsyncResult BeginInvoke(object first, object second, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal enum MS.Internal.FeatureTags : Enum {
    public int value__;
    public static FeatureTags AccessAllAlternates;
    public static FeatureTags AboveBaseForms;
    public static FeatureTags AboveBaseMarkPositioning;
    public static FeatureTags AboveBaseSubstitutions;
    public static FeatureTags AlternativeFractions;
    public static FeatureTags Akhands;
    public static FeatureTags BelowBaseForms;
    public static FeatureTags BelowBaseMarkPositioning;
    public static FeatureTags BelowBaseSubstitutions;
    public static FeatureTags PetiteCapitalsFromCapitals;
    public static FeatureTags SmallCapitalsFromCapitals;
    public static FeatureTags ContextualAlternates;
    public static FeatureTags CaseSensitiveForms;
    public static FeatureTags GlyphCompositionDecomposition;
    public static FeatureTags Conjunctformafterro;
    public static FeatureTags ContextualLigatures;
    public static FeatureTags Conjuncts;
    public static FeatureTags CapitalSpacing;
    public static FeatureTags ContextualSwash;
    public static FeatureTags CursivePositioning;
    public static FeatureTags DefaultProcessing;
    public static FeatureTags Distances;
    public static FeatureTags DiscretionaryLigatures;
    public static FeatureTags Denominators;
    public static FeatureTags Diphthongs;
    public static FeatureTags ExpertForms;
    public static FeatureTags FinalglyphAlternates;
    public static FeatureTags TerminalForms;
    public static FeatureTags TerminalForms2;
    public static FeatureTags TerminalForms3;
    public static FeatureTags Fractions;
    public static FeatureTags FullWidth;
    public static FeatureTags HalfForms;
    public static FeatureTags HalantForms;
    public static FeatureTags AlternateHalfWidth;
    public static FeatureTags HistoricalForms;
    public static FeatureTags HorizontalKanaAlternates;
    public static FeatureTags HistoricalLigatures;
    public static FeatureTags Hangul;
    public static FeatureTags HalfWidth;
    public static FeatureTags HojoKanjiForms;
    public static FeatureTags InitialForms;
    public static FeatureTags IsolatedForms;
    public static FeatureTags Italics;
    public static FeatureTags JapaneseForms;
    public static FeatureTags JustificationAlternatives;
    public static FeatureTags JIS04Forms;
    public static FeatureTags JIS78Forms;
    public static FeatureTags JIS83Forms;
    public static FeatureTags JIS90Forms;
    public static FeatureTags Kerning;
    public static FeatureTags LeftBounds;
    public static FeatureTags StandardLigatures;
    public static FeatureTags LeadingJamoForms;
    public static FeatureTags LiningFigures;
    public static FeatureTags LocalizedForms;
    public static FeatureTags MarkPositioning;
    public static FeatureTags MedialForms;
    public static FeatureTags MedialForms2;
    public static FeatureTags MathematicalGreek;
    public static FeatureTags MarktoMarkPositioning;
    public static FeatureTags MarkPositioningviaSubstitution;
    public static FeatureTags AlternateAnnotationForms;
    public static FeatureTags NLCKanjiForms;
    public static FeatureTags NuktaForms;
    public static FeatureTags Numerators;
    public static FeatureTags OldStyleFigures;
    public static FeatureTags OpticalBounds;
    public static FeatureTags Ordinals;
    public static FeatureTags Ornaments;
    public static FeatureTags ProportionalAlternateWidth;
    public static FeatureTags PetiteCapitals;
    public static FeatureTags ProportionalFigures;
    public static FeatureTags PrebaseForms;
    public static FeatureTags PrebaseSubstitutions;
    public static FeatureTags PostbaseForms;
    public static FeatureTags PostbaseSubstitutions;
    public static FeatureTags ProportionalWidths;
    public static FeatureTags QuarterWidths;
    public static FeatureTags Randomize;
    public static FeatureTags RakarForms;
    public static FeatureTags RequiredLigatures;
    public static FeatureTags RephForm;
    public static FeatureTags RightBounds;
    public static FeatureTags RightToLeftAlternates;
    public static FeatureTags RubyNotationForms;
    public static FeatureTags StylisticAlternates;
    public static FeatureTags ScientificInferiors;
    public static FeatureTags OpticalSize;
    public static FeatureTags SmallCapitals;
    public static FeatureTags SimplifiedForms;
    public static FeatureTags StylisticSet1;
    public static FeatureTags StylisticSet2;
    public static FeatureTags StylisticSet3;
    public static FeatureTags StylisticSet4;
    public static FeatureTags StylisticSet5;
    public static FeatureTags StylisticSet6;
    public static FeatureTags StylisticSet7;
    public static FeatureTags StylisticSet8;
    public static FeatureTags StylisticSet9;
    public static FeatureTags StylisticSet10;
    public static FeatureTags StylisticSet11;
    public static FeatureTags StylisticSet12;
    public static FeatureTags StylisticSet13;
    public static FeatureTags StylisticSet14;
    public static FeatureTags StylisticSet15;
    public static FeatureTags StylisticSet16;
    public static FeatureTags StylisticSet17;
    public static FeatureTags StylisticSet18;
    public static FeatureTags StylisticSet19;
    public static FeatureTags StylisticSet20;
    public static FeatureTags Subscript;
    public static FeatureTags Superscript;
    public static FeatureTags Swash;
    public static FeatureTags Titling;
    public static FeatureTags TrailingJamoForms;
    public static FeatureTags TraditionalNameForms;
    public static FeatureTags TabularFigures;
    public static FeatureTags TraditionalForms;
    public static FeatureTags ThirdWidths;
    public static FeatureTags Unicase;
    public static FeatureTags AlternateVerticalMetrics;
    public static FeatureTags VattuVariants;
    public static FeatureTags VerticalWriting;
    public static FeatureTags AlternateVerticalHalfMetrics;
    public static FeatureTags VowelJamoForms;
    public static FeatureTags VerticalKanaAlternates;
    public static FeatureTags VerticalKerning;
    public static FeatureTags ProportionalAlternateVerticalMetrics;
    public static FeatureTags VerticalRotation;
    public static FeatureTags SlashedZero;
}
internal static class MS.Internal.FloatUtil : object {
    internal static float FLT_EPSILON;
    internal static float FLT_MAX_PRECISION;
    internal static float INVERSE_FLT_MAX_PRECISION;
    private static FloatUtil();
    public static bool AreClose(float a, float b);
    public static bool IsOne(float a);
    public static bool IsZero(float a);
    public static bool IsCloseToDivideByZero(float numerator, float denominator);
}
internal static class MS.Internal.FontCache.BufferCache : object {
    private static int MaxBufferLength;
    private static int GlyphMetricsIndex;
    private static int UIntsIndex;
    private static int UShortsIndex;
    private static int BuffersLength;
    private static long _mutex;
    private static Array[] _buffers;
    internal static void Reset();
    internal static GlyphMetrics[] GetGlyphMetrics(int length);
    internal static void ReleaseGlyphMetrics(GlyphMetrics[] glyphMetrics);
    internal static UInt16[] GetUShorts(int length);
    internal static void ReleaseUShorts(UInt16[] ushorts);
    internal static UInt32[] GetUInts(int length);
    internal static void ReleaseUInts(UInt32[] uints);
    private static Array GetBuffer(int length, int index);
    private static void ReleaseBuffer(Array buffer, int index);
}
internal class MS.Internal.FontCache.CachedTypeface : object {
    private FontStyle _canonicalStyle;
    private FontWeight _canonicalWeight;
    private FontStretch _canonicalStretch;
    private IFontFamily _firstFontFamily;
    private ITypefaceMetrics _typefaceMetrics;
    private bool _nullFont;
    internal FontStyle CanonicalStyle { get; }
    internal FontWeight CanonicalWeight { get; }
    internal FontStretch CanonicalStretch { get; }
    internal IFontFamily FirstFontFamily { get; }
    internal ITypefaceMetrics TypefaceMetrics { get; }
    internal bool NullFont { get; }
    internal CachedTypeface(FontStyle canonicalStyle, FontWeight canonicalWeight, FontStretch canonicalStretch, IFontFamily firstFontFamily, ITypefaceMetrics typefaceMetrics, bool nullFont);
    internal FontStyle get_CanonicalStyle();
    internal FontWeight get_CanonicalWeight();
    internal FontStretch get_CanonicalStretch();
    internal IFontFamily get_FirstFontFamily();
    internal ITypefaceMetrics get_TypefaceMetrics();
    internal bool get_NullFont();
}
internal class MS.Internal.FontCache.CanonicalFontFamilyReference : object {
    [CompilerGeneratedAttribute]
private string <EscapedFileName>k__BackingField;
    private Uri _absoluteLocationUri;
    private string _familyName;
    private static CanonicalFontFamilyReference _unresolved;
    public static CanonicalFontFamilyReference Unresolved { get; }
    public string FamilyName { get; }
    public string EscapedFileName { get; private set; }
    public Uri LocationUri { get; }
    private CanonicalFontFamilyReference(string escapedFileName, string familyName);
    private CanonicalFontFamilyReference(Uri absoluteLocationUri, string familyName);
    private static CanonicalFontFamilyReference();
    public static CanonicalFontFamilyReference Create(Uri baseUri, string normalizedString);
    public static CanonicalFontFamilyReference get_Unresolved();
    public string get_FamilyName();
    [CompilerGeneratedAttribute]
public string get_EscapedFileName();
    [CompilerGeneratedAttribute]
private void set_EscapedFileName(string value);
    public Uri get_LocationUri();
    public bool Equals(CanonicalFontFamilyReference other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private static bool SplitFontFamilyReference(string normalizedString, String& locationString, String& escapedFamilyName);
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.FontCache.CheckedPointer : ValueType {
    private Void* _pointer;
    private int _size;
    internal bool IsNull { get; }
    internal int Size { get; }
    internal CheckedPointer(Void* pointer, int size);
    internal CheckedPointer(UnmanagedMemoryStream stream);
    internal bool get_IsNull();
    internal int get_Size();
    internal Byte[] ToArray();
    internal void CopyTo(CheckedPointer dest);
    internal int OffsetOf(Void* pointer);
    internal int OffsetOf(CheckedPointer pointer);
    public static CheckedPointer op_Addition(CheckedPointer rhs, int offset);
    internal Void* Probe(int offset, int length);
    internal CheckedPointer CheckedProbe(int offset, int length);
    internal void SetSize(int newSize);
    internal bool PointerEquals(CheckedPointer pointer);
    internal void WriteBool(bool value);
    internal bool ReadBool();
}
internal static class MS.Internal.FontCache.DWriteFactory : object {
    private static Factory _factory;
    private static FontCollection _systemFontCollection;
    private static object _systemFontCollectionLock;
    internal static Factory Instance { get; }
    internal static FontCollection SystemFontCollection { get; }
    private static DWriteFactory();
    internal static Factory get_Instance();
    internal static FontCollection get_SystemFontCollection();
    private static FontCollection GetFontCollectionFromFileOrFolder(Uri fontCollectionUri, bool isFolder);
    internal static FontCollection GetFontCollectionFromFolder(Uri fontCollectionUri);
    internal static FontCollection GetFontCollectionFromFile(Uri fontCollectionUri);
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.FontCache.FamilyCollection : object {
    private FontCollection _fontCollection;
    private Uri _folderUri;
    private List`1<CompositeFontFamily> _userCompositeFonts;
    private static object _staticLock;
    [CompilerGeneratedAttribute]
private static string <SxSFontsResourcePrefix>k__BackingField;
    internal static string SxSFontsResourcePrefix { get; }
    private bool UseSystemFonts { get; }
    private IList`1<CompositeFontFamily> UserCompositeFonts { get; }
    internal UInt32 FamilyCount { get; }
    private FamilyCollection(Uri folderUri, FontCollection fontCollection);
    private static FamilyCollection();
    [CompilerGeneratedAttribute]
internal static string get_SxSFontsResourcePrefix();
    private static List`1<CompositeFontFamily> GetCompositeFontList(FontSourceCollection fontSourceCollection);
    private bool get_UseSystemFonts();
    private IList`1<CompositeFontFamily> get_UserCompositeFonts();
    internal static FamilyCollection FromUri(Uri folderUri);
    internal static FamilyCollection FromWindowsFonts(Uri folderUri);
    internal IFontFamily LookupFamily(string familyName, FontStyle& fontStyle, FontWeight& fontWeight, FontStretch& fontStretch);
    private CompositeFontFamily LookUpUserCompositeFamily(string familyName);
    private static Font GetFontFromFamily(FontFamily fontFamily, string faceName);
    private IEnumerable`1<FontFamily> GetPhysicalFontFamilies();
    internal FontFamily[] GetFontFamilies(Uri fontFamilyBaseUri, string fontFamilyLocationReference);
    private FontFamily CreateFontFamily(CompositeFontFamily compositeFontFamily, Uri fontFamilyBaseUri, string fontFamilyLocationReference);
    internal UInt32 get_FamilyCount();
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.FontCache.FileMapping : UnmanagedMemoryStream {
    private SafeViewOfFileHandle _viewHandle;
    private SafeFileMappingHandle _mappingHandle;
    private bool _disposed;
    protected virtual override void Finalize();
    protected virtual void Dispose(bool disposing);
    internal void OpenFile(string fileName);
}
internal static class MS.Internal.FontCache.FontCacheConstants : object {
    internal static int InitialSharedCacheSize;
    internal static int MaximumSharedCacheSize;
    internal static int InitialLocalCacheSize;
    internal static int MaximumLocalCacheSize;
    internal static int CacheGrowthFactor;
    internal static int GetCacheNameMessage;
    internal static int SendMissReportMessage;
    internal static int ServerShutdownMessage;
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.FontCache.FontFaceLayoutInfo : object {
    private FontTechnology _fontTechnology;
    private TypographyAvailabilities _typographyAvailabilities;
    private FontEmbeddingRight _embeddingRights;
    private bool _embeddingRightsInitialized;
    private bool _gsubInitialized;
    private bool _gposInitialized;
    private bool _gdefInitialized;
    private bool _fontTechnologyInitialized;
    private bool _typographyAvailabilitiesInitialized;
    private Byte[] _gsubCache;
    private Byte[] _gposCache;
    private Byte[] _gsub;
    private Byte[] _gpos;
    private Byte[] _gdef;
    private Font _font;
    private ushort _blankGlyphIndex;
    private IntMap _cmap;
    private static UInt32[] LoclFeature;
    private static UInt32[] RequiredTypographyFeatures;
    private static UInt32[] RequiredFeatures;
    private static UnicodeRange[] fastTextRanges;
    internal IntMap CharacterMap { get; }
    internal ushort BlankGlyph { get; }
    internal ushort DesignEmHeight { get; }
    internal FontEmbeddingRight EmbeddingRights { get; }
    internal FontTechnology FontTechnology { get; }
    internal TypographyAvailabilities TypographyAvailabilities { get; }
    internal ushort GlyphCount { get; }
    internal FontFaceLayoutInfo(Font font);
    private static FontFaceLayoutInfo();
    internal IntMap get_CharacterMap();
    internal ushort get_BlankGlyph();
    internal ushort get_DesignEmHeight();
    internal FontEmbeddingRight get_EmbeddingRights();
    internal FontTechnology get_FontTechnology();
    internal TypographyAvailabilities get_TypographyAvailabilities();
    internal ushort get_GlyphCount();
    private Byte[] GetFontTable(OpenTypeTableTag openTypeTableTag);
    internal Byte[] Gsub();
    internal Byte[] Gpos();
    internal Byte[] Gdef();
    internal Byte[] GetTableCache(OpenTypeTags tableTag);
    internal Byte[] AllocateTableCache(OpenTypeTags tableTag, int size);
    private void ComputeFontTechnology();
    private void ComputeTypographyAvailabilities();
}
internal static class MS.Internal.FontCache.FontResourceCache : object {
    private static string FakeFileName;
    private static Dictionary`2<Assembly, Dictionary`2<string, List`1<string>>> _assemblyCaches;
    private static FontResourceCache();
    private static void ConstructFontResourceCache(Assembly entryAssembly, Dictionary`2<string, List`1<string>> folderResourceMap);
    internal static List`1<string> LookupFolder(Uri uri);
    private static bool IsFolderUri(Uri uri);
    private static void AddResourceToFolderMap(Dictionary`2<string, List`1<string>> folderResourceMap, string resourceFullName);
}
internal class MS.Internal.FontCache.FontSource : object {
    private bool _isComposite;
    private bool _isInternalCompositeFont;
    private Uri _fontUri;
    private bool _skipDemand;
    private static SizeLimitedCache`2<Uri, Byte[]> _resourceCache;
    private static int MaximumCacheItems;
    private static string ObfuscatedContentType;
    public bool IsFile { get; }
    public bool IsComposite { get; }
    public Uri Uri { get; }
    public bool IsAppSpecific { get; }
    public FontSource(Uri fontUri, bool skipDemand);
    public FontSource(Uri fontUri, bool skipDemand, bool isComposite);
    public FontSource(Uri fontUri, bool skipDemand, bool isComposite, bool isInternalCompositeFont);
    private static FontSource();
    private void Initialize(Uri fontUri, bool skipDemand, bool isComposite, bool isInternalCompositeFont);
    public bool get_IsFile();
    public sealed virtual bool get_IsComposite();
    public string GetUriString();
    public string ToStringUpperInvariant();
    public virtual int GetHashCode();
    public sealed virtual Uri get_Uri();
    public bool get_IsAppSpecific();
    internal long SkipLastWriteTime();
    public sealed virtual DateTime GetLastWriteTimeUtc();
    public sealed virtual UnmanagedMemoryStream GetUnmanagedStream();
    public sealed virtual void TestFileOpenable();
    public Stream GetStream();
    private static UnmanagedMemoryStream ByteArrayToUnmanagedStream(Byte[] bits);
    private static Byte[] StreamToByteArray(Stream fontStream);
    private Stream GetCompositeFontResourceStream();
}
internal class MS.Internal.FontCache.FontSourceCollection : object {
    private Uri _uri;
    private bool _isWindowsFonts;
    private bool _isFileSystemFolder;
    private IList`1 modreq(System.Runtime.CompilerServices.IsVolatile) _fontSources;
    private bool _tryGetCompositeFontsOnly;
    private static string InstalledWindowsFontsRegistryKey;
    private static string InstalledWindowsFontsRegistryKeyFullPath;
    public FontSourceCollection(Uri folderUri, bool isWindowsFonts);
    public FontSourceCollection(Uri folderUri, bool isWindowsFonts, bool tryGetCompositeFontsOnly);
    private void Initialize(Uri folderUri, bool isWindowsFonts, bool tryGetCompositeFontsOnly);
    private void InitializeDirectoryProperties();
    private void SetFontSources();
    private sealed virtual override IEnumerator`1<IFontSource> System.Collections.Generic.IEnumerable<MS.Internal.Text.TextInterface.IFontSource>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class MS.Internal.FontCache.FontSourceCollectionFactory : object {
    public sealed virtual IFontSourceCollection Create(string uriString);
}
internal class MS.Internal.FontCache.FontSourceFactory : object {
    public sealed virtual IFontSource Create(string uriString);
}
internal class MS.Internal.FontCache.GsubGposTables : object {
    private FontTable _gsubTable;
    private FontTable _gposTable;
    private FontFaceLayoutInfo _layout;
    internal GsubGposTables(FontFaceLayoutInfo layout);
    public sealed virtual FontTable GetFontTable(OpenTypeTags TableTag);
    public sealed virtual LayoutOffset GetGlyphPointCoord(ushort Glyph, ushort PointIndex);
    public sealed virtual Byte[] GetTableCache(OpenTypeTags tableTag);
    public sealed virtual Byte[] AllocateTableCache(OpenTypeTags tableTag, int size);
}
[FriendAccessAllowedAttribute]
internal static class MS.Internal.FontCache.HashFn : object {
    private static int HASH_MULTIPLIER;
    internal static int HashMultiply(int hash);
    internal static int HashScramble(int hash);
    internal static int HashMemory(Void* pv, int numBytes, int hash);
    internal static int HashString(string s, int hash);
}
internal class MS.Internal.FontCache.LocalizedName : object {
    private XmlLanguage _language;
    private string _name;
    private int _originalLCID;
    private static NameComparerClass _nameComparer;
    private static LanguageComparerClass _languageComparer;
    internal XmlLanguage Language { get; }
    internal string Name { get; }
    internal int OriginalLCID { get; }
    internal static IComparer`1<LocalizedName> NameComparer { get; }
    internal static IComparer`1<LocalizedName> LanguageComparer { get; }
    internal LocalizedName(XmlLanguage language, string name);
    internal LocalizedName(XmlLanguage language, string name, int originalLCID);
    private static LocalizedName();
    internal XmlLanguage get_Language();
    internal string get_Name();
    internal int get_OriginalLCID();
    internal static IComparer`1<LocalizedName> get_NameComparer();
    internal static IComparer`1<LocalizedName> get_LanguageComparer();
}
internal static class MS.Internal.FontCache.MajorLanguages : object {
    private static MajorLanguageDesc[] majorLanguages;
    private static MajorLanguages();
    internal static bool Contains(ScriptTags script, LanguageTags langSys);
    internal static bool Contains(CultureInfo culture);
}
internal static class MS.Internal.FontCache.TypefaceMetricsCache : object {
    private static Hashtable _hashTable;
    private static object _lock;
    private static int MaxCacheCapacity;
    private static TypefaceMetricsCache();
    internal static object ReadonlyLookup(object key);
    internal static void Add(object key, object value);
}
[FlagsAttribute]
internal enum MS.Internal.FontCache.TypographyAvailabilities : Enum {
    public int value__;
    public static TypographyAvailabilities None;
    public static TypographyAvailabilities Available;
    public static TypographyAvailabilities IdeoTypographyAvailable;
    public static TypographyAvailabilities FastTextTypographyAvailable;
    public static TypographyAvailabilities FastTextMajorLanguageLocalizedFormAvailable;
    public static TypographyAvailabilities FastTextExtraLanguageLocalizedFormAvailable;
}
internal class MS.Internal.FontCache.UnicodeRange : ValueType {
    internal int firstChar;
    internal int lastChar;
    internal UnicodeRange(int first, int last);
    internal UInt32[] GetFullRange();
}
[FriendAccessAllowedAttribute]
internal static class MS.Internal.FontCache.Util : object {
    internal static int nullOffset;
    private static String[] SupportedExtensions;
    private static Char[] InvalidFileNameChars;
    internal static UriComponents UriWithoutFragment;
    private static string WinDir;
    private static string EmptyFontFamilyReference;
    private static string EmptyCanonicalName;
    private static object _dpiLock;
    private static int _dpi;
    private static bool _dpiInitialized;
    private static string _windowsFontsLocalPath;
    private static Uri _windowsFontsUriObject;
    private static string _windowsFontsUriString;
    internal static string CompositeFontExtension { get; }
    internal static string WindowsFontsLocalPath { get; }
    internal static float PixelsPerDip { get; }
    internal static int Dpi { get; }
    internal static Uri WindowsFontsUriObject { get; }
    internal static string WindowsFontsUriString { get; }
    private static Util();
    internal static string get_CompositeFontExtension();
    internal static string get_WindowsFontsLocalPath();
    internal static float get_PixelsPerDip();
    internal static int get_Dpi();
    internal static Uri get_WindowsFontsUriObject();
    internal static string get_WindowsFontsUriString();
    internal static bool IsReferenceToWindowsFonts(string s);
    internal static bool IsSupportedSchemeForAbsoluteFontFamilyUri(Uri absoluteUri);
    internal static void SplitFontFaceIndex(Uri fontUri, Uri& fontSourceUri, Int32& faceIndex);
    internal static Uri CombineUriWithFaceIndex(string fontUri, int faceIndex);
    internal static bool IsSupportedFontExtension(string extension, Boolean& isComposite);
    internal static bool IsCompositeFont(string extension);
    internal static bool IsEnumerableFontUriScheme(Uri fontLocation);
    internal static bool IsAppSpecificUri(Uri fontLocation);
    internal static string GetUriExtension(Uri uri);
    internal static string GetNormalizedFontFamilyReference(string friendlyName, int startIndex, int length);
    private static string NormalizeFontFamilyReference(string fontFamilyReference);
    private static string NormalizeFontFamilyReference(string fontFamilyReference, int startIndex, int length);
    internal static string ConvertFamilyNameAndLocationToFontFamilyReference(string familyName, string location);
    internal static string ConvertFontFamilyReferenceToFriendlyName(string fontFamilyReference);
    internal static int CompareOrdinalIgnoreCase(string a, string b);
    private static int CompareOrdinalIgnoreCase(char a, char b);
    internal static void ThrowWin32Exception(int errorCode, string fileName);
    internal static Exception ConvertInPageException(FontSource fontSource, SEHException e);
}
internal class MS.Internal.FontFace.CompositeFontInfo : object {
    private LanguageSpecificStringDictionary _familyNames;
    private double _baseline;
    private double _lineSpacing;
    private FamilyTypefaceCollection _familyTypefaces;
    private FontFamilyMapCollection _familyMaps;
    private UInt16[] _defaultFamilyMapRanges;
    private Dictionary`2<XmlLanguage, UInt16[]> _familyMapRangesByLanguage;
    private static int InitialCultureCount;
    private static int InitialTargetFamilyCount;
    private static UInt16[] EmptyFamilyMapRanges;
    private static int InitialFamilyMapRangesCapacity;
    internal static int FirstFamilyMapRange;
    internal FamilyTypefaceCollection FamilyTypefaces { get; }
    internal double Baseline { get; internal set; }
    internal double LineSpacing { get; internal set; }
    internal LanguageSpecificStringDictionary FamilyNames { get; }
    internal FontFamilyMapCollection FamilyMaps { get; }
    internal ICollection`1<XmlLanguage> FamilyMapLanguages { get; }
    private static CompositeFontInfo();
    internal void PrepareToAddFamilyMap(FontFamilyMap familyMap);
    internal void InvalidateFamilyMapRanges();
    internal UInt16[] GetFamilyMapsOfLanguage(XmlLanguage language);
    internal FontFamilyMap GetFamilyMapOfChar(UInt16[] familyMapRanges, int ch);
    private bool IsFamilyMapRangesValid(UInt16[] familyMapRanges);
    private UInt16[] CreateFamilyMapRanges(XmlLanguage language);
    internal FamilyTypefaceCollection get_FamilyTypefaces();
    internal FamilyTypefaceCollection GetFamilyTypefaceList();
    internal double get_Baseline();
    internal void set_Baseline(double value);
    internal double get_LineSpacing();
    internal void set_LineSpacing(double value);
    internal LanguageSpecificStringDictionary get_FamilyNames();
    internal FontFamilyMapCollection get_FamilyMaps();
    internal ICollection`1<XmlLanguage> get_FamilyMapLanguages();
}
internal class MS.Internal.FontFace.CompositeFontParser : object {
    private static NumberStyles UnsignedDecimalPointStyle;
    private static NumberStyles SignedDecimalPointStyle;
    private CompositeFontInfo _compositeFontInfo;
    private XmlReader _reader;
    private Hashtable _namespaceMap;
    private TypeConverter _doubleTypeConverter;
    private TypeConverter _xmlLanguageTypeConverter;
    private static string SystemClrNamespace;
    private static string CompositeFontNamespace;
    private static string XamlNamespace;
    private static string XmlNamespace;
    private static string XmlnsNamespace;
    private static string FontFamilyCollectionElement;
    private static string FontFamilyElement;
    private static string BaselineAttribute;
    private static string LineSpacingAttribute;
    private static string FamilyNamesPropertyElement;
    private static string StringElement;
    private static string FamilyTypefacesPropertyElement;
    private static string FamilyTypefaceElement;
    private static string FamilyMapsPropertyElement;
    private static string FamilyMapElement;
    private static string KeyAttribute;
    private static string LanguageAttribute;
    private static string NameAttribute;
    private static string StyleAttribute;
    private static string WeightAttribute;
    private static string StretchAttribute;
    private static string UnderlinePositionAttribute;
    private static string UnderlineThicknessAttribute;
    private static string StrikethroughPositionAttribute;
    private static string StrikethroughThicknessAttribute;
    private static string CapsHeightAttribute;
    private static string XHeightAttribute;
    private static string UnicodeAttribute;
    private static string TargetAttribute;
    private static string ScaleAttribute;
    private static string DeviceFontNameAttribute;
    private static string DeviceFontCharacterMetricsPropertyElement;
    private static string CharacterMetricsElement;
    private static string MetricsAttribute;
    private static string OsAttribute;
    private CompositeFontParser(Stream fileStream);
    internal static void VerifyMultiplierOfEm(string propertyName, Double& value);
    internal static void VerifyPositiveMultiplierOfEm(string propertyName, Double& value);
    internal static void VerifyNonNegativeMultiplierOfEm(string propertyName, Double& value);
    private double GetAttributeAsDouble();
    private XmlLanguage GetAttributeAsXmlLanguage();
    private string GetAttributeValue();
    internal static CompositeFontInfo LoadXml(Stream fileStream);
    private XmlReader CreateXmlReader(Stream fileStream);
    private bool IsXmlNamespaceSupported(string xmlNamespace, String& newXmlNamespace);
    private bool IsStartElement(string localName, string namespaceURI);
    private XmlNodeType MoveToContent();
    private bool IsMappedNamespace(string xmlNamespace);
    private bool IsSystemNamespace(string xmlNamespace);
    private void ParseFontFamilyCollectionElement();
    private void ParseFontFamilyElement();
    private void VerifyNoAttributes();
    private void ParseFamilyNameElement();
    private void ParseFamilyTypefaceElement();
    private void ParseFamilyTypefaceAttributes(FamilyTypeface face);
    private void ParseCharacterMetricsElement(FamilyTypeface face);
    private void ParseFamilyMapElement();
    private void ParseEmptyElement();
    private bool IsCompositeFontAttribute();
    private bool IsIgnorableAttribute();
    private void VerifyCompositeFontInfo();
    private void FailNotWellFormed(Exception x);
    private void FailAttributeValue();
    private void FailAttributeValue(Exception x);
    private void FailUnknownElement();
    private void FailUnknownAttribute();
    private void FailMissingAttribute(string name);
    private void Fail(string message);
    private void Fail(string message, Exception innerException);
}
internal static class MS.Internal.FontFace.FontDifferentiator : object {
    internal static IDictionary`2<XmlLanguage, string> ConstructFaceNamesByStyleWeightStretch(FontStyle style, FontWeight weight, FontStretch stretch);
    private static string BuildFaceName(FontStyle fontStyle, FontWeight fontWeight, FontStretch fontStretch);
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.FontFace.FontFamilyIdentifier : ValueType {
    private string _friendlyName;
    private Uri _baseUri;
    private int _tokenCount;
    private CanonicalFontFamilyReference[] _canonicalReferences;
    internal static char FamilyNameDelimiter;
    internal static int MaxFamilyNamePerFamilyMapTarget;
    internal string Source { get; }
    internal Uri BaseUri { get; }
    internal int Count { get; }
    internal CanonicalFontFamilyReference Item { get; }
    internal FontFamilyIdentifier(string friendlyName, Uri baseUri);
    internal FontFamilyIdentifier(FontFamilyIdentifier first, FontFamilyIdentifier second);
    internal string get_Source();
    internal Uri get_BaseUri();
    public bool Equals(FontFamilyIdentifier other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal int get_Count();
    internal CanonicalFontFamilyReference get_Item(int tokenIndex);
    internal void Canonicalize();
    private static int CountTokens(string friendlyName);
    private static int FindToken(string friendlyName, int i, Int32& tokenIndex, Int32& tokenLength);
    private CanonicalFontFamilyReference GetCanonicalReference(int startIndex, int length);
}
internal enum MS.Internal.FontFace.FontTechnology : Enum {
    public int value__;
    public static FontTechnology PostscriptOpenType;
    public static FontTechnology TrueType;
    public static FontTechnology TrueTypeCollection;
}
internal interface MS.Internal.FontFace.IDeviceFont {
    public string Name { get; }
    public abstract virtual string get_Name();
    public abstract virtual bool ContainsCharacter(int unicodeScalar);
    public abstract virtual void GetAdvanceWidths(Char* characterString, int characterLength, double emSize, Int32* pAdvances);
}
internal interface MS.Internal.FontFace.IFontFamily {
    public IDictionary`2<XmlLanguage, string> Names { get; }
    public double BaselineDesign { get; }
    public double LineSpacingDesign { get; }
    public abstract virtual IDictionary`2<XmlLanguage, string> get_Names();
    public abstract virtual double Baseline(double emSize, double toReal, double pixelsPerDip, TextFormattingMode textFormattingMode);
    public abstract virtual double get_BaselineDesign();
    public abstract virtual double LineSpacing(double emSize, double toReal, double pixelsPerDip, TextFormattingMode textFormattingMode);
    public abstract virtual double get_LineSpacingDesign();
    public abstract virtual ITypefaceMetrics GetTypefaceMetrics(FontStyle style, FontWeight weight, FontStretch stretch);
    public abstract virtual IDeviceFont GetDeviceFont(FontStyle style, FontWeight weight, FontStretch stretch);
    public abstract virtual bool GetMapTargetFamilyNameAndScale(CharacterBufferRange unicodeString, CultureInfo culture, CultureInfo digitCulture, double defaultSizeInEm, Int32& cchAdvance, String& targetFamilyName, Double& scaleInEm);
    public abstract virtual ICollection`1<Typeface> GetTypefaces(FontFamilyIdentifier familyIdentifier);
}
internal interface MS.Internal.FontFace.ITypefaceMetrics {
    public double XHeight { get; }
    public double CapsHeight { get; }
    public double UnderlinePosition { get; }
    public double UnderlineThickness { get; }
    public double StrikethroughPosition { get; }
    public double StrikethroughThickness { get; }
    public bool Symbol { get; }
    public StyleSimulations StyleSimulations { get; }
    public IDictionary`2<XmlLanguage, string> AdjustedFaceNames { get; }
    public abstract virtual double get_XHeight();
    public abstract virtual double get_CapsHeight();
    public abstract virtual double get_UnderlinePosition();
    public abstract virtual double get_UnderlineThickness();
    public abstract virtual double get_StrikethroughPosition();
    public abstract virtual double get_StrikethroughThickness();
    public abstract virtual bool get_Symbol();
    public abstract virtual StyleSimulations get_StyleSimulations();
    public abstract virtual IDictionary`2<XmlLanguage, string> get_AdjustedFaceNames();
}
internal class MS.Internal.FontFace.MatchingStyle : ValueType {
    private Vector _vector;
    private static double FontWeightScale;
    private static double FontStyleScale;
    private static double FontStretchScale;
    internal MatchingStyle(FontStyle style, FontWeight weight, FontStretch stretch);
    public static bool op_Equality(MatchingStyle l, MatchingStyle r);
    public static bool op_Inequality(MatchingStyle l, MatchingStyle r);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    internal static bool IsBetterMatch(MatchingStyle target, MatchingStyle best, MatchingStyle& matching);
    internal bool IsBetterMatch(MatchingStyle target, MatchingStyle best);
}
internal class MS.Internal.FontFace.PhysicalFontFamily : object {
    private FontFamily _family;
    private IDictionary`2<XmlLanguage, string> _familyNames;
    private IDictionary`2<XmlLanguage, string> MS.Internal.FontFace.IFontFamily.Names { get; }
    private double MS.Internal.FontFace.IFontFamily.BaselineDesign { get; }
    private double MS.Internal.FontFace.IFontFamily.LineSpacingDesign { get; }
    internal PhysicalFontFamily(FontFamily family);
    private static IDictionary`2<XmlLanguage, string> ConvertDictionary(IDictionary`2<CultureInfo, string> dictionary);
    private sealed virtual override ITypefaceMetrics MS.Internal.FontFace.IFontFamily.GetTypefaceMetrics(FontStyle style, FontWeight weight, FontStretch stretch);
    private sealed virtual override IDeviceFont MS.Internal.FontFace.IFontFamily.GetDeviceFont(FontStyle style, FontWeight weight, FontStretch stretch);
    private sealed virtual override IDictionary`2<XmlLanguage, string> MS.Internal.FontFace.IFontFamily.get_Names();
    internal GlyphTypeface GetGlyphTypeface(FontStyle style, FontWeight weight, FontStretch stretch);
    internal GlyphTypeface MapGlyphTypeface(FontStyle style, FontWeight weight, FontStretch stretch, CharacterBufferRange charString, CultureInfo digitCulture, Int32& advance, Int32& nextValid);
    private int MapCharacters(Font font, CharacterBufferRange unicodeString, CultureInfo digitCulture, Int32& nextValid);
    private sealed virtual override double MS.Internal.FontFace.IFontFamily.Baseline(double emSize, double toReal, double pixelsPerDip, TextFormattingMode textFormattingMode);
    private sealed virtual override double MS.Internal.FontFace.IFontFamily.get_BaselineDesign();
    private sealed virtual override double MS.Internal.FontFace.IFontFamily.get_LineSpacingDesign();
    private sealed virtual override double MS.Internal.FontFace.IFontFamily.LineSpacing(double emSize, double toReal, double pixelsPerDip, TextFormattingMode textFormattingMode);
    private sealed virtual override ICollection`1<Typeface> MS.Internal.FontFace.IFontFamily.GetTypefaces(FontFamilyIdentifier familyIdentifier);
    private sealed virtual override bool MS.Internal.FontFace.IFontFamily.GetMapTargetFamilyNameAndScale(CharacterBufferRange unicodeString, CultureInfo culture, CultureInfo digitCulture, double defaultSizeInEm, Int32& cchAdvance, String& targetFamilyName, Double& scaleInEm);
}
internal class MS.Internal.FontFace.TrueTypeFontDriver : object {
    private CheckedPointer _fileStream;
    private UnmanagedMemoryStream _unmanagedMemoryStream;
    private Uri _sourceUri;
    private int _numFaces;
    private FontTechnology _technology;
    private int _faceIndex;
    private int _directoryOffset;
    private DirectoryEntry[] _tableDirectory;
    internal int NumFaces { get; }
    private Uri SourceUri { get; }
    internal TrueTypeFontDriver(UnmanagedMemoryStream unmanagedMemoryStream, Uri sourceUri);
    private static ushort ReadOpenTypeUShort(CheckedPointer pointer);
    private static int ReadOpenTypeLong(CheckedPointer pointer);
    internal void SetFace(int faceIndex);
    internal int get_NumFaces();
    private Uri get_SourceUri();
    internal Byte[] ComputeFontSubset(ICollection`1<ushort> glyphs);
}
internal class MS.Internal.FontFace.TypefaceCollection : ValueType {
    private FontFamily _fontFamily;
    private FontFamily _family;
    private FamilyTypefaceCollection _familyTypefaceCollection;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public TypefaceCollection(FontFamily fontFamily, FontFamily family);
    public TypefaceCollection(FontFamily fontFamily, FamilyTypefaceCollection familyTypefaceCollection);
    public sealed virtual void Add(Typeface item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Typeface item);
    public sealed virtual void CopyTo(Typeface[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(Typeface item);
    public sealed virtual IEnumerator`1<Typeface> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[FriendAccessAllowedAttribute]
internal static class MS.Internal.FreezableOperations : object {
    internal static Freezable Clone(Freezable freezable);
    public static Freezable GetAsFrozen(Freezable freezable);
    internal static Freezable GetAsFrozenIfPossible(Freezable freezable);
    internal static void PropagateChangedHandlers(Freezable oldValue, Freezable newValue, EventHandler changedHandler);
}
internal class MS.Internal.Generic.Span`1 : ValueType {
    internal T Value;
    internal int Length;
    internal Span`1(T value, int length);
}
internal class MS.Internal.Generic.SpanRider`1 : ValueType {
    private static int MaxCch;
    private SpanVector`1<T> _vector;
    private Span`1<T> _defaultSpan;
    private int _current;
    private int _cp;
    private int _dcp;
    private int _cch;
    internal int CurrentSpanStart { get; }
    internal int Length { get; }
    internal int CurrentPosition { get; }
    internal T CurrentValue { get; }
    internal SpanRider`1(SpanVector`1<T> vector);
    internal bool At(int cp);
    internal int get_CurrentSpanStart();
    internal int get_Length();
    internal int get_CurrentPosition();
    internal T get_CurrentValue();
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.Generic.SpanVector`1 : ValueType {
    private FrugalStructList`1<Span`1<T>> _spanList;
    private T _defaultValue;
    internal int Count { get; }
    internal T DefaultValue { get; }
    internal Span`1<T> Item { get; }
    internal SpanVector`1(T defaultValue);
    private SpanVector`1(T defaultValue, FrugalStructList`1<Span`1<T>> spanList);
    public sealed virtual IEnumerator`1<Span`1<T>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private void Add(Span`1<T> span);
    internal void Delete(int index, int count);
    private void Insert(int index, int count);
    internal void Set(int first, int length, T value);
    internal int get_Count();
    internal T get_DefaultValue();
    internal Span`1<T> get_Item(int index);
    private bool Resize(int targetCount);
}
internal class MS.Internal.GenericEnumerator : object {
    private IList _array;
    private object _current;
    private int _count;
    private int _position;
    private int _originalGenerationID;
    private GetGenerationIDDelegate _getGenerationID;
    private object System.Collections.IEnumerator.Current { get; }
    internal GenericEnumerator(IList array, GetGenerationIDDelegate getGenerationID);
    private void VerifyCurrent();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
internal static class MS.Internal.Hashing.PresentationCore.HashHelper : object {
    private static HashHelper();
    internal static bool HasReliableHashCode(object item);
    internal static void Initialize();
}
internal class MS.Internal.HRESULT : ValueType {
    internal static int FACILITY_NT_BIT;
    internal static int FACILITY_MASK;
    internal static int FACILITY_WINCODEC_ERROR;
    internal static int COMPONENT_MASK;
    internal static int COMPONENT_WINCODEC_ERROR;
    internal static int S_OK;
    internal static int E_FAIL;
    internal static int E_OUTOFMEMORY;
    internal static int D3DERR_OUTOFVIDEOMEMORY;
    internal static bool IsWindowsCodecError(int hr);
    internal static Exception ConvertHRToException(int hr);
    public static void Check(int hr);
    public static bool Succeeded(int hr);
    public static bool Failed(int hr);
}
internal class MS.Internal.HWND : ValueType {
    public int hwnd;
}
internal interface MS.Internal.IAppDomainShutdownListener {
    public abstract virtual void NotifyShutdown();
}
internal class MS.Internal.Ink.Bezier : object {
    private List`1<Point> _bezierControlPoints;
    private int BezierPointCount { get; }
    internal bool ConstructBezierState(StylusPointCollection stylusPoints, double fitError);
    internal List`1<Point> Flatten(double tolerance);
    private bool ExtendingRange(double error, CuspData data, int from, int next_cusp, Int32& to, Boolean& cusp, Boolean& done);
    private bool AddBezierSegment(CuspData data, int from, Vector& tanStart, int to, Vector& tanEnd);
    private bool ConstructFromData(CuspData data, double fitError);
    private void AddParabola(CuspData data, int from);
    private void AddLine(CuspData data, int from, int to);
    private bool AddLeastSquares(CuspData data, int from, Vector& V, int to, Vector& W);
    private static bool CoCubic(CuspData data, Int32[] i, double fitError);
    private void AddBezierPoint(Vector point);
    private void AddSegmentPoint(CuspData data, int index);
    private Vector DeCasteljau(int iFirst, double t);
    private void FlattenSegment(int iFirst, double tolerance, List`1<Point> points);
    private Vector GetBezierPoint(int index);
    private int get_BezierPointCount();
}
internal class MS.Internal.Ink.BitStreamReader : object {
    private Byte[] _byteArray;
    private UInt32 _bufferLengthInBits;
    private int _byteArrayIndex;
    private byte _partialByte;
    private int _cbitsInPartialByte;
    internal bool EndOfStream { get; }
    internal int CurrentIndex { get; }
    internal BitStreamReader(Byte[] buffer);
    internal BitStreamReader(Byte[] buffer, int startIndex);
    internal BitStreamReader(Byte[] buffer, UInt32 bufferLengthInBits);
    internal long ReadUInt64(int countOfBits);
    internal ushort ReadUInt16(int countOfBits);
    internal UInt32 ReadUInt16Reverse(int countOfBits);
    internal UInt32 ReadUInt32(int countOfBits);
    internal UInt32 ReadUInt32Reverse(int countOfBits);
    internal bool ReadBit();
    internal byte ReadByte(int countOfBits);
    internal bool get_EndOfStream();
    internal int get_CurrentIndex();
}
internal class MS.Internal.Ink.BitStreamWriter : object {
    private List`1<byte> _targetBuffer;
    private int _remaining;
    internal BitStreamWriter(List`1<byte> bufferToWriteTo);
    internal void Write(UInt32 bits, int countOfBits);
    internal void WriteReverse(UInt32 bits, int countOfBits);
    internal void Write(byte bits, int countOfBits);
}
internal class MS.Internal.Ink.ContourSegment : ValueType {
    private Point _begin;
    private Vector _vector;
    private Vector _radius;
    internal bool IsArc { get; }
    internal Point Begin { get; }
    internal Point End { get; }
    internal Vector Vector { get; }
    internal Vector Radius { get; }
    internal ContourSegment(Point begin, Point end);
    internal ContourSegment(Point begin, Point end, Point center);
    internal bool get_IsArc();
    internal Point get_Begin();
    internal Point get_End();
    internal Vector get_Vector();
    internal Vector get_Radius();
}
internal class MS.Internal.Ink.CuspData : object {
    private List`1<CDataPoint> _points;
    private List`1<double> _nodes;
    private double _dist;
    private List`1<int> _cusps;
    private double _span;
    internal int Count { get; }
    internal void Analyze(StylusPointCollection stylusPoints, double rSpan);
    internal void SetTanLinks(double rError);
    internal int GetNextCusp(int iCurrent);
    internal Vector XY(int i);
    internal int get_Count();
    internal double Node(int i);
    internal int GetPointIndex(int nodeIndex);
    internal double Distance();
    internal bool Tangent(Vector& ptT, int nAt, int nPrevCusp, int nNextCusp, bool bReverse, bool bIsCusp);
    private double GetCurvature(int iPrev, int iCurrent, int iNext);
    private void FindAllCusps();
    private bool FindNextAndPrev(int iPoint, int iPrevCusp, Int32& iPrev, Int32& iNext);
    private static void UpdateMinMax(double a, Double& rMin, Double& rMax);
    private void SetLinks(double rSpan);
}
internal class MS.Internal.Ink.EllipticalNodeOperations : StrokeNodeOperations {
    private double _radius;
    private Size _radii;
    private Matrix _transform;
    private Matrix _nodeShapeToCircle;
    private Matrix _circleToNodeShape;
    internal bool IsNodeShapeEllipse { get; }
    internal EllipticalNodeOperations(StylusShape nodeShape);
    internal virtual bool get_IsNodeShapeEllipse();
    internal virtual Quad GetConnectingQuad(StrokeNodeData beginNode, StrokeNodeData endNode);
    [IteratorStateMachineAttribute("MS.Internal.Ink.EllipticalNodeOperations/<GetContourSegments>d__4")]
internal virtual IEnumerable`1<ContourSegment> GetContourSegments(StrokeNodeData node, Quad quad);
    internal virtual IEnumerable`1<ContourSegment> GetNonBezierContourSegments(StrokeNodeData beginNode, StrokeNodeData endNode);
    internal virtual bool HitTest(StrokeNodeData beginNode, StrokeNodeData endNode, Quad quad, Point hitBeginPoint, Point hitEndPoint);
    internal virtual bool HitTest(StrokeNodeData beginNode, StrokeNodeData endNode, Quad quad, IEnumerable`1<ContourSegment> hitContour);
    internal virtual StrokeFIndices CutTest(StrokeNodeData beginNode, StrokeNodeData endNode, Quad quad, Point hitBeginPoint, Point hitEndPoint);
    internal virtual StrokeFIndices CutTest(StrokeNodeData beginNode, StrokeNodeData endNode, Quad quad, IEnumerable`1<ContourSegment> hitContour);
    private static double ClipTest(Vector spineVector, double beginRadius, double endRadius, Vector hitBegin, Vector hitEnd);
    private static double ClipTest(Vector spine, double beginRadius, double endRadius, Vector hit);
    private static HitResult WhereIsNodeAboutSegment(Vector spine, Vector segBegin, Vector segEnd);
    private void CalculateCutLocations(Vector spineVector, Vector hitBegin, Vector hitEnd, double endRadius, double beginRadius, StrokeFIndices& result);
}
internal class MS.Internal.Ink.ErasingStroke : object {
    private StrokeNodeIterator _nodeIterator;
    private List`1<StrokeNode> _erasingStrokeNodes;
    private Rect _bounds;
    private static double CollinearTolerance;
    internal Rect Bounds { get; }
    internal ErasingStroke(StylusShape erasingShape);
    internal ErasingStroke(StylusShape erasingShape, IEnumerable`1<Point> path);
    private static ErasingStroke();
    internal void MoveTo(IEnumerable`1<Point> path);
    internal Rect get_Bounds();
    internal bool HitTest(StrokeNodeIterator iterator);
    internal bool EraseTest(StrokeNodeIterator iterator, List`1<StrokeIntersection> intersections);
    private Point[] FilterPoints(Point[] path);
}
internal class MS.Internal.Ink.GestureRecognition.NativeRecognizer : object {
    private static string GestureRecognizerPath;
    private static string GestureRecognizerFullPath;
    private static string GestureRecognizerValueName;
    private static string GestureRecognizerGuid;
    private static ushort MAX_GESTURE_COUNT;
    private static ushort GESTURE_NULL;
    private static ushort IRAS_DefaultCount;
    private static ushort MaxStylusPoints;
    private static Guid GUID_CONFIDENCELEVEL;
    private bool _disposed;
    private ContextSafeHandle _hContext;
    private static object _syncRoot;
    private static RecognizerSafeHandle s_hRec;
    private static Guid s_Gesture;
    private static bool s_isSupported;
    private static bool s_GetAlternateListExists;
    private static RecognizerSafeHandle RecognizerHandleSingleton { get; }
    private static NativeRecognizer();
    internal static NativeRecognizer CreateInstance();
    internal ApplicationGesture[] SetEnabledGestures(IEnumerable`1<ApplicationGesture> applicationGestures);
    internal GestureRecognitionResult[] Recognize(StrokeCollection strokes);
    internal static ApplicationGesture[] GetApplicationGestureArrayAndVerify(IEnumerable`1<ApplicationGesture> applicationGestures);
    public sealed virtual void Dispose();
    private static bool LoadRecognizerDll();
    private int SetEnabledGestures(ContextSafeHandle recContext, ApplicationGesture[] enabledGestures);
    private int AddStrokes(ContextSafeHandle recContext, StrokeCollection strokes);
    private void GetPacketData(Stroke stroke, PACKET_DESCRIPTION& packetDescription, Int32& countOfBytes, IntPtr& packets, XFORM& xForm);
    private void ReleaseResourcesinPacketDescription(PACKET_DESCRIPTION pd, IntPtr packets);
    private GestureRecognitionResult[] InvokeGetAlternateList();
    private GestureRecognitionResult[] InvokeGetLatticePtr();
    private static RecognizerSafeHandle get_RecognizerHandleSingleton();
}
internal class MS.Internal.Ink.InkSerializedFormat.AlgoModule : object {
    private HuffModule _huffModule;
    private MultiByteCodec _multiByteCodec;
    private DeltaDelta _deltaDelta;
    private GorillaCodec _gorillaCodec;
    private LZCodec _lzCodec;
    internal static byte NoCompression;
    internal static byte DefaultCompression;
    internal static byte IndexedHuffman;
    internal static byte LempelZiv;
    internal static byte DefaultBAACount;
    internal static byte MaxBAACount;
    private static Double[] DefaultFirstSquareRoot;
    private HuffModule HuffModule { get; }
    private MultiByteCodec MultiByteCodec { get; }
    private DeltaDelta DeltaDelta { get; }
    private GorillaCodec GorillaCodec { get; }
    private LZCodec LZCodec { get; }
    private static AlgoModule();
    internal byte GetBestDefHuff(Int32[] input);
    internal Byte[] CompressPacketData(Int32[] input, byte compression);
    internal UInt32 DecompressPacketData(Byte[] input, Int32[] outputBuffer);
    internal Byte[] CompressPropertyData(Byte[] input, byte compression);
    internal Byte[] DecompressPropertyData(Byte[] input);
    private HuffModule get_HuffModule();
    private MultiByteCodec get_MultiByteCodec();
    private DeltaDelta get_DeltaDelta();
    private GorillaCodec get_GorillaCodec();
    private LZCodec get_LZCodec();
}
internal class MS.Internal.Ink.InkSerializedFormat.Compressor : object {
    [ThreadStaticAttribute]
private static AlgoModule _algoModule;
    private static AlgoModule AlgoModule { get; }
    internal static void DecompressPacketData(Byte[] compressedInput, UInt32& size, Int32[] decompressedPackets);
    internal static Byte[] DecompressPropertyData(Byte[] input);
    internal static Byte[] CompressPropertyData(Byte[] data, byte algorithm);
    internal static Byte[] CompressPacketData(Int32[] input, Byte& algorithm);
    private static AlgoModule get_AlgoModule();
}
internal abstract class MS.Internal.Ink.InkSerializedFormat.DataXform : object {
    internal abstract virtual void Transform(int data, Int32& xfData, Int32& extra);
    internal abstract virtual void ResetState();
    internal abstract virtual int InverseTransform(int xfData, int extra);
}
internal class MS.Internal.Ink.InkSerializedFormat.DeltaDelta : DataXform {
    private long _d_i_1;
    private long _d_i_2;
    internal virtual void Transform(int data, Int32& xfData, Int32& extra);
    internal virtual void ResetState();
    internal virtual int InverseTransform(int xfData, int extra);
}
internal static class MS.Internal.Ink.InkSerializedFormat.DrawingAttributeSerializer : object {
    private static double V1PenWidthWhenWidthIsMissing;
    private static double V1PenHeightWhenHeightIsMissing;
    private static int TransparencyDefaultV1;
    internal static UInt32 RasterOperationMaskPen;
    internal static UInt32 RasterOperationDefaultV1;
    private static DrawingAttributeSerializer();
    internal static UInt32 DecodeAsISF(Stream stream, GuidList guidList, UInt32 maximumStreamSize, DrawingAttributes da);
    internal static double GetCappedHeightOrWidth(double heightOrWidth);
    internal static UInt32 EncodeAsISF(DrawingAttributes da, Stream stream, GuidList guidList, byte compressionAlgorithm, bool fTag);
    private static void PersistDrawingFlags(DrawingAttributes da, Stream stream, GuidList guidList, UInt32& cbData, BinaryWriter& bw);
    private static void PersistColorAndTransparency(DrawingAttributes da, Stream stream, GuidList guidList, UInt32& cbData, BinaryWriter& bw);
    private static void PersistRasterOperation(DrawingAttributes da, Stream stream, GuidList guidList, UInt32& cbData, BinaryWriter& bw);
    private static void PersistExtendedProperties(DrawingAttributes da, Stream stream, GuidList guidList, UInt32& cbData, BinaryWriter& bw, byte compressionAlgorithm, bool fTag);
    private static void PersistStylusTip(DrawingAttributes da, Stream stream, GuidList guidList, UInt32& cbData, BinaryWriter& bw);
    private static void PersistWidthHeight(DrawingAttributes da, Stream stream, GuidList guidList, UInt32& cbData, BinaryWriter& bw);
}
internal static class MS.Internal.Ink.InkSerializedFormat.ExtendedPropertySerializer : object {
    private static bool UsesEmbeddedTypeInformation(Guid propGuid);
    internal static void EncodeToStream(ExtendedProperty attribute, Stream stream);
    internal static void EncodeAttribute(Guid guid, object value, VarEnum type, Stream stream);
    internal static UInt32 EncodeAsISF(Guid id, Byte[] data, Stream strm, GuidList guidList, byte compressionAlgorithm, bool fTag);
    internal static UInt32 DecodeAsISF(Stream stream, UInt32 cbSize, GuidList guidList, KnownTagIndex tag, Guid& guid, Object& data);
    internal static object DecodeAttribute(Guid guid, Stream stream);
    internal static object DecodeAttribute(Guid guid, Stream memStream, VarEnum& type);
    internal static UInt32 EncodeAsISF(ExtendedPropertyCollection attributes, Stream stream, GuidList guidList, byte compressionAlgorithm, bool fTag);
    internal static Guid[] GetUnknownGuids(ExtendedPropertyCollection attributes, Int32& count);
    internal static void Validate(Guid id, object value);
}
internal class MS.Internal.Ink.InkSerializedFormat.GorillaAlgoByte : ValueType {
    public UInt32 BitCount;
    public UInt32 PadCount;
    public GorillaAlgoByte(UInt32 bitCount, UInt32 padCount);
}
internal class MS.Internal.Ink.InkSerializedFormat.GorillaCodec : object {
    private static GorillaAlgoByte[] _gorIndexMap;
    private static Byte[] _gorIndexOffset;
    private static GorillaCodec();
    internal byte FindPacketAlgoByte(Int32[] input, bool testDelDel);
    internal byte FindPropAlgoByte(Byte[] input);
    internal void GetPropertyBitCount(byte algorithmByte, Int32& countPerItem, Int32& bitCount, Int32& padCount);
    internal void Compress(int bitCount, Int32[] input, int startInputIndex, DeltaDelta dtxf, List`1<byte> compressedData);
    internal void Compress(int bitCount, BitStreamReader reader, GorillaEncodingType encodingType, int unitsToEncode, List`1<byte> compressedData);
    private int GetDataFromReader(BitStreamReader reader, GorillaEncodingType type);
    internal UInt32 Uncompress(int bitCount, Byte[] input, int inputIndex, DeltaDelta dtxf, Int32[] outputBuffer, int outputBufferIndex);
    internal Byte[] Uncompress(int bitCount, BitStreamReader reader, GorillaEncodingType encodingType, int unitsToDecode);
    private static void UpdateMinMax(int n, Int32& max, Int32& min);
}
internal enum MS.Internal.Ink.InkSerializedFormat.GorillaEncodingType : Enum {
    public int value__;
    public static GorillaEncodingType Byte;
    public static GorillaEncodingType Short;
    public static GorillaEncodingType Int;
}
internal class MS.Internal.Ink.InkSerializedFormat.GuidList : object {
    private List`1<Guid> _CustomGuids;
    public bool Add(Guid guid);
    public static KnownTagIndex FindKnownTag(Guid guid);
    private KnownTagIndex FindCustomTag(Guid guid);
    public KnownTagIndex FindTag(Guid guid, bool bFindInKnownListFirst);
    private static Guid FindKnownGuid(KnownTagIndex tag);
    private Guid FindCustomGuid(KnownTagIndex tag);
    public Guid FindGuid(KnownTagIndex tag);
    public static UInt32 GetDataSizeIfKnownGuid(Guid guid);
    public UInt32 Save(Stream stream);
    public UInt32 Load(Stream strm, UInt32 size);
}
internal class MS.Internal.Ink.InkSerializedFormat.HuffCodec : object {
    private HuffBits _huffBits;
    private UInt32[] _mins;
    private static byte MaxBAASize;
    internal HuffCodec(UInt32 defaultIndex);
    private static HuffCodec();
    private void InitHuffTable(HuffBits huffBits);
    internal void Compress(DataXform dataXf, Int32[] input, List`1<byte> compressedData);
    internal UInt32 Uncompress(DataXform dtxf, Byte[] input, int startIndex, Int32[] outputBuffer);
    internal byte Encode(int data, int extra, BitStreamWriter writer);
    internal void Decode(Int32& data, Int32& extra, BitStreamReader reader);
}
internal class MS.Internal.Ink.InkSerializedFormat.HuffModule : object {
    private DeltaDelta _defaultDtxf;
    private List`1<HuffCodec> _huffCodecs;
    private HuffCodec[] _defaultHuffCodecs;
    private DeltaDelta DefaultDeltaDelta { get; }
    internal HuffCodec GetDefCodec(UInt32 index);
    internal HuffCodec FindCodec(byte algoData);
    internal DataXform FindDtXf(byte algoData);
    private DeltaDelta get_DefaultDeltaDelta();
}
internal static class MS.Internal.Ink.InkSerializedFormat.KnownIdCache : object {
    public static Guid[] OriginalISFIdTable;
    public static UInt32[] OriginalISFIdPersistenceSize;
    public static Guid[] TabletInternalIdTable;
    internal static KnownTagIndex KnownGuidBaseIndex;
    internal static UInt32 MaximumPossibleKnownGuidIndex;
    internal static UInt32 CustomGuidBaseIndex;
    public static Guid[] ExtendedISFIdTable;
    private static KnownIdCache();
}
internal static class MS.Internal.Ink.InkSerializedFormat.KnownTagCache : object {
    internal static UInt32 MaximumPossibleKnownTags;
    internal static UInt32 KnownTagCount;
    private static KnownTagCache();
}
internal class MS.Internal.Ink.InkSerializedFormat.LZCodec : object {
    private Byte[] _ringBuffer;
    private int _maxMatchLength;
    private int _flags;
    private int _currentRingBufferPosition;
    private static int FirstMaxMatchLength;
    private static int RingBufferLength;
    private static int MaxLiteralLength;
    private static LZCodec();
    internal Byte[] Uncompress(Byte[] input, int inputIndex);
}
internal static class MS.Internal.Ink.InkSerializedFormat.MathHelper : object {
    internal static int AbsNoThrow(int data);
    internal static long AbsNoThrow(long data);
}
internal class MS.Internal.Ink.InkSerializedFormat.MetricBlock : object {
    private MetricEntry _Entry;
    private UInt32 _Count;
    private UInt32 _size;
    public UInt32 MetricEntryCount { get; }
    public UInt32 Size { get; }
    public MetricEntry GetMetricEntryList();
    public UInt32 get_MetricEntryCount();
    public UInt32 get_Size();
    public void AddMetricEntry(MetricEntry newEntry);
    public MetricEntryType AddMetricEntry(StylusPointPropertyInfo property, KnownTagIndex tag);
    public UInt32 Pack(Stream strm);
    public bool CompareMetricBlock(MetricBlock metricColl, SetType& setType);
}
internal class MS.Internal.Ink.InkSerializedFormat.MetricEntry : object {
    private static int MAX_METRIC_DATA_BUFF;
    private KnownTagIndex _tag;
    private UInt32 _size;
    private MetricEntry _next;
    private Byte[] _data;
    private static MetricEntryList[] _metricEntryOptional;
    public static StylusPointPropertyInfo DefaultXMetric;
    public static StylusPointPropertyInfo DefaultYMetric;
    private static KnownTagIndex[] MetricEntry_Must;
    private static KnownTagIndex[] MetricEntry_Never;
    private static StylusPointPropertyInfo DefaultPropertyMetrics;
    public static MetricEntryList[] MetricEntry_Optional { get; }
    public KnownTagIndex Tag { get; public set; }
    public UInt32 Size { get; }
    public Byte[] Data { get; public set; }
    public MetricEntry Next { get; public set; }
    private static MetricEntry();
    public static MetricEntryList[] get_MetricEntry_Optional();
    public KnownTagIndex get_Tag();
    public void set_Tag(KnownTagIndex value);
    public UInt32 get_Size();
    public Byte[] get_Data();
    public void set_Data(Byte[] value);
    public bool Compare(MetricEntry metricEntry);
    public MetricEntry get_Next();
    public void set_Next(MetricEntry value);
    public void Add(MetricEntry next);
    public void Initialize(StylusPointPropertyInfo originalInfo, StylusPointPropertyInfo defaultInfo);
    public MetricEntryType CreateMetricEntry(StylusPointPropertyInfo propertyInfo, KnownTagIndex tag);
    private static bool IsValidMetricEntry(StylusPointPropertyInfo propertyInfo, KnownTagIndex tag, MetricEntryType& metricEntryType, UInt32& index);
}
internal class MS.Internal.Ink.InkSerializedFormat.MetricEntryList : ValueType {
    public KnownTagIndex Tag;
    public StylusPointPropertyInfo PropertyMetrics;
    public MetricEntryList(KnownTagIndex tag, StylusPointPropertyInfo prop);
}
internal enum MS.Internal.Ink.InkSerializedFormat.MetricEntryType : Enum {
    public int value__;
    public static MetricEntryType Optional;
    public static MetricEntryType Must;
    public static MetricEntryType Never;
    public static MetricEntryType Custom;
}
internal class MS.Internal.Ink.InkSerializedFormat.MultiByteCodec : object {
    internal void Encode(UInt32 data, List`1<byte> output);
    internal void SignEncode(int data, List`1<byte> output);
    internal UInt32 Decode(Byte[] input, int inputIndex, UInt32& data);
    internal UInt32 SignDecode(Byte[] input, int inputIndex, Int32& data);
}
internal static class MS.Internal.Ink.InkSerializedFormat.SerializationHelper : object {
    public static UInt32 VarSize(UInt32 Value);
    public static UInt32 Encode(Stream strm, UInt32 Value);
    public static UInt32 EncodeLarge(Stream strm, ulong ulValue);
    public static UInt32 SignEncode(Stream strm, int Value);
    public static UInt32 Decode(Stream strm, UInt32& dw);
    public static UInt32 DecodeLarge(Stream strm, UInt64& ull);
    public static UInt32 SignDecode(Stream strm, Int32& i);
    public static VarEnum ConvertToVarEnum(Type type, bool throwOnError);
}
internal enum MS.Internal.Ink.InkSerializedFormat.SetType : Enum {
    public int value__;
    public static SetType SubSet;
    public static SetType SuperSet;
}
internal class MS.Internal.Ink.InkSerializedFormat.StrokeCollectionSerializer : object {
    internal static double AvalonToHimetricMultiplier;
    internal static double HimetricToAvalonMultiplier;
    internal static TransformDescriptor IdentityTransformDescriptor;
    internal PersistenceFormat CurrentPersistenceFormat;
    internal CompressionMode CurrentCompressionMode;
    internal List`1<int> StrokeIds;
    private static Byte[] Base64HeaderBytes;
    private StrokeCollection _coreStrokes;
    private List`1<StrokeDescriptor> _strokeDescriptorTable;
    private List`1<TransformDescriptor> _transformTable;
    private List`1<DrawingAttributes> _drawingAttributesTable;
    private List`1<MetricBlock> _metricTable;
    private Vector _himetricSize;
    private Rect _inkSpaceRectangle;
    private Dictionary`2<Stroke, StrokeLookupEntry> _strokeLookupTable;
    private static StrokeCollectionSerializer();
    internal StrokeCollectionSerializer(StrokeCollection coreStrokes);
    internal void DecodeISF(Stream inkData);
    internal UInt32 LoadStrokeIds(Stream isfStream, UInt32 cbSize);
    private bool IsGIFData(Stream inkdata);
    private void ExamineStreamHeader(Stream inkdata, Boolean& fBase64, Boolean& fGif, UInt32& cbData);
    private void DecodeRawISF(Stream inputStream);
    private UInt32 LoadDrawAttrsTable(Stream strm, GuidList guidList, UInt32 cbSize);
    private UInt32 DecodeStrokeDescriptor(Stream strm, UInt32 cbSize, StrokeDescriptor& descr);
    private UInt32 DecodeStrokeDescriptorBlock(Stream strm, UInt32 cbSize);
    private UInt32 DecodeStrokeDescriptorTable(Stream strm, UInt32 cbSize);
    private UInt32 DecodeMetricTable(Stream strm, UInt32 cbSize);
    private UInt32 DecodeMetricBlock(Stream strm, UInt32 cbSize, MetricBlock& block);
    private UInt32 DecodeTransformTable(Stream strm, UInt32 cbSize, bool useDoubles);
    internal static UInt32 ReliableRead(Stream stream, Byte[] buffer, UInt32 requestedCount);
    private UInt32 DecodeTransformBlock(Stream strm, KnownTagIndex tag, UInt32 cbSize, bool useDoubles, TransformDescriptor& xform);
    private UInt32 DecodeInkSpaceRectangle(Stream strm, UInt32 cbSize);
    private Matrix LoadTransform(TransformDescriptor tdrd);
    private StylusPointPropertyInfo GetStylusPointPropertyInfo(Guid guid, KnownTagIndex tag, MetricBlock block);
    private StylusPointDescription BuildStylusPointDescription(StrokeDescriptor strd, MetricBlock block, GuidList guidList);
    internal void EncodeISF(Stream outputStream);
    private void StoreStrokeData(Stream localStream, GuidList guidList, UInt32& cumulativeEncodedSize, UInt32& localEncodedSize);
    internal static UInt32 SaveStrokeIds(StrokeCollection strokes, Stream strm, bool forceSave);
    private bool IsBase64Data(Stream data);
    private GuidList BuildGuidList();
    private void BuildStrokeGuidList(Stroke stroke, GuidList guidList);
    private byte GetCompressionAlgorithm();
    private UInt32 SerializePacketDescrTable(Stream strm);
    private UInt32 SerializeMetricTable(Stream strm);
    private UInt32 EncodeStrokeDescriptor(Stream strm, StrokeDescriptor strd);
    private UInt32 SerializeTransformTable(Stream strm);
    private UInt32 EncodeTransformDescriptor(Stream strm, TransformDescriptor xform, bool useDoubles);
    private UInt32 SerializeDrawingAttrsTable(Stream stream, GuidList guidList);
    private void BuildTables(GuidList guidList);
    [ConditionalAttribute("DEBUG_ISF")]
private static void ISFDebugTrace(string message);
    internal static string ISFDebugMessage(string debugMessage);
}
internal class MS.Internal.Ink.InkSerializedFormat.StrokeDescriptor : object {
    private List`1<KnownTagIndex> _strokeDescriptor;
    private UInt32 _Size;
    public UInt32 Size { get; public set; }
    public List`1<KnownTagIndex> Template { get; }
    public UInt32 get_Size();
    public void set_Size(UInt32 value);
    public List`1<KnownTagIndex> get_Template();
    public bool IsEqual(StrokeDescriptor strd);
}
internal static class MS.Internal.Ink.InkSerializedFormat.StrokeIdGenerator : object {
    internal static Int32[] GetStrokeIds(StrokeCollection strokes);
}
internal static class MS.Internal.Ink.InkSerializedFormat.StrokeSerializer : object {
    internal static UInt32 DecodeStroke(Stream stream, UInt32 size, GuidList guidList, StrokeDescriptor strokeDescriptor, StylusPointDescription stylusPointDescription, DrawingAttributes drawingAttributes, Matrix transform, Stroke& stroke);
    private static UInt32 DecodeISFIntoStroke(Stream stream, UInt32 totalBytesInStrokeBlockOfIsfStream, GuidList guidList, StrokeDescriptor strokeDescriptor, StylusPointDescription stylusPointDescription, Matrix transform, StylusPointCollection& stylusPoints, ExtendedPropertyCollection& extendedProperties);
    private static UInt32 LoadPackets(Stream inputStream, UInt32 totalBytesInStrokeBlockOfIsfStream, StylusPointDescription stylusPointDescription, Matrix transform, StylusPointCollection& stylusPoints);
    private static void FillButtonData(int pointCount, int buttonCount, int buttonIndex, Int32[] packets, Byte[] buttonData);
    internal static UInt32 EncodeStroke(Stroke stroke, Stream stream, byte compressionAlgorithm, GuidList guidList, StrokeLookupEntry strokeLookupEntry);
    internal static void BuildStrokeDescriptor(Stroke stroke, GuidList guidList, StrokeLookupEntry strokeLookupEntry, StrokeDescriptor& strokeDescriptor, MetricBlock& metricBlock);
    private static UInt32 SavePackets(Stroke stroke, Stream stream, StrokeLookupEntry strokeLookupEntry);
    private static UInt32 SavePacketPropertyData(Int32[] packetdata, Stream stream, Guid guid, Byte& algo);
}
internal class MS.Internal.Ink.InkSerializedFormat.TransformDescriptor : object {
    private Double[] _transform;
    private UInt32 _size;
    private KnownTagIndex _tag;
    public KnownTagIndex Tag { get; public set; }
    public UInt32 Size { get; public set; }
    public Double[] Transform { get; }
    public KnownTagIndex get_Tag();
    public void set_Tag(KnownTagIndex value);
    public UInt32 get_Size();
    public void set_Size(UInt32 value);
    public Double[] get_Transform();
    public bool Compare(TransformDescriptor that);
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.Ink.Lasso : object {
    private List`1<Point> _points;
    private Rect _bounds;
    private bool _incrementalLassoDirty;
    private static double MinDistance;
    internal Rect Bounds { get; internal set; }
    internal bool IsEmpty { get; }
    internal int PointCount { get; }
    internal Point Item { get; }
    internal bool IsIncrementalLassoDirty { get; internal set; }
    protected List`1<Point> PointsList { get; }
    private static Lasso();
    internal Rect get_Bounds();
    internal void set_Bounds(Rect value);
    internal bool get_IsEmpty();
    internal int get_PointCount();
    internal Point get_Item(int index);
    internal void AddPoints(IEnumerable`1<Point> points);
    internal void AddPoint(Point point);
    internal bool Contains(Point point);
    internal StrokeIntersection[] HitTest(StrokeNodeIterator iterator);
    private static void SortAndMerge(List`1& crossingList);
    private bool SegmentWithinLasso(StrokeNode strokeNode, double fIndex);
    private void ProduceHitTestResults(List`1<LassoCrossing> crossingList, List`1<StrokeIntersection> strokeIntersections);
    internal bool get_IsIncrementalLassoDirty();
    internal void set_IsIncrementalLassoDirty(bool value);
    protected List`1<Point> get_PointsList();
    protected virtual bool Filter(Point point);
    protected virtual void AddPointImpl(Point point);
}
internal static class MS.Internal.Ink.Native : object {
    internal static UInt32 SizeOfInt;
    internal static UInt32 SizeOfUInt;
    internal static UInt32 SizeOfUShort;
    internal static UInt32 SizeOfByte;
    internal static UInt32 SizeOfFloat;
    internal static UInt32 SizeOfDouble;
    internal static UInt32 SizeOfGuid;
    internal static UInt32 SizeOfDecimal;
    internal static int BitsPerByte;
    internal static int BitsPerShort;
    internal static int BitsPerInt;
    internal static int BitsPerLong;
    internal static int MaxFloatToIntValue;
    private static Native();
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.Ink.Quad : ValueType {
    private static Quad s_empty;
    private Point _A;
    private Point _B;
    private Point _C;
    private Point _D;
    internal static Quad Empty { get; }
    internal Point A { get; internal set; }
    internal Point B { get; internal set; }
    internal Point C { get; internal set; }
    internal Point D { get; internal set; }
    internal Point Item { get; }
    internal bool IsEmpty { get; }
    internal Rect Bounds { get; }
    internal Quad(Point a, Point b, Point c, Point d);
    private static Quad();
    internal static Quad get_Empty();
    internal Point get_A();
    internal void set_A(Point value);
    internal Point get_B();
    internal void set_B(Point value);
    internal Point get_C();
    internal void set_C(Point value);
    internal Point get_D();
    internal void set_D(Point value);
    internal Point get_Item(int index);
    internal bool get_IsEmpty();
    internal void GetPoints(List`1<Point> pointBuffer);
    internal Rect get_Bounds();
}
internal class MS.Internal.Ink.SingleLoopLasso : Lasso {
    private bool _hasLoop;
    private Rect _prevBounds;
    private static double NoIntersection;
    private static SingleLoopLasso();
    protected virtual bool Filter(Point point);
    protected virtual void AddPointImpl(Point point);
    private bool GetIntersectionWithExistingLasso(Point point, Double& bIndex);
    private static double FindIntersection(Vector hitBegin, Vector hitEnd, Vector orgBegin, Vector orgEnd);
    internal static double AdjustFIndex(double findex);
}
internal class MS.Internal.Ink.StrokeFIndices : ValueType {
    private static StrokeFIndices s_empty;
    private static StrokeFIndices s_full;
    private double _beginFIndex;
    private double _endFIndex;
    internal static double BeforeFirst { get; }
    internal static double AfterLast { get; }
    internal double BeginFIndex { get; internal set; }
    internal double EndFIndex { get; internal set; }
    internal static StrokeFIndices Empty { get; }
    internal static StrokeFIndices Full { get; }
    internal bool IsEmpty { get; }
    internal bool IsFull { get; }
    internal StrokeFIndices(double beginFIndex, double endFIndex);
    private static StrokeFIndices();
    internal static double get_BeforeFirst();
    internal static double get_AfterLast();
    internal double get_BeginFIndex();
    internal void set_BeginFIndex(double value);
    internal double get_EndFIndex();
    internal void set_EndFIndex(double value);
    public virtual string ToString();
    public sealed virtual bool Equals(StrokeFIndices strokeFIndices);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(StrokeFIndices sfiLeft, StrokeFIndices sfiRight);
    public static bool op_Inequality(StrokeFIndices sfiLeft, StrokeFIndices sfiRight);
    internal static string GetStringRepresentation(double fIndex);
    internal static StrokeFIndices get_Empty();
    internal static StrokeFIndices get_Full();
    internal bool get_IsEmpty();
    internal bool get_IsFull();
    internal int CompareTo(StrokeFIndices fIndices);
}
internal class MS.Internal.Ink.StrokeInfo : object {
    private Stroke _stroke;
    private Rect _bounds;
    private double _hitWeight;
    private bool _isHit;
    private bool _isDirty;
    private StylusPointCollection _stylusPoints;
    private double _totalWeight;
    private bool _totalWeightCached;
    internal Stroke Stroke { get; }
    internal Rect StrokeBounds { get; }
    internal bool IsDirty { get; internal set; }
    internal bool IsHit { get; internal set; }
    internal StylusPointCollection StylusPoints { get; }
    internal double HitWeight { get; internal set; }
    internal double TotalWeight { get; }
    internal StrokeInfo(Stroke stroke);
    internal Stroke get_Stroke();
    internal Rect get_StrokeBounds();
    internal bool get_IsDirty();
    internal void set_IsDirty(bool value);
    internal bool get_IsHit();
    internal void set_IsHit(bool value);
    internal StylusPointCollection get_StylusPoints();
    internal double get_HitWeight();
    internal void set_HitWeight(double value);
    internal double get_TotalWeight();
    internal double GetPointWeight(int index);
    internal void Detach();
    private void OnStylusPointsChanged(object sender, EventArgs args);
    private void OnStylusPointsReplaced(object sender, StylusPointsReplacedEventArgs args);
    private void OnStrokeDrawingAttributesChanged(object sender, PropertyDataChangedEventArgs args);
    private void OnDrawingAttributesReplaced(object sender, DrawingAttributesReplacedEventArgs args);
    private void Invalidate();
}
internal class MS.Internal.Ink.StrokeNode : ValueType {
    private StrokeNodeOperations _operations;
    private int _index;
    private StrokeNodeData _thisNode;
    private StrokeNodeData _lastNode;
    private bool _isQuadCached;
    private Quad _connectingQuad;
    private bool _isLastNode;
    internal Point Position { get; }
    internal Point PreviousPosition { get; }
    internal float PressureFactor { get; }
    internal float PreviousPressureFactor { get; }
    internal bool IsEllipse { get; }
    internal bool IsLastNode { get; }
    internal int Index { get; }
    internal bool IsValid { get; }
    private Quad ConnectingQuad { get; }
    internal StrokeNode(StrokeNodeOperations operations, int index, StrokeNodeData nodeData, StrokeNodeData lastNodeData, bool isLastNode);
    internal Point get_Position();
    internal Point get_PreviousPosition();
    internal float get_PressureFactor();
    internal float get_PreviousPressureFactor();
    internal bool get_IsEllipse();
    internal bool get_IsLastNode();
    internal Rect GetBounds();
    internal Rect GetBoundsConnected();
    internal void GetContourPoints(List`1<Point> pointBuffer);
    internal void GetPreviousContourPoints(List`1<Point> pointBuffer);
    internal Quad GetConnectingQuad();
    internal void GetPointsAtStartOfSegment(List`1<Point> abPoints, List`1<Point> dcPoints);
    internal void GetPointsAtEndOfSegment(List`1<Point> abPoints, List`1<Point> dcPoints);
    internal void GetPointsAtMiddleSegment(StrokeNode previous, double angleBetweenNodes, List`1<Point> abPoints, List`1<Point> dcPoints, Boolean& missingIntersection);
    internal static Point GetIntersection(Point line1Start, Point line1End, Point line2Start, Point line2End);
    internal bool HitTest(StrokeNode hitNode);
    internal StrokeFIndices CutTest(StrokeNode hitNode);
    internal StrokeFIndices CutTest(Point begin, Point end);
    private StrokeFIndices BindFIndices(StrokeFIndices fragment);
    internal int get_Index();
    private StrokeFIndices BindFIndicesForLassoHitTest(StrokeFIndices fragment);
    internal bool get_IsValid();
    private Quad get_ConnectingQuad();
    private IEnumerable`1<ContourSegment> GetContourSegments();
    internal Point GetPointAt(double findex);
}
internal class MS.Internal.Ink.StrokeNodeData : ValueType {
    private static StrokeNodeData s_empty;
    private Point _position;
    private float _pressure;
    internal static StrokeNodeData Empty { get; }
    internal bool IsEmpty { get; }
    internal Point Position { get; }
    internal float PressureFactor { get; }
    internal StrokeNodeData(Point position);
    internal StrokeNodeData(Point position, float pressure);
    private static StrokeNodeData();
    internal static StrokeNodeData get_Empty();
    internal bool get_IsEmpty();
    internal Point get_Position();
    internal float get_PressureFactor();
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.Ink.StrokeNodeIterator : object {
    private bool _usePressure;
    private StrokeNodeOperations _operations;
    private StylusPointCollection _stylusPoints;
    internal int Count { get; }
    internal StrokeNode Item { get; }
    internal StrokeNode Item { get; }
    internal StrokeNodeIterator(StylusShape nodeShape);
    internal StrokeNodeIterator(DrawingAttributes drawingAttributes);
    internal StrokeNodeIterator(StylusPointCollection stylusPoints, StrokeNodeOperations operations, bool usePressure);
    internal static StrokeNodeIterator GetIterator(Stroke stroke, DrawingAttributes drawingAttributes);
    internal static StrokeNodeIterator GetIterator(StylusPointCollection stylusPoints, DrawingAttributes drawingAttributes);
    private static float GetNormalizedPressureFactor(float stylusPointPressureFactor);
    internal StrokeNodeIterator GetIteratorForNextSegment(StylusPointCollection stylusPoints);
    internal StrokeNodeIterator GetIteratorForNextSegment(Point[] points);
    internal int get_Count();
    internal StrokeNode get_Item(int index);
    internal StrokeNode get_Item(int index, int previousIndex);
}
internal class MS.Internal.Ink.StrokeNodeOperations : object {
    private Rect _shapeBounds;
    protected Vector[] _vertices;
    internal bool IsNodeShapeEllipse { get; }
    internal StrokeNodeOperations(StylusShape nodeShape);
    internal static StrokeNodeOperations CreateInstance(StylusShape nodeShape);
    internal virtual bool get_IsNodeShapeEllipse();
    internal Rect GetNodeBounds(StrokeNodeData node);
    internal void GetNodeContourPoints(StrokeNodeData node, List`1<Point> pointBuffer);
    [IteratorStateMachineAttribute("MS.Internal.Ink.StrokeNodeOperations/<GetContourSegments>d__6")]
internal virtual IEnumerable`1<ContourSegment> GetContourSegments(StrokeNodeData node, Quad quad);
    internal virtual IEnumerable`1<ContourSegment> GetNonBezierContourSegments(StrokeNodeData beginNode, StrokeNodeData endNode);
    internal virtual Quad GetConnectingQuad(StrokeNodeData beginNode, StrokeNodeData endNode);
    internal virtual bool HitTest(StrokeNodeData beginNode, StrokeNodeData endNode, Quad quad, Point hitBeginPoint, Point hitEndPoint);
    internal virtual bool HitTest(StrokeNodeData beginNode, StrokeNodeData endNode, Quad quad, IEnumerable`1<ContourSegment> hitContour);
    internal virtual StrokeFIndices CutTest(StrokeNodeData beginNode, StrokeNodeData endNode, Quad quad, Point hitBeginPoint, Point hitEndPoint);
    internal virtual StrokeFIndices CutTest(StrokeNodeData beginNode, StrokeNodeData endNode, Quad quad, IEnumerable`1<ContourSegment> hitContour);
    private double ClipTest(Vector spineVector, double pressureDelta, Vector hitBegin, Vector hitEnd);
    private double ClipTestArc(Vector spineVector, double pressureDelta, Vector hitCenter, Vector hitRadius);
    internal Vector[] GetVertices();
    private bool HitTestPolygonContourSegments(IEnumerable`1<ContourSegment> hitContour, StrokeNodeData beginNode, StrokeNodeData endNode);
    private bool HitTestInkContour(IEnumerable`1<ContourSegment> hitContour, Quad quad, StrokeNodeData beginNode, StrokeNodeData endNode);
    private bool HitTestStrokeNodes(ContourSegment hitSegment, StrokeNodeData beginNode, StrokeNodeData endNode, StrokeFIndices& result);
    private double CalculateClipLocation(ContourSegment hitSegment, StrokeNodeData beginNode, Vector spineVector, double pressureDelta);
    protected bool IsInvalidCutTestResult(StrokeFIndices result);
    internal static bool HitTestPolygonSegment(Vector[] vertices, Vector hitBegin, Vector hitEnd);
    internal static bool HitTestQuadSegment(Quad quad, Point hitBegin, Point hitEnd);
    internal static bool HitTestPolygonCircle(Vector[] vertices, Vector center, Vector radius);
    internal static bool HitTestQuadCircle(Quad quad, Point center, Vector radius);
    internal static HitResult WhereIsSegmentAboutSegment(Vector hitBegin, Vector hitEnd, Vector orgBegin, Vector orgEnd);
    internal static HitResult WhereIsCircleAboutSegment(Vector center, Vector radius, Vector segBegin, Vector segEnd);
    internal static HitResult WhereIsVectorAboutVector(Vector vector1, Vector vector2);
    internal static HitResult WhereIsVectorAboutArc(Vector hitVector, Vector arcBegin, Vector arcEnd);
    internal static Vector TurnLeft(Vector vector);
    internal static Vector TurnRight(Vector vector);
    internal static bool IsOutside(HitResult hitResult, HitResult prevHitResult);
    internal static double GetPositionBetweenLines(Vector linesVector, Vector nextLine, Vector hitPoint);
    internal static double GetProjectionFIndex(Vector begin, Vector end);
    internal static Vector GetProjection(Vector begin, Vector end);
    internal static Vector GetNearest(Vector begin, Vector end);
    internal static double AdjustFIndex(double findex);
}
internal static class MS.Internal.Ink.StrokeRenderer : object {
    internal static double HighlighterOpacity;
    internal static byte SolidStrokeAlpha;
    internal static Point ArcToMarker;
    private static StrokeRenderer();
    internal static void CalcGeometryAndBoundsWithTransform(StrokeNodeIterator iterator, DrawingAttributes drawingAttributes, MatrixTypes stylusTipMatrixType, bool calculateBounds, Geometry& geometry, Rect& bounds);
    [FriendAccessAllowedAttribute]
internal static void CalcGeometryAndBounds(StrokeNodeIterator iterator, DrawingAttributes drawingAttributes, bool calculateBounds, Geometry& geometry, Rect& bounds);
    private static void RenderTwoStrokeNodes(StreamGeometryContext context, StrokeNode strokeNodePrevious, Rect strokeNodePreviousBounds, StrokeNode strokeNodeCurrent, Rect strokeNodeCurrentBounds, List`1<Point> pointBuffer1, List`1<Point> pointBuffer2, List`1<Point> pointBuffer3);
    private static void ReverseDCPointsRenderAndClear(StreamGeometryContext context, List`1<Point> abPoints, List`1<Point> dcPoints, List`1<Point> polyLinePoints, bool isEllipse, bool clear);
    private static RectCompareResult FuzzyContains(Rect rect1, Rect rect2, double percentIntersect);
    private static void AddFigureToStreamGeometryContext(StreamGeometryContext context, List`1<Point> points, bool isBezierFigure);
    private static void AddPolylineFigureToStreamGeometryContext(StreamGeometryContext context, List`1<Point> abPoints, List`1<Point> dcPoints);
    private static void AddArcToFigureToStreamGeometryContext(StreamGeometryContext context, List`1<Point> abPoints, List`1<Point> dcPoints, List`1<Point> polyLinePoints);
    private static double GetAngleDeltaFromLast(Point previousPosition, Point currentPosition, Double& lastAngle);
    private static double GetAngleBetween(Point previousPosition, Point currentPosition);
    internal static DrawingAttributes GetHighlighterAttributes(Stroke stroke, DrawingAttributes da);
    internal static Color GetHighlighterColor(Color color);
}
internal static class MS.Internal.Interop.TipTsfHelper : object {
    private static bool s_PlatformSupported;
    [ThreadStaticAttribute]
private static DispatcherOperation s_KbOperation;
    private static TipTsfHelper();
    private static bool CheckAndDispatchKbOperation(Action`1<DependencyObject> kbCall, DependencyObject focusedObject);
    internal static void Show(DependencyObject focusedObject);
    internal static void Hide(DependencyObject focusedObject);
    private static bool ShouldShow(DependencyObject focusedObject);
    private static HwndSource GetHwndSource(DependencyObject focusedObject);
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.IO.Packaging.ByteRangeDownloader : object {
    private bool _firstRequestMade;
    private bool _disposed;
    private object _syncObject;
    private bool _erroredOut;
    private Exception _erroredOutException;
    private Uri _requestedUri;
    private RequestCachePolicy _cachePolicy;
    private IWebProxy _proxy;
    private ICredentials _credentials;
    private CookieContainer _cookieContainer;
    private SafeWaitHandle _eventHandle;
    private Mutex _fileMutex;
    private Stream _tempFileStream;
    private ArrayList _byteRangesAvailable;
    private ArrayList _requestsOnWait;
    private Int32[0...,0...] _byteRangesInProgress;
    private HttpWebRequest _webRequest;
    private Byte[] _buffer;
    private static int WriteBufferSize;
    private static int TimeOut;
    private static int Offset_Index;
    private static int Length_Index;
    private static string ByteRangeUnit;
    private static string ContentRangeHeader;
    unknown IWebProxy Proxy {internal set; }
    unknown ICredentials Credentials {internal set; }
    unknown RequestCachePolicy CachePolicy {internal set; }
    internal Mutex FileMutex { get; }
    internal bool ErroredOut { get; }
    internal ByteRangeDownloader(Uri requestedUri, string tempFileName, SafeWaitHandle eventHandle);
    internal ByteRangeDownloader(Uri requestedUri, Stream tempStream, SafeWaitHandle eventHandle, Mutex fileMutex);
    private ByteRangeDownloader(Uri requestedUri, SafeWaitHandle eventHandle);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    internal Int32[0...,0...] GetDownloadedByteRanges();
    internal void RequestByteRanges(Int32[0...,0...] byteRanges);
    internal static Int32[0...,0...] ConvertByteRanges(Int32[] inByteRanges);
    internal static Int32[] ConvertByteRanges(Int32[0...,0...] inByteRanges);
    internal void set_Proxy(IWebProxy value);
    internal void set_Credentials(ICredentials value);
    internal void set_CachePolicy(RequestCachePolicy value);
    internal Mutex get_FileMutex();
    internal bool get_ErroredOut();
    private void CheckDisposed();
    private void CheckErroredOutCondition();
    private HttpWebRequest CreateHttpWebRequest(Int32[0...,0...] byteRanges);
    private void RaiseEvent(bool throwExceptionOnError);
    private void ResponseCallback(IAsyncResult ar);
    private bool Write(Stream s, int offset, int length);
    private bool WriteByteRange(HttpWebResponse response, int offset, int length);
    private void ProcessWaitQueue();
    private static void CheckOneDimensionalByteRanges(Int32[] byteRanges);
    private static void CheckTwoDimensionalByteRanges(Int32[0...,0...] byteRanges);
    private static bool CheckContentRange(WebHeaderCollection responseHeaders, int beginOffset, Int32& endOffset);
}
internal class MS.Internal.IO.Packaging.DeobfuscatingStream : Stream {
    private Stream _obfuscatedStream;
    private Byte[] _guid;
    private bool _ownObfuscatedStream;
    private static long ObfuscatedLength;
    public long Position { get; public set; }
    public long Length { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    internal DeobfuscatingStream(Stream obfuscatedStream, Uri streamUri, bool leaveOpen);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long newLength);
    public virtual void Flush();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long get_Length();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    protected virtual void Dispose(bool disposing);
    private void CheckDisposed();
    private void Deobfuscate(Byte[] buffer, int offset, int count, long readPosition);
    private static Byte[] GetGuidByteArray(string guidString);
}
internal class MS.Internal.IO.Packaging.NetStream : Stream {
    private Uri _uri;
    private WebRequest _originalRequest;
    private Stream _tempFileStream;
    private long _position;
    private object _syncObject;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _disposed;
    private static int _readTimeOut;
    private static int _additionalRequestMinSize;
    private static int _bufferSize;
    private static int _tempFileSyncTimeout;
    private UInt32 _additionalRequestThreshold;
    private Stream _responseStream;
    private Byte[] _readBuf;
    private string _tempFileName;
    private long _fullStreamLength;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _fullDownloadComplete;
    private long _highWaterMark;
    private EventWaitHandle[] _readEventHandles;
    private Mutex _tempFileMutex;
    private bool _allowByteRangeRequests;
    private ByteRangeDownloader _byteRangeDownloader;
    private bool _inAdditionalRequest;
    private ArrayList _byteRangesAvailable;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Position { get; public set; }
    public long Length { get; }
    internal NetStream(Stream responseStream, long fullStreamLength, Uri uri, WebRequest originalRequest, WebResponse originalResponse);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void SetLength(long newLength);
    public virtual void Write(Byte[] buf, int offset, int count);
    public virtual long get_Length();
    public virtual void Flush();
    protected virtual void Dispose(bool disposing);
    private void StartFullDownload();
    private void CheckDisposed();
    private void ReadCallBack(IAsyncResult ar);
    private void EnsureDownloader();
    private void MakeByteRangeRequest(Block block);
    private void GetByteRangeData();
    private int BytesInByteRangeAvailable(Block block);
    private int TrimByteRangeRequest(Block block);
    private void MergeByteRanges(ArrayList ranges);
    private int HandleByteRangeReadEvent(Block block);
    private int HandleFullDownloadReadEvent(Block block);
    private int GetData(Block block);
    private void TrimBlockToStreamLength(Block block);
    private void ReleaseFullDownloadResources();
    private void FreeByteRangeDownloader();
    private void FreeTempFile();
}
[FriendAccessAllowedAttribute]
internal static class MS.Internal.IO.Packaging.PreloadedPackages : object {
    private static HybridDictionary _packagePairs;
    private static object _globalLock;
    private static PreloadedPackages();
    internal static Package GetPackage(Uri uri);
    internal static Package GetPackage(Uri uri, Boolean& threadSafe);
    internal static void AddPackage(Uri uri, Package package);
    internal static void AddPackage(Uri uri, Package package, bool threadSafe);
    internal static void RemovePackage(Uri uri);
    internal static void Clear();
    private static void ValidateUriKey(Uri uri);
}
internal class MS.Internal.IO.Packaging.PseudoWebRequest : WebRequest {
    private Uri _uri;
    private Uri _innerUri;
    private Uri _partName;
    private Package _cacheEntry;
    private string _connectionGroupName;
    private string _contentType;
    private int _contentLength;
    private string _method;
    private ICredentials _credentials;
    private WebHeaderCollection _headers;
    private bool _preAuthenticate;
    private IWebProxy _proxy;
    private int _timeout;
    private bool _useDefaultCredentials;
    public RequestCachePolicy CachePolicy { get; public set; }
    public string ConnectionGroupName { get; public set; }
    public long ContentLength { get; public set; }
    public string ContentType { get; public set; }
    public ICredentials Credentials { get; public set; }
    public WebHeaderCollection Headers { get; public set; }
    public string Method { get; public set; }
    public bool PreAuthenticate { get; public set; }
    public IWebProxy Proxy { get; public set; }
    public int Timeout { get; public set; }
    public bool UseDefaultCredentials { get; public set; }
    internal PseudoWebRequest(Uri uri, Uri packageUri, Uri partUri, Package cacheEntry);
    public virtual Stream GetRequestStream();
    public virtual WebResponse GetResponse();
    public virtual RequestCachePolicy get_CachePolicy();
    public virtual void set_CachePolicy(RequestCachePolicy value);
    public virtual string get_ConnectionGroupName();
    public virtual void set_ConnectionGroupName(string value);
    public virtual long get_ContentLength();
    public virtual void set_ContentLength(long value);
    public virtual string get_ContentType();
    public virtual void set_ContentType(string value);
    public virtual ICredentials get_Credentials();
    public virtual void set_Credentials(ICredentials value);
    public virtual WebHeaderCollection get_Headers();
    public virtual void set_Headers(WebHeaderCollection value);
    public virtual string get_Method();
    public virtual void set_Method(string value);
    public virtual bool get_PreAuthenticate();
    public virtual void set_PreAuthenticate(bool value);
    public virtual IWebProxy get_Proxy();
    public virtual void set_Proxy(IWebProxy value);
    public virtual int get_Timeout();
    public virtual void set_Timeout(int value);
    public virtual bool get_UseDefaultCredentials();
    public virtual void set_UseDefaultCredentials(bool value);
    private bool IsScheme(string schemeName);
    private void SetDefaults();
}
internal class MS.Internal.IO.Packaging.ResponseStream : Stream {
    private bool _closed;
    private Stream _innerStream;
    private Package _container;
    private Stream _owningStream;
    private PackWebResponse _response;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Position { get; public set; }
    public long Length { get; }
    internal ResponseStream(Stream s, PackWebResponse response, Stream owningStream, Package container);
    internal ResponseStream(Stream s, PackWebResponse response);
    private void Init(Stream s, PackWebResponse response, Stream owningStream, Package container);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long newLength);
    public virtual void Write(Byte[] buf, int offset, int count);
    public virtual void Flush();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long get_Length();
    protected virtual void Dispose(bool disposing);
    private void CheckDisposed();
}
internal class MS.Internal.IO.Packaging.SynchronizingStream : Stream {
    private Stream _baseStream;
    private object _syncRoot;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Position { get; public set; }
    public long Length { get; }
    internal SynchronizingStream(Stream stream, object syncRoot);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual void WriteByte(byte b);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long newLength);
    public virtual void Write(Byte[] buf, int offset, int count);
    public virtual void Flush();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long get_Length();
    protected virtual void Dispose(bool disposing);
    private void CheckDisposed();
}
internal enum MS.Internal.ItemClass : Enum {
    public byte value__;
    public static ItemClass DigitClass;
    public static ItemClass ANClass;
    public static ItemClass CSClass;
    public static ItemClass ESClass;
    public static ItemClass ETClass;
    public static ItemClass StrongClass;
    public static ItemClass WeakClass;
    public static ItemClass SimpleMarkClass;
    public static ItemClass ComplexMarkClass;
    public static ItemClass ControlClass;
    public static ItemClass JoinerClass;
    public static ItemClass NumberSignClass;
    public static ItemClass MaxClass;
}
internal interface MS.Internal.IVisual3DContainer {
    public abstract virtual void AddChild(Visual3D child);
    public abstract virtual void RemoveChild(Visual3D child);
    public abstract virtual int GetChildrenCount();
    public abstract virtual Visual3D GetChild(int index);
    public abstract virtual void VerifyAPIReadOnly();
    public abstract virtual void VerifyAPIReadOnly(DependencyObject other);
    public abstract virtual void VerifyAPIReadWrite();
    public abstract virtual void VerifyAPIReadWrite(DependencyObject other);
}
[FriendAccessAllowedAttribute]
internal static class MS.Internal.KnownBoxes.FillRuleBoxes : object {
    internal static object EvenOddBox;
    internal static object NonzeroBox;
    private static FillRuleBoxes();
    internal static object Box(FillRule value);
}
[FriendAccessAllowedAttribute]
internal static class MS.Internal.KnownBoxes.VisibilityBoxes : object {
    internal static object VisibleBox;
    internal static object HiddenBox;
    internal static object CollapsedBox;
    private static VisibilityBoxes();
    internal static object Box(Visibility value);
}
internal enum MS.Internal.LanguageTags : Enum {
    public int value__;
    public static LanguageTags Abaza;
    public static LanguageTags Abkhazian;
    public static LanguageTags Adyghe;
    public static LanguageTags Afrikaans;
    public static LanguageTags Afar;
    public static LanguageTags Agaw;
    public static LanguageTags Altai;
    public static LanguageTags Amharic;
    public static LanguageTags Arabic;
    public static LanguageTags Aari;
    public static LanguageTags Arakanese;
    public static LanguageTags Assamese;
    public static LanguageTags Athapaskan;
    public static LanguageTags Avar;
    public static LanguageTags Awadhi;
    public static LanguageTags Aymara;
    public static LanguageTags Azeri;
    public static LanguageTags Badaga;
    public static LanguageTags Baghelkhandi;
    public static LanguageTags Balkar;
    public static LanguageTags Baule;
    public static LanguageTags Berber;
    public static LanguageTags Bench;
    public static LanguageTags BibleCree;
    public static LanguageTags Belarussian;
    public static LanguageTags Bemba;
    public static LanguageTags Bengali;
    public static LanguageTags Bulgarian;
    public static LanguageTags Bhili;
    public static LanguageTags Bhojpuri;
    public static LanguageTags Bikol;
    public static LanguageTags Bilen;
    public static LanguageTags Blackfoot;
    public static LanguageTags Balochi;
    public static LanguageTags Balante;
    public static LanguageTags Balti;
    public static LanguageTags Bambara;
    public static LanguageTags Bamileke;
    public static LanguageTags Breton;
    public static LanguageTags Brahui;
    public static LanguageTags BrajBhasha;
    public static LanguageTags Burmese;
    public static LanguageTags Bashkir;
    public static LanguageTags Beti;
    public static LanguageTags Catalan;
    public static LanguageTags Cebuano;
    public static LanguageTags Chechen;
    public static LanguageTags ChahaGurage;
    public static LanguageTags Chattisgarhi;
    public static LanguageTags Chichewa;
    public static LanguageTags Chukchi;
    public static LanguageTags Chipewyan;
    public static LanguageTags Cherokee;
    public static LanguageTags Chuvash;
    public static LanguageTags Comorian;
    public static LanguageTags Coptic;
    public static LanguageTags Cree;
    public static LanguageTags Carrier;
    public static LanguageTags CrimeanTatar;
    public static LanguageTags ChurchSlavonic;
    public static LanguageTags Czech;
    public static LanguageTags Danish;
    public static LanguageTags Dargwa;
    public static LanguageTags WoodsCree;
    public static LanguageTags German;
    public static LanguageTags Default;
    public static LanguageTags Dogri;
    public static LanguageTags Divehi;
    public static LanguageTags Djerma;
    public static LanguageTags Dangme;
    public static LanguageTags Dinka;
    public static LanguageTags Dungan;
    public static LanguageTags Dzongkha;
    public static LanguageTags Ebira;
    public static LanguageTags EasternCree;
    public static LanguageTags Edo;
    public static LanguageTags Efik;
    public static LanguageTags Greek;
    public static LanguageTags English;
    public static LanguageTags Erzya;
    public static LanguageTags Spanish;
    public static LanguageTags Estonian;
    public static LanguageTags Basque;
    public static LanguageTags Evenki;
    public static LanguageTags Even;
    public static LanguageTags Ewe;
    public static LanguageTags FrenchAntillean;
    public static LanguageTags Farsi;
    public static LanguageTags Finnish;
    public static LanguageTags Fijian;
    public static LanguageTags Flemish;
    public static LanguageTags ForestNenets;
    public static LanguageTags Fon;
    public static LanguageTags Faroese;
    public static LanguageTags French;
    public static LanguageTags Frisian;
    public static LanguageTags Friulian;
    public static LanguageTags Futa;
    public static LanguageTags Fulani;
    public static LanguageTags Ga;
    public static LanguageTags Gaelic;
    public static LanguageTags Gagauz;
    public static LanguageTags Galician;
    public static LanguageTags Garshuni;
    public static LanguageTags Garhwali;
    public static LanguageTags Geez;
    public static LanguageTags Gilyak;
    public static LanguageTags Gumuz;
    public static LanguageTags Gondi;
    public static LanguageTags Greenlandic;
    public static LanguageTags Garo;
    public static LanguageTags Guarani;
    public static LanguageTags Gujarati;
    public static LanguageTags Haitian;
    public static LanguageTags Halam;
    public static LanguageTags Harauti;
    public static LanguageTags Hausa;
    public static LanguageTags Hawaiin;
    public static LanguageTags HammerBanna;
    public static LanguageTags Hiligaynon;
    public static LanguageTags Hindi;
    public static LanguageTags HighMari;
    public static LanguageTags Hindko;
    public static LanguageTags Ho;
    public static LanguageTags Harari;
    public static LanguageTags Croatian;
    public static LanguageTags Hungarian;
    public static LanguageTags Armenian;
    public static LanguageTags Igbo;
    public static LanguageTags Ijo;
    public static LanguageTags Ilokano;
    public static LanguageTags Indonesian;
    public static LanguageTags Ingush;
    public static LanguageTags Inuktitut;
    public static LanguageTags Irish;
    public static LanguageTags IrishTraditional;
    public static LanguageTags Icelandic;
    public static LanguageTags InariSami;
    public static LanguageTags Italian;
    public static LanguageTags Hebrew;
    public static LanguageTags Javanese;
    public static LanguageTags Yiddish;
    public static LanguageTags Japanese;
    public static LanguageTags Judezmo;
    public static LanguageTags Jula;
    public static LanguageTags Kabardian;
    public static LanguageTags Kachchi;
    public static LanguageTags Kalenjin;
    public static LanguageTags Kannada;
    public static LanguageTags Karachay;
    public static LanguageTags Georgian;
    public static LanguageTags Kazakh;
    public static LanguageTags Kebena;
    public static LanguageTags KhutsuriGeorgian;
    public static LanguageTags Khakass;
    public static LanguageTags KhantyKazim;
    public static LanguageTags Khmer;
    public static LanguageTags KhantyShurishkar;
    public static LanguageTags KhantyVakhi;
    public static LanguageTags Khowar;
    public static LanguageTags Kikuyu;
    public static LanguageTags Kirghiz;
    public static LanguageTags Kisii;
    public static LanguageTags Kokni;
    public static LanguageTags Kalmyk;
    public static LanguageTags Kamba;
    public static LanguageTags Kumaoni;
    public static LanguageTags Komo;
    public static LanguageTags Komso;
    public static LanguageTags Kanuri;
    public static LanguageTags Kodagu;
    public static LanguageTags KoreanOldHangul;
    public static LanguageTags Konkani;
    public static LanguageTags Kikongo;
    public static LanguageTags KomiPermyak;
    public static LanguageTags Korean;
    public static LanguageTags KomiZyrian;
    public static LanguageTags Kpelle;
    public static LanguageTags Krio;
    public static LanguageTags Karakalpak;
    public static LanguageTags Karelian;
    public static LanguageTags Karaim;
    public static LanguageTags Karen;
    public static LanguageTags Koorete;
    public static LanguageTags Kashmiri;
    public static LanguageTags Khasi;
    public static LanguageTags KildinSami;
    public static LanguageTags Kui;
    public static LanguageTags Kulvi;
    public static LanguageTags Kumyk;
    public static LanguageTags Kurdish;
    public static LanguageTags Kurukh;
    public static LanguageTags Kuy;
    public static LanguageTags Koryak;
    public static LanguageTags Ladin;
    public static LanguageTags Lahuli;
    public static LanguageTags Lak;
    public static LanguageTags Lambani;
    public static LanguageTags Lao;
    public static LanguageTags Latin;
    public static LanguageTags Laz;
    public static LanguageTags LCree;
    public static LanguageTags Ladakhi;
    public static LanguageTags Lezgi;
    public static LanguageTags Lingala;
    public static LanguageTags LowMari;
    public static LanguageTags Limbu;
    public static LanguageTags Lomwe;
    public static LanguageTags LowerSorbian;
    public static LanguageTags LuleSami;
    public static LanguageTags Lithuanian;
    public static LanguageTags Luba;
    public static LanguageTags Luganda;
    public static LanguageTags Luhya;
    public static LanguageTags Luo;
    public static LanguageTags Latvian;
    public static LanguageTags Majang;
    public static LanguageTags Makua;
    public static LanguageTags MalayalamTraditional;
    public static LanguageTags Mansi;
    public static LanguageTags Marathi;
    public static LanguageTags Marwari;
    public static LanguageTags Mbundu;
    public static LanguageTags Manchu;
    public static LanguageTags MooseCree;
    public static LanguageTags Mende;
    public static LanguageTags Meen;
    public static LanguageTags Mizo;
    public static LanguageTags Macedonian;
    public static LanguageTags Male;
    public static LanguageTags Malagasy;
    public static LanguageTags Malinke;
    public static LanguageTags MalayalamReformed;
    public static LanguageTags Malay;
    public static LanguageTags Mandinka;
    public static LanguageTags Mongolian;
    public static LanguageTags Manipuri;
    public static LanguageTags Maninka;
    public static LanguageTags ManxGaelic;
    public static LanguageTags Moksha;
    public static LanguageTags Moldavian;
    public static LanguageTags Mon;
    public static LanguageTags Moroccan;
    public static LanguageTags Maori;
    public static LanguageTags Maithili;
    public static LanguageTags Maltese;
    public static LanguageTags Mundari;
    public static LanguageTags NagaAssamese;
    public static LanguageTags Nanai;
    public static LanguageTags Naskapi;
    public static LanguageTags NCree;
    public static LanguageTags Ndebele;
    public static LanguageTags Ndonga;
    public static LanguageTags Nepali;
    public static LanguageTags Newari;
    public static LanguageTags NorwayHouseCree;
    public static LanguageTags Nisi;
    public static LanguageTags Niuean;
    public static LanguageTags Nkole;
    public static LanguageTags Nko;
    public static LanguageTags Dutch;
    public static LanguageTags Nogai;
    public static LanguageTags Norwegian;
    public static LanguageTags NorthernSami;
    public static LanguageTags NorthernTai;
    public static LanguageTags Esperanto;
    public static LanguageTags Nynorsk;
    public static LanguageTags OjiCree;
    public static LanguageTags Ojibway;
    public static LanguageTags Oriya;
    public static LanguageTags Oromo;
    public static LanguageTags Ossetian;
    public static LanguageTags PalestinianAramaic;
    public static LanguageTags Pali;
    public static LanguageTags Punjabi;
    public static LanguageTags Palpa;
    public static LanguageTags Pashto;
    public static LanguageTags PolytonicGreek;
    public static LanguageTags Pilipino;
    public static LanguageTags Palaung;
    public static LanguageTags Polish;
    public static LanguageTags Provencal;
    public static LanguageTags Portuguese;
    public static LanguageTags Chin;
    public static LanguageTags Rajasthani;
    public static LanguageTags RCree;
    public static LanguageTags RussianBuriat;
    public static LanguageTags Riang;
    public static LanguageTags RhaetoRomanic;
    public static LanguageTags Romanian;
    public static LanguageTags Romany;
    public static LanguageTags Rusyn;
    public static LanguageTags Ruanda;
    public static LanguageTags Russian;
    public static LanguageTags Sadri;
    public static LanguageTags Sanskrit;
    public static LanguageTags Santali;
    public static LanguageTags Sayisi;
    public static LanguageTags Sekota;
    public static LanguageTags Selkup;
    public static LanguageTags Sango;
    public static LanguageTags Shan;
    public static LanguageTags Sibe;
    public static LanguageTags Sidamo;
    public static LanguageTags SilteGurage;
    public static LanguageTags SkoltSami;
    public static LanguageTags Slovak;
    public static LanguageTags Slavey;
    public static LanguageTags Slovenian;
    public static LanguageTags Somali;
    public static LanguageTags Samoan;
    public static LanguageTags Sena;
    public static LanguageTags Sindhi;
    public static LanguageTags Sinhalese;
    public static LanguageTags Soninke;
    public static LanguageTags SodoGurage;
    public static LanguageTags Sotho;
    public static LanguageTags Albanian;
    public static LanguageTags Serbian;
    public static LanguageTags Saraiki;
    public static LanguageTags Serer;
    public static LanguageTags SouthSlavey;
    public static LanguageTags SouthernSami;
    public static LanguageTags Suri;
    public static LanguageTags Svan;
    public static LanguageTags Swedish;
    public static LanguageTags SwadayaAramaic;
    public static LanguageTags Swahili;
    public static LanguageTags Swazi;
    public static LanguageTags Sutu;
    public static LanguageTags Syriac;
    public static LanguageTags Tabasaran;
    public static LanguageTags Tajiki;
    public static LanguageTags Tamil;
    public static LanguageTags Tatar;
    public static LanguageTags THCree;
    public static LanguageTags Telugu;
    public static LanguageTags Tongan;
    public static LanguageTags Tigre;
    public static LanguageTags Tigrinya;
    public static LanguageTags Thai;
    public static LanguageTags Tahitian;
    public static LanguageTags Tibetan;
    public static LanguageTags Turkmen;
    public static LanguageTags Temne;
    public static LanguageTags Tswana;
    public static LanguageTags TundraNenets;
    public static LanguageTags Tonga;
    public static LanguageTags Todo;
    public static LanguageTags Turkish;
    public static LanguageTags Tsonga;
    public static LanguageTags TuroyoAramaic;
    public static LanguageTags Tulu;
    public static LanguageTags Tuvin;
    public static LanguageTags Twi;
    public static LanguageTags Udmurt;
    public static LanguageTags Ukrainian;
    public static LanguageTags Urdu;
    public static LanguageTags UpperSorbian;
    public static LanguageTags Uyghur;
    public static LanguageTags Uzbek;
    public static LanguageTags Venda;
    public static LanguageTags Vietnamese;
    public static LanguageTags Wa;
    public static LanguageTags Wagdi;
    public static LanguageTags WestCree;
    public static LanguageTags Welsh;
    public static LanguageTags Wolof;
    public static LanguageTags TaiLue;
    public static LanguageTags Xhosa;
    public static LanguageTags Yakut;
    public static LanguageTags Yoruba;
    public static LanguageTags YCree;
    public static LanguageTags YiClassic;
    public static LanguageTags YiModern;
    public static LanguageTags ChineseHongKong;
    public static LanguageTags ChinesePhonetic;
    public static LanguageTags ChineseSimplified;
    public static LanguageTags ChineseTraditional;
    public static LanguageTags Zande;
    public static LanguageTags Zulu;
}
internal class MS.Internal.LegacyPriorityQueue`1 : object {
    private T[] _heap;
    private int _count;
    private IComparer`1<T> _comparer;
    private static int DefaultCapacity;
    internal int Count { get; }
    internal T Top { get; }
    internal LegacyPriorityQueue`1(int capacity, IComparer`1<T> comparer);
    internal int get_Count();
    internal T get_Top();
    internal void Push(T value);
    internal void Pop();
    private static int HeapParent(int i);
    private static int HeapLeftChild(int i);
    private static int HeapRightFromLeft(int i);
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.LoadedOrUnloadedOperation : object {
    private DispatcherOperationCallback _callback;
    private DependencyObject _target;
    private bool _cancelled;
    internal LoadedOrUnloadedOperation(DispatcherOperationCallback callback, DependencyObject target);
    internal void DoWork();
    internal void Cancel();
}
internal enum MS.Internal.LockFlags : Enum {
    public int value__;
    public static LockFlags MIL_LOCK_READ;
    public static LockFlags MIL_LOCK_WRITE;
}
internal class MS.Internal.Media.ParserStreamGeometryContext : StreamGeometryContext {
    private static byte HighNibble;
    private static byte LowNibble;
    private static byte SetBool1;
    private static byte SetBool2;
    private static byte SetBool3;
    private static byte SetBool4;
    private BinaryWriter _bw;
    private Point _startPoint;
    private bool _isClosed;
    private bool _isFilled;
    private int _figureStreamPosition;
    internal bool FigurePending { get; }
    internal int CurrentStreamPosition { get; }
    internal ParserStreamGeometryContext(BinaryWriter bw);
    internal void SetFillRule(FillRule fillRule);
    public virtual void BeginFigure(Point startPoint, bool isFilled, bool isClosed);
    public virtual void LineTo(Point point, bool isStroked, bool isSmoothJoin);
    public virtual void QuadraticBezierTo(Point point1, Point point2, bool isStroked, bool isSmoothJoin);
    public virtual void BezierTo(Point point1, Point point2, Point point3, bool isStroked, bool isSmoothJoin);
    public virtual void PolyLineTo(IList`1<Point> points, bool isStroked, bool isSmoothJoin);
    public virtual void PolyQuadraticBezierTo(IList`1<Point> points, bool isStroked, bool isSmoothJoin);
    public virtual void PolyBezierTo(IList`1<Point> points, bool isStroked, bool isSmoothJoin);
    public virtual void ArcTo(Point point, Size size, double rotationAngle, bool isLargeArc, SweepDirection sweepDirection, bool isStroked, bool isSmoothJoin);
    internal bool get_FigurePending();
    internal int get_CurrentStreamPosition();
    internal void FinishFigure();
    internal virtual void DisposeCore();
    internal virtual void SetClosedState(bool closed);
    internal void MarkEOF();
    internal static void Deserialize(BinaryReader br, StreamGeometryContext sc, StreamGeometry geometry);
    private static void DeserializeFillRule(BinaryReader br, byte firstByte, StreamGeometry geometry);
    private static void DeserializeBeginFigure(BinaryReader br, byte firstByte, StreamGeometryContext sc);
    private static void DeserializeLineTo(BinaryReader br, byte firstByte, StreamGeometryContext sc);
    private static void DeserializeQuadraticBezierTo(BinaryReader br, byte firstByte, StreamGeometryContext sc);
    private static void DeserializeBezierTo(BinaryReader br, byte firstByte, StreamGeometryContext sc);
    private static void DeserializePolyLineTo(BinaryReader br, byte firstByte, StreamGeometryContext sc);
    private static void DeserializePolyQuadraticBezierTo(BinaryReader br, byte firstByte, StreamGeometryContext sc);
    private static void DeserializePolyBezierTo(BinaryReader br, byte firstByte, StreamGeometryContext sc);
    private static void DeserializeArcTo(BinaryReader br, byte firstByte, StreamGeometryContext sc);
    private static void UnPackBools(byte packedByte, Boolean& bool1, Boolean& bool2);
    private static void UnPackBools(byte packedByte, Boolean& bool1, Boolean& bool2, Boolean& bool3, Boolean& bool4);
    private static ParserGeometryContextOpCodes UnPackOpCode(byte packedByte);
    private static IList`1<Point> DeserializeListOfPointsAndTwoBools(BinaryReader br, byte firstByte, Boolean& bool1, Boolean& bool2);
    private static void DeserializePointAndTwoBools(BinaryReader br, byte firstByte, Point& point, Boolean& bool1, Boolean& bool2);
    private static double DeserializeDouble(BinaryReader br, bool isScaledInt);
    private static SweepDirection BoolToSweep(bool value);
    private static bool SweepToBool(SweepDirection sweep);
    private static FillRule BoolToFillRule(bool value);
    private static bool FillRuleToBool(FillRule fill);
    private void SerializePointAndTwoBools(ParserGeometryContextOpCodes opCode, Point point, bool bool1, bool bool2);
    private void SerializeListOfPointsAndTwoBools(ParserGeometryContextOpCodes opCode, IList`1<Point> points, bool bool1, bool bool2);
    private void SerializeDouble(double value, bool isScaledInt, int scaledIntValue);
    private static byte PackByte(ParserGeometryContextOpCodes opCode, bool bool1, bool bool2);
    private static byte PackByte(ParserGeometryContextOpCodes opCode, bool bool1, bool bool2, bool bool3, bool bool4);
}
[FriendAccessAllowedAttribute]
internal static class MS.Internal.Media.TextOptionsInternal : object {
    [FriendAccessAllowedAttribute]
internal static DependencyProperty TextHintingModeProperty;
    private static TextOptionsInternal();
    [FriendAccessAllowedAttribute]
public static void SetTextHintingMode(DependencyObject element, TextHintingMode value);
    [FriendAccessAllowedAttribute]
public static TextHintingMode GetTextHintingMode(DependencyObject element);
}
internal static class MS.Internal.Media.VisualTreeUtils : object {
    public static string BitmapEffectObsoleteMessage;
    internal static void PropagateFlags(DependencyObject element, VisualFlags flags, VisualProxyFlags proxyFlags);
    internal static void SetFlagsToRoot(DependencyObject element, bool value, VisualFlags flags);
    internal static DependencyObject FindFirstAncestorWithFlagsAnd(DependencyObject element, VisualFlags flags);
    internal static PointHitTestResult AsNearestPointHitTestResult(HitTestResult result);
    internal static void EnsureNonNullVisual(DependencyObject element);
    internal static void EnsureVisual(DependencyObject element);
    private static void EnsureVisual(DependencyObject element, bool allowNull);
    internal static void AsNonNullVisual(DependencyObject element, Visual& visual, Visual3D& visual3D);
    internal static void AsVisual(DependencyObject element, Visual& visual, Visual3D& visual3D);
    internal static bool AsVisualInternal(DependencyObject element, Visual& visual, Visual3D& visual3D);
    private static bool AsVisualHelper(DependencyObject element, Visual& visual, Visual3D& visual3D);
}
internal static class MS.Internal.Media.XamlSerializationHelper : object {
    private static double scaleFactor;
    private static double inverseScaleFactor;
    [FriendAccessAllowedAttribute]
internal static bool SerializePoint3D(BinaryWriter writer, string stringValues);
    [FriendAccessAllowedAttribute]
internal static bool SerializeVector3D(BinaryWriter writer, string stringValues);
    [FriendAccessAllowedAttribute]
internal static bool SerializePoint(BinaryWriter writer, string stringValue);
    internal static void WriteDouble(BinaryWriter writer, double value);
    internal static double ReadDouble(BinaryReader reader);
    internal static double ReadScaledInteger(BinaryReader reader);
    internal static bool CanConvertToInteger(double doubleValue, Int32& intValue);
}
[FlagsAttribute]
internal enum MS.Internal.Media3D.FaceType : Enum {
    public int value__;
    public static FaceType None;
    public static FaceType Front;
    public static FaceType Back;
}
internal class MS.Internal.Media3D.GeneralTransform2DTo3DTo2D : GeneralTransform {
    private bool _fInverse;
    private MeshGeometry3D _geometry;
    private Rect _visualBounds;
    private Rect _visualBrushBounds;
    private GeneralTransform _transform2D;
    private GeneralTransform _transform2DInverse;
    private Camera _camera;
    private Size _viewSize;
    private Rect3D _boundingRect;
    private Matrix3D _worldTransformation;
    private GeneralTransform3DTo2D _objectToViewport;
    private List`1<HitTestEdge> _validEdgesCache;
    private static double BUFFER_SIZE;
    public GeneralTransform Inverse { get; }
    internal Transform AffineTransform { get; }
    internal bool IsInverse { get; internal set; }
    internal GeneralTransform2DTo3DTo2D(Viewport2DVisual3D visual3D, Visual fromVisual);
    public virtual bool TryTransform(Point inPoint, Point& result);
    private bool TryInverseTransform(Point inPoint, Point& result);
    private bool HandleOffMesh(Point mousePos, Point& outPoint);
    private List`1<HitTestEdge> GrabValidEdges(Point[] visualTexCoordBounds);
    private void ProcessTriangle(Point3D[] p, Point[] uv, Point[] visualTexCoordBounds, List`1<HitTestEdge> edgeList, Dictionary`2<Edge, EdgeInfo> adjInformation, Point3D camPosObjSpace);
    private void ProcessVisualBoundsIntersections(Point3D[] p, Point[] uv, Point[] visualTexCoordBounds, List`1<HitTestEdge> edgeList);
    private void HandleCoincidentLines(Point visUV1, Point visUV2, Point3D tri3D1, Point3D tri3D2, Point triUV1, Point triUV2, List`1<HitTestEdge> edgeList);
    private double IntersectRayLine(Point o, Vector d, Point p1, Point p2, Boolean& coinc);
    private void ProcessTriangleEdges(Point3D[] p, Point[] uv, Point[] visualTexCoordBounds, PolygonSide polygonSide, List`1<HitTestEdge> edgeList, Dictionary`2<Edge, EdgeInfo> adjInformation);
    private void HandleSilhouetteEdge(Point uv1, Point uv2, Point3D p3D1, Point3D p3D2, Point[] bounds, List`1<HitTestEdge> edgeList);
    private bool IsPointInPolygon(Point[] polygon, Point p);
    private bool FindClosestIntersection(Point mousePos, List`1<HitTestEdge> edges, Point& finalPoint);
    private bool TryRegularTransform(Point inPoint, Point& result);
    public virtual Rect TransformBounds(Rect rect);
    public virtual GeneralTransform get_Inverse();
    [FriendAccessAllowedAttribute]
internal virtual Transform get_AffineTransform();
    internal bool get_IsInverse();
    internal void set_IsInverse(bool value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    private void CopyCommon(GeneralTransform2DTo3DTo2D transform);
}
internal class MS.Internal.Media3D.GeneralTransform3DTo2DTo3D : GeneralTransform3D {
    private GeneralTransform3DTo2D _transform3DTo2D;
    private GeneralTransform2DTo3D _transform2DTo3D;
    public GeneralTransform3D Inverse { get; }
    internal Transform3D AffineTransform { get; }
    internal GeneralTransform3DTo2DTo3D(GeneralTransform3DTo2D transform3DTo2D, GeneralTransform2DTo3D transform2DTo3D);
    public virtual bool TryTransform(Point3D inPoint, Point3D& result);
    public virtual GeneralTransform3D get_Inverse();
    [FriendAccessAllowedAttribute]
internal virtual Transform3D get_AffineTransform();
    public virtual Rect3D TransformBounds(Rect3D rect);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    private void CopyCommon(GeneralTransform3DTo2DTo3D transform);
}
internal class MS.Internal.Media3D.HitTestEdge : object {
    internal Point3D _p1;
    internal Point3D _p2;
    internal Point _uv1;
    internal Point _uv2;
    internal Point _p1Transformed;
    internal Point _p2Transformed;
    public HitTestEdge(Point3D p1, Point3D p2, Point uv1, Point uv2);
    public void Project(GeneralTransform3DTo2D objectToViewportTransform);
}
internal static class MS.Internal.Media3D.LineUtil : object {
    private static Int32[0...,0...] s_pairs;
    private static int s_pairsCount;
    private static LineUtil();
    public static void Transform(Matrix3D modelMatrix, Point3D& origin, Vector3D& direction, Boolean& isRay);
    private static void TransformSingular(Matrix3D& modelMatrix, Point3D& origin, Vector3D& direction);
    private static void ColumnsToAffinePointVector(Double[0...,0...] matrix, int col1, int col2, Point3D& origin, Vector3D& direction);
    private static void FindSmallestTwoDiagonal(Double[0...,0...] matrix, Int32& evec1, Int32& evec2);
    private static Double[0...,0...] TransformedLineMatrix(Matrix3D& modelMatrix, Point3D& origin, Vector3D& direction);
    private static Double[0...,0...] Square(Double[0...,0...] m);
    internal static bool ComputeLineTriangleIntersection(FaceType type, Point3D& origin, Vector3D& direction, Point3D& v0, Point3D& v1, Point3D& v2, Point& hitCoord, Double& dist);
    internal static bool ComputeLineBoxIntersection(Point3D& origin, Vector3D& direction, Rect3D& box, bool isRay);
}
internal static class MS.Internal.Media3D.M3DUtil : object {
    internal static Point3D Interpolate(Point3D& v0, Point3D& v1, Point3D& v2, Point& barycentric);
    private static void AddPointToBounds(Point3D& point, Rect3D& bounds);
    internal static Rect3D ComputeAxisAlignedBoundingBox(Point3DCollection positions);
    internal static Rect3D ComputeTransformedAxisAlignedBoundingBox(Rect3D& originalBox, Transform3D transform);
    internal static Rect3D ComputeTransformedAxisAlignedBoundingBox(Rect3D& originalBox, Matrix3D& matrix);
    internal static Rect3D ComputeTransformedAxisAlignedBoundingBoxAffine(Rect3D& originalBox, Matrix3D& matrix);
    internal static Rect3D ComputeTransformedAxisAlignedBoundingBoxNonAffine(Rect3D& originalBox, Matrix3D& matrix);
    internal static double GetAspectRatio(Size viewSize);
    internal static Point GetNormalizedPoint(Point point, Size size);
    internal static double RadiansToDegrees(double radians);
    internal static double DegreesToRadians(double degrees);
    internal static Matrix3D GetWorldToViewportTransform3D(Camera camera, Rect viewport);
    internal static Matrix3D GetHomogeneousToViewportTransform3D(Rect viewport);
    internal static Matrix GetHomogeneousToViewportTransform(Rect viewport);
    internal static Matrix3D GetWorldTransformationMatrix(Visual3D visual);
    internal static Matrix3D GetWorldTransformationMatrix(Visual3D visual3DStart, Viewport3DVisual& viewport);
    internal static bool TryTransformToViewport3DVisual(Visual3D visual3D, Viewport3DVisual& viewport, Matrix3D& matrix);
    internal static bool IsPointInTriangle(Point p, Point[] triUVVertices, Point3D[] tri3DVertices, Point3D& inters3DPoint);
}
internal enum MS.Internal.MediaPlayerErrors : Enum {
    public int value__;
    public static MediaPlayerErrors NS_E_WMP_LOGON_FAILURE;
    public static MediaPlayerErrors NS_E_WMP_CANNOT_FIND_FILE;
    public static MediaPlayerErrors NS_E_WMP_UNSUPPORTED_FORMAT;
    public static MediaPlayerErrors NS_E_WMP_DSHOW_UNSUPPORTED_FORMAT;
    public static MediaPlayerErrors NS_E_WMP_INVALID_ASX;
    public static MediaPlayerErrors NS_E_WMP_URLDOWNLOADFAILED;
}
internal class MS.Internal.MILAVInstruction : ValueType {
    internal IntPtr m_pMedia;
    internal MILAVInstructionType m_instType;
    internal nested_u u;
}
internal enum MS.Internal.MILAVInstructionType : Enum {
    public int value__;
    public static MILAVInstructionType eAVPlay;
    public static MILAVInstructionType eAVStop;
    public static MILAVInstructionType eAVPause;
    public static MILAVInstructionType eAVResume;
    public static MILAVInstructionType eAVSetSeek;
    public static MILAVInstructionType eAVGetVolume;
    public static MILAVInstructionType eAVSetVolume;
    public static MILAVInstructionType eAVGetState;
    public static MILAVInstructionType eAVHasVideo;
    public static MILAVInstructionType eAVHasAudio;
    public static MILAVInstructionType eAVWidth;
    public static MILAVInstructionType eAVHeight;
    public static MILAVInstructionType eAVMediaLength;
}
internal class MS.Internal.MILBitmapItem : ValueType {
    private UInt32 Size;
    private IntPtr Desc;
    private UInt32 DescSize;
    private IntPtr Data;
    private UInt32 DataSize;
    private UInt32 Cookie;
}
internal enum MS.Internal.MILCompoundStyle : Enum {
    public int value__;
    public static MILCompoundStyle MILCompoundStyleSingle;
    public static MILCompoundStyle MILCompoundStyleDouble;
    public static MILCompoundStyle MILCompoundStyleTriple;
    public static MILCompoundStyle MILCompoundStyleCustom;
    public static MILCompoundStyle MILCOMPOUNDSTYLE_FORCE_DWORD;
}
internal enum MS.Internal.MILDashStyle : Enum {
    public int value__;
    public static MILDashStyle MILDashStyleSolid;
    public static MILDashStyle MILDashStyleDash;
    public static MILDashStyle MILDashStyleDot;
    public static MILDashStyle MILDashStyleDashDot;
    public static MILDashStyle MILDashStyleDashDotDot;
    public static MILDashStyle MILDashStyleCustom;
    public static MILDashStyle MILDASHSTYLE_FORCE_DWORD;
}
internal enum MS.Internal.MILErrors : Enum {
    public int value__;
    public static MILErrors WGXHR_CLIPPEDTOEMPTY;
    public static MILErrors WGXHR_EMPTYFILL;
    public static MILErrors WGXHR_INTERNALTEMPORARYSUCCESS;
    public static MILErrors WGXHR_RESETSHAREDHANDLEMANAGER;
    public static MILErrors WGXERR_GENERIC_ERROR;
    public static MILErrors WGXERR_INVALIDPARAMETER;
    public static MILErrors WGXERR_OUTOFMEMORY;
    public static MILErrors WGXERR_NOTIMPLEMENTED;
    public static MILErrors WGXERR_ABORTED;
    public static MILErrors WGXERR_ACCESSDENIED;
    public static MILErrors WGXERR_VALUEOVERFLOW;
    public static MILErrors WGXERR_WRONGSTATE;
    public static MILErrors WGXERR_UNSUPPORTEDVERSION;
    public static MILErrors WGXERR_NOTINITIALIZED;
    public static MILErrors WGXERR_UNSUPPORTEDPIXELFORMAT;
    public static MILErrors WGXERR_UNSUPPORTED_OPERATION;
    public static MILErrors WGXERR_PALETTEUNAVAILABLE;
    public static MILErrors WGXERR_OBJECTBUSY;
    public static MILErrors WGXERR_INSUFFICIENTBUFFER;
    public static MILErrors WGXERR_WIN32ERROR;
    public static MILErrors WGXERR_SCANNER_FAILED;
    public static MILErrors WGXERR_SCREENACCESSDENIED;
    public static MILErrors WGXERR_DISPLAYSTATEINVALID;
    public static MILErrors WGXERR_NONINVERTIBLEMATRIX;
    public static MILErrors WGXERR_ZEROVECTOR;
    public static MILErrors WGXERR_TERMINATED;
    public static MILErrors WGXERR_BADNUMBER;
    public static MILErrors WGXERR_INTERNALERROR;
    public static MILErrors WGXERR_DISPLAYFORMATNOTSUPPORTED;
    public static MILErrors WGXERR_INVALIDCALL;
    public static MILErrors WGXERR_ALREADYLOCKED;
    public static MILErrors WGXERR_NOTLOCKED;
    public static MILErrors WGXERR_DEVICECANNOTRENDERTEXT;
    public static MILErrors WGXERR_GLYPHBITMAPMISSED;
    public static MILErrors WGXERR_MALFORMEDGLYPHCACHE;
    public static MILErrors WGXERR_GENERIC_IGNORE;
    public static MILErrors WGXERR_MALFORMED_GUIDELINE_DATA;
    public static MILErrors WGXERR_NO_HARDWARE_DEVICE;
    public static MILErrors WGXERR_NEED_RECREATE_AND_PRESENT;
    public static MILErrors WGXERR_ALREADY_INITIALIZED;
    public static MILErrors WGXERR_MISMATCHED_SIZE;
    public static MILErrors WGXERR_NO_REDIRECTION_SURFACE_AVAILABLE;
    public static MILErrors WGXERR_REMOTING_NOT_SUPPORTED;
    public static MILErrors WGXERR_QUEUED_PRESENT_NOT_SUPPORTED;
    public static MILErrors WGXERR_NOT_QUEUING_PRESENTS;
    public static MILErrors WGXERR_NO_REDIRECTION_SURFACE_RETRY_LATER;
    public static MILErrors WGXERR_TOOMANYSHADERELEMNTS;
    public static MILErrors WGXERR_SHADER_COMPILE_FAILED;
    public static MILErrors WGXERR_MAX_TEXTURE_SIZE_EXCEEDED;
    public static MILErrors WGXERR_UCE_INVALIDPACKETHEADER;
    public static MILErrors WGXERR_UCE_UNKNOWNPACKET;
    public static MILErrors WGXERR_UCE_ILLEGALPACKET;
    public static MILErrors WGXERR_UCE_MALFORMEDPACKET;
    public static MILErrors WGXERR_UCE_ILLEGALHANDLE;
    public static MILErrors WGXERR_UCE_HANDLELOOKUPFAILED;
    public static MILErrors WGXERR_UCE_RENDERTHREADFAILURE;
    public static MILErrors WGXERR_UCE_CTXSTACKFRSTTARGETNULL;
    public static MILErrors WGXERR_UCE_CONNECTIONIDLOOKUPFAILED;
    public static MILErrors WGXERR_UCE_BLOCKSFULL;
    public static MILErrors WGXERR_UCE_MEMORYFAILURE;
    public static MILErrors WGXERR_UCE_PACKETRECORDOUTOFRANGE;
    public static MILErrors WGXERR_UCE_ILLEGALRECORDTYPE;
    public static MILErrors WGXERR_UCE_OUTOFHANDLES;
    public static MILErrors WGXERR_UCE_UNCHANGABLE_UPDATE_ATTEMPTED;
    public static MILErrors WGXERR_UCE_NO_MULTIPLE_WORKER_THREADS;
    public static MILErrors WGXERR_UCE_REMOTINGNOTSUPPORTED;
    public static MILErrors WGXERR_UCE_MISSINGENDCOMMAND;
    public static MILErrors WGXERR_UCE_MISSINGBEGINCOMMAND;
    public static MILErrors WGXERR_UCE_CHANNELSYNCTIMEDOUT;
    public static MILErrors WGXERR_UCE_CHANNELSYNCABANDONED;
    public static MILErrors WGXERR_UCE_UNSUPPORTEDTRANSPORTVERSION;
    public static MILErrors WGXERR_UCE_TRANSPORTUNAVAILABLE;
    public static MILErrors WGXERR_UCE_FEEDBACK_UNSUPPORTED;
    public static MILErrors WGXERR_UCE_COMMANDTRANSPORTDENIED;
    public static MILErrors WGXERR_UCE_GRAPHICSSTREAMUNAVAILABLE;
    public static MILErrors WGXERR_UCE_GRAPHICSSTREAMALREADYOPEN;
    public static MILErrors WGXERR_UCE_TRANSPORTDISCONNECTED;
    public static MILErrors WGXERR_UCE_TRANSPORTOVERLOADED;
    public static MILErrors WGXERR_UCE_PARTITION_ZOMBIED;
    public static MILErrors WGXERR_UCE_USER_SHADEREFFECT_ERROR;
    public static MILErrors WGXERR_AV_NOCLOCK;
    public static MILErrors WGXERR_AV_NOMEDIATYPE;
    public static MILErrors WGXERR_AV_NOVIDEOMIXER;
    public static MILErrors WGXERR_AV_NOVIDEOPRESENTER;
    public static MILErrors WGXERR_AV_NOREADYFRAMES;
    public static MILErrors WGXERR_AV_MODULENOTLOADED;
    public static MILErrors WGXERR_AV_WMPFACTORYNOTREGISTERED;
    public static MILErrors WGXERR_AV_INVALIDWMPVERSION;
    public static MILErrors WGXERR_AV_INSUFFICIENTVIDEORESOURCES;
    public static MILErrors WGXERR_AV_VIDEOACCELERATIONNOTAVAILABLE;
    public static MILErrors WGXERR_AV_REQUESTEDTEXTURETOOBIG;
    public static MILErrors WGXERR_AV_SEEKFAILED;
    public static MILErrors WGXERR_AV_UNEXPECTEDWMPFAILURE;
    public static MILErrors WGXERR_AV_MEDIAPLAYERCLOSED;
    public static MILErrors WGXERR_AV_UNKNOWNHARDWAREERROR;
    public static MILErrors WGXERR_D3DI_INVALIDSURFACEUSAGE;
    public static MILErrors WGXERR_D3DI_INVALIDSURFACESIZE;
    public static MILErrors WGXERR_D3DI_INVALIDSURFACEPOOL;
    public static MILErrors WGXERR_D3DI_INVALIDSURFACEDEVICE;
    public static MILErrors WGXERR_D3DI_INVALIDANTIALIASINGSETTINGS;
}
internal static class MS.Internal.MILGuidData : object {
    internal static Guid IID_IMILRenderTargetBitmap;
    internal static Guid IID_IWICPalette;
    internal static Guid IID_IWICBitmapSource;
    internal static Guid IID_IWICFormatConverter;
    internal static Guid IID_IWICBitmapScaler;
    internal static Guid IID_IWICBitmapClipper;
    internal static Guid IID_IWICBitmapFlipRotator;
    internal static Guid IID_IWICBitmap;
    internal static Guid IID_IWICBitmapEncoder;
    internal static Guid IID_IWICBitmapFrameEncode;
    internal static Guid IID_IWICBitmapDecoder;
    internal static Guid IID_IWICBitmapFrameDecode;
    internal static Guid IID_IWICMetadataQueryReader;
    internal static Guid IID_IWICMetadataQueryWriter;
    internal static Guid IID_IWICMetadataReader;
    internal static Guid IID_IWICMetadataWriter;
    internal static Guid IID_IWICPixelFormatInfo;
    internal static Guid IID_IWICImagingFactory;
    internal static Guid CLSID_WICBmpDecoder;
    internal static Guid CLSID_WICPngDecoder;
    internal static Guid CLSID_WICIcoDecoder;
    internal static Guid CLSID_WICJpegDecoder;
    internal static Guid CLSID_WICGifDecoder;
    internal static Guid CLSID_WICTiffDecoder;
    internal static Guid CLSID_WICWmpDecoder;
    internal static Guid CLSID_WICBmpEncoder;
    internal static Guid CLSID_WICPngEncoder;
    internal static Guid CLSID_WICJpegEncoder;
    internal static Guid CLSID_WICGifEncoder;
    internal static Guid CLSID_WICTiffEncoder;
    internal static Guid CLSID_WICWmpEncoder;
    internal static Guid GUID_ContainerFormatBmp;
    internal static Guid GUID_ContainerFormatIco;
    internal static Guid GUID_ContainerFormatGif;
    internal static Guid GUID_ContainerFormatJpeg;
    internal static Guid GUID_ContainerFormatPng;
    internal static Guid GUID_ContainerFormatTiff;
    internal static Guid GUID_ContainerFormatWmp;
    internal static Byte[] GUID_VendorMicrosoft;
    private static MILGuidData();
}
internal enum MS.Internal.MILLineJoin : Enum {
    public int value__;
    public static MILLineJoin MILLineJoinMiter;
    public static MILLineJoin MILLineJoinBevel;
    public static MILLineJoin MILLineJoinRound;
    public static MILLineJoin MILLineJoinMiterClipped;
    public static MILLineJoin MILLINEJOIN_FORCE_DWORD;
}
internal static class MS.Internal.MILMedia : object {
    internal static int Open(SafeMediaHandle THIS_PTR, string src);
    internal static int Stop(SafeMediaHandle THIS_PTR);
    internal static int Close(SafeMediaHandle THIS_PTR);
    internal static int GetPosition(SafeMediaHandle THIS_PTR, Int64& pllTime);
    internal static int SetPosition(SafeMediaHandle THIS_PTR, long llTime);
    internal static int SetVolume(SafeMediaHandle THIS_PTR, double dblVolume);
    internal static int SetBalance(SafeMediaHandle THIS_PTR, double dblBalance);
    internal static int SetIsScrubbingEnabled(SafeMediaHandle THIS_PTR, bool isScrubbingEnabled);
    internal static int IsBuffering(SafeMediaHandle THIS_PTR, Boolean& pIsBuffering);
    internal static int CanPause(SafeMediaHandle THIS_PTR, Boolean& pCanPause);
    internal static int GetDownloadProgress(SafeMediaHandle THIS_PTR, Double& pProgress);
    internal static int GetBufferingProgress(SafeMediaHandle THIS_PTR, Double& pProgress);
    internal static int SetRate(SafeMediaHandle THIS_PTR, double dblRate);
    internal static int HasVideo(SafeMediaHandle THIS_PTR, Boolean& pfHasVideo);
    internal static int HasAudio(SafeMediaHandle THIS_PTR, Boolean& pfHasAudio);
    internal static int GetNaturalHeight(SafeMediaHandle THIS_PTR, UInt32& puiHeight);
    internal static int GetNaturalWidth(SafeMediaHandle THIS_PTR, UInt32& puiWidth);
    internal static int GetMediaLength(SafeMediaHandle THIS_PTR, Int64& pllLength);
    internal static int NeedUIFrameUpdate(SafeMediaHandle THIS_PTR);
    internal static int Shutdown(IntPtr THIS_PTR);
    internal static int ProcessExitHandler(SafeMediaHandle THIS_PTR);
}
internal enum MS.Internal.MILPropIDs : Enum {
    public UInt32 value__;
    public static MILPropIDs MILPropertyItemIdInvalid;
    public static MILPropIDs MILPropertyItemIdNewSubfileType;
    public static MILPropIDs MILPropertyItemIdSubfileType;
    public static MILPropIDs MILPropertyItemIdImageWidth;
    public static MILPropIDs MILPropertyItemIdImageHeight;
    public static MILPropIDs MILPropertyItemIdBitsPerSample;
    public static MILPropIDs MILPropertyItemIdCompression;
    public static MILPropIDs MILPropertyItemIdPhotometricInterp;
    public static MILPropIDs MILPropertyItemIdThreshHolding;
    public static MILPropIDs MILPropertyItemIdCellWidth;
    public static MILPropIDs MILPropertyItemIdCellHeight;
    public static MILPropIDs MILPropertyItemIdFillOrder;
    public static MILPropIDs MILPropertyItemIdDocumentName;
    public static MILPropIDs MILPropertyItemIdImageDescription;
    public static MILPropIDs MILPropertyItemIdEquipMake;
    public static MILPropIDs MILPropertyItemIdEquipModel;
    public static MILPropIDs MILPropertyItemIdStripOffsets;
    public static MILPropIDs MILPropertyItemIdOrientation;
    public static MILPropIDs MILPropertyItemIdSamplesPerPixel;
    public static MILPropIDs MILPropertyItemIdRowsPerStrip;
    public static MILPropIDs MILPropertyItemIdStripBytesCount;
    public static MILPropIDs MILPropertyItemIdMinSampleValue;
    public static MILPropIDs MILPropertyItemIdMaxSampleValue;
    public static MILPropIDs MILPropertyItemIdXResolution;
    public static MILPropIDs MILPropertyItemIdYResolution;
    public static MILPropIDs MILPropertyItemIdPlanarConfig;
    public static MILPropIDs MILPropertyItemIdPageName;
    public static MILPropIDs MILPropertyItemIdXPosition;
    public static MILPropIDs MILPropertyItemIdYPosition;
    public static MILPropIDs MILPropertyItemIdFreeOffset;
    public static MILPropIDs MILPropertyItemIdFreeByteCounts;
    public static MILPropIDs MILPropertyItemIdGrayResponseUnit;
    public static MILPropIDs MILPropertyItemIdGrayResponseCurve;
    public static MILPropIDs MILPropertyItemIdT4Option;
    public static MILPropIDs MILPropertyItemIdT6Option;
    public static MILPropIDs MILPropertyItemIdResolutionUnit;
    public static MILPropIDs MILPropertyItemIdPageNumber;
    public static MILPropIDs MILPropertyItemIdTransferFuncition;
    public static MILPropIDs MILPropertyItemIdSoftwareUsed;
    public static MILPropIDs MILPropertyItemIdDateTime;
    public static MILPropIDs MILPropertyItemIdArtist;
    public static MILPropIDs MILPropertyItemIdHostComputer;
    public static MILPropIDs MILPropertyItemIdPredictor;
    public static MILPropIDs MILPropertyItemIdWhitePoint;
    public static MILPropIDs MILPropertyItemIdPrimaryChromaticities;
    public static MILPropIDs MILPropertyItemIdColorMap;
    public static MILPropIDs MILPropertyItemIdHalftoneHints;
    public static MILPropIDs MILPropertyItemIdTileWidth;
    public static MILPropIDs MILPropertyItemIdTileLength;
    public static MILPropIDs MILPropertyItemIdTileOffset;
    public static MILPropIDs MILPropertyItemIdTileByteCounts;
    public static MILPropIDs MILPropertyItemIdInkSet;
    public static MILPropIDs MILPropertyItemIdInkNames;
    public static MILPropIDs MILPropertyItemIdNumberOfInks;
    public static MILPropIDs MILPropertyItemIdDotRange;
    public static MILPropIDs MILPropertyItemIdTargetPrinter;
    public static MILPropIDs MILPropertyItemIdExtraSamples;
    public static MILPropIDs MILPropertyItemIdSampleFormat;
    public static MILPropIDs MILPropertyItemIdSMinSampleValue;
    public static MILPropIDs MILPropertyItemIdSMaxSampleValue;
    public static MILPropIDs MILPropertyItemIdTransferRange;
    public static MILPropIDs MILPropertyItemIdScreenWidth;
    public static MILPropIDs MILPropertyItemIdScreenHeight;
    public static MILPropIDs MILPropertyItemIdJPEGProc;
    public static MILPropIDs MILPropertyItemIdJPEGInterFormat;
    public static MILPropIDs MILPropertyItemIdJPEGInterLength;
    public static MILPropIDs MILPropertyItemIdJPEGRestartInterval;
    public static MILPropIDs MILPropertyItemIdJPEGLosslessPredictors;
    public static MILPropIDs MILPropertyItemIdJPEGPointTransforms;
    public static MILPropIDs MILPropertyItemIdJPEGQTables;
    public static MILPropIDs MILPropertyItemIdJPEGDCTables;
    public static MILPropIDs MILPropertyItemIdJPEGACTables;
    public static MILPropIDs MILPropertyItemIdYCbCrCoefficients;
    public static MILPropIDs MILPropertyItemIdYCbCrSubsampling;
    public static MILPropIDs MILPropertyItemIdYCbCrPositioning;
    public static MILPropIDs MILPropertyItemIdREFBlackWhite;
    public static MILPropIDs MILPropertyItemIdInterlaced;
    public static MILPropIDs MILPropertyItemIdGamma;
    public static MILPropIDs MILPropertyItemIdICCProfileDescriptor;
    public static MILPropIDs MILPropertyItemIdSRGBRenderingIntent;
    public static MILPropIDs MILPropertyItemIdICCProfile;
    public static MILPropIDs MILPropertyItemIdImageTitle;
    public static MILPropIDs MILPropertyItemIdCopyright;
    public static MILPropIDs MILPropertyItemIdResolutionXUnit;
    public static MILPropIDs MILPropertyItemIdResolutionYUnit;
    public static MILPropIDs MILPropertyItemIdResolutionXLengthUnit;
    public static MILPropIDs MILPropertyItemIdResolutionYLengthUnit;
    public static MILPropIDs MILPropertyItemIdPrintFlags;
    public static MILPropIDs MILPropertyItemIdPrintFlagsVersion;
    public static MILPropIDs MILPropertyItemIdPrintFlagsCrop;
    public static MILPropIDs MILPropertyItemIdPrintFlagsBleedWidth;
    public static MILPropIDs MILPropertyItemIdPrintFlagsBleedWidthScale;
    public static MILPropIDs MILPropertyItemIdHalftoneLPI;
    public static MILPropIDs MILPropertyItemIdHalftoneLPIUnit;
    public static MILPropIDs MILPropertyItemIdHalftoneDegree;
    public static MILPropIDs MILPropertyItemIdHalftoneShape;
    public static MILPropIDs MILPropertyItemIdHalftoneMisc;
    public static MILPropIDs MILPropertyItemIdHalftoneScreen;
    public static MILPropIDs MILPropertyItemIdJPEGQuality;
    public static MILPropIDs MILPropertyItemIdGridSize;
    public static MILPropIDs MILPropertyItemIdThumbnailFormat;
    public static MILPropIDs MILPropertyItemIdThumbnailWidth;
    public static MILPropIDs MILPropertyItemIdThumbnailHeight;
    public static MILPropIDs MILPropertyItemIdThumbnailColorDepth;
    public static MILPropIDs MILPropertyItemIdThumbnailPlanes;
    public static MILPropIDs MILPropertyItemIdThumbnailRawBytes;
    public static MILPropIDs MILPropertyItemIdThumbnailSize;
    public static MILPropIDs MILPropertyItemIdThumbnailCompressedSize;
    public static MILPropIDs MILPropertyItemIdColorTransferFunction;
    public static MILPropIDs MILPropertyItemIdThumbnailData;
    public static MILPropIDs MILPropertyItemIdThumbnailImageWidth;
    public static MILPropIDs MILPropertyItemIdThumbnailImageHeight;
    public static MILPropIDs MILPropertyItemIdThumbnailBitsPerSample;
    public static MILPropIDs MILPropertyItemIdThumbnailCompression;
    public static MILPropIDs MILPropertyItemIdThumbnailPhotometricInterp;
    public static MILPropIDs MILPropertyItemIdThumbnailImageDescription;
    public static MILPropIDs MILPropertyItemIdThumbnailEquipMake;
    public static MILPropIDs MILPropertyItemIdThumbnailEquipModel;
    public static MILPropIDs MILPropertyItemIdThumbnailStripOffsets;
    public static MILPropIDs MILPropertyItemIdThumbnailOrientation;
    public static MILPropIDs MILPropertyItemIdThumbnailSamplesPerPixel;
    public static MILPropIDs MILPropertyItemIdThumbnailRowsPerStrip;
    public static MILPropIDs MILPropertyItemIdThumbnailStripBytesCount;
    public static MILPropIDs MILPropertyItemIdThumbnailResolutionX;
    public static MILPropIDs MILPropertyItemIdThumbnailResolutionY;
    public static MILPropIDs MILPropertyItemIdThumbnailPlanarConfig;
    public static MILPropIDs MILPropertyItemIdThumbnailResolutionUnit;
    public static MILPropIDs MILPropertyItemIdThumbnailTransferFunction;
    public static MILPropIDs MILPropertyItemIdThumbnailSoftwareUsed;
    public static MILPropIDs MILPropertyItemIdThumbnailDateTime;
    public static MILPropIDs MILPropertyItemIdThumbnailArtist;
    public static MILPropIDs MILPropertyItemIdThumbnailWhitePoint;
    public static MILPropIDs MILPropertyItemIdThumbnailPrimaryChromaticities;
    public static MILPropIDs MILPropertyItemIdThumbnailYCbCrCoefficients;
    public static MILPropIDs MILPropertyItemIdThumbnailYCbCrSubsampling;
    public static MILPropIDs MILPropertyItemIdThumbnailYCbCrPositioning;
    public static MILPropIDs MILPropertyItemIdThumbnailRefBlackWhite;
    public static MILPropIDs MILPropertyItemIdThumbnailCopyRight;
    public static MILPropIDs MILPropertyItemIdLuminanceTable;
    public static MILPropIDs MILPropertyItemIdChrominanceTable;
    public static MILPropIDs MILPropertyItemIdFrameDelay;
    public static MILPropIDs MILPropertyItemIdLoopCount;
    public static MILPropIDs MILPropertyItemIdGlobalPalette;
    public static MILPropIDs MILPropertyItemIdIndexBackground;
    public static MILPropIDs MILPropertyItemIdIndexTransparent;
    public static MILPropIDs MILPropertyItemIdPixelUnit;
    public static MILPropIDs MILPropertyItemIdPixelPerUnitX;
    public static MILPropIDs MILPropertyItemIdPixelPerUnitY;
    public static MILPropIDs MILPropertyItemIdPaletteHistogram;
    public static MILPropIDs MILPropertyItemIdExifIFD;
    public static MILPropIDs MILPropertyItemIdExifExposureTime;
    public static MILPropIDs MILPropertyItemIdExifFNumber;
    public static MILPropIDs MILPropertyItemIdExifExposureProg;
    public static MILPropIDs MILPropertyItemIdExifSpectralSense;
    public static MILPropIDs MILPropertyItemIdExifISOSpeed;
    public static MILPropIDs MILPropertyItemIdExifOECF;
    public static MILPropIDs MILPropertyItemIdExifVer;
    public static MILPropIDs MILPropertyItemIdExifDTOrig;
    public static MILPropIDs MILPropertyItemIdExifDTDigitized;
    public static MILPropIDs MILPropertyItemIdExifCompConfig;
    public static MILPropIDs MILPropertyItemIdExifCompBPP;
    public static MILPropIDs MILPropertyItemIdExifShutterSpeed;
    public static MILPropIDs MILPropertyItemIdExifAperture;
    public static MILPropIDs MILPropertyItemIdExifBrightness;
    public static MILPropIDs MILPropertyItemIdExifExposureBias;
    public static MILPropIDs MILPropertyItemIdExifMaxAperture;
    public static MILPropIDs MILPropertyItemIdExifSubjectDist;
    public static MILPropIDs MILPropertyItemIdExifMeteringMode;
    public static MILPropIDs MILPropertyItemIdExifLightSource;
    public static MILPropIDs MILPropertyItemIdExifFlash;
    public static MILPropIDs MILPropertyItemIdExifFocalLength;
    public static MILPropIDs MILPropertyItemIdExifMakerNote;
    public static MILPropIDs MILPropertyItemIdExifUserComment;
    public static MILPropIDs MILPropertyItemIdExifDTSubsec;
    public static MILPropIDs MILPropertyItemIdExifDTOrigSS;
    public static MILPropIDs MILPropertyItemIdExifDTDigSS;
    public static MILPropIDs MILPropertyItemIdExifFPXVer;
    public static MILPropIDs MILPropertyItemIdExifColorSpace;
    public static MILPropIDs MILPropertyItemIdExifPixXDim;
    public static MILPropIDs MILPropertyItemIdExifPixYDim;
    public static MILPropIDs MILPropertyItemIdExifRelatedWav;
    public static MILPropIDs MILPropertyItemIdExifInterop;
    public static MILPropIDs MILPropertyItemIdExifFlashEnergy;
    public static MILPropIDs MILPropertyItemIdExifSpatialFR;
    public static MILPropIDs MILPropertyItemIdExifFocalXRes;
    public static MILPropIDs MILPropertyItemIdExifFocalYRes;
    public static MILPropIDs MILPropertyItemIdExifFocalResUnit;
    public static MILPropIDs MILPropertyItemIdExifSubjectLoc;
    public static MILPropIDs MILPropertyItemIdExifExposureIndex;
    public static MILPropIDs MILPropertyItemIdExifSensingMethod;
    public static MILPropIDs MILPropertyItemIdExifFileSource;
    public static MILPropIDs MILPropertyItemIdExifSceneType;
    public static MILPropIDs MILPropertyItemIdExifCfaPattern;
    public static MILPropIDs MILPropertyItemIdMax;
}
internal enum MS.Internal.MILPropTypes : Enum {
    public int value__;
    public static MILPropTypes MILPropertyItemTypeInvalid;
    public static MILPropTypes MILPropertyItemTypeByte;
    public static MILPropTypes MILPropertyItemTypeASCII;
    public static MILPropTypes MILPropertyItemTypeWord;
    public static MILPropTypes MILPropertyItemTypeLong;
    public static MILPropTypes MILPropertyItemTypeRational;
    public static MILPropTypes MILPropertyItemTypeUndefined;
    public static MILPropTypes MILPropertyItemTypeSLong;
    public static MILPropTypes MILPropertyItemTypeSRational;
    public static MILPropTypes MILPropertyItemTypeMax;
}
internal static class MS.Internal.MILRenderTargetBitmap : object {
    internal static int GetBitmap(SafeMILHandle THIS_PTR, BitmapSourceSafeMILHandle& ppIBitmap);
    internal static int Clear(SafeMILHandle THIS_PTR);
}
internal enum MS.Internal.MILResourceType : Enum {
    public int value__;
    public static MILResourceType eMILResourceVideo;
    public static MILResourceType eMILCOB;
    public static MILResourceType eMILChain;
    public static MILResourceType eMILTarget;
    public static MILResourceType eMILResource;
    public static MILResourceType eMILResourceLast;
}
internal static class MS.Internal.MILSwDoubleBufferedBitmap : object {
    internal static int Create(UInt32 width, UInt32 height, double dpiX, double dpiY, Guid& pixelFormatGuid, SafeMILHandle pPalette, SafeMILHandle& ppSwDoubleBufferedBitmap);
    internal static void GetBackBuffer(SafeMILHandle THIS_PTR, BitmapSourceSafeMILHandle& pBackBuffer, UInt32& pBackBufferSize);
    internal static void AddDirtyRect(SafeMILHandle THIS_PTR, Int32Rect& dirtyRect);
    internal static int ProtectBackBuffer(SafeMILHandle THIS_PTR);
}
internal static class MS.Internal.MILUpdateSystemParametersInfo : object {
    internal static int Update();
}
[FriendAccessAllowedAttribute]
internal static class MS.Internal.MimeTypeMapper : object {
    private static Dictionary`2<string, ContentType> _fileExtensionToMimeType;
    internal static ContentType OctetMime;
    internal static ContentType TextPlainMime;
    internal static string XamlExtension;
    internal static string BamlExtension;
    internal static string XbapExtension;
    internal static string JpgExtension;
    internal static ContentType XamlMime;
    internal static ContentType BamlMime;
    internal static ContentType JpgMime;
    internal static ContentType IconMime;
    internal static ContentType FixedDocumentSequenceMime;
    internal static ContentType FixedDocumentMime;
    internal static ContentType FixedPageMime;
    internal static ContentType ResourceDictionaryMime;
    internal static ContentType HtmlMime;
    internal static ContentType HtmMime;
    internal static ContentType XbapMime;
    private static MimeTypeMapper();
    internal static ContentType GetMimeTypeFromUri(Uri uriSource);
    private static ContentType GetMimeTypeFromUrlMon(Uri uriSource);
    private static string GetDocument(Uri uri);
    internal static string GetFileExtension(Uri uri);
    internal static bool IsHTMLMime(ContentType contentType);
}
internal enum MS.Internal.NtStatusErrors : Enum {
    public int value__;
    public static NtStatusErrors NT_STATUS_NO_MEMORY;
}
internal class MS.Internal.Pair : object {
    private object _first;
    private object _second;
    public object First { get; }
    public object Second { get; }
    public Pair(object first, object second);
    public object get_First();
    public object get_Second();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
}
internal static class MS.Internal.Parsers : object {
    private static int s_zeroChar;
    private static int s_aLower;
    private static int s_aUpper;
    internal static string s_ContextColor;
    internal static string s_ContextColorNoSpace;
    private static int ParseHexChar(char c);
    private static Color ParseHexColor(string trimmedColor);
    private static Color ParseContextColor(string trimmedColor, IFormatProvider formatProvider, ITypeDescriptorContext context);
    private static Color ParseScRgbColor(string trimmedColor, IFormatProvider formatProvider);
    internal static Color ParseColor(string color, IFormatProvider formatProvider);
    internal static Color ParseColor(string color, IFormatProvider formatProvider, ITypeDescriptorContext context);
    internal static Brush ParseBrush(string brush, IFormatProvider formatProvider, ITypeDescriptorContext context);
    internal static Transform ParseTransform(string transformString, IFormatProvider formatProvider);
    internal static PathFigureCollection ParsePathFigureCollection(string pathString, IFormatProvider formatProvider);
    internal static object DeserializeStreamGeometry(BinaryReader reader);
    internal static void PathMinilanguageToBinary(BinaryWriter bw, string stringValue);
    internal static Geometry ParseGeometry(string pathString, IFormatProvider formatProvider);
    private static void ParseStringToStreamGeometryContext(StreamGeometryContext context, string pathString, IFormatProvider formatProvider, FillRule& fillRule);
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.PartialArray`1 : ValueType {
    private T[] _array;
    private int _initialIndex;
    private int _count;
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public T Item { get; public set; }
    public int Count { get; }
    public PartialArray`1(T[] array, int initialIndex, int count);
    public PartialArray`1(T[] array);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Contains(T item);
    public bool get_IsFixedSize();
    public sealed virtual bool Remove(T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void Clear();
    public sealed virtual void Add(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual int IndexOf(T item);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    [IteratorStateMachineAttribute("MS.Internal.PartialArray`1/<System-Collections-Generic-IEnumerable<T>-GetEnumerator>d__22")]
private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.PartialList`1 : object {
    private IList`1<T> _list;
    private int _initialIndex;
    private int _count;
    public T Item { get; public set; }
    public bool IsReadOnly { get; }
    public int Count { get; }
    public PartialList`1(IList`1<T> list);
    public PartialList`1(IList`1<T> list, int initialIndex, int count);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual int IndexOf(T item);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Clear();
    public sealed virtual void Add(T item);
    public sealed virtual bool Contains(T item);
    public sealed virtual bool Remove(T item);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    [IteratorStateMachineAttribute("MS.Internal.PartialList`1/<System-Collections-Generic-IEnumerable<T>-GetEnumerator>d__20")]
private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal enum MS.Internal.PixelFormatEnum : Enum {
    public int value__;
    public static PixelFormatEnum Default;
    public static PixelFormatEnum Extended;
    public static PixelFormatEnum Indexed1;
    public static PixelFormatEnum Indexed2;
    public static PixelFormatEnum Indexed4;
    public static PixelFormatEnum Indexed8;
    public static PixelFormatEnum BlackWhite;
    public static PixelFormatEnum Gray2;
    public static PixelFormatEnum Gray4;
    public static PixelFormatEnum Gray8;
    public static PixelFormatEnum Bgr555;
    public static PixelFormatEnum Bgr565;
    public static PixelFormatEnum Gray16;
    public static PixelFormatEnum Bgr24;
    public static PixelFormatEnum Rgb24;
    public static PixelFormatEnum Bgr32;
    public static PixelFormatEnum Bgra32;
    public static PixelFormatEnum Pbgra32;
    public static PixelFormatEnum Gray32Float;
    public static PixelFormatEnum Bgr101010;
    public static PixelFormatEnum Rgb48;
    public static PixelFormatEnum Rgba64;
    public static PixelFormatEnum Prgba64;
    public static PixelFormatEnum Rgba128Float;
    public static PixelFormatEnum Prgba128Float;
    public static PixelFormatEnum Rgb128Float;
    public static PixelFormatEnum Cmyk32;
}
[FriendAccessAllowedAttribute]
internal static class MS.Internal.PointUtil : object {
    public static Point ClientToRoot(Point point, PresentationSource presentationSource);
    public static Point TryClientToRoot(Point point, PresentationSource presentationSource, bool throwOnError, Boolean& success);
    public static Point RootToClient(Point point, PresentationSource presentationSource);
    public static Point ApplyVisualTransform(Point point, Visual v, bool inverse);
    public static Point TryApplyVisualTransform(Point point, Visual v, bool inverse, bool throwOnError, Boolean& success);
    internal static Matrix GetVisualTransform(Visual v);
    public static Point ClientToScreen(Point pointClient, PresentationSource presentationSource);
    internal static Point ScreenToClient(Point pointScreen, PresentationSource presentationSource);
    internal static Rect ElementToRoot(Rect rectElement, Visual element, PresentationSource presentationSource);
    internal static Rect RootToClient(Rect rectRoot, PresentationSource presentationSource);
    internal static Rect ClientToScreen(Rect rectClient, HwndSource hwndSource);
    internal static POINT AdjustForRightToLeft(POINT pt, HandleRef handleRef);
    internal static RECT AdjustForRightToLeft(RECT rc, HandleRef handleRef);
    internal static POINT FromPoint(Point point);
    internal static Point ToPoint(POINT pt);
    internal static RECT FromRect(Rect rect);
    internal static Rect ToRect(RECT rc);
}
internal static class MS.Internal.PresentationCore.AnimatedTypeHelpers : object {
    internal static byte InterpolateByte(byte from, byte to, double progress);
    internal static Color InterpolateColor(Color from, Color to, double progress);
    internal static decimal InterpolateDecimal(decimal from, decimal to, double progress);
    internal static double InterpolateDouble(double from, double to, double progress);
    internal static short InterpolateInt16(short from, short to, double progress);
    internal static int InterpolateInt32(int from, int to, double progress);
    internal static long InterpolateInt64(long from, long to, double progress);
    internal static Point InterpolatePoint(Point from, Point to, double progress);
    internal static Point3D InterpolatePoint3D(Point3D from, Point3D to, double progress);
    internal static Quaternion InterpolateQuaternion(Quaternion from, Quaternion to, double progress, bool useShortestPath);
    internal static Rect InterpolateRect(Rect from, Rect to, double progress);
    internal static Rotation3D InterpolateRotation3D(Rotation3D from, Rotation3D to, double progress);
    internal static float InterpolateSingle(float from, float to, double progress);
    internal static Size InterpolateSize(Size from, Size to, double progress);
    internal static Vector InterpolateVector(Vector from, Vector to, double progress);
    internal static Vector3D InterpolateVector3D(Vector3D from, Vector3D to, double progress);
    internal static byte AddByte(byte value1, byte value2);
    internal static Color AddColor(Color value1, Color value2);
    internal static decimal AddDecimal(decimal value1, decimal value2);
    internal static double AddDouble(double value1, double value2);
    internal static short AddInt16(short value1, short value2);
    internal static int AddInt32(int value1, int value2);
    internal static long AddInt64(long value1, long value2);
    internal static Point AddPoint(Point value1, Point value2);
    internal static Point3D AddPoint3D(Point3D value1, Point3D value2);
    internal static Quaternion AddQuaternion(Quaternion value1, Quaternion value2);
    internal static float AddSingle(float value1, float value2);
    internal static Size AddSize(Size value1, Size value2);
    internal static Vector AddVector(Vector value1, Vector value2);
    internal static Vector3D AddVector3D(Vector3D value1, Vector3D value2);
    internal static Rect AddRect(Rect value1, Rect value2);
    internal static Rotation3D AddRotation3D(Rotation3D value1, Rotation3D value2);
    internal static byte SubtractByte(byte value1, byte value2);
    internal static Color SubtractColor(Color value1, Color value2);
    internal static decimal SubtractDecimal(decimal value1, decimal value2);
    internal static double SubtractDouble(double value1, double value2);
    internal static short SubtractInt16(short value1, short value2);
    internal static int SubtractInt32(int value1, int value2);
    internal static long SubtractInt64(long value1, long value2);
    internal static Point SubtractPoint(Point value1, Point value2);
    internal static Point3D SubtractPoint3D(Point3D value1, Point3D value2);
    internal static Quaternion SubtractQuaternion(Quaternion value1, Quaternion value2);
    internal static float SubtractSingle(float value1, float value2);
    internal static Size SubtractSize(Size value1, Size value2);
    internal static Vector SubtractVector(Vector value1, Vector value2);
    internal static Vector3D SubtractVector3D(Vector3D value1, Vector3D value2);
    internal static Rect SubtractRect(Rect value1, Rect value2);
    internal static Rotation3D SubtractRotation3D(Rotation3D value1, Rotation3D value2);
    internal static double GetSegmentLengthBoolean(bool from, bool to);
    internal static double GetSegmentLengthByte(byte from, byte to);
    internal static double GetSegmentLengthChar(char from, char to);
    internal static double GetSegmentLengthColor(Color from, Color to);
    internal static double GetSegmentLengthDecimal(decimal from, decimal to);
    internal static double GetSegmentLengthDouble(double from, double to);
    internal static double GetSegmentLengthInt16(short from, short to);
    internal static double GetSegmentLengthInt32(int from, int to);
    internal static double GetSegmentLengthInt64(long from, long to);
    internal static double GetSegmentLengthMatrix(Matrix from, Matrix to);
    internal static double GetSegmentLengthObject(object from, object to);
    internal static double GetSegmentLengthPoint(Point from, Point to);
    internal static double GetSegmentLengthPoint3D(Point3D from, Point3D to);
    internal static double GetSegmentLengthQuaternion(Quaternion from, Quaternion to);
    internal static double GetSegmentLengthRect(Rect from, Rect to);
    internal static double GetSegmentLengthRotation3D(Rotation3D from, Rotation3D to);
    internal static double GetSegmentLengthSingle(float from, float to);
    internal static double GetSegmentLengthSize(Size from, Size to);
    internal static double GetSegmentLengthString(string from, string to);
    internal static double GetSegmentLengthVector(Vector from, Vector to);
    internal static double GetSegmentLengthVector3D(Vector3D from, Vector3D to);
    internal static byte ScaleByte(byte value, double factor);
    internal static Color ScaleColor(Color value, double factor);
    internal static decimal ScaleDecimal(decimal value, double factor);
    internal static double ScaleDouble(double value, double factor);
    internal static short ScaleInt16(short value, double factor);
    internal static int ScaleInt32(int value, double factor);
    internal static long ScaleInt64(long value, double factor);
    internal static Point ScalePoint(Point value, double factor);
    internal static Point3D ScalePoint3D(Point3D value, double factor);
    internal static Quaternion ScaleQuaternion(Quaternion value, double factor);
    internal static Rect ScaleRect(Rect value, double factor);
    internal static Rotation3D ScaleRotation3D(Rotation3D value, double factor);
    internal static float ScaleSingle(float value, double factor);
    internal static Size ScaleSize(Size value, double factor);
    internal static Vector ScaleVector(Vector value, double factor);
    internal static Vector3D ScaleVector3D(Vector3D value, double factor);
    internal static bool IsValidAnimationValueBoolean(bool value);
    internal static bool IsValidAnimationValueByte(byte value);
    internal static bool IsValidAnimationValueChar(char value);
    internal static bool IsValidAnimationValueColor(Color value);
    internal static bool IsValidAnimationValueDecimal(decimal value);
    internal static bool IsValidAnimationValueDouble(double value);
    internal static bool IsValidAnimationValueInt16(short value);
    internal static bool IsValidAnimationValueInt32(int value);
    internal static bool IsValidAnimationValueInt64(long value);
    internal static bool IsValidAnimationValueMatrix(Matrix value);
    internal static bool IsValidAnimationValuePoint(Point value);
    internal static bool IsValidAnimationValuePoint3D(Point3D value);
    internal static bool IsValidAnimationValueQuaternion(Quaternion value);
    internal static bool IsValidAnimationValueRect(Rect value);
    internal static bool IsValidAnimationValueRotation3D(Rotation3D value);
    internal static bool IsValidAnimationValueSingle(float value);
    internal static bool IsValidAnimationValueSize(Size value);
    internal static bool IsValidAnimationValueString(string value);
    internal static bool IsValidAnimationValueVector(Vector value);
    internal static bool IsValidAnimationValueVector3D(Vector3D value);
    internal static byte GetZeroValueByte(byte baseValue);
    internal static Color GetZeroValueColor(Color baseValue);
    internal static decimal GetZeroValueDecimal(decimal baseValue);
    internal static double GetZeroValueDouble(double baseValue);
    internal static short GetZeroValueInt16(short baseValue);
    internal static int GetZeroValueInt32(int baseValue);
    internal static long GetZeroValueInt64(long baseValue);
    internal static Point GetZeroValuePoint(Point baseValue);
    internal static Point3D GetZeroValuePoint3D(Point3D baseValue);
    internal static Quaternion GetZeroValueQuaternion(Quaternion baseValue);
    internal static float GetZeroValueSingle(float baseValue);
    internal static Size GetZeroValueSize(Size baseValue);
    internal static Vector GetZeroValueVector(Vector baseValue);
    internal static Vector3D GetZeroValueVector3D(Vector3D baseValue);
    internal static Rect GetZeroValueRect(Rect baseValue);
    internal static Rotation3D GetZeroValueRotation3D(Rotation3D baseValue);
    private static bool IsInvalidDouble(double value);
}
internal static class MS.Internal.PresentationCore.BindUriHelper : object {
    private static int MAX_PATH_LENGTH;
    private static int MAX_SCHEME_LENGTH;
    public static int MAX_URL_LENGTH;
    internal static Uri BaseUri { get; internal set; }
    internal static string UriToString(Uri uri);
    internal static Uri get_BaseUri();
    internal static void set_BaseUri(Uri value);
    internal static bool DoSchemeAndHostMatch(Uri first, Uri second);
    internal static Uri GetResolvedUri(Uri baseUri, Uri orgUri);
    internal static string GetReferer(Uri destinationUri);
}
internal static class MS.Internal.PresentationCore.BuildInfo : object {
    internal static string WCP_VERSION;
    internal static string WCP_VERSION_SUFFIX;
    internal static string MIL_VERSION_SUFFIX;
    internal static string WCP_PUBLIC_KEY_TOKEN;
    internal static string WCP_PUBLIC_KEY_STRING;
    internal static string DEVDIV_PUBLIC_KEY_STRING;
    internal static string DEVDIV_PUBLIC_KEY_TOKEN;
    internal static string DirectWriteForwarder;
    internal static string PresentationCore;
    internal static string PresentationCFFRasterizer;
    internal static string PresentationFramework;
    internal static string PresentationUI;
    internal static string PresentationFrameworkLuna;
    internal static string PresentationFrameworkRoyale;
    internal static string PresentationFrameworkAero;
    internal static string PresentationFrameworkAero2;
    internal static string PresentationFrameworkAeroLite;
    internal static string PresentationFrameworkClassic;
    internal static string PresentationFrameworkSystemCore;
    internal static string PresentationFrameworkSystemData;
    internal static string PresentationFrameworkSystemDrawing;
    internal static string PresentationFrameworkSystemXml;
    internal static string PresentationFrameworkSystemXmlLinq;
    internal static string ReachFramework;
    internal static string SystemPrinting;
    internal static string SystemXaml;
    internal static string WindowsFormsIntegration;
    internal static string SystemWindowsPresentation;
    internal static string SystemWindowsControlsRibbon;
}
[AttributeUsageAttribute("256")]
[ConditionalAttribute("COMMONDPS")]
internal class MS.Internal.PresentationCore.CommonDependencyPropertyAttribute : Attribute {
}
internal static class MS.Internal.PresentationCore.DllImport : object {
    internal static string PresentationNative;
    internal static string PresentationCFFRasterizerNative;
    internal static string MilCore;
    internal static string UIAutomationCore;
    internal static string Wininet;
    internal static string WindowsCodecs;
    internal static string WindowsCodecsExt;
    internal static string Mscms;
    internal static string PrntvPt;
    internal static string Ole32;
    internal static string User32;
    internal static string NInput;
}
[AttributeUsageAttribute("5628")]
internal class MS.Internal.PresentationCore.FriendAccessAllowedAttribute : Attribute {
}
internal class MS.Internal.PresentationCore.GCNotificationToken : object {
    private WaitCallback callback;
    private object state;
    private GCNotificationToken(WaitCallback callback, object state);
    protected virtual override void Finalize();
    internal static void RegisterCallback(WaitCallback callback, object state);
}
internal static class MS.Internal.PresentationCore.SafeSecurityHelper : object {
    private static Dictionary`2<object, AssemblyName> _assemblies;
    private static object syncObject;
    private static bool _isGCCallbackPending;
    private static WaitCallback _cleanupCollectedAssemblies;
    internal static string IMAGE;
    private static SafeSecurityHelper();
    internal static void TransformLocalRectToScreen(HandleRef hwnd, RECT& rcWindowCoords);
    internal static string GetAssemblyPartialName(Assembly assembly);
    internal static Assembly GetLoadedAssembly(AssemblyName assemblyName);
    private static AssemblyName GetAssemblyName(Assembly assembly);
    private static void CleanupCollectedAssemblies(object state);
    internal static bool IsSameKeyToken(Byte[] reqKeyToken, Byte[] curKeyToken);
    internal static bool IsFeatureDisabled(KeyToRead key);
    internal static CultureInfo GetCultureInfoByIetfLanguageTag(string languageTag);
    internal static bool IsConnectedToPresentationSource(Visual visual);
}
internal static class MS.Internal.PresentationCore.SR : object {
    private static ResourceManager ResourceManager { get; }
    private static ResourceManager get_ResourceManager();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    public static string Get(string name);
    public static string Get(string name, Object[] args);
}
internal static class MS.Internal.PresentationCore.SRID : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static string AccessKeyManager_NotAUnicodeCharacter;
    internal static string AcquireBreakRecordFailure;
    internal static string AcquirePenaltyModuleFailure;
    internal static string AddText_Invalid;
    internal static string AllGesturesMustExistAlone;
    internal static string Animation_AnimationTimelineTypeMismatch;
    internal static string Animation_CalculatedValueIsInvalidForProperty;
    internal static string Animation_ChildMustBeKeyFrame;
    internal static string Animation_ChildTypeMismatch;
    internal static string Animation_DependencyPropertyIsNotAnimatable;
    internal static string Animation_Exception;
    internal static string Animation_InvalidBaseValue;
    internal static string Animation_InvalidResolvedKeyTimes;
    internal static string Animation_InvalidTimeKeyTime;
    internal static string Animation_Invalid_DefaultValue;
    internal static string Animation_KeySpline_InvalidValue;
    internal static string Animation_KeyTime_InvalidPercentValue;
    internal static string Animation_KeyTime_LessThanZero;
    internal static string Animation_NoAnimationsSpecified;
    internal static string Animation_NoTextChildren;
    internal static string Animation_ReturnedUnsetValueInstance;
    internal static string Animation_UnrecognizedHandoffBehavior;
    internal static string AnimEffect_AlreadyAttached;
    internal static string AnimEffect_CollectionInUse;
    internal static string AnimEffect_NoVisual;
    internal static string ApplicationGestureArrayLengthIsZero;
    internal static string ApplicationGestureIsInvalid;
    internal static string AutomationDispatcherShutdown;
    internal static string AutomationTimeout;
    internal static string Automation_InvalidConnectedPeer;
    internal static string Automation_InvalidEventId;
    internal static string Automation_InvalidSynchronizedInputType;
    internal static string Automation_RecursivePublicCall;
    internal static string Automation_UnsupportedUIAutomationEventAssociation;
    internal static string BitmapCacheBrush_OpacityChanged;
    internal static string BitmapCacheBrush_RelativeTransformChanged;
    internal static string BitmapCacheBrush_TransformChanged;
    internal static string BrowseBackKeyDisplayString;
    internal static string BrowseBackText;
    internal static string BrowseForwardKeyDisplayString;
    internal static string BrowseForwardText;
    internal static string BrowseHomeKeyDisplayString;
    internal static string BrowseHomeText;
    internal static string BrowseStopKeyDisplayString;
    internal static string BrowseStopText;
    internal static string BrushUnknownBamlType;
    internal static string ByteRangeDownloaderDisposed;
    internal static string ByteRangeDownloaderErroredOut;
    internal static string ByteRangeRequestIsNotSupported;
    internal static string CancelPrintText;
    internal static string CannotAttachVisualTwice;
    internal static string CannotBothBeNull;
    internal static string CannotConvertStringToType;
    internal static string CannotConvertType;
    internal static string CannotModifyReadOnlyContainer;
    internal static string CannotModifyVisualChildrenDuringTreeWalk;
    internal static string CannotNavigateToApplicationResourcesInWebBrowser;
    internal static string CannotRetrievePartsOfWriteOnlyContainer;
    internal static string Channel_InvalidCommandBufferPointer;
    internal static string CharacterMetrics_MissingRequiredField;
    internal static string CharacterMetrics_NegativeHorizontalAdvance;
    internal static string CharacterMetrics_NegativeVerticalAdvance;
    internal static string CharacterMetrics_TooManyFields;
    internal static string ClassTypeIllegal;
    internal static string CloneBreakRecordFailure;
    internal static string CloseText;
    internal static string ClusterMapEntriesShouldNotDecrease;
    internal static string ClusterMapEntryShouldPointWithinGlyphIndices;
    internal static string ClusterMapFirstEntryMustBeZero;
    internal static string CodePointOutOfRange;
    internal static string CollectionDuplicateKey;
    internal static string CollectionEnumerationError;
    internal static string CollectionIsFixedSize;
    internal static string CollectionNumberOfElementsMustBeGreaterThanZero;
    internal static string CollectionNumberOfElementsMustBeLessOrEqualTo;
    internal static string CollectionNumberOfElementsShouldBeEqualTo;
    internal static string CollectionOnlyAcceptsCommandBindings;
    internal static string CollectionOnlyAcceptsInputBindings;
    internal static string CollectionOnlyAcceptsInputGestures;
    internal static string Collection_BadDestArray;
    internal static string Collection_BadRank;
    internal static string Collection_BadType;
    internal static string Collection_CopyTo_ArrayCannotBeMultidimensional;
    internal static string Collection_CopyTo_IndexGreaterThanOrEqualToArrayLength;
    internal static string Collection_CopyTo_NumberOfElementsExceedsArrayLength;
    internal static string Collection_NoNull;
    internal static string ColorContext_FileTooLarge;
    internal static string Color_ColorContextNotsRGB_or_scRGB;
    internal static string Color_ColorContextTypeMismatch;
    internal static string Color_DimensionMismatch;
    internal static string Color_NullColorContext;
    internal static string CompatibilityPreferencesSealed;
    internal static string CompileFeatureSet_InvalidTypographyProperties;
    internal static string CompositeFontAttributeValue1;
    internal static string CompositeFontAttributeValue2;
    internal static string CompositeFontInvalidUnicodeRange;
    internal static string CompositeFontMissingAttribute;
    internal static string CompositeFontMissingElement;
    internal static string CompositeFontSignificantWhitespace;
    internal static string CompositeFontUnknownAttribute;
    internal static string CompositeFontUnknownElement;
    internal static string CompositeFont_DuplicateTypeface;
    internal static string CompositeFont_TooManyFamilyMaps;
    internal static string CompositionTarget_RootVisual_HasParent;
    internal static string ConstructorRecursion;
    internal static string ContextMenuKeyDisplayString;
    internal static string ContextMenuText;
    internal static string Converter_ConvertFromNotSupported;
    internal static string Converter_ConvertToNotSupported;
    internal static string CopyKeyDisplayString;
    internal static string CopyText;
    internal static string CorrectionListKey;
    internal static string CorrectionListKeyDisplayString;
    internal static string CorrectionListText;
    internal static string CountOfBitsGreatThanRemainingBits;
    internal static string CountOfBitsOutOfRange;
    internal static string CreateBreaksFailure;
    internal static string CreateContextFailure;
    internal static string CreateLineFailure;
    internal static string CreateParaBreakingSessionFailure;
    internal static string CurrentDispatcherNotFound;
    internal static string Cursor_InvalidStream;
    internal static string Cursor_LoadImageFailure;
    internal static string Cursor_UnsupportedFormat;
    internal static string CutKeyDisplayString;
    internal static string CutText;
    internal static string D3DImage_AARequires9Ex;
    internal static string D3DImage_InvalidDevice;
    internal static string D3DImage_InvalidPool;
    internal static string D3DImage_InvalidUsage;
    internal static string D3DImage_MustHaveBackBuffer;
    internal static string D3DImage_SurfaceTooBig;
    internal static string DataObject_CannotSetDataOnAFozenOLEDataDbject;
    internal static string DataObject_DataFormatNotPresentOnDataObject;
    internal static string DataObject_DataObjectMustHaveAtLeastOneFormat;
    internal static string DataObject_EmptyFormatNotAllowed;
    internal static string DataObject_FileDropListHasInvalidFileDropPath;
    internal static string DataObject_FileDropListIsEmpty;
    internal static string DataObject_NotImplementedEnumFormatEtc;
    internal static string DecompressPacketDataFailed;
    internal static string DecompressPropertyFailed;
    internal static string DecreaseZoomKey;
    internal static string DecreaseZoomKeyDisplayString;
    internal static string DecreaseZoomText;
    internal static string DeleteKeyDisplayString;
    internal static string DeleteText;
    internal static string DirectoryNotFoundExceptionWithFileName;
    internal static string DragDrop_DragActionInvalid;
    internal static string DragDrop_DragDropEffectsInvalid;
    internal static string DrawingContext_TooManyPops;
    internal static string DrawingGroup_AlreadyOpen;
    internal static string DrawingGroup_CannotAppendToFrozenCollection;
    internal static string DrawingGroup_CannotAppendToNullCollection;
    internal static string DuplicateApplicationGestureFound;
    internal static string DuplicateEventName;
    internal static string DuplicateStrokeAdded;
    internal static string Effect_20ShaderUsing30Registers;
    internal static string Effect_CombinedLegacyAndNew;
    internal static string Effect_No_ContextInputSource;
    internal static string Effect_No_InputSource;
    internal static string Effect_PixelFormat;
    internal static string Effect_RenderThreadError;
    internal static string Effect_Shader20ConstantRegisterLimit;
    internal static string Effect_Shader20SamplerRegisterLimit;
    internal static string Effect_Shader30BoolConstantRegisterLimit;
    internal static string Effect_Shader30FloatConstantRegisterLimit;
    internal static string Effect_Shader30IntConstantRegisterLimit;
    internal static string Effect_Shader30SamplerRegisterLimit;
    internal static string Effect_ShaderBytecodeSize;
    internal static string Effect_ShaderBytecodeSource;
    internal static string Effect_ShaderConstantType;
    internal static string Effect_ShaderEffectPadding;
    internal static string Effect_ShaderPixelShaderSet;
    internal static string Effect_ShaderSamplerType;
    internal static string Effect_ShaderSeekableStream;
    internal static string Effect_SourceUriMustBeFileOrPack;
    internal static string EmptyArray;
    internal static string EmptyArrayNotAllowedAsArgument;
    internal static string EmptyDataToLoad;
    internal static string EmptyScToReplace;
    internal static string EmptyScToReplaceWith;
    internal static string EndHitTestingCalled;
    internal static string EndOfStreamReached;
    internal static string Enumerator_CollectionChanged;
    internal static string Enumerator_NotStarted;
    internal static string Enumerator_ReachedEnd;
    internal static string Enumerator_VerifyContext;
    internal static string EnumLineFailure;
    internal static string Enum_Invalid;
    internal static string EPExists;
    internal static string EPGuidNotFound;
    internal static string EPNotFound;
    internal static string EventArgIsNull;
    internal static string ExtendSelectionDownKeyDisplayString;
    internal static string ExtendSelectionDownText;
    internal static string ExtendSelectionLeftKeyDisplayString;
    internal static string ExtendSelectionLeftText;
    internal static string ExtendSelectionRightKeyDisplayString;
    internal static string ExtendSelectionRightText;
    internal static string ExtendSelectionUpKeyDisplayString;
    internal static string ExtendSelectionUpText;
    internal static string FaceIndexMustBePositiveOrZero;
    internal static string FaceIndexValidOnlyForTTC;
    internal static string FamilyCollection_CannotFindCompositeFontsLocation;
    internal static string FamilyMap_TargetNotSet;
    internal static string FavoritesKeyDisplayString;
    internal static string FavoritesText;
    internal static string FileFormatException;
    internal static string FileFormatExceptionWithFileName;
    internal static string FileNotFoundExceptionWithFileName;
    internal static string FindKeyDisplayString;
    internal static string FindText;
    internal static string FirstPageKey;
    internal static string FirstPageKeyDisplayString;
    internal static string FirstPageText;
    internal static string FloatUnknownBamlType;
    internal static string FlushNotSupported;
    internal static string FontFamily_ReadOnly;
    internal static string Freezable_CantBeFrozen;
    internal static string Freezable_CloneInvalidType;
    internal static string Freezable_Reentrant;
    internal static string Freezable_UnexpectedChange;
    internal static string GeneralTransform_TransformFailed;
    internal static string General_BadType;
    internal static string General_Expected_Type;
    internal static string General_ObjectIsReadOnly;
    internal static string Geometry_BadNumber;
    internal static string GestureRecognizerNotAvailable;
    internal static string GetPenaltyModuleHandleFailure;
    internal static string GetResponseFailed;
    internal static string GlyphAreaTooBig;
    internal static string GlyphCoordinateTooBig;
    internal static string GlyphIndexOutOfRange;
    internal static string GlyphTypefaceNotRecorded;
    internal static string GoToPageKey;
    internal static string GoToPageKeyDisplayString;
    internal static string GoToPageText;
    internal static string HandlerTypeIllegal;
    internal static string HelpKeyDisplayString;
    internal static string HelpText;
    internal static string HitTest_Invalid;
    internal static string HitTest_Singular;
    internal static string HwndSourceDisposed;
    internal static string HwndTarget_HardwareNotSupportDueToProtocolMismatch;
    internal static string HwndTarget_InvalidWindowHandle;
    internal static string HwndTarget_InvalidWindowProcess;
    internal static string HwndTarget_InvalidWindowThread;
    internal static string HwndTarget_WindowAlreadyHasContent;
    internal static string IAnimatable_CantAnimateSealedDO;
    internal static string Image_AlphaThresholdOutOfRange;
    internal static string Image_BadDimensions;
    internal static string Image_BadMetadataHeader;
    internal static string Image_BadPixelFormat;
    internal static string Image_BadStreamData;
    internal static string Image_BadVersion;
    internal static string Image_CannotCreateTempFile;
    internal static string Image_CantBeFrozen;
    internal static string Image_CantDealWithStream;
    internal static string Image_CantDealWithUri;
    internal static string Image_CodecPresent;
    internal static string Image_ColorContextInvalid;
    internal static string Image_ColorTransformInvalid;
    internal static string Image_ComponentNotFound;
    internal static string Image_ContentTypeDoesNotMatchDecoder;
    internal static string Image_DecoderError;
    internal static string Image_DisplayStateInvalid;
    internal static string Image_DuplicateMetadataPresent;
    internal static string Image_EncoderNoColorContext;
    internal static string Image_EncoderNoGlobalMetadata;
    internal static string Image_EncoderNoGlobalThumbnail;
    internal static string Image_EncoderNoPreview;
    internal static string Image_EndInitWithoutBeginInit;
    internal static string Image_FrameMissing;
    internal static string Image_FreezableCloneNotAllowed;
    internal static string Image_GuidEmpty;
    internal static string Image_HeaderError;
    internal static string Image_IndexedPixelFormatRequiresPalette;
    internal static string Image_InInitialize;
    internal static string Image_InitializationIncomplete;
    internal static string Image_InplaceMetadataNoCopy;
    internal static string Image_InsufficientBuffer;
    internal static string Image_InsufficientBufferSize;
    internal static string Image_InternalError;
    internal static string Image_InvalidArrayForPixel;
    internal static string Image_InvalidColorContext;
    internal static string Image_InvalidQueryCharacter;
    internal static string Image_InvalidQueryRequest;
    internal static string Image_LockCountLimit;
    internal static string Image_MetadataInitializationIncomplete;
    internal static string Image_MetadataNotCompatible;
    internal static string Image_MetadataNotSupported;
    internal static string Image_MetadataReadOnly;
    internal static string Image_MetadataSizeFixed;
    internal static string Image_MustBeLocked;
    internal static string Image_NeitherArgument;
    internal static string Image_NoArgument;
    internal static string Image_NoCodecsFound;
    internal static string Image_NoDecodeFrames;
    internal static string Image_NoFrames;
    internal static string Image_NoPalette;
    internal static string Image_NoPixelFormatFound;
    internal static string Image_NoThumbnail;
    internal static string Image_NotInitialized;
    internal static string Image_OnlyOneInit;
    internal static string Image_OnlyOneSave;
    internal static string Image_OnlyOrthogonal;
    internal static string Image_OriginalStreamReadOnly;
    internal static string Image_Overflow;
    internal static string Image_PaletteColorsDoNotMatchFormat;
    internal static string Image_PaletteFixedType;
    internal static string Image_PaletteZeroColors;
    internal static string Image_PropertyNotFound;
    internal static string Image_PropertyNotSupported;
    internal static string Image_PropertySize;
    internal static string Image_PropertyUnexpectedType;
    internal static string Image_RequestOnlyValidAtMetadataRoot;
    internal static string Image_SetPropertyOutsideBeginEndInit;
    internal static string Image_SingularMatrix;
    internal static string Image_SizeOptionsAngle;
    internal static string Image_SizeOutOfRange;
    internal static string Image_StreamNotAvailable;
    internal static string Image_StreamRead;
    internal static string Image_StreamWrite;
    internal static string Image_TooManyScanlines;
    internal static string Image_TooMuchMetadata;
    internal static string Image_UnexpectedMetadataType;
    internal static string Image_UnknownFormat;
    internal static string Image_UnsupportedOperation;
    internal static string Image_UnsupportedPixelFormat;
    internal static string Image_WrongState;
    internal static string IncompatibleStylusPointDescriptions;
    internal static string IncreaseZoomKey;
    internal static string IncreaseZoomKeyDisplayString;
    internal static string IncreaseZoomText;
    internal static string InInitialization;
    internal static string InitializationIncomplete;
    internal static string InitializingCompressorFailed;
    internal static string InnerRequestNotAllowed;
    internal static string InputBinding_ExpectedInputGesture;
    internal static string InputLanguageManager_NotReadyToChangeCurrentLanguage;
    internal static string InputMethod_InvalidConversionMode;
    internal static string InputMethod_InvalidSentenceMode;
    internal static string InputProviderSiteDisposed;
    internal static string InputScope_InvalidInputScopeName;
    internal static string IntegerCollectionLengthLessThanZero;
    internal static string InvalidAbsoluteUriInFontFamilyName;
    internal static string InvalidAdditionalDataForStylusPoint;
    internal static string InvalidBufferLength;
    internal static string InvalidByteRanges;
    internal static string InvalidCursorType;
    internal static string InvalidDataInISF;
    internal static string InvalidDataTypeForExtendedProperty;
    internal static string InvalidDiameter;
    internal static string InvalidDrawingAttributesHeight;
    internal static string InvalidDrawingAttributesWidth;
    internal static string InvalidEpInIsf;
    internal static string InvalidEventHandle;
    internal static string InvalidGuid;
    internal static string InvalidIsButtonForId;
    internal static string InvalidIsButtonForId2;
    internal static string InvalidMatrixContainsInfinity;
    internal static string InvalidMatrixContainsNaN;
    internal static string InvalidMinMaxForButton;
    internal static string InvalidPartName;
    internal static string InvalidPermissionStateValue;
    internal static string InvalidPermissionType;
    internal static string InvalidPressureValue;
    internal static string InvalidRemovedStroke;
    internal static string InvalidReplacedStroke;
    internal static string InvalidScheme;
    internal static string InvalidSiteOfOriginUri;
    internal static string InvalidSizeSpecified;
    internal static string InvalidStream;
    internal static string InvalidSttValue;
    internal static string InvalidStylusPointCollectionZeroCount;
    internal static string InvalidStylusPointConstructionZeroLengthCollection;
    internal static string InvalidStylusPointDescription;
    internal static string InvalidStylusPointDescriptionButtonsMustBeLast;
    internal static string InvalidStylusPointDescriptionDuplicatesFound;
    internal static string InvalidStylusPointDescriptionSubset;
    internal static string InvalidStylusPointDescriptionTooManyButtons;
    internal static string InvalidStylusPointProperty;
    internal static string InvalidStylusPointPropertyInfoResolution;
    internal static string InvalidStylusPointXYNaN;
    internal static string InvalidTempFileName;
    internal static string InvalidTextDecorationCollectionString;
    internal static string InvalidValueOfType;
    internal static string InvalidValueType;
    internal static string InvalidValueType1;
    internal static string Invalid_IInputElement;
    internal static string Invalid_isfData_Length;
    internal static string Invalid_URI;
    internal static string IOBufferOverflow;
    internal static string IOExceptionWithFileName;
    internal static string IsfOperationFailed;
    internal static string KeyboardSinkAlreadyOwned;
    internal static string KeyboardSinkMustBeAnElement;
    internal static string KeyboardSinkNotAChild;
    internal static string KeyGesture_Invalid;
    internal static string LastPageKey;
    internal static string LastPageKeyDisplayString;
    internal static string LastPageText;
    internal static string LayoutManager_DeepRecursion;
    internal static string Manipulation_InvalidManipulationMode;
    internal static string Manipulation_ManipulationNotActive;
    internal static string Manipulation_ManipulationNotEnabled;
    internal static string Matrix3D_NotInvertible;
    internal static string MatrixNotInvertible;
    internal static string MediaBoostBassKey;
    internal static string MediaBoostBassKeyDisplayString;
    internal static string MediaBoostBassText;
    internal static string MediaChannelDownKey;
    internal static string MediaChannelDownKeyDisplayString;
    internal static string MediaChannelDownText;
    internal static string MediaChannelUpKey;
    internal static string MediaChannelUpKeyDisplayString;
    internal static string MediaChannelUpText;
    internal static string MediaContext_APINotAllowed;
    internal static string MediaContext_InfiniteLayoutLoop;
    internal static string MediaContext_InfiniteTickLoop;
    internal static string MediaContext_NoBadShaderHandler;
    internal static string MediaContext_OutOfVideoMemory;
    internal static string MediaContext_RenderThreadError;
    internal static string MediaDecreaseBassKey;
    internal static string MediaDecreaseBassKeyDisplayString;
    internal static string MediaDecreaseBassText;
    internal static string MediaDecreaseMicrophoneVolumeKey;
    internal static string MediaDecreaseMicrophoneVolumeKeyDisplayString;
    internal static string MediaDecreaseMicrophoneVolumeText;
    internal static string MediaDecreaseTrebleKey;
    internal static string MediaDecreaseTrebleKeyDisplayString;
    internal static string MediaDecreaseTrebleText;
    internal static string MediaDecreaseVolumeKey;
    internal static string MediaDecreaseVolumeKeyDisplayString;
    internal static string MediaDecreaseVolumeText;
    internal static string MediaFastForwardKey;
    internal static string MediaFastForwardKeyDisplayString;
    internal static string MediaFastForwardText;
    internal static string MediaIncreaseBassKey;
    internal static string MediaIncreaseBassKeyDisplayString;
    internal static string MediaIncreaseBassText;
    internal static string MediaIncreaseMicrophoneVolumeKey;
    internal static string MediaIncreaseMicrophoneVolumeKeyDisplayString;
    internal static string MediaIncreaseMicrophoneVolumeText;
    internal static string MediaIncreaseTrebleKey;
    internal static string MediaIncreaseTrebleKeyDisplayString;
    internal static string MediaIncreaseTrebleText;
    internal static string MediaIncreaseVolumeKey;
    internal static string MediaIncreaseVolumeKeyDisplayString;
    internal static string MediaIncreaseVolumeText;
    internal static string MediaMuteMicrophoneVolumeKey;
    internal static string MediaMuteMicrophoneVolumeKeyDisplayString;
    internal static string MediaMuteMicrophoneVolumeText;
    internal static string MediaMuteVolumeKey;
    internal static string MediaMuteVolumeKeyDisplayString;
    internal static string MediaMuteVolumeText;
    internal static string MediaNextTrackKey;
    internal static string MediaNextTrackKeyDisplayString;
    internal static string MediaNextTrackText;
    internal static string MediaPauseKey;
    internal static string MediaPauseKeyDisplayString;
    internal static string MediaPauseText;
    internal static string MediaPlayKey;
    internal static string MediaPlayKeyDisplayString;
    internal static string MediaPlayText;
    internal static string MediaPreviousTrackKey;
    internal static string MediaPreviousTrackKeyDisplayString;
    internal static string MediaPreviousTrackText;
    internal static string MediaRecordKey;
    internal static string MediaRecordKeyDisplayString;
    internal static string MediaRecordText;
    internal static string MediaRewindKey;
    internal static string MediaRewindKeyDisplayString;
    internal static string MediaRewindText;
    internal static string MediaSelectKey;
    internal static string MediaSelectKeyDisplayString;
    internal static string MediaSelectText;
    internal static string MediaStopKey;
    internal static string MediaStopKeyDisplayString;
    internal static string MediaStopText;
    internal static string MediaSystem_ApiInvalidContext;
    internal static string MediaSystem_OutOfOrderConnectOrDisconnect;
    internal static string MediaToggleMicrophoneOnOffKey;
    internal static string MediaToggleMicrophoneOnOffKeyDisplayString;
    internal static string MediaToggleMicrophoneOnOffText;
    internal static string MediaTogglePlayPauseKey;
    internal static string MediaTogglePlayPauseKeyDisplayString;
    internal static string MediaTogglePlayPauseText;
    internal static string Media_DownloadFailed;
    internal static string Media_FileFormatNotSupported;
    internal static string Media_FileNotFound;
    internal static string Media_HardwareVideoAccelerationNotAvailable;
    internal static string Media_InsufficientVideoResources;
    internal static string Media_InvalidArgument;
    internal static string Media_InvalidWmpVersion;
    internal static string Media_LogonFailure;
    internal static string Media_NotAllowedWhileTimingEngineInControl;
    internal static string Media_PackURIsAreNotSupported;
    internal static string Media_PlayerIsClosed;
    internal static string Media_PlaylistFormatNotSupported;
    internal static string Media_StreamClosed;
    internal static string Media_UninitializedResource;
    internal static string Media_UnknownChannelType;
    internal static string Media_UnknownMediaExecption;
    internal static string Media_UriNotSpecified;
    internal static string MethodCallNotAllowed;
    internal static string MilErr_UnsupportedVersion;
    internal static string Mismatched_RoutedEvent;
    internal static string MoveDownKeyDisplayString;
    internal static string MoveDownText;
    internal static string MoveFocusBackKeyDisplayString;
    internal static string MoveFocusBackText;
    internal static string MoveFocusDownKeyDisplayString;
    internal static string MoveFocusDownText;
    internal static string MoveFocusForwardKeyDisplayString;
    internal static string MoveFocusForwardText;
    internal static string MoveFocusPageDownKeyDisplayString;
    internal static string MoveFocusPageDownText;
    internal static string MoveFocusPageUpKeyDisplayString;
    internal static string MoveFocusPageUpText;
    internal static string MoveFocusUpKeyDisplayString;
    internal static string MoveFocusUpText;
    internal static string MoveLeftKeyDisplayString;
    internal static string MoveLeftText;
    internal static string MoveRightKeyDisplayString;
    internal static string MoveRightText;
    internal static string MoveToEndKeyDisplayString;
    internal static string MoveToEndText;
    internal static string MoveToHomeKeyDisplayString;
    internal static string MoveToHomeText;
    internal static string MoveToPageDownKeyDisplayString;
    internal static string MoveToPageDownText;
    internal static string MoveToPageUpKeyDisplayString;
    internal static string MoveToPageUpText;
    internal static string MoveUpKeyDisplayString;
    internal static string MoveUpText;
    internal static string MultiSingleton;
    internal static string NavigateJournalKey;
    internal static string NavigateJournalKeyDisplayString;
    internal static string NavigateJournalText;
    internal static string NewKeyDisplayString;
    internal static string NewText;
    internal static string NextPageKey;
    internal static string NextPageKeyDisplayString;
    internal static string NextPageText;
    internal static string NonCLSException;
    internal static string NonPackAppAbsoluteUriNotAllowed;
    internal static string NonWhiteSpaceInAddText;
    internal static string NotACommandText;
    internal static string NotAllowedPackageUri;
    internal static string NotAllowedToAccessStagingArea;
    internal static string NotInInitialization;
    internal static string NullBaseUriParam;
    internal static string NullHwnd;
    internal static string OffsetNegative;
    internal static string OleRegisterDragDropFailure;
    internal static string OleRevokeDragDropFailure;
    internal static string OleServicesContext_oleInitializeFailure;
    internal static string OleServicesContext_ThreadMustBeSTA;
    internal static string OnlyAcceptsKeyMessages;
    internal static string OnlyOneInitialization;
    internal static string OpenKeyDisplayString;
    internal static string OpenText;
    internal static string OptimalParagraphMustWrap;
    internal static string PackageAlreadyExists;
    internal static string PackWebRequestCachePolicyIllegal;
    internal static string PaginatorMissingContentPosition;
    internal static string PaginatorNegativePageNumber;
    internal static string ParameterCannotBeGreaterThan;
    internal static string ParameterCannotBeLessThan;
    internal static string ParameterCannotBeNegative;
    internal static string ParameterMustBeBetween;
    internal static string ParameterMustBeGreaterThanZero;
    internal static string ParameterValueCannotBeInfinity;
    internal static string ParameterValueCannotBeNaN;
    internal static string ParameterValueCannotBeNegative;
    internal static string ParameterValueMustBeGreaterThanZero;
    internal static string Parsers_IllegalToken;
    internal static string Parsers_IllegalToken_250_Chars;
    internal static string Parser_BadForm;
    internal static string Parser_Empty;
    internal static string Parser_UnexpectedToken;
    internal static string PasteKeyDisplayString;
    internal static string PasteText;
    internal static string PathGeometry_InternalReadBackError;
    internal static string PathTooLongExceptionWithFileName;
    internal static string Penservice_Disposed;
    internal static string PenService_InvalidPacketData;
    internal static string PenService_WindowAlreadyRegistered;
    internal static string PenService_WindowNotRegistered;
    internal static string PreviousPageKey;
    internal static string PreviousPageKeyDisplayString;
    internal static string PreviousPageText;
    internal static string PrintKeyDisplayString;
    internal static string PrintPreviewKeyDisplayString;
    internal static string PrintPreviewText;
    internal static string PrintText;
    internal static string PropertiesKeyDisplayString;
    internal static string PropertiesText;
    internal static string PropertyCannotBeNegative;
    internal static string PropertyMustBeGreaterThanZero;
    internal static string PropertyOfClassCannotBeGreaterThan;
    internal static string PropertyOfClassCannotBeNull;
    internal static string PropertyOfClassMustBeGreaterThanZero;
    internal static string PropertyValueCannotBeNaN;
    internal static string Quaternion_ZeroAxisSpecified;
    internal static string QueryLineFailure;
    internal static string ReadCountNegative;
    internal static string ReadOnlyInputGesturesCollection;
    internal static string Rect3D_CannotCallMethod;
    internal static string Rect3D_CannotModifyEmptyRect;
    internal static string Rect_Empty;
    internal static string RedoKeyDisplayString;
    internal static string RedoText;
    internal static string ReentrantVisualTreeChangeError;
    internal static string ReentrantVisualTreeChangeWarning;
    internal static string RefreshKeyDisplayString;
    internal static string RefreshText;
    internal static string RelievePenaltyResourceFailure;
    internal static string ReplaceKeyDisplayString;
    internal static string ReplaceText;
    internal static string RequestAlreadyStarted;
    internal static string RequiresSTA;
    internal static string ResourceNotFoundUnderCacheOnlyPolicy;
    internal static string RoutedEventArgsMustHaveRoutedEvent;
    internal static string RoutedEventCannotChangeWhileRouting;
    internal static string SaveAsText;
    internal static string SaveKeyDisplayString;
    internal static string SaveText;
    internal static string SCDataChanged;
    internal static string SCErasePath;
    internal static string SCEraseShape;
    internal static string SchemaInvalidForTransport;
    internal static string ScopeMustBeUIElementOrContent;
    internal static string ScrollByLineKey;
    internal static string ScrollByLineKeyDisplayString;
    internal static string ScrollByLineText;
    internal static string ScrollPageDownKeyDisplayString;
    internal static string ScrollPageDownText;
    internal static string ScrollPageLeftKey;
    internal static string ScrollPageLeftKeyDisplayString;
    internal static string ScrollPageLeftText;
    internal static string ScrollPageRightKey;
    internal static string ScrollPageRightKeyDisplayString;
    internal static string ScrollPageRightText;
    internal static string ScrollPageUpKeyDisplayString;
    internal static string ScrollPageUpText;
    internal static string SearchKey;
    internal static string SearchKeyDisplayString;
    internal static string SearchText;
    internal static string SecurityExceptionForSettingSandboxExternalToTrue;
    internal static string SeekNegative;
    internal static string SeekOriginInvalid;
    internal static string SelectAllKeyDisplayString;
    internal static string SelectAllText;
    internal static string SelectToEndKeyDisplayString;
    internal static string SelectToEndText;
    internal static string SelectToHomeKeyDisplayString;
    internal static string SelectToHomeText;
    internal static string SelectToPageDownKeyDisplayString;
    internal static string SelectToPageDownText;
    internal static string SelectToPageUpKeyDisplayString;
    internal static string SelectToPageUpText;
    internal static string SetBreakingFailure;
    internal static string SetDocFailure;
    internal static string SetFocusFailed;
    internal static string SetLengthNotSupported;
    internal static string SetTabsFailure;
    internal static string SidewaysRTLTextIsNotSupported;
    internal static string Size3D_CannotModifyEmptySize;
    internal static string Size3D_DimensionCannotBeNegative;
    internal static string SourceNotSet;
    internal static string SpecificNumberCultureRequired;
    internal static string StopKeyDisplayString;
    internal static string StopText;
    internal static string StreamGeometry_NeedBeginFigure;
    internal static string StringEmpty;
    internal static string StrokeCollectionCountTooBig;
    internal static string StrokeCollectionIsReadOnly;
    internal static string StrokeIsDuplicated;
    internal static string StrokesNotContiguously;
    internal static string Stylus_CanOnlyCallForDownMoveOrUp;
    internal static string Stylus_EnumeratorFailure;
    internal static string Stylus_IndexOutOfRange;
    internal static string Stylus_InvalidMax;
    internal static string Stylus_MatrixNotInvertable;
    internal static string Stylus_MustBeDownToCallReset;
    internal static string Stylus_PenContextFailure;
    internal static string Stylus_PlugInIsDuplicated;
    internal static string Stylus_PlugInIsNull;
    internal static string Stylus_PlugInNotExist;
    internal static string Stylus_StylusPointsCantBeEmpty;
    internal static string TextBreakpointHasBeenDisposed;
    internal static string TextCompositionManager_NoInputManager;
    internal static string TextCompositionManager_TextCompositionHasDone;
    internal static string TextCompositionManager_TextCompositionHasStarted;
    internal static string TextCompositionManager_TextCompositionNotStarted;
    internal static string TextComposition_NullResultText;
    internal static string TextFormatterReentranceProhibited;
    internal static string TextLineHasBeenDisposed;
    internal static string TextObjectMetrics_WidthOutOfRange;
    internal static string TextPenaltyModuleHasBeenDisposed;
    internal static string TextProvider_InvalidChild;
    internal static string TextRangeProvider_InvalidRangeProvider;
    internal static string TextRunPropertiesCannotBeNull;
    internal static string Timing_AccelAndDecelGreaterThanOne;
    internal static string Timing_CanSlipOnlyOnSimpleTimelines;
    internal static string Timing_ChildMustBeTimeline;
    internal static string Timing_CreateClockMustReturnNewClock;
    internal static string Timing_DifferentThreads;
    internal static string Timing_EnumeratorInvalidated;
    internal static string Timing_EnumeratorOutOfRange;
    internal static string Timing_InvalidArgAccelAndDecel;
    internal static string Timing_InvalidArgFiniteNonNegative;
    internal static string Timing_InvalidArgFinitePositive;
    internal static string Timing_InvalidArgNonNegative;
    internal static string Timing_InvalidArgPositive;
    internal static string Timing_NoTextChildren;
    internal static string Timing_NotTimeSpan;
    internal static string Timing_OperationEnqueuedOutOfOrder;
    internal static string Timing_RepeatBehaviorInvalidIterationCount;
    internal static string Timing_RepeatBehaviorInvalidRepeatDuration;
    internal static string Timing_RepeatBehaviorNotIterationCount;
    internal static string Timing_RepeatBehaviorNotRepeatDuration;
    internal static string Timing_SeekDestinationAmbiguousDueToSlip;
    internal static string Timing_SeekDestinationIndefinite;
    internal static string Timing_SeekDestinationNegative;
    internal static string Timing_SkipToFillDestinationIndefinite;
    internal static string Timing_SlipBehavior_SlipOnlyOnSimpleTimelines;
    internal static string Timing_SlipBehavior_SyncOnlyWithSimpleParents;
    internal static string TokenizerHelperEmptyToken;
    internal static string TokenizerHelperExtraDataEncountered;
    internal static string TokenizerHelperMissingEndQuote;
    internal static string TokenizerHelperPrematureStringTermination;
    internal static string TooManyGlyphRuns;
    internal static string TooManyRoutedEvents;
    internal static string Touch_Category;
    internal static string Touch_DeviceAlreadyActivated;
    internal static string Touch_DeviceNotActivated;
    internal static string TreeLoop;
    internal static string TypeMetadataCannotChangeAfterUse;
    internal static string UIElement_Layout_InfinityArrange;
    internal static string UIElement_Layout_NaNMeasure;
    internal static string UIElement_Layout_NaNReturned;
    internal static string UIElement_Layout_PositiveInfinityReturned;
    internal static string UnauthorizedAccessExceptionWithFileName;
    internal static string UndoKeyDisplayString;
    internal static string UndoText;
    internal static string UnexpectedParameterType;
    internal static string UnexpectedStroke;
    internal static string UnknownPathOperationType;
    internal static string UnknownStroke;
    internal static string UnknownStroke1;
    internal static string UnknownStroke3;
    internal static string UnspecifiedGestureConstructionException;
    internal static string UnspecifiedGestureException;
    internal static string UnspecifiedSetEnabledGesturesException;
    internal static string Unsupported_MouseAction;
    internal static string UriMustBeAbsolute;
    internal static string UriMustBeFileOrPack;
    internal static string UriNotAbsolute;
    internal static string UriSchemeMismatch;
    internal static string UsesPerPixelOpacityIsObsolete;
    internal static string ValueNotValidForGuid;
    internal static string Viewport2DVisual3D_MaterialGroupIsInteractiveMaterial;
    internal static string Viewport2DVisual3D_MultipleInteractiveMaterials;
    internal static string VisualCannotBeDetached;
    internal static string VisualCollection_EntryInUse;
    internal static string VisualCollection_NotEnoughCapacity;
    internal static string VisualCollection_ReadOnly;
    internal static string VisualCollection_VisualHasParent;
    internal static string VisualTarget_AnotherTargetAlreadyConnected;
    internal static string Visual_ArgumentOutOfRange;
    internal static string Visual_CannotTransformPoint;
    internal static string Visual_HasParent;
    internal static string Visual_NoCommonAncestor;
    internal static string Visual_NoPresentationSource;
    internal static string Visual_NotA3DVisual;
    internal static string Visual_NotADescendant;
    internal static string Visual_NotAnAncestor;
    internal static string Visual_NotAVisual;
    internal static string Visual_NotChild;
    internal static string WebRequestTimeout;
    internal static string WebResponseCloseFailure;
    internal static string WebResponseFailure;
    internal static string WebResponsePartNotFound;
    internal static string WIC_NotInitialized;
    internal static string WriteNotSupported;
    internal static string WrongFirstSegment;
    internal static string XmlLangGetCultureFailure;
    internal static string XmlLangGetSpecificCulture;
    internal static string XmlLangMalformed;
    internal static string ZoomKey;
    internal static string ZoomKeyDisplayString;
    internal static string ZoomText;
    internal static string PenImcDllVerificationFailed;
    internal static string PenImcSxSRegistrationFailed;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
}
internal class MS.Internal.PresentationCore.WeakRefKey : WeakReference {
    private int _hashCode;
    public WeakRefKey(object target);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public static bool op_Equality(WeakRefKey left, WeakRefKey right);
    public static bool op_Inequality(WeakRefKey left, WeakRefKey right);
}
[ExtensionAttribute]
internal static class MS.Internal.PresentationCore.WindowsRuntime.ReflectionHelper : object {
    [ExtensionAttribute]
public static TResult ReflectionStaticCall(Type type, string methodName);
    [ExtensionAttribute]
public static TResult ReflectionStaticCall(Type type, string methodName, TArg arg);
    [ExtensionAttribute]
public static TResult ReflectionCall(object obj, string methodName);
    [ExtensionAttribute]
public static object ReflectionCall(object obj, string methodName);
    [ExtensionAttribute]
public static object ReflectionCall(object obj, string methodName, TArg1 arg1);
    [ExtensionAttribute]
public static TResult ReflectionCall(object obj, string methodName, TArg1 arg1);
    [ExtensionAttribute]
public static object ReflectionCall(object obj, string methodName, TArg1 arg1, TArg2 arg2);
    [ExtensionAttribute]
public static TResult ReflectionCall(object obj, string methodName, TArg1 arg1, TArg2 arg2);
    [ExtensionAttribute]
public static TResult ReflectionGetField(object obj, string fieldName);
    [ExtensionAttribute]
public static object ReflectionNew(Type type);
    [ExtensionAttribute]
public static object ReflectionNew(Type type, TArg1 arg1);
    [ExtensionAttribute]
public static object ReflectionNew(Type type, TArg1 arg1, TArg2 arg2);
    [ExtensionAttribute]
public static TResult ReflectionGetProperty(object obj, string propertyName);
    [ExtensionAttribute]
public static object ReflectionGetProperty(object obj, string propertyName);
    [ExtensionAttribute]
public static TResult ReflectionStaticGetProperty(Type type, string propertyName);
}
internal static class MS.Internal.Resources.ContentFileHelper : object {
    private static Dictionary`2<string, string> _contentFiles;
    internal static bool IsContentFile(string partName);
    internal static Dictionary`2<string, string> GetContentFiles(Assembly asm);
}
internal class MS.Internal.Resources.ResourceManagerWrapper : object {
    private ResourceManager _resourceManager;
    private ResourceSet _resourceSet;
    private Assembly _assembly;
    private ArrayList _resourceList;
    private static string LocalizableResourceNameSuffix;
    private static string UnLocalizableResourceNameSuffix;
    internal Assembly Assembly { get; internal set; }
    internal IList ResourceList { get; }
    private ResourceSet ResourceSet { get; }
    private ResourceManager ResourceManager { get; }
    internal ResourceManagerWrapper(Assembly assembly);
    internal Stream GetStream(string name);
    internal Assembly get_Assembly();
    internal void set_Assembly(Assembly value);
    internal IList get_ResourceList();
    private CultureInfo GetNeutralResourcesLanguage();
    private void AddResourceNameToList(ResourceSet rs, ArrayList& resourceList);
    private ResourceSet get_ResourceSet();
    private ResourceManager get_ResourceManager();
}
internal enum MS.Internal.ScriptID : Enum {
    public byte value__;
    public static ScriptID Default;
    public static ScriptID Arabic;
    public static ScriptID Armenian;
    public static ScriptID Bengali;
    public static ScriptID Bopomofo;
    public static ScriptID Braille;
    public static ScriptID Buginese;
    public static ScriptID Buhid;
    public static ScriptID CanadianSyllabics;
    public static ScriptID Cherokee;
    public static ScriptID CJKIdeographic;
    public static ScriptID Coptic;
    public static ScriptID CypriotSyllabary;
    public static ScriptID Cyrillic;
    public static ScriptID Deseret;
    public static ScriptID Devanagari;
    public static ScriptID Ethiopic;
    public static ScriptID Georgian;
    public static ScriptID Glagolitic;
    public static ScriptID Gothic;
    public static ScriptID Greek;
    public static ScriptID Gujarati;
    public static ScriptID Gurmukhi;
    public static ScriptID Hangul;
    public static ScriptID Hanunoo;
    public static ScriptID Hebrew;
    public static ScriptID Kannada;
    public static ScriptID Kana;
    public static ScriptID Kharoshthi;
    public static ScriptID Khmer;
    public static ScriptID Lao;
    public static ScriptID Latin;
    public static ScriptID Limbu;
    public static ScriptID LinearB;
    public static ScriptID Malayalam;
    public static ScriptID MathematicalAlphanumericSymbols;
    public static ScriptID Mongolian;
    public static ScriptID MusicalSymbols;
    public static ScriptID Myanmar;
    public static ScriptID NewTaiLue;
    public static ScriptID Ogham;
    public static ScriptID OldItalic;
    public static ScriptID OldPersianCuneiform;
    public static ScriptID Oriya;
    public static ScriptID Osmanya;
    public static ScriptID Runic;
    public static ScriptID Shavian;
    public static ScriptID Sinhala;
    public static ScriptID SylotiNagri;
    public static ScriptID Syriac;
    public static ScriptID Tagalog;
    public static ScriptID Tagbanwa;
    public static ScriptID TaiLe;
    public static ScriptID Tamil;
    public static ScriptID Telugu;
    public static ScriptID Thaana;
    public static ScriptID Thai;
    public static ScriptID Tibetan;
    public static ScriptID Tifinagh;
    public static ScriptID UgariticCuneiform;
    public static ScriptID Yi;
    public static ScriptID Digit;
    public static ScriptID Control;
    public static ScriptID Mirror;
    public static ScriptID Max;
}
internal enum MS.Internal.ScriptTags : Enum {
    public int value__;
    public static ScriptTags Arabic;
    public static ScriptTags Armenian;
    public static ScriptTags Balinese;
    public static ScriptTags Bengali;
    public static ScriptTags Bengali_v2;
    public static ScriptTags Bopomofo;
    public static ScriptTags Braille;
    public static ScriptTags Buginese;
    public static ScriptTags Buhid;
    public static ScriptTags ByzantineMusic;
    public static ScriptTags CanadianSyllabics;
    public static ScriptTags Cherokee;
    public static ScriptTags CJKIdeographic;
    public static ScriptTags Coptic;
    public static ScriptTags CypriotSyllabary;
    public static ScriptTags Cyrillic;
    public static ScriptTags Default;
    public static ScriptTags Deseret;
    public static ScriptTags Devanagari;
    public static ScriptTags Devanagari_v2;
    public static ScriptTags Ethiopic;
    public static ScriptTags Georgian;
    public static ScriptTags Glagolitic;
    public static ScriptTags Gothic;
    public static ScriptTags Greek;
    public static ScriptTags Gujarati;
    public static ScriptTags Gujarati_v2;
    public static ScriptTags Gurmukhi;
    public static ScriptTags Gurmukhi_v2;
    public static ScriptTags HangulJamo;
    public static ScriptTags Hangul;
    public static ScriptTags Hanunoo;
    public static ScriptTags Hebrew;
    public static ScriptTags Hiragana;
    public static ScriptTags Javanese;
    public static ScriptTags Kannada;
    public static ScriptTags Kannada_v2;
    public static ScriptTags Katakana;
    public static ScriptTags Kharosthi;
    public static ScriptTags Khmer;
    public static ScriptTags Lao;
    public static ScriptTags Latin;
    public static ScriptTags Limbu;
    public static ScriptTags LinearB;
    public static ScriptTags Malayalam;
    public static ScriptTags Malayalam_v2;
    public static ScriptTags MathematicalAlphanumericSymbols;
    public static ScriptTags Mongolian;
    public static ScriptTags MusicalSymbols;
    public static ScriptTags Myanmar;
    public static ScriptTags Nko;
    public static ScriptTags Ogham;
    public static ScriptTags OldItalic;
    public static ScriptTags OldPersianCuneiform;
    public static ScriptTags Oriya;
    public static ScriptTags Oriya_v2;
    public static ScriptTags Osmanya;
    public static ScriptTags Phagspa;
    public static ScriptTags Phoenician;
    public static ScriptTags Runic;
    public static ScriptTags Shavian;
    public static ScriptTags Sinhala;
    public static ScriptTags SumeroAkkadianCuneiform;
    public static ScriptTags SylotiNagri;
    public static ScriptTags Syriac;
    public static ScriptTags Tagalog;
    public static ScriptTags Tagbanwa;
    public static ScriptTags TaiLe;
    public static ScriptTags NewTaiLue;
    public static ScriptTags Tamil;
    public static ScriptTags Tamil_v2;
    public static ScriptTags Telugu;
    public static ScriptTags Telugu_v2;
    public static ScriptTags Thaana;
    public static ScriptTags Thai;
    public static ScriptTags Tibetan;
    public static ScriptTags Tifinagh;
    public static ScriptTags UgariticCuneiform;
    public static ScriptTags Yi;
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.SecurityCriticalDataForMultipleGetAndSet`1 : object {
    private T _value;
    internal T Value { get; internal set; }
    internal SecurityCriticalDataForMultipleGetAndSet`1(T value);
    internal T get_Value();
    internal void set_Value(T value);
}
internal static class MS.Internal.SecurityHelper : object {
    internal static Uri GetBaseDirectory(AppDomain domain);
    internal static int MapUrlToZoneWrapper(Uri uri);
    internal static Exception GetExceptionForHR(int hr);
    internal static void ThrowExceptionForHR(int hr);
    internal static int GetHRForException(Exception exception);
    internal static bool AreStringTypesEqual(string m1, string m2);
}
internal class MS.Internal.SequentialUshortCollection : object {
    private ushort _count;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public SequentialUshortCollection(ushort count);
    public sealed virtual void Add(ushort item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(ushort item);
    public sealed virtual void CopyTo(UInt16[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(ushort item);
    [IteratorStateMachineAttribute("MS.Internal.SequentialUshortCollection/<GetEnumerator>d__10")]
public sealed virtual IEnumerator`1<ushort> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class MS.Internal.Shaping.AlternateSubstitutionSubtable : ValueType {
    private static int offsetFormat;
    private static int offsetCoverage;
    private static int offsetAlternateSetCount;
    private static int offsetAlternateSets;
    private static int sizeAlternateSetOffset;
    private static ushort InvalidAlternateGlyph;
    private int offset;
    public AlternateSubstitutionSubtable(int Offset);
    public ushort Format(FontTable Table);
    private CoverageTable Coverage(FontTable Table);
    private AlternateSetTable AlternateSet(FontTable Table, int index);
    public bool Apply(FontTable Table, GlyphInfoList GlyphInfo, UInt32 FeatureParam, int FirstGlyph, Int32& NextGlyph);
    public bool IsLookupCovered(FontTable table, UInt32[] glyphBits, ushort minGlyphId, ushort maxGlyphId);
    public CoverageTable GetPrimaryCoverage(FontTable table);
}
internal class MS.Internal.Shaping.AnchorTable : ValueType {
    private static int offsetFormat;
    private static int offsetXCoordinate;
    private static int offsetYCoordinate;
    private static int offsetFormat2AnchorPoint;
    private static int offsetFormat3XDeviceTable;
    private static int offsetFormat3YDeviceTable;
    private int offset;
    private ushort format;
    public AnchorTable(FontTable Table, int Offset);
    private short XCoordinate(FontTable Table);
    private short YCoordinate(FontTable Table);
    private ushort Format2AnchorPoint(FontTable Table);
    private DeviceTable Format3XDeviceTable(FontTable Table);
    private DeviceTable Format3YDeviceTable(FontTable Table);
    public bool NeedContourPoint(FontTable Table);
    public ushort ContourPointIndex(FontTable Table);
    public LayoutOffset AnchorCoordinates(FontTable Table, LayoutMetrics Metrics, LayoutOffset ContourPoint);
    public bool IsNull();
}
internal class MS.Internal.Shaping.ChainingSubtable : ValueType {
    private static int offsetFormat;
    private int offset;
    public ChainingSubtable(int Offset);
    private ushort Format(FontTable Table);
    public bool Apply(IOpenTypeFont Font, OpenTypeTags TableTag, FontTable Table, LayoutMetrics Metrics, int CharCount, UshortList Charmap, GlyphInfoList GlyphInfo, Int32* Advances, LayoutOffset* Offsets, ushort LookupFlags, int FirstGlyph, int AfterLastGlyph, UInt32 Parameter, int nestingLevel, Int32& NextGlyph);
    public bool IsLookupCovered(FontTable table, UInt32[] glyphBits, ushort minGlyphId, ushort maxGlyphId);
    public CoverageTable GetPrimaryCoverage(FontTable table);
}
internal class MS.Internal.Shaping.ClassChainingSubtable : ValueType {
    private static int offsetFormat;
    private static int offsetCoverage;
    private static int offsetBacktrackClassDef;
    private static int offsetInputClassDef;
    private static int offsetLookaheadClassDef;
    private static int offsetSubClassSetCount;
    private static int offsetSubClassSetArray;
    private static int sizeClassSetOffset;
    private int offset;
    public ClassChainingSubtable(int Offset);
    public ushort Format(FontTable Table);
    private CoverageTable Coverage(FontTable Table);
    private ClassDefTable BacktrackClassDef(FontTable Table);
    private ClassDefTable InputClassDef(FontTable Table);
    private ClassDefTable LookaheadClassDef(FontTable Table);
    private ushort ClassSetCount(FontTable Table);
    private SubClassSet ClassSet(FontTable Table, ushort Index);
    public bool Apply(IOpenTypeFont Font, OpenTypeTags TableTag, FontTable Table, LayoutMetrics Metrics, int CharCount, UshortList Charmap, GlyphInfoList GlyphInfo, Int32* Advances, LayoutOffset* Offsets, ushort LookupFlags, int FirstGlyph, int AfterLastGlyph, UInt32 Parameter, int nestingLevel, Int32& NextGlyph);
    public bool IsLookupCovered(FontTable table, UInt32[] glyphBits, ushort minGlyphId, ushort maxGlyphId);
    public CoverageTable GetPrimaryCoverage(FontTable table);
}
internal class MS.Internal.Shaping.ClassContextSubtable : ValueType {
    private static int offsetFormat;
    private static int offsetCoverage;
    private static int offsetClassDef;
    private static int offsetSubClassSetCount;
    private static int offsetSubClassSetArray;
    private static int sizeClassSetOffset;
    private int offset;
    public ClassContextSubtable(int Offset);
    public ushort Format(FontTable Table);
    private CoverageTable Coverage(FontTable Table);
    private ClassDefTable ClassDef(FontTable Table);
    private ushort ClassSetCount(FontTable Table);
    private SubClassSet ClassSet(FontTable Table, ushort Index);
    public bool Apply(IOpenTypeFont Font, OpenTypeTags TableTag, FontTable Table, LayoutMetrics Metrics, int CharCount, UshortList Charmap, GlyphInfoList GlyphInfo, Int32* Advances, LayoutOffset* Offsets, ushort LookupFlags, int FirstGlyph, int AfterLastGlyph, UInt32 Parameter, int nestingLevel, Int32& NextGlyph);
    public bool IsLookupCovered(FontTable table, UInt32[] glyphBits, ushort minGlyphId, ushort maxGlyphId);
    public CoverageTable GetPrimaryCoverage(FontTable table);
}
internal class MS.Internal.Shaping.ClassDefTable : ValueType {
    private static int offsetFormat;
    private static int offsetFormat1StartGlyph;
    private static int offsetFormat1GlyphCount;
    private static int offsetFormat1ClassValueArray;
    private static int sizeFormat1ClassValue;
    private static int offsetFormat2RangeCount;
    private static int offsetFormat2RangeRecordArray;
    private static int sizeFormat2RangeRecord;
    private static int offsetFormat2RangeRecordStart;
    private static int offsetFormat2RangeRecordEnd;
    private static int offsetFormat2RangeRecordClass;
    private int offset;
    public static ClassDefTable InvalidClassDef { get; }
    public bool IsInvalid { get; }
    public ClassDefTable(int Offset);
    private ushort Format(FontTable Table);
    private ushort Format1StartGlyph(FontTable Table);
    private ushort Format1GlyphCount(FontTable Table);
    private ushort Format1ClassValue(FontTable Table, ushort Index);
    private ushort Format2RangeCount(FontTable Table);
    private ushort Format2RangeStartGlyph(FontTable Table, ushort Index);
    private ushort Format2RangeEndGlyph(FontTable Table, ushort Index);
    private ushort Format2RangeClassValue(FontTable Table, ushort Index);
    public ushort GetClass(FontTable Table, ushort glyph);
    public static ClassDefTable get_InvalidClassDef();
    public bool get_IsInvalid();
}
internal class MS.Internal.Shaping.CompositeFontFamily : object {
    private CompositeFontInfo _fontInfo;
    private IFontFamily _firstFontFamily;
    private IDictionary`2<XmlLanguage, string> MS.Internal.FontFace.IFontFamily.Names { get; }
    private double MS.Internal.FontFace.IFontFamily.BaselineDesign { get; }
    private double MS.Internal.FontFace.IFontFamily.LineSpacingDesign { get; }
    internal LanguageSpecificStringDictionary FamilyNames { get; }
    internal FamilyTypefaceCollection FamilyTypefaces { get; }
    internal FontFamilyMapCollection FamilyMaps { get; }
    internal CompositeFontFamily(CompositeFontInfo fontInfo);
    internal CompositeFontFamily(string friendlyName);
    internal CompositeFontFamily(string friendlyName, IFontFamily firstFontFamily);
    private sealed virtual override IDictionary`2<XmlLanguage, string> MS.Internal.FontFace.IFontFamily.get_Names();
    public sealed virtual double Baseline(double emSize, double toReal, double pixelsPerDip, TextFormattingMode textFormattingMode);
    public void SetBaseline(double value);
    public sealed virtual double LineSpacing(double emSize, double toReal, double pixelsPerDip, TextFormattingMode textFormattingMode);
    private sealed virtual override double MS.Internal.FontFace.IFontFamily.get_BaselineDesign();
    private sealed virtual override double MS.Internal.FontFace.IFontFamily.get_LineSpacingDesign();
    public void SetLineSpacing(double value);
    private sealed virtual override ITypefaceMetrics MS.Internal.FontFace.IFontFamily.GetTypefaceMetrics(FontStyle style, FontWeight weight, FontStretch stretch);
    private sealed virtual override IDeviceFont MS.Internal.FontFace.IFontFamily.GetDeviceFont(FontStyle style, FontWeight weight, FontStretch stretch);
    private sealed virtual override bool MS.Internal.FontFace.IFontFamily.GetMapTargetFamilyNameAndScale(CharacterBufferRange unicodeString, CultureInfo culture, CultureInfo digitCulture, double defaultSizeInEm, Int32& cchAdvance, String& targetFamilyName, Double& scaleInEm);
    private sealed virtual override ICollection`1<Typeface> MS.Internal.FontFace.IFontFamily.GetTypefaces(FontFamilyIdentifier familyIdentifier);
    internal LanguageSpecificStringDictionary get_FamilyNames();
    internal FamilyTypefaceCollection get_FamilyTypefaces();
    internal FontFamilyMapCollection get_FamilyMaps();
    private FontFamilyMap GetTargetFamilyMap(CharacterBufferRange unicodeString, CultureInfo culture, CultureInfo digitCulture, Int32& cchAdvance);
    private IFontFamily GetFirstFontFamily();
    private ITypefaceMetrics FindTypefaceMetrics(FontStyle style, FontWeight weight, FontStretch stretch);
    private FamilyTypeface FindNearestFamilyTypeface(FontStyle style, FontWeight weight, FontStretch stretch);
    private FamilyTypeface FindExactFamilyTypeface(FontStyle style, FontWeight weight, FontStretch stretch);
}
internal class MS.Internal.Shaping.CompositeTypefaceMetrics : object {
    private double _underlinePosition;
    private double _underlineThickness;
    private double _strikethroughPosition;
    private double _strikethroughThickenss;
    private double _capsHeight;
    private double _xHeight;
    private FontStyle _style;
    private FontWeight _weight;
    private FontStretch _stretch;
    private static double UnderlineOffsetDefaultInEm;
    private static double UnderlineSizeDefaultInEm;
    private static double StrikethroughOffsetDefaultInEm;
    private static double StrikethroughSizeDefaultInEm;
    private static double CapsHeightDefaultInEm;
    private static double XHeightDefaultInEm;
    public double XHeight { get; }
    public double CapsHeight { get; }
    public double UnderlinePosition { get; }
    public double UnderlineThickness { get; }
    public double StrikethroughPosition { get; }
    public double StrikethroughThickness { get; }
    public bool Symbol { get; }
    public StyleSimulations StyleSimulations { get; }
    public IDictionary`2<XmlLanguage, string> AdjustedFaceNames { get; }
    internal CompositeTypefaceMetrics(double underlinePosition, double underlineThickness, double strikethroughPosition, double strikethroughThickness, double capsHeight, double xHeight, FontStyle style, FontWeight weight, FontStretch stretch);
    public sealed virtual double get_XHeight();
    public sealed virtual double get_CapsHeight();
    public sealed virtual double get_UnderlinePosition();
    public sealed virtual double get_UnderlineThickness();
    public sealed virtual double get_StrikethroughPosition();
    public sealed virtual double get_StrikethroughThickness();
    public sealed virtual bool get_Symbol();
    public sealed virtual StyleSimulations get_StyleSimulations();
    public sealed virtual IDictionary`2<XmlLanguage, string> get_AdjustedFaceNames();
}
internal class MS.Internal.Shaping.ContextSubtable : ValueType {
    private static int offsetFormat;
    private int offset;
    public ContextSubtable(int Offset);
    private ushort Format(FontTable Table);
    public bool Apply(IOpenTypeFont Font, OpenTypeTags TableTag, FontTable Table, LayoutMetrics Metrics, int CharCount, UshortList Charmap, GlyphInfoList GlyphInfo, Int32* Advances, LayoutOffset* Offsets, ushort LookupFlags, int FirstGlyph, int AfterLastGlyph, UInt32 Parameter, int nestingLevel, Int32& NextGlyph);
    public bool IsLookupCovered(FontTable table, UInt32[] glyphBits, ushort minGlyphId, ushort maxGlyphId);
    public CoverageTable GetPrimaryCoverage(FontTable table);
}
internal class MS.Internal.Shaping.ContextualLookupRecords : ValueType {
    private static int offsetSequenceIndex;
    private static int offsetLookupIndex;
    private static int sizeLookupRecord;
    private static int MaximumContextualLookupNestingLevel;
    private int offset;
    private ushort recordCount;
    public ContextualLookupRecords(int Offset, ushort RecordCount);
    private ushort SequenceIndex(FontTable Table, ushort Index);
    private ushort LookupIndex(FontTable Table, ushort Index);
    public void ApplyContextualLookups(IOpenTypeFont Font, OpenTypeTags TableTag, FontTable Table, LayoutMetrics Metrics, int CharCount, UshortList Charmap, GlyphInfoList GlyphInfo, Int32* Advances, LayoutOffset* Offsets, ushort LookupFlags, int FirstGlyph, int AfterLastGlyph, UInt32 Parameter, int nestingLevel, Int32& nextGlyph);
}
internal class MS.Internal.Shaping.CoverageChainingSubtable : ValueType {
    private static int offsetFormat;
    private static int offsetBacktrackGlyphCount;
    private static int offsetBacktrackCoverageArray;
    private static int sizeGlyphCount;
    private static int sizeCoverageOffset;
    private int offset;
    private int offsetInputGlyphCount;
    private int offsetLookaheadGlyphCount;
    public CoverageChainingSubtable(FontTable Table, int Offset);
    public ushort Format(FontTable Table);
    public ushort BacktrackGlyphCount(FontTable Table);
    public CoverageTable BacktrackCoverage(FontTable Table, ushort Index);
    public ushort InputGlyphCount(FontTable Table);
    public CoverageTable InputCoverage(FontTable Table, ushort Index);
    public ushort LookaheadGlyphCount(FontTable Table);
    public CoverageTable LookaheadCoverage(FontTable Table, ushort Index);
    public ContextualLookupRecords ContextualLookups(FontTable Table);
    public bool Apply(IOpenTypeFont Font, OpenTypeTags TableTag, FontTable Table, LayoutMetrics Metrics, int CharCount, UshortList Charmap, GlyphInfoList GlyphInfo, Int32* Advances, LayoutOffset* Offsets, ushort LookupFlags, int FirstGlyph, int AfterLastGlyph, UInt32 Parameter, int nestingLevel, Int32& NextGlyph);
    public bool IsLookupCovered(FontTable table, UInt32[] glyphBits, ushort minGlyphId, ushort maxGlyphId);
    public CoverageTable GetPrimaryCoverage(FontTable table);
}
internal class MS.Internal.Shaping.CoverageContextSubtable : ValueType {
    private static int offsetFormat;
    private static int offsetGlyphCount;
    private static int offsetSubstCount;
    private static int offsetInputCoverage;
    private static int sizeOffset;
    private int offset;
    public CoverageContextSubtable(int Offset);
    private ushort Format(FontTable Table);
    private ushort GlyphCount(FontTable Table);
    private ushort SubstCount(FontTable Table);
    private CoverageTable InputCoverage(FontTable Table, ushort index);
    public ContextualLookupRecords ContextualLookups(FontTable Table);
    public bool Apply(IOpenTypeFont Font, OpenTypeTags TableTag, FontTable Table, LayoutMetrics Metrics, int CharCount, UshortList Charmap, GlyphInfoList GlyphInfo, Int32* Advances, LayoutOffset* Offsets, ushort LookupFlags, int FirstGlyph, int AfterLastGlyph, UInt32 Parameter, int nestingLevel, Int32& NextGlyph);
    public bool IsLookupCovered(FontTable table, UInt32[] glyphBits, ushort minGlyphId, ushort maxGlyphId);
    public CoverageTable GetPrimaryCoverage(FontTable table);
}
internal class MS.Internal.Shaping.CoverageTable : ValueType {
    private static int offsetFormat;
    private static int offsetFormat1GlyphCount;
    private static int offsetFormat1GlyphArray;
    private static int sizeFormat1GlyphId;
    private static int offsetFormat2RangeCount;
    private static int offsetFormat2RangeRecordArray;
    private static int sizeFormat2RangeRecord;
    private static int offsetFormat2RangeRecordStart;
    private static int offsetFormat2RangeRecordEnd;
    private static int offsetFormat2RangeRecordStartIndex;
    private int offset;
    public static CoverageTable InvalidCoverage { get; }
    public bool IsInvalid { get; }
    public CoverageTable(int Offset);
    public ushort Format(FontTable Table);
    public ushort Format1GlyphCount(FontTable Table);
    public ushort Format1Glyph(FontTable Table, ushort Index);
    public ushort Format2RangeCount(FontTable Table);
    public ushort Format2RangeStartGlyph(FontTable Table, ushort Index);
    public ushort Format2RangeEndGlyph(FontTable Table, ushort Index);
    public ushort Format2RangeStartCoverageIndex(FontTable Table, ushort Index);
    public int GetGlyphIndex(FontTable Table, ushort glyph);
    public bool IsAnyGlyphCovered(FontTable table, UInt32[] glyphBits, ushort minGlyphId, ushort maxGlyphId);
    public static CoverageTable get_InvalidCoverage();
    public bool get_IsInvalid();
}
internal class MS.Internal.Shaping.CursivePositioningSubtable : ValueType {
    private static ushort offsetFormat;
    private static ushort offsetCoverage;
    private static ushort offsetEntryExitCount;
    private static ushort offsetEntryExitArray;
    private static ushort sizeEntryExitRecord;
    private static ushort offsetEntryAnchor;
    private static ushort offsetExitAnchor;
    private int offset;
    public CursivePositioningSubtable(int Offset);
    private ushort Format(FontTable Table);
    private CoverageTable Coverage(FontTable Table);
    private AnchorTable EntryAnchor(FontTable Table, int Index);
    private AnchorTable ExitAnchor(FontTable Table, int Index);
    public bool Apply(IOpenTypeFont Font, FontTable Table, LayoutMetrics Metrics, GlyphInfoList GlyphInfo, ushort LookupFlags, Int32* Advances, LayoutOffset* Offsets, int FirstGlyph, int AfterLastGlyph, Int32& NextGlyph);
    public bool IsLookupCovered(FontTable table, UInt32[] glyphBits, ushort minGlyphId, ushort maxGlyphId);
    public CoverageTable GetPrimaryCoverage(FontTable table);
}
internal class MS.Internal.Shaping.DeviceTable : ValueType {
    private static int offsetStartSize;
    private static int offsetEndSize;
    private static int offsetDeltaFormat;
    private static int offsetDeltaValueArray;
    private static int sizeDeltaValue;
    private int offset;
    public DeviceTable(int Offset);
    private ushort StartSize(FontTable Table);
    private ushort EndSize(FontTable Table);
    private ushort DeltaFormat(FontTable Table);
    private ushort DeltaValue(FontTable Table, ushort Index);
    public int Value(FontTable Table, ushort PixelsPerEm);
    private bool IsNull();
}
internal class MS.Internal.Shaping.ExtensionLookupTable : ValueType {
    private static int offsetFormat;
    private static int offsetLookupType;
    private static int offsetExtensionOffset;
    private int offset;
    public ExtensionLookupTable(int Offset);
    internal ushort LookupType(FontTable Table);
    internal int LookupSubtableOffset(FontTable Table);
}
internal class MS.Internal.Shaping.Feature : object {
    private ushort _startIndex;
    private ushort _length;
    private UInt32 _tag;
    private UInt32 _parameter;
    public UInt32 Tag { get; public set; }
    public UInt32 Parameter { get; public set; }
    public ushort StartIndex { get; public set; }
    public ushort Length { get; public set; }
    public Feature(ushort startIndex, ushort length, UInt32 tag, UInt32 parameter);
    public UInt32 get_Tag();
    public void set_Tag(UInt32 value);
    public UInt32 get_Parameter();
    public void set_Parameter(UInt32 value);
    public ushort get_StartIndex();
    public void set_StartIndex(ushort value);
    public ushort get_Length();
    public void set_Length(ushort value);
}
internal class MS.Internal.Shaping.FeatureList : ValueType {
    private static int offsetFeatureCount;
    private static int offsetFeatureRecordArray;
    private static int sizeFeatureRecord;
    private static int offsetFeatureRecordTag;
    private static int offsetFeatureRecordOffset;
    private int offset;
    public FeatureList(int Offset);
    public ushort FeatureCount(FontTable Table);
    public UInt32 FeatureTag(FontTable Table, ushort Index);
    public FeatureTable FeatureTable(FontTable Table, ushort Index);
}
internal class MS.Internal.Shaping.FeatureTable : ValueType {
    private static int offsetLookupCount;
    private static int offsetLookupIndexArray;
    private static int sizeLookupIndex;
    private int offset;
    public bool IsNull { get; }
    public FeatureTable(int Offset);
    public ushort LookupCount(FontTable Table);
    public ushort LookupIndex(FontTable Table, ushort Index);
    public bool get_IsNull();
}
internal class MS.Internal.Shaping.FontTable : object {
    public static int InvalidOffset;
    public static int NullOffset;
    private Byte[] m_data;
    private UInt32 m_length;
    public bool IsPresent { get; }
    public FontTable(Byte[] data);
    public bool get_IsPresent();
    public ushort GetUShort(int offset);
    public short GetShort(int offset);
    public UInt32 GetUInt(int offset);
    public ushort GetOffset(int offset);
}
internal class MS.Internal.Shaping.GDEFHeader : ValueType {
    private static int offsetGlyphClassDef;
    private static int offsetGlyphAttachList;
    private static int offsetLigaCaretList;
    private static int offsetMarkAttachClassDef;
    private int offset;
    public GDEFHeader(int Offset);
    public ClassDefTable GetGlyphClassDef(FontTable Table);
    public ClassDefTable GetMarkAttachClassDef(FontTable Table);
}
internal class MS.Internal.Shaping.GlyphChainingSubtable : ValueType {
    private static int offsetFormat;
    private static int offsetCoverage;
    private static int offsetSubRuleSetCount;
    private static int offsetSubRuleSetArray;
    private static int sizeRuleSetOffset;
    private int offset;
    public GlyphChainingSubtable(int Offset);
    public ushort Format(FontTable Table);
    private CoverageTable Coverage(FontTable Table);
    private SubRuleSet RuleSet(FontTable Table, int Index);
    public bool Apply(IOpenTypeFont Font, OpenTypeTags TableTag, FontTable Table, LayoutMetrics Metrics, int CharCount, UshortList Charmap, GlyphInfoList GlyphInfo, Int32* Advances, LayoutOffset* Offsets, ushort LookupFlags, int FirstGlyph, int AfterLastGlyph, UInt32 Parameter, int nestingLevel, Int32& NextGlyph);
    public bool IsLookupCovered(FontTable table, UInt32[] glyphBits, ushort minGlyphId, ushort maxGlyphId);
    public CoverageTable GetPrimaryCoverage(FontTable table);
}
internal class MS.Internal.Shaping.GlyphContextSubtable : ValueType {
    private static int offsetFormat;
    private static int offsetCoverage;
    private static int offsetSubRuleSetCount;
    private static int offsetSubRuleSetArray;
    private static int sizeRuleSetOffset;
    private int offset;
    public GlyphContextSubtable(int Offset);
    public ushort Format(FontTable Table);
    private CoverageTable Coverage(FontTable Table);
    private SubRuleSet RuleSet(FontTable Table, int Index);
    public bool Apply(IOpenTypeFont Font, OpenTypeTags TableTag, FontTable Table, LayoutMetrics Metrics, int CharCount, UshortList Charmap, GlyphInfoList GlyphInfo, Int32* Advances, LayoutOffset* Offsets, ushort LookupFlags, int FirstGlyph, int AfterLastGlyph, UInt32 Parameter, int nestingLevel, Int32& NextGlyph);
    public bool IsLookupCovered(FontTable table, UInt32[] glyphBits, ushort minGlyphId, ushort maxGlyphId);
    public CoverageTable GetPrimaryCoverage(FontTable table);
}
[FlagsAttribute]
internal enum MS.Internal.Shaping.GlyphFlags : Enum {
    public ushort value__;
    public static GlyphFlags Unassigned;
    public static GlyphFlags Base;
    public static GlyphFlags Ligature;
    public static GlyphFlags Mark;
    public static GlyphFlags Component;
    public static GlyphFlags Unresolved;
    public static GlyphFlags GlyphTypeMask;
    public static GlyphFlags Substituted;
    public static GlyphFlags Positioned;
    public static GlyphFlags NotChanged;
    public static GlyphFlags CursiveConnected;
    public static GlyphFlags ClusterStart;
    public static GlyphFlags Diacritic;
    public static GlyphFlags ZeroWidth;
    public static GlyphFlags Missing;
    public static GlyphFlags InvalidBase;
}
internal class MS.Internal.Shaping.GlyphInfoList : object {
    private UshortList _glyphs;
    private UshortList _glyphFlags;
    private UshortList _firstChars;
    private UshortList _ligatureCounts;
    public int Length { get; }
    internal int Offset { get; }
    public UshortList Glyphs { get; }
    public UshortList GlyphFlags { get; }
    public UshortList FirstChars { get; }
    public UshortList LigatureCounts { get; }
    internal GlyphInfoList(int capacity, int leap, bool justify);
    public int get_Length();
    internal int get_Offset();
    [ConditionalAttribute("DEBUG")]
internal void ValidateLength(int cch);
    public void SetRange(int index, int length);
    public void SetLength(int length);
    public void Insert(int index, int Count);
    public void Remove(int index, int Count);
    public UshortList get_Glyphs();
    public UshortList get_GlyphFlags();
    public UshortList get_FirstChars();
    public UshortList get_LigatureCounts();
}
internal class MS.Internal.Shaping.GlyphingCache : object {
    private SizeLimitedCache`2<Typeface, TypefaceMap> _sizeLimitedCache;
    internal GlyphingCache(int capacity);
    internal void GetShapeableText(Typeface typeface, CharacterBufferReference characterBufferReference, int stringLength, TextRunProperties textRunProperties, CultureInfo digitCulture, bool isRightToLeftParagraph, IList`1<TextShapeableSymbols> shapeableList, IShapeableTextCollector collector, TextFormattingMode textFormattingMode);
    private TypefaceMap Lookup(Typeface key);
}
internal class MS.Internal.Shaping.GPOSHeader : ValueType {
    private static int offsetScriptList;
    private static int offsetFeatureList;
    private static int offsetLookupList;
    private int offset;
    public GPOSHeader(int Offset);
    public ScriptList GetScriptList(FontTable Table);
    public FeatureList GetFeatureList(FontTable Table);
    public LookupList GetLookupList(FontTable Table);
}
internal class MS.Internal.Shaping.GSUBHeader : ValueType {
    private static int offsetScriptList;
    private static int offsetFeatureList;
    private static int offsetLookupList;
    private int offset;
    public GSUBHeader(int Offset);
    public ScriptList GetScriptList(FontTable Table);
    public FeatureList GetFeatureList(FontTable Table);
    public LookupList GetLookupList(FontTable Table);
}
internal interface MS.Internal.Shaping.IOpenTypeFont {
    public abstract virtual FontTable GetFontTable(OpenTypeTags TableTag);
    public abstract virtual LayoutOffset GetGlyphPointCoord(ushort Glyph, ushort PointIndex);
    public abstract virtual Byte[] GetTableCache(OpenTypeTags tableTag);
    public abstract virtual Byte[] AllocateTableCache(OpenTypeTags tableTag, int size);
}
internal class MS.Internal.Shaping.LangSysTable : ValueType {
    private static int offsetRequiredFeature;
    private static int offsetFeatureCount;
    private static int offsetFeatureIndexArray;
    private static int sizeFeatureIndex;
    private int offset;
    public bool IsNull { get; }
    public LangSysTable(int Offset);
    public FeatureTable FindFeature(FontTable Table, FeatureList Features, UInt32 FeatureTag);
    public FeatureTable RequiredFeature(FontTable Table, FeatureList Features);
    public ushort FeatureCount(FontTable Table);
    public ushort GetFeatureIndex(FontTable Table, ushort Index);
    public bool get_IsNull();
}
internal static class MS.Internal.Shaping.LayoutEngine : object {
    public static ushort LookupFlagRightToLeft;
    public static ushort LookupFlagIgnoreBases;
    public static ushort LookupFlagIgnoreLigatures;
    public static ushort LookupFlagIgnoreMarks;
    public static ushort LookupFlagMarkAttachmentTypeMask;
    public static ushort LookupFlagFindBase;
    public static int LookForward;
    public static int LookBackward;
    public static void ApplyFeatures(IOpenTypeFont Font, OpenTypeLayoutWorkspace workspace, OpenTypeTags TableTag, FontTable Table, LayoutMetrics Metrics, LangSysTable LangSys, FeatureList Features, LookupList Lookups, Feature[] FeatureSet, int featureCount, int featureSetOffset, int CharCount, UshortList Charmap, GlyphInfoList GlyphInfo, Int32* Advances, LayoutOffset* Offsets);
    internal static bool ApplyLookup(IOpenTypeFont Font, OpenTypeTags TableTag, FontTable Table, LayoutMetrics Metrics, LookupTable Lookup, int CharCount, UshortList Charmap, GlyphInfoList GlyphInfo, Int32* Advances, LayoutOffset* Offsets, int FirstGlyph, int AfterLastGlyph, UInt32 Parameter, int nestingLevel, Int32& NextGlyph);
    private static bool IsLookupReversal(OpenTypeTags TableTag, ushort LookupType);
    private static void CompileFeatureSet(Feature[] FeatureSet, int featureCount, int featureSetOffset, int charCount, FontTable Table, LangSysTable LangSys, FeatureList Features, int lookupCount, OpenTypeLayoutWorkspace workspace);
    private static void GetNextEnabledGlyphRange(Feature[] FeatureSet, int featureCount, int featureSetOffset, FontTable Table, OpenTypeLayoutWorkspace workspace, LangSysTable LangSys, FeatureList Features, ushort lookupIndex, int CharCount, UshortList Charmap, int StartChar, int StartGlyph, int GlyphRunLength, Int32& FirstChar, Int32& AfterLastChar, Int32& FirstGlyph, Int32& AfterLastGlyph, UInt32& Parameter);
    private static void UpdateGlyphFlags(IOpenTypeFont Font, GlyphInfoList GlyphInfo, int FirstGlyph, int AfterLastGlyph, bool DoAll, GlyphFlags FlagToSet);
    internal static int GetNextGlyphInLookup(IOpenTypeFont Font, GlyphInfoList GlyphInfo, int FirstGlyph, ushort LookupFlags, int Direction);
    internal static void GetComplexLanguageList(OpenTypeTags tableTag, FontTable table, UInt32[] featureTagsList, UInt32[] glyphBits, ushort minGlyphId, ushort maxGlyphId, WritingSystem[]& complexLanguages, Int32& complexLanguageCount);
    private static void AppendLangSys(UInt32 scriptTag, UInt32 langSysTag, LangSysTable langSysTable, FeatureList featureList, FontTable table, UInt32[] featureTagsList, UInt32[] lookupBits, WritingSystem[]& complexLanguages, Int32& complexLanguageCount);
}
internal class MS.Internal.Shaping.LayoutMetrics : ValueType {
    public TextFlowDirection Direction;
    public ushort DesignEmHeight;
    public ushort PixelsEmWidth;
    public ushort PixelsEmHeight;
    public LayoutMetrics(TextFlowDirection Direction, ushort DesignEmHeight, ushort PixelsEmWidth, ushort PixelsEmHeight);
}
internal class MS.Internal.Shaping.LayoutOffset : ValueType {
    public int dx;
    public int dy;
    public LayoutOffset(int dx, int dy);
}
internal class MS.Internal.Shaping.LigatureAttachTable : ValueType {
    private static int offsetAnchorArray;
    private static int sizeAnchorOffset;
    private int offset;
    private int classCount;
    public LigatureAttachTable(int Offset, ushort ClassCount);
    public AnchorTable LigatureAnchor(FontTable Table, ushort Component, ushort MarkClass);
}
internal class MS.Internal.Shaping.LigatureSubstitutionSubtable : ValueType {
    private static int offsetFormat;
    private static int offsetCoverage;
    private static int offsetLigatureSetCount;
    private static int offsetLigatureSetArray;
    private static int sizeLigatureSet;
    private int offset;
    public LigatureSubstitutionSubtable(int Offset);
    private ushort Format(FontTable Table);
    private CoverageTable Coverage(FontTable Table);
    private ushort LigatureSetCount(FontTable Table);
    private LigatureSetTable LigatureSet(FontTable Table, ushort Index);
    public bool Apply(IOpenTypeFont Font, FontTable Table, int CharCount, UshortList Charmap, GlyphInfoList GlyphInfo, ushort LookupFlags, int FirstGlyph, int AfterLastGlyph, Int32& NextGlyph);
    public bool IsLookupCovered(FontTable table, UInt32[] glyphBits, ushort minGlyphId, ushort maxGlyphId);
    public CoverageTable GetPrimaryCoverage(FontTable table);
}
internal class MS.Internal.Shaping.LookupList : ValueType {
    private static int offsetLookupCount;
    private static int LookupOffsetArray;
    private static int sizeLookupOffset;
    private int offset;
    public LookupList(int Offset);
    public ushort LookupCount(FontTable Table);
    public LookupTable Lookup(FontTable Table, ushort Index);
}
internal class MS.Internal.Shaping.LookupTable : ValueType {
    private static int offsetLookupType;
    private static int offsetLookupFlags;
    private static int offsetSubtableCount;
    private static int offsetSubtableArray;
    private static int sizeSubtableOffset;
    private int offset;
    private ushort lookupType;
    private ushort lookupFlags;
    private ushort subtableCount;
    public LookupTable(FontTable table, int Offset);
    public ushort LookupType();
    public ushort LookupFlags();
    public ushort SubTableCount();
    public int SubtableOffset(FontTable Table, ushort Index);
}
internal class MS.Internal.Shaping.MarkArray : ValueType {
    private static int offsetClassArray;
    private static int sizeClassRecord;
    private static int offsetClassRecordClass;
    private static int offsetClassRecordAnchor;
    private int offset;
    public MarkArray(int Offset);
    public ushort Class(FontTable Table, ushort Index);
    public AnchorTable MarkAnchor(FontTable Table, ushort Index);
}
internal class MS.Internal.Shaping.MarkToBasePositioningSubtable : ValueType {
    private static int offsetFormat;
    private static int offsetCoverage;
    private static int offsetBaseCoverage;
    private static int offsetClassCount;
    private static int offsetMarkArray;
    private static int offsetBaseArray;
    private int offset;
    public MarkToBasePositioningSubtable(int Offset);
    private ushort Format(FontTable Table);
    private CoverageTable MarkCoverage(FontTable Table);
    private CoverageTable BaseCoverage(FontTable Table);
    private ushort ClassCount(FontTable Table);
    private MarkArray Marks(FontTable Table);
    private BaseArray Bases(FontTable Table);
    public bool Apply(IOpenTypeFont Font, FontTable Table, LayoutMetrics Metrics, GlyphInfoList GlyphInfo, ushort LookupFlags, Int32* Advances, LayoutOffset* Offsets, int FirstGlyph, int AfterLastGlyph, Int32& NextGlyph);
    public bool IsLookupCovered(FontTable table, UInt32[] glyphBits, ushort minGlyphId, ushort maxGlyphId);
    public CoverageTable GetPrimaryCoverage(FontTable table);
}
internal class MS.Internal.Shaping.MarkToLigaturePositioningSubtable : ValueType {
    private static int offsetFormat;
    private static int offsetMarkCoverage;
    private static int offsetLigatureCoverage;
    private static int offsetClassCount;
    private static int offsetMarkArray;
    private static int offsetLigatureArray;
    private static int offsetLigatureAttachArray;
    private static int sizeOffset;
    private int offset;
    public MarkToLigaturePositioningSubtable(int Offset);
    private ushort Format(FontTable Table);
    private CoverageTable MarkCoverage(FontTable Table);
    private CoverageTable LigatureCoverage(FontTable Table);
    private ushort ClassCount(FontTable Table);
    private MarkArray Marks(FontTable Table);
    private LigatureAttachTable Ligatures(FontTable Table, int Index, ushort ClassCount);
    private void FindBaseLigature(int CharCount, UshortList Charmap, GlyphInfoList GlyphInfo, int markGlyph, UInt16& component, Int32& ligatureGlyph);
    public bool Apply(IOpenTypeFont Font, FontTable Table, LayoutMetrics Metrics, GlyphInfoList GlyphInfo, ushort LookupFlags, int CharCount, UshortList Charmap, Int32* Advances, LayoutOffset* Offsets, int FirstGlyph, int AfterLastGlyph, Int32& NextGlyph);
    public bool IsLookupCovered(FontTable table, UInt32[] glyphBits, ushort minGlyphId, ushort maxGlyphId);
    public CoverageTable GetPrimaryCoverage(FontTable table);
}
internal class MS.Internal.Shaping.MarkToMarkPositioningSubtable : ValueType {
    private static int offsetFormat;
    private static int offsetCoverage;
    private static int offsetMark2Coverage;
    private static int offsetClassCount;
    private static int offsetMark1Array;
    private static int offsetMark2Array;
    private int offset;
    public MarkToMarkPositioningSubtable(int Offset);
    private ushort Format(FontTable Table);
    private CoverageTable Mark1Coverage(FontTable Table);
    private CoverageTable Mark2Coverage(FontTable Table);
    private ushort Mark1ClassCount(FontTable Table);
    private MarkArray Mark1Array(FontTable Table);
    private Mark2Array Marks2(FontTable Table);
    public bool Apply(IOpenTypeFont Font, FontTable Table, LayoutMetrics Metrics, GlyphInfoList GlyphInfo, ushort LookupFlags, Int32* Advances, LayoutOffset* Offsets, int FirstGlyph, int AfterLastGlyph, Int32& NextGlyph);
    public bool IsLookupCovered(FontTable table, UInt32[] glyphBits, ushort minGlyphId, ushort maxGlyphId);
    public CoverageTable GetPrimaryCoverage(FontTable table);
}
internal class MS.Internal.Shaping.MultipleSubstitutionSequenceTable : ValueType {
    private static int offsetGlyphCount;
    private static int offsetGlyphArray;
    private static int sizeGlyphId;
    private int offset;
    public MultipleSubstitutionSequenceTable(int Offset);
    public ushort GlyphCount(FontTable Table);
    public ushort Glyph(FontTable Table, ushort index);
}
internal class MS.Internal.Shaping.MultipleSubstitutionSubtable : ValueType {
    private static int offsetFormat;
    private static int offsetCoverage;
    private static int offsetSequenceCount;
    private static int offsetSequenceArray;
    private static int sizeSequenceOffset;
    private int offset;
    public MultipleSubstitutionSubtable(int Offset);
    private ushort Format(FontTable Table);
    private CoverageTable Coverage(FontTable Table);
    private MultipleSubstitutionSequenceTable Sequence(FontTable Table, int Index);
    public bool Apply(IOpenTypeFont Font, FontTable Table, int CharCount, UshortList Charmap, GlyphInfoList GlyphInfo, ushort LookupFlags, int FirstGlyph, int AfterLastGlyph, Int32& NextGlyph);
    public bool IsLookupCovered(FontTable table, UInt32[] glyphBits, ushort minGlyphId, ushort maxGlyphId);
    public CoverageTable GetPrimaryCoverage(FontTable table);
}
internal static class MS.Internal.Shaping.OpenTypeLayout : object {
    internal static TagInfoFlags FindScript(IOpenTypeFont Font, UInt32 ScriptTag);
    internal static TagInfoFlags FindLangSys(IOpenTypeFont Font, UInt32 ScriptTag, UInt32 LangSysTag);
    internal static OpenTypeLayoutResult SubstituteGlyphs(IOpenTypeFont Font, OpenTypeLayoutWorkspace workspace, UInt32 ScriptTag, UInt32 LangSysTag, Feature[] FeatureSet, int featureCount, int featureSetOffset, int CharCount, UshortList Charmap, GlyphInfoList Glyphs);
    internal static OpenTypeLayoutResult PositionGlyphs(IOpenTypeFont Font, OpenTypeLayoutWorkspace workspace, UInt32 ScriptTag, UInt32 LangSysTag, LayoutMetrics Metrics, Feature[] FeatureSet, int featureCount, int featureSetOffset, int CharCount, UshortList Charmap, GlyphInfoList Glyphs, Int32* Advances, LayoutOffset* Offsets);
    internal static OpenTypeLayoutResult CreateLayoutCache(IOpenTypeFont font, int maxCacheSize);
    internal static OpenTypeLayoutResult GetComplexLanguageList(IOpenTypeFont Font, UInt32[] featureList, UInt32[] glyphBits, ushort minGlyphId, ushort maxGlyphId, WritingSystem[]& complexLanguages);
}
internal static class MS.Internal.Shaping.OpenTypeLayoutCache : object {
    public static void InitCache(IOpenTypeFont font, OpenTypeTags tableTag, GlyphInfoList glyphInfo, OpenTypeLayoutWorkspace workspace);
    public static void OnGlyphsChanged(OpenTypeLayoutWorkspace workspace, GlyphInfoList glyphInfo, int oldLength, int firstGlyphChanged, int afterLastGlyphChanged);
    private static ushort GetCacheLookupCount(OpenTypeLayoutWorkspace workspace);
    public static void FindNextLookup(OpenTypeLayoutWorkspace workspace, GlyphInfoList glyphInfo, ushort firstLookupIndex, UInt16& lookupIndex, Int32& firstGlyph);
    public static bool FindNextGlyphInLookup(OpenTypeLayoutWorkspace workspace, ushort lookupIndex, bool isLookupReversal, Int32& firstGlyph, Int32& afterLastGlyph);
    private static void RenewPointers(GlyphInfoList glyphInfo, OpenTypeLayoutWorkspace workspace, int firstGlyph, int afterLastGlyph);
    internal static void CreateCache(IOpenTypeFont font, int maxCacheSize);
    private static void CreateTableCache(IOpenTypeFont font, OpenTypeTags tableTag, int maxCacheSize, Int32& tableCacheSize);
    private static void ComputeTableCache(IOpenTypeFont font, OpenTypeTags tableTag, int maxCacheSize, Int32& cacheSize, GlyphLookupRecord[]& records, Int32& recordCount, Int32& glyphCount, Int32& lastLookupAdded);
    private static int FillTableCache(IOpenTypeFont font, OpenTypeTags tableTag, int cacheSize, GlyphLookupRecord[] records, int recordCount, int glyphCount, int lastLookupAdded);
    private static void CalculateCacheSize(GlyphLookupRecord[] records, int recordCount, Int32& cacheSize, Int32& glyphCount);
    private static bool CompareGlyphRecordLists(GlyphLookupRecord[] records, int recordCount, int glyphListIndex1, int glyphListIndex2);
    private static CoverageTable GetSubtablePrincipalCoverage(FontTable table, OpenTypeTags tableTag, ushort lookupType, int subtableOffset);
    private static bool AppendCoverageGlyphRecords(FontTable table, ushort lookupIndex, CoverageTable coverage, GlyphLookupRecord[] records, Int32& recordCount, Int32& maxLookupGlyph);
    private static bool AppendGlyphRecord(ushort glyph, ushort lookupIndex, GlyphLookupRecord[] records, Int32& recordCount, Int32& maxLookupGlyph);
}
internal enum MS.Internal.Shaping.OpenTypeLayoutResult : Enum {
    public int value__;
    public static OpenTypeLayoutResult Success;
    public static OpenTypeLayoutResult InvalidParameter;
    public static OpenTypeLayoutResult TableNotFound;
    public static OpenTypeLayoutResult ScriptNotFound;
    public static OpenTypeLayoutResult LangSysNotFound;
    public static OpenTypeLayoutResult BadFontTable;
    public static OpenTypeLayoutResult UnderConstruction;
}
internal class MS.Internal.Shaping.OpenTypeLayoutWorkspace : object {
    private static byte AggregatedFlagMask;
    private static byte RequiredFeatureFlagMask;
    private static int FeatureFlagsStartBit;
    private int _bytesPerLookup;
    private Byte[] _lookupUsageFlags;
    private UInt16[] _cachePointers;
    private Byte[] _tableCache;
    public UInt16[] CachePointers { get; }
    public Byte[] TableCacheData { get; public set; }
    internal OpenTypeLayoutResult Init(IOpenTypeFont font, OpenTypeTags tableTag, UInt32 scriptTag, UInt32 langSysTag);
    public void InitLookupUsageFlags(int lookupCount, int featureCount);
    public bool IsAggregatedFlagSet(int lookupIndex);
    public bool IsFeatureFlagSet(int lookupIndex, int featureIndex);
    public bool IsRequiredFeatureFlagSet(int lookupIndex);
    public void SetFeatureFlag(int lookupIndex, int featureIndex);
    public void SetRequiredFeatureFlag(int lookupIndex);
    public void AllocateCachePointers(int glyphRunLength);
    public void UpdateCachePointers(int oldLength, int newLength, int firstGlyphChanged, int afterLastGlyphChanged);
    public UInt16[] get_CachePointers();
    public Byte[] get_TableCacheData();
    public void set_TableCacheData(Byte[] value);
}
internal enum MS.Internal.Shaping.OpenTypeTags : Enum {
    public UInt32 value__;
    public static OpenTypeTags Null;
    public static OpenTypeTags GSUB;
    public static OpenTypeTags GPOS;
    public static OpenTypeTags GDEF;
    public static OpenTypeTags BASE;
    public static OpenTypeTags name;
    public static OpenTypeTags post;
    public static OpenTypeTags dflt;
    public static OpenTypeTags head;
    public static OpenTypeTags locl;
    public static OpenTypeTags ccmp;
    public static OpenTypeTags rlig;
    public static OpenTypeTags liga;
    public static OpenTypeTags clig;
    public static OpenTypeTags pwid;
    public static OpenTypeTags init;
    public static OpenTypeTags medi;
    public static OpenTypeTags fina;
    public static OpenTypeTags isol;
    public static OpenTypeTags calt;
    public static OpenTypeTags nukt;
    public static OpenTypeTags akhn;
    public static OpenTypeTags rphf;
    public static OpenTypeTags blwf;
    public static OpenTypeTags half;
    public static OpenTypeTags vatu;
    public static OpenTypeTags pres;
    public static OpenTypeTags abvs;
    public static OpenTypeTags blws;
    public static OpenTypeTags psts;
    public static OpenTypeTags haln;
    public static OpenTypeTags kern;
    public static OpenTypeTags mark;
    public static OpenTypeTags mkmk;
    public static OpenTypeTags curs;
    public static OpenTypeTags abvm;
    public static OpenTypeTags blwm;
    public static OpenTypeTags dist;
    public static OpenTypeTags latn;
}
internal class MS.Internal.Shaping.PairPositioningSubtable : ValueType {
    private static int offsetFormat;
    private static int offsetCoverage;
    private static int offsetValueFormat1;
    private static int offsetValueFormat2;
    private static int offsetFormat1PairSetCount;
    private static int offsetFormat1PairSetArray;
    private static int sizeFormat1PairSetOffset;
    private static int offsetFormat2ClassDef1;
    private static int offsetFormat2ClassDef2;
    private static int offsetFormat2Class1Count;
    private static int offsetFormat2Class2Count;
    private static int offsetFormat2ValueRecordArray;
    private int offset;
    public PairPositioningSubtable(int Offset);
    private ushort Format(FontTable Table);
    private CoverageTable Coverage(FontTable Table);
    private ushort FirstValueFormat(FontTable Table);
    private ushort SecondValueFormat(FontTable Table);
    private PairSetTable Format1PairSet(FontTable Table, ushort Index);
    private ClassDefTable Format2Class1Table(FontTable Table);
    private ClassDefTable Format2Class2Table(FontTable Table);
    private ushort Format2Class1Count(FontTable Table);
    private ushort Format2Class2Count(FontTable Table);
    private ValueRecordTable Format2FirstValueRecord(FontTable Table, ushort Class2Count, ushort Class1Index, ushort Class2Index);
    private ValueRecordTable Format2SecondValueRecord(FontTable Table, ushort Class2Count, ushort Class1Index, ushort Class2Index);
    public bool Apply(IOpenTypeFont Font, FontTable Table, LayoutMetrics Metrics, GlyphInfoList GlyphInfo, ushort LookupFlags, Int32* Advances, LayoutOffset* Offsets, int FirstGlyph, int AfterLastGlyph, Int32& NextGlyph);
    public bool IsLookupCovered(FontTable table, UInt32[] glyphBits, ushort minGlyphId, ushort maxGlyphId);
    public CoverageTable GetPrimaryCoverage(FontTable table);
}
internal static class MS.Internal.Shaping.Positioning : object {
    public static int DesignToPixels(ushort DesignUnitsPerEm, ushort PixelsPerEm, int Value);
    public static void AlignAnchors(IOpenTypeFont Font, FontTable Table, LayoutMetrics Metrics, GlyphInfoList GlyphInfo, Int32* Advances, LayoutOffset* Offsets, int StaticGlyph, int MobileGlyph, AnchorTable StaticAnchor, AnchorTable MobileAnchor, bool UseAdvances);
}
internal class MS.Internal.Shaping.ReverseChainingSubtable : ValueType {
    private static int offsetFormat;
    private static int offsetCoverage;
    private static int offsetBacktrackGlyphCount;
    private static int sizeCount;
    private static int sizeOffset;
    private static int sizeGlyphId;
    private int offset;
    public ReverseChainingSubtable(int Offset);
    private ushort Format(FontTable Table);
    private CoverageTable InputCoverage(FontTable Table);
    private CoverageTable Coverage(FontTable Table, int Offset);
    private ushort GlyphCount(FontTable Table, int Offset);
    private static ushort Glyph(FontTable Table, int Offset);
    public bool Apply(IOpenTypeFont Font, OpenTypeTags TableTag, FontTable Table, LayoutMetrics Metrics, int CharCount, UshortList Charmap, GlyphInfoList GlyphInfo, Int32* Advances, LayoutOffset* Offsets, ushort LookupFlags, int FirstGlyph, int AfterLastGlyph, UInt32 Parameter, Int32& NextGlyph);
    public bool IsLookupCovered(FontTable table, UInt32[] glyphBits, ushort minGlyphId, ushort maxGlyphId);
    public CoverageTable GetPrimaryCoverage(FontTable table);
}
internal class MS.Internal.Shaping.ScaledShapeTypeface : object {
    private ShapeTypeface _shapeTypeface;
    private double _scaleInEm;
    private bool _nullShape;
    internal ShapeTypeface ShapeTypeface { get; }
    internal double ScaleInEm { get; }
    internal bool NullShape { get; }
    internal ScaledShapeTypeface(GlyphTypeface glyphTypeface, IDeviceFont deviceFont, double scaleInEm, bool nullShape);
    internal ShapeTypeface get_ShapeTypeface();
    internal double get_ScaleInEm();
    internal bool get_NullShape();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
}
internal class MS.Internal.Shaping.ScriptList : ValueType {
    private static int offsetScriptCount;
    private static int offsetScriptRecordArray;
    private static int sizeScriptRecord;
    private static int offsetScriptRecordTag;
    private static int offsetScriptRecordOffset;
    private int offset;
    public ScriptList(int Offset);
    public ScriptTable FindScript(FontTable Table, UInt32 Tag);
    public ushort GetScriptCount(FontTable Table);
    public UInt32 GetScriptTag(FontTable Table, ushort Index);
    public ScriptTable GetScriptTable(FontTable Table, ushort Index);
}
internal class MS.Internal.Shaping.ScriptTable : ValueType {
    private static int offsetDefaultLangSys;
    private static int offsetLangSysCount;
    private static int offsetLangSysRecordArray;
    private static int sizeLangSysRecord;
    private static int offsetLangSysRecordTag;
    private static int offsetLangSysRecordOffset;
    private int offset;
    public bool IsNull { get; }
    public ScriptTable(int Offset);
    public LangSysTable FindLangSys(FontTable Table, UInt32 Tag);
    public bool IsDefaultLangSysExists(FontTable Table);
    public LangSysTable GetDefaultLangSysTable(FontTable Table);
    public ushort GetLangSysCount(FontTable Table);
    public UInt32 GetLangSysTag(FontTable Table, ushort Index);
    public LangSysTable GetLangSysTable(FontTable Table, ushort Index);
    public bool get_IsNull();
}
internal class MS.Internal.Shaping.ShaperBuffers : object {
    private UshortList _charMap;
    private GlyphInfoList _glyphInfoList;
    private OpenTypeLayoutWorkspace _layoutWorkspace;
    private ShaperFeaturesList _textFeatures;
    public UshortList CharMap { get; }
    public GlyphInfoList GlyphInfoList { get; public set; }
    public OpenTypeLayoutWorkspace LayoutWorkspace { get; }
    public ShaperFeaturesList TextFeatures { get; }
    public ShaperBuffers(ushort charCount, ushort glyphCount);
    protected virtual override void Finalize();
    public UshortList get_CharMap();
    public GlyphInfoList get_GlyphInfoList();
    public void set_GlyphInfoList(GlyphInfoList value);
    public bool Initialize(ushort charCount, ushort glyphCount);
    public bool InitializeFeatureList(ushort size, ushort keep);
    public OpenTypeLayoutWorkspace get_LayoutWorkspace();
    public ShaperFeaturesList get_TextFeatures();
}
internal class MS.Internal.Shaping.ShaperFeaturesList : object {
    private ushort _minimumAddCount;
    private ushort _featuresCount;
    private Feature[] _features;
    public int FeaturesCount { get; }
    public Feature[] Features { get; }
    public int NextIx { get; }
    public UInt32 CurrentTag { get; }
    public int Length { get; }
    public int get_FeaturesCount();
    public Feature[] get_Features();
    public int get_NextIx();
    public UInt32 get_CurrentTag();
    public int get_Length();
    public void SetFeatureParameter(ushort featureIx, UInt32 paramValue);
    internal bool Initialize(ushort newSize);
    internal bool Resize(ushort newSize, ushort keepCount);
    internal void AddFeature(Feature feature);
    internal void AddFeature(ushort startIndex, ushort length, UInt32 featureTag, UInt32 parameter);
    internal void AddFeature(ushort charIx, UInt32 featureTag);
    internal void UpdatePreviousShapedChar(UInt32 featureTag);
}
internal class MS.Internal.Shaping.ShapeTypeface : object {
    private GlyphTypeface _glyphTypeface;
    private IDeviceFont _deviceFont;
    internal IDeviceFont DeviceFont { get; }
    internal GlyphTypeface GlyphTypeface { get; }
    internal ShapeTypeface(GlyphTypeface glyphTypeface, IDeviceFont deviceFont);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    internal IDeviceFont get_DeviceFont();
    internal GlyphTypeface get_GlyphTypeface();
}
[FlagsAttribute]
internal enum MS.Internal.Shaping.ShapingOptions : Enum {
    public int value__;
    public static ShapingOptions None;
    public static ShapingOptions DisplayControlCode;
    public static ShapingOptions InhibitLigature;
}
internal class MS.Internal.Shaping.SinglePositioningSubtable : ValueType {
    private static int offsetFormat;
    private static int offsetCoverage;
    private static int offsetValueFormat;
    private static int offsetFormat1Value;
    private static int offsetFormat2ValueCount;
    private static int offsetFormat2ValueArray;
    private int offset;
    public SinglePositioningSubtable(int Offset);
    private ushort Format(FontTable Table);
    private CoverageTable Coverage(FontTable Table);
    private ushort ValueFormat(FontTable Table);
    private ValueRecordTable Format1ValueRecord(FontTable Table);
    private ValueRecordTable Format2ValueRecord(FontTable Table, ushort Index);
    public bool Apply(FontTable Table, LayoutMetrics Metrics, GlyphInfoList GlyphInfo, Int32* Advances, LayoutOffset* Offsets, int FirstGlyph, int AfterLastGlyph, Int32& NextGlyph);
    public bool IsLookupCovered(FontTable table, UInt32[] glyphBits, ushort minGlyphId, ushort maxGlyphId);
    public CoverageTable GetPrimaryCoverage(FontTable table);
}
internal class MS.Internal.Shaping.SingleSubstitutionSubtable : ValueType {
    private static int offsetFormat;
    private static int offsetCoverage;
    private static int offsetFormat1DeltaGlyphId;
    private static int offsetFormat2GlyphCount;
    private static int offsetFormat2SubstitutehArray;
    private static int sizeFormat2SubstituteSize;
    private int offset;
    public SingleSubstitutionSubtable(int Offset);
    private ushort Format(FontTable Table);
    private CoverageTable Coverage(FontTable Table);
    private short Format1DeltaGlyphId(FontTable Table);
    private ushort Format2SubstituteGlyphId(FontTable Table, ushort Index);
    public bool Apply(FontTable Table, GlyphInfoList GlyphInfo, int FirstGlyph, Int32& NextGlyph);
    public bool IsLookupCovered(FontTable table, UInt32[] glyphBits, ushort minGlyphId, ushort maxGlyphId);
    public CoverageTable GetPrimaryCoverage(FontTable table);
}
[FlagsAttribute]
internal enum MS.Internal.Shaping.TagInfoFlags : Enum {
    public UInt32 value__;
    public static TagInfoFlags Substitution;
    public static TagInfoFlags Positioning;
    public static TagInfoFlags Both;
    public static TagInfoFlags None;
}
internal enum MS.Internal.Shaping.TextFlowDirection : Enum {
    public ushort value__;
    public static TextFlowDirection LTR;
    public static TextFlowDirection RTL;
    public static TextFlowDirection TTB;
    public static TextFlowDirection BTT;
}
internal class MS.Internal.Shaping.TypefaceMap : object {
    private FontFamily[] _fontFamilies;
    private FontStyle _canonicalStyle;
    private FontWeight _canonicalWeight;
    private FontStretch _canonicalStretch;
    private bool _nullFont;
    private IList`1<ScaledShapeTypeface> _cachedScaledTypefaces;
    private IDictionary`2<CultureInfo, IntMap> _intMaps;
    private static int InitialScaledGlyphableTypefaceCount;
    private static int MaxTypefaceMapDepths;
    internal TypefaceMap(FontFamily fontFamily, FontFamily fallbackFontFamily, FontStyle canonicalStyle, FontWeight canonicalWeight, FontStretch canonicalStretch, bool nullFont);
    internal void GetShapeableText(CharacterBufferReference characterBufferReference, int stringLength, TextRunProperties textRunProperties, CultureInfo digitCulture, bool isRightToLeftParagraph, IList`1<TextShapeableSymbols> shapeableList, IShapeableTextCollector collector, TextFormattingMode textFormattingMode);
    private void MapItem(CharacterBufferRange unicodeString, CultureInfo culture, Span itemSpan, SpanVector`1& cachedScaledTypefaceIndexSpans, int ichItem);
    private bool GetCachedScaledTypefaceMap(CharacterBufferRange unicodeString, CultureInfo culture, CultureInfo digitCulture, SpanVector`1& cachedScaledTypefaceIndexSpans, int ichItem);
    private void CacheScaledTypefaceMap(CharacterBufferRange unicodeString, CultureInfo culture, CultureInfo digitCulture, SpanVector scaledTypefaceSpans, SpanVector`1& cachedScaledTypefaceIndexSpans, int ichItem);
    private int IndexOfScaledTypeface(ScaledShapeTypeface scaledTypeface);
    private int MapByFontFamily(CharacterBufferRange unicodeString, CultureInfo culture, CultureInfo digitCulture, IFontFamily fontFamily, CanonicalFontFamilyReference canonicalFamilyReference, FontStyle canonicalStyle, FontWeight canonicalWeight, FontStretch canonicalStretch, PhysicalFontFamily& firstValidFamily, Int32& firstValidLength, IDeviceFont deviceFont, double scaleInEm, int recursionDepth, SpanVector scaledTypefaceSpans, int firstCharIndex, Int32& nextValid);
    private int MapUnresolvedCharacters(CharacterBufferRange unicodeString, CultureInfo culture, CultureInfo digitCulture, PhysicalFontFamily firstValidFamily, Int32& firstValidLength, SpanVector scaledTypefaceSpans, int firstCharIndex, Int32& nextValid);
    private int MapByFontFamilyName(CharacterBufferRange unicodeString, CultureInfo culture, CultureInfo digitCulture, string familyName, Uri baseUri, PhysicalFontFamily& firstValidFamily, Int32& firstValidLength, IDeviceFont deviceFont, double scaleInEm, int fontMappingDepth, SpanVector scaledTypefaceSpans, int firstCharIndex, Int32& nextValid);
    private int MapByFontFamilyList(CharacterBufferRange unicodeString, CultureInfo culture, CultureInfo digitCulture, FontFamily[] familyList, PhysicalFontFamily& firstValidFamily, Int32& firstValidLength, IDeviceFont deviceFont, double scaleInEm, int recursionDepth, SpanVector scaledTypefaceSpans, int firstCharIndex, Int32& nextValid);
    private int MapOnceByFontFamilyList(CharacterBufferRange unicodeString, CultureInfo culture, CultureInfo digitCulture, FontFamily[] familyList, PhysicalFontFamily& firstValidFamily, Int32& firstValidLength, IDeviceFont deviceFont, double scaleInEm, int recursionDepth, SpanVector scaledTypefaceSpans, int firstCharIndex, Int32& nextValid);
    private int MapByFontFaceFamily(CharacterBufferRange unicodeString, CultureInfo culture, CultureInfo digitCulture, IFontFamily fontFamily, FontStyle canonicalStyle, FontWeight canonicalWeight, FontStretch canonicalStretch, PhysicalFontFamily& firstValidFamily, Int32& firstValidLength, IDeviceFont deviceFont, bool nullFont, double scaleInEm, SpanVector scaledTypefaceSpans, int firstCharIndex, bool ignoreMissing, Int32& nextValid);
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.Shaping.UnsafeUshortArray : UshortBuffer {
    private UInt16* _array;
    private SecurityCriticalDataForSet`1<int> _arrayLength;
    public ushort Item { get; public set; }
    public int Length { get; }
    internal UnsafeUshortArray(CheckedUShortPointer array, int arrayLength);
    public virtual ushort get_Item(int index);
    public virtual void set_Item(int index, ushort value);
    public virtual int get_Length();
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.Shaping.UshortArray : UshortBuffer {
    private UInt16[] _array;
    public ushort Item { get; public set; }
    public int Length { get; }
    internal UshortArray(UInt16[] array);
    internal UshortArray(int capacity, int leap);
    public virtual ushort get_Item(int index);
    public virtual void set_Item(int index, ushort value);
    public virtual int get_Length();
    public virtual UInt16[] ToArray();
    public virtual UInt16[] GetSubsetCopy(int index, int count);
    public virtual void Insert(int index, int count, int length);
    public virtual void Remove(int index, int count, int length);
}
[DefaultMemberAttribute("Item")]
internal abstract class MS.Internal.Shaping.UshortBuffer : object {
    protected int _leap;
    public ushort Item { get; public set; }
    public int Length { get; }
    public abstract virtual ushort get_Item(int index);
    public abstract virtual void set_Item(int index, ushort value);
    public abstract virtual int get_Length();
    public virtual UInt16[] ToArray();
    public virtual UInt16[] GetSubsetCopy(int index, int count);
    public virtual void Insert(int index, int count, int length);
    public virtual void Remove(int index, int count, int length);
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.Shaping.UshortList : object {
    private UshortBuffer _storage;
    private int _index;
    private int _length;
    public ushort Item { get; public set; }
    public int Length { get; public set; }
    public int Offset { get; }
    internal UshortList(int capacity, int leap);
    internal UshortList(UInt16[] array);
    internal UshortList(CheckedUShortPointer unsafeArray, int arrayLength);
    public ushort get_Item(int index);
    public void set_Item(int index, ushort value);
    public int get_Length();
    public void set_Length(int value);
    public int get_Offset();
    public void SetRange(int index, int length);
    public void Insert(int index, int count);
    public void Remove(int index, int count);
    public UInt16[] ToArray();
    public UInt16[] GetCopy();
}
internal class MS.Internal.Shaping.ValueRecordTable : ValueType {
    private static ushort XPlacmentFlag;
    private static ushort YPlacmentFlag;
    private static ushort XAdvanceFlag;
    private static ushort YAdvanceFlag;
    private static ushort XPlacementDeviceFlag;
    private static ushort YPlacementDeviceFlag;
    private static ushort XAdvanceDeviceFlag;
    private static ushort YAdvanceDeviceFlag;
    private static UInt16[] BitCount;
    private ushort format;
    private int baseTableOffset;
    private int offset;
    public ValueRecordTable(int Offset, int BaseTableOffset, ushort Format);
    private static ValueRecordTable();
    public static ushort Size(ushort Format);
    public void AdjustPos(FontTable Table, LayoutMetrics Metrics, LayoutOffset& GlyphOffset, Int32& GlyphAdvance);
}
internal class MS.Internal.Shaping.WritingSystem : ValueType {
    internal UInt32 scriptTag;
    internal UInt32 langSysTag;
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.SizeLimitedCache`2 : object {
    private int _maximumItems;
    private int _permanentCount;
    private Node<K, V> _begin;
    private Node<K, V> _end;
    private Dictionary`2<K, Node<K, V>> _nodeLookup;
    public int MaximumItems { get; }
    public SizeLimitedCache`2(int maximumItems);
    public int get_MaximumItems();
    public void Add(K key, V resource, bool isPermanent);
    public void Remove(K key);
    public V Get(K key);
    private void RemoveOldest();
    private void InsertAtEnd(Node<K, V> node);
    private void RemoveFromList(Node<K, V> node);
    private bool IsFull();
}
internal class MS.Internal.SpanEnumerator : object {
    private SpanVector _spans;
    private int _current;
    public object Current { get; }
    internal SpanEnumerator(SpanVector spans);
    public sealed virtual object get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
internal class MS.Internal.SpanPosition : ValueType {
    private int _spanIndex;
    private int _spanCP;
    internal int Index { get; }
    internal int CP { get; }
    internal SpanPosition(int spanIndex, int spanCP);
    internal int get_Index();
    internal int get_CP();
}
internal class MS.Internal.SpanRider : ValueType {
    private SpanVector _spans;
    private SpanPosition _spanPosition;
    private int _cp;
    private int _cch;
    public int CurrentSpanStart { get; }
    public int Length { get; }
    public int CurrentPosition { get; }
    public object CurrentElement { get; }
    public int CurrentSpanIndex { get; }
    public SpanPosition SpanPosition { get; }
    public SpanRider(SpanVector spans);
    public SpanRider(SpanVector spans, SpanPosition latestPosition);
    public SpanRider(SpanVector spans, SpanPosition latestPosition, int cp);
    public bool At(int cp);
    public bool At(SpanPosition latestPosition, int cp);
    public int get_CurrentSpanStart();
    public int get_Length();
    public int get_CurrentPosition();
    public object get_CurrentElement();
    public int get_CurrentSpanIndex();
    public SpanPosition get_SpanPosition();
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.SpanVector : object {
    private static Equals _referenceEquals;
    private static Equals _equals;
    private FrugalStructList`1<Span> _spans;
    private object _defaultObject;
    public int Count { get; }
    public object Default { get; }
    public Span Item { get; }
    public SpanVector(object defaultObject);
    internal SpanVector(object defaultObject, FrugalStructList`1<Span> spans);
    private static SpanVector();
    public sealed virtual IEnumerator GetEnumerator();
    private void Add(Span span);
    internal virtual void Delete(int index, int count, SpanPosition& latestPosition);
    private void DeleteInternal(int index, int count);
    private void Insert(int index, int count);
    internal bool FindSpan(int cp, SpanPosition latestPosition, SpanPosition& spanPosition);
    public void SetValue(int first, int length, object element);
    public SpanPosition SetValue(int first, int length, object element, SpanPosition spanPosition);
    public void SetReference(int first, int length, object element);
    public SpanPosition SetReference(int first, int length, object element, SpanPosition spanPosition);
    private SpanPosition Set(int first, int length, object element, Equals equals, SpanPosition spanPosition);
    public int get_Count();
    public object get_Default();
    public Span get_Item(int index);
    private bool Resize(int targetCount);
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.StringCharacterBuffer : CharacterBuffer {
    private string _string;
    public char Item { get; public set; }
    public int Count { get; }
    public StringCharacterBuffer(string characterString);
    public virtual char get_Item(int characterOffset);
    public virtual void set_Item(int characterOffset, char value);
    public virtual int get_Count();
    public virtual Char* GetCharacterPointer();
    public virtual IntPtr PinAndGetCharacterPointer(int offset, GCHandle& gcHandle);
    public virtual void UnpinCharacterPointer(GCHandle gcHandle);
    public virtual void AppendToStringBuilder(StringBuilder stringBuilder, int characterOffset, int characterLength);
}
internal static class MS.Internal.SynchronizedInputHelper : object {
    internal static DependencyObject GetUIParentCore(DependencyObject o);
    internal static bool IsMappedEvent(RoutedEventArgs args);
    internal static SynchronizedInputType GetPairedInputType(SynchronizedInputType inputType);
    internal static bool IsListening(RoutedEventArgs args);
    internal static bool IsListening(DependencyObject o, RoutedEventArgs args);
    internal static bool ShouldContinueListening(RoutedEventArgs args);
    internal static void AddParentPreOpportunityHandler(DependencyObject o, EventRoute route, RoutedEventArgs args);
    internal static void AddHandlerToRoute(DependencyObject o, EventRoute route, RoutedEventHandler eventHandler, bool handledToo);
    internal static void PreOpportunityHandler(object sender, RoutedEventArgs args);
    internal static void PostOpportunityHandler(object sender, RoutedEventArgs args);
    internal static RoutedEvent[] MapInputTypeToRoutedEvents(SynchronizedInputType inputType);
    internal static void RaiseAutomationEvents();
    internal static void RaiseAutomationEvent(AutomationPeer peer);
}
internal enum MS.Internal.SynchronizedInputStates : Enum {
    public int value__;
    public static SynchronizedInputStates NoOpportunity;
    public static SynchronizedInputStates HadOpportunity;
    public static SynchronizedInputStates Handled;
    public static SynchronizedInputStates Discarded;
}
internal static class MS.Internal.SystemDrawingHelper : object {
    internal static bool IsBitmap(object data);
    internal static bool IsImage(object data);
    internal static bool IsMetafile(object data);
    internal static IntPtr GetHandleFromMetafile(object data);
    internal static object GetMetafileFromHemf(IntPtr hMetafile);
    internal static object GetBitmap(object data);
    internal static IntPtr GetHBitmap(object data, Int32& width, Int32& height);
    internal static IntPtr GetHBitmapFromBitmap(object data);
    internal static IntPtr ConvertMetafileToHBitmap(IntPtr handle);
    internal static Stream GetCommentFromGifStream(Stream stream);
    internal static void SaveMetafileToImageStream(MemoryStream metafileStream, Stream imageStream);
    internal static object GetBitmapFromBitmapSource(object source);
}
internal class MS.Internal.Telemetry.PresentationCore.EventSourceActivity : object {
    private static Guid _emptyGuid;
    private EventSource _eventSource;
    private EventSourceOptions _startStopOptions;
    private Guid _parentId;
    private Guid _id;
    private State _state;
    internal EventSource EventSource { get; }
    internal Guid Id { get; }
    internal EventSourceActivity(EventSource eventSource);
    internal EventSourceActivity(EventSource eventSource, EventSourceOptions startStopOptions);
    internal EventSourceActivity(EventSource eventSource, EventSourceOptions startStopOptions, Guid parentActivityId);
    internal EventSourceActivity(EventSourceActivity parentActivity);
    internal EventSourceActivity(EventSourceActivity parentActivity, EventSourceOptions startStopOptions);
    internal EventSource get_EventSource();
    internal Guid get_Id();
    internal void Start(string eventName);
    internal void Start(string eventName, T data);
    internal void Stop(string eventName);
    internal void Stop(string eventName, T data);
    internal void Write(string eventName);
    internal void Write(string eventName, EventSourceOptions options);
    internal void Write(string eventName, T data);
    internal void Write(string eventName, EventSourceOptions options, T data);
    public sealed virtual void Dispose();
    private void Start(string eventName, T& data);
    private void Write(string eventName, EventSourceOptions& options, T& data);
    private void Stop(string eventName, T& data);
}
internal class MS.Internal.Telemetry.PresentationCore.TelemetryEventSource : EventSource {
    internal static EventKeywords Reserved44Keyword;
    internal static EventKeywords TelemetryKeyword;
    internal static EventKeywords MeasuresKeyword;
    internal static EventKeywords CriticalDataKeyword;
    internal static EventTags CoreData;
    internal static EventTags InjectXToken;
    internal static EventTags RealtimeLatency;
    internal static EventTags NormalLatency;
    internal static EventTags CriticalPersistence;
    internal static EventTags NormalPersistence;
    internal static EventTags DropPii;
    internal static EventTags HashPii;
    internal static EventTags MarkPii;
    internal static EventFieldTags DropPiiField;
    internal static EventFieldTags HashPiiField;
    private static String[] telemetryTraits;
    internal TelemetryEventSource(string eventSourceName);
    private static TelemetryEventSource();
    internal static EventSourceOptions TelemetryOptions();
    internal static EventSourceOptions MeasuresOptions();
    internal static EventSourceOptions CriticalDataOptions();
}
internal static class MS.Internal.Telemetry.PresentationCore.TraceLoggingProvider : object {
    private static EventSource _logger;
    private static object _lockObject;
    private static string ProviderName;
    private static TraceLoggingProvider();
    internal static EventSource GetProvider();
}
internal static class MS.Internal.Telemetry.PresentationCore.XpsOMPrintingTraceLogger : object {
    private static string XpsOMEnabled;
    private static XpsOMPrintingTraceLogger();
    internal static void LogXpsOMStatus(bool enabled);
}
internal static class MS.Internal.TextFormatting.Bidi : object {
    private static StateMachineAction[0...,0...] Action;
    private static StateMachineState[0...,0...] NextState;
    private static Byte[0...,0...] ImplictPush;
    private static Byte[0...,0...] CharProperty;
    private static StateMachineState[] ClassToState;
    private static Byte[] FastPathClass;
    private static char CharHidden;
    private static byte ParagraphTerminatorLevel;
    private static int PositionInvalid;
    private static byte BaseLevelLeft;
    private static byte BaseLevelRight;
    private static UInt32 EmptyStack;
    private static UInt32 StackLtr;
    private static UInt32 StackRtl;
    private static int MaxLevel;
    private static Bidi();
    internal static bool GetLastStongAndNumberClass(CharacterBufferRange charString, DirectionClass& strongClass, DirectionClass& numberClass);
    private static bool GetFirstStrongCharacter(CharacterBuffer charBuffer, int ichText, int cchText, DirectionClass& strongClass);
    private static void ResolveNeutrals(IList`1<DirectionClass> characterClass, int classIndex, int count, DirectionClass startClass, DirectionClass endClass, byte runLevel);
    private static void ChangeType(IList`1<DirectionClass> characterClass, int classIndex, int count, DirectionClass newClass);
    private static int ResolveNeutralAndWeak(IList`1<DirectionClass> characterClass, int classIndex, int runLength, DirectionClass sor, DirectionClass eor, byte runLevel, State stateIn, State stateOut, bool previousStrongIsArabic, Flags flags);
    private static void ResolveImplictLevels(IList`1<DirectionClass> characterClass, CharacterBuffer charBuffer, int ichText, int runLength, IList`1<byte> levels, int index, byte paragraphEmbeddingLevel);
    public static bool Analyze(Char[] chars, int cchText, int cchTextMaxHint, Flags flags, State state, Byte[]& levels, Int32& cchResolved);
    internal static bool BidiAnalyzeInternal(CharacterBuffer charBuffer, int ichText, int cchText, int cchTextMaxHint, Flags flags, State state, IList`1<byte> levels, IList`1<DirectionClass> characterClass, Int32& cchResolved);
}
internal class MS.Internal.TextFormatting.BidiState : State {
    private FormatSettings _settings;
    private int _cpFirst;
    private int _cpFirstScope;
    internal byte CurrentLevel { get; }
    public DirectionClass LastNumberClass { get; public set; }
    public DirectionClass LastStrongClass { get; public set; }
    public BidiState(FormatSettings settings, int cpFirst);
    public BidiState(FormatSettings settings, int cpFirst, TextModifierScope modifierScope);
    internal void SetLastDirectionClassesAtLevelChange();
    internal byte get_CurrentLevel();
    public virtual DirectionClass get_LastNumberClass();
    public virtual void set_LastNumberClass(DirectionClass value);
    public virtual DirectionClass get_LastStrongClass();
    public virtual void set_LastStrongClass(DirectionClass value);
    private void GetLastDirectionClasses();
    private static void InitLevelStackFromModifierScope(BidiStack stack, TextModifierScope scope, UInt16& overflowLevels);
    internal DirectionClass GetEuropeanNumberClassOverride(CultureInfo cultureInfo);
}
internal static class MS.Internal.TextFormatting.Constants : object {
    public static double GreatestMutiplierOfEm;
    public static double DefaultRealToIdeal;
    public static double DefaultIdealToReal;
    public static int IdealInfiniteWidth;
    public static double RealInfiniteWidth;
    public static double MinInterWordCompressionPerEm;
    public static double MaxInterWordExpansionPerEm;
    public static int AcceptableLineStretchability;
    public static int MinCchToCacheBeforeAndAfter;
}
internal class MS.Internal.TextFormatting.Convert : object {
    public static FlowDirection LsTFlowToFlowDirection(LsTFlow lstflow);
    public static LsKTab LsKTabFromTabAlignment(TextTabAlignment tabAlignment);
}
internal static class MS.Internal.TextFormatting.CultureMapper : object {
    private static CachedCultureMap _cachedCultureMap;
    public static CultureInfo GetSpecificCulture(CultureInfo runCulture);
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.TextFormatting.DigitMap : ValueType {
    private NumberFormatInfo _format;
    private String[] _digits;
    internal int Item { get; }
    internal DigitMap(CultureInfo digitCulture);
    internal int get_Item(int ch);
    internal static int GetFallbackCharacter(int ch);
    private static int StringToScalar(string s, int defaultValue);
    internal static bool IsHighSurrogate(int ch);
    internal static bool IsLowSurrogate(int ch);
    internal static bool IsSurrogate(int ch);
    internal static int MakeUnicodeScalar(int hi, int lo);
    private static bool IsDigitOrSymbol(int ch);
}
internal class MS.Internal.TextFormatting.DigitState : object {
    private CultureInfo _lastTraditionalCulture;
    private NumberSubstitutionMethod _lastMethod;
    private CultureInfo _lastNumberCulture;
    private CultureInfo _digitCulture;
    private bool _contextual;
    internal CultureInfo DigitCulture { get; }
    internal bool RequiresNumberSubstitution { get; }
    internal bool Contextual { get; }
    internal CultureInfo get_DigitCulture();
    internal bool get_RequiresNumberSubstitution();
    internal bool get_Contextual();
    internal static NumberSubstitutionMethod GetResolvedSubstitutionMethod(TextRunProperties properties, CultureInfo digitCulture, Boolean& ignoreUserOverride);
    internal void SetTextRunProperties(TextRunProperties properties);
    private static CultureInfo GetNumberCulture(TextRunProperties properties, NumberSubstitutionMethod& method, Boolean& ignoreUserOverride);
    private CultureInfo GetDigitCulture(CultureInfo numberCulture, NumberSubstitutionMethod method, Boolean& contextual);
    private static bool HasLatinDigits(CultureInfo culture);
    private static bool IsArabic(CultureInfo culture);
    private static bool IsFarsi(CultureInfo culture);
    private CultureInfo GetTraditionalCulture(CultureInfo numberCulture);
    private CultureInfo CreateTraditionalCulture(CultureInfo numberCulture, int firstDigit, bool arabic);
}
internal static class MS.Internal.TextFormatting.DoubleWideChar : object {
    internal static int GetChar(CharacterBuffer charBuffer, int ichText, int cchText, int charNumber, Int32& wordCount);
}
internal class MS.Internal.TextFormatting.DrawGlyphs : MulticastDelegate {
    public DrawGlyphs(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, Plsrun plsrun, Char* pwchText, UInt16* puClusterMap, UInt16* puCharProperties, int cchText, UInt16* puGlyphs, Int32* piJustifiedGlyphAdvances, Int32* puGlyphAdvances, GlyphOffset* piiGlyphOffsets, UInt32* piGlyphProperties, LsExpType* plsExpType, int glyphCount, LsTFlow textFlow, UInt32 displayMode, LSPOINT& origin, LsHeights& lsHeights, int runWidth, LSRECT& clippingRect);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, Plsrun plsrun, Char* pwchText, UInt16* puClusterMap, UInt16* puCharProperties, int cchText, UInt16* puGlyphs, Int32* piJustifiedGlyphAdvances, Int32* puGlyphAdvances, GlyphOffset* piiGlyphOffsets, UInt32* piGlyphProperties, LsExpType* plsExpType, int glyphCount, LsTFlow textFlow, UInt32 displayMode, LSPOINT& origin, LsHeights& lsHeights, int runWidth, LSRECT& clippingRect, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(LSPOINT& origin, LsHeights& lsHeights, LSRECT& clippingRect, IAsyncResult result);
}
internal class MS.Internal.TextFormatting.DrawingState : object {
    private FullTextLine _currentLine;
    private DrawingContext _drawingContext;
    private Point _lineOrigin;
    private Point _vectorToLineOrigin;
    private MatrixTransform _antiInversion;
    private bool _overrideBaseGuidelineY;
    private double _baseGuidelineY;
    internal DrawingContext DrawingContext { get; }
    internal MatrixTransform AntiInversion { get; }
    internal Point LineOrigin { get; }
    internal Point VectorToLineOrigin { get; }
    internal FullTextLine CurrentLine { get; }
    internal DrawingState(DrawingContext drawingContext, Point lineOrigin, MatrixTransform antiInversion, FullTextLine currentLine);
    internal void SetGuidelineY(double runGuidelineY);
    internal void UnsetGuidelineY();
    public sealed virtual void Dispose();
    internal DrawingContext get_DrawingContext();
    internal MatrixTransform get_AntiInversion();
    internal Point get_LineOrigin();
    internal Point get_VectorToLineOrigin();
    internal FullTextLine get_CurrentLine();
}
internal class MS.Internal.TextFormatting.DrawStrikethrough : MulticastDelegate {
    public DrawStrikethrough(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, Plsrun plsrun, UInt32 stType, LSPOINT& ptOrigin, int stLength, int stThickness, LsTFlow textFlow, UInt32 displayMode, LSRECT& clipRect);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, Plsrun plsrun, UInt32 stType, LSPOINT& ptOrigin, int stLength, int stThickness, LsTFlow textFlow, UInt32 displayMode, LSRECT& clipRect, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(LSPOINT& ptOrigin, LSRECT& clipRect, IAsyncResult result);
}
internal class MS.Internal.TextFormatting.DrawTextRun : MulticastDelegate {
    public DrawTextRun(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, Plsrun plsrun, LSPOINT& ptText, Char* runText, Int32* charWidths, int cchText, LsTFlow textFlow, UInt32 displayMode, LSPOINT& ptRun, LsHeights& lsHeights, int dupRun, LSRECT& clipRect);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, Plsrun plsrun, LSPOINT& ptText, Char* runText, Int32* charWidths, int cchText, LsTFlow textFlow, UInt32 displayMode, LSPOINT& ptRun, LsHeights& lsHeights, int dupRun, LSRECT& clipRect, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(LSPOINT& ptText, LSPOINT& ptRun, LsHeights& lsHeights, LSRECT& clipRect, IAsyncResult result);
}
internal class MS.Internal.TextFormatting.DrawUnderline : MulticastDelegate {
    public DrawUnderline(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, Plsrun plsrun, UInt32 ulType, LSPOINT& ptOrigin, int ulLength, int ulThickness, LsTFlow textFlow, UInt32 displayMode, LSRECT& clipRect);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, Plsrun plsrun, UInt32 ulType, LSPOINT& ptOrigin, int ulLength, int ulThickness, LsTFlow textFlow, UInt32 displayMode, LSRECT& clipRect, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(LSPOINT& ptOrigin, LSRECT& clipRect, IAsyncResult result);
}
internal class MS.Internal.TextFormatting.EnumTab : MulticastDelegate {
    public EnumTab(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, Plsrun plsrun, int cpFirst, Char* pwchText, char tabLeader, LsTFlow lstFlow, int fReverseOrder, int fGeometryProvided, LSPOINT& pptStart, LsHeights& heights, int dupRun);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, Plsrun plsrun, int cpFirst, Char* pwchText, char tabLeader, LsTFlow lstFlow, int fReverseOrder, int fGeometryProvided, LSPOINT& pptStart, LsHeights& heights, int dupRun, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(LSPOINT& pptStart, LsHeights& heights, IAsyncResult result);
}
internal class MS.Internal.TextFormatting.EnumText : MulticastDelegate {
    public EnumText(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, Plsrun plsrun, int cpFirst, int dcp, Char* pwchText, int cchText, LsTFlow lstFlow, int fReverseOrder, int fGeometryProvided, LSPOINT& pptStart, LsHeights& pheights, int dupRun, int glyphBaseRun, Int32* charWidths, UInt16* pClusterMap, UInt16* characterProperties, UInt16* puglyphs, Int32* pGlyphAdvances, GlyphOffset* pGlyphOffsets, UInt32* pGlyphProperties, int glyphCount);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, Plsrun plsrun, int cpFirst, int dcp, Char* pwchText, int cchText, LsTFlow lstFlow, int fReverseOrder, int fGeometryProvided, LSPOINT& pptStart, LsHeights& pheights, int dupRun, int glyphBaseRun, Int32* charWidths, UInt16* pClusterMap, UInt16* characterProperties, UInt16* puglyphs, Int32* pGlyphAdvances, GlyphOffset* pGlyphOffsets, UInt32* pGlyphProperties, int glyphCount, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(LSPOINT& pptStart, LsHeights& pheights, IAsyncResult result);
}
internal class MS.Internal.TextFormatting.EscStringInfo : ValueType {
    public IntPtr szParaSeparator;
    public IntPtr szLineSeparator;
    public IntPtr szHidden;
    public IntPtr szNbsp;
    public IntPtr szObjectTerminator;
    public IntPtr szObjectReplacement;
}
internal class MS.Internal.TextFormatting.FetchLineProps : MulticastDelegate {
    public FetchLineProps(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, int lscpFetch, int firstLineInPara, LsLineProps& lsLineProps);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, int lscpFetch, int firstLineInPara, LsLineProps& lsLineProps, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(LsLineProps& lsLineProps, IAsyncResult result);
}
internal class MS.Internal.TextFormatting.FetchPap : MulticastDelegate {
    public FetchPap(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, int lscpFetch, LsPap& lspap);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, int lscpFetch, LsPap& lspap, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(LsPap& lspap, IAsyncResult result);
}
internal class MS.Internal.TextFormatting.FetchRunRedefined : MulticastDelegate {
    public FetchRunRedefined(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, int lscpFetch, int fIsStyle, IntPtr pstyle, Char* pwchTextBuffer, int cchTextBuffer, Int32& fIsBufferUsed, Char*& pwchText, Int32& cchText, Int32& fIsHidden, LsChp& lschp, IntPtr& lsplsrun);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, int lscpFetch, int fIsStyle, IntPtr pstyle, Char* pwchTextBuffer, int cchTextBuffer, Int32& fIsBufferUsed, Char*& pwchText, Int32& cchText, Int32& fIsHidden, LsChp& lschp, IntPtr& lsplsrun, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(Int32& fIsBufferUsed, Char*& pwchText, Int32& cchText, Int32& fIsHidden, LsChp& lschp, IntPtr& lsplsrun, IAsyncResult result);
}
internal class MS.Internal.TextFormatting.FInterruptShaping : MulticastDelegate {
    public FInterruptShaping(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, LsTFlow textFlow, Plsrun firstPlsrun, Plsrun secondPlsrun, Int32& fIsInterruptOk);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, LsTFlow textFlow, Plsrun firstPlsrun, Plsrun secondPlsrun, Int32& fIsInterruptOk, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(Int32& fIsInterruptOk, IAsyncResult result);
}
internal class MS.Internal.TextFormatting.FormatSettings : object {
    private TextFormatterImp _formatter;
    private TextSource _textSource;
    private TextRunCacheImp _runCache;
    private ParaProp _pap;
    private DigitState _digitState;
    private TextLineBreak _previousLineBreak;
    private int _maxLineWidth;
    private int _textIndent;
    private TextFormattingMode _textFormattingMode;
    private bool _isSideways;
    internal TextFormattingMode TextFormattingMode { get; }
    internal bool IsSideways { get; }
    internal TextFormatterImp Formatter { get; }
    internal TextSource TextSource { get; }
    internal TextLineBreak PreviousLineBreak { get; }
    internal ParaProp Pap { get; }
    internal int MaxLineWidth { get; }
    internal DigitState DigitState { get; }
    internal int TextIndent { get; }
    internal FormatSettings(TextFormatterImp formatter, TextSource textSource, TextRunCacheImp runCache, ParaProp pap, TextLineBreak previousLineBreak, bool isSingleLineFormatting, TextFormattingMode textFormattingMode, bool isSideways);
    internal TextFormattingMode get_TextFormattingMode();
    internal bool get_IsSideways();
    internal TextFormatterImp get_Formatter();
    internal TextSource get_TextSource();
    internal TextLineBreak get_PreviousLineBreak();
    internal ParaProp get_Pap();
    internal int get_MaxLineWidth();
    internal void UpdateSettingsForCurrentLine(int maxLineWidth, TextLineBreak previousLineBreak, bool isFirstLineInPara);
    internal int GetFormatWidth(int finiteFormatWidth);
    internal int GetFiniteFormatWidth(int paragraphWidth);
    internal CharacterBufferRange FetchTextRun(int cpFetch, int cpFirst, TextRun& textRun, Int32& runLength);
    internal TextSpan`1<CultureSpecificCharacterBufferRange> GetPrecedingText(int cpLimit);
    internal DigitState get_DigitState();
    internal int get_TextIndent();
}
internal class MS.Internal.TextFormatting.FormattedTextSymbols : object {
    private Glyphs[] _glyphs;
    private bool _rightToLeft;
    private TextFormattingMode _textFormattingMode;
    private bool _isSideways;
    public double Width { get; }
    public FormattedTextSymbols(GlyphingCache glyphingCache, TextRun textSymbols, bool rightToLeft, double scalingFactor, float pixelsPerDip, TextFormattingMode textFormattingMode, bool isSideways);
    public double get_Width();
    public Rect Draw(DrawingContext drawingContext, Point currentOrigin);
}
internal class MS.Internal.TextFormatting.FullTextBreakpoint : TextBreakpoint {
    private TextMetrics _metrics;
    private SecurityCriticalDataForSet`1<IntPtr> _ploline;
    private SecurityCriticalDataForSet`1<IntPtr> _penaltyResource;
    private bool _isDisposed;
    private bool _isLineTruncated;
    public bool IsTruncated { get; }
    public int Length { get; }
    public int DependentLength { get; }
    public int NewlineLength { get; }
    public double Start { get; }
    public double Width { get; }
    public double WidthIncludingTrailingWhitespace { get; }
    public double Height { get; }
    public double TextHeight { get; }
    public double Baseline { get; }
    public double TextBaseline { get; }
    public double MarkerBaseline { get; }
    public double MarkerHeight { get; }
    private FullTextBreakpoint(FullTextState fullText, int firstCharIndex, int maxLineWidth, LsBreaks& lsbreaks, int breakIndex);
    internal static IList`1<TextBreakpoint> CreateMultiple(TextParagraphCache paragraphCache, int firstCharIndex, int maxLineWidth, TextLineBreak previousLineBreak, IntPtr penaltyRestriction, Int32& bestFitIndex);
    protected virtual override void Finalize();
    protected virtual void Dispose(bool disposing);
    public virtual TextLineBreak GetTextLineBreak();
    internal virtual SecurityCriticalDataForSet`1<IntPtr> GetTextPenaltyResource();
    public virtual bool get_IsTruncated();
    public virtual int get_Length();
    public virtual int get_DependentLength();
    public virtual int get_NewlineLength();
    public virtual double get_Start();
    public virtual double get_Width();
    public virtual double get_WidthIncludingTrailingWhitespace();
    public virtual double get_Height();
    public virtual double get_TextHeight();
    public virtual double get_Baseline();
    public virtual double get_TextBaseline();
    public virtual double get_MarkerBaseline();
    public virtual double get_MarkerHeight();
}
internal class MS.Internal.TextFormatting.FullTextState : object {
    private TextStore _store;
    private TextStore _markerStore;
    private StatusFlags _statusFlags;
    private int _cpMeasured;
    private int _lscpHyphenationLookAhead;
    private bool _isSideways;
    private static int MinCchWordToHyphenate;
    internal int CpMeasured { get; internal set; }
    internal int LscpHyphenationLookAhead { get; }
    internal TextFormattingMode TextFormattingMode { get; }
    internal bool IsSideways { get; }
    internal bool VerticalAdjust { get; internal set; }
    internal bool ForceWrap { get; internal set; }
    internal bool KeepState { get; }
    internal TextStore TextStore { get; }
    internal TextStore TextMarkerStore { get; }
    internal TextFormatterImp Formatter { get; }
    internal int FormatWidth { get; }
    private FullTextState(TextStore store, TextStore markerStore, bool isSideways);
    internal static FullTextState Create(FormatSettings settings, int cpFirst, int finiteFormatWidth);
    internal int get_CpMeasured();
    internal void set_CpMeasured(int value);
    internal int get_LscpHyphenationLookAhead();
    internal TextFormattingMode get_TextFormattingMode();
    internal bool get_IsSideways();
    internal void SetTabs(TextFormatterContext context);
    private void CreateLsTbds(ParaProp pap, LsTbd* plsTbds, int lsTbdCount);
    internal int GetMainTextToMarkerIdealDistance();
    internal LSRun CountText(int lscpLim, int cpFirst, Int32& count);
    internal int GetBreakpointInternalCp(int cp);
    internal bool FindNextHyphenBreak(int lscpCurrent, int lscchLim, bool isCurrentAtWordStart, Int32& lscpHyphen, LsHyph& lshyph);
    private LexicalChunk GetChunk(TextLexicalService lexicalService, int lscpCurrent, int lscchLim, bool isCurrentAtWordStart, Int32& lscpChunk, Int32& lscchChunk);
    internal TextStore StoreFrom(Plsrun plsrun);
    internal TextStore StoreFrom(int lscp);
    internal bool get_VerticalAdjust();
    internal void set_VerticalAdjust(bool value);
    internal bool get_ForceWrap();
    internal void set_ForceWrap(bool value);
    internal bool get_KeepState();
    internal TextStore get_TextStore();
    internal TextStore get_TextMarkerStore();
    internal TextFormatterImp get_Formatter();
    internal int get_FormatWidth();
}
internal class MS.Internal.TextFormatting.GenericTextParagraphProperties : TextParagraphProperties {
    private FlowDirection _flowDirection;
    private TextAlignment _textAlignment;
    private bool _firstLineInParagraph;
    private bool _alwaysCollapsible;
    private TextRunProperties _defaultTextRunProperties;
    private TextWrapping _textWrap;
    private double _indent;
    private double _lineHeight;
    public FlowDirection FlowDirection { get; }
    public TextAlignment TextAlignment { get; }
    public double LineHeight { get; }
    public bool FirstLineInParagraph { get; }
    public bool AlwaysCollapsible { get; }
    public TextRunProperties DefaultTextRunProperties { get; }
    public TextWrapping TextWrapping { get; }
    public TextMarkerProperties TextMarkerProperties { get; }
    public double Indent { get; }
    public GenericTextParagraphProperties(FlowDirection flowDirection, TextAlignment textAlignment, bool firstLineInParagraph, bool alwaysCollapsible, TextRunProperties defaultTextRunProperties, TextWrapping textWrap, double lineHeight, double indent);
    public GenericTextParagraphProperties(TextParagraphProperties textParagraphProperties);
    public virtual FlowDirection get_FlowDirection();
    public virtual TextAlignment get_TextAlignment();
    public virtual double get_LineHeight();
    public virtual bool get_FirstLineInParagraph();
    public virtual bool get_AlwaysCollapsible();
    public virtual TextRunProperties get_DefaultTextRunProperties();
    public virtual TextWrapping get_TextWrapping();
    public virtual TextMarkerProperties get_TextMarkerProperties();
    public virtual double get_Indent();
    internal void SetFlowDirection(FlowDirection flowDirection);
    internal void SetTextAlignment(TextAlignment textAlignment);
    internal void SetLineHeight(double lineHeight);
    internal void SetTextWrapping(TextWrapping textWrap);
}
internal class MS.Internal.TextFormatting.GenericTextRunProperties : TextRunProperties {
    private Typeface _typeface;
    private double _emSize;
    private double _emHintingSize;
    private TextDecorationCollection _textDecorations;
    private Brush _foregroundBrush;
    private Brush _backgroundBrush;
    private BaselineAlignment _baselineAlignment;
    private CultureInfo _culture;
    private NumberSubstitution _numberSubstitution;
    public Typeface Typeface { get; }
    public double FontRenderingEmSize { get; }
    public double FontHintingEmSize { get; }
    public TextDecorationCollection TextDecorations { get; }
    public Brush ForegroundBrush { get; }
    public Brush BackgroundBrush { get; }
    public BaselineAlignment BaselineAlignment { get; }
    public CultureInfo CultureInfo { get; }
    public TextRunTypographyProperties TypographyProperties { get; }
    public TextEffectCollection TextEffects { get; }
    public NumberSubstitution NumberSubstitution { get; }
    public GenericTextRunProperties(Typeface typeface, double size, double hintingSize, double pixelsPerDip, TextDecorationCollection textDecorations, Brush foregroundBrush, Brush backgroundBrush, BaselineAlignment baselineAlignment, CultureInfo culture, NumberSubstitution substitution);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public virtual Typeface get_Typeface();
    public virtual double get_FontRenderingEmSize();
    public virtual double get_FontHintingEmSize();
    public virtual TextDecorationCollection get_TextDecorations();
    public virtual Brush get_ForegroundBrush();
    public virtual Brush get_BackgroundBrush();
    public virtual BaselineAlignment get_BaselineAlignment();
    public virtual CultureInfo get_CultureInfo();
    public virtual TextRunTypographyProperties get_TypographyProperties();
    public virtual TextEffectCollection get_TextEffects();
    public virtual NumberSubstitution get_NumberSubstitution();
}
internal class MS.Internal.TextFormatting.GetAutoNumberInfo : MulticastDelegate {
    public GetAutoNumberInfo(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, LsKAlign& alignment, LsChp& lschp, IntPtr& lsplsrun, UInt16& addedChar, LsChp& lschpAddedChar, IntPtr& lsplsrunAddedChar, Int32& fWord95Model, Int32& offset, Int32& width);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, LsKAlign& alignment, LsChp& lschp, IntPtr& lsplsrun, UInt16& addedChar, LsChp& lschpAddedChar, IntPtr& lsplsrunAddedChar, Int32& fWord95Model, Int32& offset, Int32& width, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(LsKAlign& alignment, LsChp& lschp, IntPtr& lsplsrun, UInt16& addedChar, LsChp& lschpAddedChar, IntPtr& lsplsrunAddedChar, Int32& fWord95Model, Int32& offset, Int32& width, IAsyncResult result);
}
internal class MS.Internal.TextFormatting.GetCharCompressionInfoFullMixed : MulticastDelegate {
    public GetCharCompressionInfoFullMixed(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, LsDevice device, LsTFlow textFlow, LsCharRunInfo* plscharrunInfo, LsNeighborInfo* plsneighborInfoLeft, LsNeighborInfo* plsneighborInfoRight, int maxPriorityLevel, Int32** pplscompressionLeft, Int32** pplscompressionRight);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, LsDevice device, LsTFlow textFlow, LsCharRunInfo* plscharrunInfo, LsNeighborInfo* plsneighborInfoLeft, LsNeighborInfo* plsneighborInfoRight, int maxPriorityLevel, Int32** pplscompressionLeft, Int32** pplscompressionRight, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(IAsyncResult result);
}
internal class MS.Internal.TextFormatting.GetCharExpansionInfoFullMixed : MulticastDelegate {
    public GetCharExpansionInfoFullMixed(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, LsDevice device, LsTFlow textFlow, LsCharRunInfo* plscharrunInfo, LsNeighborInfo* plsneighborInfoLeft, LsNeighborInfo* plsneighborInfoRight, int maxPriorityLevel, Int32** pplsexpansionLeft, Int32** pplsexpansionRight);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, LsDevice device, LsTFlow textFlow, LsCharRunInfo* plscharrunInfo, LsNeighborInfo* plsneighborInfoLeft, LsNeighborInfo* plsneighborInfoRight, int maxPriorityLevel, Int32** pplsexpansionLeft, Int32** pplsexpansionRight, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(IAsyncResult result);
}
internal class MS.Internal.TextFormatting.GetDurMaxExpandRagged : MulticastDelegate {
    public GetDurMaxExpandRagged(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, Plsrun plsrun, LsTFlow lstFlow, Int32& maxExpandRagged);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, Plsrun plsrun, LsTFlow lstFlow, Int32& maxExpandRagged, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(Int32& maxExpandRagged, IAsyncResult result);
}
internal class MS.Internal.TextFormatting.GetGlyphCompressionInfoFullMixed : MulticastDelegate {
    public GetGlyphCompressionInfoFullMixed(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, LsDevice device, LsTFlow textFlow, LsGlyphRunInfo* plsglyphrunInfo, LsNeighborInfo* plsneighborInfoLeft, LsNeighborInfo* plsneighborInfoRight, int maxPriorityLevel, Int32** pplscompressionLeft, Int32** pplscompressionRight);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, LsDevice device, LsTFlow textFlow, LsGlyphRunInfo* plsglyphrunInfo, LsNeighborInfo* plsneighborInfoLeft, LsNeighborInfo* plsneighborInfoRight, int maxPriorityLevel, Int32** pplscompressionLeft, Int32** pplscompressionRight, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(IAsyncResult result);
}
internal class MS.Internal.TextFormatting.GetGlyphExpansionInfoFullMixed : MulticastDelegate {
    public GetGlyphExpansionInfoFullMixed(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, LsDevice device, LsTFlow textFlow, LsGlyphRunInfo* plsglyphrunInfo, LsNeighborInfo* plsneighborInfoLeft, LsNeighborInfo* plsneighborInfoRight, int maxPriorityLevel, Int32** pplsexpansionLeft, Int32** pplsexpansionRight, LsExpType* plsexptype, Int32* pduMinInk);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, LsDevice device, LsTFlow textFlow, LsGlyphRunInfo* plsglyphrunInfo, LsNeighborInfo* plsneighborInfoLeft, LsNeighborInfo* plsneighborInfoRight, int maxPriorityLevel, Int32** pplsexpansionLeft, Int32** pplsexpansionRight, LsExpType* plsexptype, Int32* pduMinInk, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(IAsyncResult result);
}
internal class MS.Internal.TextFormatting.GetGlyphPositions : MulticastDelegate {
    public GetGlyphPositions(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, IntPtr* plsplsruns, Int32* pcchPlsrun, int plsrunCount, LsDevice device, Char* pwchText, UInt16* puClusterMap, UInt16* puCharProperties, int cchText, UInt16* puGlyphs, UInt32* piGlyphProperties, int glyphCount, LsTFlow textFlow, Int32* piGlyphAdvances, GlyphOffset* piiGlyphOffsets);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, IntPtr* plsplsruns, Int32* pcchPlsrun, int plsrunCount, LsDevice device, Char* pwchText, UInt16* puClusterMap, UInt16* puCharProperties, int cchText, UInt16* puGlyphs, UInt32* piGlyphProperties, int glyphCount, LsTFlow textFlow, Int32* piGlyphAdvances, GlyphOffset* piiGlyphOffsets, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(IAsyncResult result);
}
internal class MS.Internal.TextFormatting.GetGlyphsRedefined : MulticastDelegate {
    public GetGlyphsRedefined(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, IntPtr* plsplsruns, Int32* pcchPlsrun, int plsrunCount, Char* pwchText, int cchText, LsTFlow textFlow, UInt16* puGlyphsBuffer, UInt32* piGlyphPropsBuffer, int cgiGlyphBuffers, Int32& fIsGlyphBuffersUsed, UInt16* puClusterMap, UInt16* puCharProperties, Int32* pfCanGlyphAlone, Int32& glyphCount);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, IntPtr* plsplsruns, Int32* pcchPlsrun, int plsrunCount, Char* pwchText, int cchText, LsTFlow textFlow, UInt16* puGlyphsBuffer, UInt32* piGlyphPropsBuffer, int cgiGlyphBuffers, Int32& fIsGlyphBuffersUsed, UInt16* puClusterMap, UInt16* puCharProperties, Int32* pfCanGlyphAlone, Int32& glyphCount, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(Int32& fIsGlyphBuffersUsed, Int32& glyphCount, IAsyncResult result);
}
internal class MS.Internal.TextFormatting.GetNextHyphenOpp : MulticastDelegate {
    public GetNextHyphenOpp(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, int lscpStartSearch, int lsdcpSearch, Int32& fHyphenFound, Int32& lscpHyphen, LsHyph& lsHyph);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, int lscpStartSearch, int lsdcpSearch, Int32& fHyphenFound, Int32& lscpHyphen, LsHyph& lsHyph, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(Int32& fHyphenFound, Int32& lscpHyphen, LsHyph& lsHyph, IAsyncResult result);
}
internal class MS.Internal.TextFormatting.GetObjectHandlerInfo : MulticastDelegate {
    public GetObjectHandlerInfo(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, UInt32 objectId, Void* objectInfo);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, UInt32 objectId, Void* objectInfo, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(IAsyncResult result);
}
internal class MS.Internal.TextFormatting.GetPrevHyphenOpp : MulticastDelegate {
    public GetPrevHyphenOpp(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, int lscpStartSearch, int lsdcpSearch, Int32& fHyphenFound, Int32& lscpHyphen, LsHyph& lsHyph);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, int lscpStartSearch, int lsdcpSearch, Int32& fHyphenFound, Int32& lscpHyphen, LsHyph& lsHyph, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(Int32& fHyphenFound, Int32& lscpHyphen, LsHyph& lsHyph, IAsyncResult result);
}
internal class MS.Internal.TextFormatting.GetRunCharWidths : MulticastDelegate {
    public GetRunCharWidths(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, Plsrun plsrun, LsDevice device, Char* runText, int cchRun, int maxWidth, LsTFlow textFlow, Int32* charWidths, Int32& totalWidth, Int32& cchProcessed);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, Plsrun plsrun, LsDevice device, Char* runText, int cchRun, int maxWidth, LsTFlow textFlow, Int32* charWidths, Int32& totalWidth, Int32& cchProcessed, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(Int32& totalWidth, Int32& cchProcessed, IAsyncResult result);
}
internal class MS.Internal.TextFormatting.GetRunStrikethroughInfo : MulticastDelegate {
    public GetRunStrikethroughInfo(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, Plsrun plsrun, LsHeights& lsHeights, LsTFlow textFlow, LsStInfo& stInfo);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, Plsrun plsrun, LsHeights& lsHeights, LsTFlow textFlow, LsStInfo& stInfo, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(LsHeights& lsHeights, LsStInfo& stInfo, IAsyncResult result);
}
internal class MS.Internal.TextFormatting.GetRunTextMetrics : MulticastDelegate {
    public GetRunTextMetrics(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, Plsrun plsrun, LsDevice lsDevice, LsTFlow lstFlow, LsTxM& lstTextMetrics);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, Plsrun plsrun, LsDevice lsDevice, LsTFlow lstFlow, LsTxM& lstTextMetrics, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(LsTxM& lstTextMetrics, IAsyncResult result);
}
internal class MS.Internal.TextFormatting.GetRunUnderlineInfo : MulticastDelegate {
    public GetRunUnderlineInfo(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, Plsrun plsrun, LsHeights& lsHeights, LsTFlow textFlow, LsULInfo& ulInfo);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, Plsrun plsrun, LsHeights& lsHeights, LsTFlow textFlow, LsULInfo& ulInfo, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(LsHeights& lsHeights, LsULInfo& ulInfo, IAsyncResult result);
}
internal class MS.Internal.TextFormatting.Hyphenate : MulticastDelegate {
    public Hyphenate(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, int fLastHyphenationFound, int lscpLastHyphenation, LsHyph& lastHyphenation, int lscpBeginWord, int lscpExceed, Int32& fHyphenFound, Int32& lscpHyphen, LsHyph& plsHyph);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, int fLastHyphenationFound, int lscpLastHyphenation, LsHyph& lastHyphenation, int lscpBeginWord, int lscpExceed, Int32& fHyphenFound, Int32& lscpHyphen, LsHyph& plsHyph, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(LsHyph& lastHyphenation, Int32& fHyphenFound, Int32& lscpHyphen, LsHyph& plsHyph, IAsyncResult result);
}
internal class MS.Internal.TextFormatting.InlineDraw : MulticastDelegate {
    public InlineDraw(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, Plsrun plsrun, LSPOINT& runOrigin, LsTFlow textFlow, int runWidth);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, Plsrun plsrun, LSPOINT& runOrigin, LsTFlow textFlow, int runWidth, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(LSPOINT& runOrigin, IAsyncResult result);
}
internal class MS.Internal.TextFormatting.InlineFormat : MulticastDelegate {
    public InlineFormat(object object, IntPtr method);
    public virtual LsErr Invoke(IntPtr pols, Plsrun plsrun, int lscpInline, int currentPosition, int rightMargin, ObjDim& pobjDim, Int32& fFirstRealOnLine, Int32& fPenPositionUsed, LsBrkCond& breakBefore, LsBrkCond& breakAfter);
    public virtual IAsyncResult BeginInvoke(IntPtr pols, Plsrun plsrun, int lscpInline, int currentPosition, int rightMargin, ObjDim& pobjDim, Int32& fFirstRealOnLine, Int32& fPenPositionUsed, LsBrkCond& breakBefore, LsBrkCond& breakAfter, AsyncCallback callback, object object);
    public virtual LsErr EndInvoke(ObjDim& pobjDim, Int32& fFirstRealOnLine, Int32& fPenPositionUsed, LsBrkCond& breakBefore, LsBrkCond& breakAfter, IAsyncResult result);
}
internal class MS.Internal.TextFormatting.InlineInit : ValueType {
    public UInt32 dwVersion;
    public InlineFormat pfnFormat;
    public InlineDraw pfnDraw;
}
internal interface MS.Internal.TextFormatting.IShapeableTextCollector {
    public abstract virtual void Add(IList`1<TextShapeableSymbols> shapeableList, CharacterBufferRange characterBufferRange, TextRunProperties textRunProperties, ItemProps textItem, ShapeTypeface shapeTypeface, double emScale, bool nullShape, TextFormattingMode textFormattingMode);
}
internal interface MS.Internal.TextFormatting.ITextMetrics {
    public int Length { get; }
    public int DependentLength { get; }
    public int NewlineLength { get; }
    public double Start { get; }
    public double Width { get; }
    public double WidthIncludingTrailingWhitespace { get; }
    public double Height { get; }
    public double MarkerHeight { get; }
    public double Baseline { get; }
    public double MarkerBaseline { get; }
    public abstract virtual int get_Length();
    public abstract virtual int get_DependentLength();
    public abstract virtual int get_NewlineLength();
    public abstract virtual double get_Start();
    public abstract virtual double get_Width();
    public abstract virtual double get_WidthIncludingTrailingWhitespace();
    public abstract virtual double get_Height();
    public abstract virtual double get_MarkerHeight();
    public abstract virtual double get_Baseline();
    public abstract virtual double get_MarkerBaseline();
}
internal interface MS.Internal.TextFormatting.ITextSymbols {
    public abstract virtual IList`1<TextShapeableSymbols> GetTextShapeableSymbols(GlyphingCache glyphingCache, CharacterBufferReference characterBufferReference, int characterLength, bool rightToLeft, bool isRightToLeftParagraph, CultureInfo digitCulture, TextModifierScope textModifierScope, TextFormattingMode textFormattingMode, bool isSideways);
}
internal class MS.Internal.TextFormatting.LexicalChunk : ValueType {
    private TextLexicalBreaks _breaks;
    private SpanVector`1<int> _ichVector;
    internal TextLexicalBreaks Breaks { get; }
    internal bool IsNoBreak { get; }
    internal LexicalChunk(TextLexicalBreaks breaks, SpanVector`1<int> ichVector);
    internal TextLexicalBreaks get_Breaks();
    internal bool get_IsNoBreak();
    internal int LSCPToCharacterIndex(int lsdcp);
    internal int CharacterIndexToLSCP(int ich);
}
[FlagsAttribute]
internal enum MS.Internal.TextFormatting.LineFlags : Enum {
    public int value__;
    public static LineFlags None;
    public static LineFlags BreakClassWide;
    public static LineFlags BreakClassStrict;
    public static LineFlags BreakAlways;
    public static LineFlags MinMax;
    public static LineFlags KeepState;
}
internal class MS.Internal.TextFormatting.LineServicesCallbacks : object {
    private FetchRunRedefined _pfnFetchRunRedefined;
    private FetchLineProps _pfnFetchLineProps;
    private FetchPap _pfnFetchPap;
    private GetRunTextMetrics _pfnGetRunTextMetrics;
    private GetRunCharWidths _pfnGetRunCharWidths;
    private GetDurMaxExpandRagged _pfnGetDurMaxExpandRagged;
    private GetAutoNumberInfo _pfnGetAutoNumberInfo;
    private DrawTextRun _pfnDrawTextRun;
    private GetGlyphsRedefined _pfnGetGlyphsRedefined;
    private GetGlyphPositions _pfnGetGlyphPositions;
    private DrawGlyphs _pfnDrawGlyphs;
    private GetObjectHandlerInfo _pfnGetObjectHandlerInfo;
    private GetRunUnderlineInfo _pfnGetRunUnderlineInfo;
    private GetRunStrikethroughInfo _pfnGetRunStrikethroughInfo;
    private Hyphenate _pfnHyphenate;
    private GetNextHyphenOpp _pfnGetNextHyphenOpp;
    private GetPrevHyphenOpp _pfnGetPrevHyphenOpp;
    private DrawUnderline _pfnDrawUnderline;
    private DrawStrikethrough _pfnDrawStrikethrough;
    private FInterruptShaping _pfnFInterruptShaping;
    private GetCharCompressionInfoFullMixed _pfnGetCharCompressionInfoFullMixed;
    private GetCharExpansionInfoFullMixed _pfnGetCharExpansionInfoFullMixed;
    private GetGlyphCompressionInfoFullMixed _pfnGetGlyphCompressionInfoFullMixed;
    private GetGlyphExpansionInfoFullMixed _pfnGetGlyphExpansionInfoFullMixed;
    private EnumText _pfnEnumText;
    private EnumTab _pfnEnumTab;
    private InlineFormat _pfnInlineFormat;
    private InlineDraw _pfnInlineDraw;
    private Exception _exception;
    private object _owner;
    private Rect _boundingBox;
    private ICollection`1<IndexedGlyphRun> _indexedGlyphRuns;
    internal InlineFormat InlineFormatDelegate { get; }
    internal InlineDraw InlineDrawDelegate { get; }
    internal Exception Exception { get; internal set; }
    internal object Owner { get; internal set; }
    private FullTextState FullText { get; }
    private DrawingState Draw { get; }
    internal Rect BoundingBox { get; }
    internal ICollection`1<IndexedGlyphRun> IndexedGlyphRuns { get; }
    internal LsErr FetchRunRedefined(IntPtr pols, int lscpFetch, int fIsStyle, IntPtr pstyle, Char* pwchTextBuffer, int cchTextBuffer, Int32& fIsBufferUsed, Char*& pwchText, Int32& cchText, Int32& fIsHidden, LsChp& lschp, IntPtr& lsplsrun);
    private void SetChpFormat(TextRunProperties runProp, LsChp& lschp);
    private void SetChpFormat(TextDecorationCollection textDecorations, LsChp& lschp);
    internal LsErr FetchPap(IntPtr pols, int lscpFetch, LsPap& lspap);
    internal LsErr FetchLineProps(IntPtr pols, int lscpFetch, int firstLineInPara, LsLineProps& lsLineProps);
    internal LsErr GetRunTextMetrics(IntPtr pols, Plsrun plsrun, LsDevice lsDevice, LsTFlow lstFlow, LsTxM& lstTextMetrics);
    internal LsErr GetRunCharWidths(IntPtr pols, Plsrun plsrun, LsDevice device, Char* charString, int stringLength, int maxWidth, LsTFlow textFlow, Int32* charWidths, Int32& totalWidth, Int32& stringLengthFitted);
    internal LsErr GetDurMaxExpandRagged(IntPtr pols, Plsrun plsrun, LsTFlow lstFlow, Int32& maxExpandRagged);
    internal LsErr GetAutoNumberInfo(IntPtr pols, LsKAlign& alignment, LsChp& lschp, IntPtr& lsplsrun, UInt16& addedChar, LsChp& lschpAddedChar, IntPtr& lsplsrunAddedChar, Int32& fWord95Model, Int32& offset, Int32& width);
    internal LsErr GetRunUnderlineInfo(IntPtr pols, Plsrun plsrun, LsHeights& lsHeights, LsTFlow textFlow, LsULInfo& ulInfo);
    internal LsErr GetRunStrikethroughInfo(IntPtr pols, Plsrun plsrun, LsHeights& lsHeights, LsTFlow textFlow, LsStInfo& stInfo);
    private void GetLSRunStrikethroughMetrics(LSRun lsrun, Double& strikeThroughPositionInEm, Double& strikeThroughThicknessInEm);
    internal LsErr Hyphenate(IntPtr pols, int fLastHyphenFound, int lscpLastHyphen, LsHyph& lastHyph, int lscpWordStart, int lscpExceed, Int32& fHyphenFound, Int32& lscpHyphen, LsHyph& lsHyph);
    internal LsErr GetNextHyphenOpp(IntPtr pols, int lscpStartSearch, int lsdcpSearch, Int32& fHyphenFound, Int32& lscpHyphen, LsHyph& lsHyph);
    internal LsErr GetPrevHyphenOpp(IntPtr pols, int lscpStartSearch, int lsdcpSearch, Int32& fHyphenFound, Int32& lscpHyphen, LsHyph& lsHyph);
    internal LsErr DrawStrikethrough(IntPtr pols, Plsrun plsrun, UInt32 stType, LSPOINT& ptOrigin, int stLength, int stThickness, LsTFlow textFlow, UInt32 displayMode, LSRECT& clipRect);
    internal LsErr DrawUnderline(IntPtr pols, Plsrun plsrun, UInt32 ulType, LSPOINT& ptOrigin, int ulLength, int ulThickness, LsTFlow textFlow, UInt32 displayMode, LSRECT& clipRect);
    private void DrawTextDecorations(LSRun lsrun, UInt32 locationMask, int left, int underlineTop, int overlineTop, int strikethroughTop, int baselineTop, int length, int thickness, LsTFlow textFlow);
    private void DrawTextDecorationCollection(LSRun lsrun, UInt32 locationMask, TextDecorationCollection textDecorations, Brush foregroundBrush, int left, int underlineTop, int overlineTop, int strikethroughTop, int baselineTop, int length, int thickness, LsTFlow textFlow);
    private Rect DrawTextDecoration(LSRun lsrun, Brush foregroundBrush, LSPOINT ptOrigin, int ulLength, int ulThickness, LsTFlow textFlow, TextDecoration textDecoration);
    internal LsErr DrawTextRun(IntPtr pols, Plsrun plsrun, LSPOINT& ptText, Char* pwchText, Int32* piCharAdvances, int cchText, LsTFlow textFlow, UInt32 displayMode, LSPOINT& ptRun, LsHeights& lsHeights, int dupRun, LSRECT& clipRect);
    internal LsErr FInterruptShaping(IntPtr pols, LsTFlow textFlow, Plsrun plsrunFirst, Plsrun plsrunSecond, Int32& fIsInterruptOk);
    internal static CultureInfo GetNumberCulture(TextRunProperties properties, NumberSubstitutionMethod& method);
    internal LsErr GetGlyphsRedefined(IntPtr pols, IntPtr* plsplsruns, Int32* pcchPlsrun, int plsrunCount, Char* pwchText, int cchText, LsTFlow textFlow, UInt16* puGlyphsBuffer, UInt32* piGlyphPropsBuffer, int cgiGlyphBuffers, Int32& fIsGlyphBuffersUsed, UInt16* puClusterMap, UInt16* puCharProperties, Int32* pfCanGlyphAlone, Int32& glyphCount);
    internal LsErr GetGlyphPositions(IntPtr pols, IntPtr* plsplsruns, Int32* pcchPlsrun, int plsrunCount, LsDevice device, Char* pwchText, UInt16* puClusterMap, UInt16* puCharProperties, int cchText, UInt16* puGlyphs, UInt32* piGlyphProperties, int glyphCount, LsTFlow textFlow, Int32* piGlyphAdvances, GlyphOffset* piiGlyphOffsets);
    private LSRun[] RemapLSRuns(IntPtr* plsplsruns, int plsrunCount);
    internal LsErr DrawGlyphs(IntPtr pols, Plsrun plsrun, Char* pwchText, UInt16* puClusterMap, UInt16* puCharProperties, int charCount, UInt16* puGlyphs, Int32* piJustifiedGlyphAdvances, Int32* piGlyphAdvances, GlyphOffset* piiGlyphOffsets, UInt32* piGlyphProperties, LsExpType* plsExpType, int glyphCount, LsTFlow textFlow, UInt32 displayMode, LSPOINT& ptRun, LsHeights& lsHeights, int runWidth, LSRECT& clippingRect);
    internal LsErr GetCharCompressionInfoFullMixed(IntPtr pols, LsDevice device, LsTFlow textFlow, LsCharRunInfo* plscharrunInfo, LsNeighborInfo* plsneighborInfoLeft, LsNeighborInfo* plsneighborInfoRight, int maxPriorityLevel, Int32** pplscompressionLeft, Int32** pplscompressionRight);
    internal LsErr GetCharExpansionInfoFullMixed(IntPtr pols, LsDevice device, LsTFlow textFlow, LsCharRunInfo* plscharrunInfo, LsNeighborInfo* plsneighborInfoLeft, LsNeighborInfo* plsneighborInfoRight, int maxPriorityLevel, Int32** pplsexpansionLeft, Int32** pplsexpansionRight);
    private LsErr AdjustChars(LsCharRunInfo* plscharrunInfo, bool expanding, int interWordAdjustTo, Int32** pplsAdjustLeft, Int32** pplsAdjustRight);
    internal LsErr GetGlyphCompressionInfoFullMixed(IntPtr pols, LsDevice device, LsTFlow textFlow, LsGlyphRunInfo* plsglyphrunInfo, LsNeighborInfo* plsneighborInfoLeft, LsNeighborInfo* plsneighborInfoRight, int maxPriorityLevel, Int32** pplscompressionLeft, Int32** pplscompressionRight);
    private LsErr CompressGlyphs(LsGlyphRunInfo* plsglyphrunInfo, int interWordCompressTo, Int32** pplsCompressionLeft, Int32** pplsCompressionRight);
    internal LsErr GetGlyphExpansionInfoFullMixed(IntPtr pols, LsDevice device, LsTFlow textFlow, LsGlyphRunInfo* plsglyphrunInfo, LsNeighborInfo* plsneighborInfoLeft, LsNeighborInfo* plsneighborInfoRight, int maxPriorityLevel, Int32** pplsexpansionLeft, Int32** pplsexpansionRight, LsExpType* plsexptype, Int32* pduMinInk);
    private LsErr ExpandGlyphs(LsGlyphRunInfo* plsglyphrunInfo, int interWordExpandTo, Int32** pplsExpansionLeft, Int32** pplsExpansionRight, LsExpType* plsexptype, LsExpType interWordExpansionType, LsExpType interLetterExpansionType);
    internal LsErr GetObjectHandlerInfo(IntPtr pols, UInt32 objectId, Void* objectInfo);
    internal LsErr InlineFormat(IntPtr pols, Plsrun plsrun, int lscpInline, int currentPosition, int rightMargin, ObjDim& pobjDim, Int32& fFirstRealOnLine, Int32& fPenPositionUsed, LsBrkCond& breakBefore, LsBrkCond& breakAfter);
    private LsBrkCond BreakConditionToLsBrkCond(LineBreakCondition breakCondition);
    internal LsErr InlineDraw(IntPtr pols, Plsrun plsrun, LSPOINT& ptRun, LsTFlow textFlow, int runWidth);
    internal LsErr EnumText(IntPtr pols, Plsrun plsrun, int cpFirst, int dcp, Char* pwchText, int cchText, LsTFlow lstFlow, int fReverseOrder, int fGeometryProvided, LSPOINT& pptStart, LsHeights& pheights, int dupRun, int glyphBaseRun, Int32* piCharAdvances, UInt16* puClusterMap, UInt16* characterProperties, UInt16* puGlyphs, Int32* piJustifiedGlyphAdvances, GlyphOffset* piiGlyphOffsets, UInt32* piGlyphProperties, int glyphCount);
    internal LsErr EnumTab(IntPtr pols, Plsrun plsrun, int cpFirst, Char* pwchText, char tabLeader, LsTFlow lstFlow, int fReverseOrder, int fGeometryProvided, LSPOINT& pptStart, LsHeights& heights, int dupRun);
    private bool IsSpace(char ch);
    private static int RealToIdeal(double i);
    private static double RoundDipForDisplayModeJustifiedText(double value, double pixelsPerDip);
    private static double IdealToRealWithNoRounding(double i);
    private void AdjustMetricsForDisplayModeJustifiedText(Char* pwchText, Int32* piGlyphAdvances, int glyphCount, bool isRightToLeft, int idealBaselineOriginX, int idealBaselineOriginY, double pixelsPerDip, Point& baselineOrigin, IList`1& adjustedAdvanceWidths);
    private GlyphRun ComputeShapedGlyphRun(LSRun lsrun, TextFormatterImp textFormatterImp, bool originProvided, LSPOINT lsrunOrigin, int charCount, Char* pwchText, UInt16* puClusterMap, int glyphCount, UInt16* puGlyphs, Int32* piJustifiedGlyphAdvances, GlyphOffset* piiGlyphOffsets, bool justify);
    private GlyphRun ComputeUnshapedGlyphRun(LSRun lsrun, LsTFlow textFlow, TextFormatterImp textFormatterImp, bool originProvided, LSPOINT lsrunOrigin, int dupRun, int cchText, Char* pwchText, Int32* piCharAdvances, bool justify);
    internal void PopulateContextInfo(LsContextInfo& contextInfo, LscbkRedefined& lscbkRedef);
    internal InlineFormat get_InlineFormatDelegate();
    internal InlineDraw get_InlineDrawDelegate();
    private void SaveException(Exception e, Plsrun plsrun, LSRun lsrun);
    private void SaveNonCLSException(string methodName, Plsrun plsrun, LSRun lsrun);
    internal Exception get_Exception();
    internal void set_Exception(Exception value);
    internal object get_Owner();
    internal void set_Owner(object value);
    private FullTextState get_FullText();
    private DrawingState get_Draw();
    internal void EmptyBoundingBox();
    internal Rect get_BoundingBox();
    internal void ClearIndexedGlyphRuns();
    internal ICollection`1<IndexedGlyphRun> get_IndexedGlyphRuns();
}
internal enum MS.Internal.TextFormatting.LsBreakJust : Enum {
    public int value__;
    public static LsBreakJust lsbrjBreakJustify;
    public static LsBreakJust lsbrjBreakWithCompJustify;
    public static LsBreakJust lsbrjBreakThenExpand;
    public static LsBreakJust lsbrjBreakOptimal;
    public static LsBreakJust lsbrjBreakThenSqueeze;
}
internal class MS.Internal.TextFormatting.LsBreakRecSubl : ValueType {
    public int lscpFetch;
    public int idobj;
    public IntPtr pbreakrecobj;
}
internal class MS.Internal.TextFormatting.LsBreaks : ValueType {
    public int cBreaks;
    public LsLInfo* plslinfoArray;
    public IntPtr* plinepenaltyArray;
    public IntPtr* pplolineArray;
}
internal enum MS.Internal.TextFormatting.LsBrkCond : Enum {
    public int value__;
    public static LsBrkCond Never;
    public static LsBrkCond Can;
    public static LsBrkCond Please;
    public static LsBrkCond Must;
}
internal class MS.Internal.TextFormatting.LscbkRedefined : ValueType {
    public FetchRunRedefined pfnFetchRunRedefined;
    public GetGlyphsRedefined pfnGetGlyphsRedefined;
    public FetchLineProps pfnFetchLineProps;
}
internal class MS.Internal.TextFormatting.LsCharRunInfo : ValueType {
    public Plsrun plsrun;
    public Char* pwch;
    public Int32* rgduNominalWidth;
    public Int32* rgduChangeLeft;
    public Int32* rgduChangeRight;
    public int cwch;
}
internal class MS.Internal.TextFormatting.LsChp : ValueType {
    public ushort idObj;
    public ushort dcpMaxContent;
    public UInt32 effectsFlags;
    public Flags flags;
    public int dvpPos;
}
internal class MS.Internal.TextFormatting.LsContextInfo : ValueType {
    public UInt32 version;
    public int cInstalledHandlers;
    public IntPtr plsimethods;
    public int cEstimatedCharsPerLine;
    public int cJustPriorityLim;
    public char wchUndef;
    public char wchNull;
    public char wchSpace;
    public char wchHyphen;
    public char wchTab;
    public char wchPosTab;
    public char wchEndPara1;
    public char wchEndPara2;
    public char wchAltEndPara;
    public char wchEndLineInPara;
    public char wchColumnBreak;
    public char wchSectionBreak;
    public char wchPageBreak;
    public char wchNonBreakSpace;
    public char wchNonBreakHyphen;
    public char wchNonReqHyphen;
    public char wchEmDash;
    public char wchEnDash;
    public char wchEmSpace;
    public char wchEnSpace;
    public char wchNarrowSpace;
    public char wchOptBreak;
    public char wchNoBreak;
    public char wchFESpace;
    public char wchJoiner;
    public char wchNonJoiner;
    public char wchToReplace;
    public char wchReplace;
    public char wchVisiNull;
    public char wchVisiAltEndPara;
    public char wchVisiEndLineInPara;
    public char wchVisiEndPara;
    public char wchVisiSpace;
    public char wchVisiNonBreakSpace;
    public char wchVisiNonBreakHyphen;
    public char wchVisiNonReqHyphen;
    public char wchVisiTab;
    public char wchVisiPosTab;
    public char wchVisiEmSpace;
    public char wchVisiEnSpace;
    public char wchVisiNarrowSpace;
    public char wchVisiOptBreak;
    public char wchVisiNoBreak;
    public char wchVisiFESpace;
    public char wchEscAnmRun;
    public char wchPad;
    public IntPtr pols;
    public IntPtr pfnNewPtr;
    public IntPtr pfnDisposePtr;
    public IntPtr pfnReallocPtr;
    public IntPtr pfnFetchRun;
    public GetAutoNumberInfo pfnGetAutoNumberInfo;
    public IntPtr pfnGetNumericSeparators;
    public IntPtr pfnCheckForDigit;
    public FetchPap pfnFetchPap;
    public FetchLineProps pfnFetchLineProps;
    public IntPtr pfnFetchTabs;
    public IntPtr pfnReleaseTabsBuffer;
    public IntPtr pfnGetBreakThroughTab;
    public IntPtr pfnGetPosTabProps;
    public IntPtr pfnFGetLastLineJustification;
    public IntPtr pfnCheckParaBoundaries;
    public GetRunCharWidths pfnGetRunCharWidths;
    public IntPtr pfnCheckRunKernability;
    public IntPtr pfnGetRunCharKerning;
    public GetRunTextMetrics pfnGetRunTextMetrics;
    public GetRunUnderlineInfo pfnGetRunUnderlineInfo;
    public GetRunStrikethroughInfo pfnGetRunStrikethroughInfo;
    public IntPtr pfnGetBorderInfo;
    public IntPtr pfnReleaseRun;
    public IntPtr pfnReleaseRunBuffer;
    public Hyphenate pfnHyphenate;
    public GetPrevHyphenOpp pfnGetPrevHyphenOpp;
    public GetNextHyphenOpp pfnGetNextHyphenOpp;
    public IntPtr pfnGetHyphenInfo;
    public DrawUnderline pfnDrawUnderline;
    public DrawStrikethrough pfnDrawStrikethrough;
    public IntPtr pfnDrawBorder;
    public IntPtr pfnFInterruptUnderline;
    public IntPtr pfnFInterruptShade;
    public IntPtr pfnFInterruptBorder;
    public IntPtr pfnShadeRectangle;
    public DrawTextRun pfnDrawTextRun;
    public IntPtr pfnDrawSplatLine;
    public FInterruptShaping pfnFInterruptShaping;
    public IntPtr pfnGetGlyphs;
    public GetGlyphPositions pfnGetGlyphPositions;
    public DrawGlyphs pfnDrawGlyphs;
    public IntPtr pfnReleaseGlyphBuffers;
    public IntPtr pfnGetGlyphExpansionInfo;
    public IntPtr pfnGetGlyphExpansionInkInfo;
    public IntPtr pfnGetGlyphRunInk;
    public IntPtr pfnGetEms;
    public IntPtr pfnPunctStartLine;
    public IntPtr pfnModWidthOnRun;
    public IntPtr pfnModWidthSpace;
    public IntPtr pfnCompOnRun;
    public IntPtr pfnCompWidthSpace;
    public IntPtr pfnExpOnRun;
    public IntPtr pfnExpWidthSpace;
    public IntPtr pfnGetModWidthClasses;
    public IntPtr pfnGetBreakingClasses;
    public IntPtr pfnFTruncateBefore;
    public IntPtr pfnCanBreakBeforeChar;
    public IntPtr pfnCanBreakAfterChar;
    public IntPtr pfnFHangingPunct;
    public IntPtr pfnGetSnapGrid;
    public IntPtr pfnDrawEffects;
    public IntPtr pfnFCancelHangingPunct;
    public IntPtr pfnModifyCompAtLastChar;
    public GetDurMaxExpandRagged pfnGetDurMaxExpandRagged;
    public GetCharExpansionInfoFullMixed pfnGetCharExpansionInfoFullMixed;
    public GetGlyphExpansionInfoFullMixed pfnGetGlyphExpansionInfoFullMixed;
    public GetCharCompressionInfoFullMixed pfnGetCharCompressionInfoFullMixed;
    public GetGlyphCompressionInfoFullMixed pfnGetGlyphCompressionInfoFullMixed;
    public IntPtr pfnGetCharAlignmentStartLine;
    public IntPtr pfnGetCharAlignmentEndLine;
    public IntPtr pfnGetGlyphAlignmentStartLine;
    public IntPtr pfnGetGlyphAlignmentEndLine;
    public IntPtr pfnGetPriorityForGoodTypography;
    public EnumText pfnEnumText;
    public EnumTab pfnEnumTab;
    public IntPtr pfnEnumPen;
    public GetObjectHandlerInfo pfnGetObjectHandlerInfo;
    public IntPtr pfnAssertFailedPtr;
    public int fDontReleaseRuns;
}
internal enum MS.Internal.TextFormatting.LsDevice : Enum {
    public int value__;
    public static LsDevice Presentation;
    public static LsDevice Reference;
}
internal class MS.Internal.TextFormatting.LsDevRes : ValueType {
    public UInt32 dxpInch;
    public UInt32 dypInch;
    public UInt32 dxrInch;
    public UInt32 dyrInch;
}
internal enum MS.Internal.TextFormatting.LsEndRes : Enum {
    public int value__;
    public static LsEndRes endrNormal;
    public static LsEndRes endrHyphenated;
    public static LsEndRes endrEndPara;
    public static LsEndRes endrAltPara;
    public static LsEndRes endrSoftCR;
    public static LsEndRes endrEndColumn;
    public static LsEndRes endrEndSection;
    public static LsEndRes endrEndPage;
    public static LsEndRes endrEndParaSection;
    public static LsEndRes endrStopped;
    public static LsEndRes endrBeforeFillLineObject;
    public static LsEndRes endrAfterFillLineObject;
    public static LsEndRes endrMathUserRequiredBreak;
}
internal enum MS.Internal.TextFormatting.LsErr : Enum {
    public int value__;
    public static LsErr None;
    public static LsErr InvalidParameter;
    public static LsErr OutOfMemory;
    public static LsErr NullOutputParameter;
    public static LsErr InvalidContext;
    public static LsErr InvalidLine;
    public static LsErr InvalidDnode;
    public static LsErr InvalidDeviceResolution;
    public static LsErr InvalidRun;
    public static LsErr MismatchLineContext;
    public static LsErr ContextInUse;
    public static LsErr DuplicateSpecialCharacter;
    public static LsErr InvalidAutonumRun;
    public static LsErr FormattingFunctionDisabled;
    public static LsErr UnfinishedDnode;
    public static LsErr InvalidDnodeType;
    public static LsErr InvalidPenDnode;
    public static LsErr InvalidNonPenDnode;
    public static LsErr InvalidBaselinePenDnode;
    public static LsErr InvalidFormatterResult;
    public static LsErr InvalidObjectIdFetched;
    public static LsErr InvalidDcpFetched;
    public static LsErr InvalidCpContentFetched;
    public static LsErr InvalidBookmarkType;
    public static LsErr SetDocDisabled;
    public static LsErr FiniFunctionDisabled;
    public static LsErr CurrentDnodeIsNotTab;
    public static LsErr PendingTabIsNotResolved;
    public static LsErr WrongFiniFunction;
    public static LsErr InvalidBreakingClass;
    public static LsErr BreakingTableNotSet;
    public static LsErr InvalidModWidthClass;
    public static LsErr ModWidthPairsNotSet;
    public static LsErr WrongTruncationPoint;
    public static LsErr WrongBreak;
    public static LsErr DupInvalid;
    public static LsErr RubyInvalidVersion;
    public static LsErr TatenakayokoInvalidVersion;
    public static LsErr WarichuInvalidVersion;
    public static LsErr WarichuInvalidData;
    public static LsErr CreateSublineDisabled;
    public static LsErr CurrentSublineDoesNotExist;
    public static LsErr CpOutsideSubline;
    public static LsErr HihInvalidVersion;
    public static LsErr InsufficientQueryDepth;
    public static LsErr InvalidBreakRecord;
    public static LsErr InvalidPap;
    public static LsErr ContradictoryQueryInput;
    public static LsErr LineIsNotActive;
    public static LsErr TooLongParagraph;
    public static LsErr TooManyCharsToGlyph;
    public static LsErr WrongHyphenationPosition;
    public static LsErr TooManyPriorities;
    public static LsErr WrongGivenCp;
    public static LsErr WrongCpFirstForGetBreaks;
    public static LsErr WrongJustTypeForGetBreaks;
    public static LsErr WrongJustTypeForCreateLineGivenCp;
    public static LsErr TooLongGlyphContext;
    public static LsErr InvalidCharToGlyphMapping;
    public static LsErr InvalidMathUsage;
    public static LsErr InconsistentChp;
    public static LsErr StoppedInSubline;
    public static LsErr PenPositionCouldNotBeUsed;
    public static LsErr DebugFlagsInShip;
    public static LsErr InvalidOrderTabs;
    public static LsErr OutputArrayTooSmall;
    public static LsErr SystemRestrictionsExceeded;
    public static LsErr LsInternalError;
    public static LsErr NotImplemented;
    public static LsErr ClientAbort;
}
internal enum MS.Internal.TextFormatting.LsExpType : Enum {
    public byte value__;
    public static LsExpType None;
    public static LsExpType AddWhiteSpace;
    public static LsExpType AddInkContinuous;
    public static LsExpType AddInkDiscrete;
}
internal class MS.Internal.TextFormatting.LsGlyphRunInfo : ValueType {
    public Plsrun plsrun;
    public Char* pwch;
    public UInt16* rggmap;
    public UInt16* rgchprop;
    public int cwch;
    public int duChangeRight;
    public UInt16* rggindex;
    public UInt32* rggprop;
    public Int32* rgduWidth;
    public GlyphOffset* rggoffset;
    public int cgindex;
}
internal class MS.Internal.TextFormatting.LsHeights : ValueType {
    public int dvAscent;
    public int dvDescent;
    public int dvMultiLineHeight;
}
internal class MS.Internal.TextFormatting.LsHyph : ValueType {
    public LsKysr kysr;
    public char wchYsr;
    public char wchYsr2;
    public LsHyphenQuality lshq;
}
internal enum MS.Internal.TextFormatting.LsHyphenQuality : Enum {
    public int value__;
    public static LsHyphenQuality lshqExcellent;
    public static LsHyphenQuality lshqGood;
    public static LsHyphenQuality lshqFair;
    public static LsHyphenQuality lshqPoor;
    public static LsHyphenQuality lshqBad;
}
internal class MS.Internal.TextFormatting.LsIMethods : ValueType {
    public IntPtr pfnCreateILSObj;
    public IntPtr pfnDestroyILSObj;
    public IntPtr pfnSetDoc;
    public IntPtr pfnCreateLNObj;
    public IntPtr pfnDestroyLNObj;
    public IntPtr pfnFmt;
    public IntPtr pfnFmtResume;
    public IntPtr pfnGetModWidthPrecedingChar;
    public IntPtr pfnGetModWidthFollowingChar;
    public IntPtr pfnTruncate;
    public IntPtr pfnFindPrevBreakOppInside;
    public IntPtr pfnFindNextBreakOppInside;
    public IntPtr pfnFindBreakOppBeforeCpTruncate;
    public IntPtr pfnFindBreakOppAfterCpTruncate;
    public IntPtr pfnCreateStartOppInside;
    public IntPtr pfnProposeBreakAfter;
    public IntPtr pfnProposeBreakBefore;
    public IntPtr pfnCreateBreakOppAfter;
    public IntPtr pfnCreateStartOppBefore;
    public IntPtr pfnCreateDobjFragment;
    public IntPtr pfnForceBreak;
    public IntPtr pfnCreateBreakRecord;
    public IntPtr pfnSetBreak;
    public IntPtr pfnDestroyStartOpp;
    public IntPtr pfnDestroyBreakOpp;
    public IntPtr pfnDuplicateBreakRecord;
    public IntPtr pfnDestroyBreakRecord;
    public IntPtr pfnGetSpecialEffectsFromDobj;
    public IntPtr pfnGetSpecialEffectsFromDobjFragment;
    public IntPtr pfnGetSubmissionInfoFromDobj;
    public IntPtr pfnGetSublinesFromDobj;
    public IntPtr pfnGetSubmissionInfoFromDobjFragment;
    public IntPtr pfnGetSubsFromDobjFragment;
    public IntPtr pfnFExpandWithPrecedingChar;
    public IntPtr pfnFExpandWithFollowingChar;
    public IntPtr pfnCalcPresentation;
    public IntPtr pfnQueryPointPcp;
    public IntPtr pfnQueryCpPpoint;
    public IntPtr pfnEnum;
    public IntPtr pfnDisplay;
    public IntPtr pfnDestroyDobj;
    public IntPtr pfnDestroyDobjFragment;
}
internal enum MS.Internal.TextFormatting.LsKAlign : Enum {
    public int value__;
    public static LsKAlign lskalLeft;
    public static LsKAlign lskalCentered;
    public static LsKAlign lskalRight;
}
internal enum MS.Internal.TextFormatting.LsKEOP : Enum {
    public int value__;
    public static LsKEOP lskeopEndPara1;
    public static LsKEOP lskeopEndPara2;
    public static LsKEOP lskeopEndPara12;
    public static LsKEOP lskeopEndParaAlt;
}
internal enum MS.Internal.TextFormatting.LsKJust : Enum {
    public int value__;
    public static LsKJust lskjFullInterWord;
    public static LsKJust lskjFullInterLetterAligned;
    public static LsKJust lskjFullScaled;
    public static LsKJust lskjFullGlyphs;
    public static LsKJust lskjFullMixed;
    public static LsKJust lskjSnapGrid;
}
internal enum MS.Internal.TextFormatting.LsKTab : Enum {
    public int value__;
    public static LsKTab lsktLeft;
    public static LsKTab lsktCenter;
    public static LsKTab lsktRight;
    public static LsKTab lsktDecimal;
    public static LsKTab lsktChar;
}
internal enum MS.Internal.TextFormatting.LsKysr : Enum {
    public int value__;
    public static LsKysr kysrNormal;
    public static LsKysr kysrAddBefore;
    public static LsKysr kysrChangeBefore;
    public static LsKysr kysrDeleteBefore;
    public static LsKysr kysrChangeAfter;
    public static LsKysr kysrDelAndChange;
    public static LsKysr kysrAddBeforeChangeAfter;
}
internal class MS.Internal.TextFormatting.LsLineProps : ValueType {
    public LsKAlign lskal;
    public int durLeft;
    public int durRightBreak;
    public int durRightJustify;
    public int fProhibitHyphenation;
    public int durHyphenationZone;
}
internal class MS.Internal.TextFormatting.LsLineWidths : ValueType {
    public int upStartMarker;
    public int upLimMarker;
    public int upStartMainText;
    public int upStartTrailing;
    public int upLimLine;
    public int upMinStartTrailing;
    public int upMinLimLine;
}
internal class MS.Internal.TextFormatting.LsLInfo : ValueType {
    public int dvpAscent;
    public int dvrAscent;
    public int dvpDescent;
    public int dvrDescent;
    public int dvpMultiLineHeight;
    public int dvrMultiLineHeight;
    public int dvpAscentAutoNumber;
    public int dvrAscentAutoNumber;
    public int dvpDescentAutoNumber;
    public int dvrDescentAutoNumber;
    public int cpLimToContinue;
    public int cpLimToStay;
    public int dcpDepend;
    public int cpFirstVis;
    public LsEndRes endr;
    public int fAdvanced;
    public int vaAdvance;
    public int fFirstLineInPara;
    public int fTabInMarginExLine;
    public int fForcedBreak;
    public UInt32 EffectsFlags;
}
internal class MS.Internal.TextFormatting.LsNeighborInfo : ValueType {
    public UInt32 fNeighborIsPresent;
    public UInt32 fNeighborIsText;
    public Plsrun plsrun;
    public char wch;
    public UInt32 fGlyphBased;
    public ushort chprop;
    public ushort gindex;
    public UInt32 gprop;
}
internal class MS.Internal.TextFormatting.LsPap : ValueType {
    public int cpFirst;
    public int cpFirstContent;
    public Flags grpf;
    public LsBreakJust lsbrj;
    public LsKJust lskj;
    public int fJustify;
    public int durAutoDecimalTab;
    public LsKEOP lskeop;
    public LsTFlow lstflow;
}
internal class MS.Internal.TextFormatting.LSPOINT : ValueType {
    public int x;
    public int y;
    public LSPOINT(int horizontalPosition, int verticalPosition);
}
internal class MS.Internal.TextFormatting.LsQSubInfo : ValueType {
    public LsTFlow lstflowSubLine;
    public int lscpFirstSubLine;
    public int lsdcpSubLine;
    public LSPOINT pointUvStartSubLine;
    public LsHeights lsHeightsPresSubLine;
    public int dupSubLine;
    public UInt32 idobj;
    public IntPtr plsrun;
    public int lscpFirstRun;
    public int lsdcpRun;
    public LSPOINT pointUvStartRun;
    public LsHeights lsHeightsPresRun;
    public int dupRun;
    public int dvpPosRun;
    public int dupBorderBefore;
    public int dupBorderAfter;
    public LSPOINT pointUvStartObj;
    public LsHeights lsHeightsPresObj;
    public int dupObj;
}
internal class MS.Internal.TextFormatting.LSRECT : ValueType {
    public int left;
    public int top;
    public int right;
    public int bottom;
    internal LSRECT(int x1, int y1, int x2, int y2);
}
internal class MS.Internal.TextFormatting.LSRun : object {
    private TextRunInfo _runInfo;
    private Plsrun _type;
    private int _offsetToFirstCp;
    private int _textRunLength;
    private CharacterBufferRange _charBufferRange;
    private int _baselineOffset;
    private int _height;
    private int _baselineMoveOffset;
    private int _emSize;
    private TextShapeableSymbols _shapeable;
    private ushort _charFlags;
    private byte _bidiLevel;
    private IList`1<TextEffect> _textEffects;
    private static ushort FeatureNotEnabled;
    internal bool IsHitTestable { get; }
    internal bool IsVisible { get; }
    internal bool IsNewline { get; }
    internal bool NeedsCaretInfo { get; }
    internal bool HasExtendedCharacter { get; }
    internal byte BidiLevel { get; }
    internal bool IsSymbol { get; }
    internal int OffsetToFirstCp { get; }
    internal int Length { get; }
    internal TextModifierScope TextModifierScope { get; }
    internal Plsrun Type { get; }
    internal ushort CharacterAttributeFlags { get; }
    internal CharacterBuffer CharacterBuffer { get; }
    internal int StringLength { get; }
    internal int OffsetToFirstChar { get; }
    internal TextRun TextRun { get; }
    internal TextShapeableSymbols Shapeable { get; }
    internal int BaselineOffset { get; internal set; }
    internal int Height { get; internal set; }
    internal int Descent { get; }
    internal TextRunProperties RunProp { get; }
    internal CultureInfo TextCulture { get; }
    internal int EmSize { get; }
    internal int BaselineMoveOffset { get; }
    internal LSRun(TextRunInfo runInfo, IList`1<TextEffect> textEffects, Plsrun type, int offsetToFirstCp, int textRunLength, int emSize, ushort charFlags, CharacterBufferRange charBufferRange, TextShapeableSymbols shapeable, double realToIdeal, byte bidiLevel);
    private LSRun(TextRunInfo runInfo, IList`1<TextEffect> textEffects, Plsrun type, int offsetToFirstCp, int textRunLength, int emSize, ushort charFlags, CharacterBufferRange charBufferRange, int baselineOffset, int height, TextShapeableSymbols shapeable, byte bidiLevel);
    internal LSRun(Plsrun type, IntPtr controlChar);
    internal LSRun(TextRunInfo runInfo, Plsrun type, IntPtr controlChar, int textRunLength, int offsetToFirstCp, byte bidiLevel);
    internal void Truncate(int newLength);
    internal bool get_IsHitTestable();
    internal bool get_IsVisible();
    internal bool get_IsNewline();
    internal bool get_NeedsCaretInfo();
    internal bool get_HasExtendedCharacter();
    internal Rect DrawGlyphRun(DrawingContext drawingContext, Brush foregroundBrush, GlyphRun glyphRun);
    internal static Point UVToXY(Point origin, Point vectorToOrigin, double u, double v, FullTextLine line);
    internal static Point UVToXY(Point origin, Point vectorToOrigin, int u, int v, FullTextLine line);
    internal static void UVToNominalXY(Point origin, Point vectorToOrigin, int u, int v, FullTextLine line, Int32& nominalX, Int32& nominalY);
    internal static Rect RectUV(Point origin, LSPOINT topLeft, LSPOINT bottomRight, FullTextLine line);
    internal void Move(int baselineMoveOffset);
    internal byte get_BidiLevel();
    internal bool get_IsSymbol();
    internal int get_OffsetToFirstCp();
    internal int get_Length();
    internal TextModifierScope get_TextModifierScope();
    internal Plsrun get_Type();
    internal ushort get_CharacterAttributeFlags();
    internal CharacterBuffer get_CharacterBuffer();
    internal int get_StringLength();
    internal int get_OffsetToFirstChar();
    internal TextRun get_TextRun();
    internal TextShapeableSymbols get_Shapeable();
    internal int get_BaselineOffset();
    internal void set_BaselineOffset(int value);
    internal int get_Height();
    internal void set_Height(int value);
    internal int get_Descent();
    internal TextRunProperties get_RunProp();
    internal CultureInfo get_TextCulture();
    internal int get_EmSize();
    internal int get_BaselineMoveOffset();
    private static DWriteFontFeature[] CreateDWriteFontFeatures(TextRunTypographyProperties textRunTypographyProperties);
    internal static void CompileFeatureSet(LSRun[] lsruns, Int32* pcchRuns, UInt32 totalLength, DWriteFontFeature[][]& fontFeatures, UInt32[]& fontFeatureRanges);
    internal static void CompileFeatureSet(TextRunTypographyProperties textRunTypographyProperties, UInt32 totalLength, DWriteFontFeature[][]& fontFeatures, UInt32[]& fontFeatureRanges);
}
internal class MS.Internal.TextFormatting.LSSIZE : ValueType {
    public int width;
    public int height;
}
internal class MS.Internal.TextFormatting.LsStInfo : ValueType {
    public UInt32 kstBase;
    public int cNumberOfLines;
    public int dvpLowerStrikethroughOffset;
    public int dvpLowerStrikethroughSize;
    public int dvpUpperStrikethroughOffset;
    public int dvpUpperStrikethroughSize;
}
internal class MS.Internal.TextFormatting.LsTabs : ValueType {
    public int durIncrementalTab;
    public int iTabUserDefMac;
    public IntPtr plsTbd;
}
internal class MS.Internal.TextFormatting.LsTbd : ValueType {
    public LsKTab lskt;
    public int ur;
    public char wchTabLeader;
    public char wchCharTab;
}
internal class MS.Internal.TextFormatting.LsTextCell : ValueType {
    public int lscpStartCell;
    public int lscpEndCell;
    public LSPOINT pointUvStartCell;
    public int dupCell;
    public int cCharsInCell;
    public int cGlyphsInCell;
    public IntPtr plsCellDetails;
}
internal enum MS.Internal.TextFormatting.LsTFlow : Enum {
    public int value__;
    public static LsTFlow lstflowDefault;
    public static LsTFlow lstflowES;
    public static LsTFlow lstflowEN;
    public static LsTFlow lstflowSE;
    public static LsTFlow lstflowSW;
    public static LsTFlow lstflowWS;
    public static LsTFlow lstflowWN;
    public static LsTFlow lstflowNE;
    public static LsTFlow lstflowNW;
}
internal class MS.Internal.TextFormatting.LsTxM : ValueType {
    public int dvAscent;
    public int dvDescent;
    public int dvMultiLineHeight;
    public int fMonospaced;
}
internal class MS.Internal.TextFormatting.LsULInfo : ValueType {
    public UInt32 kulBase;
    public int cNumberOfLines;
    public int dvpUnderlineOriginOffset;
    public int dvpFirstUnderlineOffset;
    public int dvpFirstUnderlineSize;
    public int dvpGapBetweenLines;
    public int dvpSecondUnderlineSize;
}
internal class MS.Internal.TextFormatting.ObjDim : ValueType {
    public LsHeights heightsRef;
    public LsHeights heightsPres;
    public int dur;
}
internal class MS.Internal.TextFormatting.ParaProp : object {
    private StatusFlags _statusFlags;
    private TextParagraphProperties _paragraphProperties;
    private int _emSize;
    private int _indent;
    private int _paragraphIndent;
    private int _height;
    internal bool RightToLeft { get; }
    internal bool OptimalBreak { get; }
    internal bool FirstLineInParagraph { get; }
    internal bool AlwaysCollapsible { get; }
    internal int Indent { get; }
    internal int ParagraphIndent { get; }
    internal double DefaultIncrementalTab { get; }
    internal IList`1<TextTabProperties> Tabs { get; }
    internal TextAlignment Align { get; }
    internal bool Justify { get; }
    internal bool EmergencyWrap { get; }
    internal bool Wrap { get; }
    internal Typeface DefaultTypeface { get; }
    internal int EmSize { get; }
    internal int LineHeight { get; }
    internal TextMarkerProperties TextMarkerProperties { get; }
    internal TextLexicalService Hyphenator { get; }
    internal TextDecorationCollection TextDecorations { get; }
    internal Brush DefaultTextDecorationsBrush { get; }
    internal ParaProp(TextFormatterImp formatter, TextParagraphProperties paragraphProperties, bool optimalBreak);
    internal bool get_RightToLeft();
    internal bool get_OptimalBreak();
    internal bool get_FirstLineInParagraph();
    internal bool get_AlwaysCollapsible();
    internal int get_Indent();
    internal int get_ParagraphIndent();
    internal double get_DefaultIncrementalTab();
    internal IList`1<TextTabProperties> get_Tabs();
    internal TextAlignment get_Align();
    internal bool get_Justify();
    internal bool get_EmergencyWrap();
    internal bool get_Wrap();
    internal Typeface get_DefaultTypeface();
    internal int get_EmSize();
    internal int get_LineHeight();
    internal TextMarkerProperties get_TextMarkerProperties();
    internal TextLexicalService get_Hyphenator();
    internal TextDecorationCollection get_TextDecorations();
    internal Brush get_DefaultTextDecorationsBrush();
}
internal enum MS.Internal.TextFormatting.Plsrun : Enum {
    public UInt32 value__;
    public static Plsrun CloseAnchor;
    public static Plsrun Reverse;
    public static Plsrun FakeLineBreak;
    public static Plsrun FormatAnchor;
    public static Plsrun Hidden;
    public static Plsrun Text;
    public static Plsrun InlineObject;
    public static Plsrun LineBreak;
    public static Plsrun ParaBreak;
    public static Plsrun Undefined;
    public static Plsrun IsMarker;
    public static Plsrun UseNewCharacterBuffer;
    public static Plsrun IsSymbol;
    public static Plsrun UnmaskAll;
}
internal class MS.Internal.TextFormatting.SimpleRun : object {
    public CharacterBufferReference CharBufferReference;
    public int Length;
    public Int32[] NominalAdvances;
    public int IdealWidth;
    public TextRun TextRun;
    public TextDecoration Underline;
    public Flags RunFlags;
    private TextFormatterImp _textFormatterImp;
    private double _pixelsPerDip;
    internal bool EOT { get; }
    internal bool Ghost { get; }
    internal bool Tab { get; }
    internal bool TrimTrailingUnderline { get; internal set; }
    internal double Baseline { get; }
    internal double Height { get; }
    internal Typeface Typeface { get; }
    internal double EmSize { get; }
    internal bool IsVisible { get; }
    internal SimpleRun(TextFormatterImp textFormatterImp, double pixelsPerDip);
    private SimpleRun(int length, TextRun textRun, Flags flags, TextFormatterImp textFormatterImp, double pixelsPerDip);
    internal bool get_EOT();
    internal bool get_Ghost();
    internal bool get_Tab();
    internal bool get_TrimTrailingUnderline();
    internal void set_TrimTrailingUnderline(bool value);
    internal double get_Baseline();
    internal double get_Height();
    internal Typeface get_Typeface();
    internal double get_EmSize();
    internal bool get_IsVisible();
    public static SimpleRun Create(FormatSettings settings, int cp, int cpFirst, int widthLeft, int widthMax, int idealRunOffsetUnRounded, double pixelsPerDip);
    public static SimpleRun Create(FormatSettings settings, CharacterBufferRange charString, TextRun textRun, int cp, int cpFirst, int runLength, int widthLeft, int idealRunOffsetUnRounded, double pixelsPerDip);
    private static SimpleRun CreateSimpleRunForTab(FormatSettings settings, TextRun textRun, int idealRunOffsetUnRounded, double pixelsPerDip);
    private static bool CanProcessTabsInSimpleShapingPath(ParaProp textParagraphProperties, TextFormattingMode textFormattingMode);
    internal static SimpleRun CreateSimpleTextRun(CharacterBufferRange charBufferRange, TextRun textRun, TextFormatterImp formatter, int widthLeft, bool emergencyWrap, bool breakOnTabs, double pixelsPerDip);
    internal Rect Draw(DrawingContext drawingContext, double x, double y, bool visiCodePath);
    internal bool CollectTrailingSpaces(TextFormatterImp formatter, Int32& trailing, Int32& trailingSpaceWidth);
    private static bool IsSpace(char ch);
    internal bool IsUnderlineCompatible(SimpleRun nextRun);
    internal int DistanceFromDcp(int dcp);
    internal CharacterHit DcpFromDistance(int idealDistance);
}
internal class MS.Internal.TextFormatting.SimpleTextLine : TextLine {
    private SimpleRun[] _runs;
    private int _cpFirst;
    private int _cpLength;
    private int _cpLengthEOT;
    private double _widthAtTrailing;
    private double _width;
    private double _paragraphWidth;
    private double _height;
    private double _offset;
    private int _idealOffsetUnRounded;
    private double _baselineOffset;
    private int _trailing;
    private Rect _boundingBox;
    private StatusFlags _statusFlags;
    private FormatSettings _settings;
    public int Length { get; }
    public int TrailingWhitespaceLength { get; }
    public int DependentLength { get; }
    public int NewlineLength { get; }
    public double Start { get; }
    public double Width { get; }
    public double WidthIncludingTrailingWhitespace { get; }
    public double Height { get; }
    public double TextHeight { get; }
    public double Extent { get; }
    public double Baseline { get; }
    public double TextBaseline { get; }
    public double MarkerBaseline { get; }
    public double MarkerHeight { get; }
    public double OverhangLeading { get; }
    public double OverhangTrailing { get; }
    public double OverhangAfter { get; }
    public bool HasOverflowed { get; }
    public bool HasCollapsed { get; }
    public SimpleTextLine(FormatSettings settings, int cpFirst, int paragraphWidth, ArrayList runs, Int32& trailing, Int32& trailingSpaceWidth, double pixelsPerDip);
    public static TextLine Create(FormatSettings settings, int cpFirst, int paragraphWidth, double pixelsPerDip);
    public virtual void Dispose();
    private static void CollectTrailingSpaces(ArrayList runs, TextFormatterImp formatter, Int32& trailing, Int32& trailingSpaceWidth);
    private static void AddRun(ArrayList runs, SimpleRun run, Int32& nonHiddenLength);
    private double DistanceFromCp(int currentIndex);
    public virtual void Draw(DrawingContext drawingContext, Point origin, InvertAxes inversion);
    public virtual TextLine Collapse(TextCollapsingProperties[] collapsingPropertiesList);
    private void CheckBoundingBox();
    private void DrawTextLine(DrawingContext drawingContext, Point origin);
    public virtual CharacterHit GetCharacterHitFromDistance(double distance);
    public virtual double GetDistanceFromCharacterHit(CharacterHit characterHit);
    public virtual CharacterHit GetNextCaretCharacterHit(CharacterHit characterHit);
    public virtual CharacterHit GetPreviousCaretCharacterHit(CharacterHit characterHit);
    public virtual CharacterHit GetBackspaceCaretCharacterHit(CharacterHit characterHit);
    public virtual IList`1<TextBounds> GetTextBounds(int firstTextSourceCharacterIndex, int textLength);
    public virtual IList`1<TextSpan`1<TextRun>> GetTextRunSpans();
    public virtual IEnumerable`1<IndexedGlyphRun> GetIndexedGlyphRuns();
    public virtual TextLineBreak GetTextLineBreak();
    public virtual IList`1<TextCollapsedRange> GetTextCollapsedRanges();
    public virtual int get_Length();
    public virtual int get_TrailingWhitespaceLength();
    public virtual int get_DependentLength();
    public virtual int get_NewlineLength();
    public virtual double get_Start();
    public virtual double get_Width();
    public virtual double get_WidthIncludingTrailingWhitespace();
    public virtual double get_Height();
    public virtual double get_TextHeight();
    public virtual double get_Extent();
    public virtual double get_Baseline();
    public virtual double get_TextBaseline();
    public virtual double get_MarkerBaseline();
    public virtual double get_MarkerHeight();
    public virtual double get_OverhangLeading();
    public virtual double get_OverhangTrailing();
    public virtual double get_OverhangAfter();
    public virtual bool get_HasOverflowed();
    public virtual bool get_HasCollapsed();
    private bool FindNextVisibleCp(int cp, Int32& cpVisible);
    private bool FindPreviousVisibleCp(int cp, Int32& cpVisible);
    private void GetRunIndexAtCp(int cp, Int32& runIndex, Int32& cpRunStart);
}
internal class MS.Internal.TextFormatting.TextFormatterImp : TextFormatter {
    private FrugalStructList`1<TextFormatterContext> _contextList;
    private bool _multipleContextProhibited;
    private GlyphingCache _glyphingCache;
    private TextFormattingMode _textFormattingMode;
    private TextAnalyzer _textAnalyzer;
    private static int MaxGlyphingCacheCapacity;
    internal TextFormattingMode TextFormattingMode { get; }
    internal static double ToIdeal { get; }
    internal GlyphingCache GlyphingCache { get; }
    internal TextAnalyzer TextAnalyzer { get; }
    internal TextFormatterImp(TextFormattingMode textFormattingMode);
    internal TextFormatterImp(TextFormatterContext soleContext, TextFormattingMode textFormattingMode);
    protected virtual override void Finalize();
    public virtual void Dispose();
    private void CleanupInternal();
    public virtual TextLine FormatLine(TextSource textSource, int firstCharIndex, double paragraphWidth, TextParagraphProperties paragraphProperties, TextLineBreak previousLineBreak);
    public virtual TextLine FormatLine(TextSource textSource, int firstCharIndex, double paragraphWidth, TextParagraphProperties paragraphProperties, TextLineBreak previousLineBreak, TextRunCache textRunCache);
    internal virtual TextLine RecreateLine(TextSource textSource, int firstCharIndex, int lineLength, double paragraphWidth, TextParagraphProperties paragraphProperties, TextLineBreak previousLineBreak, TextRunCache textRunCache);
    private TextLine FormatLineInternal(TextSource textSource, int firstCharIndex, int lineLength, double paragraphWidth, TextParagraphProperties paragraphProperties, TextLineBreak previousLineBreak, TextRunCache textRunCache);
    public virtual MinMaxParagraphWidth FormatMinMaxParagraphWidth(TextSource textSource, int firstCharIndex, TextParagraphProperties paragraphProperties);
    public virtual MinMaxParagraphWidth FormatMinMaxParagraphWidth(TextSource textSource, int firstCharIndex, TextParagraphProperties paragraphProperties, TextRunCache textRunCache);
    internal TextFormattingMode get_TextFormattingMode();
    internal virtual TextParagraphCache CreateParagraphCache(TextSource textSource, int firstCharIndex, double paragraphWidth, TextParagraphProperties paragraphProperties, TextLineBreak previousLineBreak, TextRunCache textRunCache);
    private FormatSettings PrepareFormatSettings(TextSource textSource, int firstCharIndex, double paragraphWidth, TextParagraphProperties paragraphProperties, TextLineBreak previousLineBreak, TextRunCache textRunCache, bool useOptimalBreak, bool isSingleLineFormatting, TextFormattingMode textFormattingMode);
    private void VerifyTextFormattingArguments(TextSource textSource, int firstCharIndex, double paragraphWidth, TextParagraphProperties paragraphProperties, TextRunCache textRunCache);
    internal static void VerifyCaretCharacterHit(CharacterHit characterHit, int cpFirst, int cchLength);
    internal TextFormatterContext AcquireContext(object owner, IntPtr ploc);
    internal static MatrixTransform CreateAntiInversionTransform(InvertAxes inversion, double paragraphWidth, double lineHeight);
    internal static int CompareReal(double x, double y, double pixelsPerDip, TextFormattingMode mode);
    internal static double RoundDip(double value, double pixelsPerDip, TextFormattingMode textFormattingMode);
    internal static double RoundDipForDisplayMode(double value, double pixelsPerDip);
    private static double RoundDipForDisplayMode(double value, double pixelsPerDip, MidpointRounding midpointRounding);
    internal static double RoundDipForDisplayModeJustifiedText(double value, double pixelsPerDip);
    internal static double IdealToRealWithNoRounding(double i);
    internal double IdealToReal(double i, double pixelsPerDip);
    internal static int RealToIdeal(double i);
    internal static int RealToIdealFloor(double i);
    internal static double get_ToIdeal();
    internal GlyphingCache get_GlyphingCache();
    internal TextAnalyzer get_TextAnalyzer();
}
internal class MS.Internal.TextFormatting.TextMarkerSource : TextSource {
    private Char[] _characterArray;
    private TextRunProperties _textRunProperties;
    private TextParagraphProperties _textParagraphProperties;
    private static char NumberSuffix;
    private static string DecimalNumerics;
    private static string LowerLatinNumerics;
    private static string UpperLatinNumerics;
    private static String[][] RomanNumerics;
    internal TextMarkerSource(TextParagraphProperties textParagraphProperties, TextMarkerStyle markerStyle, int autoNumberingIndex);
    private static TextMarkerSource();
    public virtual TextRun GetTextRun(int textSourceCharacterIndex);
    public virtual TextSpan`1<CultureSpecificCharacterBufferRange> GetPrecedingText(int textSourceCharacterIndexLimit);
    public virtual int GetTextEffectCharacterIndexFromTextSourceCharacterIndex(int textSourceCharacterIndex);
    private static Char[] ConvertNumberToString(int number, bool oneBased, string numericSymbols);
    private static string ConvertNumberToRomanString(int number, bool uppercase);
    private static void AddRomanNumeric(StringBuilder builder, int number, string oneFiveTen);
    internal static bool IsKnownSymbolMarkerStyle(TextMarkerStyle markerStyle);
    internal static bool IsKnownIndexMarkerStyle(TextMarkerStyle markerStyle);
}
internal class MS.Internal.TextFormatting.TextMetrics : ValueType {
    private TextFormatterImp _formatter;
    private int _lscpLim;
    private int _cchLength;
    private int _cchDepend;
    private int _cchNewline;
    private int _height;
    private int _textHeight;
    private int _baselineOffset;
    private int _textAscent;
    private int _textStart;
    private int _textWidth;
    private int _textWidthAtTrailing;
    private int _paragraphToText;
    private LSRun _lastRun;
    private double _pixelsPerDip;
    public int Length { get; }
    public int DependentLength { get; }
    public int NewlineLength { get; }
    public double Start { get; }
    public double Width { get; }
    public double WidthIncludingTrailingWhitespace { get; }
    public double Height { get; }
    public double TextHeight { get; }
    public double Baseline { get; }
    public double TextBaseline { get; }
    public double MarkerBaseline { get; }
    public double MarkerHeight { get; }
    internal void Compute(FullTextState fullText, int firstCharIndex, int paragraphWidth, FormattedTextSymbols collapsingSymbol, LsLineWidths& lineWidths, LsLInfo* plsLineInfo);
    internal TextLineBreak GetTextLineBreak(IntPtr ploline);
    private void AppendCollapsingSymbolWidth(int symbolIdealWidth);
    public sealed virtual int get_Length();
    public sealed virtual int get_DependentLength();
    public sealed virtual int get_NewlineLength();
    public sealed virtual double get_Start();
    public sealed virtual double get_Width();
    public sealed virtual double get_WidthIncludingTrailingWhitespace();
    public sealed virtual double get_Height();
    public double get_TextHeight();
    public sealed virtual double get_Baseline();
    public double get_TextBaseline();
    public sealed virtual double get_MarkerBaseline();
    public sealed virtual double get_MarkerHeight();
}
[FriendAccessAllowedAttribute]
internal class MS.Internal.TextFormatting.TextPenaltyModule : object {
    private SecurityCriticalDataForSet`1<IntPtr> _ploPenaltyModule;
    private bool _isDisposed;
    internal TextPenaltyModule(SecurityCriticalDataForSet`1<IntPtr> ploc);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    internal IntPtr DangerousGetHandle();
}
internal class MS.Internal.TextFormatting.TextRunCacheImp : object {
    private SpanVector _textRunVector;
    private SpanPosition _latestPosition;
    public void Change(int textSourceCharacterIndex, int addition, int removal);
    internal TextRun FetchTextRun(FormatSettings settings, int cpFetch, int cpFirst, Int32& offsetToFirstCp, Int32& runLength);
    internal TextSpan`1<CultureSpecificCharacterBufferRange> GetPrecedingText(TextSource textSource, int cpLimit);
    internal IList`1<TextSpan`1<TextRun>> GetTextRunSpans();
}
internal class MS.Internal.TextFormatting.TextRunInfo : object {
    private CharacterBufferRange _charBufferRange;
    private int _textRunLength;
    private int _offsetToFirstCp;
    private TextRun _textRun;
    private Plsrun _plsrun;
    private CultureInfo _digitCulture;
    private ushort _charFlags;
    private ushort _runFlags;
    private TextModifierScope _modifierScope;
    private TextRunProperties _properties;
    internal TextRun TextRun { get; }
    internal TextRunProperties Properties { get; }
    internal CharacterBuffer CharacterBuffer { get; }
    internal int OffsetToFirstChar { get; }
    internal int OffsetToFirstCp { get; }
    internal int StringLength { get; internal set; }
    internal int Length { get; internal set; }
    internal ushort CharacterAttributeFlags { get; internal set; }
    internal CultureInfo DigitCulture { get; }
    internal bool ContextualSubstitution { get; }
    internal bool IsSymbol { get; }
    internal Plsrun Plsrun { get; }
    internal bool IsEndOfLine { get; }
    internal TextModifierScope TextModifierScope { get; }
    internal TextRunInfo(CharacterBufferRange charBufferRange, int textRunLength, int offsetToFirstCp, TextRun textRun, Plsrun lsRunType, ushort charFlags, CultureInfo digitCulture, bool contextualSubstitution, bool symbolTypeface, TextModifierScope modifierScope);
    internal TextRun get_TextRun();
    internal TextRunProperties get_Properties();
    internal CharacterBuffer get_CharacterBuffer();
    internal int get_OffsetToFirstChar();
    internal int get_OffsetToFirstCp();
    internal int get_StringLength();
    internal void set_StringLength(int value);
    internal int get_Length();
    internal void set_Length(int value);
    internal ushort get_CharacterAttributeFlags();
    internal void set_CharacterAttributeFlags(ushort value);
    internal CultureInfo get_DigitCulture();
    internal bool get_ContextualSubstitution();
    internal bool get_IsSymbol();
    internal Plsrun get_Plsrun();
    internal bool get_IsEndOfLine();
    internal TextModifierScope get_TextModifierScope();
    internal int GetRoughWidth(double realToIdeal);
    internal static Plsrun GetRunType(TextRun textRun);
}
internal abstract class MS.Internal.TextFormatting.TextShapeableSymbols : TextRun {
    internal bool IsShapingRequired { get; }
    internal bool NeedsMaxClusterSize { get; }
    internal ushort MaxClusterSize { get; }
    internal bool NeedsCaretInfo { get; }
    internal bool HasExtendedCharacter { get; }
    internal GlyphTypeface GlyphTypeFace { get; }
    internal double EmSize { get; }
    internal ItemProps ItemProps { get; }
    internal double Height { get; }
    internal double Baseline { get; }
    internal double UnderlinePosition { get; }
    internal double UnderlineThickness { get; }
    internal double StrikethroughPosition { get; }
    internal double StrikethroughThickness { get; }
    internal abstract virtual GlyphRun ComputeShapedGlyphRun(Point origin, Char[] characterString, UInt16[] clusterMap, UInt16[] glyphIndices, IList`1<double> glyphAdvances, IList`1<Point> glyphOffsets, bool rightToLeft, bool sideways);
    internal abstract virtual bool CanShapeTogether(TextShapeableSymbols shapeable);
    internal abstract virtual bool get_IsShapingRequired();
    internal abstract virtual bool get_NeedsMaxClusterSize();
    internal abstract virtual ushort get_MaxClusterSize();
    internal abstract virtual bool get_NeedsCaretInfo();
    internal abstract virtual bool get_HasExtendedCharacter();
    internal abstract virtual GlyphTypeface get_GlyphTypeFace();
    internal abstract virtual double get_EmSize();
    internal abstract virtual ItemProps get_ItemProps();
    internal abstract virtual void GetAdvanceWidthsUnshaped(Char* characterString, int characterLength, double scalingFactor, Int32* advanceWidthsUnshaped);
    internal abstract virtual GlyphRun ComputeUnshapedGlyphRun(Point origin, Char[] characterString, IList`1<double> characterAdvances);
    internal abstract virtual void Draw(DrawingContext drawingContext, Brush foregroundBrush, GlyphRun glyphRun);
    internal abstract virtual double get_Height();
    internal abstract virtual double get_Baseline();
    internal abstract virtual double get_UnderlinePosition();
    internal abstract virtual double get_UnderlineThickness();
    internal abstract virtual double get_StrikethroughPosition();
    internal abstract virtual double get_StrikethroughThickness();
}
internal class MS.Internal.TextFormatting.TextStore : object {
    private FormatSettings _settings;
    private int _lscpFirstValue;
    private int _cpFirst;
    private int _lscchUpTo;
    private int _cchUpTo;
    private int _cchEol;
    private int _accNominalWidthSoFar;
    private int _accTextLengthSoFar;
    private NumberContext _numberContext;
    private int _cpNumberContext;
    private SpanVector _plsrunVector;
    private SpanPosition _plsrunVectorLatestPosition;
    private ArrayList _lsrunList;
    private BidiState _bidiState;
    private TextModifierScope _modifierScope;
    private int _formatWidth;
    private SpanVector _textObjectMetricsVector;
    internal static LSRun[] ControlRuns;
    internal static int LscpFirstMarker;
    internal static int TypicalCharactersPerLine;
    internal static char CharLineSeparator;
    internal static char CharParaSeparator;
    internal static char CharLineFeed;
    internal static char CharCarriageReturn;
    internal static char CharTab;
    internal static IntPtr PwchParaSeparator;
    internal static IntPtr PwchLineSeparator;
    internal static IntPtr PwchNbsp;
    internal static IntPtr PwchHidden;
    internal static IntPtr PwchObjectTerminator;
    internal static IntPtr PwchObjectReplacement;
    internal static int MaxCharactersPerLine;
    private static int MaxCchWordToHyphenate;
    private int BaseBidiLevel { get; }
    internal FormatSettings Settings { get; }
    internal ParaProp Pap { get; }
    internal int CpFirst { get; }
    internal SpanVector PlsrunVector { get; }
    internal ArrayList LsrunList { get; }
    internal int FormatWidth { get; }
    internal int CchEol { get; internal set; }
    private static TextStore();
    public TextStore(FormatSettings settings, int cpFirst, int lscpFirstValue, int formatWidth);
    internal LSRun FetchLSRun(int lscpFetch, TextFormattingMode textFormattingMode, bool isSideways, Plsrun& plsrun, Int32& lsrunOffset, Int32& lsrunLength);
    internal TextRunInfo FetchTextRun(int cpFetch);
    private void SetTextEffectsVector(SpanVector textEffectsVector, int ich, TextRunInfo runInfo, TextEffectCollection textEffects);
    private TextRunInfo CreateSpecialRunFromTextContent(TextRunInfo runInfo, int cchFetched);
    private LSRun GrabLSRun(int lscpFetch, Plsrun& plsrun, Int32& lsrunOffset, Int32& lsrunLength);
    private int GetLastLevel();
    private int get_BaseBidiLevel();
    private int BidiAnalyze(SpanVector runInfoVector, int stringLength, Byte[]& bidiLevels);
    private byte AnalyzeDirectionalModifier(BidiState state, FlowDirection flowDirection);
    private byte AnalyzeEndOfDirectionalModifier(BidiState state);
    private bool IsEndOfDirectionalModifier(TextRunInfo runInfo);
    private bool IsDirectionalModifier(TextModifier modifier);
    internal bool InsertFakeLineBreak(int cpLimit);
    private bool IsForceBreakRequired(SpanVector runInfoVector, Int32& cchToAdd);
    private NumberContext GetNumberContext(TextModifierScope scope);
    private void CreateLSRunsUniformBidiLevel(SpanVector runInfoVector, SpanVector textEffectsVector, int runInfoFirstCp, int ichUniform, int cchUniform, int uniformBidiLevel, TextFormattingMode textFormattingMode, bool isSideways, Int32& lastBidiLevel);
    private int CreateReverseLSRuns(int currentBidiLevel, int lastBidiLevel);
    private void CreateLSRuns(TextRunInfo runInfo, IList`1<TextEffect> textEffects, CultureInfo digitCulture, int offsetToFirstChar, int stringLength, int uniformBidiLevel, TextFormattingMode textFormattingMode, bool isSideways, Int32& lastBidiLevel, Int32& textRunLength);
    private void CreateTextLSRuns(TextRunInfo runInfo, IList`1<TextEffect> textEffects, CultureInfo digitCulture, int offsetToFirstChar, int stringLength, int uniformBidiLevel, TextFormattingMode textFormattingMode, bool isSideways, Int32& lastBidiLevel);
    private LSRun CreateLineBreakLSRun(TextRunInfo runInfo, int stringLength, Int32& lsrunLength, Int32& textRunLength);
    private Plsrun AddLSRun(LSRun lsrun);
    internal int GetExternalCp(int lscp);
    internal LSRun GetRun(Plsrun plsrun);
    internal static bool IsMarker(Plsrun plsrun);
    internal static Plsrun MakePlsrunMarker(Plsrun plsrun);
    internal static Plsrun MakePlsrunSymbol(Plsrun plsrun);
    internal static Plsrun ToIndex(Plsrun plsrun);
    internal static bool IsContent(Plsrun plsrun);
    internal static bool IsSpace(char ch);
    internal static bool IsStrong(char ch);
    internal static bool IsNewline(Plsrun plsrun);
    internal static bool IsNewline(ushort flags);
    internal void AdjustRunsVerticalOffset(int dcpLimit, int height, int baselineOffset, Int32& cellHeight, Int32& cellAscent);
    internal Char[] CollectRawWord(int lscpCurrent, bool isCurrentAtWordStart, bool isSideways, Int32& lscpChunk, Int32& lscchChunk, CultureInfo& textCulture, Int32& cchWordMax, SpanVector`1& textVector);
    internal TextEmbeddedObjectMetrics FormatTextObject(TextEmbeddedObject textObject, int cpFirst, int currentPosition, int rightMargin);
    internal FormatSettings get_Settings();
    internal ParaProp get_Pap();
    internal int get_CpFirst();
    internal SpanVector get_PlsrunVector();
    internal ArrayList get_LsrunList();
    internal int get_FormatWidth();
    internal int get_CchEol();
    internal void set_CchEol(int value);
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.TextFormatting.ThousandthOfEmRealDoubles : object {
    private Int16[] _shortList;
    private Double[] _doubleList;
    private double _emSize;
    private static double ToThousandthOfEm;
    private static double ToReal;
    private static double CutOffEmSize;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public double Item { get; public set; }
    internal ThousandthOfEmRealDoubles(double emSize, int capacity);
    internal ThousandthOfEmRealDoubles(double emSize, IList`1<double> realValues);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual double get_Item(int index);
    public sealed virtual void set_Item(int index, double value);
    public sealed virtual int IndexOf(double item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(double item);
    public sealed virtual void CopyTo(Double[] array, int arrayIndex);
    [IteratorStateMachineAttribute("MS.Internal.TextFormatting.ThousandthOfEmRealDoubles/<GetEnumerator>d__13")]
public sealed virtual IEnumerator`1<double> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(double value);
    public sealed virtual void Insert(int index, double item);
    public sealed virtual bool Remove(double item);
    public sealed virtual void RemoveAt(int index);
    private void InitArrays(int capacity);
    private bool RealToThousandthOfEm(double value, Int16& thousandthOfEm);
    private double ThousandthOfEmToReal(short thousandthOfEm);
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.TextFormatting.ThousandthOfEmRealPoints : object {
    private ThousandthOfEmRealDoubles _xArray;
    private ThousandthOfEmRealDoubles _yArray;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public Point Item { get; public set; }
    internal ThousandthOfEmRealPoints(double emSize, int capacity);
    internal ThousandthOfEmRealPoints(double emSize, IList`1<Point> pointValues);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual Point get_Item(int index);
    public sealed virtual void set_Item(int index, Point value);
    public sealed virtual int IndexOf(Point item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Point item);
    public sealed virtual void CopyTo(Point[] array, int arrayIndex);
    [IteratorStateMachineAttribute("MS.Internal.TextFormatting.ThousandthOfEmRealPoints/<GetEnumerator>d__13")]
public sealed virtual IEnumerator`1<Point> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(Point value);
    public sealed virtual void Insert(int index, Point item);
    public sealed virtual bool Remove(Point item);
    public sealed virtual void RemoveAt(int index);
    private void InitArrays(double emSize, int capacity);
}
internal static class MS.Internal.TextFormatting.UnsafeNativeMethods : object {
    internal static LsErr LoCreateContext(LsContextInfo& contextInfo, LscbkRedefined& lscbkRedef, IntPtr& ploc);
    internal static LsErr LoDestroyContext(IntPtr ploc);
    internal static LsErr LoCreateLine(IntPtr ploc, int cp, int ccpLim, int durColumn, UInt32 dwLineFlags, IntPtr pInputBreakRec, LsLInfo& plslinfo, IntPtr& pploline, Int32& maxDepth, LsLineWidths& lineWidths);
    internal static LsErr LoDisposeLine(IntPtr ploline, bool finalizing);
    internal static LsErr LoAcquireBreakRecord(IntPtr ploline, IntPtr& pbreakrec);
    internal static LsErr LoDisposeBreakRecord(IntPtr pBreakRec, bool finalizing);
    internal static LsErr LoCloneBreakRecord(IntPtr pBreakRec, IntPtr& pBreakRecClone);
    internal static LsErr LoRelievePenaltyResource(IntPtr ploline);
    internal static LsErr LoSetBreaking(IntPtr ploc, int strategy);
    internal static LsErr LoSetDoc(IntPtr ploc, int isDisplay, int isReferencePresentationEqual, LsDevRes& deviceInfo);
    internal static LsErr LoSetTabs(IntPtr ploc, int durIncrementalTab, int tabCount, LsTbd* pTabs);
    internal static LsErr LoDisplayLine(IntPtr ploline, LSPOINT& pt, UInt32 displayMode, LSRECT& clipRect);
    internal static LsErr LoEnumLine(IntPtr ploline, bool reverseOder, bool fGeometryneeded, LSPOINT& pt);
    internal static LsErr LoQueryLineCpPpoint(IntPtr ploline, int lscpQuery, int depthQueryMax, IntPtr pSubLineInfo, Int32& actualDepthQuery, LsTextCell& lsTextCell);
    internal static LsErr LoQueryLinePointPcp(IntPtr ploline, LSPOINT& ptQuery, int depthQueryMax, IntPtr pSubLineInfo, Int32& actualDepthQuery, LsTextCell& lsTextCell);
    internal static LsErr LoCreateBreaks(IntPtr ploc, int cpFirst, IntPtr previousBreakRecord, IntPtr ploparabreak, IntPtr ptslinevariantRestriction, LsBreaks& lsbreaks, Int32& bestFitIndex);
    internal static LsErr LoCreateParaBreakingSession(IntPtr ploc, int cpParagraphFirst, int maxWidth, IntPtr previousParaBreakRecord, IntPtr& pploparabreak, Boolean& fParagraphJustified);
    internal static LsErr LoDisposeParaBreakingSession(IntPtr ploparabreak, bool finalizing);
    internal static LsErr LocbkGetObjectHandlerInfo(IntPtr ploc, UInt32 objectId, Void* objectInfo);
    internal static void LoGetEscString(EscStringInfo& escStringInfo);
    private static void LoGetEscStringImpl(EscStringInfo& escStringInfo);
    internal static LsErr LoAcquirePenaltyModule(IntPtr ploc, IntPtr& penaltyModuleHandle);
    internal static LsErr LoDisposePenaltyModule(IntPtr penaltyModuleHandle);
    internal static LsErr LoGetPenaltyModuleInternalHandle(IntPtr penaltyModuleHandle, IntPtr& penaltyModuleInternalHandle);
    internal static Void* CreateTextAnalysisSink();
    internal static Void* GetScriptAnalysisList(Void* textAnalysisSink);
    internal static Void* GetNumberSubstitutionList(Void* textAnalysisSink);
    internal static int CreateTextAnalysisSource(Char* text, UInt32 length, Char* culture, Void* factory, bool isRightToLeft, Char* numberCulture, bool ignoreUserOverride, UInt32 numberSubstitutionMethod, Void** ppTextAnalysisSource);
}
internal static class MS.Internal.TimeEnumHelper : object {
    private static int c_maxFillBehavior;
    private static int c_maxSlipBehavior;
    private static int _maxTimeSeekOrigin;
    private static byte _maxPathAnimationSource;
    internal static bool IsValidFillBehavior(FillBehavior value);
    internal static bool IsValidSlipBehavior(SlipBehavior value);
    internal static bool IsValidTimeSeekOrigin(TimeSeekOrigin value);
    internal static bool IsValidPathAnimationSource(PathAnimationSource value);
}
internal static class MS.Internal.TraceAnimation : object {
    private static AvTrace _avTrace;
    private static AvTraceDetails _StoryboardBegin;
    private static AvTraceDetails _StoryboardPause;
    private static AvTraceDetails _StoryboardRemove;
    private static AvTraceDetails _StoryboardResume;
    private static AvTraceDetails _StoryboardStop;
    private static AvTraceDetails _StoryboardNotApplied;
    private static AvTraceDetails _AnimateStorageValidationFailed;
    private static AvTraceDetails _AnimateStorageValidationNoLongerFailing;
    public static AvTraceDetails StoryboardBegin { get; }
    public static AvTraceDetails StoryboardPause { get; }
    public static AvTraceDetails StoryboardRemove { get; }
    public static AvTraceDetails StoryboardResume { get; }
    public static AvTraceDetails StoryboardStop { get; }
    public static AvTraceDetails StoryboardNotApplied { get; }
    public static AvTraceDetails AnimateStorageValidationFailed { get; }
    public static AvTraceDetails AnimateStorageValidationNoLongerFailing { get; }
    public static bool IsEnabled { get; }
    public static bool IsEnabledOverride { get; }
    private static TraceAnimation();
    public static AvTraceDetails get_StoryboardBegin();
    public static AvTraceDetails get_StoryboardPause();
    public static AvTraceDetails get_StoryboardRemove();
    public static AvTraceDetails get_StoryboardResume();
    public static AvTraceDetails get_StoryboardStop();
    public static AvTraceDetails get_StoryboardNotApplied();
    public static AvTraceDetails get_AnimateStorageValidationFailed();
    public static AvTraceDetails get_AnimateStorageValidationNoLongerFailing();
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, Object[] parameters);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1, object p2);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1, object p2, object p3);
    public static void TraceActivityItem(AvTraceDetails traceDetails, Object[] parameters);
    public static void TraceActivityItem(AvTraceDetails traceDetails);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1, object p2);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1, object p2, object p3);
    public static bool get_IsEnabled();
    public static bool get_IsEnabledOverride();
    public static void Refresh();
}
internal static class MS.Internal.TraceRoutedEvent : object {
    private static AvTrace _avTrace;
    private static AvTraceDetails _RaiseEvent;
    private static AvTraceDetails _ReRaiseEventAs;
    private static AvTraceDetails _HandleEvent;
    private static AvTraceDetails _InvokeHandlers;
    public static AvTraceDetails RaiseEvent { get; }
    public static AvTraceDetails ReRaiseEventAs { get; }
    public static AvTraceDetails HandleEvent { get; }
    public static AvTraceDetails InvokeHandlers { get; }
    public static bool IsEnabled { get; }
    public static bool IsEnabledOverride { get; }
    private static TraceRoutedEvent();
    public static AvTraceDetails get_RaiseEvent();
    public static AvTraceDetails get_ReRaiseEventAs();
    public static AvTraceDetails get_HandleEvent();
    public static AvTraceDetails get_InvokeHandlers();
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, Object[] parameters);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1, object p2);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1, object p2, object p3);
    public static void TraceActivityItem(AvTraceDetails traceDetails, Object[] parameters);
    public static void TraceActivityItem(AvTraceDetails traceDetails);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1, object p2);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1, object p2, object p3);
    public static bool get_IsEnabled();
    public static bool get_IsEnabledOverride();
    public static void Refresh();
}
internal static class MS.Internal.UIElementHelper : object {
    [FriendAccessAllowedAttribute]
internal static bool IsHitTestVisible(DependencyObject o);
    [FriendAccessAllowedAttribute]
internal static bool IsVisible(DependencyObject o);
    [FriendAccessAllowedAttribute]
internal static DependencyObject PredictFocus(DependencyObject o, FocusNavigationDirection direction);
    [FriendAccessAllowedAttribute]
internal static UIElement GetContainingUIElement2D(DependencyObject reference);
    [FriendAccessAllowedAttribute]
internal static DependencyObject GetUIParent(DependencyObject child);
    [FriendAccessAllowedAttribute]
internal static DependencyObject GetUIParent(DependencyObject child, bool continuePastVisualTree);
    [FriendAccessAllowedAttribute]
internal static bool IsUIElementOrUIElement3D(DependencyObject o);
    [FriendAccessAllowedAttribute]
internal static void InvalidateAutomationAncestors(DependencyObject o);
    internal static bool InvalidateAutomationPeer(DependencyObject o, UIElement& e, ContentElement& ce, UIElement3D& e3d);
}
internal enum MS.Internal.UnicodeClass : Enum {
    public ushort value__;
    public static UnicodeClass Max;
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.UnsafeStringCharacterBuffer : CharacterBuffer {
    private Char* _unsafeString;
    private int _length;
    public char Item { get; public set; }
    public int Count { get; }
    public UnsafeStringCharacterBuffer(Char* characterString, int length);
    public virtual char get_Item(int characterOffset);
    public virtual void set_Item(int characterOffset, char value);
    public virtual int get_Count();
    public virtual Char* GetCharacterPointer();
    public virtual IntPtr PinAndGetCharacterPointer(int offset, GCHandle& gcHandle);
    public virtual void UnpinCharacterPointer(GCHandle gcHandle);
    public virtual void AppendToStringBuilder(StringBuilder stringBuilder, int characterOffset, int characterLength);
}
internal enum MS.Internal.WICBitmapAlphaChannelOption : Enum {
    public int value__;
    public static WICBitmapAlphaChannelOption WICBitmapUseAlpha;
    public static WICBitmapAlphaChannelOption WICBitmapUsePremultipliedAlpha;
    public static WICBitmapAlphaChannelOption WICBitmapIgnoreAlpha;
}
internal enum MS.Internal.WICBitmapCreateCacheOptions : Enum {
    public int value__;
    public static WICBitmapCreateCacheOptions WICBitmapNoCache;
    public static WICBitmapCreateCacheOptions WICBitmapCacheOnDemand;
    public static WICBitmapCreateCacheOptions WICBitmapCacheOnLoad;
}
internal enum MS.Internal.WICBitmapEncodeCacheOption : Enum {
    public int value__;
    public static WICBitmapEncodeCacheOption WICBitmapEncodeCacheInMemory;
    public static WICBitmapEncodeCacheOption WICBitmapEncodeCacheTempFile;
    public static WICBitmapEncodeCacheOption WICBitmapEncodeNoCache;
}
internal class MS.Internal.WICBitmapPattern : ValueType {
    private long Offset;
    private UInt32 Length;
    private IntPtr Pattern;
    private IntPtr Mask;
}
internal enum MS.Internal.WICBitmapTransformOptions : Enum {
    public int value__;
    public static WICBitmapTransformOptions WICBitmapTransformRotate0;
    public static WICBitmapTransformOptions WICBitmapTransformRotate90;
    public static WICBitmapTransformOptions WICBitmapTransformRotate180;
    public static WICBitmapTransformOptions WICBitmapTransformRotate270;
    public static WICBitmapTransformOptions WICBitmapTransformFlipHorizontal;
    public static WICBitmapTransformOptions WICBitmapTransformFlipVertical;
}
internal enum MS.Internal.WICComponentType : Enum {
    public int value__;
    public static WICComponentType WICDecoder;
    public static WICComponentType WICEncoder;
    public static WICComponentType WICFormat;
    public static WICComponentType WICFormatConverter;
    public static WICComponentType WICMetadataReader;
    public static WICComponentType WICMetadataWriter;
}
internal enum MS.Internal.WICInterpolationMode : Enum {
    public int value__;
    public static WICInterpolationMode NearestNeighbor;
    public static WICInterpolationMode Linear;
    public static WICInterpolationMode Cubic;
    public static WICInterpolationMode Fant;
}
internal enum MS.Internal.WICMetadataCacheOptions : Enum {
    public int value__;
    public static WICMetadataCacheOptions WICMetadataCacheOnDemand;
    public static WICMetadataCacheOptions WICMetadataCacheOnLoad;
}
internal enum MS.Internal.WICPaletteType : Enum {
    public int value__;
    public static WICPaletteType WICPaletteTypeCustom;
    public static WICPaletteType WICPaletteTypeOptimal;
    public static WICPaletteType WICPaletteTypeFixedBW;
    public static WICPaletteType WICPaletteTypeFixedHalftone8;
    public static WICPaletteType WICPaletteTypeFixedHalftone27;
    public static WICPaletteType WICPaletteTypeFixedHalftone64;
    public static WICPaletteType WICPaletteTypeFixedHalftone125;
    public static WICPaletteType WICPaletteTypeFixedHalftone216;
    public static WICPaletteType WICPaletteTypeFixedWebPalette;
    public static WICPaletteType WICPaletteTypeFixedHalftone252;
    public static WICPaletteType WICPaletteTypeFixedHalftone256;
    public static WICPaletteType WICPaletteTypeFixedGray4;
    public static WICPaletteType WICPaletteTypeFixedGray16;
    public static WICPaletteType WICPaletteTypeFixedGray256;
}
internal static class MS.Internal.WICPixelFormatGUIDs : object {
    internal static Guid WICPixelFormatDontCare;
    internal static Guid WICPixelFormat1bppIndexed;
    internal static Guid WICPixelFormat2bppIndexed;
    internal static Guid WICPixelFormat4bppIndexed;
    internal static Guid WICPixelFormat8bppIndexed;
    internal static Guid WICPixelFormatBlackWhite;
    internal static Guid WICPixelFormat2bppGray;
    internal static Guid WICPixelFormat4bppGray;
    internal static Guid WICPixelFormat8bppGray;
    internal static Guid WICPixelFormat16bppBGR555;
    internal static Guid WICPixelFormat16bppBGR565;
    internal static Guid WICPixelFormat16bppGray;
    internal static Guid WICPixelFormat24bppBGR;
    internal static Guid WICPixelFormat24bppRGB;
    internal static Guid WICPixelFormat32bppBGR;
    internal static Guid WICPixelFormat32bppBGRA;
    internal static Guid WICPixelFormat32bppPBGRA;
    internal static Guid WICPixelFormat32bppGrayFloat;
    internal static Guid WICPixelFormat32bppBGR101010;
    internal static Guid WICPixelFormat48bppRGB;
    internal static Guid WICPixelFormat64bppRGBA;
    internal static Guid WICPixelFormat64bppPRGBA;
    internal static Guid WICPixelFormat128bppRGBAFloat;
    internal static Guid WICPixelFormat128bppPRGBAFloat;
    internal static Guid WICPixelFormat128bppRGBFloat;
    internal static Guid WICPixelFormat32bppCMYK;
    private static WICPixelFormatGUIDs();
}
internal enum MS.Internal.WinCodecErrors : Enum {
    public int value__;
    public static WinCodecErrors WINCODEC_ERR_GENERIC_ERROR;
    public static WinCodecErrors WINCODEC_ERR_INVALIDPARAMETER;
    public static WinCodecErrors WINCODEC_ERR_OUTOFMEMORY;
    public static WinCodecErrors WINCODEC_ERR_NOTIMPLEMENTED;
    public static WinCodecErrors WINCODEC_ERR_ABORTED;
    public static WinCodecErrors WINCODEC_ERR_ACCESSDENIED;
    public static WinCodecErrors WINCODEC_ERR_VALUEOVERFLOW;
    public static WinCodecErrors WINCODEC_ERR_WRONGSTATE;
    public static WinCodecErrors WINCODEC_ERR_VALUEOUTOFRANGE;
    public static WinCodecErrors WINCODEC_ERR_UNKNOWNIMAGEFORMAT;
    public static WinCodecErrors WINCODEC_ERR_UNSUPPORTEDVERSION;
    public static WinCodecErrors WINCODEC_ERR_NOTINITIALIZED;
    public static WinCodecErrors WINCODEC_ERR_ALREADYLOCKED;
    public static WinCodecErrors WINCODEC_ERR_PROPERTYNOTFOUND;
    public static WinCodecErrors WINCODEC_ERR_PROPERTYNOTSUPPORTED;
    public static WinCodecErrors WINCODEC_ERR_PROPERTYSIZE;
    public static WinCodecErrors WINCODEC_ERR_CODECPRESENT;
    public static WinCodecErrors WINCODEC_ERR_CODECNOTHUMBNAIL;
    public static WinCodecErrors WINCODEC_ERR_PALETTEUNAVAILABLE;
    public static WinCodecErrors WINCODEC_ERR_CODECTOOMANYSCANLINES;
    public static WinCodecErrors WINCODEC_ERR_INTERNALERROR;
    public static WinCodecErrors WINCODEC_ERR_SOURCERECTDOESNOTMATCHDIMENSIONS;
    public static WinCodecErrors WINCODEC_ERR_COMPONENTNOTFOUND;
    public static WinCodecErrors WINCODEC_ERR_IMAGESIZEOUTOFRANGE;
    public static WinCodecErrors WINCODEC_ERR_TOOMUCHMETADATA;
    public static WinCodecErrors WINCODEC_ERR_BADIMAGE;
    public static WinCodecErrors WINCODEC_ERR_BADHEADER;
    public static WinCodecErrors WINCODEC_ERR_FRAMEMISSING;
    public static WinCodecErrors WINCODEC_ERR_BADMETADATAHEADER;
    public static WinCodecErrors WINCODEC_ERR_BADSTREAMDATA;
    public static WinCodecErrors WINCODEC_ERR_STREAMWRITE;
    public static WinCodecErrors WINCODEC_ERR_STREAMREAD;
    public static WinCodecErrors WINCODEC_ERR_STREAMNOTAVAILABLE;
    public static WinCodecErrors WINCODEC_ERR_UNSUPPORTEDPIXELFORMAT;
    public static WinCodecErrors WINCODEC_ERR_UNSUPPORTEDOPERATION;
    public static WinCodecErrors WINCODEC_ERR_INVALIDREGISTRATION;
    public static WinCodecErrors WINCODEC_ERR_COMPONENTINITIALIZEFAILURE;
    public static WinCodecErrors WINCODEC_ERR_INSUFFICIENTBUFFER;
    public static WinCodecErrors WINCODEC_ERR_DUPLICATEMETADATAPRESENT;
    public static WinCodecErrors WINCODEC_ERR_PROPERTYUNEXPECTEDTYPE;
    public static WinCodecErrors WINCODEC_ERR_UNEXPECTEDSIZE;
    public static WinCodecErrors WINCODEC_ERR_INVALIDQUERYREQUEST;
    public static WinCodecErrors WINCODEC_ERR_UNEXPECTEDMETADATATYPE;
    public static WinCodecErrors WINCODEC_ERR_REQUESTONLYVALIDATMETADATAROOT;
    public static WinCodecErrors WINCODEC_ERR_INVALIDQUERYCHARACTER;
}
internal class MS.Internal.WindowsRuntime.Windows.UI.ViewManagement.InputPane : object {
    private static string s_TypeName;
    private static Type s_WinRTType;
    private static IActivationFactory _winRtActivationFactory;
    private IInputPane2 _inputPane;
    private bool _disposed;
    private static InputPane();
    private InputPane(Nullable`1<IntPtr> hwnd);
    internal static InputPane GetForWindow(HwndSource source);
    internal bool TryShow();
    internal bool TryHide();
    private static IActivationFactory GetWinRtActivationFactory(bool forceInitialization);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
}
internal static class MS.Internal.WindowsRuntime.Windows.UI.ViewManagement.InputPaneRcw : object {
}
internal static class MS.Internal.WpfWebRequestHelper : object {
    private static HttpRequestCachePolicy _httpRequestCachePolicy;
    private static HttpRequestCachePolicy _httpRequestCachePolicyRefresh;
    private static string _defaultUserAgent;
    internal static string DefaultUserAgent { get; internal set; }
    [FriendAccessAllowedAttribute]
internal static WebRequest CreateRequest(Uri uri);
    [FriendAccessAllowedAttribute]
internal static void ConfigCachePolicy(WebRequest request, bool isRefresh);
    internal static string get_DefaultUserAgent();
    internal static void set_DefaultUserAgent(string value);
    [FriendAccessAllowedAttribute]
internal static void HandleWebResponse(WebResponse response);
    [FriendAccessAllowedAttribute]
internal static Stream CreateRequestAndGetResponseStream(Uri uri);
    [FriendAccessAllowedAttribute]
internal static Stream CreateRequestAndGetResponseStream(Uri uri, ContentType& contentType);
    [FriendAccessAllowedAttribute]
internal static WebResponse CreateRequestAndGetResponse(Uri uri);
    [FriendAccessAllowedAttribute]
internal static WebResponse GetResponse(WebRequest request);
    [FriendAccessAllowedAttribute]
internal static WebResponse EndGetResponse(WebRequest request, IAsyncResult ar);
    [FriendAccessAllowedAttribute]
internal static Stream GetResponseStream(WebRequest request);
    [FriendAccessAllowedAttribute]
internal static Stream GetResponseStream(WebRequest request, ContentType& contentType);
    [FriendAccessAllowedAttribute]
internal static ContentType GetContentType(WebResponse response);
}
[FriendAccessAllowedAttribute]
[DefaultMemberAttribute("Item")]
internal class MS.Utility.DTypeMap : object {
    private int _entryCount;
    private Object[] _entries;
    private Hashtable _overFlow;
    private ItemStructList`1<DependencyObjectType> _activeDTypes;
    public object Item { get; public set; }
    public ItemStructList`1<DependencyObjectType> ActiveDTypes { get; }
    public DTypeMap(int entryCount);
    public object get_Item(DependencyObjectType dType);
    public void set_Item(DependencyObjectType dType, object value);
    public ItemStructList`1<DependencyObjectType> get_ActiveDTypes();
    public void Clear();
}
[FriendAccessAllowedAttribute]
internal static class MS.Utility.PerfService : object {
    private static ConditionalWeakTable`2<object, object> perfElementIds;
    private static PerfService();
    internal static long GetPerfElementID2(object element, string extraData);
    internal static long GetPerfElementID(object element);
}
[FriendAccessAllowedAttribute]
internal static class MS.Win32.Compile.UnsafeNativeMethods : object {
    public static int SHGetFolderPath(IntPtr hwndOwner, int nFolder, IntPtr hToken, int dwFlags, StringBuilder lpszPath);
    internal static int FindMimeFromData(IBindCtx pBC, string wszUrl, IntPtr Buffer, int cbSize, string wzMimeProposed, int dwMimeFlags, String& wzMimeOut, int dwReserved);
}
internal static class MS.Win32.LoadLibraryHelper : object {
    private static bool IsKnowledgeBase2533623OrGreater();
    internal static IntPtr SecureLoadLibraryEx(string lpFileName, IntPtr hFile, LoadLibraryFlags dwFlags);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("75C6AAEE-2BA4-4008-B523-4F1E033FF049")]
internal interface MS.Win32.Penimc.IPimcContext3 {
    public abstract virtual void ShutdownComm();
    public abstract virtual void GetPacketDescriptionInfo(Int32& cProps, Int32& cButtons);
    public abstract virtual void GetPacketPropertyInfo(int iProp, Guid& guid, Int32& iMin, Int32& iMax, Int32& iUnits, Single& flResolution);
    public abstract virtual void GetPacketButtonInfo(int iButton, Guid& guid);
    public abstract virtual void GetLastSystemEventData(Int32& evt, Int32& modifier, Int32& character, Int32& x, Int32& y, Int32& stylusMode, Int32& buttonState);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("BD2C38C2-E064-41D0-A999-940F526219C2")]
internal interface MS.Win32.Penimc.IPimcManager3 {
    public abstract virtual void GetTabletCount(UInt32& count);
    public abstract virtual void GetTablet(UInt32 tablet, IPimcTablet3& IPimcTablet);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("CEB1EF24-BB4E-498B-9DF7-12887ED0EB24")]
internal interface MS.Win32.Penimc.IPimcTablet3 {
    public abstract virtual void GetKey(Int32& key);
    public abstract virtual void GetName(String& name);
    public abstract virtual void GetPlugAndPlayId(String& plugAndPlayId);
    public abstract virtual void GetTabletAndDisplaySize(Int32& tabletWidth, Int32& tabletHeight, Int32& displayWidth, Int32& displayHeight);
    public abstract virtual void GetHardwareCaps(Int32& caps);
    public abstract virtual void GetDeviceType(Int32& devType);
    public abstract virtual void RefreshCursorInfo();
    public abstract virtual void GetCursorCount(Int32& cCursors);
    public abstract virtual void GetCursorInfo(int iCursor, String& sName, Int32& id, Boolean& fInverted);
    public abstract virtual void GetCursorButtonCount(int iCursor, Int32& cButtons);
    public abstract virtual void GetCursorButtonInfo(int iCursor, int iButton, String& sName, Guid& guid);
    public abstract virtual void IsPropertySupported(Guid guid, Boolean& fSupported);
    public abstract virtual void GetPropertyInfo(Guid guid, Int32& min, Int32& max, Int32& units, Single& resolution);
    public abstract virtual void CreateContext(IntPtr handle, bool fEnable, UInt32 timeout, IPimcContext3& IPimcContext, Int32& key, Int64& commHandle);
    public abstract virtual void GetPacketDescriptionInfo(Int32& cProps, Int32& cButtons);
    public abstract virtual void GetPacketPropertyInfo(int iProp, Guid& guid, Int32& iMin, Int32& iMax, Int32& iUnits, Single& flResolution);
    public abstract virtual void GetPacketButtonInfo(int iButton, Guid& guid);
}
internal static class MS.Win32.Penimc.PimcConstants : object {
    internal static string PimcManager3CLSID;
    internal static string IPimcManager3IID;
}
internal static class MS.Win32.Penimc.UnsafeNativeMethods : object {
    private static UInt32 ReleaseManagerExt;
    private static int ReleaseTabletExt;
    private static int GetWispTabletKey;
    private static int GetWispManagerKey;
    private static int LockTabletExt;
    private static int GetWispContextKey;
    [ThreadStaticAttribute]
private static Nullable`1<UInt32> _wispManagerKey;
    [ThreadStaticAttribute]
private static bool _wispManagerLocked;
    [ThreadStaticAttribute]
private static IPimcManager3 _pimcManagerThreadStatic;
    internal static IPimcManager3 PimcManager { get; }
    private static UnsafeNativeMethods();
    internal static IntPtr RegisterDllForSxSCOM();
    internal static IPimcManager3 get_PimcManager();
    private static IPimcManager3 CreatePimcManager();
    internal static void CheckedLockWispObjectFromGit(UInt32 gitKey);
    internal static void CheckedUnlockWispObjectFromGit(UInt32 gitKey);
    private static void ReleaseManagerExternalLockImpl(IPimcManager3 manager);
    internal static void ReleaseManagerExternalLock();
    internal static void SetWispManagerKey(IPimcTablet3 tablet);
    internal static void LockWispManager();
    internal static void UnlockWispManager();
    internal static void AcquireTabletExternalLock(IPimcTablet3 tablet);
    internal static void ReleaseTabletExternalLock(IPimcTablet3 tablet);
    private static UInt32 QueryWispKeyFromTablet(int keyType, IPimcTablet3 tablet);
    internal static UInt32 QueryWispTabletKey(IPimcTablet3 tablet);
    internal static UInt32 QueryWispContextKey(IPimcContext3 context);
    internal static bool GetPenEvent(IntPtr commHandle, IntPtr handleReset, Int32& evt, Int32& stylusPointerId, Int32& cPackets, Int32& cbPacket, IntPtr& pPackets);
    internal static bool GetPenEventMultiple(int cCommHandles, IntPtr[] commHandles, IntPtr handleReset, Int32& iHandle, Int32& evt, Int32& stylusPointerId, Int32& cPackets, Int32& cbPacket, IntPtr& pPackets);
    internal static bool GetLastSystemEventData(IntPtr commHandle, Int32& evt, Int32& modifier, Int32& key, Int32& x, Int32& y, Int32& cursorMode, Int32& buttonState);
    internal static bool CreateResetEvent(IntPtr& handle);
    internal static bool DestroyResetEvent(IntPtr handle);
    internal static bool RaiseResetEvent(IntPtr handle);
    private static bool LockWispObjectFromGit(UInt32 gitKey);
    private static bool UnlockWispObjectFromGit(UInt32 gitKey);
    private static object CoCreateInstance(Guid& clsid, object punkOuter, int context, Guid& iid);
}
internal class MS.Win32.Pointer.UnsafeNativeMethods : object {
    internal static int POINTER_DEVICE_PRODUCT_STRING_MAX;
    internal static bool GetPointerDevices(UInt32& deviceCount, POINTER_DEVICE_INFO[] devices);
    internal static bool GetPointerDeviceCursors(IntPtr device, UInt32& cursorCount, POINTER_DEVICE_CURSOR_INFO[] cursors);
    internal static bool GetPointerInfo(UInt32 pointerId, POINTER_INFO& pointerInfo);
    internal static bool GetPointerInfoHistory(UInt32 pointerId, UInt32& entriesCount, POINTER_INFO[] pointerInfo);
    internal static bool GetPointerDeviceProperties(IntPtr device, UInt32& propertyCount, POINTER_DEVICE_PROPERTY[] pointerProperties);
    internal static bool GetPointerDeviceRects(IntPtr device, RECT& pointerDeviceRect, RECT& displayRect);
    internal static bool GetPointerCursorId(UInt32 pointerId, UInt32& cursorId);
    internal static bool GetPointerPenInfo(UInt32 pointerId, POINTER_PEN_INFO& penInfo);
    internal static bool GetPointerTouchInfo(UInt32 pointerId, POINTER_TOUCH_INFO& touchInfo);
    internal static bool GetRawPointerDeviceData(UInt32 pointerId, UInt32 historyCount, UInt32 propertiesCount, POINTER_DEVICE_PROPERTY[] pProperties, Int32[] pValues);
    internal static void CreateInteractionContext(IntPtr& interactionContext);
    internal static void DestroyInteractionContext(IntPtr interactionContext);
    internal static void SetInteractionConfigurationInteractionContext(IntPtr interactionContext, UInt32 configurationCount, INTERACTION_CONTEXT_CONFIGURATION[] configuration);
    internal static void RegisterOutputCallbackInteractionContext(IntPtr interactionContext, INTERACTION_CONTEXT_OUTPUT_CALLBACK outputCallback, IntPtr clientData);
    internal static void SetPropertyInteractionContext(IntPtr interactionContext, INTERACTION_CONTEXT_PROPERTY contextProperty, UInt32 value);
    internal static void BufferPointerPacketsInteractionContext(IntPtr interactionContext, UInt32 entriesCount, POINTER_INFO[] pointerInfo);
    internal static void ProcessBufferedPacketsInteractionContext(IntPtr interactionContext);
}
internal static class MS.Win32.PresentationCore.SafeNativeMethods : object {
    internal static int MilCompositionEngine_InitializePartitionManager(int nPriority);
    internal static int MilCompositionEngine_DeinitializePartitionManager();
    internal static long GetNextPerfElementId();
}
internal static class MS.Win32.PresentationCore.UnsafeNativeMethods : object {
}
internal enum MS.Win32.Recognizer.ALT_BREAKS : Enum {
    public int value__;
    public static ALT_BREAKS ALT_BREAKS_SAME;
    public static ALT_BREAKS ALT_BREAKS_UNIQUE;
    public static ALT_BREAKS ALT_BREAKS_FULL;
}
internal class MS.Win32.Recognizer.CHARACTER_RANGE : ValueType {
    public ushort wcLow;
    public ushort cChars;
}
internal class MS.Win32.Recognizer.ContextSafeHandle : SafeHandle {
    private RecognizerSafeHandle _recognizerHandle;
    public bool IsInvalid { get; }
    private ContextSafeHandle(bool ownHandle);
    [ReliabilityContractAttribute("3", "2")]
public virtual bool get_IsInvalid();
    [ReliabilityContractAttribute("3", "2")]
protected virtual bool ReleaseHandle();
    internal void AddReferenceOnRecognizer(RecognizerSafeHandle handle);
}
internal class MS.Win32.Recognizer.PACKET_DESCRIPTION : ValueType {
    public UInt32 cbPacketSize;
    public UInt32 cPacketProperties;
    public IntPtr pPacketProperties;
    public UInt32 cButtons;
    public IntPtr pguidButtons;
}
internal class MS.Win32.Recognizer.PACKET_PROPERTY : ValueType {
    public Guid guid;
    public PROPERTY_METRICS PropertyMetrics;
}
internal class MS.Win32.Recognizer.PROPERTY_METRICS : ValueType {
    public int nLogicalMin;
    public int nLogicalMax;
    public int Units;
    public float fResolution;
}
internal class MS.Win32.Recognizer.RECO_LATTICE : ValueType {
    public UInt32 ulColumnCount;
    public IntPtr pLatticeColumns;
    public UInt32 ulPropertyCount;
    public IntPtr pGuidProperties;
    public UInt32 ulBestResultColumnCount;
    public IntPtr pulBestResultColumns;
    public IntPtr pulBestResultIndexes;
}
internal class MS.Win32.Recognizer.RECO_LATTICE_COLUMN : ValueType {
    public UInt32 key;
    public RECO_LATTICE_PROPERTIES cpProp;
    public UInt32 cStrokes;
    public IntPtr pStrokes;
    public UInt32 cLatticeElements;
    public IntPtr pLatticeElements;
}
internal class MS.Win32.Recognizer.RECO_LATTICE_ELEMENT : ValueType {
    public int score;
    public ushort type;
    public IntPtr pData;
    public UInt32 ulNextColumn;
    public UInt32 ulStrokeNumber;
    public RECO_LATTICE_PROPERTIES epProp;
}
internal class MS.Win32.Recognizer.RECO_LATTICE_PROPERTIES : ValueType {
    public UInt32 cProperties;
    public IntPtr apProps;
}
internal class MS.Win32.Recognizer.RECO_LATTICE_PROPERTY : ValueType {
    public Guid guidProperty;
    public ushort cbPropertyValue;
    public IntPtr pPropertyValue;
}
internal class MS.Win32.Recognizer.RECO_RANGE : ValueType {
    public UInt32 iwcBegin;
    public UInt32 cCount;
}
internal class MS.Win32.Recognizer.RecognizerSafeHandle : SafeHandle {
    public bool IsInvalid { get; }
    private RecognizerSafeHandle(bool ownHandle);
    [ReliabilityContractAttribute("3", "2")]
public virtual bool get_IsInvalid();
    [ReliabilityContractAttribute("3", "2")]
protected virtual bool ReleaseHandle();
}
internal static class MS.Win32.Recognizer.UnsafeNativeMethods : object {
    internal static int CreateRecognizer(Guid& clsid, RecognizerSafeHandle& hRec);
    internal static int DestroyRecognizer(IntPtr hRec);
    internal static int CreateContext(RecognizerSafeHandle hRec, ContextSafeHandle& hRecContext);
    internal static int DestroyContext(IntPtr hRecContext);
    internal static int AddStroke(ContextSafeHandle hRecContext, PACKET_DESCRIPTION& packetDesc, UInt32 cbPackets, IntPtr pByte, XFORM xForm);
    internal static int SetEnabledUnicodeRanges(ContextSafeHandle hRecContext, UInt32 cRangs, CHARACTER_RANGE[] charRanges);
    internal static int EndInkInput(ContextSafeHandle hRecContext);
    internal static int Process(ContextSafeHandle hRecContext, Boolean& partialProcessing);
    internal static int GetAlternateList(ContextSafeHandle hRecContext, RECO_RANGE& recoRange, UInt32& cAlts, IntPtr[] recAtls, ALT_BREAKS breaks);
    internal static int DestroyAlternate(IntPtr hRecAtls);
    internal static int GetString(IntPtr hRecAtls, RECO_RANGE& recoRange, UInt32& size, StringBuilder recoString);
    internal static int GetConfidenceLevel(IntPtr hRecAtls, RECO_RANGE& recoRange, RecognitionConfidence& confidenceLevel);
    internal static int ResetContext(ContextSafeHandle hRecContext);
    internal static int GetLatticePtr(ContextSafeHandle hRecContext, IntPtr& pRecoLattice);
}
[FriendAccessAllowedAttribute]
internal class MS.Win32.SafeSystemMetrics : object {
    internal static int DoubleClickDeltaX { get; }
    internal static int DoubleClickDeltaY { get; }
    internal static int DragDeltaX { get; }
    internal static int DragDeltaY { get; }
    internal static bool IsImmEnabled { get; }
    internal static int get_DoubleClickDeltaX();
    internal static int get_DoubleClickDeltaY();
    internal static int get_DragDeltaX();
    internal static int get_DragDeltaY();
    internal static bool get_IsImmEnabled();
}
internal static class MS.Win32.WinInet : object {
    internal static Uri InternetCacheFolder { get; }
    internal static Uri get_InternetCacheFolder();
}
internal static class System.AppContextDefaultValues : object {
    public static void PopulateDefaultValues();
    private static void ParseTargetFrameworkName(String& identifier, String& profile, Int32& version);
    private static string GetTargetFrameworkMoniker();
    private static bool TryParseFrameworkName(string frameworkName, String& identifier, Int32& version, String& profile);
    private static void PopulateDefaultValuesPartial(string platformIdentifier, string profile, int version);
    private static void InitializeNetFxSwitchDefaultsForNetCoreRuntime();
}
internal static class System.IO.FileHelper : object {
    internal static FileStream CreateAndOpenTemporaryFile(String& filePath, FileAccess fileAccess, FileOptions fileOptions, string extension, string subFolder);
    internal static void DeleteTemporaryFile(string filePath);
}
public static class System.IO.Packaging.PackageStore : object {
    private static HybridDictionary _packages;
    private static object _globalLock;
    private static PackageStore();
    public static Package GetPackage(Uri uri);
    public static void AddPackage(Uri uri, Package package);
    public static void RemovePackage(Uri uri);
    private static void ValidatePackageUri(Uri uri);
}
public class System.IO.Packaging.PackWebRequest : WebRequest {
    private Uri _uri;
    private Uri _innerUri;
    private Uri _partName;
    private WebRequest _webRequest;
    private Package _cacheEntry;
    private bool _respectCachePolicy;
    private bool _cachedPackageIsThreadSafe;
    private RequestCachePolicy _cachePolicy;
    private static RequestCachePolicy _defaultCachePolicy;
    private static Uri _siteOfOriginUri;
    private static Uri _appBaseUri;
    public RequestCachePolicy CachePolicy { get; public set; }
    public string ConnectionGroupName { get; public set; }
    public long ContentLength { get; public set; }
    public string ContentType { get; public set; }
    public ICredentials Credentials { get; public set; }
    public WebHeaderCollection Headers { get; public set; }
    public string Method { get; public set; }
    public bool PreAuthenticate { get; public set; }
    public IWebProxy Proxy { get; public set; }
    public Uri RequestUri { get; }
    public int Timeout { get; public set; }
    public bool UseDefaultCredentials { get; public set; }
    private bool IsCachedPackage { get; }
    private bool IsPreloadedPackage { get; }
    internal PackWebRequest(Uri uri, Uri packageUri, Uri partUri);
    internal PackWebRequest(Uri uri, Uri packageUri, Uri partUri, Package cacheEntry, bool respectCachePolicy, bool cachedPackageIsThreadSafe);
    private static PackWebRequest();
    public virtual Stream GetRequestStream();
    public virtual WebResponse GetResponse();
    public virtual RequestCachePolicy get_CachePolicy();
    public virtual void set_CachePolicy(RequestCachePolicy value);
    public virtual string get_ConnectionGroupName();
    public virtual void set_ConnectionGroupName(string value);
    public virtual long get_ContentLength();
    public virtual void set_ContentLength(long value);
    public virtual string get_ContentType();
    public virtual void set_ContentType(string value);
    public virtual ICredentials get_Credentials();
    public virtual void set_Credentials(ICredentials value);
    public virtual WebHeaderCollection get_Headers();
    public virtual void set_Headers(WebHeaderCollection value);
    public virtual string get_Method();
    public virtual void set_Method(string value);
    public virtual bool get_PreAuthenticate();
    public virtual void set_PreAuthenticate(bool value);
    public virtual IWebProxy get_Proxy();
    public virtual void set_Proxy(IWebProxy value);
    public virtual Uri get_RequestUri();
    public virtual int get_Timeout();
    public virtual void set_Timeout(int value);
    public virtual bool get_UseDefaultCredentials();
    public virtual void set_UseDefaultCredentials(bool value);
    public WebRequest GetInnerRequest();
    private WebRequest GetRequest();
    private WebRequest GetRequest(bool allowPseudoRequest);
    private bool get_IsCachedPackage();
    private bool get_IsPreloadedPackage();
}
public class System.IO.Packaging.PackWebRequestFactory : object {
    private static PackWebRequestFactory _factorySingleton;
    private static PackWebRequestFactory();
    private sealed virtual override WebRequest System.Net.IWebRequestCreate.Create(Uri uri);
    [FriendAccessAllowedAttribute]
internal static WebRequest CreateWebRequest(Uri uri);
}
public class System.IO.Packaging.PackWebResponse : WebResponse {
    private ContentType _mimeType;
    private static int _bufferSize;
    private Uri _uri;
    private Uri _innerUri;
    private Uri _partName;
    private bool _disposed;
    private WebRequest _webRequest;
    private WebResponse _fullResponse;
    private long _fullStreamLength;
    private Stream _responseStream;
    private bool _responseError;
    private Exception _responseException;
    private Timer _timeoutTimer;
    private ManualResetEvent _responseAvailable;
    private bool _lengthAvailable;
    private CachedResponse _cachedResponse;
    private object _lockObject;
    public WebResponse InnerResponse { get; }
    public WebHeaderCollection Headers { get; }
    public Uri ResponseUri { get; }
    public bool IsFromCache { get; }
    public string ContentType { get; }
    public long ContentLength { get; }
    private bool FromPackageCache { get; }
    private static PackWebResponse();
    internal PackWebResponse(Uri uri, Uri innerUri, Uri partName, WebRequest innerRequest);
    internal PackWebResponse(Uri uri, Uri innerUri, Uri partName, Package cacheEntry, bool cachedPackageIsThreadSafe);
    public virtual Stream GetResponseStream();
    public virtual void Close();
    public WebResponse get_InnerResponse();
    public virtual WebHeaderCollection get_Headers();
    public virtual Uri get_ResponseUri();
    public virtual bool get_IsFromCache();
    public virtual string get_ContentType();
    public virtual long get_ContentLength();
    private void AbortResponse();
    protected virtual void Dispose(bool disposing);
    private bool get_FromPackageCache();
    private void CheckDisposed();
    private void ResponseCallback(IAsyncResult ar);
    private void WaitForResponse();
    private void TimeoutCallback(object stateInfo);
}
internal class System.LocalAppContext : object {
    private static TryGetSwitchDelegate TryGetSwitchFromCentralAppContext;
    private static bool s_canForwardCalls;
    private static Dictionary`2<string, bool> s_switchMap;
    private static object s_syncLock;
    [CompilerGeneratedAttribute]
private static bool <DisableCaching>k__BackingField;
    private static bool DisableCaching { get; private set; }
    private static LocalAppContext();
    [CompilerGeneratedAttribute]
private static bool get_DisableCaching();
    [CompilerGeneratedAttribute]
private static void set_DisableCaching(bool value);
    public static bool IsSwitchEnabled(string switchName);
    private static bool IsSwitchEnabledLocal(string switchName);
    private static bool SetupDelegate();
    internal static bool GetCachedSwitchValue(string switchName, Int32& switchValue);
    private static bool GetCachedSwitchValueInternal(string switchName, Int32& switchValue);
    internal static void DefineSwitchDefault(string switchName, bool initialValue);
}
public enum System.Windows.Automation.AutomationLiveSetting : Enum {
    public int value__;
    public static AutomationLiveSetting Off;
    public static AutomationLiveSetting Polite;
    public static AutomationLiveSetting Assertive;
}
public static class System.Windows.Automation.AutomationProperties : object {
    public static DependencyProperty AutomationIdProperty;
    public static DependencyProperty NameProperty;
    public static DependencyProperty HelpTextProperty;
    public static DependencyProperty AcceleratorKeyProperty;
    public static DependencyProperty AccessKeyProperty;
    public static DependencyProperty ItemStatusProperty;
    public static DependencyProperty ItemTypeProperty;
    public static DependencyProperty IsColumnHeaderProperty;
    public static DependencyProperty IsRowHeaderProperty;
    public static DependencyProperty IsRequiredForFormProperty;
    public static DependencyProperty LabeledByProperty;
    public static DependencyProperty IsOffscreenBehaviorProperty;
    public static DependencyProperty LiveSettingProperty;
    public static DependencyProperty PositionInSetProperty;
    public static DependencyProperty SizeOfSetProperty;
    internal static int AutomationPositionInSetDefault;
    internal static int AutomationSizeOfSetDefault;
    private static AutomationProperties();
    public static void SetAutomationId(DependencyObject element, string value);
    public static string GetAutomationId(DependencyObject element);
    public static void SetName(DependencyObject element, string value);
    public static string GetName(DependencyObject element);
    public static void SetHelpText(DependencyObject element, string value);
    public static string GetHelpText(DependencyObject element);
    public static void SetAcceleratorKey(DependencyObject element, string value);
    public static string GetAcceleratorKey(DependencyObject element);
    public static void SetAccessKey(DependencyObject element, string value);
    public static string GetAccessKey(DependencyObject element);
    public static void SetItemStatus(DependencyObject element, string value);
    public static string GetItemStatus(DependencyObject element);
    public static void SetItemType(DependencyObject element, string value);
    public static string GetItemType(DependencyObject element);
    public static void SetIsColumnHeader(DependencyObject element, bool value);
    public static bool GetIsColumnHeader(DependencyObject element);
    public static void SetIsRowHeader(DependencyObject element, bool value);
    public static bool GetIsRowHeader(DependencyObject element);
    public static void SetIsRequiredForForm(DependencyObject element, bool value);
    public static bool GetIsRequiredForForm(DependencyObject element);
    public static void SetLabeledBy(DependencyObject element, UIElement value);
    public static UIElement GetLabeledBy(DependencyObject element);
    public static void SetIsOffscreenBehavior(DependencyObject element, IsOffscreenBehavior value);
    public static IsOffscreenBehavior GetIsOffscreenBehavior(DependencyObject element);
    public static void SetLiveSetting(DependencyObject element, AutomationLiveSetting value);
    public static AutomationLiveSetting GetLiveSetting(DependencyObject element);
    public static void SetPositionInSet(DependencyObject element, int value);
    public static int GetPositionInSet(DependencyObject element);
    public static void SetSizeOfSet(DependencyObject element, int value);
    public static int GetSizeOfSet(DependencyObject element);
    private static bool IsNotNull(object value);
}
public enum System.Windows.Automation.IsOffscreenBehavior : Enum {
    public int value__;
    public static IsOffscreenBehavior Default;
    public static IsOffscreenBehavior Onscreen;
    public static IsOffscreenBehavior Offscreen;
    public static IsOffscreenBehavior FromClip;
}
public enum System.Windows.Automation.Peers.AutomationControlType : Enum {
    public int value__;
    public static AutomationControlType Button;
    public static AutomationControlType Calendar;
    public static AutomationControlType CheckBox;
    public static AutomationControlType ComboBox;
    public static AutomationControlType Edit;
    public static AutomationControlType Hyperlink;
    public static AutomationControlType Image;
    public static AutomationControlType ListItem;
    public static AutomationControlType List;
    public static AutomationControlType Menu;
    public static AutomationControlType MenuBar;
    public static AutomationControlType MenuItem;
    public static AutomationControlType ProgressBar;
    public static AutomationControlType RadioButton;
    public static AutomationControlType ScrollBar;
    public static AutomationControlType Slider;
    public static AutomationControlType Spinner;
    public static AutomationControlType StatusBar;
    public static AutomationControlType Tab;
    public static AutomationControlType TabItem;
    public static AutomationControlType Text;
    public static AutomationControlType ToolBar;
    public static AutomationControlType ToolTip;
    public static AutomationControlType Tree;
    public static AutomationControlType TreeItem;
    public static AutomationControlType Custom;
    public static AutomationControlType Group;
    public static AutomationControlType Thumb;
    public static AutomationControlType DataGrid;
    public static AutomationControlType DataItem;
    public static AutomationControlType Document;
    public static AutomationControlType SplitButton;
    public static AutomationControlType Window;
    public static AutomationControlType Pane;
    public static AutomationControlType Header;
    public static AutomationControlType HeaderItem;
    public static AutomationControlType Table;
    public static AutomationControlType TitleBar;
    public static AutomationControlType Separator;
}
public enum System.Windows.Automation.Peers.AutomationEvents : Enum {
    public int value__;
    public static AutomationEvents ToolTipOpened;
    public static AutomationEvents ToolTipClosed;
    public static AutomationEvents MenuOpened;
    public static AutomationEvents MenuClosed;
    public static AutomationEvents AutomationFocusChanged;
    public static AutomationEvents InvokePatternOnInvoked;
    public static AutomationEvents SelectionItemPatternOnElementAddedToSelection;
    public static AutomationEvents SelectionItemPatternOnElementRemovedFromSelection;
    public static AutomationEvents SelectionItemPatternOnElementSelected;
    public static AutomationEvents SelectionPatternOnInvalidated;
    public static AutomationEvents TextPatternOnTextSelectionChanged;
    public static AutomationEvents TextPatternOnTextChanged;
    public static AutomationEvents AsyncContentLoaded;
    public static AutomationEvents PropertyChanged;
    public static AutomationEvents StructureChanged;
    public static AutomationEvents InputReachedTarget;
    public static AutomationEvents InputReachedOtherElement;
    public static AutomationEvents InputDiscarded;
    public static AutomationEvents LiveRegionChanged;
}
public enum System.Windows.Automation.Peers.AutomationOrientation : Enum {
    public int value__;
    public static AutomationOrientation None;
    public static AutomationOrientation Horizontal;
    public static AutomationOrientation Vertical;
}
public abstract class System.Windows.Automation.Peers.AutomationPeer : DispatcherObject {
    private static Hashtable s_patternInfo;
    private static Hashtable s_propertyInfo;
    private int _index;
    private IntPtr _hwnd;
    private List`1<AutomationPeer> _children;
    private AutomationPeer _parent;
    private object _eventsSourceOrPeerRecord;
    private Rect _boundingRectangle;
    private string _itemStatus;
    private string _name;
    private bool _isOffscreen;
    private bool _isEnabled;
    private bool _invalidated;
    private bool _ancestorsInvalid;
    private bool _childrenValid;
    private bool _addedToEventList;
    private bool _publicCallInProgress;
    private bool _publicSetFocusInProgress;
    private bool _isInteropPeer;
    private bool _hasIterationParent;
    private WeakReference _elementProxyWeakReference;
    private static DispatcherOperationCallback _updatePeer;
    protected internal bool IsHwndHost { get; }
    private AutomationPeer IterationParent { get; private set; }
    public AutomationPeer EventsSource { get; public set; }
    internal IntPtr Hwnd { get; internal set; }
    internal bool AncestorsInvalid { get; internal set; }
    internal bool ChildrenValid { get; internal set; }
    internal bool IsInteropPeer { get; internal set; }
    internal int Index { get; }
    internal List`1<AutomationPeer> Children { get; }
    internal WeakReference ElementProxyWeakReference { get; internal set; }
    internal bool IncludeInvisibleElementsInControlView { get; }
    private static AutomationPeer();
    protected abstract virtual List`1<AutomationPeer> GetChildrenCore();
    public abstract virtual object GetPattern(PatternInterface patternInterface);
    public void InvalidatePeer();
    public static bool ListenerExists(AutomationEvents eventId);
    public void RaiseAutomationEvent(AutomationEvents eventId);
    public void RaisePropertyChangedEvent(AutomationProperty property, object oldValue, object newValue);
    public void RaiseAsyncContentLoadedEvent(AsyncContentLoadedEventArgs args);
    internal static void RaiseFocusChangedEventHelper(IInputElement newFocus);
    internal static AutomationPeer AutomationPeerFromInputElement(IInputElement focusedElement);
    internal AutomationPeer ValidateConnected(AutomationPeer connectedPeer);
    internal bool TrySetParentInfo(AutomationPeer peer);
    internal virtual bool IsDataItemAutomationPeer();
    internal virtual bool IgnoreUpdatePeer();
    internal virtual void AddToParentProxyWeakRefCache();
    private bool isDescendantOf(AutomationPeer parent);
    protected virtual HostedWindowWrapper GetHostRawElementProviderCore();
    internal HostedWindowWrapper GetHostRawElementProvider();
    protected internal virtual bool get_IsHwndHost();
    protected abstract virtual Rect GetBoundingRectangleCore();
    protected abstract virtual bool IsOffscreenCore();
    protected abstract virtual AutomationOrientation GetOrientationCore();
    protected abstract virtual string GetItemTypeCore();
    protected abstract virtual string GetClassNameCore();
    protected abstract virtual string GetItemStatusCore();
    protected abstract virtual bool IsRequiredForFormCore();
    protected abstract virtual bool IsKeyboardFocusableCore();
    protected abstract virtual bool HasKeyboardFocusCore();
    protected abstract virtual bool IsEnabledCore();
    protected abstract virtual bool IsPasswordCore();
    protected abstract virtual string GetAutomationIdCore();
    protected abstract virtual string GetNameCore();
    protected abstract virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetLocalizedControlTypeCore();
    protected abstract virtual bool IsContentElementCore();
    protected abstract virtual bool IsControlElementCore();
    protected abstract virtual AutomationPeer GetLabeledByCore();
    protected abstract virtual string GetHelpTextCore();
    protected abstract virtual string GetAcceleratorKeyCore();
    protected abstract virtual string GetAccessKeyCore();
    protected abstract virtual Point GetClickablePointCore();
    protected abstract virtual void SetFocusCore();
    protected virtual AutomationLiveSetting GetLiveSettingCore();
    protected virtual List`1<AutomationPeer> GetControlledPeersCore();
    protected virtual int GetSizeOfSetCore();
    protected virtual int GetPositionInSetCore();
    internal virtual Rect GetVisibleBoundingRectCore();
    public Rect GetBoundingRectangle();
    public bool IsOffscreen();
    public AutomationOrientation GetOrientation();
    public string GetItemType();
    public string GetClassName();
    public string GetItemStatus();
    public bool IsRequiredForForm();
    public bool IsKeyboardFocusable();
    public bool HasKeyboardFocus();
    public bool IsEnabled();
    public bool IsPassword();
    public string GetAutomationId();
    public string GetName();
    public AutomationControlType GetAutomationControlType();
    public string GetLocalizedControlType();
    public bool IsContentElement();
    public bool IsControlElement();
    private bool IsControlElementPrivate();
    public AutomationPeer GetLabeledBy();
    public string GetHelpText();
    public string GetAcceleratorKey();
    public string GetAccessKey();
    public Point GetClickablePoint();
    public void SetFocus();
    public AutomationLiveSetting GetLiveSetting();
    public List`1<AutomationPeer> GetControlledPeers();
    private IRawElementProviderSimple[] GetControllerForProviderArray();
    public int GetSizeOfSet();
    public int GetPositionInSet();
    public AutomationPeer GetParent();
    public List`1<AutomationPeer> GetChildren();
    public void ResetChildrenCache();
    internal Int32[] GetRuntimeId();
    internal string GetFrameworkId();
    internal AutomationPeer GetFirstChild();
    private void EnsureChildren();
    internal void ForceEnsureChildren();
    internal AutomationPeer GetLastChild();
    [FriendAccessAllowedAttribute]
internal virtual InteropAutomationProvider GetInteropChild();
    internal AutomationPeer GetNextSibling();
    internal AutomationPeer GetPreviousSibling();
    private void ChooseIterationParent(AutomationPeer caller);
    private AutomationPeer get_IterationParent();
    private void set_IterationParent(AutomationPeer value);
    internal ControlType GetControlType();
    public AutomationPeer GetPeerFromPoint(Point point);
    protected virtual AutomationPeer GetPeerFromPointCore(Point point);
    internal Rect GetVisibleBoundingRect();
    protected internal IRawElementProviderSimple ProviderFromPeer(AutomationPeer peer);
    private IRawElementProviderSimple ProviderFromPeerNoDelegation(AutomationPeer peer);
    public AutomationPeer get_EventsSource();
    public void set_EventsSource(AutomationPeer value);
    protected AutomationPeer PeerFromProvider(IRawElementProviderSimple provider);
    internal void FireAutomationEvents();
    private void RaisePropertyChangedInternal(IRawElementProviderSimple provider, AutomationProperty propertyId, object oldValue, object newValue);
    internal void UpdateChildrenInternal(int invalidateLimit);
    internal virtual IDisposable UpdateChildren();
    [FriendAccessAllowedAttribute]
internal void UpdateSubtree();
    internal void InvalidateAncestorsRecursive();
    private static object UpdatePeer(object arg);
    internal void AddToAutomationEventList();
    internal IntPtr get_Hwnd();
    internal void set_Hwnd(IntPtr value);
    internal object GetWrappedPattern(int patternId);
    internal object GetPropertyValue(int propertyId);
    internal virtual bool get_AncestorsInvalid();
    internal virtual void set_AncestorsInvalid(bool value);
    internal bool get_ChildrenValid();
    internal void set_ChildrenValid(bool value);
    internal bool get_IsInteropPeer();
    internal void set_IsInteropPeer(bool value);
    internal int get_Index();
    internal List`1<AutomationPeer> get_Children();
    internal WeakReference get_ElementProxyWeakReference();
    internal void set_ElementProxyWeakReference(WeakReference value);
    internal bool get_IncludeInvisibleElementsInControlView();
    private static void Initialize();
    private static object IsControlElement(AutomationPeer peer);
    private static object GetControlType(AutomationPeer peer);
    private static object IsContentElement(AutomationPeer peer);
    private static object GetLabeledBy(AutomationPeer peer);
    private static object GetNativeWindowHandle(AutomationPeer peer);
    private static object GetAutomationId(AutomationPeer peer);
    private static object GetItemType(AutomationPeer peer);
    private static object IsPassword(AutomationPeer peer);
    private static object GetLocalizedControlType(AutomationPeer peer);
    private static object GetName(AutomationPeer peer);
    private static object GetAcceleratorKey(AutomationPeer peer);
    private static object GetAccessKey(AutomationPeer peer);
    private static object HasKeyboardFocus(AutomationPeer peer);
    private static object IsKeyboardFocusable(AutomationPeer peer);
    private static object IsEnabled(AutomationPeer peer);
    private static object GetBoundingRectangle(AutomationPeer peer);
    private static object GetCurrentProcessId(AutomationPeer peer);
    private static object GetRuntimeId(AutomationPeer peer);
    private static object GetClassName(AutomationPeer peer);
    private static object GetHelpText(AutomationPeer peer);
    private static object GetClickablePoint(AutomationPeer peer);
    private static object GetCultureInfo(AutomationPeer peer);
    private static object IsOffscreen(AutomationPeer peer);
    private static object GetOrientation(AutomationPeer peer);
    private static object GetFrameworkId(AutomationPeer peer);
    private static object IsRequiredForForm(AutomationPeer peer);
    private static object GetItemStatus(AutomationPeer peer);
    private static object GetLiveSetting(AutomationPeer peer);
    private static object GetControllerFor(AutomationPeer peer);
    private static object GetSizeOfSet(AutomationPeer peer);
    private static object GetPositionInSet(AutomationPeer peer);
}
public class System.Windows.Automation.Peers.ContentElementAutomationPeer : AutomationPeer {
    private ContentElement _owner;
    private SynchronizedInputAdaptor _synchronizedInputPattern;
    public ContentElement Owner { get; }
    public ContentElementAutomationPeer(ContentElement owner);
    public ContentElement get_Owner();
    public static AutomationPeer CreatePeerForElement(ContentElement element);
    public static AutomationPeer FromElement(ContentElement element);
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetAutomationIdCore();
    protected virtual string GetNameCore();
    protected virtual string GetHelpTextCore();
    protected virtual Rect GetBoundingRectangleCore();
    protected virtual bool IsOffscreenCore();
    protected virtual AutomationOrientation GetOrientationCore();
    protected virtual string GetItemTypeCore();
    protected virtual string GetClassNameCore();
    protected virtual string GetItemStatusCore();
    protected virtual bool IsRequiredForFormCore();
    protected virtual bool IsKeyboardFocusableCore();
    protected virtual bool HasKeyboardFocusCore();
    protected virtual bool IsEnabledCore();
    protected virtual bool IsPasswordCore();
    protected virtual bool IsContentElementCore();
    protected virtual bool IsControlElementCore();
    protected virtual AutomationPeer GetLabeledByCore();
    protected virtual string GetAcceleratorKeyCore();
    protected virtual string GetAccessKeyCore();
    protected virtual AutomationLiveSetting GetLiveSettingCore();
    protected virtual int GetPositionInSetCore();
    protected virtual int GetSizeOfSetCore();
    protected virtual Point GetClickablePointCore();
    protected virtual void SetFocusCore();
    internal virtual Rect GetVisibleBoundingRectCore();
}
public class System.Windows.Automation.Peers.GenericRootAutomationPeer : UIElementAutomationPeer {
    public GenericRootAutomationPeer(UIElement owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetNameCore();
    protected virtual Rect GetBoundingRectangleCore();
}
public class System.Windows.Automation.Peers.HostedWindowWrapper : object {
    private IntPtr _hwnd;
    internal IntPtr Handle { get; }
    public HostedWindowWrapper(IntPtr hwnd);
    internal static HostedWindowWrapper CreateInternal(IntPtr hwnd);
    internal IntPtr get_Handle();
}
public enum System.Windows.Automation.Peers.PatternInterface : Enum {
    public int value__;
    public static PatternInterface Invoke;
    public static PatternInterface Selection;
    public static PatternInterface Value;
    public static PatternInterface RangeValue;
    public static PatternInterface Scroll;
    public static PatternInterface ScrollItem;
    public static PatternInterface ExpandCollapse;
    public static PatternInterface Grid;
    public static PatternInterface GridItem;
    public static PatternInterface MultipleView;
    public static PatternInterface Window;
    public static PatternInterface SelectionItem;
    public static PatternInterface Dock;
    public static PatternInterface Table;
    public static PatternInterface TableItem;
    public static PatternInterface Toggle;
    public static PatternInterface Transform;
    public static PatternInterface Text;
    public static PatternInterface ItemContainer;
    public static PatternInterface VirtualizedItem;
    public static PatternInterface SynchronizedInput;
}
public class System.Windows.Automation.Peers.UIElement3DAutomationPeer : AutomationPeer {
    private UIElement3D _owner;
    private SynchronizedInputAdaptor _synchronizedInputPattern;
    public UIElement3D Owner { get; }
    public UIElement3DAutomationPeer(UIElement3D owner);
    public UIElement3D get_Owner();
    public static AutomationPeer CreatePeerForElement(UIElement3D element);
    public static AutomationPeer FromElement(UIElement3D element);
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    private static bool iterate(DependencyObject parent, IteratorCallback callback);
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetAutomationIdCore();
    protected virtual string GetNameCore();
    protected virtual string GetHelpTextCore();
    protected virtual Rect GetBoundingRectangleCore();
    private bool ComputeBoundingRectangle(Rect& rect);
    protected virtual bool IsOffscreenCore();
    private static UIElement GetContainingUIElement(DependencyObject reference);
    protected virtual AutomationOrientation GetOrientationCore();
    protected virtual string GetItemTypeCore();
    protected virtual string GetClassNameCore();
    protected virtual string GetItemStatusCore();
    protected virtual bool IsRequiredForFormCore();
    protected virtual bool IsKeyboardFocusableCore();
    protected virtual bool HasKeyboardFocusCore();
    protected virtual bool IsEnabledCore();
    protected virtual bool IsPasswordCore();
    protected virtual bool IsContentElementCore();
    protected virtual bool IsControlElementCore();
    protected virtual AutomationPeer GetLabeledByCore();
    protected virtual string GetAcceleratorKeyCore();
    protected virtual string GetAccessKeyCore();
    protected virtual AutomationLiveSetting GetLiveSettingCore();
    protected virtual int GetPositionInSetCore();
    protected virtual int GetSizeOfSetCore();
    protected virtual Point GetClickablePointCore();
    protected virtual void SetFocusCore();
    internal virtual Rect GetVisibleBoundingRectCore();
}
public class System.Windows.Automation.Peers.UIElementAutomationPeer : AutomationPeer {
    private UIElement _owner;
    private SynchronizedInputAdaptor _synchronizedInputPattern;
    public UIElement Owner { get; }
    public UIElementAutomationPeer(UIElement owner);
    public UIElement get_Owner();
    public static AutomationPeer CreatePeerForElement(UIElement element);
    public static AutomationPeer FromElement(UIElement element);
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    internal static AutomationPeer GetRootAutomationPeer(Visual rootVisual, IntPtr hwnd);
    private static bool iterate(DependencyObject parent, IteratorCallback callback);
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetAutomationIdCore();
    protected virtual string GetNameCore();
    protected virtual string GetHelpTextCore();
    protected virtual Rect GetBoundingRectangleCore();
    internal virtual Rect GetVisibleBoundingRectCore();
    protected virtual bool IsOffscreenCore();
    internal static Rect CalculateVisibleBoundingRect(UIElement owner);
    protected virtual AutomationOrientation GetOrientationCore();
    protected virtual string GetItemTypeCore();
    protected virtual string GetClassNameCore();
    protected virtual string GetItemStatusCore();
    protected virtual bool IsRequiredForFormCore();
    protected virtual bool IsKeyboardFocusableCore();
    protected virtual bool HasKeyboardFocusCore();
    protected virtual bool IsEnabledCore();
    protected virtual bool IsPasswordCore();
    protected virtual bool IsContentElementCore();
    protected virtual bool IsControlElementCore();
    protected virtual AutomationPeer GetLabeledByCore();
    protected virtual string GetAcceleratorKeyCore();
    protected virtual string GetAccessKeyCore();
    protected virtual AutomationLiveSetting GetLiveSettingCore();
    protected virtual int GetPositionInSetCore();
    protected virtual int GetSizeOfSetCore();
    protected virtual Point GetClickablePointCore();
    protected virtual void SetFocusCore();
}
public class System.Windows.AutoResizedEventArgs : EventArgs {
    private Size _size;
    public Size Size { get; }
    public AutoResizedEventArgs(Size size);
    public Size get_Size();
}
public class System.Windows.AutoResizedEventHandler : MulticastDelegate {
    public AutoResizedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, AutoResizedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, AutoResizedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Windows.BaselineAlignment : Enum {
    public int value__;
    public static BaselineAlignment Top;
    public static BaselineAlignment Center;
    public static BaselineAlignment Bottom;
    public static BaselineAlignment Baseline;
    public static BaselineAlignment TextTop;
    public static BaselineAlignment TextBottom;
    public static BaselineAlignment Subscript;
    public static BaselineAlignment Superscript;
}
internal class System.Windows.ClassHandlers : ValueType {
    internal RoutedEvent RoutedEvent;
    internal RoutedEventHandlerInfoList Handlers;
    internal bool HasSelfHandlers;
    public virtual bool Equals(object o);
    public bool Equals(ClassHandlers classHandlers);
    public virtual int GetHashCode();
    public static bool op_Equality(ClassHandlers classHandlers1, ClassHandlers classHandlers2);
    public static bool op_Inequality(ClassHandlers classHandlers1, ClassHandlers classHandlers2);
}
internal class System.Windows.ClassHandlersStore : object {
    private ItemStructList`1<ClassHandlers> _eventHandlersList;
    internal ClassHandlersStore(int size);
    internal RoutedEventHandlerInfoList AddToExistingHandlers(int index, Delegate handler, bool handledEventsToo);
    internal RoutedEventHandlerInfoList GetExistingHandlers(int index);
    internal int CreateHandlersLink(RoutedEvent routedEvent, RoutedEventHandlerInfoList handlers);
    internal void UpdateSubClassHandlers(RoutedEvent routedEvent, RoutedEventHandlerInfoList baseClassListeners);
    internal int GetHandlersIndex(RoutedEvent routedEvent);
}
public static class System.Windows.Clipboard : object {
    private static int OleRetryCount;
    private static int OleRetryDelay;
    private static int OleFlushDelay;
    private static int _isDeviceGuardEnabled;
    private static bool IsDeviceGuardEnabled { get; }
    public static void Clear();
    public static bool ContainsAudio();
    public static bool ContainsData(string format);
    public static bool ContainsFileDropList();
    public static bool ContainsImage();
    public static bool ContainsText();
    public static bool ContainsText(TextDataFormat format);
    public static void Flush();
    public static Stream GetAudioStream();
    public static object GetData(string format);
    public static StringCollection GetFileDropList();
    public static BitmapSource GetImage();
    public static string GetText();
    public static string GetText(TextDataFormat format);
    public static void SetAudio(Byte[] audioBytes);
    public static void SetAudio(Stream audioStream);
    public static void SetData(string format, object data);
    public static void SetFileDropList(StringCollection fileDropList);
    public static void SetImage(BitmapSource image);
    public static void SetText(string text);
    public static void SetText(string text, TextDataFormat format);
    public static IDataObject GetDataObject();
    public static bool IsCurrent(IDataObject data);
    public static void SetDataObject(object data);
    public static void SetDataObject(object data, bool copy);
    [FriendAccessAllowedAttribute]
internal static void CriticalSetDataObject(object data, bool copy);
    [FriendAccessAllowedAttribute]
internal static bool IsClipboardPopulated();
    private static bool get_IsDeviceGuardEnabled();
    private static bool IsDynamicCodePolicyEnabled();
    private static IDataObject GetDataObjectInternal();
    private static bool ContainsDataInternal(string format);
    private static object GetDataInternal(string format);
    private static void SetDataInternal(string format, object data);
    private static bool IsDataFormatAutoConvert(string format);
}
public class System.Windows.ContentElement : DependencyObject {
    private static Type _typeofThis;
    public static RoutedEvent PreviewMouseDownEvent;
    public static RoutedEvent MouseDownEvent;
    public static RoutedEvent PreviewMouseUpEvent;
    public static RoutedEvent MouseUpEvent;
    public static RoutedEvent PreviewMouseLeftButtonDownEvent;
    public static RoutedEvent MouseLeftButtonDownEvent;
    public static RoutedEvent PreviewMouseLeftButtonUpEvent;
    public static RoutedEvent MouseLeftButtonUpEvent;
    public static RoutedEvent PreviewMouseRightButtonDownEvent;
    public static RoutedEvent MouseRightButtonDownEvent;
    public static RoutedEvent PreviewMouseRightButtonUpEvent;
    public static RoutedEvent MouseRightButtonUpEvent;
    public static RoutedEvent PreviewMouseMoveEvent;
    public static RoutedEvent MouseMoveEvent;
    public static RoutedEvent PreviewMouseWheelEvent;
    public static RoutedEvent MouseWheelEvent;
    public static RoutedEvent MouseEnterEvent;
    public static RoutedEvent MouseLeaveEvent;
    public static RoutedEvent GotMouseCaptureEvent;
    public static RoutedEvent LostMouseCaptureEvent;
    public static RoutedEvent QueryCursorEvent;
    public static RoutedEvent PreviewStylusDownEvent;
    public static RoutedEvent StylusDownEvent;
    public static RoutedEvent PreviewStylusUpEvent;
    public static RoutedEvent StylusUpEvent;
    public static RoutedEvent PreviewStylusMoveEvent;
    public static RoutedEvent StylusMoveEvent;
    public static RoutedEvent PreviewStylusInAirMoveEvent;
    public static RoutedEvent StylusInAirMoveEvent;
    public static RoutedEvent StylusEnterEvent;
    public static RoutedEvent StylusLeaveEvent;
    public static RoutedEvent PreviewStylusInRangeEvent;
    public static RoutedEvent StylusInRangeEvent;
    public static RoutedEvent PreviewStylusOutOfRangeEvent;
    public static RoutedEvent StylusOutOfRangeEvent;
    public static RoutedEvent PreviewStylusSystemGestureEvent;
    public static RoutedEvent StylusSystemGestureEvent;
    public static RoutedEvent GotStylusCaptureEvent;
    public static RoutedEvent LostStylusCaptureEvent;
    public static RoutedEvent StylusButtonDownEvent;
    public static RoutedEvent StylusButtonUpEvent;
    public static RoutedEvent PreviewStylusButtonDownEvent;
    public static RoutedEvent PreviewStylusButtonUpEvent;
    public static RoutedEvent PreviewKeyDownEvent;
    public static RoutedEvent KeyDownEvent;
    public static RoutedEvent PreviewKeyUpEvent;
    public static RoutedEvent KeyUpEvent;
    public static RoutedEvent PreviewGotKeyboardFocusEvent;
    public static RoutedEvent GotKeyboardFocusEvent;
    public static RoutedEvent PreviewLostKeyboardFocusEvent;
    public static RoutedEvent LostKeyboardFocusEvent;
    public static RoutedEvent PreviewTextInputEvent;
    public static RoutedEvent TextInputEvent;
    public static RoutedEvent PreviewQueryContinueDragEvent;
    public static RoutedEvent QueryContinueDragEvent;
    public static RoutedEvent PreviewGiveFeedbackEvent;
    public static RoutedEvent GiveFeedbackEvent;
    public static RoutedEvent PreviewDragEnterEvent;
    public static RoutedEvent DragEnterEvent;
    public static RoutedEvent PreviewDragOverEvent;
    public static RoutedEvent DragOverEvent;
    public static RoutedEvent PreviewDragLeaveEvent;
    public static RoutedEvent DragLeaveEvent;
    public static RoutedEvent PreviewDropEvent;
    public static RoutedEvent DropEvent;
    public static RoutedEvent PreviewTouchDownEvent;
    public static RoutedEvent TouchDownEvent;
    public static RoutedEvent PreviewTouchMoveEvent;
    public static RoutedEvent TouchMoveEvent;
    public static RoutedEvent PreviewTouchUpEvent;
    public static RoutedEvent TouchUpEvent;
    public static RoutedEvent GotTouchCaptureEvent;
    public static RoutedEvent LostTouchCaptureEvent;
    public static RoutedEvent TouchEnterEvent;
    public static RoutedEvent TouchLeaveEvent;
    public static DependencyProperty IsMouseDirectlyOverProperty;
    public static DependencyProperty IsMouseOverProperty;
    public static DependencyProperty IsStylusOverProperty;
    public static DependencyProperty IsKeyboardFocusWithinProperty;
    public static DependencyProperty IsMouseCapturedProperty;
    public static DependencyProperty IsMouseCaptureWithinProperty;
    public static DependencyProperty IsStylusDirectlyOverProperty;
    public static DependencyProperty IsStylusCapturedProperty;
    public static DependencyProperty IsStylusCaptureWithinProperty;
    public static DependencyProperty IsKeyboardFocusedProperty;
    public static DependencyProperty AreAnyTouchesDirectlyOverProperty;
    public static DependencyProperty AreAnyTouchesOverProperty;
    public static DependencyProperty AreAnyTouchesCapturedProperty;
    public static DependencyProperty AreAnyTouchesCapturedWithinProperty;
    private CoreFlags _flags;
    public static RoutedEvent GotFocusEvent;
    public static RoutedEvent LostFocusEvent;
    public static DependencyProperty IsFocusedProperty;
    public static DependencyProperty IsEnabledProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty FocusableProperty;
    public static DependencyProperty AllowDropProperty;
    internal DependencyObject _parent;
    internal static UncommonField`1<EventHandlersStore> EventHandlersStoreField;
    internal static UncommonField`1<InputBindingCollection> InputBindingCollectionField;
    internal static UncommonField`1<CommandBindingCollection> CommandBindingCollectionField;
    private static UncommonField`1<AutomationPeer> AutomationPeerField;
    private static DependencyObjectType ContentElementType;
    public bool HasAnimatedProperties { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public InputBindingCollection InputBindings { get; }
    internal InputBindingCollection InputBindingsInternal { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public CommandBindingCollection CommandBindings { get; }
    internal CommandBindingCollection CommandBindingsInternal { get; }
    internal EventHandlersStore EventHandlersStore { get; }
    internal DependencyObject Parent { get; }
    public bool IsMouseDirectlyOver { get; }
    public bool IsMouseOver { get; }
    public bool IsStylusOver { get; }
    public bool IsKeyboardFocusWithin { get; }
    public bool IsMouseCaptured { get; }
    public bool IsMouseCaptureWithin { get; }
    public bool IsStylusDirectlyOver { get; }
    public bool IsStylusCaptured { get; }
    public bool IsStylusCaptureWithin { get; }
    public bool IsKeyboardFocused { get; }
    public bool IsFocused { get; }
    public bool IsEnabled { get; public set; }
    protected bool IsEnabledCore { get; }
    public bool Focusable { get; public set; }
    public bool IsInputMethodEnabled { get; }
    public bool AllowDrop { get; public set; }
    public bool AreAnyTouchesOver { get; }
    public bool AreAnyTouchesDirectlyOver { get; }
    public bool AreAnyTouchesCapturedWithin { get; }
    public bool AreAnyTouchesCaptured { get; }
    public IEnumerable`1<TouchDevice> TouchesCaptured { get; }
    public IEnumerable`1<TouchDevice> TouchesCapturedWithin { get; }
    public IEnumerable`1<TouchDevice> TouchesOver { get; }
    public IEnumerable`1<TouchDevice> TouchesDirectlyOver { get; }
    internal bool HasAutomationPeer { get; internal set; }
    private static ContentElement();
    public sealed virtual void ApplyAnimationClock(DependencyProperty dp, AnimationClock clock);
    public sealed virtual void ApplyAnimationClock(DependencyProperty dp, AnimationClock clock, HandoffBehavior handoffBehavior);
    public sealed virtual void BeginAnimation(DependencyProperty dp, AnimationTimeline animation);
    public sealed virtual void BeginAnimation(DependencyProperty dp, AnimationTimeline animation, HandoffBehavior handoffBehavior);
    public sealed virtual bool get_HasAnimatedProperties();
    public sealed virtual object GetAnimationBaseValue(DependencyProperty dp);
    internal sealed virtual void EvaluateAnimatedValueCore(DependencyProperty dp, PropertyMetadata metadata, EffectiveValueEntry& entry);
    public InputBindingCollection get_InputBindings();
    internal InputBindingCollection get_InputBindingsInternal();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeInputBindings();
    public CommandBindingCollection get_CommandBindings();
    internal CommandBindingCollection get_CommandBindingsInternal();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeCommandBindings();
    internal virtual bool BuildRouteCore(EventRoute route, RoutedEventArgs args);
    internal void BuildRoute(EventRoute route, RoutedEventArgs args);
    public sealed virtual void RaiseEvent(RoutedEventArgs e);
    internal void RaiseEvent(RoutedEventArgs args, bool trusted);
    internal void RaiseTrustedEvent(RoutedEventArgs args);
    internal virtual object AdjustEventSource(RoutedEventArgs args);
    public sealed virtual void AddHandler(RoutedEvent routedEvent, Delegate handler);
    public void AddHandler(RoutedEvent routedEvent, Delegate handler, bool handledEventsToo);
    internal virtual void OnAddHandler(RoutedEvent routedEvent, Delegate handler);
    public sealed virtual void RemoveHandler(RoutedEvent routedEvent, Delegate handler);
    internal virtual void OnRemoveHandler(RoutedEvent routedEvent, Delegate handler);
    private void EventHandlersStoreAdd(EventPrivateKey key, Delegate handler);
    private void EventHandlersStoreRemove(EventPrivateKey key, Delegate handler);
    public void AddToEventRoute(EventRoute route, RoutedEventArgs e);
    internal virtual void AddToEventRouteCore(EventRoute route, RoutedEventArgs args);
    [FriendAccessAllowedAttribute]
internal EventHandlersStore get_EventHandlersStore();
    [FriendAccessAllowedAttribute]
internal void EnsureEventHandlersStore();
    internal virtual bool InvalidateAutomationAncestorsCore(Stack`1<DependencyObject> branchNodeStack, Boolean& continuePastVisualTree);
    private static void RegisterProperties();
    public void add_PreviewMouseDown(MouseButtonEventHandler value);
    public void remove_PreviewMouseDown(MouseButtonEventHandler value);
    protected internal virtual void OnPreviewMouseDown(MouseButtonEventArgs e);
    public void add_MouseDown(MouseButtonEventHandler value);
    public void remove_MouseDown(MouseButtonEventHandler value);
    protected internal virtual void OnMouseDown(MouseButtonEventArgs e);
    public void add_PreviewMouseUp(MouseButtonEventHandler value);
    public void remove_PreviewMouseUp(MouseButtonEventHandler value);
    protected internal virtual void OnPreviewMouseUp(MouseButtonEventArgs e);
    public void add_MouseUp(MouseButtonEventHandler value);
    public void remove_MouseUp(MouseButtonEventHandler value);
    protected internal virtual void OnMouseUp(MouseButtonEventArgs e);
    public sealed virtual void add_PreviewMouseLeftButtonDown(MouseButtonEventHandler value);
    public sealed virtual void remove_PreviewMouseLeftButtonDown(MouseButtonEventHandler value);
    protected internal virtual void OnPreviewMouseLeftButtonDown(MouseButtonEventArgs e);
    public sealed virtual void add_MouseLeftButtonDown(MouseButtonEventHandler value);
    public sealed virtual void remove_MouseLeftButtonDown(MouseButtonEventHandler value);
    protected internal virtual void OnMouseLeftButtonDown(MouseButtonEventArgs e);
    public sealed virtual void add_PreviewMouseLeftButtonUp(MouseButtonEventHandler value);
    public sealed virtual void remove_PreviewMouseLeftButtonUp(MouseButtonEventHandler value);
    protected internal virtual void OnPreviewMouseLeftButtonUp(MouseButtonEventArgs e);
    public sealed virtual void add_MouseLeftButtonUp(MouseButtonEventHandler value);
    public sealed virtual void remove_MouseLeftButtonUp(MouseButtonEventHandler value);
    protected internal virtual void OnMouseLeftButtonUp(MouseButtonEventArgs e);
    public sealed virtual void add_PreviewMouseRightButtonDown(MouseButtonEventHandler value);
    public sealed virtual void remove_PreviewMouseRightButtonDown(MouseButtonEventHandler value);
    protected internal virtual void OnPreviewMouseRightButtonDown(MouseButtonEventArgs e);
    public sealed virtual void add_MouseRightButtonDown(MouseButtonEventHandler value);
    public sealed virtual void remove_MouseRightButtonDown(MouseButtonEventHandler value);
    protected internal virtual void OnMouseRightButtonDown(MouseButtonEventArgs e);
    public sealed virtual void add_PreviewMouseRightButtonUp(MouseButtonEventHandler value);
    public sealed virtual void remove_PreviewMouseRightButtonUp(MouseButtonEventHandler value);
    protected internal virtual void OnPreviewMouseRightButtonUp(MouseButtonEventArgs e);
    public sealed virtual void add_MouseRightButtonUp(MouseButtonEventHandler value);
    public sealed virtual void remove_MouseRightButtonUp(MouseButtonEventHandler value);
    protected internal virtual void OnMouseRightButtonUp(MouseButtonEventArgs e);
    public sealed virtual void add_PreviewMouseMove(MouseEventHandler value);
    public sealed virtual void remove_PreviewMouseMove(MouseEventHandler value);
    protected internal virtual void OnPreviewMouseMove(MouseEventArgs e);
    public sealed virtual void add_MouseMove(MouseEventHandler value);
    public sealed virtual void remove_MouseMove(MouseEventHandler value);
    protected internal virtual void OnMouseMove(MouseEventArgs e);
    public sealed virtual void add_PreviewMouseWheel(MouseWheelEventHandler value);
    public sealed virtual void remove_PreviewMouseWheel(MouseWheelEventHandler value);
    protected internal virtual void OnPreviewMouseWheel(MouseWheelEventArgs e);
    public sealed virtual void add_MouseWheel(MouseWheelEventHandler value);
    public sealed virtual void remove_MouseWheel(MouseWheelEventHandler value);
    protected internal virtual void OnMouseWheel(MouseWheelEventArgs e);
    public sealed virtual void add_MouseEnter(MouseEventHandler value);
    public sealed virtual void remove_MouseEnter(MouseEventHandler value);
    protected internal virtual void OnMouseEnter(MouseEventArgs e);
    public sealed virtual void add_MouseLeave(MouseEventHandler value);
    public sealed virtual void remove_MouseLeave(MouseEventHandler value);
    protected internal virtual void OnMouseLeave(MouseEventArgs e);
    public sealed virtual void add_GotMouseCapture(MouseEventHandler value);
    public sealed virtual void remove_GotMouseCapture(MouseEventHandler value);
    protected internal virtual void OnGotMouseCapture(MouseEventArgs e);
    public sealed virtual void add_LostMouseCapture(MouseEventHandler value);
    public sealed virtual void remove_LostMouseCapture(MouseEventHandler value);
    protected internal virtual void OnLostMouseCapture(MouseEventArgs e);
    public void add_QueryCursor(QueryCursorEventHandler value);
    public void remove_QueryCursor(QueryCursorEventHandler value);
    protected internal virtual void OnQueryCursor(QueryCursorEventArgs e);
    public sealed virtual void add_PreviewStylusDown(StylusDownEventHandler value);
    public sealed virtual void remove_PreviewStylusDown(StylusDownEventHandler value);
    protected internal virtual void OnPreviewStylusDown(StylusDownEventArgs e);
    public sealed virtual void add_StylusDown(StylusDownEventHandler value);
    public sealed virtual void remove_StylusDown(StylusDownEventHandler value);
    protected internal virtual void OnStylusDown(StylusDownEventArgs e);
    public sealed virtual void add_PreviewStylusUp(StylusEventHandler value);
    public sealed virtual void remove_PreviewStylusUp(StylusEventHandler value);
    protected internal virtual void OnPreviewStylusUp(StylusEventArgs e);
    public sealed virtual void add_StylusUp(StylusEventHandler value);
    public sealed virtual void remove_StylusUp(StylusEventHandler value);
    protected internal virtual void OnStylusUp(StylusEventArgs e);
    public sealed virtual void add_PreviewStylusMove(StylusEventHandler value);
    public sealed virtual void remove_PreviewStylusMove(StylusEventHandler value);
    protected internal virtual void OnPreviewStylusMove(StylusEventArgs e);
    public sealed virtual void add_StylusMove(StylusEventHandler value);
    public sealed virtual void remove_StylusMove(StylusEventHandler value);
    protected internal virtual void OnStylusMove(StylusEventArgs e);
    public sealed virtual void add_PreviewStylusInAirMove(StylusEventHandler value);
    public sealed virtual void remove_PreviewStylusInAirMove(StylusEventHandler value);
    protected internal virtual void OnPreviewStylusInAirMove(StylusEventArgs e);
    public sealed virtual void add_StylusInAirMove(StylusEventHandler value);
    public sealed virtual void remove_StylusInAirMove(StylusEventHandler value);
    protected internal virtual void OnStylusInAirMove(StylusEventArgs e);
    public sealed virtual void add_StylusEnter(StylusEventHandler value);
    public sealed virtual void remove_StylusEnter(StylusEventHandler value);
    protected internal virtual void OnStylusEnter(StylusEventArgs e);
    public sealed virtual void add_StylusLeave(StylusEventHandler value);
    public sealed virtual void remove_StylusLeave(StylusEventHandler value);
    protected internal virtual void OnStylusLeave(StylusEventArgs e);
    public sealed virtual void add_PreviewStylusInRange(StylusEventHandler value);
    public sealed virtual void remove_PreviewStylusInRange(StylusEventHandler value);
    protected internal virtual void OnPreviewStylusInRange(StylusEventArgs e);
    public sealed virtual void add_StylusInRange(StylusEventHandler value);
    public sealed virtual void remove_StylusInRange(StylusEventHandler value);
    protected internal virtual void OnStylusInRange(StylusEventArgs e);
    public sealed virtual void add_PreviewStylusOutOfRange(StylusEventHandler value);
    public sealed virtual void remove_PreviewStylusOutOfRange(StylusEventHandler value);
    protected internal virtual void OnPreviewStylusOutOfRange(StylusEventArgs e);
    public sealed virtual void add_StylusOutOfRange(StylusEventHandler value);
    public sealed virtual void remove_StylusOutOfRange(StylusEventHandler value);
    protected internal virtual void OnStylusOutOfRange(StylusEventArgs e);
    public sealed virtual void add_PreviewStylusSystemGesture(StylusSystemGestureEventHandler value);
    public sealed virtual void remove_PreviewStylusSystemGesture(StylusSystemGestureEventHandler value);
    protected internal virtual void OnPreviewStylusSystemGesture(StylusSystemGestureEventArgs e);
    public sealed virtual void add_StylusSystemGesture(StylusSystemGestureEventHandler value);
    public sealed virtual void remove_StylusSystemGesture(StylusSystemGestureEventHandler value);
    protected internal virtual void OnStylusSystemGesture(StylusSystemGestureEventArgs e);
    public sealed virtual void add_GotStylusCapture(StylusEventHandler value);
    public sealed virtual void remove_GotStylusCapture(StylusEventHandler value);
    protected internal virtual void OnGotStylusCapture(StylusEventArgs e);
    public sealed virtual void add_LostStylusCapture(StylusEventHandler value);
    public sealed virtual void remove_LostStylusCapture(StylusEventHandler value);
    protected internal virtual void OnLostStylusCapture(StylusEventArgs e);
    public sealed virtual void add_StylusButtonDown(StylusButtonEventHandler value);
    public sealed virtual void remove_StylusButtonDown(StylusButtonEventHandler value);
    protected internal virtual void OnStylusButtonDown(StylusButtonEventArgs e);
    public sealed virtual void add_StylusButtonUp(StylusButtonEventHandler value);
    public sealed virtual void remove_StylusButtonUp(StylusButtonEventHandler value);
    protected internal virtual void OnStylusButtonUp(StylusButtonEventArgs e);
    public sealed virtual void add_PreviewStylusButtonDown(StylusButtonEventHandler value);
    public sealed virtual void remove_PreviewStylusButtonDown(StylusButtonEventHandler value);
    protected internal virtual void OnPreviewStylusButtonDown(StylusButtonEventArgs e);
    public sealed virtual void add_PreviewStylusButtonUp(StylusButtonEventHandler value);
    public sealed virtual void remove_PreviewStylusButtonUp(StylusButtonEventHandler value);
    protected internal virtual void OnPreviewStylusButtonUp(StylusButtonEventArgs e);
    public sealed virtual void add_PreviewKeyDown(KeyEventHandler value);
    public sealed virtual void remove_PreviewKeyDown(KeyEventHandler value);
    protected internal virtual void OnPreviewKeyDown(KeyEventArgs e);
    public sealed virtual void add_KeyDown(KeyEventHandler value);
    public sealed virtual void remove_KeyDown(KeyEventHandler value);
    protected internal virtual void OnKeyDown(KeyEventArgs e);
    public sealed virtual void add_PreviewKeyUp(KeyEventHandler value);
    public sealed virtual void remove_PreviewKeyUp(KeyEventHandler value);
    protected internal virtual void OnPreviewKeyUp(KeyEventArgs e);
    public sealed virtual void add_KeyUp(KeyEventHandler value);
    public sealed virtual void remove_KeyUp(KeyEventHandler value);
    protected internal virtual void OnKeyUp(KeyEventArgs e);
    public sealed virtual void add_PreviewGotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    public sealed virtual void remove_PreviewGotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    protected internal virtual void OnPreviewGotKeyboardFocus(KeyboardFocusChangedEventArgs e);
    public sealed virtual void add_GotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    public sealed virtual void remove_GotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    protected internal virtual void OnGotKeyboardFocus(KeyboardFocusChangedEventArgs e);
    public sealed virtual void add_PreviewLostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    public sealed virtual void remove_PreviewLostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    protected internal virtual void OnPreviewLostKeyboardFocus(KeyboardFocusChangedEventArgs e);
    public sealed virtual void add_LostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    public sealed virtual void remove_LostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    protected internal virtual void OnLostKeyboardFocus(KeyboardFocusChangedEventArgs e);
    public sealed virtual void add_PreviewTextInput(TextCompositionEventHandler value);
    public sealed virtual void remove_PreviewTextInput(TextCompositionEventHandler value);
    protected internal virtual void OnPreviewTextInput(TextCompositionEventArgs e);
    public sealed virtual void add_TextInput(TextCompositionEventHandler value);
    public sealed virtual void remove_TextInput(TextCompositionEventHandler value);
    protected internal virtual void OnTextInput(TextCompositionEventArgs e);
    public void add_PreviewQueryContinueDrag(QueryContinueDragEventHandler value);
    public void remove_PreviewQueryContinueDrag(QueryContinueDragEventHandler value);
    protected internal virtual void OnPreviewQueryContinueDrag(QueryContinueDragEventArgs e);
    public void add_QueryContinueDrag(QueryContinueDragEventHandler value);
    public void remove_QueryContinueDrag(QueryContinueDragEventHandler value);
    protected internal virtual void OnQueryContinueDrag(QueryContinueDragEventArgs e);
    public void add_PreviewGiveFeedback(GiveFeedbackEventHandler value);
    public void remove_PreviewGiveFeedback(GiveFeedbackEventHandler value);
    protected internal virtual void OnPreviewGiveFeedback(GiveFeedbackEventArgs e);
    public void add_GiveFeedback(GiveFeedbackEventHandler value);
    public void remove_GiveFeedback(GiveFeedbackEventHandler value);
    protected internal virtual void OnGiveFeedback(GiveFeedbackEventArgs e);
    public void add_PreviewDragEnter(DragEventHandler value);
    public void remove_PreviewDragEnter(DragEventHandler value);
    protected internal virtual void OnPreviewDragEnter(DragEventArgs e);
    public void add_DragEnter(DragEventHandler value);
    public void remove_DragEnter(DragEventHandler value);
    protected internal virtual void OnDragEnter(DragEventArgs e);
    public void add_PreviewDragOver(DragEventHandler value);
    public void remove_PreviewDragOver(DragEventHandler value);
    protected internal virtual void OnPreviewDragOver(DragEventArgs e);
    public void add_DragOver(DragEventHandler value);
    public void remove_DragOver(DragEventHandler value);
    protected internal virtual void OnDragOver(DragEventArgs e);
    public void add_PreviewDragLeave(DragEventHandler value);
    public void remove_PreviewDragLeave(DragEventHandler value);
    protected internal virtual void OnPreviewDragLeave(DragEventArgs e);
    public void add_DragLeave(DragEventHandler value);
    public void remove_DragLeave(DragEventHandler value);
    protected internal virtual void OnDragLeave(DragEventArgs e);
    public void add_PreviewDrop(DragEventHandler value);
    public void remove_PreviewDrop(DragEventHandler value);
    protected internal virtual void OnPreviewDrop(DragEventArgs e);
    public void add_Drop(DragEventHandler value);
    public void remove_Drop(DragEventHandler value);
    protected internal virtual void OnDrop(DragEventArgs e);
    public void add_PreviewTouchDown(EventHandler`1<TouchEventArgs> value);
    public void remove_PreviewTouchDown(EventHandler`1<TouchEventArgs> value);
    protected internal virtual void OnPreviewTouchDown(TouchEventArgs e);
    public void add_TouchDown(EventHandler`1<TouchEventArgs> value);
    public void remove_TouchDown(EventHandler`1<TouchEventArgs> value);
    protected internal virtual void OnTouchDown(TouchEventArgs e);
    public void add_PreviewTouchMove(EventHandler`1<TouchEventArgs> value);
    public void remove_PreviewTouchMove(EventHandler`1<TouchEventArgs> value);
    protected internal virtual void OnPreviewTouchMove(TouchEventArgs e);
    public void add_TouchMove(EventHandler`1<TouchEventArgs> value);
    public void remove_TouchMove(EventHandler`1<TouchEventArgs> value);
    protected internal virtual void OnTouchMove(TouchEventArgs e);
    public void add_PreviewTouchUp(EventHandler`1<TouchEventArgs> value);
    public void remove_PreviewTouchUp(EventHandler`1<TouchEventArgs> value);
    protected internal virtual void OnPreviewTouchUp(TouchEventArgs e);
    public void add_TouchUp(EventHandler`1<TouchEventArgs> value);
    public void remove_TouchUp(EventHandler`1<TouchEventArgs> value);
    protected internal virtual void OnTouchUp(TouchEventArgs e);
    public void add_GotTouchCapture(EventHandler`1<TouchEventArgs> value);
    public void remove_GotTouchCapture(EventHandler`1<TouchEventArgs> value);
    protected internal virtual void OnGotTouchCapture(TouchEventArgs e);
    public void add_LostTouchCapture(EventHandler`1<TouchEventArgs> value);
    public void remove_LostTouchCapture(EventHandler`1<TouchEventArgs> value);
    protected internal virtual void OnLostTouchCapture(TouchEventArgs e);
    public void add_TouchEnter(EventHandler`1<TouchEventArgs> value);
    public void remove_TouchEnter(EventHandler`1<TouchEventArgs> value);
    protected internal virtual void OnTouchEnter(TouchEventArgs e);
    public void add_TouchLeave(EventHandler`1<TouchEventArgs> value);
    public void remove_TouchLeave(EventHandler`1<TouchEventArgs> value);
    protected internal virtual void OnTouchLeave(TouchEventArgs e);
    private static void IsMouseDirectlyOver_Changed(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public void add_IsMouseDirectlyOverChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsMouseDirectlyOverChanged(DependencyPropertyChangedEventHandler value);
    protected virtual void OnIsMouseDirectlyOverChanged(DependencyPropertyChangedEventArgs e);
    private void RaiseIsMouseDirectlyOverChanged(DependencyPropertyChangedEventArgs args);
    public void add_IsKeyboardFocusWithinChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsKeyboardFocusWithinChanged(DependencyPropertyChangedEventHandler value);
    protected virtual void OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs e);
    internal void RaiseIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs args);
    private static void IsMouseCaptured_Changed(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public void add_IsMouseCapturedChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsMouseCapturedChanged(DependencyPropertyChangedEventHandler value);
    protected virtual void OnIsMouseCapturedChanged(DependencyPropertyChangedEventArgs e);
    private void RaiseIsMouseCapturedChanged(DependencyPropertyChangedEventArgs args);
    public void add_IsMouseCaptureWithinChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsMouseCaptureWithinChanged(DependencyPropertyChangedEventHandler value);
    protected virtual void OnIsMouseCaptureWithinChanged(DependencyPropertyChangedEventArgs e);
    internal void RaiseIsMouseCaptureWithinChanged(DependencyPropertyChangedEventArgs args);
    private static void IsStylusDirectlyOver_Changed(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public void add_IsStylusDirectlyOverChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsStylusDirectlyOverChanged(DependencyPropertyChangedEventHandler value);
    protected virtual void OnIsStylusDirectlyOverChanged(DependencyPropertyChangedEventArgs e);
    private void RaiseIsStylusDirectlyOverChanged(DependencyPropertyChangedEventArgs args);
    private static void IsStylusCaptured_Changed(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public void add_IsStylusCapturedChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsStylusCapturedChanged(DependencyPropertyChangedEventHandler value);
    protected virtual void OnIsStylusCapturedChanged(DependencyPropertyChangedEventArgs e);
    private void RaiseIsStylusCapturedChanged(DependencyPropertyChangedEventArgs args);
    public void add_IsStylusCaptureWithinChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsStylusCaptureWithinChanged(DependencyPropertyChangedEventHandler value);
    protected virtual void OnIsStylusCaptureWithinChanged(DependencyPropertyChangedEventArgs e);
    internal void RaiseIsStylusCaptureWithinChanged(DependencyPropertyChangedEventArgs args);
    private static void IsKeyboardFocused_Changed(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public void add_IsKeyboardFocusedChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsKeyboardFocusedChanged(DependencyPropertyChangedEventHandler value);
    protected virtual void OnIsKeyboardFocusedChanged(DependencyPropertyChangedEventArgs e);
    private void RaiseIsKeyboardFocusedChanged(DependencyPropertyChangedEventArgs args);
    internal bool ReadFlag(CoreFlags field);
    internal void WriteFlag(CoreFlags field, bool value);
    internal DependencyObject GetUIParent();
    internal DependencyObject GetUIParent(bool continuePastVisualTree);
    protected internal virtual DependencyObject GetUIParentCore();
    internal DependencyObject get_Parent();
    [FriendAccessAllowedAttribute]
internal virtual void OnContentParentChanged(DependencyObject oldParent);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    internal AutomationPeer CreateAutomationPeer();
    internal AutomationPeer GetAutomationPeer();
    internal void AddSynchronizedInputPreOpportunityHandler(EventRoute route, RoutedEventArgs args);
    internal void AddSynchronizedInputPostOpportunityHandler(EventRoute route, RoutedEventArgs args);
    internal void SynchronizedInputPreOpportunityHandler(object sender, RoutedEventArgs args);
    internal void SynchronizedInputPostOpportunityHandler(object sender, RoutedEventArgs args);
    internal bool StartListeningSynchronizedInput(SynchronizedInputType inputType);
    internal void CancelSynchronizedInput();
    public sealed virtual bool get_IsMouseDirectlyOver();
    private bool IsMouseDirectlyOver_ComputeValue();
    [FriendAccessAllowedAttribute]
internal void SynchronizeReverseInheritPropertyFlags(DependencyObject oldParent, bool isCoreParent);
    internal virtual bool BlockReverseInheritance();
    public sealed virtual bool get_IsMouseOver();
    public sealed virtual bool get_IsStylusOver();
    public sealed virtual bool get_IsKeyboardFocusWithin();
    public sealed virtual bool get_IsMouseCaptured();
    public sealed virtual bool CaptureMouse();
    public sealed virtual void ReleaseMouseCapture();
    public bool get_IsMouseCaptureWithin();
    public sealed virtual bool get_IsStylusDirectlyOver();
    private bool IsStylusDirectlyOver_ComputeValue();
    public sealed virtual bool get_IsStylusCaptured();
    public sealed virtual bool CaptureStylus();
    public sealed virtual void ReleaseStylusCapture();
    public bool get_IsStylusCaptureWithin();
    public sealed virtual bool get_IsKeyboardFocused();
    private bool IsKeyboardFocused_ComputeValue();
    public sealed virtual bool Focus();
    public virtual bool MoveFocus(TraversalRequest request);
    public virtual DependencyObject PredictFocus(FocusNavigationDirection direction);
    public void add_GotFocus(RoutedEventHandler value);
    public void remove_GotFocus(RoutedEventHandler value);
    public void add_LostFocus(RoutedEventHandler value);
    public void remove_LostFocus(RoutedEventHandler value);
    private static void IsFocused_Changed(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnGotFocus(RoutedEventArgs e);
    protected virtual void OnLostFocus(RoutedEventArgs e);
    public bool get_IsFocused();
    public sealed virtual bool get_IsEnabled();
    public void set_IsEnabled(bool value);
    public void add_IsEnabledChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsEnabledChanged(DependencyPropertyChangedEventHandler value);
    protected virtual bool get_IsEnabledCore();
    private static object CoerceIsEnabled(DependencyObject d, object value);
    private static void OnIsEnabledChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public sealed virtual bool get_Focusable();
    public sealed virtual void set_Focusable(bool value);
    public void add_FocusableChanged(DependencyPropertyChangedEventHandler value);
    public void remove_FocusableChanged(DependencyPropertyChangedEventHandler value);
    private static void OnFocusableChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public bool get_IsInputMethodEnabled();
    private void RaiseMouseButtonEvent(EventPrivateKey key, MouseButtonEventArgs e);
    private void RaiseDependencyPropertyChanged(EventPrivateKey key, DependencyPropertyChangedEventArgs args);
    public bool get_AllowDrop();
    public void set_AllowDrop(bool value);
    internal virtual void InvalidateForceInheritPropertyOnChildren(DependencyProperty property);
    public bool get_AreAnyTouchesOver();
    public bool get_AreAnyTouchesDirectlyOver();
    public bool get_AreAnyTouchesCapturedWithin();
    public bool get_AreAnyTouchesCaptured();
    public bool CaptureTouch(TouchDevice touchDevice);
    public bool ReleaseTouchCapture(TouchDevice touchDevice);
    public void ReleaseAllTouchCaptures();
    public IEnumerable`1<TouchDevice> get_TouchesCaptured();
    public IEnumerable`1<TouchDevice> get_TouchesCapturedWithin();
    public IEnumerable`1<TouchDevice> get_TouchesOver();
    public IEnumerable`1<TouchDevice> get_TouchesDirectlyOver();
    internal bool get_HasAutomationPeer();
    internal void set_HasAutomationPeer(bool value);
}
public static class System.Windows.ContentOperations : object {
    public static DependencyObject GetParent(ContentElement reference);
    public static void SetParent(ContentElement reference, DependencyObject parent);
}
internal class System.Windows.ContextLayoutManager : DispatcherObject {
    private static DispatcherOperationCallback _updateCallback;
    private LayoutEventList _layoutEvents;
    private LayoutEventList _automationEvents;
    private UIElement _forceLayoutElement;
    private UIElement _lastExceptionElement;
    private InternalMeasureQueue _measureQueue;
    private InternalArrangeQueue _arrangeQueue;
    private SizeChangedInfo _sizeChangedChain;
    private static DispatcherOperationCallback _updateLayoutBackground;
    private EventHandler _shutdownHandler;
    internal static int s_LayoutRecursionLimit;
    private int _arrangesOnStack;
    private int _measuresOnStack;
    private int _automationSyncUpdateCounter;
    private bool _isDead;
    private bool _isUpdating;
    private bool _isInUpdateLayout;
    private bool _gotException;
    private bool _layoutRequestPosted;
    private bool _inFireLayoutUpdated;
    private bool _inFireSizeChanged;
    private bool _firePostLayoutEvents;
    private bool _inFireAutomationEvents;
    private bool hasDirtiness { get; }
    internal LayoutQueue MeasureQueue { get; }
    internal LayoutQueue ArrangeQueue { get; }
    internal LayoutEventList LayoutEvents { get; }
    internal LayoutEventList AutomationEvents { get; }
    internal int AutomationSyncUpdateCounter { get; internal set; }
    private static ContextLayoutManager();
    private void OnDispatcherShutdown(object sender, EventArgs e);
    internal static ContextLayoutManager From(Dispatcher dispatcher);
    private void setForceLayout(UIElement e);
    private void markTreeDirty(UIElement e);
    private void markTreeDirtyHelper(Visual v);
    private void NeedsRecalc();
    private static object UpdateLayoutBackground(object arg);
    private bool get_hasDirtiness();
    internal void EnterMeasure();
    internal void ExitMeasure();
    internal void EnterArrange();
    internal void ExitArrange();
    internal void UpdateLayout();
    private Rect getProperArrangeRect(UIElement element);
    private void invalidateTreeIfRecovering();
    internal LayoutQueue get_MeasureQueue();
    internal LayoutQueue get_ArrangeQueue();
    private static object UpdateLayoutCallback(object arg);
    private void fireLayoutUpdateEvent();
    internal LayoutEventList get_LayoutEvents();
    internal void AddToSizeChangedChain(SizeChangedInfo info);
    private void fireSizeChangedEvents();
    private void fireAutomationEvents();
    internal LayoutEventList get_AutomationEvents();
    internal AutomationPeer[] GetAutomationRoots();
    internal int get_AutomationSyncUpdateCounter();
    internal void set_AutomationSyncUpdateCounter(int value);
    internal UIElement GetLastExceptionElement();
    internal void SetLastExceptionElement(UIElement e);
}
public static class System.Windows.CoreCompatibilityPreferences : object {
    private static bool _isAltKeyRequiredInAccessKeyDefaultScope;
    private static bool _includeAllInkInBoundingBox;
    private static Nullable`1<bool> _enableMultiMonitorDisplayClipping;
    private static bool _isSealed;
    private static object _lockObject;
    internal static bool TargetsAtLeast_Desktop_V4_5 { get; }
    public static bool IsAltKeyRequiredInAccessKeyDefaultScope { get; public set; }
    internal static bool IncludeAllInkInBoundingBox { get; internal set; }
    public static Nullable`1<bool> EnableMultiMonitorDisplayClipping { get; public set; }
    private static CoreCompatibilityPreferences();
    internal static bool get_TargetsAtLeast_Desktop_V4_5();
    public static bool get_IsAltKeyRequiredInAccessKeyDefaultScope();
    public static void set_IsAltKeyRequiredInAccessKeyDefaultScope(bool value);
    internal static bool GetIsAltKeyRequiredInAccessKeyDefaultScope();
    internal static bool get_IncludeAllInkInBoundingBox();
    internal static void set_IncludeAllInkInBoundingBox(bool value);
    internal static bool GetIncludeAllInkInBoundingBox();
    private static void SetIncludeAllInkInBoundingBoxFromAppSettings(NameValueCollection appSettings);
    public static Nullable`1<bool> get_EnableMultiMonitorDisplayClipping();
    public static void set_EnableMultiMonitorDisplayClipping(Nullable`1<bool> value);
    internal static Nullable`1<bool> GetEnableMultiMonitorDisplayClipping();
    private static void SetEnableMultiMonitorDisplayClippingFromAppSettings(NameValueCollection appSettings);
    private static void Seal();
}
[FlagsAttribute]
internal enum System.Windows.CoreFlags : Enum {
    public UInt32 value__;
    public static CoreFlags None;
    public static CoreFlags SnapsToDevicePixelsCache;
    public static CoreFlags ClipToBoundsCache;
    public static CoreFlags MeasureDirty;
    public static CoreFlags ArrangeDirty;
    public static CoreFlags MeasureInProgress;
    public static CoreFlags ArrangeInProgress;
    public static CoreFlags NeverMeasured;
    public static CoreFlags NeverArranged;
    public static CoreFlags MeasureDuringArrange;
    public static CoreFlags IsCollapsed;
    public static CoreFlags IsKeyboardFocusWithinCache;
    public static CoreFlags IsKeyboardFocusWithinChanged;
    public static CoreFlags IsMouseOverCache;
    public static CoreFlags IsMouseOverChanged;
    public static CoreFlags IsMouseCaptureWithinCache;
    public static CoreFlags IsMouseCaptureWithinChanged;
    public static CoreFlags IsStylusOverCache;
    public static CoreFlags IsStylusOverChanged;
    public static CoreFlags IsStylusCaptureWithinCache;
    public static CoreFlags IsStylusCaptureWithinChanged;
    public static CoreFlags HasAutomationPeer;
    public static CoreFlags RenderingInvalidated;
    public static CoreFlags IsVisibleCache;
    public static CoreFlags AreTransformsClean;
    public static CoreFlags IsOpacitySuppressed;
    public static CoreFlags ExistsEventHandlersStore;
    public static CoreFlags TouchesOverCache;
    public static CoreFlags TouchesOverChanged;
    public static CoreFlags TouchesCapturedWithinCache;
    public static CoreFlags TouchesCapturedWithinChanged;
    public static CoreFlags TouchLeaveCache;
    public static CoreFlags TouchEnterCache;
}
public class System.Windows.CultureInfoIetfLanguageTagConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext typeDescriptorContext, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext typeDescriptorContext, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object source);
    public virtual object ConvertTo(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object value, Type destinationType);
}
public class System.Windows.DataFormat : object {
    private string _name;
    private int _id;
    public string Name { get; }
    public int Id { get; }
    public DataFormat(string name, int id);
    public string get_Name();
    public int get_Id();
}
public static class System.Windows.DataFormats : object {
    public static string Text;
    public static string UnicodeText;
    public static string Dib;
    public static string Bitmap;
    public static string EnhancedMetafile;
    public static string MetafilePicture;
    public static string SymbolicLink;
    public static string Dif;
    public static string Tiff;
    public static string OemText;
    public static string Palette;
    public static string PenData;
    public static string Riff;
    public static string WaveAudio;
    public static string FileDrop;
    public static string Locale;
    public static string Html;
    public static string Rtf;
    public static string CommaSeparatedValue;
    public static string StringFormat;
    public static string Serializable;
    public static string Xaml;
    public static string XamlPackage;
    internal static string ApplicationTrust;
    internal static string FileName;
    internal static string FileNameW;
    private static ArrayList _formatList;
    private static object _formatListlock;
    private static DataFormats();
    public static DataFormat GetDataFormat(int id);
    public static DataFormat GetDataFormat(string format);
    internal static string ConvertToDataFormats(TextDataFormat textDataformat);
    internal static bool IsValidTextDataFormat(TextDataFormat textDataFormat);
    private static DataFormat InternalGetDataFormat(int id);
    private static void EnsurePredefined();
}
public class System.Windows.DataObject : object {
    public static RoutedEvent CopyingEvent;
    public static RoutedEvent PastingEvent;
    public static RoutedEvent SettingDataEvent;
    private static string SystemDrawingBitmapFormat;
    private static string SystemBitmapSourceFormat;
    private static string SystemDrawingImagingMetafileFormat;
    private static int DV_E_FORMATETC;
    private static int DV_E_LINDEX;
    private static int DV_E_TYMED;
    private static int DV_E_DVASPECT;
    private static int OLE_E_NOTRUNNING;
    private static int OLE_E_ADVISENOTSUPPORTED;
    private static int DATA_S_SAMEFORMATETC;
    private static int STG_E_MEDIUMFULL;
    private static int FILEDROPBASESIZE;
    private static TYMED[] ALLOWED_TYMEDS;
    private IDataObject _innerData;
    private static Byte[] _serializedObjectID;
    public DataObject(object data);
    public DataObject(string format, object data);
    public DataObject(Type format, object data);
    public DataObject(string format, object data, bool autoConvert);
    internal DataObject(IDataObject data);
    internal DataObject(IDataObject data);
    private static DataObject();
    public sealed virtual object GetData(string format, bool autoConvert);
    public sealed virtual object GetData(string format);
    public sealed virtual object GetData(Type format);
    public sealed virtual bool GetDataPresent(Type format);
    public sealed virtual bool GetDataPresent(string format, bool autoConvert);
    public sealed virtual bool GetDataPresent(string format);
    public sealed virtual String[] GetFormats(bool autoConvert);
    public sealed virtual String[] GetFormats();
    public sealed virtual void SetData(object data);
    public sealed virtual void SetData(string format, object data);
    public sealed virtual void SetData(Type format, object data);
    [FriendAccessAllowedAttribute]
public sealed virtual void SetData(string format, object data, bool autoConvert);
    public bool ContainsAudio();
    public bool ContainsFileDropList();
    public bool ContainsImage();
    public bool ContainsText();
    public bool ContainsText(TextDataFormat format);
    public Stream GetAudioStream();
    public StringCollection GetFileDropList();
    public BitmapSource GetImage();
    public string GetText();
    public string GetText(TextDataFormat format);
    public void SetAudio(Byte[] audioBytes);
    public void SetAudio(Stream audioStream);
    public void SetFileDropList(StringCollection fileDropList);
    public void SetImage(BitmapSource image);
    public void SetText(string textData);
    public void SetText(string textData, TextDataFormat format);
    private sealed virtual override int System.Runtime.InteropServices.ComTypes.IDataObject.DAdvise(FORMATETC& pFormatetc, ADVF advf, IAdviseSink pAdvSink, Int32& pdwConnection);
    private sealed virtual override void System.Runtime.InteropServices.ComTypes.IDataObject.DUnadvise(int dwConnection);
    private sealed virtual override int System.Runtime.InteropServices.ComTypes.IDataObject.EnumDAdvise(IEnumSTATDATA& enumAdvise);
    private sealed virtual override IEnumFORMATETC System.Runtime.InteropServices.ComTypes.IDataObject.EnumFormatEtc(DATADIR dwDirection);
    private sealed virtual override int System.Runtime.InteropServices.ComTypes.IDataObject.GetCanonicalFormatEtc(FORMATETC& pformatetcIn, FORMATETC& pformatetcOut);
    private sealed virtual override void System.Runtime.InteropServices.ComTypes.IDataObject.GetData(FORMATETC& formatetc, STGMEDIUM& medium);
    private sealed virtual override void System.Runtime.InteropServices.ComTypes.IDataObject.GetDataHere(FORMATETC& formatetc, STGMEDIUM& medium);
    private sealed virtual override int System.Runtime.InteropServices.ComTypes.IDataObject.QueryGetData(FORMATETC& formatetc);
    private sealed virtual override void System.Runtime.InteropServices.ComTypes.IDataObject.SetData(FORMATETC& pFormatetcIn, STGMEDIUM& pmedium, bool fRelease);
    public static void AddCopyingHandler(DependencyObject element, DataObjectCopyingEventHandler handler);
    public static void RemoveCopyingHandler(DependencyObject element, DataObjectCopyingEventHandler handler);
    public static void AddPastingHandler(DependencyObject element, DataObjectPastingEventHandler handler);
    public static void RemovePastingHandler(DependencyObject element, DataObjectPastingEventHandler handler);
    public static void AddSettingDataHandler(DependencyObject element, DataObjectSettingDataEventHandler handler);
    public static void RemoveSettingDataHandler(DependencyObject element, DataObjectSettingDataEventHandler handler);
    internal static IntPtr Win32GlobalAlloc(int flags, IntPtr bytes);
    private static int Win32CreateStreamOnHGlobal(IntPtr hGlobal, bool fDeleteOnRelease, IStream& istream);
    internal static void Win32GlobalFree(HandleRef handle);
    internal static IntPtr Win32GlobalReAlloc(HandleRef handle, IntPtr bytes, int flags);
    internal static IntPtr Win32GlobalLock(HandleRef handle);
    internal static void Win32GlobalUnlock(HandleRef handle);
    internal static IntPtr Win32GlobalSize(HandleRef handle);
    internal static IntPtr Win32SelectObject(HandleRef handleDC, IntPtr handleObject);
    internal static void Win32DeleteObject(HandleRef handleDC);
    internal static IntPtr Win32GetDC(HandleRef handleDC);
    internal static IntPtr Win32CreateCompatibleDC(HandleRef handleDC);
    internal static IntPtr Win32CreateCompatibleBitmap(HandleRef handleDC, int width, int height);
    internal static void Win32DeleteDC(HandleRef handleDC);
    private static void Win32ReleaseDC(HandleRef handleHWND, HandleRef handleDC);
    internal static void Win32BitBlt(HandleRef handledestination, int width, int height, HandleRef handleSource, int operationCode);
    internal static int Win32WideCharToMultiByte(string wideString, int wideChars, Byte[] bytes, int byteCount);
    internal static String[] GetMappedFormats(string format);
    private int OleGetDataUnrestricted(FORMATETC& formatetc, STGMEDIUM& medium, bool doNotReallocate);
    private static String[] GetDistinctStrings(String[] formats);
    private bool GetTymedUseable(TYMED tymed);
    private IntPtr GetCompatibleBitmap(object data);
    private IntPtr GetEnhancedMetafileHandle(string format, object data);
    private int GetDataIntoOleStructs(FORMATETC& formatetc, STGMEDIUM& medium, bool doNotReallocate);
    private int GetDataIntoOleStructsByTypeMedimHGlobal(string format, object data, STGMEDIUM& medium, bool doNotReallocate);
    private int GetDataIntoOleStructsByTypeMedimIStream(string format, object data, STGMEDIUM& medium);
    private int GetDataIntoOleStructsByTypeMediumGDI(string format, object data, STGMEDIUM& medium);
    private int GetDataIntoOleStructsByTypeMediumEnhancedMetaFile(string format, object data, STGMEDIUM& medium);
    private int SaveObjectToHandle(IntPtr handle, object data, bool doNotReallocate);
    private int SaveStreamToHandle(IntPtr handle, Stream stream, bool doNotReallocate);
    private int SaveSystemBitmapSourceToHandle(IntPtr handle, object data, bool doNotReallocate);
    private int SaveSystemDrawingBitmapToHandle(IntPtr handle, object data, bool doNotReallocate);
    private int SaveFileListToHandle(IntPtr handle, String[] files, bool doNotReallocate);
    private int SaveStringToHandle(IntPtr handle, string str, bool unicode, bool doNotReallocate);
    private int SaveStringToHandleAsUtf8(IntPtr handle, string str, bool doNotReallocate);
    private static bool IsDataSystemBitmapSource(object data);
    private static bool IsFormatAndDataSerializable(string format, object data);
    private static bool IsFormatEqual(string format1, string format2);
    private int EnsureMemoryCapacity(IntPtr& handle, int minimumByteCount, bool doNotReallocate);
    private static object EnsureBitmapDataFromFormat(string format, bool autoConvert, object data);
}
public class System.Windows.DataObjectCopyingEventArgs : DataObjectEventArgs {
    private IDataObject _dataObject;
    public IDataObject DataObject { get; }
    public DataObjectCopyingEventArgs(IDataObject dataObject, bool isDragDrop);
    public IDataObject get_DataObject();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.DataObjectCopyingEventHandler : MulticastDelegate {
    public DataObjectCopyingEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DataObjectCopyingEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DataObjectCopyingEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class System.Windows.DataObjectEventArgs : RoutedEventArgs {
    private bool _isDragDrop;
    private bool _commandCancelled;
    public bool IsDragDrop { get; }
    public bool CommandCancelled { get; }
    internal DataObjectEventArgs(RoutedEvent routedEvent, bool isDragDrop);
    public bool get_IsDragDrop();
    public bool get_CommandCancelled();
    public void CancelCommand();
}
public class System.Windows.DataObjectPastingEventArgs : DataObjectEventArgs {
    private IDataObject _originalDataObject;
    private IDataObject _dataObject;
    private string _formatToApply;
    public IDataObject SourceDataObject { get; }
    public IDataObject DataObject { get; public set; }
    public string FormatToApply { get; public set; }
    public DataObjectPastingEventArgs(IDataObject dataObject, bool isDragDrop, string formatToApply);
    public IDataObject get_SourceDataObject();
    public IDataObject get_DataObject();
    public void set_DataObject(IDataObject value);
    public string get_FormatToApply();
    public void set_FormatToApply(string value);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.DataObjectPastingEventHandler : MulticastDelegate {
    public DataObjectPastingEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DataObjectPastingEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DataObjectPastingEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.DataObjectSettingDataEventArgs : DataObjectEventArgs {
    private IDataObject _dataObject;
    private string _format;
    public IDataObject DataObject { get; }
    public string Format { get; }
    public DataObjectSettingDataEventArgs(IDataObject dataObject, string format);
    public IDataObject get_DataObject();
    public string get_Format();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.DataObjectSettingDataEventHandler : MulticastDelegate {
    public DataObjectSettingDataEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DataObjectSettingDataEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DataObjectSettingDataEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public static class System.Windows.Diagnostics.VisualDiagnostics : object {
    private static bool s_isDebuggerCheckDisabledForTestPurposes;
    private static bool s_IsEnabled;
    [CompilerGeneratedAttribute]
private static EventHandler`1<VisualTreeChangeEventArgs> s_visualTreeChanged;
    private static bool s_HasVisualTreeChangedListeners;
    [ThreadStaticAttribute]
private static bool s_IsVisualTreeChangedInProgress;
    [ThreadStaticAttribute]
private static HwndSource s_ActiveHwndSource;
    internal static bool IsEnabled { get; }
    private static VisualDiagnostics();
    [CompilerGeneratedAttribute]
private static void add_s_visualTreeChanged(EventHandler`1<VisualTreeChangeEventArgs> value);
    [CompilerGeneratedAttribute]
private static void remove_s_visualTreeChanged(EventHandler`1<VisualTreeChangeEventArgs> value);
    public static void add_VisualTreeChanged(EventHandler`1<VisualTreeChangeEventArgs> value);
    public static void remove_VisualTreeChanged(EventHandler`1<VisualTreeChangeEventArgs> value);
    public static void EnableVisualTreeChanged();
    public static void DisableVisualTreeChanged();
    public static XamlSourceInfo GetXamlSourceInfo(object obj);
    internal static void OnVisualChildChanged(DependencyObject parent, DependencyObject child, bool isAdded);
    private static void RaiseVisualTreeChangedEvent(EventHandler`1<VisualTreeChangeEventArgs> visualTreeChanged, VisualTreeChangeEventArgs args, bool isPotentialOuterChange);
    private static int GetChildIndex(DependencyObject parent, DependencyObject child);
    internal static bool get_IsEnabled();
    internal static void VerifyVisualTreeChange(DependencyObject d);
    private static void VerifyVisualTreeChangeCore(DependencyObject d);
    internal static bool IsEnvironmentVariableSet(string value, string environmentVariable);
    internal static bool IsEnvironmentValueSet(string value);
}
public class System.Windows.Diagnostics.VisualTreeChangeEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private DependencyObject <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private DependencyObject <Child>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ChildIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private VisualTreeChangeType <ChangeType>k__BackingField;
    public DependencyObject Parent { get; private set; }
    public DependencyObject Child { get; private set; }
    public int ChildIndex { get; private set; }
    public VisualTreeChangeType ChangeType { get; private set; }
    public VisualTreeChangeEventArgs(DependencyObject parent, DependencyObject child, int childIndex, VisualTreeChangeType changeType);
    [CompilerGeneratedAttribute]
public DependencyObject get_Parent();
    [CompilerGeneratedAttribute]
private void set_Parent(DependencyObject value);
    [CompilerGeneratedAttribute]
public DependencyObject get_Child();
    [CompilerGeneratedAttribute]
private void set_Child(DependencyObject value);
    [CompilerGeneratedAttribute]
public int get_ChildIndex();
    [CompilerGeneratedAttribute]
private void set_ChildIndex(int value);
    [CompilerGeneratedAttribute]
public VisualTreeChangeType get_ChangeType();
    [CompilerGeneratedAttribute]
private void set_ChangeType(VisualTreeChangeType value);
}
public enum System.Windows.Diagnostics.VisualTreeChangeType : Enum {
    public int value__;
    public static VisualTreeChangeType Add;
    public static VisualTreeChangeType Remove;
}
[DebuggerDisplayAttribute("{line={LineNumber}, offset={LinePosition}, uri={SourceUri}}")]
public class System.Windows.Diagnostics.XamlSourceInfo : object {
    [CompilerGeneratedAttribute]
private Uri <SourceUri>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LinePosition>k__BackingField;
    public Uri SourceUri { get; private set; }
    public int LineNumber { get; private set; }
    public int LinePosition { get; private set; }
    public XamlSourceInfo(Uri sourceUri, int lineNumber, int linePosition);
    [CompilerGeneratedAttribute]
public Uri get_SourceUri();
    [CompilerGeneratedAttribute]
private void set_SourceUri(Uri value);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
private void set_LineNumber(int value);
    [CompilerGeneratedAttribute]
public int get_LinePosition();
    [CompilerGeneratedAttribute]
private void set_LinePosition(int value);
}
internal static class System.Windows.Diagnostics.XamlSourceInfoHelper : object {
    private static ConditionalWeakTable`2<object, XamlSourceInfo> s_sourceInfoTable;
    private static object s_lock;
    private static PropertyInfo s_sourceBamlUriProperty;
    private static PropertyInfo s_elementLineNumberProperty;
    private static PropertyInfo s_elementLinePositionProperty;
    internal static bool IsXamlSourceInfoEnabled { get; }
    private static XamlSourceInfoHelper();
    internal static bool get_IsXamlSourceInfoEnabled();
    private static void InitializeEnableXamlSourceInfo(string value);
    private static bool InitializeXamlObjectEventArgs();
    internal static void SetXamlSourceInfo(object obj, XamlObjectEventArgs args, Uri overrideSourceUri);
    internal static void SetXamlSourceInfo(object obj, Uri sourceUri, int elementLineNumber, int elementLinePosition);
    internal static XamlSourceInfo GetXamlSourceInfo(object obj);
}
public abstract class System.Windows.Documents.ContentPosition : object {
    public static ContentPosition Missing;
    private static ContentPosition();
}
public class System.Windows.Documents.DocumentPage : object {
    public static DocumentPage Missing;
    [CompilerGeneratedAttribute]
private EventHandler PageDestroyed;
    private Visual _visual;
    private Size _pageSize;
    private Rect _bleedBox;
    private Rect _contentBox;
    public Visual Visual { get; }
    public Size Size { get; }
    public Rect BleedBox { get; }
    public Rect ContentBox { get; }
    public DocumentPage(Visual visual);
    public DocumentPage(Visual visual, Size pageSize, Rect bleedBox, Rect contentBox);
    private static DocumentPage();
    public virtual void Dispose();
    public virtual Visual get_Visual();
    public virtual Size get_Size();
    public virtual Rect get_BleedBox();
    public virtual Rect get_ContentBox();
    [CompilerGeneratedAttribute]
public void add_PageDestroyed(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PageDestroyed(EventHandler value);
    protected void OnPageDestroyed(EventArgs e);
    protected void SetVisual(Visual visual);
    protected void SetSize(Size size);
    protected void SetBleedBox(Rect bleedBox);
    protected void SetContentBox(Rect contentBox);
}
public abstract class System.Windows.Documents.DocumentPaginator : object {
    [CompilerGeneratedAttribute]
private GetPageCompletedEventHandler GetPageCompleted;
    [CompilerGeneratedAttribute]
private AsyncCompletedEventHandler ComputePageCountCompleted;
    [CompilerGeneratedAttribute]
private PagesChangedEventHandler PagesChanged;
    public bool IsPageCountValid { get; }
    public int PageCount { get; }
    public Size PageSize { get; public set; }
    public IDocumentPaginatorSource Source { get; }
    public abstract virtual DocumentPage GetPage(int pageNumber);
    public virtual void GetPageAsync(int pageNumber);
    public virtual void GetPageAsync(int pageNumber, object userState);
    public virtual void ComputePageCount();
    public virtual void ComputePageCountAsync();
    public virtual void ComputePageCountAsync(object userState);
    public virtual void CancelAsync(object userState);
    public abstract virtual bool get_IsPageCountValid();
    public abstract virtual int get_PageCount();
    public abstract virtual Size get_PageSize();
    public abstract virtual void set_PageSize(Size value);
    public abstract virtual IDocumentPaginatorSource get_Source();
    [CompilerGeneratedAttribute]
public void add_GetPageCompleted(GetPageCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_GetPageCompleted(GetPageCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_ComputePageCountCompleted(AsyncCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ComputePageCountCompleted(AsyncCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_PagesChanged(PagesChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PagesChanged(PagesChangedEventHandler value);
    protected virtual void OnGetPageCompleted(GetPageCompletedEventArgs e);
    protected virtual void OnComputePageCountCompleted(AsyncCompletedEventArgs e);
    protected virtual void OnPagesChanged(PagesChangedEventArgs e);
}
public abstract class System.Windows.Documents.DynamicDocumentPaginator : DocumentPaginator {
    [CompilerGeneratedAttribute]
private GetPageNumberCompletedEventHandler GetPageNumberCompleted;
    [CompilerGeneratedAttribute]
private EventHandler PaginationCompleted;
    [CompilerGeneratedAttribute]
private PaginationProgressEventHandler PaginationProgress;
    public bool IsBackgroundPaginationEnabled { get; public set; }
    public abstract virtual int GetPageNumber(ContentPosition contentPosition);
    public virtual void GetPageNumberAsync(ContentPosition contentPosition);
    public virtual void GetPageNumberAsync(ContentPosition contentPosition, object userState);
    public abstract virtual ContentPosition GetPagePosition(DocumentPage page);
    public abstract virtual ContentPosition GetObjectPosition(object value);
    public virtual bool get_IsBackgroundPaginationEnabled();
    public virtual void set_IsBackgroundPaginationEnabled(bool value);
    [CompilerGeneratedAttribute]
public void add_GetPageNumberCompleted(GetPageNumberCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_GetPageNumberCompleted(GetPageNumberCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_PaginationCompleted(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PaginationCompleted(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_PaginationProgress(PaginationProgressEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PaginationProgress(PaginationProgressEventHandler value);
    protected virtual void OnGetPageNumberCompleted(GetPageNumberCompletedEventArgs e);
    protected virtual void OnPaginationProgress(PaginationProgressEventArgs e);
    protected virtual void OnPaginationCompleted(EventArgs e);
}
public class System.Windows.Documents.GetPageCompletedEventArgs : AsyncCompletedEventArgs {
    private DocumentPage _page;
    private int _pageNumber;
    public DocumentPage DocumentPage { get; }
    public int PageNumber { get; }
    public GetPageCompletedEventArgs(DocumentPage page, int pageNumber, Exception error, bool cancelled, object userState);
    public DocumentPage get_DocumentPage();
    public int get_PageNumber();
}
public class System.Windows.Documents.GetPageCompletedEventHandler : MulticastDelegate {
    public GetPageCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, GetPageCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, GetPageCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Documents.GetPageNumberCompletedEventArgs : AsyncCompletedEventArgs {
    private ContentPosition _contentPosition;
    private int _pageNumber;
    public ContentPosition ContentPosition { get; }
    public int PageNumber { get; }
    public GetPageNumberCompletedEventArgs(ContentPosition contentPosition, int pageNumber, Exception error, bool cancelled, object userState);
    public ContentPosition get_ContentPosition();
    public int get_PageNumber();
}
public class System.Windows.Documents.GetPageNumberCompletedEventHandler : MulticastDelegate {
    public GetPageNumberCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, GetPageNumberCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, GetPageNumberCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public interface System.Windows.Documents.IDocumentPaginatorSource {
    public DocumentPaginator DocumentPaginator { get; }
    public abstract virtual DocumentPaginator get_DocumentPaginator();
}
public class System.Windows.Documents.PagesChangedEventArgs : EventArgs {
    private int _start;
    private int _count;
    public int Start { get; }
    public int Count { get; }
    public PagesChangedEventArgs(int start, int count);
    public int get_Start();
    public int get_Count();
}
public class System.Windows.Documents.PagesChangedEventHandler : MulticastDelegate {
    public PagesChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, PagesChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, PagesChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Documents.PaginationProgressEventArgs : EventArgs {
    private int _start;
    private int _count;
    public int Start { get; }
    public int Count { get; }
    public PaginationProgressEventArgs(int start, int count);
    public int get_Start();
    public int get_Count();
}
public class System.Windows.Documents.PaginationProgressEventHandler : MulticastDelegate {
    public PaginationProgressEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, PaginationProgressEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, PaginationProgressEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.DpiChangedEventArgs : RoutedEventArgs {
    [CompilerGeneratedAttribute]
private DpiScale <OldDpi>k__BackingField;
    [CompilerGeneratedAttribute]
private DpiScale <NewDpi>k__BackingField;
    public DpiScale OldDpi { get; private set; }
    public DpiScale NewDpi { get; private set; }
    internal DpiChangedEventArgs(DpiScale oldDpi, DpiScale newDpi, RoutedEvent routedEvent, object source);
    [CompilerGeneratedAttribute]
public DpiScale get_OldDpi();
    [CompilerGeneratedAttribute]
private void set_OldDpi(DpiScale value);
    [CompilerGeneratedAttribute]
public DpiScale get_NewDpi();
    [CompilerGeneratedAttribute]
private void set_NewDpi(DpiScale value);
}
public class System.Windows.DpiChangedEventHandler : MulticastDelegate {
    public DpiChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DpiChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DpiChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Windows.DpiFlags : object {
    [CompilerGeneratedAttribute]
private bool <DpiScaleFlag1>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DpiScaleFlag2>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    internal bool DpiScaleFlag1 { get; internal set; }
    internal bool DpiScaleFlag2 { get; internal set; }
    internal int Index { get; internal set; }
    internal DpiFlags(bool dpiScaleFlag1, bool dpiScaleFlag2, int index);
    [CompilerGeneratedAttribute]
internal bool get_DpiScaleFlag1();
    [CompilerGeneratedAttribute]
internal void set_DpiScaleFlag1(bool value);
    [CompilerGeneratedAttribute]
internal bool get_DpiScaleFlag2();
    [CompilerGeneratedAttribute]
internal void set_DpiScaleFlag2(bool value);
    [CompilerGeneratedAttribute]
internal int get_Index();
    [CompilerGeneratedAttribute]
internal void set_Index(int value);
}
internal class System.Windows.DpiRecursiveChangeArgs : object {
    [CompilerGeneratedAttribute]
private bool <DpiScaleFlag1>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DpiScaleFlag2>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private DpiScale <OldDpiScale>k__BackingField;
    [CompilerGeneratedAttribute]
private DpiScale <NewDpiScale>k__BackingField;
    internal bool DpiScaleFlag1 { get; internal set; }
    internal bool DpiScaleFlag2 { get; internal set; }
    internal int Index { get; internal set; }
    internal DpiScale OldDpiScale { get; internal set; }
    internal DpiScale NewDpiScale { get; internal set; }
    internal DpiRecursiveChangeArgs(DpiFlags dpiFlags, DpiScale oldDpiScale, DpiScale newDpiScale);
    [CompilerGeneratedAttribute]
internal bool get_DpiScaleFlag1();
    [CompilerGeneratedAttribute]
internal void set_DpiScaleFlag1(bool value);
    [CompilerGeneratedAttribute]
internal bool get_DpiScaleFlag2();
    [CompilerGeneratedAttribute]
internal void set_DpiScaleFlag2(bool value);
    [CompilerGeneratedAttribute]
internal int get_Index();
    [CompilerGeneratedAttribute]
internal void set_Index(int value);
    [CompilerGeneratedAttribute]
internal DpiScale get_OldDpiScale();
    [CompilerGeneratedAttribute]
internal void set_OldDpiScale(DpiScale value);
    [CompilerGeneratedAttribute]
internal DpiScale get_NewDpiScale();
    [CompilerGeneratedAttribute]
internal void set_NewDpiScale(DpiScale value);
}
public class System.Windows.DpiScale : ValueType {
    private double _dpiScaleX;
    private double _dpiScaleY;
    public double DpiScaleX { get; }
    public double DpiScaleY { get; }
    public double PixelsPerDip { get; }
    public double PixelsPerInchX { get; }
    public double PixelsPerInchY { get; }
    public DpiScale(double dpiScaleX, double dpiScaleY);
    public double get_DpiScaleX();
    public double get_DpiScaleY();
    public double get_PixelsPerDip();
    public double get_PixelsPerInchX();
    public double get_PixelsPerInchY();
}
public enum System.Windows.DragAction : Enum {
    public int value__;
    public static DragAction Continue;
    public static DragAction Drop;
    public static DragAction Cancel;
}
public static class System.Windows.DragDrop : object {
    public static RoutedEvent PreviewQueryContinueDragEvent;
    public static RoutedEvent QueryContinueDragEvent;
    public static RoutedEvent PreviewGiveFeedbackEvent;
    public static RoutedEvent GiveFeedbackEvent;
    public static RoutedEvent PreviewDragEnterEvent;
    public static RoutedEvent DragEnterEvent;
    public static RoutedEvent PreviewDragOverEvent;
    public static RoutedEvent DragOverEvent;
    public static RoutedEvent PreviewDragLeaveEvent;
    public static RoutedEvent DragLeaveEvent;
    public static RoutedEvent PreviewDropEvent;
    public static RoutedEvent DropEvent;
    internal static RoutedEvent DragDropStartedEvent;
    internal static RoutedEvent DragDropCompletedEvent;
    private static DragDrop();
    public static void AddPreviewQueryContinueDragHandler(DependencyObject element, QueryContinueDragEventHandler handler);
    public static void RemovePreviewQueryContinueDragHandler(DependencyObject element, QueryContinueDragEventHandler handler);
    public static void AddQueryContinueDragHandler(DependencyObject element, QueryContinueDragEventHandler handler);
    public static void RemoveQueryContinueDragHandler(DependencyObject element, QueryContinueDragEventHandler handler);
    public static void AddPreviewGiveFeedbackHandler(DependencyObject element, GiveFeedbackEventHandler handler);
    public static void RemovePreviewGiveFeedbackHandler(DependencyObject element, GiveFeedbackEventHandler handler);
    public static void AddGiveFeedbackHandler(DependencyObject element, GiveFeedbackEventHandler handler);
    public static void RemoveGiveFeedbackHandler(DependencyObject element, GiveFeedbackEventHandler handler);
    public static void AddPreviewDragEnterHandler(DependencyObject element, DragEventHandler handler);
    public static void RemovePreviewDragEnterHandler(DependencyObject element, DragEventHandler handler);
    public static void AddDragEnterHandler(DependencyObject element, DragEventHandler handler);
    public static void RemoveDragEnterHandler(DependencyObject element, DragEventHandler handler);
    public static void AddPreviewDragOverHandler(DependencyObject element, DragEventHandler handler);
    public static void RemovePreviewDragOverHandler(DependencyObject element, DragEventHandler handler);
    public static void AddDragOverHandler(DependencyObject element, DragEventHandler handler);
    public static void RemoveDragOverHandler(DependencyObject element, DragEventHandler handler);
    public static void AddPreviewDragLeaveHandler(DependencyObject element, DragEventHandler handler);
    public static void RemovePreviewDragLeaveHandler(DependencyObject element, DragEventHandler handler);
    public static void AddDragLeaveHandler(DependencyObject element, DragEventHandler handler);
    public static void RemoveDragLeaveHandler(DependencyObject element, DragEventHandler handler);
    public static void AddPreviewDropHandler(DependencyObject element, DragEventHandler handler);
    public static void RemovePreviewDropHandler(DependencyObject element, DragEventHandler handler);
    public static void AddDropHandler(DependencyObject element, DragEventHandler handler);
    public static void RemoveDropHandler(DependencyObject element, DragEventHandler handler);
    public static DragDropEffects DoDragDrop(DependencyObject dragSource, object data, DragDropEffects allowedEffects);
    internal static void RegisterDropTarget(IntPtr windowHandle);
    internal static void RevokeDropTarget(IntPtr windowHandle);
    internal static bool IsValidDragDropEffects(DragDropEffects dragDropEffects);
    internal static bool IsValidDragAction(DragAction dragAction);
    internal static bool IsValidDragDropKeyStates(DragDropKeyStates dragDropKeyStates);
    private static DragDropEffects OleDoDragDrop(DependencyObject dragSource, DataObject dataObject, DragDropEffects allowedEffects);
}
[FlagsAttribute]
public enum System.Windows.DragDropEffects : Enum {
    public int value__;
    public static DragDropEffects None;
    public static DragDropEffects Copy;
    public static DragDropEffects Move;
    public static DragDropEffects Link;
    public static DragDropEffects Scroll;
    public static DragDropEffects All;
}
[FlagsAttribute]
public enum System.Windows.DragDropKeyStates : Enum {
    public int value__;
    public static DragDropKeyStates None;
    public static DragDropKeyStates LeftMouseButton;
    public static DragDropKeyStates RightMouseButton;
    public static DragDropKeyStates ShiftKey;
    public static DragDropKeyStates ControlKey;
    public static DragDropKeyStates MiddleMouseButton;
    public static DragDropKeyStates AltKey;
}
public class System.Windows.DragEventArgs : RoutedEventArgs {
    private IDataObject _data;
    private DragDropKeyStates _dragDropKeyStates;
    private DragDropEffects _allowedEffects;
    private DragDropEffects _effects;
    private DependencyObject _target;
    private Point _dropPoint;
    public IDataObject Data { get; }
    public DragDropKeyStates KeyStates { get; }
    public DragDropEffects AllowedEffects { get; }
    public DragDropEffects Effects { get; public set; }
    internal DragEventArgs(IDataObject data, DragDropKeyStates dragDropKeyStates, DragDropEffects allowedEffects, DependencyObject target, Point point);
    public Point GetPosition(IInputElement relativeTo);
    public IDataObject get_Data();
    public DragDropKeyStates get_KeyStates();
    public DragDropEffects get_AllowedEffects();
    public DragDropEffects get_Effects();
    public void set_Effects(DragDropEffects value);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.DragEventHandler : MulticastDelegate {
    public DragEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DragEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DragEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[TypeConverterAttribute("System.Windows.DurationConverter")]
public class System.Windows.Duration : ValueType {
    private TimeSpan _timeSpan;
    private DurationType _durationType;
    public bool HasTimeSpan { get; }
    public static Duration Automatic { get; }
    public static Duration Forever { get; }
    public TimeSpan TimeSpan { get; }
    public Duration(TimeSpan timeSpan);
    public static Duration op_Implicit(TimeSpan timeSpan);
    public static Duration op_Addition(Duration t1, Duration t2);
    public static Duration op_Subtraction(Duration t1, Duration t2);
    public static bool op_Equality(Duration t1, Duration t2);
    public static bool op_Inequality(Duration t1, Duration t2);
    public static bool op_GreaterThan(Duration t1, Duration t2);
    public static bool op_GreaterThanOrEqual(Duration t1, Duration t2);
    public static bool op_LessThan(Duration t1, Duration t2);
    public static bool op_LessThanOrEqual(Duration t1, Duration t2);
    public static int Compare(Duration t1, Duration t2);
    public static Duration Plus(Duration duration);
    public static Duration op_UnaryPlus(Duration duration);
    public bool get_HasTimeSpan();
    public static Duration get_Automatic();
    public static Duration get_Forever();
    public TimeSpan get_TimeSpan();
    public Duration Add(Duration duration);
    public virtual bool Equals(object value);
    public bool Equals(Duration duration);
    public static bool Equals(Duration t1, Duration t2);
    public virtual int GetHashCode();
    public Duration Subtract(Duration duration);
    public virtual string ToString();
}
public class System.Windows.DurationConverter : TypeConverter {
    private static TimeSpanConverter _timeSpanConverter;
    public virtual bool CanConvertFrom(ITypeDescriptorContext td, Type t);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext td, CultureInfo cultureInfo, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo cultureInfo, object value, Type destinationType);
}
[DefaultMemberAttribute("Item")]
[FriendAccessAllowedAttribute]
internal class System.Windows.EventHandlersStore : object {
    private FrugalMap _entries;
    private static FrugalMapIterationCallback _iterationCallback;
    internal FrugalObjectList`1<RoutedEventHandlerInfo> Item { get; }
    internal Delegate Item { get; }
    internal int Count { get; }
    public EventHandlersStore(EventHandlersStore source);
    private static EventHandlersStore();
    public void Add(EventPrivateKey key, Delegate handler);
    public void Remove(EventPrivateKey key, Delegate handler);
    public Delegate Get(EventPrivateKey key);
    public void AddRoutedEventHandler(RoutedEvent routedEvent, Delegate handler, bool handledEventsToo);
    public void RemoveRoutedEventHandler(RoutedEvent routedEvent, Delegate handler);
    public bool Contains(RoutedEvent routedEvent);
    private static void OnEventHandlersIterationCallback(ArrayList list, int key, object value);
    public RoutedEventHandlerInfo[] GetRoutedEventHandlers(RoutedEvent routedEvent);
    internal FrugalObjectList`1<RoutedEventHandlerInfo> get_Item(RoutedEvent key);
    internal Delegate get_Item(EventPrivateKey key);
    internal int get_Count();
}
public static class System.Windows.EventManager : object {
    public static RoutedEvent RegisterRoutedEvent(string name, RoutingStrategy routingStrategy, Type handlerType, Type ownerType);
    public static void RegisterClassHandler(Type classType, RoutedEvent routedEvent, Delegate handler);
    public static void RegisterClassHandler(Type classType, RoutedEvent routedEvent, Delegate handler, bool handledEventsToo);
    public static RoutedEvent[] GetRoutedEvents();
    public static RoutedEvent[] GetRoutedEventsForOwner(Type ownerType);
    [FriendAccessAllowedAttribute]
internal static RoutedEvent GetRoutedEventFromName(string name, Type ownerType);
}
public class System.Windows.EventPrivateKey : object {
    private int _globalIndex;
    internal int GlobalIndex { get; }
    internal int get_GlobalIndex();
}
public class System.Windows.EventRoute : object {
    private RoutedEvent _routedEvent;
    private FrugalStructList`1<RouteItem> _routeItemList;
    private Stack`1<BranchNode> _branchNodeStack;
    private FrugalStructList`1<SourceItem> _sourceItemList;
    internal RoutedEvent RoutedEvent { get; internal set; }
    private Stack`1<BranchNode> BranchNodeStack { get; }
    public EventRoute(RoutedEvent routedEvent);
    public void Add(object target, Delegate handler, bool handledEventsToo);
    internal void InvokeHandlers(object source, RoutedEventArgs args);
    internal void ReInvokeHandlers(object source, RoutedEventArgs args);
    private void InvokeHandlersImpl(object source, RoutedEventArgs args, bool reRaised);
    [EditorBrowsableAttribute("2")]
public void PushBranchNode(object node, object source);
    [EditorBrowsableAttribute("2")]
public object PopBranchNode();
    [EditorBrowsableAttribute("2")]
public object PeekBranchNode();
    [EditorBrowsableAttribute("2")]
public object PeekBranchSource();
    internal RoutedEvent get_RoutedEvent();
    internal void set_RoutedEvent(RoutedEvent value);
    private Stack`1<BranchNode> get_BranchNodeStack();
    internal void AddSource(object source);
    private object GetBubbleSource(int index, Int32& endIndex);
    private object GetTunnelSource(int index, Int32& startIndex);
    internal void Clear();
}
internal static class System.Windows.EventRouteFactory : object {
    private static EventRoute[] _eventRouteStack;
    private static int _stackTop;
    private static object _synchronized;
    private static EventRouteFactory();
    internal static EventRoute FetchObject(RoutedEvent routedEvent);
    internal static void RecycleObject(EventRoute eventRoute);
    private static void Push(EventRoute eventRoute);
    private static EventRoute Pop();
}
[LocalizabilityAttribute("0")]
public enum System.Windows.FlowDirection : Enum {
    public int value__;
    public static FlowDirection LeftToRight;
    public static FlowDirection RightToLeft;
}
internal class System.Windows.FocusWithinProperty : ReverseInheritProperty {
    internal virtual void FireNotifications(UIElement uie, ContentElement ce, UIElement3D uie3D, bool oldValue);
}
public enum System.Windows.FontCapitals : Enum {
    public int value__;
    public static FontCapitals Normal;
    public static FontCapitals AllSmallCaps;
    public static FontCapitals SmallCaps;
    public static FontCapitals AllPetiteCaps;
    public static FontCapitals PetiteCaps;
    public static FontCapitals Unicase;
    public static FontCapitals Titling;
}
public enum System.Windows.FontEastAsianLanguage : Enum {
    public int value__;
    public static FontEastAsianLanguage Normal;
    public static FontEastAsianLanguage Jis78;
    public static FontEastAsianLanguage Jis83;
    public static FontEastAsianLanguage Jis90;
    public static FontEastAsianLanguage Jis04;
    public static FontEastAsianLanguage HojoKanji;
    public static FontEastAsianLanguage NlcKanji;
    public static FontEastAsianLanguage Simplified;
    public static FontEastAsianLanguage Traditional;
    public static FontEastAsianLanguage TraditionalNames;
}
public enum System.Windows.FontEastAsianWidths : Enum {
    public int value__;
    public static FontEastAsianWidths Normal;
    public static FontEastAsianWidths Proportional;
    public static FontEastAsianWidths Full;
    public static FontEastAsianWidths Half;
    public static FontEastAsianWidths Third;
    public static FontEastAsianWidths Quarter;
}
public enum System.Windows.FontFraction : Enum {
    public int value__;
    public static FontFraction Normal;
    public static FontFraction Slashed;
    public static FontFraction Stacked;
}
public enum System.Windows.FontNumeralAlignment : Enum {
    public int value__;
    public static FontNumeralAlignment Normal;
    public static FontNumeralAlignment Proportional;
    public static FontNumeralAlignment Tabular;
}
public enum System.Windows.FontNumeralStyle : Enum {
    public int value__;
    public static FontNumeralStyle Normal;
    public static FontNumeralStyle Lining;
    public static FontNumeralStyle OldStyle;
}
[LocalizabilityAttribute("0")]
[TypeConverterAttribute("System.Windows.FontStretchConverter")]
public class System.Windows.FontStretch : ValueType {
    private int _stretch;
    private int RealStretch { get; }
    internal FontStretch(int stretch);
    public static FontStretch FromOpenTypeStretch(int stretchValue);
    public int ToOpenTypeStretch();
    public static int Compare(FontStretch left, FontStretch right);
    public static bool op_LessThan(FontStretch left, FontStretch right);
    public static bool op_LessThanOrEqual(FontStretch left, FontStretch right);
    public static bool op_GreaterThan(FontStretch left, FontStretch right);
    public static bool op_GreaterThanOrEqual(FontStretch left, FontStretch right);
    public static bool op_Equality(FontStretch left, FontStretch right);
    public static bool op_Inequality(FontStretch left, FontStretch right);
    public bool Equals(FontStretch obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    private string ConvertToString(string format, IFormatProvider provider);
    private int get_RealStretch();
}
public class System.Windows.FontStretchConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext td, Type t);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext td, CultureInfo ci, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public static class System.Windows.FontStretches : object {
    public static FontStretch UltraCondensed { get; }
    public static FontStretch ExtraCondensed { get; }
    public static FontStretch Condensed { get; }
    public static FontStretch SemiCondensed { get; }
    public static FontStretch Normal { get; }
    public static FontStretch Medium { get; }
    public static FontStretch SemiExpanded { get; }
    public static FontStretch Expanded { get; }
    public static FontStretch ExtraExpanded { get; }
    public static FontStretch UltraExpanded { get; }
    public static FontStretch get_UltraCondensed();
    public static FontStretch get_ExtraCondensed();
    public static FontStretch get_Condensed();
    public static FontStretch get_SemiCondensed();
    public static FontStretch get_Normal();
    public static FontStretch get_Medium();
    public static FontStretch get_SemiExpanded();
    public static FontStretch get_Expanded();
    public static FontStretch get_ExtraExpanded();
    public static FontStretch get_UltraExpanded();
    internal static bool FontStretchStringToKnownStretch(string s, IFormatProvider provider, FontStretch& fontStretch);
    internal static bool FontStretchToString(int stretch, String& convertedValue);
}
[LocalizabilityAttribute("0")]
[TypeConverterAttribute("System.Windows.FontStyleConverter")]
public class System.Windows.FontStyle : ValueType {
    private int _style;
    internal FontStyle(int style);
    public static bool op_Equality(FontStyle left, FontStyle right);
    public static bool op_Inequality(FontStyle left, FontStyle right);
    public bool Equals(FontStyle obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal int GetStyleForInternalConstruction();
    private string ConvertToString(string format, IFormatProvider provider);
}
public class System.Windows.FontStyleConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext td, Type t);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext td, CultureInfo ci, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public static class System.Windows.FontStyles : object {
    public static FontStyle Normal { get; }
    public static FontStyle Oblique { get; }
    public static FontStyle Italic { get; }
    public static FontStyle get_Normal();
    public static FontStyle get_Oblique();
    public static FontStyle get_Italic();
    internal static bool FontStyleStringToKnownStyle(string s, IFormatProvider provider, FontStyle& fontStyle);
}
public enum System.Windows.FontVariants : Enum {
    public int value__;
    public static FontVariants Normal;
    public static FontVariants Superscript;
    public static FontVariants Subscript;
    public static FontVariants Ordinal;
    public static FontVariants Inferior;
    public static FontVariants Ruby;
}
[LocalizabilityAttribute("0")]
[TypeConverterAttribute("System.Windows.FontWeightConverter")]
public class System.Windows.FontWeight : ValueType {
    private int _weight;
    private int RealWeight { get; }
    internal FontWeight(int weight);
    public static FontWeight FromOpenTypeWeight(int weightValue);
    public int ToOpenTypeWeight();
    public static int Compare(FontWeight left, FontWeight right);
    public static bool op_LessThan(FontWeight left, FontWeight right);
    public static bool op_LessThanOrEqual(FontWeight left, FontWeight right);
    public static bool op_GreaterThan(FontWeight left, FontWeight right);
    public static bool op_GreaterThanOrEqual(FontWeight left, FontWeight right);
    public static bool op_Equality(FontWeight left, FontWeight right);
    public static bool op_Inequality(FontWeight left, FontWeight right);
    public bool Equals(FontWeight obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    private string ConvertToString(string format, IFormatProvider provider);
    private int get_RealWeight();
}
public class System.Windows.FontWeightConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext td, Type t);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext td, CultureInfo ci, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public static class System.Windows.FontWeights : object {
    public static FontWeight Thin { get; }
    public static FontWeight ExtraLight { get; }
    public static FontWeight UltraLight { get; }
    public static FontWeight Light { get; }
    public static FontWeight Normal { get; }
    public static FontWeight Regular { get; }
    public static FontWeight Medium { get; }
    public static FontWeight DemiBold { get; }
    public static FontWeight SemiBold { get; }
    public static FontWeight Bold { get; }
    public static FontWeight ExtraBold { get; }
    public static FontWeight UltraBold { get; }
    public static FontWeight Black { get; }
    public static FontWeight Heavy { get; }
    public static FontWeight ExtraBlack { get; }
    public static FontWeight UltraBlack { get; }
    public static FontWeight get_Thin();
    public static FontWeight get_ExtraLight();
    public static FontWeight get_UltraLight();
    public static FontWeight get_Light();
    public static FontWeight get_Normal();
    public static FontWeight get_Regular();
    public static FontWeight get_Medium();
    public static FontWeight get_DemiBold();
    public static FontWeight get_SemiBold();
    public static FontWeight get_Bold();
    public static FontWeight get_ExtraBold();
    public static FontWeight get_UltraBold();
    public static FontWeight get_Black();
    public static FontWeight get_Heavy();
    public static FontWeight get_ExtraBlack();
    public static FontWeight get_UltraBlack();
    internal static bool FontWeightStringToKnownWeight(string s, IFormatProvider provider, FontWeight& fontWeight);
    internal static bool FontWeightToString(int weight, String& convertedValue);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.FreezableCollection`1 : Animatable {
    [CompilerGeneratedAttribute]
private NotifyCollectionChangedEventHandler CollectionChanged;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PrivatePropertyChanged;
    internal List`1<T> _collection;
    internal UInt32 _version;
    private static string CountPropertyName;
    private static string IndexerPropertyName;
    private SimpleMonitor<T> _monitor;
    public T Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public FreezableCollection`1(int capacity);
    public FreezableCollection`1(IEnumerable`1<T> collection);
    public FreezableCollection`1<T> Clone();
    public FreezableCollection`1<T> CloneCurrentValue();
    public sealed virtual void Add(T value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T value);
    public sealed virtual int IndexOf(T value);
    public sealed virtual void Insert(int index, T value);
    public sealed virtual bool Remove(T value);
    public sealed virtual void RemoveAt(int index);
    internal void RemoveAtWithoutFiringPublicEvents(int index);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(T[] array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.Specialized.INotifyCollectionChanged.add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    private sealed virtual override void System.Collections.Specialized.INotifyCollectionChanged.remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
private void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
private void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    private void OnCollectionChanged(NotifyCollectionChangedEventArgs e);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
private void add_PrivatePropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
private void remove_PrivatePropertyChanged(PropertyChangedEventHandler value);
    private void OnPropertyChanged(PropertyChangedEventArgs e);
    internal virtual void OnInheritanceContextChangedCore(EventArgs args);
    private T Cast(object value);
    private int GetCount(IEnumerable`1<T> enumerable);
    private int AddHelper(T value);
    internal int AddWithoutFiringPublicEvents(T value);
    private void OnCollectionChanged(NotifyCollectionChangedAction action, int oldIndex, T oldValue, int newIndex, T newValue);
    protected virtual Freezable CreateInstanceCore();
    private void CloneCommon(FreezableCollection`1<T> source, CloneCommonType<T> cloneType);
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected virtual bool FreezeCore(bool isChecking);
    private IDisposable BlockReentrancy();
    private void CheckReentrancy();
}
public class System.Windows.GiveFeedbackEventArgs : RoutedEventArgs {
    private DragDropEffects _effects;
    private bool _useDefaultCursors;
    public DragDropEffects Effects { get; }
    public bool UseDefaultCursors { get; public set; }
    internal GiveFeedbackEventArgs(DragDropEffects effects, bool useDefaultCursors);
    public DragDropEffects get_Effects();
    public bool get_UseDefaultCursors();
    public void set_UseDefaultCursors(bool value);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.GiveFeedbackEventHandler : MulticastDelegate {
    public GiveFeedbackEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, GiveFeedbackEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, GiveFeedbackEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class System.Windows.GlobalEventManager : object {
    private static ArrayList _globalIndexToEventMap;
    private static DTypeMap _dTypedRoutedEventList;
    private static Hashtable _ownerTypedRoutedEventList;
    private static int _countRoutedEvents;
    private static DTypeMap _dTypedClassListeners;
    private static DependencyObjectType _dependencyObjectType;
    internal static object Synchronized;
    private static GlobalEventManager();
    internal static RoutedEvent RegisterRoutedEvent(string name, RoutingStrategy routingStrategy, Type handlerType, Type ownerType);
    internal static void RegisterClassHandler(Type classType, RoutedEvent routedEvent, Delegate handler, bool handledEventsToo);
    internal static RoutedEvent[] GetRoutedEvents();
    internal static void AddOwner(RoutedEvent routedEvent, Type ownerType);
    internal static RoutedEvent[] GetRoutedEventsForOwner(Type ownerType);
    internal static RoutedEvent GetRoutedEventFromName(string name, Type ownerType, bool includeSupers);
    internal static RoutedEventHandlerInfoList GetDTypedClassListeners(DependencyObjectType dType, RoutedEvent routedEvent);
    internal static RoutedEventHandlerInfoList GetDTypedClassListeners(DependencyObjectType dType, RoutedEvent routedEvent, ClassHandlersStore& classListenersLists, Int32& index);
    private static RoutedEventHandlerInfoList GetUpdatedDTypedClassListeners(DependencyObjectType dType, RoutedEvent routedEvent, ClassHandlersStore& classListenersLists, Int32& index);
    internal static int GetNextAvailableGlobalIndex(object value);
    internal static object EventFromGlobalIndex(int globalIndex);
}
internal class System.Windows.HwndDpiChangedAfterParentEventArgs : HandledEventArgs {
    [CompilerGeneratedAttribute]
private DpiScale <OldDpi>k__BackingField;
    [CompilerGeneratedAttribute]
private DpiScale <NewDpi>k__BackingField;
    [CompilerGeneratedAttribute]
private Rect <SuggestedRect>k__BackingField;
    internal DpiScale OldDpi { get; }
    internal DpiScale NewDpi { get; }
    internal Rect SuggestedRect { get; }
    internal HwndDpiChangedAfterParentEventArgs(DpiScale oldDpi, DpiScale newDpi, Rect suggestedRect);
    internal HwndDpiChangedAfterParentEventArgs(HwndDpiChangedEventArgs e);
    [CompilerGeneratedAttribute]
internal DpiScale get_OldDpi();
    [CompilerGeneratedAttribute]
internal DpiScale get_NewDpi();
    [CompilerGeneratedAttribute]
internal Rect get_SuggestedRect();
    public static HwndDpiChangedEventArgs op_Explicit(HwndDpiChangedAfterParentEventArgs e);
}
public class System.Windows.HwndDpiChangedEventArgs : HandledEventArgs {
    [CompilerGeneratedAttribute]
private DpiScale <OldDpi>k__BackingField;
    [CompilerGeneratedAttribute]
private DpiScale <NewDpi>k__BackingField;
    [CompilerGeneratedAttribute]
private Rect <SuggestedRect>k__BackingField;
    public DpiScale OldDpi { get; private set; }
    public DpiScale NewDpi { get; private set; }
    public Rect SuggestedRect { get; private set; }
    [ObsoleteAttribute]
internal HwndDpiChangedEventArgs(double oldDpiX, double oldDpiY, double newDpiX, double newDpiY, IntPtr lParam);
    internal HwndDpiChangedEventArgs(DpiScale oldDpi, DpiScale newDpi, Rect suggestedRect);
    [CompilerGeneratedAttribute]
public DpiScale get_OldDpi();
    [CompilerGeneratedAttribute]
private void set_OldDpi(DpiScale value);
    [CompilerGeneratedAttribute]
public DpiScale get_NewDpi();
    [CompilerGeneratedAttribute]
private void set_NewDpi(DpiScale value);
    [CompilerGeneratedAttribute]
public Rect get_SuggestedRect();
    [CompilerGeneratedAttribute]
private void set_SuggestedRect(Rect value);
}
public class System.Windows.HwndDpiChangedEventHandler : MulticastDelegate {
    public HwndDpiChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, HwndDpiChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, HwndDpiChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public interface System.Windows.IContentHost {
    public IEnumerator`1<IInputElement> HostedElements { get; }
    public abstract virtual IInputElement InputHitTest(Point point);
    public abstract virtual ReadOnlyCollection`1<Rect> GetRectangles(ContentElement child);
    public abstract virtual IEnumerator`1<IInputElement> get_HostedElements();
    public abstract virtual void OnChildDesiredSizeChanged(UIElement child);
}
public interface System.Windows.IDataObject {
    public abstract virtual object GetData(string format);
    public abstract virtual object GetData(Type format);
    public abstract virtual object GetData(string format, bool autoConvert);
    public abstract virtual bool GetDataPresent(string format);
    public abstract virtual bool GetDataPresent(Type format);
    public abstract virtual bool GetDataPresent(string format, bool autoConvert);
    public abstract virtual String[] GetFormats();
    public abstract virtual String[] GetFormats(bool autoConvert);
    public abstract virtual void SetData(object data);
    public abstract virtual void SetData(string format, object data);
    public abstract virtual void SetData(Type format, object data);
    public abstract virtual void SetData(string format, object data, bool autoConvert);
}
public interface System.Windows.IInputElement {
    public bool IsMouseOver { get; }
    public bool IsMouseDirectlyOver { get; }
    public bool IsMouseCaptured { get; }
    public bool IsStylusOver { get; }
    public bool IsStylusDirectlyOver { get; }
    public bool IsStylusCaptured { get; }
    public bool IsKeyboardFocusWithin { get; }
    public bool IsKeyboardFocused { get; }
    public bool IsEnabled { get; }
    public bool Focusable { get; public set; }
    public abstract virtual void RaiseEvent(RoutedEventArgs e);
    public abstract virtual void AddHandler(RoutedEvent routedEvent, Delegate handler);
    public abstract virtual void RemoveHandler(RoutedEvent routedEvent, Delegate handler);
    public abstract virtual bool get_IsMouseOver();
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewMouseLeftButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewMouseLeftButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_MouseLeftButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_MouseLeftButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewMouseLeftButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewMouseLeftButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_MouseLeftButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_MouseLeftButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewMouseRightButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewMouseRightButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_MouseRightButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_MouseRightButtonDown(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewMouseRightButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewMouseRightButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_MouseRightButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_MouseRightButtonUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewMouseMove(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewMouseMove(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_MouseMove(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_MouseMove(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewMouseWheel(MouseWheelEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewMouseWheel(MouseWheelEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_MouseWheel(MouseWheelEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_MouseWheel(MouseWheelEventHandler value);
    public abstract virtual bool get_IsMouseDirectlyOver();
    [CompilerGeneratedAttribute]
public abstract virtual void add_MouseEnter(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_MouseEnter(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_MouseLeave(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_MouseLeave(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_GotMouseCapture(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_GotMouseCapture(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_LostMouseCapture(MouseEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_LostMouseCapture(MouseEventHandler value);
    public abstract virtual bool get_IsMouseCaptured();
    public abstract virtual bool CaptureMouse();
    public abstract virtual void ReleaseMouseCapture();
    public abstract virtual bool get_IsStylusOver();
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewStylusDown(StylusDownEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewStylusDown(StylusDownEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StylusDown(StylusDownEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StylusDown(StylusDownEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewStylusUp(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewStylusUp(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StylusUp(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StylusUp(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewStylusMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewStylusMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StylusMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StylusMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewStylusInAirMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewStylusInAirMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StylusInAirMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StylusInAirMove(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StylusEnter(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StylusEnter(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StylusLeave(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StylusLeave(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewStylusInRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewStylusInRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StylusInRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StylusInRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewStylusOutOfRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewStylusOutOfRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StylusOutOfRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StylusOutOfRange(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewStylusSystemGesture(StylusSystemGestureEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewStylusSystemGesture(StylusSystemGestureEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StylusSystemGesture(StylusSystemGestureEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StylusSystemGesture(StylusSystemGestureEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StylusButtonDown(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StylusButtonDown(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewStylusButtonDown(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewStylusButtonDown(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewStylusButtonUp(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewStylusButtonUp(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StylusButtonUp(StylusButtonEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StylusButtonUp(StylusButtonEventHandler value);
    public abstract virtual bool get_IsStylusDirectlyOver();
    [CompilerGeneratedAttribute]
public abstract virtual void add_GotStylusCapture(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_GotStylusCapture(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_LostStylusCapture(StylusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_LostStylusCapture(StylusEventHandler value);
    public abstract virtual bool get_IsStylusCaptured();
    public abstract virtual bool CaptureStylus();
    public abstract virtual void ReleaseStylusCapture();
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewKeyDown(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewKeyDown(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_KeyDown(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_KeyDown(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewKeyUp(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewKeyUp(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_KeyUp(KeyEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_KeyUp(KeyEventHandler value);
    public abstract virtual bool get_IsKeyboardFocusWithin();
    public abstract virtual bool get_IsKeyboardFocused();
    public abstract virtual bool Focus();
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewGotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewGotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_GotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_GotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewLostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewLostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_LostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_LostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    public abstract virtual bool get_IsEnabled();
    public abstract virtual bool get_Focusable();
    public abstract virtual void set_Focusable(bool value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PreviewTextInput(TextCompositionEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PreviewTextInput(TextCompositionEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_TextInput(TextCompositionEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_TextInput(TextCompositionEventHandler value);
}
public enum System.Windows.Ink.ApplicationGesture : Enum {
    public int value__;
    public static ApplicationGesture AllGestures;
    public static ApplicationGesture ArrowDown;
    public static ApplicationGesture ArrowLeft;
    public static ApplicationGesture ArrowRight;
    public static ApplicationGesture ArrowUp;
    public static ApplicationGesture Check;
    public static ApplicationGesture ChevronDown;
    public static ApplicationGesture ChevronLeft;
    public static ApplicationGesture ChevronRight;
    public static ApplicationGesture ChevronUp;
    public static ApplicationGesture Circle;
    public static ApplicationGesture Curlicue;
    public static ApplicationGesture DoubleCircle;
    public static ApplicationGesture DoubleCurlicue;
    public static ApplicationGesture DoubleTap;
    public static ApplicationGesture Down;
    public static ApplicationGesture DownLeft;
    public static ApplicationGesture DownLeftLong;
    public static ApplicationGesture DownRight;
    public static ApplicationGesture DownRightLong;
    public static ApplicationGesture DownUp;
    public static ApplicationGesture Exclamation;
    public static ApplicationGesture Left;
    public static ApplicationGesture LeftDown;
    public static ApplicationGesture LeftRight;
    public static ApplicationGesture LeftUp;
    public static ApplicationGesture NoGesture;
    public static ApplicationGesture Right;
    public static ApplicationGesture RightDown;
    public static ApplicationGesture RightLeft;
    public static ApplicationGesture RightUp;
    public static ApplicationGesture ScratchOut;
    public static ApplicationGesture SemicircleLeft;
    public static ApplicationGesture SemicircleRight;
    public static ApplicationGesture Square;
    public static ApplicationGesture Star;
    public static ApplicationGesture Tap;
    public static ApplicationGesture Triangle;
    public static ApplicationGesture Up;
    public static ApplicationGesture UpDown;
    public static ApplicationGesture UpLeft;
    public static ApplicationGesture UpLeftLong;
    public static ApplicationGesture UpRight;
    public static ApplicationGesture UpRightLong;
}
internal static class System.Windows.Ink.ApplicationGestureHelper : object {
    internal static int CountOfValues;
    private static ApplicationGestureHelper();
    internal static bool IsDefined(ApplicationGesture applicationGesture);
}
internal enum System.Windows.Ink.CompressionMode : Enum {
    public int value__;
    public static CompressionMode Compressed;
    public static CompressionMode NoCompression;
}
public static class System.Windows.Ink.DrawingAttributeIds : object {
    public static Guid Color;
    public static Guid StylusTip;
    public static Guid StylusTipTransform;
    public static Guid StylusHeight;
    public static Guid StylusWidth;
    public static Guid DrawingFlags;
    public static Guid IsHighlighter;
    private static DrawingAttributeIds();
}
public class System.Windows.Ink.DrawingAttributes : object {
    [CompilerGeneratedAttribute]
private PropertyDataChangedEventHandler AttributeChanged;
    [CompilerGeneratedAttribute]
private PropertyDataChangedEventHandler PropertyDataChanged;
    private PropertyChangedEventHandler _propertyChanged;
    private ExtendedPropertyCollection _extendedProperties;
    private UInt32 _v1RasterOperation;
    private bool _heightChangedForCompatabity;
    internal static float StylusPrecision;
    internal static double DefaultWidth;
    internal static double DefaultHeight;
    public static double MinHeight;
    public static double MinWidth;
    public static double MaxHeight;
    public static double MaxWidth;
    public Color Color { get; public set; }
    public StylusTip StylusTip { get; public set; }
    public Matrix StylusTipTransform { get; public set; }
    public double Height { get; public set; }
    public double Width { get; public set; }
    public bool FitToCurve { get; public set; }
    public bool IgnorePressure { get; public set; }
    public bool IsHighlighter { get; public set; }
    internal ExtendedPropertyCollection ExtendedProperties { get; }
    internal StylusShape StylusShape { get; }
    internal int FittingError { get; internal set; }
    internal DrawingFlags DrawingFlags { get; internal set; }
    internal UInt32 RasterOperation { get; internal set; }
    internal bool HeightChangedForCompatabity { get; internal set; }
    internal DrawingAttributes(ExtendedPropertyCollection extendedProperties);
    private static DrawingAttributes();
    private void Initialize();
    public Color get_Color();
    public void set_Color(Color value);
    public StylusTip get_StylusTip();
    public void set_StylusTip(StylusTip value);
    public Matrix get_StylusTipTransform();
    public void set_StylusTipTransform(Matrix value);
    public double get_Height();
    public void set_Height(double value);
    public double get_Width();
    public void set_Width(double value);
    public bool get_FitToCurve();
    public void set_FitToCurve(bool value);
    public bool get_IgnorePressure();
    public void set_IgnorePressure(bool value);
    public bool get_IsHighlighter();
    public void set_IsHighlighter(bool value);
    public void AddPropertyData(Guid propertyDataId, object propertyData);
    public void RemovePropertyData(Guid propertyDataId);
    public object GetPropertyData(Guid propertyDataId);
    public Guid[] GetPropertyDataIds();
    public bool ContainsPropertyData(Guid propertyDataId);
    internal ExtendedPropertyCollection get_ExtendedProperties();
    internal ExtendedPropertyCollection CopyPropertyData();
    internal StylusShape get_StylusShape();
    internal int get_FittingError();
    internal void set_FittingError(int value);
    internal DrawingFlags get_DrawingFlags();
    internal void set_DrawingFlags(DrawingFlags value);
    internal UInt32 get_RasterOperation();
    internal void set_RasterOperation(UInt32 value);
    internal bool get_HeightChangedForCompatabity();
    internal void set_HeightChangedForCompatabity(bool value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public static bool op_Equality(DrawingAttributes first, DrawingAttributes second);
    public static bool op_Inequality(DrawingAttributes first, DrawingAttributes second);
    public virtual DrawingAttributes Clone();
    [CompilerGeneratedAttribute]
public void add_AttributeChanged(PropertyDataChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_AttributeChanged(PropertyDataChangedEventHandler value);
    protected virtual void OnAttributeChanged(PropertyDataChangedEventArgs e);
    [CompilerGeneratedAttribute]
public void add_PropertyDataChanged(PropertyDataChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PropertyDataChanged(PropertyDataChangedEventHandler value);
    protected virtual void OnPropertyDataChanged(PropertyDataChangedEventArgs e);
    protected virtual void OnPropertyChanged(PropertyChangedEventArgs e);
    internal static object GetDefaultDrawingAttributeValue(Guid id);
    internal static void ValidateStylusTipTransform(Guid propertyDataId, object propertyData);
    internal static bool RemoveIdFromExtendedProperties(Guid id);
    internal static bool GeometricallyEqual(DrawingAttributes left, DrawingAttributes right);
    internal static bool IsGeometricalDaGuid(Guid guid);
    private void ExtendedPropertiesChanged_EventForwarder(object sender, ExtendedPropertiesChangedEventArgs args);
    private void SetExtendedPropertyBackedProperty(Guid id, object value);
    private object GetExtendedPropertyBackedProperty(Guid id);
    private void PrivateNotifyPropertyChanged(PropertyDataChangedEventArgs e);
    private void OnPropertyChanged(string propertyName);
}
public class System.Windows.Ink.DrawingAttributesReplacedEventArgs : EventArgs {
    private DrawingAttributes _newDrawingAttributes;
    private DrawingAttributes _previousDrawingAttributes;
    public DrawingAttributes NewDrawingAttributes { get; }
    public DrawingAttributes PreviousDrawingAttributes { get; }
    public DrawingAttributesReplacedEventArgs(DrawingAttributes newDrawingAttributes, DrawingAttributes previousDrawingAttributes);
    public DrawingAttributes get_NewDrawingAttributes();
    public DrawingAttributes get_PreviousDrawingAttributes();
}
public class System.Windows.Ink.DrawingAttributesReplacedEventHandler : MulticastDelegate {
    public DrawingAttributesReplacedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DrawingAttributesReplacedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DrawingAttributesReplacedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[FlagsAttribute]
internal enum System.Windows.Ink.DrawingFlags : Enum {
    public int value__;
    public static DrawingFlags Polyline;
    public static DrawingFlags FitToCurve;
    public static DrawingFlags SubtractiveTransparency;
    public static DrawingFlags IgnorePressure;
    public static DrawingFlags AntiAliased;
    public static DrawingFlags IgnoreRotation;
    public static DrawingFlags IgnoreAngle;
}
public class System.Windows.Ink.EllipseStylusShape : StylusShape {
    public EllipseStylusShape(double width, double height);
    public EllipseStylusShape(double width, double height, double rotation);
}
internal class System.Windows.Ink.ExtendedPropertiesChangedEventArgs : EventArgs {
    private ExtendedProperty _oldProperty;
    private ExtendedProperty _newProperty;
    internal ExtendedProperty OldProperty { get; }
    internal ExtendedProperty NewProperty { get; }
    internal ExtendedPropertiesChangedEventArgs(ExtendedProperty oldProperty, ExtendedProperty newProperty);
    internal ExtendedProperty get_OldProperty();
    internal ExtendedProperty get_NewProperty();
}
internal class System.Windows.Ink.ExtendedPropertiesChangedEventHandler : MulticastDelegate {
    public ExtendedPropertiesChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ExtendedPropertiesChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ExtendedPropertiesChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Windows.Ink.ExtendedProperty : object {
    private Guid _id;
    private object _value;
    internal Guid Id { get; }
    internal object Value { get; internal set; }
    internal ExtendedProperty(Guid id, object value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public static bool op_Equality(ExtendedProperty first, ExtendedProperty second);
    public static bool op_Inequality(ExtendedProperty first, ExtendedProperty second);
    public virtual string ToString();
    internal Guid get_Id();
    internal object get_Value();
    internal void set_Value(object value);
    internal ExtendedProperty Clone();
}
[DefaultMemberAttribute("Item")]
internal class System.Windows.Ink.ExtendedPropertyCollection : object {
    [CompilerGeneratedAttribute]
private ExtendedPropertiesChangedEventHandler Changed;
    private List`1<ExtendedProperty> _extendedProperties;
    private int _optimisticIndex;
    internal object Item { get; internal set; }
    internal ExtendedProperty Item { get; }
    internal int Count { get; }
    public virtual bool Equals(object o);
    public static bool op_Equality(ExtendedPropertyCollection first, ExtendedPropertyCollection second);
    public static bool op_Inequality(ExtendedPropertyCollection first, ExtendedPropertyCollection second);
    public virtual int GetHashCode();
    internal bool Contains(Guid attributeId);
    internal ExtendedPropertyCollection Clone();
    internal void Add(Guid id, object value);
    internal void Remove(Guid id);
    internal Guid[] GetGuidArray();
    internal object get_Item(Guid attributeId);
    internal void set_Item(Guid attributeId, object value);
    internal ExtendedProperty get_Item(int index);
    internal int get_Count();
    [CompilerGeneratedAttribute]
internal void add_Changed(ExtendedPropertiesChangedEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_Changed(ExtendedPropertiesChangedEventHandler value);
    private void Add(ExtendedProperty extendedProperty);
    private ExtendedProperty GetExtendedPropertyById(Guid id);
}
public class System.Windows.Ink.GestureRecognitionResult : object {
    private RecognitionConfidence _confidence;
    private ApplicationGesture _gesture;
    public RecognitionConfidence RecognitionConfidence { get; }
    public ApplicationGesture ApplicationGesture { get; }
    internal GestureRecognitionResult(RecognitionConfidence confidence, ApplicationGesture gesture);
    public RecognitionConfidence get_RecognitionConfidence();
    public ApplicationGesture get_ApplicationGesture();
}
public class System.Windows.Ink.GestureRecognizer : DependencyObject {
    private ApplicationGesture[] _enabledGestures;
    private NativeRecognizer _nativeRecognizer;
    private bool _disposed;
    public bool IsRecognizerAvailable { get; }
    public GestureRecognizer(IEnumerable`1<ApplicationGesture> enabledApplicationGestures);
    public void SetEnabledGestures(IEnumerable`1<ApplicationGesture> applicationGestures);
    public ReadOnlyCollection`1<ApplicationGesture> GetEnabledGestures();
    public ReadOnlyCollection`1<GestureRecognitionResult> Recognize(StrokeCollection strokes);
    internal ReadOnlyCollection`1<GestureRecognitionResult> CriticalRecognize(StrokeCollection strokes);
    private ReadOnlyCollection`1<GestureRecognitionResult> RecognizeImpl(StrokeCollection strokes);
    public bool get_IsRecognizerAvailable();
    public sealed virtual void Dispose();
    private void VerifyRecognizerAvailable();
    private void VerifyDisposed();
}
internal static class System.Windows.Ink.IEnumerablePointHelper : object {
    internal static int GetCount(IEnumerable`1<Point> ienum);
    internal static Point[] GetPointArray(IEnumerable`1<Point> ienum);
}
public abstract class System.Windows.Ink.IncrementalHitTester : object {
    private StrokeCollection _strokes;
    private List`1<StrokeInfo> _strokeInfos;
    private bool _fValid;
    public bool IsValid { get; }
    internal List`1<StrokeInfo> StrokeInfos { get; }
    internal IncrementalHitTester(StrokeCollection strokes);
    public void AddPoint(Point point);
    public void AddPoints(IEnumerable`1<Point> points);
    public void AddPoints(StylusPointCollection stylusPoints);
    public void EndHitTesting();
    public bool get_IsValid();
    protected abstract virtual void AddPointsCore(IEnumerable`1<Point> points);
    internal List`1<StrokeInfo> get_StrokeInfos();
    private void OnStrokesChanged(object sender, StrokeCollectionChangedEventArgs args);
    private void RebuildStrokeInfoCache();
}
public class System.Windows.Ink.IncrementalLassoHitTester : IncrementalHitTester {
    [CompilerGeneratedAttribute]
private LassoSelectionChangedEventHandler SelectionChanged;
    private Lasso _lasso;
    private int _percentIntersect;
    internal IncrementalLassoHitTester(StrokeCollection strokes, int percentageWithinLasso);
    [CompilerGeneratedAttribute]
public void add_SelectionChanged(LassoSelectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_SelectionChanged(LassoSelectionChangedEventHandler value);
    protected virtual void AddPointsCore(IEnumerable`1<Point> points);
    protected void OnSelectionChanged(LassoSelectionChangedEventArgs eventArgs);
}
public class System.Windows.Ink.IncrementalStrokeHitTester : IncrementalHitTester {
    [CompilerGeneratedAttribute]
private StrokeHitEventHandler StrokeHit;
    private ErasingStroke _erasingStroke;
    internal IncrementalStrokeHitTester(StrokeCollection strokes, StylusShape eraserShape);
    [CompilerGeneratedAttribute]
public void add_StrokeHit(StrokeHitEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_StrokeHit(StrokeHitEventHandler value);
    protected virtual void AddPointsCore(IEnumerable`1<Point> points);
    protected void OnStrokeHit(StrokeHitEventArgs eventArgs);
}
internal static class System.Windows.Ink.KnownIds : object {
    internal static Guid X;
    internal static Guid Y;
    internal static Guid Z;
    internal static Guid PacketStatus;
    internal static Guid TimerTick;
    internal static Guid SerialNumber;
    internal static Guid NormalPressure;
    internal static Guid TangentPressure;
    internal static Guid ButtonPressure;
    internal static Guid XTiltOrientation;
    internal static Guid YTiltOrientation;
    internal static Guid AzimuthOrientation;
    internal static Guid AltitudeOrientation;
    internal static Guid TwistOrientation;
    internal static Guid PitchRotation;
    internal static Guid RollRotation;
    internal static Guid YawRotation;
    internal static Guid Color;
    internal static Guid DrawingFlags;
    internal static Guid CursorId;
    internal static Guid WordAlternates;
    internal static Guid CharacterAlternates;
    internal static Guid InkMetrics;
    internal static Guid GuideStructure;
    internal static Guid Timestamp;
    internal static Guid Language;
    internal static Guid Transparency;
    internal static Guid CurveFittingError;
    internal static Guid RecognizedLattice;
    internal static Guid CursorDown;
    internal static Guid SecondaryTipSwitch;
    internal static Guid TabletPick;
    internal static Guid BarrelDown;
    internal static Guid RasterOperation;
    internal static Guid StylusHeight;
    internal static Guid StylusWidth;
    internal static Guid Highlighter;
    internal static Guid InkProperties;
    internal static Guid InkStyleBold;
    internal static Guid InkStyleItalics;
    internal static Guid StrokeTimestamp;
    internal static Guid StrokeTimeId;
    internal static Guid StylusTip;
    internal static Guid StylusTipTransform;
    internal static Guid IsHighlighter;
    internal static Guid PenStyle;
    internal static Guid PenTip;
    internal static Guid InkCustomStrokes;
    internal static Guid InkStrokeLattice;
    private static MemberInfo[] PublicMemberInfo;
    private static KnownIds();
    internal static string ConvertToString(Guid id);
}
public class System.Windows.Ink.LassoSelectionChangedEventArgs : EventArgs {
    private StrokeCollection _selectedStrokes;
    private StrokeCollection _deselectedStrokes;
    public StrokeCollection SelectedStrokes { get; }
    public StrokeCollection DeselectedStrokes { get; }
    internal LassoSelectionChangedEventArgs(StrokeCollection selectedStrokes, StrokeCollection deselectedStrokes);
    public StrokeCollection get_SelectedStrokes();
    public StrokeCollection get_DeselectedStrokes();
}
public class System.Windows.Ink.LassoSelectionChangedEventHandler : MulticastDelegate {
    public LassoSelectionChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, LassoSelectionChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, LassoSelectionChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class System.Windows.Ink.MatrixHelper : object {
    internal static bool ContainsNaN(Matrix matrix);
    internal static bool ContainsInfinity(Matrix matrix);
}
internal enum System.Windows.Ink.PersistenceFormat : Enum {
    public int value__;
    public static PersistenceFormat InkSerializedFormat;
    public static PersistenceFormat Gif;
}
public class System.Windows.Ink.PropertyDataChangedEventArgs : EventArgs {
    private Guid _propertyGuid;
    private object _newValue;
    private object _previousValue;
    public Guid PropertyGuid { get; }
    public object NewValue { get; }
    public object PreviousValue { get; }
    public PropertyDataChangedEventArgs(Guid propertyGuid, object newValue, object previousValue);
    public Guid get_PropertyGuid();
    public object get_NewValue();
    public object get_PreviousValue();
}
public class System.Windows.Ink.PropertyDataChangedEventHandler : MulticastDelegate {
    public PropertyDataChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, PropertyDataChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, PropertyDataChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Windows.Ink.RecognitionConfidence : Enum {
    public int value__;
    public static RecognitionConfidence Strong;
    public static RecognitionConfidence Intermediate;
    public static RecognitionConfidence Poor;
}
public class System.Windows.Ink.RectangleStylusShape : StylusShape {
    public RectangleStylusShape(double width, double height);
    public RectangleStylusShape(double width, double height, double rotation);
}
[FriendAccessAllowedAttribute]
internal class System.Windows.Ink.Renderer : object {
    private ContainerVisual _rootVisual;
    private ContainerVisual _highlightersRoot;
    private ContainerVisual _incrementalRenderingVisuals;
    private ContainerVisual _regularInkVisuals;
    private Dictionary`2<Stroke, StrokeVisual> _visuals;
    private Dictionary`2<Color, HighlighterContainerVisual> _highlighters;
    private StrokeCollection _strokes;
    private List`1<Visual> _attachedVisuals;
    private bool _highContrast;
    private Color _highContrastColor;
    internal Visual RootVisual { get; }
    internal StrokeCollection Strokes { get; internal set; }
    internal Visual get_RootVisual();
    internal StrokeCollection get_Strokes();
    internal void set_Strokes(StrokeCollection value);
    internal void AttachIncrementalRendering(Visual visual, DrawingAttributes drawingAttributes);
    internal void DetachIncrementalRendering(Visual visual);
    internal bool ContainsAttachedIncrementalRenderingVisual(Visual visual);
    internal bool AttachedVisualIsPositionedCorrectly(Visual visual, DrawingAttributes drawingAttributes);
    internal void TurnHighContrastOn(Color strokeColor);
    internal void TurnHighContrastOff();
    internal bool IsHighContrast();
    public Color GetHighContrastColor();
    private void OnStrokesChanged(object sender, StrokeCollectionChangedEventArgs eventArgs);
    private void OnStrokeInvalidated(object sender, EventArgs eventArgs);
    private void UpdateStrokeVisuals();
    private void AttachVisual(StrokeVisual visual, bool buildingStrokeCollection);
    private void DetachVisual(Visual visual);
    private void StartListeningOnStrokeEvents(Stroke stroke);
    private void StopListeningOnStrokeEvents(Stroke stroke);
    private ContainerVisual GetContainerVisual(DrawingAttributes drawingAttributes);
}
public class System.Windows.Ink.Stroke : object {
    [CompilerGeneratedAttribute]
private PropertyDataChangedEventHandler DrawingAttributesChanged;
    [CompilerGeneratedAttribute]
private DrawingAttributesReplacedEventHandler DrawingAttributesReplaced;
    [CompilerGeneratedAttribute]
private StylusPointsReplacedEventHandler StylusPointsReplaced;
    [CompilerGeneratedAttribute]
private EventHandler StylusPointsChanged;
    [CompilerGeneratedAttribute]
private PropertyDataChangedEventHandler PropertyDataChanged;
    [CompilerGeneratedAttribute]
private EventHandler Invalidated;
    private ExtendedPropertyCollection _extendedProperties;
    private DrawingAttributes _drawingAttributes;
    private StylusPointCollection _stylusPoints;
    internal double TapHitPointSize;
    internal double TapHitRotation;
    private Geometry _cachedGeometry;
    private bool _isSelected;
    private bool _drawAsHollow;
    private bool _cloneStylusPoints;
    private bool _delayRaiseInvalidated;
    private static double HollowLineSize;
    private Rect _cachedBounds;
    private PropertyChangedEventHandler _propertyChanged;
    private static string DrawingAttributesName;
    private static string StylusPointsName;
    internal static double PercentageTolerance;
    public DrawingAttributes DrawingAttributes { get; public set; }
    public StylusPointCollection StylusPoints { get; public set; }
    internal ExtendedPropertyCollection ExtendedProperties { get; }
    [FriendAccessAllowedAttribute]
internal bool IsSelected { get; internal set; }
    public Stroke(StylusPointCollection stylusPoints);
    public Stroke(StylusPointCollection stylusPoints, DrawingAttributes drawingAttributes);
    internal Stroke(StylusPointCollection stylusPoints, DrawingAttributes drawingAttributes, ExtendedPropertyCollection extendedProperties);
    private static Stroke();
    private void Initialize();
    public virtual Stroke Clone();
    public virtual void Transform(Matrix transformMatrix, bool applyToStylusTip);
    public StylusPointCollection GetBezierStylusPoints();
    private StylusPointCollection GetInterpolatedStylusPoints(List`1<Point> bezierPoints);
    private double GetDistanceBetweenPoints(Point p1, Point p2);
    private void AddInterpolatedBezierPoint(StylusPointCollection bezierStylusPoints, Point bezierPoint, Int32[] additionalData, float pressure);
    public void AddPropertyData(Guid propertyDataId, object propertyData);
    public void RemovePropertyData(Guid propertyDataId);
    public object GetPropertyData(Guid propertyDataId);
    public Guid[] GetPropertyDataIds();
    public bool ContainsPropertyData(Guid propertyDataId);
    public DrawingAttributes get_DrawingAttributes();
    public void set_DrawingAttributes(DrawingAttributes value);
    public StylusPointCollection get_StylusPoints();
    public void set_StylusPoints(StylusPointCollection value);
    [CompilerGeneratedAttribute]
public void add_DrawingAttributesChanged(PropertyDataChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_DrawingAttributesChanged(PropertyDataChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_DrawingAttributesReplaced(DrawingAttributesReplacedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_DrawingAttributesReplaced(DrawingAttributesReplacedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_StylusPointsReplaced(StylusPointsReplacedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_StylusPointsReplaced(StylusPointsReplacedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_StylusPointsChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_StylusPointsChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_PropertyDataChanged(PropertyDataChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PropertyDataChanged(PropertyDataChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_Invalidated(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Invalidated(EventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
    protected virtual void OnDrawingAttributesChanged(PropertyDataChangedEventArgs e);
    protected virtual void OnDrawingAttributesReplaced(DrawingAttributesReplacedEventArgs e);
    protected virtual void OnStylusPointsReplaced(StylusPointsReplacedEventArgs e);
    protected virtual void OnStylusPointsChanged(EventArgs e);
    protected virtual void OnPropertyDataChanged(PropertyDataChangedEventArgs e);
    protected virtual void OnInvalidated(EventArgs e);
    protected virtual void OnPropertyChanged(PropertyChangedEventArgs e);
    internal ExtendedPropertyCollection get_ExtendedProperties();
    private StrokeCollection Clip(StrokeFIndices[] cutAt);
    private StrokeCollection Erase(StrokeFIndices[] cutAt);
    private Stroke Copy(StylusPointCollection sourceStylusPoints, double beginFIndex, double endFIndex);
    private Point GetIntermediatePoint(StylusPoint p1, StylusPoint p2, double findex);
    private void DrawingAttributes_Changed(object sender, PropertyDataChangedEventArgs e);
    private void StylusPoints_Changed(object sender, EventArgs e);
    private void StylusPoints_CountGoingToZero(object sender, CancelEventArgs e);
    private void OnPropertyChanged(string propertyName);
    public virtual Rect GetBounds();
    public void Draw(DrawingContext context);
    public void Draw(DrawingContext drawingContext, DrawingAttributes drawingAttributes);
    public StrokeCollection GetClipResult(Rect bounds);
    public StrokeCollection GetClipResult(IEnumerable`1<Point> lassoPoints);
    public StrokeCollection GetEraseResult(Rect bounds);
    public StrokeCollection GetEraseResult(IEnumerable`1<Point> lassoPoints);
    public StrokeCollection GetEraseResult(IEnumerable`1<Point> eraserPath, StylusShape eraserShape);
    public bool HitTest(Point point);
    public bool HitTest(Point point, double diameter);
    public bool HitTest(Rect bounds, int percentageWithinBounds);
    public bool HitTest(IEnumerable`1<Point> lassoPoints, int percentageWithinLasso);
    public bool HitTest(IEnumerable`1<Point> path, StylusShape stylusShape);
    protected virtual void DrawCore(DrawingContext drawingContext, DrawingAttributes drawingAttributes);
    public Geometry GetGeometry();
    public Geometry GetGeometry(DrawingAttributes drawingAttributes);
    [FriendAccessAllowedAttribute]
internal void DrawInternal(DrawingContext dc, DrawingAttributes DrawingAttributes, bool drawAsHollow);
    internal bool get_IsSelected();
    internal void set_IsSelected(bool value);
    internal void SetGeometry(Geometry geometry);
    internal void SetBounds(Rect newBounds);
    internal StrokeIntersection[] EraseTest(IEnumerable`1<Point> path, StylusShape shape);
    internal StrokeIntersection[] HitTest(Lasso lasso);
    internal StrokeCollection Erase(StrokeIntersection[] cutAt);
    internal StrokeCollection Clip(StrokeIntersection[] cutAt);
    private static void CalcHollowTransforms(DrawingAttributes originalDa, Matrix& innerTransform, Matrix& outerTransform);
}
[TypeConverterAttribute("System.Windows.StrokeCollectionConverter")]
public class System.Windows.Ink.StrokeCollection : Collection`1<Stroke> {
    public static string InkSerializedFormat;
    [CompilerGeneratedAttribute]
private StrokeCollectionChangedEventHandler StrokesChanged;
    [CompilerGeneratedAttribute]
private StrokeCollectionChangedEventHandler StrokesChangedInternal;
    [CompilerGeneratedAttribute]
private PropertyDataChangedEventHandler PropertyDataChanged;
    private ExtendedPropertyCollection _extendedProperties;
    private PropertyChangedEventHandler _propertyChanged;
    private NotifyCollectionChangedEventHandler _collectionChanged;
    private static string IndexerName;
    private static string CountName;
    internal ExtendedPropertyCollection ExtendedProperties { get; private set; }
    public StrokeCollection(IEnumerable`1<Stroke> strokes);
    public StrokeCollection(Stream stream);
    private static StrokeCollection();
    public virtual void Save(Stream stream, bool compress);
    public void Save(Stream stream);
    internal void SaveIsf(Stream stream, bool compress);
    private Stream GetSeekableStream(Stream stream);
    public void AddPropertyData(Guid propertyDataId, object propertyData);
    public void RemovePropertyData(Guid propertyDataId);
    public object GetPropertyData(Guid propertyDataId);
    public Guid[] GetPropertyDataIds();
    public bool ContainsPropertyData(Guid propertyDataId);
    public void Transform(Matrix transformMatrix, bool applyToStylusTip);
    public virtual StrokeCollection Clone();
    protected sealed virtual void ClearItems();
    protected sealed virtual void RemoveItem(int index);
    protected sealed virtual void InsertItem(int index, Stroke stroke);
    protected sealed virtual void SetItem(int index, Stroke stroke);
    public int IndexOf(Stroke stroke);
    public void Remove(StrokeCollection strokes);
    public void Add(StrokeCollection strokes);
    public void Replace(Stroke strokeToReplace, StrokeCollection strokesToReplaceWith);
    public void Replace(StrokeCollection strokesToReplace, StrokeCollection strokesToReplaceWith);
    internal void AddWithoutEvent(Stroke stroke);
    internal ExtendedPropertyCollection get_ExtendedProperties();
    private void set_ExtendedProperties(ExtendedPropertyCollection value);
    [CompilerGeneratedAttribute]
public void add_StrokesChanged(StrokeCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_StrokesChanged(StrokeCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
internal void add_StrokesChangedInternal(StrokeCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_StrokesChangedInternal(StrokeCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_PropertyDataChanged(PropertyDataChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PropertyDataChanged(PropertyDataChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.Collections.Specialized.INotifyCollectionChanged.add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    private sealed virtual override void System.Collections.Specialized.INotifyCollectionChanged.remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    protected virtual void OnStrokesChanged(StrokeCollectionChangedEventArgs e);
    protected virtual void OnPropertyDataChanged(PropertyDataChangedEventArgs e);
    protected virtual void OnPropertyChanged(PropertyChangedEventArgs e);
    private int OptimisticIndexOf(int startingIndex, Stroke stroke);
    private Int32[] GetStrokeIndexes(StrokeCollection strokes);
    private void RaiseStrokesChanged(StrokeCollection addedStrokes, StrokeCollection removedStrokes, int index);
    private void OnPropertyChanged(string propertyName);
    public Rect GetBounds();
    public StrokeCollection HitTest(Point point);
    public StrokeCollection HitTest(Point point, double diameter);
    public StrokeCollection HitTest(IEnumerable`1<Point> lassoPoints, int percentageWithinLasso);
    public StrokeCollection HitTest(Rect bounds, int percentageWithinBounds);
    public StrokeCollection HitTest(IEnumerable`1<Point> path, StylusShape stylusShape);
    public void Clip(IEnumerable`1<Point> lassoPoints);
    public void Clip(Rect bounds);
    public void Erase(IEnumerable`1<Point> lassoPoints);
    public void Erase(Rect bounds);
    public void Erase(IEnumerable`1<Point> eraserPath, StylusShape eraserShape);
    public void Draw(DrawingContext context);
    public IncrementalStrokeHitTester GetIncrementalStrokeHitTester(StylusShape eraserShape);
    public IncrementalLassoHitTester GetIncrementalLassoHitTester(int percentageWithinLasso);
    private StrokeCollection PointHitTest(Point point, StylusShape shape);
    private void UpdateStrokeCollection(Stroke original, StrokeCollection toReplace, Int32& index);
}
public class System.Windows.Ink.StrokeCollectionChangedEventArgs : EventArgs {
    private ReadOnlyStrokeCollection _added;
    private ReadOnlyStrokeCollection _removed;
    private int _index;
    public StrokeCollection Added { get; }
    public StrokeCollection Removed { get; }
    internal int Index { get; }
    internal StrokeCollectionChangedEventArgs(StrokeCollection added, StrokeCollection removed, int index);
    public StrokeCollectionChangedEventArgs(StrokeCollection added, StrokeCollection removed);
    public StrokeCollection get_Added();
    public StrokeCollection get_Removed();
    internal int get_Index();
}
public class System.Windows.Ink.StrokeCollectionChangedEventHandler : MulticastDelegate {
    public StrokeCollectionChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, StrokeCollectionChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, StrokeCollectionChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Ink.StrokeHitEventArgs : EventArgs {
    private Stroke _stroke;
    private StrokeIntersection[] _hitFragments;
    public Stroke HitStroke { get; }
    internal StrokeHitEventArgs(Stroke stroke, StrokeIntersection[] hitFragments);
    public Stroke get_HitStroke();
    public StrokeCollection GetPointEraseResults();
}
public class System.Windows.Ink.StrokeHitEventHandler : MulticastDelegate {
    public StrokeHitEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, StrokeHitEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, StrokeHitEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Windows.Ink.StrokeIntersection : ValueType {
    private static StrokeIntersection s_empty;
    private static StrokeIntersection s_full;
    private StrokeFIndices _hitSegment;
    private StrokeFIndices _inSegment;
    internal static double BeforeFirst { get; }
    internal static double AfterLast { get; }
    unknown double HitBegin {internal set; }
    internal double HitEnd { get; internal set; }
    internal double InBegin { get; internal set; }
    internal double InEnd { get; internal set; }
    internal static StrokeIntersection Full { get; }
    internal bool IsEmpty { get; }
    internal StrokeFIndices HitSegment { get; }
    internal StrokeFIndices InSegment { get; }
    internal StrokeIntersection(double hitBegin, double inBegin, double inEnd, double hitEnd);
    private static StrokeIntersection();
    internal static double get_BeforeFirst();
    internal static double get_AfterLast();
    internal void set_HitBegin(double value);
    internal double get_HitEnd();
    internal void set_HitEnd(double value);
    internal double get_InBegin();
    internal void set_InBegin(double value);
    internal double get_InEnd();
    internal void set_InEnd(double value);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(StrokeIntersection left, StrokeIntersection right);
    public static bool op_Inequality(StrokeIntersection left, StrokeIntersection right);
    internal static StrokeIntersection get_Full();
    internal bool get_IsEmpty();
    internal StrokeFIndices get_HitSegment();
    internal StrokeFIndices get_InSegment();
    internal static StrokeFIndices[] GetInSegments(StrokeIntersection[] intersections);
    internal static StrokeFIndices[] GetHitSegments(StrokeIntersection[] intersections);
}
public class System.Windows.Ink.StylusPointsReplacedEventArgs : EventArgs {
    private StylusPointCollection _newStylusPoints;
    private StylusPointCollection _previousStylusPoints;
    public StylusPointCollection NewStylusPoints { get; }
    public StylusPointCollection PreviousStylusPoints { get; }
    public StylusPointsReplacedEventArgs(StylusPointCollection newStylusPoints, StylusPointCollection previousStylusPoints);
    public StylusPointCollection get_NewStylusPoints();
    public StylusPointCollection get_PreviousStylusPoints();
}
public class System.Windows.Ink.StylusPointsReplacedEventHandler : MulticastDelegate {
    public StylusPointsReplacedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, StylusPointsReplacedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, StylusPointsReplacedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class System.Windows.Ink.StylusShape : object {
    private double m_width;
    private double m_height;
    private double m_rotation;
    private Point[] m_vertices;
    private StylusTip m_tip;
    private Matrix _transform;
    public double Width { get; }
    public double Height { get; }
    public double Rotation { get; }
    internal Matrix Transform { get; internal set; }
    internal bool IsEllipse { get; }
    internal bool IsPolygon { get; }
    internal Rect BoundingBox { get; }
    internal StylusShape(StylusTip tip, double width, double height, double rotation);
    public double get_Width();
    public double get_Height();
    public double get_Rotation();
    internal Vector[] GetVerticesAsVectors();
    internal Matrix get_Transform();
    internal void set_Transform(Matrix value);
    internal bool get_IsEllipse();
    internal bool get_IsPolygon();
    internal Rect get_BoundingBox();
    private void ComputeRectangleVertices();
    private void FixCounterClockwiseVertices(Vector[] vertices);
    private Point[] GetBezierControlPoints();
}
public enum System.Windows.Ink.StylusTip : Enum {
    public int value__;
    public static StylusTip Rectangle;
    public static StylusTip Ellipse;
}
internal static class System.Windows.Ink.StylusTipHelper : object {
    internal static bool IsDefined(StylusTip stylusTip);
}
public class System.Windows.Input.AccessKeyEventArgs : EventArgs {
    private string _key;
    private bool _isMultiple;
    private SecurityCriticalDataForSet`1<bool> _userInitiated;
    public string Key { get; }
    public bool IsMultiple { get; }
    internal bool UserInitiated { get; }
    internal AccessKeyEventArgs(string key, bool isMultiple, bool userInitiated);
    internal void ClearUserInitiated();
    public string get_Key();
    public bool get_IsMultiple();
    internal bool get_UserInitiated();
}
public class System.Windows.Input.AccessKeyManager : object {
    public static RoutedEvent AccessKeyPressedEvent;
    private static DependencyProperty AccessKeyElementProperty;
    private Hashtable _keyToElements;
    [ThreadStaticAttribute]
private static AccessKeyManager _accessKeyManager;
    private static AccessKeyManager Current { get; }
    private static AccessKeyManager();
    public static void Register(string key, IInputElement element);
    public static void Unregister(string key, IInputElement element);
    public static bool IsKeyRegistered(object scope, string key);
    public static bool ProcessKey(object scope, string key, bool isMultiple);
    private static string NormalizeKey(string key);
    public static void AddAccessKeyPressedHandler(DependencyObject element, AccessKeyPressedEventHandler handler);
    public static void RemoveAccessKeyPressedHandler(DependencyObject element, AccessKeyPressedEventHandler handler);
    private static AccessKeyManager get_Current();
    private void PostProcessInput(object sender, ProcessInputEventArgs e);
    private ProcessKeyResult ProcessKeyForSender(object sender, string key, bool existsElsewhere, bool userInitiated);
    private ProcessKeyResult ProcessKeyForScope(object scope, string key, bool existsElsewhere, bool userInitiated);
    private ProcessKeyResult ProcessKey(List`1<IInputElement> targets, string key, bool existsElsewhere, bool userInitiated);
    private void OnText(TextCompositionEventArgs e);
    private void OnKeyDown(KeyEventArgs e);
    private List`1<IInputElement> GetTargetsForSender(IInputElement sender, string key);
    private List`1<IInputElement> GetTargetsForScope(object scope, string key, IInputElement sender, AccessKeyInformation senderInfo);
    private AccessKeyInformation GetInfoForElement(IInputElement element, string key);
    private PresentationSource GetSourceForElement(IInputElement element);
    private PresentationSource GetActiveSource();
    private PresentationSource CriticalGetActiveSource();
    private bool IsTargetable(IInputElement element);
    private static bool IsVisible(DependencyObject element);
    private static bool IsEnabled(DependencyObject element);
    private static void PurgeDead(ArrayList elements, object elementToRemove);
    private static List`1<IInputElement> CopyAndPurgeDead(ArrayList elements);
    internal static string InternalGetAccessKeyCharacter(DependencyObject d);
    private string GetAccessKeyCharacter(DependencyObject d);
}
public class System.Windows.Input.AccessKeyPressedEventArgs : RoutedEventArgs {
    private object _scope;
    private UIElement _target;
    private string _key;
    public object Scope { get; public set; }
    public UIElement Target { get; public set; }
    public string Key { get; }
    public AccessKeyPressedEventArgs(string key);
    public object get_Scope();
    public void set_Scope(object value);
    public UIElement get_Target();
    public void set_Target(UIElement value);
    public string get_Key();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.AccessKeyPressedEventHandler : MulticastDelegate {
    public AccessKeyPressedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, AccessKeyPressedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, AccessKeyPressedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal enum System.Windows.Input.AltNumpadConversionMode : Enum {
    public int value__;
    public static AltNumpadConversionMode DefaultCodePage;
    public static AltNumpadConversionMode OEMCodePage;
    public static AltNumpadConversionMode HexDefaultCodePage;
    public static AltNumpadConversionMode HexUnicode;
}
internal static class System.Windows.Input.AngleUtil : object {
    public static double DegreesToRadians(double degrees);
    public static double RadiansToDegrees(double radians);
}
public static class System.Windows.Input.ApplicationCommands : object {
    private static RoutedUICommand[] _internalCommands;
    private static string ContextMenuKey;
    private static string CopyKey;
    private static string CutKey;
    private static string DeleteKey;
    private static string FindKey;
    private static string HelpKey;
    private static string NewKey;
    private static string OpenKey;
    private static string PasteKey;
    private static string PrintKey;
    private static string PrintPreviewKey;
    private static string PropertiesKey;
    private static string RedoKey;
    private static string ReplaceKey;
    private static string SaveKey;
    private static string SelectAllKey;
    private static string StopKey;
    private static string UndoKey;
    public static RoutedUICommand Cut { get; }
    public static RoutedUICommand Copy { get; }
    public static RoutedUICommand Paste { get; }
    public static RoutedUICommand Delete { get; }
    public static RoutedUICommand Undo { get; }
    public static RoutedUICommand Redo { get; }
    public static RoutedUICommand Find { get; }
    public static RoutedUICommand Replace { get; }
    public static RoutedUICommand SelectAll { get; }
    public static RoutedUICommand Help { get; }
    public static RoutedUICommand New { get; }
    public static RoutedUICommand Open { get; }
    public static RoutedUICommand Close { get; }
    public static RoutedUICommand Save { get; }
    public static RoutedUICommand SaveAs { get; }
    public static RoutedUICommand Print { get; }
    public static RoutedUICommand CancelPrint { get; }
    public static RoutedUICommand PrintPreview { get; }
    public static RoutedUICommand Properties { get; }
    public static RoutedUICommand ContextMenu { get; }
    public static RoutedUICommand Stop { get; }
    public static RoutedUICommand CorrectionList { get; }
    public static RoutedUICommand NotACommand { get; }
    private static ApplicationCommands();
    public static RoutedUICommand get_Cut();
    public static RoutedUICommand get_Copy();
    public static RoutedUICommand get_Paste();
    public static RoutedUICommand get_Delete();
    public static RoutedUICommand get_Undo();
    public static RoutedUICommand get_Redo();
    public static RoutedUICommand get_Find();
    public static RoutedUICommand get_Replace();
    public static RoutedUICommand get_SelectAll();
    public static RoutedUICommand get_Help();
    public static RoutedUICommand get_New();
    public static RoutedUICommand get_Open();
    public static RoutedUICommand get_Close();
    public static RoutedUICommand get_Save();
    public static RoutedUICommand get_SaveAs();
    public static RoutedUICommand get_Print();
    public static RoutedUICommand get_CancelPrint();
    public static RoutedUICommand get_PrintPreview();
    public static RoutedUICommand get_Properties();
    public static RoutedUICommand get_ContextMenu();
    public static RoutedUICommand get_Stop();
    public static RoutedUICommand get_CorrectionList();
    public static RoutedUICommand get_NotACommand();
    private static string GetPropertyName(CommandId commandId);
    internal static string GetUIText(byte commandId);
    internal static InputGestureCollection LoadDefaultGestureFromResource(byte commandId);
    private static RoutedUICommand _EnsureCommand(CommandId idCommand);
}
internal class System.Windows.Input.AvalonAdapterImpl : object {
    private sealed virtual override bool System.Windows.Input.IAvalonAdapter.OnNoMoreTabStops(TraversalRequest request, Boolean& ShouldCycle);
}
public class System.Windows.Input.CanExecuteChangedEventManager : WeakEventManager {
    private ConditionalWeakTable`2<object, object> _cwt;
    private static object StaticSource;
    private static CanExecuteChangedEventManager CurrentManager { get; }
    private static CanExecuteChangedEventManager();
    public static void AddHandler(ICommand source, EventHandler`1<EventArgs> handler);
    public static void RemoveHandler(ICommand source, EventHandler`1<EventArgs> handler);
    protected virtual void StartListening(object source);
    protected virtual void StopListening(object source);
    protected virtual bool Purge(object source, object data, bool purgeAll);
    private static CanExecuteChangedEventManager get_CurrentManager();
    private void PrivateAddHandler(ICommand source, EventHandler`1<EventArgs> handler);
    private void PrivateRemoveHandler(ICommand source, EventHandler`1<EventArgs> handler);
    private void AddHandlerToCWT(Delegate handler, ConditionalWeakTable`2<object, object> cwt);
    private void RemoveHandlerFromCWT(Delegate handler, ConditionalWeakTable`2<object, object> cwt);
}
public class System.Windows.Input.CanExecuteRoutedEventArgs : RoutedEventArgs {
    private ICommand _command;
    private object _parameter;
    private bool _canExecute;
    private bool _continueRouting;
    public ICommand Command { get; }
    public object Parameter { get; }
    public bool CanExecute { get; public set; }
    public bool ContinueRouting { get; public set; }
    internal CanExecuteRoutedEventArgs(ICommand command, object parameter);
    public ICommand get_Command();
    public object get_Parameter();
    public bool get_CanExecute();
    public void set_CanExecute(bool value);
    public bool get_ContinueRouting();
    public void set_ContinueRouting(bool value);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object target);
}
public class System.Windows.Input.CanExecuteRoutedEventHandler : MulticastDelegate {
    public CanExecuteRoutedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, CanExecuteRoutedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, CanExecuteRoutedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Windows.Input.CaptureMode : Enum {
    public int value__;
    public static CaptureMode None;
    public static CaptureMode Element;
    public static CaptureMode SubTree;
}
public class System.Windows.Input.CommandBinding : object {
    [CompilerGeneratedAttribute]
private ExecutedRoutedEventHandler PreviewExecuted;
    [CompilerGeneratedAttribute]
private ExecutedRoutedEventHandler Executed;
    [CompilerGeneratedAttribute]
private CanExecuteRoutedEventHandler PreviewCanExecute;
    [CompilerGeneratedAttribute]
private CanExecuteRoutedEventHandler CanExecute;
    private ICommand _command;
    [LocalizabilityAttribute("17")]
public ICommand Command { get; public set; }
    public CommandBinding(ICommand command);
    public CommandBinding(ICommand command, ExecutedRoutedEventHandler executed);
    public CommandBinding(ICommand command, ExecutedRoutedEventHandler executed, CanExecuteRoutedEventHandler canExecute);
    public ICommand get_Command();
    public void set_Command(ICommand value);
    [CompilerGeneratedAttribute]
public void add_PreviewExecuted(ExecutedRoutedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PreviewExecuted(ExecutedRoutedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_Executed(ExecutedRoutedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Executed(ExecutedRoutedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_PreviewCanExecute(CanExecuteRoutedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PreviewCanExecute(CanExecuteRoutedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_CanExecute(CanExecuteRoutedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_CanExecute(CanExecuteRoutedEventHandler value);
    internal void OnCanExecute(object sender, CanExecuteRoutedEventArgs e);
    private bool CheckCanExecute(object sender, ExecutedRoutedEventArgs e);
    internal void OnExecuted(object sender, ExecutedRoutedEventArgs e);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Input.CommandBindingCollection : object {
    private List`1<CommandBinding> _innerCBList;
    private object System.Collections.IList.Item { get; private set; }
    public CommandBinding Item { get; public set; }
    public bool IsFixedSize { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsReadOnly { get; }
    public int Count { get; }
    public CommandBindingCollection(IList commandBindings);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.IList.Contains(object key);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object commandBinding);
    private sealed virtual override void System.Collections.IList.Remove(object commandBinding);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public CommandBinding get_Item(int index);
    public void set_Item(int index, CommandBinding value);
    public int Add(CommandBinding commandBinding);
    public void AddRange(ICollection collection);
    public void Insert(int index, CommandBinding commandBinding);
    public void Remove(CommandBinding commandBinding);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int get_Count();
    public sealed virtual void Clear();
    public int IndexOf(CommandBinding value);
    public bool Contains(CommandBinding commandBinding);
    public void CopyTo(CommandBinding[] commandBindings, int index);
    public sealed virtual IEnumerator GetEnumerator();
    internal ICommand FindMatch(object targetElement, InputEventArgs inputEventArgs);
    internal CommandBinding FindMatch(ICommand command, Int32& index);
}
internal class System.Windows.Input.CommandDevice : InputDevice {
    internal static RoutedEvent CommandDeviceEvent;
    private SecurityCriticalData`1<InputManager> _inputManager;
    public IInputElement Target { get; }
    public PresentationSource ActiveSource { get; }
    internal CommandDevice(InputManager inputManager);
    private static CommandDevice();
    public virtual IInputElement get_Target();
    public virtual PresentationSource get_ActiveSource();
    private void PreProcessInput(object sender, PreProcessInputEventArgs e);
    private void PostProcessInput(object sender, ProcessInputEventArgs e);
    private RoutedCommand GetRoutedCommand(int appCommandId);
    private IInputElement GetSourceFromDevice(InputType device);
}
internal class System.Windows.Input.CommandDeviceEventArgs : InputEventArgs {
    private ICommand _command;
    internal ICommand Command { get; }
    internal CommandDeviceEventArgs(CommandDevice commandDevice, int timestamp, ICommand command);
    internal ICommand get_Command();
    protected virtual void InvokeEventHandler(Delegate execHandler, object target);
}
internal class System.Windows.Input.CommandDeviceEventHandler : MulticastDelegate {
    public CommandDeviceEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, CommandDeviceEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, CommandDeviceEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Input.CommandManager : object {
    public static RoutedEvent PreviewExecutedEvent;
    public static RoutedEvent ExecutedEvent;
    public static RoutedEvent PreviewCanExecuteEvent;
    public static RoutedEvent CanExecuteEvent;
    [ThreadStaticAttribute]
private static CommandManager _commandManager;
    private static HybridDictionary _classCommandBindings;
    private static HybridDictionary _classInputBindings;
    private DispatcherOperation _requerySuggestedOperation;
    [CompilerGeneratedAttribute]
private EventHandler PrivateRequerySuggested;
    private static CommandManager Current { get; }
    private static CommandManager();
    public static void add_RequerySuggested(EventHandler value);
    public static void remove_RequerySuggested(EventHandler value);
    public static void AddPreviewExecutedHandler(UIElement element, ExecutedRoutedEventHandler handler);
    public static void RemovePreviewExecutedHandler(UIElement element, ExecutedRoutedEventHandler handler);
    public static void AddExecutedHandler(UIElement element, ExecutedRoutedEventHandler handler);
    public static void RemoveExecutedHandler(UIElement element, ExecutedRoutedEventHandler handler);
    public static void AddPreviewCanExecuteHandler(UIElement element, CanExecuteRoutedEventHandler handler);
    public static void RemovePreviewCanExecuteHandler(UIElement element, CanExecuteRoutedEventHandler handler);
    public static void AddCanExecuteHandler(UIElement element, CanExecuteRoutedEventHandler handler);
    public static void RemoveCanExecuteHandler(UIElement element, CanExecuteRoutedEventHandler handler);
    public static void RegisterClassInputBinding(Type type, InputBinding inputBinding);
    public static void RegisterClassCommandBinding(Type type, CommandBinding commandBinding);
    public static void InvalidateRequerySuggested();
    private static CommandManager get_Current();
    internal static void TranslateInput(IInputElement targetElement, InputEventArgs inputEventArgs);
    private static bool ExecuteCommand(RoutedCommand routedCommand, object parameter, IInputElement target, InputEventArgs inputEventArgs);
    internal static void OnCanExecute(object sender, CanExecuteRoutedEventArgs e);
    private static bool CanExecuteCommandBinding(object sender, CanExecuteRoutedEventArgs e, CommandBinding commandBinding);
    internal static void OnExecuted(object sender, ExecutedRoutedEventArgs e);
    private static bool ExecuteCommandBinding(object sender, ExecutedRoutedEventArgs e, CommandBinding commandBinding);
    internal static void OnCommandDevice(object sender, CommandDeviceEventArgs e);
    private static void FindCommandBinding(object sender, RoutedEventArgs e, ICommand command, bool execute);
    private static void FindCommandBinding(CommandBindingCollection commandBindings, object sender, RoutedEventArgs e, ICommand command, bool execute);
    private static void TransferEvent(IInputElement newSource, CanExecuteRoutedEventArgs e);
    private static void TransferEvent(IInputElement newSource, ExecutedRoutedEventArgs e);
    private static IInputElement GetParentScopeFocusedElement(DependencyObject childScope);
    private static DependencyObject GetParentScope(DependencyObject childScope);
    private static bool ContainsElement(DependencyObject scope, DependencyObject child);
    private void RaiseRequerySuggested();
    private object RaiseRequerySuggested(object obj);
    [CompilerGeneratedAttribute]
private void add_PrivateRequerySuggested(EventHandler value);
    [CompilerGeneratedAttribute]
private void remove_PrivateRequerySuggested(EventHandler value);
}
internal enum System.Windows.Input.CompartmentScope : Enum {
    public int value__;
    public static CompartmentScope Invalid;
    public static CompartmentScope Thread;
    public static CompartmentScope Global;
}
public static class System.Windows.Input.ComponentCommands : object {
    private static RoutedUICommand[] _internalCommands;
    private static string ExtendSelectionDownKey;
    private static string ExtendSelectionLeftKey;
    private static string ExtendSelectionRightKey;
    private static string ExtendSelectionUpKey;
    private static string MoveDownKey;
    private static string MoveFocusBackKey;
    private static string MoveFocusDownKey;
    private static string MoveFocusForwardKey;
    private static string MoveFocusPageDownKey;
    private static string MoveFocusPageUpKey;
    private static string MoveFocusUpKey;
    private static string MoveLeftKey;
    private static string MoveRightKey;
    private static string MoveToEndKey;
    private static string MoveToHomeKey;
    private static string MoveToPageDownKey;
    private static string MoveToPageUpKey;
    private static string MoveUpKey;
    private static string ScrollPageDownKey;
    private static string ScrollPageUpKey;
    private static string SelectToEndKey;
    private static string SelectToHomeKey;
    private static string SelectToPageDownKey;
    private static string SelectToPageUpKey;
    public static RoutedUICommand ScrollPageUp { get; }
    public static RoutedUICommand ScrollPageDown { get; }
    public static RoutedUICommand ScrollPageLeft { get; }
    public static RoutedUICommand ScrollPageRight { get; }
    public static RoutedUICommand ScrollByLine { get; }
    public static RoutedUICommand MoveLeft { get; }
    public static RoutedUICommand MoveRight { get; }
    public static RoutedUICommand MoveUp { get; }
    public static RoutedUICommand MoveDown { get; }
    public static RoutedUICommand MoveToHome { get; }
    public static RoutedUICommand MoveToEnd { get; }
    public static RoutedUICommand MoveToPageUp { get; }
    public static RoutedUICommand MoveToPageDown { get; }
    public static RoutedUICommand ExtendSelectionUp { get; }
    public static RoutedUICommand ExtendSelectionDown { get; }
    public static RoutedUICommand ExtendSelectionLeft { get; }
    public static RoutedUICommand ExtendSelectionRight { get; }
    public static RoutedUICommand SelectToHome { get; }
    public static RoutedUICommand SelectToEnd { get; }
    public static RoutedUICommand SelectToPageUp { get; }
    public static RoutedUICommand SelectToPageDown { get; }
    public static RoutedUICommand MoveFocusUp { get; }
    public static RoutedUICommand MoveFocusDown { get; }
    public static RoutedUICommand MoveFocusForward { get; }
    public static RoutedUICommand MoveFocusBack { get; }
    public static RoutedUICommand MoveFocusPageUp { get; }
    public static RoutedUICommand MoveFocusPageDown { get; }
    private static ComponentCommands();
    public static RoutedUICommand get_ScrollPageUp();
    public static RoutedUICommand get_ScrollPageDown();
    public static RoutedUICommand get_ScrollPageLeft();
    public static RoutedUICommand get_ScrollPageRight();
    public static RoutedUICommand get_ScrollByLine();
    public static RoutedUICommand get_MoveLeft();
    public static RoutedUICommand get_MoveRight();
    public static RoutedUICommand get_MoveUp();
    public static RoutedUICommand get_MoveDown();
    public static RoutedUICommand get_MoveToHome();
    public static RoutedUICommand get_MoveToEnd();
    public static RoutedUICommand get_MoveToPageUp();
    public static RoutedUICommand get_MoveToPageDown();
    public static RoutedUICommand get_ExtendSelectionUp();
    public static RoutedUICommand get_ExtendSelectionDown();
    public static RoutedUICommand get_ExtendSelectionLeft();
    public static RoutedUICommand get_ExtendSelectionRight();
    public static RoutedUICommand get_SelectToHome();
    public static RoutedUICommand get_SelectToEnd();
    public static RoutedUICommand get_SelectToPageUp();
    public static RoutedUICommand get_SelectToPageDown();
    public static RoutedUICommand get_MoveFocusUp();
    public static RoutedUICommand get_MoveFocusDown();
    public static RoutedUICommand get_MoveFocusForward();
    public static RoutedUICommand get_MoveFocusBack();
    public static RoutedUICommand get_MoveFocusPageUp();
    public static RoutedUICommand get_MoveFocusPageDown();
    private static string GetPropertyName(CommandId commandId);
    internal static string GetUIText(byte commandId);
    internal static InputGestureCollection LoadDefaultGestureFromResource(byte commandId);
    private static RoutedUICommand _EnsureCommand(CommandId idCommand);
}
[LocalizabilityAttribute("0")]
[TypeConverterAttribute("System.Windows.Input.CursorConverter")]
public class System.Windows.Input.Cursor : object {
    private static int BUFFERSIZE;
    private string _fileName;
    private CursorType _cursorType;
    private bool _scaleWithDpi;
    private SafeHandle _cursorHandle;
    private static Int32[] CursorTypes;
    internal CursorType CursorType { get; }
    internal SafeHandle Handle { get; }
    internal string FileName { get; }
    internal Cursor(CursorType cursorType);
    public Cursor(string cursorFile);
    public Cursor(string cursorFile, bool scaleWithDpi);
    public Cursor(Stream cursorStream);
    public Cursor(Stream cursorStream, bool scaleWithDpi);
    [FriendAccessAllowedAttribute]
internal Cursor(SafeHandle cursorHandle);
    private static Cursor();
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    internal CursorType get_CursorType();
    internal SafeHandle get_Handle();
    internal string get_FileName();
    private void LoadFromFile(string fileName);
    private void LegacyLoadFromStream(Stream cursorStream);
    private void LoadFromStream(Stream cursorStream);
    private void LoadCursorHelper(CursorType cursorType);
    public virtual string ToString();
    private bool IsValidCursorType(CursorType cursorType);
}
public class System.Windows.Input.CursorConverter : TypeConverter {
    private StandardValuesCollection _standardValues;
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    private PropertyInfo[] GetProperties();
    public virtual StandardValuesCollection GetStandardValues(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public static class System.Windows.Input.Cursors : object {
    private static int _cursorTypeCount;
    private static Cursor[] _stockCursors;
    public static Cursor None { get; }
    public static Cursor No { get; }
    public static Cursor Arrow { get; }
    public static Cursor AppStarting { get; }
    public static Cursor Cross { get; }
    public static Cursor Help { get; }
    public static Cursor IBeam { get; }
    public static Cursor SizeAll { get; }
    public static Cursor SizeNESW { get; }
    public static Cursor SizeNS { get; }
    public static Cursor SizeNWSE { get; }
    public static Cursor SizeWE { get; }
    public static Cursor UpArrow { get; }
    public static Cursor Wait { get; }
    public static Cursor Hand { get; }
    public static Cursor Pen { get; }
    public static Cursor ScrollNS { get; }
    public static Cursor ScrollWE { get; }
    public static Cursor ScrollAll { get; }
    public static Cursor ScrollN { get; }
    public static Cursor ScrollS { get; }
    public static Cursor ScrollW { get; }
    public static Cursor ScrollE { get; }
    public static Cursor ScrollNW { get; }
    public static Cursor ScrollNE { get; }
    public static Cursor ScrollSW { get; }
    public static Cursor ScrollSE { get; }
    public static Cursor ArrowCD { get; }
    private static Cursors();
    public static Cursor get_None();
    public static Cursor get_No();
    public static Cursor get_Arrow();
    public static Cursor get_AppStarting();
    public static Cursor get_Cross();
    public static Cursor get_Help();
    public static Cursor get_IBeam();
    public static Cursor get_SizeAll();
    public static Cursor get_SizeNESW();
    public static Cursor get_SizeNS();
    public static Cursor get_SizeNWSE();
    public static Cursor get_SizeWE();
    public static Cursor get_UpArrow();
    public static Cursor get_Wait();
    public static Cursor get_Hand();
    public static Cursor get_Pen();
    public static Cursor get_ScrollNS();
    public static Cursor get_ScrollWE();
    public static Cursor get_ScrollAll();
    public static Cursor get_ScrollN();
    public static Cursor get_ScrollS();
    public static Cursor get_ScrollW();
    public static Cursor get_ScrollE();
    public static Cursor get_ScrollNW();
    public static Cursor get_ScrollNE();
    public static Cursor get_ScrollSW();
    public static Cursor get_ScrollSE();
    public static Cursor get_ArrowCD();
    internal static Cursor EnsureCursor(CursorType cursorType);
}
public enum System.Windows.Input.CursorType : Enum {
    public int value__;
    public static CursorType None;
    public static CursorType No;
    public static CursorType Arrow;
    public static CursorType AppStarting;
    public static CursorType Cross;
    public static CursorType Help;
    public static CursorType IBeam;
    public static CursorType SizeAll;
    public static CursorType SizeNESW;
    public static CursorType SizeNS;
    public static CursorType SizeNWSE;
    public static CursorType SizeWE;
    public static CursorType UpArrow;
    public static CursorType Wait;
    public static CursorType Hand;
    public static CursorType Pen;
    public static CursorType ScrollNS;
    public static CursorType ScrollWE;
    public static CursorType ScrollAll;
    public static CursorType ScrollN;
    public static CursorType ScrollS;
    public static CursorType ScrollW;
    public static CursorType ScrollE;
    public static CursorType ScrollNW;
    public static CursorType ScrollNE;
    public static CursorType ScrollSW;
    public static CursorType ScrollSE;
    public static CursorType ArrowCD;
}
internal class System.Windows.Input.DeadCharTextComposition : TextComposition {
    private bool _composed;
    internal bool Composed { get; internal set; }
    internal DeadCharTextComposition(InputManager inputManager, IInputElement source, string text, TextCompositionAutoComplete autoComplete, InputDevice inputDevice);
    internal bool get_Composed();
    internal void set_Composed(bool value);
}
internal class System.Windows.Input.DefaultTextStore : object {
    private Dispatcher _dispatcher;
    private TextComposition _composition;
    private SecurityCriticalData`1<ITfDocumentMgr> _doc;
    private int _editCookie;
    private int _transitoryExtensionSinkCookie;
    internal static DefaultTextStore Current { get; }
    internal ITfDocumentMgr DocumentManager { get; internal set; }
    unknown int EditCookie {internal set; }
    internal int TransitoryExtensionSinkCookie { get; internal set; }
    internal ITfDocumentMgr TransitoryDocumentManager { get; }
    internal DefaultTextStore(Dispatcher dispatcher);
    public sealed virtual void GetACPFromPoint(POINT& point, GetPositionFromPointFlags flags, Int32& position);
    public sealed virtual void GetTextExt(int start, int end, RECT& rect, Boolean& clipped);
    public sealed virtual void GetScreenExt(RECT& rect);
    public sealed virtual void GetStatus(TS_STATUS& status);
    public sealed virtual void GetWnd(IntPtr& hwnd);
    public sealed virtual void GetValue(Guid& guidAttribute, Object& varValue);
    public sealed virtual void OnStartComposition(ITfCompositionView view, Boolean& ok);
    public sealed virtual void OnUpdateComposition(ITfCompositionView view, ITfRange rangeNew);
    public sealed virtual void OnEndComposition(ITfCompositionView view);
    public sealed virtual void OnTransitoryExtensionUpdated(ITfContext context, int ecReadOnly, ITfRange rangeResult, ITfRange rangeComposition, Boolean& fDeleteResultRange);
    internal static DefaultTextStore get_Current();
    internal ITfDocumentMgr get_DocumentManager();
    internal void set_DocumentManager(ITfDocumentMgr value);
    internal void set_EditCookie(int value);
    internal int get_TransitoryExtensionSinkCookie();
    internal void set_TransitoryExtensionSinkCookie(int value);
    internal ITfDocumentMgr get_TransitoryDocumentManager();
    private string StringFromITfRange(ITfRange range, int ecReadOnly);
    private void Register();
}
internal class System.Windows.Input.DefaultTextStoreTextComposition : TextComposition {
    internal DefaultTextStoreTextComposition(InputManager inputManager, IInputElement source, string text, TextCompositionAutoComplete autoComplete);
    public virtual void Complete();
    private ITfContext GetTransitoryContext();
    private ITfCompositionView GetComposition(ITfContext context);
}
public class System.Windows.Input.ExecutedRoutedEventArgs : RoutedEventArgs {
    private ICommand _command;
    private object _parameter;
    public ICommand Command { get; }
    public object Parameter { get; }
    internal ExecutedRoutedEventArgs(ICommand command, object parameter);
    public ICommand get_Command();
    public object get_Parameter();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object target);
}
public class System.Windows.Input.ExecutedRoutedEventHandler : MulticastDelegate {
    public ExecutedRoutedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ExecutedRoutedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ExecutedRoutedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public static class System.Windows.Input.FocusManager : object {
    public static RoutedEvent GotFocusEvent;
    public static RoutedEvent LostFocusEvent;
    public static DependencyProperty FocusedElementProperty;
    public static DependencyProperty IsFocusScopeProperty;
    private static UncommonField`1<bool> IsFocusedElementSet;
    private static UncommonField`1<WeakReference> FocusedElementWeakCacheField;
    private static UncommonField`1<bool> IsFocusedElementCacheValid;
    private static UncommonField`1<WeakReference> FocusedElementCache;
    private static FocusManager();
    public static void AddGotFocusHandler(DependencyObject element, RoutedEventHandler handler);
    public static void RemoveGotFocusHandler(DependencyObject element, RoutedEventHandler handler);
    public static void AddLostFocusHandler(DependencyObject element, RoutedEventHandler handler);
    public static void RemoveLostFocusHandler(DependencyObject element, RoutedEventHandler handler);
    [DesignerSerializationVisibilityAttribute("0")]
public static IInputElement GetFocusedElement(DependencyObject element);
    internal static IInputElement GetFocusedElement(DependencyObject element, bool validate);
    public static void SetFocusedElement(DependencyObject element, IInputElement value);
    public static void SetIsFocusScope(DependencyObject element, bool value);
    public static bool GetIsFocusScope(DependencyObject element);
    public static DependencyObject GetFocusScope(DependencyObject element);
    private static void OnFocusedElementChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static DependencyObject GetRoot(DependencyObject element);
    private static DependencyObject _GetFocusScope(DependencyObject d);
}
internal interface System.Windows.Input.IAvalonAdapter {
    public abstract virtual bool OnNoMoreTabStops(TraversalRequest request, Boolean& ShouldCycle);
}
public interface System.Windows.Input.ICommandSource {
    public ICommand Command { get; }
    public object CommandParameter { get; }
    public IInputElement CommandTarget { get; }
    public abstract virtual ICommand get_Command();
    public abstract virtual object get_CommandParameter();
    public abstract virtual IInputElement get_CommandTarget();
}
public interface System.Windows.Input.IInputLanguageSource {
    public CultureInfo CurrentInputLanguage { get; public set; }
    public IEnumerable InputLanguageList { get; }
    public abstract virtual void Initialize();
    public abstract virtual void Uninitialize();
    public abstract virtual CultureInfo get_CurrentInputLanguage();
    public abstract virtual void set_CurrentInputLanguage(CultureInfo value);
    public abstract virtual IEnumerable get_InputLanguageList();
}
internal interface System.Windows.Input.IInputProvider {
    public abstract virtual bool ProvidesInputForRootVisual(Visual v);
    public abstract virtual void NotifyDeactivate();
}
internal interface System.Windows.Input.IKeyboardInputProvider {
    public abstract virtual bool AcquireFocus(bool checkOnly);
}
public interface System.Windows.Input.IManipulator {
    public int Id { get; }
    public abstract virtual int get_Id();
    public abstract virtual Point GetPosition(IInputElement relativeTo);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Updated(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Updated(EventHandler value);
    public abstract virtual void ManipulationEnded(bool cancel);
}
[FlagsAttribute]
public enum System.Windows.Input.ImeConversionModeValues : Enum {
    public int value__;
    public static ImeConversionModeValues Native;
    public static ImeConversionModeValues Katakana;
    public static ImeConversionModeValues FullShape;
    public static ImeConversionModeValues Roman;
    public static ImeConversionModeValues CharCode;
    public static ImeConversionModeValues NoConversion;
    public static ImeConversionModeValues Eudc;
    public static ImeConversionModeValues Symbol;
    public static ImeConversionModeValues Fixed;
    public static ImeConversionModeValues Alphanumeric;
    public static ImeConversionModeValues DoNotCare;
}
[FlagsAttribute]
public enum System.Windows.Input.ImeSentenceModeValues : Enum {
    public int value__;
    public static ImeSentenceModeValues None;
    public static ImeSentenceModeValues PluralClause;
    public static ImeSentenceModeValues SingleConversion;
    public static ImeSentenceModeValues Automatic;
    public static ImeSentenceModeValues PhrasePrediction;
    public static ImeSentenceModeValues Conversation;
    public static ImeSentenceModeValues DoNotCare;
}
internal interface System.Windows.Input.IMouseInputProvider {
    public abstract virtual bool SetCursor(Cursor cursor);
    public abstract virtual bool CaptureMouse();
    public abstract virtual void ReleaseMouseCapture();
    public abstract virtual int GetIntermediatePoints(IInputElement relativeTo, Point[] points);
}
public class System.Windows.Input.InertiaExpansionBehavior : object {
    private bool _isInitialVelocitySet;
    private Vector _initialVelocity;
    private bool _isDesiredDecelerationSet;
    private double _desiredDeceleration;
    private bool _isDesiredExpansionSet;
    private Vector _desiredExpansion;
    private bool _isInitialRadiusSet;
    private double _initialRadius;
    public Vector InitialVelocity { get; public set; }
    public double DesiredDeceleration { get; public set; }
    public Vector DesiredExpansion { get; public set; }
    public double InitialRadius { get; public set; }
    internal InertiaExpansionBehavior(Vector initialVelocity);
    public Vector get_InitialVelocity();
    public void set_InitialVelocity(Vector value);
    public double get_DesiredDeceleration();
    public void set_DesiredDeceleration(double value);
    public Vector get_DesiredExpansion();
    public void set_DesiredExpansion(Vector value);
    public double get_InitialRadius();
    public void set_InitialRadius(double value);
    internal bool CanUseForInertia();
    internal static void ApplyParameters(InertiaExpansionBehavior behavior, InertiaProcessor2D processor, Vector initialVelocity);
}
public class System.Windows.Input.InertiaRotationBehavior : object {
    private bool _isInitialVelocitySet;
    private double _initialVelocity;
    private bool _isDesiredDecelerationSet;
    private double _desiredDeceleration;
    private bool _isDesiredRotationSet;
    private double _desiredRotation;
    public double InitialVelocity { get; public set; }
    public double DesiredDeceleration { get; public set; }
    public double DesiredRotation { get; public set; }
    internal InertiaRotationBehavior(double initialVelocity);
    public double get_InitialVelocity();
    public void set_InitialVelocity(double value);
    public double get_DesiredDeceleration();
    public void set_DesiredDeceleration(double value);
    public double get_DesiredRotation();
    public void set_DesiredRotation(double value);
    internal bool CanUseForInertia();
    internal static void ApplyParameters(InertiaRotationBehavior behavior, InertiaProcessor2D processor, double initialVelocity);
}
public class System.Windows.Input.InertiaTranslationBehavior : object {
    private bool _isInitialVelocitySet;
    private Vector _initialVelocity;
    private bool _isDesiredDecelerationSet;
    private double _desiredDeceleration;
    private bool _isDesiredDisplacementSet;
    private double _desiredDisplacement;
    public Vector InitialVelocity { get; public set; }
    public double DesiredDeceleration { get; public set; }
    public double DesiredDisplacement { get; public set; }
    internal InertiaTranslationBehavior(Vector initialVelocity);
    public Vector get_InitialVelocity();
    public void set_InitialVelocity(Vector value);
    public double get_DesiredDeceleration();
    public void set_DesiredDeceleration(double value);
    public double get_DesiredDisplacement();
    public void set_DesiredDisplacement(double value);
    internal bool CanUseForInertia();
    internal static void ApplyParameters(InertiaTranslationBehavior behavior, InertiaProcessor2D processor, Vector initialVelocity);
}
public class System.Windows.Input.InputBinding : Freezable {
    public static DependencyProperty CommandProperty;
    public static DependencyProperty CommandParameterProperty;
    public static DependencyProperty CommandTargetProperty;
    private InputGesture _gesture;
    internal static object _dataLock;
    private DependencyObject _inheritanceContext;
    private bool _hasMultipleInheritanceContexts;
    [LocalizabilityAttribute("17")]
[TypeConverterAttribute("System.Windows.Input.CommandConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
public ICommand Command { get; public set; }
    public object CommandParameter { get; public set; }
    public IInputElement CommandTarget { get; public set; }
    public InputGesture Gesture { get; public set; }
    internal DependencyObject InheritanceContext { get; }
    internal bool HasMultipleInheritanceContexts { get; }
    public InputBinding(ICommand command, InputGesture gesture);
    private static InputBinding();
    public sealed virtual ICommand get_Command();
    public void set_Command(ICommand value);
    private static void OnCommandPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public sealed virtual object get_CommandParameter();
    public void set_CommandParameter(object value);
    public sealed virtual IInputElement get_CommandTarget();
    public void set_CommandTarget(IInputElement value);
    public virtual InputGesture get_Gesture();
    public virtual void set_Gesture(InputGesture value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    internal virtual DependencyObject get_InheritanceContext();
    internal virtual void AddInheritanceContext(DependencyObject context, DependencyProperty property);
    internal virtual void RemoveInheritanceContext(DependencyObject context, DependencyProperty property);
    internal virtual bool get_HasMultipleInheritanceContexts();
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Input.InputBindingCollection : object {
    private List`1<InputBinding> _innerBindingList;
    private bool _isReadOnly;
    private DependencyObject _owner;
    private object System.Collections.IList.Item { get; private set; }
    public InputBinding Item { get; public set; }
    public bool IsSynchronized { get; }
    public bool IsFixedSize { get; }
    public int Count { get; }
    public object SyncRoot { get; }
    public bool IsReadOnly { get; }
    public InputBindingCollection(IList inputBindings);
    internal InputBindingCollection(DependencyObject owner);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.IList.Contains(object key);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object inputBinding);
    private sealed virtual override void System.Collections.IList.Remove(object inputBinding);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public InputBinding get_Item(int index);
    public void set_Item(int index, InputBinding value);
    public int Add(InputBinding inputBinding);
    public sealed virtual bool get_IsSynchronized();
    public int IndexOf(InputBinding value);
    public void AddRange(ICollection collection);
    public void Insert(int index, InputBinding inputBinding);
    public void Remove(InputBinding inputBinding);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual int get_Count();
    public sealed virtual object get_SyncRoot();
    public sealed virtual void Clear();
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual bool get_IsReadOnly();
    public bool Contains(InputBinding key);
    public void CopyTo(InputBinding[] inputBindings, int index);
    internal InputBinding FindMatch(object targetElement, InputEventArgs inputEventArgs);
}
public abstract class System.Windows.Input.InputDevice : DispatcherObject {
    public IInputElement Target { get; }
    public PresentationSource ActiveSource { get; }
    public abstract virtual IInputElement get_Target();
    public abstract virtual PresentationSource get_ActiveSource();
}
internal static class System.Windows.Input.InputElement : object {
    private static DependencyObjectType ContentElementType;
    private static DependencyObjectType UIElementType;
    private static DependencyObjectType UIElement3DType;
    private static InputElement();
    internal static bool IsValid(IInputElement e);
    internal static bool IsValid(DependencyObject o);
    internal static bool IsUIElement(DependencyObject o);
    internal static bool IsUIElement3D(DependencyObject o);
    internal static bool IsContentElement(DependencyObject o);
    internal static DependencyObject GetContainingUIElement(DependencyObject o, bool onlyTraverse2D);
    internal static DependencyObject GetContainingUIElement(DependencyObject o);
    internal static IInputElement GetContainingInputElement(DependencyObject o, bool onlyTraverse2D);
    internal static IInputElement GetContainingInputElement(DependencyObject o);
    internal static DependencyObject GetContainingVisual(DependencyObject o);
    internal static DependencyObject GetRootVisual(DependencyObject o);
    internal static DependencyObject GetRootVisual(DependencyObject o, bool enable2DTo3DTransition);
    internal static Point TranslatePoint(Point pt, DependencyObject from, DependencyObject to);
    internal static Point TranslatePoint(Point pt, DependencyObject from, DependencyObject to, Boolean& translated);
}
[FriendAccessAllowedAttribute]
public class System.Windows.Input.InputEventArgs : RoutedEventArgs {
    private InputDevice _inputDevice;
    private static int _timestamp;
    public InputDevice Device { get; internal set; }
    public int Timestamp { get; }
    public InputEventArgs(InputDevice inputDevice, int timestamp);
    public InputDevice get_Device();
    internal void set_Device(InputDevice value);
    public int get_Timestamp();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.InputEventHandler : MulticastDelegate {
    public InputEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, InputEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, InputEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class System.Windows.Input.InputGesture : object {
    public abstract virtual bool Matches(object targetElement, InputEventArgs inputEventArgs);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Input.InputGestureCollection : object {
    private List`1<InputGesture> _innerGestureList;
    private bool _isReadOnly;
    private object System.Collections.IList.Item { get; private set; }
    public InputGesture Item { get; public set; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public int Count { get; }
    public InputGestureCollection(IList inputGestures);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.IList.Contains(object key);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object inputGesture);
    private sealed virtual override void System.Collections.IList.Remove(object inputGesture);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual IEnumerator GetEnumerator();
    public InputGesture get_Item(int index);
    public void set_Item(int index, InputGesture value);
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public int IndexOf(InputGesture value);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual bool get_IsFixedSize();
    public int Add(InputGesture inputGesture);
    public void AddRange(ICollection collection);
    public void Insert(int index, InputGesture inputGesture);
    public sealed virtual bool get_IsReadOnly();
    public void Remove(InputGesture inputGesture);
    public sealed virtual int get_Count();
    public sealed virtual void Clear();
    public bool Contains(InputGesture key);
    public void CopyTo(InputGesture[] inputGestures, int index);
    public void Seal();
    private void EnsureList();
    internal InputGesture FindMatch(object targetElement, InputEventArgs inputEventArgs);
}
public class System.Windows.Input.InputLanguageChangedEventArgs : InputLanguageEventArgs {
    public InputLanguageChangedEventArgs(CultureInfo newLanguageId, CultureInfo previousLanguageId);
}
public class System.Windows.Input.InputLanguageChangingEventArgs : InputLanguageEventArgs {
    private bool _rejected;
    public bool Rejected { get; public set; }
    public InputLanguageChangingEventArgs(CultureInfo newLanguageId, CultureInfo previousLanguageId);
    public bool get_Rejected();
    public void set_Rejected(bool value);
}
public abstract class System.Windows.Input.InputLanguageEventArgs : EventArgs {
    private CultureInfo _newLanguageId;
    private CultureInfo _previousLanguageId;
    public CultureInfo NewLanguage { get; }
    public CultureInfo PreviousLanguage { get; }
    protected InputLanguageEventArgs(CultureInfo newLanguageId, CultureInfo previousLanguageId);
    public virtual CultureInfo get_NewLanguage();
    public virtual CultureInfo get_PreviousLanguage();
}
public class System.Windows.Input.InputLanguageEventHandler : MulticastDelegate {
    public InputLanguageEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, InputLanguageEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, InputLanguageEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Input.InputLanguageManager : DispatcherObject {
    public static DependencyProperty InputLanguageProperty;
    public static DependencyProperty RestoreInputLanguageProperty;
    [CompilerGeneratedAttribute]
private InputLanguageEventHandler _InputLanguageChanged;
    [CompilerGeneratedAttribute]
private InputLanguageEventHandler _InputLanguageChanging;
    private CultureInfo _previousLanguageId;
    private IInputLanguageSource _source;
    public static InputLanguageManager Current { get; }
    [TypeConverterAttribute("System.Windows.CultureInfoIetfLanguageTagConverter")]
public CultureInfo CurrentInputLanguage { get; public set; }
    public IEnumerable AvailableInputLanguages { get; }
    internal IInputLanguageSource Source { get; }
    internal static bool IsMultipleKeyboardLayout { get; }
    private static InputLanguageManager();
    public static void SetInputLanguage(DependencyObject target, CultureInfo inputLanguage);
    [TypeConverterAttribute("System.Windows.CultureInfoIetfLanguageTagConverter")]
[AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static CultureInfo GetInputLanguage(DependencyObject target);
    public static void SetRestoreInputLanguage(DependencyObject target, bool restore);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetRestoreInputLanguage(DependencyObject target);
    public void RegisterInputLanguageSource(IInputLanguageSource inputLanguageSource);
    public void ReportInputLanguageChanged(CultureInfo newLanguageId, CultureInfo previousLanguageId);
    public bool ReportInputLanguageChanging(CultureInfo newLanguageId, CultureInfo previousLanguageId);
    public static InputLanguageManager get_Current();
    public CultureInfo get_CurrentInputLanguage();
    public void set_CurrentInputLanguage(CultureInfo value);
    public IEnumerable get_AvailableInputLanguages();
    public void add_InputLanguageChanged(InputLanguageEventHandler value);
    public void remove_InputLanguageChanged(InputLanguageEventHandler value);
    public void add_InputLanguageChanging(InputLanguageEventHandler value);
    public void remove_InputLanguageChanging(InputLanguageEventHandler value);
    internal void Focus(DependencyObject focus, DependencyObject focused);
    internal IInputLanguageSource get_Source();
    internal static bool get_IsMultipleKeyboardLayout();
    private void SetSourceCurrentLanguageId(CultureInfo languageId);
    [CompilerGeneratedAttribute]
private void add__InputLanguageChanged(InputLanguageEventHandler value);
    [CompilerGeneratedAttribute]
private void remove__InputLanguageChanged(InputLanguageEventHandler value);
    [CompilerGeneratedAttribute]
private void add__InputLanguageChanging(InputLanguageEventHandler value);
    [CompilerGeneratedAttribute]
private void remove__InputLanguageChanging(InputLanguageEventHandler value);
}
internal class System.Windows.Input.InputLanguageProfileNotifySink : object {
    private InputLanguageSource _target;
    internal InputLanguageProfileNotifySink(InputLanguageSource target);
    public sealed virtual void OnLanguageChange(short langid, Boolean& accept);
    public sealed virtual void OnLanguageChanged();
}
internal class System.Windows.Input.InputLanguageSource : object {
    private short _langid;
    private int _dispatcherThreadId;
    private InputLanguageManager _inputlanguagemanager;
    private InputProcessorProfiles _ipp;
    public CultureInfo CurrentInputLanguage { get; public set; }
    public IEnumerable InputLanguageList { get; }
    private short _CurrentInputLanguage { get; private set; }
    internal InputLanguageSource(InputLanguageManager inputlanguagemanager);
    public sealed virtual void Dispose();
    public sealed virtual void Initialize();
    public sealed virtual void Uninitialize();
    public sealed virtual CultureInfo get_CurrentInputLanguage();
    public sealed virtual void set_CurrentInputLanguage(CultureInfo value);
    public sealed virtual IEnumerable get_InputLanguageList();
    internal bool OnLanguageChange(short langid);
    internal void OnLanguageChanged();
    private void EnsureInputProcessorProfile();
    private short get__CurrentInputLanguage();
    private void set__CurrentInputLanguage(short value);
}
public class System.Windows.Input.InputManager : DispatcherObject {
    internal static RoutedEvent PreviewInputReportEvent;
    [FriendAccessAllowedAttribute]
internal static RoutedEvent InputReportEvent;
    [CompilerGeneratedAttribute]
private EventHandler EnterMenuMode;
    [CompilerGeneratedAttribute]
private EventHandler LeaveMenuMode;
    private int _menuModeCount;
    [CompilerGeneratedAttribute]
private EventHandler HitTestInvalidatedAsync;
    private DispatcherOperationCallback _continueProcessingStagingAreaCallback;
    private bool _continueProcessingStagingArea;
    private NotifyInputEventArgs _notifyInputEventArgs;
    private ProcessInputEventArgs _processInputEventArgs;
    private PreProcessInputEventArgs _preProcessInputEventArgs;
    [CompilerGeneratedAttribute]
private PreProcessInputEventHandler _preProcessInput;
    [CompilerGeneratedAttribute]
private NotifyInputEventHandler _preNotifyInput;
    [CompilerGeneratedAttribute]
private NotifyInputEventHandler _postNotifyInput;
    [CompilerGeneratedAttribute]
private ProcessInputEventHandler _postProcessInput;
    [CompilerGeneratedAttribute]
private KeyEventHandler _translateAccelerator;
    private Hashtable _inputProviders;
    private KeyboardDevice _primaryKeyboardDevice;
    private MouseDevice _primaryMouseDevice;
    private CommandDevice _primaryCommandDevice;
    private bool _inDragDrop;
    private DispatcherOperationCallback _hitTestInvalidatedAsyncCallback;
    private DispatcherOperation _hitTestInvalidatedAsyncOperation;
    private EventHandler _layoutUpdatedCallback;
    private Stack _stagingArea;
    private InputDevice _mostRecentInputDevice;
    private DispatcherTimer _inputTimer;
    private static bool _isSynchronizedInput;
    private static DependencyObject _listeningElement;
    private static RoutedEvent[] _synchronizedInputEvents;
    private static RoutedEvent[] _pairedSynchronizedInputEvents;
    private static SynchronizedInputType _synchronizedInputType;
    private static SynchronizedInputStates _synchronizedInputState;
    private static DispatcherOperation _synchronizedInputAsyncClearOperation;
    private static object _synchronizedInputLock;
    public static InputManager Current { get; }
    internal static InputManager UnsecureCurrent { get; }
    internal static bool IsSynchronizedInput { get; }
    internal static RoutedEvent[] SynchronizedInputEvents { get; }
    internal static RoutedEvent[] PairedSynchronizedInputEvents { get; }
    internal static SynchronizedInputType SynchronizeInputType { get; }
    internal static DependencyObject ListeningElement { get; }
    internal static SynchronizedInputStates SynchronizedInputState { get; internal set; }
    public ICollection InputProviders { get; }
    internal ICollection UnsecureInputProviders { get; }
    public KeyboardDevice PrimaryKeyboardDevice { get; }
    public MouseDevice PrimaryMouseDevice { get; }
    internal StylusLogic StylusLogic { get; }
    internal CommandDevice PrimaryCommandDevice { get; }
    internal bool InDragDrop { get; internal set; }
    public InputDevice MostRecentInputDevice { get; internal set; }
    public bool IsInMenuMode { get; }
    private static InputManager();
    public static InputManager get_Current();
    [FriendAccessAllowedAttribute]
internal static InputManager get_UnsecureCurrent();
    internal static bool get_IsSynchronizedInput();
    internal static RoutedEvent[] get_SynchronizedInputEvents();
    internal static RoutedEvent[] get_PairedSynchronizedInputEvents();
    internal static SynchronizedInputType get_SynchronizeInputType();
    internal static DependencyObject get_ListeningElement();
    internal static SynchronizedInputStates get_SynchronizedInputState();
    internal static void set_SynchronizedInputState(SynchronizedInputStates value);
    private static InputManager GetCurrentInputManagerImpl();
    public void add_PreProcessInput(PreProcessInputEventHandler value);
    public void remove_PreProcessInput(PreProcessInputEventHandler value);
    public void add_PreNotifyInput(NotifyInputEventHandler value);
    public void remove_PreNotifyInput(NotifyInputEventHandler value);
    public void add_PostNotifyInput(NotifyInputEventHandler value);
    public void remove_PostNotifyInput(NotifyInputEventHandler value);
    public void add_PostProcessInput(ProcessInputEventHandler value);
    public void remove_PostProcessInput(ProcessInputEventHandler value);
    [FriendAccessAllowedAttribute]
internal void add_TranslateAccelerator(KeyEventHandler value);
    [FriendAccessAllowedAttribute]
internal void remove_TranslateAccelerator(KeyEventHandler value);
    internal void RaiseTranslateAccelerator(KeyEventArgs e);
    internal InputProviderSite RegisterInputProvider(IInputProvider inputProvider);
    internal void UnregisterInputProvider(IInputProvider inputProvider);
    public ICollection get_InputProviders();
    internal ICollection get_UnsecureInputProviders();
    public KeyboardDevice get_PrimaryKeyboardDevice();
    public MouseDevice get_PrimaryMouseDevice();
    internal StylusLogic get_StylusLogic();
    internal CommandDevice get_PrimaryCommandDevice();
    internal bool get_InDragDrop();
    internal void set_InDragDrop(bool value);
    public InputDevice get_MostRecentInputDevice();
    internal void set_MostRecentInputDevice(InputDevice value);
    public void PushMenuMode(PresentationSource menuSite);
    public void PopMenuMode(PresentationSource menuSite);
    public bool get_IsInMenuMode();
    [CompilerGeneratedAttribute]
public void add_EnterMenuMode(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_EnterMenuMode(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_LeaveMenuMode(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_LeaveMenuMode(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_HitTestInvalidatedAsync(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_HitTestInvalidatedAsync(EventHandler value);
    internal void NotifyHitTestInvalidated();
    internal static void SafeCurrentNotifyHitTestInvalidated();
    private object HitTestInvalidatedAsyncCallback(object arg);
    private void OnLayoutUpdated(object sender, EventArgs e);
    internal void InvalidateInputDevices();
    private void ValidateInputDevices(object sender, EventArgs e);
    public bool ProcessInput(InputEventArgs input);
    internal StagingAreaInputItem PushInput(StagingAreaInputItem inputItem);
    internal StagingAreaInputItem PushInput(InputEventArgs input, StagingAreaInputItem promote);
    internal StagingAreaInputItem PushMarker();
    internal StagingAreaInputItem PopInput();
    internal StagingAreaInputItem PeekInput();
    internal object ContinueProcessingStagingArea(object unused);
    internal static bool StartListeningSynchronizedInput(DependencyObject d, SynchronizedInputType inputType);
    internal static void CancelSynchronizedInput();
    private bool ProcessStagingArea();
    private void RaiseProcessInputEventHandlers(ProcessInputEventHandler postProcessInput, ProcessInputEventArgs processInputEventArgs);
    private void RequestContinueProcessingStagingArea();
    [CompilerGeneratedAttribute]
private void add__preProcessInput(PreProcessInputEventHandler value);
    [CompilerGeneratedAttribute]
private void remove__preProcessInput(PreProcessInputEventHandler value);
    [CompilerGeneratedAttribute]
private void add__preNotifyInput(NotifyInputEventHandler value);
    [CompilerGeneratedAttribute]
private void remove__preNotifyInput(NotifyInputEventHandler value);
    [CompilerGeneratedAttribute]
private void add__postNotifyInput(NotifyInputEventHandler value);
    [CompilerGeneratedAttribute]
private void remove__postNotifyInput(NotifyInputEventHandler value);
    [CompilerGeneratedAttribute]
private void add__postProcessInput(ProcessInputEventHandler value);
    [CompilerGeneratedAttribute]
private void remove__postProcessInput(ProcessInputEventHandler value);
    [CompilerGeneratedAttribute]
private void add__translateAccelerator(KeyEventHandler value);
    [CompilerGeneratedAttribute]
private void remove__translateAccelerator(KeyEventHandler value);
}
public class System.Windows.Input.InputMethod : DispatcherObject {
    public static DependencyProperty IsInputMethodEnabledProperty;
    public static DependencyProperty IsInputMethodSuspendedProperty;
    public static DependencyProperty PreferredImeStateProperty;
    public static DependencyProperty PreferredImeConversionModeProperty;
    public static DependencyProperty PreferredImeSentenceModeProperty;
    public static DependencyProperty InputScopeProperty;
    [CompilerGeneratedAttribute]
private InputMethodStateChangedEventHandler _StateChanged;
    private TextServicesCompartmentEventSink _sink;
    private TextServicesContext _textservicesContext;
    private TextServicesCompartmentContext _textservicesCompartmentContext;
    private InputLanguageManager _inputlanguagemanager;
    private DefaultTextStore _defaulttextstore;
    private static bool _immEnabled;
    [ThreadStaticAttribute]
private static SecurityCriticalDataClass`1<IntPtr> _defaultImc;
    public static InputMethod Current { get; }
    public InputMethodState ImeState { get; public set; }
    public InputMethodState MicrophoneState { get; public set; }
    public InputMethodState HandwritingState { get; public set; }
    public SpeechMode SpeechMode { get; public set; }
    public ImeConversionModeValues ImeConversionMode { get; public set; }
    public ImeSentenceModeValues ImeSentenceMode { get; public set; }
    public bool CanShowConfigurationUI { get; }
    public bool CanShowRegisterWordUI { get; }
    internal TextServicesContext TextServicesContext { get; internal set; }
    internal TextServicesCompartmentContext TextServicesCompartmentContext { get; internal set; }
    internal InputLanguageManager InputLanguageManager { get; internal set; }
    internal DefaultTextStore DefaultTextStore { get; internal set; }
    private IntPtr DefaultImc { get; }
    private static InputMethod();
    public static void SetIsInputMethodEnabled(DependencyObject target, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetIsInputMethodEnabled(DependencyObject target);
    public static void SetIsInputMethodSuspended(DependencyObject target, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetIsInputMethodSuspended(DependencyObject target);
    public static void SetPreferredImeState(DependencyObject target, InputMethodState value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static InputMethodState GetPreferredImeState(DependencyObject target);
    public static void SetPreferredImeConversionMode(DependencyObject target, ImeConversionModeValues value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static ImeConversionModeValues GetPreferredImeConversionMode(DependencyObject target);
    public static void SetPreferredImeSentenceMode(DependencyObject target, ImeSentenceModeValues value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static ImeSentenceModeValues GetPreferredImeSentenceMode(DependencyObject target);
    public static void SetInputScope(DependencyObject target, InputScope value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static InputScope GetInputScope(DependencyObject target);
    public static InputMethod get_Current();
    public void ShowConfigureUI();
    public void ShowConfigureUI(UIElement element);
    public void ShowRegisterWordUI();
    public void ShowRegisterWordUI(string registeredText);
    public void ShowRegisterWordUI(UIElement element, string registeredText);
    public InputMethodState get_ImeState();
    public void set_ImeState(InputMethodState value);
    public InputMethodState get_MicrophoneState();
    public void set_MicrophoneState(InputMethodState value);
    public InputMethodState get_HandwritingState();
    public void set_HandwritingState(InputMethodState value);
    public SpeechMode get_SpeechMode();
    public void set_SpeechMode(SpeechMode value);
    public ImeConversionModeValues get_ImeConversionMode();
    public void set_ImeConversionMode(ImeConversionModeValues value);
    public ImeSentenceModeValues get_ImeSentenceMode();
    public void set_ImeSentenceMode(ImeSentenceModeValues value);
    public bool get_CanShowConfigurationUI();
    public bool get_CanShowRegisterWordUI();
    public void add_StateChanged(InputMethodStateChangedEventHandler value);
    public void remove_StateChanged(InputMethodStateChangedEventHandler value);
    internal void GotKeyboardFocus(DependencyObject focus);
    internal void OnChange(Guid& rguid);
    internal static bool IsImm32ImeCurrent();
    internal static bool IsImm32Ime(IntPtr hkl);
    private static void IsInputMethodEnabled_Changed(DependencyObject d, DependencyPropertyChangedEventArgs e);
    internal void EnableOrDisableInputMethod(bool bEnabled);
    internal TextServicesContext get_TextServicesContext();
    internal void set_TextServicesContext(TextServicesContext value);
    internal TextServicesCompartmentContext get_TextServicesCompartmentContext();
    internal void set_TextServicesCompartmentContext(TextServicesCompartmentContext value);
    internal InputLanguageManager get_InputLanguageManager();
    internal void set_InputLanguageManager(InputLanguageManager value);
    internal DefaultTextStore get_DefaultTextStore();
    internal void set_DefaultTextStore(DefaultTextStore value);
    private ConversionModeFlags Imm32ConversionModeToTSFConversionMode(IntPtr hwnd);
    private void InitializeCompartmentEventSink();
    private void UninitializeCompartmentEventSink();
    private bool _ShowConfigureUI(UIElement element, bool fShow);
    private bool _ShowRegisterWordUI(UIElement element, bool fShow, string strRegister);
    private static IntPtr HwndFromInputElement(IInputElement element);
    private ITfFunctionProvider GetFunctionPrvForCurrentKeyboardTIP(TF_LANGUAGEPROFILE& tf_profile);
    private TF_LANGUAGEPROFILE GetCurrentKeybordTipProfile();
    private bool IsValidConversionMode(ImeConversionModeValues mode);
    private bool IsValidSentenceMode(ImeSentenceModeValues mode);
    [CompilerGeneratedAttribute]
private void add__StateChanged(InputMethodStateChangedEventHandler value);
    [CompilerGeneratedAttribute]
private void remove__StateChanged(InputMethodStateChangedEventHandler value);
    private IntPtr get_DefaultImc();
}
internal class System.Windows.Input.InputMethodEventTypeInfo : object {
    private static InputMethodEventTypeInfo _iminfoImeState;
    private static InputMethodEventTypeInfo _iminfoHandwritingState;
    private static InputMethodEventTypeInfo _iminfoMicrophoneState;
    private static InputMethodEventTypeInfo _iminfoSpeechMode;
    private static InputMethodEventTypeInfo _iminfoImeConversionMode;
    private static InputMethodEventTypeInfo _iminfoImeSentenceMode;
    private static InputMethodEventTypeInfo[] _iminfo;
    private InputMethodStateType _inputmethodstatetype;
    private Guid _guid;
    private CompartmentScope _scope;
    internal InputMethodStateType Type { get; }
    internal Guid Guid { get; }
    internal CompartmentScope Scope { get; }
    internal static InputMethodEventTypeInfo[] InfoList { get; }
    internal InputMethodEventTypeInfo(InputMethodStateType type, Guid guid, CompartmentScope scope);
    private static InputMethodEventTypeInfo();
    internal static InputMethodStateType ToType(Guid& rguid);
    internal InputMethodStateType get_Type();
    internal Guid get_Guid();
    internal CompartmentScope get_Scope();
    internal static InputMethodEventTypeInfo[] get_InfoList();
}
public enum System.Windows.Input.InputMethodState : Enum {
    public int value__;
    public static InputMethodState Off;
    public static InputMethodState On;
    public static InputMethodState DoNotCare;
}
public class System.Windows.Input.InputMethodStateChangedEventArgs : EventArgs {
    private InputMethodStateType _statetype;
    public bool IsImeStateChanged { get; }
    public bool IsMicrophoneStateChanged { get; }
    public bool IsHandwritingStateChanged { get; }
    public bool IsSpeechModeChanged { get; }
    public bool IsImeConversionModeChanged { get; }
    public bool IsImeSentenceModeChanged { get; }
    internal InputMethodStateChangedEventArgs(InputMethodStateType statetype);
    public bool get_IsImeStateChanged();
    public bool get_IsMicrophoneStateChanged();
    public bool get_IsHandwritingStateChanged();
    public bool get_IsSpeechModeChanged();
    public bool get_IsImeConversionModeChanged();
    public bool get_IsImeSentenceModeChanged();
}
public class System.Windows.Input.InputMethodStateChangedEventHandler : MulticastDelegate {
    public InputMethodStateChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, InputMethodStateChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, InputMethodStateChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal enum System.Windows.Input.InputMethodStateType : Enum {
    public int value__;
    public static InputMethodStateType Invalid;
    public static InputMethodStateType ImeState;
    public static InputMethodStateType MicrophoneState;
    public static InputMethodStateType HandwritingState;
    public static InputMethodStateType SpeechMode;
    public static InputMethodStateType ImeConversionModeValues;
    public static InputMethodStateType ImeSentenceModeValues;
}
public enum System.Windows.Input.InputMode : Enum {
    public int value__;
    public static InputMode Foreground;
    public static InputMode Sink;
}
internal class System.Windows.Input.InputProcessorProfiles : object {
    private SecurityCriticalDataForSet`1<ITfInputProcessorProfiles> _ipp;
    private int _cookie;
    unknown short CurrentInputLanguage {internal set; }
    internal ArrayList InputLanguageList { get; }
    internal bool Initialize(object o);
    internal void Uninitialize();
    internal void set_CurrentInputLanguage(short value);
    internal ArrayList get_InputLanguageList();
    private void AdviseNotifySink(object o);
    private void UnadviseNotifySink();
}
internal static class System.Windows.Input.InputProcessorProfilesLoader : object {
    internal static ITfInputProcessorProfiles Load();
}
internal class System.Windows.Input.InputProviderSite : object {
    private bool _isDisposed;
    private SecurityCriticalDataClass`1<InputManager> _inputManager;
    private SecurityCriticalDataClass`1<IInputProvider> _inputProvider;
    public InputManager InputManager { get; }
    internal InputManager CriticalInputManager { get; }
    public bool IsDisposed { get; }
    internal InputProviderSite(InputManager inputManager, IInputProvider inputProvider);
    public InputManager get_InputManager();
    internal InputManager get_CriticalInputManager();
    public sealed virtual void Dispose();
    public bool get_IsDisposed();
    public bool ReportInput(InputReport inputReport);
}
[FriendAccessAllowedAttribute]
internal abstract class System.Windows.Input.InputReport : object {
    private SecurityCriticalData`1<PresentationSource> _inputSource;
    private InputType _type;
    private InputMode _mode;
    private int _timestamp;
    public PresentationSource InputSource { get; }
    public InputType Type { get; }
    public InputMode Mode { get; }
    public int Timestamp { get; }
    protected InputReport(PresentationSource inputSource, InputType type, InputMode mode, int timestamp);
    public PresentationSource get_InputSource();
    public InputType get_Type();
    public InputMode get_Mode();
    public int get_Timestamp();
    private void Validate_InputMode(InputMode mode);
    private void Validate_InputType(InputType type);
}
[FriendAccessAllowedAttribute]
internal class System.Windows.Input.InputReportEventArgs : InputEventArgs {
    private InputReport _report;
    public InputReport Report { get; }
    public InputReportEventArgs(InputDevice inputDevice, InputReport report);
    public InputReport get_Report();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
internal class System.Windows.Input.InputReportEventHandler : MulticastDelegate {
    public InputReportEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, InputReportEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, InputReportEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[TypeConverterAttribute("System.Windows.Input.InputScopeConverter, PresentationCore, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
public class System.Windows.Input.InputScope : object {
    private IList`1<InputScopeName> _scopeNames;
    private IList`1<InputScopePhrase> _phraseList;
    private string _regexString;
    private string _srgsMarkup;
    [DesignerSerializationVisibilityAttribute("2")]
public IList Names { get; }
    [DefaultValueAttribute("")]
public string SrgsMarkup { get; public set; }
    [DefaultValueAttribute("")]
public string RegularExpression { get; public set; }
    [DesignerSerializationVisibilityAttribute("2")]
public IList PhraseList { get; }
    public IList get_Names();
    public string get_SrgsMarkup();
    public void set_SrgsMarkup(string value);
    public string get_RegularExpression();
    public void set_RegularExpression(string value);
    public IList get_PhraseList();
}
public class System.Windows.Input.InputScopeConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object source);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[ContentPropertyAttribute("NameValue")]
[TypeConverterAttribute("System.Windows.Input.InputScopeNameConverter, PresentationCore, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
public class System.Windows.Input.InputScopeName : object {
    private InputScopeNameValue _nameValue;
    public InputScopeNameValue NameValue { get; public set; }
    public InputScopeName(InputScopeNameValue nameValue);
    public sealed virtual void AddChild(object value);
    public sealed virtual void AddText(string name);
    public InputScopeNameValue get_NameValue();
    public void set_NameValue(InputScopeNameValue value);
    private bool IsValidInputScopeNameValue(InputScopeNameValue name);
}
public class System.Windows.Input.InputScopeNameConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object source);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public enum System.Windows.Input.InputScopeNameValue : Enum {
    public int value__;
    public static InputScopeNameValue Default;
    public static InputScopeNameValue Url;
    public static InputScopeNameValue FullFilePath;
    public static InputScopeNameValue FileName;
    public static InputScopeNameValue EmailUserName;
    public static InputScopeNameValue EmailSmtpAddress;
    public static InputScopeNameValue LogOnName;
    public static InputScopeNameValue PersonalFullName;
    public static InputScopeNameValue PersonalNamePrefix;
    public static InputScopeNameValue PersonalGivenName;
    public static InputScopeNameValue PersonalMiddleName;
    public static InputScopeNameValue PersonalSurname;
    public static InputScopeNameValue PersonalNameSuffix;
    public static InputScopeNameValue PostalAddress;
    public static InputScopeNameValue PostalCode;
    public static InputScopeNameValue AddressStreet;
    public static InputScopeNameValue AddressStateOrProvince;
    public static InputScopeNameValue AddressCity;
    public static InputScopeNameValue AddressCountryName;
    public static InputScopeNameValue AddressCountryShortName;
    public static InputScopeNameValue CurrencyAmountAndSymbol;
    public static InputScopeNameValue CurrencyAmount;
    public static InputScopeNameValue Date;
    public static InputScopeNameValue DateMonth;
    public static InputScopeNameValue DateDay;
    public static InputScopeNameValue DateYear;
    public static InputScopeNameValue DateMonthName;
    public static InputScopeNameValue DateDayName;
    public static InputScopeNameValue Digits;
    public static InputScopeNameValue Number;
    public static InputScopeNameValue OneChar;
    public static InputScopeNameValue Password;
    public static InputScopeNameValue TelephoneNumber;
    public static InputScopeNameValue TelephoneCountryCode;
    public static InputScopeNameValue TelephoneAreaCode;
    public static InputScopeNameValue TelephoneLocalNumber;
    public static InputScopeNameValue Time;
    public static InputScopeNameValue TimeHour;
    public static InputScopeNameValue TimeMinorSec;
    public static InputScopeNameValue NumberFullWidth;
    public static InputScopeNameValue AlphanumericHalfWidth;
    public static InputScopeNameValue AlphanumericFullWidth;
    public static InputScopeNameValue CurrencyChinese;
    public static InputScopeNameValue Bopomofo;
    public static InputScopeNameValue Hiragana;
    public static InputScopeNameValue KatakanaHalfWidth;
    public static InputScopeNameValue KatakanaFullWidth;
    public static InputScopeNameValue Hanja;
    public static InputScopeNameValue PhraseList;
    public static InputScopeNameValue RegularExpression;
    public static InputScopeNameValue Srgs;
    public static InputScopeNameValue Xml;
}
[ContentPropertyAttribute("Name")]
public class System.Windows.Input.InputScopePhrase : object {
    private string _phraseName;
    public string Name { get; public set; }
    public InputScopePhrase(string name);
    public sealed virtual void AddChild(object value);
    public sealed virtual void AddText(string name);
    public string get_Name();
    public void set_Name(string value);
}
public enum System.Windows.Input.InputType : Enum {
    public int value__;
    public static InputType Keyboard;
    public static InputType Mouse;
    public static InputType Stylus;
    public static InputType Hid;
    public static InputType Text;
    public static InputType Command;
}
[TypeConverterAttribute("System.Windows.Input.CommandConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
[FriendAccessAllowedAttribute]
internal interface System.Windows.Input.ISecureCommand {
}
public class System.Windows.Input.KeyBinding : InputBinding {
    public static DependencyProperty ModifiersProperty;
    public static DependencyProperty KeyProperty;
    private bool _settingGesture;
    [ValueSerializerAttribute("System.Windows.Input.KeyGestureValueSerializer")]
[TypeConverterAttribute("System.Windows.Input.KeyGestureConverter")]
public InputGesture Gesture { get; public set; }
    public ModifierKeys Modifiers { get; public set; }
    public Key Key { get; public set; }
    public KeyBinding(ICommand command, KeyGesture gesture);
    public KeyBinding(ICommand command, Key key, ModifierKeys modifiers);
    private static KeyBinding();
    public virtual InputGesture get_Gesture();
    public virtual void set_Gesture(InputGesture value);
    public ModifierKeys get_Modifiers();
    public void set_Modifiers(ModifierKeys value);
    private static void OnModifiersPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Key get_Key();
    public void set_Key(Key value);
    private static void OnKeyPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual Freezable CreateInstanceCore();
    private void SynchronizePropertiesFromGesture(KeyGesture keyGesture);
    private void SynchronizeGestureFromProperties(Key key, ModifierKeys modifiers);
}
public static class System.Windows.Input.Keyboard : object {
    public static RoutedEvent PreviewKeyDownEvent;
    public static RoutedEvent KeyDownEvent;
    public static RoutedEvent PreviewKeyUpEvent;
    public static RoutedEvent KeyUpEvent;
    public static RoutedEvent PreviewGotKeyboardFocusEvent;
    public static RoutedEvent PreviewKeyboardInputProviderAcquireFocusEvent;
    public static RoutedEvent KeyboardInputProviderAcquireFocusEvent;
    public static RoutedEvent GotKeyboardFocusEvent;
    public static RoutedEvent PreviewLostKeyboardFocusEvent;
    public static RoutedEvent LostKeyboardFocusEvent;
    public static IInputElement FocusedElement { get; }
    public static RestoreFocusMode DefaultRestoreFocusMode { get; public set; }
    public static ModifierKeys Modifiers { get; }
    public static KeyboardDevice PrimaryDevice { get; }
    private static Keyboard();
    public static void AddPreviewKeyDownHandler(DependencyObject element, KeyEventHandler handler);
    public static void RemovePreviewKeyDownHandler(DependencyObject element, KeyEventHandler handler);
    public static void AddKeyDownHandler(DependencyObject element, KeyEventHandler handler);
    public static void RemoveKeyDownHandler(DependencyObject element, KeyEventHandler handler);
    public static void AddPreviewKeyUpHandler(DependencyObject element, KeyEventHandler handler);
    public static void RemovePreviewKeyUpHandler(DependencyObject element, KeyEventHandler handler);
    public static void AddKeyUpHandler(DependencyObject element, KeyEventHandler handler);
    public static void RemoveKeyUpHandler(DependencyObject element, KeyEventHandler handler);
    public static void AddPreviewGotKeyboardFocusHandler(DependencyObject element, KeyboardFocusChangedEventHandler handler);
    public static void RemovePreviewGotKeyboardFocusHandler(DependencyObject element, KeyboardFocusChangedEventHandler handler);
    public static void AddPreviewKeyboardInputProviderAcquireFocusHandler(DependencyObject element, KeyboardInputProviderAcquireFocusEventHandler handler);
    public static void RemovePreviewKeyboardInputProviderAcquireFocusHandler(DependencyObject element, KeyboardInputProviderAcquireFocusEventHandler handler);
    public static void AddKeyboardInputProviderAcquireFocusHandler(DependencyObject element, KeyboardInputProviderAcquireFocusEventHandler handler);
    public static void RemoveKeyboardInputProviderAcquireFocusHandler(DependencyObject element, KeyboardInputProviderAcquireFocusEventHandler handler);
    public static void AddGotKeyboardFocusHandler(DependencyObject element, KeyboardFocusChangedEventHandler handler);
    public static void RemoveGotKeyboardFocusHandler(DependencyObject element, KeyboardFocusChangedEventHandler handler);
    public static void AddPreviewLostKeyboardFocusHandler(DependencyObject element, KeyboardFocusChangedEventHandler handler);
    public static void RemovePreviewLostKeyboardFocusHandler(DependencyObject element, KeyboardFocusChangedEventHandler handler);
    public static void AddLostKeyboardFocusHandler(DependencyObject element, KeyboardFocusChangedEventHandler handler);
    public static void RemoveLostKeyboardFocusHandler(DependencyObject element, KeyboardFocusChangedEventHandler handler);
    public static IInputElement get_FocusedElement();
    public static void ClearFocus();
    public static IInputElement Focus(IInputElement element);
    public static RestoreFocusMode get_DefaultRestoreFocusMode();
    public static void set_DefaultRestoreFocusMode(RestoreFocusMode value);
    public static ModifierKeys get_Modifiers();
    public static bool IsKeyDown(Key key);
    public static bool IsKeyUp(Key key);
    public static bool IsKeyToggled(Key key);
    public static KeyStates GetKeyStates(Key key);
    public static KeyboardDevice get_PrimaryDevice();
    internal static bool IsValidKey(Key key);
    internal static bool IsFocusable(DependencyObject element);
}
public abstract class System.Windows.Input.KeyboardDevice : InputDevice {
    [CompilerGeneratedAttribute]
private RestoreFocusMode <DefaultRestoreFocusMode>k__BackingField;
    private SecurityCriticalDataClass`1<InputManager> _inputManager;
    private SecurityCriticalDataClass`1<PresentationSource> _activeSource;
    private DependencyObject _focus;
    private DeferredElementTreeState _focusTreeState;
    private DependencyObject _forceTarget;
    private DependencyObject _focusRootVisual;
    private Key _previousKey;
    private DependencyPropertyChangedEventHandler _isEnabledChangedEventHandler;
    private DependencyPropertyChangedEventHandler _isVisibleChangedEventHandler;
    private DependencyPropertyChangedEventHandler _focusableChangedEventHandler;
    private DispatcherOperationCallback _reevaluateFocusCallback;
    private DispatcherOperation _reevaluateFocusOperation;
    private object _tagNonRedundantActions;
    private object _tagKey;
    private object _tagScanCode;
    private SecurityCriticalData`1<TextCompositionManager> _textcompositionManager;
    private SecurityCriticalDataClass`1<TextServicesManager> _TsfManager;
    public IInputElement Target { get; }
    internal IInputElement ForceTarget { get; internal set; }
    public PresentationSource ActiveSource { get; }
    public RestoreFocusMode DefaultRestoreFocusMode { get; public set; }
    public IInputElement FocusedElement { get; }
    public ModifierKeys Modifiers { get; }
    internal TextServicesManager TextServicesManager { get; }
    internal TextCompositionManager TextCompositionManager { get; }
    internal bool IsActive { get; }
    private DeferredElementTreeState FocusTreeState { get; }
    protected KeyboardDevice(InputManager inputManager);
    protected abstract virtual KeyStates GetKeyStatesFromSystem(Key key);
    public virtual IInputElement get_Target();
    internal IInputElement get_ForceTarget();
    internal void set_ForceTarget(IInputElement value);
    public virtual PresentationSource get_ActiveSource();
    [CompilerGeneratedAttribute]
public RestoreFocusMode get_DefaultRestoreFocusMode();
    [CompilerGeneratedAttribute]
public void set_DefaultRestoreFocusMode(RestoreFocusMode value);
    public IInputElement get_FocusedElement();
    public void ClearFocus();
    public IInputElement Focus(IInputElement element);
    private void Focus(DependencyObject focus, bool askOld, bool askNew, bool forceToNullIfFailed);
    public ModifierKeys get_Modifiers();
    private void Validate_Key(Key key);
    private bool IsKeyDown_private(Key key);
    public bool IsKeyDown(Key key);
    public bool IsKeyUp(Key key);
    public bool IsKeyToggled(Key key);
    public KeyStates GetKeyStates(Key key);
    internal TextServicesManager get_TextServicesManager();
    internal TextCompositionManager get_TextCompositionManager();
    private void TryChangeFocus(DependencyObject newFocus, IKeyboardInputProvider keyboardInputProvider, bool askOld, bool askNew, bool forceToNullIfFailed);
    private void ChangeFocus(DependencyObject focus, int timestamp);
    private void OnIsEnabledChanged(object sender, DependencyPropertyChangedEventArgs e);
    private void OnIsVisibleChanged(object sender, DependencyPropertyChangedEventArgs e);
    private void OnFocusableChanged(object sender, DependencyPropertyChangedEventArgs e);
    internal void ReevaluateFocusAsync(DependencyObject element, DependencyObject oldParent, bool isCoreParent);
    private object ReevaluateFocusCallback(object arg);
    private void PreProcessInput(object sender, PreProcessInputEventArgs e);
    private void PreNotifyInput(object sender, NotifyInputEventArgs e);
    private void PostProcessInput(object sender, ProcessInputEventArgs e);
    private RawKeyboardInputReport ExtractRawKeyboardInputReport(NotifyInputEventArgs e, RoutedEvent Event);
    private RawKeyboardActions GetNonRedundantActions(NotifyInputEventArgs e);
    private bool CheckForDisconnectedFocus();
    internal bool get_IsActive();
    private DeferredElementTreeState get_FocusTreeState();
}
public class System.Windows.Input.KeyboardEventArgs : InputEventArgs {
    public KeyboardDevice KeyboardDevice { get; }
    public KeyboardEventArgs(KeyboardDevice keyboard, int timestamp);
    public KeyboardDevice get_KeyboardDevice();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.KeyboardEventHandler : MulticastDelegate {
    public KeyboardEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, KeyboardEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, KeyboardEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Input.KeyboardFocusChangedEventArgs : KeyboardEventArgs {
    private IInputElement _oldFocus;
    private IInputElement _newFocus;
    public IInputElement OldFocus { get; }
    public IInputElement NewFocus { get; }
    public KeyboardFocusChangedEventArgs(KeyboardDevice keyboard, int timestamp, IInputElement oldFocus, IInputElement newFocus);
    public IInputElement get_OldFocus();
    public IInputElement get_NewFocus();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.KeyboardFocusChangedEventHandler : MulticastDelegate {
    public KeyboardFocusChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, KeyboardFocusChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, KeyboardFocusChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Input.KeyboardInputProviderAcquireFocusEventArgs : KeyboardEventArgs {
    private bool _focusAcquired;
    public bool FocusAcquired { get; }
    public KeyboardInputProviderAcquireFocusEventArgs(KeyboardDevice keyboard, int timestamp, bool focusAcquired);
    public bool get_FocusAcquired();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.KeyboardInputProviderAcquireFocusEventHandler : MulticastDelegate {
    public KeyboardInputProviderAcquireFocusEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, KeyboardInputProviderAcquireFocusEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, KeyboardInputProviderAcquireFocusEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Input.KeyEventArgs : KeyboardEventArgs {
    private Key _realKey;
    private Key _key;
    private PresentationSource _inputSource;
    private bool _isRepeat;
    private int _scanCode;
    private bool _isExtendedKey;
    public PresentationSource InputSource { get; }
    public Key Key { get; }
    internal Key RealKey { get; }
    public Key ImeProcessedKey { get; }
    public Key SystemKey { get; }
    public Key DeadCharProcessedKey { get; }
    public KeyStates KeyStates { get; }
    public bool IsRepeat { get; }
    public bool IsDown { get; }
    public bool IsUp { get; }
    public bool IsToggled { get; }
    internal PresentationSource UnsafeInputSource { get; }
    internal int ScanCode { get; internal set; }
    internal bool IsExtendedKey { get; internal set; }
    public KeyEventArgs(KeyboardDevice keyboard, PresentationSource inputSource, int timestamp, Key key);
    public PresentationSource get_InputSource();
    public Key get_Key();
    internal Key get_RealKey();
    public Key get_ImeProcessedKey();
    public Key get_SystemKey();
    public Key get_DeadCharProcessedKey();
    public KeyStates get_KeyStates();
    public bool get_IsRepeat();
    public bool get_IsDown();
    public bool get_IsUp();
    public bool get_IsToggled();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
    internal void SetRepeat(bool newRepeatState);
    internal void MarkNormal();
    internal void MarkSystem();
    internal void MarkImeProcessed();
    internal void MarkDeadCharProcessed();
    internal PresentationSource get_UnsafeInputSource();
    internal int get_ScanCode();
    internal void set_ScanCode(int value);
    internal bool get_IsExtendedKey();
    internal void set_IsExtendedKey(bool value);
}
public class System.Windows.Input.KeyEventHandler : MulticastDelegate {
    public KeyEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, KeyEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, KeyEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[ValueSerializerAttribute("System.Windows.Input.KeyGestureValueSerializer")]
[TypeConverterAttribute("System.Windows.Input.KeyGestureConverter")]
public class System.Windows.Input.KeyGesture : InputGesture {
    private ModifierKeys _modifiers;
    private Key _key;
    private string _displayString;
    private static string MULTIPLEGESTURE_DELIMITER;
    private static TypeConverter _keyGestureConverter;
    public ModifierKeys Modifiers { get; }
    public Key Key { get; }
    public string DisplayString { get; }
    public KeyGesture(Key key);
    public KeyGesture(Key key, ModifierKeys modifiers);
    public KeyGesture(Key key, ModifierKeys modifiers, string displayString);
    internal KeyGesture(Key key, ModifierKeys modifiers, bool validateGesture);
    private KeyGesture(Key key, ModifierKeys modifiers, string displayString, bool validateGesture);
    private static KeyGesture();
    public ModifierKeys get_Modifiers();
    public Key get_Key();
    public string get_DisplayString();
    public string GetDisplayStringForCulture(CultureInfo culture);
    public virtual bool Matches(object targetElement, InputEventArgs inputEventArgs);
    internal static bool IsDefinedKey(Key key);
    internal static bool IsValid(Key key, ModifierKeys modifiers);
    internal static void AddGesturesFromResourceStrings(string keyGestures, string displayStrings, InputGestureCollection gestures);
    internal static KeyGesture CreateFromResourceStrings(string keyGestureToken, string keyDisplayString);
}
public class System.Windows.Input.KeyGestureConverter : TypeConverter {
    private static char MODIFIERS_DELIMITER;
    internal static char DISPLAYSTRING_SEPARATOR;
    private static KeyConverter keyConverter;
    private static ModifierKeysConverter modifierKeysConverter;
    private static KeyGestureConverter();
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object source);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    internal static bool IsDefinedKey(Key key);
}
public class System.Windows.Input.KeyGestureValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
[FlagsAttribute]
public enum System.Windows.Input.KeyStates : Enum {
    public byte value__;
    public static KeyStates None;
    public static KeyStates Down;
    public static KeyStates Toggled;
}
public static class System.Windows.Input.Manipulation : object {
    internal static RoutedEvent ManipulationStartingEvent;
    internal static RoutedEvent ManipulationStartedEvent;
    internal static RoutedEvent ManipulationDeltaEvent;
    internal static RoutedEvent ManipulationInertiaStartingEvent;
    internal static RoutedEvent ManipulationBoundaryFeedbackEvent;
    internal static RoutedEvent ManipulationCompletedEvent;
    private static Manipulation();
    public static bool IsManipulationActive(UIElement element);
    private static ManipulationDevice GetActiveManipulationDevice(UIElement element);
    public static void StartInertia(UIElement element);
    public static void CompleteManipulation(UIElement element);
    internal static bool TryCompleteManipulation(UIElement element);
    public static void SetManipulationMode(UIElement element, ManipulationModes mode);
    public static ManipulationModes GetManipulationMode(UIElement element);
    public static void SetManipulationContainer(UIElement element, IInputElement container);
    public static IInputElement GetManipulationContainer(UIElement element);
    public static void SetManipulationPivot(UIElement element, ManipulationPivot pivot);
    public static ManipulationPivot GetManipulationPivot(UIElement element);
    public static void AddManipulator(UIElement element, IManipulator manipulator);
    public static void RemoveManipulator(UIElement element, IManipulator manipulator);
    internal static bool TryRemoveManipulator(UIElement element, IManipulator manipulator);
    [BrowsableAttribute("False")]
public static void SetManipulationParameter(UIElement element, ManipulationParameters2D parameter);
    internal static UIElement FindManipulationParent(Visual visual);
}
public class System.Windows.Input.ManipulationBoundaryFeedbackEventArgs : InputEventArgs {
    [CompilerGeneratedAttribute]
private IInputElement <ManipulationContainer>k__BackingField;
    [CompilerGeneratedAttribute]
private ManipulationDelta <BoundaryFeedback>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<Point, Point> <CompensateForBoundaryFeedback>k__BackingField;
    private IEnumerable`1<IManipulator> _manipulators;
    public IInputElement ManipulationContainer { get; private set; }
    public ManipulationDelta BoundaryFeedback { get; private set; }
    internal Func`2<Point, Point> CompensateForBoundaryFeedback { get; internal set; }
    public IEnumerable`1<IManipulator> Manipulators { get; }
    internal ManipulationBoundaryFeedbackEventArgs(ManipulationDevice manipulationDevice, int timestamp, IInputElement manipulationContainer, ManipulationDelta boundaryFeedback);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
    [CompilerGeneratedAttribute]
public IInputElement get_ManipulationContainer();
    [CompilerGeneratedAttribute]
private void set_ManipulationContainer(IInputElement value);
    [CompilerGeneratedAttribute]
public ManipulationDelta get_BoundaryFeedback();
    [CompilerGeneratedAttribute]
private void set_BoundaryFeedback(ManipulationDelta value);
    [CompilerGeneratedAttribute]
internal Func`2<Point, Point> get_CompensateForBoundaryFeedback();
    [CompilerGeneratedAttribute]
internal void set_CompensateForBoundaryFeedback(Func`2<Point, Point> value);
    public IEnumerable`1<IManipulator> get_Manipulators();
}
public class System.Windows.Input.ManipulationCompletedEventArgs : InputEventArgs {
    [CompilerGeneratedAttribute]
private bool <IsInertial>k__BackingField;
    [CompilerGeneratedAttribute]
private IInputElement <ManipulationContainer>k__BackingField;
    [CompilerGeneratedAttribute]
private Point <ManipulationOrigin>k__BackingField;
    [CompilerGeneratedAttribute]
private ManipulationDelta <TotalManipulation>k__BackingField;
    [CompilerGeneratedAttribute]
private ManipulationVelocities <FinalVelocities>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequestedCancel>k__BackingField;
    private IEnumerable`1<IManipulator> _manipulators;
    public bool IsInertial { get; private set; }
    public IInputElement ManipulationContainer { get; private set; }
    public Point ManipulationOrigin { get; private set; }
    public ManipulationDelta TotalManipulation { get; private set; }
    public ManipulationVelocities FinalVelocities { get; private set; }
    internal bool RequestedCancel { get; private set; }
    public IEnumerable`1<IManipulator> Manipulators { get; }
    internal ManipulationCompletedEventArgs(ManipulationDevice manipulationDevice, int timestamp, IInputElement manipulationContainer, Point origin, ManipulationDelta total, ManipulationVelocities velocities, bool isInertial);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
    [CompilerGeneratedAttribute]
public bool get_IsInertial();
    [CompilerGeneratedAttribute]
private void set_IsInertial(bool value);
    [CompilerGeneratedAttribute]
public IInputElement get_ManipulationContainer();
    [CompilerGeneratedAttribute]
private void set_ManipulationContainer(IInputElement value);
    [CompilerGeneratedAttribute]
public Point get_ManipulationOrigin();
    [CompilerGeneratedAttribute]
private void set_ManipulationOrigin(Point value);
    [CompilerGeneratedAttribute]
public ManipulationDelta get_TotalManipulation();
    [CompilerGeneratedAttribute]
private void set_TotalManipulation(ManipulationDelta value);
    [CompilerGeneratedAttribute]
public ManipulationVelocities get_FinalVelocities();
    [CompilerGeneratedAttribute]
private void set_FinalVelocities(ManipulationVelocities value);
    public bool Cancel();
    [CompilerGeneratedAttribute]
internal bool get_RequestedCancel();
    [CompilerGeneratedAttribute]
private void set_RequestedCancel(bool value);
    public IEnumerable`1<IManipulator> get_Manipulators();
}
public class System.Windows.Input.ManipulationDelta : object {
    [CompilerGeneratedAttribute]
private Vector <Translation>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Rotation>k__BackingField;
    [CompilerGeneratedAttribute]
private Vector <Scale>k__BackingField;
    [CompilerGeneratedAttribute]
private Vector <Expansion>k__BackingField;
    public Vector Translation { get; private set; }
    public double Rotation { get; private set; }
    public Vector Scale { get; private set; }
    public Vector Expansion { get; private set; }
    public ManipulationDelta(Vector translation, double rotation, Vector scale, Vector expansion);
    [CompilerGeneratedAttribute]
public Vector get_Translation();
    [CompilerGeneratedAttribute]
private void set_Translation(Vector value);
    [CompilerGeneratedAttribute]
public double get_Rotation();
    [CompilerGeneratedAttribute]
private void set_Rotation(double value);
    [CompilerGeneratedAttribute]
public Vector get_Scale();
    [CompilerGeneratedAttribute]
private void set_Scale(Vector value);
    [CompilerGeneratedAttribute]
public Vector get_Expansion();
    [CompilerGeneratedAttribute]
private void set_Expansion(Vector value);
}
public class System.Windows.Input.ManipulationDeltaEventArgs : InputEventArgs {
    [CompilerGeneratedAttribute]
private bool <IsInertial>k__BackingField;
    [CompilerGeneratedAttribute]
private IInputElement <ManipulationContainer>k__BackingField;
    [CompilerGeneratedAttribute]
private Point <ManipulationOrigin>k__BackingField;
    [CompilerGeneratedAttribute]
private ManipulationDelta <CumulativeManipulation>k__BackingField;
    [CompilerGeneratedAttribute]
private ManipulationDelta <DeltaManipulation>k__BackingField;
    [CompilerGeneratedAttribute]
private ManipulationVelocities <Velocities>k__BackingField;
    [CompilerGeneratedAttribute]
private ManipulationDelta <UnusedManipulation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequestedComplete>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequestedInertia>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequestedCancel>k__BackingField;
    private IEnumerable`1<IManipulator> _manipulators;
    public bool IsInertial { get; private set; }
    public IInputElement ManipulationContainer { get; private set; }
    public Point ManipulationOrigin { get; private set; }
    public ManipulationDelta CumulativeManipulation { get; private set; }
    public ManipulationDelta DeltaManipulation { get; private set; }
    public ManipulationVelocities Velocities { get; private set; }
    internal ManipulationDelta UnusedManipulation { get; private set; }
    internal bool RequestedComplete { get; private set; }
    internal bool RequestedInertia { get; private set; }
    internal bool RequestedCancel { get; private set; }
    public IEnumerable`1<IManipulator> Manipulators { get; }
    internal ManipulationDeltaEventArgs(ManipulationDevice manipulationDevice, int timestamp, IInputElement manipulationContainer, Point origin, ManipulationDelta delta, ManipulationDelta cumulative, ManipulationVelocities velocities, bool isInertial);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
    [CompilerGeneratedAttribute]
public bool get_IsInertial();
    [CompilerGeneratedAttribute]
private void set_IsInertial(bool value);
    [CompilerGeneratedAttribute]
public IInputElement get_ManipulationContainer();
    [CompilerGeneratedAttribute]
private void set_ManipulationContainer(IInputElement value);
    [CompilerGeneratedAttribute]
public Point get_ManipulationOrigin();
    [CompilerGeneratedAttribute]
private void set_ManipulationOrigin(Point value);
    [CompilerGeneratedAttribute]
public ManipulationDelta get_CumulativeManipulation();
    [CompilerGeneratedAttribute]
private void set_CumulativeManipulation(ManipulationDelta value);
    [CompilerGeneratedAttribute]
public ManipulationDelta get_DeltaManipulation();
    [CompilerGeneratedAttribute]
private void set_DeltaManipulation(ManipulationDelta value);
    [CompilerGeneratedAttribute]
public ManipulationVelocities get_Velocities();
    [CompilerGeneratedAttribute]
private void set_Velocities(ManipulationVelocities value);
    public void ReportBoundaryFeedback(ManipulationDelta unusedManipulation);
    [CompilerGeneratedAttribute]
internal ManipulationDelta get_UnusedManipulation();
    [CompilerGeneratedAttribute]
private void set_UnusedManipulation(ManipulationDelta value);
    public void Complete();
    public void StartInertia();
    public bool Cancel();
    [CompilerGeneratedAttribute]
internal bool get_RequestedComplete();
    [CompilerGeneratedAttribute]
private void set_RequestedComplete(bool value);
    [CompilerGeneratedAttribute]
internal bool get_RequestedInertia();
    [CompilerGeneratedAttribute]
private void set_RequestedInertia(bool value);
    [CompilerGeneratedAttribute]
internal bool get_RequestedCancel();
    [CompilerGeneratedAttribute]
private void set_RequestedCancel(bool value);
    public IEnumerable`1<IManipulator> get_Manipulators();
}
internal class System.Windows.Input.ManipulationDevice : InputDevice {
    private InputManager _inputManager;
    private ManipulationLogic _manipulationLogic;
    private PresentationSource _activeSource;
    private UIElement _target;
    private List`1<IManipulator> _manipulators;
    private bool _ticking;
    private bool _wasTicking;
    private Func`2<Point, Point> _compensateForBoundaryFeedback;
    private bool _manipulationEnded;
    private IManipulator _removedManipulator;
    [ThreadStaticAttribute]
private static long LastUpdatedTimestamp;
    private static long ThrottleTimeout;
    [ThreadStaticAttribute]
private static Dictionary`2<UIElement, ManipulationDevice> _manipulationDevices;
    public IInputElement Target { get; }
    public PresentationSource ActiveSource { get; }
    internal ManipulationModes ManipulationMode { get; internal set; }
    internal ManipulationPivot ManipulationPivot { get; internal set; }
    internal IInputElement ManipulationContainer { get; internal set; }
    internal bool IsManipulationActive { get; }
    private ManipulationDevice(UIElement element);
    private void DetachManipulationDevice();
    public virtual IInputElement get_Target();
    public virtual PresentationSource get_ActiveSource();
    internal static ManipulationDevice AddManipulationDevice(UIElement element);
    internal static ManipulationDevice GetManipulationDevice(UIElement element);
    private void RemoveManipulationDevice();
    private void RemoveAllManipulators();
    internal void AddManipulator(IManipulator manipulator);
    internal void RemoveManipulator(IManipulator manipulator);
    internal ManipulationModes get_ManipulationMode();
    internal void set_ManipulationMode(ManipulationModes value);
    internal ManipulationPivot get_ManipulationPivot();
    internal void set_ManipulationPivot(ManipulationPivot value);
    internal IInputElement get_ManipulationContainer();
    internal void set_ManipulationContainer(IInputElement value);
    internal IEnumerable`1<IManipulator> GetManipulatorsReadOnly();
    internal void OnManipulatorUpdated(object sender, EventArgs e);
    internal Point GetTransformedManipulatorPosition(Point point);
    private static void ResumeAllTicking();
    private void StartTicking();
    private void StopTicking();
    private void SubscribeToLayoutUpdate();
    private void UnsubscribeFromLayoutUpdate();
    private void OnContainerLayoutUpdated(object sender, EventArgs e);
    private void OnRendering(object sender, EventArgs e);
    private void ReportFrame();
    internal bool get_IsManipulationActive();
    private void PostProcessInput(object sender, ProcessInputEventArgs e);
    private void OnManipulationCancel();
    private void OnManipulationComplete();
    internal void SetManipulationParameters(ManipulationParameters2D parameter);
    internal void CompleteManipulation(bool withInertia);
    internal void ProcessManipulationInput(InputEventArgs e);
}
public class System.Windows.Input.ManipulationInertiaStartingEventArgs : InputEventArgs {
    [CompilerGeneratedAttribute]
private IInputElement <ManipulationContainer>k__BackingField;
    [CompilerGeneratedAttribute]
private Point <ManipulationOrigin>k__BackingField;
    [CompilerGeneratedAttribute]
private ManipulationVelocities <InitialVelocities>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequestedCancel>k__BackingField;
    private List`1<InertiaParameters2D> _inertiaParameters;
    private InertiaTranslationBehavior _translationBehavior;
    private InertiaRotationBehavior _rotationBehavior;
    private InertiaExpansionBehavior _expansionBehavior;
    private Behaviors _behaviors;
    private bool _isInInertia;
    private IEnumerable`1<IManipulator> _manipulators;
    public IInputElement ManipulationContainer { get; private set; }
    public Point ManipulationOrigin { get; public set; }
    public ManipulationVelocities InitialVelocities { get; private set; }
    public InertiaTranslationBehavior TranslationBehavior { get; public set; }
    public InertiaRotationBehavior RotationBehavior { get; public set; }
    public InertiaExpansionBehavior ExpansionBehavior { get; public set; }
    internal bool RequestedCancel { get; private set; }
    public IEnumerable`1<IManipulator> Manipulators { get; }
    internal ManipulationInertiaStartingEventArgs(ManipulationDevice manipulationDevice, int timestamp, IInputElement manipulationContainer, Point origin, ManipulationVelocities initialVelocities, bool isInInertia);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
    [CompilerGeneratedAttribute]
public IInputElement get_ManipulationContainer();
    [CompilerGeneratedAttribute]
private void set_ManipulationContainer(IInputElement value);
    [CompilerGeneratedAttribute]
public Point get_ManipulationOrigin();
    [CompilerGeneratedAttribute]
public void set_ManipulationOrigin(Point value);
    [CompilerGeneratedAttribute]
public ManipulationVelocities get_InitialVelocities();
    [CompilerGeneratedAttribute]
private void set_InitialVelocities(ManipulationVelocities value);
    public InertiaTranslationBehavior get_TranslationBehavior();
    public void set_TranslationBehavior(InertiaTranslationBehavior value);
    public InertiaRotationBehavior get_RotationBehavior();
    public void set_RotationBehavior(InertiaRotationBehavior value);
    public InertiaExpansionBehavior get_ExpansionBehavior();
    public void set_ExpansionBehavior(InertiaExpansionBehavior value);
    public bool Cancel();
    [CompilerGeneratedAttribute]
internal bool get_RequestedCancel();
    [CompilerGeneratedAttribute]
private void set_RequestedCancel(bool value);
    public IEnumerable`1<IManipulator> get_Manipulators();
    [BrowsableAttribute("False")]
public void SetInertiaParameter(InertiaParameters2D parameter);
    internal bool CanBeginInertia();
    internal void ApplyParameters(InertiaProcessor2D processor);
    private bool IsBehaviorSet(Behaviors behavior);
    private void SetBehavior(Behaviors behavior);
}
internal class System.Windows.Input.ManipulationLogic : object {
    [CompilerGeneratedAttribute]
private bool <HasPendingBoundaryFeedback>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LastTimestamp>k__BackingField;
    private ManipulationDevice _manipulationDevice;
    private IInputElement _currentContainer;
    private ManipulationPivot _pivot;
    private ManipulationModes _mode;
    private ManipulationProcessor2D _manipulationProcessor;
    private InertiaProcessor2D _inertiaProcessor;
    private Dictionary`2<int, Manipulator2D> _currentManipulators;
    private Dictionary`2<int, Manipulator2D> _removedManipulators;
    private ManipulationDelta _lastManipulationBeforeInertia;
    private InputEventArgs _generatedEvent;
    private DispatcherTimer _inertiaTimer;
    private bool _manualComplete;
    private bool _manualCompleteWithInertia;
    private EventHandler`1<EventArgs> _containerLayoutUpdated;
    private static Point LayoutUpdateDetectionPivotPoint;
    private Point _containerPivotPoint;
    private Size _containerSize;
    private UIElement _root;
    private bool HasPendingBoundaryFeedback { get; private set; }
    private int LastTimestamp { get; private set; }
    internal IInputElement ManipulationContainer { get; internal set; }
    internal ManipulationModes ManipulationMode { get; internal set; }
    internal ManipulationPivot ManipulationPivot { get; internal set; }
    private IEnumerable`1<Manipulator2D> CurrentManipulators { get; }
    internal bool IsManipulationActive { get; }
    private bool IsInertiaActive { get; }
    internal ManipulationLogic(ManipulationDevice manipulationDevice);
    private static ManipulationLogic();
    private void OnManipulationStarted(object sender, Manipulation2DStartedEventArgs e);
    private void OnManipulationDelta(object sender, Manipulation2DDeltaEventArgs e);
    private void OnManipulationCompleted(object sender, Manipulation2DCompletedEventArgs e);
    private void OnInertiaCompleted(object sender, Manipulation2DCompletedEventArgs e);
    private void RaiseManipulationCompleted(ManipulationCompletedEventArgs e);
    internal void OnCompleted();
    private ManipulationCompletedEventArgs ConvertCompletedArguments(Manipulation2DCompletedEventArgs e);
    private static ManipulationDelta ConvertDelta(ManipulationDelta2D delta, ManipulationDelta add);
    private static ManipulationVelocities ConvertVelocities(ManipulationVelocities2D velocities);
    internal void Complete(bool withInertia);
    private ManipulationCompletedEventArgs GetManipulationCompletedArguments(ManipulationInertiaStartingEventArgs e);
    internal void BeginInertia(ManipulationInertiaStartingEventArgs e);
    internal static long GetCurrentTimestamp();
    private void OnInertiaTick(object sender, EventArgs e);
    private void ClearTimer();
    private void PushEvent(InputEventArgs e);
    internal void PushEventsToDevice();
    internal void RaiseBoundaryFeedback(ManipulationDelta unusedManipulation, bool requestedComplete);
    [CompilerGeneratedAttribute]
private bool get_HasPendingBoundaryFeedback();
    [CompilerGeneratedAttribute]
private void set_HasPendingBoundaryFeedback(bool value);
    [CompilerGeneratedAttribute]
private int get_LastTimestamp();
    [CompilerGeneratedAttribute]
private void set_LastTimestamp(int value);
    internal void ReportFrame(ICollection`1<IManipulator> manipulators);
    private ManipulationStartingEventArgs RaiseStarting();
    internal IInputElement get_ManipulationContainer();
    internal void set_ManipulationContainer(IInputElement value);
    internal ManipulationModes get_ManipulationMode();
    internal void set_ManipulationMode(ManipulationModes value);
    private static Manipulations2D ConvertMode(ManipulationModes mode);
    internal ManipulationPivot get_ManipulationPivot();
    internal void set_ManipulationPivot(ManipulationPivot value);
    private static ManipulationPivot2D ConvertPivot(ManipulationPivot pivot);
    internal void SetManipulationParameters(ManipulationParameters2D parameter);
    private void UpdateManipulators(ICollection`1<IManipulator> updatedManipulators);
    private void SetContainer(IInputElement newContainer);
    internal void add_ContainerLayoutUpdated(EventHandler`1<EventArgs> value);
    internal void remove_ContainerLayoutUpdated(EventHandler`1<EventArgs> value);
    private void SubscribeToLayoutUpdated();
    private void UnsubscribeFromLayoutUpdated();
    private void OnLayoutUpdated(object sender, EventArgs e);
    private bool UpdateCachedPositionAndSize();
    private IEnumerable`1<Manipulator2D> get_CurrentManipulators();
    internal bool get_IsManipulationActive();
    private bool get_IsInertiaActive();
}
[FlagsAttribute]
public enum System.Windows.Input.ManipulationModes : Enum {
    public int value__;
    public static ManipulationModes None;
    public static ManipulationModes TranslateX;
    public static ManipulationModes TranslateY;
    public static ManipulationModes Translate;
    public static ManipulationModes Rotate;
    public static ManipulationModes Scale;
    public static ManipulationModes All;
}
public class System.Windows.Input.ManipulationPivot : object {
    [CompilerGeneratedAttribute]
private Point <Center>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Radius>k__BackingField;
    public Point Center { get; public set; }
    public double Radius { get; public set; }
    public ManipulationPivot(Point center, double radius);
    [CompilerGeneratedAttribute]
public Point get_Center();
    [CompilerGeneratedAttribute]
public void set_Center(Point value);
    [CompilerGeneratedAttribute]
public double get_Radius();
    [CompilerGeneratedAttribute]
public void set_Radius(double value);
}
public class System.Windows.Input.ManipulationStartedEventArgs : InputEventArgs {
    [CompilerGeneratedAttribute]
private IInputElement <ManipulationContainer>k__BackingField;
    [CompilerGeneratedAttribute]
private Point <ManipulationOrigin>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequestedComplete>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequestedCancel>k__BackingField;
    private IEnumerable`1<IManipulator> _manipulators;
    public IInputElement ManipulationContainer { get; private set; }
    public Point ManipulationOrigin { get; private set; }
    internal bool RequestedComplete { get; private set; }
    internal bool RequestedCancel { get; private set; }
    public IEnumerable`1<IManipulator> Manipulators { get; }
    internal ManipulationStartedEventArgs(ManipulationDevice manipulationDevice, int timestamp, IInputElement manipulationContainer, Point origin);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
    [CompilerGeneratedAttribute]
public IInputElement get_ManipulationContainer();
    [CompilerGeneratedAttribute]
private void set_ManipulationContainer(IInputElement value);
    [CompilerGeneratedAttribute]
public Point get_ManipulationOrigin();
    [CompilerGeneratedAttribute]
private void set_ManipulationOrigin(Point value);
    public void Complete();
    public bool Cancel();
    [CompilerGeneratedAttribute]
internal bool get_RequestedComplete();
    [CompilerGeneratedAttribute]
private void set_RequestedComplete(bool value);
    [CompilerGeneratedAttribute]
internal bool get_RequestedCancel();
    [CompilerGeneratedAttribute]
private void set_RequestedCancel(bool value);
    public IEnumerable`1<IManipulator> get_Manipulators();
}
public class System.Windows.Input.ManipulationStartingEventArgs : InputEventArgs {
    [CompilerGeneratedAttribute]
private IInputElement <ManipulationContainer>k__BackingField;
    [CompilerGeneratedAttribute]
private ManipulationPivot <Pivot>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSingleTouchEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequestedCancel>k__BackingField;
    private List`1<ManipulationParameters2D> _parameters;
    private ManipulationModes _mode;
    private IEnumerable`1<IManipulator> _manipulators;
    public ManipulationModes Mode { get; public set; }
    public IInputElement ManipulationContainer { get; public set; }
    public ManipulationPivot Pivot { get; public set; }
    public bool IsSingleTouchEnabled { get; public set; }
    internal bool RequestedCancel { get; private set; }
    public IEnumerable`1<IManipulator> Manipulators { get; }
    internal IList`1<ManipulationParameters2D> Parameters { get; }
    internal ManipulationStartingEventArgs(ManipulationDevice manipulationDevice, int timestamp);
    public ManipulationModes get_Mode();
    public void set_Mode(ManipulationModes value);
    [CompilerGeneratedAttribute]
public IInputElement get_ManipulationContainer();
    [CompilerGeneratedAttribute]
public void set_ManipulationContainer(IInputElement value);
    [CompilerGeneratedAttribute]
public ManipulationPivot get_Pivot();
    [CompilerGeneratedAttribute]
public void set_Pivot(ManipulationPivot value);
    [CompilerGeneratedAttribute]
public bool get_IsSingleTouchEnabled();
    [CompilerGeneratedAttribute]
public void set_IsSingleTouchEnabled(bool value);
    public bool Cancel();
    [CompilerGeneratedAttribute]
internal bool get_RequestedCancel();
    [CompilerGeneratedAttribute]
private void set_RequestedCancel(bool value);
    public IEnumerable`1<IManipulator> get_Manipulators();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
    [BrowsableAttribute("False")]
public void SetManipulationParameter(ManipulationParameters2D parameter);
    internal IList`1<ManipulationParameters2D> get_Parameters();
}
public class System.Windows.Input.ManipulationVelocities : object {
    [CompilerGeneratedAttribute]
private Vector <LinearVelocity>k__BackingField;
    [CompilerGeneratedAttribute]
private double <AngularVelocity>k__BackingField;
    [CompilerGeneratedAttribute]
private Vector <ExpansionVelocity>k__BackingField;
    public Vector LinearVelocity { get; private set; }
    public double AngularVelocity { get; private set; }
    public Vector ExpansionVelocity { get; private set; }
    public ManipulationVelocities(Vector linearVelocity, double angularVelocity, Vector expansionVelocity);
    [CompilerGeneratedAttribute]
public Vector get_LinearVelocity();
    [CompilerGeneratedAttribute]
private void set_LinearVelocity(Vector value);
    [CompilerGeneratedAttribute]
public double get_AngularVelocity();
    [CompilerGeneratedAttribute]
private void set_AngularVelocity(double value);
    [CompilerGeneratedAttribute]
public Vector get_ExpansionVelocity();
    [CompilerGeneratedAttribute]
private void set_ExpansionVelocity(Vector value);
}
public static class System.Windows.Input.MediaCommands : object {
    private static RoutedUICommand[] _internalCommands;
    public static RoutedUICommand Play { get; }
    public static RoutedUICommand Pause { get; }
    public static RoutedUICommand Stop { get; }
    public static RoutedUICommand Record { get; }
    public static RoutedUICommand NextTrack { get; }
    public static RoutedUICommand PreviousTrack { get; }
    public static RoutedUICommand FastForward { get; }
    public static RoutedUICommand Rewind { get; }
    public static RoutedUICommand ChannelUp { get; }
    public static RoutedUICommand ChannelDown { get; }
    public static RoutedUICommand TogglePlayPause { get; }
    public static RoutedUICommand Select { get; }
    public static RoutedUICommand IncreaseVolume { get; }
    public static RoutedUICommand DecreaseVolume { get; }
    public static RoutedUICommand MuteVolume { get; }
    public static RoutedUICommand IncreaseTreble { get; }
    public static RoutedUICommand DecreaseTreble { get; }
    public static RoutedUICommand IncreaseBass { get; }
    public static RoutedUICommand DecreaseBass { get; }
    public static RoutedUICommand BoostBass { get; }
    public static RoutedUICommand IncreaseMicrophoneVolume { get; }
    public static RoutedUICommand DecreaseMicrophoneVolume { get; }
    public static RoutedUICommand MuteMicrophoneVolume { get; }
    public static RoutedUICommand ToggleMicrophoneOnOff { get; }
    private static MediaCommands();
    public static RoutedUICommand get_Play();
    public static RoutedUICommand get_Pause();
    public static RoutedUICommand get_Stop();
    public static RoutedUICommand get_Record();
    public static RoutedUICommand get_NextTrack();
    public static RoutedUICommand get_PreviousTrack();
    public static RoutedUICommand get_FastForward();
    public static RoutedUICommand get_Rewind();
    public static RoutedUICommand get_ChannelUp();
    public static RoutedUICommand get_ChannelDown();
    public static RoutedUICommand get_TogglePlayPause();
    public static RoutedUICommand get_Select();
    public static RoutedUICommand get_IncreaseVolume();
    public static RoutedUICommand get_DecreaseVolume();
    public static RoutedUICommand get_MuteVolume();
    public static RoutedUICommand get_IncreaseTreble();
    public static RoutedUICommand get_DecreaseTreble();
    public static RoutedUICommand get_IncreaseBass();
    public static RoutedUICommand get_DecreaseBass();
    public static RoutedUICommand get_BoostBass();
    public static RoutedUICommand get_IncreaseMicrophoneVolume();
    public static RoutedUICommand get_DecreaseMicrophoneVolume();
    public static RoutedUICommand get_MuteMicrophoneVolume();
    public static RoutedUICommand get_ToggleMicrophoneOnOff();
    private static string GetPropertyName(CommandId commandId);
    internal static string GetUIText(byte commandId);
    internal static InputGestureCollection LoadDefaultGestureFromResource(byte commandId);
    private static RoutedUICommand _EnsureCommand(CommandId idCommand);
}
public static class System.Windows.Input.Mouse : object {
    public static RoutedEvent PreviewMouseMoveEvent;
    public static RoutedEvent MouseMoveEvent;
    public static RoutedEvent PreviewMouseDownOutsideCapturedElementEvent;
    public static RoutedEvent PreviewMouseUpOutsideCapturedElementEvent;
    public static RoutedEvent PreviewMouseDownEvent;
    public static RoutedEvent MouseDownEvent;
    public static RoutedEvent PreviewMouseUpEvent;
    public static RoutedEvent MouseUpEvent;
    public static RoutedEvent PreviewMouseWheelEvent;
    public static RoutedEvent MouseWheelEvent;
    public static RoutedEvent MouseEnterEvent;
    public static RoutedEvent MouseLeaveEvent;
    public static RoutedEvent GotMouseCaptureEvent;
    public static RoutedEvent LostMouseCaptureEvent;
    public static RoutedEvent QueryCursorEvent;
    public static int MouseWheelDeltaForOneLine;
    public static IInputElement DirectlyOver { get; }
    public static IInputElement Captured { get; }
    internal static CaptureMode CapturedMode { get; }
    public static Cursor OverrideCursor { get; public set; }
    public static MouseButtonState LeftButton { get; }
    public static MouseButtonState RightButton { get; }
    public static MouseButtonState MiddleButton { get; }
    public static MouseButtonState XButton1 { get; }
    public static MouseButtonState XButton2 { get; }
    public static MouseDevice PrimaryDevice { get; }
    private static Mouse();
    public static void AddPreviewMouseMoveHandler(DependencyObject element, MouseEventHandler handler);
    public static void RemovePreviewMouseMoveHandler(DependencyObject element, MouseEventHandler handler);
    public static void AddMouseMoveHandler(DependencyObject element, MouseEventHandler handler);
    public static void RemoveMouseMoveHandler(DependencyObject element, MouseEventHandler handler);
    public static void AddPreviewMouseDownOutsideCapturedElementHandler(DependencyObject element, MouseButtonEventHandler handler);
    public static void RemovePreviewMouseDownOutsideCapturedElementHandler(DependencyObject element, MouseButtonEventHandler handler);
    public static void AddPreviewMouseUpOutsideCapturedElementHandler(DependencyObject element, MouseButtonEventHandler handler);
    public static void RemovePreviewMouseUpOutsideCapturedElementHandler(DependencyObject element, MouseButtonEventHandler handler);
    public static void AddPreviewMouseDownHandler(DependencyObject element, MouseButtonEventHandler handler);
    public static void RemovePreviewMouseDownHandler(DependencyObject element, MouseButtonEventHandler handler);
    public static void AddMouseDownHandler(DependencyObject element, MouseButtonEventHandler handler);
    public static void RemoveMouseDownHandler(DependencyObject element, MouseButtonEventHandler handler);
    public static void AddPreviewMouseUpHandler(DependencyObject element, MouseButtonEventHandler handler);
    public static void RemovePreviewMouseUpHandler(DependencyObject element, MouseButtonEventHandler handler);
    public static void AddMouseUpHandler(DependencyObject element, MouseButtonEventHandler handler);
    public static void RemoveMouseUpHandler(DependencyObject element, MouseButtonEventHandler handler);
    public static void AddPreviewMouseWheelHandler(DependencyObject element, MouseWheelEventHandler handler);
    public static void RemovePreviewMouseWheelHandler(DependencyObject element, MouseWheelEventHandler handler);
    public static void AddMouseWheelHandler(DependencyObject element, MouseWheelEventHandler handler);
    public static void RemoveMouseWheelHandler(DependencyObject element, MouseWheelEventHandler handler);
    public static void AddMouseEnterHandler(DependencyObject element, MouseEventHandler handler);
    public static void RemoveMouseEnterHandler(DependencyObject element, MouseEventHandler handler);
    public static void AddMouseLeaveHandler(DependencyObject element, MouseEventHandler handler);
    public static void RemoveMouseLeaveHandler(DependencyObject element, MouseEventHandler handler);
    public static void AddGotMouseCaptureHandler(DependencyObject element, MouseEventHandler handler);
    public static void RemoveGotMouseCaptureHandler(DependencyObject element, MouseEventHandler handler);
    public static void AddLostMouseCaptureHandler(DependencyObject element, MouseEventHandler handler);
    public static void RemoveLostMouseCaptureHandler(DependencyObject element, MouseEventHandler handler);
    public static void AddQueryCursorHandler(DependencyObject element, QueryCursorEventHandler handler);
    public static void RemoveQueryCursorHandler(DependencyObject element, QueryCursorEventHandler handler);
    public static IInputElement get_DirectlyOver();
    public static IInputElement get_Captured();
    internal static CaptureMode get_CapturedMode();
    public static bool Capture(IInputElement element);
    public static bool Capture(IInputElement element, CaptureMode captureMode);
    public static int GetIntermediatePoints(IInputElement relativeTo, Point[] points);
    public static Cursor get_OverrideCursor();
    public static void set_OverrideCursor(Cursor value);
    public static bool SetCursor(Cursor cursor);
    public static MouseButtonState get_LeftButton();
    public static MouseButtonState get_RightButton();
    public static MouseButtonState get_MiddleButton();
    public static MouseButtonState get_XButton1();
    public static MouseButtonState get_XButton2();
    public static Point GetPosition(IInputElement relativeTo);
    public static void Synchronize();
    public static void UpdateCursor();
    public static MouseDevice get_PrimaryDevice();
}
[ValueSerializerAttribute("System.Windows.Input.MouseActionValueSerializer")]
[TypeConverterAttribute("System.Windows.Input.MouseActionConverter")]
public enum System.Windows.Input.MouseAction : Enum {
    public byte value__;
    public static MouseAction None;
    public static MouseAction LeftClick;
    public static MouseAction RightClick;
    public static MouseAction MiddleClick;
    public static MouseAction WheelClick;
    public static MouseAction LeftDoubleClick;
    public static MouseAction RightDoubleClick;
    public static MouseAction MiddleDoubleClick;
}
public class System.Windows.Input.MouseActionConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object source);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    internal static bool IsDefinedMouseAction(MouseAction mouseAction);
}
public class System.Windows.Input.MouseActionValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Input.MouseBinding : InputBinding {
    public static DependencyProperty MouseActionProperty;
    private bool _settingGesture;
    [ValueSerializerAttribute("System.Windows.Input.MouseGestureValueSerializer")]
[TypeConverterAttribute("System.Windows.Input.MouseGestureConverter")]
public InputGesture Gesture { get; public set; }
    public MouseAction MouseAction { get; public set; }
    internal MouseBinding(ICommand command, MouseAction mouseAction);
    public MouseBinding(ICommand command, MouseGesture gesture);
    private static MouseBinding();
    public virtual InputGesture get_Gesture();
    public virtual void set_Gesture(InputGesture value);
    public MouseAction get_MouseAction();
    public void set_MouseAction(MouseAction value);
    private static void OnMouseActionPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    private void SynchronizePropertiesFromGesture(MouseGesture mouseGesture);
    private void SynchronizeGestureFromProperties(MouseAction mouseAction);
    private void OnMouseGesturePropertyChanged(object sender, PropertyChangedEventArgs e);
    private void CloneGesture();
}
public enum System.Windows.Input.MouseButton : Enum {
    public int value__;
    public static MouseButton Left;
    public static MouseButton Middle;
    public static MouseButton Right;
    public static MouseButton XButton1;
    public static MouseButton XButton2;
}
public class System.Windows.Input.MouseButtonEventArgs : MouseEventArgs {
    private MouseButton _button;
    private int _count;
    public MouseButton ChangedButton { get; }
    public MouseButtonState ButtonState { get; }
    public int ClickCount { get; internal set; }
    public MouseButtonEventArgs(MouseDevice mouse, int timestamp, MouseButton button);
    public MouseButtonEventArgs(MouseDevice mouse, int timestamp, MouseButton button, StylusDevice stylusDevice);
    public MouseButton get_ChangedButton();
    public MouseButtonState get_ButtonState();
    public int get_ClickCount();
    internal void set_ClickCount(int value);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.MouseButtonEventHandler : MulticastDelegate {
    public MouseButtonEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, MouseButtonEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, MouseButtonEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Windows.Input.MouseButtonState : Enum {
    public int value__;
    public static MouseButtonState Released;
    public static MouseButtonState Pressed;
}
internal class System.Windows.Input.MouseButtonUtilities : object {
    [FriendAccessAllowedAttribute]
internal static void Validate(MouseButton button);
}
public abstract class System.Windows.Input.MouseDevice : InputDevice {
    private SecurityCriticalDataClass`1<PresentationSource> _inputSource;
    private SecurityCriticalData`1<InputManager> _inputManager;
    private IInputElement _mouseOver;
    private DeferredElementTreeState _mouseOverTreeState;
    private bool _isPhysicallyOver;
    private WeakReference _rawMouseOver;
    private IInputElement _mouseCapture;
    private DeferredElementTreeState _mouseCaptureWithinTreeState;
    private SecurityCriticalDataClass`1<IMouseInputProvider> _providerCapture;
    private CaptureMode _captureMode;
    private bool _isCaptureMouseInProgress;
    private DependencyPropertyChangedEventHandler _overIsEnabledChangedEventHandler;
    private DependencyPropertyChangedEventHandler _overIsVisibleChangedEventHandler;
    private DependencyPropertyChangedEventHandler _overIsHitTestVisibleChangedEventHandler;
    private DispatcherOperationCallback _reevaluateMouseOverDelegate;
    private DispatcherOperation _reevaluateMouseOverOperation;
    private DependencyPropertyChangedEventHandler _captureIsEnabledChangedEventHandler;
    private DependencyPropertyChangedEventHandler _captureIsVisibleChangedEventHandler;
    private DependencyPropertyChangedEventHandler _captureIsHitTestVisibleChangedEventHandler;
    private DispatcherOperationCallback _reevaluateCaptureDelegate;
    private DispatcherOperation _reevaluateCaptureOperation;
    private Point _positionRelativeToOver;
    private Point _lastPosition;
    private bool _forceUpdateLastPosition;
    private object _tagNonRedundantActions;
    private object _tagStylusDevice;
    private object _tagRootPoint;
    private Point _lastClick;
    private MouseButton _lastButton;
    private int _clickCount;
    private int _lastClickTime;
    private int _doubleClickDeltaTime;
    private int _doubleClickDeltaX;
    private int _doubleClickDeltaY;
    private Cursor _overrideCursor;
    private StylusDevice _stylusDevice;
    public IInputElement Target { get; }
    public PresentationSource ActiveSource { get; }
    internal PresentationSource CriticalActiveSource { get; }
    public IInputElement DirectlyOver { get; }
    [FriendAccessAllowedAttribute]
internal IInputElement RawDirectlyOver { get; }
    public IInputElement Captured { get; }
    internal CaptureMode CapturedMode { get; }
    public Cursor OverrideCursor { get; public set; }
    public MouseButtonState LeftButton { get; }
    public MouseButtonState RightButton { get; }
    public MouseButtonState MiddleButton { get; }
    public MouseButtonState XButton1 { get; }
    public MouseButtonState XButton2 { get; }
    internal Point PositionRelativeToOver { get; }
    internal Point NonRelativePosition { get; }
    internal bool IsActive { get; }
    internal StylusDevice StylusDevice { get; }
    private DeferredElementTreeState MouseOverTreeState { get; }
    private DeferredElementTreeState MouseCaptureWithinTreeState { get; }
    internal MouseDevice(InputManager inputManager);
    protected MouseButtonState GetButtonState(MouseButton mouseButton);
    protected Point GetScreenPosition();
    internal abstract virtual MouseButtonState GetButtonStateFromSystem(MouseButton mouseButton);
    internal Point GetScreenPositionFromSystem();
    protected Point GetClientPosition();
    protected Point GetClientPosition(PresentationSource presentationSource);
    public virtual IInputElement get_Target();
    public virtual PresentationSource get_ActiveSource();
    internal PresentationSource get_CriticalActiveSource();
    public IInputElement get_DirectlyOver();
    internal IInputElement get_RawDirectlyOver();
    public IInputElement get_Captured();
    internal CaptureMode get_CapturedMode();
    public bool Capture(IInputElement element);
    public bool Capture(IInputElement element, CaptureMode captureMode);
    private IMouseInputProvider FindMouseInputProviderForCursor();
    public Cursor get_OverrideCursor();
    public void set_OverrideCursor(Cursor value);
    public bool SetCursor(Cursor cursor);
    public MouseButtonState get_LeftButton();
    public MouseButtonState get_RightButton();
    public MouseButtonState get_MiddleButton();
    public MouseButtonState get_XButton1();
    public MouseButtonState get_XButton2();
    public Point GetPosition(IInputElement relativeTo);
    internal void ReevaluateMouseOver(DependencyObject element, DependencyObject oldParent, bool isCoreParent);
    private object ReevaluateMouseOverAsync(object arg);
    internal void ReevaluateCapture(DependencyObject element, DependencyObject oldParent, bool isCoreParent);
    private object ReevaluateCaptureAsync(object arg);
    private bool ValidateUIElementForCapture(UIElement element);
    private bool ValidateUIElement3DForCapture(UIElement3D element);
    private bool ValidateContentElementForCapture(ContentElement element);
    private bool ValidateVisualForCapture(DependencyObject visual);
    private void OnOverIsEnabledChanged(object sender, DependencyPropertyChangedEventArgs e);
    private void OnOverIsVisibleChanged(object sender, DependencyPropertyChangedEventArgs e);
    private void OnOverIsHitTestVisibleChanged(object sender, DependencyPropertyChangedEventArgs e);
    private void OnCaptureIsEnabledChanged(object sender, DependencyPropertyChangedEventArgs e);
    private void OnCaptureIsVisibleChanged(object sender, DependencyPropertyChangedEventArgs e);
    private void OnCaptureIsHitTestVisibleChanged(object sender, DependencyPropertyChangedEventArgs e);
    private void OnHitTestInvalidatedAsync(object sender, EventArgs e);
    public void Synchronize();
    public void UpdateCursor();
    private bool UpdateCursorPrivate();
    private void ChangeMouseOver(IInputElement mouseOver, int timestamp);
    private void ChangeMouseCapture(IInputElement mouseCapture, IMouseInputProvider providerCapture, CaptureMode captureMode, int timestamp);
    private void PreProcessInput(object sender, PreProcessInputEventArgs e);
    internal static void PushActivateInputReport(PreProcessInputEventArgs e, InputReportEventArgs inputReportEventArgs, RawMouseInputReport rawMouseInputReport, bool clearExtraInformation);
    private void PreNotifyInput(object sender, NotifyInputEventArgs e);
    private bool ArePointsClose(Point A, Point B);
    private void PostProcessInput(object sender, ProcessInputEventArgs e);
    private RawMouseActions GetNonRedundantActions(NotifyInputEventArgs e);
    internal static IInputElement GlobalHitTest(bool clientUnits, Point pt, PresentationSource inputSource);
    internal static IInputElement GlobalHitTest(Point ptClient, PresentationSource inputSource);
    private static void GlobalHitTest(bool clientUnits, Point pt, PresentationSource inputSource, IInputElement& enabledHit, IInputElement& originalHit);
    internal static IInputElement LocalHitTest(bool clientUnits, Point pt, PresentationSource inputSource);
    internal static IInputElement LocalHitTest(Point ptClient, PresentationSource inputSource);
    private static void LocalHitTest(bool clientUnits, Point pt, PresentationSource inputSource, IInputElement& enabledHit, IInputElement& originalHit);
    internal bool IsSameSpot(Point newPosition, StylusDevice stylusDevice);
    internal int CalculateClickCount(MouseButton button, int timeStamp, StylusDevice stylusDevice, Point downPt);
    internal Point get_PositionRelativeToOver();
    internal Point get_NonRelativePosition();
    internal bool get_IsActive();
    private StylusDevice GetStylusDevice(StagingAreaInputItem stagingItem);
    internal StylusDevice get_StylusDevice();
    private DeferredElementTreeState get_MouseOverTreeState();
    private DeferredElementTreeState get_MouseCaptureWithinTreeState();
}
public class System.Windows.Input.MouseEventArgs : InputEventArgs {
    private StylusDevice _stylusDevice;
    public MouseDevice MouseDevice { get; }
    public StylusDevice StylusDevice { get; }
    public MouseButtonState LeftButton { get; }
    public MouseButtonState RightButton { get; }
    public MouseButtonState MiddleButton { get; }
    public MouseButtonState XButton1 { get; }
    public MouseButtonState XButton2 { get; }
    public MouseEventArgs(MouseDevice mouse, int timestamp);
    public MouseEventArgs(MouseDevice mouse, int timestamp, StylusDevice stylusDevice);
    public MouseDevice get_MouseDevice();
    public StylusDevice get_StylusDevice();
    public Point GetPosition(IInputElement relativeTo);
    public MouseButtonState get_LeftButton();
    public MouseButtonState get_RightButton();
    public MouseButtonState get_MiddleButton();
    public MouseButtonState get_XButton1();
    public MouseButtonState get_XButton2();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.MouseEventHandler : MulticastDelegate {
    public MouseEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, MouseEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, MouseEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[TypeConverterAttribute("System.Windows.Input.MouseGestureConverter")]
[ValueSerializerAttribute("System.Windows.Input.MouseGestureValueSerializer")]
public class System.Windows.Input.MouseGesture : InputGesture {
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    private MouseAction _mouseAction;
    private ModifierKeys _modifiers;
    public MouseAction MouseAction { get; public set; }
    public ModifierKeys Modifiers { get; public set; }
    public MouseGesture(MouseAction mouseAction);
    public MouseGesture(MouseAction mouseAction, ModifierKeys modifiers);
    public MouseAction get_MouseAction();
    public void set_MouseAction(MouseAction value);
    public ModifierKeys get_Modifiers();
    public void set_Modifiers(ModifierKeys value);
    public virtual bool Matches(object targetElement, InputEventArgs inputEventArgs);
    internal static bool IsDefinedMouseAction(MouseAction mouseAction);
    [CompilerGeneratedAttribute]
internal void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_PropertyChanged(PropertyChangedEventHandler value);
    internal virtual void OnPropertyChanged(string propertyName);
    internal static MouseAction GetMouseAction(InputEventArgs inputArgs);
}
public class System.Windows.Input.MouseGestureConverter : TypeConverter {
    private static char MODIFIERS_DELIMITER;
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object source);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Input.MouseGestureValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Input.MouseWheelEventArgs : MouseEventArgs {
    private static int _delta;
    public int Delta { get; }
    public MouseWheelEventArgs(MouseDevice mouse, int timestamp, int delta);
    public int get_Delta();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.MouseWheelEventHandler : MulticastDelegate {
    public MouseWheelEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, MouseWheelEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, MouseWheelEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Windows.Input.MultiTouchSystemGestureLogic : object {
    private State _currentState;
    private Nullable`1<int> _firstStylusDeviceId;
    private Nullable`1<int> _secondStylusDeviceId;
    private int _firstDownTime;
    private int _firstUpTime;
    private static int TwoFingerTapTime;
    private static int RolloverTime;
    internal Nullable`1<SystemGesture> GenerateStaticGesture(RawStylusInputReport stylusInputReport);
    private void OnTouchDown(RawStylusInputReport stylusInputReport);
    private Nullable`1<SystemGesture> OnTouchUp(RawStylusInputReport stylusInputReport);
    private void OnSystemGesture(RawStylusSystemGestureInputReport stylusInputReport);
    private void Reset();
    private bool IsTrackedStylusId(int id);
    private bool IsTwoFingerTap();
}
public static class System.Windows.Input.NavigationCommands : object {
    private static RoutedUICommand[] _internalCommands;
    private static string BrowseBackKey;
    private static string BrowseForwardKey;
    private static string BrowseHomeKey;
    private static string BrowseStopKey;
    private static string FavoritesKey;
    private static string RefreshKey;
    private static string SearchKey;
    public static RoutedUICommand BrowseBack { get; }
    public static RoutedUICommand BrowseForward { get; }
    public static RoutedUICommand BrowseHome { get; }
    public static RoutedUICommand BrowseStop { get; }
    public static RoutedUICommand Refresh { get; }
    public static RoutedUICommand Favorites { get; }
    public static RoutedUICommand Search { get; }
    public static RoutedUICommand IncreaseZoom { get; }
    public static RoutedUICommand DecreaseZoom { get; }
    public static RoutedUICommand Zoom { get; }
    public static RoutedUICommand NextPage { get; }
    public static RoutedUICommand PreviousPage { get; }
    public static RoutedUICommand FirstPage { get; }
    public static RoutedUICommand LastPage { get; }
    public static RoutedUICommand GoToPage { get; }
    public static RoutedUICommand NavigateJournal { get; }
    private static NavigationCommands();
    public static RoutedUICommand get_BrowseBack();
    public static RoutedUICommand get_BrowseForward();
    public static RoutedUICommand get_BrowseHome();
    public static RoutedUICommand get_BrowseStop();
    public static RoutedUICommand get_Refresh();
    public static RoutedUICommand get_Favorites();
    public static RoutedUICommand get_Search();
    public static RoutedUICommand get_IncreaseZoom();
    public static RoutedUICommand get_DecreaseZoom();
    public static RoutedUICommand get_Zoom();
    public static RoutedUICommand get_NextPage();
    public static RoutedUICommand get_PreviousPage();
    public static RoutedUICommand get_FirstPage();
    public static RoutedUICommand get_LastPage();
    public static RoutedUICommand get_GoToPage();
    public static RoutedUICommand get_NavigateJournal();
    private static string GetPropertyName(CommandId commandId);
    internal static string GetUIText(byte commandId);
    internal static InputGestureCollection LoadDefaultGestureFromResource(byte commandId);
    private static RoutedUICommand _EnsureCommand(CommandId idCommand);
}
public class System.Windows.Input.NotifyInputEventArgs : EventArgs {
    private StagingAreaInputItem _input;
    private InputManager _inputManager;
    public StagingAreaInputItem StagingItem { get; }
    public InputManager InputManager { get; }
    internal InputManager UnsecureInputManager { get; }
    internal virtual void Reset(StagingAreaInputItem input, InputManager inputManager);
    public StagingAreaInputItem get_StagingItem();
    public InputManager get_InputManager();
    internal InputManager get_UnsecureInputManager();
}
public class System.Windows.Input.NotifyInputEventHandler : MulticastDelegate {
    public NotifyInputEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, NotifyInputEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, NotifyInputEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Windows.Input.PenContext : object {
    [CompilerGeneratedAttribute]
private bool <UpdateScreenMeasurementsPending>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <WispContextKey>k__BackingField;
    internal SecurityCriticalDataClass`1<IPimcContext3> _pimcContext;
    private SecurityCriticalData`1<IntPtr> _hwnd;
    private SecurityCriticalData`1<IntPtr> _commHandle;
    private PenContexts _contexts;
    private PenThread _penThreadPenContext;
    private int _id;
    private int _tabletDeviceId;
    private StylusPointPropertyInfo _infoX;
    private StylusPointPropertyInfo _infoY;
    private bool _supportInRange;
    private List`1<int> _stylusDevicesInRange;
    private bool _isIntegrated;
    private StylusPointDescription _stylusPointDescription;
    private int _statusPropertyIndex;
    private int _lastInRangeTime;
    private int _queuedInRangeCount;
    internal PenContexts Contexts { get; }
    internal IntPtr CommHandle { get; }
    internal int Id { get; }
    internal int TabletDeviceId { get; }
    internal StylusPointDescription StylusPointDescription { get; }
    internal bool SupportInRange { get; }
    internal bool UpdateScreenMeasurementsPending { get; internal set; }
    internal int LastInRangeTime { get; }
    internal int QueuedInRangeCount { get; }
    internal UInt32 WispContextKey { get; private set; }
    internal PenContext(IPimcContext3 pimcContext, IntPtr hwnd, PenContexts contexts, bool supportInRange, bool isIntegrated, int id, IntPtr commHandle, int tabletDeviceId, UInt32 wispContextKey);
    protected virtual override void Finalize();
    internal PenContexts get_Contexts();
    internal IntPtr get_CommHandle();
    internal int get_Id();
    internal int get_TabletDeviceId();
    internal StylusPointDescription get_StylusPointDescription();
    private void InitStylusPointDescription();
    internal void Enable();
    internal void Disable(bool shutdownWorkerThread);
    private bool TryRemove(bool shutdownWorkerThread);
    internal bool get_SupportInRange();
    internal bool IsInRange(int stylusPointerId);
    internal void FirePenDown(int stylusPointerId, Int32[] data, int timestamp);
    internal void FirePenUp(int stylusPointerId, Int32[] data, int timestamp);
    internal void FirePackets(int stylusPointerId, Int32[] data, int timestamp);
    internal void FirePenInRange(int stylusPointerId, Int32[] data, int timestamp);
    internal void FirePenOutOfRange(int stylusPointerId, int timestamp);
    internal void FireSystemGesture(int stylusPointerId, int timestamp);
    internal void CheckForRectMappingChanged(Int32[] data, int numPackets);
    [CompilerGeneratedAttribute]
internal bool get_UpdateScreenMeasurementsPending();
    [CompilerGeneratedAttribute]
internal void set_UpdateScreenMeasurementsPending(bool value);
    private int EnsureTimestampUnique(int timestamp);
    internal int get_LastInRangeTime();
    internal int get_QueuedInRangeCount();
    internal void DecrementQueuedInRangeCount();
    [CompilerGeneratedAttribute]
internal UInt32 get_WispContextKey();
    [CompilerGeneratedAttribute]
private void set_WispContextKey(UInt32 value);
}
internal class System.Windows.Input.PenContextInfo : ValueType {
    public SecurityCriticalDataClass`1<IPimcContext3> PimcContext;
    public SecurityCriticalDataClass`1<IntPtr> CommHandle;
    public int ContextId;
    public UInt32 WispContextKey;
}
internal class System.Windows.Input.PenContexts : object {
    internal SecurityCriticalData`1<HwndSource> _inputSource;
    private WispLogic _stylusLogic;
    private object __rtiLock;
    private List`1<StylusPlugInCollection> _plugInCollectionList;
    private PenContext[] _contexts;
    private bool _isWindowDisabled;
    private Point _destroyedLocation;
    internal bool IsWindowDisabled { get; internal set; }
    internal Point DestroyedLocation { get; internal set; }
    internal object SyncRoot { get; }
    internal PenContexts(WispLogic stylusLogic, PresentationSource inputSource);
    internal void Enable();
    internal void Disable(bool shutdownWorkerThread);
    internal bool get_IsWindowDisabled();
    internal void set_IsWindowDisabled(bool value);
    internal Point get_DestroyedLocation();
    internal void set_DestroyedLocation(Point value);
    internal void OnPenDown(PenContext penContext, int tabletDeviceId, int stylusPointerId, Int32[] data, int timestamp);
    internal void OnPenUp(PenContext penContext, int tabletDeviceId, int stylusPointerId, Int32[] data, int timestamp);
    internal void OnPackets(PenContext penContext, int tabletDeviceId, int stylusPointerId, Int32[] data, int timestamp);
    internal void OnInAirPackets(PenContext penContext, int tabletDeviceId, int stylusPointerId, Int32[] data, int timestamp);
    internal void OnPenInRange(PenContext penContext, int tabletDeviceId, int stylusPointerId, Int32[] data, int timestamp);
    internal void OnPenOutOfRange(PenContext penContext, int tabletDeviceId, int stylusPointerId, int timestamp);
    internal void OnSystemEvent(PenContext penContext, int tabletDeviceId, int stylusPointerId, int timestamp, SystemGesture id, int gestureX, int gestureY, int buttonState);
    private void ProcessInput(RawStylusActions actions, PenContext penContext, int tabletDeviceId, int stylusPointerId, Int32[] data, int timestamp);
    internal PenContext GetTabletDeviceIDPenContext(int tabletDeviceId);
    internal bool ConsiderInRange(int timestamp);
    internal void AddContext(UInt32 index);
    internal void RemoveContext(UInt32 index);
    internal object get_SyncRoot();
    internal void AddStylusPlugInCollection(StylusPlugInCollection pic);
    internal void RemoveStylusPlugInCollection(StylusPlugInCollection pic);
    internal int FindZOrderIndex(StylusPlugInCollection spicAdding);
    internal StylusPlugInCollection InvokeStylusPluginCollectionForMouse(RawStylusInputReport inputReport, IInputElement directlyOver, StylusPlugInCollection currentPlugInCollection);
    internal void InvokeStylusPluginCollection(RawStylusInputReport inputReport);
    internal StylusPlugInCollection TargetPlugInCollection(RawStylusInputReport inputReport);
    internal StylusPlugInCollection FindPlugInCollection(UIElement element);
    private StylusPlugInCollection HittestPlugInCollection(Point pt);
}
internal class System.Windows.Input.PenThread : object {
    private PenThreadWorker _penThreadWorker;
    internal void Dispose();
    protected virtual override void Finalize();
    private void DisposeHelper();
    internal bool AddPenContext(PenContext penContext);
    internal bool RemovePenContext(PenContext penContext);
    internal TabletDeviceInfo[] WorkerGetTabletsInfo();
    internal PenContextInfo WorkerCreateContext(IntPtr hwnd, IPimcTablet3 pimcTablet);
    internal bool WorkerAcquireTabletLocks(IPimcTablet3 tablet, UInt32 wispTabletKey);
    internal bool WorkerReleaseTabletLocks(IPimcTablet3 tablet, UInt32 wispTabletKey);
    internal StylusDeviceInfo[] WorkerRefreshCursorInfo(IPimcTablet3 pimcTablet);
    internal TabletDeviceInfo WorkerGetTabletInfo(UInt32 index);
    internal TabletDeviceSizeInfo WorkerGetUpdatedSizes(IPimcTablet3 pimcTablet);
}
internal class System.Windows.Input.PenThreadPool : object {
    private static int MAX_PENTHREAD_RETRIES;
    [ThreadStaticAttribute]
private static PenThreadPool _penThreadPool;
    private List`1<WeakReference`1<PenThread>> _penThreadWeakRefList;
    private static PenThreadPool();
    internal static PenThread GetPenThreadForPenContext(PenContext penContext);
    private PenThread GetPenThreadForPenContextHelper(PenContext penContext);
}
internal class System.Windows.Input.PenThreadWorker : object {
    private static int PenEventNone;
    private static int PenEventTimeout;
    private static int PenEventPenInRange;
    private static int PenEventPenOutOfRange;
    private static int PenEventPenDown;
    private static int PenEventPenUp;
    private static int PenEventPackets;
    private static int PenEventSystem;
    private static int MaxContextPerThread;
    private static int EventsFrequency;
    private IntPtr[] _handles;
    private WeakReference[] _penContexts;
    private IPimcContext3[] _pimcContexts;
    private UInt32[] _wispContextKeys;
    private SecurityCriticalData`1<IntPtr> _pimcResetHandle;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) __disposed;
    private List`1<WorkerOperation> _workerOperation;
    private object _workerOperationLock;
    private PenContext _cachedMovePenContext;
    private int _cachedMoveStylusPointerId;
    private int _cachedMoveStartTimestamp;
    private Int32[] _cachedMoveData;
    internal void Dispose();
    internal bool WorkerAddPenContext(PenContext penContext);
    internal bool WorkerRemovePenContext(PenContext penContext);
    internal TabletDeviceInfo[] WorkerGetTabletsInfo();
    internal PenContextInfo WorkerCreateContext(IntPtr hwnd, IPimcTablet3 pimcTablet);
    internal bool WorkerAcquireTabletLocks(IPimcTablet3 tablet, UInt32 wispTabletKey);
    internal bool WorkerReleaseTabletLocks(IPimcTablet3 tablet, UInt32 wispTabletKey);
    internal StylusDeviceInfo[] WorkerRefreshCursorInfo(IPimcTablet3 pimcTablet);
    internal TabletDeviceInfo WorkerGetTabletInfo(UInt32 index);
    internal TabletDeviceSizeInfo WorkerGetUpdatedSizes(IPimcTablet3 pimcTablet);
    private void FlushCache(bool goingOutOfRange);
    private bool DoCacheEvent(int evt, PenContext penContext, int stylusPointerId, Int32[] data, int timestamp);
    internal void FireEvent(PenContext penContext, int evt, int stylusPointerId, int cPackets, int cbPacket, IntPtr pPackets);
    private static TabletDeviceInfo GetTabletInfoHelper(IPimcTablet3 pimcTablet);
    private static void InitializeSupportedStylusPointProperties(IPimcTablet3 pimcTablet, TabletDeviceInfo tabletInfo);
    private static StylusDeviceInfo[] GetStylusDevicesInfo(IPimcTablet3 pimcTablet);
    internal bool AddPenContext(PenContext penContext);
    internal bool RemovePenContext(PenContext penContext);
    private static bool IsKnownException(Exception e);
    internal void ThreadProc();
}
public class System.Windows.Input.PreProcessInputEventArgs : ProcessInputEventArgs {
    private bool _canceled;
    public bool Canceled { get; }
    internal virtual void Reset(StagingAreaInputItem input, InputManager inputManager);
    public void Cancel();
    public bool get_Canceled();
}
public class System.Windows.Input.PreProcessInputEventHandler : MulticastDelegate {
    public PreProcessInputEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, PreProcessInputEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, PreProcessInputEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Input.ProcessInputEventArgs : NotifyInputEventArgs {
    private bool _allowAccessToStagingArea;
    internal virtual void Reset(StagingAreaInputItem input, InputManager inputManager);
    public StagingAreaInputItem PushInput(InputEventArgs input, StagingAreaInputItem promote);
    public StagingAreaInputItem PushInput(StagingAreaInputItem input);
    public StagingAreaInputItem PopInput();
    public StagingAreaInputItem PeekInput();
}
public class System.Windows.Input.ProcessInputEventHandler : MulticastDelegate {
    public ProcessInputEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ProcessInputEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ProcessInputEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Input.QueryCursorEventArgs : MouseEventArgs {
    private Cursor _cursor;
    public Cursor Cursor { get; public set; }
    public QueryCursorEventArgs(MouseDevice mouse, int timestamp);
    public QueryCursorEventArgs(MouseDevice mouse, int timestamp, StylusDevice stylusDevice);
    public Cursor get_Cursor();
    public void set_Cursor(Cursor value);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.QueryCursorEventHandler : MulticastDelegate {
    public QueryCursorEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, QueryCursorEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, QueryCursorEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Windows.Input.RawAppCommandInputReport : InputReport {
    private int _appCommand;
    private InputType _device;
    internal int AppCommand { get; }
    internal InputType Device { get; }
    internal RawAppCommandInputReport(PresentationSource inputSource, InputMode mode, int timestamp, int appCommand, InputType device, InputType inputType);
    internal int get_AppCommand();
    internal InputType get_Device();
}
[FlagsAttribute]
internal enum System.Windows.Input.RawKeyboardActions : Enum {
    public int value__;
    public static RawKeyboardActions None;
    public static RawKeyboardActions AttributesChanged;
    public static RawKeyboardActions Activate;
    public static RawKeyboardActions Deactivate;
    public static RawKeyboardActions KeyDown;
    public static RawKeyboardActions KeyUp;
}
internal class System.Windows.Input.RawKeyboardInputReport : InputReport {
    private RawKeyboardActions _actions;
    private int _scanCode;
    private bool _isExtendedKey;
    private bool _isSystemKey;
    private int _virtualKey;
    private SecurityCriticalData`1<IntPtr> _extraInformation;
    public RawKeyboardActions Actions { get; }
    public int ScanCode { get; }
    public bool IsExtendedKey { get; }
    public bool IsSystemKey { get; }
    public int VirtualKey { get; }
    public IntPtr ExtraInformation { get; }
    public RawKeyboardInputReport(PresentationSource inputSource, InputMode mode, int timestamp, RawKeyboardActions actions, int scanCode, bool isExtendedKey, bool isSystemKey, int virtualKey, IntPtr extraInformation);
    public RawKeyboardActions get_Actions();
    public int get_ScanCode();
    public bool get_IsExtendedKey();
    public bool get_IsSystemKey();
    public int get_VirtualKey();
    public IntPtr get_ExtraInformation();
    internal static bool IsValidRawKeyboardActions(RawKeyboardActions actions);
}
[FlagsAttribute]
internal enum System.Windows.Input.RawMouseActions : Enum {
    public int value__;
    public static RawMouseActions None;
    public static RawMouseActions AttributesChanged;
    public static RawMouseActions Activate;
    public static RawMouseActions Deactivate;
    public static RawMouseActions RelativeMove;
    public static RawMouseActions AbsoluteMove;
    public static RawMouseActions VirtualDesktopMove;
    public static RawMouseActions Button1Press;
    public static RawMouseActions Button1Release;
    public static RawMouseActions Button2Press;
    public static RawMouseActions Button2Release;
    public static RawMouseActions Button3Press;
    public static RawMouseActions Button3Release;
    public static RawMouseActions Button4Press;
    public static RawMouseActions Button4Release;
    public static RawMouseActions Button5Press;
    public static RawMouseActions Button5Release;
    public static RawMouseActions VerticalWheelRotate;
    public static RawMouseActions HorizontalWheelRotate;
    public static RawMouseActions QueryCursor;
    public static RawMouseActions CancelCapture;
}
[FriendAccessAllowedAttribute]
internal class System.Windows.Input.RawMouseInputReport : InputReport {
    private RawMouseActions _actions;
    private int _x;
    private int _y;
    private int _wheel;
    internal bool _isSynchronize;
    private SecurityCriticalData`1<IntPtr> _extraInformation;
    public RawMouseActions Actions { get; }
    public int X { get; }
    public int Y { get; }
    public int Wheel { get; }
    public IntPtr ExtraInformation { get; }
    public RawMouseInputReport(InputMode mode, int timestamp, PresentationSource inputSource, RawMouseActions actions, int x, int y, int wheel, IntPtr extraInformation);
    public RawMouseActions get_Actions();
    public int get_X();
    public int get_Y();
    public int get_Wheel();
    public IntPtr get_ExtraInformation();
    internal static bool IsValidRawMouseActions(RawMouseActions actions);
}
[FlagsAttribute]
internal enum System.Windows.Input.RawStylusActions : Enum {
    public int value__;
    public static RawStylusActions None;
    public static RawStylusActions Activate;
    public static RawStylusActions Deactivate;
    public static RawStylusActions Down;
    public static RawStylusActions Up;
    public static RawStylusActions Move;
    public static RawStylusActions InAirMove;
    public static RawStylusActions InRange;
    public static RawStylusActions OutOfRange;
    public static RawStylusActions SystemGesture;
}
internal static class System.Windows.Input.RawStylusActionsHelper : object {
    private static RawStylusActions MaxActions;
    private static RawStylusActionsHelper();
    internal static bool IsValid(RawStylusActions action);
}
internal class System.Windows.Input.RawStylusInputReport : InputReport {
    private RawStylusActions _actions;
    private int _tabletDeviceId;
    private int _stylusDeviceId;
    private bool _isQueued;
    private Int32[] _data;
    private StylusDevice _stylusDevice;
    private SecurityCriticalDataForSet`1<RawStylusInput> _rawStylusInput;
    private bool _isSynchronize;
    private Func`1<StylusPointDescription> _stylusPointDescGenerator;
    [CompilerGeneratedAttribute]
private PenContext <PenContext>k__BackingField;
    internal RawStylusInput RawStylusInput { get; internal set; }
    internal bool Synchronized { get; internal set; }
    internal RawStylusActions Actions { get; }
    internal int TabletDeviceId { get; }
    internal PenContext PenContext { get; private set; }
    internal StylusPointDescription StylusPointDescription { get; }
    internal int StylusDeviceId { get; }
    internal StylusDevice StylusDevice { get; internal set; }
    internal bool IsQueued { get; internal set; }
    internal Int32[] Data { get; }
    internal RawStylusInputReport(InputMode mode, int timestamp, PresentationSource inputSource, PenContext penContext, RawStylusActions actions, int tabletDeviceId, int stylusDeviceId, Int32[] data);
    internal RawStylusInputReport(InputMode mode, int timestamp, PresentationSource inputSource, RawStylusActions actions, Func`1<StylusPointDescription> stylusPointDescGenerator, int tabletDeviceId, int stylusDeviceId, Int32[] data);
    internal RawStylusInput get_RawStylusInput();
    internal void set_RawStylusInput(RawStylusInput value);
    internal bool get_Synchronized();
    internal void set_Synchronized(bool value);
    internal RawStylusActions get_Actions();
    internal int get_TabletDeviceId();
    [CompilerGeneratedAttribute]
internal PenContext get_PenContext();
    [CompilerGeneratedAttribute]
private void set_PenContext(PenContext value);
    internal StylusPointDescription get_StylusPointDescription();
    internal int get_StylusDeviceId();
    internal StylusDevice get_StylusDevice();
    internal void set_StylusDevice(StylusDevice value);
    internal bool get_IsQueued();
    internal void set_IsQueued(bool value);
    internal Int32[] GetRawPacketData();
    internal Point GetLastTabletPoint();
    internal Int32[] get_Data();
}
internal class System.Windows.Input.RawStylusSystemGestureInputReport : RawStylusInputReport {
    internal static SystemGesture InternalSystemGestureDoubleTap;
    private SystemGesture _id;
    private int _gestureX;
    private int _gestureY;
    private int _buttonState;
    internal SystemGesture SystemGesture { get; }
    internal int GestureX { get; }
    internal int GestureY { get; }
    internal int ButtonState { get; }
    internal RawStylusSystemGestureInputReport(InputMode mode, int timestamp, PresentationSource inputSource, Func`1<StylusPointDescription> stylusPointDescGenerator, int tabletId, int stylusDeviceId, SystemGesture systemGesture, int gestureX, int gestureY, int buttonState);
    internal RawStylusSystemGestureInputReport(InputMode mode, int timestamp, PresentationSource inputSource, PenContext penContext, int tabletId, int stylusDeviceId, SystemGesture systemGesture, int gestureX, int gestureY, int buttonState);
    internal static bool IsValidSystemGesture(SystemGesture systemGesture, bool allowFlick, bool allowDoubleTap);
    private void Initialize(SystemGesture systemGesture, int gestureX, int gestureY, int buttonState);
    internal SystemGesture get_SystemGesture();
    internal int get_GestureX();
    internal int get_GestureY();
    internal int get_ButtonState();
}
internal class System.Windows.Input.RawTextInputReport : InputReport {
    private bool _isDeadCharacter;
    private bool _isSystemCharacter;
    private bool _isControlCharacter;
    private char _characterCode;
    public bool IsDeadCharacter { get; }
    public bool IsSystemCharacter { get; }
    public bool IsControlCharacter { get; }
    public char CharacterCode { get; }
    public RawTextInputReport(PresentationSource inputSource, InputMode mode, int timestamp, bool isDeadCharacter, bool isSystemCharacter, bool isControlCharacter, char characterCode);
    public bool get_IsDeadCharacter();
    public bool get_IsSystemCharacter();
    public bool get_IsControlCharacter();
    public char get_CharacterCode();
}
internal enum System.Windows.Input.RawUIStateActions : Enum {
    public int value__;
    public static RawUIStateActions Set;
    public static RawUIStateActions Clear;
    public static RawUIStateActions Initialize;
}
internal class System.Windows.Input.RawUIStateInputReport : InputReport {
    private RawUIStateActions _action;
    private RawUIStateTargets _targets;
    public RawUIStateActions Action { get; }
    public RawUIStateTargets Targets { get; }
    public RawUIStateInputReport(PresentationSource inputSource, InputMode mode, int timestamp, RawUIStateActions action, RawUIStateTargets targets);
    public RawUIStateActions get_Action();
    public RawUIStateTargets get_Targets();
    internal static bool IsValidRawUIStateAction(RawUIStateActions action);
    internal static bool IsValidRawUIStateTargets(RawUIStateTargets targets);
}
[FlagsAttribute]
internal enum System.Windows.Input.RawUIStateTargets : Enum {
    public int value__;
    public static RawUIStateTargets None;
    public static RawUIStateTargets HideFocus;
    public static RawUIStateTargets HideAccelerators;
    public static RawUIStateTargets Active;
}
public enum System.Windows.Input.RestoreFocusMode : Enum {
    public int value__;
    public static RestoreFocusMode Auto;
    public static RestoreFocusMode None;
}
[TypeConverterAttribute("System.Windows.Input.CommandConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
[ValueSerializerAttribute("System.Windows.Input.CommandValueSerializer, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
public class System.Windows.Input.RoutedCommand : object {
    private string _name;
    private SecurityCriticalDataForSet`1<PrivateFlags> _flags;
    private Type _ownerType;
    private InputGestureCollection _inputGestureCollection;
    private byte _commandId;
    public string Name { get; }
    public Type OwnerType { get; }
    internal byte CommandId { get; }
    public InputGestureCollection InputGestures { get; }
    internal InputGestureCollection InputGesturesInternal { get; }
    internal bool IsBlockedByRM { get; internal set; }
    internal bool AreInputGesturesDelayLoaded { get; internal set; }
    public RoutedCommand(string name, Type ownerType);
    public RoutedCommand(string name, Type ownerType, InputGestureCollection inputGestures);
    internal RoutedCommand(string name, Type ownerType, byte commandId);
    private sealed virtual override void System.Windows.Input.ICommand.Execute(object parameter);
    private sealed virtual override bool System.Windows.Input.ICommand.CanExecute(object parameter);
    public sealed virtual void add_CanExecuteChanged(EventHandler value);
    public sealed virtual void remove_CanExecuteChanged(EventHandler value);
    public void Execute(object parameter, IInputElement target);
    public bool CanExecute(object parameter, IInputElement target);
    internal bool CriticalCanExecute(object parameter, IInputElement target, bool trusted, Boolean& continueRouting);
    public string get_Name();
    public Type get_OwnerType();
    internal byte get_CommandId();
    public InputGestureCollection get_InputGestures();
    internal InputGestureCollection get_InputGesturesInternal();
    private InputGestureCollection GetInputGestures();
    internal bool get_IsBlockedByRM();
    internal void set_IsBlockedByRM(bool value);
    internal bool get_AreInputGesturesDelayLoaded();
    internal void set_AreInputGesturesDelayLoaded(bool value);
    private static IInputElement FilterInputElement(IInputElement elem);
    private bool CanExecuteImpl(object parameter, IInputElement target, bool trusted, Boolean& continueRouting);
    private void CriticalCanExecuteWrapper(object parameter, IInputElement target, bool trusted, CanExecuteRoutedEventArgs args);
    internal bool ExecuteCore(object parameter, IInputElement target, bool userInitiated);
    private bool ExecuteImpl(object parameter, IInputElement target, bool userInitiated);
    private void WritePrivateFlag(PrivateFlags bit, bool value);
    private bool ReadPrivateFlag(PrivateFlags bit);
}
[TypeConverterAttribute("System.Windows.Input.CommandConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
public class System.Windows.Input.RoutedUICommand : RoutedCommand {
    private string _text;
    public string Text { get; public set; }
    public RoutedUICommand(string text, string name, Type ownerType);
    public RoutedUICommand(string text, string name, Type ownerType, InputGestureCollection inputGestures);
    internal RoutedUICommand(string name, Type ownerType, byte commandId);
    public string get_Text();
    public void set_Text(string value);
    private string GetText();
}
[TypeConverterAttribute("System.Windows.Input.CommandConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
internal class System.Windows.Input.SecureUICommand : RoutedUICommand {
    internal SecureUICommand(string name, Type ownerType, byte commandId);
}
public enum System.Windows.Input.SpeechMode : Enum {
    public int value__;
    public static SpeechMode Dictation;
    public static SpeechMode Command;
    public static SpeechMode Indeterminate;
}
public class System.Windows.Input.StagingAreaInputItem : object {
    private bool _isMarker;
    private InputEventArgs _input;
    private Hashtable _dictionary;
    public InputEventArgs Input { get; }
    internal bool IsMarker { get; }
    internal StagingAreaInputItem(bool isMarker);
    internal void Reset(InputEventArgs input, StagingAreaInputItem promote);
    public InputEventArgs get_Input();
    public object GetData(object key);
    public void SetData(object key, object value);
    internal bool get_IsMarker();
}
public static class System.Windows.Input.Stylus : object {
    public static RoutedEvent PreviewStylusDownEvent;
    public static RoutedEvent StylusDownEvent;
    public static RoutedEvent PreviewStylusUpEvent;
    public static RoutedEvent StylusUpEvent;
    public static RoutedEvent PreviewStylusMoveEvent;
    public static RoutedEvent StylusMoveEvent;
    public static RoutedEvent PreviewStylusInAirMoveEvent;
    public static RoutedEvent StylusInAirMoveEvent;
    public static RoutedEvent StylusEnterEvent;
    public static RoutedEvent StylusLeaveEvent;
    public static RoutedEvent PreviewStylusInRangeEvent;
    public static RoutedEvent StylusInRangeEvent;
    public static RoutedEvent PreviewStylusOutOfRangeEvent;
    public static RoutedEvent StylusOutOfRangeEvent;
    public static RoutedEvent PreviewStylusSystemGestureEvent;
    public static RoutedEvent StylusSystemGestureEvent;
    public static RoutedEvent GotStylusCaptureEvent;
    public static RoutedEvent LostStylusCaptureEvent;
    public static RoutedEvent StylusButtonDownEvent;
    public static RoutedEvent StylusButtonUpEvent;
    public static RoutedEvent PreviewStylusButtonDownEvent;
    public static RoutedEvent PreviewStylusButtonUpEvent;
    public static DependencyProperty IsPressAndHoldEnabledProperty;
    public static DependencyProperty IsFlicksEnabledProperty;
    public static DependencyProperty IsTapFeedbackEnabledProperty;
    public static DependencyProperty IsTouchFeedbackEnabledProperty;
    public static IInputElement DirectlyOver { get; }
    public static IInputElement Captured { get; }
    public static StylusDevice CurrentStylusDevice { get; }
    private static Stylus();
    public static void AddPreviewStylusDownHandler(DependencyObject element, StylusDownEventHandler handler);
    public static void RemovePreviewStylusDownHandler(DependencyObject element, StylusDownEventHandler handler);
    public static void AddStylusDownHandler(DependencyObject element, StylusDownEventHandler handler);
    public static void RemoveStylusDownHandler(DependencyObject element, StylusDownEventHandler handler);
    public static void AddPreviewStylusUpHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemovePreviewStylusUpHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddStylusUpHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemoveStylusUpHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddPreviewStylusMoveHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemovePreviewStylusMoveHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddStylusMoveHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemoveStylusMoveHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddPreviewStylusInAirMoveHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemovePreviewStylusInAirMoveHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddStylusInAirMoveHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemoveStylusInAirMoveHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddStylusEnterHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemoveStylusEnterHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddStylusLeaveHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemoveStylusLeaveHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddPreviewStylusInRangeHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemovePreviewStylusInRangeHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddStylusInRangeHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemoveStylusInRangeHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddPreviewStylusOutOfRangeHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemovePreviewStylusOutOfRangeHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddStylusOutOfRangeHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemoveStylusOutOfRangeHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddPreviewStylusSystemGestureHandler(DependencyObject element, StylusSystemGestureEventHandler handler);
    public static void RemovePreviewStylusSystemGestureHandler(DependencyObject element, StylusSystemGestureEventHandler handler);
    public static void AddStylusSystemGestureHandler(DependencyObject element, StylusSystemGestureEventHandler handler);
    public static void RemoveStylusSystemGestureHandler(DependencyObject element, StylusSystemGestureEventHandler handler);
    public static void AddGotStylusCaptureHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemoveGotStylusCaptureHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddLostStylusCaptureHandler(DependencyObject element, StylusEventHandler handler);
    public static void RemoveLostStylusCaptureHandler(DependencyObject element, StylusEventHandler handler);
    public static void AddStylusButtonDownHandler(DependencyObject element, StylusButtonEventHandler handler);
    public static void RemoveStylusButtonDownHandler(DependencyObject element, StylusButtonEventHandler handler);
    public static void AddStylusButtonUpHandler(DependencyObject element, StylusButtonEventHandler handler);
    public static void RemoveStylusButtonUpHandler(DependencyObject element, StylusButtonEventHandler handler);
    public static void AddPreviewStylusButtonDownHandler(DependencyObject element, StylusButtonEventHandler handler);
    public static void RemovePreviewStylusButtonDownHandler(DependencyObject element, StylusButtonEventHandler handler);
    public static void AddPreviewStylusButtonUpHandler(DependencyObject element, StylusButtonEventHandler handler);
    public static void RemovePreviewStylusButtonUpHandler(DependencyObject element, StylusButtonEventHandler handler);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetIsPressAndHoldEnabled(DependencyObject element);
    public static void SetIsPressAndHoldEnabled(DependencyObject element, bool enabled);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetIsFlicksEnabled(DependencyObject element);
    public static void SetIsFlicksEnabled(DependencyObject element, bool enabled);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetIsTapFeedbackEnabled(DependencyObject element);
    public static void SetIsTapFeedbackEnabled(DependencyObject element, bool enabled);
    public static bool GetIsTouchFeedbackEnabled(DependencyObject element);
    public static void SetIsTouchFeedbackEnabled(DependencyObject element, bool enabled);
    public static IInputElement get_DirectlyOver();
    public static IInputElement get_Captured();
    public static bool Capture(IInputElement element);
    public static bool Capture(IInputElement element, CaptureMode captureMode);
    public static void Synchronize();
    public static StylusDevice get_CurrentStylusDevice();
}
public class System.Windows.Input.StylusButton : object {
    private StylusDeviceBase _stylusDevice;
    private string _name;
    private Guid _guid;
    private StylusButtonState _cachedButtonState;
    public Guid Guid { get; }
    public StylusButtonState StylusButtonState { get; }
    internal StylusButtonState CachedButtonState { get; internal set; }
    public string Name { get; }
    public StylusDevice StylusDevice { get; }
    internal StylusButton(string name, Guid id);
    public Guid get_Guid();
    public StylusButtonState get_StylusButtonState();
    internal StylusButtonState get_CachedButtonState();
    internal void set_CachedButtonState(StylusButtonState value);
    public string get_Name();
    public StylusDevice get_StylusDevice();
    internal void SetOwner(StylusDeviceBase stylusDevice);
    public virtual string ToString();
}
public class System.Windows.Input.StylusButtonCollection : ReadOnlyCollection`1<StylusButton> {
    internal StylusButtonCollection(StylusButton[] buttons);
    internal StylusButtonCollection(List`1<StylusButton> buttons);
    public StylusButton GetStylusButtonByGuid(Guid guid);
}
public class System.Windows.Input.StylusButtonEventArgs : StylusEventArgs {
    private StylusButton _button;
    public StylusButton StylusButton { get; }
    public StylusButtonEventArgs(StylusDevice stylusDevice, int timestamp, StylusButton button);
    public StylusButton get_StylusButton();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.StylusButtonEventHandler : MulticastDelegate {
    public StylusButtonEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, StylusButtonEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, StylusButtonEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Windows.Input.StylusButtonState : Enum {
    public int value__;
    public static StylusButtonState Up;
    public static StylusButtonState Down;
}
public class System.Windows.Input.StylusDevice : InputDevice {
    [CompilerGeneratedAttribute]
private StylusDeviceBase <StylusDeviceImpl>k__BackingField;
    internal StylusDeviceBase StylusDeviceImpl { get; internal set; }
    public IInputElement Target { get; }
    public bool IsValid { get; }
    public PresentationSource ActiveSource { get; }
    public IInputElement DirectlyOver { get; }
    public IInputElement Captured { get; }
    public TabletDevice TabletDevice { get; }
    public string Name { get; }
    public int Id { get; }
    public StylusButtonCollection StylusButtons { get; }
    public bool InAir { get; }
    public bool Inverted { get; }
    public bool InRange { get; }
    internal int DoubleTapDeltaX { get; }
    internal int DoubleTapDeltaY { get; }
    internal int DoubleTapDeltaTime { get; }
    internal StylusDevice(StylusDeviceBase impl);
    [CompilerGeneratedAttribute]
internal StylusDeviceBase get_StylusDeviceImpl();
    [CompilerGeneratedAttribute]
internal void set_StylusDeviceImpl(StylusDeviceBase value);
    public virtual IInputElement get_Target();
    public bool get_IsValid();
    public virtual PresentationSource get_ActiveSource();
    public IInputElement get_DirectlyOver();
    public IInputElement get_Captured();
    public bool Capture(IInputElement element, CaptureMode captureMode);
    public bool Capture(IInputElement element);
    public void Synchronize();
    public TabletDevice get_TabletDevice();
    public string get_Name();
    public virtual string ToString();
    public int get_Id();
    public StylusPointCollection GetStylusPoints(IInputElement relativeTo);
    public StylusPointCollection GetStylusPoints(IInputElement relativeTo, StylusPointDescription subsetToReformatTo);
    public StylusButtonCollection get_StylusButtons();
    public Point GetPosition(IInputElement relativeTo);
    public bool get_InAir();
    public bool get_Inverted();
    public bool get_InRange();
    internal int get_DoubleTapDeltaX();
    internal int get_DoubleTapDeltaY();
    internal int get_DoubleTapDeltaTime();
    internal Point GetMouseScreenPosition(MouseDevice mouseDevice);
    internal MouseButtonState GetMouseButtonState(MouseButton mouseButton, MouseDevice mouseDevice);
    internal static IInputElement LocalHitTest(PresentationSource inputSource, Point pt);
    internal static IInputElement GlobalHitTest(PresentationSource inputSource, Point pt);
    internal static GeneralTransform GetElementTransform(IInputElement relativeTo);
    internal T As();
}
internal abstract class System.Windows.Input.StylusDeviceBase : DispatcherObject {
    [CompilerGeneratedAttribute]
private StylusDevice <StylusDevice>k__BackingField;
    protected bool _disposed;
    internal StylusDevice StylusDevice { get; private set; }
    internal IInputElement Target { get; }
    internal PresentationSource ActiveSource { get; }
    internal PresentationSource CriticalActiveSource { get; }
    internal StylusPoint RawStylusPoint { get; }
    internal bool IsValid { get; }
    internal IInputElement DirectlyOver { get; }
    internal IInputElement Captured { get; }
    internal CaptureMode CapturedMode { get; }
    internal TabletDevice TabletDevice { get; }
    internal string Name { get; }
    internal int Id { get; }
    internal StylusButtonCollection StylusButtons { get; }
    internal bool InAir { get; }
    internal bool Inverted { get; }
    internal bool InRange { get; }
    internal int DoubleTapDeltaX { get; }
    internal int DoubleTapDeltaY { get; }
    internal int DoubleTapDeltaTime { get; }
    internal int TapCount { get; internal set; }
    internal StylusPlugInCollection CurrentVerifiedTarget { get; internal set; }
    [CompilerGeneratedAttribute]
internal StylusDevice get_StylusDevice();
    [CompilerGeneratedAttribute]
private void set_StylusDevice(StylusDevice value);
    internal T As();
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    internal abstract virtual IInputElement get_Target();
    internal abstract virtual PresentationSource get_ActiveSource();
    internal abstract virtual void UpdateEventStylusPoints(RawStylusInputReport report, bool resetIfNoOverride);
    internal abstract virtual PresentationSource get_CriticalActiveSource();
    internal abstract virtual StylusPoint get_RawStylusPoint();
    internal abstract virtual bool get_IsValid();
    internal abstract virtual IInputElement get_DirectlyOver();
    internal abstract virtual IInputElement get_Captured();
    internal abstract virtual CaptureMode get_CapturedMode();
    internal abstract virtual bool Capture(IInputElement element, CaptureMode captureMode);
    internal abstract virtual bool Capture(IInputElement element);
    internal abstract virtual void Synchronize();
    internal abstract virtual TabletDevice get_TabletDevice();
    internal abstract virtual string get_Name();
    internal abstract virtual int get_Id();
    internal abstract virtual StylusPointCollection GetStylusPoints(IInputElement relativeTo);
    internal abstract virtual StylusPointCollection GetStylusPoints(IInputElement relativeTo, StylusPointDescription subsetToReformatTo);
    internal abstract virtual StylusButtonCollection get_StylusButtons();
    internal abstract virtual Point GetPosition(IInputElement relativeTo);
    internal abstract virtual bool get_InAir();
    internal abstract virtual bool get_Inverted();
    internal abstract virtual bool get_InRange();
    internal abstract virtual int get_DoubleTapDeltaX();
    internal abstract virtual int get_DoubleTapDeltaY();
    internal abstract virtual int get_DoubleTapDeltaTime();
    internal abstract virtual Point GetMouseScreenPosition(MouseDevice mouseDevice);
    internal abstract virtual MouseButtonState GetMouseButtonState(MouseButton mouseButton, MouseDevice mouseDevice);
    internal abstract virtual int get_TapCount();
    internal abstract virtual void set_TapCount(int value);
    internal abstract virtual StylusPlugInCollection GetCapturedPlugInCollection(Boolean& elementHasCapture);
    internal abstract virtual StylusPlugInCollection get_CurrentVerifiedTarget();
    internal abstract virtual void set_CurrentVerifiedTarget(StylusPlugInCollection value);
}
public class System.Windows.Input.StylusDeviceCollection : ReadOnlyCollection`1<StylusDevice> {
    internal StylusDeviceCollection(IEnumerable`1<StylusDeviceBase> styluses);
    internal void Dispose();
    internal void AddStylusDevice(int index, StylusDeviceBase stylusDevice);
}
internal class System.Windows.Input.StylusDeviceInfo : ValueType {
    public string CursorName;
    public int CursorId;
    public bool CursorInverted;
    public StylusButtonCollection ButtonCollection;
}
public class System.Windows.Input.StylusDownEventArgs : StylusEventArgs {
    public int TapCount { get; }
    public StylusDownEventArgs(StylusDevice stylusDevice, int timestamp);
    public int get_TapCount();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.StylusDownEventHandler : MulticastDelegate {
    public StylusDownEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, StylusDownEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, StylusDownEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Input.StylusEventArgs : InputEventArgs {
    private RawStylusInputReport _inputReport;
    public StylusDevice StylusDevice { get; }
    internal StylusDeviceBase StylusDeviceImpl { get; }
    public bool InAir { get; }
    public bool Inverted { get; }
    internal RawStylusInputReport InputReport { get; internal set; }
    public StylusEventArgs(StylusDevice stylus, int timestamp);
    public StylusDevice get_StylusDevice();
    internal StylusDeviceBase get_StylusDeviceImpl();
    public Point GetPosition(IInputElement relativeTo);
    public bool get_InAir();
    public bool get_Inverted();
    public StylusPointCollection GetStylusPoints(IInputElement relativeTo);
    public StylusPointCollection GetStylusPoints(IInputElement relativeTo, StylusPointDescription subsetToReformatTo);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
    internal RawStylusInputReport get_InputReport();
    internal void set_InputReport(RawStylusInputReport value);
}
public class System.Windows.Input.StylusEventHandler : MulticastDelegate {
    public StylusEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, StylusEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, StylusEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal abstract class System.Windows.Input.StylusLogic : DispatcherObject {
    private static int FlickCommandMask;
    private static string WispKeyAssert;
    private static string WispRootKey;
    private static string WispPenSystemEventParametersKey;
    private static string WispTouchConfigKey;
    private static string WispDoubleTapDistanceValue;
    private static string WispDoubleTapTimeValue;
    private static string WispCancelDeltaValue;
    private static string WispTouchDoubleTapDistanceValue;
    private static string WispTouchDoubleTapTimeValue;
    private static string WpfPointerKeyAssert;
    private static string WpfPointerKey;
    private static string WpfPointerValue;
    private static UInt32 PromotedMouseEventTag;
    private static UInt32 PromotedMouseEventMask;
    private static byte PromotedMouseEventCursorIdMask;
    protected int _stylusDoubleTapDeltaTime;
    protected int _stylusDoubleTapDelta;
    protected int _cancelDelta;
    protected int _touchDoubleTapDeltaTime;
    protected int _touchDoubleTapDelta;
    protected static double DoubleTapMinFactor;
    protected static double DoubleTapMaxFactor;
    private static Nullable`1<bool> _isPointerStackEnabled;
    [ThreadStaticAttribute]
private static SecurityCriticalDataClass`1<StylusLogic> _currentStylusLogic;
    [CompilerGeneratedAttribute]
private StylusLogicShutDownListener <ShutdownListener>k__BackingField;
    [CompilerGeneratedAttribute]
private StylusStatistics <Statistics>k__BackingField;
    internal static bool IsInstantiated { get; }
    internal static bool IsStylusAndTouchSupportEnabled { get; }
    internal static bool IsPointerStackEnabled { get; }
    internal static StylusLogic CurrentStylusLogic { get; }
    private static bool IsPointerEnabledInRegistry { get; }
    internal int StylusDoubleTapDelta { get; }
    internal int TouchDoubleTapDelta { get; }
    internal int StylusDoubleTapDeltaTime { get; }
    internal int TouchDoubleTapDeltaTime { get; }
    internal StylusDeviceBase CurrentStylusDevice { get; }
    internal TabletDeviceCollection TabletDevices { get; }
    protected StylusLogicShutDownListener ShutdownListener { get; protected set; }
    public StylusStatistics Statistics { get; protected set; }
    internal static bool get_IsInstantiated();
    internal static bool get_IsStylusAndTouchSupportEnabled();
    internal static bool get_IsPointerStackEnabled();
    internal static StylusLogic get_CurrentStylusLogic();
    internal static T GetCurrentStylusLogicAs();
    private static void Initialize();
    private static bool get_IsPointerEnabledInRegistry();
    internal int get_StylusDoubleTapDelta();
    internal int get_TouchDoubleTapDelta();
    internal int get_StylusDoubleTapDeltaTime();
    internal int get_TouchDoubleTapDeltaTime();
    protected void ReadSystemConfig();
    internal abstract virtual void UpdateOverProperty(StylusDeviceBase stylusDevice, IInputElement newOver);
    internal abstract virtual StylusDeviceBase get_CurrentStylusDevice();
    internal abstract virtual TabletDeviceCollection get_TabletDevices();
    internal abstract virtual Point DeviceUnitsFromMeasureUnits(Point measurePoint);
    internal abstract virtual Point MeasureUnitsFromDeviceUnits(Point measurePoint);
    internal abstract virtual void UpdateStylusCapture(StylusDeviceBase stylusDevice, IInputElement oldStylusDeviceCapture, IInputElement newStylusDeviceCapture, int timestamp);
    internal abstract virtual void ReevaluateCapture(DependencyObject element, DependencyObject oldParent, bool isCoreParent);
    internal abstract virtual void ReevaluateStylusOver(DependencyObject element, DependencyObject oldParent, bool isCoreParent);
    protected abstract virtual void OnTabletRemoved(UInt32 wisptisIndex);
    internal abstract virtual void HandleMessage(WindowMessage msg, IntPtr wParam, IntPtr lParam);
    [CompilerGeneratedAttribute]
protected StylusLogicShutDownListener get_ShutdownListener();
    [CompilerGeneratedAttribute]
protected void set_ShutdownListener(StylusLogicShutDownListener value);
    [CompilerGeneratedAttribute]
public StylusStatistics get_Statistics();
    [CompilerGeneratedAttribute]
protected void set_Statistics(StylusStatistics value);
    private static int FitToCplCurve(double vMin, double vMid, double vMax, int value);
    internal static bool IsPromotedMouseEvent(RawMouseInputReport mouseInputReport);
    internal static UInt32 GetCursorIdFromMouseEvent(RawMouseInputReport mouseInputReport);
    internal static void CurrentStylusLogicReevaluateStylusOver(DependencyObject element, DependencyObject oldParent, bool isCoreParent);
    internal static void CurrentStylusLogicReevaluateCapture(DependencyObject element, DependencyObject oldParent, bool isCoreParent);
    internal static RoutedEvent GetMainEventFromPreviewEvent(RoutedEvent routedEvent);
    internal static RoutedEvent GetPreviewEventFromRawStylusActions(RawStylusActions actions);
    protected bool ValidateUIElementForCapture(UIElement element);
    protected bool ValidateContentElementForCapture(ContentElement element);
    protected bool ValidateUIElement3DForCapture(UIElement3D element);
    protected bool ValidateVisualForCapture(DependencyObject visual, StylusDeviceBase currentStylusDevice);
    internal static FlickAction GetFlickAction(int flickData);
    protected static bool GetIsScrollUp(int flickData);
    internal bool HandleFlick(int flickData, IInputElement element);
}
internal class System.Windows.Input.StylusPlugIns.DispatcherShutdownStartedEventManager : WeakEventManager {
    private static DispatcherShutdownStartedEventManager CurrentManager { get; }
    public static void AddListener(Dispatcher source, IWeakEventListener listener);
    protected virtual void StartListening(object source);
    protected virtual void StopListening(object source);
    private static DispatcherShutdownStartedEventManager get_CurrentManager();
    private void OnShutdownStarted(object sender, EventArgs args);
}
public class System.Windows.Input.StylusPlugIns.DynamicRenderer : StylusPlugIn {
    private Dispatcher _applicationDispatcher;
    private Geometry _zeroSizedFrozenRect;
    private DrawingAttributes _drawAttrsSource;
    private List`1<StrokeInfo> _strokeInfoList;
    private ContainerVisual _mainContainerVisual;
    private ContainerVisual _mainRawInkContainerVisual;
    private DynamicRendererHostVisual _rawInkHostVisual1;
    private DynamicRendererHostVisual _rawInkHostVisual2;
    private DynamicRendererHostVisual _currentHostVisual;
    private EventHandler _onRenderComplete;
    private bool _waitingForRenderComplete;
    private object __siLock;
    private StrokeInfo _renderCompleteStrokeInfo;
    private DynamicRendererThreadManager _renderingThread;
    private EventHandler _onDRThreadRenderComplete;
    private bool _waitingForDRThreadRenderComplete;
    private Queue`1<StrokeInfo> _renderCompleteDRThreadStrokeInfoList;
    public Visual RootVisual { get; }
    public DrawingAttributes DrawingAttributes { get; public set; }
    public virtual void Reset(StylusDevice stylusDevice, StylusPointCollection stylusPoints);
    public Visual get_RootVisual();
    protected virtual void OnAdded();
    protected virtual void OnRemoved();
    protected virtual void OnIsActiveForInputChanged();
    protected virtual void OnStylusEnter(RawStylusInput rawStylusInput, bool confirmed);
    protected virtual void OnStylusLeave(RawStylusInput rawStylusInput, bool confirmed);
    private void HandleStylusEnterLeave(RawStylusInput rawStylusInput, bool isEnter, bool isConfirmed);
    protected virtual void OnEnabledChanged();
    protected virtual void OnStylusDown(RawStylusInput rawStylusInput);
    protected virtual void OnStylusMove(RawStylusInput rawStylusInput);
    protected virtual void OnStylusUp(RawStylusInput rawStylusInput);
    private bool IsStylusUp(int stylusId);
    private void OnRenderComplete();
    private void RemoveDynamicRendererVisualAndNotifyWhenDone(StrokeInfo si);
    private void NotifyAppOfDRThreadRenderComplete(StrokeInfo si);
    private void OnDRThreadRenderComplete(object sender, EventArgs e);
    protected virtual void OnStylusDownProcessed(object callbackData, bool targetVerified);
    protected virtual void OnStylusUpProcessed(object callbackData, bool targetVerified);
    private void OnInternalRenderComplete(object sender, EventArgs e);
    private void NotifyOnNextRenderComplete();
    protected virtual void OnDraw(DrawingContext drawingContext, StylusPointCollection stylusPoints, Geometry geometry, Brush fillBrush);
    protected virtual void OnDrawingAttributesReplaced();
    protected Dispatcher GetDispatcher();
    private void RenderPackets(StylusPointCollection stylusPoints, StrokeInfo si);
    private void AbortAllStrokes();
    private void TransitionStrokeVisuals(StrokeInfo si, bool abortStroke);
    private DynamicRendererHostVisual GetCurrentHostVisual();
    private void TransitionComplete(StrokeInfo si);
    private void RemoveStrokeInfo(StrokeInfo si);
    private StrokeInfo FindStrokeInfo(int timestamp);
    public DrawingAttributes get_DrawingAttributes();
    public void set_DrawingAttributes(DrawingAttributes value);
    private void CreateInkingVisuals();
    private void CreateRealTimeVisuals();
    private void DestroyRealTimeVisuals();
}
internal class System.Windows.Input.StylusPlugIns.DynamicRendererThreadManager : object {
    [ThreadStaticAttribute]
private static WeakReference _tsDRTMWeakRef;
    private Dispatcher modreq(System.Runtime.CompilerServices.IsVolatile) __inkingDispatcher;
    private bool _disposed;
    internal Dispatcher ThreadDispatcher { get; }
    internal static DynamicRendererThreadManager GetCurrentThreadInstance();
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    private sealed virtual override bool System.Windows.IWeakEventListener.ReceiveWeakEvent(Type managerType, object sender, EventArgs args);
    private void OnAppDispatcherShutdown(object sender, EventArgs e);
    private void Dispose(bool disposing);
    internal Dispatcher get_ThreadDispatcher();
    [CompilerGeneratedAttribute]
private object <OnAppDispatcherShutdown>b__8_0(object unused);
}
public class System.Windows.Input.StylusPlugIns.RawStylusInput : object {
    private RawStylusInputReport _report;
    private GeneralTransform _tabletToElementTransform;
    private StylusPlugInCollection _targetPlugInCollection;
    private StylusPointCollection _stylusPoints;
    private StylusPlugIn _currentNotifyPlugIn;
    private RawStylusInputCustomDataList _customData;
    public int StylusDeviceId { get; }
    public int TabletDeviceId { get; }
    public int Timestamp { get; }
    internal bool StylusPointsModified { get; }
    internal StylusPlugInCollection Target { get; }
    internal RawStylusInputReport Report { get; }
    internal GeneralTransform ElementTransform { get; }
    internal RawStylusInputCustomDataList CustomDataList { get; }
    internal StylusPlugIn CurrentNotifyPlugIn { get; internal set; }
    internal RawStylusInput(RawStylusInputReport report, GeneralTransform tabletToElementTransform, StylusPlugInCollection targetPlugInCollection);
    public int get_StylusDeviceId();
    public int get_TabletDeviceId();
    public int get_Timestamp();
    public StylusPointCollection GetStylusPoints();
    internal StylusPointCollection GetStylusPoints(GeneralTransform transform);
    public void SetStylusPoints(StylusPointCollection stylusPoints);
    public void NotifyWhenProcessed(object callbackData);
    internal bool get_StylusPointsModified();
    internal StylusPlugInCollection get_Target();
    internal RawStylusInputReport get_Report();
    internal GeneralTransform get_ElementTransform();
    internal RawStylusInputCustomDataList get_CustomDataList();
    internal StylusPlugIn get_CurrentNotifyPlugIn();
    internal void set_CurrentNotifyPlugIn(StylusPlugIn value);
}
internal class System.Windows.Input.StylusPlugIns.RawStylusInputCustomData : object {
    private StylusPlugIn _owner;
    private object _data;
    public object Data { get; }
    public StylusPlugIn Owner { get; }
    public RawStylusInputCustomData(StylusPlugIn owner, object data);
    public object get_Data();
    public StylusPlugIn get_Owner();
}
internal class System.Windows.Input.StylusPlugIns.RawStylusInputCustomDataList : Collection`1<RawStylusInputCustomData> {
}
public abstract class System.Windows.Input.StylusPlugIns.StylusPlugIn : object {
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) __enabled;
    private bool _activeForInput;
    private StylusPlugInCollection _pic;
    public UIElement Element { get; }
    public Rect ElementBounds { get; }
    public bool Enabled { get; public set; }
    public bool IsActiveForInput { get; }
    internal void Added(StylusPlugInCollection plugInCollection);
    protected virtual void OnAdded();
    internal void Removed();
    protected virtual void OnRemoved();
    internal void StylusEnterLeave(bool isEnter, RawStylusInput rawStylusInput, bool confirmed);
    internal void RawStylusInput(RawStylusInput rawStylusInput);
    protected virtual void OnStylusEnter(RawStylusInput rawStylusInput, bool confirmed);
    protected virtual void OnStylusLeave(RawStylusInput rawStylusInput, bool confirmed);
    protected virtual void OnStylusDown(RawStylusInput rawStylusInput);
    protected virtual void OnStylusMove(RawStylusInput rawStylusInput);
    protected virtual void OnStylusUp(RawStylusInput rawStylusInput);
    internal void FireCustomData(object callbackData, RawStylusActions action, bool targetVerified);
    protected virtual void OnStylusDownProcessed(object callbackData, bool targetVerified);
    protected virtual void OnStylusMoveProcessed(object callbackData, bool targetVerified);
    protected virtual void OnStylusUpProcessed(object callbackData, bool targetVerified);
    public UIElement get_Element();
    public Rect get_ElementBounds();
    public bool get_Enabled();
    public void set_Enabled(bool value);
    protected virtual void OnEnabledChanged();
    internal void InvalidateIsActiveForInput();
    public bool get_IsActiveForInput();
    protected virtual void OnIsActiveForInputChanged();
}
public class System.Windows.Input.StylusPlugIns.StylusPlugInCollection : Collection`1<StylusPlugIn> {
    private StylusPlugInCollectionBase _stylusPlugInCollectionImpl;
    private UIElement _element;
    private Rect _rc;
    private GeneralTransform _viewToElement;
    private Transform _lastRenderTransform;
    private DependencyPropertyChangedEventHandler _isEnabledChangedEventHandler;
    private DependencyPropertyChangedEventHandler _isVisibleChangedEventHandler;
    private DependencyPropertyChangedEventHandler _isHitTestVisibleChangedEventHandler;
    private EventHandler _renderTransformChangedEventHandler;
    private SourceChangedEventHandler _sourceChangedEventHandler;
    private EventHandler _layoutChangedEventHandler;
    internal UIElement Element { get; }
    internal GeneralTransform ViewToElement { get; }
    internal Rect Rect { get; }
    internal bool IsActiveForInput { get; }
    internal object SyncRoot { get; }
    internal StylusPlugInCollection(UIElement element);
    protected virtual void InsertItem(int index, StylusPlugIn plugIn);
    protected virtual void ClearItems();
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, StylusPlugIn plugIn);
    internal UIElement get_Element();
    internal void UpdateRect();
    internal bool IsHit(Point pt);
    internal GeneralTransform get_ViewToElement();
    internal Rect get_Rect();
    internal void FireEnterLeave(bool isEnter, RawStylusInput rawStylusInput, bool confirmed);
    internal void FireRawStylusInput(RawStylusInput args);
    internal bool get_IsActiveForInput();
    internal object get_SyncRoot();
    internal void OnLayoutUpdated(object sender, EventArgs e);
    internal void ExecuteWithPotentialLock(Action action);
    internal void ExecuteWithPotentialDispatcherDisable(Action action);
    private void EnsureEventsHooked();
    private void EnsureEventsUnhooked();
    private void OnIsEnabledChanged(object sender, DependencyPropertyChangedEventArgs e);
    private void OnIsVisibleChanged(object sender, DependencyPropertyChangedEventArgs e);
    private void OnIsHitTestVisibleChanged(object sender, DependencyPropertyChangedEventArgs e);
    private void OnRenderTransformChanged(object sender, EventArgs e);
    private void OnSourceChanged(object sender, SourceChangedEventArgs e);
    [DebuggerHiddenAttribute]
[CompilerGeneratedAttribute]
private void <>n__0(int index, StylusPlugIn item);
    [CompilerGeneratedAttribute]
private void <ClearItems>b__1_0();
    [CompilerGeneratedAttribute]
private void <ClearItems>b__1_1();
    [DebuggerHiddenAttribute]
[CompilerGeneratedAttribute]
private StylusPlugIn <>n__1(int index);
    [DebuggerHiddenAttribute]
[CompilerGeneratedAttribute]
private void <>n__2(int index);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__3(int index, StylusPlugIn item);
    [CompilerGeneratedAttribute]
private void <OnLayoutUpdated>b__19_0();
    [CompilerGeneratedAttribute]
private void <OnLayoutUpdated>b__19_1();
    [CompilerGeneratedAttribute]
private void <EnsureEventsUnhooked>b__23_0();
}
internal abstract class System.Windows.Input.StylusPlugIns.StylusPlugInCollectionBase : object {
    [CompilerGeneratedAttribute]
private StylusPlugInCollection <Wrapper>k__BackingField;
    internal StylusPlugInCollection Wrapper { get; private set; }
    internal bool IsActiveForInput { get; }
    internal object SyncRoot { get; }
    internal static StylusPlugInCollectionBase Create(StylusPlugInCollection wrapper);
    [CompilerGeneratedAttribute]
internal StylusPlugInCollection get_Wrapper();
    [CompilerGeneratedAttribute]
private void set_Wrapper(StylusPlugInCollection value);
    internal abstract virtual bool get_IsActiveForInput();
    internal abstract virtual object get_SyncRoot();
    internal abstract virtual void UpdateState(UIElement element);
    internal abstract virtual void Unhook();
}
public class System.Windows.Input.StylusPoint : ValueType {
    internal static float DefaultPressure;
    private double _x;
    private double _y;
    private float _pressureFactor;
    private Int32[] _additionalValues;
    private StylusPointDescription _stylusPointDescription;
    public static double MaxXY;
    public static double MinXY;
    public double X { get; public set; }
    public double Y { get; public set; }
    public float PressureFactor { get; public set; }
    public StylusPointDescription Description { get; internal set; }
    internal bool HasDefaultPressure { get; }
    public StylusPoint(double x, double y);
    public StylusPoint(double x, double y, float pressureFactor);
    public StylusPoint(double x, double y, float pressureFactor, StylusPointDescription stylusPointDescription, Int32[] additionalValues);
    internal StylusPoint(double x, double y, float pressureFactor, StylusPointDescription stylusPointDescription, Int32[] additionalValues, bool validateAdditionalData, bool validatePressureFactor);
    private static StylusPoint();
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public float get_PressureFactor();
    public void set_PressureFactor(float value);
    public StylusPointDescription get_Description();
    internal void set_Description(StylusPointDescription value);
    public bool HasProperty(StylusPointProperty stylusPointProperty);
    public int GetPropertyValue(StylusPointProperty stylusPointProperty);
    public void SetPropertyValue(StylusPointProperty stylusPointProperty, int value);
    internal void SetPropertyValue(StylusPointProperty stylusPointProperty, int value, bool copyBeforeWrite);
    public static Point op_Explicit(StylusPoint stylusPoint);
    public Point ToPoint();
    public static bool op_Equality(StylusPoint stylusPoint1, StylusPoint stylusPoint2);
    public static bool op_Inequality(StylusPoint stylusPoint1, StylusPoint stylusPoint2);
    public static bool Equals(StylusPoint stylusPoint1, StylusPoint stylusPoint2);
    public virtual bool Equals(object o);
    public sealed virtual bool Equals(StylusPoint value);
    public virtual int GetHashCode();
    internal Int32[] GetAdditionalData();
    internal float GetUntruncatedPressureFactor();
    internal Int32[] GetPacketData();
    internal bool get_HasDefaultPressure();
    private void CopyAdditionalData();
    private static double GetClampedXYValue(double xyValue);
}
public class System.Windows.Input.StylusPointCollection : Collection`1<StylusPoint> {
    private StylusPointDescription _stylusPointDescription;
    [CompilerGeneratedAttribute]
private EventHandler Changed;
    [CompilerGeneratedAttribute]
private CancelEventHandler CountGoingToZero;
    public StylusPointDescription Description { get; }
    public StylusPointCollection(int initialCapacity);
    public StylusPointCollection(StylusPointDescription stylusPointDescription);
    public StylusPointCollection(StylusPointDescription stylusPointDescription, int initialCapacity);
    public StylusPointCollection(IEnumerable`1<StylusPoint> stylusPoints);
    public StylusPointCollection(IEnumerable`1<Point> points);
    internal StylusPointCollection(StylusPointDescription stylusPointDescription, Int32[] rawPacketData, GeneralTransform tabletToView, Matrix tabletToViewMatrix);
    [CompilerGeneratedAttribute]
public void add_Changed(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Changed(EventHandler value);
    [CompilerGeneratedAttribute]
internal void add_CountGoingToZero(CancelEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_CountGoingToZero(CancelEventHandler value);
    public void Add(StylusPointCollection stylusPoints);
    public StylusPointDescription get_Description();
    protected sealed virtual void ClearItems();
    protected sealed virtual void RemoveItem(int index);
    protected sealed virtual void InsertItem(int index, StylusPoint stylusPoint);
    protected sealed virtual void SetItem(int index, StylusPoint stylusPoint);
    public StylusPointCollection Clone();
    public static Point[] op_Explicit(StylusPointCollection stylusPoints);
    internal StylusPointCollection Clone(int count);
    internal StylusPointCollection Clone(GeneralTransform transform, StylusPointDescription descriptionToUse);
    private StylusPointCollection Clone(GeneralTransform transform, StylusPointDescription descriptionToUse, int count);
    protected virtual void OnChanged(EventArgs e);
    internal void Transform(GeneralTransform transform);
    public StylusPointCollection Reformat(StylusPointDescription subsetToReformatTo);
    internal StylusPointCollection Reformat(StylusPointDescription subsetToReformatTo, GeneralTransform transform);
    public Int32[] ToHiMetricArray();
    internal void ToISFReadyArrays(Int32[][]& output, Boolean& shouldPersistPressure);
    private bool CanGoToZero();
}
public class System.Windows.Input.StylusPointDescription : object {
    internal static int RequiredCountOfProperties;
    internal static int RequiredXIndex;
    internal static int RequiredYIndex;
    internal static int RequiredPressureIndex;
    internal static int MaximumButtonCount;
    private int _buttonCount;
    private int _originalPressureIndex;
    private StylusPointPropertyInfo[] _stylusPointPropertyInfos;
    public int PropertyCount { get; }
    internal int ButtonCount { get; }
    internal bool ContainsTruePressure { get; }
    internal int OriginalPressureIndex { get; }
    public StylusPointDescription(IEnumerable`1<StylusPointPropertyInfo> stylusPointPropertyInfos);
    internal StylusPointDescription(IEnumerable`1<StylusPointPropertyInfo> stylusPointPropertyInfos, int originalPressureIndex);
    private static StylusPointDescription();
    public bool HasProperty(StylusPointProperty stylusPointProperty);
    public int get_PropertyCount();
    public StylusPointPropertyInfo GetPropertyInfo(StylusPointProperty stylusPointProperty);
    internal StylusPointPropertyInfo GetPropertyInfo(Guid guid);
    internal int GetPropertyIndex(Guid guid);
    public ReadOnlyCollection`1<StylusPointPropertyInfo> GetStylusPointProperties();
    internal Guid[] GetStylusPointPropertyIds();
    internal int GetInputArrayLengthPerPoint();
    internal int GetExpectedAdditionalDataCount();
    internal int GetOutputArrayLengthPerPoint();
    internal int get_ButtonCount();
    internal int GetButtonBitPosition(StylusPointProperty buttonProperty);
    internal bool get_ContainsTruePressure();
    internal int get_OriginalPressureIndex();
    public static bool AreCompatible(StylusPointDescription stylusPointDescription1, StylusPointDescription stylusPointDescription2);
    public static StylusPointDescription GetCommonDescription(StylusPointDescription stylusPointDescription, StylusPointDescription stylusPointDescriptionPreserveInfo);
    public bool IsSubsetOf(StylusPointDescription stylusPointDescriptionSuperset);
    private int IndexOf(Guid propertyId);
}
internal class System.Windows.Input.StylusPointer.PointerData : object {
    private POINTER_INFO _info;
    private POINTER_TOUCH_INFO _touchInfo;
    private POINTER_PEN_INFO _penInfo;
    private POINTER_INFO[] _history;
    [CompilerGeneratedAttribute]
private bool <IsValid>k__BackingField;
    internal bool IsValid { get; private set; }
    internal POINTER_INFO Info { get; }
    internal POINTER_TOUCH_INFO TouchInfo { get; }
    internal POINTER_PEN_INFO PenInfo { get; }
    internal POINTER_INFO[] History { get; }
    internal PointerData(UInt32 pointerId);
    [CompilerGeneratedAttribute]
internal bool get_IsValid();
    [CompilerGeneratedAttribute]
private void set_IsValid(bool value);
    internal POINTER_INFO get_Info();
    internal POINTER_TOUCH_INFO get_TouchInfo();
    internal POINTER_PEN_INFO get_PenInfo();
    internal POINTER_INFO[] get_History();
}
internal class System.Windows.Input.StylusPointer.PointerFlickEngine : object {
    private static double ThresholdTime;
    private static double ThresholdLength;
    private static double RelaxedFlickMinimumLength;
    private static double RelaxedFlickMaximumLengthRatio;
    private static double RelaxedFlickMinimumVelocity;
    private static double RelaxedFlickMaximumTime;
    private static double RelaxedFlickMaximumStationaryTime;
    private static double RelaxedFlickMaxStationaryDispX;
    private static double RelaxedFlickMaxStationaryDispY;
    private static double PreciseFlickMinimumLength;
    private static double PreciseFlickMaximumLengthRatio;
    private static double PreciseFlickMinimumVelocity;
    private static double PreciseFlickMaximumTime;
    private static double PreciseFlickMaximumStationaryTime;
    private static double PreciseFlickMaxStationaryDispX;
    private static double PreciseFlickMaxStationaryDispY;
    private bool _collectingData;
    private bool _analyzingData;
    private bool _lastPhysicalPointValid;
    private bool _movedEnoughFromPenDown;
    private bool _canDetectFlick;
    private bool _allowPressFlicks;
    private bool _previousFlickDataValid;
    private Point _flickStartPhysical;
    private Point _flickStartTablet;
    private Point _lastPhysicalPoint;
    private PointerStylusDevice _stylusDevice;
    private double _distance;
    private double _flickDirectionRadians;
    private double _flickPathDistance;
    private double _flickLength;
    private double _flickTimeLowVelocity;
    private double _flickMaximumStationaryTime;
    private double _flickMaximumLengthRatio;
    private double _flickMinimumLength;
    private double _flickMinimumVelocity;
    private double _flickMaximumStationaryDisplacementX;
    private double _flickMaximumStationaryDisplacementY;
    private double _tolerance;
    private FlickRecognitionData _previousFlickData;
    private Rect _drag;
    private double _timePeriod;
    private double _timePeriodAlpha;
    private int _previousTickCount;
    private double _elapsedTime;
    private double _flickTime;
    private double _flickMaximumTime;
    [CompilerGeneratedAttribute]
private FlickResult <Result>k__BackingField;
    internal FlickResult Result { get; private set; }
    internal PointerFlickEngine(PointerStylusDevice stylusDevice);
    [CompilerGeneratedAttribute]
internal FlickResult get_Result();
    [CompilerGeneratedAttribute]
private void set_Result(FlickResult value);
    internal void Reset();
    internal void ResetResult();
    internal void Update(RawStylusInputReport rsir, bool initial);
    private void UpdateTimePeriod(int tickCount, bool initial);
    private void ProcessPacket(RawStylusInputReport rsir, bool initial);
    private void Analyze(bool decide);
    private void AddPoint(Point physicalPoint, Point tabletPoint);
    private void CheckWithThreshold(Point physicalPoint);
    private void SetStableRect();
    private double RadiansToDegrees(double radians);
    private double Distance(Point p1, Point p2);
    private Point GetPhysicalCoordinates(Point tabletPoint);
    private bool SetTolerance(double tolerance);
}
internal class System.Windows.Input.StylusPointer.PointerInteractionEngine : object {
    private static int HoverActivationThresholdTicks;
    private static double DragThresholdInches;
    private static List`1<INTERACTION_CONTEXT_CONFIGURATION> DefaultConfiguration;
    private SecurityCriticalDataForSet`1<IntPtr> _interactionContext;
    private PointerStylusDevice _stylusDevice;
    private INTERACTION_CONTEXT_OUTPUT_CALLBACK _callbackDelegate;
    private bool _firedDrag;
    private bool _firedHold;
    private bool _firedFlick;
    private HoverState _hoverState;
    private UInt32 _hoverStartTicks;
    private PointerFlickEngine _flickEngine;
    [CompilerGeneratedAttribute]
private EventHandler`1<RawStylusSystemGestureInputReport> InteractionDetected;
    private bool _disposed;
    internal PointerInteractionEngine(PointerStylusDevice stylusDevice, List`1<INTERACTION_CONTEXT_CONFIGURATION> configuration);
    private static PointerInteractionEngine();
    [CompilerGeneratedAttribute]
internal void add_InteractionDetected(EventHandler`1<RawStylusSystemGestureInputReport> value);
    [CompilerGeneratedAttribute]
internal void remove_InteractionDetected(EventHandler`1<RawStylusSystemGestureInputReport> value);
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    internal void Update(RawStylusInputReport rsir);
    private void Callback(IntPtr clientData, INTERACTION_CONTEXT_OUTPUT& output);
    private void DetectFlick(RawStylusInputReport rsir);
    private void DetectHover();
    private SystemGesture DetectDragOrFlick(INTERACTION_CONTEXT_OUTPUT output);
}
internal class System.Windows.Input.StylusPointer.PointerLogic : StylusLogic {
    private bool _lastTapBarrelDown;
    private Point _lastTapPoint;
    private int _lastTapTimeTicks;
    private IInputElement _stylusCapture;
    private IInputElement _stylusOver;
    private DeferredElementTreeState _stylusOverTreeState;
    private DeferredElementTreeState _stylusCaptureWithinTreeState;
    private DependencyPropertyChangedEventHandler _overIsEnabledChangedEventHandler;
    private DependencyPropertyChangedEventHandler _overIsVisibleChangedEventHandler;
    private DependencyPropertyChangedEventHandler _overIsHitTestVisibleChangedEventHandler;
    private DispatcherOperationCallback _reevaluateStylusOverDelegate;
    private DispatcherOperation _reevaluateStylusOverOperation;
    private DependencyPropertyChangedEventHandler _captureIsEnabledChangedEventHandler;
    private DependencyPropertyChangedEventHandler _captureIsVisibleChangedEventHandler;
    private DependencyPropertyChangedEventHandler _captureIsHitTestVisibleChangedEventHandler;
    private DispatcherOperationCallback _reevaluateCaptureDelegate;
    private DispatcherOperation _reevaluateCaptureOperation;
    private bool _initialDeviceRefreshDone;
    private PointerTabletDeviceCollection _pointerDevices;
    private PointerStylusDevice _currentStylusDevice;
    private SecurityCriticalData`1<InputManager> _inputManager;
    private bool _inDragDrop;
    [CompilerGeneratedAttribute]
private Dictionary`2<PresentationSource, PointerStylusPlugInManager> <PlugInManagers>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsEnabled>k__BackingField;
    internal Dictionary`2<PresentationSource, PointerStylusPlugInManager> PlugInManagers { get; private set; }
    internal bool InDragDrop { get; }
    internal static bool IsEnabled { get; private set; }
    internal StylusDeviceBase CurrentStylusDevice { get; }
    internal TabletDeviceCollection TabletDevices { get; }
    internal PointerLogic(InputManager inputManager);
    private static PointerLogic();
    [CompilerGeneratedAttribute]
internal Dictionary`2<PresentationSource, PointerStylusPlugInManager> get_PlugInManagers();
    [CompilerGeneratedAttribute]
private void set_PlugInManagers(Dictionary`2<PresentationSource, PointerStylusPlugInManager> value);
    internal bool get_InDragDrop();
    [CompilerGeneratedAttribute]
internal static bool get_IsEnabled();
    [CompilerGeneratedAttribute]
private static void set_IsEnabled(bool value);
    private void PreNotifyInput(object sender, NotifyInputEventArgs e);
    private void PreProcessMouseInput(PreProcessInputEventArgs e, InputReportEventArgs input);
    private void PreProcessInput(object sender, PreProcessInputEventArgs e);
    private void PostProcessInput(object sender, ProcessInputEventArgs e);
    internal virtual StylusDeviceBase get_CurrentStylusDevice();
    internal virtual TabletDeviceCollection get_TabletDevices();
    internal virtual Point DeviceUnitsFromMeasureUnits(Point measurePoint);
    internal virtual Point MeasureUnitsFromDeviceUnits(Point devicePoint);
    internal virtual void UpdateStylusCapture(StylusDeviceBase stylusDevice, IInputElement oldStylusDeviceCapture, IInputElement newStylusDeviceCapture, int timestamp);
    internal virtual void UpdateOverProperty(StylusDeviceBase stylusDevice, IInputElement newOver);
    private void OnOverIsEnabledChanged(object sender, DependencyPropertyChangedEventArgs e);
    private void OnOverIsVisibleChanged(object sender, DependencyPropertyChangedEventArgs e);
    private void OnOverIsHitTestVisibleChanged(object sender, DependencyPropertyChangedEventArgs e);
    private void OnCaptureIsEnabledChanged(object sender, DependencyPropertyChangedEventArgs e);
    private void OnCaptureIsVisibleChanged(object sender, DependencyPropertyChangedEventArgs e);
    private void OnCaptureIsHitTestVisibleChanged(object sender, DependencyPropertyChangedEventArgs e);
    internal virtual void ReevaluateCapture(DependencyObject element, DependencyObject oldParent, bool isCoreParent);
    private object ReevaluateCaptureAsync(object arg);
    internal virtual void ReevaluateStylusOver(DependencyObject element, DependencyObject oldParent, bool isCoreParent);
    private object ReevaluateStylusOverAsync(object arg);
    protected virtual void OnTabletRemoved(UInt32 wisptisIndex);
    internal virtual void HandleMessage(WindowMessage msg, IntPtr wParam, IntPtr lParam);
    private bool IsTouchPromotionEvent(StylusEventArgs stylusEventArgs);
    private void PromoteRawToPreview(RawStylusInputReport report, ProcessInputEventArgs e);
    private void PromotePreviewToMain(ProcessInputEventArgs e);
    private void PromoteMainToOther(ProcessInputEventArgs e);
    private void PromoteMainToTouch(ProcessInputEventArgs e, StylusEventArgs stylusEventArgs);
    private void PromoteMainDownToTouch(PointerStylusDevice stylusDevice, StagingAreaInputItem stagingItem);
    private void PromoteMainMoveToTouch(PointerStylusDevice stylusDevice, StagingAreaInputItem stagingItem);
    private void PromoteMainUpToTouch(PointerStylusDevice stylusDevice, StagingAreaInputItem stagingItem);
    internal void SelectStylusDevice(PointerStylusDevice pointerStylusDevice, IInputElement newOver, bool updateOver);
    internal PointerStylusPlugInManager GetManagerForSource(PresentationSource source);
    private void UpdateTapCount(NotifyInputEventArgs args);
    private void GenerateGesture(RawStylusInputReport rawStylusInputReport, SystemGesture gesture);
}
internal class System.Windows.Input.StylusPointer.PointerStylusDevice : StylusDeviceBase {
    private int _tapCount;
    private StylusButtonCollection _stylusButtons;
    private PointerInteractionEngine _interactionEngine;
    private StylusPlugInCollection _stylusCapturePlugInCollection;
    private PointerLogic _pointerLogic;
    private IInputElement _stylusCapture;
    private CaptureMode _captureMode;
    private IInputElement _stylusOver;
    private Point _rawElementRelativePosition;
    private SecurityCriticalDataClass`1<PresentationSource> _inputSource;
    private int _lastEventTimeTicks;
    private PointerData _pointerData;
    private POINTER_DEVICE_CURSOR_INFO _cursorInfo;
    private PointerTabletDevice _tabletDevice;
    private StylusPointCollection _currentStylusPoints;
    [CompilerGeneratedAttribute]
private HwndPointerInputProvider <CurrentPointerProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private PointerTouchDevice <TouchDevice>k__BackingField;
    [CompilerGeneratedAttribute]
private StylusPlugInCollection <CurrentVerifiedTarget>k__BackingField;
    internal IInputElement Target { get; }
    internal PresentationSource ActiveSource { get; }
    internal POINTER_INFO CurrentPointerInfo { get; }
    internal HwndPointerInputProvider CurrentPointerProvider { get; private set; }
    internal UInt32 CursorId { get; }
    internal bool IsNew { get; }
    internal bool IsInContact { get; }
    internal bool IsPrimary { get; }
    internal bool IsFirstButton { get; }
    internal bool IsSecondButton { get; }
    internal bool IsThirdButton { get; }
    internal bool IsFourthButton { get; }
    internal bool IsFifthButton { get; }
    internal UInt32 TimeStamp { get; }
    internal bool IsDown { get; }
    internal bool IsUpdate { get; }
    internal bool IsUp { get; }
    internal bool HasCaptureChanged { get; }
    internal bool HasTransform { get; }
    internal PointerTouchDevice TouchDevice { get; private set; }
    internal StylusPlugInCollection CurrentVerifiedTarget { get; internal set; }
    internal PresentationSource CriticalActiveSource { get; }
    internal StylusButtonCollection StylusButtons { get; }
    internal StylusPoint RawStylusPoint { get; }
    internal bool IsValid { get; }
    internal IInputElement DirectlyOver { get; }
    internal IInputElement Captured { get; }
    internal TabletDevice TabletDevice { get; }
    internal PointerTabletDevice PointerTabletDevice { get; }
    internal string Name { get; }
    internal int Id { get; }
    internal bool InAir { get; }
    internal bool Inverted { get; }
    internal bool InRange { get; }
    internal int DoubleTapDeltaX { get; }
    internal int DoubleTapDeltaY { get; }
    internal int DoubleTapDeltaTime { get; }
    internal int TapCount { get; internal set; }
    internal CaptureMode CapturedMode { get; }
    internal PointerStylusDevice(PointerTabletDevice tabletDevice, POINTER_DEVICE_CURSOR_INFO cursorInfo);
    protected virtual void Dispose(bool disposing);
    internal virtual IInputElement get_Target();
    internal virtual PresentationSource get_ActiveSource();
    internal POINTER_INFO get_CurrentPointerInfo();
    [CompilerGeneratedAttribute]
internal HwndPointerInputProvider get_CurrentPointerProvider();
    [CompilerGeneratedAttribute]
private void set_CurrentPointerProvider(HwndPointerInputProvider value);
    internal UInt32 get_CursorId();
    internal bool get_IsNew();
    internal bool get_IsInContact();
    internal bool get_IsPrimary();
    internal bool get_IsFirstButton();
    internal bool get_IsSecondButton();
    internal bool get_IsThirdButton();
    internal bool get_IsFourthButton();
    internal bool get_IsFifthButton();
    internal UInt32 get_TimeStamp();
    internal bool get_IsDown();
    internal bool get_IsUpdate();
    internal bool get_IsUp();
    internal bool get_HasCaptureChanged();
    internal bool get_HasTransform();
    [CompilerGeneratedAttribute]
internal PointerTouchDevice get_TouchDevice();
    [CompilerGeneratedAttribute]
private void set_TouchDevice(PointerTouchDevice value);
    [CompilerGeneratedAttribute]
internal virtual StylusPlugInCollection get_CurrentVerifiedTarget();
    [CompilerGeneratedAttribute]
internal virtual void set_CurrentVerifiedTarget(StylusPlugInCollection value);
    internal virtual PresentationSource get_CriticalActiveSource();
    internal virtual StylusButtonCollection get_StylusButtons();
    internal virtual StylusPoint get_RawStylusPoint();
    internal virtual bool get_IsValid();
    internal virtual IInputElement get_DirectlyOver();
    internal virtual IInputElement get_Captured();
    internal virtual TabletDevice get_TabletDevice();
    internal PointerTabletDevice get_PointerTabletDevice();
    internal virtual string get_Name();
    internal virtual int get_Id();
    internal virtual bool get_InAir();
    internal virtual bool get_Inverted();
    internal virtual bool get_InRange();
    internal virtual int get_DoubleTapDeltaX();
    internal virtual int get_DoubleTapDeltaY();
    internal virtual int get_DoubleTapDeltaTime();
    internal virtual int get_TapCount();
    internal virtual void set_TapCount(int value);
    internal virtual CaptureMode get_CapturedMode();
    internal virtual bool Capture(IInputElement element, CaptureMode captureMode);
    internal virtual bool Capture(IInputElement element);
    internal virtual void Synchronize();
    internal virtual StylusPointCollection GetStylusPoints(IInputElement relativeTo);
    internal virtual StylusPointCollection GetStylusPoints(IInputElement relativeTo, StylusPointDescription subsetToReformatTo);
    internal virtual Point GetPosition(IInputElement relativeTo);
    internal virtual Point GetMouseScreenPosition(MouseDevice mouseDevice);
    internal virtual MouseButtonState GetMouseButtonState(MouseButton mouseButton, MouseDevice mouseDevice);
    internal void Update(HwndPointerInputProvider provider, PresentationSource inputSource, PointerData pointerData, RawStylusInputReport rsir);
    internal void UpdateInteractions(RawStylusInputReport rsir);
    private void HandleInteraction(object clientData, RawStylusSystemGestureInputReport originalReport);
    internal virtual StylusPlugInCollection GetCapturedPlugInCollection(Boolean& elementHasCapture);
    internal IInputElement FindTarget(PresentationSource inputSource, Point position);
    internal void ChangeStylusOver(IInputElement stylusOver);
    internal void ChangeStylusCapture(IInputElement stylusCapture, CaptureMode captureMode, int timestamp);
    internal virtual void UpdateEventStylusPoints(RawStylusInputReport report, bool resetIfNoOverride);
    internal GeneralTransform GetTabletToElementTransform(IInputElement relativeTo);
    [CompilerGeneratedAttribute]
private StylusPointDescription <Synchronize>b__104_0();
    [CompilerGeneratedAttribute]
private StylusPointDescription <HandleInteraction>b__112_0();
}
internal class System.Windows.Input.StylusPointer.PointerStylusPlugInCollection : StylusPlugInCollectionBase {
    private PointerStylusPlugInManager _manager;
    internal bool IsActiveForInput { get; }
    internal object SyncRoot { get; }
    internal virtual bool get_IsActiveForInput();
    internal virtual object get_SyncRoot();
    internal virtual void UpdateState(UIElement element);
    internal virtual void Unhook();
}
internal class System.Windows.Input.StylusPointer.PointerStylusPlugInManager : object {
    private static StylusPointDescription _mousePointDescription;
    internal SecurityCriticalData`1<PresentationSource> _inputSource;
    private List`1<StylusPlugInCollection> _plugInCollectionList;
    [ThreadStaticAttribute]
private static StylusPlugInCollection _activeMousePlugInCollection;
    private static StylusPointDescription MousePointDescription { get; }
    internal PointerStylusPlugInManager(PresentationSource source);
    internal void AddStylusPlugInCollection(StylusPlugInCollection pic);
    internal void RemoveStylusPlugInCollection(StylusPlugInCollection pic);
    private Matrix GetTabletToViewTransform(TabletDevice tablet);
    internal int FindZOrderIndex(StylusPlugInCollection spicAdding);
    internal StylusPlugInCollection TargetPlugInCollection(RawStylusInputReport inputReport);
    internal StylusPlugInCollection FindPlugInCollection(UIElement element);
    private StylusPlugInCollection HittestPlugInCollection(Point pt);
    internal void VerifyStylusPlugInCollectionTarget(RawStylusInputReport rawStylusInputReport);
    internal StylusPlugInCollection InvokeStylusPluginCollectionForMouse(RawStylusInputReport inputReport, IInputElement directlyOver, StylusPlugInCollection currentPlugInCollection);
    internal void InvokeStylusPluginCollection(RawStylusInputReport inputReport);
    internal static void InvokePlugInsForMouse(ProcessInputEventArgs e);
    private static StylusPointDescription get_MousePointDescription();
}
internal class System.Windows.Input.StylusPointer.PointerStylusPointPropertyInfoHelper : object {
    private static byte HidExponentMask;
    private static Dictionary`2<byte, short> _hidExponentMap;
    private static PointerStylusPointPropertyInfoHelper();
    internal static StylusPointPropertyInfo CreatePropertyInfo(POINTER_DEVICE_PROPERTY prop);
}
internal class System.Windows.Input.StylusPointer.PointerTabletDevice : TabletDeviceBase {
    private PointerTabletDeviceInfo _deviceInfo;
    private StylusDeviceCollection _stylusDevices;
    private Dictionary`2<UInt32, PointerStylusDevice> _stylusDeviceMap;
    internal PointerTabletDeviceInfo DeviceInfo { get; }
    internal IntPtr Device { get; }
    internal int DoubleTapDelta { get; }
    internal int DoubleTapDeltaTime { get; }
    internal Size DoubleTapSize { get; }
    internal StylusDeviceCollection StylusDevices { get; }
    internal IInputElement Target { get; }
    internal PresentationSource ActiveSource { get; }
    internal PointerTabletDevice(PointerTabletDeviceInfo deviceInfo);
    internal PointerTabletDeviceInfo get_DeviceInfo();
    internal IntPtr get_Device();
    internal int get_DoubleTapDelta();
    internal int get_DoubleTapDeltaTime();
    private void BuildStylusDevices();
    internal void UpdateSizeDeltas();
    internal virtual Size get_DoubleTapSize();
    internal virtual StylusDeviceCollection get_StylusDevices();
    internal virtual IInputElement get_Target();
    internal virtual PresentationSource get_ActiveSource();
    internal PointerStylusDevice GetStylusByCursorId(UInt32 cursorId);
}
internal class System.Windows.Input.StylusPointer.PointerTabletDeviceCollection : TabletDeviceCollection {
    private Dictionary`2<IntPtr, PointerTabletDevice> _tabletDeviceMap;
    [CompilerGeneratedAttribute]
private bool <IsValid>k__BackingField;
    internal bool IsValid { get; private set; }
    [CompilerGeneratedAttribute]
internal bool get_IsValid();
    [CompilerGeneratedAttribute]
private void set_IsValid(bool value);
    internal PointerTabletDevice GetByDeviceId(IntPtr deviceId);
    internal PointerStylusDevice GetStylusDeviceByCursorId(UInt32 cursorId);
    internal void Refresh();
}
internal class System.Windows.Input.StylusPointer.PointerTabletDeviceInfo : TabletDeviceInfo {
    private POINTER_DEVICE_INFO _deviceInfo;
    [CompilerGeneratedAttribute]
private POINTER_DEVICE_PROPERTY[] <SupportedPointerProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SupportedButtonPropertyIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private StylusButtonCollection <StylusButtons>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UsingFakePressure>k__BackingField;
    [CompilerGeneratedAttribute]
private RECT <DeviceRect>k__BackingField;
    [CompilerGeneratedAttribute]
private RECT <DisplayRect>k__BackingField;
    internal POINTER_DEVICE_PROPERTY[] SupportedPointerProperties { get; private set; }
    internal int SupportedButtonPropertyIndex { get; private set; }
    internal StylusButtonCollection StylusButtons { get; private set; }
    internal IntPtr Device { get; }
    internal bool UsingFakePressure { get; private set; }
    internal RECT DeviceRect { get; private set; }
    internal RECT DisplayRect { get; private set; }
    internal PointerTabletDeviceInfo(int id, POINTER_DEVICE_INFO deviceInfo);
    [CompilerGeneratedAttribute]
internal POINTER_DEVICE_PROPERTY[] get_SupportedPointerProperties();
    [CompilerGeneratedAttribute]
private void set_SupportedPointerProperties(POINTER_DEVICE_PROPERTY[] value);
    [CompilerGeneratedAttribute]
internal int get_SupportedButtonPropertyIndex();
    [CompilerGeneratedAttribute]
private void set_SupportedButtonPropertyIndex(int value);
    [CompilerGeneratedAttribute]
internal StylusButtonCollection get_StylusButtons();
    [CompilerGeneratedAttribute]
private void set_StylusButtons(StylusButtonCollection value);
    internal IntPtr get_Device();
    [CompilerGeneratedAttribute]
internal bool get_UsingFakePressure();
    [CompilerGeneratedAttribute]
private void set_UsingFakePressure(bool value);
    [CompilerGeneratedAttribute]
internal RECT get_DeviceRect();
    [CompilerGeneratedAttribute]
private void set_DeviceRect(RECT value);
    [CompilerGeneratedAttribute]
internal RECT get_DisplayRect();
    [CompilerGeneratedAttribute]
private void set_DisplayRect(RECT value);
    internal bool TryInitialize();
    private void InitializeDeviceType();
    private bool TryInitializeSupportedStylusPointProperties();
    private bool TryInitializeDeviceRects();
}
internal class System.Windows.Input.StylusPointer.PointerTouchDevice : StylusTouchDeviceBase {
    private PointerStylusDevice _stylusDevice;
    internal PointerTouchDevice(PointerStylusDevice stylusDevice);
    protected virtual void OnManipulationEnded(bool cancel);
    protected virtual void OnManipulationStarted();
    protected virtual double GetStylusPointWidthOrHeight(StylusPoint stylusPoint, bool isWidth);
    protected virtual void OnActivateImpl();
    protected virtual void OnDeactivateImpl();
}
public static class System.Windows.Input.StylusPointProperties : object {
    public static StylusPointProperty X;
    public static StylusPointProperty Y;
    public static StylusPointProperty Z;
    public static StylusPointProperty Width;
    public static StylusPointProperty Height;
    public static StylusPointProperty SystemTouch;
    public static StylusPointProperty PacketStatus;
    public static StylusPointProperty SerialNumber;
    public static StylusPointProperty NormalPressure;
    public static StylusPointProperty TangentPressure;
    public static StylusPointProperty ButtonPressure;
    public static StylusPointProperty XTiltOrientation;
    public static StylusPointProperty YTiltOrientation;
    public static StylusPointProperty AzimuthOrientation;
    public static StylusPointProperty AltitudeOrientation;
    public static StylusPointProperty TwistOrientation;
    public static StylusPointProperty PitchRotation;
    public static StylusPointProperty RollRotation;
    public static StylusPointProperty YawRotation;
    public static StylusPointProperty TipButton;
    public static StylusPointProperty BarrelButton;
    public static StylusPointProperty SecondaryTipButton;
    private static StylusPointProperties();
}
public class System.Windows.Input.StylusPointProperty : object {
    private Guid _id;
    private bool _isButton;
    public Guid Id { get; }
    public bool IsButton { get; }
    public StylusPointProperty(Guid identifier, bool isButton);
    protected StylusPointProperty(StylusPointProperty stylusPointProperty);
    private void Initialize(Guid identifier, bool isButton);
    public Guid get_Id();
    public bool get_IsButton();
    public virtual string ToString();
}
internal static class System.Windows.Input.StylusPointPropertyIds : object {
    public static Guid X;
    public static Guid Y;
    public static Guid Z;
    public static Guid Width;
    public static Guid Height;
    public static Guid SystemTouch;
    public static Guid PacketStatus;
    public static Guid SerialNumber;
    public static Guid NormalPressure;
    public static Guid TangentPressure;
    public static Guid ButtonPressure;
    public static Guid XTiltOrientation;
    public static Guid YTiltOrientation;
    public static Guid AzimuthOrientation;
    public static Guid AltitudeOrientation;
    public static Guid TwistOrientation;
    public static Guid PitchRotation;
    public static Guid RollRotation;
    public static Guid YawRotation;
    public static Guid TipButton;
    public static Guid BarrelButton;
    public static Guid SecondaryTipButton;
    private static Dictionary`2<HidUsagePage, Dictionary`2<HidUsage, Guid>> _hidToGuidMap;
    private static StylusPointPropertyIds();
    internal static Guid GetKnownGuid(HidUsagePage page, HidUsage usage);
    internal static bool IsKnownId(Guid guid);
    internal static string GetStringRepresentation(Guid guid);
    internal static bool IsKnownButton(Guid guid);
}
public class System.Windows.Input.StylusPointPropertyInfo : StylusPointProperty {
    private int _min;
    private int _max;
    private float _resolution;
    private StylusPointPropertyUnit _unit;
    public int Minimum { get; }
    public int Maximum { get; }
    public float Resolution { get; internal set; }
    public StylusPointPropertyUnit Unit { get; }
    public StylusPointPropertyInfo(StylusPointProperty stylusPointProperty);
    public StylusPointPropertyInfo(StylusPointProperty stylusPointProperty, int minimum, int maximum, StylusPointPropertyUnit unit, float resolution);
    public int get_Minimum();
    public int get_Maximum();
    public float get_Resolution();
    internal void set_Resolution(float value);
    public StylusPointPropertyUnit get_Unit();
    internal static bool AreCompatible(StylusPointPropertyInfo stylusPointPropertyInfo1, StylusPointPropertyInfo stylusPointPropertyInfo2);
}
internal static class System.Windows.Input.StylusPointPropertyInfoDefaults : object {
    internal static StylusPointPropertyInfo X;
    internal static StylusPointPropertyInfo Y;
    internal static StylusPointPropertyInfo Z;
    internal static StylusPointPropertyInfo Width;
    internal static StylusPointPropertyInfo Height;
    internal static StylusPointPropertyInfo SystemTouch;
    internal static StylusPointPropertyInfo PacketStatus;
    internal static StylusPointPropertyInfo SerialNumber;
    internal static StylusPointPropertyInfo NormalPressure;
    internal static StylusPointPropertyInfo TangentPressure;
    internal static StylusPointPropertyInfo ButtonPressure;
    internal static StylusPointPropertyInfo XTiltOrientation;
    internal static StylusPointPropertyInfo YTiltOrientation;
    internal static StylusPointPropertyInfo AzimuthOrientation;
    internal static StylusPointPropertyInfo AltitudeOrientation;
    internal static StylusPointPropertyInfo TwistOrientation;
    internal static StylusPointPropertyInfo PitchRotation;
    internal static StylusPointPropertyInfo RollRotation;
    internal static StylusPointPropertyInfo YawRotation;
    internal static StylusPointPropertyInfo TipButton;
    internal static StylusPointPropertyInfo BarrelButton;
    internal static StylusPointPropertyInfo SecondaryTipButton;
    internal static StylusPointPropertyInfo DefaultValue;
    internal static StylusPointPropertyInfo DefaultButton;
    private static StylusPointPropertyInfoDefaults();
    internal static StylusPointPropertyInfo GetStylusPointPropertyInfoDefault(StylusPointProperty stylusPointProperty);
}
public enum System.Windows.Input.StylusPointPropertyUnit : Enum {
    public int value__;
    public static StylusPointPropertyUnit None;
    public static StylusPointPropertyUnit Inches;
    public static StylusPointPropertyUnit Centimeters;
    public static StylusPointPropertyUnit Degrees;
    public static StylusPointPropertyUnit Radians;
    public static StylusPointPropertyUnit Seconds;
    public static StylusPointPropertyUnit Pounds;
    public static StylusPointPropertyUnit Grams;
}
internal static class System.Windows.Input.StylusPointPropertyUnitHelper : object {
    private static UInt32 UNIT_MASK;
    private static Dictionary`2<UInt32, StylusPointPropertyUnit> _pointerUnitMap;
    private static StylusPointPropertyUnitHelper();
    internal static Nullable`1<StylusPointPropertyUnit> FromPointerUnit(UInt32 pointerUnit);
    internal static bool IsDefined(StylusPointPropertyUnit unit);
}
public class System.Windows.Input.StylusSystemGestureEventArgs : StylusEventArgs {
    private SystemGesture _id;
    private int _buttonState;
    private int _gestureX;
    private int _gestureY;
    public SystemGesture SystemGesture { get; }
    internal int ButtonState { get; }
    internal int GestureX { get; }
    internal int GestureY { get; }
    public StylusSystemGestureEventArgs(StylusDevice stylusDevice, int timestamp, SystemGesture systemGesture);
    internal StylusSystemGestureEventArgs(StylusDevice stylusDevice, int timestamp, SystemGesture systemGesture, int gestureX, int gestureY, int buttonState);
    public SystemGesture get_SystemGesture();
    internal int get_ButtonState();
    internal int get_GestureX();
    internal int get_GestureY();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.StylusSystemGestureEventHandler : MulticastDelegate {
    public StylusSystemGestureEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, StylusSystemGestureEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, StylusSystemGestureEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal abstract class System.Windows.Input.StylusTouchDeviceBase : TouchDevice {
    [CompilerGeneratedAttribute]
private bool <PromotingToOther>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DownHandled>k__BackingField;
    [CompilerGeneratedAttribute]
private StylusDeviceBase <StylusDevice>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPrimary>k__BackingField;
    [ThreadStaticAttribute]
private static int _activeDeviceCount;
    private TouchAction _lastAction;
    private StylusPointDescription _stylusPointDescription;
    internal static double CentimetersPerInch;
    public bool PromotingToOther { get; protected set; }
    internal bool DownHandled { get; private set; }
    internal StylusDeviceBase StylusDevice { get; private set; }
    internal bool IsPrimary { get; private set; }
    internal static int ActiveDeviceCount { get; }
    internal StylusTouchDeviceBase(StylusDeviceBase stylusDevice);
    public virtual TouchPoint GetTouchPoint(IInputElement relativeTo);
    private Rect GetBounds(StylusPoint stylusPoint, Point position, IInputElement relativeTo);
    private Rect GetBounds(StylusPoint stylusPoint, Point position, IInputElement relativeTo, GeneralTransform elementToRoot, GeneralTransform rootToElement);
    protected abstract virtual double GetStylusPointWidthOrHeight(StylusPoint stylusPoint, bool isWidth);
    public virtual TouchPointCollection GetIntermediateTouchPoints(IInputElement relativeTo);
    private void GetRootTransforms(IInputElement relativeTo, GeneralTransform& elementToRoot, GeneralTransform& rootToElement);
    internal void ChangeActiveSource(PresentationSource activeSource);
    internal void OnActivate();
    protected abstract virtual void OnActivateImpl();
    internal void OnDeactivate();
    protected abstract virtual void OnDeactivateImpl();
    internal bool OnDown();
    internal bool OnMove();
    internal bool OnUp();
    [CompilerGeneratedAttribute]
public bool get_PromotingToOther();
    [CompilerGeneratedAttribute]
protected void set_PromotingToOther(bool value);
    [CompilerGeneratedAttribute]
internal bool get_DownHandled();
    [CompilerGeneratedAttribute]
private void set_DownHandled(bool value);
    [CompilerGeneratedAttribute]
internal StylusDeviceBase get_StylusDevice();
    [CompilerGeneratedAttribute]
private void set_StylusDevice(StylusDeviceBase value);
    [CompilerGeneratedAttribute]
internal bool get_IsPrimary();
    [CompilerGeneratedAttribute]
private void set_IsPrimary(bool value);
    internal static int get_ActiveDeviceCount();
}
internal class System.Windows.Input.StylusWisp.WispLogic : StylusLogic {
    [CompilerGeneratedAttribute]
private object <CurrentMousePromotionStylusDevice>k__BackingField;
    private Matrix _transformToDevice;
    private bool _transformInitialized;
    private SecurityCriticalData`1<InputManager> _inputManager;
    private DispatcherOperationCallback _dlgInputManagerProcessInput;
    private object _stylusEventQueueLock;
    private Queue`1<RawStylusInputReport> _queueStylusEvents;
    private int _lastStylusDeviceId;
    private bool _lastMouseMoveFromStylus;
    private MouseButtonState _mouseLeftButtonState;
    private MouseButtonState _mouseRightButtonState;
    private StylusPlugInCollection _activeMousePlugInCollection;
    private StylusPointDescription _mousePointDescription;
    private EventHandler _shutdownHandler;
    private bool _tabletDeviceCollectionDisposed;
    private WispTabletDeviceCollection _tabletDeviceCollection;
    private WispStylusDevice _currentStylusDevice;
    private int _lastInRangeTime;
    private bool _triedDeferringMouseMove;
    private RawMouseInputReport _deferredMouseMove;
    private DispatcherOperationCallback _processDeferredMouseMove;
    private RawMouseInputReport _mouseDeactivateInputReport;
    private bool _inputEnabled;
    private bool _updatingScreenMeasurements;
    private DispatcherOperationCallback _processDisplayChanged;
    private object __penContextsLock;
    private Dictionary`2<object, PenContexts> __penContextsMap;
    private object __stylusDeviceLock;
    private Dictionary`2<int, StylusDevice> __stylusDeviceMap;
    private bool _inDragDrop;
    private bool _leavingDragDrop;
    private bool _processingQueuedEvent;
    private bool _stylusDeviceInRange;
    private bool _seenRealMouseActivate;
    private int _lastKnownDeviceCount;
    private Dictionary`2<StylusDeviceBase, RawStylusInputReport> _lastMovesQueued;
    private Dictionary`2<StylusDeviceBase, RawStylusInputReport> _coalescedMoves;
    private object _coalesceLock;
    private IInputElement _stylusCapture;
    private IInputElement _stylusOver;
    private DeferredElementTreeState _stylusOverTreeState;
    private DeferredElementTreeState _stylusCaptureWithinTreeState;
    private DependencyPropertyChangedEventHandler _overIsEnabledChangedEventHandler;
    private DependencyPropertyChangedEventHandler _overIsVisibleChangedEventHandler;
    private DependencyPropertyChangedEventHandler _overIsHitTestVisibleChangedEventHandler;
    private DispatcherOperationCallback _reevaluateStylusOverDelegate;
    private DispatcherOperation _reevaluateStylusOverOperation;
    private DependencyPropertyChangedEventHandler _captureIsEnabledChangedEventHandler;
    private DependencyPropertyChangedEventHandler _captureIsVisibleChangedEventHandler;
    private DependencyPropertyChangedEventHandler _captureIsHitTestVisibleChangedEventHandler;
    private DispatcherOperationCallback _reevaluateCaptureDelegate;
    private DispatcherOperation _reevaluateCaptureOperation;
    internal object CurrentMousePromotionStylusDevice { get; internal set; }
    internal StylusPointDescription GetMousePointDescription { get; }
    internal int DoubleTapDelta { get; }
    internal int DoubleTapDeltaTime { get; }
    internal int CancelDelta { get; }
    internal TabletDeviceCollection TabletDevices { get; }
    internal WispTabletDeviceCollection WispTabletDevices { get; }
    internal StylusDeviceBase CurrentStylusDevice { get; }
    internal bool Enabled { get; }
    private DeferredElementTreeState StylusOverTreeState { get; }
    private DeferredElementTreeState StylusCaptureWithinTreeState { get; }
    internal WispLogic(InputManager inputManager);
    private void OnDispatcherShutdown(object sender, EventArgs e);
    internal void ProcessSystemEvent(PenContext penContext, int tabletDeviceId, int stylusDeviceId, int timestamp, SystemGesture systemGesture, int gestureX, int gestureY, int buttonState, PresentationSource inputSource);
    internal void ProcessInput(RawStylusActions actions, PenContext penContext, int tabletDeviceId, int stylusDeviceId, Int32[] data, int timestamp, PresentationSource inputSource);
    private void CoalesceAndQueueStylusEvent(RawStylusInputReport inputReport);
    private void ProcessInputReport(RawStylusInputReport inputReport);
    private void QueueStylusEvent(RawStylusInputReport report);
    internal object InputManagerProcessInput(object oInput);
    internal void InputManagerProcessInputEventArgs(InputEventArgs input);
    private bool DeferMouseMove(RawMouseInputReport mouseInputReport);
    internal object ProcessDeferredMouseMove(object oInput);
    private void SendDeferredMouseEvent(bool sendInput);
    private void PreProcessInput(object sender, PreProcessInputEventArgs e);
    private void PreNotifyInput(object sender, NotifyInputEventArgs e);
    private void PostProcessInput(object sender, ProcessInputEventArgs e);
    private void PromoteRawToPreview(RawStylusInputReport report, ProcessInputEventArgs e);
    private void PromotePreviewToMain(ProcessInputEventArgs e);
    private void PromoteMainToOther(ProcessInputEventArgs e);
    private static bool IsTouchPromotionEvent(StylusEventArgs stylusEventArgs);
    private static bool IsTouchStylusDevice(WispStylusDevice stylusDevice);
    private void PromoteMainToTouch(ProcessInputEventArgs e, StylusEventArgs stylusEventArgs);
    private void PromoteMainDownToTouch(WispStylusDevice stylusDevice, StagingAreaInputItem stagingItem);
    private void PromoteMainMoveToTouch(WispStylusDevice stylusDevice, StagingAreaInputItem stagingItem);
    private void PromoteMainUpToTouch(WispStylusDevice stylusDevice, StagingAreaInputItem stagingItem);
    internal void PromoteStoredItemsToMouse(WispStylusTouchDevice touchDevice);
    private bool ShouldPromoteToMouse(WispStylusDevice stylusDevice);
    [CompilerGeneratedAttribute]
internal object get_CurrentMousePromotionStylusDevice();
    [CompilerGeneratedAttribute]
internal void set_CurrentMousePromotionStylusDevice(object value);
    private void PromoteMainToMouse(StagingAreaInputItem stagingItem);
    private bool IgnoreGestureToMousePromotion(StylusSystemGestureEventArgs gestureArgs, WispStylusTouchDevice touchDevice);
    private void CallPlugInsForMouse(ProcessInputEventArgs e);
    internal StylusPointDescription get_GetMousePointDescription();
    internal MouseButtonState GetMouseLeftOrRightButtonState(bool leftButton);
    internal bool UpdateMouseButtonState(RawMouseActions actions);
    private void UpdateMouseState();
    private void UpdateIsStylusInRange(bool forceInRange);
    internal virtual void UpdateStylusCapture(StylusDeviceBase stylusDevice, IInputElement oldStylusDeviceCapture, IInputElement newStylusDeviceCapture, int timestamp);
    internal virtual void UpdateOverProperty(StylusDeviceBase stylusDevice, IInputElement newOver);
    private void OnOverIsEnabledChanged(object sender, DependencyPropertyChangedEventArgs e);
    private void OnOverIsVisibleChanged(object sender, DependencyPropertyChangedEventArgs e);
    private void OnOverIsHitTestVisibleChanged(object sender, DependencyPropertyChangedEventArgs e);
    private void OnCaptureIsEnabledChanged(object sender, DependencyPropertyChangedEventArgs e);
    private void OnCaptureIsVisibleChanged(object sender, DependencyPropertyChangedEventArgs e);
    private void OnCaptureIsHitTestVisibleChanged(object sender, DependencyPropertyChangedEventArgs e);
    internal virtual void ReevaluateStylusOver(DependencyObject element, DependencyObject oldParent, bool isCoreParent);
    private object ReevaluateStylusOverAsync(object arg);
    internal virtual void ReevaluateCapture(DependencyObject element, DependencyObject oldParent, bool isCoreParent);
    private object ReevaluateCaptureAsync(object arg);
    private bool IsValidStylusAction(RawStylusInputReport rawStylusInputReport);
    private void GenerateInRange(RawStylusInputReport rawStylusInputReport);
    internal virtual void HandleMessage(WindowMessage msg, IntPtr wParam, IntPtr lParam);
    internal void InvokeStylusPluginCollection(RawStylusInputReport inputReport);
    private void VerifyStylusPlugInCollectionTarget(RawStylusInputReport rawStylusInputReport);
    internal int get_DoubleTapDelta();
    internal int get_DoubleTapDeltaTime();
    internal int get_CancelDelta();
    private void GenerateGesture(RawStylusInputReport rawStylusInputReport, SystemGesture gesture);
    private void ProcessMouseMove(WispStylusDevice stylusDevice, int timestamp, bool isSynchronize);
    private void UpdateButtonStates(ProcessInputEventArgs e);
    private static bool InWindowClientRect(Point ptClient, PresentationSource inputSource);
    internal virtual TabletDeviceCollection get_TabletDevices();
    internal WispTabletDeviceCollection get_WispTabletDevices();
    internal virtual StylusDeviceBase get_CurrentStylusDevice();
    internal void RegisterStylusDeviceCore(StylusDevice stylusDevice);
    internal void UnregisterStylusDeviceCore(StylusDevice stylusDevice);
    internal WispStylusDevice FindStylusDevice(int stylusDeviceId);
    internal WispStylusDevice FindStylusDeviceWithLock(int stylusDeviceId);
    internal void SelectStylusDevice(WispStylusDevice wispStylusDevice, IInputElement newOver, bool updateOver);
    internal void EnableCore();
    internal bool get_Enabled();
    internal void RegisterHwndForInput(InputManager inputManager, PresentationSource inputSource);
    internal void UnRegisterHwndForInput(HwndSource hwndSource);
    internal PenContexts GetPenContextsFromHwnd(PresentationSource presentationSource);
    internal bool ShouldConsiderStylusInRange(RawMouseInputReport mouseInputReport);
    internal PenContext GetStylusPenContextForHwnd(PresentationSource presentationSource, int tabletDeviceId);
    private void OnDeviceChange();
    private void OnTabletAdded(UInt32 wisptisIndex);
    protected virtual void OnTabletRemoved(UInt32 wisptisIndex);
    private void OnTabletRemovedImpl(UInt32 wisptisIndex, bool isInternalCall);
    private void RefreshTablets();
    private int GetDeviceCount();
    private void OnScreenMeasurementsChanged();
    internal void OnWindowEnableChanged(IntPtr hwnd, bool disabled);
    internal object ProcessDisplayChanged(object oInput);
    internal Matrix GetTabletToViewTransform(TabletDevice tabletDevice);
    internal virtual Point DeviceUnitsFromMeasureUnits(Point measurePoint);
    internal virtual Point MeasureUnitsFromDeviceUnits(Point measurePoint);
    private DeferredElementTreeState get_StylusOverTreeState();
    private DeferredElementTreeState get_StylusCaptureWithinTreeState();
    [CompilerGeneratedAttribute]
private StylusPointDescription <CallPlugInsForMouse>b__32_0();
}
internal class System.Windows.Input.StylusWisp.WispStylusDevice : StylusDeviceBase {
    private WispTabletDevice _tabletDevice;
    private string _sName;
    private int _id;
    private bool _fInverted;
    private bool _fInRange;
    private StylusButtonCollection _stylusButtonCollection;
    private IInputElement _stylusOver;
    private IInputElement _stylusCapture;
    private CaptureMode _captureMode;
    private StylusPoint _rawPosition;
    private Point _rawElementRelativePosition;
    private StylusPointCollection _eventStylusPoints;
    private SecurityCriticalDataClass`1<PresentationSource> _inputSource;
    private SecurityCriticalDataClass`1<PenContext> _activePenContext;
    private bool _needToSendMouseDown;
    private Point _lastMouseScreenLocation;
    private Point _lastScreenLocation;
    private bool _fInAir;
    private bool _fLeftButtonDownTrigger;
    private bool _fGestureWasFired;
    private bool _fBlockMouseMoveChanges;
    private bool _fDetectedDrag;
    private MouseButtonState _promotedMouseState;
    private StylusPlugInCollection _nonVerifiedTarget;
    private StylusPlugInCollection _verifiedTarget;
    private object _rtiCaptureChanged;
    private StylusPlugInCollection _stylusCapturePlugInCollection;
    private Point _lastTapXY;
    private int _tapCount;
    private int _lastTapTime;
    private bool _lastTapBarrelDown;
    private bool _seenDoubleTapGesture;
    private bool _seenHoldEnterGesture;
    private bool _sawMouseButton1Down;
    private bool _ignoreStroke;
    private WispLogic _stylusLogic;
    private WispStylusTouchDevice _touchDevice;
    internal IInputElement Target { get; }
    internal bool IsValid { get; }
    internal PresentationSource ActiveSource { get; }
    internal PresentationSource CriticalActiveSource { get; }
    internal PenContext ActivePenContext { get; }
    internal StylusPlugInCollection CurrentNonVerifiedTarget { get; internal set; }
    internal StylusPlugInCollection CurrentVerifiedTarget { get; internal set; }
    internal IInputElement DirectlyOver { get; }
    internal IInputElement Captured { get; }
    internal CaptureMode CapturedMode { get; }
    internal TabletDevice TabletDevice { get; }
    internal string Name { get; }
    internal int Id { get; }
    internal StylusButtonCollection StylusButtons { get; }
    internal StylusPoint RawStylusPoint { get; }
    internal bool InAir { get; }
    internal bool Inverted { get; }
    internal bool InRange { get; }
    internal int TapCount { get; internal set; }
    internal int LastTapTime { get; internal set; }
    internal Point LastTapPoint { get; internal set; }
    internal bool LastTapBarrelDown { get; internal set; }
    internal int DoubleTapDeltaX { get; }
    internal int DoubleTapDeltaY { get; }
    internal int DoubleTapDeltaTime { get; }
    internal Point LastMouseScreenPoint { get; internal set; }
    internal bool SeenDoubleTapGesture { get; internal set; }
    internal bool SeenHoldEnterGesture { get; }
    internal bool GestureWasFired { get; }
    internal bool SentMouseDown { get; }
    internal bool DetectedDrag { get; }
    internal bool LeftIsActiveMouseButton { get; }
    internal bool IgnoreStroke { get; internal set; }
    internal WispStylusTouchDevice TouchDevice { get; }
    internal WispStylusDevice(WispTabletDevice tabletDevice, string sName, int id, bool fInverted, StylusButtonCollection stylusButtonCollection);
    protected virtual void Dispose(bool disposing);
    internal virtual IInputElement get_Target();
    internal virtual bool get_IsValid();
    internal virtual PresentationSource get_ActiveSource();
    internal virtual PresentationSource get_CriticalActiveSource();
    internal PenContext get_ActivePenContext();
    internal StylusPlugInCollection get_CurrentNonVerifiedTarget();
    internal void set_CurrentNonVerifiedTarget(StylusPlugInCollection value);
    internal virtual StylusPlugInCollection get_CurrentVerifiedTarget();
    internal virtual void set_CurrentVerifiedTarget(StylusPlugInCollection value);
    internal virtual IInputElement get_DirectlyOver();
    internal virtual IInputElement get_Captured();
    internal virtual CaptureMode get_CapturedMode();
    internal virtual bool Capture(IInputElement element, CaptureMode captureMode);
    internal virtual bool Capture(IInputElement element);
    internal virtual StylusPlugInCollection GetCapturedPlugInCollection(Boolean& elementHasCapture);
    internal virtual void Synchronize();
    internal void ChangeStylusCapture(IInputElement stylusCapture, CaptureMode captureMode, int timestamp);
    internal void ChangeStylusOver(IInputElement stylusOver);
    internal IInputElement FindTarget(PresentationSource inputSource, Point position);
    internal virtual TabletDevice get_TabletDevice();
    internal virtual string get_Name();
    public virtual string ToString();
    internal virtual int get_Id();
    internal virtual StylusPointCollection GetStylusPoints(IInputElement relativeTo);
    internal virtual StylusPointCollection GetStylusPoints(IInputElement relativeTo, StylusPointDescription subsetToReformatTo);
    internal virtual StylusButtonCollection get_StylusButtons();
    internal virtual Point GetPosition(IInputElement relativeTo);
    internal Point GetRawPosition(IInputElement relativeTo);
    internal virtual StylusPoint get_RawStylusPoint();
    internal virtual MouseButtonState GetMouseButtonState(MouseButton mouseButton, MouseDevice mouseDevice);
    internal virtual Point GetMouseScreenPosition(MouseDevice mouseDevice);
    private GeneralTransform GetTabletToElementTransform(IInputElement relativeTo);
    internal virtual bool get_InAir();
    internal virtual bool get_Inverted();
    internal virtual bool get_InRange();
    internal virtual void UpdateEventStylusPoints(RawStylusInputReport report, bool resetIfNoOverride);
    internal virtual int get_TapCount();
    internal virtual void set_TapCount(int value);
    internal int get_LastTapTime();
    internal void set_LastTapTime(int value);
    internal Point get_LastTapPoint();
    internal void set_LastTapPoint(Point value);
    internal bool get_LastTapBarrelDown();
    internal void set_LastTapBarrelDown(bool value);
    internal virtual int get_DoubleTapDeltaX();
    internal virtual int get_DoubleTapDeltaY();
    internal virtual int get_DoubleTapDeltaTime();
    internal void UpdateState(RawStylusInputReport report);
    private PresentationSource DetermineValidSource(PresentationSource inputSource, StylusPointCollection stylusPoints, PenContexts penContextsOfPoints);
    internal void UpdateInRange(bool inRange, PenContext penContext);
    internal void UpdateStateForSystemGesture(RawStylusSystemGestureInputReport report);
    private void UpdateStateForSystemGesture(SystemGesture gesture, RawStylusSystemGestureInputReport report);
    internal void PlayBackCachedDownInputReport(int timestamp);
    internal PresentationSource GetMousePresentationSource();
    internal RawMouseActions GetMouseActionsFromStylusEventAndPlaybackCachedDown(RoutedEvent stylusEvent, StylusEventArgs stylusArgs);
    internal void ResetStateForStylusUp();
    internal Point get_LastMouseScreenPoint();
    internal void set_LastMouseScreenPoint(Point value);
    internal bool get_SeenDoubleTapGesture();
    internal void set_SeenDoubleTapGesture(bool value);
    internal bool get_SeenHoldEnterGesture();
    internal bool get_GestureWasFired();
    internal bool get_SentMouseDown();
    internal bool get_DetectedDrag();
    internal bool get_LeftIsActiveMouseButton();
    internal void SetSawMouseButton1Down(bool sawMouseButton1Down);
    internal bool get_IgnoreStroke();
    internal void set_IgnoreStroke(bool value);
    internal WispStylusTouchDevice get_TouchDevice();
    internal void UpdateTouchActiveSource();
}
internal class System.Windows.Input.StylusWisp.WispStylusPlugInCollection : StylusPlugInCollectionBase {
    private PenContexts _penContexts;
    internal bool IsActiveForInput { get; }
    internal object SyncRoot { get; }
    internal PenContexts PenContexts { get; }
    internal virtual bool get_IsActiveForInput();
    internal virtual object get_SyncRoot();
    internal PenContexts get_PenContexts();
    internal virtual void UpdateState(UIElement element);
    internal virtual void Unhook();
}
internal class System.Windows.Input.StylusWisp.WispStylusTouchDevice : StylusTouchDeviceBase {
    private WispLogic _stylusLogic;
    private StagingAreaInputItemList _storedStagingAreaItems;
    private static object NoMousePromotionStylusDevice;
    internal StagingAreaInputItemList StoredStagingAreaItems { get; }
    internal WispStylusTouchDevice(StylusDeviceBase stylusDevice);
    private static WispStylusTouchDevice();
    protected virtual double GetStylusPointWidthOrHeight(StylusPoint stylusPoint, bool isWidth);
    protected virtual void OnManipulationStarted();
    protected virtual void OnManipulationEnded(bool cancel);
    internal StagingAreaInputItemList get_StoredStagingAreaItems();
    protected virtual void OnActivateImpl();
    protected virtual void OnDeactivateImpl();
}
public class System.Windows.Input.StylusWisp.WispTabletDeviceCollection : TabletDeviceCollection {
    private static int VistaMajorVersion;
    private TabletDevice[] _tablets;
    private UInt32 _indexMouseTablet;
    private bool _inUpdateTablets;
    private bool _hasUpdateTabletsBeenCalledReentrantly;
    private List`1<TabletDevice> _deferredTablets;
    internal List`1<TabletDevice> DeferredTablets { get; }
    internal static bool ShouldEnableTablets();
    private static bool IsWisptisRegistered();
    private static bool HasTabletDevices();
    internal void UpdateTablets();
    private void UpdateTabletsImpl();
    internal bool HandleTabletAdded(UInt32 wisptisIndex, UInt32& tabletIndexChanged);
    internal UInt32 HandleTabletRemoved(UInt32 wisptisIndex);
    private void AddTablet(UInt32 index, TabletDevice tabletDevice);
    private void RemoveTablet(UInt32 index);
    internal WispStylusDevice UpdateStylusDevices(int tabletId, int stylusId);
    internal void DisposeTablets();
    internal void DisposeDeferredTablets();
    internal PenContext[] CreateContexts(IntPtr hwnd, PenContexts contexts);
    internal List`1<TabletDevice> get_DeferredTablets();
}
public enum System.Windows.Input.SystemGesture : Enum {
    public int value__;
    public static SystemGesture None;
    public static SystemGesture Tap;
    public static SystemGesture RightTap;
    public static SystemGesture Drag;
    public static SystemGesture RightDrag;
    public static SystemGesture HoldEnter;
    public static SystemGesture HoldLeave;
    public static SystemGesture HoverEnter;
    public static SystemGesture HoverLeave;
    public static SystemGesture Flick;
    public static SystemGesture TwoFingerTap;
}
public static class System.Windows.Input.Tablet : object {
    public static TabletDevice CurrentTabletDevice { get; }
    public static TabletDeviceCollection TabletDevices { get; }
    public static TabletDevice get_CurrentTabletDevice();
    public static TabletDeviceCollection get_TabletDevices();
}
public class System.Windows.Input.TabletDevice : InputDevice {
    [CompilerGeneratedAttribute]
private TabletDeviceBase <TabletDeviceImpl>k__BackingField;
    internal TabletDeviceBase TabletDeviceImpl { get; internal set; }
    public IInputElement Target { get; }
    public PresentationSource ActiveSource { get; }
    public int Id { get; }
    public string Name { get; }
    public string ProductId { get; }
    public TabletHardwareCapabilities TabletHardwareCapabilities { get; }
    public ReadOnlyCollection`1<StylusPointProperty> SupportedStylusPointProperties { get; }
    public TabletDeviceType Type { get; }
    public StylusDeviceCollection StylusDevices { get; }
    internal TabletDevice(TabletDeviceBase impl);
    [CompilerGeneratedAttribute]
internal TabletDeviceBase get_TabletDeviceImpl();
    [CompilerGeneratedAttribute]
internal void set_TabletDeviceImpl(TabletDeviceBase value);
    public virtual IInputElement get_Target();
    public virtual PresentationSource get_ActiveSource();
    public int get_Id();
    public string get_Name();
    public string get_ProductId();
    public TabletHardwareCapabilities get_TabletHardwareCapabilities();
    public ReadOnlyCollection`1<StylusPointProperty> get_SupportedStylusPointProperties();
    public TabletDeviceType get_Type();
    public virtual string ToString();
    public StylusDeviceCollection get_StylusDevices();
    internal T As();
}
internal abstract class System.Windows.Input.TabletDeviceBase : DispatcherObject {
    private static UInt32 DefaultPropertyValue;
    [CompilerGeneratedAttribute]
private TabletDevice <TabletDevice>k__BackingField;
    protected bool _disposed;
    protected Size _doubleTapSize;
    protected bool _forceUpdateSizeDeltas;
    private MultiTouchSystemGestureLogic _multiTouchSystemGestureLogic;
    protected TabletDeviceInfo _tabletInfo;
    protected StylusPointDescription _stylusPointDescription;
    internal TabletDevice TabletDevice { get; private set; }
    internal IInputElement Target { get; }
    internal PresentationSource ActiveSource { get; }
    internal int Id { get; }
    internal string Name { get; }
    internal string ProductId { get; }
    internal TabletHardwareCapabilities TabletHardwareCapabilities { get; }
    internal ReadOnlyCollection`1<StylusPointProperty> SupportedStylusPointProperties { get; }
    internal TabletDeviceType Type { get; }
    internal StylusDeviceCollection StylusDevices { get; }
    internal Matrix TabletToScreen { get; }
    internal Size TabletSize { get; }
    internal Size ScreenSize { get; }
    internal Size DoubleTapSize { get; }
    internal StylusPointDescription StylusPointDescription { get; }
    protected TabletDeviceBase(TabletDeviceInfo info);
    [CompilerGeneratedAttribute]
internal TabletDevice get_TabletDevice();
    [CompilerGeneratedAttribute]
private void set_TabletDevice(TabletDevice value);
    internal T As();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    internal abstract virtual IInputElement get_Target();
    internal abstract virtual PresentationSource get_ActiveSource();
    internal int get_Id();
    internal string get_Name();
    internal string get_ProductId();
    internal TabletHardwareCapabilities get_TabletHardwareCapabilities();
    internal ReadOnlyCollection`1<StylusPointProperty> get_SupportedStylusPointProperties();
    internal TabletDeviceType get_Type();
    public virtual string ToString();
    internal abstract virtual StylusDeviceCollection get_StylusDevices();
    internal Nullable`1<SystemGesture> GenerateStaticGesture(RawStylusInputReport stylusInputReport);
    internal Matrix get_TabletToScreen();
    internal Size get_TabletSize();
    internal Size get_ScreenSize();
    internal abstract virtual Size get_DoubleTapSize();
    internal StylusPointDescription get_StylusPointDescription();
    protected static UInt32 GetPropertyValue(StylusPointPropertyInfo propertyInfo);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Input.TabletDeviceCollection : object {
    [CompilerGeneratedAttribute]
private List`1<TabletDevice> <TabletDevices>k__BackingField;
    private static TabletDeviceCollection _emptyTabletDeviceCollection;
    public int Count { get; }
    public TabletDevice Item { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    internal List`1<TabletDevice> TabletDevices { get; internal set; }
    internal static TabletDeviceCollection EmptyTabletDeviceCollection { get; }
    internal T As();
    public sealed virtual int get_Count();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(TabletDevice[] array, int index);
    public TabletDevice get_Item(int index);
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsSynchronized();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
internal List`1<TabletDevice> get_TabletDevices();
    [CompilerGeneratedAttribute]
internal void set_TabletDevices(List`1<TabletDevice> value);
    internal static TabletDeviceCollection get_EmptyTabletDeviceCollection();
}
internal class System.Windows.Input.TabletDeviceInfo : object {
    public SecurityCriticalDataClass`1<IPimcTablet3> PimcTablet;
    public int Id;
    public string Name;
    public string PlugAndPlayId;
    public TabletDeviceSizeInfo SizeInfo;
    public TabletHardwareCapabilities HardwareCapabilities;
    public TabletDeviceType DeviceType;
    public ReadOnlyCollection`1<StylusPointProperty> StylusPointProperties;
    public int PressureIndex;
    public StylusDeviceInfo[] StylusDevicesInfo;
    [CompilerGeneratedAttribute]
private UInt32 <WispTabletKey>k__BackingField;
    public UInt32 WispTabletKey { get; public set; }
    [CompilerGeneratedAttribute]
public UInt32 get_WispTabletKey();
    [CompilerGeneratedAttribute]
public void set_WispTabletKey(UInt32 value);
}
internal class System.Windows.Input.TabletDeviceSizeInfo : ValueType {
    public Size TabletSize;
    public Size ScreenSize;
    internal TabletDeviceSizeInfo(Size tabletSize, Size screenSize);
}
public enum System.Windows.Input.TabletDeviceType : Enum {
    public int value__;
    public static TabletDeviceType Stylus;
    public static TabletDeviceType Touch;
}
[FlagsAttribute]
public enum System.Windows.Input.TabletHardwareCapabilities : Enum {
    public int value__;
    public static TabletHardwareCapabilities None;
    public static TabletHardwareCapabilities Integrated;
    public static TabletHardwareCapabilities StylusMustTouch;
    public static TabletHardwareCapabilities HardProximity;
    public static TabletHardwareCapabilities StylusHasPhysicalIds;
    public static TabletHardwareCapabilities SupportsPressure;
}
public class System.Windows.Input.TextComposition : DispatcherObject {
    private InputManager _inputManager;
    private InputDevice _inputDevice;
    private string _resultText;
    private string _compositionText;
    private string _systemText;
    private string _controlText;
    private string _systemCompositionText;
    private TextCompositionAutoComplete _autoComplete;
    private TextCompositionStage _stage;
    private IInputElement _source;
    [CLSCompliantAttribute("False")]
public string Text { get; protected set; }
    [CLSCompliantAttribute("False")]
public string CompositionText { get; protected set; }
    [CLSCompliantAttribute("False")]
public string SystemText { get; protected set; }
    [CLSCompliantAttribute("False")]
public string ControlText { get; protected set; }
    [CLSCompliantAttribute("False")]
public string SystemCompositionText { get; protected set; }
    public TextCompositionAutoComplete AutoComplete { get; }
    internal IInputElement Source { get; }
    internal InputDevice _InputDevice { get; }
    internal InputManager _InputManager { get; }
    internal TextCompositionStage Stage { get; internal set; }
    public TextComposition(InputManager inputManager, IInputElement source, string resultText);
    public TextComposition(InputManager inputManager, IInputElement source, string resultText, TextCompositionAutoComplete autoComplete);
    internal TextComposition(InputManager inputManager, IInputElement source, string resultText, TextCompositionAutoComplete autoComplete, InputDevice inputDevice);
    public virtual void Complete();
    public string get_Text();
    protected void set_Text(string value);
    public string get_CompositionText();
    protected void set_CompositionText(string value);
    public string get_SystemText();
    protected void set_SystemText(string value);
    public string get_ControlText();
    protected void set_ControlText(string value);
    public string get_SystemCompositionText();
    protected void set_SystemCompositionText(string value);
    public TextCompositionAutoComplete get_AutoComplete();
    internal void SetText(string resultText);
    internal void SetCompositionText(string compositionText);
    internal void MakeSystem();
    internal void MakeControl();
    internal void ClearTexts();
    internal IInputElement get_Source();
    internal InputDevice get__InputDevice();
    internal InputManager get__InputManager();
    internal TextCompositionStage get_Stage();
    internal void set_Stage(TextCompositionStage value);
}
public enum System.Windows.Input.TextCompositionAutoComplete : Enum {
    public int value__;
    public static TextCompositionAutoComplete Off;
    public static TextCompositionAutoComplete On;
}
public class System.Windows.Input.TextCompositionEventArgs : InputEventArgs {
    private TextComposition _composition;
    public TextComposition TextComposition { get; }
    public string Text { get; }
    public string SystemText { get; }
    public string ControlText { get; }
    public TextCompositionEventArgs(InputDevice inputDevice, TextComposition composition);
    public TextComposition get_TextComposition();
    public string get_Text();
    public string get_SystemText();
    public string get_ControlText();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.TextCompositionEventHandler : MulticastDelegate {
    public TextCompositionEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, TextCompositionEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, TextCompositionEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Input.TextCompositionManager : DispatcherObject {
    public static RoutedEvent PreviewTextInputStartEvent;
    public static RoutedEvent TextInputStartEvent;
    public static RoutedEvent PreviewTextInputUpdateEvent;
    public static RoutedEvent TextInputUpdateEvent;
    public static RoutedEvent PreviewTextInputEvent;
    public static RoutedEvent TextInputEvent;
    private InputManager _inputManager;
    private DeadCharTextComposition _deadCharTextComposition;
    private bool _altNumpadEntryMode;
    private int _altNumpadEntry;
    private AltNumpadConversionMode _altNumpadConversionMode;
    private TextComposition _altNumpadcomposition;
    private static bool _isHexNumpadRegistryChecked;
    private static bool _isHexNumpadEnabled;
    private static int EncodingBufferLen;
    private bool HexConversionMode { get; }
    private static bool IsHexNumpadEnabled { get; }
    internal TextCompositionManager(InputManager inputManager);
    private static TextCompositionManager();
    public static void AddPreviewTextInputStartHandler(DependencyObject element, TextCompositionEventHandler handler);
    public static void RemovePreviewTextInputStartHandler(DependencyObject element, TextCompositionEventHandler handler);
    public static void AddTextInputStartHandler(DependencyObject element, TextCompositionEventHandler handler);
    public static void RemoveTextInputStartHandler(DependencyObject element, TextCompositionEventHandler handler);
    public static void AddPreviewTextInputUpdateHandler(DependencyObject element, TextCompositionEventHandler handler);
    public static void RemovePreviewTextInputUpdateHandler(DependencyObject element, TextCompositionEventHandler handler);
    public static void AddTextInputUpdateHandler(DependencyObject element, TextCompositionEventHandler handler);
    public static void RemoveTextInputUpdateHandler(DependencyObject element, TextCompositionEventHandler handler);
    public static void AddPreviewTextInputHandler(DependencyObject element, TextCompositionEventHandler handler);
    public static void RemovePreviewTextInputHandler(DependencyObject element, TextCompositionEventHandler handler);
    public static void AddTextInputHandler(DependencyObject element, TextCompositionEventHandler handler);
    public static void RemoveTextInputHandler(DependencyObject element, TextCompositionEventHandler handler);
    public static bool StartComposition(TextComposition composition);
    public static bool UpdateComposition(TextComposition composition);
    public static bool CompleteComposition(TextComposition composition);
    private static bool UnsafeStartComposition(TextComposition composition);
    private static bool UnsafeUpdateComposition(TextComposition composition);
    private static bool UnsafeCompleteComposition(TextComposition composition);
    private static string GetCurrentOEMCPEncoding(int code);
    private static string CharacterEncoding(int cp, int code);
    private void PreProcessInput(object sender, PreProcessInputEventArgs e);
    private void PostProcessInput(object sender, ProcessInputEventArgs e);
    internal void CompleteDeadCharComposition();
    private bool CompleteDeadCharComposition(string inputText, bool isSystemCharacter, bool isControlCharacter);
    private bool EnterAltNumpadEntryMode(Key key);
    private bool HandleAltNumpadEntry(Key key, int scanCode, bool isExtendedKey);
    private int GetNewEntry(Key key, int scanCode);
    private static Byte[] ConvertCodeToByteArray(int codeEntry);
    private void ClearAltnumpadComposition();
    private bool get_HexConversionMode();
    private static bool get_IsHexNumpadEnabled();
}
internal enum System.Windows.Input.TextCompositionStage : Enum {
    public int value__;
    public static TextCompositionStage None;
    public static TextCompositionStage Started;
    public static TextCompositionStage Done;
}
internal class System.Windows.Input.TextServicesCompartment : object {
    private SecurityCriticalData`1<ITfCompartmentMgr> _compartmentmgr;
    private Guid _guid;
    private int _cookie;
    internal bool BooleanValue { get; internal set; }
    internal int IntValue { get; internal set; }
    internal object Value { get; internal set; }
    internal TextServicesCompartment(Guid guid, ITfCompartmentMgr compartmentmgr);
    internal void AdviseNotifySink(ITfCompartmentEventSink sink);
    internal void UnadviseNotifySink();
    internal ITfCompartment GetITfCompartment();
    internal bool get_BooleanValue();
    internal void set_BooleanValue(bool value);
    internal int get_IntValue();
    internal void set_IntValue(int value);
    internal object get_Value();
    internal void set_Value(object value);
}
internal class System.Windows.Input.TextServicesCompartmentContext : object {
    private Hashtable _compartmentTable;
    private Hashtable _globalcompartmentTable;
    private ITfCompartmentMgr _globalcompartmentmanager;
    internal static TextServicesCompartmentContext Current { get; }
    internal TextServicesCompartment GetCompartment(InputMethodStateType statetype);
    internal TextServicesCompartment GetThreadCompartment(Guid guid);
    internal TextServicesCompartment GetGlobalCompartment(Guid guid);
    internal static TextServicesCompartmentContext get_Current();
}
internal class System.Windows.Input.TextServicesCompartmentEventSink : object {
    private InputMethod _inputmethod;
    internal TextServicesCompartmentEventSink(InputMethod inputmethod);
    public sealed virtual void OnChange(Guid& rguid);
}
internal class System.Windows.Input.TextServicesContext : object {
    private DefaultTextStore _defaultTextStore;
    private bool _istimactivated;
    private SecurityCriticalDataClass`1<ITfThreadMgr> _threadManager;
    private SecurityCriticalData`1<int> _clientId;
    private SecurityCriticalDataClass`1<ITfDocumentMgr> _dimEmpty;
    internal static TextServicesContext DispatcherCurrent { get; }
    internal ITfThreadMgr ThreadManager { get; }
    private ITfDocumentMgr EmptyDocumentManager { get; }
    internal void Uninitialize(bool appDomainShutdown);
    internal bool Keystroke(int wParam, int lParam, KeyOp op);
    internal void RegisterTextStore(DefaultTextStore defaultTextStore);
    internal void SetFocusOnDefaultTextStore();
    internal void SetFocusOnEmptyDim();
    internal static TextServicesContext get_DispatcherCurrent();
    internal ITfThreadMgr get_ThreadManager();
    private void SetFocusOnDim(ITfDocumentMgr dim);
    private void StartTransitoryExtension();
    private void StopTransitoryExtension();
    private ITfDocumentMgr get_EmptyDocumentManager();
}
internal class System.Windows.Input.TextServicesManager : DispatcherObject {
    private InputManager _inputManager;
    internal TextServicesManager(InputManager inputManager);
    internal void Focus(DependencyObject focus);
    private void PreProcessInput(object sender, PreProcessInputEventArgs e);
    private void PostProcessInput(object sender, ProcessInputEventArgs e);
    private bool TextServicesKeystroke(TextServicesContext context, KeyEventArgs keyArgs, bool test);
    private bool IsSysKeyDown();
}
public static class System.Windows.Input.Touch : object {
    internal static RoutedEvent PreviewTouchDownEvent;
    internal static RoutedEvent TouchDownEvent;
    internal static RoutedEvent PreviewTouchMoveEvent;
    internal static RoutedEvent TouchMoveEvent;
    internal static RoutedEvent PreviewTouchUpEvent;
    internal static RoutedEvent TouchUpEvent;
    internal static RoutedEvent GotTouchCaptureEvent;
    internal static RoutedEvent LostTouchCaptureEvent;
    internal static RoutedEvent TouchEnterEvent;
    internal static RoutedEvent TouchLeaveEvent;
    [CompilerGeneratedAttribute]
private static TouchFrameEventHandler FrameReported;
    private static Touch();
    [CompilerGeneratedAttribute]
public static void add_FrameReported(TouchFrameEventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_FrameReported(TouchFrameEventHandler value);
    internal static void ReportFrame();
}
public enum System.Windows.Input.TouchAction : Enum {
    public int value__;
    public static TouchAction Down;
    public static TouchAction Move;
    public static TouchAction Up;
}
public abstract class System.Windows.Input.TouchDevice : InputDevice {
    [CompilerGeneratedAttribute]
private EventHandler Activated;
    [CompilerGeneratedAttribute]
private EventHandler Deactivated;
    [CompilerGeneratedAttribute]
private bool <PromotingToManipulation>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler Updated;
    private int _deviceId;
    private IInputElement _directlyOver;
    private IInputElement _captured;
    private CaptureMode _captureMode;
    private bool _isDown;
    private DispatcherOperation _reevaluateCapture;
    private DispatcherOperation _reevaluateOver;
    private DeferredElementTreeState _directlyOverTreeState;
    private DeferredElementTreeState _capturedWithinTreeState;
    private bool _isPrimary;
    private bool _isActive;
    private Action`2<DependencyObject, bool> _raiseTouchEnterOrLeaveAction;
    private bool _lastDownHandled;
    private bool _lastUpHandled;
    private bool _lastMoveHandled;
    private PresentationSource _activeSource;
    private InputManager _inputManager;
    private WeakReference _manipulatingElement;
    [ThreadStaticAttribute]
private static List`1<TouchDevice> _activeDevices;
    public int Id { get; }
    public bool IsActive { get; }
    public IInputElement Target { get; }
    public PresentationSource ActiveSource { get; }
    public IInputElement DirectlyOver { get; }
    public IInputElement Captured { get; }
    public CaptureMode CaptureMode { get; }
    private Action`2<DependencyObject, bool> RaiseTouchEnterOrLeaveAction { get; }
    internal bool PromotingToManipulation { get; private set; }
    private int System.Windows.Input.IManipulator.Id { get; }
    protected TouchDevice(int deviceId);
    private void AttachTouchDevice();
    private void DetachTouchDevice();
    public int get_Id();
    [CompilerGeneratedAttribute]
public void add_Activated(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Activated(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_Deactivated(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Deactivated(EventHandler value);
    public bool get_IsActive();
    public sealed virtual IInputElement get_Target();
    public sealed virtual PresentationSource get_ActiveSource();
    protected void SetActiveSource(PresentationSource activeSource);
    public IInputElement get_DirectlyOver();
    public abstract virtual TouchPoint GetTouchPoint(IInputElement relativeTo);
    public abstract virtual TouchPointCollection GetIntermediateTouchPoints(IInputElement relativeTo);
    private IInputElement CriticalHitTest(Point point, bool isSynchronize);
    private static void EnsureValid(IInputElement& element);
    private static IInputElement GlobalHitTest(Point pt, PresentationSource inputSource);
    private static IInputElement LocalHitTest(Point pt, PresentationSource inputSource);
    public IInputElement get_Captured();
    public CaptureMode get_CaptureMode();
    public bool Capture(IInputElement element);
    public bool Capture(IInputElement element, CaptureMode captureMode);
    private void UpdateReverseInheritedProperty(bool capture, IInputElement oldElement, IInputElement newElement);
    internal static void ReevaluateCapturedWithin(DependencyObject element, DependencyObject oldParent, bool isCoreParent);
    private void ReevaluateCapturedWithinAsync(DependencyObject element, DependencyObject oldParent, bool isCoreParent);
    private void OnReevaluateCapturedWithinAsync();
    private bool ValidateVisualForCapture(DependencyObject visual);
    private void OnReevaluateCapture(object sender, DependencyPropertyChangedEventArgs e);
    private static void CastInputElement(IInputElement element, UIElement& uiElement, ContentElement& contentElement, UIElement3D& uiElement3D);
    private void RaiseLostCapture(IInputElement oldCapture);
    private void RaiseGotCapture(IInputElement captured);
    protected virtual void OnCapture(IInputElement element, CaptureMode captureMode);
    protected bool ReportDown();
    protected bool ReportMove();
    protected bool ReportUp();
    protected void Activate();
    protected void Deactivate();
    public void Synchronize();
    protected virtual void OnManipulationEnded(bool cancel);
    protected virtual void OnManipulationStarted();
    private void OnHitTestInvalidatedAsync(object sender, EventArgs e);
    private bool UpdateDirectlyOver(bool isSynchronize);
    private void OnReevaluateDirectlyOver(object sender, DependencyPropertyChangedEventArgs e);
    internal static void ReevaluateDirectlyOver(DependencyObject element, DependencyObject oldParent, bool isCoreParent);
    private void ReevaluateDirectlyOverAsync(DependencyObject element, DependencyObject oldParent, bool isCoreParent);
    private void ChangeDirectlyOver(IInputElement newDirectlyOver);
    private Action`2<DependencyObject, bool> get_RaiseTouchEnterOrLeaveAction();
    private void RaiseTouchEnterOrLeave(DependencyObject element, bool isLeave);
    private TouchEventArgs CreateEventArgs(RoutedEvent routedEvent);
    private bool RaiseTouchDown();
    private bool RaiseTouchMove();
    private bool RaiseTouchUp();
    private void PostProcessInput(object sender, ProcessInputEventArgs e);
    private RoutedEvent PromotePreviewToMain(RoutedEvent routedEvent, Boolean& forManipulation);
    private UIElement GetManipulatableElement();
    private void PromoteMainToManipulation(UIElement manipulatableElement, TouchEventArgs touchEventArgs);
    [CompilerGeneratedAttribute]
internal bool get_PromotingToManipulation();
    [CompilerGeneratedAttribute]
private void set_PromotingToManipulation(bool value);
    private static void AddActiveDevice(TouchDevice device);
    private static void RemoveActiveDevice(TouchDevice device);
    internal static TouchPointCollection GetTouchPoints(IInputElement relativeTo);
    internal static TouchPoint GetPrimaryTouchPoint(IInputElement relativeTo);
    internal static void ReleaseAllCaptures(IInputElement element);
    internal static IEnumerable`1<TouchDevice> GetCapturedTouches(IInputElement element, bool includeWithin);
    internal static IEnumerable`1<TouchDevice> GetTouchesOver(IInputElement element, bool includeWithin);
    private static bool IsWithin(IInputElement parent, IInputElement child);
    private static IEnumerable`1<TouchDevice> GetCapturedOrOverTouches(IInputElement element, bool includeWithin, bool isCapture);
    private static bool AreAnyTouchesCapturedOrDirectlyOver(IInputElement element, bool isCapture);
    private sealed virtual override int System.Windows.Input.IManipulator.get_Id();
    private sealed virtual override Point System.Windows.Input.IManipulator.GetPosition(IInputElement relativeTo);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Updated(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Updated(EventHandler value);
    private void OnUpdated();
    private sealed virtual override void System.Windows.Input.IManipulator.ManipulationEnded(bool cancel);
    [CompilerGeneratedAttribute]
private object <ReevaluateCapturedWithinAsync>b__34_0(object args);
    [CompilerGeneratedAttribute]
private object <OnReevaluateCapture>b__37_0(object args);
    [CompilerGeneratedAttribute]
private object <ReevaluateDirectlyOverAsync>b__54_0(object args);
}
internal class System.Windows.Input.TouchesCapturedWithinProperty : ReverseInheritProperty {
    internal virtual void FireNotifications(UIElement uie, ContentElement ce, UIElement3D uie3D, bool oldValue);
}
internal class System.Windows.Input.TouchesOverProperty : ReverseInheritProperty {
    internal virtual void FireNotifications(UIElement uie, ContentElement ce, UIElement3D uie3D, bool oldValue);
}
public class System.Windows.Input.TouchEventArgs : InputEventArgs {
    public TouchDevice TouchDevice { get; }
    public TouchEventArgs(TouchDevice touchDevice, int timestamp);
    public TouchDevice get_TouchDevice();
    public TouchPoint GetTouchPoint(IInputElement relativeTo);
    public TouchPointCollection GetIntermediateTouchPoints(IInputElement relativeTo);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Input.TouchFrameEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private int <Timestamp>k__BackingField;
    public int Timestamp { get; private set; }
    internal TouchFrameEventArgs(int timestamp);
    [CompilerGeneratedAttribute]
public int get_Timestamp();
    [CompilerGeneratedAttribute]
private void set_Timestamp(int value);
    public TouchPointCollection GetTouchPoints(IInputElement relativeTo);
    public TouchPoint GetPrimaryTouchPoint(IInputElement relativeTo);
    public void SuspendMousePromotionUntilTouchUp();
}
public class System.Windows.Input.TouchFrameEventHandler : MulticastDelegate {
    public TouchFrameEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, TouchFrameEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, TouchFrameEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Input.TouchPoint : object {
    [CompilerGeneratedAttribute]
private TouchDevice <TouchDevice>k__BackingField;
    [CompilerGeneratedAttribute]
private Point <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private Rect <Bounds>k__BackingField;
    [CompilerGeneratedAttribute]
private TouchAction <Action>k__BackingField;
    public TouchDevice TouchDevice { get; private set; }
    public Point Position { get; private set; }
    public Rect Bounds { get; private set; }
    public Size Size { get; }
    public TouchAction Action { get; private set; }
    public TouchPoint(TouchDevice device, Point position, Rect bounds, TouchAction action);
    [CompilerGeneratedAttribute]
public TouchDevice get_TouchDevice();
    [CompilerGeneratedAttribute]
private void set_TouchDevice(TouchDevice value);
    [CompilerGeneratedAttribute]
public Point get_Position();
    [CompilerGeneratedAttribute]
private void set_Position(Point value);
    [CompilerGeneratedAttribute]
public Rect get_Bounds();
    [CompilerGeneratedAttribute]
private void set_Bounds(Rect value);
    public Size get_Size();
    [CompilerGeneratedAttribute]
public TouchAction get_Action();
    [CompilerGeneratedAttribute]
private void set_Action(TouchAction value);
    private sealed virtual override bool System.IEquatable<System.Windows.Input.TouchPoint>.Equals(TouchPoint other);
}
public class System.Windows.Input.TouchPointCollection : Collection`1<TouchPoint> {
}
internal static class System.Windows.Input.Tracing.StylusTraceLogger : object {
    private static string StartupEventTag;
    private static string ShutdownEventTag;
    private static string StatisticsTag;
    private static string ErrorTag;
    private static string DeviceConnectTag;
    private static string DeviceDisconnectTag;
    private static string ReentrancyTag;
    private static string ReentrancyRetryLimitTag;
    private static StylusTraceLogger();
    internal static void LogStartup();
    internal static void LogStatistics(StylusStatistics stylusData);
    internal static void LogReentrancyRetryLimitReached();
    internal static void LogError(string error);
    internal static void LogDeviceConnect(StylusDeviceInfo deviceInfo);
    internal static void LogDeviceDisconnect(int deviceId);
    internal static void LogReentrancy(string functionName);
    internal static void LogShutdown();
    private static void Requires(bool condition);
    private static void Log(string tag);
    private static void Log(string tag, T data);
}
internal class System.Windows.Input.Win32KeyboardDevice : KeyboardDevice {
    internal Win32KeyboardDevice(InputManager inputManager);
    protected virtual KeyStates GetKeyStatesFromSystem(Key key);
}
internal class System.Windows.Input.Win32MouseDevice : MouseDevice {
    internal Win32MouseDevice(InputManager inputManager);
    internal virtual MouseButtonState GetButtonStateFromSystem(MouseButton mouseButton);
}
internal class System.Windows.Input.WispTabletDevice : TabletDeviceBase {
    private PenThread _penThread;
    protected Size _cancelSize;
    private StylusDeviceCollection _stylusDeviceCollection;
    private bool _isDisposalPending;
    private int _queuedEventCount;
    internal IInputElement Target { get; }
    internal PresentationSource ActiveSource { get; }
    internal StylusDeviceCollection StylusDevices { get; }
    internal PenThread PenThread { get; }
    internal Size DoubleTapSize { get; }
    internal Size CancelSize { get; }
    internal bool IsDisposalPending { get; }
    internal bool CanDispose { get; }
    internal int QueuedEventCount { get; internal set; }
    internal UInt32 WispTabletKey { get; }
    internal WispTabletDevice(TabletDeviceInfo tabletInfo, PenThread penThread);
    protected virtual void Dispose(bool disposing);
    internal WispStylusDevice UpdateStylusDevices(int stylusId);
    internal virtual IInputElement get_Target();
    internal virtual PresentationSource get_ActiveSource();
    public virtual string ToString();
    internal virtual StylusDeviceCollection get_StylusDevices();
    internal PenContext CreateContext(IntPtr hwnd, PenContexts contexts);
    internal PenThread get_PenThread();
    internal void UpdateScreenMeasurements();
    internal virtual Size get_DoubleTapSize();
    internal Size get_CancelSize();
    internal void InvalidateSizeDeltas();
    internal bool AreSizeDeltasValid();
    internal void UpdateSizeDeltas(StylusPointDescription description, WispLogic stylusLogic);
    internal void DisposeOrDeferDisposal();
    internal bool get_IsDisposalPending();
    internal bool get_CanDispose();
    internal int get_QueuedEventCount();
    internal void set_QueuedEventCount(int value);
    internal UInt32 get_WispTabletKey();
}
public static class System.Windows.Interop.CursorInteropHelper : object {
    public static Cursor Create(SafeHandle cursorHandle);
    internal static Cursor CriticalCreate(SafeHandle cursorHandle);
}
public class System.Windows.Interop.D3DImage : ImageSource {
    public static DependencyProperty IsFrontBufferAvailableProperty;
    private static DependencyPropertyKey IsFrontBufferAvailablePropertyKey;
    internal MultiChannelResource _duceResource;
    private double _dpiX;
    private double _dpiY;
    private SafeMILHandle _pInteropDeviceBitmap;
    private BitmapSource _softwareCopy;
    private IntPtr _pUserSurfaceUnsafe;
    private bool _isSoftwareFallbackEnabled;
    private ManualResetEvent _canWriteEvent;
    private FrontBufferAvailableCallback _availableCallback;
    private DependencyPropertyChangedEventHandler _isFrontBufferAvailableChangedHandlers;
    private EventHandler _sendPresentDelegate;
    private WeakReference _listener;
    private UInt32 _lockCount;
    private UInt32 _pixelWidth;
    private UInt32 _pixelHeight;
    private UInt32 _version;
    private bool _isDirty;
    private bool _isWaitingForPresent;
    private bool _isChangePending;
    private bool _waitingForUpdateResourceBecauseBitmapChanged;
    public bool IsFrontBufferAvailable { get; }
    public int PixelWidth { get; }
    public int PixelHeight { get; }
    public double Width { get; }
    public double Height { get; }
    public ImageMetadata Metadata { get; }
    private static D3DImage();
    public D3DImage(double dpiX, double dpiY);
    protected virtual override void Finalize();
    public void SetBackBuffer(D3DResourceType backBufferType, IntPtr backBuffer);
    public void SetBackBuffer(D3DResourceType backBufferType, IntPtr backBuffer, bool enableSoftwareFallback);
    public void Lock();
    public bool TryLock(Duration timeout);
    public void Unlock();
    public void AddDirtyRect(Int32Rect dirtyRect);
    public bool get_IsFrontBufferAvailable();
    public void add_IsFrontBufferAvailableChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsFrontBufferAvailableChanged(DependencyPropertyChangedEventHandler value);
    public int get_PixelWidth();
    public int get_PixelHeight();
    public sealed virtual double get_Width();
    public sealed virtual double get_Height();
    public sealed virtual ImageMetadata get_Metadata();
    public D3DImage Clone();
    public D3DImage CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    protected sealed virtual bool FreezeCore(bool isChecking);
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected internal virtual BitmapSource CopyBackBuffer();
    private void CloneCommon(Freezable sourceFreezable);
    private void SubscribeToCommittingBatch();
    private void UnsubscribeFromCommittingBatch();
    private bool LockImpl(Duration timeout);
    private static void IsFrontBufferAvailablePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void SendPresent(object sender, EventArgs args);
    private object SetIsFrontBufferAvailable(object isAvailableVersionPair);
    private void Callback(bool isFrontBufferAvailable, UInt32 version);
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    private sealed virtual override void MS.Internal.IAppDomainShutdownListener.NotifyShutdown();
}
public enum System.Windows.Interop.D3DResourceType : Enum {
    public int value__;
    public static D3DResourceType IDirect3DSurface9;
}
internal class System.Windows.Interop.HwndAppCommandInputProvider : DispatcherObject {
    private SecurityCriticalDataClass`1<HwndSource> _source;
    private SecurityCriticalDataClass`1<InputProviderSite> _site;
    internal HwndAppCommandInputProvider(HwndSource source);
    public sealed virtual void Dispose();
    private sealed virtual override bool System.Windows.Input.IInputProvider.ProvidesInputForRootVisual(Visual v);
    private sealed virtual override void System.Windows.Input.IInputProvider.NotifyDeactivate();
    internal IntPtr FilterMessage(IntPtr hwnd, WindowMessage msg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    private static int GetAppCommand(IntPtr lParam);
    private static InputType GetDevice(IntPtr lParam);
}
internal class System.Windows.Interop.HwndKeyboardInputProvider : DispatcherObject {
    private int _msgTime;
    private SecurityCriticalDataClass`1<HwndSource> _source;
    private SecurityCriticalDataClass`1<InputProviderSite> _site;
    private IInputElement _restoreFocus;
    private IntPtr _restoreFocusWindow;
    private bool _active;
    private bool _partialActive;
    private bool _acquiringFocusOurselves;
    internal HwndKeyboardInputProvider(HwndSource source);
    public sealed virtual void Dispose();
    public void OnRootChanged(Visual oldRoot, Visual newRoot);
    private sealed virtual override bool System.Windows.Input.IInputProvider.ProvidesInputForRootVisual(Visual v);
    private sealed virtual override void System.Windows.Input.IInputProvider.NotifyDeactivate();
    private sealed virtual override bool System.Windows.Input.IKeyboardInputProvider.AcquireFocus(bool checkOnly);
    internal IntPtr FilterMessage(IntPtr hwnd, WindowMessage message, IntPtr wParam, IntPtr lParam, Boolean& handled);
    private void OnSetFocus(IntPtr hwnd);
    internal void ProcessKeyAction(MSG& msg, Boolean& handled);
    internal void ProcessTextInputAction(IntPtr hwnd, WindowMessage msg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    internal static int GetVirtualKey(IntPtr wParam, IntPtr lParam);
    internal static int GetScanCode(IntPtr wParam, IntPtr lParam);
    internal static bool IsExtendedKey(IntPtr lParam);
    [FriendAccessAllowedAttribute]
internal static ModifierKeys GetSystemModifierKeys();
    private RawKeyboardActions GetKeyUpKeyDown(WindowMessage msg);
    private void PossiblyDeactivate(IntPtr hwndFocus);
    private bool IsOurWindow(IntPtr hwnd);
    private IntPtr GetImmediateChildFor(IntPtr hwnd, IntPtr hwndRoot);
    private bool ReportInput(IntPtr hwnd, InputMode mode, int timestamp, RawKeyboardActions actions, int scanCode, bool isExtendedKey, bool isSystemKey, int virtualKey);
}
internal class System.Windows.Interop.HwndMouseInputProvider : DispatcherObject {
    private SecurityCriticalDataClass`1<HwndSource> _source;
    private SecurityCriticalDataClass`1<InputProviderSite> _site;
    private int _msgTime;
    private MOUSEMOVEPOINT _latestMovePoint;
    private MOUSEMOVEPOINT _previousMovePoint;
    private int _lastX;
    private int _lastY;
    private bool _tracking;
    private bool _active;
    private SetCursorState _setCursorState;
    private bool _haveCapture;
    private DispatcherOperation _queryCursorOperation;
    private bool _isDwmProcess;
    private TRACKMOUSEEVENT _tme;
    private static string PresentationFrameworkAssemblyFullName;
    private static DependencyProperty WindowChromeWorkerProperty;
    private static MethodInfo GetEffectiveClientAreaMI;
    internal HwndMouseInputProvider(HwndSource source);
    public sealed virtual void Dispose();
    private sealed virtual override bool System.Windows.Input.IInputProvider.ProvidesInputForRootVisual(Visual v);
    private sealed virtual override void System.Windows.Input.IInputProvider.NotifyDeactivate();
    private sealed virtual override bool System.Windows.Input.IMouseInputProvider.SetCursor(Cursor cursor);
    private sealed virtual override bool System.Windows.Input.IMouseInputProvider.CaptureMouse();
    private sealed virtual override void System.Windows.Input.IMouseInputProvider.ReleaseMouseCapture();
    private sealed virtual override int System.Windows.Input.IMouseInputProvider.GetIntermediatePoints(IInputElement relativeTo, Point[] points);
    internal IntPtr FilterMessage(IntPtr hwnd, WindowMessage msg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    private void PossiblyDeactivate(IntPtr hwndCapture, bool stillActiveIfOverSelf);
    private RECT GetEffectiveClientRect(IntPtr hwnd);
    private bool HasCustomChrome(HwndSource hwndSource, RECT& rcClient);
    private bool EnsureFrameworkAccessors(HwndSource hwndSource);
    private Assembly GetPresentationFrameworkFromHwndSource(HwndSource hwndSource);
    private void StartTracking(IntPtr hwnd);
    private void StopTracking(IntPtr hwnd);
    private IntPtr MakeLPARAM(int high, int low);
    private bool IsOurWindow(IntPtr hwnd);
    private bool IsOurWindowImpl(IntPtr hwnd, HwndSource& hwndSource);
    private bool ReportInput(IntPtr hwnd, InputMode mode, int timestamp, RawMouseActions actions, int x, int y, int wheel);
    private void RecordMouseMove(int x, int y, int timestamp);
    [CompilerGeneratedAttribute]
private object <FilterMessage>b__8_0(object sender);
}
internal class System.Windows.Interop.HwndPanningFeedback : object {
    private int _deviceOffsetX;
    private int _deviceOffsetY;
    private bool _inInertia;
    private DispatcherOperation _updatePanningOperation;
    private bool _isProvidingPanningFeedback;
    private HwndSource _hwndSource;
    private static bool IsSupported { get; }
    private HandleRef Handle { get; }
    public HwndPanningFeedback(HwndSource hwndSource);
    private static bool get_IsSupported();
    private HandleRef get_Handle();
    public void UpdatePanningFeedback(Vector totalOverpanOffset, bool inInertia);
    private object OnUpdatePanningFeedback(object args);
    public void EndPanningFeedback(bool animateBack);
}
internal class System.Windows.Interop.HwndPointerInputProvider : DispatcherObject {
    private bool _disposed;
    private SecurityCriticalDataClass`1<HwndSource> _source;
    private SecurityCriticalDataClass`1<InputProviderSite> _site;
    private SecurityCriticalDataClass`1<PointerLogic> _pointerLogic;
    private PointerStylusDevice _currentStylusDevice;
    private PointerTabletDevice _currentTabletDevice;
    [CompilerGeneratedAttribute]
private bool <IsWindowEnabled>k__BackingField;
    internal bool IsWindowEnabled { get; private set; }
    internal HwndPointerInputProvider(HwndSource source);
    [CompilerGeneratedAttribute]
internal bool get_IsWindowEnabled();
    [CompilerGeneratedAttribute]
private void set_IsWindowEnabled(bool value);
    protected virtual override void Finalize();
    private void Dispose(bool disposing);
    public sealed virtual void Dispose();
    private UInt32 GetPointerId(IntPtr wParam);
    private Int32[] GenerateRawStylusData(PointerData pointerData, PointerTabletDevice tabletDevice);
    private bool ProcessMessage(UInt32 pointerId, RawStylusActions action, int timestamp);
    private void GetOriginOffsetsLogical(Int32& originOffsetX, Int32& originOffsetY);
    private bool UpdateCurrentTabletAndStylus(IntPtr deviceId, UInt32 cursorId);
    private sealed virtual override IntPtr System.Windows.Interop.IStylusInputProvider.FilterMessage(IntPtr hwnd, WindowMessage msg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    public sealed virtual bool ProvidesInputForRootVisual(Visual v);
    public sealed virtual void NotifyDeactivate();
    [CompilerGeneratedAttribute]
private StylusPointDescription <ProcessMessage>b__16_0();
}
public class System.Windows.Interop.HwndSource : PresentationSource {
    [CompilerGeneratedAttribute]
private EventHandler Disposed;
    [CompilerGeneratedAttribute]
private EventHandler SizeToContentChanged;
    [CompilerGeneratedAttribute]
private HwndDpiChangedEventHandler DpiChanged;
    [CompilerGeneratedAttribute]
private bool <IsInExclusiveMenuMode>k__BackingField;
    [CompilerGeneratedAttribute]
private AutoResizedEventHandler AutoResized;
    private object _constructionParameters;
    private bool _isDisposed;
    private bool _isDisposing;
    private bool _inRealHwndDispose;
    private bool _adjustSizingForNonClientArea;
    private bool _treatAncestorsAsNonClientArea;
    private bool _myOwnUpdate;
    private bool _isWindowInMinimizeState;
    private int _registeredDropTargetCount;
    private SizeToContent _sizeToContent;
    private Nullable`1<Size> _previousSize;
    private HwndWrapper _hwndWrapper;
    private HwndTarget _hwndTarget;
    private SecurityCriticalDataForSet`1<Visual> _rootVisual;
    [CompilerGeneratedAttribute]
private HwndSourceHook _hooks;
    private SecurityCriticalDataClass`1<HwndMouseInputProvider> _mouse;
    private SecurityCriticalDataClass`1<HwndKeyboardInputProvider> _keyboard;
    private SecurityCriticalDataClass`1<IStylusInputProvider> _stylus;
    private SecurityCriticalDataClass`1<HwndAppCommandInputProvider> _appCommand;
    private WeakEventDispatcherShutdown _weakShutdownHandler;
    private WeakEventPreprocessMessage _weakPreprocessMessageHandler;
    private WeakEventPreprocessMessage _weakMenuModeMessageHandler;
    private static LocalDataStoreSlot _threadSlot;
    private RestoreFocusMode _restoreFocusMode;
    [ThreadStaticAttribute]
private static Nullable`1<bool> _defaultAcquireHwndFocusInMenuMode;
    private bool _acquireHwndFocusInMenuMode;
    private MSG _lastKeyboardMessage;
    private List`1<HwndSourceKeyboardInputSite> _keyboardInputSinkChildren;
    private IKeyboardInputSite _keyboardInputSite;
    private HwndWrapperHook _layoutHook;
    private HwndWrapperHook _inputHook;
    private HwndWrapperHook _hwndTargetHook;
    private HwndWrapperHook _publicHook;
    [ThreadStaticAttribute]
internal static bool _eatCharMessages;
    public bool IsDisposed { get; }
    public Visual RootVisual { get; public set; }
    unknown Visual RootVisualInternal {private set; }
    public IEnumerable`1<IKeyboardInputSink> ChildKeyboardInputSinks { get; }
    public HwndTarget CompositionTarget { get; }
    internal bool IsInExclusiveMenuMode { get; private set; }
    public IntPtr Handle { get; }
    internal IntPtr CriticalHandle { get; }
    internal HwndWrapper HwndWrapper { get; }
    internal bool HasCapture { get; }
    internal bool IsHandleNull { get; }
    public SizeToContent SizeToContent { get; public set; }
    public bool UsesPerPixelOpacity { get; }
    protected IKeyboardInputSite KeyboardInputSiteCore { get; protected set; }
    private IKeyboardInputSite System.Windows.Interop.IKeyboardInputSink.KeyboardInputSite { get; private set; }
    public RestoreFocusMode RestoreFocusMode { get; }
    public static bool DefaultAcquireHwndFocusInMenuMode { get; public set; }
    public bool AcquireHwndFocusInMenuMode { get; }
    private IKeyboardInputSink ChildSinkWithFocus { get; }
    private bool IsUsable { get; }
    private bool HasFocus { get; }
    private static ThreadDataBlob PerThreadData { get; }
    private static HwndSource();
    public HwndSource(int classStyle, int style, int exStyle, int x, int y, string name, IntPtr parent);
    public HwndSource(int classStyle, int style, int exStyle, int x, int y, int width, int height, string name, IntPtr parent, bool adjustSizingForNonClientArea);
    public HwndSource(int classStyle, int style, int exStyle, int x, int y, int width, int height, string name, IntPtr parent);
    public HwndSource(HwndSourceParameters parameters);
    private void Initialize(HwndSourceParameters parameters);
    public sealed virtual void Dispose();
    public void AddHook(HwndSourceHook hook);
    public void RemoveHook(HwndSourceHook hook);
    internal virtual IInputProvider GetInputProvider(Type inputDevice);
    internal void ChangeDpi(HwndDpiChangedEventArgs e);
    internal void ChangeDpi(HwndDpiChangedAfterParentEventArgs e);
    protected virtual void OnDpiChanged(HwndDpiChangedEventArgs e);
    private void OnDpiChangedAfterParent(HwndDpiChangedAfterParentEventArgs e);
    [CompilerGeneratedAttribute]
public void add_Disposed(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Disposed(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_SizeToContentChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_SizeToContentChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_DpiChanged(HwndDpiChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_DpiChanged(HwndDpiChangedEventHandler value);
    public virtual bool get_IsDisposed();
    public virtual Visual get_RootVisual();
    public virtual void set_RootVisual(Visual value);
    private void set_RootVisualInternal(Visual value);
    [IteratorStateMachineAttribute("System.Windows.Interop.HwndSource/<get_ChildKeyboardInputSinks>d__31")]
public IEnumerable`1<IKeyboardInputSink> get_ChildKeyboardInputSinks();
    public static HwndSource FromHwnd(IntPtr hwnd);
    internal static HwndSource CriticalFromHwnd(IntPtr hwnd);
    public HwndTarget get_CompositionTarget();
    protected virtual CompositionTarget GetCompositionTargetCore();
    internal virtual void OnEnterMenuMode();
    internal virtual void OnLeaveMenuMode();
    [CompilerGeneratedAttribute]
internal bool get_IsInExclusiveMenuMode();
    [CompilerGeneratedAttribute]
private void set_IsInExclusiveMenuMode(bool value);
    [CompilerGeneratedAttribute]
public void add_AutoResized(AutoResizedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_AutoResized(AutoResizedEventHandler value);
    private void OnLayoutUpdated(object obj, EventArgs args);
    private void Resize(Size newSize);
    internal void ShowSystemMenu();
    internal Point TransformToDevice(Point pt);
    internal Point TransformFromDevice(Point pt);
    private RECT AdjustWindowSize(Size newSize);
    private void RoundDeviceSize(Point& size);
    public sealed virtual IntPtr get_Handle();
    [FriendAccessAllowedAttribute]
internal IntPtr get_CriticalHandle();
    internal HwndWrapper get_HwndWrapper();
    internal bool get_HasCapture();
    internal bool get_IsHandleNull();
    public HandleRef CreateHandleRef();
    public SizeToContent get_SizeToContent();
    public void set_SizeToContent(SizeToContent value);
    private bool IsLayoutActive();
    private void SetLayoutSize();
    public bool get_UsesPerPixelOpacity();
    private Size GetSizeFromHwnd();
    private IntPtr HwndTargetFilterMessage(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    private IntPtr LayoutFilterMessage(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    private void Process_WM_WINDOWPOSCHANGING(UIElement rootUIElement, IntPtr hwnd, WindowMessage msg, IntPtr wParam, IntPtr lParam);
    private void Process_WM_SIZE(UIElement rootUIElement, IntPtr hwnd, WindowMessage msg, IntPtr wParam, IntPtr lParam);
    private void DisableSizeToContent(UIElement rootUIElement, IntPtr hwnd);
    private void GetNonClientRect(RECT& rc);
    private IntPtr InputFilterMessage(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    private IntPtr PublicHooksFilterMessage(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    private void DisposeStylusInputProvider();
    private void OnPreprocessMessageThunk(MSG& msg, Boolean& handled);
    private object OnPreprocessMessage(object param);
    protected IKeyboardInputSite RegisterKeyboardInputSinkCore(IKeyboardInputSink sink);
    private sealed virtual override IKeyboardInputSite System.Windows.Interop.IKeyboardInputSink.RegisterKeyboardInputSink(IKeyboardInputSink sink);
    protected virtual bool TranslateAcceleratorCore(MSG& msg, ModifierKeys modifiers);
    private sealed virtual override bool System.Windows.Interop.IKeyboardInputSink.TranslateAccelerator(MSG& msg, ModifierKeys modifiers);
    protected virtual bool TabIntoCore(TraversalRequest request);
    private sealed virtual override bool System.Windows.Interop.IKeyboardInputSink.TabInto(TraversalRequest request);
    protected IKeyboardInputSite get_KeyboardInputSiteCore();
    protected void set_KeyboardInputSiteCore(IKeyboardInputSite value);
    private sealed virtual override IKeyboardInputSite System.Windows.Interop.IKeyboardInputSink.get_KeyboardInputSite();
    private sealed virtual override void System.Windows.Interop.IKeyboardInputSink.set_KeyboardInputSite(IKeyboardInputSite value);
    protected virtual bool OnMnemonicCore(MSG& msg, ModifierKeys modifiers);
    private sealed virtual override bool System.Windows.Interop.IKeyboardInputSink.OnMnemonic(MSG& msg, ModifierKeys modifiers);
    protected virtual bool TranslateCharCore(MSG& msg, ModifierKeys modifiers);
    private sealed virtual override bool System.Windows.Interop.IKeyboardInputSink.TranslateChar(MSG& msg, ModifierKeys modifiers);
    protected virtual bool HasFocusWithinCore();
    private sealed virtual override bool System.Windows.Interop.IKeyboardInputSink.HasFocusWithin();
    public RestoreFocusMode get_RestoreFocusMode();
    public static bool get_DefaultAcquireHwndFocusInMenuMode();
    public static void set_DefaultAcquireHwndFocusInMenuMode(bool value);
    public bool get_AcquireHwndFocusInMenuMode();
    internal void CriticalUnregisterKeyboardInputSink(HwndSourceKeyboardInputSite site);
    private IKeyboardInputSink get_ChildSinkWithFocus();
    internal bool CriticalTranslateAccelerator(MSG& msg, ModifierKeys modifiers);
    internal static object RestoreCharMessages(object unused);
    internal bool IsRepeatedKeyboardMessage(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam);
    private void OnHwndDisposed(object sender, EventArgs args);
    private void OnNoMoreWindowMessages();
    private void OnShutdownFinished(object sender, EventArgs args);
    private void Dispose(bool disposing);
    private void CheckDisposed(bool verifyAccess);
    private bool get_IsUsable();
    private bool get_HasFocus();
    private static bool IsValidSizeToContent(SizeToContent value);
    private static ThreadDataBlob get_PerThreadData();
    [CompilerGeneratedAttribute]
private void add__hooks(HwndSourceHook value);
    [CompilerGeneratedAttribute]
private void remove__hooks(HwndSourceHook value);
}
public class System.Windows.Interop.HwndSourceHook : MulticastDelegate {
    public HwndSourceHook(object object, IntPtr method);
    public virtual IntPtr Invoke(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    public virtual IAsyncResult BeginInvoke(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, Boolean& handled, AsyncCallback callback, object object);
    public virtual IntPtr EndInvoke(Boolean& handled, IAsyncResult result);
}
internal class System.Windows.Interop.HwndSourceKeyboardInputSite : object {
    private HwndSource _source;
    private IKeyboardInputSink _sink;
    private UIElement _sinkElement;
    private IKeyboardInputSink System.Windows.Interop.IKeyboardInputSite.Sink { get; }
    public HwndSourceKeyboardInputSite(HwndSource source, IKeyboardInputSink sink);
    private sealed virtual override void System.Windows.Interop.IKeyboardInputSite.Unregister();
    internal void CriticalUnregister();
    private sealed virtual override IKeyboardInputSink System.Windows.Interop.IKeyboardInputSite.get_Sink();
    private sealed virtual override bool System.Windows.Interop.IKeyboardInputSite.OnNoMoreTabStops(TraversalRequest request);
}
public class System.Windows.Interop.HwndSourceParameters : ValueType {
    private int _classStyleBits;
    private int _styleBits;
    private int _extendedStyleBits;
    private int _x;
    private int _y;
    private int _width;
    private int _height;
    private string _name;
    private IntPtr _parent;
    private HwndSourceHook _hwndSourceHook;
    private bool _adjustSizingForNonClientArea;
    private bool _hasAssignedSize;
    private bool _usesPerPixelOpacity;
    private bool _usesPerPixelTransparency;
    private Nullable`1<bool> _treatAsInputRoot;
    private bool _treatAncestorsAsNonClientArea;
    private Nullable`1<RestoreFocusMode> _restoreFocusMode;
    private Nullable`1<bool> _acquireHwndFocusInMenuMode;
    private static bool _platformSupportsTransparentChildWindows;
    public int WindowClassStyle { get; public set; }
    public int WindowStyle { get; public set; }
    public int ExtendedWindowStyle { get; public set; }
    public int PositionX { get; public set; }
    public int PositionY { get; public set; }
    public int Width { get; public set; }
    public int Height { get; public set; }
    public bool HasAssignedSize { get; }
    public string WindowName { get; public set; }
    public IntPtr ParentWindow { get; public set; }
    public HwndSourceHook HwndSourceHook { get; public set; }
    public bool AdjustSizingForNonClientArea { get; public set; }
    public bool TreatAncestorsAsNonClientArea { get; public set; }
    public bool UsesPerPixelOpacity { get; public set; }
    public bool UsesPerPixelTransparency { get; public set; }
    public RestoreFocusMode RestoreFocusMode { get; public set; }
    public bool AcquireHwndFocusInMenuMode { get; public set; }
    public bool TreatAsInputRoot { get; public set; }
    internal bool EffectivePerPixelOpacity { get; }
    internal static bool PlatformSupportsTransparentChildWindows { get; }
    public HwndSourceParameters(string name);
    public HwndSourceParameters(string name, int width, int height);
    private static HwndSourceParameters();
    public virtual int GetHashCode();
    public int get_WindowClassStyle();
    public void set_WindowClassStyle(int value);
    public int get_WindowStyle();
    public void set_WindowStyle(int value);
    public int get_ExtendedWindowStyle();
    public void set_ExtendedWindowStyle(int value);
    public void SetPosition(int x, int y);
    public int get_PositionX();
    public void set_PositionX(int value);
    public int get_PositionY();
    public void set_PositionY(int value);
    public void SetSize(int width, int height);
    public int get_Width();
    public void set_Width(int value);
    public int get_Height();
    public void set_Height(int value);
    public bool get_HasAssignedSize();
    public string get_WindowName();
    public void set_WindowName(string value);
    public IntPtr get_ParentWindow();
    public void set_ParentWindow(IntPtr value);
    public HwndSourceHook get_HwndSourceHook();
    public void set_HwndSourceHook(HwndSourceHook value);
    public bool get_AdjustSizingForNonClientArea();
    public void set_AdjustSizingForNonClientArea(bool value);
    public bool get_TreatAncestorsAsNonClientArea();
    public void set_TreatAncestorsAsNonClientArea(bool value);
    public bool get_UsesPerPixelOpacity();
    public void set_UsesPerPixelOpacity(bool value);
    public bool get_UsesPerPixelTransparency();
    public void set_UsesPerPixelTransparency(bool value);
    public RestoreFocusMode get_RestoreFocusMode();
    public void set_RestoreFocusMode(RestoreFocusMode value);
    public bool get_AcquireHwndFocusInMenuMode();
    public void set_AcquireHwndFocusInMenuMode(bool value);
    public bool get_TreatAsInputRoot();
    public void set_TreatAsInputRoot(bool value);
    internal bool get_EffectivePerPixelOpacity();
    public static bool op_Equality(HwndSourceParameters a, HwndSourceParameters b);
    public static bool op_Inequality(HwndSourceParameters a, HwndSourceParameters b);
    public virtual bool Equals(object obj);
    public bool Equals(HwndSourceParameters obj);
    internal static bool get_PlatformSupportsTransparentChildWindows();
    internal static void SetPlatformSupportsTransparentChildWindowsForTestingOnly(bool value);
}
internal class System.Windows.Interop.HwndStylusInputProvider : DispatcherObject {
    private static UInt32 TABLET_PRESSANDHOLD_DISABLED;
    private static UInt32 TABLET_TAPFEEDBACK_DISABLED;
    private static UInt32 TABLET_TOUCHUI_FORCEON;
    private static UInt32 TABLET_TOUCHUI_FORCEOFF;
    private static UInt32 TABLET_FLICKS_DISABLED;
    private static int MultiTouchEnabledFlag;
    private SecurityCriticalDataClass`1<WispLogic> _stylusLogic;
    private SecurityCriticalDataClass`1<HwndSource> _source;
    private SecurityCriticalDataClass`1<InputProviderSite> _site;
    internal HwndStylusInputProvider(HwndSource source);
    public sealed virtual void Dispose();
    private sealed virtual override bool System.Windows.Input.IInputProvider.ProvidesInputForRootVisual(Visual v);
    private sealed virtual override void System.Windows.Input.IInputProvider.NotifyDeactivate();
    private sealed virtual override IntPtr System.Windows.Interop.IStylusInputProvider.FilterMessage(IntPtr hwnd, WindowMessage msg, IntPtr wParam, IntPtr lParam, Boolean& handled);
}
public class System.Windows.Interop.HwndTarget : CompositionTarget {
    private static object s_lockObject;
    private static WindowMessage s_updateWindowSettings;
    private static WindowMessage s_needsRePresentOnWake;
    private static WindowMessage s_DisplayDevicesAvailabilityChanged;
    private static IntPtr Handled;
    private static IntPtr Unhandled;
    private MatrixTransform _worldTransform;
    private DpiScale2 _currentDpiScale;
    private SecurityCriticalDataForSet`1<RenderMode> _renderModePreference;
    private HWND _hWnd;
    private RECT _hwndClientRectInScreenCoords;
    private RECT _hwndWindowRectInScreenCoords;
    private Color _backgroundColor;
    private MultiChannelResource _compositionTarget;
    private bool _isRenderTargetEnabled;
    private bool _usesPerPixelOpacity;
    private int _disableCookie;
    private bool _isMinimized;
    private bool _isSessionDisconnected;
    private bool _isSuspended;
    private bool _userInputResize;
    private bool _needsRePresentOnWake;
    private bool _hasRePresentedSinceWake;
    private bool _displayDevicesAvailable;
    private bool _wasWmPaintProcessingDeferred;
    private Nullable`1<int> _sessionId;
    private DateTime _lastWakeOrUnlockEvent;
    private static double _allowedPresentFailureDelay;
    private DispatcherTimer _restoreDT;
    private bool _windowPosChanging;
    [CompilerGeneratedAttribute]
private static Nullable`1<PROCESS_DPI_AWARENESS> <ProcessDpiAwareness>k__BackingField;
    [CompilerGeneratedAttribute]
private static Nullable`1<PROCESS_DPI_AWARENESS> <AppManifestProcessDpiAwareness>k__BackingField;
    [CompilerGeneratedAttribute]
private DpiAwarenessContextValue <DpiAwarenessContext>k__BackingField;
    [ThreadStaticAttribute]
private static NotificationWindowHelper _notificationWindowHelper;
    public RenderMode RenderMode { get; public set; }
    private static Nullable`1<PROCESS_DPI_AWARENESS> ProcessDpiAwareness { get; private set; }
    private static Nullable`1<PROCESS_DPI_AWARENESS> AppManifestProcessDpiAwareness { get; private set; }
    private DpiAwarenessContextValue DpiAwarenessContext { get; private set; }
    internal static bool IsPerMonitorDpiScalingSupportedOnCurrentPlatform { get; }
    internal static bool IsPerMonitorDpiScalingEnabled { get; }
    internal static Nullable`1<bool> IsProcessPerMonitorDpiAware { get; }
    internal static Nullable`1<bool> IsProcessSystemAware { get; }
    internal static Nullable`1<bool> IsProcessUnaware { get; }
    internal bool IsWindowPerMonitorDpiAware { get; }
    unknown Visual RootVisual {public set; }
    public Matrix TransformToDevice { get; }
    public Matrix TransformFromDevice { get; }
    public Color BackgroundColor { get; public set; }
    public bool UsesPerPixelOpacity { get; internal set; }
    private static HwndTarget();
    public HwndTarget(IntPtr hwnd);
    private void InitializeDpiAwarenessAndDpiScales();
    private static void GetProcessDpiAwareness(IntPtr hWnd, PROCESS_DPI_AWARENESS& appManifestProcessDpiAwareness, PROCESS_DPI_AWARENESS& processDpiAwareness);
    private static DpiScale2 GetDpiScaleForWindow(IntPtr hWnd);
    private static HandleRef NormalizeWindow(HandleRef hWnd, bool normalizeChildWindows, bool normalizePopups);
    private void AttachToHwnd(IntPtr hwnd);
    internal static int VisualTarget_AttachToHwnd(IntPtr hwnd);
    internal static int VisualTarget_DetachFromHwnd(IntPtr hwnd);
    internal void InvalidateRenderMode();
    public RenderMode get_RenderMode();
    public void set_RenderMode(RenderMode value);
    public virtual void Dispose();
    internal virtual void CreateUCEResources(Channel channel, Channel outOfBandChannel);
    internal virtual void ReleaseUCEResources(Channel channel, Channel outOfBandChannel);
    private bool HandleDpiChangedMessage(IntPtr wParam, IntPtr lParam);
    private bool HandleDpiChangedAfterParentMessage();
    internal IntPtr HandleMessage(WindowMessage msg, IntPtr wparam, IntPtr lparam);
    private void OnMonitorPowerEvent(object sender, MonitorPowerEventArgs eventArgs);
    private void OnMonitorPowerEvent(object sender, bool powerOn, bool paintOnWake);
    private void InvalidateSelf(object s, EventArgs args);
    private void DoPaint();
    internal AutomationPeer EnsureAutomationPeer(Visual root);
    internal static AutomationPeer EnsureAutomationPeer(Visual root, IntPtr handle);
    private static IntPtr CriticalHandleWMGetobject(IntPtr wparam, IntPtr lparam, Visual root, IntPtr handle);
    internal void AdjustForRightToLeft(RECT& rc, HandleRef handleRef);
    private bool OnSettingChange(int firstParam);
    private void InvalidateRect(RECT rcDirty);
    private void OnResize();
    private void UpdateWindowAndClientCoordinates();
    private void UpdateWorldTransform(DpiScale2 dpiScale);
    private void PropagateDpiChangeToRootVisual(DpiScale2 oldDpi, DpiScale2 newDpi);
    private void NotifyListenersOfWorldTransformAndClipBoundsChanged();
    internal void OnDpiChanged(HwndDpiChangedEventArgs e);
    internal void OnDpiChangedAfterParent(HwndDpiChangedAfterParentEventArgs e);
    private void NotifyRendererOfDpiChange(bool afterParent);
    private void RecursiveUpdateDpiFlagAndInvalidateMeasure(DependencyObject d, DpiRecursiveChangeArgs args);
    private void OnWindowPosChanging(IntPtr lParam);
    private void OnWindowPosChanged(IntPtr lParam);
    private void UpdateWindowPos(IntPtr lParam);
    private void OnShowWindow(bool enableRenderTarget);
    [CompilerGeneratedAttribute]
private static Nullable`1<PROCESS_DPI_AWARENESS> get_ProcessDpiAwareness();
    [CompilerGeneratedAttribute]
private static void set_ProcessDpiAwareness(Nullable`1<PROCESS_DPI_AWARENESS> value);
    [CompilerGeneratedAttribute]
private static Nullable`1<PROCESS_DPI_AWARENESS> get_AppManifestProcessDpiAwareness();
    [CompilerGeneratedAttribute]
private static void set_AppManifestProcessDpiAwareness(Nullable`1<PROCESS_DPI_AWARENESS> value);
    [CompilerGeneratedAttribute]
private DpiAwarenessContextValue get_DpiAwarenessContext();
    [CompilerGeneratedAttribute]
private void set_DpiAwarenessContext(DpiAwarenessContextValue value);
    internal static bool get_IsPerMonitorDpiScalingSupportedOnCurrentPlatform();
    internal static bool get_IsPerMonitorDpiScalingEnabled();
    internal static Nullable`1<bool> get_IsProcessPerMonitorDpiAware();
    internal static Nullable`1<bool> get_IsProcessSystemAware();
    internal static Nullable`1<bool> get_IsProcessUnaware();
    internal bool get_IsWindowPerMonitorDpiAware();
    private void OnEnterSizeMove();
    private void OnExitSizeMove();
    private void UpdateWindowSettings();
    private void UpdateWindowSettings(bool enableRenderTarget);
    private void UpdateWindowSettings(bool enableRenderTarget, Nullable`1<ChannelSet> channelSet);
    public virtual void set_RootVisual(Visual value);
    public virtual Matrix get_TransformToDevice();
    public virtual Matrix get_TransformFromDevice();
    public Color get_BackgroundColor();
    public void set_BackgroundColor(Color value);
    public bool get_UsesPerPixelOpacity();
    internal void set_UsesPerPixelOpacity(bool value);
    private void EnsureNotificationWindow();
}
public static class System.Windows.Interop.Imaging : object {
    public static BitmapSource CreateBitmapSourceFromHBitmap(IntPtr bitmap, IntPtr palette, Int32Rect sourceRect, BitmapSizeOptions sizeOptions);
    internal static BitmapSource CriticalCreateBitmapSourceFromHBitmap(IntPtr bitmap, IntPtr palette, Int32Rect sourceRect, BitmapSizeOptions sizeOptions, WICBitmapAlphaChannelOption alphaOptions);
    public static BitmapSource CreateBitmapSourceFromHIcon(IntPtr icon, Int32Rect sourceRect, BitmapSizeOptions sizeOptions);
    public static BitmapSource CreateBitmapSourceFromMemorySection(IntPtr section, int pixelWidth, int pixelHeight, PixelFormat format, int stride, int offset);
}
public class System.Windows.Interop.InteropBitmap : BitmapSource {
    private BitmapSourceSafeMILHandle _unmanagedSource;
    private Int32Rect _sourceRect;
    private BitmapSizeOptions _sizeOptions;
    internal InteropBitmap(IntPtr hbitmap, IntPtr hpalette, Int32Rect sourceRect, BitmapSizeOptions sizeOptions, WICBitmapAlphaChannelOption alphaOptions);
    internal InteropBitmap(IntPtr hicon, Int32Rect sourceRect, BitmapSizeOptions sizeOptions);
    internal InteropBitmap(IntPtr section, int pixelWidth, int pixelHeight, PixelFormat format, int stride, int offset);
    protected virtual Freezable CreateInstanceCore();
    private void CopyCommon(InteropBitmap sourceBitmapSource);
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    private void InitFromWICSource(SafeMILHandle wicSource);
    public void Invalidate();
    public void Invalidate(Nullable`1<Int32Rect> dirtyRect);
    internal virtual void FinalizeCreation();
}
internal interface System.Windows.Interop.IStylusInputProvider {
    public abstract virtual IntPtr FilterMessage(IntPtr hwnd, WindowMessage msg, IntPtr wParam, IntPtr lParam, Boolean& handled);
}
public interface System.Windows.Interop.IWin32Window {
    public IntPtr Handle { get; }
    public abstract virtual IntPtr get_Handle();
}
internal enum System.Windows.Interop.OperatingSystemVersion : Enum {
    public int value__;
    public static OperatingSystemVersion WindowsXPSP2;
    public static OperatingSystemVersion WindowsXPSP3;
    public static OperatingSystemVersion WindowsVista;
    public static OperatingSystemVersion WindowsVistaSP1;
    public static OperatingSystemVersion WindowsVistaSP2;
    public static OperatingSystemVersion Windows7;
    public static OperatingSystemVersion Windows7SP1;
    public static OperatingSystemVersion Windows8;
    public static OperatingSystemVersion Windows8Point1;
    public static OperatingSystemVersion Windows10;
    public static OperatingSystemVersion Windows10TH2;
    public static OperatingSystemVersion Windows10RS1;
    public static OperatingSystemVersion Windows10RS2;
    public static OperatingSystemVersion Windows10RS3;
    public static OperatingSystemVersion Windows10RS5;
}
internal static class System.Windows.Interop.OperatingSystemVersionCheck : object {
    internal static bool IsVersionOrLater(OperatingSystemVersion version);
}
internal static class System.Windows.Interop.OSVersionHelper : object {
    [CompilerGeneratedAttribute]
private static bool <IsOsWindows10RS5OrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindows10RS3OrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindows10RS2OrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindows10RS1OrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindows10TH2OrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindows10TH1OrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindows10OrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindows8Point1OrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindows8OrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindows7SP1OrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindows7OrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindowsVistaSP2OrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindowsVistaSP1OrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindowsVistaOrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindowsXPSP3OrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindowsXPSP2OrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindowsXPSP1OrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindowsXPOrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindowsServer>k__BackingField;
    internal static bool IsOsWindows10RS5OrGreater { get; internal set; }
    internal static bool IsOsWindows10RS3OrGreater { get; internal set; }
    internal static bool IsOsWindows10RS2OrGreater { get; internal set; }
    internal static bool IsOsWindows10RS1OrGreater { get; internal set; }
    internal static bool IsOsWindows10TH2OrGreater { get; internal set; }
    internal static bool IsOsWindows10TH1OrGreater { get; internal set; }
    internal static bool IsOsWindows10OrGreater { get; internal set; }
    internal static bool IsOsWindows8Point1OrGreater { get; internal set; }
    internal static bool IsOsWindows8OrGreater { get; internal set; }
    internal static bool IsOsWindows7SP1OrGreater { get; internal set; }
    internal static bool IsOsWindows7OrGreater { get; internal set; }
    internal static bool IsOsWindowsVistaSP2OrGreater { get; internal set; }
    internal static bool IsOsWindowsVistaSP1OrGreater { get; internal set; }
    internal static bool IsOsWindowsVistaOrGreater { get; internal set; }
    internal static bool IsOsWindowsXPSP3OrGreater { get; internal set; }
    internal static bool IsOsWindowsXPSP2OrGreater { get; internal set; }
    internal static bool IsOsWindowsXPSP1OrGreater { get; internal set; }
    internal static bool IsOsWindowsXPOrGreater { get; internal set; }
    internal static bool IsOsWindowsServer { get; internal set; }
    private static OSVersionHelper();
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows10RS5OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows10RS5OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows10RS3OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows10RS3OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows10RS2OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows10RS2OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows10RS1OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows10RS1OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows10TH2OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows10TH2OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows10TH1OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows10TH1OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows10OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows10OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows8Point1OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows8Point1OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows8OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows8OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows7SP1OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows7SP1OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows7OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows7OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindowsVistaSP2OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindowsVistaSP2OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindowsVistaSP1OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindowsVistaSP1OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindowsVistaOrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindowsVistaOrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindowsXPSP3OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindowsXPSP3OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindowsXPSP2OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindowsXPSP2OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindowsXPSP1OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindowsXPSP1OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindowsXPOrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindowsXPOrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindowsServer();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindowsServer(bool value);
    private static bool IsWindows10RS5OrGreater();
    private static bool IsWindows10RS3OrGreater();
    private static bool IsWindows10RS2OrGreater();
    private static bool IsWindows10RS1OrGreater();
    private static bool IsWindows10TH2OrGreater();
    private static bool IsWindows10TH1OrGreater();
    private static bool IsWindows10OrGreater();
    private static bool IsWindows8Point1OrGreater();
    private static bool IsWindows8OrGreater();
    private static bool IsWindows7SP1OrGreater();
    private static bool IsWindows7OrGreater();
    private static bool IsWindowsVistaSP2OrGreater();
    private static bool IsWindowsVistaSP1OrGreater();
    private static bool IsWindowsVistaOrGreater();
    private static bool IsWindowsXPSP3OrGreater();
    private static bool IsWindowsXPSP2OrGreater();
    private static bool IsWindowsXPSP1OrGreater();
    private static bool IsWindowsXPOrGreater();
    private static bool IsWindowsServer();
    internal static bool IsOsVersionOrGreater(OperatingSystemVersion osVer);
    internal static OperatingSystemVersion GetOsVersion();
}
internal enum System.Windows.Interop.RenderingMode : Enum {
    public int value__;
    public static RenderingMode Default;
    public static RenderingMode Software;
    public static RenderingMode Hardware;
    public static RenderingMode HardwareReference;
    public static RenderingMode DisableMultimonDisplayClipping;
    public static RenderingMode IsDisableMultimonDisplayClippingValid;
}
public enum System.Windows.Interop.RenderMode : Enum {
    public int value__;
    public static RenderMode Default;
    public static RenderMode SoftwareOnly;
}
public class System.Windows.KeySplineConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext typeDescriptor, Type destinationType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo cultureInfo, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo cultureInfo, object value, Type destinationType);
}
public class System.Windows.KeyTimeConverter : TypeConverter {
    private static Char[] _percentCharacter;
    private static KeyTimeConverter();
    public virtual bool CanConvertFrom(ITypeDescriptorContext typeDescriptorContext, Type type);
    public virtual bool CanConvertTo(ITypeDescriptorContext typeDescriptorContext, Type type);
    public virtual object ConvertFrom(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object value);
    public virtual object ConvertTo(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object value, Type destinationType);
}
internal class System.Windows.LayoutEventList : object {
    private static int PocketCapacity;
    private ListItem _head;
    private ListItem _pocket;
    private int _pocketSize;
    private int _count;
    internal int Count { get; }
    internal ListItem Add(object target);
    internal void Remove(ListItem t);
    private ListItem getNewListItem(object target);
    private void reuseListItem(ListItem t);
    internal ListItem[] CopyToArray();
    internal int get_Count();
}
public enum System.Windows.LineBreakCondition : Enum {
    public int value__;
    public static LineBreakCondition BreakDesired;
    public static LineBreakCondition BreakPossible;
    public static LineBreakCondition BreakRestrained;
    public static LineBreakCondition BreakAlways;
}
[AttributeUsageAttribute("412")]
public class System.Windows.LocalizabilityAttribute : Attribute {
    private LocalizationCategory _category;
    private Readability _readability;
    private Modifiability _modifiability;
    public LocalizationCategory Category { get; }
    public Readability Readability { get; public set; }
    public Modifiability Modifiability { get; public set; }
    public LocalizabilityAttribute(LocalizationCategory category);
    public LocalizationCategory get_Category();
    public Readability get_Readability();
    public void set_Readability(Readability value);
    public Modifiability get_Modifiability();
    public void set_Modifiability(Modifiability value);
}
public enum System.Windows.LocalizationCategory : Enum {
    public int value__;
    public static LocalizationCategory None;
    public static LocalizationCategory Text;
    public static LocalizationCategory Title;
    public static LocalizationCategory Label;
    public static LocalizationCategory Button;
    public static LocalizationCategory CheckBox;
    public static LocalizationCategory ComboBox;
    public static LocalizationCategory ListBox;
    public static LocalizationCategory Menu;
    public static LocalizationCategory RadioButton;
    public static LocalizationCategory ToolTip;
    public static LocalizationCategory Hyperlink;
    public static LocalizationCategory TextFlow;
    public static LocalizationCategory XmlData;
    public static LocalizationCategory Font;
    public static LocalizationCategory Inherit;
    public static LocalizationCategory Ignore;
    public static LocalizationCategory NeverLocalize;
}
public interface System.Windows.Markup.IAddChild {
    public abstract virtual void AddChild(object value);
    public abstract virtual void AddText(string text);
}
internal interface System.Windows.Markup.IAddChildInternal {
}
[TypeForwardedFromAttribute("PresentationFramework, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")]
internal interface System.Windows.Markup.IProvidePropertyFallback {
    public abstract virtual bool CanProvidePropertyFallback(string property);
    public abstract virtual object ProvidePropertyFallback(string property, Exception cause);
}
internal static class System.Windows.Markup.XamlCoreSerializerUtil : object {
    private static XamlCoreSerializerUtil();
    internal static void ThrowIfIAddChildInternal(object o);
    internal static void ThrowIfNonWhiteSpaceInAddText(string s);
}
[TypeConverterAttribute("System.Windows.Markup.XmlLanguageConverter")]
public class System.Windows.Markup.XmlLanguage : object {
    private static Hashtable _cache;
    private static int InitialDictionarySize;
    private static int MaxCultureDepth;
    private static XmlLanguage _empty;
    private string _lowerCaseTag;
    private CultureInfo _equivalentCulture;
    private CultureInfo _specificCulture;
    private CultureInfo _compatibleCulture;
    private int _specificity;
    private bool _equivalentCultureFailed;
    public static XmlLanguage Empty { get; }
    public string IetfLanguageTag { get; }
    internal MatchingLanguageCollection MatchingLanguages { get; }
    private XmlLanguage PrefixLanguage { get; }
    private XmlLanguage(string lowercase);
    private static XmlLanguage();
    public static XmlLanguage get_Empty();
    public static XmlLanguage GetLanguage(string ietfLanguageTag);
    public string get_IetfLanguageTag();
    public virtual string ToString();
    public CultureInfo GetEquivalentCulture();
    public CultureInfo GetSpecificCulture();
    [FriendAccessAllowedAttribute]
internal CultureInfo GetCompatibleCulture();
    [FriendAccessAllowedAttribute]
internal bool RangeIncludes(XmlLanguage language);
    internal bool RangeIncludes(CultureInfo culture);
    internal int GetSpecificity();
    private static int GetSpecificity(CultureInfo culture, int maxDepth);
    private static int GetSubtagCount(string languageTag);
    internal MatchingLanguageCollection get_MatchingLanguages();
    private bool IsPrefixOf(string longTag);
    private bool TryGetEquivalentCulture(CultureInfo& culture);
    private XmlLanguage get_PrefixLanguage();
    private static string Shorten(string languageTag);
    private static void ValidateLowerCaseTag(string ietfLanguageTag);
    private static int ParseSubtag(string ietfLanguageTag, StringReader reader, bool isPrimary);
    private static bool IsLowerAlpha(int c);
    private static bool IsDigit(int c);
    private static void ThrowParseException(string ietfLanguageTag);
    private static string AsciiToLower(string tag);
}
public class System.Windows.Markup.XmlLanguageConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext typeDescriptorContext, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext typeDescriptorContext, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object source);
    public virtual object ConvertTo(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object value, Type destinationType);
}
internal class System.Windows.MeasureData : object {
    private Size _availableSize;
    private Rect _viewport;
    public bool HasViewport { get; }
    public Size AvailableSize { get; public set; }
    public Rect Viewport { get; public set; }
    public MeasureData(Size availableSize, Rect viewport);
    public MeasureData(MeasureData data);
    public bool get_HasViewport();
    public bool IsCloseTo(MeasureData other);
    public Size get_AvailableSize();
    public void set_AvailableSize(Size value);
    public Rect get_Viewport();
    public void set_Viewport(Rect value);
}
public enum System.Windows.Media.AlignmentX : Enum {
    public int value__;
    public static AlignmentX Left;
    public static AlignmentX Center;
    public static AlignmentX Right;
}
public enum System.Windows.Media.AlignmentY : Enum {
    public int value__;
    public static AlignmentY Top;
    public static AlignmentY Center;
    public static AlignmentY Bottom;
}
internal class System.Windows.Media.AncestorChangedEventArgs : object {
    private DependencyObject _subRoot;
    private DependencyObject _oldParent;
    public DependencyObject Ancestor { get; }
    public DependencyObject OldParent { get; }
    public AncestorChangedEventArgs(DependencyObject subRoot, DependencyObject oldParent);
    public DependencyObject get_Ancestor();
    public DependencyObject get_OldParent();
}
public abstract class System.Windows.Media.Animation.Animatable : Freezable {
    private static UncommonField`1<WeakReference> StoredWeakReferenceField;
    public bool HasAnimatedProperties { get; }
    private static Animatable();
    public Animatable Clone();
    internal void PropertyChanged(DependencyProperty dp);
    internal virtual void AddRefOnChannelAnimations(Channel channel);
    internal virtual void ReleaseOnChannelAnimations(Channel channel);
    internal static DependencyProperty RegisterProperty(string name, Type propertyType, Type ownerType, object defaultValue, PropertyChangedCallback changed, ValidateValueCallback validate, bool isIndependentlyAnimated, CoerceValueCallback coerced);
    internal void AddRefResource(IResource resource, Channel channel);
    internal void ReleaseResource(IResource resource, Channel channel);
    protected virtual bool FreezeCore(bool isChecking);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.Get3DHandle(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.RemoveChildFromParent(IResource parent, Channel channel);
    internal ResourceHandle GetAnimationResourceHandle(DependencyProperty dp, Channel channel);
    internal WeakReference GetWeakReference();
    internal bool IsBaseValueDefault(DependencyProperty dp);
    internal void RegisterForAsyncUpdateResource();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal void InternalWritePreamble();
    [EditorBrowsableAttribute("1")]
public static bool ShouldSerializeStoredWeakReference(DependencyObject target);
    public sealed virtual void ApplyAnimationClock(DependencyProperty dp, AnimationClock clock);
    public sealed virtual void ApplyAnimationClock(DependencyProperty dp, AnimationClock clock, HandoffBehavior handoffBehavior);
    public sealed virtual void BeginAnimation(DependencyProperty dp, AnimationTimeline animation);
    public sealed virtual void BeginAnimation(DependencyProperty dp, AnimationTimeline animation, HandoffBehavior handoffBehavior);
    public sealed virtual bool get_HasAnimatedProperties();
    public sealed virtual object GetAnimationBaseValue(DependencyProperty dp);
    internal sealed virtual void EvaluateAnimatedValueCore(DependencyProperty dp, PropertyMetadata metadata, EffectiveValueEntry& entry);
}
public class System.Windows.Media.Animation.AnimationClock : Clock {
    public AnimationTimeline Timeline { get; }
    internal bool NeedsTicksWhenActive { get; }
    protected internal AnimationClock(AnimationTimeline animation);
    public AnimationTimeline get_Timeline();
    public object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue);
    internal virtual bool get_NeedsTicksWhenActive();
}
internal abstract class System.Windows.Media.Animation.AnimationClockResource : object {
    private MultiChannelResource _duceResource;
    private bool _isResourceInvalid;
    protected AnimationClock _animationClock;
    public AnimationClock AnimationClock { get; }
    protected bool IsResourceInvalid { get; protected set; }
    protected ResourceType ResourceType { get; }
    protected AnimationClockResource(AnimationClock animationClock);
    public AnimationClock get_AnimationClock();
    protected void OnChanged(object sender, EventArgs args);
    internal virtual void PropagateChangedHandlersCore(EventHandler handler, bool adding);
    private void UpdateResourceFromMediaContext(Channel channel, bool skipOnChannelCheck);
    protected abstract virtual void UpdateResource(ResourceHandle handle, Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.RemoveChildFromParent(IResource parent, Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.Get3DHandle(Channel channel);
    protected bool get_IsResourceInvalid();
    protected void set_IsResourceInvalid(bool value);
    protected abstract virtual ResourceType get_ResourceType();
}
public class System.Windows.Media.Animation.AnimationException : SystemException {
    private AnimationClock _clock;
    private DependencyProperty _property;
    private IAnimatable _targetElement;
    public AnimationClock Clock { get; }
    public DependencyProperty Property { get; }
    public IAnimatable Target { get; }
    internal AnimationException(AnimationClock clock, DependencyProperty property, IAnimatable target, string message, Exception innerException);
    private AnimationException(SerializationInfo info, StreamingContext context);
    public AnimationClock get_Clock();
    public DependencyProperty get_Property();
    public IAnimatable get_Target();
}
internal class System.Windows.Media.Animation.AnimationLayer : object {
    private object _snapshotValue;
    private IList`1<AnimationClock> _animationClocks;
    private AnimationStorage _ownerStorage;
    private EventHandler _removeRequestedHandler;
    private bool _hasStickySnapshotValue;
    internal AnimationLayer(AnimationStorage ownerStorage);
    internal void ApplyAnimationClocks(IList`1<AnimationClock> newAnimationClocks, HandoffBehavior handoffBehavior, object defaultDestinationValue);
    private void DetachAnimationClocks();
    private void SetAnimationClocks(IList`1<AnimationClock> animationClocks);
    private void OnCurrentStateInvalidated(object sender, EventArgs args);
    private void OnRemoveRequested(object sender, EventArgs args);
    private void AppendAnimationClocks(IList`1<AnimationClock> newAnimationClocks);
    internal object GetCurrentValue(object defaultDestinationValue);
}
internal class System.Windows.Media.Animation.AnimationStorage : object {
    private static UncommonField`1<FrugalMap> AnimatedPropertyMapField;
    protected WeakReference _dependencyObject;
    protected DependencyProperty _dependencyProperty;
    protected FrugalObjectList`1<AnimationClock> _animationClocks;
    private SortedList`2<long, AnimationLayer> _propertyTriggerLayers;
    private EventHandler _currentTimeInvalidatedHandler;
    private EventHandler _removeRequestedHandler;
    private object _snapshotValue;
    private bool _hasStickySnapshotValue;
    private bool _hadValidationError;
    internal object _baseValue;
    internal bool IsEmpty { get; }
    private static AnimationStorage();
    internal bool get_IsEmpty();
    internal void AttachAnimationClock(AnimationClock animationClock, EventHandler removeRequestedHandler);
    internal void DetachAnimationClock(AnimationClock animationClock, EventHandler removeRequestedHandler);
    internal void Initialize(DependencyObject d, DependencyProperty dp);
    internal void RemoveLayer(AnimationLayer layer);
    internal void WritePostscript();
    internal void EvaluateAnimatedValue(PropertyMetadata metadata, EffectiveValueEntry& entry);
    private void OnCurrentTimeInvalidated(object sender, EventArgs args);
    private void OnRemoveRequested(object sender, EventArgs args);
    private void OnCurrentStateInvalidated(object sender, EventArgs args);
    private void ClearAnimations();
    internal static void ApplyAnimationClock(DependencyObject d, DependencyProperty dp, AnimationClock animationClock, HandoffBehavior handoffBehavior);
    [FriendAccessAllowedAttribute]
internal static void ApplyAnimationClocks(DependencyObject d, DependencyProperty dp, IList`1<AnimationClock> animationClocks, HandoffBehavior handoffBehavior);
    [FriendAccessAllowedAttribute]
internal static void ApplyAnimationClocksToLayer(DependencyObject d, DependencyProperty dp, IList`1<AnimationClock> animationClocks, HandoffBehavior handoffBehavior, long propertyTriggerLayerIndex);
    internal static void BeginAnimation(DependencyObject d, DependencyProperty dp, AnimationTimeline animation, HandoffBehavior handoffBehavior);
    internal static AnimationStorage EnsureStorage(DependencyObject d, DependencyProperty dp);
    internal static object GetCurrentPropertyValue(AnimationStorage storage, DependencyObject d, DependencyProperty dp, PropertyMetadata metadata, object baseValue);
    [FriendAccessAllowedAttribute]
internal static bool IsPropertyAnimatable(DependencyObject d, DependencyProperty dp);
    internal static bool IsAnimationValid(DependencyProperty dp, AnimationTimeline animation);
    [FriendAccessAllowedAttribute]
internal static bool IsAnimationClockValid(DependencyProperty dp, AnimationClock animation);
    internal static FrugalMap GetAnimatedPropertiesMap(DependencyObject d);
    internal static AnimationStorage GetStorage(DependencyObject d, DependencyProperty dp);
    private static AnimationStorage CreateStorage(DependencyObject d, DependencyProperty dp);
    private static IndependentAnimationStorage CreateIndependentAnimationStorageForType(Type type);
}
public abstract class System.Windows.Media.Animation.AnimationTimeline : Timeline {
    public static DependencyProperty IsAdditiveProperty;
    public static DependencyProperty IsCumulativeProperty;
    public Type TargetPropertyType { get; }
    public bool IsDestinationDefault { get; }
    private static AnimationTimeline();
    private static void AnimationTimeline_PropertyChangedFunction(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public AnimationTimeline Clone();
    protected internal virtual Clock AllocateClock();
    public AnimationClock CreateClock();
    public virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    protected virtual Duration GetNaturalDurationCore(Clock clock);
    public abstract virtual Type get_TargetPropertyType();
    public virtual bool get_IsDestinationDefault();
}
internal enum System.Windows.Media.Animation.AnimationType : Enum {
    public byte value__;
    public static AnimationType Automatic;
    public static AnimationType From;
    public static AnimationType To;
    public static AnimationType By;
    public static AnimationType FromTo;
    public static AnimationType FromBy;
}
public class System.Windows.Media.Animation.BackEase : EasingFunctionBase {
    public static DependencyProperty AmplitudeProperty;
    public double Amplitude { get; public set; }
    private static BackEase();
    public double get_Amplitude();
    public void set_Amplitude(double value);
    protected virtual double EaseInCore(double normalizedTime);
    protected virtual Freezable CreateInstanceCore();
}
public abstract class System.Windows.Media.Animation.BooleanAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public BooleanAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual Type get_TargetPropertyType();
    public bool GetCurrentValue(bool defaultOriginValue, bool defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual bool GetCurrentValueCore(bool defaultOriginValue, bool defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.BooleanAnimationUsingKeyFrames : BooleanAnimationBase {
    private BooleanKeyFrameCollection _keyFrames;
    private ResolvedKeyFrameEntry[] _sortedResolvedKeyFrames;
    private bool _areKeyTimesValid;
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public BooleanKeyFrameCollection KeyFrames { get; public set; }
    private TimeSpan LargestTimeSpanKeyTime { get; }
    public BooleanAnimationUsingKeyFrames Clone();
    public BooleanAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private void CopyCommon(BooleanAnimationUsingKeyFrames sourceAnimation, bool isCurrentValueClone);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual bool GetCurrentValueCore(bool defaultOriginValue, bool defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public BooleanKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(BooleanKeyFrameCollection value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    private bool GetResolvedKeyFrameValue(int resolvedKeyFrameIndex);
    private BooleanKeyFrame GetResolvedKeyFrame(int resolvedKeyFrameIndex);
    private TimeSpan get_LargestTimeSpanKeyTime();
    private void ResolveKeyTimes();
    private void ResolvePacedKeyTimes();
}
public abstract class System.Windows.Media.Animation.BooleanKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public bool Value { get; public set; }
    protected BooleanKeyFrame(bool value);
    protected BooleanKeyFrame(bool value, KeyTime keyTime);
    private static BooleanKeyFrame();
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public bool get_Value();
    public void set_Value(bool value);
    public bool InterpolateValue(bool baseValue, double keyFrameProgress);
    protected abstract virtual bool InterpolateValueCore(bool baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.BooleanKeyFrameCollection : Freezable {
    private List`1<BooleanKeyFrame> _keyFrames;
    private static BooleanKeyFrameCollection s_emptyCollection;
    public static BooleanKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public BooleanKeyFrame Item { get; public set; }
    public static BooleanKeyFrameCollection get_Empty();
    public BooleanKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(BooleanKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(BooleanKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(BooleanKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(BooleanKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, BooleanKeyFrame keyFrame);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(BooleanKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public BooleanKeyFrame get_Item(int index);
    public void set_Item(int index, BooleanKeyFrame value);
}
public class System.Windows.Media.Animation.BounceEase : EasingFunctionBase {
    public static DependencyProperty BouncesProperty;
    public static DependencyProperty BouncinessProperty;
    public int Bounces { get; public set; }
    public double Bounciness { get; public set; }
    private static BounceEase();
    public int get_Bounces();
    public void set_Bounces(int value);
    public double get_Bounciness();
    public void set_Bounciness(double value);
    protected virtual double EaseInCore(double normalizedTime);
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Animation.ByteAnimation : ByteAnimationBase {
    private Byte[] _keyValues;
    private AnimationType _animationType;
    private bool _isAnimationFunctionValid;
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public Nullable`1<byte> From { get; public set; }
    public Nullable`1<byte> To { get; public set; }
    public Nullable`1<byte> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private static ByteAnimation();
    public ByteAnimation(byte toValue, Duration duration);
    public ByteAnimation(byte toValue, Duration duration, FillBehavior fillBehavior);
    public ByteAnimation(byte fromValue, byte toValue, Duration duration);
    public ByteAnimation(byte fromValue, byte toValue, Duration duration, FillBehavior fillBehavior);
    public ByteAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual byte GetCurrentValueCore(byte defaultOriginValue, byte defaultDestinationValue, AnimationClock animationClock);
    private void ValidateAnimationFunction();
    private static void AnimationFunction_Changed(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static bool ValidateFromToOrByValue(object value);
    public Nullable`1<byte> get_From();
    public void set_From(Nullable`1<byte> value);
    public Nullable`1<byte> get_To();
    public void set_To(Nullable`1<byte> value);
    public Nullable`1<byte> get_By();
    public void set_By(Nullable`1<byte> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
}
public abstract class System.Windows.Media.Animation.ByteAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public ByteAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual Type get_TargetPropertyType();
    public byte GetCurrentValue(byte defaultOriginValue, byte defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual byte GetCurrentValueCore(byte defaultOriginValue, byte defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.ByteAnimationUsingKeyFrames : ByteAnimationBase {
    private ByteKeyFrameCollection _keyFrames;
    private ResolvedKeyFrameEntry[] _sortedResolvedKeyFrames;
    private bool _areKeyTimesValid;
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public ByteKeyFrameCollection KeyFrames { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private TimeSpan LargestTimeSpanKeyTime { get; }
    public ByteAnimationUsingKeyFrames Clone();
    public ByteAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private void CopyCommon(ByteAnimationUsingKeyFrames sourceAnimation, bool isCurrentValueClone);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual byte GetCurrentValueCore(byte defaultOriginValue, byte defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public ByteKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(ByteKeyFrameCollection value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    private byte GetResolvedKeyFrameValue(int resolvedKeyFrameIndex);
    private ByteKeyFrame GetResolvedKeyFrame(int resolvedKeyFrameIndex);
    private TimeSpan get_LargestTimeSpanKeyTime();
    private void ResolveKeyTimes();
    private void ResolvePacedKeyTimes();
}
public abstract class System.Windows.Media.Animation.ByteKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public byte Value { get; public set; }
    protected ByteKeyFrame(byte value);
    protected ByteKeyFrame(byte value, KeyTime keyTime);
    private static ByteKeyFrame();
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public byte get_Value();
    public void set_Value(byte value);
    public byte InterpolateValue(byte baseValue, double keyFrameProgress);
    protected abstract virtual byte InterpolateValueCore(byte baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.ByteKeyFrameCollection : Freezable {
    private List`1<ByteKeyFrame> _keyFrames;
    private static ByteKeyFrameCollection s_emptyCollection;
    public static ByteKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public ByteKeyFrame Item { get; public set; }
    public static ByteKeyFrameCollection get_Empty();
    public ByteKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(ByteKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(ByteKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(ByteKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(ByteKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, ByteKeyFrame keyFrame);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(ByteKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public ByteKeyFrame get_Item(int index);
    public void set_Item(int index, ByteKeyFrame value);
}
public abstract class System.Windows.Media.Animation.CharAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public CharAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual Type get_TargetPropertyType();
    public char GetCurrentValue(char defaultOriginValue, char defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual char GetCurrentValueCore(char defaultOriginValue, char defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.CharAnimationUsingKeyFrames : CharAnimationBase {
    private CharKeyFrameCollection _keyFrames;
    private ResolvedKeyFrameEntry[] _sortedResolvedKeyFrames;
    private bool _areKeyTimesValid;
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public CharKeyFrameCollection KeyFrames { get; public set; }
    private TimeSpan LargestTimeSpanKeyTime { get; }
    public CharAnimationUsingKeyFrames Clone();
    public CharAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private void CopyCommon(CharAnimationUsingKeyFrames sourceAnimation, bool isCurrentValueClone);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual char GetCurrentValueCore(char defaultOriginValue, char defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public CharKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(CharKeyFrameCollection value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    private char GetResolvedKeyFrameValue(int resolvedKeyFrameIndex);
    private CharKeyFrame GetResolvedKeyFrame(int resolvedKeyFrameIndex);
    private TimeSpan get_LargestTimeSpanKeyTime();
    private void ResolveKeyTimes();
    private void ResolvePacedKeyTimes();
}
public abstract class System.Windows.Media.Animation.CharKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public char Value { get; public set; }
    protected CharKeyFrame(char value);
    protected CharKeyFrame(char value, KeyTime keyTime);
    private static CharKeyFrame();
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public char get_Value();
    public void set_Value(char value);
    public char InterpolateValue(char baseValue, double keyFrameProgress);
    protected abstract virtual char InterpolateValueCore(char baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.CharKeyFrameCollection : Freezable {
    private List`1<CharKeyFrame> _keyFrames;
    private static CharKeyFrameCollection s_emptyCollection;
    public static CharKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public CharKeyFrame Item { get; public set; }
    public static CharKeyFrameCollection get_Empty();
    public CharKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(CharKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(CharKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(CharKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(CharKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, CharKeyFrame keyFrame);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(CharKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public CharKeyFrame get_Item(int index);
    public void set_Item(int index, CharKeyFrame value);
}
public class System.Windows.Media.Animation.CircleEase : EasingFunctionBase {
    protected virtual double EaseInCore(double normalizedTime);
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Animation.Clock : DispatcherObject {
    private ClockFlags _flags;
    private Nullable`1<int> _currentIteration;
    private Nullable`1<double> _currentProgress;
    private Nullable`1<double> _currentGlobalSpeed;
    private Nullable`1<TimeSpan> _currentTime;
    private ClockState _currentClockState;
    private RootData _rootData;
    internal SyncData _syncData;
    internal Nullable`1<TimeSpan> _beginTime;
    private Nullable`1<TimeSpan> _currentIterationBeginTime;
    internal Nullable`1<TimeSpan> _nextTickNeededTime;
    private WeakReference _weakReference;
    private SubtreeFinalizer _subtreeFinalizer;
    private EventHandlersStore _eventHandlersStore;
    internal Duration _resolvedDuration;
    internal Duration _currentDuration;
    private double _appliedSpeedRatio;
    internal Timeline _timeline;
    internal TimeManager _timeManager;
    internal ClockGroup _parent;
    internal int _childIndex;
    internal int _depth;
    private static long s_TimeSpanTicksPerSecond;
    internal bool CanGrow { get; }
    internal bool CanSlip { get; }
    public ClockController Controller { get; }
    public Nullable`1<int> CurrentIteration { get; }
    public Nullable`1<double> CurrentGlobalSpeed { get; }
    public Nullable`1<double> CurrentProgress { get; }
    public ClockState CurrentState { get; }
    public Nullable`1<TimeSpan> CurrentTime { get; }
    public bool HasControllableRoot { get; }
    public bool IsPaused { get; }
    public Duration NaturalDuration { get; }
    public Clock Parent { get; }
    public Timeline Timeline { get; }
    protected TimeSpan CurrentGlobalTime { get; }
    internal Duration CurrentDuration { get; }
    internal int Depth { get; }
    internal Duration EndOfActivePeriod { get; }
    internal Clock FirstChild { get; }
    internal ClockState InternalCurrentClockState { get; internal set; }
    internal Nullable`1<double> InternalCurrentGlobalSpeed { get; internal set; }
    internal Nullable`1<int> InternalCurrentIteration { get; internal set; }
    internal Nullable`1<double> InternalCurrentProgress { get; internal set; }
    internal Nullable`1<TimeSpan> InternalNextTickNeededTime { get; internal set; }
    internal ClockGroup InternalParent { get; }
    internal Duration ResolvedDuration { get; }
    internal Clock NextSibling { get; }
    internal WeakReference WeakReference { get; }
    internal Nullable`1<int> DesiredFrameRate { get; }
    internal bool CompletedEventRaised { get; internal set; }
    internal bool CurrentGlobalSpeedInvalidatedEventRaised { get; internal set; }
    internal bool CurrentStateInvalidatedEventRaised { get; internal set; }
    internal bool CurrentTimeInvalidatedEventRaised { get; internal set; }
    private bool HasDesiredFrameRate { get; private set; }
    internal bool HasResolvedDuration { get; internal set; }
    internal bool IsBackwardsProgressingGlobal { get; internal set; }
    internal bool IsInEventQueue { get; internal set; }
    internal bool IsInteractivelyPaused { get; internal set; }
    internal bool IsInteractivelyStopped { get; internal set; }
    internal bool IsRoot { get; internal set; }
    internal bool IsTimeManager { get; internal set; }
    internal bool NeedsPostfixTraversal { get; internal set; }
    internal bool NeedsTicksWhenActive { get; internal set; }
    internal bool PauseStateChangedDuringTick { get; internal set; }
    internal bool PendingInteractivePause { get; internal set; }
    internal bool PendingInteractiveRemove { get; internal set; }
    internal bool PendingInteractiveResume { get; internal set; }
    internal bool PendingInteractiveStop { get; internal set; }
    internal bool RemoveRequestedEventRaised { get; internal set; }
    private bool HasDiscontinuousTimeMovementOccured { get; private set; }
    internal bool HasDescendantsWithUnresolvedDuration { get; internal set; }
    private bool HasSeekOccuredAfterLastTick { get; private set; }
    private bool IsInTimingTree { get; }
    private bool RootBeginPending { get; private set; }
    protected internal Clock(Timeline timeline);
    private static Clock();
    internal bool get_CanGrow();
    internal bool get_CanSlip();
    public ClockController get_Controller();
    public Nullable`1<int> get_CurrentIteration();
    public Nullable`1<double> get_CurrentGlobalSpeed();
    public Nullable`1<double> get_CurrentProgress();
    public ClockState get_CurrentState();
    public Nullable`1<TimeSpan> get_CurrentTime();
    public bool get_HasControllableRoot();
    public bool get_IsPaused();
    public Duration get_NaturalDuration();
    public Clock get_Parent();
    public Timeline get_Timeline();
    public void add_Completed(EventHandler value);
    public void remove_Completed(EventHandler value);
    public void add_CurrentGlobalSpeedInvalidated(EventHandler value);
    public void remove_CurrentGlobalSpeedInvalidated(EventHandler value);
    public void add_CurrentStateInvalidated(EventHandler value);
    public void remove_CurrentStateInvalidated(EventHandler value);
    public void add_CurrentTimeInvalidated(EventHandler value);
    public void remove_CurrentTimeInvalidated(EventHandler value);
    public void add_RemoveRequested(EventHandler value);
    public void remove_RemoveRequested(EventHandler value);
    protected virtual void DiscontinuousTimeMovement();
    protected virtual bool GetCanSlip();
    protected virtual TimeSpan GetCurrentTimeCore();
    protected virtual void SpeedChanged();
    protected virtual void Stopped();
    protected TimeSpan get_CurrentGlobalTime();
    internal virtual void AddNullPointToCurrentIntervals();
    internal static Clock AllocateClock(Timeline timeline, bool hasControllableRoot);
    internal virtual void BuildClockSubTreeFromTimeline(Timeline timeline, bool hasControllableRoot);
    internal static Clock BuildClockTreeFromTimeline(Timeline rootTimeline, bool hasControllableRoot);
    internal virtual void ClearCurrentIntervalsToNull();
    internal void ClipNextTickByParent();
    internal virtual void ComputeCurrentIntervals(TimeIntervalCollection parentIntervalCollection, TimeSpan beginTime, Nullable`1<TimeSpan> endTime, Duration fillDuration, Duration period, double appliedSpeedRatio, double accelRatio, double decelRatio, bool isAutoReversed);
    internal virtual void ComputeCurrentFillInterval(TimeIntervalCollection parentIntervalCollection, TimeSpan beginTime, TimeSpan endTime, Duration period, double appliedSpeedRatio, double accelRatio, double decelRatio, bool isAutoReversed);
    internal void ComputeLocalState();
    internal virtual Duration get_CurrentDuration();
    internal void InternalBegin();
    internal double InternalGetSpeedRatio();
    internal void InternalPause();
    internal void InternalRemove();
    internal void InternalResume();
    internal void InternalSeek(TimeSpan destination);
    internal void InternalSeekAlignedToLastTick(TimeSpan destination);
    internal void InternalSetSpeedRatio(double ratio);
    internal void InternalSkipToFill();
    internal void InternalStop();
    internal void RaiseAccumulatedEvents();
    internal void RaiseCompleted();
    internal void RaiseCurrentGlobalSpeedInvalidated();
    internal void RaiseCurrentStateInvalidated();
    internal void RaiseCurrentTimeInvalidated();
    internal void RaiseRemoveRequested();
    internal void ResetCachedStateToStopped();
    internal virtual void ResetNodesWithSlip();
    internal virtual void UpdateDescendantsWithUnresolvedDuration();
    internal int get_Depth();
    internal Duration get_EndOfActivePeriod();
    internal virtual Clock get_FirstChild();
    internal ClockState get_InternalCurrentClockState();
    internal void set_InternalCurrentClockState(ClockState value);
    internal Nullable`1<double> get_InternalCurrentGlobalSpeed();
    internal void set_InternalCurrentGlobalSpeed(Nullable`1<double> value);
    internal Nullable`1<int> get_InternalCurrentIteration();
    internal void set_InternalCurrentIteration(Nullable`1<int> value);
    internal Nullable`1<double> get_InternalCurrentProgress();
    internal void set_InternalCurrentProgress(Nullable`1<double> value);
    internal Nullable`1<TimeSpan> get_InternalNextTickNeededTime();
    internal void set_InternalNextTickNeededTime(Nullable`1<TimeSpan> value);
    internal ClockGroup get_InternalParent();
    internal Duration get_ResolvedDuration();
    internal Clock get_NextSibling();
    internal WeakReference get_WeakReference();
    internal Nullable`1<int> get_DesiredFrameRate();
    internal bool get_CompletedEventRaised();
    internal void set_CompletedEventRaised(bool value);
    internal bool get_CurrentGlobalSpeedInvalidatedEventRaised();
    internal void set_CurrentGlobalSpeedInvalidatedEventRaised(bool value);
    internal bool get_CurrentStateInvalidatedEventRaised();
    internal void set_CurrentStateInvalidatedEventRaised(bool value);
    internal bool get_CurrentTimeInvalidatedEventRaised();
    internal void set_CurrentTimeInvalidatedEventRaised(bool value);
    private bool get_HasDesiredFrameRate();
    private void set_HasDesiredFrameRate(bool value);
    internal bool get_HasResolvedDuration();
    internal void set_HasResolvedDuration(bool value);
    internal bool get_IsBackwardsProgressingGlobal();
    internal void set_IsBackwardsProgressingGlobal(bool value);
    internal bool get_IsInEventQueue();
    internal void set_IsInEventQueue(bool value);
    internal bool get_IsInteractivelyPaused();
    internal void set_IsInteractivelyPaused(bool value);
    internal bool get_IsInteractivelyStopped();
    internal void set_IsInteractivelyStopped(bool value);
    internal bool get_IsRoot();
    internal void set_IsRoot(bool value);
    internal bool get_IsTimeManager();
    internal void set_IsTimeManager(bool value);
    internal bool get_NeedsPostfixTraversal();
    internal void set_NeedsPostfixTraversal(bool value);
    internal virtual bool get_NeedsTicksWhenActive();
    internal virtual void set_NeedsTicksWhenActive(bool value);
    internal bool get_PauseStateChangedDuringTick();
    internal void set_PauseStateChangedDuringTick(bool value);
    internal bool get_PendingInteractivePause();
    internal void set_PendingInteractivePause(bool value);
    internal bool get_PendingInteractiveRemove();
    internal void set_PendingInteractiveRemove(bool value);
    internal bool get_PendingInteractiveResume();
    internal void set_PendingInteractiveResume(bool value);
    internal bool get_PendingInteractiveStop();
    internal void set_PendingInteractiveStop(bool value);
    internal bool get_RemoveRequestedEventRaised();
    internal void set_RemoveRequestedEventRaised(bool value);
    private bool get_HasDiscontinuousTimeMovementOccured();
    private void set_HasDiscontinuousTimeMovementOccured(bool value);
    internal bool get_HasDescendantsWithUnresolvedDuration();
    internal void set_HasDescendantsWithUnresolvedDuration(bool value);
    private bool get_HasSeekOccuredAfterLastTick();
    private void set_HasSeekOccuredAfterLastTick(bool value);
    private void AdjustBeginTime();
    internal void ApplyDesiredFrameRateToGlobalTime();
    internal void ApplyDesiredFrameRateToNextTick();
    private bool ComputeCurrentIteration(TimeSpan parentTime, double parentSpeed, Nullable`1<TimeSpan> expirationTime, TimeSpan& localProgress);
    private void ComputeCurrentIterationWithGrow(TimeSpan parentTime, Nullable`1<TimeSpan> expirationTime, TimeSpan& localProgress, Int32& newIteration);
    private bool ComputeCurrentState(Nullable`1<TimeSpan> expirationTime, TimeSpan& parentTime, double parentSpeed, bool isInTick);
    private bool ComputeCurrentSpeed(double localSpeed);
    private bool ComputeCurrentTime(TimeSpan localProgress, Double& localSpeed);
    private void ResolveDuration();
    private Nullable`1<TimeSpan> ComputeEffectiveDuration();
    private void ComputeEvents(Nullable`1<TimeSpan> expirationTime, TimeIntervalCollection parentIntervalCollection);
    private bool ComputeExpirationTime(Nullable`1& expirationTime);
    private bool ComputeInteractiveValues();
    private void ComputeIntervalsWithHoldEnd(TimeIntervalCollection parentIntervalCollection, Nullable`1<TimeSpan> endOfActivePeriod);
    private void ComputeIntervalsWithParentIntersection(TimeIntervalCollection parentIntervalCollection, TimeIntervalCollection activePeriod, Nullable`1<TimeSpan> endOfActivePeriod, Duration postFillDuration);
    private void ComputeLocalStateHelper(bool performTickOperations, bool seekedAlignedToLastTick);
    private bool ComputeNextTickNeededTime(Nullable`1<TimeSpan> expirationTime, TimeSpan parentTime, double parentSpeed);
    private bool ComputeParentParameters(Nullable`1& parentTime, Nullable`1& parentSpeed, TimeIntervalCollection& parentIntervalCollection, bool seekedAlignedToLastTick);
    private void ComputeSyncEnter(TimeIntervalCollection& parentIntervalCollection, TimeSpan currentParentTimePT);
    private void ComputeSyncSlip(TimeIntervalCollection& parentIntervalCollection, TimeSpan currentParentTimePT, double currentParentSpeed);
    private void ResetSlipOnSubtree();
    private void AddEventHandler(EventPrivateKey key, Delegate handler);
    private void FireCompletedEvent();
    private void FireCurrentGlobalSpeedInvalidatedEvent();
    private void FireCurrentStateInvalidatedEvent();
    private void FireCurrentTimeInvalidatedEvent();
    private void FireEvent(EventPrivateKey key);
    private void FireRemoveRequestedEvent();
    private TimeSpan GetCurrentDesiredFrameTime(TimeSpan time);
    private TimeSpan GetDesiredFrameTime(TimeSpan time, int frameOffset);
    private TimeSpan GetNextDesiredFrameTime(TimeSpan time);
    private void RemoveEventHandler(EventPrivateKey key, Delegate handler);
    private void AddToTimeManager();
    private TimeSpan DivideTimeSpan(TimeSpan timeSpan, double factor);
    private bool GetFlag(ClockFlags flagMask);
    private static TimeSpan MultiplyTimeSpan(TimeSpan timeSpan, double factor);
    private void NotifyNewEarliestFutureActivity();
    private void ResetCachedStateToFilling();
    private void RaiseCompletedForRoot(bool isInTick);
    private void RaiseRemoveRequestedForRoot();
    private void SetFlag(ClockFlags flagMask, bool value);
    private void SetTimeManager(TimeManager timeManager);
    private void UpdateNeedsTicksWhenActive();
    private void UpdateSyncBeginTime();
    private void VerifyNeedsTicksWhenActive();
    private bool get_IsInTimingTree();
    private bool get_RootBeginPending();
    private void set_RootBeginPending(bool value);
    [ConditionalAttribute("DEBUG")]
private void Debug_VerifyOffsetFromBegin(long inputTime, long optimizedInputTime);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.ClockCollection : object {
    private Clock _owner;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public Clock Item { get; }
    internal ClockCollection(Clock owner);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Clear();
    public sealed virtual void Add(Clock item);
    public sealed virtual bool Remove(Clock item);
    public sealed virtual bool Contains(Clock item);
    public sealed virtual void CopyTo(Clock[] array, int index);
    private sealed virtual override IEnumerator`1<Clock> System.Collections.Generic.IEnumerable<System.Windows.Media.Animation.Clock>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual bool Equals(object obj);
    public static bool Equals(ClockCollection objA, ClockCollection objB);
    public static bool op_Equality(ClockCollection objA, ClockCollection objB);
    public static bool op_Inequality(ClockCollection objA, ClockCollection objB);
    public virtual int GetHashCode();
    public Clock get_Item(int index);
}
public class System.Windows.Media.Animation.ClockController : DispatcherObject {
    private Clock _owner;
    public Clock Clock { get; }
    public double SpeedRatio { get; public set; }
    internal ClockController(Clock owner);
    public void Begin();
    public void SkipToFill();
    public void Pause();
    public void Resume();
    public void Seek(TimeSpan offset, TimeSeekOrigin origin);
    public void SeekAlignedToLastTick(TimeSpan offset, TimeSeekOrigin origin);
    public void Stop();
    public void Remove();
    public Clock get_Clock();
    public double get_SpeedRatio();
    public void set_SpeedRatio(double value);
}
public class System.Windows.Media.Animation.ClockGroup : Clock {
    private List`1<Clock> _children;
    private List`1<WeakReference> _rootChildren;
    private TimeIntervalCollection _currentIntervals;
    public TimelineGroup Timeline { get; }
    public ClockCollection Children { get; }
    internal List`1<Clock> InternalChildren { get; }
    internal List`1<WeakReference> InternalRootChildren { get; }
    internal Clock FirstChild { get; }
    internal Duration CurrentDuration { get; }
    internal bool RootHasChildren { get; }
    internal TimeIntervalCollection CurrentIntervals { get; }
    protected internal ClockGroup(TimelineGroup timelineGroup);
    public TimelineGroup get_Timeline();
    public ClockCollection get_Children();
    internal List`1<Clock> get_InternalChildren();
    internal List`1<WeakReference> get_InternalRootChildren();
    internal virtual void BuildClockSubTreeFromTimeline(Timeline timeline, bool hasControllableRoot);
    internal virtual Clock get_FirstChild();
    internal int GetMaxDesiredFrameRate();
    internal void ComputeTreeState();
    internal void ComputeTreeStateRoot();
    private void ComputeTreeStatePostfix();
    private void ClipNextTickByChildren();
    internal virtual Duration get_CurrentDuration();
    internal void MakeRoot(TimeManager timeManager);
    internal virtual void ResetNodesWithSlip();
    internal void RootActivate();
    internal void RootCleanChildren();
    internal bool get_RootHasChildren();
    internal void RootDisable();
    internal virtual void UpdateDescendantsWithUnresolvedDuration();
    internal virtual void ClearCurrentIntervalsToNull();
    internal virtual void AddNullPointToCurrentIntervals();
    internal virtual void ComputeCurrentIntervals(TimeIntervalCollection parentIntervalCollection, TimeSpan beginTime, Nullable`1<TimeSpan> endTime, Duration fillDuration, Duration period, double appliedSpeedRatio, double accelRatio, double decelRatio, bool isAutoReversed);
    internal virtual void ComputeCurrentFillInterval(TimeIntervalCollection parentIntervalCollection, TimeSpan beginTime, TimeSpan endTime, Duration period, double appliedSpeedRatio, double accelRatio, double decelRatio, bool isAutoReversed);
    internal TimeIntervalCollection get_CurrentIntervals();
}
public enum System.Windows.Media.Animation.ClockState : Enum {
    public int value__;
    public static ClockState Active;
    public static ClockState Filling;
    public static ClockState Stopped;
}
public class System.Windows.Media.Animation.ColorAnimation : ColorAnimationBase {
    private Color[] _keyValues;
    private AnimationType _animationType;
    private bool _isAnimationFunctionValid;
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public Nullable`1<Color> From { get; public set; }
    public Nullable`1<Color> To { get; public set; }
    public Nullable`1<Color> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private static ColorAnimation();
    public ColorAnimation(Color toValue, Duration duration);
    public ColorAnimation(Color toValue, Duration duration, FillBehavior fillBehavior);
    public ColorAnimation(Color fromValue, Color toValue, Duration duration);
    public ColorAnimation(Color fromValue, Color toValue, Duration duration, FillBehavior fillBehavior);
    public ColorAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Color GetCurrentValueCore(Color defaultOriginValue, Color defaultDestinationValue, AnimationClock animationClock);
    private void ValidateAnimationFunction();
    private static void AnimationFunction_Changed(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static bool ValidateFromToOrByValue(object value);
    public Nullable`1<Color> get_From();
    public void set_From(Nullable`1<Color> value);
    public Nullable`1<Color> get_To();
    public void set_To(Nullable`1<Color> value);
    public Nullable`1<Color> get_By();
    public void set_By(Nullable`1<Color> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
}
public abstract class System.Windows.Media.Animation.ColorAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public ColorAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual Type get_TargetPropertyType();
    public Color GetCurrentValue(Color defaultOriginValue, Color defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual Color GetCurrentValueCore(Color defaultOriginValue, Color defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.ColorAnimationUsingKeyFrames : ColorAnimationBase {
    private ColorKeyFrameCollection _keyFrames;
    private ResolvedKeyFrameEntry[] _sortedResolvedKeyFrames;
    private bool _areKeyTimesValid;
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public ColorKeyFrameCollection KeyFrames { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private TimeSpan LargestTimeSpanKeyTime { get; }
    public ColorAnimationUsingKeyFrames Clone();
    public ColorAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private void CopyCommon(ColorAnimationUsingKeyFrames sourceAnimation, bool isCurrentValueClone);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual Color GetCurrentValueCore(Color defaultOriginValue, Color defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public ColorKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(ColorKeyFrameCollection value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    private Color GetResolvedKeyFrameValue(int resolvedKeyFrameIndex);
    private ColorKeyFrame GetResolvedKeyFrame(int resolvedKeyFrameIndex);
    private TimeSpan get_LargestTimeSpanKeyTime();
    private void ResolveKeyTimes();
    private void ResolvePacedKeyTimes();
}
internal class System.Windows.Media.Animation.ColorIndependentAnimationStorage : IndependentAnimationStorage {
    protected ResourceType ResourceType { get; }
    protected virtual ResourceType get_ResourceType();
    protected virtual void UpdateResourceCore(Channel channel);
}
public abstract class System.Windows.Media.Animation.ColorKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public Color Value { get; public set; }
    protected ColorKeyFrame(Color value);
    protected ColorKeyFrame(Color value, KeyTime keyTime);
    private static ColorKeyFrame();
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public Color get_Value();
    public void set_Value(Color value);
    public Color InterpolateValue(Color baseValue, double keyFrameProgress);
    protected abstract virtual Color InterpolateValueCore(Color baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.ColorKeyFrameCollection : Freezable {
    private List`1<ColorKeyFrame> _keyFrames;
    private static ColorKeyFrameCollection s_emptyCollection;
    public static ColorKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public ColorKeyFrame Item { get; public set; }
    public static ColorKeyFrameCollection get_Empty();
    public ColorKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(ColorKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(ColorKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(ColorKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(ColorKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, ColorKeyFrame keyFrame);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(ColorKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public ColorKeyFrame get_Item(int index);
    public void set_Item(int index, ColorKeyFrame value);
}
public class System.Windows.Media.Animation.CubicEase : EasingFunctionBase {
    protected virtual double EaseInCore(double normalizedTime);
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Animation.DecimalAnimation : DecimalAnimationBase {
    private Decimal[] _keyValues;
    private AnimationType _animationType;
    private bool _isAnimationFunctionValid;
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public Nullable`1<decimal> From { get; public set; }
    public Nullable`1<decimal> To { get; public set; }
    public Nullable`1<decimal> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private static DecimalAnimation();
    public DecimalAnimation(decimal toValue, Duration duration);
    public DecimalAnimation(decimal toValue, Duration duration, FillBehavior fillBehavior);
    public DecimalAnimation(decimal fromValue, decimal toValue, Duration duration);
    public DecimalAnimation(decimal fromValue, decimal toValue, Duration duration, FillBehavior fillBehavior);
    public DecimalAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual decimal GetCurrentValueCore(decimal defaultOriginValue, decimal defaultDestinationValue, AnimationClock animationClock);
    private void ValidateAnimationFunction();
    private static void AnimationFunction_Changed(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static bool ValidateFromToOrByValue(object value);
    public Nullable`1<decimal> get_From();
    public void set_From(Nullable`1<decimal> value);
    public Nullable`1<decimal> get_To();
    public void set_To(Nullable`1<decimal> value);
    public Nullable`1<decimal> get_By();
    public void set_By(Nullable`1<decimal> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
}
public abstract class System.Windows.Media.Animation.DecimalAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public DecimalAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual Type get_TargetPropertyType();
    public decimal GetCurrentValue(decimal defaultOriginValue, decimal defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual decimal GetCurrentValueCore(decimal defaultOriginValue, decimal defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.DecimalAnimationUsingKeyFrames : DecimalAnimationBase {
    private DecimalKeyFrameCollection _keyFrames;
    private ResolvedKeyFrameEntry[] _sortedResolvedKeyFrames;
    private bool _areKeyTimesValid;
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public DecimalKeyFrameCollection KeyFrames { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private TimeSpan LargestTimeSpanKeyTime { get; }
    public DecimalAnimationUsingKeyFrames Clone();
    public DecimalAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private void CopyCommon(DecimalAnimationUsingKeyFrames sourceAnimation, bool isCurrentValueClone);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual decimal GetCurrentValueCore(decimal defaultOriginValue, decimal defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public DecimalKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(DecimalKeyFrameCollection value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    private decimal GetResolvedKeyFrameValue(int resolvedKeyFrameIndex);
    private DecimalKeyFrame GetResolvedKeyFrame(int resolvedKeyFrameIndex);
    private TimeSpan get_LargestTimeSpanKeyTime();
    private void ResolveKeyTimes();
    private void ResolvePacedKeyTimes();
}
public abstract class System.Windows.Media.Animation.DecimalKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public decimal Value { get; public set; }
    protected DecimalKeyFrame(decimal value);
    protected DecimalKeyFrame(decimal value, KeyTime keyTime);
    private static DecimalKeyFrame();
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public decimal get_Value();
    public void set_Value(decimal value);
    public decimal InterpolateValue(decimal baseValue, double keyFrameProgress);
    protected abstract virtual decimal InterpolateValueCore(decimal baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.DecimalKeyFrameCollection : Freezable {
    private List`1<DecimalKeyFrame> _keyFrames;
    private static DecimalKeyFrameCollection s_emptyCollection;
    public static DecimalKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public DecimalKeyFrame Item { get; public set; }
    public static DecimalKeyFrameCollection get_Empty();
    public DecimalKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(DecimalKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(DecimalKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(DecimalKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(DecimalKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, DecimalKeyFrame keyFrame);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(DecimalKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public DecimalKeyFrame get_Item(int index);
    public void set_Item(int index, DecimalKeyFrame value);
}
public class System.Windows.Media.Animation.DiscreteBooleanKeyFrame : BooleanKeyFrame {
    public DiscreteBooleanKeyFrame(bool value);
    public DiscreteBooleanKeyFrame(bool value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual bool InterpolateValueCore(bool baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteByteKeyFrame : ByteKeyFrame {
    public DiscreteByteKeyFrame(byte value);
    public DiscreteByteKeyFrame(byte value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual byte InterpolateValueCore(byte baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteCharKeyFrame : CharKeyFrame {
    public DiscreteCharKeyFrame(char value);
    public DiscreteCharKeyFrame(char value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual char InterpolateValueCore(char baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteColorKeyFrame : ColorKeyFrame {
    public DiscreteColorKeyFrame(Color value);
    public DiscreteColorKeyFrame(Color value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Color InterpolateValueCore(Color baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteDecimalKeyFrame : DecimalKeyFrame {
    public DiscreteDecimalKeyFrame(decimal value);
    public DiscreteDecimalKeyFrame(decimal value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual decimal InterpolateValueCore(decimal baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteDoubleKeyFrame : DoubleKeyFrame {
    public DiscreteDoubleKeyFrame(double value);
    public DiscreteDoubleKeyFrame(double value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual double InterpolateValueCore(double baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteInt16KeyFrame : Int16KeyFrame {
    public DiscreteInt16KeyFrame(short value);
    public DiscreteInt16KeyFrame(short value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual short InterpolateValueCore(short baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteInt32KeyFrame : Int32KeyFrame {
    public DiscreteInt32KeyFrame(int value);
    public DiscreteInt32KeyFrame(int value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual int InterpolateValueCore(int baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteInt64KeyFrame : Int64KeyFrame {
    public DiscreteInt64KeyFrame(long value);
    public DiscreteInt64KeyFrame(long value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual long InterpolateValueCore(long baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteMatrixKeyFrame : MatrixKeyFrame {
    public DiscreteMatrixKeyFrame(Matrix value);
    public DiscreteMatrixKeyFrame(Matrix value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Matrix InterpolateValueCore(Matrix baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteObjectKeyFrame : ObjectKeyFrame {
    public DiscreteObjectKeyFrame(object value);
    public DiscreteObjectKeyFrame(object value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual object InterpolateValueCore(object baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscretePoint3DKeyFrame : Point3DKeyFrame {
    public DiscretePoint3DKeyFrame(Point3D value);
    public DiscretePoint3DKeyFrame(Point3D value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Point3D InterpolateValueCore(Point3D baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscretePointKeyFrame : PointKeyFrame {
    public DiscretePointKeyFrame(Point value);
    public DiscretePointKeyFrame(Point value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Point InterpolateValueCore(Point baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteQuaternionKeyFrame : QuaternionKeyFrame {
    public DiscreteQuaternionKeyFrame(Quaternion value);
    public DiscreteQuaternionKeyFrame(Quaternion value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Quaternion InterpolateValueCore(Quaternion baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteRectKeyFrame : RectKeyFrame {
    public DiscreteRectKeyFrame(Rect value);
    public DiscreteRectKeyFrame(Rect value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Rect InterpolateValueCore(Rect baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteRotation3DKeyFrame : Rotation3DKeyFrame {
    public DiscreteRotation3DKeyFrame(Rotation3D value);
    public DiscreteRotation3DKeyFrame(Rotation3D value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Rotation3D InterpolateValueCore(Rotation3D baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteSingleKeyFrame : SingleKeyFrame {
    public DiscreteSingleKeyFrame(float value);
    public DiscreteSingleKeyFrame(float value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual float InterpolateValueCore(float baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteSizeKeyFrame : SizeKeyFrame {
    public DiscreteSizeKeyFrame(Size value);
    public DiscreteSizeKeyFrame(Size value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Size InterpolateValueCore(Size baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteStringKeyFrame : StringKeyFrame {
    public DiscreteStringKeyFrame(string value);
    public DiscreteStringKeyFrame(string value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual string InterpolateValueCore(string baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteVector3DKeyFrame : Vector3DKeyFrame {
    public DiscreteVector3DKeyFrame(Vector3D value);
    public DiscreteVector3DKeyFrame(Vector3D value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Vector3D InterpolateValueCore(Vector3D baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DiscreteVectorKeyFrame : VectorKeyFrame {
    public DiscreteVectorKeyFrame(Vector value);
    public DiscreteVectorKeyFrame(Vector value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Vector InterpolateValueCore(Vector baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.DoubleAnimation : DoubleAnimationBase {
    private Double[] _keyValues;
    private AnimationType _animationType;
    private bool _isAnimationFunctionValid;
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public Nullable`1<double> From { get; public set; }
    public Nullable`1<double> To { get; public set; }
    public Nullable`1<double> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private static DoubleAnimation();
    public DoubleAnimation(double toValue, Duration duration);
    public DoubleAnimation(double toValue, Duration duration, FillBehavior fillBehavior);
    public DoubleAnimation(double fromValue, double toValue, Duration duration);
    public DoubleAnimation(double fromValue, double toValue, Duration duration, FillBehavior fillBehavior);
    public DoubleAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual double GetCurrentValueCore(double defaultOriginValue, double defaultDestinationValue, AnimationClock animationClock);
    private void ValidateAnimationFunction();
    private static void AnimationFunction_Changed(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static bool ValidateFromToOrByValue(object value);
    public Nullable`1<double> get_From();
    public void set_From(Nullable`1<double> value);
    public Nullable`1<double> get_To();
    public void set_To(Nullable`1<double> value);
    public Nullable`1<double> get_By();
    public void set_By(Nullable`1<double> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
}
public abstract class System.Windows.Media.Animation.DoubleAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public DoubleAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual Type get_TargetPropertyType();
    public double GetCurrentValue(double defaultOriginValue, double defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual double GetCurrentValueCore(double defaultOriginValue, double defaultDestinationValue, AnimationClock animationClock);
}
internal class System.Windows.Media.Animation.DoubleAnimationClockResource : AnimationClockResource {
    private double _baseValue;
    public double BaseValue { get; }
    public double CurrentValue { get; }
    protected ResourceType ResourceType { get; }
    public DoubleAnimationClockResource(double baseValue, AnimationClock animationClock);
    public double get_BaseValue();
    public double get_CurrentValue();
    protected virtual ResourceType get_ResourceType();
    protected virtual void UpdateResource(ResourceHandle handle, Channel channel);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.DoubleAnimationUsingKeyFrames : DoubleAnimationBase {
    private DoubleKeyFrameCollection _keyFrames;
    private ResolvedKeyFrameEntry[] _sortedResolvedKeyFrames;
    private bool _areKeyTimesValid;
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public DoubleKeyFrameCollection KeyFrames { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private TimeSpan LargestTimeSpanKeyTime { get; }
    public DoubleAnimationUsingKeyFrames Clone();
    public DoubleAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private void CopyCommon(DoubleAnimationUsingKeyFrames sourceAnimation, bool isCurrentValueClone);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual double GetCurrentValueCore(double defaultOriginValue, double defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public DoubleKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(DoubleKeyFrameCollection value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    private double GetResolvedKeyFrameValue(int resolvedKeyFrameIndex);
    private DoubleKeyFrame GetResolvedKeyFrame(int resolvedKeyFrameIndex);
    private TimeSpan get_LargestTimeSpanKeyTime();
    private void ResolveKeyTimes();
    private void ResolvePacedKeyTimes();
}
public class System.Windows.Media.Animation.DoubleAnimationUsingPath : DoubleAnimationBase {
    private bool _isValid;
    private double _accumulatingValue;
    public static DependencyProperty PathGeometryProperty;
    public static DependencyProperty SourceProperty;
    public PathGeometry PathGeometry { get; public set; }
    public PathAnimationSource Source { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private static DoubleAnimationUsingPath();
    public PathGeometry get_PathGeometry();
    public void set_PathGeometry(PathGeometry value);
    public PathAnimationSource get_Source();
    public void set_Source(PathAnimationSource value);
    public DoubleAnimationUsingPath Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void OnChanged();
    protected virtual double GetCurrentValueCore(double defaultOriginValue, double defaultDestinationValue, AnimationClock animationClock);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    private void Validate();
    internal static double CalculateAngleFromTangentVector(double x, double y);
}
internal class System.Windows.Media.Animation.DoubleIndependentAnimationStorage : IndependentAnimationStorage {
    protected ResourceType ResourceType { get; }
    protected virtual ResourceType get_ResourceType();
    protected virtual void UpdateResourceCore(Channel channel);
}
public abstract class System.Windows.Media.Animation.DoubleKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public double Value { get; public set; }
    protected DoubleKeyFrame(double value);
    protected DoubleKeyFrame(double value, KeyTime keyTime);
    private static DoubleKeyFrame();
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public double get_Value();
    public void set_Value(double value);
    public double InterpolateValue(double baseValue, double keyFrameProgress);
    protected abstract virtual double InterpolateValueCore(double baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.DoubleKeyFrameCollection : Freezable {
    private List`1<DoubleKeyFrame> _keyFrames;
    private static DoubleKeyFrameCollection s_emptyCollection;
    public static DoubleKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public DoubleKeyFrame Item { get; public set; }
    public static DoubleKeyFrameCollection get_Empty();
    public DoubleKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(DoubleKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(DoubleKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(DoubleKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(DoubleKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, DoubleKeyFrame keyFrame);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(DoubleKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public DoubleKeyFrame get_Item(int index);
    public void set_Item(int index, DoubleKeyFrame value);
}
public class System.Windows.Media.Animation.EasingByteKeyFrame : ByteKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingByteKeyFrame(byte value);
    public EasingByteKeyFrame(byte value, KeyTime keyTime);
    public EasingByteKeyFrame(byte value, KeyTime keyTime, IEasingFunction easingFunction);
    private static EasingByteKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual byte InterpolateValueCore(byte baseValue, double keyFrameProgress);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
}
public class System.Windows.Media.Animation.EasingColorKeyFrame : ColorKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingColorKeyFrame(Color value);
    public EasingColorKeyFrame(Color value, KeyTime keyTime);
    public EasingColorKeyFrame(Color value, KeyTime keyTime, IEasingFunction easingFunction);
    private static EasingColorKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Color InterpolateValueCore(Color baseValue, double keyFrameProgress);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
}
public class System.Windows.Media.Animation.EasingDecimalKeyFrame : DecimalKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingDecimalKeyFrame(decimal value);
    public EasingDecimalKeyFrame(decimal value, KeyTime keyTime);
    public EasingDecimalKeyFrame(decimal value, KeyTime keyTime, IEasingFunction easingFunction);
    private static EasingDecimalKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual decimal InterpolateValueCore(decimal baseValue, double keyFrameProgress);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
}
public class System.Windows.Media.Animation.EasingDoubleKeyFrame : DoubleKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingDoubleKeyFrame(double value);
    public EasingDoubleKeyFrame(double value, KeyTime keyTime);
    public EasingDoubleKeyFrame(double value, KeyTime keyTime, IEasingFunction easingFunction);
    private static EasingDoubleKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual double InterpolateValueCore(double baseValue, double keyFrameProgress);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
}
public abstract class System.Windows.Media.Animation.EasingFunctionBase : Freezable {
    public static DependencyProperty EasingModeProperty;
    public EasingMode EasingMode { get; public set; }
    private static EasingFunctionBase();
    public EasingMode get_EasingMode();
    public void set_EasingMode(EasingMode value);
    public sealed virtual double Ease(double normalizedTime);
    protected abstract virtual double EaseInCore(double normalizedTime);
}
public class System.Windows.Media.Animation.EasingInt16KeyFrame : Int16KeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingInt16KeyFrame(short value);
    public EasingInt16KeyFrame(short value, KeyTime keyTime);
    public EasingInt16KeyFrame(short value, KeyTime keyTime, IEasingFunction easingFunction);
    private static EasingInt16KeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual short InterpolateValueCore(short baseValue, double keyFrameProgress);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
}
public class System.Windows.Media.Animation.EasingInt32KeyFrame : Int32KeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingInt32KeyFrame(int value);
    public EasingInt32KeyFrame(int value, KeyTime keyTime);
    public EasingInt32KeyFrame(int value, KeyTime keyTime, IEasingFunction easingFunction);
    private static EasingInt32KeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual int InterpolateValueCore(int baseValue, double keyFrameProgress);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
}
public class System.Windows.Media.Animation.EasingInt64KeyFrame : Int64KeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingInt64KeyFrame(long value);
    public EasingInt64KeyFrame(long value, KeyTime keyTime);
    public EasingInt64KeyFrame(long value, KeyTime keyTime, IEasingFunction easingFunction);
    private static EasingInt64KeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual long InterpolateValueCore(long baseValue, double keyFrameProgress);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
}
public enum System.Windows.Media.Animation.EasingMode : Enum {
    public int value__;
    public static EasingMode EaseIn;
    public static EasingMode EaseOut;
    public static EasingMode EaseInOut;
}
public class System.Windows.Media.Animation.EasingPoint3DKeyFrame : Point3DKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingPoint3DKeyFrame(Point3D value);
    public EasingPoint3DKeyFrame(Point3D value, KeyTime keyTime);
    public EasingPoint3DKeyFrame(Point3D value, KeyTime keyTime, IEasingFunction easingFunction);
    private static EasingPoint3DKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Point3D InterpolateValueCore(Point3D baseValue, double keyFrameProgress);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
}
public class System.Windows.Media.Animation.EasingPointKeyFrame : PointKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingPointKeyFrame(Point value);
    public EasingPointKeyFrame(Point value, KeyTime keyTime);
    public EasingPointKeyFrame(Point value, KeyTime keyTime, IEasingFunction easingFunction);
    private static EasingPointKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Point InterpolateValueCore(Point baseValue, double keyFrameProgress);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
}
public class System.Windows.Media.Animation.EasingQuaternionKeyFrame : QuaternionKeyFrame {
    public static DependencyProperty UseShortestPathProperty;
    public static DependencyProperty EasingFunctionProperty;
    public bool UseShortestPath { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public EasingQuaternionKeyFrame(Quaternion value);
    public EasingQuaternionKeyFrame(Quaternion value, KeyTime keyTime);
    public EasingQuaternionKeyFrame(Quaternion value, KeyTime keyTime, IEasingFunction easingFunction);
    private static EasingQuaternionKeyFrame();
    public bool get_UseShortestPath();
    public void set_UseShortestPath(bool value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Quaternion InterpolateValueCore(Quaternion baseValue, double keyFrameProgress);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
}
public class System.Windows.Media.Animation.EasingRectKeyFrame : RectKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingRectKeyFrame(Rect value);
    public EasingRectKeyFrame(Rect value, KeyTime keyTime);
    public EasingRectKeyFrame(Rect value, KeyTime keyTime, IEasingFunction easingFunction);
    private static EasingRectKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Rect InterpolateValueCore(Rect baseValue, double keyFrameProgress);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
}
public class System.Windows.Media.Animation.EasingRotation3DKeyFrame : Rotation3DKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingRotation3DKeyFrame(Rotation3D value);
    public EasingRotation3DKeyFrame(Rotation3D value, KeyTime keyTime);
    public EasingRotation3DKeyFrame(Rotation3D value, KeyTime keyTime, IEasingFunction easingFunction);
    private static EasingRotation3DKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Rotation3D InterpolateValueCore(Rotation3D baseValue, double keyFrameProgress);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
}
public class System.Windows.Media.Animation.EasingSingleKeyFrame : SingleKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingSingleKeyFrame(float value);
    public EasingSingleKeyFrame(float value, KeyTime keyTime);
    public EasingSingleKeyFrame(float value, KeyTime keyTime, IEasingFunction easingFunction);
    private static EasingSingleKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual float InterpolateValueCore(float baseValue, double keyFrameProgress);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
}
public class System.Windows.Media.Animation.EasingSizeKeyFrame : SizeKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingSizeKeyFrame(Size value);
    public EasingSizeKeyFrame(Size value, KeyTime keyTime);
    public EasingSizeKeyFrame(Size value, KeyTime keyTime, IEasingFunction easingFunction);
    private static EasingSizeKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Size InterpolateValueCore(Size baseValue, double keyFrameProgress);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
}
public class System.Windows.Media.Animation.EasingVector3DKeyFrame : Vector3DKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingVector3DKeyFrame(Vector3D value);
    public EasingVector3DKeyFrame(Vector3D value, KeyTime keyTime);
    public EasingVector3DKeyFrame(Vector3D value, KeyTime keyTime, IEasingFunction easingFunction);
    private static EasingVector3DKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Vector3D InterpolateValueCore(Vector3D baseValue, double keyFrameProgress);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
}
public class System.Windows.Media.Animation.EasingVectorKeyFrame : VectorKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingVectorKeyFrame(Vector value);
    public EasingVectorKeyFrame(Vector value, KeyTime keyTime);
    public EasingVectorKeyFrame(Vector value, KeyTime keyTime, IEasingFunction easingFunction);
    private static EasingVectorKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Vector InterpolateValueCore(Vector baseValue, double keyFrameProgress);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
}
public class System.Windows.Media.Animation.ElasticEase : EasingFunctionBase {
    public static DependencyProperty OscillationsProperty;
    public static DependencyProperty SpringinessProperty;
    public int Oscillations { get; public set; }
    public double Springiness { get; public set; }
    private static ElasticEase();
    public int get_Oscillations();
    public void set_Oscillations(int value);
    public double get_Springiness();
    public void set_Springiness(double value);
    protected virtual double EaseInCore(double normalizedTime);
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Animation.ExponentialEase : EasingFunctionBase {
    public static DependencyProperty ExponentProperty;
    public double Exponent { get; public set; }
    private static ExponentialEase();
    public double get_Exponent();
    public void set_Exponent(double value);
    protected virtual double EaseInCore(double normalizedTime);
    protected virtual Freezable CreateInstanceCore();
}
public enum System.Windows.Media.Animation.FillBehavior : Enum {
    public int value__;
    public static FillBehavior HoldEnd;
    public static FillBehavior Stop;
}
public enum System.Windows.Media.Animation.HandoffBehavior : Enum {
    public int value__;
    public static HandoffBehavior SnapshotAndReplace;
    public static HandoffBehavior Compose;
}
internal static class System.Windows.Media.Animation.HandoffBehaviorEnum : object {
    [FriendAccessAllowedAttribute]
internal static bool IsDefined(HandoffBehavior handoffBehavior);
}
public interface System.Windows.Media.Animation.IAnimatable {
    public bool HasAnimatedProperties { get; }
    public abstract virtual void ApplyAnimationClock(DependencyProperty dp, AnimationClock clock);
    public abstract virtual void ApplyAnimationClock(DependencyProperty dp, AnimationClock clock, HandoffBehavior handoffBehavior);
    public abstract virtual void BeginAnimation(DependencyProperty dp, AnimationTimeline animation);
    public abstract virtual void BeginAnimation(DependencyProperty dp, AnimationTimeline animation, HandoffBehavior handoffBehavior);
    public abstract virtual bool get_HasAnimatedProperties();
    public abstract virtual object GetAnimationBaseValue(DependencyProperty dp);
}
public interface System.Windows.Media.Animation.IAnimation {
    public abstract virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
}
internal interface System.Windows.Media.Animation.IClock {
    public TimeSpan CurrentTime { get; }
    public abstract virtual TimeSpan get_CurrentTime();
}
public interface System.Windows.Media.Animation.IEasingFunction {
    public abstract virtual double Ease(double normalizedTime);
}
public interface System.Windows.Media.Animation.IKeyFrame {
    public KeyTime KeyTime { get; public set; }
    public object Value { get; public set; }
    public abstract virtual KeyTime get_KeyTime();
    public abstract virtual void set_KeyTime(KeyTime value);
    public abstract virtual object get_Value();
    public abstract virtual void set_Value(object value);
}
public interface System.Windows.Media.Animation.IKeyFrameAnimation {
    public IList KeyFrames { get; public set; }
    public abstract virtual IList get_KeyFrames();
    public abstract virtual void set_KeyFrames(IList value);
}
internal abstract class System.Windows.Media.Animation.IndependentAnimationStorage : AnimationStorage {
    protected ResourcesUpdatedHandler _updateResourceHandler;
    protected MultiChannelResource _duceResource;
    private bool _isValid;
    protected ResourceType ResourceType { get; }
    protected abstract virtual void UpdateResourceCore(Channel channel);
    protected abstract virtual ResourceType get_ResourceType();
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.RemoveChildFromParent(IResource parent, Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.Get3DHandle(Channel channel);
    private void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal void InvalidateResource();
    internal static ResourceHandle GetResourceHandle(DependencyObject d, DependencyProperty dp, Channel channel);
}
internal class System.Windows.Media.Animation.IndependentlyAnimatedPropertyMetadata : UIPropertyMetadata {
    internal IndependentlyAnimatedPropertyMetadata(object defaultValue);
    internal IndependentlyAnimatedPropertyMetadata(object defaultValue, PropertyChangedCallback propertyChangedCallback, CoerceValueCallback coerceValueCallback);
    internal virtual PropertyMetadata CreateInstance();
}
public class System.Windows.Media.Animation.Int16Animation : Int16AnimationBase {
    private Int16[] _keyValues;
    private AnimationType _animationType;
    private bool _isAnimationFunctionValid;
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public Nullable`1<short> From { get; public set; }
    public Nullable`1<short> To { get; public set; }
    public Nullable`1<short> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private static Int16Animation();
    public Int16Animation(short toValue, Duration duration);
    public Int16Animation(short toValue, Duration duration, FillBehavior fillBehavior);
    public Int16Animation(short fromValue, short toValue, Duration duration);
    public Int16Animation(short fromValue, short toValue, Duration duration, FillBehavior fillBehavior);
    public Int16Animation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual short GetCurrentValueCore(short defaultOriginValue, short defaultDestinationValue, AnimationClock animationClock);
    private void ValidateAnimationFunction();
    private static void AnimationFunction_Changed(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static bool ValidateFromToOrByValue(object value);
    public Nullable`1<short> get_From();
    public void set_From(Nullable`1<short> value);
    public Nullable`1<short> get_To();
    public void set_To(Nullable`1<short> value);
    public Nullable`1<short> get_By();
    public void set_By(Nullable`1<short> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
}
public abstract class System.Windows.Media.Animation.Int16AnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public Int16AnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual Type get_TargetPropertyType();
    public short GetCurrentValue(short defaultOriginValue, short defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual short GetCurrentValueCore(short defaultOriginValue, short defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.Int16AnimationUsingKeyFrames : Int16AnimationBase {
    private Int16KeyFrameCollection _keyFrames;
    private ResolvedKeyFrameEntry[] _sortedResolvedKeyFrames;
    private bool _areKeyTimesValid;
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public Int16KeyFrameCollection KeyFrames { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private TimeSpan LargestTimeSpanKeyTime { get; }
    public Int16AnimationUsingKeyFrames Clone();
    public Int16AnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private void CopyCommon(Int16AnimationUsingKeyFrames sourceAnimation, bool isCurrentValueClone);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual short GetCurrentValueCore(short defaultOriginValue, short defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public Int16KeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(Int16KeyFrameCollection value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    private short GetResolvedKeyFrameValue(int resolvedKeyFrameIndex);
    private Int16KeyFrame GetResolvedKeyFrame(int resolvedKeyFrameIndex);
    private TimeSpan get_LargestTimeSpanKeyTime();
    private void ResolveKeyTimes();
    private void ResolvePacedKeyTimes();
}
public abstract class System.Windows.Media.Animation.Int16KeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public short Value { get; public set; }
    protected Int16KeyFrame(short value);
    protected Int16KeyFrame(short value, KeyTime keyTime);
    private static Int16KeyFrame();
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public short get_Value();
    public void set_Value(short value);
    public short InterpolateValue(short baseValue, double keyFrameProgress);
    protected abstract virtual short InterpolateValueCore(short baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.Int16KeyFrameCollection : Freezable {
    private List`1<Int16KeyFrame> _keyFrames;
    private static Int16KeyFrameCollection s_emptyCollection;
    public static Int16KeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public Int16KeyFrame Item { get; public set; }
    public static Int16KeyFrameCollection get_Empty();
    public Int16KeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(Int16KeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(Int16KeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(Int16KeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(Int16KeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, Int16KeyFrame keyFrame);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(Int16KeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public Int16KeyFrame get_Item(int index);
    public void set_Item(int index, Int16KeyFrame value);
}
public class System.Windows.Media.Animation.Int32Animation : Int32AnimationBase {
    private Int32[] _keyValues;
    private AnimationType _animationType;
    private bool _isAnimationFunctionValid;
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public Nullable`1<int> From { get; public set; }
    public Nullable`1<int> To { get; public set; }
    public Nullable`1<int> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private static Int32Animation();
    public Int32Animation(int toValue, Duration duration);
    public Int32Animation(int toValue, Duration duration, FillBehavior fillBehavior);
    public Int32Animation(int fromValue, int toValue, Duration duration);
    public Int32Animation(int fromValue, int toValue, Duration duration, FillBehavior fillBehavior);
    public Int32Animation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual int GetCurrentValueCore(int defaultOriginValue, int defaultDestinationValue, AnimationClock animationClock);
    private void ValidateAnimationFunction();
    private static void AnimationFunction_Changed(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static bool ValidateFromToOrByValue(object value);
    public Nullable`1<int> get_From();
    public void set_From(Nullable`1<int> value);
    public Nullable`1<int> get_To();
    public void set_To(Nullable`1<int> value);
    public Nullable`1<int> get_By();
    public void set_By(Nullable`1<int> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
}
public abstract class System.Windows.Media.Animation.Int32AnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public Int32AnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual Type get_TargetPropertyType();
    public int GetCurrentValue(int defaultOriginValue, int defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual int GetCurrentValueCore(int defaultOriginValue, int defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.Int32AnimationUsingKeyFrames : Int32AnimationBase {
    private Int32KeyFrameCollection _keyFrames;
    private ResolvedKeyFrameEntry[] _sortedResolvedKeyFrames;
    private bool _areKeyTimesValid;
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public Int32KeyFrameCollection KeyFrames { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private TimeSpan LargestTimeSpanKeyTime { get; }
    public Int32AnimationUsingKeyFrames Clone();
    public Int32AnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private void CopyCommon(Int32AnimationUsingKeyFrames sourceAnimation, bool isCurrentValueClone);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual int GetCurrentValueCore(int defaultOriginValue, int defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public Int32KeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(Int32KeyFrameCollection value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    private int GetResolvedKeyFrameValue(int resolvedKeyFrameIndex);
    private Int32KeyFrame GetResolvedKeyFrame(int resolvedKeyFrameIndex);
    private TimeSpan get_LargestTimeSpanKeyTime();
    private void ResolveKeyTimes();
    private void ResolvePacedKeyTimes();
}
public abstract class System.Windows.Media.Animation.Int32KeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public int Value { get; public set; }
    protected Int32KeyFrame(int value);
    protected Int32KeyFrame(int value, KeyTime keyTime);
    private static Int32KeyFrame();
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public int get_Value();
    public void set_Value(int value);
    public int InterpolateValue(int baseValue, double keyFrameProgress);
    protected abstract virtual int InterpolateValueCore(int baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.Int32KeyFrameCollection : Freezable {
    private List`1<Int32KeyFrame> _keyFrames;
    private static Int32KeyFrameCollection s_emptyCollection;
    public static Int32KeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public Int32KeyFrame Item { get; public set; }
    public static Int32KeyFrameCollection get_Empty();
    public Int32KeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(Int32KeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(Int32KeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(Int32KeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(Int32KeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, Int32KeyFrame keyFrame);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(Int32KeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public Int32KeyFrame get_Item(int index);
    public void set_Item(int index, Int32KeyFrame value);
}
public class System.Windows.Media.Animation.Int64Animation : Int64AnimationBase {
    private Int64[] _keyValues;
    private AnimationType _animationType;
    private bool _isAnimationFunctionValid;
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public Nullable`1<long> From { get; public set; }
    public Nullable`1<long> To { get; public set; }
    public Nullable`1<long> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private static Int64Animation();
    public Int64Animation(long toValue, Duration duration);
    public Int64Animation(long toValue, Duration duration, FillBehavior fillBehavior);
    public Int64Animation(long fromValue, long toValue, Duration duration);
    public Int64Animation(long fromValue, long toValue, Duration duration, FillBehavior fillBehavior);
    public Int64Animation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual long GetCurrentValueCore(long defaultOriginValue, long defaultDestinationValue, AnimationClock animationClock);
    private void ValidateAnimationFunction();
    private static void AnimationFunction_Changed(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static bool ValidateFromToOrByValue(object value);
    public Nullable`1<long> get_From();
    public void set_From(Nullable`1<long> value);
    public Nullable`1<long> get_To();
    public void set_To(Nullable`1<long> value);
    public Nullable`1<long> get_By();
    public void set_By(Nullable`1<long> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
}
public abstract class System.Windows.Media.Animation.Int64AnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public Int64AnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual Type get_TargetPropertyType();
    public long GetCurrentValue(long defaultOriginValue, long defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual long GetCurrentValueCore(long defaultOriginValue, long defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.Int64AnimationUsingKeyFrames : Int64AnimationBase {
    private Int64KeyFrameCollection _keyFrames;
    private ResolvedKeyFrameEntry[] _sortedResolvedKeyFrames;
    private bool _areKeyTimesValid;
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public Int64KeyFrameCollection KeyFrames { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private TimeSpan LargestTimeSpanKeyTime { get; }
    public Int64AnimationUsingKeyFrames Clone();
    public Int64AnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private void CopyCommon(Int64AnimationUsingKeyFrames sourceAnimation, bool isCurrentValueClone);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual long GetCurrentValueCore(long defaultOriginValue, long defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public Int64KeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(Int64KeyFrameCollection value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    private long GetResolvedKeyFrameValue(int resolvedKeyFrameIndex);
    private Int64KeyFrame GetResolvedKeyFrame(int resolvedKeyFrameIndex);
    private TimeSpan get_LargestTimeSpanKeyTime();
    private void ResolveKeyTimes();
    private void ResolvePacedKeyTimes();
}
public abstract class System.Windows.Media.Animation.Int64KeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public long Value { get; public set; }
    protected Int64KeyFrame(long value);
    protected Int64KeyFrame(long value, KeyTime keyTime);
    private static Int64KeyFrame();
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public long get_Value();
    public void set_Value(long value);
    public long InterpolateValue(long baseValue, double keyFrameProgress);
    protected abstract virtual long InterpolateValueCore(long baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.Int64KeyFrameCollection : Freezable {
    private List`1<Int64KeyFrame> _keyFrames;
    private static Int64KeyFrameCollection s_emptyCollection;
    public static Int64KeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public Int64KeyFrame Item { get; public set; }
    public static Int64KeyFrameCollection get_Empty();
    public Int64KeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(Int64KeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(Int64KeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(Int64KeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(Int64KeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, Int64KeyFrame keyFrame);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(Int64KeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public Int64KeyFrame get_Item(int index);
    public void set_Item(int index, Int64KeyFrame value);
}
[LocalizabilityAttribute("0")]
[TypeConverterAttribute("System.Windows.KeySplineConverter")]
public class System.Windows.Media.Animation.KeySpline : Freezable {
    private Point _controlPoint1;
    private Point _controlPoint2;
    private bool _isSpecified;
    private bool _isDirty;
    private double _parameter;
    private double _Bx;
    private double _Cx;
    private double _Cx_Bx;
    private double _three_Cx;
    private double _By;
    private double _Cy;
    private static double accuracy;
    private static double fuzz;
    public Point ControlPoint1 { get; public set; }
    public Point ControlPoint2 { get; public set; }
    public KeySpline(double x1, double y1, double x2, double y2);
    public KeySpline(Point controlPoint1, Point controlPoint2);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual void OnChanged();
    public Point get_ControlPoint1();
    public void set_ControlPoint1(Point value);
    public Point get_ControlPoint2();
    public void set_ControlPoint2(Point value);
    public double GetSplineProgress(double linearProgress);
    private bool IsValidControlPoint(Point point);
    private void Build();
    private static double GetBezierValue(double b, double c, double t);
    private void GetXAndDx(double t, Double& x, Double& dx);
    private void SetParameterFromX(double time);
    private void CloneCommon(KeySpline sourceKeySpline);
    public virtual string ToString();
    public string ToString(IFormatProvider formatProvider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider formatProvider);
    internal string InternalConvertToString(string format, IFormatProvider formatProvider);
}
[TypeConverterAttribute("System.Windows.KeyTimeConverter")]
public class System.Windows.Media.Animation.KeyTime : ValueType {
    private object _value;
    private KeyTimeType _type;
    public static KeyTime Uniform { get; }
    public static KeyTime Paced { get; }
    public TimeSpan TimeSpan { get; }
    public double Percent { get; }
    public KeyTimeType Type { get; }
    public static KeyTime FromPercent(double percent);
    public static KeyTime FromTimeSpan(TimeSpan timeSpan);
    public static KeyTime get_Uniform();
    public static KeyTime get_Paced();
    public static bool Equals(KeyTime keyTime1, KeyTime keyTime2);
    public static bool op_Equality(KeyTime keyTime1, KeyTime keyTime2);
    public static bool op_Inequality(KeyTime keyTime1, KeyTime keyTime2);
    public sealed virtual bool Equals(KeyTime value);
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static KeyTime op_Implicit(TimeSpan timeSpan);
    public TimeSpan get_TimeSpan();
    public double get_Percent();
    public KeyTimeType get_Type();
}
public enum System.Windows.Media.Animation.KeyTimeType : Enum {
    public byte value__;
    public static KeyTimeType Uniform;
    public static KeyTimeType Percent;
    public static KeyTimeType TimeSpan;
    public static KeyTimeType Paced;
}
public class System.Windows.Media.Animation.LinearByteKeyFrame : ByteKeyFrame {
    public LinearByteKeyFrame(byte value);
    public LinearByteKeyFrame(byte value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual byte InterpolateValueCore(byte baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearColorKeyFrame : ColorKeyFrame {
    public LinearColorKeyFrame(Color value);
    public LinearColorKeyFrame(Color value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Color InterpolateValueCore(Color baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearDecimalKeyFrame : DecimalKeyFrame {
    public LinearDecimalKeyFrame(decimal value);
    public LinearDecimalKeyFrame(decimal value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual decimal InterpolateValueCore(decimal baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearDoubleKeyFrame : DoubleKeyFrame {
    public LinearDoubleKeyFrame(double value);
    public LinearDoubleKeyFrame(double value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual double InterpolateValueCore(double baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearInt16KeyFrame : Int16KeyFrame {
    public LinearInt16KeyFrame(short value);
    public LinearInt16KeyFrame(short value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual short InterpolateValueCore(short baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearInt32KeyFrame : Int32KeyFrame {
    public LinearInt32KeyFrame(int value);
    public LinearInt32KeyFrame(int value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual int InterpolateValueCore(int baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearInt64KeyFrame : Int64KeyFrame {
    public LinearInt64KeyFrame(long value);
    public LinearInt64KeyFrame(long value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual long InterpolateValueCore(long baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearPoint3DKeyFrame : Point3DKeyFrame {
    public LinearPoint3DKeyFrame(Point3D value);
    public LinearPoint3DKeyFrame(Point3D value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Point3D InterpolateValueCore(Point3D baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearPointKeyFrame : PointKeyFrame {
    public LinearPointKeyFrame(Point value);
    public LinearPointKeyFrame(Point value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Point InterpolateValueCore(Point baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearQuaternionKeyFrame : QuaternionKeyFrame {
    public static DependencyProperty UseShortestPathProperty;
    public bool UseShortestPath { get; public set; }
    public LinearQuaternionKeyFrame(Quaternion value);
    public LinearQuaternionKeyFrame(Quaternion value, KeyTime keyTime);
    private static LinearQuaternionKeyFrame();
    public bool get_UseShortestPath();
    public void set_UseShortestPath(bool value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Quaternion InterpolateValueCore(Quaternion baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearRectKeyFrame : RectKeyFrame {
    public LinearRectKeyFrame(Rect value);
    public LinearRectKeyFrame(Rect value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Rect InterpolateValueCore(Rect baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearRotation3DKeyFrame : Rotation3DKeyFrame {
    public LinearRotation3DKeyFrame(Rotation3D value);
    public LinearRotation3DKeyFrame(Rotation3D value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Rotation3D InterpolateValueCore(Rotation3D baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearSingleKeyFrame : SingleKeyFrame {
    public LinearSingleKeyFrame(float value);
    public LinearSingleKeyFrame(float value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual float InterpolateValueCore(float baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearSizeKeyFrame : SizeKeyFrame {
    public LinearSizeKeyFrame(Size value);
    public LinearSizeKeyFrame(Size value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Size InterpolateValueCore(Size baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearVector3DKeyFrame : Vector3DKeyFrame {
    public LinearVector3DKeyFrame(Vector3D value);
    public LinearVector3DKeyFrame(Vector3D value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Vector3D InterpolateValueCore(Vector3D baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.LinearVectorKeyFrame : VectorKeyFrame {
    public LinearVectorKeyFrame(Vector value);
    public LinearVectorKeyFrame(Vector value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Vector InterpolateValueCore(Vector baseValue, double keyFrameProgress);
}
public abstract class System.Windows.Media.Animation.MatrixAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public MatrixAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual Type get_TargetPropertyType();
    public Matrix GetCurrentValue(Matrix defaultOriginValue, Matrix defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual Matrix GetCurrentValueCore(Matrix defaultOriginValue, Matrix defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.MatrixAnimationUsingKeyFrames : MatrixAnimationBase {
    private MatrixKeyFrameCollection _keyFrames;
    private ResolvedKeyFrameEntry[] _sortedResolvedKeyFrames;
    private bool _areKeyTimesValid;
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public MatrixKeyFrameCollection KeyFrames { get; public set; }
    private TimeSpan LargestTimeSpanKeyTime { get; }
    public MatrixAnimationUsingKeyFrames Clone();
    public MatrixAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private void CopyCommon(MatrixAnimationUsingKeyFrames sourceAnimation, bool isCurrentValueClone);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual Matrix GetCurrentValueCore(Matrix defaultOriginValue, Matrix defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public MatrixKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(MatrixKeyFrameCollection value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    private Matrix GetResolvedKeyFrameValue(int resolvedKeyFrameIndex);
    private MatrixKeyFrame GetResolvedKeyFrame(int resolvedKeyFrameIndex);
    private TimeSpan get_LargestTimeSpanKeyTime();
    private void ResolveKeyTimes();
    private void ResolvePacedKeyTimes();
}
public class System.Windows.Media.Animation.MatrixAnimationUsingPath : MatrixAnimationBase {
    private bool _isValid;
    private Vector _accumulatingOffset;
    private double _accumulatingAngle;
    public static DependencyProperty DoesRotateWithTangentProperty;
    public static DependencyProperty IsAngleCumulativeProperty;
    public static DependencyProperty IsOffsetCumulativeProperty;
    public static DependencyProperty PathGeometryProperty;
    public bool DoesRotateWithTangent { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsAngleCumulative { get; public set; }
    public bool IsOffsetCumulative { get; public set; }
    public PathGeometry PathGeometry { get; public set; }
    private static MatrixAnimationUsingPath();
    public MatrixAnimationUsingPath Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void OnChanged();
    public bool get_DoesRotateWithTangent();
    public void set_DoesRotateWithTangent(bool value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsAngleCumulative();
    public void set_IsAngleCumulative(bool value);
    public bool get_IsOffsetCumulative();
    public void set_IsOffsetCumulative(bool value);
    public PathGeometry get_PathGeometry();
    public void set_PathGeometry(PathGeometry value);
    protected virtual Matrix GetCurrentValueCore(Matrix defaultOriginValue, Matrix defaultDestinationValue, AnimationClock animationClock);
    private void Validate();
}
internal class System.Windows.Media.Animation.MatrixIndependentAnimationStorage : IndependentAnimationStorage {
    protected ResourceType ResourceType { get; }
    protected virtual ResourceType get_ResourceType();
    protected virtual void UpdateResourceCore(Channel channel);
}
public abstract class System.Windows.Media.Animation.MatrixKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public Matrix Value { get; public set; }
    protected MatrixKeyFrame(Matrix value);
    protected MatrixKeyFrame(Matrix value, KeyTime keyTime);
    private static MatrixKeyFrame();
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public Matrix get_Value();
    public void set_Value(Matrix value);
    public Matrix InterpolateValue(Matrix baseValue, double keyFrameProgress);
    protected abstract virtual Matrix InterpolateValueCore(Matrix baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.MatrixKeyFrameCollection : Freezable {
    private List`1<MatrixKeyFrame> _keyFrames;
    private static MatrixKeyFrameCollection s_emptyCollection;
    public static MatrixKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public MatrixKeyFrame Item { get; public set; }
    public static MatrixKeyFrameCollection get_Empty();
    public MatrixKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(MatrixKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(MatrixKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(MatrixKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(MatrixKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, MatrixKeyFrame keyFrame);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(MatrixKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public MatrixKeyFrame get_Item(int index);
    public void set_Item(int index, MatrixKeyFrame value);
}
public abstract class System.Windows.Media.Animation.ObjectAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public ObjectAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual Type get_TargetPropertyType();
    protected abstract virtual object GetCurrentValueCore(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.ObjectAnimationUsingKeyFrames : ObjectAnimationBase {
    private ObjectKeyFrameCollection _keyFrames;
    private ResolvedKeyFrameEntry[] _sortedResolvedKeyFrames;
    private bool _areKeyTimesValid;
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public ObjectKeyFrameCollection KeyFrames { get; public set; }
    private TimeSpan LargestTimeSpanKeyTime { get; }
    public ObjectAnimationUsingKeyFrames Clone();
    public ObjectAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private void CopyCommon(ObjectAnimationUsingKeyFrames sourceAnimation, bool isCurrentValueClone);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual object GetCurrentValueCore(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public ObjectKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(ObjectKeyFrameCollection value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    private object GetResolvedKeyFrameValue(int resolvedKeyFrameIndex);
    private ObjectKeyFrame GetResolvedKeyFrame(int resolvedKeyFrameIndex);
    private TimeSpan get_LargestTimeSpanKeyTime();
    private void ResolveKeyTimes();
    private void ResolvePacedKeyTimes();
}
public abstract class System.Windows.Media.Animation.ObjectKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public object Value { get; public set; }
    protected ObjectKeyFrame(object value);
    protected ObjectKeyFrame(object value, KeyTime keyTime);
    private static ObjectKeyFrame();
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public object get_Value();
    public void set_Value(object value);
    public object InterpolateValue(object baseValue, double keyFrameProgress);
    protected abstract virtual object InterpolateValueCore(object baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.ObjectKeyFrameCollection : Freezable {
    private List`1<ObjectKeyFrame> _keyFrames;
    private static ObjectKeyFrameCollection s_emptyCollection;
    public static ObjectKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public ObjectKeyFrame Item { get; public set; }
    public static ObjectKeyFrameCollection get_Empty();
    public ObjectKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(ObjectKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(ObjectKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(ObjectKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(ObjectKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, ObjectKeyFrame keyFrame);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(ObjectKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public ObjectKeyFrame get_Item(int index);
    public void set_Item(int index, ObjectKeyFrame value);
}
public class System.Windows.Media.Animation.ParallelTimeline : TimelineGroup {
    public static DependencyProperty SlipBehaviorProperty;
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public SlipBehavior SlipBehavior { get; public set; }
    public ParallelTimeline(Nullable`1<TimeSpan> beginTime);
    public ParallelTimeline(Nullable`1<TimeSpan> beginTime, Duration duration);
    public ParallelTimeline(Nullable`1<TimeSpan> beginTime, Duration duration, RepeatBehavior repeatBehavior);
    private static ParallelTimeline();
    protected virtual Duration GetNaturalDurationCore(Clock clock);
    private static bool ValidateSlipBehavior(object value);
    public SlipBehavior get_SlipBehavior();
    public void set_SlipBehavior(SlipBehavior value);
    internal static void ParallelTimeline_PropertyChangedFunction(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public ParallelTimeline Clone();
    public ParallelTimeline CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
}
public enum System.Windows.Media.Animation.PathAnimationSource : Enum {
    public byte value__;
    public static PathAnimationSource X;
    public static PathAnimationSource Y;
    public static PathAnimationSource Angle;
}
public class System.Windows.Media.Animation.Point3DAnimation : Point3DAnimationBase {
    private Point3D[] _keyValues;
    private AnimationType _animationType;
    private bool _isAnimationFunctionValid;
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public Nullable`1<Point3D> From { get; public set; }
    public Nullable`1<Point3D> To { get; public set; }
    public Nullable`1<Point3D> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private static Point3DAnimation();
    public Point3DAnimation(Point3D toValue, Duration duration);
    public Point3DAnimation(Point3D toValue, Duration duration, FillBehavior fillBehavior);
    public Point3DAnimation(Point3D fromValue, Point3D toValue, Duration duration);
    public Point3DAnimation(Point3D fromValue, Point3D toValue, Duration duration, FillBehavior fillBehavior);
    public Point3DAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Point3D GetCurrentValueCore(Point3D defaultOriginValue, Point3D defaultDestinationValue, AnimationClock animationClock);
    private void ValidateAnimationFunction();
    private static void AnimationFunction_Changed(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static bool ValidateFromToOrByValue(object value);
    public Nullable`1<Point3D> get_From();
    public void set_From(Nullable`1<Point3D> value);
    public Nullable`1<Point3D> get_To();
    public void set_To(Nullable`1<Point3D> value);
    public Nullable`1<Point3D> get_By();
    public void set_By(Nullable`1<Point3D> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
}
public abstract class System.Windows.Media.Animation.Point3DAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public Point3DAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual Type get_TargetPropertyType();
    public Point3D GetCurrentValue(Point3D defaultOriginValue, Point3D defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual Point3D GetCurrentValueCore(Point3D defaultOriginValue, Point3D defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.Point3DAnimationUsingKeyFrames : Point3DAnimationBase {
    private Point3DKeyFrameCollection _keyFrames;
    private ResolvedKeyFrameEntry[] _sortedResolvedKeyFrames;
    private bool _areKeyTimesValid;
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public Point3DKeyFrameCollection KeyFrames { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private TimeSpan LargestTimeSpanKeyTime { get; }
    public Point3DAnimationUsingKeyFrames Clone();
    public Point3DAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private void CopyCommon(Point3DAnimationUsingKeyFrames sourceAnimation, bool isCurrentValueClone);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual Point3D GetCurrentValueCore(Point3D defaultOriginValue, Point3D defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public Point3DKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(Point3DKeyFrameCollection value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    private Point3D GetResolvedKeyFrameValue(int resolvedKeyFrameIndex);
    private Point3DKeyFrame GetResolvedKeyFrame(int resolvedKeyFrameIndex);
    private TimeSpan get_LargestTimeSpanKeyTime();
    private void ResolveKeyTimes();
    private void ResolvePacedKeyTimes();
}
internal class System.Windows.Media.Animation.Point3DIndependentAnimationStorage : IndependentAnimationStorage {
    protected ResourceType ResourceType { get; }
    protected virtual ResourceType get_ResourceType();
    protected virtual void UpdateResourceCore(Channel channel);
}
public abstract class System.Windows.Media.Animation.Point3DKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public Point3D Value { get; public set; }
    protected Point3DKeyFrame(Point3D value);
    protected Point3DKeyFrame(Point3D value, KeyTime keyTime);
    private static Point3DKeyFrame();
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public Point3D get_Value();
    public void set_Value(Point3D value);
    public Point3D InterpolateValue(Point3D baseValue, double keyFrameProgress);
    protected abstract virtual Point3D InterpolateValueCore(Point3D baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.Point3DKeyFrameCollection : Freezable {
    private List`1<Point3DKeyFrame> _keyFrames;
    private static Point3DKeyFrameCollection s_emptyCollection;
    public static Point3DKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public Point3DKeyFrame Item { get; public set; }
    public static Point3DKeyFrameCollection get_Empty();
    public Point3DKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(Point3DKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(Point3DKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(Point3DKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(Point3DKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, Point3DKeyFrame keyFrame);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(Point3DKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public Point3DKeyFrame get_Item(int index);
    public void set_Item(int index, Point3DKeyFrame value);
}
public class System.Windows.Media.Animation.PointAnimation : PointAnimationBase {
    private Point[] _keyValues;
    private AnimationType _animationType;
    private bool _isAnimationFunctionValid;
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public Nullable`1<Point> From { get; public set; }
    public Nullable`1<Point> To { get; public set; }
    public Nullable`1<Point> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private static PointAnimation();
    public PointAnimation(Point toValue, Duration duration);
    public PointAnimation(Point toValue, Duration duration, FillBehavior fillBehavior);
    public PointAnimation(Point fromValue, Point toValue, Duration duration);
    public PointAnimation(Point fromValue, Point toValue, Duration duration, FillBehavior fillBehavior);
    public PointAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Point GetCurrentValueCore(Point defaultOriginValue, Point defaultDestinationValue, AnimationClock animationClock);
    private void ValidateAnimationFunction();
    private static void AnimationFunction_Changed(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static bool ValidateFromToOrByValue(object value);
    public Nullable`1<Point> get_From();
    public void set_From(Nullable`1<Point> value);
    public Nullable`1<Point> get_To();
    public void set_To(Nullable`1<Point> value);
    public Nullable`1<Point> get_By();
    public void set_By(Nullable`1<Point> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
}
public abstract class System.Windows.Media.Animation.PointAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public PointAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual Type get_TargetPropertyType();
    public Point GetCurrentValue(Point defaultOriginValue, Point defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual Point GetCurrentValueCore(Point defaultOriginValue, Point defaultDestinationValue, AnimationClock animationClock);
}
internal class System.Windows.Media.Animation.PointAnimationClockResource : AnimationClockResource {
    private Point _baseValue;
    public Point BaseValue { get; }
    public Point CurrentValue { get; }
    protected ResourceType ResourceType { get; }
    public PointAnimationClockResource(Point baseValue, AnimationClock animationClock);
    public Point get_BaseValue();
    public Point get_CurrentValue();
    protected virtual ResourceType get_ResourceType();
    protected virtual void UpdateResource(ResourceHandle handle, Channel channel);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.PointAnimationUsingKeyFrames : PointAnimationBase {
    private PointKeyFrameCollection _keyFrames;
    private ResolvedKeyFrameEntry[] _sortedResolvedKeyFrames;
    private bool _areKeyTimesValid;
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public PointKeyFrameCollection KeyFrames { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private TimeSpan LargestTimeSpanKeyTime { get; }
    public PointAnimationUsingKeyFrames Clone();
    public PointAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private void CopyCommon(PointAnimationUsingKeyFrames sourceAnimation, bool isCurrentValueClone);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual Point GetCurrentValueCore(Point defaultOriginValue, Point defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public PointKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(PointKeyFrameCollection value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    private Point GetResolvedKeyFrameValue(int resolvedKeyFrameIndex);
    private PointKeyFrame GetResolvedKeyFrame(int resolvedKeyFrameIndex);
    private TimeSpan get_LargestTimeSpanKeyTime();
    private void ResolveKeyTimes();
    private void ResolvePacedKeyTimes();
}
public class System.Windows.Media.Animation.PointAnimationUsingPath : PointAnimationBase {
    private bool _isValid;
    private Vector _accumulatingVector;
    public static DependencyProperty PathGeometryProperty;
    public PathGeometry PathGeometry { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private static PointAnimationUsingPath();
    public PathGeometry get_PathGeometry();
    public void set_PathGeometry(PathGeometry value);
    public PointAnimationUsingPath Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void OnChanged();
    protected virtual Point GetCurrentValueCore(Point defaultOriginValue, Point defaultDestinationValue, AnimationClock animationClock);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    private void Validate();
}
internal class System.Windows.Media.Animation.PointIndependentAnimationStorage : IndependentAnimationStorage {
    protected ResourceType ResourceType { get; }
    protected virtual ResourceType get_ResourceType();
    protected virtual void UpdateResourceCore(Channel channel);
}
public abstract class System.Windows.Media.Animation.PointKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public Point Value { get; public set; }
    protected PointKeyFrame(Point value);
    protected PointKeyFrame(Point value, KeyTime keyTime);
    private static PointKeyFrame();
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public Point get_Value();
    public void set_Value(Point value);
    public Point InterpolateValue(Point baseValue, double keyFrameProgress);
    protected abstract virtual Point InterpolateValueCore(Point baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.PointKeyFrameCollection : Freezable {
    private List`1<PointKeyFrame> _keyFrames;
    private static PointKeyFrameCollection s_emptyCollection;
    public static PointKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public PointKeyFrame Item { get; public set; }
    public static PointKeyFrameCollection get_Empty();
    public PointKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(PointKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(PointKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(PointKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(PointKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, PointKeyFrame keyFrame);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(PointKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public PointKeyFrame get_Item(int index);
    public void set_Item(int index, PointKeyFrame value);
}
internal class System.Windows.Media.Animation.PostfixSubtreeEnumerator : ValueType {
    private Clock _rootClock;
    private Clock _currentClock;
    private SubtreeFlag _flags;
    internal Clock Current { get; }
    internal PostfixSubtreeEnumerator(Clock root, bool processRoot);
    public bool MoveNext();
    internal Clock get_Current();
}
public class System.Windows.Media.Animation.PowerEase : EasingFunctionBase {
    public static DependencyProperty PowerProperty;
    public double Power { get; public set; }
    private static PowerEase();
    public double get_Power();
    public void set_Power(double value);
    protected virtual double EaseInCore(double normalizedTime);
    protected virtual Freezable CreateInstanceCore();
}
internal class System.Windows.Media.Animation.PrefixSubtreeEnumerator : ValueType {
    private Clock _rootClock;
    private Clock _currentClock;
    private SubtreeFlag _flags;
    internal Clock Current { get; }
    internal PrefixSubtreeEnumerator(Clock root, bool processRoot);
    internal void SkipSubtree();
    public bool MoveNext();
    public void Reset();
    internal Clock get_Current();
}
public class System.Windows.Media.Animation.QuadraticEase : EasingFunctionBase {
    protected virtual double EaseInCore(double normalizedTime);
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Animation.QuarticEase : EasingFunctionBase {
    protected virtual double EaseInCore(double normalizedTime);
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Animation.QuaternionAnimation : QuaternionAnimationBase {
    public static DependencyProperty UseShortestPathProperty;
    private Quaternion[] _keyValues;
    private AnimationType _animationType;
    private bool _isAnimationFunctionValid;
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public bool UseShortestPath { get; public set; }
    public Nullable`1<Quaternion> From { get; public set; }
    public Nullable`1<Quaternion> To { get; public set; }
    public Nullable`1<Quaternion> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private static QuaternionAnimation();
    public QuaternionAnimation(Quaternion toValue, Duration duration);
    public QuaternionAnimation(Quaternion toValue, Duration duration, FillBehavior fillBehavior);
    public QuaternionAnimation(Quaternion fromValue, Quaternion toValue, Duration duration);
    public QuaternionAnimation(Quaternion fromValue, Quaternion toValue, Duration duration, FillBehavior fillBehavior);
    public bool get_UseShortestPath();
    public void set_UseShortestPath(bool value);
    public QuaternionAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Quaternion GetCurrentValueCore(Quaternion defaultOriginValue, Quaternion defaultDestinationValue, AnimationClock animationClock);
    private void ValidateAnimationFunction();
    private static void AnimationFunction_Changed(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static bool ValidateFromToOrByValue(object value);
    public Nullable`1<Quaternion> get_From();
    public void set_From(Nullable`1<Quaternion> value);
    public Nullable`1<Quaternion> get_To();
    public void set_To(Nullable`1<Quaternion> value);
    public Nullable`1<Quaternion> get_By();
    public void set_By(Nullable`1<Quaternion> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
}
public abstract class System.Windows.Media.Animation.QuaternionAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public QuaternionAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual Type get_TargetPropertyType();
    public Quaternion GetCurrentValue(Quaternion defaultOriginValue, Quaternion defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual Quaternion GetCurrentValueCore(Quaternion defaultOriginValue, Quaternion defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.QuaternionAnimationUsingKeyFrames : QuaternionAnimationBase {
    private QuaternionKeyFrameCollection _keyFrames;
    private ResolvedKeyFrameEntry[] _sortedResolvedKeyFrames;
    private bool _areKeyTimesValid;
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public QuaternionKeyFrameCollection KeyFrames { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private TimeSpan LargestTimeSpanKeyTime { get; }
    public QuaternionAnimationUsingKeyFrames Clone();
    public QuaternionAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private void CopyCommon(QuaternionAnimationUsingKeyFrames sourceAnimation, bool isCurrentValueClone);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual Quaternion GetCurrentValueCore(Quaternion defaultOriginValue, Quaternion defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public QuaternionKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(QuaternionKeyFrameCollection value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    private Quaternion GetResolvedKeyFrameValue(int resolvedKeyFrameIndex);
    private QuaternionKeyFrame GetResolvedKeyFrame(int resolvedKeyFrameIndex);
    private TimeSpan get_LargestTimeSpanKeyTime();
    private void ResolveKeyTimes();
    private void ResolvePacedKeyTimes();
}
internal class System.Windows.Media.Animation.QuaternionIndependentAnimationStorage : IndependentAnimationStorage {
    protected ResourceType ResourceType { get; }
    protected virtual ResourceType get_ResourceType();
    protected virtual void UpdateResourceCore(Channel channel);
}
public abstract class System.Windows.Media.Animation.QuaternionKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public Quaternion Value { get; public set; }
    protected QuaternionKeyFrame(Quaternion value);
    protected QuaternionKeyFrame(Quaternion value, KeyTime keyTime);
    private static QuaternionKeyFrame();
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public Quaternion get_Value();
    public void set_Value(Quaternion value);
    public Quaternion InterpolateValue(Quaternion baseValue, double keyFrameProgress);
    protected abstract virtual Quaternion InterpolateValueCore(Quaternion baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.QuaternionKeyFrameCollection : Freezable {
    private List`1<QuaternionKeyFrame> _keyFrames;
    private static QuaternionKeyFrameCollection s_emptyCollection;
    public static QuaternionKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public QuaternionKeyFrame Item { get; public set; }
    public static QuaternionKeyFrameCollection get_Empty();
    public QuaternionKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(QuaternionKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(QuaternionKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(QuaternionKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(QuaternionKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, QuaternionKeyFrame keyFrame);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(QuaternionKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public QuaternionKeyFrame get_Item(int index);
    public void set_Item(int index, QuaternionKeyFrame value);
}
public class System.Windows.Media.Animation.QuinticEase : EasingFunctionBase {
    protected virtual double EaseInCore(double normalizedTime);
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Animation.RectAnimation : RectAnimationBase {
    private Rect[] _keyValues;
    private AnimationType _animationType;
    private bool _isAnimationFunctionValid;
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public Nullable`1<Rect> From { get; public set; }
    public Nullable`1<Rect> To { get; public set; }
    public Nullable`1<Rect> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private static RectAnimation();
    public RectAnimation(Rect toValue, Duration duration);
    public RectAnimation(Rect toValue, Duration duration, FillBehavior fillBehavior);
    public RectAnimation(Rect fromValue, Rect toValue, Duration duration);
    public RectAnimation(Rect fromValue, Rect toValue, Duration duration, FillBehavior fillBehavior);
    public RectAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Rect GetCurrentValueCore(Rect defaultOriginValue, Rect defaultDestinationValue, AnimationClock animationClock);
    private void ValidateAnimationFunction();
    private static void AnimationFunction_Changed(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static bool ValidateFromToOrByValue(object value);
    public Nullable`1<Rect> get_From();
    public void set_From(Nullable`1<Rect> value);
    public Nullable`1<Rect> get_To();
    public void set_To(Nullable`1<Rect> value);
    public Nullable`1<Rect> get_By();
    public void set_By(Nullable`1<Rect> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
}
public abstract class System.Windows.Media.Animation.RectAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public RectAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual Type get_TargetPropertyType();
    public Rect GetCurrentValue(Rect defaultOriginValue, Rect defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual Rect GetCurrentValueCore(Rect defaultOriginValue, Rect defaultDestinationValue, AnimationClock animationClock);
}
internal class System.Windows.Media.Animation.RectAnimationClockResource : AnimationClockResource {
    private Rect _baseValue;
    public Rect BaseValue { get; }
    public Rect CurrentValue { get; }
    protected ResourceType ResourceType { get; }
    public RectAnimationClockResource(Rect baseValue, AnimationClock animationClock);
    public Rect get_BaseValue();
    public Rect get_CurrentValue();
    protected virtual ResourceType get_ResourceType();
    protected virtual void UpdateResource(ResourceHandle handle, Channel channel);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.RectAnimationUsingKeyFrames : RectAnimationBase {
    private RectKeyFrameCollection _keyFrames;
    private ResolvedKeyFrameEntry[] _sortedResolvedKeyFrames;
    private bool _areKeyTimesValid;
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public RectKeyFrameCollection KeyFrames { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private TimeSpan LargestTimeSpanKeyTime { get; }
    public RectAnimationUsingKeyFrames Clone();
    public RectAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private void CopyCommon(RectAnimationUsingKeyFrames sourceAnimation, bool isCurrentValueClone);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual Rect GetCurrentValueCore(Rect defaultOriginValue, Rect defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public RectKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(RectKeyFrameCollection value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    private Rect GetResolvedKeyFrameValue(int resolvedKeyFrameIndex);
    private RectKeyFrame GetResolvedKeyFrame(int resolvedKeyFrameIndex);
    private TimeSpan get_LargestTimeSpanKeyTime();
    private void ResolveKeyTimes();
    private void ResolvePacedKeyTimes();
}
internal class System.Windows.Media.Animation.RectIndependentAnimationStorage : IndependentAnimationStorage {
    protected ResourceType ResourceType { get; }
    protected virtual ResourceType get_ResourceType();
    protected virtual void UpdateResourceCore(Channel channel);
}
public abstract class System.Windows.Media.Animation.RectKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public Rect Value { get; public set; }
    protected RectKeyFrame(Rect value);
    protected RectKeyFrame(Rect value, KeyTime keyTime);
    private static RectKeyFrame();
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public Rect get_Value();
    public void set_Value(Rect value);
    public Rect InterpolateValue(Rect baseValue, double keyFrameProgress);
    protected abstract virtual Rect InterpolateValueCore(Rect baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.RectKeyFrameCollection : Freezable {
    private List`1<RectKeyFrame> _keyFrames;
    private static RectKeyFrameCollection s_emptyCollection;
    public static RectKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public RectKeyFrame Item { get; public set; }
    public static RectKeyFrameCollection get_Empty();
    public RectKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(RectKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(RectKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(RectKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(RectKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, RectKeyFrame keyFrame);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(RectKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public RectKeyFrame get_Item(int index);
    public void set_Item(int index, RectKeyFrame value);
}
[TypeConverterAttribute("System.Windows.Media.Animation.RepeatBehaviorConverter")]
public class System.Windows.Media.Animation.RepeatBehavior : ValueType {
    private double _iterationCount;
    private TimeSpan _repeatDuration;
    private RepeatBehaviorType _type;
    public static RepeatBehavior Forever { get; }
    public bool HasCount { get; }
    public bool HasDuration { get; }
    public double Count { get; }
    public TimeSpan Duration { get; }
    public RepeatBehavior(double count);
    public RepeatBehavior(TimeSpan duration);
    public static RepeatBehavior get_Forever();
    public bool get_HasCount();
    public bool get_HasDuration();
    public double get_Count();
    public TimeSpan get_Duration();
    public virtual bool Equals(object value);
    public bool Equals(RepeatBehavior repeatBehavior);
    public static bool Equals(RepeatBehavior repeatBehavior1, RepeatBehavior repeatBehavior2);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(IFormatProvider formatProvider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider formatProvider);
    internal string InternalToString(string format, IFormatProvider formatProvider);
    public static bool op_Equality(RepeatBehavior repeatBehavior1, RepeatBehavior repeatBehavior2);
    public static bool op_Inequality(RepeatBehavior repeatBehavior1, RepeatBehavior repeatBehavior2);
}
public class System.Windows.Media.Animation.RepeatBehaviorConverter : TypeConverter {
    private static Char[] _iterationCharacter;
    private static RepeatBehaviorConverter();
    public virtual bool CanConvertFrom(ITypeDescriptorContext td, Type t);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext td, CultureInfo cultureInfo, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo cultureInfo, object value, Type destinationType);
}
internal class System.Windows.Media.Animation.ResolvedKeyFrameEntry : ValueType {
    internal int _originalKeyFrameIndex;
    internal TimeSpan _resolvedKeyTime;
    public sealed virtual int CompareTo(object other);
}
public class System.Windows.Media.Animation.Rotation3DAnimation : Rotation3DAnimationBase {
    private Rotation3D[] _keyValues;
    private AnimationType _animationType;
    private bool _isAnimationFunctionValid;
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public Rotation3D From { get; public set; }
    public Rotation3D To { get; public set; }
    public Rotation3D By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private static Rotation3DAnimation();
    public Rotation3DAnimation(Rotation3D toValue, Duration duration);
    public Rotation3DAnimation(Rotation3D toValue, Duration duration, FillBehavior fillBehavior);
    public Rotation3DAnimation(Rotation3D fromValue, Rotation3D toValue, Duration duration);
    public Rotation3DAnimation(Rotation3D fromValue, Rotation3D toValue, Duration duration, FillBehavior fillBehavior);
    public Rotation3DAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Rotation3D GetCurrentValueCore(Rotation3D defaultOriginValue, Rotation3D defaultDestinationValue, AnimationClock animationClock);
    private void ValidateAnimationFunction();
    private static void AnimationFunction_Changed(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static bool ValidateFromToOrByValue(object value);
    public Rotation3D get_From();
    public void set_From(Rotation3D value);
    public Rotation3D get_To();
    public void set_To(Rotation3D value);
    public Rotation3D get_By();
    public void set_By(Rotation3D value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
}
public abstract class System.Windows.Media.Animation.Rotation3DAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public Rotation3DAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual Type get_TargetPropertyType();
    public Rotation3D GetCurrentValue(Rotation3D defaultOriginValue, Rotation3D defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual Rotation3D GetCurrentValueCore(Rotation3D defaultOriginValue, Rotation3D defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.Rotation3DAnimationUsingKeyFrames : Rotation3DAnimationBase {
    private Rotation3DKeyFrameCollection _keyFrames;
    private ResolvedKeyFrameEntry[] _sortedResolvedKeyFrames;
    private bool _areKeyTimesValid;
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public Rotation3DKeyFrameCollection KeyFrames { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private TimeSpan LargestTimeSpanKeyTime { get; }
    public Rotation3DAnimationUsingKeyFrames Clone();
    public Rotation3DAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private void CopyCommon(Rotation3DAnimationUsingKeyFrames sourceAnimation, bool isCurrentValueClone);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual Rotation3D GetCurrentValueCore(Rotation3D defaultOriginValue, Rotation3D defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public Rotation3DKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(Rotation3DKeyFrameCollection value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    private Rotation3D GetResolvedKeyFrameValue(int resolvedKeyFrameIndex);
    private Rotation3DKeyFrame GetResolvedKeyFrame(int resolvedKeyFrameIndex);
    private TimeSpan get_LargestTimeSpanKeyTime();
    private void ResolveKeyTimes();
    private void ResolvePacedKeyTimes();
}
public abstract class System.Windows.Media.Animation.Rotation3DKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public Rotation3D Value { get; public set; }
    protected Rotation3DKeyFrame(Rotation3D value);
    protected Rotation3DKeyFrame(Rotation3D value, KeyTime keyTime);
    private static Rotation3DKeyFrame();
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public Rotation3D get_Value();
    public void set_Value(Rotation3D value);
    public Rotation3D InterpolateValue(Rotation3D baseValue, double keyFrameProgress);
    protected abstract virtual Rotation3D InterpolateValueCore(Rotation3D baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.Rotation3DKeyFrameCollection : Freezable {
    private List`1<Rotation3DKeyFrame> _keyFrames;
    private static Rotation3DKeyFrameCollection s_emptyCollection;
    public static Rotation3DKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public Rotation3DKeyFrame Item { get; public set; }
    public static Rotation3DKeyFrameCollection get_Empty();
    public Rotation3DKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(Rotation3DKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(Rotation3DKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(Rotation3DKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(Rotation3DKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, Rotation3DKeyFrame keyFrame);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(Rotation3DKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public Rotation3DKeyFrame get_Item(int index);
    public void set_Item(int index, Rotation3DKeyFrame value);
}
public class System.Windows.Media.Animation.SineEase : EasingFunctionBase {
    protected virtual double EaseInCore(double normalizedTime);
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Animation.SingleAnimation : SingleAnimationBase {
    private Single[] _keyValues;
    private AnimationType _animationType;
    private bool _isAnimationFunctionValid;
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public Nullable`1<float> From { get; public set; }
    public Nullable`1<float> To { get; public set; }
    public Nullable`1<float> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private static SingleAnimation();
    public SingleAnimation(float toValue, Duration duration);
    public SingleAnimation(float toValue, Duration duration, FillBehavior fillBehavior);
    public SingleAnimation(float fromValue, float toValue, Duration duration);
    public SingleAnimation(float fromValue, float toValue, Duration duration, FillBehavior fillBehavior);
    public SingleAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual float GetCurrentValueCore(float defaultOriginValue, float defaultDestinationValue, AnimationClock animationClock);
    private void ValidateAnimationFunction();
    private static void AnimationFunction_Changed(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static bool ValidateFromToOrByValue(object value);
    public Nullable`1<float> get_From();
    public void set_From(Nullable`1<float> value);
    public Nullable`1<float> get_To();
    public void set_To(Nullable`1<float> value);
    public Nullable`1<float> get_By();
    public void set_By(Nullable`1<float> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
}
public abstract class System.Windows.Media.Animation.SingleAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public SingleAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual Type get_TargetPropertyType();
    public float GetCurrentValue(float defaultOriginValue, float defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual float GetCurrentValueCore(float defaultOriginValue, float defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.SingleAnimationUsingKeyFrames : SingleAnimationBase {
    private SingleKeyFrameCollection _keyFrames;
    private ResolvedKeyFrameEntry[] _sortedResolvedKeyFrames;
    private bool _areKeyTimesValid;
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public SingleKeyFrameCollection KeyFrames { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private TimeSpan LargestTimeSpanKeyTime { get; }
    public SingleAnimationUsingKeyFrames Clone();
    public SingleAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private void CopyCommon(SingleAnimationUsingKeyFrames sourceAnimation, bool isCurrentValueClone);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual float GetCurrentValueCore(float defaultOriginValue, float defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public SingleKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(SingleKeyFrameCollection value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    private float GetResolvedKeyFrameValue(int resolvedKeyFrameIndex);
    private SingleKeyFrame GetResolvedKeyFrame(int resolvedKeyFrameIndex);
    private TimeSpan get_LargestTimeSpanKeyTime();
    private void ResolveKeyTimes();
    private void ResolvePacedKeyTimes();
}
public abstract class System.Windows.Media.Animation.SingleKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public float Value { get; public set; }
    protected SingleKeyFrame(float value);
    protected SingleKeyFrame(float value, KeyTime keyTime);
    private static SingleKeyFrame();
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public float get_Value();
    public void set_Value(float value);
    public float InterpolateValue(float baseValue, double keyFrameProgress);
    protected abstract virtual float InterpolateValueCore(float baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.SingleKeyFrameCollection : Freezable {
    private List`1<SingleKeyFrame> _keyFrames;
    private static SingleKeyFrameCollection s_emptyCollection;
    public static SingleKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public SingleKeyFrame Item { get; public set; }
    public static SingleKeyFrameCollection get_Empty();
    public SingleKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(SingleKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(SingleKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(SingleKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(SingleKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, SingleKeyFrame keyFrame);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(SingleKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public SingleKeyFrame get_Item(int index);
    public void set_Item(int index, SingleKeyFrame value);
}
public class System.Windows.Media.Animation.SizeAnimation : SizeAnimationBase {
    private Size[] _keyValues;
    private AnimationType _animationType;
    private bool _isAnimationFunctionValid;
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public Nullable`1<Size> From { get; public set; }
    public Nullable`1<Size> To { get; public set; }
    public Nullable`1<Size> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private static SizeAnimation();
    public SizeAnimation(Size toValue, Duration duration);
    public SizeAnimation(Size toValue, Duration duration, FillBehavior fillBehavior);
    public SizeAnimation(Size fromValue, Size toValue, Duration duration);
    public SizeAnimation(Size fromValue, Size toValue, Duration duration, FillBehavior fillBehavior);
    public SizeAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Size GetCurrentValueCore(Size defaultOriginValue, Size defaultDestinationValue, AnimationClock animationClock);
    private void ValidateAnimationFunction();
    private static void AnimationFunction_Changed(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static bool ValidateFromToOrByValue(object value);
    public Nullable`1<Size> get_From();
    public void set_From(Nullable`1<Size> value);
    public Nullable`1<Size> get_To();
    public void set_To(Nullable`1<Size> value);
    public Nullable`1<Size> get_By();
    public void set_By(Nullable`1<Size> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
}
public abstract class System.Windows.Media.Animation.SizeAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public SizeAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual Type get_TargetPropertyType();
    public Size GetCurrentValue(Size defaultOriginValue, Size defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual Size GetCurrentValueCore(Size defaultOriginValue, Size defaultDestinationValue, AnimationClock animationClock);
}
internal class System.Windows.Media.Animation.SizeAnimationClockResource : AnimationClockResource {
    private Size _baseValue;
    public Size BaseValue { get; }
    public Size CurrentValue { get; }
    protected ResourceType ResourceType { get; }
    public SizeAnimationClockResource(Size baseValue, AnimationClock animationClock);
    public Size get_BaseValue();
    public Size get_CurrentValue();
    protected virtual ResourceType get_ResourceType();
    protected virtual void UpdateResource(ResourceHandle handle, Channel channel);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.SizeAnimationUsingKeyFrames : SizeAnimationBase {
    private SizeKeyFrameCollection _keyFrames;
    private ResolvedKeyFrameEntry[] _sortedResolvedKeyFrames;
    private bool _areKeyTimesValid;
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public SizeKeyFrameCollection KeyFrames { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private TimeSpan LargestTimeSpanKeyTime { get; }
    public SizeAnimationUsingKeyFrames Clone();
    public SizeAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private void CopyCommon(SizeAnimationUsingKeyFrames sourceAnimation, bool isCurrentValueClone);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual Size GetCurrentValueCore(Size defaultOriginValue, Size defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public SizeKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(SizeKeyFrameCollection value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    private Size GetResolvedKeyFrameValue(int resolvedKeyFrameIndex);
    private SizeKeyFrame GetResolvedKeyFrame(int resolvedKeyFrameIndex);
    private TimeSpan get_LargestTimeSpanKeyTime();
    private void ResolveKeyTimes();
    private void ResolvePacedKeyTimes();
}
internal class System.Windows.Media.Animation.SizeIndependentAnimationStorage : IndependentAnimationStorage {
    protected ResourceType ResourceType { get; }
    protected virtual ResourceType get_ResourceType();
    protected virtual void UpdateResourceCore(Channel channel);
}
public abstract class System.Windows.Media.Animation.SizeKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public Size Value { get; public set; }
    protected SizeKeyFrame(Size value);
    protected SizeKeyFrame(Size value, KeyTime keyTime);
    private static SizeKeyFrame();
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public Size get_Value();
    public void set_Value(Size value);
    public Size InterpolateValue(Size baseValue, double keyFrameProgress);
    protected abstract virtual Size InterpolateValueCore(Size baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.SizeKeyFrameCollection : Freezable {
    private List`1<SizeKeyFrame> _keyFrames;
    private static SizeKeyFrameCollection s_emptyCollection;
    public static SizeKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public SizeKeyFrame Item { get; public set; }
    public static SizeKeyFrameCollection get_Empty();
    public SizeKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(SizeKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(SizeKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(SizeKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(SizeKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, SizeKeyFrame keyFrame);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(SizeKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public SizeKeyFrame get_Item(int index);
    public void set_Item(int index, SizeKeyFrame value);
}
public enum System.Windows.Media.Animation.SlipBehavior : Enum {
    public int value__;
    public static SlipBehavior Grow;
    public static SlipBehavior Slip;
}
public class System.Windows.Media.Animation.SplineByteKeyFrame : ByteKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineByteKeyFrame(byte value);
    public SplineByteKeyFrame(byte value, KeyTime keyTime);
    public SplineByteKeyFrame(byte value, KeyTime keyTime, KeySpline keySpline);
    private static SplineByteKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual byte InterpolateValueCore(byte baseValue, double keyFrameProgress);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
}
public class System.Windows.Media.Animation.SplineColorKeyFrame : ColorKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineColorKeyFrame(Color value);
    public SplineColorKeyFrame(Color value, KeyTime keyTime);
    public SplineColorKeyFrame(Color value, KeyTime keyTime, KeySpline keySpline);
    private static SplineColorKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Color InterpolateValueCore(Color baseValue, double keyFrameProgress);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
}
public class System.Windows.Media.Animation.SplineDecimalKeyFrame : DecimalKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineDecimalKeyFrame(decimal value);
    public SplineDecimalKeyFrame(decimal value, KeyTime keyTime);
    public SplineDecimalKeyFrame(decimal value, KeyTime keyTime, KeySpline keySpline);
    private static SplineDecimalKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual decimal InterpolateValueCore(decimal baseValue, double keyFrameProgress);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
}
public class System.Windows.Media.Animation.SplineDoubleKeyFrame : DoubleKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineDoubleKeyFrame(double value);
    public SplineDoubleKeyFrame(double value, KeyTime keyTime);
    public SplineDoubleKeyFrame(double value, KeyTime keyTime, KeySpline keySpline);
    private static SplineDoubleKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual double InterpolateValueCore(double baseValue, double keyFrameProgress);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
}
public class System.Windows.Media.Animation.SplineInt16KeyFrame : Int16KeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineInt16KeyFrame(short value);
    public SplineInt16KeyFrame(short value, KeyTime keyTime);
    public SplineInt16KeyFrame(short value, KeyTime keyTime, KeySpline keySpline);
    private static SplineInt16KeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual short InterpolateValueCore(short baseValue, double keyFrameProgress);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
}
public class System.Windows.Media.Animation.SplineInt32KeyFrame : Int32KeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineInt32KeyFrame(int value);
    public SplineInt32KeyFrame(int value, KeyTime keyTime);
    public SplineInt32KeyFrame(int value, KeyTime keyTime, KeySpline keySpline);
    private static SplineInt32KeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual int InterpolateValueCore(int baseValue, double keyFrameProgress);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
}
public class System.Windows.Media.Animation.SplineInt64KeyFrame : Int64KeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineInt64KeyFrame(long value);
    public SplineInt64KeyFrame(long value, KeyTime keyTime);
    public SplineInt64KeyFrame(long value, KeyTime keyTime, KeySpline keySpline);
    private static SplineInt64KeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual long InterpolateValueCore(long baseValue, double keyFrameProgress);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
}
public class System.Windows.Media.Animation.SplinePoint3DKeyFrame : Point3DKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplinePoint3DKeyFrame(Point3D value);
    public SplinePoint3DKeyFrame(Point3D value, KeyTime keyTime);
    public SplinePoint3DKeyFrame(Point3D value, KeyTime keyTime, KeySpline keySpline);
    private static SplinePoint3DKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Point3D InterpolateValueCore(Point3D baseValue, double keyFrameProgress);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
}
public class System.Windows.Media.Animation.SplinePointKeyFrame : PointKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplinePointKeyFrame(Point value);
    public SplinePointKeyFrame(Point value, KeyTime keyTime);
    public SplinePointKeyFrame(Point value, KeyTime keyTime, KeySpline keySpline);
    private static SplinePointKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Point InterpolateValueCore(Point baseValue, double keyFrameProgress);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
}
public class System.Windows.Media.Animation.SplineQuaternionKeyFrame : QuaternionKeyFrame {
    public static DependencyProperty UseShortestPathProperty;
    public static DependencyProperty KeySplineProperty;
    public bool UseShortestPath { get; public set; }
    public KeySpline KeySpline { get; public set; }
    public SplineQuaternionKeyFrame(Quaternion value);
    public SplineQuaternionKeyFrame(Quaternion value, KeyTime keyTime);
    public SplineQuaternionKeyFrame(Quaternion value, KeyTime keyTime, KeySpline keySpline);
    private static SplineQuaternionKeyFrame();
    public bool get_UseShortestPath();
    public void set_UseShortestPath(bool value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Quaternion InterpolateValueCore(Quaternion baseValue, double keyFrameProgress);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
}
public class System.Windows.Media.Animation.SplineRectKeyFrame : RectKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineRectKeyFrame(Rect value);
    public SplineRectKeyFrame(Rect value, KeyTime keyTime);
    public SplineRectKeyFrame(Rect value, KeyTime keyTime, KeySpline keySpline);
    private static SplineRectKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Rect InterpolateValueCore(Rect baseValue, double keyFrameProgress);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
}
public class System.Windows.Media.Animation.SplineRotation3DKeyFrame : Rotation3DKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineRotation3DKeyFrame(Rotation3D value);
    public SplineRotation3DKeyFrame(Rotation3D value, KeyTime keyTime);
    public SplineRotation3DKeyFrame(Rotation3D value, KeyTime keyTime, KeySpline keySpline);
    private static SplineRotation3DKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Rotation3D InterpolateValueCore(Rotation3D baseValue, double keyFrameProgress);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
}
public class System.Windows.Media.Animation.SplineSingleKeyFrame : SingleKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineSingleKeyFrame(float value);
    public SplineSingleKeyFrame(float value, KeyTime keyTime);
    public SplineSingleKeyFrame(float value, KeyTime keyTime, KeySpline keySpline);
    private static SplineSingleKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual float InterpolateValueCore(float baseValue, double keyFrameProgress);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
}
public class System.Windows.Media.Animation.SplineSizeKeyFrame : SizeKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineSizeKeyFrame(Size value);
    public SplineSizeKeyFrame(Size value, KeyTime keyTime);
    public SplineSizeKeyFrame(Size value, KeyTime keyTime, KeySpline keySpline);
    private static SplineSizeKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Size InterpolateValueCore(Size baseValue, double keyFrameProgress);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
}
public class System.Windows.Media.Animation.SplineVector3DKeyFrame : Vector3DKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineVector3DKeyFrame(Vector3D value);
    public SplineVector3DKeyFrame(Vector3D value, KeyTime keyTime);
    public SplineVector3DKeyFrame(Vector3D value, KeyTime keyTime, KeySpline keySpline);
    private static SplineVector3DKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Vector3D InterpolateValueCore(Vector3D baseValue, double keyFrameProgress);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
}
public class System.Windows.Media.Animation.SplineVectorKeyFrame : VectorKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineVectorKeyFrame(Vector value);
    public SplineVectorKeyFrame(Vector value, KeyTime keyTime);
    public SplineVectorKeyFrame(Vector value, KeyTime keyTime, KeySpline keySpline);
    private static SplineVectorKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Vector InterpolateValueCore(Vector baseValue, double keyFrameProgress);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
}
public abstract class System.Windows.Media.Animation.StringAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public StringAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual Type get_TargetPropertyType();
    public string GetCurrentValue(string defaultOriginValue, string defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual string GetCurrentValueCore(string defaultOriginValue, string defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.StringAnimationUsingKeyFrames : StringAnimationBase {
    private StringKeyFrameCollection _keyFrames;
    private ResolvedKeyFrameEntry[] _sortedResolvedKeyFrames;
    private bool _areKeyTimesValid;
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public StringKeyFrameCollection KeyFrames { get; public set; }
    private TimeSpan LargestTimeSpanKeyTime { get; }
    public StringAnimationUsingKeyFrames Clone();
    public StringAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private void CopyCommon(StringAnimationUsingKeyFrames sourceAnimation, bool isCurrentValueClone);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual string GetCurrentValueCore(string defaultOriginValue, string defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public StringKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(StringKeyFrameCollection value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    private string GetResolvedKeyFrameValue(int resolvedKeyFrameIndex);
    private StringKeyFrame GetResolvedKeyFrame(int resolvedKeyFrameIndex);
    private TimeSpan get_LargestTimeSpanKeyTime();
    private void ResolveKeyTimes();
    private void ResolvePacedKeyTimes();
}
public abstract class System.Windows.Media.Animation.StringKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public string Value { get; public set; }
    protected StringKeyFrame(string value);
    protected StringKeyFrame(string value, KeyTime keyTime);
    private static StringKeyFrame();
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public string get_Value();
    public void set_Value(string value);
    public string InterpolateValue(string baseValue, double keyFrameProgress);
    protected abstract virtual string InterpolateValueCore(string baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.StringKeyFrameCollection : Freezable {
    private List`1<StringKeyFrame> _keyFrames;
    private static StringKeyFrameCollection s_emptyCollection;
    public static StringKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public StringKeyFrame Item { get; public set; }
    public static StringKeyFrameCollection get_Empty();
    public StringKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(StringKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(StringKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(StringKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(StringKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, StringKeyFrame keyFrame);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(StringKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public StringKeyFrame get_Item(int index);
    public void set_Item(int index, StringKeyFrame value);
}
[FlagsAttribute]
[FriendAccessAllowedAttribute]
internal enum System.Windows.Media.Animation.SubtreeFlag : Enum {
    public int value__;
    public static SubtreeFlag Reset;
    public static SubtreeFlag ProcessRoot;
    public static SubtreeFlag SkipSubtree;
}
internal class System.Windows.Media.Animation.TimeIntervalCollection : ValueType {
    private TimeSpan[] _nodeTime;
    private Boolean[] _nodeIsPoint;
    private Boolean[] _nodeIsInterval;
    private bool _containsNullPoint;
    private int _count;
    private int _current;
    private bool _invertCollection;
    private static int _minimumCapacity;
    internal bool IsSingleInterval { get; }
    internal TimeSpan FirstNodeTime { get; }
    internal static TimeIntervalCollection Empty { get; }
    internal bool IsEmptyOfRealPoints { get; }
    internal bool IsEmpty { get; }
    private bool CurrentIsAtLastNode { get; }
    private TimeSpan CurrentNodeTime { get; private set; }
    private bool CurrentNodeIsPoint { get; private set; }
    private bool CurrentNodeIsInterval { get; private set; }
    private TimeSpan NextNodeTime { get; }
    private bool NextNodeIsPoint { get; }
    private bool NextNodeIsInterval { get; }
    internal bool ContainsNullPoint { get; }
    private TimeIntervalCollection(bool containsNullPoint);
    private TimeIntervalCollection(TimeSpan point);
    private TimeIntervalCollection(TimeSpan point, bool includePoint);
    private TimeIntervalCollection(TimeSpan from, bool includeFrom, TimeSpan to, bool includeTo);
    private void InitializePoint(TimeSpan point);
    internal void Clear();
    internal bool get_IsSingleInterval();
    internal TimeSpan get_FirstNodeTime();
    internal TimeIntervalCollection SlipBeginningOfConnectedInterval(TimeSpan slipTime);
    internal TimeIntervalCollection SetBeginningOfConnectedInterval(TimeSpan beginTime);
    internal static TimeIntervalCollection CreatePoint(TimeSpan time);
    internal static TimeIntervalCollection CreateClosedOpenInterval(TimeSpan from, TimeSpan to);
    internal static TimeIntervalCollection CreateOpenClosedInterval(TimeSpan from, TimeSpan to);
    internal static TimeIntervalCollection CreateInfiniteClosedInterval(TimeSpan from);
    internal static TimeIntervalCollection get_Empty();
    internal static TimeIntervalCollection CreateNullPoint();
    internal void AddNullPoint();
    internal bool Contains(TimeSpan time);
    internal bool Intersects(TimeSpan from, TimeSpan to);
    internal bool Intersects(TimeIntervalCollection other);
    private bool IntersectsHelper(TimeIntervalCollection other);
    private static void IntersectsHelperPrepareIndexers(TimeIntervalCollection& tic1, TimeIntervalCollection& tic2);
    private static bool IntersectsHelperUnequalCase(TimeIntervalCollection& tic1, TimeIntervalCollection& tic2, Boolean& intersectionFound);
    private static bool IntersectsHelperEqualCase(TimeIntervalCollection& tic1, TimeIntervalCollection& tic2, Boolean& intersectionFound);
    internal bool IntersectsInverseOf(TimeIntervalCollection other);
    internal bool IntersectsPeriodicCollection(TimeSpan beginTime, Duration period, double appliedSpeedRatio, double accelRatio, double decelRatio, bool isAutoReversed);
    internal bool IntersectsMultiplePeriods(TimeSpan beginTime, Duration period, double appliedSpeedRatio);
    internal void ProjectPostFillZone(TimeIntervalCollection& projection, TimeSpan beginTime, TimeSpan endTime, Duration period, double appliedSpeedRatio, double accelRatio, double decelRatio, bool isAutoReversed);
    internal void ProjectOntoPeriodicFunction(TimeIntervalCollection& projection, TimeSpan beginTime, Nullable`1<TimeSpan> endTime, Duration fillDuration, Duration period, double appliedSpeedRatio, double accelRatio, double decelRatio, bool isAutoReversed);
    private void ProjectionNormalize(TimeIntervalCollection& projection, TimeSpan beginTime, Nullable`1<TimeSpan> endTime, bool includeFillPeriod, double speedRatio);
    private void ProjectionFold(TimeIntervalCollection& projection, Nullable`1<TimeSpan> activeDuration, long periodInTicks, bool isAutoReversed, bool includeMaxPoint);
    private void ProjectionFoldPoint(TimeIntervalCollection& projection, Nullable`1<TimeSpan> activeDuration, long periodInTicks, bool isAutoReversed, bool includeMaxPoint);
    private bool ProjectionFoldInterval(TimeIntervalCollection& projection, Nullable`1<TimeSpan> activeDuration, long periodInTicks, bool isAutoReversed, bool includeMaxPoint);
    private void MergePoint(TimeSpan point);
    private void MergeInterval(TimeSpan from, bool includeFrom, TimeSpan to, bool includeTo);
    private void EnsureAllocatedCapacity(int requiredCapacity);
    private void ProjectionWarp(long periodInTicks, double accelRatio, double decelRatio);
    private int Locate(TimeSpan time);
    internal bool get_IsEmptyOfRealPoints();
    internal bool get_IsEmpty();
    private void MoveFirst();
    private void MoveNext();
    private bool get_CurrentIsAtLastNode();
    private TimeSpan get_CurrentNodeTime();
    private void set_CurrentNodeTime(TimeSpan value);
    private bool get_CurrentNodeIsPoint();
    private void set_CurrentNodeIsPoint(bool value);
    private bool get_CurrentNodeIsInterval();
    private void set_CurrentNodeIsInterval(bool value);
    private TimeSpan get_NextNodeTime();
    private bool get_NextNodeIsPoint();
    private bool get_NextNodeIsInterval();
    internal bool get_ContainsNullPoint();
    private void SetInvertedMode(bool mode);
}
[RuntimeNamePropertyAttribute("Name")]
[LocalizabilityAttribute("0")]
public abstract class System.Windows.Media.Animation.Timeline : Animatable {
    public static DependencyProperty AccelerationRatioProperty;
    public static DependencyProperty AutoReverseProperty;
    public static DependencyProperty BeginTimeProperty;
    public static DependencyProperty DecelerationRatioProperty;
    public static DependencyProperty DesiredFrameRateProperty;
    public static DependencyProperty DurationProperty;
    public static DependencyProperty FillBehaviorProperty;
    public static DependencyProperty NameProperty;
    public static DependencyProperty RepeatBehaviorProperty;
    public static DependencyProperty SpeedRatioProperty;
    internal static UncommonField`1<EventHandlersStore> EventHandlersStoreField;
    internal static EventPrivateKey CurrentGlobalSpeedInvalidatedKey;
    internal static EventPrivateKey CurrentStateInvalidatedKey;
    internal static EventPrivateKey CurrentTimeInvalidatedKey;
    internal static EventPrivateKey CompletedKey;
    internal static EventPrivateKey RemoveRequestedKey;
    public double AccelerationRatio { get; public set; }
    [DefaultValueAttribute("False")]
public bool AutoReverse { get; public set; }
    public Nullable`1<TimeSpan> BeginTime { get; public set; }
    public double DecelerationRatio { get; public set; }
    public Duration Duration { get; public set; }
    public FillBehavior FillBehavior { get; public set; }
    [DefaultValueAttribute("")]
[MergablePropertyAttribute("False")]
public string Name { get; public set; }
    public RepeatBehavior RepeatBehavior { get; public set; }
    [DefaultValueAttribute("1")]
public double SpeedRatio { get; public set; }
    internal EventHandlersStore InternalEventHandlersStore { get; }
    protected Timeline(Nullable`1<TimeSpan> beginTime);
    protected Timeline(Nullable`1<TimeSpan> beginTime, Duration duration);
    protected Timeline(Nullable`1<TimeSpan> beginTime, Duration duration, RepeatBehavior repeatBehavior);
    private static Timeline();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    private static void Timeline_PropertyChangedFunction(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public double get_AccelerationRatio();
    public void set_AccelerationRatio(double value);
    private static bool ValidateAccelerationDecelerationRatio(object value);
    public bool get_AutoReverse();
    public void set_AutoReverse(bool value);
    public Nullable`1<TimeSpan> get_BeginTime();
    public void set_BeginTime(Nullable`1<TimeSpan> value);
    public double get_DecelerationRatio();
    public void set_DecelerationRatio(double value);
    private static bool ValidateDesiredFrameRate(object value);
    public static Nullable`1<int> GetDesiredFrameRate(Timeline timeline);
    public static void SetDesiredFrameRate(Timeline timeline, Nullable`1<int> desiredFrameRate);
    public Duration get_Duration();
    public void set_Duration(Duration value);
    private static bool ValidateFillBehavior(object value);
    public FillBehavior get_FillBehavior();
    public void set_FillBehavior(FillBehavior value);
    public string get_Name();
    public void set_Name(string value);
    public RepeatBehavior get_RepeatBehavior();
    public void set_RepeatBehavior(RepeatBehavior value);
    public double get_SpeedRatio();
    public void set_SpeedRatio(double value);
    private static bool ValidateSpeedRatio(object value);
    protected internal virtual Clock AllocateClock();
    public Clock CreateClock();
    public Clock CreateClock(bool hasControllableRoot);
    protected internal Duration GetNaturalDuration(Clock clock);
    protected virtual Duration GetNaturalDurationCore(Clock clock);
    private void ValidateTimeline();
    public void add_CurrentStateInvalidated(EventHandler value);
    public void remove_CurrentStateInvalidated(EventHandler value);
    public void add_CurrentTimeInvalidated(EventHandler value);
    public void remove_CurrentTimeInvalidated(EventHandler value);
    public void add_CurrentGlobalSpeedInvalidated(EventHandler value);
    public void remove_CurrentGlobalSpeedInvalidated(EventHandler value);
    public void add_Completed(EventHandler value);
    public void remove_Completed(EventHandler value);
    public void add_RemoveRequested(EventHandler value);
    public void remove_RemoveRequested(EventHandler value);
    internal EventHandlersStore get_InternalEventHandlersStore();
    internal void InternalOnFreezablePropertyChanged(Timeline originalTimeline, Timeline newTimeline);
    internal bool InternalFreeze(bool isChecking);
    internal void InternalReadPreamble();
    internal void InternalWritePostscript();
    private void AddEventHandler(EventPrivateKey key, Delegate handler);
    private void CopyCommon(Timeline sourceTimeline);
    private void RemoveEventHandler(EventPrivateKey key, Delegate handler);
    public Timeline Clone();
    public Timeline CloneCurrentValue();
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.TimelineCollection : Animatable {
    private static TimelineCollection s_empty;
    internal FrugalStructList`1<Timeline> _collection;
    internal UInt32 _version;
    public Timeline Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.Animation.Timeline>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal static TimelineCollection Empty { get; }
    public TimelineCollection(int capacity);
    public TimelineCollection(IEnumerable`1<Timeline> collection);
    public TimelineCollection Clone();
    public TimelineCollection CloneCurrentValue();
    public sealed virtual void Add(Timeline value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Timeline value);
    public sealed virtual int IndexOf(Timeline value);
    public sealed virtual void Insert(int index, Timeline value);
    public sealed virtual bool Remove(Timeline value);
    public sealed virtual void RemoveAt(int index);
    internal void RemoveAtWithoutFiringPublicEvents(int index);
    public sealed virtual Timeline get_Item(int index);
    public sealed virtual void set_Item(int index, Timeline value);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(Timeline[] array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.Animation.Timeline>.get_IsReadOnly();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<Timeline> System.Collections.Generic.IEnumerable<System.Windows.Media.Animation.Timeline>.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal static TimelineCollection get_Empty();
    internal Timeline Internal_GetItem(int i);
    internal virtual void OnInheritanceContextChangedCore(EventArgs args);
    private Timeline Cast(object value);
    private int AddHelper(Timeline value);
    internal int AddWithoutFiringPublicEvents(Timeline value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected virtual bool FreezeCore(bool isChecking);
}
[ContentPropertyAttribute("Children")]
public abstract class System.Windows.Media.Animation.TimelineGroup : Timeline {
    public static DependencyProperty ChildrenProperty;
    internal static TimelineCollection s_Children;
    public TimelineCollection Children { get; public set; }
    protected TimelineGroup(Nullable`1<TimeSpan> beginTime);
    protected TimelineGroup(Nullable`1<TimeSpan> beginTime, Duration duration);
    protected TimelineGroup(Nullable`1<TimeSpan> beginTime, Duration duration, RepeatBehavior repeatBehavior);
    private static TimelineGroup();
    protected internal virtual Clock AllocateClock();
    public ClockGroup CreateClock();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    public TimelineGroup Clone();
    public TimelineGroup CloneCurrentValue();
    public TimelineCollection get_Children();
    public void set_Children(TimelineCollection value);
}
[FriendAccessAllowedAttribute]
internal class System.Windows.Media.Animation.TimelineTreeEnumerator : ValueType {
    private Timeline _rootTimeline;
    private SubtreeFlag _flags;
    private Stack _indexStack;
    private Stack`1<Timeline> _timelineStack;
    internal Timeline Current { get; }
    internal TimelineTreeEnumerator(Timeline root, bool processRoot);
    internal void SkipSubtree();
    public bool MoveNext();
    internal Timeline get_Current();
}
internal class System.Windows.Media.Animation.TimeManager : DispatcherObject {
    private TimeState _timeState;
    private TimeState _lastTimeState;
    private IClock _systemClock;
    private TimeSpan _globalTime;
    private TimeSpan _startTime;
    private TimeSpan _lastTickTime;
    private TimeSpan _pauseTime;
    private TimeIntervalCollection _currentTickInterval;
    private bool _nextTickTimeQueried;
    private bool _isDirty;
    private bool _isInTick;
    private bool _lockTickTime;
    private EventHandler _userNeedTickSooner;
    private ClockGroup _timeManagerClock;
    private Queue`1<WeakReference> _eventQueue;
    private bool _needClockCleanup;
    public IClock Clock { get; public set; }
    public Nullable`1<TimeSpan> CurrentTime { get; }
    public bool IsDirty { get; }
    internal TimeSpan InternalCurrentGlobalTime { get; }
    internal bool InternalIsStopped { get; }
    internal TimeIntervalCollection InternalCurrentIntervals { get; internal set; }
    internal TimeSpan LastTickDelta { get; }
    internal TimeSpan LastTickTime { get; }
    internal ClockGroup TimeManagerClock { get; }
    internal TimeState State { get; }
    public TimeManager(IClock clock);
    public IClock get_Clock();
    public void set_Clock(IClock value);
    public Nullable`1<TimeSpan> get_CurrentTime();
    public bool get_IsDirty();
    public void Pause();
    public void Restart();
    public void Resume();
    public void Seek(int offset, TimeSeekOrigin origin);
    public void Start();
    public void Stop();
    public void Tick();
    internal int GetMaxDesiredFrameRate();
    private void CleanupClocks();
    internal void AddToEventQueue(Clock sender);
    internal TimeSpan GetCurrentGlobalTime();
    internal void LockTickTime();
    internal void NotifyNewEarliestFutureActivity();
    private void RaiseEnqueuedEvents();
    internal void ScheduleClockCleanup();
    internal void SetDirty();
    internal void UnlockTickTime();
    internal TimeSpan get_InternalCurrentGlobalTime();
    internal bool get_InternalIsStopped();
    internal TimeIntervalCollection get_InternalCurrentIntervals();
    internal void set_InternalCurrentIntervals(TimeIntervalCollection value);
    internal TimeSpan GetNextTickNeeded();
    internal TimeSpan get_LastTickDelta();
    internal TimeSpan get_LastTickTime();
    internal ClockGroup get_TimeManagerClock();
    internal TimeState get_State();
    internal void add_NeedTickSooner(EventHandler value);
    internal void remove_NeedTickSooner(EventHandler value);
}
public enum System.Windows.Media.Animation.TimeSeekOrigin : Enum {
    public int value__;
    public static TimeSeekOrigin BeginTime;
    public static TimeSeekOrigin Duration;
}
internal enum System.Windows.Media.Animation.TimeState : Enum {
    public int value__;
    public static TimeState Stopped;
    public static TimeState Paused;
    public static TimeState Running;
}
public class System.Windows.Media.Animation.Vector3DAnimation : Vector3DAnimationBase {
    private Vector3D[] _keyValues;
    private AnimationType _animationType;
    private bool _isAnimationFunctionValid;
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public Nullable`1<Vector3D> From { get; public set; }
    public Nullable`1<Vector3D> To { get; public set; }
    public Nullable`1<Vector3D> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private static Vector3DAnimation();
    public Vector3DAnimation(Vector3D toValue, Duration duration);
    public Vector3DAnimation(Vector3D toValue, Duration duration, FillBehavior fillBehavior);
    public Vector3DAnimation(Vector3D fromValue, Vector3D toValue, Duration duration);
    public Vector3DAnimation(Vector3D fromValue, Vector3D toValue, Duration duration, FillBehavior fillBehavior);
    public Vector3DAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Vector3D GetCurrentValueCore(Vector3D defaultOriginValue, Vector3D defaultDestinationValue, AnimationClock animationClock);
    private void ValidateAnimationFunction();
    private static void AnimationFunction_Changed(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static bool ValidateFromToOrByValue(object value);
    public Nullable`1<Vector3D> get_From();
    public void set_From(Nullable`1<Vector3D> value);
    public Nullable`1<Vector3D> get_To();
    public void set_To(Nullable`1<Vector3D> value);
    public Nullable`1<Vector3D> get_By();
    public void set_By(Nullable`1<Vector3D> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
}
public abstract class System.Windows.Media.Animation.Vector3DAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public Vector3DAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual Type get_TargetPropertyType();
    public Vector3D GetCurrentValue(Vector3D defaultOriginValue, Vector3D defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual Vector3D GetCurrentValueCore(Vector3D defaultOriginValue, Vector3D defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.Vector3DAnimationUsingKeyFrames : Vector3DAnimationBase {
    private Vector3DKeyFrameCollection _keyFrames;
    private ResolvedKeyFrameEntry[] _sortedResolvedKeyFrames;
    private bool _areKeyTimesValid;
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public Vector3DKeyFrameCollection KeyFrames { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private TimeSpan LargestTimeSpanKeyTime { get; }
    public Vector3DAnimationUsingKeyFrames Clone();
    public Vector3DAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private void CopyCommon(Vector3DAnimationUsingKeyFrames sourceAnimation, bool isCurrentValueClone);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual Vector3D GetCurrentValueCore(Vector3D defaultOriginValue, Vector3D defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public Vector3DKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(Vector3DKeyFrameCollection value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    private Vector3D GetResolvedKeyFrameValue(int resolvedKeyFrameIndex);
    private Vector3DKeyFrame GetResolvedKeyFrame(int resolvedKeyFrameIndex);
    private TimeSpan get_LargestTimeSpanKeyTime();
    private void ResolveKeyTimes();
    private void ResolvePacedKeyTimes();
}
internal class System.Windows.Media.Animation.Vector3DIndependentAnimationStorage : IndependentAnimationStorage {
    protected ResourceType ResourceType { get; }
    protected virtual ResourceType get_ResourceType();
    protected virtual void UpdateResourceCore(Channel channel);
}
public abstract class System.Windows.Media.Animation.Vector3DKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public Vector3D Value { get; public set; }
    protected Vector3DKeyFrame(Vector3D value);
    protected Vector3DKeyFrame(Vector3D value, KeyTime keyTime);
    private static Vector3DKeyFrame();
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public Vector3D get_Value();
    public void set_Value(Vector3D value);
    public Vector3D InterpolateValue(Vector3D baseValue, double keyFrameProgress);
    protected abstract virtual Vector3D InterpolateValueCore(Vector3D baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.Vector3DKeyFrameCollection : Freezable {
    private List`1<Vector3DKeyFrame> _keyFrames;
    private static Vector3DKeyFrameCollection s_emptyCollection;
    public static Vector3DKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public Vector3DKeyFrame Item { get; public set; }
    public static Vector3DKeyFrameCollection get_Empty();
    public Vector3DKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(Vector3DKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(Vector3DKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(Vector3DKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(Vector3DKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, Vector3DKeyFrame keyFrame);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(Vector3DKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public Vector3DKeyFrame get_Item(int index);
    public void set_Item(int index, Vector3DKeyFrame value);
}
public class System.Windows.Media.Animation.VectorAnimation : VectorAnimationBase {
    private Vector[] _keyValues;
    private AnimationType _animationType;
    private bool _isAnimationFunctionValid;
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public Nullable`1<Vector> From { get; public set; }
    public Nullable`1<Vector> To { get; public set; }
    public Nullable`1<Vector> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private static VectorAnimation();
    public VectorAnimation(Vector toValue, Duration duration);
    public VectorAnimation(Vector toValue, Duration duration, FillBehavior fillBehavior);
    public VectorAnimation(Vector fromValue, Vector toValue, Duration duration);
    public VectorAnimation(Vector fromValue, Vector toValue, Duration duration, FillBehavior fillBehavior);
    public VectorAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Vector GetCurrentValueCore(Vector defaultOriginValue, Vector defaultDestinationValue, AnimationClock animationClock);
    private void ValidateAnimationFunction();
    private static void AnimationFunction_Changed(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static bool ValidateFromToOrByValue(object value);
    public Nullable`1<Vector> get_From();
    public void set_From(Nullable`1<Vector> value);
    public Nullable`1<Vector> get_To();
    public void set_To(Nullable`1<Vector> value);
    public Nullable`1<Vector> get_By();
    public void set_By(Nullable`1<Vector> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
}
public abstract class System.Windows.Media.Animation.VectorAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public VectorAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual Type get_TargetPropertyType();
    public Vector GetCurrentValue(Vector defaultOriginValue, Vector defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual Vector GetCurrentValueCore(Vector defaultOriginValue, Vector defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.VectorAnimationUsingKeyFrames : VectorAnimationBase {
    private VectorKeyFrameCollection _keyFrames;
    private ResolvedKeyFrameEntry[] _sortedResolvedKeyFrames;
    private bool _areKeyTimesValid;
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public VectorKeyFrameCollection KeyFrames { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private TimeSpan LargestTimeSpanKeyTime { get; }
    public VectorAnimationUsingKeyFrames Clone();
    public VectorAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private void CopyCommon(VectorAnimationUsingKeyFrames sourceAnimation, bool isCurrentValueClone);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual Vector GetCurrentValueCore(Vector defaultOriginValue, Vector defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public VectorKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(VectorKeyFrameCollection value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    private Vector GetResolvedKeyFrameValue(int resolvedKeyFrameIndex);
    private VectorKeyFrame GetResolvedKeyFrame(int resolvedKeyFrameIndex);
    private TimeSpan get_LargestTimeSpanKeyTime();
    private void ResolveKeyTimes();
    private void ResolvePacedKeyTimes();
}
public abstract class System.Windows.Media.Animation.VectorKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public Vector Value { get; public set; }
    protected VectorKeyFrame(Vector value);
    protected VectorKeyFrame(Vector value, KeyTime keyTime);
    private static VectorKeyFrame();
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public Vector get_Value();
    public void set_Value(Vector value);
    public Vector InterpolateValue(Vector baseValue, double keyFrameProgress);
    protected abstract virtual Vector InterpolateValueCore(Vector baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.VectorKeyFrameCollection : Freezable {
    private List`1<VectorKeyFrame> _keyFrames;
    private static VectorKeyFrameCollection s_emptyCollection;
    public static VectorKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public VectorKeyFrame Item { get; public set; }
    public static VectorKeyFrameCollection get_Empty();
    public VectorKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(VectorKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(VectorKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(VectorKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(VectorKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, VectorKeyFrame keyFrame);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(VectorKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public VectorKeyFrame get_Item(int index);
    public void set_Item(int index, VectorKeyFrame value);
}
internal class System.Windows.Media.Animation.WeakRefEnumerator`1 : ValueType {
    private List`1<WeakReference> _list;
    private T _current;
    private int _readIndex;
    private int _writeIndex;
    internal T Current { get; }
    internal int CurrentIndex { get; }
    internal WeakRefEnumerator`1(List`1<WeakReference> list);
    internal T get_Current();
    internal int get_CurrentIndex();
    internal void Dispose();
    internal bool MoveNext();
}
public class System.Windows.Media.ArcSegment : PathSegment {
    public static DependencyProperty PointProperty;
    public static DependencyProperty SizeProperty;
    public static DependencyProperty RotationAngleProperty;
    public static DependencyProperty IsLargeArcProperty;
    public static DependencyProperty SweepDirectionProperty;
    internal static Point s_Point;
    internal static Size s_Size;
    internal static double c_RotationAngle;
    internal static bool c_IsLargeArc;
    internal static SweepDirection c_SweepDirection;
    internal int EffectiveValuesInitialSize { get; }
    public Point Point { get; public set; }
    public Size Size { get; public set; }
    public double RotationAngle { get; public set; }
    public bool IsLargeArc { get; public set; }
    public SweepDirection SweepDirection { get; public set; }
    public ArcSegment(Point point, Size size, double rotationAngle, bool isLargeArc, SweepDirection sweepDirection, bool isStroked);
    private static ArcSegment();
    internal virtual void AddToFigure(Matrix matrix, PathFigure figure, Point& current);
    internal virtual void SerializeData(StreamGeometryContext ctx);
    internal virtual bool IsCurved();
    internal virtual string ConvertToString(string format, IFormatProvider provider);
    internal virtual int get_EffectiveValuesInitialSize();
    private static object CoerceSize(DependencyObject d, object value);
    public ArcSegment Clone();
    public ArcSegment CloneCurrentValue();
    public Point get_Point();
    public void set_Point(Point value);
    public Size get_Size();
    public void set_Size(Size value);
    public double get_RotationAngle();
    public void set_RotationAngle(double value);
    public bool get_IsLargeArc();
    public void set_IsLargeArc(bool value);
    public SweepDirection get_SweepDirection();
    public void set_SweepDirection(SweepDirection value);
    protected virtual Freezable CreateInstanceCore();
}
internal enum System.Windows.Media.AVEvent : Enum {
    public int value__;
    public static AVEvent AVMediaNone;
    public static AVEvent AVMediaOpened;
    public static AVEvent AVMediaClosed;
    public static AVEvent AVMediaStarted;
    public static AVEvent AVMediaStopped;
    public static AVEvent AVMediaPaused;
    public static AVEvent AVMediaRateChanged;
    public static AVEvent AVMediaEnded;
    public static AVEvent AVMediaFailed;
    public static AVEvent AVMediaBufferingStarted;
    public static AVEvent AVMediaBufferingEnded;
    public static AVEvent AVMediaPrerolled;
    public static AVEvent AVMediaScriptCommand;
    public static AVEvent AVMediaNewFrame;
}
public class System.Windows.Media.BezierSegment : PathSegment {
    public static DependencyProperty Point1Property;
    public static DependencyProperty Point2Property;
    public static DependencyProperty Point3Property;
    internal static Point s_Point1;
    internal static Point s_Point2;
    internal static Point s_Point3;
    public Point Point1 { get; public set; }
    public Point Point2 { get; public set; }
    public Point Point3 { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    public BezierSegment(Point point1, Point point2, Point point3, bool isStroked);
    internal BezierSegment(Point point1, Point point2, Point point3, bool isStroked, bool isSmoothJoin);
    private static BezierSegment();
    internal virtual void AddToFigure(Matrix matrix, PathFigure figure, Point& current);
    internal virtual void SerializeData(StreamGeometryContext ctx);
    internal virtual bool IsCurved();
    internal virtual string ConvertToString(string format, IFormatProvider provider);
    public BezierSegment Clone();
    public BezierSegment CloneCurrentValue();
    public Point get_Point1();
    public void set_Point1(Point value);
    public Point get_Point2();
    public void set_Point2(Point value);
    public Point get_Point3();
    public void set_Point3(Point value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual int get_EffectiveValuesInitialSize();
}
public class System.Windows.Media.BitmapCache : CacheMode {
    public static DependencyProperty RenderAtScaleProperty;
    public static DependencyProperty SnapsToDevicePixelsProperty;
    public static DependencyProperty EnableClearTypeProperty;
    internal MultiChannelResource _duceResource;
    internal static double c_RenderAtScale;
    internal static bool c_SnapsToDevicePixels;
    internal static bool c_EnableClearType;
    public double RenderAtScale { get; public set; }
    public bool SnapsToDevicePixels { get; public set; }
    public bool EnableClearType { get; public set; }
    public BitmapCache(double renderAtScale);
    private static BitmapCache();
    public BitmapCache Clone();
    public BitmapCache CloneCurrentValue();
    private static void RenderAtScalePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void SnapsToDevicePixelsPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void EnableClearTypePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public double get_RenderAtScale();
    public void set_RenderAtScale(double value);
    public bool get_SnapsToDevicePixels();
    public void set_SnapsToDevicePixels(bool value);
    public bool get_EnableClearType();
    public void set_EnableClearType(bool value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
}
public class System.Windows.Media.BitmapCacheBrush : Brush {
    private ContainerVisual _dummyVisual;
    private DispatcherOperation _DispatcherLayoutResult;
    private bool _pendingLayout;
    private bool _reentrancyFlag;
    private bool _isAsyncRenderRegistered;
    public static DependencyProperty TargetProperty;
    public static DependencyProperty BitmapCacheProperty;
    public static DependencyProperty AutoLayoutContentProperty;
    internal static DependencyProperty InternalTargetProperty;
    internal static DependencyProperty AutoWrapTargetProperty;
    internal MultiChannelResource _duceResource;
    internal static bool c_AutoLayoutContent;
    internal static bool c_AutoWrapTarget;
    private ContainerVisual AutoWrapVisual { get; }
    public Visual Target { get; public set; }
    public BitmapCache BitmapCache { get; public set; }
    public bool AutoLayoutContent { get; public set; }
    internal Visual InternalTarget { get; internal set; }
    internal bool AutoWrapTarget { get; internal set; }
    internal int EffectiveValuesInitialSize { get; }
    public BitmapCacheBrush(Visual visual);
    private static BitmapCacheBrush();
    private ContainerVisual get_AutoWrapVisual();
    private sealed virtual override void System.Windows.Media.ICyclicBrush.FireOnChanged();
    private void RegisterForAsyncRenderForCyclicBrush();
    private sealed virtual override void System.Windows.Media.ICyclicBrush.RenderForCyclicBrush(Channel channel, bool skipChannelCheck);
    internal void AddRefResource(Visual visual, Channel channel);
    internal void ReleaseResource(Visual visual, Channel channel);
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    private void DoLayout(UIElement element);
    private void OnLayoutUpdated(object sender, EventArgs args);
    private object LayoutCallback(object arg);
    internal bool Enter();
    internal void Exit();
    private static object CoerceOpacity(DependencyObject d, object value);
    private static object CoerceTransform(DependencyObject d, object value);
    private static object CoerceRelativeTransform(DependencyObject d, object value);
    private static void StaticInitialize(Type typeofThis);
    public BitmapCacheBrush Clone();
    public BitmapCacheBrush CloneCurrentValue();
    private static void TargetPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void BitmapCachePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void AutoLayoutContentPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void InternalTargetPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void AutoWrapTargetPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Visual get_Target();
    public void set_Target(Visual value);
    public BitmapCache get_BitmapCache();
    public void set_BitmapCache(BitmapCache value);
    public bool get_AutoLayoutContent();
    public void set_AutoLayoutContent(bool value);
    internal Visual get_InternalTarget();
    internal void set_InternalTarget(Visual value);
    internal bool get_AutoWrapTarget();
    internal void set_AutoWrapTarget(bool value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    internal virtual int get_EffectiveValuesInitialSize();
}
public enum System.Windows.Media.BitmapScalingMode : Enum {
    public int value__;
    public static BitmapScalingMode Unspecified;
    public static BitmapScalingMode LowQuality;
    public static BitmapScalingMode HighQuality;
    public static BitmapScalingMode Linear;
    public static BitmapScalingMode Fant;
    public static BitmapScalingMode NearestNeighbor;
}
internal class System.Windows.Media.BoundsDrawingContextWalker : DrawingContextWalker {
    private Rect _bounds;
    private Rect _clip;
    private bool _haveClip;
    private Matrix _transform;
    private Stack`1<PushType> _pushTypeStack;
    private Stack`1<Matrix> _transformStack;
    private Stack`1<Rect> _clipStack;
    public Rect Bounds { get; }
    public Rect get_Bounds();
    public virtual void DrawLine(Pen pen, Point point0, Point point1);
    public virtual void DrawRectangle(Brush brush, Pen pen, Rect rectangle);
    public virtual void DrawRoundedRectangle(Brush brush, Pen pen, Rect rectangle, double radiusX, double radiusY);
    public virtual void DrawEllipse(Brush brush, Pen pen, Point center, double radiusX, double radiusY);
    public virtual void DrawGeometry(Brush brush, Pen pen, Geometry geometry);
    public virtual void DrawImage(ImageSource imageSource, Rect rectangle);
    public virtual void DrawVideo(MediaPlayer video, Rect rectangle);
    public virtual void DrawGlyphRun(Brush foregroundBrush, GlyphRun glyphRun);
    public virtual void PushOpacityMask(Brush brush);
    public virtual void PushClip(Geometry clipGeometry);
    public virtual void PushOpacity(double opacity);
    public virtual void PushTransform(Transform transform);
    public virtual void PushGuidelineSet(GuidelineSet guidelines);
    internal virtual void PushGuidelineY1(double coordinate);
    internal virtual void PushGuidelineY2(double leadingCoordinate, double offsetToDrivenCoordinate);
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
public virtual void PushEffect(BitmapEffect effect, BitmapEffectInput effectInput);
    public virtual void Pop();
    private void AddBounds(Rect& bounds);
    private void AddTransformedBounds(Rect& bounds);
    private void PushTypeStack(PushType pushType);
    internal void ClearState();
}
[TypeConverterAttribute("System.Windows.Media.BrushConverter")]
[LocalizabilityAttribute("0")]
[ValueSerializerAttribute("System.Windows.Media.Converters.BrushValueSerializer")]
public abstract class System.Windows.Media.Brush : Animatable {
    public static DependencyProperty OpacityProperty;
    public static DependencyProperty TransformProperty;
    public static DependencyProperty RelativeTransformProperty;
    internal static double c_Opacity;
    internal static Transform s_Transform;
    internal static Transform s_RelativeTransform;
    public double Opacity { get; public set; }
    public Transform Transform { get; public set; }
    public Transform RelativeTransform { get; public set; }
    private static Brush();
    internal static Brush Parse(string value, ITypeDescriptorContext context);
    internal virtual bool CanSerializeToString();
    public Brush Clone();
    public Brush CloneCurrentValue();
    private static void OpacityPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void TransformPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void RelativeTransformPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public double get_Opacity();
    public void set_Opacity(double value);
    public Transform get_Transform();
    public void set_Transform(Transform value);
    public Transform get_RelativeTransform();
    public void set_RelativeTransform(Transform value);
    internal abstract virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    internal abstract virtual void ReleaseOnChannelCore(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    internal abstract virtual ResourceHandle GetHandleCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    internal abstract virtual int GetChannelCountCore();
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    internal abstract virtual Channel GetChannelCore(int index);
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal virtual string ConvertToString(string format, IFormatProvider provider);
}
public class System.Windows.Media.BrushConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.Brushes : object {
    public static SolidColorBrush AliceBlue { get; }
    public static SolidColorBrush AntiqueWhite { get; }
    public static SolidColorBrush Aqua { get; }
    public static SolidColorBrush Aquamarine { get; }
    public static SolidColorBrush Azure { get; }
    public static SolidColorBrush Beige { get; }
    public static SolidColorBrush Bisque { get; }
    public static SolidColorBrush Black { get; }
    public static SolidColorBrush BlanchedAlmond { get; }
    public static SolidColorBrush Blue { get; }
    public static SolidColorBrush BlueViolet { get; }
    public static SolidColorBrush Brown { get; }
    public static SolidColorBrush BurlyWood { get; }
    public static SolidColorBrush CadetBlue { get; }
    public static SolidColorBrush Chartreuse { get; }
    public static SolidColorBrush Chocolate { get; }
    public static SolidColorBrush Coral { get; }
    public static SolidColorBrush CornflowerBlue { get; }
    public static SolidColorBrush Cornsilk { get; }
    public static SolidColorBrush Crimson { get; }
    public static SolidColorBrush Cyan { get; }
    public static SolidColorBrush DarkBlue { get; }
    public static SolidColorBrush DarkCyan { get; }
    public static SolidColorBrush DarkGoldenrod { get; }
    public static SolidColorBrush DarkGray { get; }
    public static SolidColorBrush DarkGreen { get; }
    public static SolidColorBrush DarkKhaki { get; }
    public static SolidColorBrush DarkMagenta { get; }
    public static SolidColorBrush DarkOliveGreen { get; }
    public static SolidColorBrush DarkOrange { get; }
    public static SolidColorBrush DarkOrchid { get; }
    public static SolidColorBrush DarkRed { get; }
    public static SolidColorBrush DarkSalmon { get; }
    public static SolidColorBrush DarkSeaGreen { get; }
    public static SolidColorBrush DarkSlateBlue { get; }
    public static SolidColorBrush DarkSlateGray { get; }
    public static SolidColorBrush DarkTurquoise { get; }
    public static SolidColorBrush DarkViolet { get; }
    public static SolidColorBrush DeepPink { get; }
    public static SolidColorBrush DeepSkyBlue { get; }
    public static SolidColorBrush DimGray { get; }
    public static SolidColorBrush DodgerBlue { get; }
    public static SolidColorBrush Firebrick { get; }
    public static SolidColorBrush FloralWhite { get; }
    public static SolidColorBrush ForestGreen { get; }
    public static SolidColorBrush Fuchsia { get; }
    public static SolidColorBrush Gainsboro { get; }
    public static SolidColorBrush GhostWhite { get; }
    public static SolidColorBrush Gold { get; }
    public static SolidColorBrush Goldenrod { get; }
    public static SolidColorBrush Gray { get; }
    public static SolidColorBrush Green { get; }
    public static SolidColorBrush GreenYellow { get; }
    public static SolidColorBrush Honeydew { get; }
    public static SolidColorBrush HotPink { get; }
    public static SolidColorBrush IndianRed { get; }
    public static SolidColorBrush Indigo { get; }
    public static SolidColorBrush Ivory { get; }
    public static SolidColorBrush Khaki { get; }
    public static SolidColorBrush Lavender { get; }
    public static SolidColorBrush LavenderBlush { get; }
    public static SolidColorBrush LawnGreen { get; }
    public static SolidColorBrush LemonChiffon { get; }
    public static SolidColorBrush LightBlue { get; }
    public static SolidColorBrush LightCoral { get; }
    public static SolidColorBrush LightCyan { get; }
    public static SolidColorBrush LightGoldenrodYellow { get; }
    public static SolidColorBrush LightGray { get; }
    public static SolidColorBrush LightGreen { get; }
    public static SolidColorBrush LightPink { get; }
    public static SolidColorBrush LightSalmon { get; }
    public static SolidColorBrush LightSeaGreen { get; }
    public static SolidColorBrush LightSkyBlue { get; }
    public static SolidColorBrush LightSlateGray { get; }
    public static SolidColorBrush LightSteelBlue { get; }
    public static SolidColorBrush LightYellow { get; }
    public static SolidColorBrush Lime { get; }
    public static SolidColorBrush LimeGreen { get; }
    public static SolidColorBrush Linen { get; }
    public static SolidColorBrush Magenta { get; }
    public static SolidColorBrush Maroon { get; }
    public static SolidColorBrush MediumAquamarine { get; }
    public static SolidColorBrush MediumBlue { get; }
    public static SolidColorBrush MediumOrchid { get; }
    public static SolidColorBrush MediumPurple { get; }
    public static SolidColorBrush MediumSeaGreen { get; }
    public static SolidColorBrush MediumSlateBlue { get; }
    public static SolidColorBrush MediumSpringGreen { get; }
    public static SolidColorBrush MediumTurquoise { get; }
    public static SolidColorBrush MediumVioletRed { get; }
    public static SolidColorBrush MidnightBlue { get; }
    public static SolidColorBrush MintCream { get; }
    public static SolidColorBrush MistyRose { get; }
    public static SolidColorBrush Moccasin { get; }
    public static SolidColorBrush NavajoWhite { get; }
    public static SolidColorBrush Navy { get; }
    public static SolidColorBrush OldLace { get; }
    public static SolidColorBrush Olive { get; }
    public static SolidColorBrush OliveDrab { get; }
    public static SolidColorBrush Orange { get; }
    public static SolidColorBrush OrangeRed { get; }
    public static SolidColorBrush Orchid { get; }
    public static SolidColorBrush PaleGoldenrod { get; }
    public static SolidColorBrush PaleGreen { get; }
    public static SolidColorBrush PaleTurquoise { get; }
    public static SolidColorBrush PaleVioletRed { get; }
    public static SolidColorBrush PapayaWhip { get; }
    public static SolidColorBrush PeachPuff { get; }
    public static SolidColorBrush Peru { get; }
    public static SolidColorBrush Pink { get; }
    public static SolidColorBrush Plum { get; }
    public static SolidColorBrush PowderBlue { get; }
    public static SolidColorBrush Purple { get; }
    public static SolidColorBrush Red { get; }
    public static SolidColorBrush RosyBrown { get; }
    public static SolidColorBrush RoyalBlue { get; }
    public static SolidColorBrush SaddleBrown { get; }
    public static SolidColorBrush Salmon { get; }
    public static SolidColorBrush SandyBrown { get; }
    public static SolidColorBrush SeaGreen { get; }
    public static SolidColorBrush SeaShell { get; }
    public static SolidColorBrush Sienna { get; }
    public static SolidColorBrush Silver { get; }
    public static SolidColorBrush SkyBlue { get; }
    public static SolidColorBrush SlateBlue { get; }
    public static SolidColorBrush SlateGray { get; }
    public static SolidColorBrush Snow { get; }
    public static SolidColorBrush SpringGreen { get; }
    public static SolidColorBrush SteelBlue { get; }
    public static SolidColorBrush Tan { get; }
    public static SolidColorBrush Teal { get; }
    public static SolidColorBrush Thistle { get; }
    public static SolidColorBrush Tomato { get; }
    public static SolidColorBrush Transparent { get; }
    public static SolidColorBrush Turquoise { get; }
    public static SolidColorBrush Violet { get; }
    public static SolidColorBrush Wheat { get; }
    public static SolidColorBrush White { get; }
    public static SolidColorBrush WhiteSmoke { get; }
    public static SolidColorBrush Yellow { get; }
    public static SolidColorBrush YellowGreen { get; }
    public static SolidColorBrush get_AliceBlue();
    public static SolidColorBrush get_AntiqueWhite();
    public static SolidColorBrush get_Aqua();
    public static SolidColorBrush get_Aquamarine();
    public static SolidColorBrush get_Azure();
    public static SolidColorBrush get_Beige();
    public static SolidColorBrush get_Bisque();
    public static SolidColorBrush get_Black();
    public static SolidColorBrush get_BlanchedAlmond();
    public static SolidColorBrush get_Blue();
    public static SolidColorBrush get_BlueViolet();
    public static SolidColorBrush get_Brown();
    public static SolidColorBrush get_BurlyWood();
    public static SolidColorBrush get_CadetBlue();
    public static SolidColorBrush get_Chartreuse();
    public static SolidColorBrush get_Chocolate();
    public static SolidColorBrush get_Coral();
    public static SolidColorBrush get_CornflowerBlue();
    public static SolidColorBrush get_Cornsilk();
    public static SolidColorBrush get_Crimson();
    public static SolidColorBrush get_Cyan();
    public static SolidColorBrush get_DarkBlue();
    public static SolidColorBrush get_DarkCyan();
    public static SolidColorBrush get_DarkGoldenrod();
    public static SolidColorBrush get_DarkGray();
    public static SolidColorBrush get_DarkGreen();
    public static SolidColorBrush get_DarkKhaki();
    public static SolidColorBrush get_DarkMagenta();
    public static SolidColorBrush get_DarkOliveGreen();
    public static SolidColorBrush get_DarkOrange();
    public static SolidColorBrush get_DarkOrchid();
    public static SolidColorBrush get_DarkRed();
    public static SolidColorBrush get_DarkSalmon();
    public static SolidColorBrush get_DarkSeaGreen();
    public static SolidColorBrush get_DarkSlateBlue();
    public static SolidColorBrush get_DarkSlateGray();
    public static SolidColorBrush get_DarkTurquoise();
    public static SolidColorBrush get_DarkViolet();
    public static SolidColorBrush get_DeepPink();
    public static SolidColorBrush get_DeepSkyBlue();
    public static SolidColorBrush get_DimGray();
    public static SolidColorBrush get_DodgerBlue();
    public static SolidColorBrush get_Firebrick();
    public static SolidColorBrush get_FloralWhite();
    public static SolidColorBrush get_ForestGreen();
    public static SolidColorBrush get_Fuchsia();
    public static SolidColorBrush get_Gainsboro();
    public static SolidColorBrush get_GhostWhite();
    public static SolidColorBrush get_Gold();
    public static SolidColorBrush get_Goldenrod();
    public static SolidColorBrush get_Gray();
    public static SolidColorBrush get_Green();
    public static SolidColorBrush get_GreenYellow();
    public static SolidColorBrush get_Honeydew();
    public static SolidColorBrush get_HotPink();
    public static SolidColorBrush get_IndianRed();
    public static SolidColorBrush get_Indigo();
    public static SolidColorBrush get_Ivory();
    public static SolidColorBrush get_Khaki();
    public static SolidColorBrush get_Lavender();
    public static SolidColorBrush get_LavenderBlush();
    public static SolidColorBrush get_LawnGreen();
    public static SolidColorBrush get_LemonChiffon();
    public static SolidColorBrush get_LightBlue();
    public static SolidColorBrush get_LightCoral();
    public static SolidColorBrush get_LightCyan();
    public static SolidColorBrush get_LightGoldenrodYellow();
    public static SolidColorBrush get_LightGray();
    public static SolidColorBrush get_LightGreen();
    public static SolidColorBrush get_LightPink();
    public static SolidColorBrush get_LightSalmon();
    public static SolidColorBrush get_LightSeaGreen();
    public static SolidColorBrush get_LightSkyBlue();
    public static SolidColorBrush get_LightSlateGray();
    public static SolidColorBrush get_LightSteelBlue();
    public static SolidColorBrush get_LightYellow();
    public static SolidColorBrush get_Lime();
    public static SolidColorBrush get_LimeGreen();
    public static SolidColorBrush get_Linen();
    public static SolidColorBrush get_Magenta();
    public static SolidColorBrush get_Maroon();
    public static SolidColorBrush get_MediumAquamarine();
    public static SolidColorBrush get_MediumBlue();
    public static SolidColorBrush get_MediumOrchid();
    public static SolidColorBrush get_MediumPurple();
    public static SolidColorBrush get_MediumSeaGreen();
    public static SolidColorBrush get_MediumSlateBlue();
    public static SolidColorBrush get_MediumSpringGreen();
    public static SolidColorBrush get_MediumTurquoise();
    public static SolidColorBrush get_MediumVioletRed();
    public static SolidColorBrush get_MidnightBlue();
    public static SolidColorBrush get_MintCream();
    public static SolidColorBrush get_MistyRose();
    public static SolidColorBrush get_Moccasin();
    public static SolidColorBrush get_NavajoWhite();
    public static SolidColorBrush get_Navy();
    public static SolidColorBrush get_OldLace();
    public static SolidColorBrush get_Olive();
    public static SolidColorBrush get_OliveDrab();
    public static SolidColorBrush get_Orange();
    public static SolidColorBrush get_OrangeRed();
    public static SolidColorBrush get_Orchid();
    public static SolidColorBrush get_PaleGoldenrod();
    public static SolidColorBrush get_PaleGreen();
    public static SolidColorBrush get_PaleTurquoise();
    public static SolidColorBrush get_PaleVioletRed();
    public static SolidColorBrush get_PapayaWhip();
    public static SolidColorBrush get_PeachPuff();
    public static SolidColorBrush get_Peru();
    public static SolidColorBrush get_Pink();
    public static SolidColorBrush get_Plum();
    public static SolidColorBrush get_PowderBlue();
    public static SolidColorBrush get_Purple();
    public static SolidColorBrush get_Red();
    public static SolidColorBrush get_RosyBrown();
    public static SolidColorBrush get_RoyalBlue();
    public static SolidColorBrush get_SaddleBrown();
    public static SolidColorBrush get_Salmon();
    public static SolidColorBrush get_SandyBrown();
    public static SolidColorBrush get_SeaGreen();
    public static SolidColorBrush get_SeaShell();
    public static SolidColorBrush get_Sienna();
    public static SolidColorBrush get_Silver();
    public static SolidColorBrush get_SkyBlue();
    public static SolidColorBrush get_SlateBlue();
    public static SolidColorBrush get_SlateGray();
    public static SolidColorBrush get_Snow();
    public static SolidColorBrush get_SpringGreen();
    public static SolidColorBrush get_SteelBlue();
    public static SolidColorBrush get_Tan();
    public static SolidColorBrush get_Teal();
    public static SolidColorBrush get_Thistle();
    public static SolidColorBrush get_Tomato();
    public static SolidColorBrush get_Transparent();
    public static SolidColorBrush get_Turquoise();
    public static SolidColorBrush get_Violet();
    public static SolidColorBrush get_Wheat();
    public static SolidColorBrush get_White();
    public static SolidColorBrush get_WhiteSmoke();
    public static SolidColorBrush get_Yellow();
    public static SolidColorBrush get_YellowGreen();
}
public enum System.Windows.Media.BrushMappingMode : Enum {
    public int value__;
    public static BrushMappingMode Absolute;
    public static BrushMappingMode RelativeToBoundingBox;
}
internal class System.Windows.Media.ByteStreamGeometryContext : CapacityStreamGeometryContext {
    private bool _disposed;
    private int _currChunkOffset;
    private FrugalStructList`1<Byte[]> _chunkList;
    private int _currOffset;
    private MIL_PATHGEOMETRY _currentPathGeometryData;
    private MIL_PATHFIGURE _currentPathFigureData;
    private int _currentPathFigureDataOffset;
    private MIL_SEGMENT_POLY _currentPolySegmentData;
    private int _currentPolySegmentDataOffset;
    private UInt32 _lastSegmentSize;
    private UInt32 _lastFigureSize;
    private static int c_defaultChunkSize;
    private static int c_maxChunkSize;
    [ThreadStaticAttribute]
private static Byte[] _pooledChunk;
    public virtual void Close();
    public virtual void BeginFigure(Point startPoint, bool isFilled, bool isClosed);
    public virtual void LineTo(Point point, bool isStroked, bool isSmoothJoin);
    public virtual void QuadraticBezierTo(Point point1, Point point2, bool isStroked, bool isSmoothJoin);
    public virtual void BezierTo(Point point1, Point point2, Point point3, bool isStroked, bool isSmoothJoin);
    public virtual void PolyLineTo(IList`1<Point> points, bool isStroked, bool isSmoothJoin);
    public virtual void PolyQuadraticBezierTo(IList`1<Point> points, bool isStroked, bool isSmoothJoin);
    public virtual void PolyBezierTo(IList`1<Point> points, bool isStroked, bool isSmoothJoin);
    public virtual void ArcTo(Point point, Size size, double rotationAngle, bool isLargeArc, SweepDirection sweepDirection, bool isStroked, bool isSmoothJoin);
    internal Byte[] GetData();
    internal virtual void SetClosedState(bool isClosed);
    private void VerifyApi();
    protected virtual void CloseCore(Byte[] geometryData);
    internal virtual void DisposeCore();
    private void ReadData(Byte* pbData, int bufferOffset, int cbDataSize);
    private void OverwriteData(Byte* pbData, int bufferOffset, int cbDataSize);
    private void AppendData(Byte* pbData, int cbDataSize);
    internal void ShrinkToFit();
    private void ReadWriteData(bool reading, Byte* pbData, int cbDataSize, int currentChunk, Int32& bufferOffset);
    private void FinishFigure();
    private void FinishSegment();
    private void GenericPolyTo(IList`1<Point> points, bool isStroked, bool isSmoothJoin, bool hasCurves, int pointCountMultiple, MIL_SEGMENT_TYPE segmentType);
    private void GenericPolyTo(Point* points, int count, bool isStroked, bool isSmoothJoin, bool hasCurves, MIL_SEGMENT_TYPE segmentType);
    private void GenericPolyToHelper(bool isStroked, bool isSmoothJoin, bool hasCurves, MIL_SEGMENT_TYPE segmentType);
    private static Byte[] AcquireChunkFromPool();
    private static void ReturnChunkToPool(Byte[] chunk);
}
[ValueSerializerAttribute("System.Windows.Media.Converters.CacheModeValueSerializer")]
[TypeConverterAttribute("System.Windows.Media.CacheModeConverter")]
public abstract class System.Windows.Media.CacheMode : Animatable {
    internal static CacheMode Parse(string value);
    internal virtual bool CanSerializeToString();
    internal virtual string ConvertToString(string format, IFormatProvider provider);
    public CacheMode Clone();
    public CacheMode CloneCurrentValue();
    internal abstract virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    internal abstract virtual void ReleaseOnChannelCore(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    internal abstract virtual ResourceHandle GetHandleCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    internal abstract virtual int GetChannelCountCore();
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    internal abstract virtual Channel GetChannelCore(int index);
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
}
public class System.Windows.Media.CacheModeConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public enum System.Windows.Media.CachingHint : Enum {
    public int value__;
    public static CachingHint Unspecified;
    public static CachingHint Cache;
}
internal abstract class System.Windows.Media.CapacityStreamGeometryContext : StreamGeometryContext {
    internal virtual void SetFigureCount(int figureCount);
    internal virtual void SetSegmentCount(int segmentCount);
}
public class System.Windows.Media.CharacterMetrics : object {
    private double _blackBoxWidth;
    private double _blackBoxHeight;
    private double _baseline;
    private double _leftSideBearing;
    private double _rightSideBearing;
    private double _topSideBearing;
    private double _bottomSideBearing;
    private static int NumFields;
    private static int NumRequiredFields;
    private static int HashMultiplier;
    public string Metrics { get; public set; }
    public double BlackBoxWidth { get; }
    public double BlackBoxHeight { get; }
    public double Baseline { get; }
    public double LeftSideBearing { get; }
    public double RightSideBearing { get; }
    public double TopSideBearing { get; }
    public double BottomSideBearing { get; }
    public CharacterMetrics(string metrics);
    public string get_Metrics();
    public void set_Metrics(string value);
    private static void AppendField(double value, FieldIndex fieldIndex, Int32& lastIndex, StringBuilder s);
    private static Double[] ParseMetrics(string s);
    public double get_BlackBoxWidth();
    public double get_BlackBoxHeight();
    public double get_Baseline();
    public double get_LeftSideBearing();
    public double get_RightSideBearing();
    public double get_TopSideBearing();
    public double get_BottomSideBearing();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.CharacterMetricsDictionary : object {
    internal static int LastDeviceFontCharacterCode;
    internal static int PageShift;
    internal static int PageSize;
    internal static int PageMask;
    internal static int PageCount;
    private CharacterMetrics[][] _pageTable;
    private int _count;
    public int Count { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public CharacterMetrics Item { get; public set; }
    [CLSCompliantAttribute("False")]
public ICollection`1<int> Keys { get; }
    [CLSCompliantAttribute("False")]
public ICollection`1<CharacterMetrics> Values { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    [CLSCompliantAttribute("False")]
public sealed virtual IEnumerator`1<KeyValuePair`2<int, CharacterMetrics>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    public sealed virtual bool TryGetValue(int key, CharacterMetrics& value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    [CLSCompliantAttribute("False")]
public sealed virtual void Add(KeyValuePair`2<int, CharacterMetrics> item);
    public sealed virtual void Clear();
    [CLSCompliantAttribute("False")]
public sealed virtual bool Contains(KeyValuePair`2<int, CharacterMetrics> item);
    [CLSCompliantAttribute("False")]
public sealed virtual void CopyTo(KeyValuePair`2[] array, int index);
    [CLSCompliantAttribute("False")]
public sealed virtual bool Remove(KeyValuePair`2<int, CharacterMetrics> item);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public sealed virtual void Add(int key, CharacterMetrics value);
    public sealed virtual bool ContainsKey(int key);
    public sealed virtual bool Remove(int key);
    public sealed virtual CharacterMetrics get_Item(int key);
    public sealed virtual void set_Item(int key, CharacterMetrics value);
    public sealed virtual ICollection`1<int> get_Keys();
    public sealed virtual ICollection`1<CharacterMetrics> get_Values();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    internal CharacterMetrics[] GetPage(int i);
    private CharacterMetrics[] GetPageFromUnicodeScalar(int unicodeScalar);
    private void SetValue(int key, CharacterMetrics value, bool failIfExists);
    internal CharacterMetrics GetValue(int key);
    private bool RemoveValue(int key, CharacterMetrics value);
    private CharacterMetrics GetNextValue(Int32& unicodeScalar);
    private int CountValues();
    private Int32[] GetKeys();
    private CharacterMetrics[] GetValues();
    internal static int ConvertKey(object key);
    private CharacterMetrics ConvertValue(object value);
}
public enum System.Windows.Media.ClearTypeHint : Enum {
    public int value__;
    public static ClearTypeHint Auto;
    public static ClearTypeHint Enabled;
}
[LocalizabilityAttribute("0")]
[TypeConverterAttribute("System.Windows.Media.ColorConverter")]
public class System.Windows.Media.Color : ValueType {
    private ColorContext context;
    private MILColorF scRgbColor;
    private MILColor sRgbColor;
    private Single[] nativeColorValue;
    private bool isFromScRgb;
    private static string c_scRgbFormat;
    public ColorContext ColorContext { get; }
    public byte A { get; public set; }
    public byte R { get; public set; }
    public byte G { get; public set; }
    public byte B { get; public set; }
    public float ScA { get; public set; }
    public float ScR { get; public set; }
    public float ScG { get; public set; }
    public float ScB { get; public set; }
    private static Color FromProfile(Uri profileUri);
    public static Color FromAValues(float a, Single[] values, Uri profileUri);
    public static Color FromValues(Single[] values, Uri profileUri);
    internal static Color FromUInt32(UInt32 argb);
    public static Color FromScRgb(float a, float r, float g, float b);
    public static Color FromArgb(byte a, byte r, byte g, byte b);
    public static Color FromRgb(byte r, byte g, byte b);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
    public static bool AreClose(Color color1, Color color2);
    private bool IsClose(Color color);
    public void Clamp();
    public Single[] GetNativeColorValues();
    public static Color op_Addition(Color color1, Color color2);
    public static Color Add(Color color1, Color color2);
    public static Color op_Subtraction(Color color1, Color color2);
    public static Color Subtract(Color color1, Color color2);
    public static Color op_Multiply(Color color, float coefficient);
    public static Color Multiply(Color color, float coefficient);
    public static bool Equals(Color color1, Color color2);
    public sealed virtual bool Equals(Color color);
    public virtual bool Equals(object o);
    public static bool op_Equality(Color color1, Color color2);
    public static bool op_Inequality(Color color1, Color color2);
    public ColorContext get_ColorContext();
    public byte get_A();
    public void set_A(byte value);
    public byte get_R();
    public void set_R(byte value);
    public byte get_G();
    public void set_G(byte value);
    public byte get_B();
    public void set_B(byte value);
    public float get_ScA();
    public void set_ScA(float value);
    public float get_ScR();
    public void set_ScR(float value);
    public float get_ScG();
    public void set_ScG(float value);
    public float get_ScB();
    public void set_ScB(float value);
    private static float sRgbToScRgb(byte bval);
    private static byte ScRgbTosRgb(float val);
    private void ComputeScRgbValues();
    private void ComputeNativeValues(int numChannels);
}
public class System.Windows.Media.ColorContext : object {
    private ColorContextHelper _colorContextHelper;
    private StandardColorSpace _colorSpaceFamily;
    private int _numChannels;
    private SecurityCriticalData`1<Uri> _profileUri;
    private SecurityCriticalDataForSet`1<bool> _isProfileUriNotFromUser;
    private AbbreviatedPROFILEHEADER _profileHeader;
    private SafeMILHandle _colorContextHandle;
    private static int _bufferSizeIncrement;
    private static int _maximumColorContextLength;
    private static COLORTYPE[] _colorTypeFromChannels;
    private static string _colorProfileResources;
    private static string _sRGBProfileName;
    public Uri ProfileUri { get; }
    internal SafeProfileHandle ProfileHandle { get; }
    internal SafeMILHandle ColorContextHandle { get; }
    internal int NumChannels { get; }
    internal UInt32 ColorType { get; }
    internal StandardColorSpace ColorSpaceFamily { get; }
    internal bool IsValid { get; }
    private ColorContext(SafeMILHandle colorContextHandle);
    public ColorContext(Uri profileUri);
    public ColorContext(PixelFormat pixelFormat);
    private static ColorContext();
    public Stream OpenProfileStream();
    public Uri get_ProfileUri();
    internal SafeProfileHandle get_ProfileHandle();
    internal SafeMILHandle get_ColorContextHandle();
    internal int get_NumChannels();
    internal UInt32 get_ColorType();
    internal StandardColorSpace get_ColorSpaceFamily();
    internal bool get_IsValid();
    internal static IList`1<ColorContext> GetColorContextsHelper(GetColorContextsDelegate getColorContexts);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ColorContext context1, ColorContext context2);
    public static bool op_Inequality(ColorContext context1, ColorContext context2);
    private void Initialize(Uri profileUri, bool isStandardProfileUriNotFromUser);
    private static Uri GetStandardColorSpaceProfile();
    private void FromStream(Stream stm, string filename);
    private void FromRawBytes(Byte[] data, int dataLength, bool dontThrowException);
}
internal class System.Windows.Media.ColorContextHelper : ValueType {
    private SafeProfileHandle _profileHandle;
    internal bool IsInvalid { get; }
    internal SafeProfileHandle ProfileHandle { get; }
    internal void OpenColorProfile(PROFILE& profile);
    internal bool GetColorProfileHeader(PROFILEHEADER& header);
    internal void GetColorProfileFromHandle(Byte[] buffer, UInt32& bufferSize);
    internal bool get_IsInvalid();
    internal SafeProfileHandle get_ProfileHandle();
}
public class System.Windows.Media.ColorConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext td, Type t);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public static object ConvertFromString(string value);
    public virtual object ConvertFrom(ITypeDescriptorContext td, CultureInfo ci, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public enum System.Windows.Media.ColorInterpolationMode : Enum {
    public int value__;
    public static ColorInterpolationMode ScRgbLinearInterpolation;
    public static ColorInterpolationMode SRgbLinearInterpolation;
}
public class System.Windows.Media.Colors : object {
    public static Color AliceBlue { get; }
    public static Color AntiqueWhite { get; }
    public static Color Aqua { get; }
    public static Color Aquamarine { get; }
    public static Color Azure { get; }
    public static Color Beige { get; }
    public static Color Bisque { get; }
    public static Color Black { get; }
    public static Color BlanchedAlmond { get; }
    public static Color Blue { get; }
    public static Color BlueViolet { get; }
    public static Color Brown { get; }
    public static Color BurlyWood { get; }
    public static Color CadetBlue { get; }
    public static Color Chartreuse { get; }
    public static Color Chocolate { get; }
    public static Color Coral { get; }
    public static Color CornflowerBlue { get; }
    public static Color Cornsilk { get; }
    public static Color Crimson { get; }
    public static Color Cyan { get; }
    public static Color DarkBlue { get; }
    public static Color DarkCyan { get; }
    public static Color DarkGoldenrod { get; }
    public static Color DarkGray { get; }
    public static Color DarkGreen { get; }
    public static Color DarkKhaki { get; }
    public static Color DarkMagenta { get; }
    public static Color DarkOliveGreen { get; }
    public static Color DarkOrange { get; }
    public static Color DarkOrchid { get; }
    public static Color DarkRed { get; }
    public static Color DarkSalmon { get; }
    public static Color DarkSeaGreen { get; }
    public static Color DarkSlateBlue { get; }
    public static Color DarkSlateGray { get; }
    public static Color DarkTurquoise { get; }
    public static Color DarkViolet { get; }
    public static Color DeepPink { get; }
    public static Color DeepSkyBlue { get; }
    public static Color DimGray { get; }
    public static Color DodgerBlue { get; }
    public static Color Firebrick { get; }
    public static Color FloralWhite { get; }
    public static Color ForestGreen { get; }
    public static Color Fuchsia { get; }
    public static Color Gainsboro { get; }
    public static Color GhostWhite { get; }
    public static Color Gold { get; }
    public static Color Goldenrod { get; }
    public static Color Gray { get; }
    public static Color Green { get; }
    public static Color GreenYellow { get; }
    public static Color Honeydew { get; }
    public static Color HotPink { get; }
    public static Color IndianRed { get; }
    public static Color Indigo { get; }
    public static Color Ivory { get; }
    public static Color Khaki { get; }
    public static Color Lavender { get; }
    public static Color LavenderBlush { get; }
    public static Color LawnGreen { get; }
    public static Color LemonChiffon { get; }
    public static Color LightBlue { get; }
    public static Color LightCoral { get; }
    public static Color LightCyan { get; }
    public static Color LightGoldenrodYellow { get; }
    public static Color LightGray { get; }
    public static Color LightGreen { get; }
    public static Color LightPink { get; }
    public static Color LightSalmon { get; }
    public static Color LightSeaGreen { get; }
    public static Color LightSkyBlue { get; }
    public static Color LightSlateGray { get; }
    public static Color LightSteelBlue { get; }
    public static Color LightYellow { get; }
    public static Color Lime { get; }
    public static Color LimeGreen { get; }
    public static Color Linen { get; }
    public static Color Magenta { get; }
    public static Color Maroon { get; }
    public static Color MediumAquamarine { get; }
    public static Color MediumBlue { get; }
    public static Color MediumOrchid { get; }
    public static Color MediumPurple { get; }
    public static Color MediumSeaGreen { get; }
    public static Color MediumSlateBlue { get; }
    public static Color MediumSpringGreen { get; }
    public static Color MediumTurquoise { get; }
    public static Color MediumVioletRed { get; }
    public static Color MidnightBlue { get; }
    public static Color MintCream { get; }
    public static Color MistyRose { get; }
    public static Color Moccasin { get; }
    public static Color NavajoWhite { get; }
    public static Color Navy { get; }
    public static Color OldLace { get; }
    public static Color Olive { get; }
    public static Color OliveDrab { get; }
    public static Color Orange { get; }
    public static Color OrangeRed { get; }
    public static Color Orchid { get; }
    public static Color PaleGoldenrod { get; }
    public static Color PaleGreen { get; }
    public static Color PaleTurquoise { get; }
    public static Color PaleVioletRed { get; }
    public static Color PapayaWhip { get; }
    public static Color PeachPuff { get; }
    public static Color Peru { get; }
    public static Color Pink { get; }
    public static Color Plum { get; }
    public static Color PowderBlue { get; }
    public static Color Purple { get; }
    public static Color Red { get; }
    public static Color RosyBrown { get; }
    public static Color RoyalBlue { get; }
    public static Color SaddleBrown { get; }
    public static Color Salmon { get; }
    public static Color SandyBrown { get; }
    public static Color SeaGreen { get; }
    public static Color SeaShell { get; }
    public static Color Sienna { get; }
    public static Color Silver { get; }
    public static Color SkyBlue { get; }
    public static Color SlateBlue { get; }
    public static Color SlateGray { get; }
    public static Color Snow { get; }
    public static Color SpringGreen { get; }
    public static Color SteelBlue { get; }
    public static Color Tan { get; }
    public static Color Teal { get; }
    public static Color Thistle { get; }
    public static Color Tomato { get; }
    public static Color Transparent { get; }
    public static Color Turquoise { get; }
    public static Color Violet { get; }
    public static Color Wheat { get; }
    public static Color White { get; }
    public static Color WhiteSmoke { get; }
    public static Color Yellow { get; }
    public static Color YellowGreen { get; }
    public static Color get_AliceBlue();
    public static Color get_AntiqueWhite();
    public static Color get_Aqua();
    public static Color get_Aquamarine();
    public static Color get_Azure();
    public static Color get_Beige();
    public static Color get_Bisque();
    public static Color get_Black();
    public static Color get_BlanchedAlmond();
    public static Color get_Blue();
    public static Color get_BlueViolet();
    public static Color get_Brown();
    public static Color get_BurlyWood();
    public static Color get_CadetBlue();
    public static Color get_Chartreuse();
    public static Color get_Chocolate();
    public static Color get_Coral();
    public static Color get_CornflowerBlue();
    public static Color get_Cornsilk();
    public static Color get_Crimson();
    public static Color get_Cyan();
    public static Color get_DarkBlue();
    public static Color get_DarkCyan();
    public static Color get_DarkGoldenrod();
    public static Color get_DarkGray();
    public static Color get_DarkGreen();
    public static Color get_DarkKhaki();
    public static Color get_DarkMagenta();
    public static Color get_DarkOliveGreen();
    public static Color get_DarkOrange();
    public static Color get_DarkOrchid();
    public static Color get_DarkRed();
    public static Color get_DarkSalmon();
    public static Color get_DarkSeaGreen();
    public static Color get_DarkSlateBlue();
    public static Color get_DarkSlateGray();
    public static Color get_DarkTurquoise();
    public static Color get_DarkViolet();
    public static Color get_DeepPink();
    public static Color get_DeepSkyBlue();
    public static Color get_DimGray();
    public static Color get_DodgerBlue();
    public static Color get_Firebrick();
    public static Color get_FloralWhite();
    public static Color get_ForestGreen();
    public static Color get_Fuchsia();
    public static Color get_Gainsboro();
    public static Color get_GhostWhite();
    public static Color get_Gold();
    public static Color get_Goldenrod();
    public static Color get_Gray();
    public static Color get_Green();
    public static Color get_GreenYellow();
    public static Color get_Honeydew();
    public static Color get_HotPink();
    public static Color get_IndianRed();
    public static Color get_Indigo();
    public static Color get_Ivory();
    public static Color get_Khaki();
    public static Color get_Lavender();
    public static Color get_LavenderBlush();
    public static Color get_LawnGreen();
    public static Color get_LemonChiffon();
    public static Color get_LightBlue();
    public static Color get_LightCoral();
    public static Color get_LightCyan();
    public static Color get_LightGoldenrodYellow();
    public static Color get_LightGray();
    public static Color get_LightGreen();
    public static Color get_LightPink();
    public static Color get_LightSalmon();
    public static Color get_LightSeaGreen();
    public static Color get_LightSkyBlue();
    public static Color get_LightSlateGray();
    public static Color get_LightSteelBlue();
    public static Color get_LightYellow();
    public static Color get_Lime();
    public static Color get_LimeGreen();
    public static Color get_Linen();
    public static Color get_Magenta();
    public static Color get_Maroon();
    public static Color get_MediumAquamarine();
    public static Color get_MediumBlue();
    public static Color get_MediumOrchid();
    public static Color get_MediumPurple();
    public static Color get_MediumSeaGreen();
    public static Color get_MediumSlateBlue();
    public static Color get_MediumSpringGreen();
    public static Color get_MediumTurquoise();
    public static Color get_MediumVioletRed();
    public static Color get_MidnightBlue();
    public static Color get_MintCream();
    public static Color get_MistyRose();
    public static Color get_Moccasin();
    public static Color get_NavajoWhite();
    public static Color get_Navy();
    public static Color get_OldLace();
    public static Color get_Olive();
    public static Color get_OliveDrab();
    public static Color get_Orange();
    public static Color get_OrangeRed();
    public static Color get_Orchid();
    public static Color get_PaleGoldenrod();
    public static Color get_PaleGreen();
    public static Color get_PaleTurquoise();
    public static Color get_PaleVioletRed();
    public static Color get_PapayaWhip();
    public static Color get_PeachPuff();
    public static Color get_Peru();
    public static Color get_Pink();
    public static Color get_Plum();
    public static Color get_PowderBlue();
    public static Color get_Purple();
    public static Color get_Red();
    public static Color get_RosyBrown();
    public static Color get_RoyalBlue();
    public static Color get_SaddleBrown();
    public static Color get_Salmon();
    public static Color get_SandyBrown();
    public static Color get_SeaGreen();
    public static Color get_SeaShell();
    public static Color get_Sienna();
    public static Color get_Silver();
    public static Color get_SkyBlue();
    public static Color get_SlateBlue();
    public static Color get_SlateGray();
    public static Color get_Snow();
    public static Color get_SpringGreen();
    public static Color get_SteelBlue();
    public static Color get_Tan();
    public static Color get_Teal();
    public static Color get_Thistle();
    public static Color get_Tomato();
    public static Color get_Transparent();
    public static Color get_Turquoise();
    public static Color get_Violet();
    public static Color get_Wheat();
    public static Color get_White();
    public static Color get_WhiteSmoke();
    public static Color get_Yellow();
    public static Color get_YellowGreen();
}
internal class System.Windows.Media.ColorTransform : object {
    private ColorTransformHelper _colorTransformHelper;
    private UInt32 _inputColorType;
    private UInt32 _outputColorType;
    internal ColorTransform(ColorContext srcContext, ColorContext dstContext);
    internal ColorTransform(SafeMILHandle bitmapSource, ColorContext srcContext, ColorContext dstContext, PixelFormat pixelFormat);
    internal void Translate(Single[] srcValue, Single[] dstValue);
    private void InitializeICM();
    private long ICM2Color(Single[] srcValue);
}
internal class System.Windows.Media.ColorTransformHandle : SafeHandleZeroOrMinusOneIsInvalid {
    internal ColorTransformHandle(IntPtr profile);
    protected virtual bool ReleaseHandle();
}
internal class System.Windows.Media.ColorTransformHelper : object {
    private ColorTransformHandle _transformHandle;
    private static UInt32 INTENT_PERCEPTUAL;
    private static UInt32 INTENT_RELATIVE_COLORIMETRIC;
    private static UInt32 INTENT_SATURATION;
    private static UInt32 INTENT_ABSOLUTE_COLORIMETRIC;
    private static UInt32 PROOF_MODE;
    private static UInt32 NORMAL_MODE;
    private static UInt32 BEST_MODE;
    private static UInt32 ENABLE_GAMUT_CHECKING;
    private static UInt32 USE_RELATIVE_COLORIMETRIC;
    private static UInt32 FAST_TRANSLATE;
    internal void CreateTransform(SafeProfileHandle sourceProfile, SafeProfileHandle destinationProfile);
    internal void TranslateColors(IntPtr paInputColors, UInt32 numColors, UInt32 inputColorType, IntPtr paOutputColors, UInt32 outputColorType);
}
public class System.Windows.Media.CombinedGeometry : Geometry {
    public static DependencyProperty GeometryCombineModeProperty;
    public static DependencyProperty Geometry1Property;
    public static DependencyProperty Geometry2Property;
    internal MultiChannelResource _duceResource;
    internal static GeometryCombineMode c_GeometryCombineMode;
    internal static Geometry s_Geometry1;
    internal static Geometry s_Geometry2;
    public Rect Bounds { get; }
    public GeometryCombineMode GeometryCombineMode { get; public set; }
    public Geometry Geometry1 { get; public set; }
    public Geometry Geometry2 { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    public CombinedGeometry(Geometry geometry1, Geometry geometry2);
    public CombinedGeometry(GeometryCombineMode geometryCombineMode, Geometry geometry1, Geometry geometry2);
    public CombinedGeometry(GeometryCombineMode geometryCombineMode, Geometry geometry1, Geometry geometry2, Transform transform);
    private static CombinedGeometry();
    public virtual Rect get_Bounds();
    internal virtual Rect GetBoundsInternal(Pen pen, Matrix matrix, double tolerance, ToleranceType type);
    internal virtual bool ContainsInternal(Pen pen, Point hitPoint, double tolerance, ToleranceType type);
    public virtual double GetArea(double tolerance, ToleranceType type);
    internal virtual PathFigureCollection GetTransformedFigureCollection(Transform transform);
    internal virtual PathGeometryData GetPathGeometryData();
    internal virtual PathGeometry GetAsPathGeometry();
    public virtual bool IsEmpty();
    internal virtual bool IsObviouslyEmpty();
    public virtual bool MayHaveCurves();
    public CombinedGeometry Clone();
    public CombinedGeometry CloneCurrentValue();
    private static void GeometryCombineModePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void Geometry1PropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void Geometry2PropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public GeometryCombineMode get_GeometryCombineMode();
    public void set_GeometryCombineMode(GeometryCombineMode value);
    public Geometry get_Geometry1();
    public void set_Geometry1(Geometry value);
    public Geometry get_Geometry2();
    public void set_Geometry2(Geometry value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    internal virtual int get_EffectiveValuesInitialSize();
}
internal enum System.Windows.Media.Composition.ChannelMarshalType : Enum {
    public int value__;
    public static ChannelMarshalType ChannelMarshalTypeInvalid;
    public static ChannelMarshalType ChannelMarshalTypeSameThread;
    public static ChannelMarshalType ChannelMarshalTypeCrossThread;
}
internal class System.Windows.Media.Composition.CompositionEngineLock : ValueType {
    internal static CompositionEngineLock Acquire();
    public sealed virtual void Dispose();
}
internal static class System.Windows.Media.Composition.CompositionResourceManager : object {
    public static int InvalidResourceHandle;
    internal static MilColorF ColorToMilColorF(Color c);
    internal static D3DMATRIX Matrix3DToD3DMATRIX(Matrix3D m);
    internal static MilPoint3F Point3DToMilPoint3F(Point3D p);
    internal static MilPoint3F Vector3DToMilPoint3F(Vector3D v);
    internal static MilQuaternionF QuaternionToMilQuaternionF(Quaternion q);
    internal static MilMatrix4x4D MatrixToMilMatrix4x4D(Matrix m);
    internal static MilMatrix3x2D TransformToMilMatrix3x2D(Transform t);
    internal static MilMatrix3x2D MatrixToMilMatrix3x2D(Matrix m);
    internal static MilMatrix3x2D MatrixToMilMatrix3x2D(Matrix& m);
    internal static Matrix MilMatrix3x2DToMatrix(MilMatrix3x2D& m);
    internal static UInt32 BooleanToUInt32(bool v);
}
internal class System.Windows.Media.Composition.D3DMATRIX : ValueType {
    internal float _11;
    internal float _12;
    internal float _13;
    internal float _14;
    internal float _21;
    internal float _22;
    internal float _23;
    internal float _24;
    internal float _31;
    internal float _32;
    internal float _33;
    internal float _34;
    internal float _41;
    internal float _42;
    internal float _43;
    internal float _44;
    internal D3DMATRIX(float m11, float m12, float m13, float m14, float m21, float m22, float m23, float m24, float m31, float m32, float m33, float m34, float m41, float m42, float m43, float m44);
}
internal class System.Windows.Media.Composition.DUCE : object {
    internal static UInt32 waitInfinite;
    internal static void CopyBytes(Byte* pbTo, Byte* pbFrom, int cbData);
    internal static void NotifyPolicyChangeForNonInteractiveMode(bool forceRender, Channel channel);
}
internal class System.Windows.Media.Composition.MIL_PATHFIGURE : ValueType {
    internal UInt32 BackSize;
    internal MilPathFigureFlags Flags;
    internal UInt32 Count;
    internal UInt32 Size;
    internal Point StartPoint;
    internal UInt32 OffsetToLastSegment;
    internal UInt32 ForcePacking;
}
internal class System.Windows.Media.Composition.MIL_PATHGEOMETRY : ValueType {
    internal UInt32 Size;
    internal MilPathGeometryFlags Flags;
    internal MilRectD Bounds;
    internal UInt32 FigureCount;
    internal UInt32 ForcePacking;
}
internal enum System.Windows.Media.Composition.MIL_PEN_CAP : Enum {
    public int value__;
    public static MIL_PEN_CAP MilPenCapFlat;
    public static MIL_PEN_CAP MilPenCapSquare;
    public static MIL_PEN_CAP MilPenCapRound;
    public static MIL_PEN_CAP MilPenCapTriangle;
    public static MIL_PEN_CAP MIL_PEN_CAP_FORCE_DWORD;
}
internal class System.Windows.Media.Composition.MIL_PEN_DATA : ValueType {
    internal double Thickness;
    internal double MiterLimit;
    internal double DashOffset;
    internal MIL_PEN_CAP StartLineCap;
    internal MIL_PEN_CAP EndLineCap;
    internal MIL_PEN_CAP DashCap;
    internal MIL_PEN_JOIN LineJoin;
    internal UInt32 DashArraySize;
}
internal enum System.Windows.Media.Composition.MIL_PEN_JOIN : Enum {
    public int value__;
    public static MIL_PEN_JOIN MilPenJoinMiter;
    public static MIL_PEN_JOIN MilPenJoinBevel;
    public static MIL_PEN_JOIN MilPenJoinRound;
    public static MIL_PEN_JOIN MIL_PEN_JOIN_FORCE_DWORD;
}
internal enum System.Windows.Media.Composition.MIL_PRESENTATION_RESULTS : Enum {
    public int value__;
    public static MIL_PRESENTATION_RESULTS MIL_PRESENTATION_VSYNC;
    public static MIL_PRESENTATION_RESULTS MIL_PRESENTATION_NOPRESENT;
    public static MIL_PRESENTATION_RESULTS MIL_PRESENTATION_VSYNC_UNSUPPORTED;
    public static MIL_PRESENTATION_RESULTS MIL_PRESENTATION_DWM;
    public static MIL_PRESENTATION_RESULTS MIL_PRESENTATION_FORCE_DWORD;
}
internal class System.Windows.Media.Composition.MIL_SEGMENT : ValueType {
    internal MIL_SEGMENT_TYPE Type;
    internal MILCoreSegFlags Flags;
    internal UInt32 BackSize;
}
internal class System.Windows.Media.Composition.MIL_SEGMENT_ARC : ValueType {
    internal MIL_SEGMENT_TYPE Type;
    internal MILCoreSegFlags Flags;
    internal UInt32 BackSize;
    internal UInt32 LargeArc;
    internal Point Point;
    internal Size Size;
    internal double XRotation;
    internal UInt32 Sweep;
    internal UInt32 ForcePacking;
}
internal class System.Windows.Media.Composition.MIL_SEGMENT_BEZIER : ValueType {
    internal MIL_SEGMENT_TYPE Type;
    internal MILCoreSegFlags Flags;
    internal UInt32 BackSize;
    internal UInt32 ForcePacking;
    internal Point Point1;
    internal Point Point2;
    internal Point Point3;
}
internal class System.Windows.Media.Composition.MIL_SEGMENT_LINE : ValueType {
    internal MIL_SEGMENT_TYPE Type;
    internal MILCoreSegFlags Flags;
    internal UInt32 BackSize;
    internal UInt32 ForcePacking;
    internal Point Point;
}
internal class System.Windows.Media.Composition.MIL_SEGMENT_POLY : ValueType {
    internal MIL_SEGMENT_TYPE Type;
    internal MILCoreSegFlags Flags;
    internal UInt32 BackSize;
    internal UInt32 Count;
}
internal class System.Windows.Media.Composition.MIL_SEGMENT_QUADRATICBEZIER : ValueType {
    internal MIL_SEGMENT_TYPE Type;
    internal MILCoreSegFlags Flags;
    internal UInt32 BackSize;
    internal UInt32 ForcePacking;
    internal Point Point1;
    internal Point Point2;
}
internal enum System.Windows.Media.Composition.MIL_SEGMENT_TYPE : Enum {
    public int value__;
    public static MIL_SEGMENT_TYPE MilSegmentNone;
    public static MIL_SEGMENT_TYPE MilSegmentLine;
    public static MIL_SEGMENT_TYPE MilSegmentBezier;
    public static MIL_SEGMENT_TYPE MilSegmentQuadraticBezier;
    public static MIL_SEGMENT_TYPE MilSegmentArc;
    public static MIL_SEGMENT_TYPE MilSegmentPolyLine;
    public static MIL_SEGMENT_TYPE MilSegmentPolyBezier;
    public static MIL_SEGMENT_TYPE MilSegmentPolyQuadraticBezier;
    public static MIL_SEGMENT_TYPE MIL_SEGMENT_TYPE_FORCE_DWORD;
}
internal enum System.Windows.Media.Composition.MilBrushMappingMode : Enum {
    public int value__;
    public static MilBrushMappingMode Absolute;
    public static MilBrushMappingMode RelativeToBoundingBox;
    public static MilBrushMappingMode FORCE_DWORD;
}
internal enum System.Windows.Media.Composition.MILCMD : Enum {
    public int value__;
    public static MILCMD MilCmdInvalid;
    public static MILCMD MilCmdTransportSyncFlush;
    public static MILCMD MilCmdTransportDestroyResourcesOnChannel;
    public static MILCMD MilCmdPartitionRegisterForNotifications;
    public static MILCMD MilCmdChannelRequestTier;
    public static MILCMD MilCmdPartitionSetVBlankSyncMode;
    public static MILCMD MilCmdPartitionNotifyPresent;
    public static MILCMD MilCmdChannelCreateResource;
    public static MILCMD MilCmdChannelDeleteResource;
    public static MILCMD MilCmdChannelDuplicateHandle;
    public static MILCMD MilCmdD3DImage;
    public static MILCMD MilCmdD3DImagePresent;
    public static MILCMD MilCmdBitmapSource;
    public static MILCMD MilCmdBitmapInvalidate;
    public static MILCMD MilCmdDoubleResource;
    public static MILCMD MilCmdColorResource;
    public static MILCMD MilCmdPointResource;
    public static MILCMD MilCmdRectResource;
    public static MILCMD MilCmdSizeResource;
    public static MILCMD MilCmdMatrixResource;
    public static MILCMD MilCmdPoint3DResource;
    public static MILCMD MilCmdVector3DResource;
    public static MILCMD MilCmdQuaternionResource;
    public static MILCMD MilCmdMediaPlayer;
    public static MILCMD MilCmdRenderData;
    public static MILCMD MilCmdEtwEventResource;
    public static MILCMD MilCmdVisualCreate;
    public static MILCMD MilCmdVisualSetOffset;
    public static MILCMD MilCmdVisualSetTransform;
    public static MILCMD MilCmdVisualSetEffect;
    public static MILCMD MilCmdVisualSetCacheMode;
    public static MILCMD MilCmdVisualSetClip;
    public static MILCMD MilCmdVisualSetAlpha;
    public static MILCMD MilCmdVisualSetRenderOptions;
    public static MILCMD MilCmdVisualSetContent;
    public static MILCMD MilCmdVisualSetAlphaMask;
    public static MILCMD MilCmdVisualRemoveAllChildren;
    public static MILCMD MilCmdVisualRemoveChild;
    public static MILCMD MilCmdVisualInsertChildAt;
    public static MILCMD MilCmdVisualSetGuidelineCollection;
    public static MILCMD MilCmdVisualSetScrollableAreaClip;
    public static MILCMD MilCmdViewport3DVisualSetCamera;
    public static MILCMD MilCmdViewport3DVisualSetViewport;
    public static MILCMD MilCmdViewport3DVisualSet3DChild;
    public static MILCMD MilCmdVisual3DSetContent;
    public static MILCMD MilCmdVisual3DSetTransform;
    public static MILCMD MilCmdVisual3DRemoveAllChildren;
    public static MILCMD MilCmdVisual3DRemoveChild;
    public static MILCMD MilCmdVisual3DInsertChildAt;
    public static MILCMD MilCmdHwndTargetCreate;
    public static MILCMD MilCmdHwndTargetSuppressLayered;
    public static MILCMD MilCmdTargetUpdateWindowSettings;
    public static MILCMD MilCmdGenericTargetCreate;
    public static MILCMD MilCmdTargetSetRoot;
    public static MILCMD MilCmdTargetSetClearColor;
    public static MILCMD MilCmdTargetInvalidate;
    public static MILCMD MilCmdTargetSetFlags;
    public static MILCMD MilCmdHwndTargetDpiChanged;
    public static MILCMD MilCmdGlyphRunCreate;
    public static MILCMD MilCmdDoubleBufferedBitmap;
    public static MILCMD MilCmdDoubleBufferedBitmapCopyForward;
    public static MILCMD MilCmdPartitionNotifyPolicyChangeForNonInteractiveMode;
    public static MILCMD MilDrawLine;
    public static MILCMD MilDrawLineAnimate;
    public static MILCMD MilDrawRectangle;
    public static MILCMD MilDrawRectangleAnimate;
    public static MILCMD MilDrawRoundedRectangle;
    public static MILCMD MilDrawRoundedRectangleAnimate;
    public static MILCMD MilDrawEllipse;
    public static MILCMD MilDrawEllipseAnimate;
    public static MILCMD MilDrawGeometry;
    public static MILCMD MilDrawImage;
    public static MILCMD MilDrawImageAnimate;
    public static MILCMD MilDrawGlyphRun;
    public static MILCMD MilDrawDrawing;
    public static MILCMD MilDrawVideo;
    public static MILCMD MilDrawVideoAnimate;
    public static MILCMD MilPushClip;
    public static MILCMD MilPushOpacityMask;
    public static MILCMD MilPushOpacity;
    public static MILCMD MilPushOpacityAnimate;
    public static MILCMD MilPushTransform;
    public static MILCMD MilPushGuidelineSet;
    public static MILCMD MilPushGuidelineY1;
    public static MILCMD MilPushGuidelineY2;
    public static MILCMD MilPushEffect;
    public static MILCMD MilPop;
    public static MILCMD MilCmdAxisAngleRotation3D;
    public static MILCMD MilCmdQuaternionRotation3D;
    public static MILCMD MilCmdPerspectiveCamera;
    public static MILCMD MilCmdOrthographicCamera;
    public static MILCMD MilCmdMatrixCamera;
    public static MILCMD MilCmdModel3DGroup;
    public static MILCMD MilCmdAmbientLight;
    public static MILCMD MilCmdDirectionalLight;
    public static MILCMD MilCmdPointLight;
    public static MILCMD MilCmdSpotLight;
    public static MILCMD MilCmdGeometryModel3D;
    public static MILCMD MilCmdMeshGeometry3D;
    public static MILCMD MilCmdMaterialGroup;
    public static MILCMD MilCmdDiffuseMaterial;
    public static MILCMD MilCmdSpecularMaterial;
    public static MILCMD MilCmdEmissiveMaterial;
    public static MILCMD MilCmdTransform3DGroup;
    public static MILCMD MilCmdTranslateTransform3D;
    public static MILCMD MilCmdScaleTransform3D;
    public static MILCMD MilCmdRotateTransform3D;
    public static MILCMD MilCmdMatrixTransform3D;
    public static MILCMD MilCmdPixelShader;
    public static MILCMD MilCmdImplicitInputBrush;
    public static MILCMD MilCmdBlurEffect;
    public static MILCMD MilCmdDropShadowEffect;
    public static MILCMD MilCmdShaderEffect;
    public static MILCMD MilCmdDrawingImage;
    public static MILCMD MilCmdTransformGroup;
    public static MILCMD MilCmdTranslateTransform;
    public static MILCMD MilCmdScaleTransform;
    public static MILCMD MilCmdSkewTransform;
    public static MILCMD MilCmdRotateTransform;
    public static MILCMD MilCmdMatrixTransform;
    public static MILCMD MilCmdLineGeometry;
    public static MILCMD MilCmdRectangleGeometry;
    public static MILCMD MilCmdEllipseGeometry;
    public static MILCMD MilCmdGeometryGroup;
    public static MILCMD MilCmdCombinedGeometry;
    public static MILCMD MilCmdPathGeometry;
    public static MILCMD MilCmdSolidColorBrush;
    public static MILCMD MilCmdLinearGradientBrush;
    public static MILCMD MilCmdRadialGradientBrush;
    public static MILCMD MilCmdImageBrush;
    public static MILCMD MilCmdDrawingBrush;
    public static MILCMD MilCmdVisualBrush;
    public static MILCMD MilCmdBitmapCacheBrush;
    public static MILCMD MilCmdDashStyle;
    public static MILCMD MilCmdPen;
    public static MILCMD MilCmdGeometryDrawing;
    public static MILCMD MilCmdGlyphRunDrawing;
    public static MILCMD MilCmdImageDrawing;
    public static MILCMD MilCmdVideoDrawing;
    public static MILCMD MilCmdDrawingGroup;
    public static MILCMD MilCmdGuidelineSet;
    public static MILCMD MilCmdBitmapCache;
}
internal class System.Windows.Media.Composition.MilColorF : ValueType {
    internal float r;
    internal float g;
    internal float b;
    internal float a;
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
internal class System.Windows.Media.Composition.MilColorI : ValueType {
    internal int r;
    internal int g;
    internal int b;
    internal int a;
}
internal enum System.Windows.Media.Composition.MilCompositingMode : Enum {
    public int value__;
    public static MilCompositingMode SourceOver;
    public static MilCompositingMode SourceCopy;
    public static MilCompositingMode SourceAdd;
    public static MilCompositingMode SourceAlphaMultiply;
    public static MilCompositingMode SourceInverseAlphaMultiply;
    public static MilCompositingMode SourceUnder;
    public static MilCompositingMode SourceOverNonPremultiplied;
    public static MilCompositingMode SourceInverseAlphaOverNonPremultiplied;
    public static MilCompositingMode DestInvert;
    public static MilCompositingMode Last;
    public static MilCompositingMode FORCE_DWORD;
}
internal static class System.Windows.Media.Composition.MilCoreApi : object {
    internal static int MilComposition_SyncFlush(IntPtr pChannel);
    internal static int MilUtility_GetPointAtLengthFraction(MilMatrix3x2D* pMatrix, FillRule fillRule, Byte* pPathData, UInt32 nSize, double rFraction, Point& pt, Point& vecTangent);
    internal static int MilUtility_PolygonBounds(MilMatrix3x2D* pWorldMatrix, MIL_PEN_DATA* pPenData, Double* pDashArray, Point* pPoints, Byte* pTypes, UInt32 pointCount, UInt32 segmentCount, MilMatrix3x2D* pGeometryMatrix, double rTolerance, bool fRelative, bool fSkipHollows, Rect* pBounds);
    internal static int MilUtility_PolygonHitTest(MilMatrix3x2D* pGeometryMatrix, MIL_PEN_DATA* pPenData, Double* pDashArray, Point* pPoints, Byte* pTypes, UInt32 cPoints, UInt32 cSegments, double rTolerance, bool fRelative, Point* pHitPoint, Boolean& pDoesContain);
    internal static int MilUtility_PathGeometryHitTest(MilMatrix3x2D* pMatrix, MIL_PEN_DATA* pPenData, Double* pDashArray, FillRule fillRule, Byte* pPathData, UInt32 nSize, double rTolerance, bool fRelative, Point* pHitPoint, Boolean& pDoesContain);
    internal static int MilUtility_PathGeometryHitTestPathGeometry(MilMatrix3x2D* pMatrix1, FillRule fillRule1, Byte* pPathData1, UInt32 nSize1, MilMatrix3x2D* pMatrix2, FillRule fillRule2, Byte* pPathData2, UInt32 nSize2, double rTolerance, bool fRelative, IntersectionDetail* pDetail);
    internal static int MilUtility_GeometryGetArea(FillRule fillRule, Byte* pPathData, UInt32 nSize, MilMatrix3x2D* pMatrix, double rTolerance, bool fRelative, Double* pArea);
    internal static void MilUtility_ArcToBezier(Point ptStart, Size rRadii, double rRotation, bool fLargeArc, SweepDirection fSweepUp, Point ptEnd, MilMatrix3x2D* pMatrix, Point* pPt, Int32& cPieces);
}
[FlagsAttribute]
internal enum System.Windows.Media.Composition.MILCoreSegFlags : Enum {
    public int value__;
    public static MILCoreSegFlags SegTypeLine;
    public static MILCoreSegFlags SegTypeBezier;
    public static MILCoreSegFlags SegTypeMask;
    public static MILCoreSegFlags SegIsAGap;
    public static MILCoreSegFlags SegSmoothJoin;
    public static MILCoreSegFlags SegClosed;
    public static MILCoreSegFlags SegIsCurved;
    public static MILCoreSegFlags FORCE_DWORD;
}
[FlagsAttribute]
internal enum System.Windows.Media.Composition.MilGlyphRun : Enum {
    public ushort value__;
    public static MilGlyphRun Sideways;
    public static MilGlyphRun HasOffsets;
    public static MilGlyphRun FORCE_WORD;
}
internal class System.Windows.Media.Composition.MilGraphicsAccelerationAssessment : ValueType {
    internal UInt32 VideoMemoryBandwidth;
    internal UInt32 VideoMemorySize;
}
internal class System.Windows.Media.Composition.MilGraphicsAccelerationCaps : ValueType {
    internal int TierValue;
    internal int HasWDDMSupport;
    internal UInt32 PixelShaderVersion;
    internal UInt32 VertexShaderVersion;
    internal UInt32 MaxTextureWidth;
    internal UInt32 MaxTextureHeight;
    internal int WindowCompatibleMode;
    internal UInt32 BitsPerPixel;
    internal UInt32 HasSSE2Support;
    internal UInt32 MaxPixelShader30InstructionSlots;
}
internal enum System.Windows.Media.Composition.MilHorizontalAlignment : Enum {
    public int value__;
    public static MilHorizontalAlignment Left;
    public static MilHorizontalAlignment Center;
    public static MilHorizontalAlignment Right;
    public static MilHorizontalAlignment FORCE_DWORD;
}
internal class System.Windows.Media.Composition.MilMatrix3x2D : ValueType {
    internal double S_11;
    internal double S_12;
    internal double S_21;
    internal double S_22;
    internal double DX;
    internal double DY;
}
internal class System.Windows.Media.Composition.MilMatrix4x4D : ValueType {
    internal double M_11;
    internal double M_12;
    internal double M_13;
    internal double M_14;
    internal double M_21;
    internal double M_22;
    internal double M_23;
    internal double M_24;
    internal double M_31;
    internal double M_32;
    internal double M_33;
    internal double M_34;
    internal double M_41;
    internal double M_42;
    internal double M_43;
    internal double M_44;
}
internal enum System.Windows.Media.Composition.MilMessageClass : Enum {
    public int value__;
    public static MilMessageClass Invalid;
    public static MilMessageClass SyncFlushReply;
    public static MilMessageClass Tier;
    public static MilMessageClass CompositionDeviceStateChange;
    public static MilMessageClass PartitionIsZombie;
    public static MilMessageClass SyncModeStatus;
    public static MilMessageClass Presented;
    public static MilMessageClass RenderStatus;
    public static MilMessageClass BadPixelShader;
    public static MilMessageClass Last;
    public static MilMessageClass FORCE_DWORD;
}
[FlagsAttribute]
internal enum System.Windows.Media.Composition.MilPathFigureFlags : Enum {
    public int value__;
    public static MilPathFigureFlags HasGaps;
    public static MilPathFigureFlags HasCurves;
    public static MilPathFigureFlags IsClosed;
    public static MilPathFigureFlags IsFillable;
    public static MilPathFigureFlags IsRectangleData;
    public static MilPathFigureFlags Mask;
    public static MilPathFigureFlags FORCE_DWORD;
}
[FlagsAttribute]
internal enum System.Windows.Media.Composition.MilPathGeometryFlags : Enum {
    public int value__;
    public static MilPathGeometryFlags HasCurves;
    public static MilPathGeometryFlags BoundsValid;
    public static MilPathGeometryFlags HasGaps;
    public static MilPathGeometryFlags HasHollows;
    public static MilPathGeometryFlags IsRegionData;
    public static MilPathGeometryFlags Mask;
    public static MilPathGeometryFlags FORCE_DWORD;
}
internal class System.Windows.Media.Composition.MilPoint2F : ValueType {
    internal float X;
    internal float Y;
}
internal class System.Windows.Media.Composition.MilPoint3F : ValueType {
    internal float X;
    internal float Y;
    internal float Z;
}
internal class System.Windows.Media.Composition.MilQuaternionF : ValueType {
    internal float X;
    internal float Y;
    internal float Z;
    internal float W;
}
internal class System.Windows.Media.Composition.MilRectD : ValueType {
    internal double _left;
    internal double _top;
    internal double _right;
    internal double _bottom;
    internal static MilRectD Empty { get; }
    internal static MilRectD NaN { get; }
    internal Rect AsRect { get; }
    internal MilRectD(double left, double top, double right, double bottom);
    internal static MilRectD get_Empty();
    internal static MilRectD get_NaN();
    internal Rect get_AsRect();
}
internal class System.Windows.Media.Composition.MilRectF : ValueType {
    internal float _left;
    internal float _top;
    internal float _right;
    internal float _bottom;
}
[FlagsAttribute]
internal enum System.Windows.Media.Composition.MilRenderOptionFlags : Enum {
    public int value__;
    public static MilRenderOptionFlags BitmapScalingMode;
    public static MilRenderOptionFlags EdgeMode;
    public static MilRenderOptionFlags CompositingMode;
    public static MilRenderOptionFlags ClearTypeHint;
    public static MilRenderOptionFlags TextRenderingMode;
    public static MilRenderOptionFlags TextHintingMode;
    public static MilRenderOptionFlags Last;
    public static MilRenderOptionFlags FORCE_DWORD;
}
internal class System.Windows.Media.Composition.MilRenderOptions : ValueType {
    internal MilRenderOptionFlags Flags;
    internal EdgeMode EdgeMode;
    internal MilCompositingMode CompositingMode;
    internal BitmapScalingMode BitmapScalingMode;
    internal ClearTypeHint ClearTypeHint;
    internal TextRenderingMode TextRenderingMode;
    internal TextHintingMode TextHintingMode;
}
[FlagsAttribute]
internal enum System.Windows.Media.Composition.MILRTInitializationFlags : Enum {
    public int value__;
    public static MILRTInitializationFlags MIL_RT_INITIALIZE_DEFAULT;
    public static MILRTInitializationFlags MIL_RT_SOFTWARE_ONLY;
    public static MILRTInitializationFlags MIL_RT_HARDWARE_ONLY;
    public static MILRTInitializationFlags MIL_RT_NULL;
    public static MILRTInitializationFlags MIL_RT_TYPE_MASK;
    public static MILRTInitializationFlags MIL_RT_PRESENT_IMMEDIATELY;
    public static MILRTInitializationFlags MIL_RT_PRESENT_RETAIN_CONTENTS;
    public static MILRTInitializationFlags MIL_RT_FULLSCREEN;
    public static MILRTInitializationFlags MIL_RT_LINEAR_GAMMA;
    public static MILRTInitializationFlags MIL_RT_NEED_DESTINATION_ALPHA;
    public static MILRTInitializationFlags MIL_RT_ALLOW_LOW_PRECISION;
    public static MILRTInitializationFlags MIL_RT_SINGLE_THREADED_USAGE;
    public static MILRTInitializationFlags MIL_RT_RENDER_NONCLIENT;
    public static MILRTInitializationFlags MIL_RT_PRESENT_FLIP;
    public static MILRTInitializationFlags MIL_RT_FULLSCREEN_NO_AUTOROTATE;
    public static MILRTInitializationFlags MIL_RT_DISABLE_DISPLAY_CLIPPING;
    public static MILRTInitializationFlags MIL_RT_DISABLE_MULTIMON_DISPLAY_CLIPPING;
    public static MILRTInitializationFlags MIL_RT_IS_DISABLE_MULTIMON_DISPLAY_CLIPPING_VALID;
    public static MILRTInitializationFlags MIL_UCE_RT_ENABLE_OCCLUSION;
    public static MILRTInitializationFlags MIL_RT_USE_REF_RAST;
    public static MILRTInitializationFlags MIL_RT_USE_RGB_RAST;
    public static MILRTInitializationFlags MIL_RT_FULLSCREEN_TRANSPOSE_XY;
    public static MILRTInitializationFlags MIL_RT_PRESENT_USING_MASK;
    public static MILRTInitializationFlags MIL_RT_PRESENT_USING_HAL;
    public static MILRTInitializationFlags MIL_RT_PRESENT_USING_BITBLT;
    public static MILRTInitializationFlags MIL_RT_PRESENT_USING_ALPHABLEND;
    public static MILRTInitializationFlags MIL_RT_PRESENT_USING_ULW;
    public static MILRTInitializationFlags FORCE_DWORD;
}
[FlagsAttribute]
internal enum System.Windows.Media.Composition.MILTransparencyFlags : Enum {
    public int value__;
    public static MILTransparencyFlags Opaque;
    public static MILTransparencyFlags ConstantAlpha;
    public static MILTransparencyFlags PerPixelAlpha;
    public static MILTransparencyFlags ColorKey;
    public static MILTransparencyFlags FORCE_DWORD;
}
internal enum System.Windows.Media.Composition.MilVerticalAlignment : Enum {
    public int value__;
    public static MilVerticalAlignment Top;
    public static MilVerticalAlignment Center;
    public static MilVerticalAlignment Bottom;
    public static MilVerticalAlignment FORCE_DWORD;
}
internal enum System.Windows.Media.Composition.MILWindowLayerType : Enum {
    public int value__;
    public static MILWindowLayerType NotLayered;
    public static MILWindowLayerType SystemManagedLayer;
    public static MILWindowLayerType ApplicationManagedLayer;
    public static MILWindowLayerType FORCE_DWORD;
}
internal class System.Windows.Media.Composition.VisualProxy : ValueType {
    private static int PROXY_NOT_FOUND;
    private static int PROXY_STORED_INLINE;
    private Proxy _head;
    private Proxy[] _tail;
    internal int Count { get; }
    internal bool IsOnAnyChannel { get; }
    internal int get_Count();
    internal bool get_IsOnAnyChannel();
    internal bool IsOnChannel(Channel channel);
    internal bool CreateOrAddRefOnChannel(object instance, Channel channel, ResourceType resourceType);
    internal bool ReleaseOnChannel(Channel channel);
    internal Channel GetChannel(int index);
    internal ResourceHandle GetHandle(Channel channel);
    internal ResourceHandle GetHandle(int index);
    internal VisualProxyFlags GetFlags(Channel channel);
    internal VisualProxyFlags GetFlags(int index);
    internal void SetFlags(Channel channel, bool value, VisualProxyFlags flags);
    internal void SetFlags(int index, bool value, VisualProxyFlags flags);
    internal void SetFlagsOnAllChannels(bool value, VisualProxyFlags flags);
    internal bool CheckFlagsOnAllChannels(VisualProxyFlags conjunctionFlags);
    private int Find(Channel channel);
    private void ResizeTail(int delta);
}
public abstract class System.Windows.Media.CompositionTarget : DispatcherObject {
    internal MultiChannelResource _contentRoot;
    internal static ResourceType s_contentRootType;
    private bool _isDisposed;
    private SecurityCriticalDataForSet`1<Visual> _rootVisual;
    private RenderContext _cachedRenderContext;
    private Matrix _worldTransform;
    private Rect _worldClipBounds;
    internal bool IsDisposed { get; }
    public Visual RootVisual { get; public set; }
    public Matrix TransformToDevice { get; }
    public Matrix TransformFromDevice { get; }
    internal Matrix WorldTransform { get; }
    internal Rect WorldClipBounds { get; }
    internal virtual void CreateUCEResources(Channel channel, Channel outOfBandChannel);
    internal virtual void ReleaseUCEResources(Channel channel, Channel outOfBandChannel);
    public virtual void Dispose();
    internal bool get_IsDisposed();
    public virtual Visual get_RootVisual();
    public virtual void set_RootVisual(Visual value);
    public abstract virtual Matrix get_TransformToDevice();
    public abstract virtual Matrix get_TransformFromDevice();
    internal object StateChangedCallback(object arg);
    private sealed virtual override void System.Windows.Media.ICompositionTarget.AddRefOnChannel(Channel channel, Channel outOfBandChannel);
    private sealed virtual override void System.Windows.Media.ICompositionTarget.ReleaseOnChannel(Channel channel, Channel outOfBandChannel);
    private sealed virtual override void System.Windows.Media.ICompositionTarget.Render(bool inResize, Channel channel);
    internal Matrix get_WorldTransform();
    internal Rect get_WorldClipBounds();
    private void Compile(Channel channel);
    private void SetRootVisual(Visual visual);
    private void ClearRootNode(Channel channel);
    internal void VerifyAPIReadOnly();
    internal void VerifyAPIReadWrite();
    public static void add_Rendering(EventHandler value);
    public static void remove_Rendering(EventHandler value);
}
public class System.Windows.Media.ContainerVisual : Visual {
    private VisualCollection _children;
    public VisualCollection Children { get; }
    public DependencyObject Parent { get; }
    public Geometry Clip { get; public set; }
    public double Opacity { get; public set; }
    public Brush OpacityMask { get; public set; }
    public CacheMode CacheMode { get; public set; }
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
public BitmapEffect BitmapEffect { get; public set; }
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
public BitmapEffectInput BitmapEffectInput { get; public set; }
    public Effect Effect { get; public set; }
    [DefaultValueAttribute("")]
public DoubleCollection XSnappingGuidelines { get; public set; }
    [DefaultValueAttribute("")]
public DoubleCollection YSnappingGuidelines { get; public set; }
    public Rect ContentBounds { get; }
    public Transform Transform { get; public set; }
    public Vector Offset { get; public set; }
    public Rect DescendantBounds { get; }
    protected int VisualChildrenCount { get; }
    public VisualCollection get_Children();
    public DependencyObject get_Parent();
    public Geometry get_Clip();
    public void set_Clip(Geometry value);
    public double get_Opacity();
    public void set_Opacity(double value);
    public Brush get_OpacityMask();
    public void set_OpacityMask(Brush value);
    public CacheMode get_CacheMode();
    public void set_CacheMode(CacheMode value);
    public BitmapEffect get_BitmapEffect();
    public void set_BitmapEffect(BitmapEffect value);
    public BitmapEffectInput get_BitmapEffectInput();
    public void set_BitmapEffectInput(BitmapEffectInput value);
    public Effect get_Effect();
    public void set_Effect(Effect value);
    public DoubleCollection get_XSnappingGuidelines();
    public void set_XSnappingGuidelines(DoubleCollection value);
    public DoubleCollection get_YSnappingGuidelines();
    public void set_YSnappingGuidelines(DoubleCollection value);
    public HitTestResult HitTest(Point point);
    public void HitTest(HitTestFilterCallback filterCallback, HitTestResultCallback resultCallback, HitTestParameters hitTestParameters);
    public Rect get_ContentBounds();
    public Transform get_Transform();
    public void set_Transform(Transform value);
    public Vector get_Offset();
    public void set_Offset(Vector value);
    public Rect get_DescendantBounds();
    protected sealed virtual Visual GetVisualChild(int index);
    protected sealed virtual int get_VisualChildrenCount();
}
[FriendAccessAllowedAttribute]
public abstract class System.Windows.Media.Converters.BaseIListConverter : TypeConverter {
    internal TokenizerHelper _tokenizer;
    internal static char DelimiterChar;
    public virtual bool CanConvertFrom(ITypeDescriptorContext td, Type t);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext td, CultureInfo ci, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    internal abstract virtual object ConvertFromCore(ITypeDescriptorContext td, CultureInfo ci, string value);
    internal abstract virtual object ConvertToCore(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.Converters.BoolIListConverter : BaseIListConverter {
    private static int EstimatedCharCountPerItem;
    internal virtual object ConvertFromCore(ITypeDescriptorContext td, CultureInfo ci, string value);
    internal virtual object ConvertToCore(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.Converters.BrushValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Converters.CacheModeValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Converters.CharIListConverter : BaseIListConverter {
    internal virtual object ConvertFromCore(ITypeDescriptorContext td, CultureInfo ci, string value);
    internal virtual object ConvertToCore(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.Converters.DoubleCollectionValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Converters.DoubleIListConverter : BaseIListConverter {
    private static int EstimatedCharCountPerItem;
    internal sealed virtual object ConvertFromCore(ITypeDescriptorContext td, CultureInfo ci, string value);
    internal virtual object ConvertToCore(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.Converters.GeometryValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Converters.Int32CollectionValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Converters.PathFigureCollectionValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Converters.PointCollectionValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Converters.PointIListConverter : BaseIListConverter {
    private PointConverter converter;
    private static int EstimatedCharCountPerItem;
    internal virtual object ConvertFromCore(ITypeDescriptorContext td, CultureInfo ci, string value);
    internal virtual object ConvertToCore(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.Converters.TransformValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Converters.UShortIListConverter : BaseIListConverter {
    private static int EstimatedCharCountPerItem;
    internal virtual object ConvertFromCore(ITypeDescriptorContext td, CultureInfo ci, string value);
    internal virtual object ConvertToCore(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.Converters.VectorCollectionValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
[LocalizabilityAttribute("0")]
public class System.Windows.Media.DashStyle : Animatable {
    public static DependencyProperty OffsetProperty;
    public static DependencyProperty DashesProperty;
    internal MultiChannelResource _duceResource;
    internal static double c_Offset;
    internal static DoubleCollection s_Dashes;
    public double Offset { get; public set; }
    public DoubleCollection Dashes { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    public DashStyle(IEnumerable`1<double> dashes, double offset);
    private static DashStyle();
    internal void GetDashData(MIL_PEN_DATA* pData, Double[]& dashArray);
    public DashStyle Clone();
    public DashStyle CloneCurrentValue();
    private static void OffsetPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void DashesPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public double get_Offset();
    public void set_Offset(double value);
    public DoubleCollection get_Dashes();
    public void set_Dashes(DoubleCollection value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
    internal virtual int get_EffectiveValuesInitialSize();
}
public static class System.Windows.Media.DashStyles : object {
    private static DashStyle _solid;
    private static DashStyle _dash;
    private static DashStyle _dot;
    private static DashStyle _dashDot;
    private static DashStyle _dashDotDot;
    public static DashStyle Solid { get; }
    public static DashStyle Dash { get; }
    public static DashStyle Dot { get; }
    public static DashStyle DashDot { get; }
    public static DashStyle DashDotDot { get; }
    public static DashStyle get_Solid();
    public static DashStyle get_Dash();
    public static DashStyle get_Dot();
    public static DashStyle get_DashDot();
    public static DashStyle get_DashDotDot();
}
[TypeConverterAttribute("System.Windows.Media.DoubleCollectionConverter")]
[DefaultMemberAttribute("Item")]
[ValueSerializerAttribute("System.Windows.Media.Converters.DoubleCollectionValueSerializer")]
public class System.Windows.Media.DoubleCollection : Freezable {
    private static DoubleCollection s_empty;
    internal FrugalStructList`1<double> _collection;
    internal UInt32 _version;
    public double Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Double>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal static DoubleCollection Empty { get; }
    public DoubleCollection(int capacity);
    public DoubleCollection(IEnumerable`1<double> collection);
    public DoubleCollection Clone();
    public DoubleCollection CloneCurrentValue();
    public sealed virtual void Add(double value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(double value);
    public sealed virtual int IndexOf(double value);
    public sealed virtual void Insert(int index, double value);
    public sealed virtual bool Remove(double value);
    public sealed virtual void RemoveAt(int index);
    internal void RemoveAtWithoutFiringPublicEvents(int index);
    public sealed virtual double get_Item(int index);
    public sealed virtual void set_Item(int index, double value);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(Double[] array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Double>.get_IsReadOnly();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<double> System.Collections.Generic.IEnumerable<System.Double>.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal static DoubleCollection get_Empty();
    internal double Internal_GetItem(int i);
    private double Cast(object value);
    private int AddHelper(double value);
    internal int AddWithoutFiringPublicEvents(double value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
    public static DoubleCollection Parse(string source);
}
public class System.Windows.Media.DoubleCollectionConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[LocalizabilityAttribute("0")]
public abstract class System.Windows.Media.Drawing : Animatable {
    public Rect Bounds { get; }
    public Rect get_Bounds();
    internal abstract virtual void WalkCurrentValue(DrawingContextWalker ctx);
    private sealed virtual override Rect System.Windows.Media.IDrawingContent.GetContentBounds(BoundsDrawingContextWalker ctx);
    private sealed virtual override void System.Windows.Media.IDrawingContent.WalkContent(DrawingContextWalker ctx);
    private sealed virtual override bool System.Windows.Media.IDrawingContent.HitTestPoint(Point point);
    private sealed virtual override IntersectionDetail System.Windows.Media.IDrawingContent.HitTestGeometry(PathGeometry geometry);
    private sealed virtual override void System.Windows.Media.IDrawingContent.PropagateChangedHandler(EventHandler handler, bool adding);
    internal Rect GetBounds();
    public Drawing Clone();
    public Drawing CloneCurrentValue();
    internal abstract virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    internal abstract virtual void ReleaseOnChannelCore(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    internal abstract virtual ResourceHandle GetHandleCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    internal abstract virtual int GetChannelCountCore();
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    internal abstract virtual Channel GetChannelCore(int index);
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
}
public class System.Windows.Media.DrawingBrush : TileBrush {
    public static DependencyProperty DrawingProperty;
    internal MultiChannelResource _duceResource;
    public Drawing Drawing { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    public DrawingBrush(Drawing drawing);
    private static DrawingBrush();
    protected virtual void GetContentBounds(Rect& contentBounds);
    public DrawingBrush Clone();
    public DrawingBrush CloneCurrentValue();
    private static void DrawingPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Drawing get_Drawing();
    public void set_Drawing(Drawing value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    internal virtual int get_EffectiveValuesInitialSize();
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.DrawingCollection : Animatable {
    [CompilerGeneratedAttribute]
private ItemInsertedHandler ItemInserted;
    [CompilerGeneratedAttribute]
private ItemRemovedHandler ItemRemoved;
    private static DrawingCollection s_empty;
    internal FrugalStructList`1<Drawing> _collection;
    internal UInt32 _version;
    public Drawing Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.Drawing>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal static DrawingCollection Empty { get; }
    public DrawingCollection(int capacity);
    public DrawingCollection(IEnumerable`1<Drawing> collection);
    internal void TransactionalAppend(DrawingCollection collectionToAppend);
    public DrawingCollection Clone();
    public DrawingCollection CloneCurrentValue();
    public sealed virtual void Add(Drawing value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Drawing value);
    public sealed virtual int IndexOf(Drawing value);
    public sealed virtual void Insert(int index, Drawing value);
    public sealed virtual bool Remove(Drawing value);
    public sealed virtual void RemoveAt(int index);
    internal void RemoveAtWithoutFiringPublicEvents(int index);
    public sealed virtual Drawing get_Item(int index);
    public sealed virtual void set_Item(int index, Drawing value);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(Drawing[] array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.Drawing>.get_IsReadOnly();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<Drawing> System.Collections.Generic.IEnumerable<System.Windows.Media.Drawing>.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal static DrawingCollection get_Empty();
    internal Drawing Internal_GetItem(int i);
    internal virtual void OnInheritanceContextChangedCore(EventArgs args);
    private Drawing Cast(object value);
    private int AddHelper(Drawing value);
    internal int AddWithoutFiringPublicEvents(Drawing value);
    [CompilerGeneratedAttribute]
internal void add_ItemInserted(ItemInsertedHandler value);
    [CompilerGeneratedAttribute]
internal void remove_ItemInserted(ItemInsertedHandler value);
    [CompilerGeneratedAttribute]
internal void add_ItemRemoved(ItemRemovedHandler value);
    [CompilerGeneratedAttribute]
internal void remove_ItemRemoved(ItemRemovedHandler value);
    private void OnInsert(object item);
    private void OnRemove(object oldValue);
    private void OnSet(object oldValue, object newValue);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected virtual bool FreezeCore(bool isChecking);
}
public abstract class System.Windows.Media.DrawingContext : DispatcherObject {
    public void DrawText(FormattedText formattedText, Point origin);
    public abstract virtual void Close();
    private sealed virtual override void System.IDisposable.Dispose();
    protected abstract virtual void DisposeCore();
    protected virtual void VerifyApiNonstructuralChange();
    public abstract virtual void DrawLine(Pen pen, Point point0, Point point1);
    public abstract virtual void DrawLine(Pen pen, Point point0, AnimationClock point0Animations, Point point1, AnimationClock point1Animations);
    public abstract virtual void DrawRectangle(Brush brush, Pen pen, Rect rectangle);
    public abstract virtual void DrawRectangle(Brush brush, Pen pen, Rect rectangle, AnimationClock rectangleAnimations);
    public abstract virtual void DrawRoundedRectangle(Brush brush, Pen pen, Rect rectangle, double radiusX, double radiusY);
    public abstract virtual void DrawRoundedRectangle(Brush brush, Pen pen, Rect rectangle, AnimationClock rectangleAnimations, double radiusX, AnimationClock radiusXAnimations, double radiusY, AnimationClock radiusYAnimations);
    public abstract virtual void DrawEllipse(Brush brush, Pen pen, Point center, double radiusX, double radiusY);
    public abstract virtual void DrawEllipse(Brush brush, Pen pen, Point center, AnimationClock centerAnimations, double radiusX, AnimationClock radiusXAnimations, double radiusY, AnimationClock radiusYAnimations);
    public abstract virtual void DrawGeometry(Brush brush, Pen pen, Geometry geometry);
    public abstract virtual void DrawImage(ImageSource imageSource, Rect rectangle);
    public abstract virtual void DrawImage(ImageSource imageSource, Rect rectangle, AnimationClock rectangleAnimations);
    public abstract virtual void DrawGlyphRun(Brush foregroundBrush, GlyphRun glyphRun);
    public abstract virtual void DrawDrawing(Drawing drawing);
    public abstract virtual void DrawVideo(MediaPlayer player, Rect rectangle);
    public abstract virtual void DrawVideo(MediaPlayer player, Rect rectangle, AnimationClock rectangleAnimations);
    public abstract virtual void PushClip(Geometry clipGeometry);
    public abstract virtual void PushOpacityMask(Brush opacityMask);
    public abstract virtual void PushOpacity(double opacity);
    public abstract virtual void PushOpacity(double opacity, AnimationClock opacityAnimations);
    public abstract virtual void PushTransform(Transform transform);
    public abstract virtual void PushGuidelineSet(GuidelineSet guidelines);
    internal abstract virtual void PushGuidelineY1(double coordinate);
    internal abstract virtual void PushGuidelineY2(double leadingCoordinate, double offsetToDrivenCoordinate);
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
public abstract virtual void PushEffect(BitmapEffect effect, BitmapEffectInput effectInput);
    public abstract virtual void Pop();
}
internal class System.Windows.Media.DrawingContextDrawingContextWalker : DrawingContextWalker {
    private DrawingContext _drawingContext;
    public DrawingContextDrawingContextWalker(DrawingContext drawingContext);
    public virtual void DrawLine(Pen pen, Point point0, Point point1);
    public virtual void DrawLine(Pen pen, Point point0, AnimationClock point0Animations, Point point1, AnimationClock point1Animations);
    public virtual void DrawRectangle(Brush brush, Pen pen, Rect rectangle);
    public virtual void DrawRectangle(Brush brush, Pen pen, Rect rectangle, AnimationClock rectangleAnimations);
    public virtual void DrawRoundedRectangle(Brush brush, Pen pen, Rect rectangle, double radiusX, double radiusY);
    public virtual void DrawRoundedRectangle(Brush brush, Pen pen, Rect rectangle, AnimationClock rectangleAnimations, double radiusX, AnimationClock radiusXAnimations, double radiusY, AnimationClock radiusYAnimations);
    public virtual void DrawEllipse(Brush brush, Pen pen, Point center, double radiusX, double radiusY);
    public virtual void DrawEllipse(Brush brush, Pen pen, Point center, AnimationClock centerAnimations, double radiusX, AnimationClock radiusXAnimations, double radiusY, AnimationClock radiusYAnimations);
    public virtual void DrawGeometry(Brush brush, Pen pen, Geometry geometry);
    public virtual void DrawImage(ImageSource imageSource, Rect rectangle);
    public virtual void DrawImage(ImageSource imageSource, Rect rectangle, AnimationClock rectangleAnimations);
    public virtual void DrawGlyphRun(Brush foregroundBrush, GlyphRun glyphRun);
    public virtual void DrawDrawing(Drawing drawing);
    public virtual void DrawVideo(MediaPlayer player, Rect rectangle);
    public virtual void DrawVideo(MediaPlayer player, Rect rectangle, AnimationClock rectangleAnimations);
    public virtual void PushClip(Geometry clipGeometry);
    public virtual void PushOpacityMask(Brush opacityMask);
    public virtual void PushOpacity(double opacity);
    public virtual void PushOpacity(double opacity, AnimationClock opacityAnimations);
    public virtual void PushTransform(Transform transform);
    public virtual void PushGuidelineSet(GuidelineSet guidelines);
    internal virtual void PushGuidelineY1(double coordinate);
    internal virtual void PushGuidelineY2(double leadingCoordinate, double offsetToDrivenCoordinate);
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
public virtual void PushEffect(BitmapEffect effect, BitmapEffectInput effectInput);
    public virtual void Pop();
}
internal abstract class System.Windows.Media.DrawingContextWalker : DrawingContext {
    private bool _stopWalking;
    internal bool ShouldStopWalking { get; internal set; }
    public sealed virtual void Close();
    protected virtual void DisposeCore();
    protected void StopWalking();
    internal bool get_ShouldStopWalking();
    internal void set_ShouldStopWalking(bool value);
    public virtual void DrawLine(Pen pen, Point point0, Point point1);
    public virtual void DrawLine(Pen pen, Point point0, AnimationClock point0Animations, Point point1, AnimationClock point1Animations);
    public virtual void DrawRectangle(Brush brush, Pen pen, Rect rectangle);
    public virtual void DrawRectangle(Brush brush, Pen pen, Rect rectangle, AnimationClock rectangleAnimations);
    public virtual void DrawRoundedRectangle(Brush brush, Pen pen, Rect rectangle, double radiusX, double radiusY);
    public virtual void DrawRoundedRectangle(Brush brush, Pen pen, Rect rectangle, AnimationClock rectangleAnimations, double radiusX, AnimationClock radiusXAnimations, double radiusY, AnimationClock radiusYAnimations);
    public virtual void DrawEllipse(Brush brush, Pen pen, Point center, double radiusX, double radiusY);
    public virtual void DrawEllipse(Brush brush, Pen pen, Point center, AnimationClock centerAnimations, double radiusX, AnimationClock radiusXAnimations, double radiusY, AnimationClock radiusYAnimations);
    public virtual void DrawGeometry(Brush brush, Pen pen, Geometry geometry);
    public virtual void DrawImage(ImageSource imageSource, Rect rectangle);
    public virtual void DrawImage(ImageSource imageSource, Rect rectangle, AnimationClock rectangleAnimations);
    public virtual void DrawGlyphRun(Brush foregroundBrush, GlyphRun glyphRun);
    public virtual void DrawDrawing(Drawing drawing);
    public virtual void DrawVideo(MediaPlayer player, Rect rectangle);
    public virtual void DrawVideo(MediaPlayer player, Rect rectangle, AnimationClock rectangleAnimations);
    public virtual void PushClip(Geometry clipGeometry);
    public virtual void PushOpacityMask(Brush opacityMask);
    public virtual void PushOpacity(double opacity);
    public virtual void PushOpacity(double opacity, AnimationClock opacityAnimations);
    public virtual void PushTransform(Transform transform);
    public virtual void PushGuidelineSet(GuidelineSet guidelines);
    internal virtual void PushGuidelineY1(double coordinate);
    internal virtual void PushGuidelineY2(double leadingCoordinate, double offsetToDrivenCoordinate);
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
public virtual void PushEffect(BitmapEffect effect, BitmapEffectInput effectInput);
    public virtual void Pop();
}
internal class System.Windows.Media.DrawingDrawingContext : DrawingContext {
    protected Drawing _rootDrawing;
    protected DrawingGroup _currentDrawingGroup;
    private Stack`1<DrawingGroup> _previousDrawingGroupStack;
    private bool _disposed;
    private bool _canBeInheritanceContext;
    internal bool CanBeInheritanceContext { get; internal set; }
    public virtual void DrawLine(Pen pen, Point point0, Point point1);
    public virtual void DrawLine(Pen pen, Point point0, AnimationClock point0Animations, Point point1, AnimationClock point1Animations);
    public virtual void DrawRectangle(Brush brush, Pen pen, Rect rectangle);
    public virtual void DrawRectangle(Brush brush, Pen pen, Rect rectangle, AnimationClock rectangleAnimations);
    public virtual void DrawRoundedRectangle(Brush brush, Pen pen, Rect rectangle, double radiusX, double radiusY);
    public virtual void DrawRoundedRectangle(Brush brush, Pen pen, Rect rectangle, AnimationClock rectangleAnimations, double radiusX, AnimationClock radiusXAnimations, double radiusY, AnimationClock radiusYAnimations);
    public virtual void DrawEllipse(Brush brush, Pen pen, Point center, double radiusX, double radiusY);
    public virtual void DrawEllipse(Brush brush, Pen pen, Point center, AnimationClock centerAnimations, double radiusX, AnimationClock radiusXAnimations, double radiusY, AnimationClock radiusYAnimations);
    public virtual void DrawGeometry(Brush brush, Pen pen, Geometry geometry);
    public virtual void DrawImage(ImageSource imageSource, Rect rectangle);
    public virtual void DrawImage(ImageSource imageSource, Rect rectangle, AnimationClock rectangleAnimations);
    public virtual void DrawDrawing(Drawing drawing);
    public virtual void DrawVideo(MediaPlayer player, Rect rectangle);
    public virtual void DrawVideo(MediaPlayer player, Rect rectangle, AnimationClock rectangleAnimations);
    public virtual void PushClip(Geometry clipGeometry);
    public virtual void PushOpacityMask(Brush brush);
    public virtual void PushOpacity(double opacity);
    public virtual void PushOpacity(double opacity, AnimationClock opacityAnimations);
    public virtual void PushTransform(Transform transform);
    public virtual void PushGuidelineSet(GuidelineSet guidelines);
    internal virtual void PushGuidelineY1(double coordinate);
    internal virtual void PushGuidelineY2(double leadingCoordinate, double offsetToDrivenCoordinate);
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
public virtual void PushEffect(BitmapEffect effect, BitmapEffectInput effectInput);
    public virtual void Pop();
    public virtual void DrawGlyphRun(Brush foregroundBrush, GlyphRun glyphRun);
    public virtual void Close();
    protected virtual void DisposeCore();
    protected virtual void CloseCore(DrawingCollection rootDrawingGroupChildren);
    protected virtual void VerifyApiNonstructuralChange();
    internal bool get_CanBeInheritanceContext();
    internal void set_CanBeInheritanceContext(bool value);
    private void VerifyNotDisposed();
    private Freezable SetupNewFreezable(Freezable newFreezable, bool fFreeze);
    private void AddNewGeometryDrawing(Brush brush, Pen pen, Geometry geometry);
    private void PushNewDrawingGroup();
    private void AddDrawing(Drawing newDrawing);
}
[ContentPropertyAttribute("Children")]
public class System.Windows.Media.DrawingGroup : Drawing {
    private bool _openedForAppend;
    private bool _open;
    public static DependencyProperty ChildrenProperty;
    public static DependencyProperty ClipGeometryProperty;
    public static DependencyProperty OpacityProperty;
    public static DependencyProperty OpacityMaskProperty;
    public static DependencyProperty TransformProperty;
    public static DependencyProperty GuidelineSetProperty;
    public static DependencyProperty BitmapEffectProperty;
    public static DependencyProperty BitmapEffectInputProperty;
    internal MultiChannelResource _duceResource;
    internal static DrawingCollection s_Children;
    internal static double c_Opacity;
    internal static EdgeMode c_EdgeMode;
    internal static BitmapScalingMode c_BitmapScalingMode;
    internal static ClearTypeHint c_ClearTypeHint;
    public DrawingCollection Children { get; public set; }
    public Geometry ClipGeometry { get; public set; }
    public double Opacity { get; public set; }
    public Brush OpacityMask { get; public set; }
    public Transform Transform { get; public set; }
    public GuidelineSet GuidelineSet { get; public set; }
    public BitmapEffect BitmapEffect { get; public set; }
    public BitmapEffectInput BitmapEffectInput { get; public set; }
    private static DrawingGroup();
    public DrawingContext Open();
    public DrawingContext Append();
    internal void Close(DrawingCollection rootDrawingGroupChildren);
    internal virtual void WalkCurrentValue(DrawingContextWalker ctx);
    private void VerifyOpen();
    public DrawingGroup Clone();
    public DrawingGroup CloneCurrentValue();
    private static void ChildrenPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void ClipGeometryPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OpacityPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OpacityMaskPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void TransformPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void GuidelineSetPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void EdgeModePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void BitmapEffectPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void BitmapEffectInputPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void BitmapScalingModePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void ClearTypeHintPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public DrawingCollection get_Children();
    public void set_Children(DrawingCollection value);
    public Geometry get_ClipGeometry();
    public void set_ClipGeometry(Geometry value);
    public double get_Opacity();
    public void set_Opacity(double value);
    public Brush get_OpacityMask();
    public void set_OpacityMask(Brush value);
    public Transform get_Transform();
    public void set_Transform(Transform value);
    public GuidelineSet get_GuidelineSet();
    public void set_GuidelineSet(GuidelineSet value);
    public BitmapEffect get_BitmapEffect();
    public void set_BitmapEffect(BitmapEffect value);
    public BitmapEffectInput get_BitmapEffectInput();
    public void set_BitmapEffectInput(BitmapEffectInput value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    private void ChildrenItemInserted(object sender, object item);
    private void ChildrenItemRemoved(object sender, object item);
}
internal class System.Windows.Media.DrawingGroupDrawingContext : DrawingDrawingContext {
    private DrawingGroup _drawingGroup;
    internal DrawingGroupDrawingContext(DrawingGroup drawingGroup);
    protected virtual void CloseCore(DrawingCollection rootDrawingGroupChildren);
}
public class System.Windows.Media.DrawingImage : ImageSource {
    public static DependencyProperty DrawingProperty;
    internal MultiChannelResource _duceResource;
    public double Width { get; }
    public double Height { get; }
    public ImageMetadata Metadata { get; }
    internal Size Size { get; }
    public Drawing Drawing { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    public DrawingImage(Drawing drawing);
    private static DrawingImage();
    public virtual double get_Width();
    public virtual double get_Height();
    public virtual ImageMetadata get_Metadata();
    internal virtual Size get_Size();
    public DrawingImage Clone();
    public DrawingImage CloneCurrentValue();
    private static void DrawingPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Drawing get_Drawing();
    public void set_Drawing(Drawing value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    internal virtual int get_EffectiveValuesInitialSize();
}
internal static class System.Windows.Media.DrawingServices : object {
    internal static bool HitTestPoint(Drawing drawing, Point point);
    internal static IntersectionDetail HitTestGeometry(Drawing drawing, PathGeometry geometry);
    internal static DrawingGroup DrawingGroupFromRenderData(RenderData renderData);
}
public class System.Windows.Media.DrawingVisual : ContainerVisual {
    private IDrawingContent _content;
    public DrawingGroup Drawing { get; }
    protected virtual HitTestResult HitTestCore(PointHitTestParameters hitTestParameters);
    protected virtual GeometryHitTestResult HitTestCore(GeometryHitTestParameters hitTestParameters);
    public DrawingContext RenderOpen();
    internal virtual void RenderClose(IDrawingContent newContent);
    internal virtual void FreeContent(Channel channel);
    internal virtual Rect GetContentBounds();
    internal void WalkContent(DrawingContextWalker walker);
    internal virtual void RenderContent(RenderContext ctx, bool isOnChannel);
    internal virtual DrawingGroup GetDrawing();
    public DrawingGroup get_Drawing();
}
public enum System.Windows.Media.EdgeMode : Enum {
    public int value__;
    public static EdgeMode Unspecified;
    public static EdgeMode Aliased;
}
public class System.Windows.Media.Effects.BevelBitmapEffect : BitmapEffect {
    public static DependencyProperty BevelWidthProperty;
    public static DependencyProperty ReliefProperty;
    public static DependencyProperty LightAngleProperty;
    public static DependencyProperty SmoothnessProperty;
    public static DependencyProperty EdgeProfileProperty;
    internal static double c_BevelWidth;
    internal static double c_Relief;
    internal static double c_LightAngle;
    internal static double c_Smoothness;
    internal static EdgeProfile c_EdgeProfile;
    public double BevelWidth { get; public set; }
    public double Relief { get; public set; }
    public double LightAngle { get; public set; }
    public double Smoothness { get; public set; }
    public EdgeProfile EdgeProfile { get; public set; }
    private static BevelBitmapEffect();
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected virtual SafeHandle CreateUnmanagedEffect();
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected virtual void UpdateUnmanagedPropertyState(SafeHandle unmanagedEffect);
    public BevelBitmapEffect Clone();
    public BevelBitmapEffect CloneCurrentValue();
    private static void BevelWidthPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void ReliefPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void LightAnglePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void SmoothnessPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public double get_BevelWidth();
    public void set_BevelWidth(double value);
    public double get_Relief();
    public void set_Relief(double value);
    public double get_LightAngle();
    public void set_LightAngle(double value);
    public double get_Smoothness();
    public void set_Smoothness(double value);
    public EdgeProfile get_EdgeProfile();
    public void set_EdgeProfile(EdgeProfile value);
    protected virtual Freezable CreateInstanceCore();
}
public abstract class System.Windows.Media.Effects.BitmapEffect : Animatable {
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected abstract virtual void UpdateUnmanagedPropertyState(SafeHandle unmanagedEffect);
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected abstract virtual SafeHandle CreateUnmanagedEffect();
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected static void SetValue(SafeHandle effect, string propertyName, object value);
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected static SafeHandle CreateBitmapEffectOuter();
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected static void InitializeBitmapEffect(SafeHandle outerObject, SafeHandle innerObject);
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
public BitmapSource GetOutput(BitmapEffectInput input);
    internal virtual bool CanBeEmulatedUsingEffectPipeline();
    internal virtual Effect GetEmulatingEffect();
    public BitmapEffect Clone();
    public BitmapEffect CloneCurrentValue();
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Effects.BitmapEffectCollection : Animatable {
    private static BitmapEffectCollection s_empty;
    internal FrugalStructList`1<BitmapEffect> _collection;
    internal UInt32 _version;
    public BitmapEffect Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.Effects.BitmapEffect>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal static BitmapEffectCollection Empty { get; }
    public BitmapEffectCollection(int capacity);
    public BitmapEffectCollection(IEnumerable`1<BitmapEffect> collection);
    public BitmapEffectCollection Clone();
    public BitmapEffectCollection CloneCurrentValue();
    public sealed virtual void Add(BitmapEffect value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(BitmapEffect value);
    public sealed virtual int IndexOf(BitmapEffect value);
    public sealed virtual void Insert(int index, BitmapEffect value);
    public sealed virtual bool Remove(BitmapEffect value);
    public sealed virtual void RemoveAt(int index);
    internal void RemoveAtWithoutFiringPublicEvents(int index);
    public sealed virtual BitmapEffect get_Item(int index);
    public sealed virtual void set_Item(int index, BitmapEffect value);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(BitmapEffect[] array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.Effects.BitmapEffect>.get_IsReadOnly();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<BitmapEffect> System.Collections.Generic.IEnumerable<System.Windows.Media.Effects.BitmapEffect>.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal static BitmapEffectCollection get_Empty();
    internal BitmapEffect Internal_GetItem(int i);
    internal virtual void OnInheritanceContextChangedCore(EventArgs args);
    private BitmapEffect Cast(object value);
    private int AddHelper(BitmapEffect value);
    internal int AddWithoutFiringPublicEvents(BitmapEffect value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected virtual bool FreezeCore(bool isChecking);
}
[ContentPropertyAttribute("Children")]
public class System.Windows.Media.Effects.BitmapEffectGroup : BitmapEffect {
    public static DependencyProperty ChildrenProperty;
    internal static BitmapEffectCollection s_Children;
    public BitmapEffectCollection Children { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    private static BitmapEffectGroup();
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected virtual void UpdateUnmanagedPropertyState(SafeHandle unmanagedEffect);
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected virtual SafeHandle CreateUnmanagedEffect();
    public BitmapEffectGroup Clone();
    public BitmapEffectGroup CloneCurrentValue();
    public BitmapEffectCollection get_Children();
    public void set_Children(BitmapEffectCollection value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual int get_EffectiveValuesInitialSize();
}
public class System.Windows.Media.Effects.BitmapEffectInput : Animatable {
    private static BitmapSource s_defaultInputSource;
    public static DependencyProperty InputProperty;
    public static DependencyProperty AreaToApplyEffectUnitsProperty;
    public static DependencyProperty AreaToApplyEffectProperty;
    internal static BitmapSource s_Input;
    internal static BrushMappingMode c_AreaToApplyEffectUnits;
    internal static Rect s_AreaToApplyEffect;
    public static BitmapSource ContextInputSource { get; }
    public BitmapSource Input { get; public set; }
    public BrushMappingMode AreaToApplyEffectUnits { get; public set; }
    public Rect AreaToApplyEffect { get; public set; }
    public BitmapEffectInput(BitmapSource input);
    private static BitmapEffectInput();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeInput();
    public static BitmapSource get_ContextInputSource();
    public BitmapEffectInput Clone();
    public BitmapEffectInput CloneCurrentValue();
    private static void AreaToApplyEffectPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public BitmapSource get_Input();
    public void set_Input(BitmapSource value);
    public BrushMappingMode get_AreaToApplyEffectUnits();
    public void set_AreaToApplyEffectUnits(BrushMappingMode value);
    public Rect get_AreaToApplyEffect();
    public void set_AreaToApplyEffect(Rect value);
    protected virtual Freezable CreateInstanceCore();
}
internal class System.Windows.Media.Effects.BitmapEffectInputData : ValueType {
    public BitmapEffect BitmapEffect;
    public BitmapEffectInput BitmapEffectInput;
    public BitmapEffectInputData(BitmapEffect bitmapEffect, BitmapEffectInput bitmapEffectInput);
}
internal class System.Windows.Media.Effects.BitmapEffectState : object {
    private BitmapEffect _bitmapEffect;
    private BitmapEffectInput _bitmapEffectInput;
    public BitmapEffect BitmapEffect { get; public set; }
    public BitmapEffectInput BitmapEffectInput { get; public set; }
    public BitmapEffect get_BitmapEffect();
    public void set_BitmapEffect(BitmapEffect value);
    public BitmapEffectInput get_BitmapEffectInput();
    public void set_BitmapEffectInput(BitmapEffectInput value);
}
public class System.Windows.Media.Effects.BlurBitmapEffect : BitmapEffect {
    private BlurEffect _imageEffectEmulation;
    public static DependencyProperty RadiusProperty;
    public static DependencyProperty KernelTypeProperty;
    internal static double c_Radius;
    internal static KernelType c_KernelType;
    public double Radius { get; public set; }
    public KernelType KernelType { get; public set; }
    private static BlurBitmapEffect();
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected virtual SafeHandle CreateUnmanagedEffect();
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected virtual void UpdateUnmanagedPropertyState(SafeHandle unmanagedEffect);
    internal virtual bool CanBeEmulatedUsingEffectPipeline();
    internal virtual Effect GetEmulatingEffect();
    public BlurBitmapEffect Clone();
    public BlurBitmapEffect CloneCurrentValue();
    private static void RadiusPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public double get_Radius();
    public void set_Radius(double value);
    public KernelType get_KernelType();
    public void set_KernelType(KernelType value);
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Effects.BlurEffect : Effect {
    public static DependencyProperty RadiusProperty;
    public static DependencyProperty KernelTypeProperty;
    public static DependencyProperty RenderingBiasProperty;
    internal MultiChannelResource _duceResource;
    internal static double c_Radius;
    internal static KernelType c_KernelType;
    internal static RenderingBias c_RenderingBias;
    public double Radius { get; public set; }
    public KernelType KernelType { get; public set; }
    public RenderingBias RenderingBias { get; public set; }
    private static BlurEffect();
    internal virtual Rect GetRenderBounds(Rect contentBounds);
    public BlurEffect Clone();
    public BlurEffect CloneCurrentValue();
    private static void RadiusPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void KernelTypePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void RenderingBiasPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public double get_Radius();
    public void set_Radius(double value);
    public KernelType get_KernelType();
    public void set_KernelType(KernelType value);
    public RenderingBias get_RenderingBias();
    public void set_RenderingBias(RenderingBias value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
}
public class System.Windows.Media.Effects.DropShadowBitmapEffect : BitmapEffect {
    private DropShadowEffect _imageEffectEmulation;
    private static double _MAX_EMULATED_BLUR_RADIUS;
    public static DependencyProperty ShadowDepthProperty;
    public static DependencyProperty ColorProperty;
    public static DependencyProperty DirectionProperty;
    public static DependencyProperty NoiseProperty;
    public static DependencyProperty OpacityProperty;
    public static DependencyProperty SoftnessProperty;
    internal static double c_ShadowDepth;
    internal static Color s_Color;
    internal static double c_Direction;
    internal static double c_Noise;
    internal static double c_Opacity;
    internal static double c_Softness;
    public double ShadowDepth { get; public set; }
    public Color Color { get; public set; }
    public double Direction { get; public set; }
    public double Noise { get; public set; }
    public double Opacity { get; public set; }
    public double Softness { get; public set; }
    private static DropShadowBitmapEffect();
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected virtual SafeHandle CreateUnmanagedEffect();
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected virtual void UpdateUnmanagedPropertyState(SafeHandle unmanagedEffect);
    internal virtual bool CanBeEmulatedUsingEffectPipeline();
    internal virtual Effect GetEmulatingEffect();
    public DropShadowBitmapEffect Clone();
    public DropShadowBitmapEffect CloneCurrentValue();
    private static void ShadowDepthPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void ColorPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void DirectionPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void NoisePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OpacityPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void SoftnessPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public double get_ShadowDepth();
    public void set_ShadowDepth(double value);
    public Color get_Color();
    public void set_Color(Color value);
    public double get_Direction();
    public void set_Direction(double value);
    public double get_Noise();
    public void set_Noise(double value);
    public double get_Opacity();
    public void set_Opacity(double value);
    public double get_Softness();
    public void set_Softness(double value);
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Effects.DropShadowEffect : Effect {
    public static DependencyProperty ShadowDepthProperty;
    public static DependencyProperty ColorProperty;
    public static DependencyProperty DirectionProperty;
    public static DependencyProperty OpacityProperty;
    public static DependencyProperty BlurRadiusProperty;
    public static DependencyProperty RenderingBiasProperty;
    internal MultiChannelResource _duceResource;
    internal static double c_ShadowDepth;
    internal static Color s_Color;
    internal static double c_Direction;
    internal static double c_Opacity;
    internal static double c_BlurRadius;
    internal static RenderingBias c_RenderingBias;
    public double ShadowDepth { get; public set; }
    public Color Color { get; public set; }
    public double Direction { get; public set; }
    public double Opacity { get; public set; }
    public double BlurRadius { get; public set; }
    public RenderingBias RenderingBias { get; public set; }
    private static DropShadowEffect();
    internal virtual Rect GetRenderBounds(Rect contentBounds);
    public DropShadowEffect Clone();
    public DropShadowEffect CloneCurrentValue();
    private static void ShadowDepthPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void ColorPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void DirectionPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OpacityPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void BlurRadiusPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void RenderingBiasPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public double get_ShadowDepth();
    public void set_ShadowDepth(double value);
    public Color get_Color();
    public void set_Color(Color value);
    public double get_Direction();
    public void set_Direction(double value);
    public double get_Opacity();
    public void set_Opacity(double value);
    public double get_BlurRadius();
    public void set_BlurRadius(double value);
    public RenderingBias get_RenderingBias();
    public void set_RenderingBias(RenderingBias value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
}
public enum System.Windows.Media.Effects.EdgeProfile : Enum {
    public int value__;
    public static EdgeProfile Linear;
    public static EdgeProfile CurvedIn;
    public static EdgeProfile CurvedOut;
    public static EdgeProfile BulgedUp;
}
public abstract class System.Windows.Media.Effects.Effect : Animatable {
    [CompilerGeneratedAttribute]
private static Brush <ImplicitInput>k__BackingField;
    private Rect _mruWorldBounds;
    private GeneralTransform _mruInnerGeneralTransform;
    private GeneralTransform _mruWorldSpaceGeneralTransform;
    [BrowsableAttribute("False")]
public static Brush ImplicitInput { get; private set; }
    protected internal GeneralTransform EffectMapping { get; }
    private static Effect();
    [CompilerGeneratedAttribute]
public static Brush get_ImplicitInput();
    [CompilerGeneratedAttribute]
private static void set_ImplicitInput(Brush value);
    internal abstract virtual Rect GetRenderBounds(Rect contentBounds);
    protected internal virtual GeneralTransform get_EffectMapping();
    internal GeneralTransform CoerceToUnitSpaceGeneralTransform(GeneralTransform gt, Rect worldBounds);
    private static Point UnitToWorldUnsafe(Point unitPoint, Rect worldBounds);
    internal static Nullable`1<Point> UnitToWorld(Point unitPoint, Rect worldBounds);
    internal static Nullable`1<Point> WorldToUnit(Point worldPoint, Rect worldBounds);
    internal static Rect UnitToWorld(Rect unitRect, Rect worldBounds);
    internal static Nullable`1<Rect> WorldToUnit(Rect worldRect, Rect worldBounds);
    public Effect Clone();
    public Effect CloneCurrentValue();
    internal abstract virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    internal abstract virtual void ReleaseOnChannelCore(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    internal abstract virtual ResourceHandle GetHandleCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    internal abstract virtual int GetChannelCountCore();
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    internal abstract virtual Channel GetChannelCore(int index);
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
}
public class System.Windows.Media.Effects.EmbossBitmapEffect : BitmapEffect {
    public static DependencyProperty LightAngleProperty;
    public static DependencyProperty ReliefProperty;
    internal static double c_LightAngle;
    internal static double c_Relief;
    public double LightAngle { get; public set; }
    public double Relief { get; public set; }
    private static EmbossBitmapEffect();
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected virtual SafeHandle CreateUnmanagedEffect();
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected virtual void UpdateUnmanagedPropertyState(SafeHandle unmanagedEffect);
    public EmbossBitmapEffect Clone();
    public EmbossBitmapEffect CloneCurrentValue();
    private static void LightAnglePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void ReliefPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public double get_LightAngle();
    public void set_LightAngle(double value);
    public double get_Relief();
    public void set_Relief(double value);
    protected virtual Freezable CreateInstanceCore();
}
internal class System.Windows.Media.Effects.ImplicitInputBrush : Brush {
    internal MultiChannelResource _duceResource;
    public ImplicitInputBrush Clone();
    public ImplicitInputBrush CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
}
public enum System.Windows.Media.Effects.KernelType : Enum {
    public int value__;
    public static KernelType Gaussian;
    public static KernelType Box;
}
public class System.Windows.Media.Effects.OuterGlowBitmapEffect : BitmapEffect {
    public static DependencyProperty GlowColorProperty;
    public static DependencyProperty GlowSizeProperty;
    public static DependencyProperty NoiseProperty;
    public static DependencyProperty OpacityProperty;
    internal static Color s_GlowColor;
    internal static double c_GlowSize;
    internal static double c_Noise;
    internal static double c_Opacity;
    public Color GlowColor { get; public set; }
    public double GlowSize { get; public set; }
    public double Noise { get; public set; }
    public double Opacity { get; public set; }
    private static OuterGlowBitmapEffect();
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected virtual SafeHandle CreateUnmanagedEffect();
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected virtual void UpdateUnmanagedPropertyState(SafeHandle unmanagedEffect);
    public OuterGlowBitmapEffect Clone();
    public OuterGlowBitmapEffect CloneCurrentValue();
    private static void GlowColorPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void GlowSizePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void NoisePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OpacityPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Color get_GlowColor();
    public void set_GlowColor(Color value);
    public double get_GlowSize();
    public void set_GlowSize(double value);
    public double get_Noise();
    public void set_Noise(double value);
    public double get_Opacity();
    public void set_Opacity(double value);
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Effects.PixelShader : Animatable {
    [CompilerGeneratedAttribute]
private short <ShaderMajorVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private short <ShaderMinorVersion>k__BackingField;
    private SecurityCriticalData`1<Byte[]> _shaderBytecode;
    [CompilerGeneratedAttribute]
private EventHandler _shaderBytecodeChanged;
    public static DependencyProperty UriSourceProperty;
    public static DependencyProperty ShaderRenderModeProperty;
    internal MultiChannelResource _duceResource;
    internal static Uri s_UriSource;
    internal static ShaderRenderMode c_ShaderRenderMode;
    internal short ShaderMajorVersion { get; private set; }
    internal short ShaderMinorVersion { get; private set; }
    public Uri UriSource { get; public set; }
    public ShaderRenderMode ShaderRenderMode { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    private static PixelShader();
    public void SetStreamSource(Stream source);
    [CompilerGeneratedAttribute]
internal short get_ShaderMajorVersion();
    [CompilerGeneratedAttribute]
private void set_ShaderMajorVersion(short value);
    [CompilerGeneratedAttribute]
internal short get_ShaderMinorVersion();
    [CompilerGeneratedAttribute]
private void set_ShaderMinorVersion(short value);
    public static void add_InvalidPixelShaderEncountered(EventHandler value);
    public static void remove_InvalidPixelShaderEncountered(EventHandler value);
    private void UriSourcePropertyChangedHook(DependencyPropertyChangedEventArgs e);
    private void LoadPixelShaderFromStreamIntoMemory(Stream source);
    private void ManualUpdateResource(Channel channel, bool skipOnChannelCheck);
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    private void CopyCommon(PixelShader shader);
    [CompilerGeneratedAttribute]
internal void add__shaderBytecodeChanged(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove__shaderBytecodeChanged(EventHandler value);
    public PixelShader Clone();
    public PixelShader CloneCurrentValue();
    private static void UriSourcePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void ShaderRenderModePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Uri get_UriSource();
    public void set_UriSource(Uri value);
    public ShaderRenderMode get_ShaderRenderMode();
    public void set_ShaderRenderMode(ShaderRenderMode value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
    internal virtual int get_EffectiveValuesInitialSize();
}
public enum System.Windows.Media.Effects.RenderingBias : Enum {
    public int value__;
    public static RenderingBias Performance;
    public static RenderingBias Quality;
}
public enum System.Windows.Media.Effects.SamplingMode : Enum {
    public int value__;
    public static SamplingMode NearestNeighbor;
    public static SamplingMode Bilinear;
    public static SamplingMode Auto;
}
public abstract class System.Windows.Media.Effects.ShaderEffect : Effect {
    private static SamplingMode _defaultSamplingMode;
    private double _topPadding;
    private double _bottomPadding;
    private double _leftPadding;
    private double _rightPadding;
    private List`1<Nullable`1<MilColorF>> _floatRegisters;
    private List`1<Nullable`1<MilColorI>> _intRegisters;
    private List`1<Nullable`1<bool>> _boolRegisters;
    private List`1<Nullable`1<SamplerData>> _samplerData;
    private UInt32 _floatCount;
    private UInt32 _intCount;
    private UInt32 _boolCount;
    private UInt32 _samplerCount;
    private int _ddxUvDdyUvRegisterIndex;
    private static int PS_2_0_FLOAT_REGISTER_LIMIT;
    private static int PS_3_0_FLOAT_REGISTER_LIMIT;
    private static int PS_3_0_INT_REGISTER_LIMIT;
    private static int PS_3_0_BOOL_REGISTER_LIMIT;
    private static int PS_2_0_SAMPLER_LIMIT;
    private static int PS_3_0_SAMPLER_LIMIT;
    protected static DependencyProperty PixelShaderProperty;
    internal MultiChannelResource _duceResource;
    protected double PaddingTop { get; protected set; }
    protected double PaddingBottom { get; protected set; }
    protected double PaddingLeft { get; protected set; }
    protected double PaddingRight { get; protected set; }
    protected int DdxUvDdyUvRegisterIndex { get; protected set; }
    protected PixelShader PixelShader { get; protected set; }
    private static ShaderEffect();
    internal virtual Rect GetRenderBounds(Rect contentBounds);
    protected double get_PaddingTop();
    protected void set_PaddingTop(double value);
    protected double get_PaddingBottom();
    protected void set_PaddingBottom(double value);
    protected double get_PaddingLeft();
    protected void set_PaddingLeft(double value);
    protected double get_PaddingRight();
    protected void set_PaddingRight(double value);
    protected int get_DdxUvDdyUvRegisterIndex();
    protected void set_DdxUvDdyUvRegisterIndex(int value);
    private void PixelShaderPropertyChangedHook(DependencyPropertyChangedEventArgs e);
    private void OnPixelShaderBytecodeChanged(object sender, EventArgs e);
    private bool UsesPS30OnlyRegisters();
    protected void UpdateShaderValue(DependencyProperty dp);
    protected static PropertyChangedCallback PixelShaderConstantCallback(int floatRegisterIndex);
    protected static PropertyChangedCallback PixelShaderSamplerCallback(int samplerRegisterIndex);
    protected static PropertyChangedCallback PixelShaderSamplerCallback(int samplerRegisterIndex, SamplingMode samplingMode);
    protected static DependencyProperty RegisterPixelShaderSamplerProperty(string dpName, Type ownerType, int samplerRegisterIndex);
    protected static DependencyProperty RegisterPixelShaderSamplerProperty(string dpName, Type ownerType, int samplerRegisterIndex, SamplingMode samplingMode);
    private void UpdateShaderConstant(DependencyProperty dp, object newValue, int registerIndex);
    private void UpdateShaderSampler(DependencyProperty dp, object newValue, int registerIndex, SamplingMode samplingMode);
    private static void StashInPosition(List`1& list, int position, T value, int maxIndex, UInt32& count);
    private void StashSamplerDataInPosition(int position, SamplerData newSampler, int maxIndex);
    private void ManualUpdateResource(Channel channel, bool skipOnChannelCheck);
    private void AppendRegisters(Channel channel, List`1<Nullable`1<T>> list);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal static Type DetermineShaderConstantType(Type type, PixelShader pixelShader);
    internal static void ConvertValueToMilColorF(object value, MilColorF& newVal);
    internal static void ConvertValueToMilColorI(object value, MilColorI& newVal);
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    private void CopyCommon(ShaderEffect effect);
    public ShaderEffect Clone();
    public ShaderEffect CloneCurrentValue();
    private static void PixelShaderPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected PixelShader get_PixelShader();
    protected void set_PixelShader(PixelShader value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    private ResourceHandle GeneratedAddRefOnChannelCore(Channel channel);
    private void GeneratedReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
}
public enum System.Windows.Media.Effects.ShaderRenderMode : Enum {
    public int value__;
    public static ShaderRenderMode Auto;
    public static ShaderRenderMode SoftwareOnly;
    public static ShaderRenderMode HardwareOnly;
}
internal static class System.Windows.Media.Effects.ValidateEnums : object {
    public static bool IsShaderRenderModeValid(object valueObject);
    public static bool IsKernelTypeValid(object valueObject);
    public static bool IsEdgeProfileValid(object valueObject);
    public static bool IsRenderingBiasValid(object valueObject);
}
public class System.Windows.Media.EllipseGeometry : Geometry {
    internal static double c_arcAsBezier;
    private static UInt32 c_segmentCount;
    private static UInt32 c_pointCount;
    private static byte c_smoothBezier;
    private static Byte[] s_roundedPathTypes;
    public static DependencyProperty RadiusXProperty;
    public static DependencyProperty RadiusYProperty;
    public static DependencyProperty CenterProperty;
    internal MultiChannelResource _duceResource;
    internal static double c_RadiusX;
    internal static double c_RadiusY;
    internal static Point s_Center;
    public Rect Bounds { get; }
    public double RadiusX { get; public set; }
    public double RadiusY { get; public set; }
    public Point Center { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    public EllipseGeometry(Rect rect);
    public EllipseGeometry(Point center, double radiusX, double radiusY);
    public EllipseGeometry(Point center, double radiusX, double radiusY, Transform transform);
    private static EllipseGeometry();
    public virtual Rect get_Bounds();
    internal virtual Rect GetBoundsInternal(Pen pen, Matrix matrix, double tolerance, ToleranceType type);
    internal static Rect GetBoundsHelper(Pen pen, Matrix worldMatrix, Point center, double radiusX, double radiusY, Matrix geometryMatrix, double tolerance, ToleranceType type);
    internal virtual bool ContainsInternal(Pen pen, Point hitPoint, double tolerance, ToleranceType type);
    public virtual bool IsEmpty();
    public virtual bool MayHaveCurves();
    public virtual double GetArea(double tolerance, ToleranceType type);
    internal virtual PathFigureCollection GetTransformedFigureCollection(Transform transform);
    internal virtual PathGeometry GetAsPathGeometry();
    internal virtual PathGeometryData GetPathGeometryData();
    private Point[] GetPointList();
    private static void GetPointList(Point* points, UInt32 pointsCount, Point center, double radiusX, double radiusY);
    private Byte[] GetTypeList();
    private UInt32 GetPointCount();
    private UInt32 GetSegmentCount();
    public EllipseGeometry Clone();
    public EllipseGeometry CloneCurrentValue();
    private static void RadiusXPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void RadiusYPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void CenterPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public double get_RadiusX();
    public void set_RadiusX(double value);
    public double get_RadiusY();
    public void set_RadiusY(double value);
    public Point get_Center();
    public void set_Center(Point value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    internal virtual int get_EffectiveValuesInitialSize();
}
internal class System.Windows.Media.EventProxyDescriptor : ValueType {
    internal Dispose pfnDispose;
    internal RaiseEvent pfnRaiseEvent;
    internal GCHandle m_handle;
    internal static void StaticDispose(EventProxyDescriptor& pEPD);
}
internal static class System.Windows.Media.EventProxyStaticPtrs : object {
    internal static Dispose pfnDispose;
    internal static RaiseEvent pfnRaiseEvent;
    private static EventProxyStaticPtrs();
}
internal class System.Windows.Media.EventProxyWrapper : object {
    private WeakReference target;
    private EventProxyWrapper(IInvokable invokable);
    private void Verify();
    public int RaiseEvent(Byte[] buffer, UInt32 cb);
    internal static EventProxyWrapper FromEPD(EventProxyDescriptor& epd);
    internal static int RaiseEvent(EventProxyDescriptor& pEPD, Byte[] buffer, UInt32 cb);
    internal static SafeMILHandle CreateEventProxyWrapper(IInvokable invokable);
    private static int MILCreateEventProxy(EventProxyDescriptor& pEPD, SafeMILHandle& ppEventProxy);
}
public class System.Windows.Media.ExceptionEventArgs : EventArgs {
    private Exception _errorException;
    public Exception ErrorException { get; }
    internal ExceptionEventArgs(Exception errorException);
    public Exception get_ErrorException();
}
internal class System.Windows.Media.FactoryMaker : object {
    private bool _disposed;
    private static IntPtr s_pFactory;
    private static IntPtr s_pImagingFactory;
    private static int s_cInstance;
    private static object s_factoryMakerLock;
    private bool _fValidObject;
    internal IntPtr FactoryPtr { get; }
    internal IntPtr ImagingFactoryPtr { get; }
    private static FactoryMaker();
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool fDisposing);
    internal IntPtr get_FactoryPtr();
    internal IntPtr get_ImagingFactoryPtr();
}
public class System.Windows.Media.FamilyTypeface : object {
    private bool _readOnly;
    private FontStyle _style;
    private FontWeight _weight;
    private FontStretch _stretch;
    private double _underlinePosition;
    private double _underlineThickness;
    private double _strikeThroughPosition;
    private double _strikeThroughThickness;
    private double _capsHeight;
    private double _xHeight;
    private string _deviceFontName;
    private CharacterMetricsDictionary _characterMetrics;
    public FontStyle Style { get; public set; }
    public FontWeight Weight { get; public set; }
    public FontStretch Stretch { get; public set; }
    public double UnderlinePosition { get; public set; }
    public double UnderlineThickness { get; public set; }
    public double StrikethroughPosition { get; public set; }
    public double StrikethroughThickness { get; public set; }
    public double CapsHeight { get; public set; }
    public double XHeight { get; public set; }
    private bool MS.Internal.FontFace.ITypefaceMetrics.Symbol { get; }
    private StyleSimulations MS.Internal.FontFace.ITypefaceMetrics.StyleSimulations { get; }
    public IDictionary`2<XmlLanguage, string> AdjustedFaceNames { get; }
    public string DeviceFontName { get; public set; }
    [DesignerSerializationVisibilityAttribute("2")]
public CharacterMetricsDictionary DeviceFontCharacterMetrics { get; }
    private string MS.Internal.FontFace.IDeviceFont.Name { get; }
    internal FamilyTypeface(Typeface face);
    public FontStyle get_Style();
    public void set_Style(FontStyle value);
    public FontWeight get_Weight();
    public void set_Weight(FontWeight value);
    public FontStretch get_Stretch();
    public void set_Stretch(FontStretch value);
    public sealed virtual double get_UnderlinePosition();
    public void set_UnderlinePosition(double value);
    public sealed virtual double get_UnderlineThickness();
    public void set_UnderlineThickness(double value);
    public sealed virtual double get_StrikethroughPosition();
    public void set_StrikethroughPosition(double value);
    public sealed virtual double get_StrikethroughThickness();
    public void set_StrikethroughThickness(double value);
    public sealed virtual double get_CapsHeight();
    public void set_CapsHeight(double value);
    public sealed virtual double get_XHeight();
    public void set_XHeight(double value);
    private sealed virtual override bool MS.Internal.FontFace.ITypefaceMetrics.get_Symbol();
    private sealed virtual override StyleSimulations MS.Internal.FontFace.ITypefaceMetrics.get_StyleSimulations();
    public sealed virtual IDictionary`2<XmlLanguage, string> get_AdjustedFaceNames();
    public bool Equals(FamilyTypeface typeface);
    public string get_DeviceFontName();
    public void set_DeviceFontName(string value);
    public CharacterMetricsDictionary get_DeviceFontCharacterMetrics();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    private void VerifyChangeable();
    private sealed virtual override string MS.Internal.FontFace.IDeviceFont.get_Name();
    private sealed virtual override bool MS.Internal.FontFace.IDeviceFont.ContainsCharacter(int unicodeScalar);
    private sealed virtual override void MS.Internal.FontFace.IDeviceFont.GetAdvanceWidths(Char* characterString, int characterLength, double emSize, Int32* pAdvances);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.FamilyTypefaceCollection : object {
    private static int InitialCapacity;
    private ICollection`1<Typeface> _innerList;
    private FamilyTypeface[] _items;
    private int _count;
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public FamilyTypeface Item { get; public set; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    internal FamilyTypefaceCollection(ICollection`1<Typeface> innerList);
    public sealed virtual IEnumerator`1<FamilyTypeface> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(FamilyTypeface item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(FamilyTypeface item);
    public sealed virtual void CopyTo(FamilyTypeface[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual bool Remove(FamilyTypeface item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int IndexOf(FamilyTypeface item);
    public sealed virtual void Insert(int index, FamilyTypeface item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual FamilyTypeface get_Item(int index);
    public sealed virtual void set_Item(int index, FamilyTypeface value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object item);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private int InsertItem(int index, FamilyTypeface item);
    private void InitializeItemsFromInnerList();
    private FamilyTypeface GetItem(int index);
    private void SetItem(int index, FamilyTypeface item);
    private void ClearItems();
    private void RemoveItem(int index);
    private int FindItem(FamilyTypeface item);
    private void RangeCheck(int index);
    private void VerifyChangeable();
    private FamilyTypeface ConvertValue(object obj);
    private void CopyItems(Array array, int index);
}
public enum System.Windows.Media.FillRule : Enum {
    public int value__;
    public static FillRule EvenOdd;
    public static FillRule Nonzero;
}
public class System.Windows.Media.FontEmbeddingManager : object {
    private Dictionary`2<Uri, Dictionary`2<ushort, bool>> _collectedGlyphTypefaces;
    private static UriComparer _uriComparer;
    [CLSCompliantAttribute("False")]
public ICollection`1<Uri> GlyphTypefaceUris { get; }
    private static FontEmbeddingManager();
    public void RecordUsage(GlyphRun glyphRun);
    public ICollection`1<Uri> get_GlyphTypefaceUris();
    [CLSCompliantAttribute("False")]
public ICollection`1<ushort> GetUsedGlyphs(Uri glyphTypeface);
}
public enum System.Windows.Media.FontEmbeddingRight : Enum {
    public int value__;
    public static FontEmbeddingRight Installable;
    public static FontEmbeddingRight InstallableButNoSubsetting;
    public static FontEmbeddingRight InstallableButWithBitmapsOnly;
    public static FontEmbeddingRight InstallableButNoSubsettingAndWithBitmapsOnly;
    public static FontEmbeddingRight RestrictedLicense;
    public static FontEmbeddingRight PreviewAndPrint;
    public static FontEmbeddingRight PreviewAndPrintButNoSubsetting;
    public static FontEmbeddingRight PreviewAndPrintButWithBitmapsOnly;
    public static FontEmbeddingRight PreviewAndPrintButNoSubsettingAndWithBitmapsOnly;
    public static FontEmbeddingRight Editable;
    public static FontEmbeddingRight EditableButNoSubsetting;
    public static FontEmbeddingRight EditableButWithBitmapsOnly;
    public static FontEmbeddingRight EditableButNoSubsettingAndWithBitmapsOnly;
}
[TypeConverterAttribute("System.Windows.Media.FontFamilyConverter")]
[LocalizabilityAttribute("14")]
[ValueSerializerAttribute("System.Windows.Media.FontFamilyValueSerializer")]
public class System.Windows.Media.FontFamily : object {
    private FontFamilyIdentifier _familyIdentifier;
    private IFontFamily _firstFontFamily;
    internal static CanonicalFontFamilyReference NullFontFamilyCanonicalName;
    internal static string GlobalUI;
    internal static FontFamily FontFamilyGlobalUI;
    private static FamilyCollection modreq(System.Runtime.CompilerServices.IsVolatile) _defaultFamilyCollection;
    private static FontFamilyMapCollection _emptyFamilyMaps;
    [DesignerSerializationVisibilityAttribute("2")]
public LanguageSpecificStringDictionary FamilyNames { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public FamilyTypefaceCollection FamilyTypefaces { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public FontFamilyMapCollection FamilyMaps { get; }
    public string Source { get; }
    public Uri BaseUri { get; }
    internal FontFamilyIdentifier FamilyIdentifier { get; }
    public double Baseline { get; public set; }
    public double LineSpacing { get; public set; }
    internal IFontFamily FirstFontFamily { get; }
    public FontFamily(string familyName);
    public FontFamily(Uri baseUri, string familyName);
    internal FontFamily(FontFamilyIdentifier familyIdentifier);
    private static FontFamily();
    public LanguageSpecificStringDictionary get_FamilyNames();
    public FamilyTypefaceCollection get_FamilyTypefaces();
    public FontFamilyMapCollection get_FamilyMaps();
    public string get_Source();
    public Uri get_BaseUri();
    public virtual string ToString();
    internal FontFamilyIdentifier get_FamilyIdentifier();
    public double get_Baseline();
    public void set_Baseline(double value);
    public double get_LineSpacing();
    public void set_LineSpacing(double value);
    internal double GetLineSpacingForDisplayMode(double emSize, double pixelsPerDip);
    [CLSCompliantAttribute("False")]
public ICollection`1<Typeface> GetTypefaces();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    private CompositeFontFamily VerifyMutable();
    internal IFontFamily get_FirstFontFamily();
    internal static IFontFamily FindFontFamilyFromFriendlyNameList(string friendlyNameList);
    internal static IFontFamily SafeLookupFontFamily(CanonicalFontFamilyReference canonicalName, Boolean& nullFont);
    internal static IFontFamily LookupFontFamily(CanonicalFontFamilyReference canonicalName);
    private static FamilyCollection PreCreateDefaultFamilyCollection();
    internal IFontFamily FindFirstFontFamilyAndFace(FontStyle& style, FontWeight& weight, FontStretch& stretch);
    internal static IFontFamily LookupFontFamilyAndFace(CanonicalFontFamilyReference canonicalFamilyReference, FontStyle& style, FontWeight& weight, FontStretch& stretch);
}
public class System.Windows.Media.FontFamilyConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext td, Type t);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo cultureInfo, object o);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.FontFamilyMap : object {
    private Range[] _ranges;
    private XmlLanguage _language;
    private double _scaleInEm;
    private string _targetFamilyName;
    internal static int LastUnicodeScalar;
    private static Range[] _defaultRanges;
    internal static FontFamilyMap Default;
    [DesignerSerializationOptionsAttribute("1")]
public string Unicode { get; public set; }
    [DesignerSerializationOptionsAttribute("1")]
public string Target { get; public set; }
    public double Scale { get; public set; }
    public XmlLanguage Language { get; public set; }
    internal bool IsSimpleFamilyMap { get; }
    internal Range[] Ranges { get; }
    internal FontFamilyMap(int firstChar, int lastChar, XmlLanguage language, string targetFamilyName, double scaleInEm);
    private static FontFamilyMap();
    public void set_Unicode(string value);
    public string get_Unicode();
    public string get_Target();
    public void set_Target(string value);
    public double get_Scale();
    public void set_Scale(double value);
    public XmlLanguage get_Language();
    public void set_Language(XmlLanguage value);
    internal bool get_IsSimpleFamilyMap();
    internal static bool MatchLanguage(XmlLanguage familyMapLanguage, XmlLanguage language);
    internal static bool MatchCulture(XmlLanguage familyMapLanguage, CultureInfo culture);
    internal Range[] get_Ranges();
    private static void ThrowInvalidUnicodeRange();
    private static Range[] ParseUnicodeRanges(string unicodeRanges);
    internal static bool ParseHexNumber(string numString, Int32& index, Int32& number);
    internal bool InRange(int ch);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.FontFamilyMapCollection : object {
    private static int InitialCapacity;
    private CompositeFontInfo _fontInfo;
    private FontFamilyMap[] _items;
    private int _count;
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public FontFamilyMap Item { get; public set; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    internal FontFamilyMapCollection(CompositeFontInfo fontInfo);
    public sealed virtual IEnumerator`1<FontFamilyMap> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(FontFamilyMap item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(FontFamilyMap item);
    public sealed virtual void CopyTo(FontFamilyMap[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual bool Remove(FontFamilyMap item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int IndexOf(FontFamilyMap item);
    public sealed virtual void Insert(int index, FontFamilyMap item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual FontFamilyMap get_Item(int index);
    public sealed virtual void set_Item(int index, FontFamilyMap value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object item);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private int InsertItem(int index, FontFamilyMap item);
    private void SetItem(int index, FontFamilyMap item);
    private void ClearItems();
    private void RemoveItem(int index);
    private int FindItem(FontFamilyMap item);
    private void RangeCheck(int index);
    private void VerifyChangeable();
    private FontFamilyMap ConvertValue(object obj);
}
public class System.Windows.Media.FontFamilyValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public static class System.Windows.Media.Fonts : object {
    private static ICollection`1<FontFamily> _defaultFontCollection;
    public static ICollection`1<FontFamily> SystemFontFamilies { get; }
    public static ICollection`1<Typeface> SystemTypefaces { get; }
    private static Fonts();
    public static ICollection`1<FontFamily> GetFontFamilies(string location);
    public static ICollection`1<FontFamily> GetFontFamilies(Uri baseUri);
    public static ICollection`1<FontFamily> GetFontFamilies(Uri baseUri, string location);
    public static ICollection`1<Typeface> GetTypefaces(string location);
    public static ICollection`1<Typeface> GetTypefaces(Uri baseUri);
    public static ICollection`1<Typeface> GetTypefaces(Uri baseUri, string location);
    public static ICollection`1<FontFamily> get_SystemFontFamilies();
    public static ICollection`1<Typeface> get_SystemTypefaces();
    private static ICollection`1<FontFamily> CreateFamilyCollection(Uri fontLocation, Uri fontFamilyBaseUri, string fontFamilyLocationReference);
    private static ICollection`1<FontFamily> CreateDefaultFamilyCollection();
}
public class System.Windows.Media.FormattedText : object {
    private string _text;
    private double _pixelsPerDip;
    private SpanVector _formatRuns;
    private SpanPosition _latestPosition;
    private GenericTextParagraphProperties _defaultParaProps;
    private double _maxTextWidth;
    private Double[] _maxTextWidths;
    private double _maxTextHeight;
    private int _maxLineCount;
    private TextTrimming _trimming;
    private TextFormattingMode _textFormattingMode;
    private TextSourceImplementation _textSourceImpl;
    private CachedMetrics _metrics;
    private double _minWidth;
    private static double MaxFontEmSize;
    public string Text { get; }
    public double PixelsPerDip { get; public set; }
    public FlowDirection FlowDirection { get; public set; }
    public TextAlignment TextAlignment { get; public set; }
    public double LineHeight { get; public set; }
    public double MaxTextWidth { get; public set; }
    public double MaxTextHeight { get; public set; }
    public int MaxLineCount { get; public set; }
    public TextTrimming Trimming { get; public set; }
    private CachedMetrics Metrics { get; }
    private CachedMetrics BlackBoxMetrics { get; }
    public double Height { get; }
    public double Extent { get; }
    public double Baseline { get; }
    public double OverhangAfter { get; }
    public double OverhangLeading { get; }
    public double OverhangTrailing { get; }
    public double Width { get; }
    public double WidthIncludingTrailingWhitespace { get; }
    public double MinWidth { get; }
    [ObsoleteAttribute("Use the PixelsPerDip override", "False")]
public FormattedText(string textToFormat, CultureInfo culture, FlowDirection flowDirection, Typeface typeface, double emSize, Brush foreground);
    public FormattedText(string textToFormat, CultureInfo culture, FlowDirection flowDirection, Typeface typeface, double emSize, Brush foreground, double pixelsPerDip);
    [ObsoleteAttribute("Use the PixelsPerDip override", "False")]
public FormattedText(string textToFormat, CultureInfo culture, FlowDirection flowDirection, Typeface typeface, double emSize, Brush foreground, NumberSubstitution numberSubstitution);
    public FormattedText(string textToFormat, CultureInfo culture, FlowDirection flowDirection, Typeface typeface, double emSize, Brush foreground, NumberSubstitution numberSubstitution, double pixelsPerDip);
    [ObsoleteAttribute("Use the PixelsPerDip override", "False")]
public FormattedText(string textToFormat, CultureInfo culture, FlowDirection flowDirection, Typeface typeface, double emSize, Brush foreground, NumberSubstitution numberSubstitution, TextFormattingMode textFormattingMode);
    public FormattedText(string textToFormat, CultureInfo culture, FlowDirection flowDirection, Typeface typeface, double emSize, Brush foreground, NumberSubstitution numberSubstitution, TextFormattingMode textFormattingMode, double pixelsPerDip);
    private void InitFormattedText(string textToFormat, CultureInfo culture, FlowDirection flowDirection, Typeface typeface, double emSize, Brush foreground, NumberSubstitution numberSubstitution, TextFormattingMode textFormattingMode, double pixelsPerDip);
    public string get_Text();
    public double get_PixelsPerDip();
    public void set_PixelsPerDip(double value);
    private static void ValidateCulture(CultureInfo culture);
    private static void ValidateFontSize(double emSize);
    private static void ValidateFlowDirection(FlowDirection flowDirection, string parameterName);
    private int ValidateRange(int startIndex, int count);
    private void InvalidateMetrics();
    public void SetForegroundBrush(Brush foregroundBrush);
    public void SetForegroundBrush(Brush foregroundBrush, int startIndex, int count);
    public void SetFontFamily(string fontFamily);
    public void SetFontFamily(string fontFamily, int startIndex, int count);
    public void SetFontFamily(FontFamily fontFamily);
    public void SetFontFamily(FontFamily fontFamily, int startIndex, int count);
    public void SetFontSize(double emSize);
    public void SetFontSize(double emSize, int startIndex, int count);
    public void SetCulture(CultureInfo culture);
    public void SetCulture(CultureInfo culture, int startIndex, int count);
    public void SetNumberSubstitution(NumberSubstitution numberSubstitution);
    public void SetNumberSubstitution(NumberSubstitution numberSubstitution, int startIndex, int count);
    public void SetFontWeight(FontWeight weight);
    public void SetFontWeight(FontWeight weight, int startIndex, int count);
    public void SetFontStyle(FontStyle style);
    public void SetFontStyle(FontStyle style, int startIndex, int count);
    public void SetFontStretch(FontStretch stretch);
    public void SetFontStretch(FontStretch stretch, int startIndex, int count);
    public void SetFontTypeface(Typeface typeface);
    public void SetFontTypeface(Typeface typeface, int startIndex, int count);
    public void SetTextDecorations(TextDecorationCollection textDecorations);
    public void SetTextDecorations(TextDecorationCollection textDecorations, int startIndex, int count);
    private LineEnumerator GetEnumerator();
    private void AdvanceLineOrigin(Point& lineOrigin, TextLine currentLine);
    public void set_FlowDirection(FlowDirection value);
    public FlowDirection get_FlowDirection();
    public void set_TextAlignment(TextAlignment value);
    public TextAlignment get_TextAlignment();
    public void set_LineHeight(double value);
    public double get_LineHeight();
    public void set_MaxTextWidth(double value);
    public double get_MaxTextWidth();
    public void SetMaxTextWidths(Double[] maxTextWidths);
    public Double[] GetMaxTextWidths();
    public void set_MaxTextHeight(double value);
    public double get_MaxTextHeight();
    public void set_MaxLineCount(int value);
    public int get_MaxLineCount();
    public void set_Trimming(TextTrimming value);
    public TextTrimming get_Trimming();
    private CachedMetrics get_Metrics();
    private CachedMetrics get_BlackBoxMetrics();
    public double get_Height();
    public double get_Extent();
    public double get_Baseline();
    public double get_OverhangAfter();
    public double get_OverhangLeading();
    public double get_OverhangTrailing();
    public double get_Width();
    public double get_WidthIncludingTrailingWhitespace();
    public double get_MinWidth();
    public Geometry BuildHighlightGeometry(Point origin);
    public Geometry BuildGeometry(Point origin);
    public Geometry BuildHighlightGeometry(Point origin, int startIndex, int count);
    internal void Draw(DrawingContext dc, Point origin);
    private CachedMetrics DrawAndCalculateMetrics(DrawingContext dc, Point drawingOffset, bool getBlackBoxMetrics);
    private void CombineGeometryRecursive(Drawing drawing, GeometryGroup& accumulatedGeometry);
}
[LocalizabilityAttribute("0")]
public abstract class System.Windows.Media.GeneralTransform : Animatable {
    public GeneralTransform Inverse { get; }
    internal Transform AffineTransform { get; }
    public abstract virtual bool TryTransform(Point inPoint, Point& result);
    public Point Transform(Point point);
    public abstract virtual Rect TransformBounds(Rect rect);
    public abstract virtual GeneralTransform get_Inverse();
    [FriendAccessAllowedAttribute]
internal virtual Transform get_AffineTransform();
    public GeneralTransform Clone();
    public GeneralTransform CloneCurrentValue();
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal virtual string ConvertToString(string format, IFormatProvider provider);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.GeneralTransformCollection : Animatable {
    private static GeneralTransformCollection s_empty;
    internal FrugalStructList`1<GeneralTransform> _collection;
    internal UInt32 _version;
    public GeneralTransform Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.GeneralTransform>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal static GeneralTransformCollection Empty { get; }
    public GeneralTransformCollection(int capacity);
    public GeneralTransformCollection(IEnumerable`1<GeneralTransform> collection);
    public GeneralTransformCollection Clone();
    public GeneralTransformCollection CloneCurrentValue();
    public sealed virtual void Add(GeneralTransform value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(GeneralTransform value);
    public sealed virtual int IndexOf(GeneralTransform value);
    public sealed virtual void Insert(int index, GeneralTransform value);
    public sealed virtual bool Remove(GeneralTransform value);
    public sealed virtual void RemoveAt(int index);
    internal void RemoveAtWithoutFiringPublicEvents(int index);
    public sealed virtual GeneralTransform get_Item(int index);
    public sealed virtual void set_Item(int index, GeneralTransform value);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(GeneralTransform[] array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.GeneralTransform>.get_IsReadOnly();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<GeneralTransform> System.Collections.Generic.IEnumerable<System.Windows.Media.GeneralTransform>.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal static GeneralTransformCollection get_Empty();
    internal GeneralTransform Internal_GetItem(int i);
    internal virtual void OnInheritanceContextChangedCore(EventArgs args);
    private GeneralTransform Cast(object value);
    private int AddHelper(GeneralTransform value);
    internal int AddWithoutFiringPublicEvents(GeneralTransform value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected virtual bool FreezeCore(bool isChecking);
}
[LocalizabilityAttribute("0")]
[ContentPropertyAttribute("Children")]
public class System.Windows.Media.GeneralTransformGroup : GeneralTransform {
    public static DependencyProperty ChildrenProperty;
    internal static GeneralTransformCollection s_Children;
    public GeneralTransform Inverse { get; }
    internal Transform AffineTransform { get; }
    public GeneralTransformCollection Children { get; public set; }
    private static GeneralTransformGroup();
    public virtual bool TryTransform(Point inPoint, Point& result);
    public virtual Rect TransformBounds(Rect rect);
    public virtual GeneralTransform get_Inverse();
    [FriendAccessAllowedAttribute]
internal virtual Transform get_AffineTransform();
    public GeneralTransformGroup Clone();
    public GeneralTransformGroup CloneCurrentValue();
    public GeneralTransformCollection get_Children();
    public void set_Children(GeneralTransformCollection value);
    protected virtual Freezable CreateInstanceCore();
}
[TypeConverterAttribute("System.Windows.Media.GeometryConverter")]
[ValueSerializerAttribute("System.Windows.Media.Converters.GeometryValueSerializer")]
[LocalizabilityAttribute("0")]
public abstract class System.Windows.Media.Geometry : Animatable {
    private static double c_tolerance;
    private static Geometry s_empty;
    private static PathGeometryData s_emptyPathGeometryData;
    public static DependencyProperty TransformProperty;
    internal static Transform s_Transform;
    public static Geometry Empty { get; }
    public Rect Bounds { get; }
    public static double StandardFlatteningTolerance { get; }
    public Transform Transform { get; public set; }
    private static Geometry();
    public static Geometry get_Empty();
    public virtual Rect get_Bounds();
    public static double get_StandardFlatteningTolerance();
    public virtual Rect GetRenderBounds(Pen pen, double tolerance, ToleranceType type);
    public Rect GetRenderBounds(Pen pen);
    internal virtual bool AreClose(Geometry geometry);
    internal virtual Rect GetBoundsInternal(Pen pen, Matrix matrix, double tolerance, ToleranceType type);
    internal Rect GetBoundsInternal(Pen pen, Matrix matrix);
    internal static Rect GetBoundsHelper(Pen pen, Matrix* pWorldMatrix, Point* pPoints, Byte* pTypes, UInt32 pointCount, UInt32 segmentCount, Matrix* pGeometryMatrix, double tolerance, ToleranceType type, bool fSkipHollows);
    internal virtual void TransformPropertyChangedHook(DependencyPropertyChangedEventArgs e);
    internal Geometry GetTransformedCopy(Transform transform);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeTransform();
    public virtual double GetArea(double tolerance, ToleranceType type);
    public double GetArea();
    public abstract virtual bool IsEmpty();
    public abstract virtual bool MayHaveCurves();
    public bool FillContains(Point hitPoint, double tolerance, ToleranceType type);
    public bool FillContains(Point hitPoint);
    public bool StrokeContains(Pen pen, Point hitPoint, double tolerance, ToleranceType type);
    internal virtual bool ContainsInternal(Pen pen, Point hitPoint, double tolerance, ToleranceType type);
    internal bool ContainsInternal(Pen pen, Point hitPoint, double tolerance, ToleranceType type, Point* pPoints, UInt32 pointCount, Byte* pTypes, UInt32 typeCount);
    public bool StrokeContains(Pen pen, Point hitPoint);
    public bool FillContains(Geometry geometry, double tolerance, ToleranceType type);
    public bool FillContains(Geometry geometry);
    public virtual IntersectionDetail FillContainsWithDetail(Geometry geometry, double tolerance, ToleranceType type);
    public IntersectionDetail FillContainsWithDetail(Geometry geometry);
    public IntersectionDetail StrokeContainsWithDetail(Pen pen, Geometry geometry, double tolerance, ToleranceType type);
    public IntersectionDetail StrokeContainsWithDetail(Pen pen, Geometry geometry);
    public virtual PathGeometry GetFlattenedPathGeometry(double tolerance, ToleranceType type);
    public PathGeometry GetFlattenedPathGeometry();
    public virtual PathGeometry GetWidenedPathGeometry(Pen pen, double tolerance, ToleranceType type);
    public PathGeometry GetWidenedPathGeometry(Pen pen);
    public static PathGeometry Combine(Geometry geometry1, Geometry geometry2, GeometryCombineMode mode, Transform transform, double tolerance, ToleranceType type);
    public static PathGeometry Combine(Geometry geometry1, Geometry geometry2, GeometryCombineMode mode, Transform transform);
    public virtual PathGeometry GetOutlinedPathGeometry(double tolerance, ToleranceType type);
    public PathGeometry GetOutlinedPathGeometry();
    internal abstract virtual PathGeometry GetAsPathGeometry();
    internal abstract virtual PathGeometryData GetPathGeometryData();
    internal PathFigureCollection GetPathFigureCollection();
    internal Matrix GetCombinedMatrix(Transform transform);
    internal abstract virtual PathFigureCollection GetTransformedFigureCollection(Transform transform);
    internal virtual bool IsObviouslyEmpty();
    internal virtual bool CanSerializeToString();
    internal static PathGeometryData GetEmptyPathGeometryData();
    private static PathGeometryData MakeEmptyPathGeometryData();
    private static Geometry MakeEmptyGeometry();
    public Geometry Clone();
    public Geometry CloneCurrentValue();
    private static void TransformPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Transform get_Transform();
    public void set_Transform(Transform value);
    internal abstract virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    internal abstract virtual void ReleaseOnChannelCore(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    internal abstract virtual ResourceHandle GetHandleCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    internal abstract virtual int GetChannelCountCore();
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    internal abstract virtual Channel GetChannelCore(int index);
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal virtual string ConvertToString(string format, IFormatProvider provider);
    public static Geometry Parse(string source);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.GeometryCollection : Animatable {
    [CompilerGeneratedAttribute]
private ItemInsertedHandler ItemInserted;
    [CompilerGeneratedAttribute]
private ItemRemovedHandler ItemRemoved;
    private static GeometryCollection s_empty;
    internal FrugalStructList`1<Geometry> _collection;
    internal UInt32 _version;
    public Geometry Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.Geometry>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal static GeometryCollection Empty { get; }
    public GeometryCollection(int capacity);
    public GeometryCollection(IEnumerable`1<Geometry> collection);
    public GeometryCollection Clone();
    public GeometryCollection CloneCurrentValue();
    public sealed virtual void Add(Geometry value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Geometry value);
    public sealed virtual int IndexOf(Geometry value);
    public sealed virtual void Insert(int index, Geometry value);
    public sealed virtual bool Remove(Geometry value);
    public sealed virtual void RemoveAt(int index);
    internal void RemoveAtWithoutFiringPublicEvents(int index);
    public sealed virtual Geometry get_Item(int index);
    public sealed virtual void set_Item(int index, Geometry value);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(Geometry[] array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.Geometry>.get_IsReadOnly();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<Geometry> System.Collections.Generic.IEnumerable<System.Windows.Media.Geometry>.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal static GeometryCollection get_Empty();
    internal Geometry Internal_GetItem(int i);
    internal virtual void OnInheritanceContextChangedCore(EventArgs args);
    private Geometry Cast(object value);
    private int AddHelper(Geometry value);
    internal int AddWithoutFiringPublicEvents(Geometry value);
    [CompilerGeneratedAttribute]
internal void add_ItemInserted(ItemInsertedHandler value);
    [CompilerGeneratedAttribute]
internal void remove_ItemInserted(ItemInsertedHandler value);
    [CompilerGeneratedAttribute]
internal void add_ItemRemoved(ItemRemovedHandler value);
    [CompilerGeneratedAttribute]
internal void remove_ItemRemoved(ItemRemovedHandler value);
    private void OnInsert(object item);
    private void OnRemove(object oldValue);
    private void OnSet(object oldValue, object newValue);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected virtual bool FreezeCore(bool isChecking);
}
public enum System.Windows.Media.GeometryCombineMode : Enum {
    public int value__;
    public static GeometryCombineMode Union;
    public static GeometryCombineMode Intersect;
    public static GeometryCombineMode Xor;
    public static GeometryCombineMode Exclude;
}
public class System.Windows.Media.GeometryConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.GeometryDrawing : Drawing {
    public static DependencyProperty BrushProperty;
    public static DependencyProperty PenProperty;
    public static DependencyProperty GeometryProperty;
    internal MultiChannelResource _duceResource;
    public Brush Brush { get; public set; }
    public Pen Pen { get; public set; }
    public Geometry Geometry { get; public set; }
    public GeometryDrawing(Brush brush, Pen pen, Geometry geometry);
    private static GeometryDrawing();
    internal virtual void WalkCurrentValue(DrawingContextWalker ctx);
    public GeometryDrawing Clone();
    public GeometryDrawing CloneCurrentValue();
    private static void BrushPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void PenPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void GeometryPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Brush get_Brush();
    public void set_Brush(Brush value);
    public Pen get_Pen();
    public void set_Pen(Pen value);
    public Geometry get_Geometry();
    public void set_Geometry(Geometry value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
}
[ContentPropertyAttribute("Children")]
public class System.Windows.Media.GeometryGroup : Geometry {
    public static DependencyProperty FillRuleProperty;
    public static DependencyProperty ChildrenProperty;
    internal MultiChannelResource _duceResource;
    internal static FillRule c_FillRule;
    internal static GeometryCollection s_Children;
    public FillRule FillRule { get; public set; }
    public GeometryCollection Children { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    private static GeometryGroup();
    internal virtual PathGeometryData GetPathGeometryData();
    internal virtual PathGeometry GetAsPathGeometry();
    internal virtual PathFigureCollection GetTransformedFigureCollection(Transform transform);
    public virtual bool IsEmpty();
    internal virtual bool IsObviouslyEmpty();
    public virtual bool MayHaveCurves();
    public GeometryGroup Clone();
    public GeometryGroup CloneCurrentValue();
    private static void FillRulePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void ChildrenPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public FillRule get_FillRule();
    public void set_FillRule(FillRule value);
    public GeometryCollection get_Children();
    public void set_Children(GeometryCollection value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    private void ChildrenItemInserted(object sender, object item);
    private void ChildrenItemRemoved(object sender, object item);
    internal virtual int get_EffectiveValuesInitialSize();
}
public class System.Windows.Media.GeometryHitTestParameters : HitTestParameters {
    private PathGeometry _hitGeometryInternal;
    private Geometry _hitGeometryCache;
    private Rect _origBounds;
    private Rect _bounds;
    private MatrixStack _matrixStack;
    public Geometry HitGeometry { get; }
    internal PathGeometry InternalHitGeometry { get; }
    internal Rect Bounds { get; }
    public GeometryHitTestParameters(Geometry geometry);
    public Geometry get_HitGeometry();
    internal PathGeometry get_InternalHitGeometry();
    internal Rect get_Bounds();
    internal void PushMatrix(Matrix& newMatrix);
    internal void PopMatrix();
    internal void EmergencyRestoreOriginalTransform();
    private void ClearHitGeometryCache();
}
public class System.Windows.Media.GeometryHitTestResult : HitTestResult {
    private IntersectionDetail _intersectionDetail;
    public IntersectionDetail IntersectionDetail { get; }
    public Visual VisualHit { get; }
    public GeometryHitTestResult(Visual visualHit, IntersectionDetail intersectionDetail);
    public IntersectionDetail get_IntersectionDetail();
    public Visual get_VisualHit();
}
public class System.Windows.Media.GlyphRun : object {
    private MultiChannelResource _mcr;
    private Point _baselineOrigin;
    private GlyphRunFlags _flags;
    private double _renderingEmSize;
    private IList`1<ushort> _glyphIndices;
    private IList`1<double> _advanceWidths;
    private IList`1<Point> _glyphOffsets;
    private int _bidiLevel;
    private GlyphTypeface _glyphTypeface;
    private IList`1<char> _characters;
    private IList`1<ushort> _clusterMap;
    private IList`1<bool> _caretStops;
    private XmlLanguage _language;
    private string _deviceFontName;
    private object _inkBoundingBox;
    private TextFormattingMode _textFormattingMode;
    private float _pixelsPerDip;
    private static double Sin20;
    private static double InkMetricsEpsilon;
    private static double DefaultFontHintingSize;
    internal static double RelativeFlatteningTolerance;
    internal static int MaxGlyphCount;
    internal static int MaxStackAlloc;
    public float PixelsPerDip { get; public set; }
    private double AdvanceWidth { get; }
    private double Ascent { get; }
    private double Height { get; }
    public Point BaselineOrigin { get; public set; }
    public double FontRenderingEmSize { get; public set; }
    public GlyphTypeface GlyphTypeface { get; public set; }
    public int BidiLevel { get; public set; }
    private bool IsLeftToRight { get; }
    public bool IsSideways { get; public set; }
    [CLSCompliantAttribute("False")]
[TypeConverterAttribute("System.Windows.Media.Converters.BoolIListConverter")]
public IList`1<bool> CaretStops { get; public set; }
    public bool IsHitTestable { get; }
    [TypeConverterAttribute("System.Windows.Media.Converters.UShortIListConverter")]
[CLSCompliantAttribute("False")]
public IList`1<ushort> ClusterMap { get; public set; }
    [TypeConverterAttribute("System.Windows.Media.Converters.CharIListConverter")]
[CLSCompliantAttribute("False")]
public IList`1<char> Characters { get; public set; }
    [TypeConverterAttribute("System.Windows.Media.Converters.UShortIListConverter")]
[CLSCompliantAttribute("False")]
public IList`1<ushort> GlyphIndices { get; public set; }
    [CLSCompliantAttribute("False")]
[TypeConverterAttribute("System.Windows.Media.Converters.DoubleIListConverter")]
public IList`1<double> AdvanceWidths { get; public set; }
    [TypeConverterAttribute("System.Windows.Media.Converters.PointIListConverter")]
[CLSCompliantAttribute("False")]
public IList`1<Point> GlyphOffsets { get; public set; }
    public XmlLanguage Language { get; public set; }
    public string DeviceFontName { get; public set; }
    internal int GlyphCount { get; }
    internal int CodepointCount { get; }
    private bool IsInitializing { get; private set; }
    private bool IsInitialized { get; private set; }
    public GlyphRun(float pixelsPerDip);
    [CLSCompliantAttribute("False")]
public GlyphRun(GlyphTypeface glyphTypeface, int bidiLevel, bool isSideways, double renderingEmSize, float pixelsPerDip, IList`1<ushort> glyphIndices, Point baselineOrigin, IList`1<double> advanceWidths, IList`1<Point> glyphOffsets, IList`1<char> characters, string deviceFontName, IList`1<ushort> clusterMap, IList`1<bool> caretStops, XmlLanguage language);
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute("Use the PixelsPerDip override", "False")]
public GlyphRun(GlyphTypeface glyphTypeface, int bidiLevel, bool isSideways, double renderingEmSize, IList`1<ushort> glyphIndices, Point baselineOrigin, IList`1<double> advanceWidths, IList`1<Point> glyphOffsets, IList`1<char> characters, string deviceFontName, IList`1<ushort> clusterMap, IList`1<bool> caretStops, XmlLanguage language);
    private static GlyphRun();
    internal static GlyphRun TryCreate(GlyphTypeface glyphTypeface, int bidiLevel, bool isSideways, double renderingEmSize, float pixelsPerDip, IList`1<ushort> glyphIndices, Point baselineOrigin, IList`1<double> advanceWidths, IList`1<Point> glyphOffsets, IList`1<char> characters, string deviceFontName, IList`1<ushort> clusterMap, IList`1<bool> caretStops, XmlLanguage language, TextFormattingMode textLayout);
    private void Initialize(GlyphTypeface glyphTypeface, int bidiLevel, bool isSideways, double renderingEmSize, float pixelsPerDip, IList`1<ushort> glyphIndices, Point baselineOrigin, IList`1<double> advanceWidths, IList`1<Point> glyphOffsets, IList`1<char> characters, string deviceFontName, IList`1<ushort> clusterMap, IList`1<bool> caretStops, XmlLanguage language, TextFormattingMode textFormattingMode);
    public double GetDistanceFromCaretCharacterHit(CharacterHit characterHit);
    public CharacterHit GetCaretCharacterHitFromDistance(double distance, Boolean& isInside);
    public CharacterHit GetNextCaretCharacterHit(CharacterHit characterHit);
    public CharacterHit GetPreviousCaretCharacterHit(CharacterHit characterHit);
    public float get_PixelsPerDip();
    public void set_PixelsPerDip(float value);
    private double get_AdvanceWidth();
    private double get_Ascent();
    private double get_Height();
    public Point get_BaselineOrigin();
    public void set_BaselineOrigin(Point value);
    public double get_FontRenderingEmSize();
    public void set_FontRenderingEmSize(double value);
    public GlyphTypeface get_GlyphTypeface();
    public void set_GlyphTypeface(GlyphTypeface value);
    public int get_BidiLevel();
    public void set_BidiLevel(int value);
    private bool get_IsLeftToRight();
    public bool get_IsSideways();
    public void set_IsSideways(bool value);
    public IList`1<bool> get_CaretStops();
    public void set_CaretStops(IList`1<bool> value);
    public bool get_IsHitTestable();
    public IList`1<ushort> get_ClusterMap();
    public void set_ClusterMap(IList`1<ushort> value);
    public IList`1<char> get_Characters();
    public void set_Characters(IList`1<char> value);
    public IList`1<ushort> get_GlyphIndices();
    public void set_GlyphIndices(IList`1<ushort> value);
    public IList`1<double> get_AdvanceWidths();
    public void set_AdvanceWidths(IList`1<double> value);
    public IList`1<Point> get_GlyphOffsets();
    public void set_GlyphOffsets(IList`1<Point> value);
    public XmlLanguage get_Language();
    public void set_Language(XmlLanguage value);
    public string get_DeviceFontName();
    public void set_DeviceFontName(string value);
    internal Point GetGlyphOffset(int i);
    internal int get_GlyphCount();
    internal int get_CodepointCount();
    public Rect ComputeInkBoundingBox();
    private double AdjustAdvanceForDisplayLayout(double advance, double oneSideBearing, double otherSideBearing);
    private Rect ComputeInkBoundingBoxLtoR(GlyphMetrics[] glyphMetrics);
    public Geometry BuildGeometry();
    public Rect ComputeAlignmentBox();
    internal void EmitBackground(DrawingContext dc, Brush backgroundBrush);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.RemoveChildFromParent(IResource parent, Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.Get3DHandle(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
    private void CreateOnChannel(Channel channel);
    private ushort ComposeFlags();
    private void FindNearestCaretStop(int characterIndex, IList`1<bool> caretStops, Int32& caretStopIndex, Int32& codePointsUntilNextStop);
    private sealed virtual override void System.ComponentModel.ISupportInitialize.BeginInit();
    private sealed virtual override void System.ComponentModel.ISupportInitialize.EndInit();
    private void CheckInitialized();
    private void CheckInitializing();
    private bool get_IsInitializing();
    private void set_IsInitializing(bool value);
    private bool get_IsInitialized();
    private void set_IsInitialized(bool value);
}
public class System.Windows.Media.GlyphRunDrawing : Drawing {
    public static DependencyProperty GlyphRunProperty;
    public static DependencyProperty ForegroundBrushProperty;
    internal MultiChannelResource _duceResource;
    public GlyphRun GlyphRun { get; public set; }
    public Brush ForegroundBrush { get; public set; }
    public GlyphRunDrawing(Brush foregroundBrush, GlyphRun glyphRun);
    private static GlyphRunDrawing();
    internal virtual void WalkCurrentValue(DrawingContextWalker ctx);
    public GlyphRunDrawing Clone();
    public GlyphRunDrawing CloneCurrentValue();
    private static void GlyphRunPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void ForegroundBrushPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public GlyphRun get_GlyphRun();
    public void set_GlyphRun(GlyphRun value);
    public Brush get_ForegroundBrush();
    public void set_ForegroundBrush(Brush value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
}
[FriendAccessAllowedAttribute]
internal class System.Windows.Media.GlyphsSerializer : object {
    private GlyphTypeface _glyphTypeface;
    private IList`1<char> _characters;
    private double _milToEm;
    private bool _sideways;
    private int _glyphClusterInitialOffset;
    private IList`1<ushort> _clusters;
    private IList`1<ushort> _indices;
    private IList`1<double> _advances;
    private IList`1<Point> _offsets;
    private IList`1<bool> _caretStops;
    private StringBuilder _indicesStringBuider;
    private StringBuilder _glyphStringBuider;
    private static char GlyphSubEntrySeparator;
    private static char GlyphSeparator;
    private static double EmScaleFactor;
    public GlyphsSerializer(GlyphRun glyphRun);
    public void ComputeContentStrings(String& characters, String& indices, String& caretStops);
    private void RemoveTrailingCharacters(StringBuilder sb, char trailingCharacter);
    private void AddGlyph(int glyph, int sourceCharacter);
    private void AddCluster(int glyphClusterStart, int glyphClusterEnd, int charClusterStart, int charClusterEnd);
    private string CreateCaretStopsString();
}
public class System.Windows.Media.GlyphTypeface : object {
    private FontFaceLayoutInfo _fontFace;
    private StyleSimulations _styleSimulations;
    private Font _font;
    private FontSource _fontSource;
    private SecurityCriticalDataClass`1<Uri> _originalUri;
    private static double CFFConversionFactor;
    private InitializationState _initializationState;
    public Uri FontUri { get; public set; }
    public IDictionary`2<CultureInfo, string> FamilyNames { get; }
    public IDictionary`2<CultureInfo, string> FaceNames { get; }
    public IDictionary`2<CultureInfo, string> Win32FamilyNames { get; }
    private IDictionary`2<XmlLanguage, string> MS.Internal.FontFace.ITypefaceMetrics.AdjustedFaceNames { get; }
    public IDictionary`2<CultureInfo, string> Win32FaceNames { get; }
    public IDictionary`2<CultureInfo, string> VersionStrings { get; }
    public IDictionary`2<CultureInfo, string> Copyrights { get; }
    public IDictionary`2<CultureInfo, string> ManufacturerNames { get; }
    public IDictionary`2<CultureInfo, string> Trademarks { get; }
    public IDictionary`2<CultureInfo, string> DesignerNames { get; }
    public IDictionary`2<CultureInfo, string> Descriptions { get; }
    public IDictionary`2<CultureInfo, string> VendorUrls { get; }
    public IDictionary`2<CultureInfo, string> DesignerUrls { get; }
    public IDictionary`2<CultureInfo, string> LicenseDescriptions { get; }
    public IDictionary`2<CultureInfo, string> SampleTexts { get; }
    public FontStyle Style { get; }
    public FontWeight Weight { get; }
    public FontStretch Stretch { get; }
    public double Version { get; }
    public double Height { get; }
    public double Baseline { get; }
    public double CapsHeight { get; }
    public double XHeight { get; }
    public bool Symbol { get; }
    public double UnderlinePosition { get; }
    public double UnderlineThickness { get; }
    public double StrikethroughPosition { get; }
    public double StrikethroughThickness { get; }
    public FontEmbeddingRight EmbeddingRights { get; }
    private double MS.Internal.FontFace.ITypefaceMetrics.CapsHeight { get; }
    private double MS.Internal.FontFace.ITypefaceMetrics.XHeight { get; }
    private bool MS.Internal.FontFace.ITypefaceMetrics.Symbol { get; }
    private double MS.Internal.FontFace.ITypefaceMetrics.UnderlinePosition { get; }
    private double MS.Internal.FontFace.ITypefaceMetrics.UnderlineThickness { get; }
    private double MS.Internal.FontFace.ITypefaceMetrics.StrikethroughPosition { get; }
    private double MS.Internal.FontFace.ITypefaceMetrics.StrikethroughThickness { get; }
    public IDictionary`2<ushort, double> AdvanceWidths { get; }
    public IDictionary`2<ushort, double> AdvanceHeights { get; }
    public IDictionary`2<ushort, double> LeftSideBearings { get; }
    public IDictionary`2<ushort, double> RightSideBearings { get; }
    public IDictionary`2<ushort, double> TopSideBearings { get; }
    public IDictionary`2<ushort, double> BottomSideBearings { get; }
    public IDictionary`2<ushort, double> DistancesFromHorizontalBaselineToBlackBoxBottom { get; }
    public IDictionary`2<int, ushort> CharacterToGlyphMap { get; }
    public StyleSimulations StyleSimulations { get; public set; }
    public int GlyphCount { get; }
    internal Font FontDWrite { get; }
    internal FontSource FontSource { get; }
    internal int FaceIndex { get; }
    internal FontFaceLayoutInfo FontFaceLayoutInfo { get; }
    internal ushort BlankGlyphIndex { get; }
    internal FontTechnology FontTechnology { get; }
    internal ushort DesignEmHeight { get; }
    internal IntPtr GetDWriteFontAddRef { get; }
    public GlyphTypeface(Uri typefaceSource);
    public GlyphTypeface(Uri typefaceSource, StyleSimulations styleSimulations);
    internal GlyphTypeface(Font font);
    private void Initialize(Uri typefaceSource, StyleSimulations styleSimulations);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    [CLSCompliantAttribute("False")]
public Geometry GetGlyphOutline(ushort glyphIndex, double renderingEmSize, double hintingEmSize);
    [CLSCompliantAttribute("False")]
public Byte[] ComputeSubset(ICollection`1<ushort> glyphs);
    public Stream GetFontStream();
    public Uri get_FontUri();
    public void set_FontUri(Uri value);
    public IDictionary`2<CultureInfo, string> get_FamilyNames();
    public IDictionary`2<CultureInfo, string> get_FaceNames();
    public IDictionary`2<CultureInfo, string> get_Win32FamilyNames();
    private sealed virtual override IDictionary`2<XmlLanguage, string> MS.Internal.FontFace.ITypefaceMetrics.get_AdjustedFaceNames();
    public IDictionary`2<CultureInfo, string> get_Win32FaceNames();
    public IDictionary`2<CultureInfo, string> get_VersionStrings();
    public IDictionary`2<CultureInfo, string> get_Copyrights();
    public IDictionary`2<CultureInfo, string> get_ManufacturerNames();
    public IDictionary`2<CultureInfo, string> get_Trademarks();
    public IDictionary`2<CultureInfo, string> get_DesignerNames();
    public IDictionary`2<CultureInfo, string> get_Descriptions();
    public IDictionary`2<CultureInfo, string> get_VendorUrls();
    public IDictionary`2<CultureInfo, string> get_DesignerUrls();
    public IDictionary`2<CultureInfo, string> get_LicenseDescriptions();
    public IDictionary`2<CultureInfo, string> get_SampleTexts();
    public FontStyle get_Style();
    public FontWeight get_Weight();
    public FontStretch get_Stretch();
    public double get_Version();
    public double get_Height();
    public double get_Baseline();
    public double get_CapsHeight();
    public double get_XHeight();
    public bool get_Symbol();
    public double get_UnderlinePosition();
    public double get_UnderlineThickness();
    public double get_StrikethroughPosition();
    public double get_StrikethroughThickness();
    public FontEmbeddingRight get_EmbeddingRights();
    private sealed virtual override double MS.Internal.FontFace.ITypefaceMetrics.get_CapsHeight();
    private sealed virtual override double MS.Internal.FontFace.ITypefaceMetrics.get_XHeight();
    private sealed virtual override bool MS.Internal.FontFace.ITypefaceMetrics.get_Symbol();
    private sealed virtual override double MS.Internal.FontFace.ITypefaceMetrics.get_UnderlinePosition();
    private sealed virtual override double MS.Internal.FontFace.ITypefaceMetrics.get_UnderlineThickness();
    private sealed virtual override double MS.Internal.FontFace.ITypefaceMetrics.get_StrikethroughPosition();
    private sealed virtual override double MS.Internal.FontFace.ITypefaceMetrics.get_StrikethroughThickness();
    public IDictionary`2<ushort, double> get_AdvanceWidths();
    public IDictionary`2<ushort, double> get_AdvanceHeights();
    public IDictionary`2<ushort, double> get_LeftSideBearings();
    public IDictionary`2<ushort, double> get_RightSideBearings();
    public IDictionary`2<ushort, double> get_TopSideBearings();
    public IDictionary`2<ushort, double> get_BottomSideBearings();
    public IDictionary`2<ushort, double> get_DistancesFromHorizontalBaselineToBlackBoxBottom();
    public IDictionary`2<int, ushort> get_CharacterToGlyphMap();
    public sealed virtual StyleSimulations get_StyleSimulations();
    public void set_StyleSimulations(StyleSimulations value);
    public int get_GlyphCount();
    internal bool HasCharacter(UInt32 unicodeValue);
    internal Font get_FontDWrite();
    internal double GetAdvanceWidth(ushort glyph, float pixelsPerDip, TextFormattingMode textFormattingMode, bool isSideways);
    private double GetAdvanceHeight(ushort glyph, float pixelsPerDip, TextFormattingMode textFormattingMode, bool isSideways);
    private GlyphMetrics GlyphMetrics(ushort glyphIndex, double emSize, float pixelsPerDip, TextFormattingMode textFormattingMode, bool isSideways);
    private void GlyphMetrics(UInt16* pGlyphIndices, int characterCount, GlyphMetrics* pGlyphMetrics, double emSize, float pixelsPerDip, TextFormattingMode textFormattingMode, bool isSideways);
    private double GetLeftSidebearing(ushort glyph, float pixelsPerDip, TextFormattingMode textFormattingMode, bool isSideways);
    private double GetRightSidebearing(ushort glyph, float pixelsPerDip, TextFormattingMode textFormattingMode, bool isSideways);
    private double GetTopSidebearing(ushort glyph, float pixelsPerDip, TextFormattingMode textFormattingMode, bool isSideways);
    private double GetBottomSidebearing(ushort glyph, float pixelsPerDip, TextFormattingMode textFormattingMode, bool isSideways);
    private double GetBaseline(ushort glyph, float pixelsPerDip, TextFormattingMode textFormattingMode, bool isSideways);
    internal static double BaselineHelper(GlyphMetrics metrics);
    internal void GetGlyphMetrics(ushort glyph, double renderingEmSize, double scalingFactor, float pixelsPerDip, TextFormattingMode textFormattingMode, bool isSideways, Double& aw, Double& ah, Double& lsb, Double& rsb, Double& tsb, Double& bsb, Double& baseline);
    internal void GetGlyphMetrics(UInt16[] glyphs, int glyphsLength, double renderingEmSize, float pixelsPerDip, TextFormattingMode textFormattingMode, bool isSideways, GlyphMetrics[] glyphMetrics);
    internal Geometry ComputeGlyphOutline(ushort glyphIndex, bool sideways, double renderingEmSize);
    internal void GetAdvanceWidthsUnshaped(Char* unsafeCharString, int stringLength, double emSize, float pixelsPerDip, double scalingFactor, Int32* advanceWidthsUnshaped, bool nullFont, TextFormattingMode textFormattingMode, bool isSideways);
    internal GlyphRun ComputeUnshapedGlyphRun(Point origin, CharacterBufferRange charBufferRange, IList`1<double> charWidths, double emSize, float pixelsPerDip, double emHintingSize, bool nullGlyph, CultureInfo cultureInfo, string deviceFontName, TextFormattingMode textFormattingMode);
    internal void GetGlyphIndicesOptimized(CharacterBufferRange characters, UInt16[] glyphIndices, float pixelsPerDip);
    internal void GetGlyphMetricsOptimized(CharacterBufferRange characters, double emSize, float pixelsPerDip, TextFormattingMode textFormattingMode, bool isSideways, GlyphMetrics[] glyphMetrics);
    internal void GetGlyphMetricsOptimized(CharacterBufferRange characters, double emSize, float pixelsPerDip, UInt16[] glyphIndices, GlyphMetrics[] glyphMetrics, TextFormattingMode textFormattingMode, bool isSideways);
    private void GetGlyphMetricsAndIndicesOptimized(UInt32* pCodepoints, int characterCount, double emSize, float pixelsPerDip, UInt16[] glyphIndices, GlyphMetrics[] glyphMetrics, TextFormattingMode textFormattingMode, bool isSideways);
    internal FontSource get_FontSource();
    internal int get_FaceIndex();
    internal FontFaceLayoutInfo get_FontFaceLayoutInfo();
    internal ushort get_BlankGlyphIndex();
    internal FontTechnology get_FontTechnology();
    internal ushort get_DesignEmHeight();
    internal IntPtr get_GetDWriteFontAddRef();
    private IDictionary`2<CultureInfo, string> GetFontInfo(InformationalStringID informationalStringID);
    private sealed virtual override void System.ComponentModel.ISupportInitialize.BeginInit();
    private sealed virtual override void System.ComponentModel.ISupportInitialize.EndInit();
    private void CheckInitialized();
    private void CheckInitializing();
    private GlyphIndexer CreateGlyphIndexer(GlyphAccessor accessor);
}
[ContentPropertyAttribute("GradientStops")]
public abstract class System.Windows.Media.GradientBrush : Brush {
    public static DependencyProperty ColorInterpolationModeProperty;
    public static DependencyProperty MappingModeProperty;
    public static DependencyProperty SpreadMethodProperty;
    public static DependencyProperty GradientStopsProperty;
    internal static ColorInterpolationMode c_ColorInterpolationMode;
    internal static BrushMappingMode c_MappingMode;
    internal static GradientSpreadMethod c_SpreadMethod;
    internal static GradientStopCollection s_GradientStops;
    public ColorInterpolationMode ColorInterpolationMode { get; public set; }
    public BrushMappingMode MappingMode { get; public set; }
    public GradientSpreadMethod SpreadMethod { get; public set; }
    public GradientStopCollection GradientStops { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    protected GradientBrush(GradientStopCollection gradientStopCollection);
    private static GradientBrush();
    public GradientBrush Clone();
    public GradientBrush CloneCurrentValue();
    private static void ColorInterpolationModePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void MappingModePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void SpreadMethodPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void GradientStopsPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public ColorInterpolationMode get_ColorInterpolationMode();
    public void set_ColorInterpolationMode(ColorInterpolationMode value);
    public BrushMappingMode get_MappingMode();
    public void set_MappingMode(BrushMappingMode value);
    public GradientSpreadMethod get_SpreadMethod();
    public void set_SpreadMethod(GradientSpreadMethod value);
    public GradientStopCollection get_GradientStops();
    public void set_GradientStops(GradientStopCollection value);
    internal virtual int get_EffectiveValuesInitialSize();
}
public enum System.Windows.Media.GradientSpreadMethod : Enum {
    public int value__;
    public static GradientSpreadMethod Pad;
    public static GradientSpreadMethod Reflect;
    public static GradientSpreadMethod Repeat;
}
[LocalizabilityAttribute("0")]
public class System.Windows.Media.GradientStop : Animatable {
    public static DependencyProperty ColorProperty;
    public static DependencyProperty OffsetProperty;
    internal static Color s_Color;
    internal static double c_Offset;
    public Color Color { get; public set; }
    public double Offset { get; public set; }
    public GradientStop(Color color, double offset);
    private static GradientStop();
    public GradientStop Clone();
    public GradientStop CloneCurrentValue();
    public Color get_Color();
    public void set_Color(Color value);
    public double get_Offset();
    public void set_Offset(double value);
    protected virtual Freezable CreateInstanceCore();
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.GradientStopCollection : Animatable {
    private static GradientStopCollection s_empty;
    internal FrugalStructList`1<GradientStop> _collection;
    internal UInt32 _version;
    public GradientStop Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.GradientStop>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal static GradientStopCollection Empty { get; }
    public GradientStopCollection(int capacity);
    public GradientStopCollection(IEnumerable`1<GradientStop> collection);
    public GradientStopCollection Clone();
    public GradientStopCollection CloneCurrentValue();
    public sealed virtual void Add(GradientStop value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(GradientStop value);
    public sealed virtual int IndexOf(GradientStop value);
    public sealed virtual void Insert(int index, GradientStop value);
    public sealed virtual bool Remove(GradientStop value);
    public sealed virtual void RemoveAt(int index);
    internal void RemoveAtWithoutFiringPublicEvents(int index);
    public sealed virtual GradientStop get_Item(int index);
    public sealed virtual void set_Item(int index, GradientStop value);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(GradientStop[] array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.GradientStop>.get_IsReadOnly();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<GradientStop> System.Collections.Generic.IEnumerable<System.Windows.Media.GradientStop>.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal static GradientStopCollection get_Empty();
    internal GradientStop Internal_GetItem(int i);
    internal virtual void OnInheritanceContextChangedCore(EventArgs args);
    private GradientStop Cast(object value);
    private int AddHelper(GradientStop value);
    internal int AddWithoutFiringPublicEvents(GradientStop value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected virtual bool FreezeCore(bool isChecking);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
    public static GradientStopCollection Parse(string source);
}
public class System.Windows.Media.GuidelineSet : Animatable {
    public static DependencyProperty GuidelinesXProperty;
    public static DependencyProperty GuidelinesYProperty;
    internal static DependencyProperty IsDynamicProperty;
    internal MultiChannelResource _duceResource;
    internal static DoubleCollection s_GuidelinesX;
    internal static DoubleCollection s_GuidelinesY;
    internal static bool c_IsDynamic;
    public DoubleCollection GuidelinesX { get; public set; }
    public DoubleCollection GuidelinesY { get; public set; }
    internal bool IsDynamic { get; internal set; }
    internal GuidelineSet(Double[] guidelinesX, Double[] guidelinesY, bool isDynamic);
    public GuidelineSet(Double[] guidelinesX, Double[] guidelinesY);
    private static GuidelineSet();
    public GuidelineSet Clone();
    public GuidelineSet CloneCurrentValue();
    private static void GuidelinesXPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void GuidelinesYPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void IsDynamicPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public DoubleCollection get_GuidelinesX();
    public void set_GuidelinesX(DoubleCollection value);
    public DoubleCollection get_GuidelinesY();
    public void set_GuidelinesY(DoubleCollection value);
    internal bool get_IsDynamic();
    internal void set_IsDynamic(bool value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
}
internal abstract class System.Windows.Media.HitTestDrawingContextWalker : DrawingContextWalker {
    protected bool _contains;
    internal bool IsHit { get; }
    internal IntersectionDetail IntersectionDetail { get; }
    internal abstract virtual bool get_IsHit();
    internal abstract virtual IntersectionDetail get_IntersectionDetail();
    public virtual void DrawLine(Pen pen, Point point0, Point point1);
    public virtual void DrawRectangle(Brush brush, Pen pen, Rect rectangle);
    public virtual void DrawRoundedRectangle(Brush brush, Pen pen, Rect rectangle, double radiusX, double radiusY);
    public virtual void DrawEllipse(Brush brush, Pen pen, Point center, double radiusX, double radiusY);
    public virtual void DrawImage(ImageSource imageSource, Rect rectangle);
    public virtual void DrawVideo(MediaPlayer video, Rect rectangle);
}
public enum System.Windows.Media.HitTestFilterBehavior : Enum {
    public int value__;
    public static HitTestFilterBehavior ContinueSkipChildren;
    public static HitTestFilterBehavior ContinueSkipSelfAndChildren;
    public static HitTestFilterBehavior ContinueSkipSelf;
    public static HitTestFilterBehavior Continue;
    public static HitTestFilterBehavior Stop;
}
public class System.Windows.Media.HitTestFilterCallback : MulticastDelegate {
    public HitTestFilterCallback(object object, IntPtr method);
    public virtual HitTestFilterBehavior Invoke(DependencyObject potentialHitTestTarget);
    public virtual IAsyncResult BeginInvoke(DependencyObject potentialHitTestTarget, AsyncCallback callback, object object);
    public virtual HitTestFilterBehavior EndInvoke(IAsyncResult result);
}
public abstract class System.Windows.Media.HitTestParameters : object {
}
public abstract class System.Windows.Media.HitTestResult : object {
    private DependencyObject _visualHit;
    public DependencyObject VisualHit { get; }
    internal HitTestResult(DependencyObject visualHit);
    public DependencyObject get_VisualHit();
}
public enum System.Windows.Media.HitTestResultBehavior : Enum {
    public int value__;
    public static HitTestResultBehavior Stop;
    public static HitTestResultBehavior Continue;
}
public class System.Windows.Media.HitTestResultCallback : MulticastDelegate {
    public HitTestResultCallback(object object, IntPtr method);
    public virtual HitTestResultBehavior Invoke(HitTestResult result);
    public virtual IAsyncResult BeginInvoke(HitTestResult result, AsyncCallback callback, object object);
    public virtual HitTestResultBehavior EndInvoke(IAsyncResult result);
}
internal class System.Windows.Media.HitTestWithGeometryDrawingContextWalker : HitTestDrawingContextWalker {
    private PathGeometry _geometry;
    private Stack _modifierStack;
    private Transform _currentTransform;
    private Geometry _currentClip;
    private IntersectionDetail _intersectionDetail;
    internal bool IsHit { get; }
    internal IntersectionDetail IntersectionDetail { get; }
    internal HitTestWithGeometryDrawingContextWalker(PathGeometry geometry);
    internal virtual bool get_IsHit();
    internal virtual IntersectionDetail get_IntersectionDetail();
    public virtual void DrawGeometry(Brush brush, Pen pen, Geometry geometry);
    public virtual void DrawGlyphRun(Brush foregroundBrush, GlyphRun glyphRun);
    public virtual void PushClip(Geometry clipGeometry);
    public virtual void PushOpacityMask(Brush brush);
    public virtual void PushOpacity(double opacity);
    public virtual void PushTransform(Transform transform);
    public virtual void PushGuidelineSet(GuidelineSet guidelines);
    internal virtual void PushGuidelineY1(double coordinate);
    internal virtual void PushGuidelineY2(double leadingCoordinate, double offsetToDrivenCoordinate);
    public virtual void Pop();
    private void AccumulateIntersectionDetail(IntersectionDetail intersectionDetail);
    private void PushModifierStack(ModifierNode modifier);
}
internal class System.Windows.Media.HitTestWithPointDrawingContextWalker : HitTestDrawingContextWalker {
    private Point _point;
    private Stack`1<Point> _pointStack;
    private bool _currentLayerIsNoOp;
    private int _noOpLayerDepth;
    internal bool IsHit { get; }
    internal IntersectionDetail IntersectionDetail { get; }
    private bool IsCurrentLayerNoOp { get; private set; }
    internal HitTestWithPointDrawingContextWalker(Point point);
    internal virtual bool get_IsHit();
    internal virtual IntersectionDetail get_IntersectionDetail();
    public virtual void DrawGeometry(Brush brush, Pen pen, Geometry geometry);
    public virtual void DrawGlyphRun(Brush foregroundBrush, GlyphRun glyphRun);
    public virtual void PushClip(Geometry clipGeometry);
    public virtual void PushOpacityMask(Brush brush);
    public virtual void PushOpacity(double opacity);
    public virtual void PushTransform(Transform transform);
    public virtual void PushGuidelineSet(GuidelineSet guidelines);
    internal virtual void PushGuidelineY1(double coordinate);
    internal virtual void PushGuidelineY2(double leadingCoordinate, double offsetToDrivenCoordinate);
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
public virtual void PushEffect(BitmapEffect effect, BitmapEffectInput effectInput);
    public virtual void Pop();
    private void PushPointStack(Point point);
    private void PopPointStack();
    private bool IsPushNoOp();
    private bool IsPopNoOp();
    private void set_IsCurrentLayerNoOp(bool value);
    private bool get_IsCurrentLayerNoOp();
}
public class System.Windows.Media.HostVisual : ContainerVisual {
    private VisualTarget _target;
    private Dictionary`2<Channel, Dispatcher> _connectedChannels;
    private static DisconnectData _disconnectData;
    protected virtual HitTestResult HitTestCore(PointHitTestParameters hitTestParameters);
    protected virtual GeometryHitTestResult HitTestCore(GeometryHitTestParameters hitTestParameters);
    internal virtual Rect GetContentBounds();
    internal virtual void RenderContent(RenderContext ctx, bool isOnChannel);
    internal virtual void FreeContent(Channel channel);
    internal void BeginHosting(VisualTarget target);
    internal void EndHosting();
    internal object DoHandleDuplication(object channel);
    private void EnsureHostedVisualConnected(Channel channel);
    private void DisconnectHostedVisualOnAllChannels();
    private void DisconnectHostedVisual(Channel channel, bool removeChannelFromCollection);
    private object DoDisconnectHostedVisual(object arg);
    private bool DoPendingDisconnect(Channel channel);
    private void Disconnect(Channel channel, Dispatcher channelDispatcher, ResourceHandle hostHandle, ResourceHandle targetHandle, MultiChannelResource contentRoot);
    private void Invalidate();
    [CompilerGeneratedAttribute]
private object <BeginHosting>b__6_0(object args);
    [CompilerGeneratedAttribute]
private object <EnsureHostedVisualConnected>b__9_0(object args);
}
internal static class System.Windows.Media.HTFBInterpreter : object {
    internal static int c_DoHitTest;
    internal static int c_IncludeChidren;
    internal static int c_Stop;
    internal static bool DoHitTest(HitTestFilterBehavior behavior);
    internal static bool IncludeChildren(HitTestFilterBehavior behavior);
    internal static bool Stop(HitTestFilterBehavior behavior);
    internal static bool SkipSubgraph(HitTestFilterBehavior behavior);
}
internal interface System.Windows.Media.ICompositionTarget {
    public abstract virtual void Render(bool inResize, Channel channel);
    public abstract virtual void AddRefOnChannel(Channel channel, Channel outOfBandChannel);
    public abstract virtual void ReleaseOnChannel(Channel channel, Channel outOfBandChannel);
}
internal interface System.Windows.Media.ICyclicBrush {
    public abstract virtual void FireOnChanged();
    public abstract virtual void RenderForCyclicBrush(Channel channel, bool skipChannelCheck);
}
internal interface System.Windows.Media.IDrawingContent {
    public abstract virtual Rect GetContentBounds(BoundsDrawingContextWalker ctx);
    public abstract virtual void WalkContent(DrawingContextWalker walker);
    public abstract virtual bool HitTestPoint(Point point);
    public abstract virtual IntersectionDetail HitTestGeometry(PathGeometry geometry);
    public abstract virtual void PropagateChangedHandler(EventHandler handler, bool adding);
}
internal interface System.Windows.Media.IFreezeFreezables {
    public bool FreezeFreezables { get; }
    public abstract virtual bool get_FreezeFreezables();
    public abstract virtual bool TryFreeze(string value, Freezable freezable);
    public abstract virtual Freezable TryGetFreezable(string value);
}
internal interface System.Windows.Media.IInvokable {
    public abstract virtual void RaiseEvent(Byte[] buffer, int cb);
}
public class System.Windows.Media.ImageBrush : TileBrush {
    public static DependencyProperty ImageSourceProperty;
    internal MultiChannelResource _duceResource;
    public ImageSource ImageSource { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    public ImageBrush(ImageSource image);
    private static ImageBrush();
    protected virtual void GetContentBounds(Rect& contentBounds);
    public ImageBrush Clone();
    public ImageBrush CloneCurrentValue();
    private static void ImageSourcePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public ImageSource get_ImageSource();
    public void set_ImageSource(ImageSource value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    internal virtual int get_EffectiveValuesInitialSize();
}
public class System.Windows.Media.ImageDrawing : Drawing {
    public static DependencyProperty ImageSourceProperty;
    public static DependencyProperty RectProperty;
    internal MultiChannelResource _duceResource;
    internal static Rect s_Rect;
    public ImageSource ImageSource { get; public set; }
    public Rect Rect { get; public set; }
    public ImageDrawing(ImageSource imageSource, Rect rect);
    private static ImageDrawing();
    internal virtual void WalkCurrentValue(DrawingContextWalker ctx);
    public ImageDrawing Clone();
    public ImageDrawing CloneCurrentValue();
    private static void ImageSourcePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void RectPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public ImageSource get_ImageSource();
    public void set_ImageSource(ImageSource value);
    public Rect get_Rect();
    public void set_Rect(Rect value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
}
public abstract class System.Windows.Media.ImageMetadata : Freezable {
    public ImageMetadata Clone();
}
[ValueSerializerAttribute("System.Windows.Media.ImageSourceValueSerializer")]
[TypeConverterAttribute("System.Windows.Media.ImageSourceConverter")]
[LocalizabilityAttribute("0")]
public abstract class System.Windows.Media.ImageSource : Animatable {
    public double Width { get; }
    public double Height { get; }
    public ImageMetadata Metadata { get; }
    internal Size Size { get; }
    public abstract virtual double get_Width();
    public abstract virtual double get_Height();
    public abstract virtual ImageMetadata get_Metadata();
    internal virtual Size get_Size();
    internal virtual bool CanSerializeToString();
    protected static double PixelsToDIPs(double dpi, int pixels);
    public ImageSource Clone();
    public ImageSource CloneCurrentValue();
    internal abstract virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    internal abstract virtual void ReleaseOnChannelCore(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    internal abstract virtual ResourceHandle GetHandleCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    internal abstract virtual int GetChannelCountCore();
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    internal abstract virtual Channel GetChannelCore(int index);
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal virtual string ConvertToString(string format, IFormatProvider provider);
}
public class System.Windows.Media.ImageSourceConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    private Stream GetBitmapStream(Byte[] rawData);
}
public class System.Windows.Media.ImageSourceValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public enum System.Windows.Media.Imaging.BitmapCacheOption : Enum {
    public int value__;
    public static BitmapCacheOption Default;
    public static BitmapCacheOption OnDemand;
    public static BitmapCacheOption OnLoad;
    public static BitmapCacheOption None;
}
public abstract class System.Windows.Media.Imaging.BitmapCodecInfo : object {
    private bool _isBuiltIn;
    private SafeMILHandle _codecInfoHandle;
    public Guid ContainerFormat { get; }
    public string Author { get; }
    public Version Version { get; }
    public Version SpecificationVersion { get; }
    public string FriendlyName { get; }
    public string DeviceManufacturer { get; }
    public string DeviceModels { get; }
    public string MimeTypes { get; }
    public string FileExtensions { get; }
    public bool SupportsAnimation { get; }
    public bool SupportsLossless { get; }
    public bool SupportsMultipleFrames { get; }
    internal BitmapCodecInfo(SafeMILHandle codecInfoHandle);
    public virtual Guid get_ContainerFormat();
    public virtual string get_Author();
    public virtual Version get_Version();
    public virtual Version get_SpecificationVersion();
    public virtual string get_FriendlyName();
    public virtual string get_DeviceManufacturer();
    public virtual string get_DeviceModels();
    public virtual string get_MimeTypes();
    public virtual string get_FileExtensions();
    public virtual bool get_SupportsAnimation();
    public virtual bool get_SupportsLossless();
    public virtual bool get_SupportsMultipleFrames();
    private void EnsureBuiltIn();
}
internal class System.Windows.Media.Imaging.BitmapCodecInfoInternal : BitmapCodecInfo {
    internal BitmapCodecInfoInternal(SafeMILHandle codecInfoHandle);
}
[FlagsAttribute]
public enum System.Windows.Media.Imaging.BitmapCreateOptions : Enum {
    public int value__;
    public static BitmapCreateOptions None;
    public static BitmapCreateOptions PreservePixelFormat;
    public static BitmapCreateOptions DelayCreation;
    public static BitmapCreateOptions IgnoreColorProfile;
    public static BitmapCreateOptions IgnoreImageCache;
}
public abstract class System.Windows.Media.Imaging.BitmapDecoder : DispatcherObject {
    private bool _isBuiltInDecoder;
    private SafeMILHandle _decoderHandle;
    private bool _shouldCacheDecoder;
    private bool _isOriginalWritable;
    private bool _isPaletteCached;
    private BitmapPalette _palette;
    private bool _isColorContextCached;
    internal ReadOnlyCollection`1<ColorContext> _readOnlycolorContexts;
    private bool _isThumbnailCached;
    private BitmapMetadata _metadata;
    private bool _isMetadataCached;
    private BitmapSource _thumbnail;
    private BitmapCodecInfo _codecInfo;
    private bool _isPreviewCached;
    private BitmapSource _preview;
    internal List`1<BitmapFrame> _frames;
    internal ReadOnlyCollection`1<BitmapFrame> _readOnlyFrames;
    internal Stream _stream;
    internal Uri _uri;
    internal Uri _baseUri;
    internal Stream _uriStream;
    internal BitmapCreateOptions _createOptions;
    internal BitmapCacheOption _cacheOption;
    internal UniqueEventHelper _downloadEvent;
    internal UniqueEventHelper`1<DownloadProgressEventArgs> _progressEvent;
    internal UniqueEventHelper`1<ExceptionEventArgs> _failedEvent;
    private object _syncObject;
    private UnmanagedMemoryStream _unmanagedMemoryStream;
    private SafeFileHandle _safeFilehandle;
    private BitmapDecoder _cachedDecoder;
    public BitmapPalette Palette { get; }
    public ReadOnlyCollection`1<ColorContext> ColorContexts { get; }
    public BitmapSource Thumbnail { get; }
    public BitmapMetadata Metadata { get; }
    public BitmapCodecInfo CodecInfo { get; }
    public ReadOnlyCollection`1<BitmapFrame> Frames { get; }
    public BitmapSource Preview { get; }
    public bool IsDownloading { get; }
    internal SafeMILHandle InternalDecoder { get; }
    internal bool IsMetadataFixedSize { get; }
    internal object SyncObject { get; }
    internal ReadOnlyCollection`1<ColorContext> InternalColorContexts { get; }
    private static BitmapDecoder();
    internal BitmapDecoder(bool isBuiltIn);
    internal BitmapDecoder(Uri bitmapUri, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption, Guid expectedClsId);
    internal BitmapDecoder(Stream bitmapStream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption, Guid expectedClsId);
    internal BitmapDecoder(SafeMILHandle decoderHandle, BitmapDecoder decoder, Uri baseUri, Uri uri, Stream stream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption, bool insertInDecoderCache, bool isOriginalWritable, Stream uriStream, UnmanagedMemoryStream unmanagedMemoryStream, SafeFileHandle safeFilehandle);
    protected virtual override void Finalize();
    internal static BitmapDecoder CreateFromUriOrStream(Uri baseUri, Uri uri, Stream stream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption, RequestCachePolicy uriCachePolicy, bool insertInDecoderCache);
    public static BitmapDecoder Create(Uri bitmapUri, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    public static BitmapDecoder Create(Uri bitmapUri, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption, RequestCachePolicy uriCachePolicy);
    public static BitmapDecoder Create(Stream bitmapStream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    public virtual BitmapPalette get_Palette();
    public virtual ReadOnlyCollection`1<ColorContext> get_ColorContexts();
    public virtual BitmapSource get_Thumbnail();
    public virtual BitmapMetadata get_Metadata();
    public virtual BitmapCodecInfo get_CodecInfo();
    public virtual ReadOnlyCollection`1<BitmapFrame> get_Frames();
    public virtual BitmapSource get_Preview();
    public virtual bool get_IsDownloading();
    public virtual void add_DownloadCompleted(EventHandler value);
    public virtual void remove_DownloadCompleted(EventHandler value);
    public virtual void add_DownloadProgress(EventHandler`1<DownloadProgressEventArgs> value);
    public virtual void remove_DownloadProgress(EventHandler`1<DownloadProgressEventArgs> value);
    public virtual void add_DownloadFailed(EventHandler`1<ExceptionEventArgs> value);
    public virtual void remove_DownloadFailed(EventHandler`1<ExceptionEventArgs> value);
    public virtual InPlaceBitmapMetadataWriter CreateInPlaceBitmapMetadataWriter();
    public virtual string ToString();
    internal SafeMILHandle get_InternalDecoder();
    internal virtual bool get_IsMetadataFixedSize();
    internal object get_SyncObject();
    private int GetColorContexts(UInt32& numContexts, IntPtr[] colorContextPtrs);
    internal ReadOnlyCollection`1<ColorContext> get_InternalColorContexts();
    internal void CheckOriginalWritable();
    internal static SafeMILHandle SetupDecoderFromUriOrStream(Uri uri, Stream stream, BitmapCacheOption cacheOption, Guid& clsId, Boolean& isOriginalWritable, Stream& uriStream, UnmanagedMemoryStream& unmanagedMemoryStream, SafeFileHandle& safeFilehandle);
    private static Stream ProcessHttpsFiles(Uri uri, Stream stream);
    private static Stream ProcessHttpFiles(Uri uri, Stream stream);
    private static Stream ProcessUncFiles(Uri uri);
    private static Guid GetCLSIDFromDecoder(SafeMILHandle decoderHandle, String& decoderMimeTypes);
    private static Stream GetSeekableStream(Stream bitmapStream);
    private static BitmapDecoder CheckCache(Uri uri, Guid& clsId);
    private void Initialize(BitmapDecoder decoder);
    internal void CloseStream();
    internal void SetupFrames(BitmapDecoder decoder, ReadOnlyCollection`1<BitmapFrame> frames);
    private void EnsureBuiltInDecoder();
    private static IntPtr GetIStreamFromStream(Stream& bitmapStream);
    internal bool CanConvertToString();
    internal abstract virtual void SealObject();
}
internal static class System.Windows.Media.Imaging.BitmapDownload : object {
    internal static AutoResetEvent _waitEvent;
    internal static Queue _workQueue;
    internal static Hashtable _uriTable;
    internal static AsyncCallback _readCallback;
    internal static AsyncCallback _responseCallback;
    private static Thread _thread;
    private static object _syncLock;
    private static int READ_SIZE;
    private static BitmapDownload();
    internal static void BeginDownload(BitmapDecoder decoder, Uri uri, RequestCachePolicy uriCachePolicy, Stream stream);
    internal static void DownloadThreadProc();
    private static void ResponseCallback(IAsyncResult result);
    private static void ReadCallback(IAsyncResult result);
    private static void MarshalEvents(LateBoundBitmapDecoder decoder, DispatcherOperationCallback doc, object arg);
    private static void MarshalException(QueueEntry entry, Exception e);
}
public abstract class System.Windows.Media.Imaging.BitmapEncoder : DispatcherObject {
    internal bool _supportsPreview;
    internal bool _supportsGlobalThumbnail;
    internal bool _supportsGlobalMetadata;
    internal bool _supportsFrameThumbnails;
    internal bool _supportsFrameMetadata;
    internal bool _supportsMultipleFrames;
    internal bool _supportsColorContext;
    private bool _isBuiltIn;
    private SafeMILHandle _encoderHandle;
    private BitmapMetadata _metadata;
    private SafeMILHandle _metadataHandle;
    private ReadOnlyCollection`1<ColorContext> _readOnlycolorContexts;
    private BitmapCodecInfoInternal _codecInfo;
    private BitmapSource _thumbnail;
    private BitmapSource _preview;
    private BitmapPalette _palette;
    private IList`1<BitmapFrame> _frames;
    private bool _hasSaved;
    private IList`1<SafeMILHandle> _frameHandles;
    private IList`1<SafeMILHandle> _writeSourceHandles;
    private EncodeState _encodeState;
    public ReadOnlyCollection`1<ColorContext> ColorContexts { get; public set; }
    public BitmapSource Thumbnail { get; public set; }
    public BitmapMetadata Metadata { get; public set; }
    public BitmapSource Preview { get; public set; }
    public BitmapCodecInfo CodecInfo { get; }
    public BitmapPalette Palette { get; public set; }
    public IList`1<BitmapFrame> Frames { get; public set; }
    internal Guid ContainerFormat { get; }
    internal bool IsMetadataFixedSize { get; }
    internal BitmapEncoder(bool isBuiltIn);
    public static BitmapEncoder Create(Guid containerFormat);
    public virtual ReadOnlyCollection`1<ColorContext> get_ColorContexts();
    public virtual void set_ColorContexts(ReadOnlyCollection`1<ColorContext> value);
    public virtual BitmapSource get_Thumbnail();
    public virtual void set_Thumbnail(BitmapSource value);
    public virtual BitmapMetadata get_Metadata();
    public virtual void set_Metadata(BitmapMetadata value);
    public virtual BitmapSource get_Preview();
    public virtual void set_Preview(BitmapSource value);
    public virtual BitmapCodecInfo get_CodecInfo();
    public virtual BitmapPalette get_Palette();
    public virtual void set_Palette(BitmapPalette value);
    public virtual IList`1<BitmapFrame> get_Frames();
    public virtual void set_Frames(IList`1<BitmapFrame> value);
    public virtual void Save(Stream stream);
    internal virtual Guid get_ContainerFormat();
    internal virtual bool get_IsMetadataFixedSize();
    internal virtual void SetupFrame(SafeMILHandle frameEncodeHandle, SafeMILHandle encoderOptions);
    private void EnsureBuiltIn();
    private void EnsureMetadata(bool createBitmapMetadata);
    private void EnsureUnmanagedEncoder();
    private void SaveFrame(SafeMILHandle frameEncodeHandle, SafeMILHandle encoderOptions, BitmapFrame frame);
    internal abstract virtual void SealObject();
}
public abstract class System.Windows.Media.Imaging.BitmapFrame : BitmapSource {
    internal BitmapSource _thumbnail;
    internal BitmapMetadata _metadata;
    internal ReadOnlyCollection`1<ColorContext> _readOnlycolorContexts;
    public Uri BaseUri { get; public set; }
    public BitmapSource Thumbnail { get; }
    public BitmapDecoder Decoder { get; }
    public ReadOnlyCollection`1<ColorContext> ColorContexts { get; }
    internal BitmapMetadata InternalMetadata { get; internal set; }
    internal BitmapFrame(bool useVirtuals);
    internal static BitmapFrame CreateFromUriOrStream(Uri baseUri, Uri uri, Stream stream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption, RequestCachePolicy uriCachePolicy);
    public static BitmapFrame Create(Uri bitmapUri);
    public static BitmapFrame Create(Uri bitmapUri, RequestCachePolicy uriCachePolicy);
    public static BitmapFrame Create(Uri bitmapUri, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    public static BitmapFrame Create(Uri bitmapUri, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption, RequestCachePolicy uriCachePolicy);
    public static BitmapFrame Create(Stream bitmapStream);
    public static BitmapFrame Create(Stream bitmapStream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    public static BitmapFrame Create(BitmapSource source);
    public static BitmapFrame Create(BitmapSource source, BitmapSource thumbnail);
    public static BitmapFrame Create(BitmapSource source, BitmapSource thumbnail, BitmapMetadata metadata, ReadOnlyCollection`1<ColorContext> colorContexts);
    public abstract virtual Uri get_BaseUri();
    public abstract virtual void set_BaseUri(Uri value);
    public abstract virtual BitmapSource get_Thumbnail();
    public abstract virtual BitmapDecoder get_Decoder();
    public abstract virtual ReadOnlyCollection`1<ColorContext> get_ColorContexts();
    public abstract virtual InPlaceBitmapMetadataWriter CreateInPlaceBitmapMetadataWriter();
    internal virtual BitmapMetadata get_InternalMetadata();
    internal virtual void set_InternalMetadata(BitmapMetadata value);
}
internal class System.Windows.Media.Imaging.BitmapFrameDecode : BitmapFrame {
    private BitmapSourceSafeMILHandle _frameSource;
    private int _frameNumber;
    private bool _isThumbnailCached;
    private bool _isMetadataCached;
    private bool _isColorContextCached;
    private BitmapCreateOptions _createOptions;
    private BitmapCacheOption _cacheOption;
    private BitmapDecoder _decoder;
    private WeakBitmapFrameDecodeEventSink _weakBitmapFrameDecodeEventSink;
    public Uri BaseUri { get; public set; }
    public BitmapSource Thumbnail { get; }
    public ImageMetadata Metadata { get; }
    public BitmapDecoder Decoder { get; }
    public ReadOnlyCollection`1<ColorContext> ColorContexts { get; }
    public bool IsDownloading { get; }
    internal bool ShouldCloneEventDelegates { get; }
    internal BitmapMetadata InternalMetadata { get; internal set; }
    internal BitmapFrameDecode(int frameNumber, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption, BitmapDecoder decoder);
    internal BitmapFrameDecode(int frameNumber, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption, BitmapFrameDecode frameDecode);
    internal BitmapFrameDecode(int frameNumber, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption, LateBoundBitmapDecoder decoder);
    public virtual Uri get_BaseUri();
    public virtual void set_BaseUri(Uri value);
    public virtual BitmapSource get_Thumbnail();
    public virtual ImageMetadata get_Metadata();
    public virtual BitmapDecoder get_Decoder();
    private int GetColorContexts(UInt32& numContexts, IntPtr[] colorContextPtrs);
    public virtual ReadOnlyCollection`1<ColorContext> get_ColorContexts();
    public virtual bool get_IsDownloading();
    public virtual InPlaceBitmapMetadataWriter CreateInPlaceBitmapMetadataWriter();
    internal virtual bool CanSerializeToString();
    internal virtual string ConvertToString(string format, IFormatProvider provider);
    protected virtual Freezable CreateInstanceCore();
    private void CopyCommon(BitmapFrameDecode sourceBitmapFrameDecode);
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    internal void UpdateDecoder(BitmapDecoder decoder);
    internal virtual void FinalizeCreation();
    internal virtual bool get_ShouldCloneEventDelegates();
    private void OnDownloadCompleted(object sender, EventArgs e);
    private void OnDownloadProgress(object sender, DownloadProgressEventArgs e);
    private void OnDownloadFailed(object sender, ExceptionEventArgs e);
    private void OnOriginalDownloadCompleted(BitmapFrameDecode original, EventArgs e);
    private void OnOriginalDownloadFailed(ExceptionEventArgs e);
    private void CleanUpWeakEventSink();
    private void EnsureThumbnail();
    internal virtual BitmapMetadata get_InternalMetadata();
    internal virtual void set_InternalMetadata(BitmapMetadata value);
    private void EnsureSource();
}
internal class System.Windows.Media.Imaging.BitmapFrameEncode : BitmapFrame {
    private BitmapSource _source;
    public Uri BaseUri { get; public set; }
    public BitmapSource Thumbnail { get; }
    public ImageMetadata Metadata { get; }
    public BitmapDecoder Decoder { get; }
    public ReadOnlyCollection`1<ColorContext> ColorContexts { get; }
    internal BitmapMetadata InternalMetadata { get; internal set; }
    internal BitmapFrameEncode(BitmapSource source, BitmapSource thumbnail, BitmapMetadata metadata, ReadOnlyCollection`1<ColorContext> colorContexts);
    public virtual Uri get_BaseUri();
    public virtual void set_BaseUri(Uri value);
    public virtual BitmapSource get_Thumbnail();
    public virtual ImageMetadata get_Metadata();
    public virtual BitmapDecoder get_Decoder();
    public virtual ReadOnlyCollection`1<ColorContext> get_ColorContexts();
    public virtual InPlaceBitmapMetadataWriter CreateInPlaceBitmapMetadataWriter();
    protected virtual Freezable CreateInstanceCore();
    private void CopyCommon(BitmapFrameEncode sourceBitmapFrameEncode);
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    internal virtual void FinalizeCreation();
    internal virtual BitmapMetadata get_InternalMetadata();
    internal virtual void set_InternalMetadata(BitmapMetadata value);
}
public class System.Windows.Media.Imaging.BitmapImage : BitmapSource {
    private Uri _baseUri;
    private bool _isDownloading;
    private BitmapDecoder _decoder;
    private RequestCachePolicy _uriCachePolicy;
    private Uri _uriSource;
    private Stream _streamSource;
    private int _decodePixelWidth;
    private int _decodePixelHeight;
    private Rotation _rotation;
    private Int32Rect _sourceRect;
    private BitmapCreateOptions _createOptions;
    private BitmapCacheOption _cacheOption;
    private BitmapSource _finalSource;
    private BitmapImage _cachedBitmapImage;
    public static DependencyProperty UriCachePolicyProperty;
    public static DependencyProperty UriSourceProperty;
    public static DependencyProperty StreamSourceProperty;
    public static DependencyProperty DecodePixelWidthProperty;
    public static DependencyProperty DecodePixelHeightProperty;
    public static DependencyProperty RotationProperty;
    public static DependencyProperty SourceRectProperty;
    public static DependencyProperty CreateOptionsProperty;
    public static DependencyProperty CacheOptionProperty;
    internal static RequestCachePolicy s_UriCachePolicy;
    internal static Uri s_UriSource;
    internal static Stream s_StreamSource;
    internal static int c_DecodePixelWidth;
    internal static int c_DecodePixelHeight;
    internal static Rotation c_Rotation;
    internal static Int32Rect s_SourceRect;
    internal static BitmapCreateOptions s_CreateOptions;
    internal static BitmapCacheOption s_CacheOption;
    public Uri BaseUri { get; public set; }
    public bool IsDownloading { get; }
    public ImageMetadata Metadata { get; }
    [TypeConverterAttribute("System.Windows.Media.RequestCachePolicyConverter")]
public RequestCachePolicy UriCachePolicy { get; public set; }
    public Uri UriSource { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public Stream StreamSource { get; public set; }
    public int DecodePixelWidth { get; public set; }
    public int DecodePixelHeight { get; public set; }
    public Rotation Rotation { get; public set; }
    public Int32Rect SourceRect { get; public set; }
    public BitmapCreateOptions CreateOptions { get; public set; }
    public BitmapCacheOption CacheOption { get; public set; }
    public BitmapImage(Uri uriSource);
    public BitmapImage(Uri uriSource, RequestCachePolicy uriCachePolicy);
    private static BitmapImage();
    public sealed virtual void BeginInit();
    public sealed virtual void EndInit();
    public sealed virtual Uri get_BaseUri();
    public sealed virtual void set_BaseUri(Uri value);
    public virtual bool get_IsDownloading();
    public virtual ImageMetadata get_Metadata();
    internal virtual bool CanSerializeToString();
    internal virtual string ConvertToString(string format, IFormatProvider provider);
    private void ClonePrequel(BitmapImage otherBitmapImage);
    private void ClonePostscript(BitmapImage otherBitmapImage);
    private BitmapImage CheckCache(Uri uri);
    private void InsertInCache(Uri uri);
    internal virtual void FinalizeCreation();
    private void UriCachePolicyPropertyChangedHook(DependencyPropertyChangedEventArgs e);
    private void UriSourcePropertyChangedHook(DependencyPropertyChangedEventArgs e);
    private void StreamSourcePropertyChangedHook(DependencyPropertyChangedEventArgs e);
    private void DecodePixelWidthPropertyChangedHook(DependencyPropertyChangedEventArgs e);
    private void DecodePixelHeightPropertyChangedHook(DependencyPropertyChangedEventArgs e);
    private void RotationPropertyChangedHook(DependencyPropertyChangedEventArgs e);
    private void SourceRectPropertyChangedHook(DependencyPropertyChangedEventArgs e);
    private void CreateOptionsPropertyChangedHook(DependencyPropertyChangedEventArgs e);
    private void CacheOptionPropertyChangedHook(DependencyPropertyChangedEventArgs e);
    private static object CoerceUriCachePolicy(DependencyObject d, object value);
    private static object CoerceUriSource(DependencyObject d, object value);
    private static object CoerceStreamSource(DependencyObject d, object value);
    private static object CoerceDecodePixelWidth(DependencyObject d, object value);
    private static object CoerceDecodePixelHeight(DependencyObject d, object value);
    private static object CoerceRotation(DependencyObject d, object value);
    private static object CoerceSourceRect(DependencyObject d, object value);
    private static object CoerceCreateOptions(DependencyObject d, object value);
    private static object CoerceCacheOption(DependencyObject d, object value);
    private void OnDownloadCompleted(object sender, EventArgs e);
    private void OnDownloadProgress(object sender, DownloadProgressEventArgs e);
    private void OnDownloadFailed(object sender, ExceptionEventArgs e);
    public BitmapImage Clone();
    public BitmapImage CloneCurrentValue();
    private static void UriCachePolicyPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void UriSourcePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void StreamSourcePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void DecodePixelWidthPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void DecodePixelHeightPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void RotationPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void SourceRectPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void CreateOptionsPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void CacheOptionPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public RequestCachePolicy get_UriCachePolicy();
    public void set_UriCachePolicy(RequestCachePolicy value);
    public Uri get_UriSource();
    public void set_UriSource(Uri value);
    public Stream get_StreamSource();
    public void set_StreamSource(Stream value);
    public int get_DecodePixelWidth();
    public void set_DecodePixelWidth(int value);
    public int get_DecodePixelHeight();
    public void set_DecodePixelHeight(int value);
    public Rotation get_Rotation();
    public void set_Rotation(Rotation value);
    public Int32Rect get_SourceRect();
    public void set_SourceRect(Int32Rect value);
    public BitmapCreateOptions get_CreateOptions();
    public void set_CreateOptions(BitmapCreateOptions value);
    public BitmapCacheOption get_CacheOption();
    public void set_CacheOption(BitmapCacheOption value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
}
internal class System.Windows.Media.Imaging.BitmapInitialize : object {
    private bool _inInit;
    private bool _isInitialized;
    public bool IsInInit { get; }
    public bool IsInitAtLeastOnce { get; }
    public sealed virtual void BeginInit();
    public sealed virtual void EndInit();
    public void SetPrologue();
    public bool get_IsInInit();
    public bool get_IsInitAtLeastOnce();
    public void EnsureInitializedComplete();
    public void Reset();
}
public class System.Windows.Media.Imaging.BitmapMetadata : ImageMetadata {
    private static string policy_Author;
    private static string policy_Title;
    private static string policy_Subject;
    private static string policy_Comment;
    private static string policy_Keywords;
    private static string policy_DateTaken;
    private static string policy_ApplicationName;
    private static string policy_Copyright;
    private static string policy_CameraManufacturer;
    private static string policy_CameraModel;
    private static string policy_Rating;
    private SafeMILHandle _metadataHandle;
    private BitmapMetadataBlockWriter _blockWriter;
    private bool _readOnly;
    private bool _fixedSize;
    private object _setQueryValue;
    private string _setQueryString;
    private object _syncObject;
    public string Format { get; }
    public string Location { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public ReadOnlyCollection`1<string> Author { get; public set; }
    public string Title { get; public set; }
    public int Rating { get; public set; }
    public string Subject { get; public set; }
    public string Comment { get; public set; }
    public string DateTaken { get; public set; }
    public string ApplicationName { get; public set; }
    public string Copyright { get; public set; }
    public string CameraManufacturer { get; public set; }
    public string CameraModel { get; public set; }
    public ReadOnlyCollection`1<string> Keywords { get; public set; }
    internal Guid GuidFormat { get; }
    internal SafeMILHandle InternalMetadataHandle { get; }
    internal object SyncObject { get; }
    internal BitmapMetadataBlockWriter BlockWriter { get; }
    public BitmapMetadata(string containerFormat);
    internal BitmapMetadata(SafeMILHandle metadataHandle, bool readOnly, bool fixedSize, object syncObject);
    internal BitmapMetadata(BitmapMetadata bitmapMetadata);
    private void Init(Guid containerFormat, bool readOnly, bool fixedSize);
    private void InitializeFromBlockWriter(Guid containerFormat, bool readOnly, bool fixedSize);
    private void InitializeFromBlockWriter(BitmapMetadataBlockWriter sourceBlockWriter, object syncObject);
    private void InitializeFromMetadataWriter(SafeMILHandle metadataHandle, object syncObject);
    public BitmapMetadata Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    public string get_Format();
    public string get_Location();
    public bool get_IsReadOnly();
    public bool get_IsFixedSize();
    public void SetQuery(string query, object value);
    public object GetQuery(string query);
    public void RemoveQuery(string query);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<string> System.Collections.Generic.IEnumerable<System.String>.GetEnumerator();
    public bool ContainsQuery(string query);
    public ReadOnlyCollection`1<string> get_Author();
    public void set_Author(ReadOnlyCollection`1<string> value);
    public string get_Title();
    public void set_Title(string value);
    public int get_Rating();
    public void set_Rating(int value);
    public string get_Subject();
    public void set_Subject(string value);
    public string get_Comment();
    public void set_Comment(string value);
    public string get_DateTaken();
    public void set_DateTaken(string value);
    public string get_ApplicationName();
    public void set_ApplicationName(string value);
    public string get_Copyright();
    public void set_Copyright(string value);
    public string get_CameraManufacturer();
    public void set_CameraManufacturer(string value);
    public string get_CameraModel();
    public void set_CameraModel(string value);
    public ReadOnlyCollection`1<string> get_Keywords();
    public void set_Keywords(ReadOnlyCollection`1<string> value);
    private void CopyCommon(BitmapMetadata sourceBitmapMetadata);
    internal Guid get_GuidFormat();
    internal SafeMILHandle get_InternalMetadataHandle();
    internal object get_SyncObject();
    internal BitmapMetadataBlockWriter get_BlockWriter();
    private void EnsureBitmapMetadata();
}
public class System.Windows.Media.Imaging.BitmapMetadataBlob : object {
    private Byte[] _blob;
    public BitmapMetadataBlob(Byte[] blob);
    public Byte[] GetBlobValue();
    internal Byte[] InternalGetBlobValue();
}
internal class System.Windows.Media.Imaging.BitmapMetadataEnumerator : ValueType {
    private SafeMILHandle _enumeratorHandle;
    private string _current;
    private bool _fStarted;
    private object System.Collections.IEnumerator.Current { get; }
    public string Current { get; }
    internal BitmapMetadataEnumerator(SafeMILHandle metadataHandle);
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual string get_Current();
    private sealed virtual override void System.IDisposable.Dispose();
}
public class System.Windows.Media.Imaging.BitmapPalette : DispatcherObject {
    private SafeMILHandle _palette;
    private IList`1<Color> _colors;
    public IList`1<Color> Colors { get; }
    internal SafeMILHandle InternalPalette { get; }
    public BitmapPalette(IList`1<Color> colors);
    public BitmapPalette(BitmapSource bitmapSource, int maxColorCount);
    internal BitmapPalette(WICPaletteType paletteType, bool addtransparentColor);
    internal BitmapPalette(SafeMILHandle unmanagedPalette);
    internal static BitmapPalette CreateFromBitmapSource(BitmapSource source);
    public IList`1<Color> get_Colors();
    internal SafeMILHandle get_InternalPalette();
    internal static bool DoesPaletteHaveAlpha(BitmapPalette palette);
    internal static SafeMILHandle CreateInternalPalette();
    private void UpdateUnmanaged();
    private void UpdateManaged();
}
public static class System.Windows.Media.Imaging.BitmapPalettes : object {
    private static BitmapPalette[] s_transparentPalettes;
    private static BitmapPalette[] s_opaquePalettes;
    private static int c_maxPalettes;
    public static BitmapPalette BlackAndWhite { get; }
    public static BitmapPalette BlackAndWhiteTransparent { get; }
    public static BitmapPalette Halftone8 { get; }
    public static BitmapPalette Halftone8Transparent { get; }
    public static BitmapPalette Halftone27 { get; }
    public static BitmapPalette Halftone27Transparent { get; }
    public static BitmapPalette Halftone64 { get; }
    public static BitmapPalette Halftone64Transparent { get; }
    public static BitmapPalette Halftone125 { get; }
    public static BitmapPalette Halftone125Transparent { get; }
    public static BitmapPalette Halftone216 { get; }
    public static BitmapPalette Halftone216Transparent { get; }
    public static BitmapPalette Halftone252 { get; }
    public static BitmapPalette Halftone252Transparent { get; }
    public static BitmapPalette Halftone256 { get; }
    public static BitmapPalette Halftone256Transparent { get; }
    public static BitmapPalette Gray4 { get; }
    public static BitmapPalette Gray4Transparent { get; }
    public static BitmapPalette Gray16 { get; }
    public static BitmapPalette Gray16Transparent { get; }
    public static BitmapPalette Gray256 { get; }
    public static BitmapPalette Gray256Transparent { get; }
    public static BitmapPalette WebPalette { get; }
    public static BitmapPalette WebPaletteTransparent { get; }
    private static BitmapPalette[] transparentPalettes { get; }
    private static BitmapPalette[] opaquePalettes { get; }
    public static BitmapPalette get_BlackAndWhite();
    public static BitmapPalette get_BlackAndWhiteTransparent();
    public static BitmapPalette get_Halftone8();
    public static BitmapPalette get_Halftone8Transparent();
    public static BitmapPalette get_Halftone27();
    public static BitmapPalette get_Halftone27Transparent();
    public static BitmapPalette get_Halftone64();
    public static BitmapPalette get_Halftone64Transparent();
    public static BitmapPalette get_Halftone125();
    public static BitmapPalette get_Halftone125Transparent();
    public static BitmapPalette get_Halftone216();
    public static BitmapPalette get_Halftone216Transparent();
    public static BitmapPalette get_Halftone252();
    public static BitmapPalette get_Halftone252Transparent();
    public static BitmapPalette get_Halftone256();
    public static BitmapPalette get_Halftone256Transparent();
    public static BitmapPalette get_Gray4();
    public static BitmapPalette get_Gray4Transparent();
    public static BitmapPalette get_Gray16();
    public static BitmapPalette get_Gray16Transparent();
    public static BitmapPalette get_Gray256();
    public static BitmapPalette get_Gray256Transparent();
    public static BitmapPalette get_WebPalette();
    public static BitmapPalette get_WebPaletteTransparent();
    internal static BitmapPalette FromMILPaletteType(WICPaletteType type, bool hasAlpha);
    private static BitmapPalette[] get_transparentPalettes();
    private static BitmapPalette[] get_opaquePalettes();
}
public class System.Windows.Media.Imaging.BitmapSizeOptions : object {
    private bool _preservesAspectRatio;
    private int _pixelWidth;
    private int _pixelHeight;
    private Rotation _rotationAngle;
    public bool PreservesAspectRatio { get; }
    public int PixelWidth { get; }
    public int PixelHeight { get; }
    public Rotation Rotation { get; }
    internal bool DoesScale { get; }
    internal WICBitmapTransformOptions WICTransformOptions { get; }
    public bool get_PreservesAspectRatio();
    public int get_PixelWidth();
    public int get_PixelHeight();
    public Rotation get_Rotation();
    public static BitmapSizeOptions FromEmptyOptions();
    public static BitmapSizeOptions FromHeight(int pixelHeight);
    public static BitmapSizeOptions FromWidth(int pixelWidth);
    public static BitmapSizeOptions FromWidthAndHeight(int pixelWidth, int pixelHeight);
    public static BitmapSizeOptions FromRotation(Rotation rotation);
    internal void GetScaledWidthAndHeight(UInt32 width, UInt32 height, UInt32& newWidth, UInt32& newHeight);
    internal bool get_DoesScale();
    internal WICBitmapTransformOptions get_WICTransformOptions();
}
[LocalizabilityAttribute("0")]
public abstract class System.Windows.Media.Imaging.BitmapSource : ImageSource {
    private bool _delayCreation;
    private bool _creationComplete;
    private bool _useVirtuals;
    internal BitmapInitialize _bitmapInit;
    internal BitmapSourceSafeMILHandle _wicSource;
    internal BitmapSourceSafeMILHandle _convertedDUCEPtr;
    internal object _syncObject;
    internal bool _isSourceCached;
    internal bool _needsUpdate;
    internal bool _isColorCorrected;
    internal UniqueEventHelper _downloadEvent;
    internal UniqueEventHelper`1<DownloadProgressEventArgs> _progressEvent;
    internal UniqueEventHelper`1<ExceptionEventArgs> _failedEvent;
    internal UniqueEventHelper`1<ExceptionEventArgs> _decodeFailedEvent;
    internal PixelFormat _format;
    internal int _pixelWidth;
    internal int _pixelHeight;
    internal double _dpiX;
    internal double _dpiY;
    internal BitmapPalette _palette;
    internal MultiChannelResource _duceResource;
    private static PixelFormat[] s_supportedDUCEFormats;
    private WeakBitmapSourceEventSink _weakBitmapSourceEventSink;
    public PixelFormat Format { get; }
    public int PixelWidth { get; }
    public int PixelHeight { get; }
    public double DpiX { get; }
    public double DpiY { get; }
    public BitmapPalette Palette { get; }
    public bool IsDownloading { get; }
    public double Width { get; }
    public double Height { get; }
    public ImageMetadata Metadata { get; }
    internal Size Size { get; }
    internal bool DelayCreation { get; internal set; }
    internal bool CreationCompleted { get; internal set; }
    internal object SyncObject { get; }
    internal bool IsSourceCached { get; internal set; }
    internal BitmapSourceSafeMILHandle WicSourceHandle { get; internal set; }
    internal BitmapSourceSafeMILHandle DUCECompatiblePtr { get; }
    internal bool ShouldCloneEventDelegates { get; }
    internal bool UsableWithoutCache { get; }
    internal bool HasCompatibleFormat { get; }
    internal BitmapSource(bool useVirtuals);
    private static BitmapSource();
    public static BitmapSource Create(int pixelWidth, int pixelHeight, double dpiX, double dpiY, PixelFormat pixelFormat, BitmapPalette palette, Array pixels, int stride);
    public static BitmapSource Create(int pixelWidth, int pixelHeight, double dpiX, double dpiY, PixelFormat pixelFormat, BitmapPalette palette, IntPtr buffer, int bufferSize, int stride);
    public BitmapSource Clone();
    public BitmapSource CloneCurrentValue();
    public virtual PixelFormat get_Format();
    public virtual int get_PixelWidth();
    public virtual int get_PixelHeight();
    public virtual double get_DpiX();
    public virtual double get_DpiY();
    public virtual BitmapPalette get_Palette();
    public virtual bool get_IsDownloading();
    public virtual void add_DownloadCompleted(EventHandler value);
    public virtual void remove_DownloadCompleted(EventHandler value);
    public virtual void add_DownloadProgress(EventHandler`1<DownloadProgressEventArgs> value);
    public virtual void remove_DownloadProgress(EventHandler`1<DownloadProgressEventArgs> value);
    public virtual void add_DownloadFailed(EventHandler`1<ExceptionEventArgs> value);
    public virtual void remove_DownloadFailed(EventHandler`1<ExceptionEventArgs> value);
    public virtual void add_DecodeFailed(EventHandler`1<ExceptionEventArgs> value);
    public virtual void remove_DecodeFailed(EventHandler`1<ExceptionEventArgs> value);
    public virtual void CopyPixels(Int32Rect sourceRect, Array pixels, int stride, int offset);
    public virtual void CopyPixels(Array pixels, int stride, int offset);
    public virtual void CopyPixels(Int32Rect sourceRect, IntPtr buffer, int bufferSize, int stride);
    public virtual double get_Width();
    public virtual double get_Height();
    public virtual ImageMetadata get_Metadata();
    private double GetWidthInternal();
    private double GetHeightInternal();
    internal virtual Size get_Size();
    internal bool get_DelayCreation();
    internal void set_DelayCreation(bool value);
    internal bool get_CreationCompleted();
    internal void set_CreationCompleted(bool value);
    internal void CompleteDelayedCreation();
    internal virtual void FinalizeCreation();
    private void EnsureShouldUseVirtuals();
    internal object get_SyncObject();
    internal bool get_IsSourceCached();
    internal void set_IsSourceCached(bool value);
    internal BitmapSourceSafeMILHandle get_WicSourceHandle();
    internal void set_WicSourceHandle(BitmapSourceSafeMILHandle value);
    internal virtual void UpdateCachedSettings();
    [FriendAccessAllowedAttribute]
internal void CriticalCopyPixels(Int32Rect sourceRect, Array pixels, int stride, int offset);
    internal void CriticalCopyPixels(Int32Rect sourceRect, IntPtr buffer, int bufferSize, int stride);
    protected void CheckIfSiteOfOrigin();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual BitmapSourceSafeMILHandle get_DUCECompatiblePtr();
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    internal virtual int GetChannelCountCore();
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    internal virtual Channel GetChannelCore(int index);
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
    internal virtual void UpdateBitmapSourceResource(Channel channel, bool skipOnChannelCheck);
    internal void RecoverFromDecodeFailure(Exception e);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    internal static PixelFormat GetClosestDUCEFormat(PixelFormat format, BitmapPalette palette);
    internal static BitmapSourceSafeMILHandle CreateCachedBitmap(BitmapFrame frame, BitmapSourceSafeMILHandle wicSource, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption, BitmapPalette palette);
    private void OnDecodeFailed(object sender, ExceptionEventArgs e);
    private void OnSourceDownloadCompleted(object sender, EventArgs e);
    private void OnSourceDownloadFailed(object sender, ExceptionEventArgs e);
    private void OnSourceDownloadProgress(object sender, DownloadProgressEventArgs e);
    private void CleanUpWeakEventSink();
    internal void RegisterDownloadEventSource(BitmapSource eventSource);
    internal void UnregisterDownloadEventSource();
    internal virtual bool IsValidForFinalizeCreation(bool throwIfInvalid);
    internal virtual bool get_ShouldCloneEventDelegates();
    protected virtual bool FreezeCore(bool isChecking);
    private void CopyCommon(BitmapSource sourceBitmap);
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    internal bool get_UsableWithoutCache();
    internal bool get_HasCompatibleFormat();
    internal static bool IsCompatibleFormat(PixelFormat format);
}
internal class System.Windows.Media.Imaging.BitmapSourceSafeMILHandle : SafeMILHandle {
    private static Guid _uuidBitmap;
    private static BitmapSourceSafeMILHandle();
    internal BitmapSourceSafeMILHandle(IntPtr handle);
    internal BitmapSourceSafeMILHandle(IntPtr handle, SafeMILHandle copyMemoryPressureFrom);
    internal void CalculateSize();
    private static long ComputeEstimatedSize(IntPtr bitmapObject);
    protected virtual bool ReleaseHandle();
}
internal class System.Windows.Media.Imaging.BitmapVisualManager : DispatcherObject {
    private RenderTargetBitmap _bitmapTarget;
    public BitmapVisualManager(RenderTargetBitmap bitmapTarget);
    public void Render(Visual visual);
    internal void Render(Visual visual, Matrix worldTransform, Rect windowClip);
}
public class System.Windows.Media.Imaging.BmpBitmapDecoder : BitmapDecoder {
    public BmpBitmapDecoder(Uri bitmapUri, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    public BmpBitmapDecoder(Stream bitmapStream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    internal BmpBitmapDecoder(SafeMILHandle decoderHandle, BitmapDecoder decoder, Uri baseUri, Uri uri, Stream stream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption, bool insertInDecoderCache, bool originalWritable, Stream uriStream, UnmanagedMemoryStream unmanagedMemoryStream, SafeFileHandle safeFilehandle);
    internal virtual void SealObject();
}
public class System.Windows.Media.Imaging.BmpBitmapEncoder : BitmapEncoder {
    private Guid _containerFormat;
    internal Guid ContainerFormat { get; }
    internal virtual Guid get_ContainerFormat();
    internal virtual void SetupFrame(SafeMILHandle frameEncodeHandle, SafeMILHandle encoderOptions);
    internal virtual void SealObject();
}
public class System.Windows.Media.Imaging.CachedBitmap : BitmapSource {
    private BitmapSource _source;
    private BitmapCreateOptions _createOptions;
    private BitmapCacheOption _cacheOption;
    public CachedBitmap(BitmapSource source, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    internal CachedBitmap(int pixelWidth, int pixelHeight, double dpiX, double dpiY, PixelFormat pixelFormat, BitmapPalette palette, IntPtr buffer, int bufferSize, int stride);
    internal CachedBitmap(BitmapSourceSafeMILHandle bitmap);
    internal CachedBitmap(int pixelWidth, int pixelHeight, double dpiX, double dpiY, PixelFormat pixelFormat, BitmapPalette palette, Array pixels, int stride);
    private void CopyCommon(CachedBitmap sourceBitmap);
    private void BeginInit();
    private void EndInit();
    internal virtual void FinalizeCreation();
    public CachedBitmap Clone();
    public CachedBitmap CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    private void InitFromWICSource(SafeMILHandle wicSource);
    private void InitFromMemoryPtr(int pixelWidth, int pixelHeight, double dpiX, double dpiY, PixelFormat pixelFormat, BitmapPalette palette, IntPtr buffer, int bufferSize, int stride);
}
public class System.Windows.Media.Imaging.ColorConvertedBitmap : BitmapSource {
    private BitmapSource _source;
    private ColorContext _sourceColorContext;
    private ColorContext _destinationColorContext;
    private PixelFormat _destinationFormat;
    public static DependencyProperty SourceProperty;
    public static DependencyProperty SourceColorContextProperty;
    public static DependencyProperty DestinationColorContextProperty;
    public static DependencyProperty DestinationFormatProperty;
    internal static BitmapSource s_Source;
    internal static ColorContext s_SourceColorContext;
    internal static ColorContext s_DestinationColorContext;
    internal static PixelFormat s_DestinationFormat;
    public BitmapSource Source { get; public set; }
    public ColorContext SourceColorContext { get; public set; }
    public ColorContext DestinationColorContext { get; public set; }
    public PixelFormat DestinationFormat { get; public set; }
    public ColorConvertedBitmap(BitmapSource source, ColorContext sourceColorContext, ColorContext destinationColorContext, PixelFormat format);
    private static ColorConvertedBitmap();
    public sealed virtual void BeginInit();
    public sealed virtual void EndInit();
    private void ClonePrequel(ColorConvertedBitmap otherColorConvertedBitmap);
    private void ClonePostscript(ColorConvertedBitmap otherColorConvertedBitmap);
    internal virtual void FinalizeCreation();
    private void SourcePropertyChangedHook(DependencyPropertyChangedEventArgs e);
    internal virtual bool IsValidForFinalizeCreation(bool throwIfInvalid);
    private void SourceColorContextPropertyChangedHook(DependencyPropertyChangedEventArgs e);
    private void DestinationColorContextPropertyChangedHook(DependencyPropertyChangedEventArgs e);
    private void DestinationFormatPropertyChangedHook(DependencyPropertyChangedEventArgs e);
    private static object CoerceSource(DependencyObject d, object value);
    private static object CoerceSourceColorContext(DependencyObject d, object value);
    private static object CoerceDestinationColorContext(DependencyObject d, object value);
    private static object CoerceDestinationFormat(DependencyObject d, object value);
    public ColorConvertedBitmap Clone();
    public ColorConvertedBitmap CloneCurrentValue();
    private static void SourcePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void SourceColorContextPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void DestinationColorContextPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void DestinationFormatPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public BitmapSource get_Source();
    public void set_Source(BitmapSource value);
    public ColorContext get_SourceColorContext();
    public void set_SourceColorContext(ColorContext value);
    public ColorContext get_DestinationColorContext();
    public void set_DestinationColorContext(ColorContext value);
    public PixelFormat get_DestinationFormat();
    public void set_DestinationFormat(PixelFormat value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
}
public class System.Windows.Media.Imaging.CroppedBitmap : BitmapSource {
    private BitmapSource _source;
    private Int32Rect _sourceRect;
    public static DependencyProperty SourceProperty;
    public static DependencyProperty SourceRectProperty;
    internal static BitmapSource s_Source;
    internal static Int32Rect s_SourceRect;
    public BitmapSource Source { get; public set; }
    public Int32Rect SourceRect { get; public set; }
    public CroppedBitmap(BitmapSource source, Int32Rect sourceRect);
    private static CroppedBitmap();
    public sealed virtual void BeginInit();
    public sealed virtual void EndInit();
    private void ClonePrequel(CroppedBitmap otherCroppedBitmap);
    private void ClonePostscript(CroppedBitmap otherCroppedBitmap);
    internal virtual void FinalizeCreation();
    private void SourcePropertyChangedHook(DependencyPropertyChangedEventArgs e);
    internal virtual bool IsValidForFinalizeCreation(bool throwIfInvalid);
    private void SourceRectPropertyChangedHook(DependencyPropertyChangedEventArgs e);
    private static object CoerceSource(DependencyObject d, object value);
    private static object CoerceSourceRect(DependencyObject d, object value);
    public CroppedBitmap Clone();
    public CroppedBitmap CloneCurrentValue();
    private static void SourcePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void SourceRectPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public BitmapSource get_Source();
    public void set_Source(BitmapSource value);
    public Int32Rect get_SourceRect();
    public void set_SourceRect(Int32Rect value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
}
public class System.Windows.Media.Imaging.DownloadProgressEventArgs : EventArgs {
    private int _percentComplete;
    public int Progress { get; }
    internal DownloadProgressEventArgs(int percentComplete);
    public int get_Progress();
}
public class System.Windows.Media.Imaging.FormatConvertedBitmap : BitmapSource {
    private BitmapSource _source;
    private PixelFormat _destinationFormat;
    private BitmapPalette _destinationPalette;
    private double _alphaThreshold;
    public static DependencyProperty SourceProperty;
    public static DependencyProperty DestinationFormatProperty;
    public static DependencyProperty DestinationPaletteProperty;
    public static DependencyProperty AlphaThresholdProperty;
    internal static BitmapSource s_Source;
    internal static PixelFormat s_DestinationFormat;
    internal static BitmapPalette s_DestinationPalette;
    internal static double c_AlphaThreshold;
    public BitmapSource Source { get; public set; }
    public PixelFormat DestinationFormat { get; public set; }
    public BitmapPalette DestinationPalette { get; public set; }
    public double AlphaThreshold { get; public set; }
    public FormatConvertedBitmap(BitmapSource source, PixelFormat destinationFormat, BitmapPalette destinationPalette, double alphaThreshold);
    private static FormatConvertedBitmap();
    public sealed virtual void BeginInit();
    public sealed virtual void EndInit();
    private void ClonePrequel(FormatConvertedBitmap otherFormatConvertedBitmap);
    private void ClonePostscript(FormatConvertedBitmap otherFormatConvertedBitmap);
    internal virtual void FinalizeCreation();
    private void SourcePropertyChangedHook(DependencyPropertyChangedEventArgs e);
    internal virtual bool IsValidForFinalizeCreation(bool throwIfInvalid);
    private void DestinationFormatPropertyChangedHook(DependencyPropertyChangedEventArgs e);
    private void DestinationPalettePropertyChangedHook(DependencyPropertyChangedEventArgs e);
    private void AlphaThresholdPropertyChangedHook(DependencyPropertyChangedEventArgs e);
    private static object CoerceSource(DependencyObject d, object value);
    private static object CoerceDestinationFormat(DependencyObject d, object value);
    private static object CoerceDestinationPalette(DependencyObject d, object value);
    private static object CoerceAlphaThreshold(DependencyObject d, object value);
    public FormatConvertedBitmap Clone();
    public FormatConvertedBitmap CloneCurrentValue();
    private static void SourcePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void DestinationFormatPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void DestinationPalettePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void AlphaThresholdPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public BitmapSource get_Source();
    public void set_Source(BitmapSource value);
    public PixelFormat get_DestinationFormat();
    public void set_DestinationFormat(PixelFormat value);
    public BitmapPalette get_DestinationPalette();
    public void set_DestinationPalette(BitmapPalette value);
    public double get_AlphaThreshold();
    public void set_AlphaThreshold(double value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
}
public class System.Windows.Media.Imaging.GifBitmapDecoder : BitmapDecoder {
    public GifBitmapDecoder(Uri bitmapUri, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    public GifBitmapDecoder(Stream bitmapStream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    internal GifBitmapDecoder(SafeMILHandle decoderHandle, BitmapDecoder decoder, Uri baseUri, Uri uri, Stream stream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption, bool insertInDecoderCache, bool originalWritable, Stream uriStream, UnmanagedMemoryStream unmanagedMemoryStream, SafeFileHandle safeFilehandle);
    internal virtual void SealObject();
}
public class System.Windows.Media.Imaging.GifBitmapEncoder : BitmapEncoder {
    private Guid _containerFormat;
    internal Guid ContainerFormat { get; }
    internal virtual Guid get_ContainerFormat();
    internal virtual void SetupFrame(SafeMILHandle frameEncodeHandle, SafeMILHandle encoderOptions);
    internal virtual void SealObject();
}
public class System.Windows.Media.Imaging.IconBitmapDecoder : BitmapDecoder {
    public IconBitmapDecoder(Uri bitmapUri, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    public IconBitmapDecoder(Stream bitmapStream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    internal IconBitmapDecoder(SafeMILHandle decoderHandle, BitmapDecoder decoder, Uri baseUri, Uri uri, Stream stream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption, bool insertInDecoderCache, bool originalWritable, Stream uriStream, UnmanagedMemoryStream unmanagedMemoryStream, SafeFileHandle safeFilehandle);
    internal virtual void SealObject();
}
internal static class System.Windows.Media.Imaging.ImagingCache : object {
    private static Hashtable _imageCache;
    private static Hashtable _decoderCache;
    private static int MAX_CACHE_SIZE;
    private static ImagingCache();
    internal static void AddToImageCache(Uri uri, object obj);
    internal static void RemoveFromImageCache(Uri uri);
    internal static object CheckImageCache(Uri uri);
    internal static void AddToDecoderCache(Uri uri, object obj);
    internal static void RemoveFromDecoderCache(Uri uri);
    internal static object CheckDecoderCache(Uri uri);
    private static void AddToCache(Uri uri, object obj, Hashtable table);
    private static void RemoveFromCache(Uri uri, Hashtable table);
    private static object CheckCache(Uri uri, Hashtable table);
}
public class System.Windows.Media.Imaging.InPlaceBitmapMetadataWriter : BitmapMetadata {
    private SafeMILHandle _fmeHandle;
    internal InPlaceBitmapMetadataWriter(SafeMILHandle fmeHandle, SafeMILHandle metadataHandle, object syncObject);
    internal static InPlaceBitmapMetadataWriter CreateFromFrameDecode(BitmapSourceSafeMILHandle frameHandle, object syncObject);
    internal static InPlaceBitmapMetadataWriter CreateFromDecoder(SafeMILHandle decoderHandle, object syncObject);
    public bool TrySave();
    public InPlaceBitmapMetadataWriter Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
}
public class System.Windows.Media.Imaging.JpegBitmapDecoder : BitmapDecoder {
    public JpegBitmapDecoder(Uri bitmapUri, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    public JpegBitmapDecoder(Stream bitmapStream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    internal JpegBitmapDecoder(SafeMILHandle decoderHandle, BitmapDecoder decoder, Uri baseUri, Uri uri, Stream stream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption, bool insertInDecoderCache, bool originalWritable, Stream uriStream, UnmanagedMemoryStream unmanagedMemoryStream, SafeFileHandle safeFilehandle);
    internal virtual void SealObject();
}
public class System.Windows.Media.Imaging.JpegBitmapEncoder : BitmapEncoder {
    private Guid _containerFormat;
    private static int c_defaultQualityLevel;
    private int _qualityLevel;
    private static WICBitmapTransformOptions c_defaultTransformation;
    private WICBitmapTransformOptions _transformation;
    public int QualityLevel { get; public set; }
    public Rotation Rotation { get; public set; }
    public bool FlipHorizontal { get; public set; }
    public bool FlipVertical { get; public set; }
    internal Guid ContainerFormat { get; }
    private bool Rotate90 { get; private set; }
    private bool Rotate180 { get; private set; }
    private bool Rotate270 { get; private set; }
    public int get_QualityLevel();
    public void set_QualityLevel(int value);
    public Rotation get_Rotation();
    public void set_Rotation(Rotation value);
    public bool get_FlipHorizontal();
    public void set_FlipHorizontal(bool value);
    public bool get_FlipVertical();
    public void set_FlipVertical(bool value);
    internal virtual Guid get_ContainerFormat();
    internal virtual void SetupFrame(SafeMILHandle frameEncodeHandle, SafeMILHandle encoderOptions);
    private bool get_Rotate90();
    private void set_Rotate90(bool value);
    private bool get_Rotate180();
    private void set_Rotate180(bool value);
    private bool get_Rotate270();
    private void set_Rotate270(bool value);
    internal virtual void SealObject();
}
public class System.Windows.Media.Imaging.LateBoundBitmapDecoder : BitmapDecoder {
    private bool _isDownloading;
    private bool _failed;
    private BitmapDecoder _realDecoder;
    private RequestCachePolicy _requestCachePolicy;
    public BitmapPalette Palette { get; }
    public ReadOnlyCollection`1<ColorContext> ColorContexts { get; }
    public BitmapSource Thumbnail { get; }
    public BitmapCodecInfo CodecInfo { get; }
    public ReadOnlyCollection`1<BitmapFrame> Frames { get; }
    public BitmapSource Preview { get; }
    public BitmapDecoder Decoder { get; }
    public bool IsDownloading { get; }
    internal LateBoundBitmapDecoder(Uri baseUri, Uri uri, Stream stream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption, RequestCachePolicy requestCachePolicy);
    public virtual BitmapPalette get_Palette();
    public virtual ReadOnlyCollection`1<ColorContext> get_ColorContexts();
    public virtual BitmapSource get_Thumbnail();
    public virtual BitmapCodecInfo get_CodecInfo();
    public virtual ReadOnlyCollection`1<BitmapFrame> get_Frames();
    public virtual BitmapSource get_Preview();
    public BitmapDecoder get_Decoder();
    public virtual bool get_IsDownloading();
    private void EnsureDecoder();
    internal object DownloadCallback(object arg);
    internal object ProgressCallback(object arg);
    internal object ExceptionCallback(object arg);
    internal virtual void SealObject();
}
public class System.Windows.Media.Imaging.PngBitmapDecoder : BitmapDecoder {
    public PngBitmapDecoder(Uri bitmapUri, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    public PngBitmapDecoder(Stream bitmapStream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    internal PngBitmapDecoder(SafeMILHandle decoderHandle, BitmapDecoder decoder, Uri baseUri, Uri uri, Stream stream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption, bool insertInDecoderCache, bool originalWritable, Stream uriStream, UnmanagedMemoryStream unmanagedMemoryStream, SafeFileHandle safeFilehandle);
    internal virtual void SealObject();
}
public class System.Windows.Media.Imaging.PngBitmapEncoder : BitmapEncoder {
    private Guid _containerFormat;
    private static PngInterlaceOption c_defaultInterlaceOption;
    private PngInterlaceOption _interlaceOption;
    public PngInterlaceOption Interlace { get; public set; }
    internal Guid ContainerFormat { get; }
    public PngInterlaceOption get_Interlace();
    public void set_Interlace(PngInterlaceOption value);
    internal virtual Guid get_ContainerFormat();
    internal virtual void SetupFrame(SafeMILHandle frameEncodeHandle, SafeMILHandle encoderOptions);
    internal virtual void SealObject();
}
public enum System.Windows.Media.Imaging.PngInterlaceOption : Enum {
    public int value__;
    public static PngInterlaceOption Default;
    public static PngInterlaceOption On;
    public static PngInterlaceOption Off;
}
internal class System.Windows.Media.Imaging.PROPARRAY : ValueType {
    internal UInt32 cElems;
    internal IntPtr pElems;
}
internal class System.Windows.Media.Imaging.PROPBAG2 : ValueType {
    internal UInt32 dwType;
    internal ushort vt;
    internal ushort cfType;
    internal IntPtr dwHint;
    internal IntPtr pstrName;
    internal Guid clsid;
    internal void Init(string name);
    internal void Clear();
}
internal class System.Windows.Media.Imaging.PROPVARIANT : ValueType {
    internal ushort varType;
    internal ushort wReserved1;
    internal ushort wReserved2;
    internal ushort wReserved3;
    internal byte bVal;
    internal sbyte cVal;
    internal ushort uiVal;
    internal short iVal;
    internal UInt32 uintVal;
    internal int intVal;
    internal ulong ulVal;
    internal long lVal;
    internal float fltVal;
    internal double dblVal;
    internal short boolVal;
    internal IntPtr pclsidVal;
    internal IntPtr pszVal;
    internal IntPtr pwszVal;
    internal IntPtr punkVal;
    internal PROPARRAY ca;
    internal FILETIME filetime;
    internal bool RequiresSyncObject { get; }
    private static void CopyBytes(Byte* pbTo, int cbTo, Byte* pbFrom, int cbFrom);
    internal void InitVector(Array array, Type type, VarEnum varEnum);
    internal void Init(Array array, Type type, VarEnum vt);
    internal void Init(String[] value, bool fAscii);
    internal void Init(object value);
    internal void Clear();
    internal object ToObject(object syncObject);
    internal bool get_RequiresSyncObject();
}
internal class System.Windows.Media.Imaging.QueueEntry : object {
    internal List`1<WeakReference> decoders;
    internal Uri inputUri;
    internal Stream inputStream;
    internal Stream outputStream;
    internal string streamPath;
    internal Byte[] readBuffer;
    internal long contentLength;
    internal string contentType;
    internal int lastPercent;
    internal WebRequest webRequest;
}
public class System.Windows.Media.Imaging.RenderTargetBitmap : BitmapSource {
    private SafeMILHandle _renderTargetBitmap;
    internal SafeMILHandle MILRenderTarget { get; }
    public RenderTargetBitmap(int pixelWidth, int pixelHeight, double dpiX, double dpiY, PixelFormat pixelFormat);
    protected virtual Freezable CreateInstanceCore();
    private void CopyCommon(RenderTargetBitmap sourceBitmap);
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    public void Render(Visual visual);
    public void Clear();
    internal SafeMILHandle get_MILRenderTarget();
    internal void RenderTargetContentsChanged();
    internal virtual void FinalizeCreation();
}
public enum System.Windows.Media.Imaging.Rotation : Enum {
    public int value__;
    public static Rotation Rotate0;
    public static Rotation Rotate90;
    public static Rotation Rotate180;
    public static Rotation Rotate270;
}
public class System.Windows.Media.Imaging.TiffBitmapDecoder : BitmapDecoder {
    internal bool IsMetadataFixedSize { get; }
    public TiffBitmapDecoder(Uri bitmapUri, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    public TiffBitmapDecoder(Stream bitmapStream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    internal TiffBitmapDecoder(SafeMILHandle decoderHandle, BitmapDecoder decoder, Uri baseUri, Uri uri, Stream stream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption, bool insertInDecoderCache, bool originalWritable, Stream uriStream, UnmanagedMemoryStream unmanagedMemoryStream, SafeFileHandle safeFilehandle);
    internal virtual bool get_IsMetadataFixedSize();
    internal virtual void SealObject();
}
public class System.Windows.Media.Imaging.TiffBitmapEncoder : BitmapEncoder {
    private Guid _containerFormat;
    private static TiffCompressOption c_defaultCompressionMethod;
    private TiffCompressOption _compressionMethod;
    public TiffCompressOption Compression { get; public set; }
    internal Guid ContainerFormat { get; }
    internal bool IsMetadataFixedSize { get; }
    public TiffCompressOption get_Compression();
    public void set_Compression(TiffCompressOption value);
    internal virtual Guid get_ContainerFormat();
    internal virtual bool get_IsMetadataFixedSize();
    internal virtual void SetupFrame(SafeMILHandle frameEncodeHandle, SafeMILHandle encoderOptions);
    internal virtual void SealObject();
}
public enum System.Windows.Media.Imaging.TiffCompressOption : Enum {
    public int value__;
    public static TiffCompressOption Default;
    public static TiffCompressOption None;
    public static TiffCompressOption Ccitt3;
    public static TiffCompressOption Ccitt4;
    public static TiffCompressOption Lzw;
    public static TiffCompressOption Rle;
    public static TiffCompressOption Zip;
}
public class System.Windows.Media.Imaging.TransformedBitmap : BitmapSource {
    private BitmapSource _source;
    private Transform _transform;
    public static DependencyProperty SourceProperty;
    public static DependencyProperty TransformProperty;
    internal static BitmapSource s_Source;
    internal static Transform s_Transform;
    public BitmapSource Source { get; public set; }
    public Transform Transform { get; public set; }
    public TransformedBitmap(BitmapSource source, Transform newTransform);
    private static TransformedBitmap();
    public sealed virtual void BeginInit();
    public sealed virtual void EndInit();
    private void ClonePrequel(TransformedBitmap otherTransformedBitmap);
    private void ClonePostscript(TransformedBitmap otherTransformedBitmap);
    internal bool CheckTransform(Transform newTransform);
    internal void GetParamsFromTransform(Transform newTransform, Double& scaleX, Double& scaleY, WICBitmapTransformOptions& options);
    internal virtual void FinalizeCreation();
    private void SourcePropertyChangedHook(DependencyPropertyChangedEventArgs e);
    internal virtual bool IsValidForFinalizeCreation(bool throwIfInvalid);
    private void TransformPropertyChangedHook(DependencyPropertyChangedEventArgs e);
    private static object CoerceSource(DependencyObject d, object value);
    private static object CoerceTransform(DependencyObject d, object value);
    public TransformedBitmap Clone();
    public TransformedBitmap CloneCurrentValue();
    private static void SourcePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void TransformPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public BitmapSource get_Source();
    public void set_Source(BitmapSource value);
    public Transform get_Transform();
    public void set_Transform(Transform value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
}
internal class System.Windows.Media.Imaging.UnknownBitmapDecoder : BitmapDecoder {
    private CoInitSafeHandle _safeHandle;
    internal UnknownBitmapDecoder(SafeMILHandle decoderHandle, BitmapDecoder decoder, Uri baseUri, Uri uri, Stream stream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption, bool insertInDecoderCache, bool originalWritable, Stream uriStream, UnmanagedMemoryStream unmanagedMemoryStream, SafeFileHandle safeFilehandle);
    internal virtual void SealObject();
}
internal class System.Windows.Media.Imaging.UnknownBitmapEncoder : BitmapEncoder {
    private Guid _containerFormat;
    internal Guid ContainerFormat { get; }
    public UnknownBitmapEncoder(Guid containerFormat);
    internal virtual Guid get_ContainerFormat();
    internal virtual void SetupFrame(SafeMILHandle frameEncodeHandle, SafeMILHandle encoderOptions);
    internal virtual void SealObject();
}
internal class System.Windows.Media.Imaging.UnmanagedBitmapWrapper : BitmapSource {
    public UnmanagedBitmapWrapper(BitmapSourceSafeMILHandle bitmapSource);
    internal UnmanagedBitmapWrapper(bool initialize);
    protected virtual Freezable CreateInstanceCore();
    private void CopyCommon(UnmanagedBitmapWrapper sourceBitmap);
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
}
internal static class System.Windows.Media.Imaging.ValidateEnums : object {
    public static bool IsRotationValid(object valueObject);
}
public class System.Windows.Media.Imaging.WmpBitmapDecoder : BitmapDecoder {
    public WmpBitmapDecoder(Uri bitmapUri, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    public WmpBitmapDecoder(Stream bitmapStream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption);
    internal WmpBitmapDecoder(SafeMILHandle decoderHandle, BitmapDecoder decoder, Uri baseUri, Uri uri, Stream stream, BitmapCreateOptions createOptions, BitmapCacheOption cacheOption, bool insertInDecoderCache, bool originalWritable, Stream uriStream, UnmanagedMemoryStream unmanagedMemoryStream, SafeFileHandle safeFilehandle);
    internal virtual void SealObject();
}
public class System.Windows.Media.Imaging.WmpBitmapEncoder : BitmapEncoder {
    private Guid _containerFormat;
    private static bool c_defaultLossless;
    private bool _lossless;
    private static float c_defaultImageQualityLevel;
    private float _imagequalitylevel;
    private static WICBitmapTransformOptions c_defaultTransformation;
    private WICBitmapTransformOptions _transformation;
    private static bool c_defaultUseCodecOptions;
    private bool _usecodecoptions;
    private static byte c_defaultQualityLevel;
    private byte _qualitylevel;
    private static byte c_defaultSubsamplingLevel;
    private byte _subsamplinglevel;
    private static byte c_defaultOverlapLevel;
    private byte _overlaplevel;
    private static short c_defaultHorizontalTileSlices;
    private short _horizontaltileslices;
    private static short c_defaultVerticalTileSlices;
    private short _verticaltileslices;
    private static bool c_defaultFrequencyOrder;
    private bool _frequencyorder;
    private static bool c_defaultInterleavedAlpha;
    private bool _interleavedalpha;
    private static byte c_defaultAlphaQualityLevel;
    private byte _alphaqualitylevel;
    private static bool c_defaultCompressedDomainTranscode;
    private bool _compresseddomaintranscode;
    private static byte c_defaultImageDataDiscardLevel;
    private byte _imagedatadiscardlevel;
    private static byte c_defaultAlphaDataDiscardLevel;
    private byte _alphadatadiscardlevel;
    private static bool c_defaultIgnoreOverlap;
    private bool _ignoreoverlap;
    public float ImageQualityLevel { get; public set; }
    public bool Lossless { get; public set; }
    public Rotation Rotation { get; public set; }
    public bool FlipHorizontal { get; public set; }
    public bool FlipVertical { get; public set; }
    public bool UseCodecOptions { get; public set; }
    public byte QualityLevel { get; public set; }
    public byte SubsamplingLevel { get; public set; }
    public byte OverlapLevel { get; public set; }
    public short HorizontalTileSlices { get; public set; }
    public short VerticalTileSlices { get; public set; }
    public bool FrequencyOrder { get; public set; }
    public bool InterleavedAlpha { get; public set; }
    public byte AlphaQualityLevel { get; public set; }
    public bool CompressedDomainTranscode { get; public set; }
    public byte ImageDataDiscardLevel { get; public set; }
    public byte AlphaDataDiscardLevel { get; public set; }
    public bool IgnoreOverlap { get; public set; }
    private bool Rotate90 { get; private set; }
    private bool Rotate180 { get; private set; }
    private bool Rotate270 { get; private set; }
    internal Guid ContainerFormat { get; }
    public float get_ImageQualityLevel();
    public void set_ImageQualityLevel(float value);
    public bool get_Lossless();
    public void set_Lossless(bool value);
    public Rotation get_Rotation();
    public void set_Rotation(Rotation value);
    public bool get_FlipHorizontal();
    public void set_FlipHorizontal(bool value);
    public bool get_FlipVertical();
    public void set_FlipVertical(bool value);
    public bool get_UseCodecOptions();
    public void set_UseCodecOptions(bool value);
    public byte get_QualityLevel();
    public void set_QualityLevel(byte value);
    public byte get_SubsamplingLevel();
    public void set_SubsamplingLevel(byte value);
    public byte get_OverlapLevel();
    public void set_OverlapLevel(byte value);
    public short get_HorizontalTileSlices();
    public void set_HorizontalTileSlices(short value);
    public short get_VerticalTileSlices();
    public void set_VerticalTileSlices(short value);
    public bool get_FrequencyOrder();
    public void set_FrequencyOrder(bool value);
    public bool get_InterleavedAlpha();
    public void set_InterleavedAlpha(bool value);
    public byte get_AlphaQualityLevel();
    public void set_AlphaQualityLevel(byte value);
    public bool get_CompressedDomainTranscode();
    public void set_CompressedDomainTranscode(bool value);
    public byte get_ImageDataDiscardLevel();
    public void set_ImageDataDiscardLevel(byte value);
    public byte get_AlphaDataDiscardLevel();
    public void set_AlphaDataDiscardLevel(byte value);
    public bool get_IgnoreOverlap();
    public void set_IgnoreOverlap(bool value);
    internal virtual void SetupFrame(SafeMILHandle frameEncodeHandle, SafeMILHandle encoderOptions);
    private bool get_Rotate90();
    private void set_Rotate90(bool value);
    private bool get_Rotate180();
    private void set_Rotate180(bool value);
    private bool get_Rotate270();
    private void set_Rotate270(bool value);
    internal virtual Guid get_ContainerFormat();
    internal virtual void SealObject();
}
public class System.Windows.Media.Imaging.WriteableBitmap : BitmapSource {
    private IntPtr _backBuffer;
    private UInt32 _backBufferSize;
    private SecurityCriticalDataForSet`1<int> _backBufferStride;
    private SafeMILHandle _pDoubleBufferedBitmap;
    private SafeMILHandle _pBackBufferLock;
    private BitmapSourceSafeMILHandle _pBackBuffer;
    private UInt32 _lockCount;
    private bool _hasDirtyRects;
    private bool _isWaitingForCommit;
    private ManualResetEvent _copyCompletedEvent;
    private EventHandler _committingBatchHandler;
    private bool _actLikeSimpleBitmap;
    public IntPtr BackBuffer { get; private set; }
    public int BackBufferStride { get; }
    private EventHandler CommittingBatchHandler { get; }
    public WriteableBitmap(BitmapSource source);
    public WriteableBitmap(int pixelWidth, int pixelHeight, double dpiX, double dpiY, PixelFormat pixelFormat, BitmapPalette palette);
    public void AddDirtyRect(Int32Rect dirtyRect);
    public WriteableBitmap Clone();
    public WriteableBitmap CloneCurrentValue();
    public void Lock();
    public bool TryLock(Duration timeout);
    public void Unlock();
    public void WritePixels(Int32Rect sourceRect, IntPtr sourceBuffer, int sourceBufferSize, int sourceBufferStride, int destinationX, int destinationY);
    public void WritePixels(Int32Rect sourceRect, Array sourceBuffer, int sourceBufferStride, int destinationX, int destinationY);
    public void WritePixels(Int32Rect sourceRect, IntPtr buffer, int bufferSize, int stride);
    public void WritePixels(Int32Rect sourceRect, Array pixels, int stride, int offset);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    private long GetEstimatedSize(int pixelWidth, int pixelHeight, PixelFormat pixelFormat);
    private void InitFromBitmapSource(BitmapSource source);
    private void WritePixelsImpl(Int32Rect sourceRect, IntPtr sourceBuffer, int sourceBufferSize, int sourceBufferStride, int destinationX, int destinationY, bool backwardsCompat);
    private bool AcquireBackBuffer(TimeSpan timeout, bool waitForCopy);
    private void CopyCommon(WriteableBitmap sourceBitmap);
    private void BeginInit();
    private void EndInit();
    internal virtual void FinalizeCreation();
    private void ValidateArrayAndGetInfo(Array sourceBuffer, bool backwardsCompat, Int32& elementSize, Int32& sourceBufferSize, Type& elementType);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual void UpdateBitmapSourceResource(Channel channel, bool skipOnChannelCheck);
    private void SubscribeToCommittingBatch();
    private void UnsubscribeFromCommittingBatch();
    private void OnCommittingBatch(object sender, EventArgs args);
    public IntPtr get_BackBuffer();
    private void set_BackBuffer(IntPtr value);
    public int get_BackBufferStride();
    private EventHandler get_CommittingBatchHandler();
}
[ValueSerializerAttribute("System.Windows.Media.Converters.Int32CollectionValueSerializer")]
[TypeConverterAttribute("System.Windows.Media.Int32CollectionConverter")]
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Int32Collection : Freezable {
    private static Int32Collection s_empty;
    internal FrugalStructList`1<int> _collection;
    internal UInt32 _version;
    public int Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Int32>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal static Int32Collection Empty { get; }
    public Int32Collection(int capacity);
    public Int32Collection(IEnumerable`1<int> collection);
    public Int32Collection Clone();
    public Int32Collection CloneCurrentValue();
    public sealed virtual void Add(int value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(int value);
    public sealed virtual int IndexOf(int value);
    public sealed virtual void Insert(int index, int value);
    public sealed virtual bool Remove(int value);
    public sealed virtual void RemoveAt(int index);
    internal void RemoveAtWithoutFiringPublicEvents(int index);
    public sealed virtual int get_Item(int index);
    public sealed virtual void set_Item(int index, int value);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(Int32[] array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Int32>.get_IsReadOnly();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<int> System.Collections.Generic.IEnumerable<System.Int32>.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal static Int32Collection get_Empty();
    internal int Internal_GetItem(int i);
    private int Cast(object value);
    private int AddHelper(int value);
    internal int AddWithoutFiringPublicEvents(int value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
    public static Int32Collection Parse(string source);
}
public class System.Windows.Media.Int32CollectionConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public enum System.Windows.Media.IntersectionDetail : Enum {
    public int value__;
    public static IntersectionDetail NotCalculated;
    public static IntersectionDetail Empty;
    public static IntersectionDetail FullyInside;
    public static IntersectionDetail FullyContains;
    public static IntersectionDetail Intersects;
}
public class System.Windows.Media.InvalidWmpVersionException : SystemException {
    public InvalidWmpVersionException(string message);
    protected InvalidWmpVersionException(SerializationInfo info, StreamingContext context);
    public InvalidWmpVersionException(string message, Exception innerException);
}
internal enum System.Windows.Media.KnownColor : Enum {
    public UInt32 value__;
    public static KnownColor AliceBlue;
    public static KnownColor AntiqueWhite;
    public static KnownColor Aqua;
    public static KnownColor Aquamarine;
    public static KnownColor Azure;
    public static KnownColor Beige;
    public static KnownColor Bisque;
    public static KnownColor Black;
    public static KnownColor BlanchedAlmond;
    public static KnownColor Blue;
    public static KnownColor BlueViolet;
    public static KnownColor Brown;
    public static KnownColor BurlyWood;
    public static KnownColor CadetBlue;
    public static KnownColor Chartreuse;
    public static KnownColor Chocolate;
    public static KnownColor Coral;
    public static KnownColor CornflowerBlue;
    public static KnownColor Cornsilk;
    public static KnownColor Crimson;
    public static KnownColor Cyan;
    public static KnownColor DarkBlue;
    public static KnownColor DarkCyan;
    public static KnownColor DarkGoldenrod;
    public static KnownColor DarkGray;
    public static KnownColor DarkGreen;
    public static KnownColor DarkKhaki;
    public static KnownColor DarkMagenta;
    public static KnownColor DarkOliveGreen;
    public static KnownColor DarkOrange;
    public static KnownColor DarkOrchid;
    public static KnownColor DarkRed;
    public static KnownColor DarkSalmon;
    public static KnownColor DarkSeaGreen;
    public static KnownColor DarkSlateBlue;
    public static KnownColor DarkSlateGray;
    public static KnownColor DarkTurquoise;
    public static KnownColor DarkViolet;
    public static KnownColor DeepPink;
    public static KnownColor DeepSkyBlue;
    public static KnownColor DimGray;
    public static KnownColor DodgerBlue;
    public static KnownColor Firebrick;
    public static KnownColor FloralWhite;
    public static KnownColor ForestGreen;
    public static KnownColor Fuchsia;
    public static KnownColor Gainsboro;
    public static KnownColor GhostWhite;
    public static KnownColor Gold;
    public static KnownColor Goldenrod;
    public static KnownColor Gray;
    public static KnownColor Green;
    public static KnownColor GreenYellow;
    public static KnownColor Honeydew;
    public static KnownColor HotPink;
    public static KnownColor IndianRed;
    public static KnownColor Indigo;
    public static KnownColor Ivory;
    public static KnownColor Khaki;
    public static KnownColor Lavender;
    public static KnownColor LavenderBlush;
    public static KnownColor LawnGreen;
    public static KnownColor LemonChiffon;
    public static KnownColor LightBlue;
    public static KnownColor LightCoral;
    public static KnownColor LightCyan;
    public static KnownColor LightGoldenrodYellow;
    public static KnownColor LightGreen;
    public static KnownColor LightGray;
    public static KnownColor LightPink;
    public static KnownColor LightSalmon;
    public static KnownColor LightSeaGreen;
    public static KnownColor LightSkyBlue;
    public static KnownColor LightSlateGray;
    public static KnownColor LightSteelBlue;
    public static KnownColor LightYellow;
    public static KnownColor Lime;
    public static KnownColor LimeGreen;
    public static KnownColor Linen;
    public static KnownColor Magenta;
    public static KnownColor Maroon;
    public static KnownColor MediumAquamarine;
    public static KnownColor MediumBlue;
    public static KnownColor MediumOrchid;
    public static KnownColor MediumPurple;
    public static KnownColor MediumSeaGreen;
    public static KnownColor MediumSlateBlue;
    public static KnownColor MediumSpringGreen;
    public static KnownColor MediumTurquoise;
    public static KnownColor MediumVioletRed;
    public static KnownColor MidnightBlue;
    public static KnownColor MintCream;
    public static KnownColor MistyRose;
    public static KnownColor Moccasin;
    public static KnownColor NavajoWhite;
    public static KnownColor Navy;
    public static KnownColor OldLace;
    public static KnownColor Olive;
    public static KnownColor OliveDrab;
    public static KnownColor Orange;
    public static KnownColor OrangeRed;
    public static KnownColor Orchid;
    public static KnownColor PaleGoldenrod;
    public static KnownColor PaleGreen;
    public static KnownColor PaleTurquoise;
    public static KnownColor PaleVioletRed;
    public static KnownColor PapayaWhip;
    public static KnownColor PeachPuff;
    public static KnownColor Peru;
    public static KnownColor Pink;
    public static KnownColor Plum;
    public static KnownColor PowderBlue;
    public static KnownColor Purple;
    public static KnownColor Red;
    public static KnownColor RosyBrown;
    public static KnownColor RoyalBlue;
    public static KnownColor SaddleBrown;
    public static KnownColor Salmon;
    public static KnownColor SandyBrown;
    public static KnownColor SeaGreen;
    public static KnownColor SeaShell;
    public static KnownColor Sienna;
    public static KnownColor Silver;
    public static KnownColor SkyBlue;
    public static KnownColor SlateBlue;
    public static KnownColor SlateGray;
    public static KnownColor Snow;
    public static KnownColor SpringGreen;
    public static KnownColor SteelBlue;
    public static KnownColor Tan;
    public static KnownColor Teal;
    public static KnownColor Thistle;
    public static KnownColor Tomato;
    public static KnownColor Transparent;
    public static KnownColor Turquoise;
    public static KnownColor Violet;
    public static KnownColor Wheat;
    public static KnownColor White;
    public static KnownColor WhiteSmoke;
    public static KnownColor Yellow;
    public static KnownColor YellowGreen;
    public static KnownColor UnknownColor;
}
internal static class System.Windows.Media.KnownColors : object {
    private static Dictionary`2<UInt32, SolidColorBrush> s_solidColorBrushCache;
    private static Dictionary`2<string, KnownColor> s_knownArgbColors;
    private static KnownColors();
    public static SolidColorBrush ColorStringToKnownBrush(string s);
    public static bool IsKnownSolidColorBrush(SolidColorBrush scp);
    public static SolidColorBrush SolidColorBrushFromUint(UInt32 argb);
    internal static string MatchColor(string colorString, Boolean& isKnownColor, Boolean& isNumericColor, Boolean& isContextColor, Boolean& isScRgbColor);
    internal static KnownColor ColorStringToKnownColor(string colorString);
    internal static KnownColor ArgbStringToKnownColor(string argbString);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.LanguageSpecificStringDictionary : object {
    private IDictionary`2<XmlLanguage, string> _innerDictionary;
    public int Count { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public string Item { get; public set; }
    [CLSCompliantAttribute("False")]
public ICollection`1<XmlLanguage> Keys { get; }
    [CLSCompliantAttribute("False")]
public ICollection`1<string> Values { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    internal LanguageSpecificStringDictionary(IDictionary`2<XmlLanguage, string> innerDictionary);
    [CLSCompliantAttribute("False")]
public sealed virtual IEnumerator`1<KeyValuePair`2<XmlLanguage, string>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    public sealed virtual bool TryGetValue(XmlLanguage key, String& value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    [CLSCompliantAttribute("False")]
public sealed virtual void Add(KeyValuePair`2<XmlLanguage, string> item);
    public sealed virtual void Clear();
    [CLSCompliantAttribute("False")]
public sealed virtual bool Contains(KeyValuePair`2<XmlLanguage, string> item);
    [CLSCompliantAttribute("False")]
public sealed virtual void CopyTo(KeyValuePair`2[] array, int index);
    [CLSCompliantAttribute("False")]
public sealed virtual bool Remove(KeyValuePair`2<XmlLanguage, string> item);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public sealed virtual void Add(XmlLanguage key, string value);
    public sealed virtual bool ContainsKey(XmlLanguage key);
    public sealed virtual bool Remove(XmlLanguage key);
    public sealed virtual string get_Item(XmlLanguage key);
    public sealed virtual void set_Item(XmlLanguage key, string value);
    public sealed virtual ICollection`1<XmlLanguage> get_Keys();
    public sealed virtual ICollection`1<string> get_Values();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private string ValidateValue(string value);
    private string ConvertValue(object value);
    private XmlLanguage ConvertKey(object key);
    private XmlLanguage TryConvertKey(object key);
}
public class System.Windows.Media.LinearGradientBrush : GradientBrush {
    public static DependencyProperty StartPointProperty;
    public static DependencyProperty EndPointProperty;
    internal MultiChannelResource _duceResource;
    internal static Point s_StartPoint;
    internal static Point s_EndPoint;
    public Point StartPoint { get; public set; }
    public Point EndPoint { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    public LinearGradientBrush(Color startColor, Color endColor, double angle);
    public LinearGradientBrush(Color startColor, Color endColor, Point startPoint, Point endPoint);
    public LinearGradientBrush(GradientStopCollection gradientStopCollection);
    public LinearGradientBrush(GradientStopCollection gradientStopCollection, double angle);
    public LinearGradientBrush(GradientStopCollection gradientStopCollection, Point startPoint, Point endPoint);
    private static LinearGradientBrush();
    private void ManualUpdateResource(Channel channel, bool skipOnChannelCheck);
    private Point EndPointFromAngle(double angle);
    public LinearGradientBrush Clone();
    public LinearGradientBrush CloneCurrentValue();
    private static void StartPointPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void EndPointPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Point get_StartPoint();
    public void set_StartPoint(Point value);
    public Point get_EndPoint();
    public void set_EndPoint(Point value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    internal virtual int get_EffectiveValuesInitialSize();
}
public class System.Windows.Media.LineGeometry : Geometry {
    private static Byte[] s_lineTypes;
    private static UInt32 c_segmentCount;
    private static UInt32 c_pointCount;
    public static DependencyProperty StartPointProperty;
    public static DependencyProperty EndPointProperty;
    internal MultiChannelResource _duceResource;
    internal static Point s_StartPoint;
    internal static Point s_EndPoint;
    public Rect Bounds { get; }
    public Point StartPoint { get; public set; }
    public Point EndPoint { get; public set; }
    public LineGeometry(Point startPoint, Point endPoint);
    public LineGeometry(Point startPoint, Point endPoint, Transform transform);
    private static LineGeometry();
    public virtual Rect get_Bounds();
    internal virtual Rect GetBoundsInternal(Pen pen, Matrix worldMatrix, double tolerance, ToleranceType type);
    internal static Rect GetBoundsHelper(Pen pen, Matrix worldMatrix, Point pt1, Point pt2, Matrix geometryMatrix, double tolerance, ToleranceType type);
    internal virtual bool ContainsInternal(Pen pen, Point hitPoint, double tolerance, ToleranceType type);
    public virtual bool IsEmpty();
    public virtual bool MayHaveCurves();
    public virtual double GetArea(double tolerance, ToleranceType type);
    private Byte[] GetTypeList();
    private UInt32 GetPointCount();
    private UInt32 GetSegmentCount();
    internal virtual PathGeometry GetAsPathGeometry();
    internal virtual PathFigureCollection GetTransformedFigureCollection(Transform transform);
    internal virtual PathGeometryData GetPathGeometryData();
    public LineGeometry Clone();
    public LineGeometry CloneCurrentValue();
    private static void StartPointPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void EndPointPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Point get_StartPoint();
    public void set_StartPoint(Point value);
    public Point get_EndPoint();
    public void set_EndPoint(Point value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
}
public class System.Windows.Media.LineSegment : PathSegment {
    public static DependencyProperty PointProperty;
    internal static Point s_Point;
    public Point Point { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    public LineSegment(Point point, bool isStroked);
    internal LineSegment(Point point, bool isStroked, bool isSmoothJoin);
    private static LineSegment();
    internal virtual void AddToFigure(Matrix matrix, PathFigure figure, Point& current);
    internal virtual void SerializeData(StreamGeometryContext ctx);
    internal virtual bool IsCurved();
    internal virtual string ConvertToString(string format, IFormatProvider provider);
    public LineSegment Clone();
    public LineSegment CloneCurrentValue();
    public Point get_Point();
    public void set_Point(Point value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual int get_EffectiveValuesInitialSize();
}
internal class System.Windows.Media.MapClass : object {
    public Map`1<bool> _map_ofBrushes;
    internal bool IsEmpty { get; }
    internal bool get_IsEmpty();
}
internal class System.Windows.Media.MatrixStack : object {
    private Matrix[] _items;
    private int _size;
    private static int s_initialSize;
    private static int s_growFactor;
    private static int s_shrinkFactor;
    private int _highWaterMark;
    private int _observeCount;
    private static int s_trimCount;
    public bool IsEmpty { get; }
    private static MatrixStack();
    private void EnsureCapacity();
    public void Push(Matrix& matrix, bool combine);
    public void Push(Transform transform, bool combine);
    public void Push(Vector offset, bool combine);
    public void Pop();
    public Matrix Peek();
    public bool get_IsEmpty();
    public void Optimize();
}
public class System.Windows.Media.MatrixTransform : Transform {
    public static DependencyProperty MatrixProperty;
    internal MultiChannelResource _duceResource;
    internal static Matrix s_Matrix;
    public Matrix Value { get; }
    internal bool IsIdentity { get; }
    public Matrix Matrix { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    public MatrixTransform(double m11, double m12, double m21, double m22, double offsetX, double offsetY);
    public MatrixTransform(Matrix matrix);
    private static MatrixTransform();
    public virtual Matrix get_Value();
    internal virtual bool get_IsIdentity();
    internal virtual bool CanSerializeToString();
    internal virtual string ConvertToString(string format, IFormatProvider provider);
    internal virtual void TransformRect(Rect& rect);
    internal virtual void MultiplyValueByMatrix(Matrix& result, Matrix& matrixToMultiplyBy);
    public MatrixTransform Clone();
    public MatrixTransform CloneCurrentValue();
    private static void MatrixPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Matrix get_Matrix();
    public void set_Matrix(Matrix value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    internal virtual int get_EffectiveValuesInitialSize();
}
public abstract class System.Windows.Media.Media3D.AffineTransform3D : Transform3D {
    public bool IsAffine { get; }
    public virtual bool get_IsAffine();
    public AffineTransform3D Clone();
    public AffineTransform3D CloneCurrentValue();
}
public class System.Windows.Media.Media3D.AmbientLight : Light {
    internal MultiChannelResource _duceResource;
    internal int EffectiveValuesInitialSize { get; }
    public AmbientLight(Color ambientColor);
    public AmbientLight Clone();
    public AmbientLight CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    internal virtual int get_EffectiveValuesInitialSize();
}
public class System.Windows.Media.Media3D.AxisAngleRotation3D : Rotation3D {
    private Quaternion _cachedQuaternionValue;
    internal static Quaternion c_dirtyQuaternion;
    public static DependencyProperty AxisProperty;
    public static DependencyProperty AngleProperty;
    internal MultiChannelResource _duceResource;
    internal static Vector3D s_Axis;
    internal static double c_Angle;
    internal Quaternion InternalQuaternion { get; }
    public Vector3D Axis { get; public set; }
    public double Angle { get; public set; }
    public AxisAngleRotation3D(Vector3D axis, double angle);
    private static AxisAngleRotation3D();
    internal virtual Quaternion get_InternalQuaternion();
    internal void AxisPropertyChangedHook(DependencyPropertyChangedEventArgs e);
    internal void AnglePropertyChangedHook(DependencyPropertyChangedEventArgs e);
    public AxisAngleRotation3D Clone();
    public AxisAngleRotation3D CloneCurrentValue();
    private static void AxisPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void AnglePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Vector3D get_Axis();
    public void set_Axis(Vector3D value);
    public double get_Angle();
    public void set_Angle(double value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
}
public abstract class System.Windows.Media.Media3D.Camera : Animatable {
    public static DependencyProperty TransformProperty;
    internal static Transform3D s_Transform;
    public Transform3D Transform { get; public set; }
    private static Camera();
    internal abstract virtual RayHitTestParameters RayFromViewportPoint(Point point, Size viewSize, Rect3D boundingRect, Double& distanceAdjustment);
    internal abstract virtual Matrix3D GetViewMatrix();
    internal abstract virtual Matrix3D GetProjectionMatrix(double aspectRatio);
    internal static void PrependInverseTransform(Transform3D transform, Matrix3D& viewMatrix);
    internal static void PrependInverseTransform(Matrix3D matrix, Matrix3D& viewMatrix);
    public Camera Clone();
    public Camera CloneCurrentValue();
    private static void TransformPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Transform3D get_Transform();
    public void set_Transform(Transform3D value);
    internal abstract virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    internal abstract virtual void ReleaseOnChannelCore(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    internal abstract virtual ResourceHandle GetHandleCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    internal abstract virtual int GetChannelCountCore();
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    internal abstract virtual Channel GetChannelCore(int index);
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal virtual string ConvertToString(string format, IFormatProvider provider);
}
[ContentPropertyAttribute("Children")]
public class System.Windows.Media.Media3D.ContainerUIElement3D : UIElement3D {
    private Visual3DCollection _children;
    protected int Visual3DChildrenCount { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public Visual3DCollection Children { get; }
    protected virtual Visual3D GetVisual3DChild(int index);
    protected virtual int get_Visual3DChildrenCount();
    public Visual3DCollection get_Children();
    protected virtual AutomationPeer OnCreateAutomationPeer();
}
public class System.Windows.Media.Media3D.Converters.Matrix3DValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Media3D.Converters.Point3DCollectionValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Media3D.Converters.Point3DValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Media3D.Converters.Point4DValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Media3D.Converters.QuaternionValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Media3D.Converters.Rect3DValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Media3D.Converters.Size3DValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Media3D.Converters.Vector3DCollectionValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Media3D.Converters.Vector3DValueSerializer : ValueSerializer {
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
}
public class System.Windows.Media.Media3D.DiffuseMaterial : Material {
    public static DependencyProperty ColorProperty;
    public static DependencyProperty AmbientColorProperty;
    public static DependencyProperty BrushProperty;
    internal MultiChannelResource _duceResource;
    internal static Color s_Color;
    internal static Color s_AmbientColor;
    internal static Brush s_Brush;
    public Color Color { get; public set; }
    public Color AmbientColor { get; public set; }
    public Brush Brush { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    public DiffuseMaterial(Brush brush);
    private static DiffuseMaterial();
    public DiffuseMaterial Clone();
    public DiffuseMaterial CloneCurrentValue();
    private static void ColorPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void AmbientColorPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void BrushPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Color get_Color();
    public void set_Color(Color value);
    public Color get_AmbientColor();
    public void set_AmbientColor(Color value);
    public Brush get_Brush();
    public void set_Brush(Brush value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    internal virtual int get_EffectiveValuesInitialSize();
}
public class System.Windows.Media.Media3D.DirectionalLight : Light {
    public static DependencyProperty DirectionProperty;
    internal MultiChannelResource _duceResource;
    internal static Vector3D s_Direction;
    public Vector3D Direction { get; public set; }
    public DirectionalLight(Color diffuseColor, Vector3D direction);
    private static DirectionalLight();
    public DirectionalLight Clone();
    public DirectionalLight CloneCurrentValue();
    private static void DirectionPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Vector3D get_Direction();
    public void set_Direction(Vector3D value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
}
public class System.Windows.Media.Media3D.EmissiveMaterial : Material {
    public static DependencyProperty ColorProperty;
    public static DependencyProperty BrushProperty;
    internal MultiChannelResource _duceResource;
    internal static Color s_Color;
    internal static Brush s_Brush;
    public Color Color { get; public set; }
    public Brush Brush { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    public EmissiveMaterial(Brush brush);
    private static EmissiveMaterial();
    public EmissiveMaterial Clone();
    public EmissiveMaterial CloneCurrentValue();
    private static void ColorPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void BrushPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Color get_Color();
    public void set_Color(Color value);
    public Brush get_Brush();
    public void set_Brush(Brush value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    internal virtual int get_EffectiveValuesInitialSize();
}
public class System.Windows.Media.Media3D.GeneralTransform2DTo3D : Freezable {
    private GeneralTransform _transform2D;
    private GeneralTransform3D _transform3D;
    private Point3DCollection _positions;
    private PointCollection _textureCoords;
    private Int32Collection _triIndices;
    private Rect _childBounds;
    internal GeneralTransform2DTo3D(GeneralTransform transform2D, Viewport2DVisual3D containingVisual3D, GeneralTransform3D transform3D);
    public bool TryTransform(Point inPoint, Point3D& result);
    public Point3D Transform(Point point);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    private void CopyCommon(GeneralTransform2DTo3D transform);
}
[LocalizabilityAttribute("0")]
public abstract class System.Windows.Media.Media3D.GeneralTransform3D : Animatable {
    public GeneralTransform3D Inverse { get; }
    internal Transform3D AffineTransform { get; }
    public abstract virtual bool TryTransform(Point3D inPoint, Point3D& result);
    public Point3D Transform(Point3D point);
    public abstract virtual Rect3D TransformBounds(Rect3D rect);
    public abstract virtual GeneralTransform3D get_Inverse();
    [FriendAccessAllowedAttribute]
internal abstract virtual Transform3D get_AffineTransform();
    public GeneralTransform3D Clone();
    public GeneralTransform3D CloneCurrentValue();
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal virtual string ConvertToString(string format, IFormatProvider provider);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Media3D.GeneralTransform3DCollection : Animatable {
    private static GeneralTransform3DCollection s_empty;
    internal FrugalStructList`1<GeneralTransform3D> _collection;
    internal UInt32 _version;
    public GeneralTransform3D Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.GeneralTransform3D>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal static GeneralTransform3DCollection Empty { get; }
    public GeneralTransform3DCollection(int capacity);
    public GeneralTransform3DCollection(IEnumerable`1<GeneralTransform3D> collection);
    public GeneralTransform3DCollection Clone();
    public GeneralTransform3DCollection CloneCurrentValue();
    public sealed virtual void Add(GeneralTransform3D value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(GeneralTransform3D value);
    public sealed virtual int IndexOf(GeneralTransform3D value);
    public sealed virtual void Insert(int index, GeneralTransform3D value);
    public sealed virtual bool Remove(GeneralTransform3D value);
    public sealed virtual void RemoveAt(int index);
    internal void RemoveAtWithoutFiringPublicEvents(int index);
    public sealed virtual GeneralTransform3D get_Item(int index);
    public sealed virtual void set_Item(int index, GeneralTransform3D value);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(GeneralTransform3D[] array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.GeneralTransform3D>.get_IsReadOnly();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<GeneralTransform3D> System.Collections.Generic.IEnumerable<System.Windows.Media.Media3D.GeneralTransform3D>.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal static GeneralTransform3DCollection get_Empty();
    internal GeneralTransform3D Internal_GetItem(int i);
    internal virtual void OnInheritanceContextChangedCore(EventArgs args);
    private GeneralTransform3D Cast(object value);
    private int AddHelper(GeneralTransform3D value);
    internal int AddWithoutFiringPublicEvents(GeneralTransform3D value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected virtual bool FreezeCore(bool isChecking);
}
[LocalizabilityAttribute("0")]
[ContentPropertyAttribute("Children")]
public class System.Windows.Media.Media3D.GeneralTransform3DGroup : GeneralTransform3D {
    public static DependencyProperty ChildrenProperty;
    internal static GeneralTransform3DCollection s_Children;
    public GeneralTransform3D Inverse { get; }
    internal Transform3D AffineTransform { get; }
    public GeneralTransform3DCollection Children { get; public set; }
    private static GeneralTransform3DGroup();
    public virtual bool TryTransform(Point3D inPoint, Point3D& result);
    public virtual Rect3D TransformBounds(Rect3D rect);
    public virtual GeneralTransform3D get_Inverse();
    [FriendAccessAllowedAttribute]
internal virtual Transform3D get_AffineTransform();
    public GeneralTransform3DGroup Clone();
    public GeneralTransform3DGroup CloneCurrentValue();
    public GeneralTransform3DCollection get_Children();
    public void set_Children(GeneralTransform3DCollection value);
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.Media3D.GeneralTransform3DTo2D : Freezable {
    private Matrix3D _projectionTransform;
    private GeneralTransform _transformBetween2D;
    internal GeneralTransform3DTo2D(Matrix3D projectionTransform, GeneralTransform transformBetween2D);
    public bool TryTransform(Point3D inPoint, Point& result);
    public Point Transform(Point3D point);
    public Rect TransformBounds(Rect3D rect3D);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    private void CopyCommon(GeneralTransform3DTo2D transform);
}
[LocalizabilityAttribute("0")]
public abstract class System.Windows.Media.Media3D.Geometry3D : Animatable {
    public Rect3D Bounds { get; }
    public abstract virtual Rect3D get_Bounds();
    internal void RayHitTest(RayHitTestParameters rayParams, FaceType facesToHit);
    internal abstract virtual void RayHitTestCore(RayHitTestParameters rayParams, FaceType hitTestableFaces);
    public Geometry3D Clone();
    public Geometry3D CloneCurrentValue();
    internal abstract virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    internal abstract virtual void ReleaseOnChannelCore(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    internal abstract virtual ResourceHandle GetHandleCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    internal abstract virtual int GetChannelCountCore();
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    internal abstract virtual Channel GetChannelCore(int index);
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
}
public class System.Windows.Media.Media3D.GeometryModel3D : Model3D {
    public static DependencyProperty GeometryProperty;
    public static DependencyProperty MaterialProperty;
    public static DependencyProperty BackMaterialProperty;
    internal MultiChannelResource _duceResource;
    public Geometry3D Geometry { get; public set; }
    public Material Material { get; public set; }
    public Material BackMaterial { get; public set; }
    public GeometryModel3D(Geometry3D geometry, Material material);
    private static GeometryModel3D();
    internal virtual Rect3D CalculateSubgraphBoundsInnerSpace();
    internal virtual void RayHitTestCore(RayHitTestParameters rayParams);
    internal void MaterialPropertyChangedHook(DependencyPropertyChangedEventArgs e);
    internal void BackMaterialPropertyChangedHook(DependencyPropertyChangedEventArgs e);
    public GeometryModel3D Clone();
    public GeometryModel3D CloneCurrentValue();
    private static void GeometryPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void MaterialPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void BackMaterialPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Geometry3D get_Geometry();
    public void set_Geometry(Geometry3D value);
    public Material get_Material();
    public void set_Material(Material value);
    public Material get_BackMaterial();
    public void set_BackMaterial(Material value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
}
public abstract class System.Windows.Media.Media3D.HitTestParameters3D : object {
    internal Visual3D CurrentVisual;
    internal Model3D CurrentModel;
    internal GeometryModel3D CurrentGeometry;
    private Nullable`1<Matrix3D> _hitTestProjectionMatrix;
    private Matrix3DStack _visualTransformStack;
    private Matrix3DStack _modelTransformStack;
    internal bool HasWorldTransformMatrix { get; }
    internal Matrix3D WorldTransformMatrix { get; }
    internal bool HasModelTransformMatrix { get; }
    internal Matrix3D ModelTransformMatrix { get; }
    internal bool HasHitTestProjectionMatrix { get; }
    internal Matrix3D HitTestProjectionMatrix { get; internal set; }
    internal void PushVisualTransform(Transform3D transform);
    internal void PushModelTransform(Transform3D transform);
    internal void PopTransform(Transform3D transform);
    internal bool get_HasWorldTransformMatrix();
    internal Matrix3D get_WorldTransformMatrix();
    internal bool get_HasModelTransformMatrix();
    internal Matrix3D get_ModelTransformMatrix();
    internal bool get_HasHitTestProjectionMatrix();
    internal Matrix3D get_HitTestProjectionMatrix();
    internal void set_HitTestProjectionMatrix(Matrix3D value);
}
public abstract class System.Windows.Media.Media3D.Light : Model3D {
    public static DependencyProperty ColorProperty;
    internal static Color s_Color;
    public Color Color { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    private static Light();
    internal virtual void RayHitTestCore(RayHitTestParameters rayParams);
    internal virtual Rect3D CalculateSubgraphBoundsInnerSpace();
    public Light Clone();
    public Light CloneCurrentValue();
    private static void ColorPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Color get_Color();
    public void set_Color(Color value);
    internal virtual int get_EffectiveValuesInitialSize();
}
[LocalizabilityAttribute("0")]
public abstract class System.Windows.Media.Media3D.Material : Animatable {
    public Material Clone();
    public Material CloneCurrentValue();
    internal abstract virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    internal abstract virtual void ReleaseOnChannelCore(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    internal abstract virtual ResourceHandle GetHandleCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    internal abstract virtual int GetChannelCountCore();
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    internal abstract virtual Channel GetChannelCore(int index);
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal virtual string ConvertToString(string format, IFormatProvider provider);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Media3D.MaterialCollection : Animatable {
    [CompilerGeneratedAttribute]
private ItemInsertedHandler ItemInserted;
    [CompilerGeneratedAttribute]
private ItemRemovedHandler ItemRemoved;
    private static MaterialCollection s_empty;
    internal FrugalStructList`1<Material> _collection;
    internal UInt32 _version;
    public Material Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.Material>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal static MaterialCollection Empty { get; }
    public MaterialCollection(int capacity);
    public MaterialCollection(IEnumerable`1<Material> collection);
    public MaterialCollection Clone();
    public MaterialCollection CloneCurrentValue();
    public sealed virtual void Add(Material value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Material value);
    public sealed virtual int IndexOf(Material value);
    public sealed virtual void Insert(int index, Material value);
    public sealed virtual bool Remove(Material value);
    public sealed virtual void RemoveAt(int index);
    internal void RemoveAtWithoutFiringPublicEvents(int index);
    public sealed virtual Material get_Item(int index);
    public sealed virtual void set_Item(int index, Material value);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(Material[] array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.Material>.get_IsReadOnly();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<Material> System.Collections.Generic.IEnumerable<System.Windows.Media.Media3D.Material>.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal static MaterialCollection get_Empty();
    internal Material Internal_GetItem(int i);
    internal virtual void OnInheritanceContextChangedCore(EventArgs args);
    private Material Cast(object value);
    private int AddHelper(Material value);
    internal int AddWithoutFiringPublicEvents(Material value);
    [CompilerGeneratedAttribute]
internal void add_ItemInserted(ItemInsertedHandler value);
    [CompilerGeneratedAttribute]
internal void remove_ItemInserted(ItemInsertedHandler value);
    [CompilerGeneratedAttribute]
internal void add_ItemRemoved(ItemRemovedHandler value);
    [CompilerGeneratedAttribute]
internal void remove_ItemRemoved(ItemRemovedHandler value);
    private void OnInsert(object item);
    private void OnRemove(object oldValue);
    private void OnSet(object oldValue, object newValue);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected virtual bool FreezeCore(bool isChecking);
}
[ContentPropertyAttribute("Children")]
public class System.Windows.Media.Media3D.MaterialGroup : Material {
    public static DependencyProperty ChildrenProperty;
    internal MultiChannelResource _duceResource;
    internal static MaterialCollection s_Children;
    public MaterialCollection Children { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    private static MaterialGroup();
    public MaterialGroup Clone();
    public MaterialGroup CloneCurrentValue();
    private static void ChildrenPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public MaterialCollection get_Children();
    public void set_Children(MaterialCollection value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    private void ChildrenItemInserted(object sender, object item);
    private void ChildrenItemRemoved(object sender, object item);
    internal virtual int get_EffectiveValuesInitialSize();
}
[ValueSerializerAttribute("System.Windows.Media.Media3D.Converters.Matrix3DValueSerializer")]
[TypeConverterAttribute("System.Windows.Media.Media3D.Matrix3DConverter")]
public class System.Windows.Media.Media3D.Matrix3D : ValueType {
    private double _m11;
    private double _m12;
    private double _m13;
    private double _m14;
    private double _m21;
    private double _m22;
    private double _m23;
    private double _m24;
    private double _m31;
    private double _m32;
    private double _m33;
    private double _m34;
    private double _offsetX;
    private double _offsetY;
    private double _offsetZ;
    private double _m44;
    private bool _isNotKnownToBeIdentity;
    private static Matrix3D s_identity;
    private static int c_identityHashCode;
    public static Matrix3D Identity { get; }
    public bool IsIdentity { get; }
    public bool IsAffine { get; }
    public double Determinant { get; }
    public bool HasInverse { get; }
    public double M11 { get; public set; }
    public double M12 { get; public set; }
    public double M13 { get; public set; }
    public double M14 { get; public set; }
    public double M21 { get; public set; }
    public double M22 { get; public set; }
    public double M23 { get; public set; }
    public double M24 { get; public set; }
    public double M31 { get; public set; }
    public double M32 { get; public set; }
    public double M33 { get; public set; }
    public double M34 { get; public set; }
    public double OffsetX { get; public set; }
    public double OffsetY { get; public set; }
    public double OffsetZ { get; public set; }
    public double M44 { get; public set; }
    private bool IsDistinguishedIdentity { get; private set; }
    public Matrix3D(double m11, double m12, double m13, double m14, double m21, double m22, double m23, double m24, double m31, double m32, double m33, double m34, double offsetX, double offsetY, double offsetZ, double m44);
    private static Matrix3D();
    public static Matrix3D get_Identity();
    public void SetIdentity();
    public bool get_IsIdentity();
    public void Prepend(Matrix3D matrix);
    public void Append(Matrix3D matrix);
    public void Rotate(Quaternion quaternion);
    public void RotatePrepend(Quaternion quaternion);
    public void RotateAt(Quaternion quaternion, Point3D center);
    public void RotateAtPrepend(Quaternion quaternion, Point3D center);
    public void Scale(Vector3D scale);
    public void ScalePrepend(Vector3D scale);
    public void ScaleAt(Vector3D scale, Point3D center);
    public void ScaleAtPrepend(Vector3D scale, Point3D center);
    public void Translate(Vector3D offset);
    public void TranslatePrepend(Vector3D offset);
    public static Matrix3D op_Multiply(Matrix3D matrix1, Matrix3D matrix2);
    public static Matrix3D Multiply(Matrix3D matrix1, Matrix3D matrix2);
    public Point3D Transform(Point3D point);
    public void Transform(Point3D[] points);
    public Point4D Transform(Point4D point);
    public void Transform(Point4D[] points);
    public Vector3D Transform(Vector3D vector);
    public void Transform(Vector3D[] vectors);
    public bool get_IsAffine();
    public double get_Determinant();
    public bool get_HasInverse();
    public void Invert();
    public double get_M11();
    public void set_M11(double value);
    public double get_M12();
    public void set_M12(double value);
    public double get_M13();
    public void set_M13(double value);
    public double get_M14();
    public void set_M14(double value);
    public double get_M21();
    public void set_M21(double value);
    public double get_M22();
    public void set_M22(double value);
    public double get_M23();
    public void set_M23(double value);
    public double get_M24();
    public void set_M24(double value);
    public double get_M31();
    public void set_M31(double value);
    public double get_M32();
    public void set_M32(double value);
    public double get_M33();
    public void set_M33(double value);
    public double get_M34();
    public void set_M34(double value);
    public double get_OffsetX();
    public void set_OffsetX(double value);
    public double get_OffsetY();
    public void set_OffsetY(double value);
    public double get_OffsetZ();
    public void set_OffsetZ(double value);
    public double get_M44();
    public void set_M44(double value);
    internal void SetScaleMatrix(Vector3D& scale);
    internal void SetScaleMatrix(Vector3D& scale, Point3D& center);
    internal void SetTranslationMatrix(Vector3D& offset);
    internal static Matrix3D CreateRotationMatrix(Quaternion& quaternion, Point3D& center);
    internal void MultiplyPoint(Point3D& point);
    internal void MultiplyPoint(Point4D& point);
    internal void MultiplyVector(Vector3D& vector);
    internal double GetNormalizedAffineDeterminant();
    internal bool NormalizedAffineInvert();
    internal bool InvertCore();
    private static Matrix3D CreateIdentity();
    private bool get_IsDistinguishedIdentity();
    private void set_IsDistinguishedIdentity(bool value);
    public static bool op_Equality(Matrix3D matrix1, Matrix3D matrix2);
    public static bool op_Inequality(Matrix3D matrix1, Matrix3D matrix2);
    public static bool Equals(Matrix3D matrix1, Matrix3D matrix2);
    public virtual bool Equals(object o);
    public bool Equals(Matrix3D value);
    public virtual int GetHashCode();
    public static Matrix3D Parse(string source);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
}
public class System.Windows.Media.Media3D.Matrix3DConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
internal class System.Windows.Media.Media3D.Matrix3DStack : object {
    private List`1<Matrix3D> _stack;
    public int Count { get; }
    public bool IsEmpty { get; }
    public Matrix3D Top { get; }
    public void Clear();
    public Matrix3D Pop();
    public void Push(Matrix3D matrix);
    public int get_Count();
    public bool get_IsEmpty();
    public Matrix3D get_Top();
}
public class System.Windows.Media.Media3D.MatrixCamera : Camera {
    public static DependencyProperty ViewMatrixProperty;
    public static DependencyProperty ProjectionMatrixProperty;
    internal MultiChannelResource _duceResource;
    internal static Matrix3D s_ViewMatrix;
    internal static Matrix3D s_ProjectionMatrix;
    public Matrix3D ViewMatrix { get; public set; }
    public Matrix3D ProjectionMatrix { get; public set; }
    public MatrixCamera(Matrix3D viewMatrix, Matrix3D projectionMatrix);
    private static MatrixCamera();
    internal virtual Matrix3D GetViewMatrix();
    internal virtual Matrix3D GetProjectionMatrix(double aspectRatio);
    internal virtual RayHitTestParameters RayFromViewportPoint(Point p, Size viewSize, Rect3D boundingRect, Double& distanceAdjustment);
    public MatrixCamera Clone();
    public MatrixCamera CloneCurrentValue();
    private static void ViewMatrixPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void ProjectionMatrixPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Matrix3D get_ViewMatrix();
    public void set_ViewMatrix(Matrix3D value);
    public Matrix3D get_ProjectionMatrix();
    public void set_ProjectionMatrix(Matrix3D value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
}
public class System.Windows.Media.Media3D.MatrixTransform3D : Transform3D {
    public static DependencyProperty MatrixProperty;
    internal MultiChannelResource _duceResource;
    internal static Matrix3D s_Matrix;
    public Matrix3D Value { get; }
    public bool IsAffine { get; }
    public Matrix3D Matrix { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    public MatrixTransform3D(Matrix3D matrix);
    private static MatrixTransform3D();
    public virtual Matrix3D get_Value();
    public virtual bool get_IsAffine();
    internal virtual void Append(Matrix3D& matrix);
    public MatrixTransform3D Clone();
    public MatrixTransform3D CloneCurrentValue();
    private static void MatrixPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Matrix3D get_Matrix();
    public void set_Matrix(Matrix3D value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    internal virtual int get_EffectiveValuesInitialSize();
}
public class System.Windows.Media.Media3D.MeshGeometry3D : Geometry3D {
    private Rect3D _cachedBounds;
    public static DependencyProperty PositionsProperty;
    public static DependencyProperty NormalsProperty;
    public static DependencyProperty TextureCoordinatesProperty;
    public static DependencyProperty TriangleIndicesProperty;
    internal MultiChannelResource _duceResource;
    internal static Point3DCollection s_Positions;
    internal static Vector3DCollection s_Normals;
    internal static PointCollection s_TextureCoordinates;
    internal static Int32Collection s_TriangleIndices;
    public Rect3D Bounds { get; }
    public Point3DCollection Positions { get; public set; }
    public Vector3DCollection Normals { get; public set; }
    public PointCollection TextureCoordinates { get; public set; }
    public Int32Collection TriangleIndices { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    private static MeshGeometry3D();
    public virtual Rect3D get_Bounds();
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    internal Rect GetTextureCoordinateBounds();
    internal virtual void RayHitTestCore(RayHitTestParameters rayParams, FaceType hitTestableFaces);
    private void ValidateRayHit(RayHitTestParameters rayParams, Point3D& origin, Vector3D& direction, double hitTime, int i0, int i1, int i2, Point& barycentric);
    private void ValidateLineHit(RayHitTestParameters rayParams, FaceType facesToHit, int i0, int i1, int i2, Point3D& v0, Point3D& v1, Point3D& v2, Point& barycentric);
    private void UpdateCachedBounds();
    private void SetCachedBoundsDirty();
    [ConditionalAttribute("DEBUG")]
private void Debug_VerifyCachedBounds();
    public MeshGeometry3D Clone();
    public MeshGeometry3D CloneCurrentValue();
    private static void PositionsPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void NormalsPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void TextureCoordinatesPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void TriangleIndicesPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Point3DCollection get_Positions();
    public void set_Positions(Point3DCollection value);
    public Vector3DCollection get_Normals();
    public void set_Normals(Vector3DCollection value);
    public PointCollection get_TextureCoordinates();
    public void set_TextureCoordinates(PointCollection value);
    public Int32Collection get_TriangleIndices();
    public void set_TriangleIndices(Int32Collection value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    internal virtual int get_EffectiveValuesInitialSize();
}
[LocalizabilityAttribute("0")]
public abstract class System.Windows.Media.Media3D.Model3D : Animatable {
    public static DependencyProperty TransformProperty;
    internal static Transform3D s_Transform;
    public Rect3D Bounds { get; }
    public Transform3D Transform { get; public set; }
    private static Model3D();
    public Rect3D get_Bounds();
    internal void RayHitTest(RayHitTestParameters rayParams);
    internal abstract virtual void RayHitTestCore(RayHitTestParameters rayParams);
    internal Rect3D CalculateSubgraphBoundsOuterSpace();
    internal abstract virtual Rect3D CalculateSubgraphBoundsInnerSpace();
    public Model3D Clone();
    public Model3D CloneCurrentValue();
    private static void TransformPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Transform3D get_Transform();
    public void set_Transform(Transform3D value);
    internal abstract virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    internal abstract virtual void ReleaseOnChannelCore(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    internal abstract virtual ResourceHandle GetHandleCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    internal abstract virtual int GetChannelCountCore();
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    internal abstract virtual Channel GetChannelCore(int index);
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal virtual string ConvertToString(string format, IFormatProvider provider);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Media3D.Model3DCollection : Animatable {
    [CompilerGeneratedAttribute]
private ItemInsertedHandler ItemInserted;
    [CompilerGeneratedAttribute]
private ItemRemovedHandler ItemRemoved;
    private static Model3DCollection s_empty;
    internal FrugalStructList`1<Model3D> _collection;
    internal UInt32 _version;
    public Model3D Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.Model3D>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal static Model3DCollection Empty { get; }
    public Model3DCollection(int capacity);
    public Model3DCollection(IEnumerable`1<Model3D> collection);
    public Model3DCollection Clone();
    public Model3DCollection CloneCurrentValue();
    public sealed virtual void Add(Model3D value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Model3D value);
    public sealed virtual int IndexOf(Model3D value);
    public sealed virtual void Insert(int index, Model3D value);
    public sealed virtual bool Remove(Model3D value);
    public sealed virtual void RemoveAt(int index);
    internal void RemoveAtWithoutFiringPublicEvents(int index);
    public sealed virtual Model3D get_Item(int index);
    public sealed virtual void set_Item(int index, Model3D value);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(Model3D[] array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.Model3D>.get_IsReadOnly();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<Model3D> System.Collections.Generic.IEnumerable<System.Windows.Media.Media3D.Model3D>.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal static Model3DCollection get_Empty();
    internal Model3D Internal_GetItem(int i);
    internal virtual void OnInheritanceContextChangedCore(EventArgs args);
    private Model3D Cast(object value);
    private int AddHelper(Model3D value);
    internal int AddWithoutFiringPublicEvents(Model3D value);
    [CompilerGeneratedAttribute]
internal void add_ItemInserted(ItemInsertedHandler value);
    [CompilerGeneratedAttribute]
internal void remove_ItemInserted(ItemInsertedHandler value);
    [CompilerGeneratedAttribute]
internal void add_ItemRemoved(ItemRemovedHandler value);
    [CompilerGeneratedAttribute]
internal void remove_ItemRemoved(ItemRemovedHandler value);
    private void OnInsert(object item);
    private void OnRemove(object oldValue);
    private void OnSet(object oldValue, object newValue);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected virtual bool FreezeCore(bool isChecking);
}
[ContentPropertyAttribute("Children")]
public class System.Windows.Media.Media3D.Model3DGroup : Model3D {
    private static Model3DGroup s_empty;
    public static DependencyProperty ChildrenProperty;
    internal MultiChannelResource _duceResource;
    internal static Model3DCollection s_Children;
    internal static Model3DGroup EmptyGroup { get; }
    public Model3DCollection Children { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    private static Model3DGroup();
    internal virtual void RayHitTestCore(RayHitTestParameters rayParams);
    internal virtual Rect3D CalculateSubgraphBoundsInnerSpace();
    internal static Model3DGroup get_EmptyGroup();
    public Model3DGroup Clone();
    public Model3DGroup CloneCurrentValue();
    private static void ChildrenPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Model3DCollection get_Children();
    public void set_Children(Model3DCollection value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    private void ChildrenItemInserted(object sender, object item);
    private void ChildrenItemRemoved(object sender, object item);
    internal virtual int get_EffectiveValuesInitialSize();
}
[ContentPropertyAttribute("Model")]
public class System.Windows.Media.Media3D.ModelUIElement3D : UIElement3D {
    public static DependencyProperty ModelProperty;
    public Model3D Model { get; public set; }
    private static ModelUIElement3D();
    private static void ModelPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Model3D get_Model();
    public void set_Model(Model3D value);
    protected virtual AutomationPeer OnCreateAutomationPeer();
}
[ContentPropertyAttribute("Children")]
public class System.Windows.Media.Media3D.ModelVisual3D : Visual3D {
    public static DependencyProperty ContentProperty;
    public static DependencyProperty TransformProperty;
    private Visual3DCollection _children;
    protected int Visual3DChildrenCount { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public Visual3DCollection Children { get; }
    public Model3D Content { get; public set; }
    public Transform3D Transform { get; public set; }
    private static ModelVisual3D();
    protected sealed virtual Visual3D GetVisual3DChild(int index);
    protected sealed virtual int get_Visual3DChildrenCount();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    public Visual3DCollection get_Children();
    private static void ContentPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Model3D get_Content();
    public void set_Content(Model3D value);
    public Transform3D get_Transform();
    public void set_Transform(Transform3D value);
}
public class System.Windows.Media.Media3D.OrthographicCamera : ProjectionCamera {
    public static DependencyProperty WidthProperty;
    internal MultiChannelResource _duceResource;
    internal static double c_Width;
    public double Width { get; public set; }
    public OrthographicCamera(Point3D position, Vector3D lookDirection, Vector3D upDirection, double width);
    private static OrthographicCamera();
    internal Matrix3D GetProjectionMatrix(double aspectRatio, double zn, double zf);
    internal virtual Matrix3D GetProjectionMatrix(double aspectRatio);
    internal virtual RayHitTestParameters RayFromViewportPoint(Point p, Size viewSize, Rect3D boundingRect, Double& distanceAdjustment);
    private double AddEpsilon(double x);
    public OrthographicCamera Clone();
    public OrthographicCamera CloneCurrentValue();
    private static void WidthPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public double get_Width();
    public void set_Width(double value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
}
public class System.Windows.Media.Media3D.PerspectiveCamera : ProjectionCamera {
    public static DependencyProperty FieldOfViewProperty;
    internal MultiChannelResource _duceResource;
    internal static double c_FieldOfView;
    public double FieldOfView { get; public set; }
    public PerspectiveCamera(Point3D position, Vector3D lookDirection, Vector3D upDirection, double fieldOfView);
    private static PerspectiveCamera();
    internal Matrix3D GetProjectionMatrix(double aspectRatio, double zn, double zf);
    internal virtual Matrix3D GetProjectionMatrix(double aspectRatio);
    internal virtual RayHitTestParameters RayFromViewportPoint(Point p, Size viewSize, Rect3D boundingRect, Double& distanceAdjustment);
    public PerspectiveCamera Clone();
    public PerspectiveCamera CloneCurrentValue();
    private static void FieldOfViewPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public double get_FieldOfView();
    public void set_FieldOfView(double value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
}
[ValueSerializerAttribute("System.Windows.Media.Media3D.Converters.Point3DValueSerializer")]
[TypeConverterAttribute("System.Windows.Media.Media3D.Point3DConverter")]
public class System.Windows.Media.Media3D.Point3D : ValueType {
    internal double _x;
    internal double _y;
    internal double _z;
    public double X { get; public set; }
    public double Y { get; public set; }
    public double Z { get; public set; }
    public Point3D(double x, double y, double z);
    public void Offset(double offsetX, double offsetY, double offsetZ);
    public static Point3D op_Addition(Point3D point, Vector3D vector);
    public static Point3D Add(Point3D point, Vector3D vector);
    public static Point3D op_Subtraction(Point3D point, Vector3D vector);
    public static Point3D Subtract(Point3D point, Vector3D vector);
    public static Vector3D op_Subtraction(Point3D point1, Point3D point2);
    public static Vector3D Subtract(Point3D point1, Point3D point2);
    internal static void Subtract(Point3D& p1, Point3D& p2, Vector3D& result);
    public static Point3D op_Multiply(Point3D point, Matrix3D matrix);
    public static Point3D Multiply(Point3D point, Matrix3D matrix);
    public static Vector3D op_Explicit(Point3D point);
    public static Point4D op_Explicit(Point3D point);
    public static bool op_Equality(Point3D point1, Point3D point2);
    public static bool op_Inequality(Point3D point1, Point3D point2);
    public static bool Equals(Point3D point1, Point3D point2);
    public virtual bool Equals(object o);
    public bool Equals(Point3D value);
    public virtual int GetHashCode();
    public static Point3D Parse(string source);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public double get_Z();
    public void set_Z(double value);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
}
[DefaultMemberAttribute("Item")]
[ValueSerializerAttribute("System.Windows.Media.Media3D.Converters.Point3DCollectionValueSerializer")]
[TypeConverterAttribute("System.Windows.Media.Media3D.Point3DCollectionConverter")]
public class System.Windows.Media.Media3D.Point3DCollection : Freezable {
    private static Point3DCollection s_empty;
    internal FrugalStructList`1<Point3D> _collection;
    internal UInt32 _version;
    public Point3D Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.Point3D>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal static Point3DCollection Empty { get; }
    public Point3DCollection(int capacity);
    public Point3DCollection(IEnumerable`1<Point3D> collection);
    [FriendAccessAllowedAttribute]
internal static object DeserializeFrom(BinaryReader reader);
    public Point3DCollection Clone();
    public Point3DCollection CloneCurrentValue();
    public sealed virtual void Add(Point3D value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Point3D value);
    public sealed virtual int IndexOf(Point3D value);
    public sealed virtual void Insert(int index, Point3D value);
    public sealed virtual bool Remove(Point3D value);
    public sealed virtual void RemoveAt(int index);
    internal void RemoveAtWithoutFiringPublicEvents(int index);
    public sealed virtual Point3D get_Item(int index);
    public sealed virtual void set_Item(int index, Point3D value);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(Point3D[] array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.Point3D>.get_IsReadOnly();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<Point3D> System.Collections.Generic.IEnumerable<System.Windows.Media.Media3D.Point3D>.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal static Point3DCollection get_Empty();
    internal Point3D Internal_GetItem(int i);
    private Point3D Cast(object value);
    private int AddHelper(Point3D value);
    internal int AddWithoutFiringPublicEvents(Point3D value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
    public static Point3DCollection Parse(string source);
}
public class System.Windows.Media.Media3D.Point3DCollectionConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.Media3D.Point3DConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[TypeConverterAttribute("System.Windows.Media.Media3D.Point4DConverter")]
[ValueSerializerAttribute("System.Windows.Media.Media3D.Converters.Point4DValueSerializer")]
public class System.Windows.Media.Media3D.Point4D : ValueType {
    internal double _x;
    internal double _y;
    internal double _z;
    internal double _w;
    public double X { get; public set; }
    public double Y { get; public set; }
    public double Z { get; public set; }
    public double W { get; public set; }
    public Point4D(double x, double y, double z, double w);
    public void Offset(double deltaX, double deltaY, double deltaZ, double deltaW);
    public static Point4D op_Addition(Point4D point1, Point4D point2);
    public static Point4D Add(Point4D point1, Point4D point2);
    public static Point4D op_Subtraction(Point4D point1, Point4D point2);
    public static Point4D Subtract(Point4D point1, Point4D point2);
    public static Point4D op_Multiply(Point4D point, Matrix3D matrix);
    public static Point4D Multiply(Point4D point, Matrix3D matrix);
    public static bool op_Equality(Point4D point1, Point4D point2);
    public static bool op_Inequality(Point4D point1, Point4D point2);
    public static bool Equals(Point4D point1, Point4D point2);
    public virtual bool Equals(object o);
    public bool Equals(Point4D value);
    public virtual int GetHashCode();
    public static Point4D Parse(string source);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public double get_Z();
    public void set_Z(double value);
    public double get_W();
    public void set_W(double value);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
}
public class System.Windows.Media.Media3D.Point4DConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.Media3D.PointLight : PointLightBase {
    internal MultiChannelResource _duceResource;
    public PointLight(Color diffuseColor, Point3D position);
    public PointLight Clone();
    public PointLight CloneCurrentValue();
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
}
public abstract class System.Windows.Media.Media3D.PointLightBase : Light {
    public static DependencyProperty PositionProperty;
    public static DependencyProperty RangeProperty;
    public static DependencyProperty ConstantAttenuationProperty;
    public static DependencyProperty LinearAttenuationProperty;
    public static DependencyProperty QuadraticAttenuationProperty;
    internal static Point3D s_Position;
    internal static double c_Range;
    internal static double c_ConstantAttenuation;
    internal static double c_LinearAttenuation;
    internal static double c_QuadraticAttenuation;
    public Point3D Position { get; public set; }
    public double Range { get; public set; }
    public double ConstantAttenuation { get; public set; }
    public double LinearAttenuation { get; public set; }
    public double QuadraticAttenuation { get; public set; }
    private static PointLightBase();
    public PointLightBase Clone();
    public PointLightBase CloneCurrentValue();
    private static void PositionPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void RangePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void ConstantAttenuationPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void LinearAttenuationPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void QuadraticAttenuationPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Point3D get_Position();
    public void set_Position(Point3D value);
    public double get_Range();
    public void set_Range(double value);
    public double get_ConstantAttenuation();
    public void set_ConstantAttenuation(double value);
    public double get_LinearAttenuation();
    public void set_LinearAttenuation(double value);
    public double get_QuadraticAttenuation();
    public void set_QuadraticAttenuation(double value);
}
public abstract class System.Windows.Media.Media3D.ProjectionCamera : Camera {
    public static DependencyProperty NearPlaneDistanceProperty;
    public static DependencyProperty FarPlaneDistanceProperty;
    public static DependencyProperty PositionProperty;
    public static DependencyProperty LookDirectionProperty;
    public static DependencyProperty UpDirectionProperty;
    internal static double c_NearPlaneDistance;
    internal static double c_FarPlaneDistance;
    internal static Point3D s_Position;
    internal static Vector3D s_LookDirection;
    internal static Vector3D s_UpDirection;
    public double NearPlaneDistance { get; public set; }
    public double FarPlaneDistance { get; public set; }
    public Point3D Position { get; public set; }
    public Vector3D LookDirection { get; public set; }
    public Vector3D UpDirection { get; public set; }
    private static ProjectionCamera();
    internal virtual Matrix3D GetViewMatrix();
    internal static Matrix3D CreateViewMatrix(Transform3D transform, Point3D& position, Vector3D& lookDirection, Vector3D& upDirection);
    public ProjectionCamera Clone();
    public ProjectionCamera CloneCurrentValue();
    private static void NearPlaneDistancePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void FarPlaneDistancePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void PositionPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void LookDirectionPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void UpDirectionPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public double get_NearPlaneDistance();
    public void set_NearPlaneDistance(double value);
    public double get_FarPlaneDistance();
    public void set_FarPlaneDistance(double value);
    public Point3D get_Position();
    public void set_Position(Point3D value);
    public Vector3D get_LookDirection();
    public void set_LookDirection(Vector3D value);
    public Vector3D get_UpDirection();
    public void set_UpDirection(Vector3D value);
}
[TypeConverterAttribute("System.Windows.Media.Media3D.QuaternionConverter")]
[ValueSerializerAttribute("System.Windows.Media.Media3D.Converters.QuaternionValueSerializer")]
public class System.Windows.Media.Media3D.Quaternion : ValueType {
    internal double _x;
    internal double _y;
    internal double _z;
    internal double _w;
    private bool _isNotDistinguishedIdentity;
    private static int c_identityHashCode;
    private static Quaternion s_identity;
    public static Quaternion Identity { get; }
    public Vector3D Axis { get; }
    public double Angle { get; }
    public bool IsNormalized { get; }
    public bool IsIdentity { get; }
    public double X { get; public set; }
    public double Y { get; public set; }
    public double Z { get; public set; }
    public double W { get; public set; }
    private bool IsDistinguishedIdentity { get; private set; }
    public Quaternion(double x, double y, double z, double w);
    public Quaternion(Vector3D axisOfRotation, double angleInDegrees);
    private static Quaternion();
    public static Quaternion get_Identity();
    public Vector3D get_Axis();
    public double get_Angle();
    public bool get_IsNormalized();
    public bool get_IsIdentity();
    public void Conjugate();
    public void Invert();
    public void Normalize();
    public static Quaternion op_Addition(Quaternion left, Quaternion right);
    public static Quaternion Add(Quaternion left, Quaternion right);
    public static Quaternion op_Subtraction(Quaternion left, Quaternion right);
    public static Quaternion Subtract(Quaternion left, Quaternion right);
    public static Quaternion op_Multiply(Quaternion left, Quaternion right);
    public static Quaternion Multiply(Quaternion left, Quaternion right);
    private void Scale(double scale);
    private double Length();
    public static Quaternion Slerp(Quaternion from, Quaternion to, double t);
    public static Quaternion Slerp(Quaternion from, Quaternion to, double t, bool useShortestPath);
    private static double Max(double a, double b, double c, double d);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public double get_Z();
    public void set_Z(double value);
    public double get_W();
    public void set_W(double value);
    private bool get_IsDistinguishedIdentity();
    private void set_IsDistinguishedIdentity(bool value);
    private static int GetIdentityHashCode();
    private static Quaternion GetIdentity();
    public static bool op_Equality(Quaternion quaternion1, Quaternion quaternion2);
    public static bool op_Inequality(Quaternion quaternion1, Quaternion quaternion2);
    public static bool Equals(Quaternion quaternion1, Quaternion quaternion2);
    public virtual bool Equals(object o);
    public bool Equals(Quaternion value);
    public virtual int GetHashCode();
    public static Quaternion Parse(string source);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
}
public class System.Windows.Media.Media3D.QuaternionConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.Media3D.QuaternionRotation3D : Rotation3D {
    public static DependencyProperty QuaternionProperty;
    private Quaternion _cachedQuaternionValue;
    internal MultiChannelResource _duceResource;
    internal static Quaternion s_Quaternion;
    internal Quaternion InternalQuaternion { get; }
    public Quaternion Quaternion { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    public QuaternionRotation3D(Quaternion quaternion);
    private static QuaternionRotation3D();
    internal virtual Quaternion get_InternalQuaternion();
    public QuaternionRotation3D Clone();
    public QuaternionRotation3D CloneCurrentValue();
    private static void QuaternionPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Quaternion get_Quaternion();
    public void set_Quaternion(Quaternion value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    internal virtual int get_EffectiveValuesInitialSize();
}
public class System.Windows.Media.Media3D.RayHitTestParameters : HitTestParameters3D {
    private Point3D _origin;
    private Vector3D _direction;
    private List`1<RayHitTestResult> results;
    private bool _isRay;
    public Point3D Origin { get; }
    public Vector3D Direction { get; }
    internal bool IsRay { get; }
    public RayHitTestParameters(Point3D origin, Vector3D direction);
    public Point3D get_Origin();
    public Vector3D get_Direction();
    internal void ReportResult(MeshGeometry3D meshHit, Point3D pointHit, double distanceToRayOrigin, int vertexIndex1, int vertexIndex2, int vertexIndex3, Point barycentric);
    internal HitTestResultBehavior RaiseCallback(HitTestResultCallback resultCallback, HitTestFilterCallback filterCallback, HitTestResultBehavior lastResult);
    internal HitTestResultBehavior RaiseCallback(HitTestResultCallback resultCallback, HitTestFilterCallback filterCallback, HitTestResultBehavior lastResult, double distanceAdjustment);
    internal void GetLocalLine(Point3D& origin, Vector3D& direction);
    internal void ClearResults();
    internal bool get_IsRay();
}
public abstract class System.Windows.Media.Media3D.RayHitTestResult : HitTestResult {
    private Model3D _modelHit;
    public Visual3D VisualHit { get; }
    public Model3D ModelHit { get; }
    public Point3D PointHit { get; }
    public double DistanceToRayOrigin { get; }
    internal RayHitTestResult(Visual3D visualHit, Model3D modelHit);
    public Visual3D get_VisualHit();
    public Model3D get_ModelHit();
    public abstract virtual Point3D get_PointHit();
    public abstract virtual double get_DistanceToRayOrigin();
    internal abstract virtual void SetDistanceToRayOrigin(double distance);
    internal static int CompareByDistanceToRayOrigin(RayHitTestResult x, RayHitTestResult y);
}
public class System.Windows.Media.Media3D.RayMeshGeometry3DHitTestResult : RayHitTestResult {
    private double _distanceToRayOrigin;
    private int _vertexIndex1;
    private int _vertexIndex2;
    private int _vertexIndex3;
    private Point _barycentricCoordinate;
    private MeshGeometry3D _meshHit;
    private Point3D _pointHit;
    public Point3D PointHit { get; }
    public double DistanceToRayOrigin { get; }
    public int VertexIndex1 { get; }
    public int VertexIndex2 { get; }
    public int VertexIndex3 { get; }
    public double VertexWeight1 { get; }
    public double VertexWeight2 { get; }
    public double VertexWeight3 { get; }
    public MeshGeometry3D MeshHit { get; }
    internal RayMeshGeometry3DHitTestResult(Visual3D visualHit, Model3D modelHit, MeshGeometry3D meshHit, Point3D pointHit, double distanceToRayOrigin, int vertexIndex1, int vertexIndex2, int vertexIndex3, Point barycentricCoordinate);
    public virtual Point3D get_PointHit();
    public virtual double get_DistanceToRayOrigin();
    public int get_VertexIndex1();
    public int get_VertexIndex2();
    public int get_VertexIndex3();
    public double get_VertexWeight1();
    public double get_VertexWeight2();
    public double get_VertexWeight3();
    public MeshGeometry3D get_MeshHit();
    internal virtual void SetDistanceToRayOrigin(double distance);
}
[TypeConverterAttribute("System.Windows.Media.Media3D.Rect3DConverter")]
[ValueSerializerAttribute("System.Windows.Media.Media3D.Converters.Rect3DValueSerializer")]
public class System.Windows.Media.Media3D.Rect3D : ValueType {
    internal static Rect3D Infinite;
    private static Rect3D s_empty;
    internal double _x;
    internal double _y;
    internal double _z;
    internal double _sizeX;
    internal double _sizeY;
    internal double _sizeZ;
    public static Rect3D Empty { get; }
    public bool IsEmpty { get; }
    public Point3D Location { get; public set; }
    public Size3D Size { get; public set; }
    public double SizeX { get; public set; }
    public double SizeY { get; public set; }
    public double SizeZ { get; public set; }
    public double X { get; public set; }
    public double Y { get; public set; }
    public double Z { get; public set; }
    public Rect3D(Point3D location, Size3D size);
    public Rect3D(double x, double y, double z, double sizeX, double sizeY, double sizeZ);
    internal Rect3D(Point3D point1, Point3D point2);
    internal Rect3D(Point3D point, Vector3D vector);
    private static Rect3D();
    public static Rect3D get_Empty();
    public bool get_IsEmpty();
    public Point3D get_Location();
    public void set_Location(Point3D value);
    public Size3D get_Size();
    public void set_Size(Size3D value);
    public double get_SizeX();
    public void set_SizeX(double value);
    public double get_SizeY();
    public void set_SizeY(double value);
    public double get_SizeZ();
    public void set_SizeZ(double value);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public double get_Z();
    public void set_Z(double value);
    public bool Contains(Point3D point);
    public bool Contains(double x, double y, double z);
    public bool Contains(Rect3D rect);
    public bool IntersectsWith(Rect3D rect);
    public void Intersect(Rect3D rect);
    public static Rect3D Intersect(Rect3D rect1, Rect3D rect2);
    public void Union(Rect3D rect);
    public static Rect3D Union(Rect3D rect1, Rect3D rect2);
    public void Union(Point3D point);
    public static Rect3D Union(Rect3D rect, Point3D point);
    public void Offset(Vector3D offsetVector);
    public void Offset(double offsetX, double offsetY, double offsetZ);
    public static Rect3D Offset(Rect3D rect, Vector3D offsetVector);
    public static Rect3D Offset(Rect3D rect, double offsetX, double offsetY, double offsetZ);
    private bool ContainsInternal(double x, double y, double z);
    private static Rect3D CreateEmptyRect3D();
    private static Rect3D CreateInfiniteRect3D();
    public static bool op_Equality(Rect3D rect1, Rect3D rect2);
    public static bool op_Inequality(Rect3D rect1, Rect3D rect2);
    public static bool Equals(Rect3D rect1, Rect3D rect2);
    public virtual bool Equals(object o);
    public bool Equals(Rect3D value);
    public virtual int GetHashCode();
    public static Rect3D Parse(string source);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
}
public class System.Windows.Media.Media3D.Rect3DConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.Media3D.RotateTransform3D : AffineTransform3D {
    public static DependencyProperty CenterXProperty;
    public static DependencyProperty CenterYProperty;
    public static DependencyProperty CenterZProperty;
    public static DependencyProperty RotationProperty;
    private double _cachedCenterXValue;
    private double _cachedCenterYValue;
    private double _cachedCenterZValue;
    private Rotation3D _cachedRotationValue;
    internal MultiChannelResource _duceResource;
    internal static double c_CenterX;
    internal static double c_CenterY;
    internal static double c_CenterZ;
    internal static Rotation3D s_Rotation;
    public Matrix3D Value { get; }
    public double CenterX { get; public set; }
    public double CenterY { get; public set; }
    public double CenterZ { get; public set; }
    public Rotation3D Rotation { get; public set; }
    public RotateTransform3D(Rotation3D rotation);
    public RotateTransform3D(Rotation3D rotation, Point3D center);
    public RotateTransform3D(Rotation3D rotation, double centerX, double centerY, double centerZ);
    private static RotateTransform3D();
    public virtual Matrix3D get_Value();
    internal virtual void Append(Matrix3D& matrix);
    public RotateTransform3D Clone();
    public RotateTransform3D CloneCurrentValue();
    private static void CenterXPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void CenterYPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void CenterZPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void RotationPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public double get_CenterX();
    public void set_CenterX(double value);
    public double get_CenterY();
    public void set_CenterY(double value);
    public double get_CenterZ();
    public void set_CenterZ(double value);
    public Rotation3D get_Rotation();
    public void set_Rotation(Rotation3D value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
}
public abstract class System.Windows.Media.Media3D.Rotation3D : Animatable {
    private static Rotation3D s_identity;
    public static Rotation3D Identity { get; }
    internal Quaternion InternalQuaternion { get; }
    private static Rotation3D();
    public static Rotation3D get_Identity();
    internal abstract virtual Quaternion get_InternalQuaternion();
    public Rotation3D Clone();
    public Rotation3D CloneCurrentValue();
    internal abstract virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    internal abstract virtual void ReleaseOnChannelCore(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    internal abstract virtual ResourceHandle GetHandleCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    internal abstract virtual int GetChannelCountCore();
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    internal abstract virtual Channel GetChannelCore(int index);
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal virtual string ConvertToString(string format, IFormatProvider provider);
}
public class System.Windows.Media.Media3D.ScaleTransform3D : AffineTransform3D {
    public static DependencyProperty ScaleXProperty;
    public static DependencyProperty ScaleYProperty;
    public static DependencyProperty ScaleZProperty;
    public static DependencyProperty CenterXProperty;
    public static DependencyProperty CenterYProperty;
    public static DependencyProperty CenterZProperty;
    private double _cachedScaleXValue;
    private double _cachedScaleYValue;
    private double _cachedScaleZValue;
    private double _cachedCenterXValue;
    private double _cachedCenterYValue;
    private double _cachedCenterZValue;
    internal MultiChannelResource _duceResource;
    internal static double c_ScaleX;
    internal static double c_ScaleY;
    internal static double c_ScaleZ;
    internal static double c_CenterX;
    internal static double c_CenterY;
    internal static double c_CenterZ;
    public Matrix3D Value { get; }
    public double ScaleX { get; public set; }
    public double ScaleY { get; public set; }
    public double ScaleZ { get; public set; }
    public double CenterX { get; public set; }
    public double CenterY { get; public set; }
    public double CenterZ { get; public set; }
    public ScaleTransform3D(Vector3D scale);
    public ScaleTransform3D(double scaleX, double scaleY, double scaleZ);
    public ScaleTransform3D(Vector3D scale, Point3D center);
    public ScaleTransform3D(double scaleX, double scaleY, double scaleZ, double centerX, double centerY, double centerZ);
    private static ScaleTransform3D();
    public virtual Matrix3D get_Value();
    internal virtual void Append(Matrix3D& matrix);
    public ScaleTransform3D Clone();
    public ScaleTransform3D CloneCurrentValue();
    private static void ScaleXPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void ScaleYPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void ScaleZPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void CenterXPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void CenterYPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void CenterZPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public double get_ScaleX();
    public void set_ScaleX(double value);
    public double get_ScaleY();
    public void set_ScaleY(double value);
    public double get_ScaleZ();
    public void set_ScaleZ(double value);
    public double get_CenterX();
    public void set_CenterX(double value);
    public double get_CenterY();
    public void set_CenterY(double value);
    public double get_CenterZ();
    public void set_CenterZ(double value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
}
[ValueSerializerAttribute("System.Windows.Media.Media3D.Converters.Size3DValueSerializer")]
[TypeConverterAttribute("System.Windows.Media.Media3D.Size3DConverter")]
public class System.Windows.Media.Media3D.Size3D : ValueType {
    private static Size3D s_empty;
    internal double _x;
    internal double _y;
    internal double _z;
    public static Size3D Empty { get; }
    public bool IsEmpty { get; }
    public double X { get; public set; }
    public double Y { get; public set; }
    public double Z { get; public set; }
    public Size3D(double x, double y, double z);
    private static Size3D();
    public static Size3D get_Empty();
    public bool get_IsEmpty();
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public double get_Z();
    public void set_Z(double value);
    public static Vector3D op_Explicit(Size3D size);
    public static Point3D op_Explicit(Size3D size);
    private static Size3D CreateEmptySize3D();
    public static bool op_Equality(Size3D size1, Size3D size2);
    public static bool op_Inequality(Size3D size1, Size3D size2);
    public static bool Equals(Size3D size1, Size3D size2);
    public virtual bool Equals(object o);
    public bool Equals(Size3D value);
    public virtual int GetHashCode();
    public static Size3D Parse(string source);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
}
public class System.Windows.Media.Media3D.Size3DConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.Media3D.SpecularMaterial : Material {
    public static DependencyProperty ColorProperty;
    public static DependencyProperty BrushProperty;
    public static DependencyProperty SpecularPowerProperty;
    internal MultiChannelResource _duceResource;
    internal static Color s_Color;
    internal static Brush s_Brush;
    internal static double c_SpecularPower;
    public Color Color { get; public set; }
    public Brush Brush { get; public set; }
    public double SpecularPower { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    public SpecularMaterial(Brush brush, double specularPower);
    private static SpecularMaterial();
    public SpecularMaterial Clone();
    public SpecularMaterial CloneCurrentValue();
    private static void ColorPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void BrushPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void SpecularPowerPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Color get_Color();
    public void set_Color(Color value);
    public Brush get_Brush();
    public void set_Brush(Brush value);
    public double get_SpecularPower();
    public void set_SpecularPower(double value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    internal virtual int get_EffectiveValuesInitialSize();
}
public class System.Windows.Media.Media3D.SpotLight : PointLightBase {
    public static DependencyProperty DirectionProperty;
    public static DependencyProperty OuterConeAngleProperty;
    public static DependencyProperty InnerConeAngleProperty;
    internal MultiChannelResource _duceResource;
    internal static Vector3D s_Direction;
    internal static double c_OuterConeAngle;
    internal static double c_InnerConeAngle;
    public Vector3D Direction { get; public set; }
    public double OuterConeAngle { get; public set; }
    public double InnerConeAngle { get; public set; }
    public SpotLight(Color diffuseColor, Point3D position, Vector3D direction, double outerConeAngle, double innerConeAngle);
    private static SpotLight();
    public SpotLight Clone();
    public SpotLight CloneCurrentValue();
    private static void DirectionPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OuterConeAnglePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void InnerConeAnglePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Vector3D get_Direction();
    public void set_Direction(Vector3D value);
    public double get_OuterConeAngle();
    public void set_OuterConeAngle(double value);
    public double get_InnerConeAngle();
    public void set_InnerConeAngle(double value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
}
[LocalizabilityAttribute("0")]
public abstract class System.Windows.Media.Media3D.Transform3D : GeneralTransform3D {
    private static Transform3D s_identity;
    public GeneralTransform3D Inverse { get; }
    internal Transform3D AffineTransform { get; }
    public static Transform3D Identity { get; }
    public bool IsAffine { get; }
    public Matrix3D Value { get; }
    public Point3D Transform(Point3D point);
    public Vector3D Transform(Vector3D vector);
    public Point4D Transform(Point4D point);
    public void Transform(Point3D[] points);
    public void Transform(Vector3D[] vectors);
    public void Transform(Point4D[] points);
    public virtual bool TryTransform(Point3D inPoint, Point3D& result);
    public virtual Rect3D TransformBounds(Rect3D rect);
    public virtual GeneralTransform3D get_Inverse();
    [FriendAccessAllowedAttribute]
internal virtual Transform3D get_AffineTransform();
    public static Transform3D get_Identity();
    public abstract virtual bool get_IsAffine();
    public abstract virtual Matrix3D get_Value();
    internal abstract virtual void Append(Matrix3D& matrix);
    public Transform3D Clone();
    public Transform3D CloneCurrentValue();
    internal abstract virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    internal abstract virtual void ReleaseOnChannelCore(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    internal abstract virtual ResourceHandle GetHandleCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    internal abstract virtual int GetChannelCountCore();
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    internal abstract virtual Channel GetChannelCore(int index);
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Media3D.Transform3DCollection : Animatable {
    [CompilerGeneratedAttribute]
private ItemInsertedHandler ItemInserted;
    [CompilerGeneratedAttribute]
private ItemRemovedHandler ItemRemoved;
    private static Transform3DCollection s_empty;
    internal FrugalStructList`1<Transform3D> _collection;
    internal UInt32 _version;
    public Transform3D Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.Transform3D>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal static Transform3DCollection Empty { get; }
    public Transform3DCollection(int capacity);
    public Transform3DCollection(IEnumerable`1<Transform3D> collection);
    public Transform3DCollection Clone();
    public Transform3DCollection CloneCurrentValue();
    public sealed virtual void Add(Transform3D value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Transform3D value);
    public sealed virtual int IndexOf(Transform3D value);
    public sealed virtual void Insert(int index, Transform3D value);
    public sealed virtual bool Remove(Transform3D value);
    public sealed virtual void RemoveAt(int index);
    internal void RemoveAtWithoutFiringPublicEvents(int index);
    public sealed virtual Transform3D get_Item(int index);
    public sealed virtual void set_Item(int index, Transform3D value);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(Transform3D[] array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.Transform3D>.get_IsReadOnly();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<Transform3D> System.Collections.Generic.IEnumerable<System.Windows.Media.Media3D.Transform3D>.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal static Transform3DCollection get_Empty();
    internal Transform3D Internal_GetItem(int i);
    internal virtual void OnInheritanceContextChangedCore(EventArgs args);
    private Transform3D Cast(object value);
    private int AddHelper(Transform3D value);
    internal int AddWithoutFiringPublicEvents(Transform3D value);
    [CompilerGeneratedAttribute]
internal void add_ItemInserted(ItemInsertedHandler value);
    [CompilerGeneratedAttribute]
internal void remove_ItemInserted(ItemInsertedHandler value);
    [CompilerGeneratedAttribute]
internal void add_ItemRemoved(ItemRemovedHandler value);
    [CompilerGeneratedAttribute]
internal void remove_ItemRemoved(ItemRemovedHandler value);
    private void OnInsert(object item);
    private void OnRemove(object oldValue);
    private void OnSet(object oldValue, object newValue);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected virtual bool FreezeCore(bool isChecking);
}
[ContentPropertyAttribute("Children")]
public class System.Windows.Media.Media3D.Transform3DGroup : Transform3D {
    public static DependencyProperty ChildrenProperty;
    internal MultiChannelResource _duceResource;
    internal static Transform3DCollection s_Children;
    public Matrix3D Value { get; }
    public bool IsAffine { get; }
    public Transform3DCollection Children { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    private static Transform3DGroup();
    public virtual Matrix3D get_Value();
    public virtual bool get_IsAffine();
    internal virtual void Append(Matrix3D& matrix);
    public Transform3DGroup Clone();
    public Transform3DGroup CloneCurrentValue();
    private static void ChildrenPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Transform3DCollection get_Children();
    public void set_Children(Transform3DCollection value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    private void ChildrenItemInserted(object sender, object item);
    private void ChildrenItemRemoved(object sender, object item);
    internal virtual int get_EffectiveValuesInitialSize();
}
public class System.Windows.Media.Media3D.TranslateTransform3D : AffineTransform3D {
    public static DependencyProperty OffsetXProperty;
    public static DependencyProperty OffsetYProperty;
    public static DependencyProperty OffsetZProperty;
    private double _cachedOffsetXValue;
    private double _cachedOffsetYValue;
    private double _cachedOffsetZValue;
    internal MultiChannelResource _duceResource;
    internal static double c_OffsetX;
    internal static double c_OffsetY;
    internal static double c_OffsetZ;
    public Matrix3D Value { get; }
    public double OffsetX { get; public set; }
    public double OffsetY { get; public set; }
    public double OffsetZ { get; public set; }
    public TranslateTransform3D(Vector3D offset);
    public TranslateTransform3D(double offsetX, double offsetY, double offsetZ);
    private static TranslateTransform3D();
    public virtual Matrix3D get_Value();
    internal virtual void Append(Matrix3D& matrix);
    public TranslateTransform3D Clone();
    public TranslateTransform3D CloneCurrentValue();
    private static void OffsetXPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OffsetYPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OffsetZPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public double get_OffsetX();
    public void set_OffsetX(double value);
    public double get_OffsetY();
    public void set_OffsetY(double value);
    public double get_OffsetZ();
    public void set_OffsetZ(double value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
}
[ValueSerializerAttribute("System.Windows.Media.Media3D.Converters.Vector3DValueSerializer")]
[TypeConverterAttribute("System.Windows.Media.Media3D.Vector3DConverter")]
public class System.Windows.Media.Media3D.Vector3D : ValueType {
    internal double _x;
    internal double _y;
    internal double _z;
    public double Length { get; }
    public double LengthSquared { get; }
    public double X { get; public set; }
    public double Y { get; public set; }
    public double Z { get; public set; }
    public Vector3D(double x, double y, double z);
    public double get_Length();
    public double get_LengthSquared();
    public void Normalize();
    public static double AngleBetween(Vector3D vector1, Vector3D vector2);
    public static Vector3D op_UnaryNegation(Vector3D vector);
    public void Negate();
    public static Vector3D op_Addition(Vector3D vector1, Vector3D vector2);
    public static Vector3D Add(Vector3D vector1, Vector3D vector2);
    public static Vector3D op_Subtraction(Vector3D vector1, Vector3D vector2);
    public static Vector3D Subtract(Vector3D vector1, Vector3D vector2);
    public static Point3D op_Addition(Vector3D vector, Point3D point);
    public static Point3D Add(Vector3D vector, Point3D point);
    public static Point3D op_Subtraction(Vector3D vector, Point3D point);
    public static Point3D Subtract(Vector3D vector, Point3D point);
    public static Vector3D op_Multiply(Vector3D vector, double scalar);
    public static Vector3D Multiply(Vector3D vector, double scalar);
    public static Vector3D op_Multiply(double scalar, Vector3D vector);
    public static Vector3D Multiply(double scalar, Vector3D vector);
    public static Vector3D op_Division(Vector3D vector, double scalar);
    public static Vector3D Divide(Vector3D vector, double scalar);
    public static Vector3D op_Multiply(Vector3D vector, Matrix3D matrix);
    public static Vector3D Multiply(Vector3D vector, Matrix3D matrix);
    public static double DotProduct(Vector3D vector1, Vector3D vector2);
    internal static double DotProduct(Vector3D& vector1, Vector3D& vector2);
    public static Vector3D CrossProduct(Vector3D vector1, Vector3D vector2);
    internal static void CrossProduct(Vector3D& vector1, Vector3D& vector2, Vector3D& result);
    public static Point3D op_Explicit(Vector3D vector);
    public static Size3D op_Explicit(Vector3D vector);
    public static bool op_Equality(Vector3D vector1, Vector3D vector2);
    public static bool op_Inequality(Vector3D vector1, Vector3D vector2);
    public static bool Equals(Vector3D vector1, Vector3D vector2);
    public virtual bool Equals(object o);
    public bool Equals(Vector3D value);
    public virtual int GetHashCode();
    public static Vector3D Parse(string source);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public double get_Z();
    public void set_Z(double value);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
}
[DefaultMemberAttribute("Item")]
[TypeConverterAttribute("System.Windows.Media.Media3D.Vector3DCollectionConverter")]
[ValueSerializerAttribute("System.Windows.Media.Media3D.Converters.Vector3DCollectionValueSerializer")]
public class System.Windows.Media.Media3D.Vector3DCollection : Freezable {
    private static Vector3DCollection s_empty;
    internal FrugalStructList`1<Vector3D> _collection;
    internal UInt32 _version;
    public Vector3D Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.Vector3D>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal static Vector3DCollection Empty { get; }
    public Vector3DCollection(int capacity);
    public Vector3DCollection(IEnumerable`1<Vector3D> collection);
    [FriendAccessAllowedAttribute]
internal static object DeserializeFrom(BinaryReader reader);
    public Vector3DCollection Clone();
    public Vector3DCollection CloneCurrentValue();
    public sealed virtual void Add(Vector3D value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Vector3D value);
    public sealed virtual int IndexOf(Vector3D value);
    public sealed virtual void Insert(int index, Vector3D value);
    public sealed virtual bool Remove(Vector3D value);
    public sealed virtual void RemoveAt(int index);
    internal void RemoveAtWithoutFiringPublicEvents(int index);
    public sealed virtual Vector3D get_Item(int index);
    public sealed virtual void set_Item(int index, Vector3D value);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(Vector3D[] array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.Vector3D>.get_IsReadOnly();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<Vector3D> System.Collections.Generic.IEnumerable<System.Windows.Media.Media3D.Vector3D>.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal static Vector3DCollection get_Empty();
    internal Vector3D Internal_GetItem(int i);
    private Vector3D Cast(object value);
    private int AddHelper(Vector3D value);
    internal int AddWithoutFiringPublicEvents(Vector3D value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
    public static Vector3DCollection Parse(string source);
}
public class System.Windows.Media.Media3D.Vector3DCollectionConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.Media3D.Vector3DConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[ContentPropertyAttribute("Visual")]
public class System.Windows.Media.Media3D.Viewport2DVisual3D : Visual3D {
    public static DependencyProperty VisualProperty;
    public static DependencyProperty GeometryProperty;
    public static DependencyProperty MaterialProperty;
    public static DependencyProperty IsVisualHostMaterialProperty;
    public static DependencyProperty CacheModeProperty;
    private static DependencyProperty CachingHintProperty;
    private static DependencyProperty CacheInvalidationThresholdMinimumProperty;
    private static DependencyProperty CacheInvalidationThresholdMaximumProperty;
    private VisualBrush _visualBrush;
    private BitmapCacheBrush _bitmapCacheBrush;
    private Point3DCollection _positionsCache;
    private PointCollection _textureCoordinatesCache;
    private Int32Collection _triangleIndicesCache;
    public Visual Visual { get; public set; }
    private VisualBrush InternalVisualBrush { get; private set; }
    private BitmapCacheBrush InternalBitmapCacheBrush { get; private set; }
    public Geometry3D Geometry { get; public set; }
    internal Point3DCollection InternalPositionsCache { get; internal set; }
    internal PointCollection InternalTextureCoordinatesCache { get; internal set; }
    internal Int32Collection InternalTriangleIndicesCache { get; internal set; }
    public Material Material { get; public set; }
    public CacheMode CacheMode { get; public set; }
    protected int Visual3DChildrenCount { get; }
    internal int InternalVisual2DOr3DChildrenCount { get; }
    private static Viewport2DVisual3D();
    internal static bool Get3DPointFor2DCoordinate(Point point, Point3D& point3D, Point3DCollection positions, PointCollection textureCoords, Int32Collection triIndices);
    internal static Point TextureCoordsToVisualCoords(Point uv, Visual visual);
    internal static Point TextureCoordsToVisualCoords(Point uv, Rect descBounds);
    internal static bool GetIntersectionInfo(RayHitTestResult rayHitResult, Point& outputPoint);
    internal static Point VisualCoordsToTextureCoords(Point pt, Visual visual);
    internal static Point VisualCoordsToTextureCoords(Point pt, Rect descBounds);
    private void GenerateMaterial();
    public Visual get_Visual();
    public void set_Visual(Visual value);
    private VisualBrush get_InternalVisualBrush();
    private void set_InternalVisualBrush(VisualBrush value);
    private BitmapCacheBrush get_InternalBitmapCacheBrush();
    private void set_InternalBitmapCacheBrush(BitmapCacheBrush value);
    internal static void OnVisualChanged(object sender, DependencyPropertyChangedEventArgs e);
    private void AddVisualChild(Visual child);
    private void RemoveVisualChild(Visual child);
    private VisualBrush CreateVisualBrush();
    private BitmapCacheBrush CreateBitmapCacheBrush();
    private void SwapInCyclicBrush(Material material);
    public Geometry3D get_Geometry();
    public void set_Geometry(Geometry3D value);
    internal static void OnGeometryChanged(object sender, DependencyPropertyChangedEventArgs e);
    private void InvalidateAllCachedValues();
    internal Point3DCollection get_InternalPositionsCache();
    internal void set_InternalPositionsCache(Point3DCollection value);
    internal PointCollection get_InternalTextureCoordinatesCache();
    internal void set_InternalTextureCoordinatesCache(PointCollection value);
    internal Int32Collection get_InternalTriangleIndicesCache();
    internal void set_InternalTriangleIndicesCache(Int32Collection value);
    public Material get_Material();
    public void set_Material(Material value);
    internal static void OnMaterialPropertyChanged(object sender, DependencyPropertyChangedEventArgs e);
    public static void SetIsVisualHostMaterial(Material element, bool value);
    public static bool GetIsVisualHostMaterial(Material element);
    public CacheMode get_CacheMode();
    public void set_CacheMode(CacheMode value);
    internal static void OnCacheModeChanged(object sender, DependencyPropertyChangedEventArgs e);
    protected virtual int get_Visual3DChildrenCount();
    protected virtual Visual3D GetVisual3DChild(int index);
    internal virtual int get_InternalVisual2DOr3DChildrenCount();
    internal virtual DependencyObject InternalGet2DOr3DVisualChild(int index);
    private static void OnCachingHintChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnCacheInvalidationThresholdMinimumChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnCacheInvalidationThresholdMaximumChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
}
[ContentPropertyAttribute("Children")]
public class System.Windows.Media.Media3D.Viewport3DVisual : Visual {
    public static DependencyProperty CameraProperty;
    public static DependencyProperty ViewportProperty;
    private VisualProxy _proxy3D;
    private Rect3D _bboxChildrenSubgraph3D;
    private Visual3DCollection _children;
    private DependencyObject _inheritanceContextForChildren;
    public DependencyObject Parent { get; }
    public Geometry Clip { get; public set; }
    public double Opacity { get; public set; }
    public Brush OpacityMask { get; public set; }
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
public BitmapEffect BitmapEffect { get; public set; }
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
public BitmapEffectInput BitmapEffectInput { get; public set; }
    public Rect ContentBounds { get; }
    public Transform Transform { get; public set; }
    public Vector Offset { get; public set; }
    public Rect DescendantBounds { get; }
    public Camera Camera { get; public set; }
    public Rect Viewport { get; public set; }
    [DesignerSerializationVisibilityAttribute("2")]
public Visual3DCollection Children { get; }
    internal int InternalVisual2DOr3DChildrenCount { get; }
    private Rect3D BBoxSubgraph { get; }
    private static Viewport3DVisual();
    public DependencyObject get_Parent();
    public Geometry get_Clip();
    public void set_Clip(Geometry value);
    public double get_Opacity();
    public void set_Opacity(double value);
    public Brush get_OpacityMask();
    public void set_OpacityMask(Brush value);
    public BitmapEffect get_BitmapEffect();
    public void set_BitmapEffect(BitmapEffect value);
    public BitmapEffectInput get_BitmapEffectInput();
    public void set_BitmapEffectInput(BitmapEffectInput value);
    public HitTestResult HitTest(Point point);
    public void HitTest(HitTestFilterCallback filterCallback, HitTestResultCallback resultCallback, HitTestParameters hitTestParameters);
    public Rect get_ContentBounds();
    public Transform get_Transform();
    public void set_Transform(Transform value);
    public Vector get_Offset();
    public void set_Offset(Vector value);
    public Rect get_DescendantBounds();
    private static void CameraPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Camera get_Camera();
    public void set_Camera(Camera value);
    private static void ViewportPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Rect get_Viewport();
    public void set_Viewport(Rect value);
    public Visual3DCollection get_Children();
    private sealed virtual override void MS.Internal.IVisual3DContainer.VerifyAPIReadOnly();
    private sealed virtual override void MS.Internal.IVisual3DContainer.VerifyAPIReadOnly(DependencyObject other);
    private sealed virtual override void MS.Internal.IVisual3DContainer.VerifyAPIReadWrite();
    private sealed virtual override void MS.Internal.IVisual3DContainer.VerifyAPIReadWrite(DependencyObject other);
    private sealed virtual override void MS.Internal.IVisual3DContainer.AddChild(Visual3D child);
    private sealed virtual override void MS.Internal.IVisual3DContainer.RemoveChild(Visual3D child);
    private sealed virtual override int MS.Internal.IVisual3DContainer.GetChildrenCount();
    private sealed virtual override Visual3D MS.Internal.IVisual3DContainer.GetChild(int index);
    internal virtual int get_InternalVisual2DOr3DChildrenCount();
    internal virtual DependencyObject InternalGet2DOr3DVisualChild(int index);
    internal virtual HitTestResultBehavior HitTestPointInternal(HitTestFilterCallback filterCallback, HitTestResultCallback resultCallback, PointHitTestParameters hitTestParameters);
    protected virtual GeometryHitTestResult HitTestCore(GeometryHitTestParameters hitTestParameters);
    internal Point WorldToViewport(Point4D point);
    internal virtual Rect GetHitTestBounds();
    internal virtual Rect CalculateSubgraphBoundsInnerSpace(bool renderBounds);
    private Rect3D get_BBoxSubgraph();
    internal Rect3D ComputeSubgraphBounds3D();
    [ConditionalAttribute("DEBUG")]
private void Debug_VerifyCachedSubgraphBounds();
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
    internal virtual void PrecomputeContent();
    internal virtual void RenderContent(RenderContext ctx, bool isOnChannel);
    internal virtual void FreeContent(Channel channel);
    internal void Visual3DTreeChanged();
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.Get3DHandle(Channel channel);
    [FriendAccessAllowedAttribute]
internal void SetInheritanceContextForChildren(DependencyObject inheritanceContextForChildren);
}
public abstract class System.Windows.Media.Media3D.Visual3D : DependencyObject {
    private static VisualProxyFlags c_Model3DVisualProxyFlagsDirtyMask;
    public static DependencyProperty TransformProperty;
    internal VisualProxy _proxy;
    private static UncommonField`1<Visual> _2DParent;
    private static DependencyObject UseParentAsContext;
    private static UncommonField`1<DependencyObject> _inheritanceContext;
    private static UncommonField`1<AncestorChangedEventHandler> AncestorChangedEventField;
    private Visual3D _3DParent;
    private int _parentIndex;
    private VisualFlags _flags;
    private Rect3D _bboxContent;
    private Rect3D _bboxSubgraph;
    private bool _internalIsVisible;
    private static ScaleTransform3D _zeroScale;
    private Model3D _visual3DModel;
    public Transform3D Transform { get; public set; }
    internal bool InternalIsVisible { get; internal set; }
    protected Model3D Visual3DModel { get; protected set; }
    internal Rect3D VisualContentBounds { get; }
    [FriendAccessAllowedAttribute]
internal Rect Visual2DContentBounds { get; }
    internal Rect3D BBoxSubgraph { get; }
    internal Rect3D VisualDescendantBounds { get; }
    protected int Visual3DChildrenCount { get; }
    internal DependencyObject InheritanceContext { get; }
    internal bool HasMultipleInheritanceContexts { get; }
    internal DependencyObject InternalVisualParent { get; }
    internal int ParentIndex { get; internal set; }
    internal bool IsVisualChildrenIterationInProgress { get; internal set; }
    internal int InternalVisual2DOr3DChildrenCount { get; }
    public bool HasAnimatedProperties { get; }
    private static Visual3D();
    internal bool IsOnChannel(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.Get3DHandle(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.RemoveChildFromParent(IResource parent, Channel channel);
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
    private static void TransformPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Transform3D get_Transform();
    public void set_Transform(Transform3D value);
    protected void AddVisual3DChild(Visual3D child);
    protected void RemoveVisual3DChild(Visual3D child);
    internal bool get_InternalIsVisible();
    internal void set_InternalIsVisible(bool value);
    private void Visual3DModelPropertyChanged(Model3D oldValue, bool isSubpropertyChange);
    private void Visual3DModelPropertyChanged(object o, EventArgs e);
    protected Model3D get_Visual3DModel();
    protected void set_Visual3DModel(Model3D value);
    internal virtual void FireOnVisualParentChanged(DependencyObject oldParent);
    internal void add_VisualAncestorChanged(AncestorChangedEventHandler value);
    internal void remove_VisualAncestorChanged(AncestorChangedEventHandler value);
    internal static void ProcessAncestorChangedNotificationRecursive(DependencyObject e, AncestorChangedEventArgs args);
    protected internal virtual void OnVisualParentChanged(DependencyObject oldParent);
    protected internal virtual void OnVisualChildrenChanged(DependencyObject visualAdded, DependencyObject visualRemoved);
    internal bool DoesRayHitSubgraphBounds(RayHitTestParameters rayParams);
    internal void HitTest(HitTestFilterCallback filterCallback, HitTestResultCallback resultCallback, HitTestParameters3D hitTestParameters);
    internal HitTestResultBehavior RayHitTest(HitTestFilterCallback filterCallback, RayHitTestParameters rayParams);
    internal HitTestResultBehavior HitTestChildren(HitTestFilterCallback filterCallback, RayHitTestParameters rayParams);
    internal static HitTestResultBehavior HitTestChildren(HitTestFilterCallback filterCallback, RayHitTestParameters rayParams, IVisual3DContainer container);
    internal void RayHitTestInternal(HitTestFilterCallback filterCallback, RayHitTestParameters rayParams);
    internal void RenderChanged(object sender, EventArgs e);
    internal Rect3D get_VisualContentBounds();
    internal Rect get_Visual2DContentBounds();
    internal Rect3D get_BBoxSubgraph();
    internal Rect3D GetContentBounds();
    internal Rect3D CalculateSubgraphBoundsOuterSpace();
    internal Rect3D CalculateSubgraphBoundsInnerSpace();
    internal Rect3D get_VisualDescendantBounds();
    private sealed virtual override void MS.Internal.IVisual3DContainer.VerifyAPIReadOnly();
    private sealed virtual override void MS.Internal.IVisual3DContainer.VerifyAPIReadOnly(DependencyObject other);
    private sealed virtual override void MS.Internal.IVisual3DContainer.VerifyAPIReadWrite();
    private sealed virtual override void MS.Internal.IVisual3DContainer.VerifyAPIReadWrite(DependencyObject other);
    internal void VerifyAPIReadOnly();
    internal void VerifyAPIReadOnly(DependencyObject other);
    internal void VerifyAPIReadWrite();
    internal void VerifyAPIReadWrite(DependencyObject other);
    internal void SetParent(Visual newParent);
    internal void SetParent(Visual3D newParent);
    protected virtual int get_Visual3DChildrenCount();
    protected virtual Visual3D GetVisual3DChild(int index);
    private sealed virtual override void MS.Internal.IVisual3DContainer.AddChild(Visual3D child);
    private sealed virtual override void MS.Internal.IVisual3DContainer.RemoveChild(Visual3D child);
    private sealed virtual override int MS.Internal.IVisual3DContainer.GetChildrenCount();
    private sealed virtual override Visual3D MS.Internal.IVisual3DContainer.GetChild(int index);
    internal virtual void InvalidateForceInheritPropertyOnChildren(DependencyProperty property);
    [ConditionalAttribute("DEBUG")]
internal void Debug_VerifyBoundsEqual(Rect3D bounds1, Rect3D bounds2, string errorString);
    [ConditionalAttribute("DEBUG")]
internal void Debug_VerifyCachedSubgraphBounds();
    [ConditionalAttribute("DEBUG")]
internal void Debug_VerifyCachedContentBounds();
    internal void PrecomputeRecursive(Rect3D& bboxSubgraph);
    internal void RenderRecursive(RenderContext ctx);
    internal void RenderContent(RenderContext ctx, bool isOnChannel);
    public bool IsAncestorOf(DependencyObject descendant);
    public bool IsDescendantOf(DependencyObject ancestor);
    internal void SetFlagsToRoot(bool value, VisualFlags flag);
    internal DependencyObject FindFirstAncestorWithFlagsAnd(VisualFlags flag);
    public DependencyObject FindCommonVisualAncestor(DependencyObject otherVisual);
    internal void FreeDUCEResources(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    internal void ReleaseOnChannelCore(Channel channel);
    internal void DisconnectAttachedResource(VisualProxyFlags correspondingFlag, IResource attachedResource);
    internal virtual DependencyObject get_InheritanceContext();
    internal virtual void AddInheritanceContext(DependencyObject context, DependencyProperty property);
    internal virtual void RemoveInheritanceContext(DependencyObject context, DependencyProperty property);
    private void AddOrRemoveInheritanceContext(DependencyObject newInheritanceContext);
    internal virtual bool get_HasMultipleInheritanceContexts();
    internal virtual void OnInheritanceContextChangedCore(EventArgs args);
    public GeneralTransform3D TransformToAncestor(Visual3D ancestor);
    public GeneralTransform3D TransformToDescendant(Visual3D descendant);
    private GeneralTransform3D InternalTransformToAncestor(Visual3D ancestor, bool inverse);
    public GeneralTransform3DTo2D TransformToAncestor(Visual ancestor);
    internal GeneralTransform3DTo2D InternalTransformToAncestor(Visual ancestor);
    internal DependencyObject get_InternalVisualParent();
    internal int get_ParentIndex();
    internal void set_ParentIndex(int value);
    [FriendAccessAllowedAttribute]
internal bool get_IsVisualChildrenIterationInProgress();
    [FriendAccessAllowedAttribute]
internal void set_IsVisualChildrenIterationInProgress(bool value);
    internal void SetFlagsOnAllChannels(bool value, VisualProxyFlags flagsToChange);
    internal void SetFlags(Channel channel, bool value, VisualProxyFlags flagsToChange);
    internal void SetFlags(bool value, VisualFlags Flags);
    internal bool CheckFlagsOnAllChannels(VisualProxyFlags flagsToCheck);
    internal bool CheckFlagsAnd(Channel channel, VisualProxyFlags flagsToCheck);
    internal bool CheckFlagsAnd(VisualFlags flags);
    internal virtual DependencyObject InternalGet2DOr3DVisualChild(int index);
    internal virtual int get_InternalVisual2DOr3DChildrenCount();
    internal bool CheckFlagsOr(Channel channel, VisualProxyFlags flagsToCheck);
    internal bool CheckFlagsOr(VisualFlags flags);
    internal static bool DoAnyChildrenHaveABitSet(Visual3D pe, VisualFlags flag);
    internal static void PropagateFlags(Visual3D e, VisualFlags flags, VisualProxyFlags proxyFlags);
    private void SetInheritanceContext(DependencyObject newInheritanceContext);
    public sealed virtual void ApplyAnimationClock(DependencyProperty dp, AnimationClock clock);
    public sealed virtual void ApplyAnimationClock(DependencyProperty dp, AnimationClock clock, HandoffBehavior handoffBehavior);
    public sealed virtual void BeginAnimation(DependencyProperty dp, AnimationTimeline animation);
    public sealed virtual void BeginAnimation(DependencyProperty dp, AnimationTimeline animation, HandoffBehavior handoffBehavior);
    public sealed virtual bool get_HasAnimatedProperties();
    public sealed virtual object GetAnimationBaseValue(DependencyProperty dp);
    internal sealed virtual void EvaluateAnimatedValueCore(DependencyProperty dp, PropertyMetadata metadata, EffectiveValueEntry& entry);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Media3D.Visual3DCollection : object {
    private IVisual3DContainer _owner;
    private FrugalStructList`1<Visual3D> _collection;
    private int _version;
    public Visual3D Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.Visual3D>.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    internal int InternalCount { get; }
    internal Visual3DCollection(IVisual3DContainer owner);
    public sealed virtual void Add(Visual3D value);
    private void ConnectChild(int index, Visual3D value);
    public sealed virtual void Insert(int index, Visual3D value);
    public sealed virtual bool Remove(Visual3D value);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void Clear();
    public sealed virtual void CopyTo(Visual3D[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public sealed virtual bool Contains(Visual3D value);
    public sealed virtual int IndexOf(Visual3D value);
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<Visual3D> System.Collections.Generic.IEnumerable<System.Windows.Media.Media3D.Visual3D>.GetEnumerator();
    public sealed virtual Visual3D get_Item(int index);
    public sealed virtual void set_Item(int index, Visual3D value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.Media3D.Visual3D>.get_IsReadOnly();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    internal Visual3D InternalGetItem(int index);
    internal int get_InternalCount();
    private void VerifyAPIReadOnly();
    private void VerifyAPIReadOnly(Visual3D other);
    private void VerifyAPIReadWrite();
    private void VerifyAPIReadWrite(Visual3D other);
    private Visual3D Cast(object value);
    private void VerifyAPIForAdd(Visual3D value);
    private void InternalInsert(int index, Visual3D value);
    private void InternalRemoveAt(int index);
    private void InvalidateEnumerators();
    [ConditionalAttribute("DEBUG")]
private void Debug_ICC();
}
public class System.Windows.Media.MediaClock : Clock {
    private MediaPlayer _mediaPlayer;
    public MediaTimeline Timeline { get; }
    internal bool NeedsTicksWhenActive { get; }
    internal MediaPlayer Player { get; internal set; }
    protected internal MediaClock(MediaTimeline media);
    public MediaTimeline get_Timeline();
    protected virtual bool GetCanSlip();
    protected virtual TimeSpan GetCurrentTimeCore();
    protected virtual void Stopped();
    protected virtual void SpeedChanged();
    protected virtual void DiscontinuousTimeMovement();
    private void Sync();
    internal virtual bool get_NeedsTicksWhenActive();
    internal MediaPlayer get_Player();
    internal void set_Player(MediaPlayer value);
}
internal class System.Windows.Media.MediaContext : DispatcherObject {
    [CompilerGeneratedAttribute]
private static bool <ShouldRenderEvenWhenNoDisplayDevicesAreAvailable>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler InvalidPixelShaderEncountered;
    [CompilerGeneratedAttribute]
private UInt32 <PixelShaderVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <MaxPixelShader30InstructionSlots>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasSSE2Support>k__BackingField;
    [CompilerGeneratedAttribute]
private Size <MaxTextureSize>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler TierChanged;
    private TimeManager _timeManager;
    private bool _isDisposed;
    private EventHandler _destroyHandler;
    [CompilerGeneratedAttribute]
private EventHandler _renderCompleteHandlers;
    [CompilerGeneratedAttribute]
private ResourcesUpdatedHandler _resourcesUpdatedHandlers;
    private Guid _contextGuid;
    private DispatcherOperation _currentRenderOp;
    private DispatcherOperation _inputMarkerOp;
    private DispatcherOperationCallback _renderMessage;
    private DispatcherOperationCallback _animRenderMessage;
    private DispatcherOperationCallback _inputMarkerMessage;
    private DispatcherOperationCallback _renderModeMessage;
    private DispatcherTimer _promoteRenderOpToInput;
    private DispatcherTimer _promoteRenderOpToRender;
    private DispatcherTimer _estimatedNextVSyncTimer;
    private ChannelManager _channelManager;
    private Resource _uceEtwEvent;
    private bool _isRendering;
    private bool _isDisconnecting;
    private bool _isConnected;
    private FrugalObjectList`1<InvokeOnRenderCallback> _invokeOnRenderCallbacks;
    private Dictionary`2<ICompositionTarget, object> _registeredICompositionTargets;
    private int _readOnlyAccessCounter;
    private BoundsDrawingContextWalker _cachedBoundsDrawingContextWalker;
    private static int _contextRenderID;
    private int _tier;
    [CompilerGeneratedAttribute]
private EventHandler Rendering;
    [CompilerGeneratedAttribute]
private EventHandler CommittingBatch;
    private FrugalObjectList`1<LoadedOrUnloadedOperation> _loadedOrUnloadedPendingOperations;
    private TimeSpan _timeDelay;
    private bool _commitPendingAfterRender;
    private MediaContextNotificationWindow _notificationWindow;
    private Nullable`1<ChannelSet> _currentRenderingChannel;
    private InterlockState _interlockState;
    private bool _needToCommitChannel;
    private long _lastPresentationTime;
    private long _lastCommitTime;
    private long _lastInputMarkerTime;
    private long _averagePresentationInterval;
    private TimeSpan _estimatedNextPresentationTime;
    private int _displayRefreshRate;
    private int _adjustedRefreshRate;
    private int _animationRenderRate;
    private MIL_PRESENTATION_RESULTS _lastPresentationResults;
    private static long _perfCounterFreq;
    private static long MaxTicksWithoutInput;
    internal static bool IsClockSupported { get; }
    internal static bool ShouldRenderEvenWhenNoDisplayDevicesAreAvailable { get; }
    internal int Tier { get; }
    internal UInt32 PixelShaderVersion { get; private set; }
    internal UInt32 MaxPixelShader30InstructionSlots { get; private set; }
    internal bool HasSSE2Support { get; private set; }
    internal Size MaxTextureSize { get; private set; }
    private bool HasCommittedThisVBlankInterval { get; }
    internal static long CurrentTicks { get; }
    private long RefreshPeriod { get; }
    private TimeSpan System.Windows.Media.Animation.IClock.CurrentTime { get; }
    internal static MediaContext CurrentMediaContext { get; }
    private int InvokeOnRenderCallbacksCount { get; }
    internal bool WriteAccessEnabled { get; }
    internal TimeManager TimeManager { get; }
    internal Channel Channel { get; }
    internal Channel OutOfBandChannel { get; }
    internal bool IsConnected { get; }
    private bool InterlockIsWaiting { get; }
    private bool InterlockIsEnabled { get; }
    private static MediaContext();
    internal MediaContext(Dispatcher dispatcher);
    internal static bool get_IsClockSupported();
    private static long CountsToTicks(long counts);
    private static long TicksToCounts(long ticks);
    private static bool IsPrime(int number);
    private static int FindNextPrime(int number);
    [CompilerGeneratedAttribute]
internal static bool get_ShouldRenderEvenWhenNoDisplayDevicesAreAvailable();
    internal void NotifySyncChannelMessage(Channel channel);
    internal void NotifyChannelMessage();
    internal void PostInvalidateRenderMode();
    private object InvalidateRenderMode(object dontCare);
    private void NotifySetCaps(MilGraphicsAccelerationCaps caps);
    [CompilerGeneratedAttribute]
internal void add_InvalidPixelShaderEncountered(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_InvalidPixelShaderEncountered(EventHandler value);
    private void NotifyBadPixelShader();
    private void NotifyPartitionIsZombie(int failureCode);
    private void HandleInvalidPacketNotification();
    internal int get_Tier();
    [CompilerGeneratedAttribute]
internal UInt32 get_PixelShaderVersion();
    [CompilerGeneratedAttribute]
private void set_PixelShaderVersion(UInt32 value);
    [CompilerGeneratedAttribute]
internal UInt32 get_MaxPixelShader30InstructionSlots();
    [CompilerGeneratedAttribute]
private void set_MaxPixelShader30InstructionSlots(UInt32 value);
    [CompilerGeneratedAttribute]
internal bool get_HasSSE2Support();
    [CompilerGeneratedAttribute]
private void set_HasSSE2Support(bool value);
    [CompilerGeneratedAttribute]
internal Size get_MaxTextureSize();
    [CompilerGeneratedAttribute]
private void set_MaxTextureSize(Size value);
    [CompilerGeneratedAttribute]
internal void add_TierChanged(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_TierChanged(EventHandler value);
    private void RequestTier(Channel channel);
    private void ScheduleNextRenderOp(TimeSpan minimumDelay);
    private void CommitChannelAfterNextVSync();
    private void NotifyPresented(MIL_PRESENTATION_RESULTS presentationResults, long presentationTime, int displayRefreshRate);
    private bool get_HasCommittedThisVBlankInterval();
    internal static long get_CurrentTicks();
    private long get_RefreshPeriod();
    private long TicksSinceLastPresent(long currentTime);
    private long TicksSinceLastVsync(long currentTime);
    private long TicksUntilNextVsync(long currentTime);
    private void NotifySyncModeStatus(int enabledResult);
    private sealed virtual override TimeSpan System.Windows.Media.Animation.IClock.get_CurrentTime();
    internal void CreateChannels();
    private void RemoveChannels();
    private void EnterInterlockedPresentation();
    private void LeaveInterlockedPresentation();
    private void HookNotifications();
    internal static MediaContext From(Dispatcher dispatcher);
    internal static MediaContext get_CurrentMediaContext();
    private void OnDestroyContext(object sender, EventArgs e);
    public virtual void Dispose();
    internal static void RegisterICompositionTarget(Dispatcher dispatcher, ICompositionTarget iv);
    private void RegisterICompositionTargetInternal(ICompositionTarget iv);
    internal static void UnregisterICompositionTarget(Dispatcher dispatcher, ICompositionTarget iv);
    private void UnregisterICompositionTargetInternal(ICompositionTarget iv);
    internal void BeginInvokeOnRender(DispatcherOperationCallback callback, object arg);
    [FriendAccessAllowedAttribute]
internal LoadedOrUnloadedOperation AddLoadedOrUnloadedCallback(DispatcherOperationCallback callback, DependencyObject target);
    [FriendAccessAllowedAttribute]
internal void RemoveLoadedOrUnloadedCallback(LoadedOrUnloadedOperation op);
    internal void PostRender();
    internal void Resize(ICompositionTarget resizedCompositionTarget);
    private object RenderMessageHandler(object resizedCompositionTarget);
    private object AnimatedRenderMessageHandler(object resizedCompositionTarget);
    private object InputMarkerMessageHandler(object arg);
    private void RenderMessageHandlerCore(object resizedCompositionTarget);
    private int get_InvokeOnRenderCallbacksCount();
    private void FireInvokeOnRenderCallbacks();
    private void FireLoadedPendingCallbacks();
    private void Render(ICompositionTarget resizedCompositionTarget);
    private void CommitChannel();
    private void RequestPresentedNotification(Channel channel, long estimatedFrameTime);
    internal void CompleteRender();
    private void OnNeedTickSooner(object sender, EventArgs e);
    internal void VerifyWriteAccess();
    internal bool get_WriteAccessEnabled();
    internal void PushReadOnlyAccess();
    internal void PopReadOnlyAccess();
    internal TimeManager get_TimeManager();
    internal void add_RenderComplete(EventHandler value);
    internal void remove_RenderComplete(EventHandler value);
    internal void add_ResourcesUpdated(ResourcesUpdatedHandler value);
    internal void remove_ResourcesUpdated(ResourcesUpdatedHandler value);
    private void RaiseResourcesUpdated();
    internal Channel AllocateSyncChannel();
    internal void ReleaseSyncChannel(Channel channel);
    internal Channel get_Channel();
    internal Channel get_OutOfBandChannel();
    internal bool get_IsConnected();
    internal BoundsDrawingContextWalker AcquireBoundsDrawingContextWalker();
    internal void ReleaseBoundsDrawingContextWalker(BoundsDrawingContextWalker ctx);
    private void PromoteRenderOpToInput(object sender, EventArgs e);
    private void PromoteRenderOpToRender(object sender, EventArgs e);
    private void EstimatedNextVSyncTimeExpired(object sender, EventArgs e);
    private void RegisterForNotifications(Channel channel);
    internal ChannelSet GetChannels();
    [CompilerGeneratedAttribute]
private void add__renderCompleteHandlers(EventHandler value);
    [CompilerGeneratedAttribute]
private void remove__renderCompleteHandlers(EventHandler value);
    [CompilerGeneratedAttribute]
private void add__resourcesUpdatedHandlers(ResourcesUpdatedHandler value);
    [CompilerGeneratedAttribute]
private void remove__resourcesUpdatedHandlers(ResourcesUpdatedHandler value);
    [CompilerGeneratedAttribute]
internal void add_Rendering(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_Rendering(EventHandler value);
    [CompilerGeneratedAttribute]
internal void add_CommittingBatch(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_CommittingBatch(EventHandler value);
    private bool get_InterlockIsWaiting();
    private bool get_InterlockIsEnabled();
}
internal class System.Windows.Media.MediaContextNotificationWindow : object {
    private bool _isDisposed;
    private MediaContext _ownerMediaContext;
    private SecurityCriticalDataClass`1<HwndWrapper> _hwndNotification;
    private HwndWrapperHook _hwndNotificationHook;
    private static WindowMessage s_channelNotifyMessage;
    private static WindowMessage s_dwmRedirectionEnvironmentChanged;
    private static MediaContextNotificationWindow();
    internal MediaContextNotificationWindow(MediaContext ownerMediaContext);
    public sealed virtual void Dispose();
    internal void SetAsChannelNotificationWindow();
    private IntPtr MessageFilter(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    private static int MilContent_AttachToHwnd(IntPtr hwnd);
    private static int MilContent_DetachFromHwnd(IntPtr hwnd);
    private void ChangeWindowMessageFilter(WindowMessage message, UInt32 flag);
}
internal class System.Windows.Media.MediaEventsHelper : object {
    [CompilerGeneratedAttribute]
private DispatcherOperationCallback DispatcherMediaFailed;
    [CompilerGeneratedAttribute]
private DispatcherOperationCallback DispatcherMediaOpened;
    [CompilerGeneratedAttribute]
private DispatcherOperationCallback DispatcherMediaPrerolled;
    [CompilerGeneratedAttribute]
private DispatcherOperationCallback DispatcherMediaEnded;
    [CompilerGeneratedAttribute]
private DispatcherOperationCallback DispatcherBufferingStarted;
    [CompilerGeneratedAttribute]
private DispatcherOperationCallback DispatcherBufferingEnded;
    [CompilerGeneratedAttribute]
private DispatcherOperationCallback DispatcherScriptCommand;
    [CompilerGeneratedAttribute]
private DispatcherOperationCallback DispatcherMediaNewFrame;
    private MediaPlayer _sender;
    private Dispatcher _dispatcher;
    private DispatcherOperationCallback _mediaOpened;
    private DispatcherOperationCallback _mediaFailed;
    private DispatcherOperationCallback _mediaPrerolled;
    private DispatcherOperationCallback _mediaEnded;
    private DispatcherOperationCallback _bufferingStarted;
    private DispatcherOperationCallback _bufferingEnded;
    private DispatcherOperationCallback _scriptCommand;
    private DispatcherOperationCallback _newFrame;
    private UniqueEventHelper`1<ExceptionEventArgs> _mediaFailedHelper;
    private UniqueEventHelper _mediaOpenedHelper;
    private UniqueEventHelper _mediaPrerolledHelper;
    private UniqueEventHelper _mediaEndedHelper;
    private UniqueEventHelper _bufferingStartedHelper;
    private UniqueEventHelper _bufferingEndedHelper;
    private UniqueEventHelper`1<MediaScriptCommandEventArgs> _scriptCommandHelper;
    private UniqueEventHelper _newFrameHelper;
    internal MediaEventsHelper(MediaPlayer mediaPlayer);
    internal static void CreateMediaEventsHelper(MediaPlayer mediaPlayer, MediaEventsHelper& eventsHelper, SafeMILHandle& unmanagedProxy);
    internal void SetSender(MediaPlayer sender);
    internal void add_MediaFailed(EventHandler`1<ExceptionEventArgs> value);
    internal void remove_MediaFailed(EventHandler`1<ExceptionEventArgs> value);
    internal void add_MediaOpened(EventHandler value);
    internal void remove_MediaOpened(EventHandler value);
    internal void add_MediaPrerolled(EventHandler value);
    internal void remove_MediaPrerolled(EventHandler value);
    internal void add_MediaEnded(EventHandler value);
    internal void remove_MediaEnded(EventHandler value);
    internal void add_BufferingStarted(EventHandler value);
    internal void remove_BufferingStarted(EventHandler value);
    internal void add_BufferingEnded(EventHandler value);
    internal void remove_BufferingEnded(EventHandler value);
    internal void add_ScriptCommand(EventHandler`1<MediaScriptCommandEventArgs> value);
    internal void remove_ScriptCommand(EventHandler`1<MediaScriptCommandEventArgs> value);
    internal void add_NewFrame(EventHandler value);
    internal void remove_NewFrame(EventHandler value);
    internal void RaiseMediaFailed(Exception e);
    private sealed virtual override void System.Windows.Media.IInvokable.RaiseEvent(Byte[] buffer, int cb);
    private void HandleScriptCommand(BinaryReader reader);
    private string GetStringFromReader(BinaryReader reader, int stringLength);
    private object OnMediaOpened(object o);
    private object OnMediaPrerolled(object o);
    private object OnMediaEnded(object o);
    private object OnBufferingStarted(object o);
    private object OnBufferingEnded(object o);
    private object OnMediaFailed(object o);
    private object OnScriptCommand(object o);
    private object OnNewFrame(object e);
    [CompilerGeneratedAttribute]
private void add_DispatcherMediaFailed(DispatcherOperationCallback value);
    [CompilerGeneratedAttribute]
private void remove_DispatcherMediaFailed(DispatcherOperationCallback value);
    [CompilerGeneratedAttribute]
private void add_DispatcherMediaOpened(DispatcherOperationCallback value);
    [CompilerGeneratedAttribute]
private void remove_DispatcherMediaOpened(DispatcherOperationCallback value);
    [CompilerGeneratedAttribute]
private void add_DispatcherMediaPrerolled(DispatcherOperationCallback value);
    [CompilerGeneratedAttribute]
private void remove_DispatcherMediaPrerolled(DispatcherOperationCallback value);
    [CompilerGeneratedAttribute]
private void add_DispatcherMediaEnded(DispatcherOperationCallback value);
    [CompilerGeneratedAttribute]
private void remove_DispatcherMediaEnded(DispatcherOperationCallback value);
    [CompilerGeneratedAttribute]
private void add_DispatcherBufferingStarted(DispatcherOperationCallback value);
    [CompilerGeneratedAttribute]
private void remove_DispatcherBufferingStarted(DispatcherOperationCallback value);
    [CompilerGeneratedAttribute]
private void add_DispatcherBufferingEnded(DispatcherOperationCallback value);
    [CompilerGeneratedAttribute]
private void remove_DispatcherBufferingEnded(DispatcherOperationCallback value);
    [CompilerGeneratedAttribute]
private void add_DispatcherScriptCommand(DispatcherOperationCallback value);
    [CompilerGeneratedAttribute]
private void remove_DispatcherScriptCommand(DispatcherOperationCallback value);
    [CompilerGeneratedAttribute]
private void add_DispatcherMediaNewFrame(DispatcherOperationCallback value);
    [CompilerGeneratedAttribute]
private void remove_DispatcherMediaNewFrame(DispatcherOperationCallback value);
}
public class System.Windows.Media.MediaPlayer : Animatable {
    private MediaPlayerState _mediaPlayerState;
    internal ShareableDUCEMultiChannelResource _duceResource;
    private EventHandler _newFrameHandler;
    private bool _needsUpdate;
    public bool IsBuffering { get; }
    public bool CanPause { get; }
    public double DownloadProgress { get; }
    public double BufferingProgress { get; }
    public int NaturalVideoHeight { get; }
    public int NaturalVideoWidth { get; }
    public bool HasAudio { get; }
    public bool HasVideo { get; }
    public Uri Source { get; }
    public double Volume { get; public set; }
    public double Balance { get; public set; }
    public bool ScrubbingEnabled { get; public set; }
    public bool IsMuted { get; public set; }
    public Duration NaturalDuration { get; }
    public TimeSpan Position { get; public set; }
    public double SpeedRatio { get; public set; }
    public MediaClock Clock { get; public set; }
    public bool get_IsBuffering();
    public bool get_CanPause();
    public double get_DownloadProgress();
    public double get_BufferingProgress();
    public int get_NaturalVideoHeight();
    public int get_NaturalVideoWidth();
    public bool get_HasAudio();
    public bool get_HasVideo();
    public Uri get_Source();
    public double get_Volume();
    public void set_Volume(double value);
    public double get_Balance();
    public void set_Balance(double value);
    public bool get_ScrubbingEnabled();
    public void set_ScrubbingEnabled(bool value);
    public bool get_IsMuted();
    public void set_IsMuted(bool value);
    public Duration get_NaturalDuration();
    public void set_Position(TimeSpan value);
    public TimeSpan get_Position();
    public double get_SpeedRatio();
    public void set_SpeedRatio(double value);
    public void add_MediaFailed(EventHandler`1<ExceptionEventArgs> value);
    public void remove_MediaFailed(EventHandler`1<ExceptionEventArgs> value);
    public void add_MediaOpened(EventHandler value);
    public void remove_MediaOpened(EventHandler value);
    public void add_MediaEnded(EventHandler value);
    public void remove_MediaEnded(EventHandler value);
    public void add_BufferingStarted(EventHandler value);
    public void remove_BufferingStarted(EventHandler value);
    public void add_BufferingEnded(EventHandler value);
    public void remove_BufferingEnded(EventHandler value);
    public void add_ScriptCommand(EventHandler`1<MediaScriptCommandEventArgs> value);
    public void remove_ScriptCommand(EventHandler`1<MediaScriptCommandEventArgs> value);
    public MediaClock get_Clock();
    public void set_Clock(MediaClock value);
    public void Open(Uri source);
    public void Play();
    public void Pause();
    public void Stop();
    public void Close();
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    internal ResourceHandle AddRefOnChannelCore(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    internal void ReleaseOnChannelCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    internal ResourceHandle GetHandleCore(Channel channel);
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    private void CloneCommon(Freezable sourceFreezable);
    private void EnsureState();
    protected void ReadPreamble();
    protected void WritePreamble();
    private void OnNewFrame(object sender, EventArgs args);
    private void UpdateResourceInternal(Channel channel);
    internal void SetSpeedRatio(double value);
    internal void SetSource(Uri source);
    internal void SetPosition(TimeSpan value);
}
internal class System.Windows.Media.MediaPlayerState : object {
    private double _volume;
    private double _balance;
    private bool _muted;
    private bool _scrubbingEnabled;
    private SafeMediaHandle _nativeMedia;
    private MediaEventsHelper _mediaEventsHelper;
    private static double DEFAULT_VOLUME;
    private static double DEFAULT_BALANCE;
    private double _speedRatio;
    private bool _paused;
    private Uri _sourceUri;
    private MediaClock _mediaClock;
    private Dispatcher _dispatcher;
    private UniqueEventHelper _newFrameHelper;
    private UniqueEventHelper _mediaOpenedHelper;
    private static float _defaultDevicePixelsPerInch;
    private Helper _helper;
    internal bool IsBuffering { get; }
    internal bool CanPause { get; }
    internal double DownloadProgress { get; }
    internal double BufferingProgress { get; }
    internal int NaturalVideoHeight { get; }
    internal int NaturalVideoWidth { get; }
    internal bool HasAudio { get; }
    internal bool HasVideo { get; }
    internal Uri Source { get; }
    internal double Volume { get; internal set; }
    internal double Balance { get; internal set; }
    internal bool ScrubbingEnabled { get; internal set; }
    internal bool IsMuted { get; internal set; }
    internal Duration NaturalDuration { get; }
    internal TimeSpan Position { get; internal set; }
    internal double SpeedRatio { get; internal set; }
    internal Dispatcher Dispatcher { get; }
    internal MediaClock Clock { get; }
    unknown double PrivateSpeedRatio {private set; }
    internal MediaPlayerState(MediaPlayer mediaPlayer);
    private void Init();
    protected virtual override void Finalize();
    internal bool get_IsBuffering();
    internal bool get_CanPause();
    internal double get_DownloadProgress();
    internal double get_BufferingProgress();
    internal int get_NaturalVideoHeight();
    internal int get_NaturalVideoWidth();
    internal bool get_HasAudio();
    internal bool get_HasVideo();
    internal Uri get_Source();
    internal double get_Volume();
    internal void set_Volume(double value);
    internal double get_Balance();
    internal void set_Balance(double value);
    internal bool get_ScrubbingEnabled();
    internal void set_ScrubbingEnabled(bool value);
    internal bool get_IsMuted();
    internal void set_IsMuted(bool value);
    internal Duration get_NaturalDuration();
    internal void set_Position(TimeSpan value);
    internal TimeSpan get_Position();
    internal double get_SpeedRatio();
    internal void set_SpeedRatio(double value);
    internal Dispatcher get_Dispatcher();
    internal void add_MediaFailed(EventHandler`1<ExceptionEventArgs> value);
    internal void remove_MediaFailed(EventHandler`1<ExceptionEventArgs> value);
    internal void add_MediaOpened(EventHandler value);
    internal void remove_MediaOpened(EventHandler value);
    internal void add_MediaEnded(EventHandler value);
    internal void remove_MediaEnded(EventHandler value);
    internal void add_BufferingStarted(EventHandler value);
    internal void remove_BufferingStarted(EventHandler value);
    internal void add_BufferingEnded(EventHandler value);
    internal void remove_BufferingEnded(EventHandler value);
    internal void add_ScriptCommand(EventHandler`1<MediaScriptCommandEventArgs> value);
    internal void remove_ScriptCommand(EventHandler`1<MediaScriptCommandEventArgs> value);
    internal void add_NewFrame(EventHandler value);
    internal void remove_NewFrame(EventHandler value);
    internal MediaClock get_Clock();
    internal void SetClock(MediaClock clock, MediaPlayer player);
    internal void Open(Uri source);
    internal void Play();
    internal void Pause();
    internal void Stop();
    internal void Close();
    internal void SendCommandMedia(Channel channel, ResourceHandle handle, bool notifyUceDirectly);
    private void NeedUIFrameUpdate();
    private void CreateMedia(MediaPlayer mediaPlayer);
    private void OpenMedia(Uri source);
    private Uri ResolveUri(Uri uri, Uri appBase);
    private string DemandPermissions(Uri absoluteUri);
    internal void SetPosition(TimeSpan value);
    private TimeSpan GetPosition();
    private void set_PrivateSpeedRatio(double value);
    internal void SetSpeedRatio(double value);
    internal void SetSource(Uri source);
    private void VerifyAPI();
    private void VerifyNotControlledByClock();
    private void SendMediaPlayerCommand(Channel channel, ResourceHandle handle, bool notifyUceDirectly);
    private void OnNewFrame(object sender, EventArgs args);
    private void OnMediaOpened(object sender, EventArgs args);
}
public class System.Windows.Media.MediaScriptCommandEventArgs : EventArgs {
    private string _parameterType;
    private string _parameterValue;
    public string ParameterType { get; }
    public string ParameterValue { get; }
    internal MediaScriptCommandEventArgs(string parameterType, string parameterValue);
    public string get_ParameterType();
    public string get_ParameterValue();
}
internal static class System.Windows.Media.MediaSystem : object {
    private static int s_refCount;
    private static ArrayList _mediaContexts;
    private static bool s_isConnected;
    private static Channel s_serviceChannel;
    private static bool s_animationSmoothing;
    private static IntPtr s_pConnection;
    private static bool s_forceSoftareForGraphicsStreamMagnifier;
    internal static bool IsTransportConnected { get; internal set; }
    internal static bool ForceSoftwareRendering { get; }
    internal static Channel ServiceChannel { get; }
    internal static IntPtr Connection { get; }
    internal static bool AnimationSmoothing { get; }
    private static MediaSystem();
    public static bool Startup(MediaContext mc);
    internal static bool ConnectChannels(MediaContext mc);
    private static void ReadAnimationSmoothingSetting();
    internal static void Shutdown(MediaContext mc);
    internal static void NotifyRedirectionEnvironmentChanged();
    private static void ConnectTransport();
    private static void DisconnectTransport();
    internal static void AssertSameContext(DispatcherObject reference, DispatcherObject other);
    internal static bool get_IsTransportConnected();
    internal static void set_IsTransportConnected(bool value);
    internal static bool get_ForceSoftwareRendering();
    internal static Channel get_ServiceChannel();
    internal static IntPtr get_Connection();
    internal static bool get_AnimationSmoothing();
}
public class System.Windows.Media.MediaTimeline : Timeline {
    internal static UInt32 LastTimelineFlag;
    internal ITypeDescriptorContext _context;
    private Uri _baseUri;
    public static DependencyProperty SourceProperty;
    internal static Uri s_Source;
    private Uri System.Windows.Markup.IUriContext.BaseUri { get; private set; }
    public Uri Source { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    public MediaTimeline(Uri source);
    internal MediaTimeline(ITypeDescriptorContext context, Uri source);
    public MediaTimeline(Nullable`1<TimeSpan> beginTime);
    public MediaTimeline(Nullable`1<TimeSpan> beginTime, Duration duration);
    public MediaTimeline(Nullable`1<TimeSpan> beginTime, Duration duration, RepeatBehavior repeatBehavior);
    private static MediaTimeline();
    private sealed virtual override Uri System.Windows.Markup.IUriContext.get_BaseUri();
    private sealed virtual override void System.Windows.Markup.IUriContext.set_BaseUri(Uri value);
    protected internal virtual Clock AllocateClock();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private void CopyCommon(MediaTimeline sourceTimeline);
    public MediaClock CreateClock();
    protected virtual Duration GetNaturalDurationCore(Clock clock);
    public virtual string ToString();
    public MediaTimeline Clone();
    public MediaTimeline CloneCurrentValue();
    public Uri get_Source();
    public void set_Source(Uri value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual int get_EffectiveValuesInitialSize();
}
internal class System.Windows.Media.MILCMD_DRAW_DRAWING : ValueType {
    public UInt32 hDrawing;
    private UInt32 QuadWordPad0;
    public MILCMD_DRAW_DRAWING(UInt32 hDrawing);
}
internal class System.Windows.Media.MILCMD_DRAW_ELLIPSE : ValueType {
    public Point center;
    public double radiusX;
    public double radiusY;
    public UInt32 hBrush;
    public UInt32 hPen;
    public MILCMD_DRAW_ELLIPSE(UInt32 hBrush, UInt32 hPen, Point center, double radiusX, double radiusY);
}
internal class System.Windows.Media.MILCMD_DRAW_ELLIPSE_ANIMATE : ValueType {
    public Point center;
    public double radiusX;
    public double radiusY;
    public UInt32 hBrush;
    public UInt32 hPen;
    public UInt32 hCenterAnimations;
    public UInt32 hRadiusXAnimations;
    public UInt32 hRadiusYAnimations;
    private UInt32 QuadWordPad0;
    public MILCMD_DRAW_ELLIPSE_ANIMATE(UInt32 hBrush, UInt32 hPen, Point center, UInt32 hCenterAnimations, double radiusX, UInt32 hRadiusXAnimations, double radiusY, UInt32 hRadiusYAnimations);
}
internal class System.Windows.Media.MILCMD_DRAW_GEOMETRY : ValueType {
    public UInt32 hBrush;
    public UInt32 hPen;
    public UInt32 hGeometry;
    private UInt32 QuadWordPad0;
    public MILCMD_DRAW_GEOMETRY(UInt32 hBrush, UInt32 hPen, UInt32 hGeometry);
}
internal class System.Windows.Media.MILCMD_DRAW_GLYPH_RUN : ValueType {
    public UInt32 hForegroundBrush;
    public UInt32 hGlyphRun;
    public MILCMD_DRAW_GLYPH_RUN(UInt32 hForegroundBrush, UInt32 hGlyphRun);
}
internal class System.Windows.Media.MILCMD_DRAW_IMAGE : ValueType {
    public Rect rectangle;
    public UInt32 hImageSource;
    private UInt32 QuadWordPad0;
    public MILCMD_DRAW_IMAGE(UInt32 hImageSource, Rect rectangle);
}
internal class System.Windows.Media.MILCMD_DRAW_IMAGE_ANIMATE : ValueType {
    public Rect rectangle;
    public UInt32 hImageSource;
    public UInt32 hRectangleAnimations;
    public MILCMD_DRAW_IMAGE_ANIMATE(UInt32 hImageSource, Rect rectangle, UInt32 hRectangleAnimations);
}
internal class System.Windows.Media.MILCMD_DRAW_LINE : ValueType {
    public Point point0;
    public Point point1;
    public UInt32 hPen;
    private UInt32 QuadWordPad0;
    public MILCMD_DRAW_LINE(UInt32 hPen, Point point0, Point point1);
}
internal class System.Windows.Media.MILCMD_DRAW_LINE_ANIMATE : ValueType {
    public Point point0;
    public Point point1;
    public UInt32 hPen;
    public UInt32 hPoint0Animations;
    public UInt32 hPoint1Animations;
    private UInt32 QuadWordPad0;
    public MILCMD_DRAW_LINE_ANIMATE(UInt32 hPen, Point point0, UInt32 hPoint0Animations, Point point1, UInt32 hPoint1Animations);
}
internal class System.Windows.Media.MILCMD_DRAW_RECTANGLE : ValueType {
    public Rect rectangle;
    public UInt32 hBrush;
    public UInt32 hPen;
    public MILCMD_DRAW_RECTANGLE(UInt32 hBrush, UInt32 hPen, Rect rectangle);
}
internal class System.Windows.Media.MILCMD_DRAW_RECTANGLE_ANIMATE : ValueType {
    public Rect rectangle;
    public UInt32 hBrush;
    public UInt32 hPen;
    public UInt32 hRectangleAnimations;
    private UInt32 QuadWordPad0;
    public MILCMD_DRAW_RECTANGLE_ANIMATE(UInt32 hBrush, UInt32 hPen, Rect rectangle, UInt32 hRectangleAnimations);
}
internal class System.Windows.Media.MILCMD_DRAW_ROUNDED_RECTANGLE : ValueType {
    public Rect rectangle;
    public double radiusX;
    public double radiusY;
    public UInt32 hBrush;
    public UInt32 hPen;
    public MILCMD_DRAW_ROUNDED_RECTANGLE(UInt32 hBrush, UInt32 hPen, Rect rectangle, double radiusX, double radiusY);
}
internal class System.Windows.Media.MILCMD_DRAW_ROUNDED_RECTANGLE_ANIMATE : ValueType {
    public Rect rectangle;
    public double radiusX;
    public double radiusY;
    public UInt32 hBrush;
    public UInt32 hPen;
    public UInt32 hRectangleAnimations;
    public UInt32 hRadiusXAnimations;
    public UInt32 hRadiusYAnimations;
    private UInt32 QuadWordPad0;
    public MILCMD_DRAW_ROUNDED_RECTANGLE_ANIMATE(UInt32 hBrush, UInt32 hPen, Rect rectangle, UInt32 hRectangleAnimations, double radiusX, UInt32 hRadiusXAnimations, double radiusY, UInt32 hRadiusYAnimations);
}
internal class System.Windows.Media.MILCMD_DRAW_VIDEO : ValueType {
    public Rect rectangle;
    public UInt32 hPlayer;
    private UInt32 QuadWordPad0;
    public MILCMD_DRAW_VIDEO(UInt32 hPlayer, Rect rectangle);
}
internal class System.Windows.Media.MILCMD_DRAW_VIDEO_ANIMATE : ValueType {
    public Rect rectangle;
    public UInt32 hPlayer;
    public UInt32 hRectangleAnimations;
    public MILCMD_DRAW_VIDEO_ANIMATE(UInt32 hPlayer, Rect rectangle, UInt32 hRectangleAnimations);
}
internal class System.Windows.Media.MILCMD_POP : ValueType {
}
internal class System.Windows.Media.MILCMD_PUSH_CLIP : ValueType {
    public UInt32 hClipGeometry;
    private UInt32 QuadWordPad0;
    public MILCMD_PUSH_CLIP(UInt32 hClipGeometry);
}
internal class System.Windows.Media.MILCMD_PUSH_EFFECT : ValueType {
    public UInt32 hEffect;
    public UInt32 hEffectInput;
    public MILCMD_PUSH_EFFECT(UInt32 hEffect, UInt32 hEffectInput);
}
internal class System.Windows.Media.MILCMD_PUSH_GUIDELINE_SET : ValueType {
    public UInt32 hGuidelines;
    private UInt32 QuadWordPad0;
    public MILCMD_PUSH_GUIDELINE_SET(UInt32 hGuidelines);
}
internal class System.Windows.Media.MILCMD_PUSH_GUIDELINE_Y1 : ValueType {
    public double coordinate;
    public MILCMD_PUSH_GUIDELINE_Y1(double coordinate);
}
internal class System.Windows.Media.MILCMD_PUSH_GUIDELINE_Y2 : ValueType {
    public double leadingCoordinate;
    public double offsetToDrivenCoordinate;
    public MILCMD_PUSH_GUIDELINE_Y2(double leadingCoordinate, double offsetToDrivenCoordinate);
}
internal class System.Windows.Media.MILCMD_PUSH_OPACITY : ValueType {
    public double opacity;
    public MILCMD_PUSH_OPACITY(double opacity);
}
internal class System.Windows.Media.MILCMD_PUSH_OPACITY_ANIMATE : ValueType {
    public double opacity;
    public UInt32 hOpacityAnimations;
    private UInt32 QuadWordPad0;
    public MILCMD_PUSH_OPACITY_ANIMATE(double opacity, UInt32 hOpacityAnimations);
}
internal class System.Windows.Media.MILCMD_PUSH_OPACITY_MASK : ValueType {
    public MilRectF boundingBoxCacheLocalSpace;
    public UInt32 hOpacityMask;
    private UInt32 QuadWordPad0;
    public MILCMD_PUSH_OPACITY_MASK(UInt32 hOpacityMask);
}
internal class System.Windows.Media.MILCMD_PUSH_TRANSFORM : ValueType {
    public UInt32 hTransform;
    private UInt32 QuadWordPad0;
    public MILCMD_PUSH_TRANSFORM(UInt32 hTransform);
}
internal static class System.Windows.Media.MILUtilities : object {
    internal static D3DMATRIX D3DMATRIXIdentity;
    private static MILUtilities();
    internal static void ConvertToD3DMATRIX(Matrix* matrix, D3DMATRIX* d3dMatrix);
    internal static void ConvertFromD3DMATRIX(D3DMATRIX* d3dMatrix, Matrix* matrix);
    private static int MIL3DCalcProjected2DBounds(D3DMATRIX& pFullTransform3D, MILRect3D& pboxBounds, MilRectF& prcDestRect);
    internal static void MILCopyPixelBuffer(Byte* pOutputBuffer, UInt32 outputBufferSize, UInt32 outputBufferStride, UInt32 outputBufferOffsetInBits, Byte* pInputBuffer, UInt32 inputBufferSize, UInt32 inputBufferStride, UInt32 inputBufferOffsetInBits, UInt32 height, UInt32 copyWidthInBits);
    internal static Rect ProjectBounds(Matrix3D& viewProjMatrix, Rect3D& originalBox);
}
public enum System.Windows.Media.NumberCultureSource : Enum {
    public int value__;
    public static NumberCultureSource Text;
    public static NumberCultureSource User;
    public static NumberCultureSource Override;
}
public class System.Windows.Media.NumberSubstitution : object {
    public static DependencyProperty CultureSourceProperty;
    public static DependencyProperty CultureOverrideProperty;
    public static DependencyProperty SubstitutionProperty;
    private NumberCultureSource _source;
    private CultureInfo _cultureOverride;
    private NumberSubstitutionMethod _substitution;
    public NumberCultureSource CultureSource { get; public set; }
    [TypeConverterAttribute("System.Windows.CultureInfoIetfLanguageTagConverter")]
public CultureInfo CultureOverride { get; public set; }
    public NumberSubstitutionMethod Substitution { get; public set; }
    public NumberSubstitution(NumberCultureSource source, CultureInfo cultureOverride, NumberSubstitutionMethod substitution);
    private static NumberSubstitution();
    public NumberCultureSource get_CultureSource();
    public void set_CultureSource(NumberCultureSource value);
    public CultureInfo get_CultureOverride();
    public void set_CultureOverride(CultureInfo value);
    private static CultureInfo ThrowIfInvalidCultureOverride(CultureInfo culture);
    private static bool IsValidCultureOverride(CultureInfo culture);
    private static bool IsValidCultureOverrideValue(object value);
    public NumberSubstitutionMethod get_Substitution();
    public void set_Substitution(NumberSubstitutionMethod value);
    public static void SetCultureSource(DependencyObject target, NumberCultureSource value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static NumberCultureSource GetCultureSource(DependencyObject target);
    public static void SetCultureOverride(DependencyObject target, CultureInfo value);
    [TypeConverterAttribute("System.Windows.CultureInfoIetfLanguageTagConverter")]
[AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static CultureInfo GetCultureOverride(DependencyObject target);
    public static void SetSubstitution(DependencyObject target, NumberSubstitutionMethod value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static NumberSubstitutionMethod GetSubstitution(DependencyObject target);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public enum System.Windows.Media.NumberSubstitutionMethod : Enum {
    public int value__;
    public static NumberSubstitutionMethod AsCulture;
    public static NumberSubstitutionMethod Context;
    public static NumberSubstitutionMethod European;
    public static NumberSubstitutionMethod NativeNational;
    public static NumberSubstitutionMethod Traditional;
}
[ContentPropertyAttribute("Segments")]
[LocalizabilityAttribute("0")]
public class System.Windows.Media.PathFigure : Animatable {
    public static DependencyProperty StartPointProperty;
    public static DependencyProperty IsFilledProperty;
    public static DependencyProperty SegmentsProperty;
    public static DependencyProperty IsClosedProperty;
    internal static Point s_StartPoint;
    internal static bool c_IsFilled;
    internal static PathSegmentCollection s_Segments;
    internal static bool c_IsClosed;
    public Point StartPoint { get; public set; }
    public bool IsFilled { get; public set; }
    public PathSegmentCollection Segments { get; public set; }
    public bool IsClosed { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    public PathFigure(Point start, IEnumerable`1<PathSegment> segments, bool closed);
    private static PathFigure();
    public PathFigure GetFlattenedPathFigure(double tolerance, ToleranceType type);
    public PathFigure GetFlattenedPathFigure();
    public bool MayHaveCurves();
    internal PathFigure GetTransformedCopy(Matrix matrix);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal bool CanSerializeToString();
    internal string ConvertToString(string format, IFormatProvider provider);
    internal void SerializeData(StreamGeometryContext ctx);
    public PathFigure Clone();
    public PathFigure CloneCurrentValue();
    public Point get_StartPoint();
    public void set_StartPoint(Point value);
    public bool get_IsFilled();
    public void set_IsFilled(bool value);
    public PathSegmentCollection get_Segments();
    public void set_Segments(PathSegmentCollection value);
    public bool get_IsClosed();
    public void set_IsClosed(bool value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual int get_EffectiveValuesInitialSize();
}
[ValueSerializerAttribute("System.Windows.Media.Converters.PathFigureCollectionValueSerializer")]
[DefaultMemberAttribute("Item")]
[TypeConverterAttribute("System.Windows.Media.PathFigureCollectionConverter")]
public class System.Windows.Media.PathFigureCollection : Animatable {
    private static PathFigureCollection s_empty;
    internal FrugalStructList`1<PathFigure> _collection;
    internal UInt32 _version;
    public PathFigure Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.PathFigure>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal static PathFigureCollection Empty { get; }
    public PathFigureCollection(int capacity);
    public PathFigureCollection(IEnumerable`1<PathFigure> collection);
    internal bool CanSerializeToString();
    public PathFigureCollection Clone();
    public PathFigureCollection CloneCurrentValue();
    public sealed virtual void Add(PathFigure value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(PathFigure value);
    public sealed virtual int IndexOf(PathFigure value);
    public sealed virtual void Insert(int index, PathFigure value);
    public sealed virtual bool Remove(PathFigure value);
    public sealed virtual void RemoveAt(int index);
    internal void RemoveAtWithoutFiringPublicEvents(int index);
    public sealed virtual PathFigure get_Item(int index);
    public sealed virtual void set_Item(int index, PathFigure value);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(PathFigure[] array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.PathFigure>.get_IsReadOnly();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<PathFigure> System.Collections.Generic.IEnumerable<System.Windows.Media.PathFigure>.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal static PathFigureCollection get_Empty();
    internal PathFigure Internal_GetItem(int i);
    internal virtual void OnInheritanceContextChangedCore(EventArgs args);
    private PathFigure Cast(object value);
    private int AddHelper(PathFigure value);
    internal int AddWithoutFiringPublicEvents(PathFigure value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected virtual bool FreezeCore(bool isChecking);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
    public static PathFigureCollection Parse(string source);
}
public class System.Windows.Media.PathFigureCollectionConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[ContentPropertyAttribute("Figures")]
public class System.Windows.Media.PathGeometry : Geometry {
    internal PathGeometryInternalFlags _flags;
    internal MilRectD _bounds;
    public static DependencyProperty FillRuleProperty;
    public static DependencyProperty FiguresProperty;
    internal MultiChannelResource _duceResource;
    internal static FillRule c_FillRule;
    internal static PathFigureCollection s_Figures;
    public Rect Bounds { get; }
    public FillRule FillRule { get; public set; }
    public PathFigureCollection Figures { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    public PathGeometry(IEnumerable`1<PathFigure> figures);
    public PathGeometry(IEnumerable`1<PathFigure> figures, FillRule fillRule, Transform transform);
    private static PathGeometry();
    public static PathGeometry CreateFromGeometry(Geometry geometry);
    internal static void ParsePathGeometryData(PathGeometryData pathData, CapacityStreamGeometryContext ctx);
    protected virtual void OnChanged();
    internal virtual PathFigureCollection GetTransformedFigureCollection(Transform transform);
    public void AddGeometry(Geometry geometry);
    public void GetPointAtFractionLength(double progress, Point& point, Point& tangent);
    internal static PathGeometry InternalCombine(Geometry geometry1, Geometry geometry2, GeometryCombineMode mode, Transform transform, double tolerance, ToleranceType type);
    public void Clear();
    public virtual Rect get_Bounds();
    internal static Rect GetPathBounds(PathGeometryData pathData, Pen pen, Matrix worldMatrix, double tolerance, ToleranceType type, bool skipHollows);
    internal static MilRectD GetPathBoundsAsRB(PathGeometryData pathData, Pen pen, Matrix worldMatrix, double tolerance, ToleranceType type, bool skipHollows);
    internal static IntersectionDetail HitTestWithPathGeometry(Geometry geometry1, Geometry geometry2, double tolerance, ToleranceType type);
    public virtual bool IsEmpty();
    public virtual bool MayHaveCurves();
    internal virtual PathGeometry GetAsPathGeometry();
    internal virtual string ConvertToString(string format, IFormatProvider provider);
    internal void SetDirty();
    internal virtual PathGeometryData GetPathGeometryData();
    private void ManualUpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual void TransformPropertyChangedHook(DependencyPropertyChangedEventArgs e);
    internal void FiguresPropertyChangedHook(DependencyPropertyChangedEventArgs e);
    public PathGeometry Clone();
    public PathGeometry CloneCurrentValue();
    private static void FillRulePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void FiguresPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public FillRule get_FillRule();
    public void set_FillRule(FillRule value);
    public PathFigureCollection get_Figures();
    public void set_Figures(PathFigureCollection value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    internal virtual int get_EffectiveValuesInitialSize();
}
[FlagsAttribute]
internal enum System.Windows.Media.PathGeometryInternalFlags : Enum {
    public int value__;
    public static PathGeometryInternalFlags None;
    public static PathGeometryInternalFlags Invalid;
    public static PathGeometryInternalFlags Dirty;
    public static PathGeometryInternalFlags BoundsValid;
}
[LocalizabilityAttribute("0")]
public abstract class System.Windows.Media.PathSegment : Animatable {
    internal static bool c_isStrokedDefault;
    public static DependencyProperty IsStrokedProperty;
    public static DependencyProperty IsSmoothJoinProperty;
    internal static bool c_IsStroked;
    internal static bool c_IsSmoothJoin;
    public bool IsStroked { get; public set; }
    public bool IsSmoothJoin { get; public set; }
    private static PathSegment();
    internal abstract virtual void AddToFigure(Matrix matrix, PathFigure figure, Point& current);
    internal virtual bool IsEmpty();
    internal abstract virtual bool IsCurved();
    internal abstract virtual string ConvertToString(string format, IFormatProvider provider);
    internal abstract virtual void SerializeData(StreamGeometryContext ctx);
    public PathSegment Clone();
    public PathSegment CloneCurrentValue();
    public bool get_IsStroked();
    public void set_IsStroked(bool value);
    public bool get_IsSmoothJoin();
    public void set_IsSmoothJoin(bool value);
}
[DefaultMemberAttribute("Item")]
[LocalizabilityAttribute("0")]
public class System.Windows.Media.PathSegmentCollection : Animatable {
    private static PathSegmentCollection s_empty;
    internal FrugalStructList`1<PathSegment> _collection;
    internal UInt32 _version;
    public PathSegment Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.PathSegment>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal static PathSegmentCollection Empty { get; }
    public PathSegmentCollection(int capacity);
    public PathSegmentCollection(IEnumerable`1<PathSegment> collection);
    internal bool CanSerializeToString();
    internal string ConvertToString(string format, IFormatProvider provider);
    public PathSegmentCollection Clone();
    public PathSegmentCollection CloneCurrentValue();
    public sealed virtual void Add(PathSegment value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(PathSegment value);
    public sealed virtual int IndexOf(PathSegment value);
    public sealed virtual void Insert(int index, PathSegment value);
    public sealed virtual bool Remove(PathSegment value);
    public sealed virtual void RemoveAt(int index);
    internal void RemoveAtWithoutFiringPublicEvents(int index);
    public sealed virtual PathSegment get_Item(int index);
    public sealed virtual void set_Item(int index, PathSegment value);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(PathSegment[] array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.PathSegment>.get_IsReadOnly();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<PathSegment> System.Collections.Generic.IEnumerable<System.Windows.Media.PathSegment>.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal static PathSegmentCollection get_Empty();
    internal PathSegment Internal_GetItem(int i);
    internal virtual void OnInheritanceContextChangedCore(EventArgs args);
    private PathSegment Cast(object value);
    private int AddHelper(PathSegment value);
    internal int AddWithoutFiringPublicEvents(PathSegment value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected virtual bool FreezeCore(bool isChecking);
}
internal class System.Windows.Media.PathStreamGeometryContext : CapacityStreamGeometryContext {
    private PathGeometry _pathGeometry;
    private PathFigureCollection _figures;
    private PathFigure _currentFigure;
    private PathSegmentCollection _segments;
    private bool _currentIsClosed;
    private MIL_SEGMENT_TYPE _currentSegmentType;
    private PointCollection _currentSegmentPoints;
    private bool _currentSegmentIsStroked;
    private bool _currentSegmentIsSmoothJoin;
    private static FillRule s_defaultFillRule;
    private static bool s_defaultValueForPathFigureIsClosed;
    private static bool s_defaultValueForPathFigureIsFilled;
    private static Point s_defaultValueForPathFigureStartPoint;
    private static bool s_defaultValueForPathSegmentIsStroked;
    private static bool s_defaultValueForPathSegmentIsSmoothJoin;
    private static bool s_defaultValueForArcSegmentIsLargeArc;
    private static SweepDirection s_defaultValueForArcSegmentSweepDirection;
    private static double s_defaultValueForArcSegmentRotationAngle;
    private static PathStreamGeometryContext();
    internal PathStreamGeometryContext(FillRule fillRule, Transform transform);
    internal virtual void SetFigureCount(int figureCount);
    internal virtual void SetSegmentCount(int segmentCount);
    internal virtual void SetClosedState(bool isClosed);
    public virtual void BeginFigure(Point startPoint, bool isFilled, bool isClosed);
    public virtual void LineTo(Point point, bool isStroked, bool isSmoothJoin);
    public virtual void QuadraticBezierTo(Point point1, Point point2, bool isStroked, bool isSmoothJoin);
    public virtual void BezierTo(Point point1, Point point2, Point point3, bool isStroked, bool isSmoothJoin);
    public virtual void PolyLineTo(IList`1<Point> points, bool isStroked, bool isSmoothJoin);
    public virtual void PolyQuadraticBezierTo(IList`1<Point> points, bool isStroked, bool isSmoothJoin);
    public virtual void PolyBezierTo(IList`1<Point> points, bool isStroked, bool isSmoothJoin);
    public virtual void ArcTo(Point point, Size size, double rotationAngle, bool isLargeArc, SweepDirection sweepDirection, bool isStroked, bool isSmoothJoin);
    public virtual void Close();
    internal PathGeometry GetPathGeometry();
    private void GenericPolyTo(IList`1<Point> points, bool isStroked, bool isSmoothJoin, MIL_SEGMENT_TYPE segmentType);
    private void PrepareToAddPoints(int count, bool isStroked, bool isSmoothJoin, MIL_SEGMENT_TYPE segmentType);
    private void FinishSegment();
}
[LocalizabilityAttribute("0")]
public class System.Windows.Media.Pen : Animatable {
    public static DependencyProperty BrushProperty;
    public static DependencyProperty ThicknessProperty;
    public static DependencyProperty StartLineCapProperty;
    public static DependencyProperty EndLineCapProperty;
    public static DependencyProperty DashCapProperty;
    public static DependencyProperty LineJoinProperty;
    public static DependencyProperty MiterLimitProperty;
    public static DependencyProperty DashStyleProperty;
    internal MultiChannelResource _duceResource;
    internal static double c_Thickness;
    internal static PenLineCap c_StartLineCap;
    internal static PenLineCap c_EndLineCap;
    internal static PenLineCap c_DashCap;
    internal static PenLineJoin c_LineJoin;
    internal static double c_MiterLimit;
    internal static DashStyle s_DashStyle;
    internal bool DoesNotContainGaps { get; }
    public Brush Brush { get; public set; }
    public double Thickness { get; public set; }
    public PenLineCap StartLineCap { get; public set; }
    public PenLineCap EndLineCap { get; public set; }
    public PenLineCap DashCap { get; public set; }
    public PenLineJoin LineJoin { get; public set; }
    public double MiterLimit { get; public set; }
    public DashStyle DashStyle { get; public set; }
    public Pen(Brush brush, double thickness);
    internal Pen(Brush brush, double thickness, PenLineCap startLineCap, PenLineCap endLineCap, PenLineCap dashCap, PenLineJoin lineJoin, double miterLimit, DashStyle dashStyle);
    private static Pen();
    private MIL_PEN_CAP GetInternalCapType(PenLineCap cap);
    private MIL_PEN_JOIN GetInternalJoinType(PenLineJoin join);
    internal void GetBasicPenData(MIL_PEN_DATA* pData, Double[]& dashArray);
    internal bool get_DoesNotContainGaps();
    internal static bool ContributesToBounds(Pen pen);
    public Pen Clone();
    public Pen CloneCurrentValue();
    private static void BrushPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void ThicknessPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void StartLineCapPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void EndLineCapPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void DashCapPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void LineJoinPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void MiterLimitPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void DashStylePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Brush get_Brush();
    public void set_Brush(Brush value);
    public double get_Thickness();
    public void set_Thickness(double value);
    public PenLineCap get_StartLineCap();
    public void set_StartLineCap(PenLineCap value);
    public PenLineCap get_EndLineCap();
    public void set_EndLineCap(PenLineCap value);
    public PenLineCap get_DashCap();
    public void set_DashCap(PenLineCap value);
    public PenLineJoin get_LineJoin();
    public void set_LineJoin(PenLineJoin value);
    public double get_MiterLimit();
    public void set_MiterLimit(double value);
    public DashStyle get_DashStyle();
    public void set_DashStyle(DashStyle value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
}
public enum System.Windows.Media.PenDashCap : Enum {
    public int value__;
    public static PenDashCap Flat;
    public static PenDashCap Round;
    public static PenDashCap Triangle;
}
public enum System.Windows.Media.PenLineCap : Enum {
    public int value__;
    public static PenLineCap Flat;
    public static PenLineCap Square;
    public static PenLineCap Round;
    public static PenLineCap Triangle;
}
public enum System.Windows.Media.PenLineJoin : Enum {
    public int value__;
    public static PenLineJoin Miter;
    public static PenLineJoin Bevel;
    public static PenLineJoin Round;
}
[TypeConverterAttribute("System.Windows.Media.PixelFormatConverter")]
public class System.Windows.Media.PixelFormat : ValueType {
    private PixelFormatFlags _flags;
    private PixelFormatEnum _format;
    private UInt32 _bitsPerPixel;
    private SecurityCriticalDataForSet`1<Guid> _guidFormat;
    private static Guid WICPixelFormatPhotonFirst;
    private static Guid WICPixelFormatPhotonLast;
    private PixelFormatFlags FormatFlags { get; }
    public int BitsPerPixel { get; }
    public IList`1<PixelFormatChannelMask> Masks { get; }
    internal int InternalBitsPerPixel { get; }
    internal bool HasAlpha { get; }
    internal bool Palettized { get; }
    internal PixelFormatEnum Format { get; }
    internal Guid Guid { get; }
    internal PixelFormat(Guid guidPixelFormat);
    internal PixelFormat(PixelFormatEnum format);
    internal PixelFormat(string pixelFormatString);
    private static PixelFormat();
    private static Guid GetGuidFromFormat(PixelFormatEnum format);
    private PixelFormatFlags get_FormatFlags();
    public static bool op_Equality(PixelFormat left, PixelFormat right);
    public static bool op_Inequality(PixelFormat left, PixelFormat right);
    public static bool Equals(PixelFormat left, PixelFormat right);
    public sealed virtual bool Equals(PixelFormat pixelFormat);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public int get_BitsPerPixel();
    public IList`1<PixelFormatChannelMask> get_Masks();
    internal IntPtr CreatePixelFormatInfo();
    internal int get_InternalBitsPerPixel();
    internal bool get_HasAlpha();
    internal bool get_Palettized();
    internal PixelFormatEnum get_Format();
    internal Guid get_Guid();
    public virtual string ToString();
    internal static PixelFormat GetPixelFormat(SafeMILHandle bitmapSource);
    internal static PixelFormat GetPixelFormat(Guid pixelFormatGuid);
    internal static PixelFormat GetPixelFormat(PixelFormatEnum pixelFormatEnum);
    private static PixelFormatFlags GetPixelFormatFlagsFromGuid(Guid pixelFormatGuid);
    private static PixelFormatFlags GetPixelFormatFlagsFromEnum(PixelFormatEnum pixelFormatEnum);
    private static UInt32 GetBitsPerPixelFromEnum(PixelFormatEnum pixelFormatEnum);
}
public class System.Windows.Media.PixelFormatChannelMask : ValueType {
    private Byte[] _mask;
    public IList`1<byte> Mask { get; }
    internal PixelFormatChannelMask(Byte[] mask);
    public IList`1<byte> get_Mask();
    public static bool op_Equality(PixelFormatChannelMask left, PixelFormatChannelMask right);
    public static bool Equals(PixelFormatChannelMask left, PixelFormatChannelMask right);
    public static bool op_Inequality(PixelFormatChannelMask left, PixelFormatChannelMask right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class System.Windows.Media.PixelFormatConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext td, Type t);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public object ConvertFromString(string value);
    public virtual object ConvertFrom(ITypeDescriptorContext td, CultureInfo ci, object o);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[FlagsAttribute]
internal enum System.Windows.Media.PixelFormatFlags : Enum {
    public int value__;
    public static PixelFormatFlags BitsPerPixelMask;
    public static PixelFormatFlags BitsPerPixelUndefined;
    public static PixelFormatFlags BitsPerPixel1;
    public static PixelFormatFlags BitsPerPixel2;
    public static PixelFormatFlags BitsPerPixel4;
    public static PixelFormatFlags BitsPerPixel8;
    public static PixelFormatFlags BitsPerPixel16;
    public static PixelFormatFlags BitsPerPixel24;
    public static PixelFormatFlags BitsPerPixel32;
    public static PixelFormatFlags BitsPerPixel48;
    public static PixelFormatFlags BitsPerPixel64;
    public static PixelFormatFlags BitsPerPixel96;
    public static PixelFormatFlags BitsPerPixel128;
    public static PixelFormatFlags IsGray;
    public static PixelFormatFlags IsCMYK;
    public static PixelFormatFlags IsSRGB;
    public static PixelFormatFlags IsScRGB;
    public static PixelFormatFlags Premultiplied;
    public static PixelFormatFlags ChannelOrderMask;
    public static PixelFormatFlags ChannelOrderRGB;
    public static PixelFormatFlags ChannelOrderBGR;
    public static PixelFormatFlags ChannelOrderARGB;
    public static PixelFormatFlags ChannelOrderABGR;
    public static PixelFormatFlags Palettized;
    public static PixelFormatFlags NChannelAlpha;
    public static PixelFormatFlags IsNChannel;
}
public static class System.Windows.Media.PixelFormats : object {
    public static PixelFormat Default { get; }
    public static PixelFormat Indexed1 { get; }
    public static PixelFormat Indexed2 { get; }
    public static PixelFormat Indexed4 { get; }
    public static PixelFormat Indexed8 { get; }
    public static PixelFormat BlackWhite { get; }
    public static PixelFormat Gray2 { get; }
    public static PixelFormat Gray4 { get; }
    public static PixelFormat Gray8 { get; }
    public static PixelFormat Bgr555 { get; }
    public static PixelFormat Bgr565 { get; }
    public static PixelFormat Rgb128Float { get; }
    public static PixelFormat Bgr24 { get; }
    public static PixelFormat Rgb24 { get; }
    public static PixelFormat Bgr101010 { get; }
    public static PixelFormat Bgr32 { get; }
    public static PixelFormat Bgra32 { get; }
    public static PixelFormat Pbgra32 { get; }
    public static PixelFormat Rgb48 { get; }
    public static PixelFormat Rgba64 { get; }
    public static PixelFormat Prgba64 { get; }
    public static PixelFormat Gray16 { get; }
    public static PixelFormat Gray32Float { get; }
    public static PixelFormat Rgba128Float { get; }
    public static PixelFormat Prgba128Float { get; }
    public static PixelFormat Cmyk32 { get; }
    public static PixelFormat get_Default();
    public static PixelFormat get_Indexed1();
    public static PixelFormat get_Indexed2();
    public static PixelFormat get_Indexed4();
    public static PixelFormat get_Indexed8();
    public static PixelFormat get_BlackWhite();
    public static PixelFormat get_Gray2();
    public static PixelFormat get_Gray4();
    public static PixelFormat get_Gray8();
    public static PixelFormat get_Bgr555();
    public static PixelFormat get_Bgr565();
    public static PixelFormat get_Rgb128Float();
    public static PixelFormat get_Bgr24();
    public static PixelFormat get_Rgb24();
    public static PixelFormat get_Bgr101010();
    public static PixelFormat get_Bgr32();
    public static PixelFormat get_Bgra32();
    public static PixelFormat get_Pbgra32();
    public static PixelFormat get_Rgb48();
    public static PixelFormat get_Rgba64();
    public static PixelFormat get_Prgba64();
    public static PixelFormat get_Gray16();
    public static PixelFormat get_Gray32Float();
    public static PixelFormat get_Rgba128Float();
    public static PixelFormat get_Prgba128Float();
    public static PixelFormat get_Cmyk32();
}
[TypeConverterAttribute("System.Windows.Media.PointCollectionConverter")]
[ValueSerializerAttribute("System.Windows.Media.Converters.PointCollectionValueSerializer")]
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.PointCollection : Freezable {
    private static PointCollection s_empty;
    internal FrugalStructList`1<Point> _collection;
    internal UInt32 _version;
    public Point Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Point>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal static PointCollection Empty { get; }
    public PointCollection(int capacity);
    public PointCollection(IEnumerable`1<Point> collection);
    [FriendAccessAllowedAttribute]
internal static object DeserializeFrom(BinaryReader reader);
    public PointCollection Clone();
    public PointCollection CloneCurrentValue();
    public sealed virtual void Add(Point value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Point value);
    public sealed virtual int IndexOf(Point value);
    public sealed virtual void Insert(int index, Point value);
    public sealed virtual bool Remove(Point value);
    public sealed virtual void RemoveAt(int index);
    internal void RemoveAtWithoutFiringPublicEvents(int index);
    public sealed virtual Point get_Item(int index);
    public sealed virtual void set_Item(int index, Point value);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(Point[] array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Point>.get_IsReadOnly();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<Point> System.Collections.Generic.IEnumerable<System.Windows.Point>.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal static PointCollection get_Empty();
    internal Point Internal_GetItem(int i);
    private Point Cast(object value);
    private int AddHelper(Point value);
    internal int AddWithoutFiringPublicEvents(Point value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
    public static PointCollection Parse(string source);
}
public class System.Windows.Media.PointCollectionConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.PointHitTestParameters : HitTestParameters {
    private Point _hitPoint;
    public Point HitPoint { get; }
    public PointHitTestParameters(Point point);
    public Point get_HitPoint();
    internal void SetHitPoint(Point hitPoint);
}
public class System.Windows.Media.PointHitTestResult : HitTestResult {
    private Point _pointHit;
    public Point PointHit { get; }
    public Visual VisualHit { get; }
    public PointHitTestResult(Visual visualHit, Point pointHit);
    public Point get_PointHit();
    public Visual get_VisualHit();
}
public class System.Windows.Media.PolyBezierSegment : PathSegment {
    public static DependencyProperty PointsProperty;
    internal static PointCollection s_Points;
    public PointCollection Points { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    private static PolyBezierSegment();
    public PolyBezierSegment(IEnumerable`1<Point> points, bool isStroked);
    internal PolyBezierSegment(IEnumerable`1<Point> points, bool isStroked, bool isSmoothJoin);
    internal virtual string ConvertToString(string format, IFormatProvider provider);
    public PolyBezierSegment Clone();
    public PolyBezierSegment CloneCurrentValue();
    public PointCollection get_Points();
    public void set_Points(PointCollection value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual int get_EffectiveValuesInitialSize();
    internal virtual void AddToFigure(Matrix matrix, PathFigure figure, Point& current);
    internal virtual bool IsEmpty();
    internal virtual bool IsCurved();
    internal virtual void SerializeData(StreamGeometryContext ctx);
}
public class System.Windows.Media.PolyLineSegment : PathSegment {
    public static DependencyProperty PointsProperty;
    internal static PointCollection s_Points;
    public PointCollection Points { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    private static PolyLineSegment();
    public PolyLineSegment(IEnumerable`1<Point> points, bool isStroked);
    internal PolyLineSegment(IEnumerable`1<Point> points, bool isStroked, bool isSmoothJoin);
    internal virtual string ConvertToString(string format, IFormatProvider provider);
    public PolyLineSegment Clone();
    public PolyLineSegment CloneCurrentValue();
    public PointCollection get_Points();
    public void set_Points(PointCollection value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual int get_EffectiveValuesInitialSize();
    internal virtual void AddToFigure(Matrix matrix, PathFigure figure, Point& current);
    internal virtual bool IsEmpty();
    internal virtual bool IsCurved();
    internal virtual void SerializeData(StreamGeometryContext ctx);
}
public class System.Windows.Media.PolyQuadraticBezierSegment : PathSegment {
    public static DependencyProperty PointsProperty;
    internal static PointCollection s_Points;
    public PointCollection Points { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    private static PolyQuadraticBezierSegment();
    public PolyQuadraticBezierSegment(IEnumerable`1<Point> points, bool isStroked);
    internal PolyQuadraticBezierSegment(IEnumerable`1<Point> points, bool isStroked, bool isSmoothJoin);
    internal virtual string ConvertToString(string format, IFormatProvider provider);
    public PolyQuadraticBezierSegment Clone();
    public PolyQuadraticBezierSegment CloneCurrentValue();
    public PointCollection get_Points();
    public void set_Points(PointCollection value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual int get_EffectiveValuesInitialSize();
    internal virtual void AddToFigure(Matrix matrix, PathFigure figure, Point& current);
    internal virtual bool IsEmpty();
    internal virtual bool IsCurved();
    internal virtual void SerializeData(StreamGeometryContext ctx);
}
public class System.Windows.Media.QuadraticBezierSegment : PathSegment {
    public static DependencyProperty Point1Property;
    public static DependencyProperty Point2Property;
    internal static Point s_Point1;
    internal static Point s_Point2;
    public Point Point1 { get; public set; }
    public Point Point2 { get; public set; }
    public QuadraticBezierSegment(Point point1, Point point2, bool isStroked);
    internal QuadraticBezierSegment(Point point1, Point point2, bool isStroked, bool isSmoothJoin);
    private static QuadraticBezierSegment();
    internal virtual void AddToFigure(Matrix matrix, PathFigure figure, Point& current);
    internal virtual void SerializeData(StreamGeometryContext ctx);
    internal virtual bool IsCurved();
    internal virtual string ConvertToString(string format, IFormatProvider provider);
    public QuadraticBezierSegment Clone();
    public QuadraticBezierSegment CloneCurrentValue();
    public Point get_Point1();
    public void set_Point1(Point value);
    public Point get_Point2();
    public void set_Point2(Point value);
    protected virtual Freezable CreateInstanceCore();
}
public class System.Windows.Media.RadialGradientBrush : GradientBrush {
    public static DependencyProperty CenterProperty;
    public static DependencyProperty RadiusXProperty;
    public static DependencyProperty RadiusYProperty;
    public static DependencyProperty GradientOriginProperty;
    internal MultiChannelResource _duceResource;
    internal static Point s_Center;
    internal static double c_RadiusX;
    internal static double c_RadiusY;
    internal static Point s_GradientOrigin;
    public Point Center { get; public set; }
    public double RadiusX { get; public set; }
    public double RadiusY { get; public set; }
    public Point GradientOrigin { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    public RadialGradientBrush(Color startColor, Color endColor);
    public RadialGradientBrush(GradientStopCollection gradientStopCollection);
    private static RadialGradientBrush();
    private void ManualUpdateResource(Channel channel, bool skipOnChannelCheck);
    public RadialGradientBrush Clone();
    public RadialGradientBrush CloneCurrentValue();
    private static void CenterPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void RadiusXPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void RadiusYPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void GradientOriginPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Point get_Center();
    public void set_Center(Point value);
    public double get_RadiusX();
    public void set_RadiusX(double value);
    public double get_RadiusY();
    public void set_RadiusY(double value);
    public Point get_GradientOrigin();
    public void set_GradientOrigin(Point value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    internal virtual int get_EffectiveValuesInitialSize();
}
public class System.Windows.Media.RectangleGeometry : Geometry {
    private static UInt32 c_roundedSegmentCount;
    private static UInt32 c_roundedPointCount;
    private static byte smoothBezier;
    private static byte smoothLine;
    private static Byte[] s_roundedPathTypes;
    private static UInt32 c_squaredSegmentCount;
    private static UInt32 c_squaredPointCount;
    private static Byte[] s_squaredPathTypes;
    public static DependencyProperty RadiusXProperty;
    public static DependencyProperty RadiusYProperty;
    public static DependencyProperty RectProperty;
    internal MultiChannelResource _duceResource;
    internal static double c_RadiusX;
    internal static double c_RadiusY;
    internal static Rect s_Rect;
    public Rect Bounds { get; }
    public double RadiusX { get; public set; }
    public double RadiusY { get; public set; }
    public Rect Rect { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    public RectangleGeometry(Rect rect);
    public RectangleGeometry(Rect rect, double radiusX, double radiusY);
    public RectangleGeometry(Rect rect, double radiusX, double radiusY, Transform transform);
    private static RectangleGeometry();
    public virtual Rect get_Bounds();
    internal virtual bool AreClose(Geometry geometry);
    internal virtual Rect GetBoundsInternal(Pen pen, Matrix worldMatrix, double tolerance, ToleranceType type);
    internal static Rect GetBoundsHelper(Pen pen, Matrix worldMatrix, Rect rect, double radiusX, double radiusY, Matrix geometryMatrix, double tolerance, ToleranceType type);
    internal virtual bool ContainsInternal(Pen pen, Point hitPoint, double tolerance, ToleranceType type);
    public virtual double GetArea(double tolerance, ToleranceType type);
    internal virtual PathFigureCollection GetTransformedFigureCollection(Transform transform);
    internal static bool IsRounded(double radiusX, double radiusY);
    internal bool IsRounded();
    internal virtual PathGeometry GetAsPathGeometry();
    internal virtual PathGeometryData GetPathGeometryData();
    private Point[] GetPointList(Rect rect, double radiusX, double radiusY);
    private static void GetPointList(Point* points, UInt32 pointsCount, Rect rect, double radiusX, double radiusY);
    private static Byte[] GetTypeList(Rect rect, double radiusX, double radiusY);
    private UInt32 GetPointCount(Rect rect, double radiusX, double radiusY);
    private UInt32 GetSegmentCount(Rect rect, double radiusX, double radiusY);
    private static void GetCounts(Rect rect, double radiusX, double radiusY, UInt32& pointCount, UInt32& segmentCount);
    public virtual bool IsEmpty();
    public virtual bool MayHaveCurves();
    public RectangleGeometry Clone();
    public RectangleGeometry CloneCurrentValue();
    private static void RadiusXPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void RadiusYPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void RectPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public double get_RadiusX();
    public void set_RadiusX(double value);
    public double get_RadiusY();
    public void set_RadiusY(double value);
    public Rect get_Rect();
    public void set_Rect(Rect value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    internal virtual int get_EffectiveValuesInitialSize();
}
public static class System.Windows.Media.RenderCapability : object {
    private static string IsShaderEffectSoftwareRenderingSupported_Deprecated;
    public static int Tier { get; }
    [ObsoleteAttribute("IsShaderEffectSoftwareRenderingSupported property is deprecated.  Use IsPixelShaderVersionSupportedInSoftware static method instead.")]
public static bool IsShaderEffectSoftwareRenderingSupported { get; }
    public static Size MaxHardwareTextureSize { get; }
    public static int get_Tier();
    public static bool IsPixelShaderVersionSupported(short majorVersionRequested, short minorVersionRequested);
    public static bool IsPixelShaderVersionSupportedInSoftware(short majorVersionRequested, short minorVersionRequested);
    public static bool get_IsShaderEffectSoftwareRenderingSupported();
    public static int MaxPixelShaderInstructionSlots(short majorVersionRequested, short minorVersionRequested);
    public static Size get_MaxHardwareTextureSize();
    public static void add_TierChanged(EventHandler value);
    public static void remove_TierChanged(EventHandler value);
}
internal class System.Windows.Media.RenderContext : object {
    private Channel _channel;
    private ResourceHandle _root;
    internal Channel Channel { get; }
    internal ResourceHandle Root { get; }
    internal Channel get_Channel();
    internal ResourceHandle get_Root();
    internal void Initialize(Channel channel, ResourceHandle root);
}
internal class System.Windows.Media.RenderData : Freezable {
    private Byte[] _buffer;
    private int _curOffset;
    private int _bitmapEffectStackDepth;
    private FrugalStructList`1<object> _dependentResources;
    private MultiChannelResource _duceResource;
    internal int BitmapEffectStackDepth { get; internal set; }
    public int DataSize { get; }
    public void WriteDataRecord(MILCMD id, Byte* pbRecord, int cbRecordSize);
    public sealed virtual Rect GetContentBounds(BoundsDrawingContextWalker ctx);
    public sealed virtual void WalkContent(DrawingContextWalker walker);
    public sealed virtual bool HitTestPoint(Point point);
    public sealed virtual IntersectionDetail HitTestGeometry(PathGeometry geometry);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    public sealed virtual void PropagateChangedHandler(EventHandler handler, bool adding);
    internal int get_BitmapEffectStackDepth();
    internal void set_BitmapEffectStackDepth(int value);
    internal void BeginTopLevelBitmapEffect(int stackDepth);
    internal void EndTopLevelBitmapEffect();
    public int get_DataSize();
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.RemoveChildFromParent(IResource parent, Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.Get3DHandle(Channel channel);
    public UInt32 AddDependentResource(object o);
    private void UpdateResource(Channel channel);
    private void EnsureBuffer(int cbRequiredSize);
    private object DependentLookup(UInt32 index);
    private void MarshalToDUCE(Channel channel);
    public void DrawingContextWalk(DrawingContextWalker ctx);
    public void BaseValueDrawingContextWalk(DrawingContextWalker ctx);
}
internal class System.Windows.Media.RenderDataDrawingContext : DrawingContext {
    private RenderData _renderData;
    private bool _disposed;
    private int _stackDepth;
    internal RenderData GetRenderData();
    public virtual void Close();
    protected virtual void DisposeCore();
    protected virtual void CloseCore(RenderData renderData);
    private void EnsureRenderData();
    protected virtual void VerifyApiNonstructuralChange();
    private void EnsureCorrectNesting();
    public virtual void DrawLine(Pen pen, Point point0, Point point1);
    public virtual void DrawLine(Pen pen, Point point0, AnimationClock point0Animations, Point point1, AnimationClock point1Animations);
    public virtual void DrawRectangle(Brush brush, Pen pen, Rect rectangle);
    public virtual void DrawRectangle(Brush brush, Pen pen, Rect rectangle, AnimationClock rectangleAnimations);
    public virtual void DrawRoundedRectangle(Brush brush, Pen pen, Rect rectangle, double radiusX, double radiusY);
    public virtual void DrawRoundedRectangle(Brush brush, Pen pen, Rect rectangle, AnimationClock rectangleAnimations, double radiusX, AnimationClock radiusXAnimations, double radiusY, AnimationClock radiusYAnimations);
    public virtual void DrawEllipse(Brush brush, Pen pen, Point center, double radiusX, double radiusY);
    public virtual void DrawEllipse(Brush brush, Pen pen, Point center, AnimationClock centerAnimations, double radiusX, AnimationClock radiusXAnimations, double radiusY, AnimationClock radiusYAnimations);
    public virtual void DrawGeometry(Brush brush, Pen pen, Geometry geometry);
    public virtual void DrawImage(ImageSource imageSource, Rect rectangle);
    public virtual void DrawImage(ImageSource imageSource, Rect rectangle, AnimationClock rectangleAnimations);
    public virtual void DrawGlyphRun(Brush foregroundBrush, GlyphRun glyphRun);
    public virtual void DrawDrawing(Drawing drawing);
    public virtual void DrawVideo(MediaPlayer player, Rect rectangle);
    public virtual void DrawVideo(MediaPlayer player, Rect rectangle, AnimationClock rectangleAnimations);
    public virtual void PushClip(Geometry clipGeometry);
    public virtual void PushOpacityMask(Brush opacityMask);
    public virtual void PushOpacity(double opacity);
    public virtual void PushOpacity(double opacity, AnimationClock opacityAnimations);
    public virtual void PushTransform(Transform transform);
    public virtual void PushGuidelineSet(GuidelineSet guidelines);
    internal virtual void PushGuidelineY1(double coordinate);
    internal virtual void PushGuidelineY2(double leadingCoordinate, double offsetToDrivenCoordinate);
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
public virtual void PushEffect(BitmapEffect effect, BitmapEffectInput effectInput);
    public virtual void Pop();
    private UInt32 UseAnimations(double baseValue, AnimationClock animations);
    private UInt32 UseAnimations(Point baseValue, AnimationClock animations);
    private UInt32 UseAnimations(Size baseValue, AnimationClock animations);
    private UInt32 UseAnimations(Rect baseValue, AnimationClock animations);
}
internal static class System.Windows.Media.Renderer : object {
    public static void Render(IntPtr pRenderTarget, Channel channel, Visual visual, int width, int height, double dpiX, double dpiY);
    internal static void Render(IntPtr pRenderTarget, Channel channel, Visual visual, int width, int height, double dpiX, double dpiY, Matrix worldTransform, Rect windowClip);
}
public class System.Windows.Media.RenderingEventArgs : EventArgs {
    private TimeSpan _renderingTime;
    public TimeSpan RenderingTime { get; }
    internal RenderingEventArgs(TimeSpan renderingTime);
    public TimeSpan get_RenderingTime();
}
public static class System.Windows.Media.RenderOptions : object {
    public static DependencyProperty EdgeModeProperty;
    public static DependencyProperty BitmapScalingModeProperty;
    public static DependencyProperty ClearTypeHintProperty;
    public static DependencyProperty CachingHintProperty;
    public static DependencyProperty CacheInvalidationThresholdMinimumProperty;
    public static DependencyProperty CacheInvalidationThresholdMaximumProperty;
    public static RenderMode ProcessRenderMode { get; public set; }
    private static RenderOptions();
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static EdgeMode GetEdgeMode(DependencyObject target);
    public static void SetEdgeMode(DependencyObject target, EdgeMode edgeMode);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static BitmapScalingMode GetBitmapScalingMode(DependencyObject target);
    public static void SetBitmapScalingMode(DependencyObject target, BitmapScalingMode bitmapScalingMode);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static ClearTypeHint GetClearTypeHint(DependencyObject target);
    public static void SetClearTypeHint(DependencyObject target, ClearTypeHint clearTypeHint);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.Media.TileBrush")]
public static CachingHint GetCachingHint(DependencyObject target);
    public static void SetCachingHint(DependencyObject target, CachingHint cachingHint);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.Media.TileBrush")]
public static double GetCacheInvalidationThresholdMinimum(DependencyObject target);
    public static void SetCacheInvalidationThresholdMinimum(DependencyObject target, double cacheInvalidationThresholdMinimum);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.Media.TileBrush")]
public static double GetCacheInvalidationThresholdMaximum(DependencyObject target);
    public static void SetCacheInvalidationThresholdMaximum(DependencyObject target, double cacheInvalidationThresholdMaximum);
    public static RenderMode get_ProcessRenderMode();
    public static void set_ProcessRenderMode(RenderMode value);
}
public class System.Windows.Media.RequestCachePolicyConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext td, Type t);
    public virtual bool CanConvertTo(ITypeDescriptorContext typeDescriptorContext, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext td, CultureInfo ci, object value);
    public virtual object ConvertTo(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object value, Type destinationType);
}
public class System.Windows.Media.RotateTransform : Transform {
    public static DependencyProperty AngleProperty;
    public static DependencyProperty CenterXProperty;
    public static DependencyProperty CenterYProperty;
    internal MultiChannelResource _duceResource;
    internal static double c_Angle;
    internal static double c_CenterX;
    internal static double c_CenterY;
    public Matrix Value { get; }
    internal bool IsIdentity { get; }
    public double Angle { get; public set; }
    public double CenterX { get; public set; }
    public double CenterY { get; public set; }
    public RotateTransform(double angle);
    public RotateTransform(double angle, double centerX, double centerY);
    private static RotateTransform();
    public virtual Matrix get_Value();
    internal virtual bool get_IsIdentity();
    public RotateTransform Clone();
    public RotateTransform CloneCurrentValue();
    private static void AnglePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void CenterXPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void CenterYPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public double get_Angle();
    public void set_Angle(double value);
    public double get_CenterX();
    public void set_CenterX(double value);
    public double get_CenterY();
    public void set_CenterY(double value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
}
internal class System.Windows.Media.SafeMediaHandle : SafeMILHandle {
    internal SafeMediaHandle(IntPtr handle);
    protected virtual bool ReleaseHandle();
}
internal class System.Windows.Media.SafeMILHandle : SafeHandleZeroOrMinusOneIsInvalid {
    private SafeMILHandleMemoryPressure _gcPressure;
    internal SafeMILHandle(IntPtr handle);
    internal void UpdateEstimatedSize(long estimatedSize);
    internal void CopyMemoryPressure(SafeMILHandle original);
    protected virtual bool ReleaseHandle();
}
internal class System.Windows.Media.SafeMILHandleMemoryPressure : object {
    private long _gcPressure;
    private int _refCount;
    internal SafeMILHandleMemoryPressure(long gcPressure);
    internal void AddRef();
    internal void Release();
}
internal class System.Windows.Media.SafeProfileHandle : SafeHandleZeroOrMinusOneIsInvalid {
    internal SafeProfileHandle(IntPtr profile);
    protected virtual bool ReleaseHandle();
}
internal class System.Windows.Media.SafeReversePInvokeWrapper : SafeHandleZeroOrMinusOneIsInvalid {
    internal SafeReversePInvokeWrapper(IntPtr delegatePtr);
    protected virtual bool ReleaseHandle();
}
public class System.Windows.Media.ScaleTransform : Transform {
    public static DependencyProperty ScaleXProperty;
    public static DependencyProperty ScaleYProperty;
    public static DependencyProperty CenterXProperty;
    public static DependencyProperty CenterYProperty;
    internal MultiChannelResource _duceResource;
    internal static double c_ScaleX;
    internal static double c_ScaleY;
    internal static double c_CenterX;
    internal static double c_CenterY;
    public Matrix Value { get; }
    internal bool IsIdentity { get; }
    public double ScaleX { get; public set; }
    public double ScaleY { get; public set; }
    public double CenterX { get; public set; }
    public double CenterY { get; public set; }
    public ScaleTransform(double scaleX, double scaleY);
    public ScaleTransform(double scaleX, double scaleY, double centerX, double centerY);
    private static ScaleTransform();
    public virtual Matrix get_Value();
    internal virtual bool get_IsIdentity();
    internal virtual void TransformRect(Rect& rect);
    internal virtual void MultiplyValueByMatrix(Matrix& result, Matrix& matrixToMultiplyBy);
    public ScaleTransform Clone();
    public ScaleTransform CloneCurrentValue();
    private static void ScaleXPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void ScaleYPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void CenterXPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void CenterYPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public double get_ScaleX();
    public void set_ScaleX(double value);
    public double get_ScaleY();
    public void set_ScaleY(double value);
    public double get_CenterX();
    public void set_CenterX(double value);
    public double get_CenterY();
    public void set_CenterY(double value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
}
public class System.Windows.Media.SkewTransform : Transform {
    public static DependencyProperty AngleXProperty;
    public static DependencyProperty AngleYProperty;
    public static DependencyProperty CenterXProperty;
    public static DependencyProperty CenterYProperty;
    internal MultiChannelResource _duceResource;
    internal static double c_AngleX;
    internal static double c_AngleY;
    internal static double c_CenterX;
    internal static double c_CenterY;
    public Matrix Value { get; }
    internal bool IsIdentity { get; }
    public double AngleX { get; public set; }
    public double AngleY { get; public set; }
    public double CenterX { get; public set; }
    public double CenterY { get; public set; }
    public SkewTransform(double angleX, double angleY);
    public SkewTransform(double angleX, double angleY, double centerX, double centerY);
    private static SkewTransform();
    public virtual Matrix get_Value();
    internal virtual bool get_IsIdentity();
    public SkewTransform Clone();
    public SkewTransform CloneCurrentValue();
    private static void AngleXPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void AngleYPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void CenterXPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void CenterYPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public double get_AngleX();
    public void set_AngleX(double value);
    public double get_AngleY();
    public void set_AngleY(double value);
    public double get_CenterX();
    public void set_CenterX(double value);
    public double get_CenterY();
    public void set_CenterY(double value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
}
public class System.Windows.Media.SolidColorBrush : Brush {
    private static TwoWayDictionary`2<SolidColorBrush, string> s_knownSolidColorBrushStringCache;
    public static DependencyProperty ColorProperty;
    internal MultiChannelResource _duceResource;
    internal static Color s_Color;
    public Color Color { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    public SolidColorBrush(Color color);
    private static SolidColorBrush();
    [FriendAccessAllowedAttribute]
internal static bool SerializeOn(BinaryWriter writer, string stringValue);
    public static object DeserializeFrom(BinaryReader reader);
    internal static object DeserializeFrom(BinaryReader reader, ITypeDescriptorContext context);
    internal virtual bool CanSerializeToString();
    internal virtual string ConvertToString(string format, IFormatProvider provider);
    public SolidColorBrush Clone();
    public SolidColorBrush CloneCurrentValue();
    private static void ColorPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Color get_Color();
    public void set_Color(Color value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    internal virtual int get_EffectiveValuesInitialSize();
}
internal static class System.Windows.Media.StaticPtrs : object {
    internal static Dispose pfnDispose;
    internal static Read pfnRead;
    internal static Seek pfnSeek;
    internal static Stat pfnStat;
    internal static Write pfnWrite;
    internal static CopyTo pfnCopyTo;
    internal static SetSize pfnSetSize;
    internal static Commit pfnCommit;
    internal static Revert pfnRevert;
    internal static LockRegion pfnLockRegion;
    internal static UnlockRegion pfnUnlockRegion;
    internal static Clone pfnClone;
    internal static CanWrite pfnCanWrite;
    internal static CanSeek pfnCanSeek;
    private static StaticPtrs();
}
internal class System.Windows.Media.StreamAsIStream : object {
    private static int STREAM_SEEK_SET;
    private static int STREAM_SEEK_CUR;
    private static int STREAM_SEEK_END;
    protected Stream dataStream;
    private Exception _lastException;
    private long virtualPosition;
    private StreamAsIStream(Stream dataStream);
    private void ActualizeVirtualPosition();
    public int Clone(IntPtr& stream);
    public int Commit(UInt32 grfCommitFlags);
    public int CopyTo(IntPtr pstm, long cb, Int64& cbRead, Int64& cbWritten);
    public int LockRegion(long libOffset, long cb, UInt32 dwLockType);
    public int Read(Byte[] buffer, UInt32 cb, UInt32& cbRead);
    public int Revert();
    public int Seek(long offset, UInt32 origin, Int64* plibNewPostion);
    public int SetSize(long value);
    public int Stat(STATSTG& statstg, UInt32 grfStatFlag);
    public int UnlockRegion(long libOffset, long cb, UInt32 dwLockType);
    public int Write(Byte[] buffer, UInt32 cb, UInt32& cbWritten);
    public int CanWrite(Boolean& canWrite);
    public int CanSeek(Boolean& canSeek);
    private void Verify();
    internal static StreamAsIStream FromSD(StreamDescriptor& sd);
    internal static int Clone(StreamDescriptor& pSD, IntPtr& stream);
    internal static int Commit(StreamDescriptor& pSD, UInt32 grfCommitFlags);
    internal static int CopyTo(StreamDescriptor& pSD, IntPtr pstm, long cb, Int64& cbRead, Int64& cbWritten);
    internal static int LockRegion(StreamDescriptor& pSD, long libOffset, long cb, UInt32 dwLockType);
    internal static int Read(StreamDescriptor& pSD, Byte[] buffer, UInt32 cb, UInt32& cbRead);
    internal static int Revert(StreamDescriptor& pSD);
    internal static int Seek(StreamDescriptor& pSD, long offset, UInt32 origin, Int64* plibNewPostion);
    internal static int SetSize(StreamDescriptor& pSD, long value);
    internal static int Stat(StreamDescriptor& pSD, STATSTG& statstg, UInt32 grfStatFlag);
    internal static int UnlockRegion(StreamDescriptor& pSD, long libOffset, long cb, UInt32 dwLockType);
    internal static int Write(StreamDescriptor& pSD, Byte[] buffer, UInt32 cb, UInt32& cbWritten);
    internal static int CanWrite(StreamDescriptor& pSD, Boolean& canWrite);
    internal static int CanSeek(StreamDescriptor& pSD, Boolean& canSeek);
    internal static IntPtr IStreamMemoryFrom(IntPtr comStream);
    internal static IntPtr IStreamFrom(IntPtr memoryBuffer, int bufferSize);
    internal static IntPtr IStreamFrom(Stream stream);
    private static int MILIStreamWrite(IntPtr pStream, Byte[] buffer, UInt32 cb, UInt32& cbWritten);
}
internal class System.Windows.Media.StreamDescriptor : ValueType {
    internal Dispose pfnDispose;
    internal Read pfnRead;
    internal Seek pfnSeek;
    internal Stat pfnStat;
    internal Write pfnWrite;
    internal CopyTo pfnCopyTo;
    internal SetSize pfnSetSize;
    internal Commit pfnCommit;
    internal Revert pfnRevert;
    internal LockRegion pfnLockRegion;
    internal UnlockRegion pfnUnlockRegion;
    internal Clone pfnClone;
    internal CanWrite pfnCanWrite;
    internal CanSeek pfnCanSeek;
    internal GCHandle m_handle;
    internal static void StaticDispose(StreamDescriptor& pSD);
}
[TypeConverterAttribute("System.Windows.Media.GeometryConverter")]
public class System.Windows.Media.StreamGeometry : Geometry {
    private Byte[] _data;
    internal MultiChannelResource _duceResource;
    public static DependencyProperty FillRuleProperty;
    internal static FillRule c_FillRule;
    public Rect Bounds { get; }
    public FillRule FillRule { get; public set; }
    private static StreamGeometry();
    public StreamGeometryContext Open();
    public void Clear();
    public virtual bool IsEmpty();
    private bool AreBoundsValid(MilRectD& bounds);
    private void CacheBounds(MilRectD& bounds);
    internal void SetDirty();
    public virtual Rect get_Bounds();
    public virtual bool MayHaveCurves();
    internal bool HasHollows();
    internal bool HasGaps();
    internal void Close(Byte[] _buffer);
    protected virtual void OnChanged();
    internal virtual PathGeometry GetAsPathGeometry();
    internal virtual PathFigureCollection GetTransformedFigureCollection(Transform transform);
    internal virtual bool CanSerializeToString();
    internal virtual string ConvertToString(string format, IFormatProvider provider);
    private void InvalidateResourceFigures(object sender, EventArgs args);
    internal virtual PathGeometryData GetPathGeometryData();
    internal virtual void TransformPropertyChangedHook(DependencyPropertyChangedEventArgs e);
    private int GetFigureSize(Byte* pbPathData);
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    public StreamGeometry Clone();
    public StreamGeometry CloneCurrentValue();
    private static void FillRulePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public FillRule get_FillRule();
    public void set_FillRule(FillRule value);
    protected virtual Freezable CreateInstanceCore();
}
internal class System.Windows.Media.StreamGeometryCallbackContext : ByteStreamGeometryContext {
    private StreamGeometry _owner;
    internal StreamGeometryCallbackContext(StreamGeometry owner);
    protected virtual void CloseCore(Byte[] data);
}
public abstract class System.Windows.Media.StreamGeometryContext : DispatcherObject {
    private sealed virtual override void System.IDisposable.Dispose();
    public virtual void Close();
    public abstract virtual void BeginFigure(Point startPoint, bool isFilled, bool isClosed);
    public abstract virtual void LineTo(Point point, bool isStroked, bool isSmoothJoin);
    public abstract virtual void QuadraticBezierTo(Point point1, Point point2, bool isStroked, bool isSmoothJoin);
    public abstract virtual void BezierTo(Point point1, Point point2, Point point3, bool isStroked, bool isSmoothJoin);
    public abstract virtual void PolyLineTo(IList`1<Point> points, bool isStroked, bool isSmoothJoin);
    public abstract virtual void PolyQuadraticBezierTo(IList`1<Point> points, bool isStroked, bool isSmoothJoin);
    public abstract virtual void PolyBezierTo(IList`1<Point> points, bool isStroked, bool isSmoothJoin);
    public abstract virtual void ArcTo(Point point, Size size, double rotationAngle, bool isLargeArc, SweepDirection sweepDirection, bool isStroked, bool isSmoothJoin);
    internal virtual void DisposeCore();
    internal abstract virtual void SetClosedState(bool closed);
}
public enum System.Windows.Media.Stretch : Enum {
    public int value__;
    public static Stretch None;
    public static Stretch Fill;
    public static Stretch Uniform;
    public static Stretch UniformToFill;
}
[FlagsAttribute]
public enum System.Windows.Media.StyleSimulations : Enum {
    public int value__;
    public static StyleSimulations None;
    public static StyleSimulations BoldSimulation;
    public static StyleSimulations ItalicSimulation;
    public static StyleSimulations BoldItalicSimulation;
}
public enum System.Windows.Media.SweepDirection : Enum {
    public int value__;
    public static SweepDirection Counterclockwise;
    public static SweepDirection Clockwise;
}
[LocalizabilityAttribute("0")]
public class System.Windows.Media.TextEffect : Animatable {
    public static DependencyProperty TransformProperty;
    public static DependencyProperty ClipProperty;
    public static DependencyProperty ForegroundProperty;
    public static DependencyProperty PositionStartProperty;
    public static DependencyProperty PositionCountProperty;
    internal static int c_PositionStart;
    internal static int c_PositionCount;
    public Transform Transform { get; public set; }
    public Geometry Clip { get; public set; }
    public Brush Foreground { get; public set; }
    public int PositionStart { get; public set; }
    public int PositionCount { get; public set; }
    public TextEffect(Transform transform, Brush foreground, Geometry clip, int positionStart, int positionCount);
    private static TextEffect();
    private static bool OnPositionStartChanging(int value);
    private static bool OnPositionCountChanging(int value);
    public TextEffect Clone();
    public TextEffect CloneCurrentValue();
    private static bool ValidatePositionStartValue(object value);
    private static bool ValidatePositionCountValue(object value);
    public Transform get_Transform();
    public void set_Transform(Transform value);
    public Geometry get_Clip();
    public void set_Clip(Geometry value);
    public Brush get_Foreground();
    public void set_Foreground(Brush value);
    public int get_PositionStart();
    public void set_PositionStart(int value);
    public int get_PositionCount();
    public void set_PositionCount(int value);
    protected virtual Freezable CreateInstanceCore();
}
[LocalizabilityAttribute("0")]
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.TextEffectCollection : Animatable {
    private static TextEffectCollection s_empty;
    internal FrugalStructList`1<TextEffect> _collection;
    internal UInt32 _version;
    public TextEffect Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.TextEffect>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal static TextEffectCollection Empty { get; }
    public TextEffectCollection(int capacity);
    public TextEffectCollection(IEnumerable`1<TextEffect> collection);
    public TextEffectCollection Clone();
    public TextEffectCollection CloneCurrentValue();
    public sealed virtual void Add(TextEffect value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(TextEffect value);
    public sealed virtual int IndexOf(TextEffect value);
    public sealed virtual void Insert(int index, TextEffect value);
    public sealed virtual bool Remove(TextEffect value);
    public sealed virtual void RemoveAt(int index);
    internal void RemoveAtWithoutFiringPublicEvents(int index);
    public sealed virtual TextEffect get_Item(int index);
    public sealed virtual void set_Item(int index, TextEffect value);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(TextEffect[] array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.TextEffect>.get_IsReadOnly();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<TextEffect> System.Collections.Generic.IEnumerable<System.Windows.Media.TextEffect>.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal static TextEffectCollection get_Empty();
    internal TextEffect Internal_GetItem(int i);
    internal virtual void OnInheritanceContextChangedCore(EventArgs args);
    private TextEffect Cast(object value);
    private int AddHelper(TextEffect value);
    internal int AddWithoutFiringPublicEvents(TextEffect value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected virtual bool FreezeCore(bool isChecking);
}
internal enum System.Windows.Media.TextFormatting.BreakStrategies : Enum {
    public int value__;
    public static BreakStrategies BreakCJK;
    public static BreakStrategies KeepCJK;
    public static BreakStrategies Max;
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.TextFormatting.CharacterBufferRange : ValueType {
    private CharacterBufferReference _charBufferRef;
    private int _length;
    public CharacterBufferReference CharacterBufferReference { get; }
    public int Length { get; }
    public static CharacterBufferRange Empty { get; }
    internal bool IsEmpty { get; }
    internal CharacterBuffer CharacterBuffer { get; }
    internal int OffsetToFirstChar { get; }
    internal char Item { get; }
    public CharacterBufferRange(Char[] characterArray, int offsetToFirstChar, int characterLength);
    public CharacterBufferRange(string characterString, int offsetToFirstChar, int characterLength);
    [CLSCompliantAttribute("False")]
public CharacterBufferRange(Char* unsafeCharacterString, int characterLength);
    internal CharacterBufferRange(CharacterBufferReference characterBufferReference, int characterLength);
    internal CharacterBufferRange(CharacterBufferRange characterBufferRange, int offsetToFirstChar, int characterLength);
    internal CharacterBufferRange(string charString);
    internal CharacterBufferRange(CharacterBuffer charBuffer, int offsetToFirstChar, int characterLength);
    internal CharacterBufferRange(TextRun textRun);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CharacterBufferRange value);
    public static bool op_Equality(CharacterBufferRange left, CharacterBufferRange right);
    public static bool op_Inequality(CharacterBufferRange left, CharacterBufferRange right);
    public CharacterBufferReference get_CharacterBufferReference();
    public int get_Length();
    public static CharacterBufferRange get_Empty();
    internal bool get_IsEmpty();
    internal CharacterBuffer get_CharacterBuffer();
    internal int get_OffsetToFirstChar();
    internal char get_Item(int index);
}
public class System.Windows.Media.TextFormatting.CharacterBufferReference : ValueType {
    private CharacterBuffer _charBuffer;
    private int _offsetToFirstChar;
    internal CharacterBuffer CharacterBuffer { get; }
    internal int OffsetToFirstChar { get; }
    public CharacterBufferReference(Char[] characterArray, int offsetToFirstChar);
    public CharacterBufferReference(string characterString, int offsetToFirstChar);
    [CLSCompliantAttribute("False")]
public CharacterBufferReference(Char* unsafeCharacterString, int characterLength);
    internal CharacterBufferReference(CharacterBuffer charBuffer, int offsetToFirstChar);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CharacterBufferReference value);
    public static bool op_Equality(CharacterBufferReference left, CharacterBufferReference right);
    public static bool op_Inequality(CharacterBufferReference left, CharacterBufferReference right);
    internal CharacterBuffer get_CharacterBuffer();
    internal int get_OffsetToFirstChar();
}
public class System.Windows.Media.TextFormatting.CharacterHit : ValueType {
    private int _firstCharacterIndex;
    private int _trailingLength;
    public int FirstCharacterIndex { get; }
    public int TrailingLength { get; }
    public CharacterHit(int firstCharacterIndex, int trailingLength);
    public int get_FirstCharacterIndex();
    public int get_TrailingLength();
    public static bool op_Equality(CharacterHit left, CharacterHit right);
    public static bool op_Inequality(CharacterHit left, CharacterHit right);
    public sealed virtual bool Equals(CharacterHit obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class System.Windows.Media.TextFormatting.CultureSpecificCharacterBufferRange : object {
    private CultureInfo _culture;
    private CharacterBufferRange _characterBufferRange;
    public CultureInfo CultureInfo { get; }
    public CharacterBufferRange CharacterBufferRange { get; }
    public CultureSpecificCharacterBufferRange(CultureInfo culture, CharacterBufferRange characterBufferRange);
    public CultureInfo get_CultureInfo();
    public CharacterBufferRange get_CharacterBufferRange();
}
public class System.Windows.Media.TextFormatting.IndexedGlyphRun : object {
    private GlyphRun _glyphRun;
    private int _textSourceCharacterIndex;
    private int _length;
    public int TextSourceCharacterIndex { get; }
    public int TextSourceLength { get; }
    public GlyphRun GlyphRun { get; }
    internal IndexedGlyphRun(int textSourceCharacterIndex, int textSourceCharacterLength, GlyphRun glyphRun);
    public int get_TextSourceCharacterIndex();
    public int get_TextSourceLength();
    public GlyphRun get_GlyphRun();
}
[FlagsAttribute]
public enum System.Windows.Media.TextFormatting.InvertAxes : Enum {
    public int value__;
    public static InvertAxes None;
    public static InvertAxes Horizontal;
    public static InvertAxes Vertical;
    public static InvertAxes Both;
}
public class System.Windows.Media.TextFormatting.MinMaxParagraphWidth : ValueType {
    private double _minWidth;
    private double _maxWidth;
    public double MinWidth { get; }
    public double MaxWidth { get; }
    internal MinMaxParagraphWidth(double minWidth, double maxWidth);
    public double get_MinWidth();
    public double get_MaxWidth();
    public virtual int GetHashCode();
    public sealed virtual bool Equals(MinMaxParagraphWidth value);
    public virtual bool Equals(object obj);
    public static bool op_Equality(MinMaxParagraphWidth left, MinMaxParagraphWidth right);
    public static bool op_Inequality(MinMaxParagraphWidth left, MinMaxParagraphWidth right);
}
public class System.Windows.Media.TextFormatting.TextBounds : object {
    private FlowDirection _flowDirection;
    private Rect _bounds;
    private IList`1<TextRunBounds> _runBounds;
    public Rect Rectangle { get; }
    public IList`1<TextRunBounds> TextRunBounds { get; }
    public FlowDirection FlowDirection { get; }
    internal TextBounds(Rect bounds, FlowDirection flowDirection, IList`1<TextRunBounds> runBounds);
    public Rect get_Rectangle();
    public IList`1<TextRunBounds> get_TextRunBounds();
    public FlowDirection get_FlowDirection();
}
[FriendAccessAllowedAttribute]
internal abstract class System.Windows.Media.TextFormatting.TextBreakpoint : object {
    public bool IsTruncated { get; }
    public int Length { get; }
    public int DependentLength { get; }
    public int NewlineLength { get; }
    public double Start { get; }
    public double Width { get; }
    public double WidthIncludingTrailingWhitespace { get; }
    public double Height { get; }
    public double TextHeight { get; }
    public double Baseline { get; }
    public double TextBaseline { get; }
    public double MarkerBaseline { get; }
    public double MarkerHeight { get; }
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public abstract virtual TextLineBreak GetTextLineBreak();
    internal abstract virtual SecurityCriticalDataForSet`1<IntPtr> GetTextPenaltyResource();
    public abstract virtual bool get_IsTruncated();
    public abstract virtual int get_Length();
    public abstract virtual int get_DependentLength();
    public abstract virtual int get_NewlineLength();
    public abstract virtual double get_Start();
    public abstract virtual double get_Width();
    public abstract virtual double get_WidthIncludingTrailingWhitespace();
    public abstract virtual double get_Height();
    public abstract virtual double get_TextHeight();
    public abstract virtual double get_Baseline();
    public abstract virtual double get_TextBaseline();
    public abstract virtual double get_MarkerBaseline();
    public abstract virtual double get_MarkerHeight();
}
public class System.Windows.Media.TextFormatting.TextCharacters : TextRun {
    private CharacterBufferReference _characterBufferReference;
    private int _length;
    private TextRunProperties _textRunProperties;
    public CharacterBufferReference CharacterBufferReference { get; }
    public int Length { get; }
    public TextRunProperties Properties { get; }
    public TextCharacters(Char[] characterArray, int offsetToFirstChar, int length, TextRunProperties textRunProperties);
    public TextCharacters(string characterString, TextRunProperties textRunProperties);
    public TextCharacters(string characterString, int offsetToFirstChar, int length, TextRunProperties textRunProperties);
    [CLSCompliantAttribute("False")]
public TextCharacters(Char* unsafeCharacterString, int length, TextRunProperties textRunProperties);
    private TextCharacters(CharacterBufferReference characterBufferReference, int length, TextRunProperties textRunProperties);
    public sealed virtual CharacterBufferReference get_CharacterBufferReference();
    public sealed virtual int get_Length();
    public sealed virtual TextRunProperties get_Properties();
    private sealed virtual override IList`1<TextShapeableSymbols> MS.Internal.TextFormatting.ITextSymbols.GetTextShapeableSymbols(GlyphingCache glyphingCache, CharacterBufferReference characterBufferReference, int length, bool rightToLeft, bool isRightToLeftParagraph, CultureInfo digitCulture, TextModifierScope textModifierScope, TextFormattingMode textFormattingMode, bool isSideways);
    private sealed virtual override void MS.Internal.TextFormatting.IShapeableTextCollector.Add(IList`1<TextShapeableSymbols> shapeables, CharacterBufferRange characterBufferRange, TextRunProperties textRunProperties, ItemProps textItem, ShapeTypeface shapeTypeface, double emScale, bool nullShape, TextFormattingMode textFormattingMode);
}
public class System.Windows.Media.TextFormatting.TextCollapsedRange : object {
    private int _cp;
    private int _length;
    private double _width;
    public int TextSourceCharacterIndex { get; }
    public int Length { get; }
    public double Width { get; }
    internal TextCollapsedRange(int cp, int length, double width);
    public int get_TextSourceCharacterIndex();
    public int get_Length();
    public double get_Width();
}
public abstract class System.Windows.Media.TextFormatting.TextCollapsingProperties : object {
    public double Width { get; }
    public TextRun Symbol { get; }
    public TextCollapsingStyle Style { get; }
    public abstract virtual double get_Width();
    public abstract virtual TextRun get_Symbol();
    public abstract virtual TextCollapsingStyle get_Style();
}
public enum System.Windows.Media.TextFormatting.TextCollapsingStyle : Enum {
    public int value__;
    public static TextCollapsingStyle TrailingCharacter;
    public static TextCollapsingStyle TrailingWord;
}
public abstract class System.Windows.Media.TextFormatting.TextEmbeddedObject : TextRun {
    public LineBreakCondition BreakBefore { get; }
    public LineBreakCondition BreakAfter { get; }
    public bool HasFixedSize { get; }
    public abstract virtual LineBreakCondition get_BreakBefore();
    public abstract virtual LineBreakCondition get_BreakAfter();
    public abstract virtual bool get_HasFixedSize();
    public abstract virtual TextEmbeddedObjectMetrics Format(double remainingParagraphWidth);
    public abstract virtual Rect ComputeBoundingBox(bool rightToLeft, bool sideways);
    public abstract virtual void Draw(DrawingContext drawingContext, Point origin, bool rightToLeft, bool sideways);
}
public class System.Windows.Media.TextFormatting.TextEmbeddedObjectMetrics : object {
    private double _width;
    private double _height;
    private double _baseline;
    public double Width { get; }
    public double Height { get; }
    public double Baseline { get; }
    public TextEmbeddedObjectMetrics(double width, double height, double baseline);
    public double get_Width();
    public double get_Height();
    public double get_Baseline();
}
public class System.Windows.Media.TextFormatting.TextEndOfLine : TextRun {
    private int _length;
    private TextRunProperties _textRunProperties;
    public CharacterBufferReference CharacterBufferReference { get; }
    public int Length { get; }
    public TextRunProperties Properties { get; }
    public TextEndOfLine(int length);
    public TextEndOfLine(int length, TextRunProperties textRunProperties);
    public sealed virtual CharacterBufferReference get_CharacterBufferReference();
    public sealed virtual int get_Length();
    public sealed virtual TextRunProperties get_Properties();
}
public class System.Windows.Media.TextFormatting.TextEndOfParagraph : TextEndOfLine {
    public TextEndOfParagraph(int length);
    public TextEndOfParagraph(int length, TextRunProperties textRunProperties);
}
public class System.Windows.Media.TextFormatting.TextEndOfSegment : TextRun {
    private int _length;
    public CharacterBufferReference CharacterBufferReference { get; }
    public int Length { get; }
    public TextRunProperties Properties { get; }
    public TextEndOfSegment(int length);
    public sealed virtual CharacterBufferReference get_CharacterBufferReference();
    public sealed virtual int get_Length();
    public sealed virtual TextRunProperties get_Properties();
}
public abstract class System.Windows.Media.TextFormatting.TextFormatter : object {
    private static object _staticLock;
    private static TextFormatter();
    public static TextFormatter Create(TextFormattingMode textFormattingMode);
    public static TextFormatter Create();
    [FriendAccessAllowedAttribute]
internal static TextFormatter CreateFromContext(TextFormatterContext soleContext);
    [FriendAccessAllowedAttribute]
internal static TextFormatter CreateFromContext(TextFormatterContext soleContext, TextFormattingMode textFormattingMode);
    [FriendAccessAllowedAttribute]
internal static TextFormatter FromCurrentDispatcher();
    [FriendAccessAllowedAttribute]
internal static TextFormatter FromCurrentDispatcher(TextFormattingMode textFormattingMode);
    public virtual void Dispose();
    public abstract virtual TextLine FormatLine(TextSource textSource, int firstCharIndex, double paragraphWidth, TextParagraphProperties paragraphProperties, TextLineBreak previousLineBreak);
    public abstract virtual TextLine FormatLine(TextSource textSource, int firstCharIndex, double paragraphWidth, TextParagraphProperties paragraphProperties, TextLineBreak previousLineBreak, TextRunCache textRunCache);
    [FriendAccessAllowedAttribute]
internal abstract virtual TextLine RecreateLine(TextSource textSource, int firstCharIndex, int lineLength, double paragraphWidth, TextParagraphProperties paragraphProperties, TextLineBreak previousLineBreak, TextRunCache textRunCache);
    [FriendAccessAllowedAttribute]
internal abstract virtual TextParagraphCache CreateParagraphCache(TextSource textSource, int firstCharIndex, double paragraphWidth, TextParagraphProperties paragraphProperties, TextLineBreak previousLineBreak, TextRunCache textRunCache);
    public abstract virtual MinMaxParagraphWidth FormatMinMaxParagraphWidth(TextSource textSource, int firstCharIndex, TextParagraphProperties paragraphProperties);
    public abstract virtual MinMaxParagraphWidth FormatMinMaxParagraphWidth(TextSource textSource, int firstCharIndex, TextParagraphProperties paragraphProperties, TextRunCache textRunCache);
}
[FriendAccessAllowedAttribute]
internal class System.Windows.Media.TextFormatting.TextFormatterContext : object {
    private SecurityCriticalDataForSet`1<IntPtr> _ploc;
    private LineServicesCallbacks _callbacks;
    private State _state;
    private BreakStrategies _breaking;
    private static Dictionary`2<char, bool> _specialCharacters;
    private static UInt32 TwipsPerInch;
    internal object Owner { get; internal set; }
    internal Exception CallbackException { get; internal set; }
    internal Rect BoundingBox { get; }
    internal ICollection`1<IndexedGlyphRun> IndexedGlyphRuns { get; }
    internal SecurityCriticalDataForSet`1<IntPtr> Ploc { get; }
    private void Init();
    internal TextPenaltyModule GetTextPenaltyModule();
    internal void Release();
    internal object get_Owner();
    internal void set_Owner(object value);
    internal Exception get_CallbackException();
    internal void set_CallbackException(Exception value);
    internal void EmptyBoundingBox();
    internal Rect get_BoundingBox();
    internal void ClearIndexedGlyphRuns();
    internal ICollection`1<IndexedGlyphRun> get_IndexedGlyphRuns();
    internal void Destroy();
    internal void SetBreaking(BreakStrategies breaking);
    internal LsErr CreateLine(int cpFirst, int lineLength, int maxWidth, LineFlags lineFlags, IntPtr previousLineBreakRecord, IntPtr& ploline, LsLInfo& plslineInfo, Int32& maxDepth, LsLineWidths& lineWidths);
    internal LsErr CreateBreaks(int cpFirst, IntPtr previousLineBreakRecord, IntPtr ploparabreak, IntPtr ptslinevariantRestriction, LsBreaks& lsbreaks, Int32& bestFitIndex);
    internal LsErr CreateParaBreakingSession(int cpFirst, int maxWidth, IntPtr previousLineBreakRecord, IntPtr& ploparabreak, Boolean& penalizedAsJustified);
    internal void SetDoc(bool isDisplay, bool isReferencePresentationEqual, LsDevRes& deviceInfo);
    internal void SetTabs(int incrementalTab, LsTbd* tabStops, int tabStopCount);
    internal static void ThrowExceptionFromLsError(string message, LsErr lserr);
    internal static bool IsSpecialCharacter(char c);
    private static void SetSpecialCharacters(LsContextInfo& contextInfo);
    internal SecurityCriticalDataForSet`1<IntPtr> get_Ploc();
}
public class System.Windows.Media.TextFormatting.TextHidden : TextRun {
    private int _length;
    public CharacterBufferReference CharacterBufferReference { get; }
    public int Length { get; }
    public TextRunProperties Properties { get; }
    public TextHidden(int length);
    public sealed virtual CharacterBufferReference get_CharacterBufferReference();
    public sealed virtual int get_Length();
    public sealed virtual TextRunProperties get_Properties();
}
[FriendAccessAllowedAttribute]
internal abstract class System.Windows.Media.TextFormatting.TextLexicalBreaks : object {
    public int Length { get; }
    public abstract virtual int get_Length();
    public abstract virtual int GetNextBreak(int currentIndex);
    public abstract virtual int GetPreviousBreak(int currentIndex);
}
[FriendAccessAllowedAttribute]
internal abstract class System.Windows.Media.TextFormatting.TextLexicalService : object {
    public abstract virtual bool IsCultureSupported(CultureInfo culture);
    public abstract virtual TextLexicalBreaks AnalyzeText(Char[] characterSource, int length, CultureInfo textCulture);
}
public abstract class System.Windows.Media.TextFormatting.TextLine : object {
    private double _pixelsPerDip;
    public double PixelsPerDip { get; public set; }
    public bool HasOverflowed { get; }
    public bool HasCollapsed { get; }
    public bool IsTruncated { get; }
    public int Length { get; }
    public int TrailingWhitespaceLength { get; }
    public int DependentLength { get; }
    public int NewlineLength { get; }
    public double Start { get; }
    public double Width { get; }
    public double WidthIncludingTrailingWhitespace { get; }
    public double Height { get; }
    public double TextHeight { get; }
    public double Extent { get; }
    public double Baseline { get; }
    public double TextBaseline { get; }
    public double MarkerBaseline { get; }
    public double MarkerHeight { get; }
    public double OverhangLeading { get; }
    public double OverhangTrailing { get; }
    public double OverhangAfter { get; }
    protected TextLine(double pixelsPerDip);
    public abstract virtual void Dispose();
    public abstract virtual void Draw(DrawingContext drawingContext, Point origin, InvertAxes inversion);
    public abstract virtual TextLine Collapse(TextCollapsingProperties[] collapsingPropertiesList);
    public abstract virtual IList`1<TextCollapsedRange> GetTextCollapsedRanges();
    public abstract virtual CharacterHit GetCharacterHitFromDistance(double distance);
    public abstract virtual double GetDistanceFromCharacterHit(CharacterHit characterHit);
    public abstract virtual CharacterHit GetNextCaretCharacterHit(CharacterHit characterHit);
    public abstract virtual CharacterHit GetPreviousCaretCharacterHit(CharacterHit characterHit);
    public abstract virtual CharacterHit GetBackspaceCaretCharacterHit(CharacterHit characterHit);
    public double get_PixelsPerDip();
    public void set_PixelsPerDip(double value);
    [FriendAccessAllowedAttribute]
internal bool IsAtCaretCharacterHit(CharacterHit characterHit, int cpFirst);
    public abstract virtual IList`1<TextBounds> GetTextBounds(int firstTextSourceCharacterIndex, int textLength);
    public abstract virtual IList`1<TextSpan`1<TextRun>> GetTextRunSpans();
    public abstract virtual IEnumerable`1<IndexedGlyphRun> GetIndexedGlyphRuns();
    public abstract virtual bool get_HasOverflowed();
    public abstract virtual bool get_HasCollapsed();
    public virtual bool get_IsTruncated();
    public abstract virtual TextLineBreak GetTextLineBreak();
    public abstract virtual int get_Length();
    public abstract virtual int get_TrailingWhitespaceLength();
    public abstract virtual int get_DependentLength();
    public abstract virtual int get_NewlineLength();
    public abstract virtual double get_Start();
    public abstract virtual double get_Width();
    public abstract virtual double get_WidthIncludingTrailingWhitespace();
    public abstract virtual double get_Height();
    public abstract virtual double get_TextHeight();
    public abstract virtual double get_Extent();
    public abstract virtual double get_Baseline();
    public abstract virtual double get_TextBaseline();
    public abstract virtual double get_MarkerBaseline();
    public abstract virtual double get_MarkerHeight();
    public abstract virtual double get_OverhangLeading();
    public abstract virtual double get_OverhangTrailing();
    public abstract virtual double get_OverhangAfter();
}
public class System.Windows.Media.TextFormatting.TextLineBreak : object {
    private TextModifierScope _currentScope;
    private SecurityCriticalDataForSet`1<IntPtr> _breakRecord;
    internal TextModifierScope TextModifierScope { get; }
    internal SecurityCriticalDataForSet`1<IntPtr> BreakRecord { get; }
    internal TextLineBreak(TextModifierScope currentScope, SecurityCriticalDataForSet`1<IntPtr> breakRecord);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    public TextLineBreak Clone();
    private void DisposeInternal(bool finalizing);
    internal TextModifierScope get_TextModifierScope();
    internal SecurityCriticalDataForSet`1<IntPtr> get_BreakRecord();
}
public abstract class System.Windows.Media.TextFormatting.TextMarkerProperties : object {
    public double Offset { get; }
    public TextSource TextSource { get; }
    public abstract virtual double get_Offset();
    public abstract virtual TextSource get_TextSource();
}
public abstract class System.Windows.Media.TextFormatting.TextModifier : TextRun {
    public CharacterBufferReference CharacterBufferReference { get; }
    public bool HasDirectionalEmbedding { get; }
    public FlowDirection FlowDirection { get; }
    public sealed virtual CharacterBufferReference get_CharacterBufferReference();
    public abstract virtual TextRunProperties ModifyProperties(TextRunProperties properties);
    public abstract virtual bool get_HasDirectionalEmbedding();
    public abstract virtual FlowDirection get_FlowDirection();
}
internal class System.Windows.Media.TextFormatting.TextModifierScope : object {
    private TextModifierScope _parentScope;
    private TextModifier _modifier;
    private int _cp;
    public TextModifierScope ParentScope { get; }
    public TextModifier TextModifier { get; }
    public int TextSourceCharacterIndex { get; }
    internal TextModifierScope(TextModifierScope parentScope, TextModifier modifier, int cp);
    public TextModifierScope get_ParentScope();
    public TextModifier get_TextModifier();
    public int get_TextSourceCharacterIndex();
    internal TextRunProperties ModifyProperties(TextRunProperties properties);
    internal TextModifierScope CloneStack();
}
[FriendAccessAllowedAttribute]
internal class System.Windows.Media.TextFormatting.TextParagraphCache : object {
    private FullTextState _fullText;
    private SecurityCriticalDataForSet`1<IntPtr> _ploparabreak;
    private int _finiteFormatWidth;
    private bool _penalizedAsJustified;
    internal FullTextState FullText { get; }
    internal SecurityCriticalDataForSet`1<IntPtr> Ploparabreak { get; }
    internal TextParagraphCache(FormatSettings settings, int firstCharIndex, int paragraphWidth);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    internal IList`1<TextBreakpoint> FormatBreakpoints(int firstCharIndex, TextLineBreak previousLineBreak, IntPtr breakpointRestrictionHandle, double maxLineWidth, Int32& bestFitIndex);
    private void Dispose(bool disposing);
    private int VerifyMaxLineWidth(double maxLineWidth);
    internal FullTextState get_FullText();
    internal SecurityCriticalDataForSet`1<IntPtr> get_Ploparabreak();
}
public abstract class System.Windows.Media.TextFormatting.TextParagraphProperties : object {
    private TextLexicalService _hyphenator;
    public FlowDirection FlowDirection { get; }
    public TextAlignment TextAlignment { get; }
    public double LineHeight { get; }
    public bool FirstLineInParagraph { get; }
    public bool AlwaysCollapsible { get; }
    public TextRunProperties DefaultTextRunProperties { get; }
    public TextDecorationCollection TextDecorations { get; }
    public TextWrapping TextWrapping { get; }
    public TextMarkerProperties TextMarkerProperties { get; }
    public double Indent { get; }
    public double ParagraphIndent { get; }
    public double DefaultIncrementalTab { get; }
    public IList`1<TextTabProperties> Tabs { get; }
    internal TextLexicalService Hyphenator { get; internal set; }
    public abstract virtual FlowDirection get_FlowDirection();
    public abstract virtual TextAlignment get_TextAlignment();
    public abstract virtual double get_LineHeight();
    public abstract virtual bool get_FirstLineInParagraph();
    public virtual bool get_AlwaysCollapsible();
    public abstract virtual TextRunProperties get_DefaultTextRunProperties();
    public virtual TextDecorationCollection get_TextDecorations();
    public abstract virtual TextWrapping get_TextWrapping();
    public abstract virtual TextMarkerProperties get_TextMarkerProperties();
    public abstract virtual double get_Indent();
    public virtual double get_ParagraphIndent();
    public virtual double get_DefaultIncrementalTab();
    public virtual IList`1<TextTabProperties> get_Tabs();
    [FriendAccessAllowedAttribute]
internal virtual TextLexicalService get_Hyphenator();
    [FriendAccessAllowedAttribute]
internal virtual void set_Hyphenator(TextLexicalService value);
}
public abstract class System.Windows.Media.TextFormatting.TextRun : object {
    public CharacterBufferReference CharacterBufferReference { get; }
    public int Length { get; }
    public TextRunProperties Properties { get; }
    public abstract virtual CharacterBufferReference get_CharacterBufferReference();
    public abstract virtual int get_Length();
    public abstract virtual TextRunProperties get_Properties();
}
public class System.Windows.Media.TextFormatting.TextRunBounds : object {
    private int _cpFirst;
    private int _cch;
    private Rect _bounds;
    private TextRun _textRun;
    public int TextSourceCharacterIndex { get; }
    public int Length { get; }
    public Rect Rectangle { get; }
    public TextRun TextRun { get; }
    internal TextRunBounds(Rect bounds, int cpFirst, int cpEnd, TextRun textRun);
    public int get_TextSourceCharacterIndex();
    public int get_Length();
    public Rect get_Rectangle();
    public TextRun get_TextRun();
}
public class System.Windows.Media.TextFormatting.TextRunCache : object {
    private TextRunCacheImp _imp;
    internal TextRunCacheImp Imp { get; internal set; }
    public void Change(int textSourceCharacterIndex, int addition, int removal);
    public void Invalidate();
    [FriendAccessAllowedAttribute]
internal IList`1<TextSpan`1<TextRun>> GetTextRunSpans();
    internal TextRunCacheImp get_Imp();
    internal void set_Imp(TextRunCacheImp value);
}
public abstract class System.Windows.Media.TextFormatting.TextRunProperties : object {
    private double _pixelsPerDip;
    public Typeface Typeface { get; }
    public double FontRenderingEmSize { get; }
    public double FontHintingEmSize { get; }
    public TextDecorationCollection TextDecorations { get; }
    public Brush ForegroundBrush { get; }
    public Brush BackgroundBrush { get; }
    public CultureInfo CultureInfo { get; }
    public TextEffectCollection TextEffects { get; }
    public BaselineAlignment BaselineAlignment { get; }
    public TextRunTypographyProperties TypographyProperties { get; }
    public NumberSubstitution NumberSubstitution { get; }
    public double PixelsPerDip { get; public set; }
    public abstract virtual Typeface get_Typeface();
    public abstract virtual double get_FontRenderingEmSize();
    public abstract virtual double get_FontHintingEmSize();
    public abstract virtual TextDecorationCollection get_TextDecorations();
    public abstract virtual Brush get_ForegroundBrush();
    public abstract virtual Brush get_BackgroundBrush();
    public abstract virtual CultureInfo get_CultureInfo();
    public abstract virtual TextEffectCollection get_TextEffects();
    public virtual BaselineAlignment get_BaselineAlignment();
    public virtual TextRunTypographyProperties get_TypographyProperties();
    public virtual NumberSubstitution get_NumberSubstitution();
    public double get_PixelsPerDip();
    public void set_PixelsPerDip(double value);
}
public abstract class System.Windows.Media.TextFormatting.TextRunTypographyProperties : object {
    private DWriteFontFeature[] _features;
    public bool StandardLigatures { get; }
    public bool ContextualLigatures { get; }
    public bool DiscretionaryLigatures { get; }
    public bool HistoricalLigatures { get; }
    public bool ContextualAlternates { get; }
    public bool HistoricalForms { get; }
    public bool Kerning { get; }
    public bool CapitalSpacing { get; }
    public bool CaseSensitiveForms { get; }
    public bool StylisticSet1 { get; }
    public bool StylisticSet2 { get; }
    public bool StylisticSet3 { get; }
    public bool StylisticSet4 { get; }
    public bool StylisticSet5 { get; }
    public bool StylisticSet6 { get; }
    public bool StylisticSet7 { get; }
    public bool StylisticSet8 { get; }
    public bool StylisticSet9 { get; }
    public bool StylisticSet10 { get; }
    public bool StylisticSet11 { get; }
    public bool StylisticSet12 { get; }
    public bool StylisticSet13 { get; }
    public bool StylisticSet14 { get; }
    public bool StylisticSet15 { get; }
    public bool StylisticSet16 { get; }
    public bool StylisticSet17 { get; }
    public bool StylisticSet18 { get; }
    public bool StylisticSet19 { get; }
    public bool StylisticSet20 { get; }
    public bool SlashedZero { get; }
    public bool MathematicalGreek { get; }
    public bool EastAsianExpertForms { get; }
    public FontVariants Variants { get; }
    public FontCapitals Capitals { get; }
    public FontFraction Fraction { get; }
    public FontNumeralStyle NumeralStyle { get; }
    public FontNumeralAlignment NumeralAlignment { get; }
    public FontEastAsianWidths EastAsianWidths { get; }
    public FontEastAsianLanguage EastAsianLanguage { get; }
    public int StandardSwashes { get; }
    public int ContextualSwashes { get; }
    public int StylisticAlternates { get; }
    public int AnnotationAlternates { get; }
    internal DWriteFontFeature[] CachedFeatureSet { get; internal set; }
    public abstract virtual bool get_StandardLigatures();
    public abstract virtual bool get_ContextualLigatures();
    public abstract virtual bool get_DiscretionaryLigatures();
    public abstract virtual bool get_HistoricalLigatures();
    public abstract virtual bool get_ContextualAlternates();
    public abstract virtual bool get_HistoricalForms();
    public abstract virtual bool get_Kerning();
    public abstract virtual bool get_CapitalSpacing();
    public abstract virtual bool get_CaseSensitiveForms();
    public abstract virtual bool get_StylisticSet1();
    public abstract virtual bool get_StylisticSet2();
    public abstract virtual bool get_StylisticSet3();
    public abstract virtual bool get_StylisticSet4();
    public abstract virtual bool get_StylisticSet5();
    public abstract virtual bool get_StylisticSet6();
    public abstract virtual bool get_StylisticSet7();
    public abstract virtual bool get_StylisticSet8();
    public abstract virtual bool get_StylisticSet9();
    public abstract virtual bool get_StylisticSet10();
    public abstract virtual bool get_StylisticSet11();
    public abstract virtual bool get_StylisticSet12();
    public abstract virtual bool get_StylisticSet13();
    public abstract virtual bool get_StylisticSet14();
    public abstract virtual bool get_StylisticSet15();
    public abstract virtual bool get_StylisticSet16();
    public abstract virtual bool get_StylisticSet17();
    public abstract virtual bool get_StylisticSet18();
    public abstract virtual bool get_StylisticSet19();
    public abstract virtual bool get_StylisticSet20();
    public abstract virtual bool get_SlashedZero();
    public abstract virtual bool get_MathematicalGreek();
    public abstract virtual bool get_EastAsianExpertForms();
    public abstract virtual FontVariants get_Variants();
    public abstract virtual FontCapitals get_Capitals();
    public abstract virtual FontFraction get_Fraction();
    public abstract virtual FontNumeralStyle get_NumeralStyle();
    public abstract virtual FontNumeralAlignment get_NumeralAlignment();
    public abstract virtual FontEastAsianWidths get_EastAsianWidths();
    public abstract virtual FontEastAsianLanguage get_EastAsianLanguage();
    public abstract virtual int get_StandardSwashes();
    public abstract virtual int get_ContextualSwashes();
    public abstract virtual int get_StylisticAlternates();
    public abstract virtual int get_AnnotationAlternates();
    protected void OnPropertiesChanged();
    internal DWriteFontFeature[] get_CachedFeatureSet();
    internal void set_CachedFeatureSet(DWriteFontFeature[] value);
}
internal class System.Windows.Media.TextFormatting.TextShapeableCharacters : TextShapeableSymbols {
    private CharacterBufferRange _characterBufferRange;
    private TextFormattingMode _textFormattingMode;
    private bool _isSideways;
    private TextRunProperties _properties;
    private double _emSize;
    private ItemProps _textItem;
    private ShapeTypeface _shapeTypeface;
    private bool _nullShape;
    internal static ushort DefaultMaxClusterSize;
    private static ushort IndicMaxClusterSize;
    public CharacterBufferReference CharacterBufferReference { get; }
    public int Length { get; }
    public TextRunProperties Properties { get; }
    internal double EmSize { get; }
    internal ItemProps ItemProps { get; }
    internal bool NeedsMaxClusterSize { get; }
    internal bool IsShapingRequired { get; }
    internal bool NeedsCaretInfo { get; }
    internal bool HasExtendedCharacter { get; }
    internal double Height { get; }
    internal double Baseline { get; }
    internal double UnderlinePosition { get; }
    internal double UnderlineThickness { get; }
    internal double StrikethroughPosition { get; }
    internal double StrikethroughThickness { get; }
    internal bool IsSymbol { get; }
    internal GlyphTypeface GlyphTypeFace { get; }
    internal ushort MaxClusterSize { get; }
    internal TextShapeableCharacters(CharacterBufferRange characterRange, TextRunProperties properties, double emSize, ItemProps textItem, ShapeTypeface shapeTypeface, bool nullShape, TextFormattingMode textFormattingMode, bool isSideways);
    public sealed virtual CharacterBufferReference get_CharacterBufferReference();
    public sealed virtual int get_Length();
    public sealed virtual TextRunProperties get_Properties();
    internal sealed virtual GlyphRun ComputeShapedGlyphRun(Point origin, Char[] characterString, UInt16[] clusterMap, UInt16[] glyphIndices, IList`1<double> glyphAdvances, IList`1<Point> glyphOffsets, bool rightToLeft, bool sideways);
    private GlyphTypeface GetGlyphTypeface(Boolean& nullFont);
    internal sealed virtual GlyphRun ComputeUnshapedGlyphRun(Point origin, Char[] characterString, IList`1<double> characterAdvances);
    internal sealed virtual void Draw(DrawingContext drawingContext, Brush foregroundBrush, GlyphRun glyphRun);
    internal virtual double get_EmSize();
    internal virtual ItemProps get_ItemProps();
    internal sealed virtual void GetAdvanceWidthsUnshaped(Char* characterString, int characterLength, double scalingFactor, Int32* advanceWidthsUnshaped);
    internal sealed virtual bool get_NeedsMaxClusterSize();
    internal sealed virtual bool CanShapeTogether(TextShapeableSymbols shapeable);
    internal sealed virtual bool get_IsShapingRequired();
    internal sealed virtual bool get_NeedsCaretInfo();
    internal sealed virtual bool get_HasExtendedCharacter();
    internal sealed virtual double get_Height();
    internal sealed virtual double get_Baseline();
    internal sealed virtual double get_UnderlinePosition();
    internal sealed virtual double get_UnderlineThickness();
    internal sealed virtual double get_StrikethroughPosition();
    internal sealed virtual double get_StrikethroughThickness();
    internal bool get_IsSymbol();
    internal virtual GlyphTypeface get_GlyphTypeFace();
    internal sealed virtual ushort get_MaxClusterSize();
}
public class System.Windows.Media.TextFormatting.TextSimpleMarkerProperties : TextMarkerProperties {
    private double _offset;
    private TextSource _textSource;
    public double Offset { get; }
    public TextSource TextSource { get; }
    public TextSimpleMarkerProperties(TextMarkerStyle style, double offset, int autoNumberingIndex, TextParagraphProperties textParagraphProperties);
    public sealed virtual double get_Offset();
    public sealed virtual TextSource get_TextSource();
}
public abstract class System.Windows.Media.TextFormatting.TextSource : object {
    private double _pixelsPerDip;
    public double PixelsPerDip { get; public set; }
    public abstract virtual TextRun GetTextRun(int textSourceCharacterIndex);
    public abstract virtual TextSpan`1<CultureSpecificCharacterBufferRange> GetPrecedingText(int textSourceCharacterIndexLimit);
    public abstract virtual int GetTextEffectCharacterIndexFromTextSourceCharacterIndex(int textSourceCharacterIndex);
    public double get_PixelsPerDip();
    public void set_PixelsPerDip(double value);
}
public class System.Windows.Media.TextFormatting.TextSpan`1 : object {
    private int _length;
    private T _value;
    public int Length { get; }
    public T Value { get; }
    public TextSpan`1(int length, T value);
    public int get_Length();
    public T get_Value();
}
public enum System.Windows.Media.TextFormatting.TextTabAlignment : Enum {
    public int value__;
    public static TextTabAlignment Left;
    public static TextTabAlignment Center;
    public static TextTabAlignment Right;
    public static TextTabAlignment Character;
}
public class System.Windows.Media.TextFormatting.TextTabProperties : object {
    private TextTabAlignment _alignment;
    private double _location;
    private int _tabLeader;
    private int _aligningChar;
    public TextTabAlignment Alignment { get; }
    public double Location { get; }
    public int TabLeader { get; }
    public int AligningCharacter { get; }
    public TextTabProperties(TextTabAlignment alignment, double location, int tabLeader, int aligningChar);
    public TextTabAlignment get_Alignment();
    public double get_Location();
    public int get_TabLeader();
    public int get_AligningCharacter();
}
public class System.Windows.Media.TextFormatting.TextTrailingCharacterEllipsis : TextCollapsingProperties {
    private double _width;
    private TextRun _ellipsis;
    private static string StringHorizontalEllipsis;
    public double Width { get; }
    public TextRun Symbol { get; }
    public TextCollapsingStyle Style { get; }
    public TextTrailingCharacterEllipsis(double width, TextRunProperties textRunProperties);
    public sealed virtual double get_Width();
    public sealed virtual TextRun get_Symbol();
    public sealed virtual TextCollapsingStyle get_Style();
}
public class System.Windows.Media.TextFormatting.TextTrailingWordEllipsis : TextCollapsingProperties {
    private double _width;
    private TextRun _ellipsis;
    private static string StringHorizontalEllipsis;
    public double Width { get; }
    public TextRun Symbol { get; }
    public TextCollapsingStyle Style { get; }
    public TextTrailingWordEllipsis(double width, TextRunProperties textRunProperties);
    public sealed virtual double get_Width();
    public sealed virtual TextRun get_Symbol();
    public sealed virtual TextCollapsingStyle get_Style();
}
public enum System.Windows.Media.TextHintingMode : Enum {
    public int value__;
    public static TextHintingMode Auto;
    public static TextHintingMode Fixed;
    public static TextHintingMode Animated;
}
public enum System.Windows.Media.TextRenderingMode : Enum {
    public int value__;
    public static TextRenderingMode Auto;
    public static TextRenderingMode Aliased;
    public static TextRenderingMode Grayscale;
    public static TextRenderingMode ClearType;
}
public abstract class System.Windows.Media.TileBrush : Brush {
    public static DependencyProperty ViewportUnitsProperty;
    public static DependencyProperty ViewboxUnitsProperty;
    public static DependencyProperty ViewportProperty;
    public static DependencyProperty ViewboxProperty;
    public static DependencyProperty StretchProperty;
    public static DependencyProperty TileModeProperty;
    public static DependencyProperty AlignmentXProperty;
    public static DependencyProperty AlignmentYProperty;
    internal static BrushMappingMode c_ViewportUnits;
    internal static BrushMappingMode c_ViewboxUnits;
    internal static Rect s_Viewport;
    internal static Rect s_Viewbox;
    internal static Stretch c_Stretch;
    internal static TileMode c_TileMode;
    internal static AlignmentX c_AlignmentX;
    internal static AlignmentY c_AlignmentY;
    internal static CachingHint c_CachingHint;
    internal static double c_CacheInvalidationThresholdMinimum;
    internal static double c_CacheInvalidationThresholdMaximum;
    public BrushMappingMode ViewportUnits { get; public set; }
    public BrushMappingMode ViewboxUnits { get; public set; }
    public Rect Viewport { get; public set; }
    public Rect Viewbox { get; public set; }
    public Stretch Stretch { get; public set; }
    public TileMode TileMode { get; public set; }
    public AlignmentX AlignmentX { get; public set; }
    public AlignmentY AlignmentY { get; public set; }
    private static TileBrush();
    protected abstract virtual void GetContentBounds(Rect& contentBounds);
    internal void GetTileBrushMapping(Rect shapeFillBounds, Matrix& tileBrushMapping);
    public TileBrush Clone();
    public TileBrush CloneCurrentValue();
    private static void ViewportUnitsPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void ViewboxUnitsPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void ViewportPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void ViewboxPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void StretchPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void TileModePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void AlignmentXPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void AlignmentYPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void CachingHintPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void CacheInvalidationThresholdMinimumPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void CacheInvalidationThresholdMaximumPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public BrushMappingMode get_ViewportUnits();
    public void set_ViewportUnits(BrushMappingMode value);
    public BrushMappingMode get_ViewboxUnits();
    public void set_ViewboxUnits(BrushMappingMode value);
    public Rect get_Viewport();
    public void set_Viewport(Rect value);
    public Rect get_Viewbox();
    public void set_Viewbox(Rect value);
    public Stretch get_Stretch();
    public void set_Stretch(Stretch value);
    public TileMode get_TileMode();
    public void set_TileMode(TileMode value);
    public AlignmentX get_AlignmentX();
    public void set_AlignmentX(AlignmentX value);
    public AlignmentY get_AlignmentY();
    public void set_AlignmentY(AlignmentY value);
}
public enum System.Windows.Media.TileMode : Enum {
    public int value__;
    public static TileMode None;
    public static TileMode Tile;
    public static TileMode FlipX;
    public static TileMode FlipY;
    public static TileMode FlipXY;
}
public enum System.Windows.Media.ToleranceType : Enum {
    public int value__;
    public static ToleranceType Absolute;
    public static ToleranceType Relative;
}
[LocalizabilityAttribute("0")]
[ValueSerializerAttribute("System.Windows.Media.Converters.TransformValueSerializer")]
[TypeConverterAttribute("System.Windows.Media.TransformConverter")]
public abstract class System.Windows.Media.Transform : GeneralTransform {
    private static Transform s_identity;
    public static Transform Identity { get; }
    public Matrix Value { get; }
    internal bool IsIdentity { get; }
    public GeneralTransform Inverse { get; }
    internal Transform AffineTransform { get; }
    private static Transform();
    public static Transform get_Identity();
    private static Transform MakeIdentityTransform();
    public abstract virtual Matrix get_Value();
    internal abstract virtual bool get_IsIdentity();
    internal virtual bool CanSerializeToString();
    internal virtual void TransformRect(Rect& rect);
    internal virtual void MultiplyValueByMatrix(Matrix& result, Matrix& matrixToMultiplyBy);
    internal virtual void ConvertToD3DMATRIX(D3DMATRIX* milMatrix);
    internal static void GetTransformValue(Transform transform, Matrix& currentTransformValue);
    public virtual bool TryTransform(Point inPoint, Point& result);
    public virtual Rect TransformBounds(Rect rect);
    public virtual GeneralTransform get_Inverse();
    [FriendAccessAllowedAttribute]
internal virtual Transform get_AffineTransform();
    public Transform Clone();
    public Transform CloneCurrentValue();
    internal abstract virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    internal abstract virtual void ReleaseOnChannelCore(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    internal abstract virtual ResourceHandle GetHandleCore(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    internal abstract virtual int GetChannelCountCore();
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    internal abstract virtual Channel GetChannelCore(int index);
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
    public static Transform Parse(string source);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.TransformCollection : Animatable {
    [CompilerGeneratedAttribute]
private ItemInsertedHandler ItemInserted;
    [CompilerGeneratedAttribute]
private ItemRemovedHandler ItemRemoved;
    private static TransformCollection s_empty;
    internal FrugalStructList`1<Transform> _collection;
    internal UInt32 _version;
    public Transform Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Media.Transform>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal static TransformCollection Empty { get; }
    public TransformCollection(int capacity);
    public TransformCollection(IEnumerable`1<Transform> collection);
    public TransformCollection Clone();
    public TransformCollection CloneCurrentValue();
    public sealed virtual void Add(Transform value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Transform value);
    public sealed virtual int IndexOf(Transform value);
    public sealed virtual void Insert(int index, Transform value);
    public sealed virtual bool Remove(Transform value);
    public sealed virtual void RemoveAt(int index);
    internal void RemoveAtWithoutFiringPublicEvents(int index);
    public sealed virtual Transform get_Item(int index);
    public sealed virtual void set_Item(int index, Transform value);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(Transform[] array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Media.Transform>.get_IsReadOnly();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<Transform> System.Collections.Generic.IEnumerable<System.Windows.Media.Transform>.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal static TransformCollection get_Empty();
    internal Transform Internal_GetItem(int i);
    internal virtual void OnInheritanceContextChangedCore(EventArgs args);
    private Transform Cast(object value);
    private int AddHelper(Transform value);
    internal int AddWithoutFiringPublicEvents(Transform value);
    [CompilerGeneratedAttribute]
internal void add_ItemInserted(ItemInsertedHandler value);
    [CompilerGeneratedAttribute]
internal void remove_ItemInserted(ItemInsertedHandler value);
    [CompilerGeneratedAttribute]
internal void add_ItemRemoved(ItemRemovedHandler value);
    [CompilerGeneratedAttribute]
internal void remove_ItemRemoved(ItemRemovedHandler value);
    private void OnInsert(object item);
    private void OnRemove(object oldValue);
    private void OnSet(object oldValue, object newValue);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected virtual bool FreezeCore(bool isChecking);
}
public class System.Windows.Media.TransformConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[ContentPropertyAttribute("Children")]
public class System.Windows.Media.TransformGroup : Transform {
    public static DependencyProperty ChildrenProperty;
    internal MultiChannelResource _duceResource;
    internal static TransformCollection s_Children;
    public Matrix Value { get; }
    internal bool IsIdentity { get; }
    public TransformCollection Children { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    private static TransformGroup();
    public virtual Matrix get_Value();
    internal virtual bool get_IsIdentity();
    internal virtual bool CanSerializeToString();
    public TransformGroup Clone();
    public TransformGroup CloneCurrentValue();
    private static void ChildrenPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public TransformCollection get_Children();
    public void set_Children(TransformCollection value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    private void ChildrenItemInserted(object sender, object item);
    private void ChildrenItemRemoved(object sender, object item);
    internal virtual int get_EffectiveValuesInitialSize();
}
public class System.Windows.Media.TranslateTransform : Transform {
    public static DependencyProperty XProperty;
    public static DependencyProperty YProperty;
    internal MultiChannelResource _duceResource;
    internal static double c_X;
    internal static double c_Y;
    public Matrix Value { get; }
    internal bool IsIdentity { get; }
    public double X { get; public set; }
    public double Y { get; public set; }
    public TranslateTransform(double offsetX, double offsetY);
    private static TranslateTransform();
    public virtual Matrix get_Value();
    internal virtual bool get_IsIdentity();
    internal virtual void TransformRect(Rect& rect);
    internal virtual void MultiplyValueByMatrix(Matrix& result, Matrix& matrixToMultiplyBy);
    public TranslateTransform Clone();
    public TranslateTransform CloneCurrentValue();
    private static void XPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void YPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
}
internal static class System.Windows.Media.TypeConverterHelper : object {
    internal static UriHolder GetUriFromUriContext(ITypeDescriptorContext context, object inputString);
}
public class System.Windows.Media.Typeface : object {
    private FontFamily _fontFamily;
    private FontStyle _style;
    private FontWeight _weight;
    private FontStretch _stretch;
    private FontFamily _fallbackFontFamily;
    private CachedTypeface _cachedTypeface;
    public FontFamily FontFamily { get; }
    public FontWeight Weight { get; }
    public FontStyle Style { get; }
    public FontStretch Stretch { get; }
    public bool IsObliqueSimulated { get; }
    public bool IsBoldSimulated { get; }
    internal FontFamily FallbackFontFamily { get; }
    public double XHeight { get; }
    public double CapsHeight { get; }
    public double UnderlinePosition { get; }
    public double UnderlineThickness { get; }
    public double StrikethroughPosition { get; }
    public double StrikethroughThickness { get; }
    public LanguageSpecificStringDictionary FaceNames { get; }
    internal bool Symbol { get; }
    internal bool NullFont { get; }
    internal FontStyle CanonicalStyle { get; }
    internal FontWeight CanonicalWeight { get; }
    internal FontStretch CanonicalStretch { get; }
    private CachedTypeface CachedTypeface { get; }
    public Typeface(string typefaceName);
    public Typeface(FontFamily fontFamily, FontStyle style, FontWeight weight, FontStretch stretch);
    public Typeface(FontFamily fontFamily, FontStyle style, FontWeight weight, FontStretch stretch, FontFamily fallbackFontFamily);
    public FontFamily get_FontFamily();
    public FontWeight get_Weight();
    public FontStyle get_Style();
    public FontStretch get_Stretch();
    public bool get_IsObliqueSimulated();
    public bool get_IsBoldSimulated();
    public bool TryGetGlyphTypeface(GlyphTypeface& glyphTypeface);
    internal FontFamily get_FallbackFontFamily();
    public double get_XHeight();
    public double get_CapsHeight();
    public double get_UnderlinePosition();
    public double get_UnderlineThickness();
    public double get_StrikethroughPosition();
    public double get_StrikethroughThickness();
    public LanguageSpecificStringDictionary get_FaceNames();
    internal double Baseline(double emSize, double toReal, double pixelsPerDip, TextFormattingMode textFormattingMode);
    internal double LineSpacing(double emSize, double toReal, double pixelsPerDip, TextFormattingMode textFormattingMode);
    internal bool get_Symbol();
    internal bool get_NullFont();
    internal GlyphTypeface TryGetGlyphTypeface();
    internal FontStyle get_CanonicalStyle();
    internal FontWeight get_CanonicalWeight();
    internal FontStretch get_CanonicalStretch();
    internal bool CheckFastPathNominalGlyphs(CharacterBufferRange charBufferRange, double emSize, float pixelsPerDip, double scalingFactor, double widthMax, bool keepAWord, bool numberSubstitution, CultureInfo cultureInfo, TextFormattingMode textFormattingMode, bool isSideways, bool breakOnTabs, Int32& stringLengthFit);
    internal void GetCharacterNominalWidthsAndIdealWidth(CharacterBufferRange charBufferRange, double emSize, float pixelsPerDip, double toIdeal, TextFormattingMode textFormattingMode, bool isSideways, Int32[]& nominalWidths);
    internal void GetCharacterNominalWidthsAndIdealWidth(CharacterBufferRange charBufferRange, double emSize, float pixelsPerDip, double toIdeal, TextFormattingMode textFormattingMode, bool isSideways, Int32[]& nominalWidths, Int32& idealWidth);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    internal bool CompareFallbackFontFamily(FontFamily fallbackFontFamily);
    private CachedTypeface get_CachedTypeface();
    private CachedTypeface ConstructCachedTypeface();
}
internal class System.Windows.Media.UniqueEventHelper : object {
    private Hashtable _htDelegates;
    internal void AddEvent(EventHandler handler);
    internal void RemoveEvent(EventHandler handler);
    internal void InvokeEvents(object sender, EventArgs args);
    internal UniqueEventHelper Clone();
    private void EnsureEventTable();
}
internal class System.Windows.Media.UniqueEventHelper`1 : object {
    private Hashtable _htDelegates;
    internal void AddEvent(EventHandler`1<TEventArgs> handler);
    internal void RemoveEvent(EventHandler`1<TEventArgs> handler);
    internal void InvokeEvents(object sender, TEventArgs args);
    internal UniqueEventHelper`1<TEventArgs> Clone();
    private void EnsureEventTable();
}
internal class System.Windows.Media.UriHolder : ValueType {
    internal Uri BaseUri;
    internal Uri OriginalUri;
}
[FriendAccessAllowedAttribute]
internal static class System.Windows.Media.ValidateEnums : object {
    public static bool IsAlignmentXValid(object valueObject);
    public static bool IsAlignmentYValid(object valueObject);
    public static bool IsBrushMappingModeValid(object valueObject);
    public static bool IsCachingHintValid(object valueObject);
    public static bool IsColorInterpolationModeValid(object valueObject);
    public static bool IsGeometryCombineModeValid(object valueObject);
    public static bool IsEdgeModeValid(object valueObject);
    public static bool IsBitmapScalingModeValid(object valueObject);
    public static bool IsClearTypeHintValid(object valueObject);
    public static bool IsTextRenderingModeValid(object valueObject);
    public static bool IsTextHintingModeValid(object valueObject);
    public static bool IsFillRuleValid(object valueObject);
    public static bool IsGradientSpreadMethodValid(object valueObject);
    public static bool IsPenLineCapValid(object valueObject);
    public static bool IsPenLineJoinValid(object valueObject);
    public static bool IsStretchValid(object valueObject);
    public static bool IsTileModeValid(object valueObject);
    public static bool IsSweepDirectionValid(object valueObject);
}
[DefaultMemberAttribute("Item")]
[ValueSerializerAttribute("System.Windows.Media.Converters.VectorCollectionValueSerializer")]
[TypeConverterAttribute("System.Windows.Media.VectorCollectionConverter")]
public class System.Windows.Media.VectorCollection : Freezable {
    private static VectorCollection s_empty;
    internal FrugalStructList`1<Vector> _collection;
    internal UInt32 _version;
    public Vector Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.Vector>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal static VectorCollection Empty { get; }
    public VectorCollection(int capacity);
    public VectorCollection(IEnumerable`1<Vector> collection);
    public VectorCollection Clone();
    public VectorCollection CloneCurrentValue();
    public sealed virtual void Add(Vector value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Vector value);
    public sealed virtual int IndexOf(Vector value);
    public sealed virtual void Insert(int index, Vector value);
    public sealed virtual bool Remove(Vector value);
    public sealed virtual void RemoveAt(int index);
    internal void RemoveAtWithoutFiringPublicEvents(int index);
    public sealed virtual Vector get_Item(int index);
    public sealed virtual void set_Item(int index, Vector value);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(Vector[] array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.Vector>.get_IsReadOnly();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<Vector> System.Collections.Generic.IEnumerable<System.Windows.Vector>.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal static VectorCollection get_Empty();
    internal Vector Internal_GetItem(int i);
    private Vector Cast(object value);
    private int AddHelper(Vector value);
    internal int AddWithoutFiringPublicEvents(Vector value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
    internal string ConvertToString(string format, IFormatProvider provider);
    public static VectorCollection Parse(string source);
}
public class System.Windows.Media.VectorCollectionConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.Media.VideoDrawing : Drawing {
    public static DependencyProperty PlayerProperty;
    public static DependencyProperty RectProperty;
    internal MultiChannelResource _duceResource;
    internal static Rect s_Rect;
    public MediaPlayer Player { get; public set; }
    public Rect Rect { get; public set; }
    private static VideoDrawing();
    internal virtual void WalkCurrentValue(DrawingContextWalker ctx);
    public VideoDrawing Clone();
    public VideoDrawing CloneCurrentValue();
    private static void PlayerPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void RectPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public MediaPlayer get_Player();
    public void set_Player(MediaPlayer value);
    public Rect get_Rect();
    public void set_Rect(Rect value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
}
public abstract class System.Windows.Media.Visual : DependencyObject {
    private static VisualProxyFlags c_ProxyFlagsDirtyMask;
    private static VisualProxyFlags c_Viewport3DProxyFlagsDirtyMask;
    internal static UncommonField`1<BitmapEffectState> BitmapEffectStateField;
    internal int _parentIndex;
    internal DependencyObject _parent;
    internal VisualProxy _proxy;
    private Rect _bboxSubgraph;
    private static UncommonField`1<Dictionary`2<ICyclicBrush, int>> CyclicBrushToChannelsMapField;
    private static UncommonField`1<Dictionary`2<Channel, int>> ChannelsToCyclicBrushMapField;
    internal static UncommonField`1<int> DpiIndex;
    private static UncommonField`1<Geometry> ClipField;
    private static UncommonField`1<double> OpacityField;
    private static UncommonField`1<Brush> OpacityMaskField;
    private static UncommonField`1<EdgeMode> EdgeModeField;
    private static UncommonField`1<BitmapScalingMode> BitmapScalingModeField;
    private static UncommonField`1<ClearTypeHint> ClearTypeHintField;
    private static UncommonField`1<Transform> TransformField;
    private static UncommonField`1<Effect> EffectField;
    private static UncommonField`1<CacheMode> CacheModeField;
    private static UncommonField`1<DoubleCollection> GuidelinesXField;
    private static UncommonField`1<DoubleCollection> GuidelinesYField;
    private static UncommonField`1<AncestorChangedEventHandler> AncestorChangedEventField;
    private static UncommonField`1<BitmapEffectState> UserProvidedBitmapEffectData;
    private static UncommonField`1<Nullable`1<Rect>> ScrollableAreaClipField;
    private static UncommonField`1<TextRenderingMode> TextRenderingModeField;
    private static UncommonField`1<TextHintingMode> TextHintingModeField;
    private Vector _offset;
    private VisualFlags _flags;
    private static UInt32 TreeLevelLimit;
    internal bool IsVisualChildrenIterationInProgress { get; internal set; }
    internal bool IsRootElement { get; internal set; }
    internal Rect VisualContentBounds { get; }
    internal Rect VisualDescendantBounds { get; }
    protected int VisualChildrenCount { get; }
    internal int InternalVisualChildrenCount { get; }
    internal int InternalVisual2DOr3DChildrenCount { get; }
    internal bool HasVisualChildren { get; }
    internal UInt32 TreeLevel { get; internal set; }
    protected DependencyObject VisualParent { get; }
    internal DependencyObject InternalVisualParent { get; }
    protected internal Transform VisualTransform { get; protected set; }
    protected internal Effect VisualEffect { get; protected set; }
    internal Effect VisualEffectInternal { get; internal set; }
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected internal BitmapEffect VisualBitmapEffect { get; protected set; }
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
protected internal BitmapEffectInput VisualBitmapEffectInput { get; protected set; }
    internal bool BitmapEffectEmulationDisabled { get; internal set; }
    internal BitmapEffect VisualBitmapEffectInternal { get; internal set; }
    internal BitmapEffectInput VisualBitmapEffectInputInternal { get; internal set; }
    protected internal CacheMode VisualCacheMode { get; protected set; }
    protected internal Nullable`1<Rect> VisualScrollableAreaClip { get; protected set; }
    protected internal Geometry VisualClip { get; protected set; }
    protected internal Vector VisualOffset { get; protected set; }
    protected internal double VisualOpacity { get; protected set; }
    protected internal EdgeMode VisualEdgeMode { get; protected set; }
    protected internal BitmapScalingMode VisualBitmapScalingMode { get; protected set; }
    protected internal ClearTypeHint VisualClearTypeHint { get; protected internal set; }
    protected internal TextRenderingMode VisualTextRenderingMode { get; protected internal set; }
    protected internal TextHintingMode VisualTextHintingMode { get; protected internal set; }
    protected internal Brush VisualOpacityMask { get; protected set; }
    protected internal DoubleCollection VisualXSnappingGuidelines { get; protected set; }
    protected internal DoubleCollection VisualYSnappingGuidelines { get; protected set; }
    internal EventHandler ClipChangedHandler { get; }
    internal EventHandler ScrollableAreaClipChangedHandler { get; }
    internal EventHandler TransformChangedHandler { get; }
    internal EventHandler EffectChangedHandler { get; }
    internal EventHandler CacheModeChangedHandler { get; }
    internal EventHandler GuidelinesChangedHandler { get; }
    internal EventHandler OpacityMaskChangedHandler { get; }
    internal EventHandler ContentsChangedHandler { get; }
    private bool NodeHasLegacyBitmapEffect { get; }
    internal Visual(ResourceType resourceType);
    private static Visual();
    internal bool IsOnChannel(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.GetHandle(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.Get3DHandle(Channel channel);
    private sealed virtual override ResourceHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(Channel channel);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.RemoveChildFromParent(IResource parent, Channel channel);
    private sealed virtual override int System.Windows.Media.Composition.DUCE.IResource.GetChannelCount();
    private sealed virtual override Channel System.Windows.Media.Composition.DUCE.IResource.GetChannel(int index);
    [FriendAccessAllowedAttribute]
internal bool get_IsVisualChildrenIterationInProgress();
    [FriendAccessAllowedAttribute]
internal void set_IsVisualChildrenIterationInProgress(bool value);
    internal bool get_IsRootElement();
    internal void set_IsRootElement(bool value);
    internal virtual Rect GetContentBounds();
    internal virtual void RenderContent(RenderContext ctx, bool isOnChannel);
    internal virtual void RenderClose(IDrawingContent newContent);
    internal Rect get_VisualContentBounds();
    internal Rect get_VisualDescendantBounds();
    internal Rect CalculateSubgraphBoundsInnerSpace();
    internal Rect CalculateSubgraphRenderBoundsInnerSpace();
    internal virtual Rect CalculateSubgraphBoundsInnerSpace(bool renderBounds);
    internal Rect CalculateSubgraphBoundsOuterSpace();
    internal Rect CalculateSubgraphRenderBoundsOuterSpace();
    private Rect CalculateSubgraphBoundsOuterSpace(bool renderBounds);
    private bool IsEmptyRenderBounds(Rect& bounds);
    internal virtual void FreeContent(Channel channel);
    private bool IsCyclicBrushRootOnChannel(Channel channel);
    private sealed virtual override void System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel(Channel channel);
    internal virtual void AddRefOnChannelForCyclicBrush(ICyclicBrush cyclicBrush, Channel channel);
    internal virtual void ReleaseOnChannelForCyclicBrush(ICyclicBrush cyclicBrush, Channel channel);
    internal void VerifyAPIReadOnly();
    internal void VerifyAPIReadOnly(DependencyObject value);
    internal void VerifyAPIReadWrite();
    internal void VerifyAPIReadWrite(DependencyObject value);
    internal void Precompute();
    internal virtual void PrecomputeContent();
    internal void PrecomputeRecursive(Rect& bboxSubgraph);
    internal void Render(RenderContext ctx, UInt32 childIndex);
    internal virtual void RenderRecursive(RenderContext ctx);
    internal bool Enter();
    internal void Exit();
    private void UpdateOpacity(Channel channel, ResourceHandle handle, VisualProxyFlags flags, bool isOnChannel);
    private void UpdateOpacityMask(Channel channel, ResourceHandle handle, VisualProxyFlags flags, bool isOnChannel);
    private void UpdateTransform(Channel channel, ResourceHandle handle, VisualProxyFlags flags, bool isOnChannel);
    private void UpdateEffect(Channel channel, ResourceHandle handle, VisualProxyFlags flags, bool isOnChannel);
    private void UpdateCacheMode(Channel channel, ResourceHandle handle, VisualProxyFlags flags, bool isOnChannel);
    private void UpdateClip(Channel channel, ResourceHandle handle, VisualProxyFlags flags, bool isOnChannel);
    private void UpdateScrollableAreaClip(Channel channel, ResourceHandle handle, VisualProxyFlags flags, bool isOnChannel);
    private void UpdateOffset(Channel channel, ResourceHandle handle, VisualProxyFlags flags, bool isOnChannel);
    private void UpdateGuidelines(Channel channel, ResourceHandle handle, VisualProxyFlags flags, bool isOnChannel);
    private void UpdateRenderOptions(Channel channel, ResourceHandle handle, VisualProxyFlags flags, bool isOnChannel);
    private void UpdateContent(RenderContext ctx, VisualProxyFlags flags, bool isOnChannel);
    private void UpdateChildren(RenderContext ctx, ResourceHandle handle);
    internal void InvalidateHitTestBounds();
    internal virtual Rect GetHitTestBounds();
    internal HitTestResult HitTest(Point point);
    internal HitTestResult HitTest(Point point, bool include2DOn3D);
    internal void HitTest(HitTestFilterCallback filterCallback, HitTestResultCallback resultCallback, HitTestParameters hitTestParameters);
    internal HitTestResultBehavior HitTestPoint(HitTestFilterCallback filterCallback, HitTestResultCallback resultCallback, PointHitTestParameters pointParams);
    internal GeneralTransform TransformToOuterSpace();
    internal HitTestResultBehavior HitTestGeometry(HitTestFilterCallback filterCallback, HitTestResultCallback resultCallback, GeometryHitTestParameters geometryParams);
    internal virtual HitTestResultBehavior HitTestPointInternal(HitTestFilterCallback filterCallback, HitTestResultCallback resultCallback, PointHitTestParameters hitTestParameters);
    protected virtual HitTestResult HitTestCore(PointHitTestParameters hitTestParameters);
    protected virtual GeometryHitTestResult HitTestCore(GeometryHitTestParameters hitTestParameters);
    protected virtual int get_VisualChildrenCount();
    internal int get_InternalVisualChildrenCount();
    internal virtual int get_InternalVisual2DOr3DChildrenCount();
    internal bool get_HasVisualChildren();
    protected virtual Visual GetVisualChild(int index);
    internal Visual InternalGetVisualChild(int index);
    internal virtual DependencyObject InternalGet2DOr3DVisualChild(int index);
    internal void InternalAddVisualChild(Visual child);
    internal void InternalRemoveVisualChild(Visual child);
    protected void AddVisualChild(Visual child);
    protected void RemoveVisualChild(Visual child);
    [FriendAccessAllowedAttribute]
internal void InvalidateZOrder();
    internal UInt32 get_TreeLevel();
    internal void set_TreeLevel(UInt32 value);
    protected DependencyObject get_VisualParent();
    internal DependencyObject get_InternalVisualParent();
    [FriendAccessAllowedAttribute]
internal void InternalSetOffsetWorkaround(Vector offset);
    [FriendAccessAllowedAttribute]
internal void InternalSetTransformWorkaround(Transform transform);
    protected internal Transform get_VisualTransform();
    protected void set_VisualTransform(Transform value);
    protected internal Effect get_VisualEffect();
    protected void set_VisualEffect(Effect value);
    internal Effect get_VisualEffectInternal();
    internal void set_VisualEffectInternal(Effect value);
    protected internal BitmapEffect get_VisualBitmapEffect();
    protected void set_VisualBitmapEffect(BitmapEffect value);
    protected internal BitmapEffectInput get_VisualBitmapEffectInput();
    protected void set_VisualBitmapEffectInput(BitmapEffectInput value);
    internal void BitmapEffectEmulationChanged(object sender, EventArgs e);
    internal bool get_BitmapEffectEmulationDisabled();
    internal void set_BitmapEffectEmulationDisabled(bool value);
    internal BitmapEffect get_VisualBitmapEffectInternal();
    internal void set_VisualBitmapEffectInternal(BitmapEffect value);
    internal BitmapEffectInput get_VisualBitmapEffectInputInternal();
    internal void set_VisualBitmapEffectInputInternal(BitmapEffectInput value);
    protected internal CacheMode get_VisualCacheMode();
    protected void set_VisualCacheMode(CacheMode value);
    protected internal Nullable`1<Rect> get_VisualScrollableAreaClip();
    protected void set_VisualScrollableAreaClip(Nullable`1<Rect> value);
    protected internal Geometry get_VisualClip();
    protected void set_VisualClip(Geometry value);
    internal void ChangeVisualClip(Geometry newClip, bool dontSetWhenClose);
    protected internal Vector get_VisualOffset();
    protected void set_VisualOffset(Vector value);
    protected internal double get_VisualOpacity();
    protected void set_VisualOpacity(double value);
    protected internal EdgeMode get_VisualEdgeMode();
    protected void set_VisualEdgeMode(EdgeMode value);
    protected internal BitmapScalingMode get_VisualBitmapScalingMode();
    protected void set_VisualBitmapScalingMode(BitmapScalingMode value);
    protected internal ClearTypeHint get_VisualClearTypeHint();
    protected internal void set_VisualClearTypeHint(ClearTypeHint value);
    protected internal TextRenderingMode get_VisualTextRenderingMode();
    protected internal void set_VisualTextRenderingMode(TextRenderingMode value);
    protected internal TextHintingMode get_VisualTextHintingMode();
    protected internal void set_VisualTextHintingMode(TextHintingMode value);
    protected internal Brush get_VisualOpacityMask();
    protected void set_VisualOpacityMask(Brush value);
    protected internal DoubleCollection get_VisualXSnappingGuidelines();
    protected void set_VisualXSnappingGuidelines(DoubleCollection value);
    protected internal DoubleCollection get_VisualYSnappingGuidelines();
    protected void set_VisualYSnappingGuidelines(DoubleCollection value);
    internal void DisconnectAttachedResource(VisualProxyFlags correspondingFlag, IResource attachedResource);
    internal virtual DrawingGroup GetDrawing();
    internal virtual void FireOnVisualParentChanged(DependencyObject oldParent);
    protected internal virtual void OnVisualParentChanged(DependencyObject oldParent);
    protected internal virtual void OnVisualChildrenChanged(DependencyObject visualAdded, DependencyObject visualRemoved);
    protected virtual void OnDpiChanged(DpiScale oldDpi, DpiScale newDpi);
    internal void add_VisualAncestorChanged(AncestorChangedEventHandler value);
    internal void remove_VisualAncestorChanged(AncestorChangedEventHandler value);
    internal static void ProcessAncestorChangedNotificationRecursive(DependencyObject e, AncestorChangedEventArgs args);
    public bool IsAncestorOf(DependencyObject descendant);
    public bool IsDescendantOf(DependencyObject ancestor);
    internal void SetFlagsToRoot(bool value, VisualFlags flag);
    internal DependencyObject FindFirstAncestorWithFlagsAnd(VisualFlags flag);
    public DependencyObject FindCommonVisualAncestor(DependencyObject otherVisual);
    internal virtual void InvalidateForceInheritPropertyOnChildren(DependencyProperty property);
    public GeneralTransform TransformToAncestor(Visual ancestor);
    public GeneralTransform2DTo3D TransformToAncestor(Visual3D ancestor);
    public GeneralTransform TransformToDescendant(Visual descendant);
    public GeneralTransform TransformToVisual(Visual visual);
    private GeneralTransform InternalTransformToAncestor(Visual ancestor, bool inverse);
    internal bool TrySimpleTransformToAncestor(Visual ancestor, bool inverse, GeneralTransform& generalTransform, Matrix& simpleTransform);
    private GeneralTransform2DTo3D InternalTransformToAncestor(Visual3D ancestor, bool inverse);
    internal bool TrySimpleTransformToAncestor(Visual3D ancestor, GeneralTransform2DTo3D& transformTo3D);
    internal DpiScale GetDpi();
    public Point PointToScreen(Point point);
    public Point PointFromScreen(Point point);
    internal EventHandler get_ClipChangedHandler();
    internal void ClipChanged(object sender, EventArgs e);
    internal EventHandler get_ScrollableAreaClipChangedHandler();
    internal void ScrollableAreaClipChanged(object sender, EventArgs e);
    internal EventHandler get_TransformChangedHandler();
    internal void TransformChanged(object sender, EventArgs e);
    internal EventHandler get_EffectChangedHandler();
    internal void EffectChanged(object sender, EventArgs e);
    internal EventHandler get_CacheModeChangedHandler();
    internal void CacheModeChanged(object sender, EventArgs e);
    internal EventHandler get_GuidelinesChangedHandler();
    internal void GuidelinesChanged(object sender, EventArgs e);
    internal EventHandler get_OpacityMaskChangedHandler();
    internal void OpacityMaskChanged(object sender, EventArgs e);
    internal EventHandler get_ContentsChangedHandler();
    internal virtual void ContentsChanged(object sender, EventArgs e);
    internal void SetFlagsOnAllChannels(bool value, VisualProxyFlags flagsToChange);
    internal void SetFlags(Channel channel, bool value, VisualProxyFlags flagsToChange);
    internal void SetFlags(bool value, VisualFlags flags);
    internal void SetDpiScaleVisualFlags(DpiRecursiveChangeArgs args);
    internal void RecursiveSetDpiScaleVisualFlags(DpiRecursiveChangeArgs args);
    internal bool CheckFlagsOnAllChannels(VisualProxyFlags flagsToCheck);
    internal bool CheckFlagsAnd(Channel channel, VisualProxyFlags flagsToCheck);
    internal bool CheckFlagsAnd(VisualFlags flags);
    internal bool CheckFlagsOr(Channel channel, VisualProxyFlags flagsToCheck);
    internal bool CheckFlagsOr(VisualFlags flags);
    internal static void SetTreeBits(DependencyObject e, VisualFlags treeFlag, VisualFlags nodeFlag);
    internal static void ClearTreeBits(DependencyObject e, VisualFlags treeFlag, VisualFlags nodeFlag);
    private static bool DoAnyChildrenHaveABitSet(Visual pe, VisualFlags flag);
    internal static void PropagateFlags(Visual e, VisualFlags flags, VisualProxyFlags proxyFlags);
    internal void PropagateChangedFlags();
    private bool get_NodeHasLegacyBitmapEffect();
}
public class System.Windows.Media.VisualBrush : TileBrush {
    private DispatcherOperation _DispatcherLayoutResult;
    private bool _pendingLayout;
    private bool _reentrancyFlag;
    private bool _isAsyncRenderRegistered;
    private bool _isCacheDirty;
    private Rect _bbox;
    public static DependencyProperty VisualProperty;
    public static DependencyProperty AutoLayoutContentProperty;
    internal MultiChannelResource _duceResource;
    internal static bool c_AutoLayoutContent;
    public Visual Visual { get; public set; }
    public bool AutoLayoutContent { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    public VisualBrush(Visual visual);
    private static VisualBrush();
    private sealed virtual override void System.Windows.Media.ICyclicBrush.FireOnChanged();
    private void RegisterForAsyncRenderForCyclicBrush();
    private sealed virtual override void System.Windows.Media.ICyclicBrush.RenderForCyclicBrush(Channel channel, bool skipChannelCheck);
    internal void AddRefResource(Visual visual, Channel channel);
    internal void ReleaseResource(Visual visual, Channel channel);
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    private void DoLayout(UIElement element);
    private void OnLayoutUpdated(object sender, EventArgs args);
    private object LayoutCallback(object arg);
    internal bool Enter();
    internal void Exit();
    protected virtual void GetContentBounds(Rect& contentBounds);
    public VisualBrush Clone();
    public VisualBrush CloneCurrentValue();
    private static void VisualPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void AutoLayoutContentPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Visual get_Visual();
    public void set_Visual(Visual value);
    public bool get_AutoLayoutContent();
    public void set_AutoLayoutContent(bool value);
    protected virtual Freezable CreateInstanceCore();
    internal virtual void UpdateResource(Channel channel, bool skipOnChannelCheck);
    internal virtual ResourceHandle AddRefOnChannelCore(Channel channel);
    internal virtual void ReleaseOnChannelCore(Channel channel);
    internal virtual ResourceHandle GetHandleCore(Channel channel);
    internal virtual int GetChannelCountCore();
    internal virtual Channel GetChannelCore(int index);
    internal virtual int get_EffectiveValuesInitialSize();
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.VisualCollection : object {
    private Visual[] _items;
    private int _size;
    private Visual _owner;
    private UInt32 _data;
    private static int c_defaultCapacity;
    private static float c_growFactor;
    internal int InternalCount { get; }
    internal Visual[] InternalArray { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    internal int InternalCapacity { get; internal set; }
    public int Capacity { get; public set; }
    public Visual Item { get; public set; }
    private UInt32 Version { get; }
    private bool IsReadOnlyInternal { get; }
    public VisualCollection(Visual parent);
    internal int get_InternalCount();
    internal Visual[] get_InternalArray();
    internal void VerifyAPIReadOnly();
    internal void VerifyAPIReadOnly(Visual other);
    internal void VerifyAPIReadWrite();
    internal void VerifyAPIReadWrite(Visual other);
    internal void VerifyNotReadOnly();
    public sealed virtual int get_Count();
    public bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual void CopyTo(Array array, int index);
    public void CopyTo(Visual[] array, int index);
    private void EnsureCapacity(int min);
    internal int get_InternalCapacity();
    internal void set_InternalCapacity(int value);
    public int get_Capacity();
    public void set_Capacity(int value);
    public Visual get_Item(int index);
    public void set_Item(int index, Visual value);
    private void ConnectChild(int index, Visual value);
    private void DisconnectChild(int index);
    public int Add(Visual visual);
    public int IndexOf(Visual visual);
    public void Remove(Visual visual);
    private void InternalRemove(Visual visual);
    private UInt32 get_Version();
    private void IncrementVersion();
    private bool get_IsReadOnlyInternal();
    internal void SetReadOnly();
    public bool Contains(Visual visual);
    public void Clear();
    public void Insert(int index, Visual visual);
    public void RemoveAt(int index);
    public void RemoveRange(int index, int count);
    internal void Move(Visual visual, Visual destination);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public Enumerator GetEnumerator();
}
internal class System.Windows.Media.VisualDrawingContext : RenderDataDrawingContext {
    private Visual _ownerVisual;
    internal VisualDrawingContext(Visual ownerVisual);
    protected virtual void CloseCore(RenderData renderData);
}
[FlagsAttribute]
internal enum System.Windows.Media.VisualFlags : Enum {
    public UInt32 value__;
    public static VisualFlags None;
    public static VisualFlags IsSubtreeDirtyForPrecompute;
    public static VisualFlags ShouldPostRender;
    public static VisualFlags IsUIElement;
    public static VisualFlags IsLayoutSuspended;
    public static VisualFlags IsVisualChildrenIterationInProgress;
    public static VisualFlags Are3DContentBoundsValid;
    public static VisualFlags FindCommonAncestor;
    public static VisualFlags IsLayoutIslandRoot;
    public static VisualFlags UseLayoutRounding;
    public static VisualFlags VisibilityCache_Visible;
    public static VisualFlags VisibilityCache_TakesSpace;
    public static VisualFlags RegisteredForAncestorChanged;
    public static VisualFlags SubTreeHoldsAncestorChanged;
    public static VisualFlags NodeIsCyclicBrushRoot;
    public static VisualFlags NodeHasEffect;
    public static VisualFlags IsViewport3DVisual;
    public static VisualFlags ReentrancyFlag;
    public static VisualFlags HasChildren;
    public static VisualFlags BitmapEffectEmulationDisabled;
    public static VisualFlags DpiScaleFlag1;
    public static VisualFlags DpiScaleFlag2;
    public static VisualFlags TreeLevelBit0;
    public static VisualFlags TreeLevelBit1;
    public static VisualFlags TreeLevelBit2;
    public static VisualFlags TreeLevelBit3;
    public static VisualFlags TreeLevelBit4;
    public static VisualFlags TreeLevelBit5;
    public static VisualFlags TreeLevelBit6;
    public static VisualFlags TreeLevelBit7;
    public static VisualFlags TreeLevelBit8;
    public static VisualFlags TreeLevelBit9;
    public static VisualFlags TreeLevelBit10;
}
[FlagsAttribute]
internal enum System.Windows.Media.VisualProxyFlags : Enum {
    public UInt32 value__;
    public static VisualProxyFlags None;
    public static VisualProxyFlags IsSubtreeDirtyForRender;
    public static VisualProxyFlags IsTransformDirty;
    public static VisualProxyFlags IsClipDirty;
    public static VisualProxyFlags IsContentDirty;
    public static VisualProxyFlags IsOpacityDirty;
    public static VisualProxyFlags IsOpacityMaskDirty;
    public static VisualProxyFlags IsOffsetDirty;
    public static VisualProxyFlags IsClearTypeHintDirty;
    public static VisualProxyFlags IsGuidelineCollectionDirty;
    public static VisualProxyFlags IsEdgeModeDirty;
    public static VisualProxyFlags IsContentConnected;
    public static VisualProxyFlags IsContentNodeConnected;
    public static VisualProxyFlags IsConnectedToParent;
    public static VisualProxyFlags Viewport3DVisual_IsCameraDirty;
    public static VisualProxyFlags Viewport3DVisual_IsViewportDirty;
    public static VisualProxyFlags IsBitmapScalingModeDirty;
    public static VisualProxyFlags IsDeleteResourceInProgress;
    public static VisualProxyFlags IsChildrenZOrderDirty;
    public static VisualProxyFlags IsEffectDirty;
    public static VisualProxyFlags IsCacheModeDirty;
    public static VisualProxyFlags IsScrollableAreaClipDirty;
    public static VisualProxyFlags IsTextRenderingModeDirty;
    public static VisualProxyFlags IsTextHintingModeDirty;
}
public class System.Windows.Media.VisualTarget : CompositionTarget {
    private Channel _outOfBandChannel;
    private HostVisual _hostVisual;
    private bool _connected;
    public Matrix TransformToDevice { get; }
    public Matrix TransformFromDevice { get; }
    internal Channel OutOfBandChannel { get; }
    public VisualTarget(HostVisual hostVisual);
    private void BeginHosting();
    internal virtual void CreateUCEResources(Channel channel, Channel outOfBandChannel);
    public virtual Matrix get_TransformToDevice();
    public virtual Matrix get_TransformFromDevice();
    public virtual void Dispose();
    private void EndHosting();
    internal virtual void ReleaseUCEResources(Channel channel, Channel outOfBandChannel);
    internal Channel get_OutOfBandChannel();
}
public static class System.Windows.Media.VisualTreeHelper : object {
    private static void CheckVisualReferenceArgument(DependencyObject reference);
    [FriendAccessAllowedAttribute]
internal static bool IsVisualType(DependencyObject reference);
    public static int GetChildrenCount(DependencyObject reference);
    public static DependencyObject GetChild(DependencyObject reference, int childIndex);
    public static DpiScale GetDpi(Visual visual);
    public static void SetRootDpi(Visual visual, DpiScale dpiInfo);
    public static DependencyObject GetParent(DependencyObject reference);
    [FriendAccessAllowedAttribute]
internal static DependencyObject GetParentInternal(DependencyObject reference);
    internal static Visual GetContainingVisual2D(DependencyObject reference);
    internal static Visual3D GetContainingVisual3D(DependencyObject reference);
    internal static bool IsAncestorOf(DependencyObject reference, DependencyObject descendant);
    internal static bool IsAncestorOf(DependencyObject ancestor, DependencyObject descendant, Type stopType);
    internal static DependencyObject FindCommonAncestor(DependencyObject reference, DependencyObject otherVisual);
    public static Geometry GetClip(Visual reference);
    public static double GetOpacity(Visual reference);
    public static Brush GetOpacityMask(Visual reference);
    public static Vector GetOffset(Visual reference);
    public static Transform GetTransform(Visual reference);
    public static DoubleCollection GetXSnappingGuidelines(Visual reference);
    public static DoubleCollection GetYSnappingGuidelines(Visual reference);
    public static DrawingGroup GetDrawing(Visual reference);
    public static Rect GetContentBounds(Visual reference);
    public static Rect3D GetContentBounds(Visual3D reference);
    public static Rect GetDescendantBounds(Visual reference);
    public static Rect3D GetDescendantBounds(Visual3D reference);
    public static BitmapEffect GetBitmapEffect(Visual reference);
    public static BitmapEffectInput GetBitmapEffectInput(Visual reference);
    public static Effect GetEffect(Visual reference);
    public static CacheMode GetCacheMode(Visual reference);
    public static EdgeMode GetEdgeMode(Visual reference);
    public static HitTestResult HitTest(Visual reference, Point point);
    [FriendAccessAllowedAttribute]
internal static HitTestResult HitTest(Visual reference, Point point, bool include2DOn3D);
    public static void HitTest(Visual reference, HitTestFilterCallback filterCallback, HitTestResultCallback resultCallback, HitTestParameters hitTestParameters);
    public static void HitTest(Visual3D reference, HitTestFilterCallback filterCallback, HitTestResultCallback resultCallback, HitTestParameters3D hitTestParameters);
}
public enum System.Windows.Modifiability : Enum {
    public int value__;
    public static Modifiability Unmodifiable;
    public static Modifiability Modifiable;
    public static Modifiability Inherit;
}
internal class System.Windows.MouseCaptureWithinProperty : ReverseInheritProperty {
    internal virtual void FireNotifications(UIElement uie, ContentElement ce, UIElement3D uie3D, bool oldValue);
}
internal class System.Windows.MouseOverProperty : ReverseInheritProperty {
    internal virtual void FireNotifications(UIElement uie, ContentElement ce, UIElement3D uie3D, bool oldValue);
}
public static class System.Windows.Navigation.BaseUriHelper : object {
    private static string SOOBASE;
    private static Uri _siteOfOriginBaseUri;
    private static string APPBASE;
    private static Uri _packAppBaseUri;
    private static SecurityCriticalDataForSet`1<Uri> _baseUri;
    private static string _packageApplicationBaseUriEscaped;
    private static string _packageSiteOfOriginBaseUriEscaped;
    public static DependencyProperty BaseUriProperty;
    private static string COMPONENT;
    private static string VERSION;
    private static char COMPONENT_DELIMITER;
    private static Assembly _resourceAssembly;
    internal static Uri SiteOfOriginBaseUri { get; }
    internal static Uri PackAppBaseUri { get; }
    internal static Uri BaseUri { get; internal set; }
    internal static Assembly ResourceAssembly { get; internal set; }
    private static BaseUriHelper();
    public static Uri GetBaseUri(DependencyObject element);
    [FriendAccessAllowedAttribute]
internal static Uri get_SiteOfOriginBaseUri();
    [FriendAccessAllowedAttribute]
internal static Uri get_PackAppBaseUri();
    internal static bool IsPackApplicationUri(Uri uri);
    [FriendAccessAllowedAttribute]
internal static void GetAssemblyAndPartNameFromPackAppUri(Uri uri, Assembly& assembly, String& partName);
    [FriendAccessAllowedAttribute]
internal static Assembly GetLoadedAssembly(string assemblyName, string assemblyVersion, string assemblyKey);
    [FriendAccessAllowedAttribute]
internal static void GetAssemblyNameAndPart(Uri uri, String& partName, String& assemblyName, String& assemblyVersion, String& assemblyKey);
    [FriendAccessAllowedAttribute]
internal static bool IsComponentEntryAssembly(string component);
    [FriendAccessAllowedAttribute]
internal static Uri GetResolvedUri(Uri baseUri, Uri orgUri);
    [FriendAccessAllowedAttribute]
internal static Uri MakeRelativeToSiteOfOriginIfPossible(Uri sUri);
    [FriendAccessAllowedAttribute]
internal static Uri ConvertPackUriToAbsoluteExternallyVisibleUri(Uri packUri);
    [FriendAccessAllowedAttribute]
internal static Uri FixFileUri(Uri uri);
    [FriendAccessAllowedAttribute]
internal static Uri get_BaseUri();
    [FriendAccessAllowedAttribute]
internal static void set_BaseUri(Uri value);
    internal static Assembly get_ResourceAssembly();
    [FriendAccessAllowedAttribute]
internal static void set_ResourceAssembly(Assembly value);
    internal static Uri AppendAssemblyVersion(Uri uri, Assembly assemblyInfo);
    internal static Uri GetBaseUriCore(DependencyObject element);
    private static bool AssemblyMatchesKeyString(AssemblyName asmName, string assemblyKey);
    private static Byte[] ParseAssemblyKey(string assemblyKey);
}
internal class System.Windows.OleDragSource : object {
    private DependencyObject _dragSource;
    public OleDragSource(DependencyObject dragSource);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleDropSource.OleQueryContinueDrag(int escapeKey, int grfkeyState);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleDropSource.OleGiveFeedback(int effect);
    private void RaiseQueryContinueDragEvent(QueryContinueDragEventArgs args);
    private void RaiseGiveFeedbackEvent(GiveFeedbackEventArgs args);
    private void OnDefaultQueryContinueDrag(QueryContinueDragEventArgs e);
    private void OnDefaultGiveFeedback(GiveFeedbackEventArgs e);
}
internal class System.Windows.OleDropTarget : DispatcherObject {
    private IntPtr _windowHandle;
    private IDataObject _dataObject;
    private DependencyObject _lastTarget;
    public OleDropTarget(IntPtr handle);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleDropTarget.OleDragEnter(object data, int dragDropKeyStates, long point, Int32& effects);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleDropTarget.OleDragOver(int dragDropKeyStates, long point, Int32& effects);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleDropTarget.OleDragLeave();
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleDropTarget.OleDrop(object data, int dragDropKeyStates, long point, Int32& effects);
    private void RaiseDragEvent(RoutedEvent dragEvent, int dragDropKeyStates, Int32& effects, DependencyObject target, Point targetPoint);
    private void OnDefaultDragEnter(DragEventArgs e);
    private void OnDefaultDragOver(DragEventArgs e);
    private Point GetClientPointFromScreenPoint(long dragPoint, PresentationSource source);
    private DependencyObject GetCurrentTarget(long dragPoint, Point& targetPoint);
    private IDataObject GetDataObject(object data);
    private bool IsDataAvailable(IDataObject dataObject);
}
internal class System.Windows.OleServicesContext : object {
    private static LocalDataStoreSlot _threadDataSlot;
    internal static OleServicesContext CurrentOleServicesContext { get; }
    private static OleServicesContext();
    internal static OleServicesContext get_CurrentOleServicesContext();
    internal int OleSetClipboard(IDataObject dataObject);
    internal int OleGetClipboard(IDataObject& dataObject);
    internal int OleFlushClipboard();
    internal int OleIsCurrentClipboard(IDataObject dataObject);
    internal void OleDoDragDrop(IDataObject dataObject, IOleDropSource dropSource, int allowedEffects, Int32[] finalEffect);
    internal int OleRegisterDragDrop(HandleRef windowHandle, IOleDropTarget dropTarget);
    internal int OleRevokeDragDrop(HandleRef windowHandle);
    private void SetDispatcherThread();
    private void OnDispatcherShutdown(object sender, EventArgs args);
    private int OleInitialize();
    private int OleUninitialize();
}
public abstract class System.Windows.PresentationSource : DispatcherObject {
    private int _menuModeCount;
    [CompilerGeneratedAttribute]
private EventHandler ContentRendered;
    private static DependencyProperty RootSourceProperty;
    private static DependencyProperty CachedSourceProperty;
    private static DependencyProperty GetsSourceChangedEventProperty;
    private static RoutedEvent SourceChangedEvent;
    private static object _globalLock;
    private static WeakReferenceList _sources;
    private static WeakReferenceList _watchers;
    public CompositionTarget CompositionTarget { get; }
    public Visual RootVisual { get; public set; }
    public bool IsDisposed { get; }
    public static IEnumerable CurrentSources { get; }
    internal static IEnumerable CriticalCurrentSources { get; }
    private static PresentationSource();
    internal virtual IInputProvider GetInputProvider(Type inputDevice);
    public static PresentationSource FromVisual(Visual visual);
    public static PresentationSource FromDependencyObject(DependencyObject dependencyObject);
    public static void AddSourceChangedHandler(IInputElement element, SourceChangedEventHandler handler);
    public static void RemoveSourceChangedHandler(IInputElement e, SourceChangedEventHandler handler);
    [FriendAccessAllowedAttribute]
internal static void OnAncestorChanged(ContentElement ce);
    public CompositionTarget get_CompositionTarget();
    public abstract virtual Visual get_RootVisual();
    public abstract virtual void set_RootVisual(Visual value);
    internal void PushMenuMode();
    internal void PopMenuMode();
    internal virtual void OnEnterMenuMode();
    internal virtual void OnLeaveMenuMode();
    public abstract virtual bool get_IsDisposed();
    public static IEnumerable get_CurrentSources();
    [CompilerGeneratedAttribute]
public void add_ContentRendered(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ContentRendered(EventHandler value);
    protected abstract virtual CompositionTarget GetCompositionTargetCore();
    protected void RootChanged(Visual oldRoot, Visual newRoot);
    protected void AddSource();
    protected void RemoveSource();
    protected void ClearContentRenderedListeners();
    internal static void OnVisualAncestorChanged(DependencyObject uie, AncestorChangedEventArgs e);
    [FriendAccessAllowedAttribute]
internal static PresentationSource CriticalFromVisual(DependencyObject v);
    [FriendAccessAllowedAttribute]
internal static PresentationSource CriticalFromVisual(DependencyObject v, bool enable2DTo3DTransition);
    internal static object FireContentRendered(object arg);
    [FriendAccessAllowedAttribute]
internal static bool UnderSamePresentationSource(DependencyObject[] visuals);
    internal static IEnumerable get_CriticalCurrentSources();
    private static PresentationSource CriticalGetPresentationSourceFromElement(DependencyObject dObject, DependencyProperty dp);
    private static void AddElementToWatchList(DependencyObject element);
    private static void RemoveElementFromWatchList(DependencyObject element);
    private static PresentationSource FindSource(DependencyObject o);
    private static PresentationSource FindSource(DependencyObject o, bool enable2DTo3DTransition);
    private static bool UpdateSourceOfElement(DependencyObject doTarget, DependencyObject doAncestor, DependencyObject doOldParent);
}
public class System.Windows.QueryContinueDragEventArgs : RoutedEventArgs {
    private bool _escapePressed;
    private DragDropKeyStates _dragDropKeyStates;
    private DragAction _action;
    public bool EscapePressed { get; }
    public DragDropKeyStates KeyStates { get; }
    public DragAction Action { get; public set; }
    internal QueryContinueDragEventArgs(bool escapePressed, DragDropKeyStates dragDropKeyStates);
    public bool get_EscapePressed();
    public DragDropKeyStates get_KeyStates();
    public DragAction get_Action();
    public void set_Action(DragAction value);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.QueryContinueDragEventHandler : MulticastDelegate {
    public QueryContinueDragEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, QueryContinueDragEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, QueryContinueDragEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Windows.Readability : Enum {
    public int value__;
    public static Readability Unreadable;
    public static Readability Readable;
    public static Readability Inherit;
}
internal class System.Windows.ReadOnlyPropertyMetadata : PropertyMetadata {
    private GetReadOnlyValueCallback _getValueCallback;
    internal GetReadOnlyValueCallback GetReadOnlyValueCallback { get; }
    public ReadOnlyPropertyMetadata(object defaultValue, GetReadOnlyValueCallback getValueCallback, PropertyChangedCallback propertyChangedCallback);
    internal virtual GetReadOnlyValueCallback get_GetReadOnlyValueCallback();
}
[AttributeUsageAttribute("1")]
public class System.Windows.Resources.AssemblyAssociatedContentFileAttribute : Attribute {
    private string _path;
    public string RelativeContentFilePath { get; }
    public AssemblyAssociatedContentFileAttribute(string relativeContentFilePath);
    public string get_RelativeContentFilePath();
}
internal abstract class System.Windows.ReverseInheritProperty : object {
    protected DependencyPropertyKey FlagKey;
    protected CoreFlags FlagCache;
    protected CoreFlags FlagChanged;
    protected CoreFlags FlagOldOriginCache;
    protected CoreFlags FlagNewOriginCache;
    internal ReverseInheritProperty(DependencyPropertyKey flagKey, CoreFlags flagCache, CoreFlags flagChanged);
    internal ReverseInheritProperty(DependencyPropertyKey flagKey, CoreFlags flagCache, CoreFlags flagChanged, CoreFlags flagOldOriginCache, CoreFlags flagNewOriginCache);
    internal abstract virtual void FireNotifications(UIElement uie, ContentElement ce, UIElement3D uie3D, bool oldValue);
    internal void OnOriginValueChanged(DependencyObject oldOrigin, DependencyObject newOrigin, DeferredElementTreeState& oldTreeState);
    internal void OnOriginValueChanged(DependencyObject oldOrigin, DependencyObject newOrigin, IList`1<DependencyObject> otherOrigins, DeferredElementTreeState& oldTreeState, Action`2<DependencyObject, bool> originChangedAction);
    private void SetCacheFlagInAncestry(DependencyObject element, bool newValue, DeferredElementTreeState treeState, bool shortCircuit, bool setOriginCacheFlag);
    private void FirePropertyChangeInAncestry(DependencyObject element, bool oldValue, DeferredElementTreeState treeState, Action`2<DependencyObject, bool> originChangedAction);
    private static bool BlockReverseInheritance(UIElement uie, ContentElement ce, UIElement3D uie3D);
    private static void SetFlag(UIElement uie, ContentElement ce, UIElement3D uie3D, CoreFlags flag, bool value);
    private static bool IsFlagSet(UIElement uie, ContentElement ce, UIElement3D uie3D, CoreFlags flag);
    private static void CastElement(DependencyObject o, UIElement& uie, ContentElement& ce, UIElement3D& uie3D);
}
[TypeConverterAttribute("System.Windows.Markup.RoutedEventConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
[ValueSerializerAttribute("System.Windows.Markup.RoutedEventValueSerializer, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
public class System.Windows.RoutedEvent : object {
    private string _name;
    private RoutingStrategy _routingStrategy;
    private Type _handlerType;
    private Type _ownerType;
    private int _globalIndex;
    public string Name { get; }
    public RoutingStrategy RoutingStrategy { get; }
    public Type HandlerType { get; }
    public Type OwnerType { get; }
    internal int GlobalIndex { get; }
    internal RoutedEvent(string name, RoutingStrategy routingStrategy, Type handlerType, Type ownerType);
    public RoutedEvent AddOwner(Type ownerType);
    public string get_Name();
    public RoutingStrategy get_RoutingStrategy();
    public Type get_HandlerType();
    internal bool IsLegalHandler(Delegate handler);
    public Type get_OwnerType();
    public virtual string ToString();
    internal int get_GlobalIndex();
}
public class System.Windows.RoutedEventArgs : EventArgs {
    private RoutedEvent _routedEvent;
    private object _source;
    private object _originalSource;
    private BitVector32 _flags;
    private static int HandledIndex;
    private static int UserInitiatedIndex;
    private static int InvokingHandlerIndex;
    public RoutedEvent RoutedEvent { get; public set; }
    public bool Handled { get; public set; }
    public object Source { get; public set; }
    public object OriginalSource { get; }
    internal bool UserInitiated { get; }
    private bool InvokingHandler { get; private set; }
    public RoutedEventArgs(RoutedEvent routedEvent);
    public RoutedEventArgs(RoutedEvent routedEvent, object source);
    public RoutedEvent get_RoutedEvent();
    public void set_RoutedEvent(RoutedEvent value);
    internal void OverrideRoutedEvent(RoutedEvent newRoutedEvent);
    public bool get_Handled();
    public void set_Handled(bool value);
    public object get_Source();
    public void set_Source(object value);
    internal void OverrideSource(object source);
    public object get_OriginalSource();
    protected virtual void OnSetSource(object source);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
    internal void InvokeHandler(Delegate handler, object target);
    [FriendAccessAllowedAttribute]
internal bool get_UserInitiated();
    internal void MarkAsUserInitiated();
    internal void ClearUserInitiated();
    private bool get_InvokingHandler();
    private void set_InvokingHandler(bool value);
}
public class System.Windows.RoutedEventHandler : MulticastDelegate {
    public RoutedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, RoutedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, RoutedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.RoutedEventHandlerInfo : ValueType {
    private Delegate _handler;
    private bool _handledEventsToo;
    public Delegate Handler { get; }
    public bool InvokeHandledEventsToo { get; }
    internal RoutedEventHandlerInfo(Delegate handler, bool handledEventsToo);
    public Delegate get_Handler();
    public bool get_InvokeHandledEventsToo();
    internal void InvokeHandler(object target, RoutedEventArgs routedEventArgs);
    public virtual bool Equals(object obj);
    public bool Equals(RoutedEventHandlerInfo handlerInfo);
    public virtual int GetHashCode();
    public static bool op_Equality(RoutedEventHandlerInfo handlerInfo1, RoutedEventHandlerInfo handlerInfo2);
    public static bool op_Inequality(RoutedEventHandlerInfo handlerInfo1, RoutedEventHandlerInfo handlerInfo2);
}
internal class System.Windows.RoutedEventHandlerInfoList : object {
    internal RoutedEventHandlerInfo[] Handlers;
    internal RoutedEventHandlerInfoList Next;
    internal bool Contains(RoutedEventHandlerInfoList handlers);
}
internal class System.Windows.RouteItem : ValueType {
    private object _target;
    private RoutedEventHandlerInfo _routedEventHandlerInfo;
    internal object Target { get; }
    internal RouteItem(object target, RoutedEventHandlerInfo routedEventHandlerInfo);
    internal object get_Target();
    internal void InvokeHandler(RoutedEventArgs routedEventArgs);
    public virtual bool Equals(object o);
    public bool Equals(RouteItem routeItem);
    public virtual int GetHashCode();
    public static bool op_Equality(RouteItem routeItem1, RouteItem routeItem2);
    public static bool op_Inequality(RouteItem routeItem1, RouteItem routeItem2);
}
public enum System.Windows.RoutingStrategy : Enum {
    public int value__;
    public static RoutingStrategy Tunnel;
    public static RoutingStrategy Bubble;
    public static RoutingStrategy Direct;
}
public class System.Windows.SizeChangedInfo : object {
    private UIElement _element;
    private Size _previousSize;
    private bool _widthChanged;
    private bool _heightChanged;
    internal SizeChangedInfo Next;
    public Size PreviousSize { get; }
    public Size NewSize { get; }
    public bool WidthChanged { get; }
    public bool HeightChanged { get; }
    internal UIElement Element { get; }
    public SizeChangedInfo(UIElement element, Size previousSize, bool widthChanged, bool heightChanged);
    public Size get_PreviousSize();
    public Size get_NewSize();
    public bool get_WidthChanged();
    public bool get_HeightChanged();
    internal void Update(bool widthChanged, bool heightChanged);
    internal UIElement get_Element();
}
[LocalizabilityAttribute("0")]
public enum System.Windows.SizeToContent : Enum {
    public int value__;
    public static SizeToContent Manual;
    public static SizeToContent Width;
    public static SizeToContent Height;
    public static SizeToContent WidthAndHeight;
}
public class System.Windows.SourceChangedEventArgs : RoutedEventArgs {
    private SecurityCriticalData`1<PresentationSource> _oldSource;
    private SecurityCriticalData`1<PresentationSource> _newSource;
    private IInputElement _element;
    private IInputElement _oldParent;
    public PresentationSource OldSource { get; }
    public PresentationSource NewSource { get; }
    public IInputElement Element { get; }
    public IInputElement OldParent { get; }
    public SourceChangedEventArgs(PresentationSource oldSource, PresentationSource newSource);
    public SourceChangedEventArgs(PresentationSource oldSource, PresentationSource newSource, IInputElement element, IInputElement oldParent);
    public PresentationSource get_OldSource();
    public PresentationSource get_NewSource();
    public IInputElement get_Element();
    public IInputElement get_OldParent();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.SourceChangedEventHandler : MulticastDelegate {
    public SourceChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, SourceChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, SourceChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Windows.SourceItem : ValueType {
    private int _startIndex;
    private object _source;
    internal int StartIndex { get; }
    internal object Source { get; }
    internal SourceItem(int startIndex, object source);
    internal int get_StartIndex();
    internal object get_Source();
    public virtual bool Equals(object o);
    public bool Equals(SourceItem sourceItem);
    public virtual int GetHashCode();
    public static bool op_Equality(SourceItem sourceItem1, SourceItem sourceItem2);
    public static bool op_Inequality(SourceItem sourceItem1, SourceItem sourceItem2);
}
public class System.Windows.StrokeCollectionConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context);
}
internal class System.Windows.StylusCaptureWithinProperty : ReverseInheritProperty {
    internal virtual void FireNotifications(UIElement uie, ContentElement ce, UIElement3D uie3D, bool oldValue);
}
internal class System.Windows.StylusOverProperty : ReverseInheritProperty {
    internal virtual void FireNotifications(UIElement uie, ContentElement ce, UIElement3D uie3D, bool oldValue);
}
[LocalizabilityAttribute("0")]
public enum System.Windows.TextAlignment : Enum {
    public int value__;
    public static TextAlignment Left;
    public static TextAlignment Right;
    public static TextAlignment Center;
    public static TextAlignment Justify;
}
public enum System.Windows.TextDataFormat : Enum {
    public int value__;
    public static TextDataFormat Text;
    public static TextDataFormat UnicodeText;
    public static TextDataFormat Rtf;
    public static TextDataFormat Html;
    public static TextDataFormat CommaSeparatedValue;
    public static TextDataFormat Xaml;
}
[LocalizabilityAttribute("0")]
public class System.Windows.TextDecoration : Animatable {
    public static DependencyProperty PenProperty;
    public static DependencyProperty PenOffsetProperty;
    public static DependencyProperty PenOffsetUnitProperty;
    public static DependencyProperty PenThicknessUnitProperty;
    public static DependencyProperty LocationProperty;
    internal static double c_PenOffset;
    internal static TextDecorationUnit c_PenOffsetUnit;
    internal static TextDecorationUnit c_PenThicknessUnit;
    internal static TextDecorationLocation c_Location;
    public Pen Pen { get; public set; }
    public double PenOffset { get; public set; }
    public TextDecorationUnit PenOffsetUnit { get; public set; }
    public TextDecorationUnit PenThicknessUnit { get; public set; }
    public TextDecorationLocation Location { get; public set; }
    private static TextDecoration();
    public TextDecoration(TextDecorationLocation location, Pen pen, double penOffset, TextDecorationUnit penOffsetUnit, TextDecorationUnit penThicknessUnit);
    public TextDecoration Clone();
    public TextDecoration CloneCurrentValue();
    public Pen get_Pen();
    public void set_Pen(Pen value);
    public double get_PenOffset();
    public void set_PenOffset(double value);
    public TextDecorationUnit get_PenOffsetUnit();
    public void set_PenOffsetUnit(TextDecorationUnit value);
    public TextDecorationUnit get_PenThicknessUnit();
    public void set_PenThicknessUnit(TextDecorationUnit value);
    public TextDecorationLocation get_Location();
    public void set_Location(TextDecorationLocation value);
    protected virtual Freezable CreateInstanceCore();
    internal bool ValueEquals(TextDecoration textDecoration);
}
[LocalizabilityAttribute("0")]
[DefaultMemberAttribute("Item")]
[TypeConverterAttribute("System.Windows.TextDecorationCollectionConverter")]
public class System.Windows.TextDecorationCollection : Animatable {
    private static TextDecorationCollection s_empty;
    internal FrugalStructList`1<TextDecoration> _collection;
    internal UInt32 _version;
    public TextDecoration Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Windows.TextDecoration>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal static TextDecorationCollection Empty { get; }
    public TextDecorationCollection(int capacity);
    public TextDecorationCollection(IEnumerable`1<TextDecoration> collection);
    public TextDecorationCollection Clone();
    public TextDecorationCollection CloneCurrentValue();
    public sealed virtual void Add(TextDecoration value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(TextDecoration value);
    public sealed virtual int IndexOf(TextDecoration value);
    public sealed virtual void Insert(int index, TextDecoration value);
    public sealed virtual bool Remove(TextDecoration value);
    public sealed virtual void RemoveAt(int index);
    internal void RemoveAtWithoutFiringPublicEvents(int index);
    public sealed virtual TextDecoration get_Item(int index);
    public sealed virtual void set_Item(int index, TextDecoration value);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(TextDecoration[] array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Windows.TextDecoration>.get_IsReadOnly();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<TextDecoration> System.Collections.Generic.IEnumerable<System.Windows.TextDecoration>.GetEnumerator();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal static TextDecorationCollection get_Empty();
    internal TextDecoration Internal_GetItem(int i);
    internal virtual void OnInheritanceContextChangedCore(EventArgs args);
    private TextDecoration Cast(object value);
    private int AddHelper(TextDecoration value);
    internal int AddWithoutFiringPublicEvents(TextDecoration value);
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable source);
    protected virtual void CloneCurrentValueCore(Freezable source);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    protected virtual bool FreezeCore(bool isChecking);
    [FriendAccessAllowedAttribute]
internal bool ValueEquals(TextDecorationCollection textDecorations);
    [CLSCompliantAttribute("False")]
public void Add(IEnumerable`1<TextDecoration> textDecorations);
    public bool TryRemove(IEnumerable`1<TextDecoration> textDecorations, TextDecorationCollection& result);
}
public class System.Windows.TextDecorationCollectionConverter : TypeConverter {
    private static string None;
    private static char Separator;
    private static String[] TextDecorationNames;
    private static TextDecorationCollection[] PredefinedTextDecorations;
    private static TextDecorationCollectionConverter();
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object input);
    public static TextDecorationCollection ConvertFromString(string text);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    private static bool Match(string pattern, string input, int index);
    private static int AdvanceToNextNameStart(string input, int index);
    private static int AdvanceToNextNonWhiteSpace(string input, int index);
}
public enum System.Windows.TextDecorationLocation : Enum {
    public int value__;
    public static TextDecorationLocation Underline;
    public static TextDecorationLocation OverLine;
    public static TextDecorationLocation Strikethrough;
    public static TextDecorationLocation Baseline;
}
public static class System.Windows.TextDecorations : object {
    private static TextDecorationCollection underline;
    private static TextDecorationCollection strikethrough;
    private static TextDecorationCollection overLine;
    private static TextDecorationCollection baseline;
    public static TextDecorationCollection Underline { get; }
    public static TextDecorationCollection Strikethrough { get; }
    public static TextDecorationCollection OverLine { get; }
    public static TextDecorationCollection Baseline { get; }
    private static TextDecorations();
    public static TextDecorationCollection get_Underline();
    public static TextDecorationCollection get_Strikethrough();
    public static TextDecorationCollection get_OverLine();
    public static TextDecorationCollection get_Baseline();
}
public enum System.Windows.TextDecorationUnit : Enum {
    public int value__;
    public static TextDecorationUnit FontRecommended;
    public static TextDecorationUnit FontRenderingEmSize;
    public static TextDecorationUnit Pixel;
}
public enum System.Windows.TextMarkerStyle : Enum {
    public int value__;
    public static TextMarkerStyle None;
    public static TextMarkerStyle Disc;
    public static TextMarkerStyle Circle;
    public static TextMarkerStyle Square;
    public static TextMarkerStyle Box;
    public static TextMarkerStyle LowerRoman;
    public static TextMarkerStyle UpperRoman;
    public static TextMarkerStyle LowerLatin;
    public static TextMarkerStyle UpperLatin;
    public static TextMarkerStyle Decimal;
}
[LocalizabilityAttribute("0")]
public enum System.Windows.TextTrimming : Enum {
    public int value__;
    public static TextTrimming None;
    public static TextTrimming CharacterEllipsis;
    public static TextTrimming WordEllipsis;
}
[LocalizabilityAttribute("0")]
public enum System.Windows.TextWrapping : Enum {
    public int value__;
    public static TextWrapping WrapWithOverflow;
    public static TextWrapping NoWrap;
    public static TextWrapping Wrap;
}
[UidPropertyAttribute("Uid")]
public class System.Windows.UIElement : Visual {
    private static Type _typeofThis;
    public static RoutedEvent PreviewMouseDownEvent;
    public static RoutedEvent MouseDownEvent;
    public static RoutedEvent PreviewMouseUpEvent;
    public static RoutedEvent MouseUpEvent;
    public static RoutedEvent PreviewMouseLeftButtonDownEvent;
    public static RoutedEvent MouseLeftButtonDownEvent;
    public static RoutedEvent PreviewMouseLeftButtonUpEvent;
    public static RoutedEvent MouseLeftButtonUpEvent;
    public static RoutedEvent PreviewMouseRightButtonDownEvent;
    public static RoutedEvent MouseRightButtonDownEvent;
    public static RoutedEvent PreviewMouseRightButtonUpEvent;
    public static RoutedEvent MouseRightButtonUpEvent;
    public static RoutedEvent PreviewMouseMoveEvent;
    public static RoutedEvent MouseMoveEvent;
    public static RoutedEvent PreviewMouseWheelEvent;
    public static RoutedEvent MouseWheelEvent;
    public static RoutedEvent MouseEnterEvent;
    public static RoutedEvent MouseLeaveEvent;
    public static RoutedEvent GotMouseCaptureEvent;
    public static RoutedEvent LostMouseCaptureEvent;
    public static RoutedEvent QueryCursorEvent;
    public static RoutedEvent PreviewStylusDownEvent;
    public static RoutedEvent StylusDownEvent;
    public static RoutedEvent PreviewStylusUpEvent;
    public static RoutedEvent StylusUpEvent;
    public static RoutedEvent PreviewStylusMoveEvent;
    public static RoutedEvent StylusMoveEvent;
    public static RoutedEvent PreviewStylusInAirMoveEvent;
    public static RoutedEvent StylusInAirMoveEvent;
    public static RoutedEvent StylusEnterEvent;
    public static RoutedEvent StylusLeaveEvent;
    public static RoutedEvent PreviewStylusInRangeEvent;
    public static RoutedEvent StylusInRangeEvent;
    public static RoutedEvent PreviewStylusOutOfRangeEvent;
    public static RoutedEvent StylusOutOfRangeEvent;
    public static RoutedEvent PreviewStylusSystemGestureEvent;
    public static RoutedEvent StylusSystemGestureEvent;
    public static RoutedEvent GotStylusCaptureEvent;
    public static RoutedEvent LostStylusCaptureEvent;
    public static RoutedEvent StylusButtonDownEvent;
    public static RoutedEvent StylusButtonUpEvent;
    public static RoutedEvent PreviewStylusButtonDownEvent;
    public static RoutedEvent PreviewStylusButtonUpEvent;
    public static RoutedEvent PreviewKeyDownEvent;
    public static RoutedEvent KeyDownEvent;
    public static RoutedEvent PreviewKeyUpEvent;
    public static RoutedEvent KeyUpEvent;
    public static RoutedEvent PreviewGotKeyboardFocusEvent;
    public static RoutedEvent GotKeyboardFocusEvent;
    public static RoutedEvent PreviewLostKeyboardFocusEvent;
    public static RoutedEvent LostKeyboardFocusEvent;
    public static RoutedEvent PreviewTextInputEvent;
    public static RoutedEvent TextInputEvent;
    public static RoutedEvent PreviewQueryContinueDragEvent;
    public static RoutedEvent QueryContinueDragEvent;
    public static RoutedEvent PreviewGiveFeedbackEvent;
    public static RoutedEvent GiveFeedbackEvent;
    public static RoutedEvent PreviewDragEnterEvent;
    public static RoutedEvent DragEnterEvent;
    public static RoutedEvent PreviewDragOverEvent;
    public static RoutedEvent DragOverEvent;
    public static RoutedEvent PreviewDragLeaveEvent;
    public static RoutedEvent DragLeaveEvent;
    public static RoutedEvent PreviewDropEvent;
    public static RoutedEvent DropEvent;
    public static RoutedEvent PreviewTouchDownEvent;
    public static RoutedEvent TouchDownEvent;
    public static RoutedEvent PreviewTouchMoveEvent;
    public static RoutedEvent TouchMoveEvent;
    public static RoutedEvent PreviewTouchUpEvent;
    public static RoutedEvent TouchUpEvent;
    public static RoutedEvent GotTouchCaptureEvent;
    public static RoutedEvent LostTouchCaptureEvent;
    public static RoutedEvent TouchEnterEvent;
    public static RoutedEvent TouchLeaveEvent;
    internal static DependencyPropertyKey IsMouseDirectlyOverPropertyKey;
    public static DependencyProperty IsMouseDirectlyOverProperty;
    internal static EventPrivateKey IsMouseDirectlyOverChangedKey;
    internal static DependencyPropertyKey IsMouseOverPropertyKey;
    public static DependencyProperty IsMouseOverProperty;
    internal static DependencyPropertyKey IsStylusOverPropertyKey;
    public static DependencyProperty IsStylusOverProperty;
    internal static DependencyPropertyKey IsKeyboardFocusWithinPropertyKey;
    public static DependencyProperty IsKeyboardFocusWithinProperty;
    internal static EventPrivateKey IsKeyboardFocusWithinChangedKey;
    internal static DependencyPropertyKey IsMouseCapturedPropertyKey;
    public static DependencyProperty IsMouseCapturedProperty;
    internal static EventPrivateKey IsMouseCapturedChangedKey;
    internal static DependencyPropertyKey IsMouseCaptureWithinPropertyKey;
    public static DependencyProperty IsMouseCaptureWithinProperty;
    internal static EventPrivateKey IsMouseCaptureWithinChangedKey;
    internal static DependencyPropertyKey IsStylusDirectlyOverPropertyKey;
    public static DependencyProperty IsStylusDirectlyOverProperty;
    internal static EventPrivateKey IsStylusDirectlyOverChangedKey;
    internal static DependencyPropertyKey IsStylusCapturedPropertyKey;
    public static DependencyProperty IsStylusCapturedProperty;
    internal static EventPrivateKey IsStylusCapturedChangedKey;
    internal static DependencyPropertyKey IsStylusCaptureWithinPropertyKey;
    public static DependencyProperty IsStylusCaptureWithinProperty;
    internal static EventPrivateKey IsStylusCaptureWithinChangedKey;
    internal static DependencyPropertyKey IsKeyboardFocusedPropertyKey;
    public static DependencyProperty IsKeyboardFocusedProperty;
    internal static EventPrivateKey IsKeyboardFocusedChangedKey;
    internal static DependencyPropertyKey AreAnyTouchesDirectlyOverPropertyKey;
    public static DependencyProperty AreAnyTouchesDirectlyOverProperty;
    internal static DependencyPropertyKey AreAnyTouchesOverPropertyKey;
    public static DependencyProperty AreAnyTouchesOverProperty;
    internal static DependencyPropertyKey AreAnyTouchesCapturedPropertyKey;
    public static DependencyProperty AreAnyTouchesCapturedProperty;
    internal static DependencyPropertyKey AreAnyTouchesCapturedWithinPropertyKey;
    public static DependencyProperty AreAnyTouchesCapturedWithinProperty;
    private CoreFlags _flags;
    public static DependencyProperty AllowDropProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty RenderTransformProperty;
    public static DependencyProperty RenderTransformOriginProperty;
    public static DependencyProperty OpacityProperty;
    public static DependencyProperty OpacityMaskProperty;
    public static DependencyProperty BitmapEffectProperty;
    public static DependencyProperty EffectProperty;
    public static DependencyProperty BitmapEffectInputProperty;
    public static DependencyProperty CacheModeProperty;
    public static DependencyProperty UidProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty VisibilityProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty ClipToBoundsProperty;
    public static DependencyProperty ClipProperty;
    public static DependencyProperty SnapsToDevicePixelsProperty;
    public static RoutedEvent GotFocusEvent;
    public static RoutedEvent LostFocusEvent;
    internal static DependencyPropertyKey IsFocusedPropertyKey;
    public static DependencyProperty IsFocusedProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty IsEnabledProperty;
    internal static EventPrivateKey IsEnabledChangedKey;
    public static DependencyProperty IsHitTestVisibleProperty;
    internal static EventPrivateKey IsHitTestVisibleChangedKey;
    private static PropertyMetadata _isVisibleMetadata;
    internal static DependencyPropertyKey IsVisiblePropertyKey;
    public static DependencyProperty IsVisibleProperty;
    internal static EventPrivateKey IsVisibleChangedKey;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty FocusableProperty;
    internal static EventPrivateKey FocusableChangedKey;
    public static DependencyProperty IsManipulationEnabledProperty;
    public static RoutedEvent ManipulationStartingEvent;
    public static RoutedEvent ManipulationStartedEvent;
    public static RoutedEvent ManipulationDeltaEvent;
    public static RoutedEvent ManipulationInertiaStartingEvent;
    public static RoutedEvent ManipulationBoundaryFeedbackEvent;
    public static RoutedEvent ManipulationCompletedEvent;
    private Rect _finalRect;
    private Size _desiredSize;
    private Size _previousAvailableSize;
    private IDrawingContent _drawingContent;
    internal Request MeasureRequest;
    internal Request ArrangeRequest;
    private int _persistId;
    internal static List`1<double> DpiScaleXValues;
    internal static List`1<double> DpiScaleYValues;
    internal static object DpiLock;
    private static double _dpiScaleX;
    private static double _dpiScaleY;
    private static bool _setDpi;
    internal static UncommonField`1<EventHandlersStore> EventHandlersStoreField;
    internal static UncommonField`1<InputBindingCollection> InputBindingCollectionField;
    internal static UncommonField`1<CommandBindingCollection> CommandBindingCollectionField;
    private static UncommonField`1<object> LayoutUpdatedListItemsField;
    private static UncommonField`1<EventHandler> LayoutUpdatedHandlersField;
    private static UncommonField`1<StylusPlugInCollection> StylusPlugInsField;
    private static UncommonField`1<AutomationPeer> AutomationPeerField;
    private static UncommonField`1<WeakReference`1<UIElement>> _positionAndSizeOfSetController;
    private static UncommonField`1<bool> AutomationNotSupportedByDefaultField;
    internal SizeChangedInfo sizeChangedInfo;
    internal static FocusWithinProperty FocusWithinProperty;
    internal static MouseOverProperty MouseOverProperty;
    internal static MouseCaptureWithinProperty MouseCaptureWithinProperty;
    internal static StylusOverProperty StylusOverProperty;
    internal static StylusCaptureWithinProperty StylusCaptureWithinProperty;
    internal static TouchesOverProperty TouchesOverProperty;
    internal static TouchesCapturedWithinProperty TouchesCapturedWithinProperty;
    private Size _size;
    internal static int MAX_ELEMENTS_IN_ROUTE;
    public bool HasAnimatedProperties { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public InputBindingCollection InputBindings { get; }
    internal InputBindingCollection InputBindingsInternal { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public CommandBindingCollection CommandBindings { get; }
    internal CommandBindingCollection CommandBindingsInternal { get; }
    internal EventHandlersStore EventHandlersStore { get; }
    public bool AllowDrop { get; public set; }
    protected StylusPlugInCollection StylusPlugIns { get; }
    public Size DesiredSize { get; }
    internal Size PreviousConstraint { get; }
    public bool IsMeasureValid { get; }
    public bool IsArrangeValid { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public Size RenderSize { get; public set; }
    public Transform RenderTransform { get; public set; }
    public Point RenderTransformOrigin { get; public set; }
    public bool IsMouseDirectlyOver { get; }
    public bool IsMouseOver { get; }
    public bool IsStylusOver { get; }
    public bool IsKeyboardFocusWithin { get; }
    public bool IsMouseCaptured { get; }
    public bool IsMouseCaptureWithin { get; }
    public bool IsStylusDirectlyOver { get; }
    public bool IsStylusCaptured { get; }
    public bool IsStylusCaptureWithin { get; }
    public bool IsKeyboardFocused { get; }
    public bool IsInputMethodEnabled { get; }
    [LocalizabilityAttribute("0")]
public double Opacity { get; public set; }
    public Brush OpacityMask { get; public set; }
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
public BitmapEffect BitmapEffect { get; public set; }
    public Effect Effect { get; public set; }
    [ObsoleteAttribute("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")]
public BitmapEffectInput BitmapEffectInput { get; public set; }
    public CacheMode CacheMode { get; public set; }
    public string Uid { get; public set; }
    [LocalizabilityAttribute("0")]
public Visibility Visibility { get; public set; }
    public bool ClipToBounds { get; public set; }
    public Geometry Clip { get; public set; }
    public bool SnapsToDevicePixels { get; public set; }
    protected internal bool HasEffectiveKeyboardFocus { get; }
    public bool IsFocused { get; }
    public bool IsEnabled { get; public set; }
    protected bool IsEnabledCore { get; }
    public bool IsHitTestVisible { get; public set; }
    public bool IsVisible { get; }
    public bool Focusable { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
[ObsoleteAttribute("PersistId is an obsolete property and may be removed in a future release.  The value of this property is not defined.")]
public int PersistId { get; }
    internal Rect PreviousArrangeRect { get; }
    private Visibility VisibilityCache { get; private set; }
    [CustomCategoryAttribute("Touch_Category")]
public bool IsManipulationEnabled { get; public set; }
    public bool AreAnyTouchesOver { get; }
    public bool AreAnyTouchesDirectlyOver { get; }
    public bool AreAnyTouchesCapturedWithin { get; }
    public bool AreAnyTouchesCaptured { get; }
    public IEnumerable`1<TouchDevice> TouchesCaptured { get; }
    public IEnumerable`1<TouchDevice> TouchesCapturedWithin { get; }
    public IEnumerable`1<TouchDevice> TouchesOver { get; }
    public IEnumerable`1<TouchDevice> TouchesDirectlyOver { get; }
    internal UIElement PositionAndSizeOfSetController { get; internal set; }
    internal bool HasAutomationPeer { get; internal set; }
    private bool RenderingInvalidated { get; private set; }
    internal bool SnapsToDevicePixelsCache { get; internal set; }
    internal bool ClipToBoundsCache { get; internal set; }
    internal bool MeasureDirty { get; internal set; }
    internal bool ArrangeDirty { get; internal set; }
    internal bool MeasureInProgress { get; internal set; }
    internal bool ArrangeInProgress { get; internal set; }
    internal bool NeverMeasured { get; internal set; }
    internal bool NeverArranged { get; internal set; }
    internal bool MeasureDuringArrange { get; internal set; }
    internal bool AreTransformsClean { get; internal set; }
    private static UIElement();
    public sealed virtual void ApplyAnimationClock(DependencyProperty dp, AnimationClock clock);
    public sealed virtual void ApplyAnimationClock(DependencyProperty dp, AnimationClock clock, HandoffBehavior handoffBehavior);
    public sealed virtual void BeginAnimation(DependencyProperty dp, AnimationTimeline animation);
    public sealed virtual void BeginAnimation(DependencyProperty dp, AnimationTimeline animation, HandoffBehavior handoffBehavior);
    public sealed virtual bool get_HasAnimatedProperties();
    public sealed virtual object GetAnimationBaseValue(DependencyProperty dp);
    internal sealed virtual void EvaluateAnimatedValueCore(DependencyProperty dp, PropertyMetadata metadata, EffectiveValueEntry& entry);
    public InputBindingCollection get_InputBindings();
    internal InputBindingCollection get_InputBindingsInternal();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeInputBindings();
    public CommandBindingCollection get_CommandBindings();
    internal CommandBindingCollection get_CommandBindingsInternal();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeCommandBindings();
    internal virtual bool BuildRouteCore(EventRoute route, RoutedEventArgs args);
    internal void BuildRoute(EventRoute route, RoutedEventArgs args);
    public sealed virtual void RaiseEvent(RoutedEventArgs e);
    internal void RaiseEvent(RoutedEventArgs args, bool trusted);
    internal void RaiseTrustedEvent(RoutedEventArgs args);
    internal virtual object AdjustEventSource(RoutedEventArgs args);
    public sealed virtual void AddHandler(RoutedEvent routedEvent, Delegate handler);
    public void AddHandler(RoutedEvent routedEvent, Delegate handler, bool handledEventsToo);
    internal virtual void OnAddHandler(RoutedEvent routedEvent, Delegate handler);
    public sealed virtual void RemoveHandler(RoutedEvent routedEvent, Delegate handler);
    internal virtual void OnRemoveHandler(RoutedEvent routedEvent, Delegate handler);
    private void EventHandlersStoreAdd(EventPrivateKey key, Delegate handler);
    private void EventHandlersStoreRemove(EventPrivateKey key, Delegate handler);
    public void AddToEventRoute(EventRoute route, RoutedEventArgs e);
    internal virtual void AddToEventRouteCore(EventRoute route, RoutedEventArgs args);
    [FriendAccessAllowedAttribute]
internal EventHandlersStore get_EventHandlersStore();
    [FriendAccessAllowedAttribute]
internal void EnsureEventHandlersStore();
    internal virtual bool InvalidateAutomationAncestorsCore(Stack`1<DependencyObject> branchNodeStack, Boolean& continuePastVisualTree);
    internal static void RegisterEvents(Type type);
    private static void OnPreviewMouseDownThunk(object sender, MouseButtonEventArgs e);
    private static void OnMouseDownThunk(object sender, MouseButtonEventArgs e);
    private static void OnPreviewMouseUpThunk(object sender, MouseButtonEventArgs e);
    private static void OnMouseUpThunk(object sender, MouseButtonEventArgs e);
    private static void OnPreviewMouseLeftButtonDownThunk(object sender, MouseButtonEventArgs e);
    private static void OnMouseLeftButtonDownThunk(object sender, MouseButtonEventArgs e);
    private static void OnPreviewMouseLeftButtonUpThunk(object sender, MouseButtonEventArgs e);
    private static void OnMouseLeftButtonUpThunk(object sender, MouseButtonEventArgs e);
    private static void OnPreviewMouseRightButtonDownThunk(object sender, MouseButtonEventArgs e);
    private static void OnMouseRightButtonDownThunk(object sender, MouseButtonEventArgs e);
    private static void OnPreviewMouseRightButtonUpThunk(object sender, MouseButtonEventArgs e);
    private static void OnMouseRightButtonUpThunk(object sender, MouseButtonEventArgs e);
    private static void OnPreviewMouseMoveThunk(object sender, MouseEventArgs e);
    private static void OnMouseMoveThunk(object sender, MouseEventArgs e);
    private static void OnPreviewMouseWheelThunk(object sender, MouseWheelEventArgs e);
    private static void OnMouseWheelThunk(object sender, MouseWheelEventArgs e);
    private static void OnMouseEnterThunk(object sender, MouseEventArgs e);
    private static void OnMouseLeaveThunk(object sender, MouseEventArgs e);
    private static void OnGotMouseCaptureThunk(object sender, MouseEventArgs e);
    private static void OnLostMouseCaptureThunk(object sender, MouseEventArgs e);
    private static void OnQueryCursorThunk(object sender, QueryCursorEventArgs e);
    private static void OnPreviewStylusDownThunk(object sender, StylusDownEventArgs e);
    private static void OnStylusDownThunk(object sender, StylusDownEventArgs e);
    private static void OnPreviewStylusUpThunk(object sender, StylusEventArgs e);
    private static void OnStylusUpThunk(object sender, StylusEventArgs e);
    private static void OnPreviewStylusMoveThunk(object sender, StylusEventArgs e);
    private static void OnStylusMoveThunk(object sender, StylusEventArgs e);
    private static void OnPreviewStylusInAirMoveThunk(object sender, StylusEventArgs e);
    private static void OnStylusInAirMoveThunk(object sender, StylusEventArgs e);
    private static void OnStylusEnterThunk(object sender, StylusEventArgs e);
    private static void OnStylusLeaveThunk(object sender, StylusEventArgs e);
    private static void OnPreviewStylusInRangeThunk(object sender, StylusEventArgs e);
    private static void OnStylusInRangeThunk(object sender, StylusEventArgs e);
    private static void OnPreviewStylusOutOfRangeThunk(object sender, StylusEventArgs e);
    private static void OnStylusOutOfRangeThunk(object sender, StylusEventArgs e);
    private static void OnPreviewStylusSystemGestureThunk(object sender, StylusSystemGestureEventArgs e);
    private static void OnStylusSystemGestureThunk(object sender, StylusSystemGestureEventArgs e);
    private static void OnGotStylusCaptureThunk(object sender, StylusEventArgs e);
    private static void OnLostStylusCaptureThunk(object sender, StylusEventArgs e);
    private static void OnStylusButtonDownThunk(object sender, StylusButtonEventArgs e);
    private static void OnStylusButtonUpThunk(object sender, StylusButtonEventArgs e);
    private static void OnPreviewStylusButtonDownThunk(object sender, StylusButtonEventArgs e);
    private static void OnPreviewStylusButtonUpThunk(object sender, StylusButtonEventArgs e);
    private static void OnPreviewKeyDownThunk(object sender, KeyEventArgs e);
    private static void OnKeyDownThunk(object sender, KeyEventArgs e);
    private static void OnPreviewKeyUpThunk(object sender, KeyEventArgs e);
    private static void OnKeyUpThunk(object sender, KeyEventArgs e);
    private static void OnPreviewGotKeyboardFocusThunk(object sender, KeyboardFocusChangedEventArgs e);
    private static void OnGotKeyboardFocusThunk(object sender, KeyboardFocusChangedEventArgs e);
    private static void OnPreviewLostKeyboardFocusThunk(object sender, KeyboardFocusChangedEventArgs e);
    private static void OnLostKeyboardFocusThunk(object sender, KeyboardFocusChangedEventArgs e);
    private static void OnPreviewTextInputThunk(object sender, TextCompositionEventArgs e);
    private static void OnTextInputThunk(object sender, TextCompositionEventArgs e);
    private static void OnPreviewExecutedThunk(object sender, ExecutedRoutedEventArgs e);
    private static void OnExecutedThunk(object sender, ExecutedRoutedEventArgs e);
    private static void OnPreviewCanExecuteThunk(object sender, CanExecuteRoutedEventArgs e);
    private static void OnCanExecuteThunk(object sender, CanExecuteRoutedEventArgs e);
    private static void OnCommandDeviceThunk(object sender, CommandDeviceEventArgs e);
    private static void OnPreviewQueryContinueDragThunk(object sender, QueryContinueDragEventArgs e);
    private static void OnQueryContinueDragThunk(object sender, QueryContinueDragEventArgs e);
    private static void OnPreviewGiveFeedbackThunk(object sender, GiveFeedbackEventArgs e);
    private static void OnGiveFeedbackThunk(object sender, GiveFeedbackEventArgs e);
    private static void OnPreviewDragEnterThunk(object sender, DragEventArgs e);
    private static void OnDragEnterThunk(object sender, DragEventArgs e);
    private static void OnPreviewDragOverThunk(object sender, DragEventArgs e);
    private static void OnDragOverThunk(object sender, DragEventArgs e);
    private static void OnPreviewDragLeaveThunk(object sender, DragEventArgs e);
    private static void OnDragLeaveThunk(object sender, DragEventArgs e);
    private static void OnPreviewDropThunk(object sender, DragEventArgs e);
    private static void OnDropThunk(object sender, DragEventArgs e);
    private static void OnPreviewTouchDownThunk(object sender, TouchEventArgs e);
    private static void OnTouchDownThunk(object sender, TouchEventArgs e);
    private static void OnPreviewTouchMoveThunk(object sender, TouchEventArgs e);
    private static void OnTouchMoveThunk(object sender, TouchEventArgs e);
    private static void OnPreviewTouchUpThunk(object sender, TouchEventArgs e);
    private static void OnTouchUpThunk(object sender, TouchEventArgs e);
    private static void OnGotTouchCaptureThunk(object sender, TouchEventArgs e);
    private static void OnLostTouchCaptureThunk(object sender, TouchEventArgs e);
    private static void OnTouchEnterThunk(object sender, TouchEventArgs e);
    private static void OnTouchLeaveThunk(object sender, TouchEventArgs e);
    public void add_PreviewMouseDown(MouseButtonEventHandler value);
    public void remove_PreviewMouseDown(MouseButtonEventHandler value);
    protected virtual void OnPreviewMouseDown(MouseButtonEventArgs e);
    public void add_MouseDown(MouseButtonEventHandler value);
    public void remove_MouseDown(MouseButtonEventHandler value);
    protected virtual void OnMouseDown(MouseButtonEventArgs e);
    public void add_PreviewMouseUp(MouseButtonEventHandler value);
    public void remove_PreviewMouseUp(MouseButtonEventHandler value);
    protected virtual void OnPreviewMouseUp(MouseButtonEventArgs e);
    public void add_MouseUp(MouseButtonEventHandler value);
    public void remove_MouseUp(MouseButtonEventHandler value);
    protected virtual void OnMouseUp(MouseButtonEventArgs e);
    public sealed virtual void add_PreviewMouseLeftButtonDown(MouseButtonEventHandler value);
    public sealed virtual void remove_PreviewMouseLeftButtonDown(MouseButtonEventHandler value);
    protected virtual void OnPreviewMouseLeftButtonDown(MouseButtonEventArgs e);
    public sealed virtual void add_MouseLeftButtonDown(MouseButtonEventHandler value);
    public sealed virtual void remove_MouseLeftButtonDown(MouseButtonEventHandler value);
    protected virtual void OnMouseLeftButtonDown(MouseButtonEventArgs e);
    public sealed virtual void add_PreviewMouseLeftButtonUp(MouseButtonEventHandler value);
    public sealed virtual void remove_PreviewMouseLeftButtonUp(MouseButtonEventHandler value);
    protected virtual void OnPreviewMouseLeftButtonUp(MouseButtonEventArgs e);
    public sealed virtual void add_MouseLeftButtonUp(MouseButtonEventHandler value);
    public sealed virtual void remove_MouseLeftButtonUp(MouseButtonEventHandler value);
    protected virtual void OnMouseLeftButtonUp(MouseButtonEventArgs e);
    public sealed virtual void add_PreviewMouseRightButtonDown(MouseButtonEventHandler value);
    public sealed virtual void remove_PreviewMouseRightButtonDown(MouseButtonEventHandler value);
    protected virtual void OnPreviewMouseRightButtonDown(MouseButtonEventArgs e);
    public sealed virtual void add_MouseRightButtonDown(MouseButtonEventHandler value);
    public sealed virtual void remove_MouseRightButtonDown(MouseButtonEventHandler value);
    protected virtual void OnMouseRightButtonDown(MouseButtonEventArgs e);
    public sealed virtual void add_PreviewMouseRightButtonUp(MouseButtonEventHandler value);
    public sealed virtual void remove_PreviewMouseRightButtonUp(MouseButtonEventHandler value);
    protected virtual void OnPreviewMouseRightButtonUp(MouseButtonEventArgs e);
    public sealed virtual void add_MouseRightButtonUp(MouseButtonEventHandler value);
    public sealed virtual void remove_MouseRightButtonUp(MouseButtonEventHandler value);
    protected virtual void OnMouseRightButtonUp(MouseButtonEventArgs e);
    public sealed virtual void add_PreviewMouseMove(MouseEventHandler value);
    public sealed virtual void remove_PreviewMouseMove(MouseEventHandler value);
    protected virtual void OnPreviewMouseMove(MouseEventArgs e);
    public sealed virtual void add_MouseMove(MouseEventHandler value);
    public sealed virtual void remove_MouseMove(MouseEventHandler value);
    protected virtual void OnMouseMove(MouseEventArgs e);
    public sealed virtual void add_PreviewMouseWheel(MouseWheelEventHandler value);
    public sealed virtual void remove_PreviewMouseWheel(MouseWheelEventHandler value);
    protected virtual void OnPreviewMouseWheel(MouseWheelEventArgs e);
    public sealed virtual void add_MouseWheel(MouseWheelEventHandler value);
    public sealed virtual void remove_MouseWheel(MouseWheelEventHandler value);
    protected virtual void OnMouseWheel(MouseWheelEventArgs e);
    public sealed virtual void add_MouseEnter(MouseEventHandler value);
    public sealed virtual void remove_MouseEnter(MouseEventHandler value);
    protected virtual void OnMouseEnter(MouseEventArgs e);
    public sealed virtual void add_MouseLeave(MouseEventHandler value);
    public sealed virtual void remove_MouseLeave(MouseEventHandler value);
    protected virtual void OnMouseLeave(MouseEventArgs e);
    public sealed virtual void add_GotMouseCapture(MouseEventHandler value);
    public sealed virtual void remove_GotMouseCapture(MouseEventHandler value);
    protected virtual void OnGotMouseCapture(MouseEventArgs e);
    public sealed virtual void add_LostMouseCapture(MouseEventHandler value);
    public sealed virtual void remove_LostMouseCapture(MouseEventHandler value);
    protected virtual void OnLostMouseCapture(MouseEventArgs e);
    public void add_QueryCursor(QueryCursorEventHandler value);
    public void remove_QueryCursor(QueryCursorEventHandler value);
    protected virtual void OnQueryCursor(QueryCursorEventArgs e);
    public sealed virtual void add_PreviewStylusDown(StylusDownEventHandler value);
    public sealed virtual void remove_PreviewStylusDown(StylusDownEventHandler value);
    protected virtual void OnPreviewStylusDown(StylusDownEventArgs e);
    public sealed virtual void add_StylusDown(StylusDownEventHandler value);
    public sealed virtual void remove_StylusDown(StylusDownEventHandler value);
    protected virtual void OnStylusDown(StylusDownEventArgs e);
    public sealed virtual void add_PreviewStylusUp(StylusEventHandler value);
    public sealed virtual void remove_PreviewStylusUp(StylusEventHandler value);
    protected virtual void OnPreviewStylusUp(StylusEventArgs e);
    public sealed virtual void add_StylusUp(StylusEventHandler value);
    public sealed virtual void remove_StylusUp(StylusEventHandler value);
    protected virtual void OnStylusUp(StylusEventArgs e);
    public sealed virtual void add_PreviewStylusMove(StylusEventHandler value);
    public sealed virtual void remove_PreviewStylusMove(StylusEventHandler value);
    protected virtual void OnPreviewStylusMove(StylusEventArgs e);
    public sealed virtual void add_StylusMove(StylusEventHandler value);
    public sealed virtual void remove_StylusMove(StylusEventHandler value);
    protected virtual void OnStylusMove(StylusEventArgs e);
    public sealed virtual void add_PreviewStylusInAirMove(StylusEventHandler value);
    public sealed virtual void remove_PreviewStylusInAirMove(StylusEventHandler value);
    protected virtual void OnPreviewStylusInAirMove(StylusEventArgs e);
    public sealed virtual void add_StylusInAirMove(StylusEventHandler value);
    public sealed virtual void remove_StylusInAirMove(StylusEventHandler value);
    protected virtual void OnStylusInAirMove(StylusEventArgs e);
    public sealed virtual void add_StylusEnter(StylusEventHandler value);
    public sealed virtual void remove_StylusEnter(StylusEventHandler value);
    protected virtual void OnStylusEnter(StylusEventArgs e);
    public sealed virtual void add_StylusLeave(StylusEventHandler value);
    public sealed virtual void remove_StylusLeave(StylusEventHandler value);
    protected virtual void OnStylusLeave(StylusEventArgs e);
    public sealed virtual void add_PreviewStylusInRange(StylusEventHandler value);
    public sealed virtual void remove_PreviewStylusInRange(StylusEventHandler value);
    protected virtual void OnPreviewStylusInRange(StylusEventArgs e);
    public sealed virtual void add_StylusInRange(StylusEventHandler value);
    public sealed virtual void remove_StylusInRange(StylusEventHandler value);
    protected virtual void OnStylusInRange(StylusEventArgs e);
    public sealed virtual void add_PreviewStylusOutOfRange(StylusEventHandler value);
    public sealed virtual void remove_PreviewStylusOutOfRange(StylusEventHandler value);
    protected virtual void OnPreviewStylusOutOfRange(StylusEventArgs e);
    public sealed virtual void add_StylusOutOfRange(StylusEventHandler value);
    public sealed virtual void remove_StylusOutOfRange(StylusEventHandler value);
    protected virtual void OnStylusOutOfRange(StylusEventArgs e);
    public sealed virtual void add_PreviewStylusSystemGesture(StylusSystemGestureEventHandler value);
    public sealed virtual void remove_PreviewStylusSystemGesture(StylusSystemGestureEventHandler value);
    protected virtual void OnPreviewStylusSystemGesture(StylusSystemGestureEventArgs e);
    public sealed virtual void add_StylusSystemGesture(StylusSystemGestureEventHandler value);
    public sealed virtual void remove_StylusSystemGesture(StylusSystemGestureEventHandler value);
    protected virtual void OnStylusSystemGesture(StylusSystemGestureEventArgs e);
    public sealed virtual void add_GotStylusCapture(StylusEventHandler value);
    public sealed virtual void remove_GotStylusCapture(StylusEventHandler value);
    protected virtual void OnGotStylusCapture(StylusEventArgs e);
    public sealed virtual void add_LostStylusCapture(StylusEventHandler value);
    public sealed virtual void remove_LostStylusCapture(StylusEventHandler value);
    protected virtual void OnLostStylusCapture(StylusEventArgs e);
    public sealed virtual void add_StylusButtonDown(StylusButtonEventHandler value);
    public sealed virtual void remove_StylusButtonDown(StylusButtonEventHandler value);
    protected virtual void OnStylusButtonDown(StylusButtonEventArgs e);
    public sealed virtual void add_StylusButtonUp(StylusButtonEventHandler value);
    public sealed virtual void remove_StylusButtonUp(StylusButtonEventHandler value);
    protected virtual void OnStylusButtonUp(StylusButtonEventArgs e);
    public sealed virtual void add_PreviewStylusButtonDown(StylusButtonEventHandler value);
    public sealed virtual void remove_PreviewStylusButtonDown(StylusButtonEventHandler value);
    protected virtual void OnPreviewStylusButtonDown(StylusButtonEventArgs e);
    public sealed virtual void add_PreviewStylusButtonUp(StylusButtonEventHandler value);
    public sealed virtual void remove_PreviewStylusButtonUp(StylusButtonEventHandler value);
    protected virtual void OnPreviewStylusButtonUp(StylusButtonEventArgs e);
    public sealed virtual void add_PreviewKeyDown(KeyEventHandler value);
    public sealed virtual void remove_PreviewKeyDown(KeyEventHandler value);
    protected virtual void OnPreviewKeyDown(KeyEventArgs e);
    public sealed virtual void add_KeyDown(KeyEventHandler value);
    public sealed virtual void remove_KeyDown(KeyEventHandler value);
    protected virtual void OnKeyDown(KeyEventArgs e);
    public sealed virtual void add_PreviewKeyUp(KeyEventHandler value);
    public sealed virtual void remove_PreviewKeyUp(KeyEventHandler value);
    protected virtual void OnPreviewKeyUp(KeyEventArgs e);
    public sealed virtual void add_KeyUp(KeyEventHandler value);
    public sealed virtual void remove_KeyUp(KeyEventHandler value);
    protected virtual void OnKeyUp(KeyEventArgs e);
    public sealed virtual void add_PreviewGotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    public sealed virtual void remove_PreviewGotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    protected virtual void OnPreviewGotKeyboardFocus(KeyboardFocusChangedEventArgs e);
    public sealed virtual void add_GotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    public sealed virtual void remove_GotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    protected virtual void OnGotKeyboardFocus(KeyboardFocusChangedEventArgs e);
    public sealed virtual void add_PreviewLostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    public sealed virtual void remove_PreviewLostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    protected virtual void OnPreviewLostKeyboardFocus(KeyboardFocusChangedEventArgs e);
    public sealed virtual void add_LostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    public sealed virtual void remove_LostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    protected virtual void OnLostKeyboardFocus(KeyboardFocusChangedEventArgs e);
    public sealed virtual void add_PreviewTextInput(TextCompositionEventHandler value);
    public sealed virtual void remove_PreviewTextInput(TextCompositionEventHandler value);
    protected virtual void OnPreviewTextInput(TextCompositionEventArgs e);
    public sealed virtual void add_TextInput(TextCompositionEventHandler value);
    public sealed virtual void remove_TextInput(TextCompositionEventHandler value);
    protected virtual void OnTextInput(TextCompositionEventArgs e);
    public void add_PreviewQueryContinueDrag(QueryContinueDragEventHandler value);
    public void remove_PreviewQueryContinueDrag(QueryContinueDragEventHandler value);
    protected virtual void OnPreviewQueryContinueDrag(QueryContinueDragEventArgs e);
    public void add_QueryContinueDrag(QueryContinueDragEventHandler value);
    public void remove_QueryContinueDrag(QueryContinueDragEventHandler value);
    protected virtual void OnQueryContinueDrag(QueryContinueDragEventArgs e);
    public void add_PreviewGiveFeedback(GiveFeedbackEventHandler value);
    public void remove_PreviewGiveFeedback(GiveFeedbackEventHandler value);
    protected virtual void OnPreviewGiveFeedback(GiveFeedbackEventArgs e);
    public void add_GiveFeedback(GiveFeedbackEventHandler value);
    public void remove_GiveFeedback(GiveFeedbackEventHandler value);
    protected virtual void OnGiveFeedback(GiveFeedbackEventArgs e);
    public void add_PreviewDragEnter(DragEventHandler value);
    public void remove_PreviewDragEnter(DragEventHandler value);
    protected virtual void OnPreviewDragEnter(DragEventArgs e);
    public void add_DragEnter(DragEventHandler value);
    public void remove_DragEnter(DragEventHandler value);
    protected virtual void OnDragEnter(DragEventArgs e);
    public void add_PreviewDragOver(DragEventHandler value);
    public void remove_PreviewDragOver(DragEventHandler value);
    protected virtual void OnPreviewDragOver(DragEventArgs e);
    public void add_DragOver(DragEventHandler value);
    public void remove_DragOver(DragEventHandler value);
    protected virtual void OnDragOver(DragEventArgs e);
    public void add_PreviewDragLeave(DragEventHandler value);
    public void remove_PreviewDragLeave(DragEventHandler value);
    protected virtual void OnPreviewDragLeave(DragEventArgs e);
    public void add_DragLeave(DragEventHandler value);
    public void remove_DragLeave(DragEventHandler value);
    protected virtual void OnDragLeave(DragEventArgs e);
    public void add_PreviewDrop(DragEventHandler value);
    public void remove_PreviewDrop(DragEventHandler value);
    protected virtual void OnPreviewDrop(DragEventArgs e);
    public void add_Drop(DragEventHandler value);
    public void remove_Drop(DragEventHandler value);
    protected virtual void OnDrop(DragEventArgs e);
    public void add_PreviewTouchDown(EventHandler`1<TouchEventArgs> value);
    public void remove_PreviewTouchDown(EventHandler`1<TouchEventArgs> value);
    protected virtual void OnPreviewTouchDown(TouchEventArgs e);
    public void add_TouchDown(EventHandler`1<TouchEventArgs> value);
    public void remove_TouchDown(EventHandler`1<TouchEventArgs> value);
    protected virtual void OnTouchDown(TouchEventArgs e);
    public void add_PreviewTouchMove(EventHandler`1<TouchEventArgs> value);
    public void remove_PreviewTouchMove(EventHandler`1<TouchEventArgs> value);
    protected virtual void OnPreviewTouchMove(TouchEventArgs e);
    public void add_TouchMove(EventHandler`1<TouchEventArgs> value);
    public void remove_TouchMove(EventHandler`1<TouchEventArgs> value);
    protected virtual void OnTouchMove(TouchEventArgs e);
    public void add_PreviewTouchUp(EventHandler`1<TouchEventArgs> value);
    public void remove_PreviewTouchUp(EventHandler`1<TouchEventArgs> value);
    protected virtual void OnPreviewTouchUp(TouchEventArgs e);
    public void add_TouchUp(EventHandler`1<TouchEventArgs> value);
    public void remove_TouchUp(EventHandler`1<TouchEventArgs> value);
    protected virtual void OnTouchUp(TouchEventArgs e);
    public void add_GotTouchCapture(EventHandler`1<TouchEventArgs> value);
    public void remove_GotTouchCapture(EventHandler`1<TouchEventArgs> value);
    protected virtual void OnGotTouchCapture(TouchEventArgs e);
    public void add_LostTouchCapture(EventHandler`1<TouchEventArgs> value);
    public void remove_LostTouchCapture(EventHandler`1<TouchEventArgs> value);
    protected virtual void OnLostTouchCapture(TouchEventArgs e);
    public void add_TouchEnter(EventHandler`1<TouchEventArgs> value);
    public void remove_TouchEnter(EventHandler`1<TouchEventArgs> value);
    protected virtual void OnTouchEnter(TouchEventArgs e);
    public void add_TouchLeave(EventHandler`1<TouchEventArgs> value);
    public void remove_TouchLeave(EventHandler`1<TouchEventArgs> value);
    protected virtual void OnTouchLeave(TouchEventArgs e);
    private static void IsMouseDirectlyOver_Changed(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public void add_IsMouseDirectlyOverChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsMouseDirectlyOverChanged(DependencyPropertyChangedEventHandler value);
    protected virtual void OnIsMouseDirectlyOverChanged(DependencyPropertyChangedEventArgs e);
    private void RaiseIsMouseDirectlyOverChanged(DependencyPropertyChangedEventArgs args);
    public void add_IsKeyboardFocusWithinChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsKeyboardFocusWithinChanged(DependencyPropertyChangedEventHandler value);
    protected virtual void OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs e);
    internal void RaiseIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs args);
    private static void IsMouseCaptured_Changed(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public void add_IsMouseCapturedChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsMouseCapturedChanged(DependencyPropertyChangedEventHandler value);
    protected virtual void OnIsMouseCapturedChanged(DependencyPropertyChangedEventArgs e);
    private void RaiseIsMouseCapturedChanged(DependencyPropertyChangedEventArgs args);
    public void add_IsMouseCaptureWithinChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsMouseCaptureWithinChanged(DependencyPropertyChangedEventHandler value);
    protected virtual void OnIsMouseCaptureWithinChanged(DependencyPropertyChangedEventArgs e);
    internal void RaiseIsMouseCaptureWithinChanged(DependencyPropertyChangedEventArgs args);
    private static void IsStylusDirectlyOver_Changed(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public void add_IsStylusDirectlyOverChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsStylusDirectlyOverChanged(DependencyPropertyChangedEventHandler value);
    protected virtual void OnIsStylusDirectlyOverChanged(DependencyPropertyChangedEventArgs e);
    private void RaiseIsStylusDirectlyOverChanged(DependencyPropertyChangedEventArgs args);
    private static void IsStylusCaptured_Changed(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public void add_IsStylusCapturedChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsStylusCapturedChanged(DependencyPropertyChangedEventHandler value);
    protected virtual void OnIsStylusCapturedChanged(DependencyPropertyChangedEventArgs e);
    private void RaiseIsStylusCapturedChanged(DependencyPropertyChangedEventArgs args);
    public void add_IsStylusCaptureWithinChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsStylusCaptureWithinChanged(DependencyPropertyChangedEventHandler value);
    protected virtual void OnIsStylusCaptureWithinChanged(DependencyPropertyChangedEventArgs e);
    internal void RaiseIsStylusCaptureWithinChanged(DependencyPropertyChangedEventArgs args);
    private static void IsKeyboardFocused_Changed(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public void add_IsKeyboardFocusedChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsKeyboardFocusedChanged(DependencyPropertyChangedEventHandler value);
    protected virtual void OnIsKeyboardFocusedChanged(DependencyPropertyChangedEventArgs e);
    private void RaiseIsKeyboardFocusedChanged(DependencyPropertyChangedEventArgs args);
    internal bool ReadFlag(CoreFlags field);
    internal void WriteFlag(CoreFlags field, bool value);
    private void Initialize();
    public bool get_AllowDrop();
    public void set_AllowDrop(bool value);
    protected StylusPlugInCollection get_StylusPlugIns();
    public Size get_DesiredSize();
    internal Size get_PreviousConstraint();
    private bool IsRenderable();
    internal void InvalidateMeasureInternal();
    internal void InvalidateArrangeInternal();
    public bool get_IsMeasureValid();
    public bool get_IsArrangeValid();
    public void InvalidateMeasure();
    public void InvalidateArrange();
    public void InvalidateVisual();
    protected virtual void OnChildDesiredSizeChanged(UIElement child);
    public void add_LayoutUpdated(EventHandler value);
    public void remove_LayoutUpdated(EventHandler value);
    private void addLayoutUpdatedHandler(EventHandler handler, ListItem item);
    private ListItem getLayoutUpdatedHandler(EventHandler d);
    private void removeLayoutUpdatedHandler(EventHandler d);
    internal static void PropagateSuspendLayout(Visual v);
    internal static void PropagateResumeLayout(Visual parent, Visual v);
    public void Measure(Size availableSize);
    internal void GetUIParentOrICH(UIElement& uiParent, IContentHost& ich);
    internal UIElement GetUIParentWithinLayoutIsland();
    public void Arrange(Rect finalRect);
    protected virtual void OnRender(DrawingContext drawingContext);
    private void updatePixelSnappingGuidelines();
    private bool markForSizeChangedIfNeeded(Size oldSize, Size newSize);
    internal static Size RoundLayoutSize(Size size, double dpiScaleX, double dpiScaleY);
    internal static double RoundLayoutValue(double value, double dpiScale);
    internal static Rect RoundLayoutRect(Rect rect, double dpiScaleX, double dpiScaleY);
    internal static DpiScale EnsureDpiScale();
    protected internal virtual void OnRenderSizeChanged(SizeChangedInfo info);
    protected virtual Size MeasureCore(Size availableSize);
    protected virtual void ArrangeCore(Rect finalRect);
    public Size get_RenderSize();
    public void set_RenderSize(Size value);
    internal virtual Rect GetHitTestBounds();
    public Transform get_RenderTransform();
    public void set_RenderTransform(Transform value);
    private static void RenderTransform_Changed(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static bool IsRenderTransformOriginValid(object value);
    public Point get_RenderTransformOrigin();
    public void set_RenderTransformOrigin(Point value);
    private static void RenderTransformOrigin_Changed(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected internal virtual void OnVisualParentChanged(DependencyObject oldParent);
    private void OnVisualAncestorChanged_ForceInherit(object sender, AncestorChangedEventArgs e);
    internal void OnVisualAncestorChanged(object sender, AncestorChangedEventArgs e);
    internal DependencyObject GetUIParent();
    internal DependencyObject GetUIParent(bool continuePastVisualTree);
    internal DependencyObject GetUIParentNo3DTraversal();
    protected internal virtual DependencyObject GetUIParentCore();
    public void UpdateLayout();
    internal static void BuildRouteHelper(DependencyObject e, EventRoute route, RoutedEventArgs args);
    internal void AddSynchronizedInputPreOpportunityHandler(EventRoute route, RoutedEventArgs args);
    internal virtual void AddSynchronizedInputPreOpportunityHandlerCore(EventRoute route, RoutedEventArgs args);
    internal void AddSynchronizedInputPostOpportunityHandler(EventRoute route, RoutedEventArgs args);
    internal void SynchronizedInputPreOpportunityHandler(object sender, RoutedEventArgs args);
    internal void SynchronizedInputPostOpportunityHandler(object sender, RoutedEventArgs args);
    internal bool StartListeningSynchronizedInput(SynchronizedInputType inputType);
    internal void CancelSynchronizedInput();
    [FriendAccessAllowedAttribute]
internal static void AddHandler(DependencyObject d, RoutedEvent routedEvent, Delegate handler);
    [FriendAccessAllowedAttribute]
internal static void RemoveHandler(DependencyObject d, RoutedEvent routedEvent, Delegate handler);
    internal virtual void OnPresentationSourceChanged(bool attached);
    public Point TranslatePoint(Point point, UIElement relativeTo);
    public IInputElement InputHitTest(Point point);
    internal void InputHitTest(Point pt, IInputElement& enabledHit, IInputElement& rawHit);
    internal void InputHitTest(Point pt, IInputElement& enabledHit, IInputElement& rawHit, HitTestResult& rawHitResult);
    private HitTestFilterBehavior InputHitTestFilterCallback(DependencyObject currentNode);
    private static RoutedEvent CrackMouseButtonEvent(MouseButtonEventArgs e);
    private static void CrackMouseButtonEventAndReRaiseEvent(DependencyObject sender, MouseButtonEventArgs e);
    private static void ReRaiseEventAs(DependencyObject sender, RoutedEventArgs args, RoutedEvent newEvent);
    internal static void RaiseEventImpl(DependencyObject sender, RoutedEventArgs args);
    public sealed virtual bool get_IsMouseDirectlyOver();
    private bool IsMouseDirectlyOver_ComputeValue();
    [FriendAccessAllowedAttribute]
internal void SynchronizeReverseInheritPropertyFlags(DependencyObject oldParent, bool isCoreParent);
    internal virtual bool BlockReverseInheritance();
    public sealed virtual bool get_IsMouseOver();
    public sealed virtual bool get_IsStylusOver();
    public sealed virtual bool get_IsKeyboardFocusWithin();
    public sealed virtual bool get_IsMouseCaptured();
    public sealed virtual bool CaptureMouse();
    public sealed virtual void ReleaseMouseCapture();
    public bool get_IsMouseCaptureWithin();
    public sealed virtual bool get_IsStylusDirectlyOver();
    private bool IsStylusDirectlyOver_ComputeValue();
    public sealed virtual bool get_IsStylusCaptured();
    public sealed virtual bool CaptureStylus();
    public sealed virtual void ReleaseStylusCapture();
    public bool get_IsStylusCaptureWithin();
    public sealed virtual bool get_IsKeyboardFocused();
    private bool IsKeyboardFocused_ComputeValue();
    public sealed virtual bool Focus();
    public virtual bool MoveFocus(TraversalRequest request);
    public virtual DependencyObject PredictFocus(FocusNavigationDirection direction);
    protected virtual void OnAccessKey(AccessKeyEventArgs e);
    public bool get_IsInputMethodEnabled();
    private static void Opacity_Changed(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public double get_Opacity();
    public void set_Opacity(double value);
    private void pushOpacity();
    private static void OpacityMask_Changed(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Brush get_OpacityMask();
    public void set_OpacityMask(Brush value);
    private void pushOpacityMask();
    private static void OnBitmapEffectChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public BitmapEffect get_BitmapEffect();
    public void set_BitmapEffect(BitmapEffect value);
    private void pushBitmapEffect();
    private static void OnEffectChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Effect get_Effect();
    public void set_Effect(Effect value);
    private void pushEffect();
    private static void OnBitmapEffectInputChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public BitmapEffectInput get_BitmapEffectInput();
    public void set_BitmapEffectInput(BitmapEffectInput value);
    private void pushBitmapEffectInput(BitmapEffectInput newValue);
    private static void EdgeMode_Changed(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void pushEdgeMode();
    private static void BitmapScalingMode_Changed(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void pushBitmapScalingMode();
    private static void ClearTypeHint_Changed(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void pushClearTypeHint();
    private static void TextHintingMode_Changed(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void pushTextHintingMode();
    private static void OnCacheModeChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public CacheMode get_CacheMode();
    public void set_CacheMode(CacheMode value);
    private void pushCacheMode();
    private void pushVisualEffects();
    public string get_Uid();
    public void set_Uid(string value);
    private static void OnVisibilityChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static bool ValidateVisibility(object o);
    public Visibility get_Visibility();
    public void set_Visibility(Visibility value);
    private void switchVisibilityIfNeeded(Visibility visibility);
    private void ensureVisible();
    private void ensureInvisible(bool collapsed);
    private void signalDesiredSizeChange();
    private void ensureClip(Size layoutSlotSize);
    protected virtual HitTestResult HitTestCore(PointHitTestParameters hitTestParameters);
    protected virtual GeometryHitTestResult HitTestCore(GeometryHitTestParameters hitTestParameters);
    [FriendAccessAllowedAttribute]
internal DrawingContext RenderOpen();
    internal virtual void RenderClose(IDrawingContent newContent);
    internal virtual void FreeContent(Channel channel);
    internal virtual Rect GetContentBounds();
    internal void WalkContent(DrawingContextWalker walker);
    internal virtual void RenderContent(RenderContext ctx, bool isOnChannel);
    internal virtual DrawingGroup GetDrawing();
    protected virtual Geometry GetLayoutClip(Size layoutSlotSize);
    private static void ClipToBounds_Changed(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public bool get_ClipToBounds();
    public void set_ClipToBounds(bool value);
    private static void Clip_Changed(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Geometry get_Clip();
    public void set_Clip(Geometry value);
    private static void SnapsToDevicePixels_Changed(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public bool get_SnapsToDevicePixels();
    public void set_SnapsToDevicePixels(bool value);
    protected internal virtual bool get_HasEffectiveKeyboardFocus();
    internal void InvokeAccessKey(AccessKeyEventArgs e);
    public void add_GotFocus(RoutedEventHandler value);
    public void remove_GotFocus(RoutedEventHandler value);
    public void add_LostFocus(RoutedEventHandler value);
    public void remove_LostFocus(RoutedEventHandler value);
    private static void IsFocused_Changed(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnGotFocus(RoutedEventArgs e);
    protected virtual void OnLostFocus(RoutedEventArgs e);
    public bool get_IsFocused();
    public sealed virtual bool get_IsEnabled();
    public void set_IsEnabled(bool value);
    public void add_IsEnabledChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsEnabledChanged(DependencyPropertyChangedEventHandler value);
    protected virtual bool get_IsEnabledCore();
    private static object CoerceIsEnabled(DependencyObject d, object value);
    private static void OnIsEnabledChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public bool get_IsHitTestVisible();
    public void set_IsHitTestVisible(bool value);
    public void add_IsHitTestVisibleChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsHitTestVisibleChanged(DependencyPropertyChangedEventHandler value);
    private static object CoerceIsHitTestVisible(DependencyObject d, object value);
    private static void OnIsHitTestVisibleChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public bool get_IsVisible();
    private static object GetIsVisible(DependencyObject d, BaseValueSourceInternal& source);
    public void add_IsVisibleChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsVisibleChanged(DependencyPropertyChangedEventHandler value);
    internal void UpdateIsVisibleCache();
    private static void OnIsVisibleChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public sealed virtual bool get_Focusable();
    public sealed virtual void set_Focusable(bool value);
    public void add_FocusableChanged(DependencyPropertyChangedEventHandler value);
    public void remove_FocusableChanged(DependencyPropertyChangedEventHandler value);
    private static void OnFocusableChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    internal virtual AutomationPeer OnCreateAutomationPeerInternal();
    internal AutomationPeer CreateAutomationPeer();
    internal AutomationPeer GetAutomationPeer();
    internal AutomationPeer CreateGenericRootAutomationPeer();
    public int get_PersistId();
    [FriendAccessAllowedAttribute]
internal void SetPersistId(int value);
    private void RaiseDependencyPropertyChanged(EventPrivateKey key, DependencyPropertyChangedEventArgs args);
    [FriendAccessAllowedAttribute]
internal Rect get_PreviousArrangeRect();
    private Visibility get_VisibilityCache();
    private void set_VisibilityCache(Visibility value);
    internal static void SynchronizeForceInheritProperties(UIElement uiElement, ContentElement contentElement, UIElement3D uiElement3D, DependencyObject parent);
    internal static void InvalidateForceInheritPropertyOnChildren(Visual v, DependencyProperty property);
    public bool get_IsManipulationEnabled();
    public void set_IsManipulationEnabled(bool value);
    private static void OnIsManipulationEnabledChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void CoerceStylusProperties();
    private static bool IsDefaultValue(DependencyObject dependencyObject, DependencyProperty dependencyProperty);
    public void add_ManipulationStarting(EventHandler`1<ManipulationStartingEventArgs> value);
    public void remove_ManipulationStarting(EventHandler`1<ManipulationStartingEventArgs> value);
    private static void OnManipulationStartingThunk(object sender, ManipulationStartingEventArgs e);
    protected virtual void OnManipulationStarting(ManipulationStartingEventArgs e);
    public void add_ManipulationStarted(EventHandler`1<ManipulationStartedEventArgs> value);
    public void remove_ManipulationStarted(EventHandler`1<ManipulationStartedEventArgs> value);
    private static void OnManipulationStartedThunk(object sender, ManipulationStartedEventArgs e);
    protected virtual void OnManipulationStarted(ManipulationStartedEventArgs e);
    public void add_ManipulationDelta(EventHandler`1<ManipulationDeltaEventArgs> value);
    public void remove_ManipulationDelta(EventHandler`1<ManipulationDeltaEventArgs> value);
    private static void OnManipulationDeltaThunk(object sender, ManipulationDeltaEventArgs e);
    protected virtual void OnManipulationDelta(ManipulationDeltaEventArgs e);
    public void add_ManipulationInertiaStarting(EventHandler`1<ManipulationInertiaStartingEventArgs> value);
    public void remove_ManipulationInertiaStarting(EventHandler`1<ManipulationInertiaStartingEventArgs> value);
    private static void OnManipulationInertiaStartingThunk(object sender, ManipulationInertiaStartingEventArgs e);
    protected virtual void OnManipulationInertiaStarting(ManipulationInertiaStartingEventArgs e);
    public void add_ManipulationBoundaryFeedback(EventHandler`1<ManipulationBoundaryFeedbackEventArgs> value);
    public void remove_ManipulationBoundaryFeedback(EventHandler`1<ManipulationBoundaryFeedbackEventArgs> value);
    private static void OnManipulationBoundaryFeedbackThunk(object sender, ManipulationBoundaryFeedbackEventArgs e);
    protected virtual void OnManipulationBoundaryFeedback(ManipulationBoundaryFeedbackEventArgs e);
    public void add_ManipulationCompleted(EventHandler`1<ManipulationCompletedEventArgs> value);
    public void remove_ManipulationCompleted(EventHandler`1<ManipulationCompletedEventArgs> value);
    private static void OnManipulationCompletedThunk(object sender, ManipulationCompletedEventArgs e);
    protected virtual void OnManipulationCompleted(ManipulationCompletedEventArgs e);
    public bool get_AreAnyTouchesOver();
    public bool get_AreAnyTouchesDirectlyOver();
    public bool get_AreAnyTouchesCapturedWithin();
    public bool get_AreAnyTouchesCaptured();
    public bool CaptureTouch(TouchDevice touchDevice);
    public bool ReleaseTouchCapture(TouchDevice touchDevice);
    public void ReleaseAllTouchCaptures();
    public IEnumerable`1<TouchDevice> get_TouchesCaptured();
    public IEnumerable`1<TouchDevice> get_TouchesCapturedWithin();
    public IEnumerable`1<TouchDevice> get_TouchesOver();
    public IEnumerable`1<TouchDevice> get_TouchesDirectlyOver();
    internal UIElement get_PositionAndSizeOfSetController();
    internal void set_PositionAndSizeOfSetController(UIElement value);
    internal bool get_HasAutomationPeer();
    internal void set_HasAutomationPeer(bool value);
    private bool get_RenderingInvalidated();
    private void set_RenderingInvalidated(bool value);
    internal bool get_SnapsToDevicePixelsCache();
    internal void set_SnapsToDevicePixelsCache(bool value);
    internal bool get_ClipToBoundsCache();
    internal void set_ClipToBoundsCache(bool value);
    internal bool get_MeasureDirty();
    internal void set_MeasureDirty(bool value);
    internal bool get_ArrangeDirty();
    internal void set_ArrangeDirty(bool value);
    internal bool get_MeasureInProgress();
    internal void set_MeasureInProgress(bool value);
    internal bool get_ArrangeInProgress();
    internal void set_ArrangeInProgress(bool value);
    internal bool get_NeverMeasured();
    internal void set_NeverMeasured(bool value);
    internal bool get_NeverArranged();
    internal void set_NeverArranged(bool value);
    internal bool get_MeasureDuringArrange();
    internal void set_MeasureDuringArrange(bool value);
    internal bool get_AreTransformsClean();
    internal void set_AreTransformsClean(bool value);
}
public abstract class System.Windows.UIElement3D : Visual3D {
    private static Type _typeofThis;
    public static RoutedEvent PreviewMouseDownEvent;
    public static RoutedEvent MouseDownEvent;
    public static RoutedEvent PreviewMouseUpEvent;
    public static RoutedEvent MouseUpEvent;
    public static RoutedEvent PreviewMouseLeftButtonDownEvent;
    public static RoutedEvent MouseLeftButtonDownEvent;
    public static RoutedEvent PreviewMouseLeftButtonUpEvent;
    public static RoutedEvent MouseLeftButtonUpEvent;
    public static RoutedEvent PreviewMouseRightButtonDownEvent;
    public static RoutedEvent MouseRightButtonDownEvent;
    public static RoutedEvent PreviewMouseRightButtonUpEvent;
    public static RoutedEvent MouseRightButtonUpEvent;
    public static RoutedEvent PreviewMouseMoveEvent;
    public static RoutedEvent MouseMoveEvent;
    public static RoutedEvent PreviewMouseWheelEvent;
    public static RoutedEvent MouseWheelEvent;
    public static RoutedEvent MouseEnterEvent;
    public static RoutedEvent MouseLeaveEvent;
    public static RoutedEvent GotMouseCaptureEvent;
    public static RoutedEvent LostMouseCaptureEvent;
    public static RoutedEvent QueryCursorEvent;
    public static RoutedEvent PreviewStylusDownEvent;
    public static RoutedEvent StylusDownEvent;
    public static RoutedEvent PreviewStylusUpEvent;
    public static RoutedEvent StylusUpEvent;
    public static RoutedEvent PreviewStylusMoveEvent;
    public static RoutedEvent StylusMoveEvent;
    public static RoutedEvent PreviewStylusInAirMoveEvent;
    public static RoutedEvent StylusInAirMoveEvent;
    public static RoutedEvent StylusEnterEvent;
    public static RoutedEvent StylusLeaveEvent;
    public static RoutedEvent PreviewStylusInRangeEvent;
    public static RoutedEvent StylusInRangeEvent;
    public static RoutedEvent PreviewStylusOutOfRangeEvent;
    public static RoutedEvent StylusOutOfRangeEvent;
    public static RoutedEvent PreviewStylusSystemGestureEvent;
    public static RoutedEvent StylusSystemGestureEvent;
    public static RoutedEvent GotStylusCaptureEvent;
    public static RoutedEvent LostStylusCaptureEvent;
    public static RoutedEvent StylusButtonDownEvent;
    public static RoutedEvent StylusButtonUpEvent;
    public static RoutedEvent PreviewStylusButtonDownEvent;
    public static RoutedEvent PreviewStylusButtonUpEvent;
    public static RoutedEvent PreviewKeyDownEvent;
    public static RoutedEvent KeyDownEvent;
    public static RoutedEvent PreviewKeyUpEvent;
    public static RoutedEvent KeyUpEvent;
    public static RoutedEvent PreviewGotKeyboardFocusEvent;
    public static RoutedEvent GotKeyboardFocusEvent;
    public static RoutedEvent PreviewLostKeyboardFocusEvent;
    public static RoutedEvent LostKeyboardFocusEvent;
    public static RoutedEvent PreviewTextInputEvent;
    public static RoutedEvent TextInputEvent;
    public static RoutedEvent PreviewQueryContinueDragEvent;
    public static RoutedEvent QueryContinueDragEvent;
    public static RoutedEvent PreviewGiveFeedbackEvent;
    public static RoutedEvent GiveFeedbackEvent;
    public static RoutedEvent PreviewDragEnterEvent;
    public static RoutedEvent DragEnterEvent;
    public static RoutedEvent PreviewDragOverEvent;
    public static RoutedEvent DragOverEvent;
    public static RoutedEvent PreviewDragLeaveEvent;
    public static RoutedEvent DragLeaveEvent;
    public static RoutedEvent PreviewDropEvent;
    public static RoutedEvent DropEvent;
    public static RoutedEvent PreviewTouchDownEvent;
    public static RoutedEvent TouchDownEvent;
    public static RoutedEvent PreviewTouchMoveEvent;
    public static RoutedEvent TouchMoveEvent;
    public static RoutedEvent PreviewTouchUpEvent;
    public static RoutedEvent TouchUpEvent;
    public static RoutedEvent GotTouchCaptureEvent;
    public static RoutedEvent LostTouchCaptureEvent;
    public static RoutedEvent TouchEnterEvent;
    public static RoutedEvent TouchLeaveEvent;
    public static DependencyProperty IsMouseDirectlyOverProperty;
    public static DependencyProperty IsMouseOverProperty;
    public static DependencyProperty IsStylusOverProperty;
    public static DependencyProperty IsKeyboardFocusWithinProperty;
    public static DependencyProperty IsMouseCapturedProperty;
    public static DependencyProperty IsMouseCaptureWithinProperty;
    public static DependencyProperty IsStylusDirectlyOverProperty;
    public static DependencyProperty IsStylusCapturedProperty;
    public static DependencyProperty IsStylusCaptureWithinProperty;
    public static DependencyProperty IsKeyboardFocusedProperty;
    public static DependencyProperty AreAnyTouchesDirectlyOverProperty;
    public static DependencyProperty AreAnyTouchesOverProperty;
    public static DependencyProperty AreAnyTouchesCapturedProperty;
    public static DependencyProperty AreAnyTouchesCapturedWithinProperty;
    private CoreFlags _flags;
    public static DependencyProperty AllowDropProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty VisibilityProperty;
    public static RoutedEvent GotFocusEvent;
    public static RoutedEvent LostFocusEvent;
    public static DependencyProperty IsFocusedProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty IsEnabledProperty;
    public static DependencyProperty IsHitTestVisibleProperty;
    internal static EventPrivateKey IsHitTestVisibleChangedKey;
    private static PropertyMetadata _isVisibleMetadata;
    public static DependencyProperty IsVisibleProperty;
    internal static EventPrivateKey IsVisibleChangedKey;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty FocusableProperty;
    private Visual3DCollection _children;
    private bool _renderRequestPosted;
    internal static UncommonField`1<EventHandlersStore> EventHandlersStoreField;
    internal static UncommonField`1<InputBindingCollection> InputBindingCollectionField;
    internal static UncommonField`1<CommandBindingCollection> CommandBindingCollectionField;
    private static UncommonField`1<AutomationPeer> AutomationPeerField;
    [DesignerSerializationVisibilityAttribute("2")]
public InputBindingCollection InputBindings { get; }
    internal InputBindingCollection InputBindingsInternal { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public CommandBindingCollection CommandBindings { get; }
    internal CommandBindingCollection CommandBindingsInternal { get; }
    internal EventHandlersStore EventHandlersStore { get; }
    public bool AllowDrop { get; public set; }
    public bool IsMouseDirectlyOver { get; }
    public bool IsMouseOver { get; }
    public bool IsStylusOver { get; }
    public bool IsKeyboardFocusWithin { get; }
    public bool IsMouseCaptured { get; }
    public bool IsMouseCaptureWithin { get; }
    public bool IsStylusDirectlyOver { get; }
    public bool IsStylusCaptured { get; }
    public bool IsStylusCaptureWithin { get; }
    public bool IsKeyboardFocused { get; }
    public bool IsInputMethodEnabled { get; }
    [LocalizabilityAttribute("0")]
public Visibility Visibility { get; public set; }
    public bool IsFocused { get; }
    public bool IsEnabled { get; public set; }
    protected bool IsEnabledCore { get; }
    public bool IsHitTestVisible { get; public set; }
    public bool IsVisible { get; }
    public bool Focusable { get; public set; }
    private Visibility VisibilityCache { get; private set; }
    public bool AreAnyTouchesOver { get; }
    public bool AreAnyTouchesDirectlyOver { get; }
    public bool AreAnyTouchesCapturedWithin { get; }
    public bool AreAnyTouchesCaptured { get; }
    public IEnumerable`1<TouchDevice> TouchesCaptured { get; }
    public IEnumerable`1<TouchDevice> TouchesCapturedWithin { get; }
    public IEnumerable`1<TouchDevice> TouchesOver { get; }
    public IEnumerable`1<TouchDevice> TouchesDirectlyOver { get; }
    internal bool HasAutomationPeer { get; internal set; }
    private static UIElement3D();
    public InputBindingCollection get_InputBindings();
    internal InputBindingCollection get_InputBindingsInternal();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeInputBindings();
    public CommandBindingCollection get_CommandBindings();
    internal CommandBindingCollection get_CommandBindingsInternal();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeCommandBindings();
    internal virtual bool BuildRouteCore(EventRoute route, RoutedEventArgs args);
    internal void BuildRoute(EventRoute route, RoutedEventArgs args);
    public sealed virtual void RaiseEvent(RoutedEventArgs e);
    internal void RaiseEvent(RoutedEventArgs args, bool trusted);
    internal void RaiseTrustedEvent(RoutedEventArgs args);
    internal virtual object AdjustEventSource(RoutedEventArgs args);
    public sealed virtual void AddHandler(RoutedEvent routedEvent, Delegate handler);
    public void AddHandler(RoutedEvent routedEvent, Delegate handler, bool handledEventsToo);
    internal virtual void OnAddHandler(RoutedEvent routedEvent, Delegate handler);
    public sealed virtual void RemoveHandler(RoutedEvent routedEvent, Delegate handler);
    internal virtual void OnRemoveHandler(RoutedEvent routedEvent, Delegate handler);
    private void EventHandlersStoreAdd(EventPrivateKey key, Delegate handler);
    private void EventHandlersStoreRemove(EventPrivateKey key, Delegate handler);
    public void AddToEventRoute(EventRoute route, RoutedEventArgs e);
    internal virtual void AddToEventRouteCore(EventRoute route, RoutedEventArgs args);
    [FriendAccessAllowedAttribute]
internal EventHandlersStore get_EventHandlersStore();
    [FriendAccessAllowedAttribute]
internal void EnsureEventHandlersStore();
    internal virtual bool InvalidateAutomationAncestorsCore(Stack`1<DependencyObject> branchNodeStack, Boolean& continuePastVisualTree);
    public void add_PreviewMouseDown(MouseButtonEventHandler value);
    public void remove_PreviewMouseDown(MouseButtonEventHandler value);
    protected internal virtual void OnPreviewMouseDown(MouseButtonEventArgs e);
    public void add_MouseDown(MouseButtonEventHandler value);
    public void remove_MouseDown(MouseButtonEventHandler value);
    protected internal virtual void OnMouseDown(MouseButtonEventArgs e);
    public void add_PreviewMouseUp(MouseButtonEventHandler value);
    public void remove_PreviewMouseUp(MouseButtonEventHandler value);
    protected internal virtual void OnPreviewMouseUp(MouseButtonEventArgs e);
    public void add_MouseUp(MouseButtonEventHandler value);
    public void remove_MouseUp(MouseButtonEventHandler value);
    protected internal virtual void OnMouseUp(MouseButtonEventArgs e);
    public sealed virtual void add_PreviewMouseLeftButtonDown(MouseButtonEventHandler value);
    public sealed virtual void remove_PreviewMouseLeftButtonDown(MouseButtonEventHandler value);
    protected internal virtual void OnPreviewMouseLeftButtonDown(MouseButtonEventArgs e);
    public sealed virtual void add_MouseLeftButtonDown(MouseButtonEventHandler value);
    public sealed virtual void remove_MouseLeftButtonDown(MouseButtonEventHandler value);
    protected internal virtual void OnMouseLeftButtonDown(MouseButtonEventArgs e);
    public sealed virtual void add_PreviewMouseLeftButtonUp(MouseButtonEventHandler value);
    public sealed virtual void remove_PreviewMouseLeftButtonUp(MouseButtonEventHandler value);
    protected internal virtual void OnPreviewMouseLeftButtonUp(MouseButtonEventArgs e);
    public sealed virtual void add_MouseLeftButtonUp(MouseButtonEventHandler value);
    public sealed virtual void remove_MouseLeftButtonUp(MouseButtonEventHandler value);
    protected internal virtual void OnMouseLeftButtonUp(MouseButtonEventArgs e);
    public sealed virtual void add_PreviewMouseRightButtonDown(MouseButtonEventHandler value);
    public sealed virtual void remove_PreviewMouseRightButtonDown(MouseButtonEventHandler value);
    protected internal virtual void OnPreviewMouseRightButtonDown(MouseButtonEventArgs e);
    public sealed virtual void add_MouseRightButtonDown(MouseButtonEventHandler value);
    public sealed virtual void remove_MouseRightButtonDown(MouseButtonEventHandler value);
    protected internal virtual void OnMouseRightButtonDown(MouseButtonEventArgs e);
    public sealed virtual void add_PreviewMouseRightButtonUp(MouseButtonEventHandler value);
    public sealed virtual void remove_PreviewMouseRightButtonUp(MouseButtonEventHandler value);
    protected internal virtual void OnPreviewMouseRightButtonUp(MouseButtonEventArgs e);
    public sealed virtual void add_MouseRightButtonUp(MouseButtonEventHandler value);
    public sealed virtual void remove_MouseRightButtonUp(MouseButtonEventHandler value);
    protected internal virtual void OnMouseRightButtonUp(MouseButtonEventArgs e);
    public sealed virtual void add_PreviewMouseMove(MouseEventHandler value);
    public sealed virtual void remove_PreviewMouseMove(MouseEventHandler value);
    protected internal virtual void OnPreviewMouseMove(MouseEventArgs e);
    public sealed virtual void add_MouseMove(MouseEventHandler value);
    public sealed virtual void remove_MouseMove(MouseEventHandler value);
    protected internal virtual void OnMouseMove(MouseEventArgs e);
    public sealed virtual void add_PreviewMouseWheel(MouseWheelEventHandler value);
    public sealed virtual void remove_PreviewMouseWheel(MouseWheelEventHandler value);
    protected internal virtual void OnPreviewMouseWheel(MouseWheelEventArgs e);
    public sealed virtual void add_MouseWheel(MouseWheelEventHandler value);
    public sealed virtual void remove_MouseWheel(MouseWheelEventHandler value);
    protected internal virtual void OnMouseWheel(MouseWheelEventArgs e);
    public sealed virtual void add_MouseEnter(MouseEventHandler value);
    public sealed virtual void remove_MouseEnter(MouseEventHandler value);
    protected internal virtual void OnMouseEnter(MouseEventArgs e);
    public sealed virtual void add_MouseLeave(MouseEventHandler value);
    public sealed virtual void remove_MouseLeave(MouseEventHandler value);
    protected internal virtual void OnMouseLeave(MouseEventArgs e);
    public sealed virtual void add_GotMouseCapture(MouseEventHandler value);
    public sealed virtual void remove_GotMouseCapture(MouseEventHandler value);
    protected internal virtual void OnGotMouseCapture(MouseEventArgs e);
    public sealed virtual void add_LostMouseCapture(MouseEventHandler value);
    public sealed virtual void remove_LostMouseCapture(MouseEventHandler value);
    protected internal virtual void OnLostMouseCapture(MouseEventArgs e);
    public void add_QueryCursor(QueryCursorEventHandler value);
    public void remove_QueryCursor(QueryCursorEventHandler value);
    protected internal virtual void OnQueryCursor(QueryCursorEventArgs e);
    public sealed virtual void add_PreviewStylusDown(StylusDownEventHandler value);
    public sealed virtual void remove_PreviewStylusDown(StylusDownEventHandler value);
    protected internal virtual void OnPreviewStylusDown(StylusDownEventArgs e);
    public sealed virtual void add_StylusDown(StylusDownEventHandler value);
    public sealed virtual void remove_StylusDown(StylusDownEventHandler value);
    protected internal virtual void OnStylusDown(StylusDownEventArgs e);
    public sealed virtual void add_PreviewStylusUp(StylusEventHandler value);
    public sealed virtual void remove_PreviewStylusUp(StylusEventHandler value);
    protected internal virtual void OnPreviewStylusUp(StylusEventArgs e);
    public sealed virtual void add_StylusUp(StylusEventHandler value);
    public sealed virtual void remove_StylusUp(StylusEventHandler value);
    protected internal virtual void OnStylusUp(StylusEventArgs e);
    public sealed virtual void add_PreviewStylusMove(StylusEventHandler value);
    public sealed virtual void remove_PreviewStylusMove(StylusEventHandler value);
    protected internal virtual void OnPreviewStylusMove(StylusEventArgs e);
    public sealed virtual void add_StylusMove(StylusEventHandler value);
    public sealed virtual void remove_StylusMove(StylusEventHandler value);
    protected internal virtual void OnStylusMove(StylusEventArgs e);
    public sealed virtual void add_PreviewStylusInAirMove(StylusEventHandler value);
    public sealed virtual void remove_PreviewStylusInAirMove(StylusEventHandler value);
    protected internal virtual void OnPreviewStylusInAirMove(StylusEventArgs e);
    public sealed virtual void add_StylusInAirMove(StylusEventHandler value);
    public sealed virtual void remove_StylusInAirMove(StylusEventHandler value);
    protected internal virtual void OnStylusInAirMove(StylusEventArgs e);
    public sealed virtual void add_StylusEnter(StylusEventHandler value);
    public sealed virtual void remove_StylusEnter(StylusEventHandler value);
    protected internal virtual void OnStylusEnter(StylusEventArgs e);
    public sealed virtual void add_StylusLeave(StylusEventHandler value);
    public sealed virtual void remove_StylusLeave(StylusEventHandler value);
    protected internal virtual void OnStylusLeave(StylusEventArgs e);
    public sealed virtual void add_PreviewStylusInRange(StylusEventHandler value);
    public sealed virtual void remove_PreviewStylusInRange(StylusEventHandler value);
    protected internal virtual void OnPreviewStylusInRange(StylusEventArgs e);
    public sealed virtual void add_StylusInRange(StylusEventHandler value);
    public sealed virtual void remove_StylusInRange(StylusEventHandler value);
    protected internal virtual void OnStylusInRange(StylusEventArgs e);
    public sealed virtual void add_PreviewStylusOutOfRange(StylusEventHandler value);
    public sealed virtual void remove_PreviewStylusOutOfRange(StylusEventHandler value);
    protected internal virtual void OnPreviewStylusOutOfRange(StylusEventArgs e);
    public sealed virtual void add_StylusOutOfRange(StylusEventHandler value);
    public sealed virtual void remove_StylusOutOfRange(StylusEventHandler value);
    protected internal virtual void OnStylusOutOfRange(StylusEventArgs e);
    public sealed virtual void add_PreviewStylusSystemGesture(StylusSystemGestureEventHandler value);
    public sealed virtual void remove_PreviewStylusSystemGesture(StylusSystemGestureEventHandler value);
    protected internal virtual void OnPreviewStylusSystemGesture(StylusSystemGestureEventArgs e);
    public sealed virtual void add_StylusSystemGesture(StylusSystemGestureEventHandler value);
    public sealed virtual void remove_StylusSystemGesture(StylusSystemGestureEventHandler value);
    protected internal virtual void OnStylusSystemGesture(StylusSystemGestureEventArgs e);
    public sealed virtual void add_GotStylusCapture(StylusEventHandler value);
    public sealed virtual void remove_GotStylusCapture(StylusEventHandler value);
    protected internal virtual void OnGotStylusCapture(StylusEventArgs e);
    public sealed virtual void add_LostStylusCapture(StylusEventHandler value);
    public sealed virtual void remove_LostStylusCapture(StylusEventHandler value);
    protected internal virtual void OnLostStylusCapture(StylusEventArgs e);
    public sealed virtual void add_StylusButtonDown(StylusButtonEventHandler value);
    public sealed virtual void remove_StylusButtonDown(StylusButtonEventHandler value);
    protected internal virtual void OnStylusButtonDown(StylusButtonEventArgs e);
    public sealed virtual void add_StylusButtonUp(StylusButtonEventHandler value);
    public sealed virtual void remove_StylusButtonUp(StylusButtonEventHandler value);
    protected internal virtual void OnStylusButtonUp(StylusButtonEventArgs e);
    public sealed virtual void add_PreviewStylusButtonDown(StylusButtonEventHandler value);
    public sealed virtual void remove_PreviewStylusButtonDown(StylusButtonEventHandler value);
    protected internal virtual void OnPreviewStylusButtonDown(StylusButtonEventArgs e);
    public sealed virtual void add_PreviewStylusButtonUp(StylusButtonEventHandler value);
    public sealed virtual void remove_PreviewStylusButtonUp(StylusButtonEventHandler value);
    protected internal virtual void OnPreviewStylusButtonUp(StylusButtonEventArgs e);
    public sealed virtual void add_PreviewKeyDown(KeyEventHandler value);
    public sealed virtual void remove_PreviewKeyDown(KeyEventHandler value);
    protected internal virtual void OnPreviewKeyDown(KeyEventArgs e);
    public sealed virtual void add_KeyDown(KeyEventHandler value);
    public sealed virtual void remove_KeyDown(KeyEventHandler value);
    protected internal virtual void OnKeyDown(KeyEventArgs e);
    public sealed virtual void add_PreviewKeyUp(KeyEventHandler value);
    public sealed virtual void remove_PreviewKeyUp(KeyEventHandler value);
    protected internal virtual void OnPreviewKeyUp(KeyEventArgs e);
    public sealed virtual void add_KeyUp(KeyEventHandler value);
    public sealed virtual void remove_KeyUp(KeyEventHandler value);
    protected internal virtual void OnKeyUp(KeyEventArgs e);
    public sealed virtual void add_PreviewGotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    public sealed virtual void remove_PreviewGotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    protected internal virtual void OnPreviewGotKeyboardFocus(KeyboardFocusChangedEventArgs e);
    public sealed virtual void add_GotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    public sealed virtual void remove_GotKeyboardFocus(KeyboardFocusChangedEventHandler value);
    protected internal virtual void OnGotKeyboardFocus(KeyboardFocusChangedEventArgs e);
    public sealed virtual void add_PreviewLostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    public sealed virtual void remove_PreviewLostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    protected internal virtual void OnPreviewLostKeyboardFocus(KeyboardFocusChangedEventArgs e);
    public sealed virtual void add_LostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    public sealed virtual void remove_LostKeyboardFocus(KeyboardFocusChangedEventHandler value);
    protected internal virtual void OnLostKeyboardFocus(KeyboardFocusChangedEventArgs e);
    public sealed virtual void add_PreviewTextInput(TextCompositionEventHandler value);
    public sealed virtual void remove_PreviewTextInput(TextCompositionEventHandler value);
    protected internal virtual void OnPreviewTextInput(TextCompositionEventArgs e);
    public sealed virtual void add_TextInput(TextCompositionEventHandler value);
    public sealed virtual void remove_TextInput(TextCompositionEventHandler value);
    protected internal virtual void OnTextInput(TextCompositionEventArgs e);
    public void add_PreviewQueryContinueDrag(QueryContinueDragEventHandler value);
    public void remove_PreviewQueryContinueDrag(QueryContinueDragEventHandler value);
    protected internal virtual void OnPreviewQueryContinueDrag(QueryContinueDragEventArgs e);
    public void add_QueryContinueDrag(QueryContinueDragEventHandler value);
    public void remove_QueryContinueDrag(QueryContinueDragEventHandler value);
    protected internal virtual void OnQueryContinueDrag(QueryContinueDragEventArgs e);
    public void add_PreviewGiveFeedback(GiveFeedbackEventHandler value);
    public void remove_PreviewGiveFeedback(GiveFeedbackEventHandler value);
    protected internal virtual void OnPreviewGiveFeedback(GiveFeedbackEventArgs e);
    public void add_GiveFeedback(GiveFeedbackEventHandler value);
    public void remove_GiveFeedback(GiveFeedbackEventHandler value);
    protected internal virtual void OnGiveFeedback(GiveFeedbackEventArgs e);
    public void add_PreviewDragEnter(DragEventHandler value);
    public void remove_PreviewDragEnter(DragEventHandler value);
    protected internal virtual void OnPreviewDragEnter(DragEventArgs e);
    public void add_DragEnter(DragEventHandler value);
    public void remove_DragEnter(DragEventHandler value);
    protected internal virtual void OnDragEnter(DragEventArgs e);
    public void add_PreviewDragOver(DragEventHandler value);
    public void remove_PreviewDragOver(DragEventHandler value);
    protected internal virtual void OnPreviewDragOver(DragEventArgs e);
    public void add_DragOver(DragEventHandler value);
    public void remove_DragOver(DragEventHandler value);
    protected internal virtual void OnDragOver(DragEventArgs e);
    public void add_PreviewDragLeave(DragEventHandler value);
    public void remove_PreviewDragLeave(DragEventHandler value);
    protected internal virtual void OnPreviewDragLeave(DragEventArgs e);
    public void add_DragLeave(DragEventHandler value);
    public void remove_DragLeave(DragEventHandler value);
    protected internal virtual void OnDragLeave(DragEventArgs e);
    public void add_PreviewDrop(DragEventHandler value);
    public void remove_PreviewDrop(DragEventHandler value);
    protected internal virtual void OnPreviewDrop(DragEventArgs e);
    public void add_Drop(DragEventHandler value);
    public void remove_Drop(DragEventHandler value);
    protected internal virtual void OnDrop(DragEventArgs e);
    public void add_PreviewTouchDown(EventHandler`1<TouchEventArgs> value);
    public void remove_PreviewTouchDown(EventHandler`1<TouchEventArgs> value);
    protected internal virtual void OnPreviewTouchDown(TouchEventArgs e);
    public void add_TouchDown(EventHandler`1<TouchEventArgs> value);
    public void remove_TouchDown(EventHandler`1<TouchEventArgs> value);
    protected internal virtual void OnTouchDown(TouchEventArgs e);
    public void add_PreviewTouchMove(EventHandler`1<TouchEventArgs> value);
    public void remove_PreviewTouchMove(EventHandler`1<TouchEventArgs> value);
    protected internal virtual void OnPreviewTouchMove(TouchEventArgs e);
    public void add_TouchMove(EventHandler`1<TouchEventArgs> value);
    public void remove_TouchMove(EventHandler`1<TouchEventArgs> value);
    protected internal virtual void OnTouchMove(TouchEventArgs e);
    public void add_PreviewTouchUp(EventHandler`1<TouchEventArgs> value);
    public void remove_PreviewTouchUp(EventHandler`1<TouchEventArgs> value);
    protected internal virtual void OnPreviewTouchUp(TouchEventArgs e);
    public void add_TouchUp(EventHandler`1<TouchEventArgs> value);
    public void remove_TouchUp(EventHandler`1<TouchEventArgs> value);
    protected internal virtual void OnTouchUp(TouchEventArgs e);
    public void add_GotTouchCapture(EventHandler`1<TouchEventArgs> value);
    public void remove_GotTouchCapture(EventHandler`1<TouchEventArgs> value);
    protected internal virtual void OnGotTouchCapture(TouchEventArgs e);
    public void add_LostTouchCapture(EventHandler`1<TouchEventArgs> value);
    public void remove_LostTouchCapture(EventHandler`1<TouchEventArgs> value);
    protected internal virtual void OnLostTouchCapture(TouchEventArgs e);
    public void add_TouchEnter(EventHandler`1<TouchEventArgs> value);
    public void remove_TouchEnter(EventHandler`1<TouchEventArgs> value);
    protected internal virtual void OnTouchEnter(TouchEventArgs e);
    public void add_TouchLeave(EventHandler`1<TouchEventArgs> value);
    public void remove_TouchLeave(EventHandler`1<TouchEventArgs> value);
    protected internal virtual void OnTouchLeave(TouchEventArgs e);
    private static void IsMouseDirectlyOver_Changed(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public void add_IsMouseDirectlyOverChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsMouseDirectlyOverChanged(DependencyPropertyChangedEventHandler value);
    protected virtual void OnIsMouseDirectlyOverChanged(DependencyPropertyChangedEventArgs e);
    private void RaiseIsMouseDirectlyOverChanged(DependencyPropertyChangedEventArgs args);
    public void add_IsKeyboardFocusWithinChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsKeyboardFocusWithinChanged(DependencyPropertyChangedEventHandler value);
    protected virtual void OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs e);
    internal void RaiseIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs args);
    private static void IsMouseCaptured_Changed(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public void add_IsMouseCapturedChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsMouseCapturedChanged(DependencyPropertyChangedEventHandler value);
    protected virtual void OnIsMouseCapturedChanged(DependencyPropertyChangedEventArgs e);
    private void RaiseIsMouseCapturedChanged(DependencyPropertyChangedEventArgs args);
    public void add_IsMouseCaptureWithinChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsMouseCaptureWithinChanged(DependencyPropertyChangedEventHandler value);
    protected virtual void OnIsMouseCaptureWithinChanged(DependencyPropertyChangedEventArgs e);
    internal void RaiseIsMouseCaptureWithinChanged(DependencyPropertyChangedEventArgs args);
    private static void IsStylusDirectlyOver_Changed(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public void add_IsStylusDirectlyOverChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsStylusDirectlyOverChanged(DependencyPropertyChangedEventHandler value);
    protected virtual void OnIsStylusDirectlyOverChanged(DependencyPropertyChangedEventArgs e);
    private void RaiseIsStylusDirectlyOverChanged(DependencyPropertyChangedEventArgs args);
    private static void IsStylusCaptured_Changed(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public void add_IsStylusCapturedChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsStylusCapturedChanged(DependencyPropertyChangedEventHandler value);
    protected virtual void OnIsStylusCapturedChanged(DependencyPropertyChangedEventArgs e);
    private void RaiseIsStylusCapturedChanged(DependencyPropertyChangedEventArgs args);
    public void add_IsStylusCaptureWithinChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsStylusCaptureWithinChanged(DependencyPropertyChangedEventHandler value);
    protected virtual void OnIsStylusCaptureWithinChanged(DependencyPropertyChangedEventArgs e);
    internal void RaiseIsStylusCaptureWithinChanged(DependencyPropertyChangedEventArgs args);
    private static void IsKeyboardFocused_Changed(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public void add_IsKeyboardFocusedChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsKeyboardFocusedChanged(DependencyPropertyChangedEventHandler value);
    protected virtual void OnIsKeyboardFocusedChanged(DependencyPropertyChangedEventArgs e);
    private void RaiseIsKeyboardFocusedChanged(DependencyPropertyChangedEventArgs args);
    internal bool ReadFlag(CoreFlags field);
    internal void WriteFlag(CoreFlags field, bool value);
    private void Initialize();
    public bool get_AllowDrop();
    public void set_AllowDrop(bool value);
    private object CallRenderCallback(object o);
    public void InvalidateModel();
    protected virtual void OnUpdateModel();
    protected internal virtual void OnVisualParentChanged(DependencyObject oldParent);
    private void OnVisualAncestorChanged_ForceInherit(object sender, AncestorChangedEventArgs e);
    internal void OnVisualAncestorChanged(object sender, AncestorChangedEventArgs e);
    internal DependencyObject GetUIParent(bool continuePastVisualTree);
    protected internal DependencyObject GetUIParentCore();
    internal virtual void OnPresentationSourceChanged(bool attached);
    public sealed virtual bool get_IsMouseDirectlyOver();
    private bool IsMouseDirectlyOver_ComputeValue();
    [FriendAccessAllowedAttribute]
internal void SynchronizeReverseInheritPropertyFlags(DependencyObject oldParent, bool isCoreParent);
    internal virtual bool BlockReverseInheritance();
    public sealed virtual bool get_IsMouseOver();
    public sealed virtual bool get_IsStylusOver();
    public sealed virtual bool get_IsKeyboardFocusWithin();
    public sealed virtual bool get_IsMouseCaptured();
    public sealed virtual bool CaptureMouse();
    public sealed virtual void ReleaseMouseCapture();
    public bool get_IsMouseCaptureWithin();
    public sealed virtual bool get_IsStylusDirectlyOver();
    private bool IsStylusDirectlyOver_ComputeValue();
    public sealed virtual bool get_IsStylusCaptured();
    public sealed virtual bool CaptureStylus();
    public sealed virtual void ReleaseStylusCapture();
    public bool get_IsStylusCaptureWithin();
    public sealed virtual bool get_IsKeyboardFocused();
    private bool IsKeyboardFocused_ComputeValue();
    public sealed virtual bool Focus();
    public virtual bool MoveFocus(TraversalRequest request);
    public virtual DependencyObject PredictFocus(FocusNavigationDirection direction);
    protected virtual void OnAccessKey(AccessKeyEventArgs e);
    public bool get_IsInputMethodEnabled();
    private static void OnVisibilityChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static bool ValidateVisibility(object o);
    public Visibility get_Visibility();
    public void set_Visibility(Visibility value);
    private void switchVisibilityIfNeeded(Visibility visibility);
    private void ensureVisible();
    private void ensureInvisible(bool collapsed);
    internal void InvokeAccessKey(AccessKeyEventArgs e);
    public void add_GotFocus(RoutedEventHandler value);
    public void remove_GotFocus(RoutedEventHandler value);
    public void add_LostFocus(RoutedEventHandler value);
    public void remove_LostFocus(RoutedEventHandler value);
    private static void IsFocused_Changed(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnGotFocus(RoutedEventArgs e);
    protected virtual void OnLostFocus(RoutedEventArgs e);
    public bool get_IsFocused();
    public sealed virtual bool get_IsEnabled();
    public void set_IsEnabled(bool value);
    public void add_IsEnabledChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsEnabledChanged(DependencyPropertyChangedEventHandler value);
    protected virtual bool get_IsEnabledCore();
    private static object CoerceIsEnabled(DependencyObject d, object value);
    private static void OnIsEnabledChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public bool get_IsHitTestVisible();
    public void set_IsHitTestVisible(bool value);
    public void add_IsHitTestVisibleChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsHitTestVisibleChanged(DependencyPropertyChangedEventHandler value);
    private static object CoerceIsHitTestVisible(DependencyObject d, object value);
    private static void OnIsHitTestVisibleChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public bool get_IsVisible();
    private static object GetIsVisible(DependencyObject d, BaseValueSourceInternal& source);
    public void add_IsVisibleChanged(DependencyPropertyChangedEventHandler value);
    public void remove_IsVisibleChanged(DependencyPropertyChangedEventHandler value);
    internal void UpdateIsVisibleCache();
    private static void OnIsVisibleChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public sealed virtual bool get_Focusable();
    public sealed virtual void set_Focusable(bool value);
    public void add_FocusableChanged(DependencyPropertyChangedEventHandler value);
    public void remove_FocusableChanged(DependencyPropertyChangedEventHandler value);
    private static void OnFocusableChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    internal AutomationPeer CreateAutomationPeer();
    internal AutomationPeer GetAutomationPeer();
    internal void AddSynchronizedInputPreOpportunityHandler(EventRoute route, RoutedEventArgs args);
    internal void AddSynchronizedInputPostOpportunityHandler(EventRoute route, RoutedEventArgs args);
    internal void SynchronizedInputPreOpportunityHandler(object sender, RoutedEventArgs args);
    internal void SynchronizedInputPostOpportunityHandler(object sender, RoutedEventArgs args);
    internal bool StartListeningSynchronizedInput(SynchronizedInputType inputType);
    internal void CancelSynchronizedInput();
    private void RaiseDependencyPropertyChanged(EventPrivateKey key, DependencyPropertyChangedEventArgs args);
    private Visibility get_VisibilityCache();
    private void set_VisibilityCache(Visibility value);
    internal static void InvalidateForceInheritPropertyOnChildren(Visual3D v, DependencyProperty property);
    public bool get_AreAnyTouchesOver();
    public bool get_AreAnyTouchesDirectlyOver();
    public bool get_AreAnyTouchesCapturedWithin();
    public bool get_AreAnyTouchesCaptured();
    public bool CaptureTouch(TouchDevice touchDevice);
    public bool ReleaseTouchCapture(TouchDevice touchDevice);
    public void ReleaseAllTouchCaptures();
    public IEnumerable`1<TouchDevice> get_TouchesCaptured();
    public IEnumerable`1<TouchDevice> get_TouchesCapturedWithin();
    public IEnumerable`1<TouchDevice> get_TouchesOver();
    public IEnumerable`1<TouchDevice> get_TouchesDirectlyOver();
    internal bool get_HasAutomationPeer();
    internal void set_HasAutomationPeer(bool value);
}
public class System.Windows.UIPropertyMetadata : PropertyMetadata {
    public bool IsAnimationProhibited { get; public set; }
    public UIPropertyMetadata(object defaultValue);
    public UIPropertyMetadata(PropertyChangedCallback propertyChangedCallback);
    public UIPropertyMetadata(object defaultValue, PropertyChangedCallback propertyChangedCallback);
    public UIPropertyMetadata(object defaultValue, PropertyChangedCallback propertyChangedCallback, CoerceValueCallback coerceValueCallback);
    public UIPropertyMetadata(object defaultValue, PropertyChangedCallback propertyChangedCallback, CoerceValueCallback coerceValueCallback, bool isAnimationProhibited);
    internal virtual PropertyMetadata CreateInstance();
    public bool get_IsAnimationProhibited();
    public void set_IsAnimationProhibited(bool value);
}
internal static class System.Windows.ValidateEnums : object {
    public static bool IsTextDecorationLocationValid(object valueObject);
    public static bool IsTextDecorationUnitValid(object valueObject);
}
public enum System.Windows.Visibility : Enum {
    public byte value__;
    public static Visibility Visible;
    public static Visibility Hidden;
    public static Visibility Collapsed;
}
